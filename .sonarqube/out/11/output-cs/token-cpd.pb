ú
ïD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\KdTree\KdTreeLib\IKdTree.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
KdTree! '
{ 
	interface 

IKdTree 
< 
TKey 
, 
TValue 
>  
:! "
IEnumerable# .
<. /

KdTreeNode/ 9
<9 :
TKey: >
,> ?
TValue@ F
>F G
>G H
{ 
bool 
Add 

(
 
TKey 
[ 
] 
point 
, 
TValue 
value  %
)% &
;& '
bool		 
TryFindValueAt		 
(		 
TKey		 
[		 
]		 
point		 "
,		" #
out		$ '
TValue		( .
value		/ 4
)		4 5
;		5 6
TValue 
FindValueAt	 
( 
TKey 
[ 
] 
point !
)! "
;" #
bool 
TryFindValue 
( 
TValue 
value  
,  !
out" %
TKey& *
[* +
]+ ,
point- 2
)2 3
;3 4
TKey 
[ 
] 
	FindValue	 
( 
TValue 
value 
)  
;  !

KdTreeNode 
< 
TKey 
, 
TValue 
> 
[ 
] 
RadialSearch )
() *
TKey* .
[. /
]/ 0
center1 7
,7 8
TKey9 =
radius> D
,D E
intF I
countJ O
)O P
;P Q
void 
RemoveAt 
( 
TKey 
[ 
] 
point 
) 
; 
void 
Clear 
( 
) 
; 

KdTreeNode 
< 
TKey 
, 
TValue 
> 
[ 
]  
GetNearestNeighbours 1
(1 2
TKey2 6
[6 7
]7 8
point9 >
,> ?
int@ C
countD I
=J K
intL O
.O P
MaxValueP X
)X Y
;Y Z
int 
Count 
{ 
get 
; 
} 
} 
} “ó
îD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\KdTree\KdTreeLib\KdTree.cs
	namespace		 	
UnityEngine		
 
.		 

ProBuilder		  
.		  !
KdTree		! '
{

 
enum  
AddDuplicateBehavior 
{ 
Skip 
, 
Error 
, 
Update 
, 	
Collect 	
} 
class 
DuplicateNodeError 
: 
	Exception %
{ 
public 
DuplicateNodeError	 
( 
) 
: 
base 	
(	 

$str
 6
)6 7
{ 
} 
} 
[ 
Serializable 
] 
class 
KdTree 
< 
TKey 
, 
TValue 
> 
: 
IKdTree %
<% &
TKey& *
,* +
TValue, 2
>2 3
{ 
public 
KdTree	 
( 
int 

dimensions 
, 
	ITypeMath  )
<) *
TKey* .
>. /
typeMath0 8
)8 9
{ 
this   
.   

dimensions   
=   

dimensions   
;    
this!! 
.!! 
typeMath!! 
=!! 
typeMath!! 
;!! 
Count"" 
=""	 

$num"" 
;"" 
}## 
public%% 
KdTree%%	 
(%% 
int%% 

dimensions%% 
,%% 
	ITypeMath%%  )
<%%) *
TKey%%* .
>%%. /
typeMath%%0 8
,%%8 9 
AddDuplicateBehavior%%: N 
addDuplicateBehavior%%O c
)%%c d
:&& 
this&& 	
(&&	 


dimensions&&
 
,&& 
typeMath&& 
)&& 
{''  
AddDuplicateBehavior(( 
=((  
addDuplicateBehavior(( .
;((. /
})) 
private++ 	
int++
 

dimensions++ 
;++ 
private-- 	
	ITypeMath--
 
<-- 
TKey-- 
>-- 
typeMath-- "
=--# $
null--% )
;--) *
private// 	

KdTreeNode//
 
<// 
TKey// 
,// 
TValue// !
>//! "
root//# '
=//( )
null//* .
;//. /
public11  
AddDuplicateBehavior11	  
AddDuplicateBehavior11 2
{113 4
get115 8
;118 9
private11: A
set11B E
;11E F
}11G H
public33 
bool33	 
Add33 
(33 
TKey33 
[33 
]33 
point33 
,33 
TValue33  &
value33' ,
)33, -
{44 
var55 
	nodeToAdd55 
=55 
new55 

KdTreeNode55 !
<55! "
TKey55" &
,55& '
TValue55( .
>55. /
(55/ 0
point550 5
,555 6
value557 <
)55< =
;55= >
if77 
(77 
root77 
==77 
null77 
)77 
{88 
root99 
=99	 

new99 

KdTreeNode99 
<99 
TKey99 
,99 
TValue99  &
>99& '
(99' (
point99( -
,99- .
value99/ 4
)994 5
;995 6
}:: 
else;; 
{<< 
int== 
	dimension== 
=== 
-== 
$num== 
;== 

KdTreeNode>> 
<>> 
TKey>> 
,>> 
TValue>> 
>>> 
parent>> #
=>>$ %
root>>& *
;>>* +
do@@ 
{AA 
	dimensionCC 
=CC 
(CC 
	dimensionCC 
+CC 
$numCC 
)CC  
%CC! "

dimensionsCC# -
;CC- .
ifFF 
(FF 	
typeMathFF	 
.FF 
AreEqualFF 
(FF 
pointFF  
,FF  !
parentFF" (
.FF( )
PointFF) .
)FF. /
)FF/ 0
{GG 
switchHH 
(HH  
AddDuplicateBehaviorHH "
)HH" #
{II 
caseJJ  
AddDuplicateBehaviorJJ  
.JJ  !
SkipJJ! %
:JJ% &
returnKK 
falseKK 
;KK 
caseMM  
AddDuplicateBehaviorMM  
.MM  !
ErrorMM! &
:MM& '
throwNN 
newNN 
DuplicateNodeErrorNN $
(NN$ %
)NN% &
;NN& '
casePP  
AddDuplicateBehaviorPP  
.PP  !
UpdatePP! '
:PP' (
parentQQ 
.QQ 
ValueQQ 
=QQ 
valueQQ 
;QQ 
breakRR 
;RR 
caseTT  
AddDuplicateBehaviorTT  
.TT  !
CollectTT! (
:TT( )
parentUU 
.UU 
AddDuplicateUU 
(UU 
valueUU !
)UU! "
;UU" #
returnVV 
falseVV 
;VV 
defaultXX 
:XX 
throwZZ 
newZZ 
	ExceptionZZ 
(ZZ 
$strZZ =
)ZZ= >
;ZZ> ?
}[[ 
}\\ 
int__ 
compare__	 
=__ 
typeMath__ 
.__ 
Compare__ #
(__# $
point__$ )
[__) *
	dimension__* 3
]__3 4
,__4 5
parent__6 <
.__< =
Point__= B
[__B C
	dimension__C L
]__L M
)__M N
;__N O
ifaa 
(aa 	
parentaa	 
[aa 
compareaa 
]aa 
==aa 
nullaa  
)aa  !
{bb 
parentcc 
[cc 
comparecc 
]cc 
=cc 
	nodeToAddcc !
;cc! "
breakdd 
;dd 
}ee 
elseff 	
{gg 
parenthh 
=hh 
parenthh 
[hh 
comparehh 
]hh 
;hh 
}ii 
}jj 
whilekk 	
(kk
 
truekk 
)kk 
;kk 
}ll 
Countnn 
++nn 

;nn
 
returnoo 	
trueoo
 
;oo 
}pp 
privaterr 	
voidrr
 
ReadChildNodesrr 
(rr 

KdTreeNoderr (
<rr( )
TKeyrr) -
,rr- .
TValuerr/ 5
>rr5 6
removedNoderr7 B
)rrB C
{ss 
iftt 
(tt 
removedNodett 
.tt 
IsLeaftt 
)tt 
returnuu 

;uu
 
varzz 
nodesToReaddzz 
=zz 
newzz 
Queuezz 
<zz  

KdTreeNodezz  *
<zz* +
TKeyzz+ /
,zz/ 0
TValuezz1 7
>zz7 8
>zz8 9
(zz9 :
)zz: ;
;zz; <
var|| 
nodesToReaddQueue|| 
=|| 
new|| 
Queue|| $
<||$ %

KdTreeNode||% /
<||/ 0
TKey||0 4
,||4 5
TValue||6 <
>||< =
>||= >
(||> ?
)||? @
;||@ A
if~~ 
(~~ 
removedNode~~ 
.~~ 
	LeftChild~~ 
!=~~ 
null~~  $
)~~$ %
nodesToReaddQueue 
. 
Enqueue 
( 
removedNode )
.) *
	LeftChild* 3
)3 4
;4 5
if
ÅÅ 
(
ÅÅ 
removedNode
ÅÅ 
.
ÅÅ 

RightChild
ÅÅ 
!=
ÅÅ  
null
ÅÅ! %
)
ÅÅ% &
nodesToReaddQueue
ÇÇ 
.
ÇÇ 
Enqueue
ÇÇ 
(
ÇÇ 
removedNode
ÇÇ )
.
ÇÇ) *

RightChild
ÇÇ* 4
)
ÇÇ4 5
;
ÇÇ5 6
while
ÑÑ 
(
ÑÑ	 

nodesToReaddQueue
ÑÑ
 
.
ÑÑ 
Count
ÑÑ !
>
ÑÑ" #
$num
ÑÑ$ %
)
ÑÑ% &
{
ÖÖ 
var
ÜÜ 
nodeToReadd
ÜÜ 
=
ÜÜ 
nodesToReaddQueue
ÜÜ '
.
ÜÜ' (
Dequeue
ÜÜ( /
(
ÜÜ/ 0
)
ÜÜ0 1
;
ÜÜ1 2
nodesToReadd
àà 
.
àà 
Enqueue
àà 
(
àà 
nodeToReadd
àà $
)
àà$ %
;
àà% &
for
ää 
(
ää 	
int
ää	 
side
ää 
=
ää 
-
ää 
$num
ää 
;
ää 
side
ää 
<=
ää 
$num
ää  !
;
ää! "
side
ää# '
+=
ää( *
$num
ää+ ,
)
ää, -
{
ãã 
if
åå 
(
åå 	
nodeToReadd
åå	 
[
åå 
side
åå 
]
åå 
!=
åå 
null
åå "
)
åå" #
{
çç 
nodesToReaddQueue
éé 
.
éé 
Enqueue
éé 
(
éé  
nodeToReadd
éé  +
[
éé+ ,
side
éé, 0
]
éé0 1
)
éé1 2
;
éé2 3
nodeToReadd
êê 
[
êê 
side
êê 
]
êê 
=
êê 
null
êê 
;
êê 
}
ëë 
}
íí 
}
ìì 
while
ïï 
(
ïï	 

nodesToReadd
ïï
 
.
ïï 
Count
ïï 
>
ïï 
$num
ïï  
)
ïï  !
{
ññ 
var
óó 
nodeToReadd
óó 
=
óó 
nodesToReadd
óó "
.
óó" #
Dequeue
óó# *
(
óó* +
)
óó+ ,
;
óó, -
Count
ôô 	
--
ôô	 
;
ôô 
Add
öö 
(
öö 
nodeToReadd
öö 
.
öö 
Point
öö 
,
öö 
nodeToReadd
öö &
.
öö& '
Value
öö' ,
)
öö, -
;
öö- .
}
õõ 
}
úú 
public
ûû 
void
ûû	 
RemoveAt
ûû 
(
ûû 
TKey
ûû 
[
ûû 
]
ûû 
point
ûû #
)
ûû# $
{
üü 
if
°° 
(
°° 
root
°° 
==
°° 
null
°° 
)
°° 
return
¢¢ 

;
¢¢
 

KdTreeNode
§§ 
<
§§ 
TKey
§§ 
,
§§ 
TValue
§§ 
>
§§ 
node
§§  
;
§§  !
if
¶¶ 
(
¶¶ 
typeMath
¶¶ 
.
¶¶ 
AreEqual
¶¶ 
(
¶¶ 
point
¶¶ 
,
¶¶ 
root
¶¶  $
.
¶¶$ %
Point
¶¶% *
)
¶¶* +
)
¶¶+ ,
{
ßß 
node
®® 
=
®®	 

root
®® 
;
®® 
root
©© 
=
©©	 

null
©© 
;
©© 
Count
™™ 	
--
™™	 
;
™™ 
ReadChildNodes
´´ 
(
´´ 
node
´´ 
)
´´ 
;
´´ 
return
¨¨ 

;
¨¨
 
}
≠≠ 
node
ØØ 
=
ØØ 	
root
ØØ
 
;
ØØ 
int
±± 
	dimension
±± 
=
±± 
-
±± 
$num
±± 
;
±± 
do
≤≤ 
{
≥≥ 
	dimension
¥¥ 
=
¥¥ 
(
¥¥ 
	dimension
¥¥ 
+
¥¥ 
$num
¥¥ 
)
¥¥ 
%
¥¥  !

dimensions
¥¥" ,
;
¥¥, -
int
∂∂ 
compare
∂∂ 
=
∂∂ 
typeMath
∂∂ 
.
∂∂ 
Compare
∂∂ "
(
∂∂" #
point
∂∂# (
[
∂∂( )
	dimension
∂∂) 2
]
∂∂2 3
,
∂∂3 4
node
∂∂5 9
.
∂∂9 :
Point
∂∂: ?
[
∂∂? @
	dimension
∂∂@ I
]
∂∂I J
)
∂∂J K
;
∂∂K L
if
∏∏ 
(
∏∏ 
node
∏∏ 
[
∏∏ 
compare
∏∏ 
]
∏∏ 
==
∏∏ 
null
∏∏ 
)
∏∏ 
return
∫∫ 
;
∫∫ 
if
ºº 
(
ºº 
typeMath
ºº 
.
ºº 
AreEqual
ºº 
(
ºº 
point
ºº 
,
ºº  
node
ºº! %
[
ºº% &
compare
ºº& -
]
ºº- .
.
ºº. /
Point
ºº/ 4
)
ºº4 5
)
ºº5 6
{
ΩΩ 
var
ææ 
nodeToRemove
ææ	 
=
ææ 
node
ææ 
[
ææ 
compare
ææ $
]
ææ$ %
;
ææ% &
node
øø 	
[
øø	 

compare
øø
 
]
øø 
=
øø 
null
øø 
;
øø 
Count
¿¿ 

--
¿¿
 
;
¿¿ 
ReadChildNodes
¬¬ 
(
¬¬ 
nodeToRemove
¬¬  
)
¬¬  !
;
¬¬! "
}
√√ 
else
ƒƒ 
node
≈≈ 	
=
≈≈
 
node
≈≈ 
[
≈≈ 
compare
≈≈ 
]
≈≈ 
;
≈≈ 
}
∆∆ 
while
«« 
(
««	 

node
««
 
!=
«« 
null
«« 
)
«« 
;
«« 
}
»» 
public
   

KdTreeNode
  	 
<
   
TKey
   
,
   
TValue
    
>
    !
[
  ! "
]
  " #"
GetNearestNeighbours
  $ 8
(
  8 9
TKey
  9 =
[
  = >
]
  > ?
point
  @ E
,
  E F
int
  G J
count
  K P
)
  P Q
{
ÀÀ 
if
ÃÃ 
(
ÃÃ 
count
ÃÃ 
>
ÃÃ 
Count
ÃÃ 
)
ÃÃ 
count
ÕÕ 	
=
ÕÕ
 
Count
ÕÕ 
;
ÕÕ 
if
œœ 
(
œœ 
count
œœ 
<
œœ 
$num
œœ 
)
œœ 
{
–– 
throw
—— 	
new
——
 
ArgumentException
—— 
(
——  
$str
——  H
)
——H I
;
——I J
}
““ 
if
‘‘ 
(
‘‘ 
count
‘‘ 
==
‘‘ 
$num
‘‘ 
)
‘‘ 
return
’’ 

new
’’ 

KdTreeNode
’’ 
<
’’ 
TKey
’’ 
,
’’ 
TValue
’’  &
>
’’& '
[
’’' (
$num
’’( )
]
’’) *
;
’’* +
var
◊◊ 
nearestNeighbours
◊◊ 
=
◊◊ 
new
◊◊ "
NearestNeighbourList
◊◊ 3
<
◊◊3 4

KdTreeNode
◊◊4 >
<
◊◊> ?
TKey
◊◊? C
,
◊◊C D
TValue
◊◊E K
>
◊◊K L
,
◊◊L M
TKey
◊◊N R
>
◊◊R S
(
◊◊S T
count
◊◊T Y
,
◊◊Y Z
typeMath
◊◊[ c
)
◊◊c d
;
◊◊d e
var
ŸŸ 
rect
ŸŸ 
=
ŸŸ 
	HyperRect
ŸŸ 
<
ŸŸ 
TKey
ŸŸ 
>
ŸŸ 
.
ŸŸ 
Infinite
ŸŸ &
(
ŸŸ& '

dimensions
ŸŸ' 1
,
ŸŸ1 2
typeMath
ŸŸ3 ;
)
ŸŸ; <
;
ŸŸ< ="
AddNearestNeighbours
€€ 
(
€€ 
root
€€ 
,
€€ 
point
€€ #
,
€€# $
rect
€€% )
,
€€) *
$num
€€+ ,
,
€€, -
nearestNeighbours
€€. ?
,
€€? @
typeMath
€€A I
.
€€I J
MaxValue
€€J R
)
€€R S
;
€€S T
count
›› 
=
››	 

nearestNeighbours
›› 
.
›› 
Count
›› "
;
››" #
var
ﬂﬂ 
neighbourArray
ﬂﬂ 
=
ﬂﬂ 
new
ﬂﬂ 

KdTreeNode
ﬂﬂ &
<
ﬂﬂ& '
TKey
ﬂﬂ' +
,
ﬂﬂ+ ,
TValue
ﬂﬂ- 3
>
ﬂﬂ3 4
[
ﬂﬂ4 5
count
ﬂﬂ5 :
]
ﬂﬂ: ;
;
ﬂﬂ; <
for
·· 
(
·· 
var
·· 
index
·· 
=
·· 
$num
·· 
;
·· 
index
·· 
<
·· 
count
·· $
;
··$ %
index
··& +
++
··+ -
)
··- .
neighbourArray
‚‚ 
[
‚‚ 
count
‚‚ 
-
‚‚ 
index
‚‚  
-
‚‚! "
$num
‚‚# $
]
‚‚$ %
=
‚‚& '
nearestNeighbours
‚‚( 9
.
‚‚9 :
RemoveFurtherest
‚‚: J
(
‚‚J K
)
‚‚K L
;
‚‚L M
return
‰‰ 	
neighbourArray
‰‰
 
;
‰‰ 
}
ÂÂ 
private
åå 	
void
åå
 "
AddNearestNeighbours
åå #
(
åå# $

KdTreeNode
çç 
<
çç 
TKey
çç 
,
çç 
TValue
çç 
>
çç 
node
çç  
,
çç  !
TKey
éé 
[
éé 
]
éé 	
target
éé
 
,
éé 
	HyperRect
èè 
<
èè 
TKey
èè 
>
èè 
rect
èè 
,
èè 
int
êê 
depth
êê 
,
êê "
NearestNeighbourList
ëë 
<
ëë 

KdTreeNode
ëë "
<
ëë" #
TKey
ëë# '
,
ëë' (
TValue
ëë) /
>
ëë/ 0
,
ëë0 1
TKey
ëë2 6
>
ëë6 7
nearestNeighbours
ëë8 I
,
ëëI J
TKey
íí $
maxSearchRadiusSquared
íí 
)
íí 
{
ìì 
if
îî 
(
îî 
node
îî 
==
îî 
null
îî 
)
îî 
return
ïï 

;
ïï
 
int
òò 
	dimension
òò 
=
òò 
depth
òò 
%
òò 

dimensions
òò %
;
òò% &
var
úú 
leftRect
úú 
=
úú 
rect
úú 
.
úú 
Clone
úú 
(
úú 
)
úú 
;
úú 
leftRect
ùù 
.
ùù 
MaxPoint
ùù 
[
ùù 
	dimension
ùù 
]
ùù 
=
ùù  !
node
ùù" &
.
ùù& '
Point
ùù' ,
[
ùù, -
	dimension
ùù- 6
]
ùù6 7
;
ùù7 8
var
üü 
	rightRect
üü 
=
üü 
rect
üü 
.
üü 
Clone
üü 
(
üü 
)
üü 
;
üü  
	rightRect
†† 
.
†† 
MinPoint
†† 
[
†† 
	dimension
†† 
]
††  
=
††! "
node
††# '
.
††' (
Point
††( -
[
††- .
	dimension
††. 7
]
††7 8
;
††8 9
int
££ 
compare
££ 
=
££ 
typeMath
££ 
.
££ 
Compare
££ !
(
££! "
target
££" (
[
££( )
	dimension
££) 2
]
££2 3
,
££3 4
node
££5 9
.
££9 :
Point
££: ?
[
££? @
	dimension
££@ I
]
££I J
)
££J K
;
££K L
var
•• 

nearerRect
•• 
=
•• 
compare
•• 
<=
•• 
$num
••  
?
••! "
leftRect
••# +
:
••, -
	rightRect
••. 7
;
••7 8
var
¶¶ 
furtherRect
¶¶ 
=
¶¶ 
compare
¶¶ 
<=
¶¶ 
$num
¶¶  !
?
¶¶" #
	rightRect
¶¶$ -
:
¶¶. /
leftRect
¶¶0 8
;
¶¶8 9
var
®® 

nearerNode
®® 
=
®® 
compare
®® 
<=
®® 
$num
®®  
?
®®! "
node
®®# '
.
®®' (
	LeftChild
®®( 1
:
®®2 3
node
®®4 8
.
®®8 9

RightChild
®®9 C
;
®®C D
var
©© 
furtherNode
©© 
=
©© 
compare
©© 
<=
©© 
$num
©©  !
?
©©" #
node
©©$ (
.
©©( )

RightChild
©©) 3
:
©©4 5
node
©©6 :
.
©©: ;
	LeftChild
©©; D
;
©©D E
if
¨¨ 
(
¨¨ 

nearerNode
¨¨ 
!=
¨¨ 
null
¨¨ 
)
¨¨ 
{
≠≠ "
AddNearestNeighbours
ÆÆ 
(
ÆÆ 

nearerNode
ØØ 
,
ØØ 
target
∞∞ 
,
∞∞ 

nearerRect
±± 
,
±± 
depth
≤≤ 

+
≤≤ 
$num
≤≤ 
,
≤≤ 
nearestNeighbours
≥≥ 
,
≥≥ $
maxSearchRadiusSquared
¥¥ 
)
¥¥ 
;
¥¥ 
}
µµ 
TKey
∑∑ %
distanceSquaredToTarget
∑∑ 
;
∑∑  
TKey
ºº 
[
ºº 
]
ºº 	'
closestPointInFurtherRect
ºº
 #
=
ºº$ %
furtherRect
ºº& 1
.
ºº1 2
GetClosestPoint
ºº2 A
(
ººA B
target
ººB H
,
ººH I
typeMath
ººJ R
)
ººR S
;
ººS T%
distanceSquaredToTarget
ΩΩ 
=
ΩΩ 
typeMath
ΩΩ %
.
ΩΩ% &*
DistanceSquaredBetweenPoints
ΩΩ& B
(
ΩΩB C'
closestPointInFurtherRect
ΩΩC \
,
ΩΩ\ ]
target
ΩΩ^ d
)
ΩΩd e
;
ΩΩe f
if
øø 
(
øø 
typeMath
øø 
.
øø 
Compare
øø 
(
øø %
distanceSquaredToTarget
øø /
,
øø/ 0$
maxSearchRadiusSquared
øø1 G
)
øøG H
<=
øøI K
$num
øøL M
)
øøM N
{
¿¿ 
if
¡¡ 
(
¡¡ 
nearestNeighbours
¡¡ 
.
¡¡ 
IsCapacityReached
¡¡ +
)
¡¡+ ,
{
¬¬ 
if
√√ 
(
√√ 	
typeMath
√√	 
.
√√ 
Compare
√√ 
(
√√ %
distanceSquaredToTarget
√√ 1
,
√√1 2
nearestNeighbours
√√3 D
.
√√D E#
GetFurtherestDistance
√√E Z
(
√√Z [
)
√√[ \
)
√√\ ]
<
√√^ _
$num
√√` a
)
√√a b"
AddNearestNeighbours
ƒƒ 
(
ƒƒ 
furtherNode
≈≈ 
,
≈≈ 
target
∆∆ 
,
∆∆ 
furtherRect
«« 
,
«« 
depth
»» 
+
»» 
$num
»» 
,
»» 
nearestNeighbours
…… 
,
…… $
maxSearchRadiusSquared
   
)
   
;
   
}
ÀÀ 
else
ÃÃ 
{
ÕÕ "
AddNearestNeighbours
ŒŒ 
(
ŒŒ 
furtherNode
œœ 
,
œœ 
target
–– 
,
–– 
furtherRect
—— 
,
—— 
depth
““ 
+
““ 
$num
““ 
,
““ 
nearestNeighbours
”” 
,
”” $
maxSearchRadiusSquared
‘‘ 
)
‘‘ 
;
‘‘ 
}
’’ 
}
÷÷ %
distanceSquaredToTarget
ŸŸ 
=
ŸŸ 
typeMath
ŸŸ %
.
ŸŸ% &*
DistanceSquaredBetweenPoints
ŸŸ& B
(
ŸŸB C
node
ŸŸC G
.
ŸŸG H
Point
ŸŸH M
,
ŸŸM N
target
ŸŸO U
)
ŸŸU V
;
ŸŸV W
if
€€ 
(
€€ 
typeMath
€€ 
.
€€ 
Compare
€€ 
(
€€ %
distanceSquaredToTarget
€€ /
,
€€/ 0$
maxSearchRadiusSquared
€€1 G
)
€€G H
<=
€€I K
$num
€€L M
)
€€M N
nearestNeighbours
‹‹ 
.
‹‹ 
Add
‹‹ 
(
‹‹ 
node
‹‹ 
,
‹‹ %
distanceSquaredToTarget
‹‹  7
)
‹‹7 8
;
‹‹8 9
}
›› 
public
ﬂﬂ 

KdTreeNode
ﬂﬂ	 
<
ﬂﬂ 
TKey
ﬂﬂ 
,
ﬂﬂ 
TValue
ﬂﬂ  
>
ﬂﬂ  !
[
ﬂﬂ! "
]
ﬂﬂ" #
RadialSearch
ﬂﬂ$ 0
(
ﬂﬂ0 1
TKey
ﬂﬂ1 5
[
ﬂﬂ5 6
]
ﬂﬂ6 7
center
ﬂﬂ8 >
,
ﬂﬂ> ?
TKey
ﬂﬂ@ D
radius
ﬂﬂE K
,
ﬂﬂK L
int
ﬂﬂM P
count
ﬂﬂQ V
)
ﬂﬂV W
{
‡‡ 
var
·· 
nearestNeighbours
·· 
=
·· 
new
·· "
NearestNeighbourList
·· 3
<
··3 4

KdTreeNode
··4 >
<
··> ?
TKey
··? C
,
··C D
TValue
··E K
>
··K L
,
··L M
TKey
··N R
>
··R S
(
··S T
count
··T Y
,
··Y Z
typeMath
··[ c
)
··c d
;
··d e"
AddNearestNeighbours
„„ 
(
„„ 
root
‰‰ 
,
‰‰ 	
center
ÂÂ 

,
ÂÂ
 
	HyperRect
ÊÊ 
<
ÊÊ 
TKey
ÊÊ 
>
ÊÊ 
.
ÊÊ 
Infinite
ÊÊ 
(
ÊÊ 

dimensions
ÊÊ '
,
ÊÊ' (
typeMath
ÊÊ) 1
)
ÊÊ1 2
,
ÊÊ2 3
$num
ÁÁ 
,
ÁÁ 
nearestNeighbours
ËË 
,
ËË 
typeMath
ÈÈ 
.
ÈÈ 
Multiply
ÈÈ 
(
ÈÈ 
radius
ÈÈ 
,
ÈÈ 
radius
ÈÈ $
)
ÈÈ$ %
)
ÈÈ% &
;
ÈÈ& '
count
ÎÎ 
=
ÎÎ	 

nearestNeighbours
ÎÎ 
.
ÎÎ 
Count
ÎÎ "
;
ÎÎ" #
var
ÌÌ 
neighbourArray
ÌÌ 
=
ÌÌ 
new
ÌÌ 

KdTreeNode
ÌÌ &
<
ÌÌ& '
TKey
ÌÌ' +
,
ÌÌ+ ,
TValue
ÌÌ- 3
>
ÌÌ3 4
[
ÌÌ4 5
count
ÌÌ5 :
]
ÌÌ: ;
;
ÌÌ; <
for
ÔÔ 
(
ÔÔ 
var
ÔÔ 
index
ÔÔ 
=
ÔÔ 
$num
ÔÔ 
;
ÔÔ 
index
ÔÔ 
<
ÔÔ 
count
ÔÔ $
;
ÔÔ$ %
index
ÔÔ& +
++
ÔÔ+ -
)
ÔÔ- .
neighbourArray
 
[
 
count
 
-
 
index
  
-
! "
$num
# $
]
$ %
=
& '
nearestNeighbours
( 9
.
9 :
RemoveFurtherest
: J
(
J K
)
K L
;
L M
return
ÚÚ 	
neighbourArray
ÚÚ
 
;
ÚÚ 
}
ÛÛ 
public
ıı 
int
ıı	 
Count
ıı 
{
ıı 
get
ıı 
;
ıı 
private
ıı !
set
ıı" %
;
ıı% &
}
ıı' (
public
˜˜ 
bool
˜˜	 
TryFindValueAt
˜˜ 
(
˜˜ 
TKey
˜˜ !
[
˜˜! "
]
˜˜" #
point
˜˜$ )
,
˜˜) *
out
˜˜+ .
TValue
˜˜/ 5
value
˜˜6 ;
)
˜˜; <
{
¯¯ 
var
˘˘ 
parent
˘˘ 
=
˘˘ 
root
˘˘ 
;
˘˘ 
int
˙˙ 
	dimension
˙˙ 
=
˙˙ 
-
˙˙ 
$num
˙˙ 
;
˙˙ 
do
˚˚ 
{
¸¸ 
if
˝˝ 
(
˝˝ 
parent
˝˝ 
==
˝˝ 
null
˝˝ 
)
˝˝ 
{
˛˛ 
value
ˇˇ 

=
ˇˇ 
default
ˇˇ 
(
ˇˇ 
TValue
ˇˇ 
)
ˇˇ 
;
ˇˇ 
return
ÄÄ 
false
ÄÄ 
;
ÄÄ 
}
ÅÅ 
else
ÇÇ 
if
ÇÇ	 
(
ÇÇ 
typeMath
ÇÇ 
.
ÇÇ 
AreEqual
ÇÇ 
(
ÇÇ 
point
ÇÇ $
,
ÇÇ$ %
parent
ÇÇ& ,
.
ÇÇ, -
Point
ÇÇ- 2
)
ÇÇ2 3
)
ÇÇ3 4
{
ÉÉ 
value
ÑÑ 

=
ÑÑ 
parent
ÑÑ 
.
ÑÑ 
Value
ÑÑ 
;
ÑÑ 
return
ÖÖ 
true
ÖÖ 
;
ÖÖ 
}
ÜÜ 
	dimension
ââ 
=
ââ 
(
ââ 
	dimension
ââ 
+
ââ 
$num
ââ 
)
ââ 
%
ââ  !

dimensions
ââ" ,
;
ââ, -
int
ää 
compare
ää 
=
ää 
typeMath
ää 
.
ää 
Compare
ää "
(
ää" #
point
ää# (
[
ää( )
	dimension
ää) 2
]
ää2 3
,
ää3 4
parent
ää5 ;
.
ää; <
Point
ää< A
[
ääA B
	dimension
ääB K
]
ääK L
)
ääL M
;
ääM N
parent
ãã 

=
ãã 
parent
ãã 
[
ãã 
compare
ãã 
]
ãã 
;
ãã 
}
åå 
while
çç 
(
çç	 

true
çç
 
)
çç 
;
çç 
}
éé 
public
êê 
TValue
êê	 
FindValueAt
êê 
(
êê 
TKey
êê  
[
êê  !
]
êê! "
point
êê# (
)
êê( )
{
ëë 
TValue
íí 	
value
íí
 
;
íí 
if
ìì 
(
ìì 
TryFindValueAt
ìì 
(
ìì 
point
ìì 
,
ìì 
out
ìì  
value
ìì! &
)
ìì& '
)
ìì' (
return
îî 

value
îî 
;
îî 
else
ïï 
return
ññ 

default
ññ 
(
ññ 
TValue
ññ 
)
ññ 
;
ññ 
}
óó 
public
ôô 
bool
ôô	 
TryFindValue
ôô 
(
ôô 
TValue
ôô !
value
ôô" '
,
ôô' (
out
ôô) ,
TKey
ôô- 1
[
ôô1 2
]
ôô2 3
point
ôô4 9
)
ôô9 :
{
öö 
if
õõ 
(
õõ 
root
õõ 
==
õõ 
null
õõ 
)
õõ 
{
úú 
point
ùù 	
=
ùù
 
null
ùù 
;
ùù 
return
ûû 

false
ûû 
;
ûû 
}
üü 
var
¢¢ 
nodesToSearch
¢¢ 
=
¢¢ 
new
¢¢ 
Queue
¢¢  
<
¢¢  !

KdTreeNode
¢¢! +
<
¢¢+ ,
TKey
¢¢, 0
,
¢¢0 1
TValue
¢¢2 8
>
¢¢8 9
>
¢¢9 :
(
¢¢: ;
)
¢¢; <
;
¢¢< =
nodesToSearch
§§ 
.
§§ 
Enqueue
§§ 
(
§§ 
root
§§ 
)
§§ 
;
§§ 
while
¶¶ 
(
¶¶	 

nodesToSearch
¶¶
 
.
¶¶ 
Count
¶¶ 
>
¶¶ 
$num
¶¶  !
)
¶¶! "
{
ßß 
var
®® 
nodeToSearch
®® 
=
®® 
nodesToSearch
®® $
.
®®$ %
Dequeue
®®% ,
(
®®, -
)
®®- .
;
®®. /
if
™™ 
(
™™ 
nodeToSearch
™™ 
.
™™ 
Value
™™ 
.
™™ 
Equals
™™ !
(
™™! "
value
™™" '
)
™™' (
)
™™( )
{
´´ 
point
¨¨ 

=
¨¨ 
nodeToSearch
¨¨ 
.
¨¨ 
Point
¨¨ 
;
¨¨  
return
≠≠ 
true
≠≠ 
;
≠≠ 
}
ÆÆ 
else
ØØ 
{
∞∞ 
for
±± 
(
±±	 

int
±±
 
side
±± 
=
±± 
-
±± 
$num
±± 
;
±± 
side
±± 
<=
±±  
$num
±±! "
;
±±" #
side
±±$ (
+=
±±) +
$num
±±, -
)
±±- .
{
≤≤ 
var
≥≥ 	
	childNode
≥≥
 
=
≥≥ 
nodeToSearch
≥≥ "
[
≥≥" #
side
≥≥# '
]
≥≥' (
;
≥≥( )
if
µµ 
(
µµ	 

	childNode
µµ
 
!=
µµ 
null
µµ 
)
µµ 
nodesToSearch
∂∂ 
.
∂∂ 
Enqueue
∂∂ 
(
∂∂ 
	childNode
∂∂ &
)
∂∂& '
;
∂∂' (
}
∑∑ 
}
∏∏ 
}
ππ 
point
ªª 
=
ªª	 

null
ªª 
;
ªª 
return
ºº 	
false
ºº
 
;
ºº 
}
ΩΩ 
public
øø 
TKey
øø	 
[
øø 
]
øø 
	FindValue
øø 
(
øø 
TValue
øø  
value
øø! &
)
øø& '
{
¿¿ 
TKey
¡¡ 
[
¡¡ 
]
¡¡ 	
point
¡¡
 
;
¡¡ 
if
¬¬ 
(
¬¬ 
TryFindValue
¬¬ 
(
¬¬ 
value
¬¬ 
,
¬¬ 
out
¬¬ 
point
¬¬ $
)
¬¬$ %
)
¬¬% &
return
√√ 

point
√√ 
;
√√ 
else
ƒƒ 
return
≈≈ 

null
≈≈ 
;
≈≈ 
}
∆∆ 
private
»» 	
void
»»
 $
AddNodeToStringBuilder
»» %
(
»»% &

KdTreeNode
»»& 0
<
»»0 1
TKey
»»1 5
,
»»5 6
TValue
»»7 =
>
»»= >
node
»»? C
,
»»C D
StringBuilder
»»E R
sb
»»S U
,
»»U V
int
»»W Z
depth
»»[ `
)
»»` a
{
…… 
sb
   
.
   

AppendLine
   
(
   
node
   
.
   
ToString
   
(
   
)
    
)
    !
;
  ! "
for
ÃÃ 
(
ÃÃ 
var
ÃÃ 
side
ÃÃ 
=
ÃÃ 
-
ÃÃ 
$num
ÃÃ 
;
ÃÃ 
side
ÃÃ 
<=
ÃÃ 
$num
ÃÃ  
;
ÃÃ  !
side
ÃÃ" &
+=
ÃÃ' )
$num
ÃÃ* +
)
ÃÃ+ ,
{
ÕÕ 
for
ŒŒ 
(
ŒŒ 	
var
ŒŒ	 
index
ŒŒ 
=
ŒŒ 
$num
ŒŒ 
;
ŒŒ 
index
ŒŒ 
<=
ŒŒ  
depth
ŒŒ! &
;
ŒŒ& '
index
ŒŒ( -
++
ŒŒ- /
)
ŒŒ/ 0
sb
œœ 
.
œœ 
Append
œœ 
(
œœ 
$str
œœ 
)
œœ 
;
œœ 
sb
—— 
.
—— 
Append
—— 
(
—— 
side
—— 
==
—— 
-
—— 
$num
—— 
?
—— 
$str
—— 
:
——  !
$str
——" &
)
——& '
;
——' (
if
”” 
(
”” 
node
”” 
[
”” 
side
”” 
]
”” 
==
”” 
null
”” 
)
”” 
sb
‘‘ 
.
‘‘ 

AppendLine
‘‘ 
(
‘‘ 
$str
‘‘ 
)
‘‘ 
;
‘‘ 
else
’’ $
AddNodeToStringBuilder
÷÷ 
(
÷÷ 
node
÷÷  
[
÷÷  !
side
÷÷! %
]
÷÷% &
,
÷÷& '
sb
÷÷( *
,
÷÷* +
depth
÷÷, 1
+
÷÷2 3
$num
÷÷4 5
)
÷÷5 6
;
÷÷6 7
}
◊◊ 
}
ÿÿ 
public
⁄⁄ 
override
⁄⁄	 
string
⁄⁄ 
ToString
⁄⁄ !
(
⁄⁄! "
)
⁄⁄" #
{
€€ 
if
‹‹ 
(
‹‹ 
root
‹‹ 
==
‹‹ 
null
‹‹ 
)
‹‹ 
return
›› 

$str
›› 
;
›› 
var
ﬂﬂ 
sb
ﬂﬂ 	
=
ﬂﬂ
 
new
ﬂﬂ 
StringBuilder
ﬂﬂ 
(
ﬂﬂ 
)
ﬂﬂ 
;
ﬂﬂ  $
AddNodeToStringBuilder
‡‡ 
(
‡‡ 
root
‡‡ 
,
‡‡ 
sb
‡‡  "
,
‡‡" #
$num
‡‡$ %
)
‡‡% &
;
‡‡& '
return
·· 	
sb
··
 
.
·· 
ToString
·· 
(
·· 
)
·· 
;
·· 
}
‚‚ 
private
‰‰ 	
void
‰‰
 
AddNodesToList
‰‰ 
(
‰‰ 

KdTreeNode
‰‰ (
<
‰‰( )
TKey
‰‰) -
,
‰‰- .
TValue
‰‰/ 5
>
‰‰5 6
node
‰‰7 ;
,
‰‰; <
List
‰‰= A
<
‰‰A B

KdTreeNode
‰‰B L
<
‰‰L M
TKey
‰‰M Q
,
‰‰Q R
TValue
‰‰S Y
>
‰‰Y Z
>
‰‰Z [
nodes
‰‰\ a
)
‰‰a b
{
ÂÂ 
if
ÊÊ 
(
ÊÊ 
node
ÊÊ 
==
ÊÊ 
null
ÊÊ 
)
ÊÊ 
return
ÁÁ 

;
ÁÁ
 
nodes
ÈÈ 
.
ÈÈ 	
Add
ÈÈ	 
(
ÈÈ 
node
ÈÈ 
)
ÈÈ 
;
ÈÈ 
for
ÎÎ 
(
ÎÎ 
var
ÎÎ 
side
ÎÎ 
=
ÎÎ 
-
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
side
ÎÎ 
<=
ÎÎ 
$num
ÎÎ  
;
ÎÎ  !
side
ÎÎ" &
+=
ÎÎ' )
$num
ÎÎ* +
)
ÎÎ+ ,
{
ÏÏ 
if
ÌÌ 
(
ÌÌ 
node
ÌÌ 
[
ÌÌ 
side
ÌÌ 
]
ÌÌ 
!=
ÌÌ 
null
ÌÌ 
)
ÌÌ 
{
ÓÓ 
AddNodesToList
ÔÔ 
(
ÔÔ 
node
ÔÔ 
[
ÔÔ 
side
ÔÔ 
]
ÔÔ 
,
ÔÔ 
nodes
ÔÔ  %
)
ÔÔ% &
;
ÔÔ& '
node
 	
[
	 

side

 
]
 
=
 
null
 
;
 
}
ÒÒ 
}
ÚÚ 
}
ÛÛ 
private
ıı 	
void
ıı
 
SortNodesArray
ıı 
(
ıı 

KdTreeNode
ıı (
<
ıı( )
TKey
ıı) -
,
ıı- .
TValue
ıı/ 5
>
ıı5 6
[
ıı6 7
]
ıı7 8
nodes
ıı9 >
,
ıı> ?
int
ıı@ C
byDimension
ııD O
,
ııO P
int
ııQ T
	fromIndex
ııU ^
,
ıı^ _
int
ıı` c
toIndex
ııd k
)
ıık l
{
ˆˆ 
for
˜˜ 
(
˜˜ 
var
˜˜ 
index
˜˜ 
=
˜˜ 
	fromIndex
˜˜ 
+
˜˜ 
$num
˜˜  !
;
˜˜! "
index
˜˜# (
<=
˜˜) +
toIndex
˜˜, 3
;
˜˜3 4
index
˜˜5 :
++
˜˜: <
)
˜˜< =
{
¯¯ 
var
˘˘ 
newIndex
˘˘ 
=
˘˘ 
index
˘˘ 
;
˘˘ 
while
˚˚ 	
(
˚˚
 
true
˚˚ 
)
˚˚ 
{
¸¸ 
var
˝˝ 
a
˝˝	 

=
˝˝ 
nodes
˝˝ 
[
˝˝ 
newIndex
˝˝ 
-
˝˝ 
$num
˝˝ 
]
˝˝  
;
˝˝  !
var
˛˛ 
b
˛˛	 

=
˛˛ 
nodes
˛˛ 
[
˛˛ 
newIndex
˛˛ 
]
˛˛ 
;
˛˛ 
if
ˇˇ 
(
ˇˇ 	
typeMath
ˇˇ	 
.
ˇˇ 
Compare
ˇˇ 
(
ˇˇ 
b
ˇˇ 
.
ˇˇ 
Point
ˇˇ !
[
ˇˇ! "
byDimension
ˇˇ" -
]
ˇˇ- .
,
ˇˇ. /
a
ˇˇ0 1
.
ˇˇ1 2
Point
ˇˇ2 7
[
ˇˇ7 8
byDimension
ˇˇ8 C
]
ˇˇC D
)
ˇˇD E
<
ˇˇF G
$num
ˇˇH I
)
ˇˇI J
{
ÄÄ 
nodes
ÅÅ 
[
ÅÅ 
newIndex
ÅÅ 
-
ÅÅ 
$num
ÅÅ 
]
ÅÅ 
=
ÅÅ 
b
ÅÅ 
;
ÅÅ 
nodes
ÇÇ 
[
ÇÇ 
newIndex
ÇÇ 
]
ÇÇ 
=
ÇÇ 
a
ÇÇ 
;
ÇÇ 
}
ÉÉ 
else
ÑÑ 	
break
ÖÖ 
;
ÖÖ 
}
ÜÜ 
}
áá 
}
àà 
private
ää 	
void
ää
 
AddNodesBalanced
ää 
(
ää  

KdTreeNode
ää  *
<
ää* +
TKey
ää+ /
,
ää/ 0
TValue
ää1 7
>
ää7 8
[
ää8 9
]
ää9 :
nodes
ää; @
,
ää@ A
int
ääB E
byDimension
ääF Q
,
ääQ R
int
ääS V
	fromIndex
ääW `
,
ää` a
int
ääb e
toIndex
ääf m
)
ääm n
{
ãã 
if
åå 
(
åå 
	fromIndex
åå 
==
åå 
toIndex
åå 
)
åå 
{
çç 
Add
éé 
(
éé 
nodes
éé 
[
éé 
	fromIndex
éé 
]
éé 
.
éé 
Point
éé 
,
éé 
nodes
éé  %
[
éé% &
	fromIndex
éé& /
]
éé/ 0
.
éé0 1
Value
éé1 6
)
éé6 7
;
éé7 8
nodes
èè 	
[
èè	 

	fromIndex
èè
 
]
èè 
=
èè 
null
èè 
;
èè 
return
êê 

;
êê
 
}
ëë 
SortNodesArray
îî 
(
îî 
nodes
îî 
,
îî 
byDimension
îî $
,
îî$ %
	fromIndex
îî& /
,
îî/ 0
toIndex
îî1 8
)
îî8 9
;
îî9 :
int
óó 
midIndex
óó 
=
óó 
	fromIndex
óó 
+
óó 
(
óó 
int
óó "
)
óó" #
System
óó# )
.
óó) *
Math
óó* .
.
óó. /
Round
óó/ 4
(
óó4 5
(
óó5 6
toIndex
óó6 =
+
óó> ?
$num
óó@ A
-
óóB C
	fromIndex
óóD M
)
óóM N
/
óóO P
$num
óóQ S
)
óóS T
-
óóU V
$num
óóW X
;
óóX Y
Add
öö 
(
öö 
nodes
öö 
[
öö 
midIndex
öö 
]
öö 
.
öö 
Point
öö 
,
öö 
nodes
öö #
[
öö# $
midIndex
öö$ ,
]
öö, -
.
öö- .
Value
öö. 3
)
öö3 4
;
öö4 5
nodes
õõ 
[
õõ 	
midIndex
õõ	 
]
õõ 
=
õõ 
null
õõ 
;
õõ 
int
ûû 
nextDimension
ûû 
=
ûû 
(
ûû 
byDimension
ûû #
+
ûû$ %
$num
ûû& '
)
ûû' (
%
ûû) *

dimensions
ûû+ 5
;
ûû5 6
if
†† 
(
†† 
	fromIndex
†† 
<
†† 
midIndex
†† 
)
†† 
AddNodesBalanced
°° 
(
°° 
nodes
°° 
,
°° 
nextDimension
°° )
,
°°) *
	fromIndex
°°+ 4
,
°°4 5
midIndex
°°6 >
-
°°? @
$num
°°A B
)
°°B C
;
°°C D
if
££ 
(
££ 
toIndex
££ 
>
££ 
midIndex
££ 
)
££ 
AddNodesBalanced
§§ 
(
§§ 
nodes
§§ 
,
§§ 
nextDimension
§§ )
,
§§) *
midIndex
§§+ 3
+
§§4 5
$num
§§6 7
,
§§7 8
toIndex
§§9 @
)
§§@ A
;
§§A B
}
•• 
public
ßß 
void
ßß	 
Balance
ßß 
(
ßß 
)
ßß 
{
®® 
var
©© 
nodeList
©© 
=
©© 
new
©© 
List
©© 
<
©© 

KdTreeNode
©© %
<
©©% &
TKey
©©& *
,
©©* +
TValue
©©, 2
>
©©2 3
>
©©3 4
(
©©4 5
)
©©5 6
;
©©6 7
AddNodesToList
™™ 
(
™™ 
root
™™ 
,
™™ 
nodeList
™™  
)
™™  !
;
™™! "
Clear
¨¨ 
(
¨¨ 	
)
¨¨	 

;
¨¨
 
AddNodesBalanced
ÆÆ 
(
ÆÆ 
nodeList
ÆÆ 
.
ÆÆ 
ToArray
ÆÆ $
(
ÆÆ$ %
)
ÆÆ% &
,
ÆÆ& '
$num
ÆÆ( )
,
ÆÆ) *
$num
ÆÆ+ ,
,
ÆÆ, -
nodeList
ÆÆ. 6
.
ÆÆ6 7
Count
ÆÆ7 <
-
ÆÆ= >
$num
ÆÆ? @
)
ÆÆ@ A
;
ÆÆA B
}
ØØ 
private
±± 	
void
±±
 
RemoveChildNodes
±± 
(
±±  

KdTreeNode
±±  *
<
±±* +
TKey
±±+ /
,
±±/ 0
TValue
±±1 7
>
±±7 8
node
±±9 =
)
±±= >
{
≤≤ 
for
≥≥ 
(
≥≥ 
var
≥≥ 
side
≥≥ 
=
≥≥ 
-
≥≥ 
$num
≥≥ 
;
≥≥ 
side
≥≥ 
<=
≥≥ 
$num
≥≥  
;
≥≥  !
side
≥≥" &
+=
≥≥' )
$num
≥≥* +
)
≥≥+ ,
{
¥¥ 
if
µµ 
(
µµ 
node
µµ 
[
µµ 
side
µµ 
]
µµ 
!=
µµ 
null
µµ 
)
µµ 
{
∂∂ 
RemoveChildNodes
∑∑ 
(
∑∑ 
node
∑∑ 
[
∑∑ 
side
∑∑ 
]
∑∑  
)
∑∑  !
;
∑∑! "
node
∏∏ 	
[
∏∏	 

side
∏∏
 
]
∏∏ 
=
∏∏ 
null
∏∏ 
;
∏∏ 
}
ππ 
}
∫∫ 
}
ªª 
public
ΩΩ 
void
ΩΩ	 
Clear
ΩΩ 
(
ΩΩ 
)
ΩΩ 
{
ææ 
if
øø 
(
øø 
root
øø 
!=
øø 
null
øø 
)
øø 
RemoveChildNodes
¿¿ 
(
¿¿ 
root
¿¿ 
)
¿¿ 
;
¿¿ 
}
¡¡ 
public
√√ 
void
√√	 

SaveToFile
√√ 
(
√√ 
string
√√ 
filename
√√  (
)
√√( )
{
ƒƒ 
BinaryFormatter
≈≈ 
	formatter
≈≈ 
=
≈≈ 
new
≈≈ "
BinaryFormatter
≈≈# 2
(
≈≈2 3
)
≈≈3 4
;
≈≈4 5
using
∆∆ 
(
∆∆	 


FileStream
∆∆
 
stream
∆∆ 
=
∆∆ 
File
∆∆ "
.
∆∆" #
Create
∆∆# )
(
∆∆) *
filename
∆∆* 2
)
∆∆2 3
)
∆∆3 4
{
«« 
	formatter
»» 
.
»» 
	Serialize
»» 
(
»» 
stream
»» 
,
»» 
this
»»  $
)
»»$ %
;
»»% &
stream
…… 

.
……
 
Flush
…… 
(
…… 
)
…… 
;
…… 
}
   
}
ÀÀ 
public
ÕÕ 
static
ÕÕ	 
KdTree
ÕÕ 
<
ÕÕ 
TKey
ÕÕ 
,
ÕÕ 
TValue
ÕÕ #
>
ÕÕ# $
LoadFromFile
ÕÕ% 1
(
ÕÕ1 2
string
ÕÕ2 8
filename
ÕÕ9 A
)
ÕÕA B
{
ŒŒ 
BinaryFormatter
œœ 
	formatter
œœ 
=
œœ 
new
œœ "
BinaryFormatter
œœ# 2
(
œœ2 3
)
œœ3 4
;
œœ4 5
using
–– 
(
––	 


FileStream
––
 
stream
–– 
=
–– 
File
–– "
.
––" #
Open
––# '
(
––' (
filename
––( 0
,
––0 1
FileMode
––2 :
.
––: ;
Open
––; ?
)
––? @
)
––@ A
{
—— 
return
““ 

(
““ 
KdTree
““ 
<
““ 
TKey
““ 
,
““ 
TValue
““ 
>
““  
)
““  !
	formatter
““! *
.
““* +
Deserialize
““+ 6
(
““6 7
stream
““7 =
)
““= >
;
““> ?
}
”” 
}
’’ 
public
◊◊ 
IEnumerator
◊◊ 
<
◊◊ 

KdTreeNode
◊◊ %
<
◊◊% &
TKey
◊◊& *
,
◊◊* +
TValue
◊◊, 2
>
◊◊2 3
>
◊◊3 4
GetEnumerator
◊◊5 B
(
◊◊B C
)
◊◊C D
{
ÿÿ 	
var
ŸŸ 
left
ŸŸ 
=
ŸŸ 
new
ŸŸ 
Stack
ŸŸ  
<
ŸŸ  !

KdTreeNode
ŸŸ! +
<
ŸŸ+ ,
TKey
ŸŸ, 0
,
ŸŸ0 1
TValue
ŸŸ2 8
>
ŸŸ8 9
>
ŸŸ9 :
(
ŸŸ: ;
)
ŸŸ; <
;
ŸŸ< =
var
⁄⁄ 
right
⁄⁄ 
=
⁄⁄ 
new
⁄⁄ 
Stack
⁄⁄ !
<
⁄⁄! "

KdTreeNode
⁄⁄" ,
<
⁄⁄, -
TKey
⁄⁄- 1
,
⁄⁄1 2
TValue
⁄⁄3 9
>
⁄⁄9 :
>
⁄⁄: ;
(
⁄⁄; <
)
⁄⁄< =
;
⁄⁄= >
Action
‹‹ 
<
‹‹ 

KdTreeNode
‹‹ 
<
‹‹ 
TKey
‹‹ "
,
‹‹" #
TValue
‹‹$ *
>
‹‹* +
>
‹‹+ ,
addLeft
‹‹- 4
=
‹‹5 6
node
‹‹7 ;
=>
‹‹< >
{
›› 
if
ﬁﬁ 
(
ﬁﬁ 
node
ﬁﬁ 
.
ﬁﬁ 
	LeftChild
ﬁﬁ "
!=
ﬁﬁ# %
null
ﬁﬁ& *
)
ﬁﬁ* +
{
ﬂﬂ 
left
‡‡ 
.
‡‡ 
Push
‡‡ 
(
‡‡ 
node
‡‡ "
.
‡‡" #
	LeftChild
‡‡# ,
)
‡‡, -
;
‡‡- .
}
·· 
}
‚‚ 
;
‚‚ 
Action
‰‰ 
<
‰‰ 

KdTreeNode
‰‰ 
<
‰‰ 
TKey
‰‰ "
,
‰‰" #
TValue
‰‰$ *
>
‰‰* +
>
‰‰+ ,
addRight
‰‰- 5
=
‰‰6 7
node
‰‰8 <
=>
‰‰= ?
{
ÂÂ 
if
ÊÊ 
(
ÊÊ 
node
ÊÊ 
.
ÊÊ 

RightChild
ÊÊ #
!=
ÊÊ$ &
null
ÊÊ' +
)
ÊÊ+ ,
{
ÁÁ 
right
ËË 
.
ËË 
Push
ËË 
(
ËË 
node
ËË #
.
ËË# $

RightChild
ËË$ .
)
ËË. /
;
ËË/ 0
}
ÈÈ 
}
ÍÍ 
;
ÍÍ 
if
ÏÏ 
(
ÏÏ 
root
ÏÏ 
!=
ÏÏ 
null
ÏÏ 
)
ÏÏ 
{
ÌÌ 
yield
ÓÓ 
return
ÓÓ 
root
ÓÓ !
;
ÓÓ! "
addLeft
 
(
 
root
 
)
 
;
 
addRight
ÒÒ 
(
ÒÒ 
root
ÒÒ 
)
ÒÒ 
;
ÒÒ 
while
ÛÛ 
(
ÛÛ 
true
ÛÛ 
)
ÛÛ 
{
ÙÙ 
if
ıı 
(
ıı 
left
ıı 
.
ıı 
Any
ıı  
(
ıı  !
)
ıı! "
)
ıı" #
{
ˆˆ 
var
˜˜ 
item
˜˜  
=
˜˜! "
left
˜˜# '
.
˜˜' (
Pop
˜˜( +
(
˜˜+ ,
)
˜˜, -
;
˜˜- .
addLeft
˘˘ 
(
˘˘  
item
˘˘  $
)
˘˘$ %
;
˘˘% &
addRight
˙˙  
(
˙˙  !
item
˙˙! %
)
˙˙% &
;
˙˙& '
yield
¸¸ 
return
¸¸ $
item
¸¸% )
;
¸¸) *
}
˝˝ 
else
˛˛ 
if
˛˛ 
(
˛˛ 
right
˛˛ "
.
˛˛" #
Any
˛˛# &
(
˛˛& '
)
˛˛' (
)
˛˛( )
{
ˇˇ 
var
ÄÄ 
item
ÄÄ  
=
ÄÄ! "
right
ÄÄ# (
.
ÄÄ( )
Pop
ÄÄ) ,
(
ÄÄ, -
)
ÄÄ- .
;
ÄÄ. /
addLeft
ÇÇ 
(
ÇÇ  
item
ÇÇ  $
)
ÇÇ$ %
;
ÇÇ% &
addRight
ÉÉ  
(
ÉÉ  !
item
ÉÉ! %
)
ÉÉ% &
;
ÉÉ& '
yield
ÖÖ 
return
ÖÖ $
item
ÖÖ% )
;
ÖÖ) *
}
ÜÜ 
else
áá 
{
àà 
break
ââ 
;
ââ 
}
ää 
}
ãã 
}
åå 
}
çç 	
IEnumerator
èè 
IEnumerable
èè 
.
èè  
GetEnumerator
èè  -
(
èè- .
)
èè. /
{
êê 	
return
ëë 
GetEnumerator
ëë  
(
ëë  !
)
ëë! "
;
ëë" #
}
íí 	
}
ìì 
}îî ˆ&
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\KdTree\KdTreeLib\KdTreeNode.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
KdTree! '
{ 
[ 
Serializable 
] 
class		 

KdTreeNode		 
<		 
TKey		 
,		 
TValue		 
>		 
{

 
public 

KdTreeNode	 
( 
) 
{ 
} 
public 

KdTreeNode	 
( 
TKey 
[ 
] 
point  
,  !
TValue" (
value) .
). /
{ 
Point 
=	 

point 
; 
Value 
=	 

value 
; 
} 
public 
TKey	 
[ 
] 
Point 
; 
public 
TValue	 
Value 
= 
default 
(  
TValue  &
)& '
;' (
public 
List	 
< 
TValue 
> 

Duplicates  
=! "
null# '
;' (
internal 


KdTreeNode 
< 
TKey 
, 
TValue "
>" #
	LeftChild$ -
=. /
null0 4
;4 5
internal 


KdTreeNode 
< 
TKey 
, 
TValue "
>" #

RightChild$ .
=/ 0
null1 5
;5 6
internal 


KdTreeNode 
< 
TKey 
, 
TValue "
>" #
this$ (
[( )
int) ,
compare- 4
]4 5
{ 
get 
{ 
if   
(   
compare   
<=   
$num   
)   
return!! 
	LeftChild!! 
;!! 
else"" 
return## 

RightChild## 
;## 
}$$ 
set%% 
{&& 
if'' 
('' 
compare'' 
<='' 
$num'' 
)'' 
	LeftChild(( 
=(( 
value(( 
;(( 
else)) 

RightChild** 
=** 
value** 
;** 
}++ 
},, 
public.. 
bool..	 
IsLeaf.. 
{// 
get00 
{11 
return22 

(22 
	LeftChild22 
==22 
null22 
)22 
&&22 !
(22" #

RightChild22# -
==22. 0
null221 5
)225 6
;226 7
}33 
}44 
public66 
void66	 
AddDuplicate66 
(66 
TValue66 !
value66" '
)66' (
{77 
if88 
(88 

Duplicates88 
==88 
null88 
)88 

Duplicates99 
=99 
new99 
List99 
<99 
TValue99  
>99  !
(99! "
)99" #
{99$ %
value99& +
}99, -
;99- .
else:: 

Duplicates;; 
.;; 
Add;; 
(;; 
value;; 
);; 
;;; 
}<< 
public>> 
override>>	 
string>> 
ToString>> !
(>>! "
)>>" #
{?? 
var@@ 
sb@@ 	
=@@
 
new@@ 
StringBuilder@@ 
(@@ 
)@@ 
;@@  
forBB 
(BB 
varBB 
	dimensionBB 
=BB 
$numBB 
;BB 
	dimensionBB $
<BB% &
PointBB' ,
.BB, -
LengthBB- 3
;BB3 4
	dimensionBB5 >
++BB> @
)BB@ A
{CC 
sbDD 
.DD 
AppendDD 
(DD 
PointDD 
[DD 
	dimensionDD 
]DD 
.DD 
ToStringDD '
(DD' (
)DD( )
)DD) *
;DD* +
}EE 
ifGG 
(GG 
ValueGG 
==GG 
nullGG 
)GG 
sbHH 
.HH 
AppendHH 
(HH 
$strHH 
)HH 
;HH 
elseII 
sbJJ 
.JJ 
AppendJJ 
(JJ 
ValueJJ 
.JJ 
ToStringJJ 
(JJ 
)JJ 
)JJ 
;JJ  
returnLL 	
sbLL
 
.LL 
ToStringLL 
(LL 
)LL 
;LL 
}MM 
}NN 
}OO ë-
¢D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\KdTree\KdTreeLib\NearestNeighbourList.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
KdTree! '
{ 
	interface 
!
INearestNeighbourList  
<  !
TItem! &
,& '
	TDistance( 1
>1 2
{ 
bool 
Add 

(
 
TItem 
item 
, 
	TDistance  
distance! )
)) *
;* +
TItem 
GetFurtherest 
( 
) 
; 
TItem		 
RemoveFurtherest		 
(		 
)		 
;		 
int 
MaxCapacity 
{ 
get 
; 
} 
int 
Count 
{ 
get 
; 
} 
} 
class  
NearestNeighbourList 
< 
TItem !
,! "
	TDistance# ,
>, -
:. /!
INearestNeighbourList0 E
<E F
TItemF K
,K L
	TDistanceM V
>V W
{ 
public  
NearestNeighbourList	 
( 
int !
maxCapacity" -
,- .
	ITypeMath/ 8
<8 9
	TDistance9 B
>B C
distanceMathD P
)P Q
{ 
this 
. 
maxCapacity 
= 
maxCapacity !
;! "
this 
. 
distanceMath 
= 
distanceMath #
;# $
queue 
=	 

new 
PriorityQueue 
< 
TItem "
," #
	TDistance$ -
>- .
(. /
maxCapacity/ :
,: ;
distanceMath< H
)H I
;I J
} 
private 	
PriorityQueue
 
< 
TItem 
, 
	TDistance (
>( )
queue* /
;/ 0
private 	
	ITypeMath
 
< 
	TDistance 
> 
distanceMath +
;+ ,
private 	
int
 
maxCapacity 
; 
public 
int	 
MaxCapacity 
{ 
get 
{  
return! '
maxCapacity( 3
;3 4
}5 6
}7 8
public   
int  	 
Count   
{   
get   
{   
return   !
queue  " '
.  ' (
Count  ( -
;  - .
}  / 0
}  1 2
public"" 
bool""	 
Add"" 
("" 
TItem"" 
item"" 
,"" 
	TDistance"" '
distance""( 0
)""0 1
{## 
if$$ 
($$ 
queue$$ 
.$$ 
Count$$ 
>=$$ 
maxCapacity$$ !
)$$! "
{%% 
if)) 
()) 
distanceMath)) 
.)) 
Compare)) 
()) 
distance)) %
,))% &
queue))' ,
.)), -
GetHighestPriority))- ?
())? @
)))@ A
)))A B
<))C D
$num))E F
)))F G
{** 
queue++ 

.++
 
Dequeue++ 
(++ 
)++ 
;++ 
queue,, 

.,,
 
Enqueue,, 
(,, 
item,, 
,,, 
distance,, !
),,! "
;,," #
return-- 
true-- 
;-- 
}.. 
else// 
return00 
false00 
;00 
}11 
else22 
{33 
queue44 	
.44	 

Enqueue44
 
(44 
item44 
,44 
distance44  
)44  !
;44! "
return55 

true55 
;55 
}66 
}77 
public99 
TItem99	 
GetFurtherest99 
(99 
)99 
{:: 
if;; 
(;; 
Count;; 
==;; 
$num;; 
);; 
throw<< 	
new<<
 
	Exception<< 
(<< 
$str<< '
)<<' (
;<<( )
else== 
return>> 

queue>> 
.>> 

GetHighest>> 
(>> 
)>> 
;>> 
}?? 
publicAA 
	TDistanceAA	 !
GetFurtherestDistanceAA (
(AA( )
)AA) *
{BB 
ifCC 
(CC 
CountCC 
==CC 
$numCC 
)CC 
throwDD 	
newDD
 
	ExceptionDD 
(DD 
$strDD '
)DD' (
;DD( )
elseEE 
returnFF 

queueFF 
.FF 
GetHighestPriorityFF #
(FF# $
)FF$ %
;FF% &
}GG 
publicII 
TItemII	 
RemoveFurtherestII 
(II  
)II  !
{JJ 
returnKK 	
queueKK
 
.KK 
DequeueKK 
(KK 
)KK 
;KK 
}LL 
publicNN 
boolNN	 
IsCapacityReachedNN 
{OO 
getPP 
{PP 
returnPP	 
CountPP 
==PP 
MaxCapacityPP $
;PP$ %
}PP& '
}QQ 
}RR 
}SS Æ
öD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\KdTree\KdTreeLib\AssemblyInfo.cs
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 0
)0 1
]1 2ŒD
õD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\KdTree\KdTreeLib\PriorityQueue.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
KdTree! '
{ 
struct 
ItemPriority 
< 
TItem 
, 
	TPriority %
>% &
{ 
public 
TItem	 
Item 
; 
public 
	TPriority	 
Priority 
; 
}		 
class 
PriorityQueue 
< 
TItem 
, 
	TPriority %
>% &
:' (
IPriorityQueue) 7
<7 8
TItem8 =
,= >
	TPriority? H
>H I
{ 
public 
PriorityQueue	 
( 
int 
capacity #
,# $
	ITypeMath% .
<. /
	TPriority/ 8
>8 9
priorityMath: F
)F G
{ 
if 
( 
capacity 
<= 
$num 
) 
throw 	
new
 
ArgumentException 
(  
$str  D
)D E
;E F
this 
. 
capacity 
= 
capacity 
; 
queue 
=	 

new 
ItemPriority 
< 
TItem !
,! "
	TPriority# ,
>, -
[- .
capacity. 6
]6 7
;7 8
this 
. 
priorityMath 
= 
priorityMath #
;# $
} 
private 	
	ITypeMath
 
< 
	TPriority 
> 
priorityMath +
;+ ,
private 	
ItemPriority
 
< 
TItem 
, 
	TPriority '
>' (
[( )
]) *
queue+ 0
;0 1
private 	
int
 
capacity 
; 
private 	
int
 
count 
; 
public 
int	 
Count 
{ 
get 
{ 
return !
count" '
;' (
}) *
}+ ,
private"" 	
void""
 
ExpandCapacity"" 
("" 
)"" 
{## 
capacity%% 
*=%% 
$num%% 
;%% 
var(( 
newQueue(( 
=(( 
new(( 
ItemPriority(( "
<((" #
TItem((# (
,((( )
	TPriority((* 3
>((3 4
[((4 5
capacity((5 =
]((= >
;((> ?
Array++ 
.++ 	
Copy++	 
(++ 
queue++ 
,++ 
newQueue++ 
,++ 
queue++ $
.++$ %
Length++% +
)+++ ,
;++, -
queue.. 
=..	 

newQueue.. 
;.. 
}// 
public11 
void11	 
Enqueue11 
(11 
TItem11 
item11  
,11  !
	TPriority11" +
priority11, 4
)114 5
{22 
if33 
(33 
++33 	
count33	 
>33 
capacity33 
)33 
ExpandCapacity44 
(44 
)44 
;44 
int66 
newItemIndex66 
=66 
count66 
-66 
$num66 
;66  
queue88 
[88 	
newItemIndex88	 
]88 
=88 
new88 
ItemPriority88 )
<88) *
TItem88* /
,88/ 0
	TPriority881 :
>88: ;
{88< =
Item88> B
=88C D
item88E I
,88I J
Priority88K S
=88T U
priority88V ^
}88_ `
;88` a
ReorderItem:: 
(:: 
newItemIndex:: 
,:: 
-:: 
$num:: 
)::  
;::  !
};; 
public== 
TItem==	 
Dequeue== 
(== 
)== 
{>> 
TItem?? 
item??	 
=?? 
queue?? 
[?? 
$num?? 
]?? 
.?? 
Item?? 
;?? 
queueAA 
[AA 	
$numAA	 

]AA
 
.AA 
ItemAA 
=AA 
defaultAA 
(AA 
TItemAA  
)AA  !
;AA! "
queueBB 
[BB 	
$numBB	 

]BB
 
.BB 
PriorityBB 
=BB 
priorityMathBB #
.BB# $
MinValueBB$ ,
;BB, -
ReorderItemDD 
(DD 
$numDD 
,DD 
$numDD 
)DD 
;DD 
countFF 
--FF 

;FF
 
returnHH 	
itemHH
 
;HH 
}II 
privateKK 	
voidKK
 
ReorderItemKK 
(KK 
intKK 
indexKK $
,KK$ %
intKK& )
	directionKK* 3
)KK3 4
{LL 
ifMM 
(MM 
(MM 
	directionMM 
!=MM 
-MM 
$numMM 
)MM 
&&MM 
(MM 
	directionMM &
!=MM' )
$numMM* +
)MM+ ,
)MM, -
throwNN 	
newNN
 
ArgumentExceptionNN 
(NN  
$strNN  3
)NN3 4
;NN4 5
varPP 
itemPP 
=PP 
queuePP 
[PP 
indexPP 
]PP 
;PP 
intRR 
	nextIndexRR 
=RR 
indexRR 
+RR 
	directionRR $
;RR$ %
whileTT 
(TT	 

(TT
 
	nextIndexTT 
>=TT 
$numTT 
)TT 
&&TT 
(TT 
	nextIndexTT (
<TT) *
countTT+ 0
)TT0 1
)TT1 2
{UU 
varVV 
nextVV 
=VV 
queueVV 
[VV 
	nextIndexVV 
]VV 
;VV  
intXX 
compareXX 
=XX 
priorityMathXX 
.XX 
CompareXX &
(XX& '
itemXX' +
.XX+ ,
PriorityXX, 4
,XX4 5
nextXX6 :
.XX: ;
PriorityXX; C
)XXC D
;XXD E
if\\ 
(\\ 
(]] 
(]] 
	direction]] 
==]] 
-]] 
$num]] 
)]] 
&&]] 
(]] 
compare]] #
>]]$ %
$num]]& '
)]]' (
)]]( )
||^^ 
(__ 
(__ 
	direction__ 
==__ 
$num__ 
)__ 
&&__ 
(__ 
compare__ "
<__# $
$num__% &
)__& '
)__' (
)`` 
{aa 
queuebb 

[bb
 
indexbb 
]bb 
=bb 
nextbb 
;bb 
queuecc 

[cc
 
	nextIndexcc 
]cc 
=cc 
itemcc 
;cc 
indexee 

+=ee 
	directionee 
;ee 
	nextIndexff 
+=ff 
	directionff 
;ff 
}gg 
elsehh 
breakii 

;ii
 
}jj 
}kk 
publicmm 
TItemmm	 

GetHighestmm 
(mm 
)mm 
{nn 
ifoo 
(oo 
countoo 
==oo 
$numoo 
)oo 
throwpp 	
newpp
 
	Exceptionpp 
(pp 
$strpp (
)pp( )
;pp) *
elseqq 
returnrr 

queuerr 
[rr 
$numrr 
]rr 
.rr 
Itemrr 
;rr 
}ss 
publicuu 
	TPriorityuu	 
GetHighestPriorityuu %
(uu% &
)uu& '
{vv 
ifww 
(ww 
countww 
==ww 
$numww 
)ww 
throwxx 	
newxx
 
	Exceptionxx 
(xx 
$strxx (
)xx( )
;xx) *
elseyy 
returnzz 

queuezz 
[zz 
$numzz 
]zz 
.zz 
Priorityzz 
;zz 
}{{ 
}|| 
}}} ∂0
óD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\KdTree\KdTreeLib\HyperRect.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
KdTree! '
{ 
struct 
	HyperRect 
< 
T 
> 
{ 
private 	
T
 
[ 
] 
minPoint 
; 
public 
T	 

[
 
] 
MinPoint 
{ 
get 
{		 
return

 

minPoint

 
;

 
} 
set 
{ 
minPoint 
= 
new 
T 
[ 
value 
. 
Length !
]! "
;" #
value 	
.	 

CopyTo
 
( 
minPoint 
, 
$num 
) 
; 
} 
} 
private 	
T
 
[ 
] 
maxPoint 
; 
public 
T	 

[
 
] 
MaxPoint 
{ 
get 
{ 
return 

maxPoint 
; 
} 
set 
{ 
maxPoint 
= 
new 
T 
[ 
value 
. 
Length !
]! "
;" #
value 	
.	 

CopyTo
 
( 
maxPoint 
, 
$num 
) 
; 
} 
} 
public!! 
static!!	 
	HyperRect!! 
<!! 
T!! 
>!! 
Infinite!! %
(!!% &
int!!& )

dimensions!!* 4
,!!4 5
	ITypeMath!!6 ?
<!!? @
T!!@ A
>!!A B
math!!C G
)!!G H
{"" 
var## 
rect## 
=## 
new## 
	HyperRect## 
<## 
T## 
>## 
(## 
)##  
;##  !
rect%% 
.%% 
MinPoint%% 
=%% 
new%% 
T%% 
[%% 

dimensions%% #
]%%# $
;%%$ %
rect&& 
.&& 
MaxPoint&& 
=&& 
new&& 
T&& 
[&& 

dimensions&& #
]&&# $
;&&$ %
for(( 
((( 
var(( 
	dimension(( 
=(( 
$num(( 
;(( 
	dimension(( $
<((% &

dimensions((' 1
;((1 2
	dimension((3 <
++((< >
)((> ?
{)) 
rect** 
.** 	
MinPoint**	 
[** 
	dimension** 
]** 
=** 
math** #
.**# $
NegativeInfinity**$ 4
;**4 5
rect++ 
.++ 	
MaxPoint++	 
[++ 
	dimension++ 
]++ 
=++ 
math++ #
.++# $
PositiveInfinity++$ 4
;++4 5
},, 
return.. 	
rect..
 
;.. 
}// 
public11 
T11	 

[11
 
]11 
GetClosestPoint11 
(11 
T11 
[11 
]11  
toPoint11! (
,11( )
	ITypeMath11* 3
<113 4
T114 5
>115 6
math117 ;
)11; <
{22 
T33 
[33 
]33 
closest33 
=33 
new33 
T33 
[33 
toPoint33 
.33 
Length33 %
]33% &
;33& '
for55 
(55 
var55 
	dimension55 
=55 
$num55 
;55 
	dimension55 $
<55% &
toPoint55' .
.55. /
Length55/ 5
;555 6
	dimension557 @
++55@ B
)55B C
{66 
if77 
(77 
math77 
.77 
Compare77 
(77 
minPoint77 
[77 
	dimension77 '
]77' (
,77( )
toPoint77* 1
[771 2
	dimension772 ;
]77; <
)77< =
>77> ?
$num77@ A
)77A B
{88 
closest99 
[99 
	dimension99 
]99 
=99 
minPoint99 "
[99" #
	dimension99# ,
]99, -
;99- .
}:: 
else;; 
if;;	 
(;; 
math;; 
.;; 
Compare;; 
(;; 
maxPoint;; "
[;;" #
	dimension;;# ,
];;, -
,;;- .
toPoint;;/ 6
[;;6 7
	dimension;;7 @
];;@ A
);;A B
<;;C D
$num;;E F
);;F G
{<< 
closest== 
[== 
	dimension== 
]== 
=== 
maxPoint== "
[==" #
	dimension==# ,
]==, -
;==- .
}>> 
else?? 
closestAA 
[AA 
	dimensionAA 
]AA 
=AA 
toPointAA !
[AA! "
	dimensionAA" +
]AA+ ,
;AA, -
}BB 
returnDD 	
closestDD
 
;DD 
}EE 
publicGG 
	HyperRectGG	 
<GG 
TGG 
>GG 
CloneGG 
(GG 
)GG 
{HH 
varII 
rectII 
=II 
newII 
	HyperRectII 
<II 
TII 
>II 
(II 
)II  
;II  !
rectJJ 
.JJ 
MinPointJJ 
=JJ 
MinPointJJ 
;JJ 
rectKK 
.KK 
MaxPointKK 
=KK 
MaxPointKK 
;KK 
returnLL 	
rectLL
 
;LL 
}MM 
}NN 
}OO Í$
õD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\KdTree\KdTreeLib\Math\TypeMath.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
KdTree! '
.' (
Math( ,
{ 
[ 
Serializable 
] 
abstract 	
class
 
TypeMath 
< 
T 
> 
: 
	ITypeMath '
<' (
T( )
>) *
{ 
public

 
abstract

	 
int

 
Compare

 
(

 
T

 
a

  !
,

! "
T

# $
b

% &
)

& '
;

' (
public 
abstract	 
bool 
AreEqual 
(  
T  !
a" #
,# $
T% &
b' (
)( )
;) *
public 
virtual	 
bool 
AreEqual 
( 
T  
[  !
]! "
a# $
,$ %
T& '
[' (
]( )
b* +
)+ ,
{ 
if 
( 
a 
. 	
Length	 
!= 
b 
. 
Length 
) 
return 

false 
; 
for 
( 
var 
index 
= 
$num 
; 
index 
< 
a  
.  !
Length! '
;' (
index) .
++. 0
)0 1
{ 
if 
( 
! 	
AreEqual	 
( 
a 
[ 
index 
] 
, 
b 
[ 
index #
]# $
)$ %
)% &
return 
false 
; 
} 
return 	
true
 
; 
} 
public 
abstract	 
T 
MinValue 
{ 
get "
;" #
}$ %
public 
abstract	 
T 
MaxValue 
{ 
get "
;" #
}$ %
public   
T  	 

Min   
(   
T   
a   
,   
T   
b   
)   
{!! 
if"" 
("" 
Compare"" 
("" 
a"" 
,"" 
b"" 
)"" 
<"" 
$num"" 
)"" 
return## 

a## 
;## 
else$$ 
return%% 

b%% 
;%% 
}&& 
public(( 
T((	 

Max(( 
((( 
T(( 
a(( 
,(( 
T(( 
b(( 
)(( 
{)) 
if** 
(** 
Compare** 
(** 
a** 
,** 
b** 
)** 
>** 
$num** 
)** 
return++ 

a++ 
;++ 
else,, 
return-- 

b-- 
;-- 
}.. 
public00 
abstract00	 
T00 
Zero00 
{00 
get00 
;00 
}00  !
public22 
abstract22	 
T22 
NegativeInfinity22 $
{22% &
get22' *
;22* +
}22, -
public44 
abstract44	 
T44 
PositiveInfinity44 $
{44% &
get44' *
;44* +
}44, -
public66 
abstract66	 
T66 
Add66 
(66 
T66 
a66 
,66 
T66 
b66  
)66  !
;66! "
public88 
abstract88	 
T88 
Subtract88 
(88 
T88 
a88  
,88  !
T88" #
b88$ %
)88% &
;88& '
public:: 
abstract::	 
T:: 
Multiply:: 
(:: 
T:: 
a::  
,::  !
T::" #
b::$ %
)::% &
;::& '
public<< 
abstract<<	 
T<< (
DistanceSquaredBetweenPoints<< 0
(<<0 1
T<<1 2
[<<2 3
]<<3 4
a<<5 6
,<<6 7
T<<8 9
[<<9 :
]<<: ;
b<<< =
)<<= >
;<<> ?
}?? 
}@@ î&
úD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\KdTree\KdTreeLib\Math\FloatMath.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
KdTree! '
.' (
Math( ,
{ 
[ 
Serializable 
] 
class 
	FloatMath 
: 
TypeMath 
< 
float !
>! "
{ 
public 
override	 
int 
Compare 
( 
float #
a$ %
,% &
float' ,
b- .
). /
{		 
return

 	
a


 
.

 
	CompareTo

 
(

 
b

 
)

 
;

 
} 
public 
override	 
bool 
AreEqual 
(  
float  %
a& '
,' (
float) .
b/ 0
)0 1
{ 
return 	
a
 
== 
b 
; 
} 
public 
override	 
float 
MinValue  
{ 
get 
{ 
return	 
float 
. 
MinValue 
; 
}  !
} 
public 
override	 
float 
MaxValue  
{ 
get 
{ 
return	 
float 
. 
MaxValue 
; 
}  !
} 
public 
override	 
float 
Zero 
{ 
get 
{ 
return	 
$num 
; 
} 
} 
public!! 
override!!	 
float!! 
NegativeInfinity!! (
{!!) *
get!!+ .
{!!/ 0
return!!1 7
float!!8 =
.!!= >
NegativeInfinity!!> N
;!!N O
}!!P Q
}!!R S
public## 
override##	 
float## 
PositiveInfinity## (
{##) *
get##+ .
{##/ 0
return##1 7
float##8 =
.##= >
PositiveInfinity##> N
;##N O
}##P Q
}##R S
public%% 
override%%	 
float%% 
Add%% 
(%% 
float%% !
a%%" #
,%%# $
float%%% *
b%%+ ,
)%%, -
{&& 
return'' 	
a''
 
+'' 
b'' 
;'' 
}(( 
public** 
override**	 
float** 
Subtract**  
(**  !
float**! &
a**' (
,**( )
float*** /
b**0 1
)**1 2
{++ 
return,, 	
a,,
 
-,, 
b,, 
;,, 
}-- 
public// 
override//	 
float// 
Multiply//  
(//  !
float//! &
a//' (
,//( )
float//* /
b//0 1
)//1 2
{00 
return11 	
a11
 
*11 
b11 
;11 
}22 
public44 
override44	 
float44 (
DistanceSquaredBetweenPoints44 4
(444 5
float445 :
[44: ;
]44; <
a44= >
,44> ?
float44@ E
[44E F
]44F G
b44H I
)44I J
{55 
float66 
distance66	 
=66 
Zero66 
;66 
int77 

dimensions77 
=77 
a77 
.77 
Length77 
;77 
for:: 
(:: 
var:: 
	dimension:: 
=:: 
$num:: 
;:: 
	dimension:: $
<::% &

dimensions::' 1
;::1 2
	dimension::3 <
++::< >
)::> ?
{;; 
float<< 	
distOnThisAxis<<
 
=<< 
Subtract<< #
(<<# $
a<<$ %
[<<% &
	dimension<<& /
]<</ 0
,<<0 1
b<<2 3
[<<3 4
	dimension<<4 =
]<<= >
)<<> ?
;<<? @
float== 	!
distOnThisAxisSquared==
 
===  !
Multiply==" *
(==* +
distOnThisAxis==+ 9
,==9 :
distOnThisAxis==; I
)==I J
;==J K
distance?? 
=?? 
Add?? 
(?? 
distance?? 
,?? !
distOnThisAxisSquared?? 2
)??2 3
;??3 4
}@@ 
returnBB 	
distanceBB
 
;BB 
}CC 
}DD 
}EE ≈
úD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\KdTree\KdTreeLib\IPriorityQueue.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
KdTree! '
{ 
	interface 

IPriorityQueue 
< 
TItem 
,  
	TPriority! *
>* +
{ 
void 
Enqueue 
( 
TItem 
item 
, 
	TPriority $
priority% -
)- .
;. /
TItem 
Dequeue 
( 
) 
; 
int		 
Count		 
{		 
get		 
;		 
}		 
}

 
} Æ
úD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\KdTree\KdTreeLib\Math\ITypeMath.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
KdTree! '
{ 
	interface 

	ITypeMath 
< 
T 
> 
{ 
int 
Compare 
( 
T 
a 
, 
T 
b 
) 
; 
T 
MinValue 
{ 
get 
; 
} 
T		 
MaxValue		 
{		 
get		 
;		 
}		 
T 
Min 
( 
T 	
a
 
, 
T 
b 
) 
; 
T 
Max 
( 
T 	
a
 
, 
T 
b 
) 
; 
bool 
AreEqual 
( 
T 
a 
, 
T 
b 
) 
; 
bool 
AreEqual 
( 
T 
[ 
] 
a 
, 
T 
[ 
] 
b 
) 
; 
T 
Add 
( 
T 	
a
 
, 
T 
b 
) 
; 
T 
Subtract 
( 
T 
a 
, 
T 
b 
) 
; 
T 
Multiply 
( 
T 
a 
, 
T 
b 
) 
; 
T 
Zero 
{	 

get 
; 
} 
T 
NegativeInfinity 
{ 
get 
; 
} 
T 
PositiveInfinity 
{ 
get 
; 
} 
T (
DistanceSquaredBetweenPoints  
(  !
T! "
[" #
]# $
a% &
,& '
T( )
[) *
]* +
b, -
)- .
;. /
}   
}!! ≥&
ùD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\KdTree\KdTreeLib\Math\DoubleMath.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
KdTree! '
.' (
Math( ,
{ 
[ 
Serializable 
] 
class 	

DoubleMath
 
: 
TypeMath 
<  
double  &
>& '
{ 
public 
override 
int 
Compare #
(# $
double$ *
a+ ,
,, -
double. 4
b5 6
)6 7
{		 	
return

 
a

 
.

 
	CompareTo

 
(

 
b

  
)

  !
;

! "
} 	
public 
override 
bool 
AreEqual %
(% &
double& ,
a- .
,. /
double0 6
b7 8
)8 9
{ 	
return 
a 
== 
b 
; 
} 	
public 
override 
double 
MinValue '
{ 	
get 
{ 
return 
double 
.  
MinValue  (
;( )
}* +
} 	
public 
override 
double 
MaxValue '
{ 	
get 
{ 
return 
double 
.  
MaxValue  (
;( )
}* +
} 	
public 
override 
double 
Zero #
{ 	
get 
{ 
return 
$num 
; 
} 
} 	
public!! 
override!! 
double!! 
NegativeInfinity!! /
{!!0 1
get!!2 5
{!!6 7
return!!8 >
double!!? E
.!!E F
NegativeInfinity!!F V
;!!V W
}!!X Y
}!!Z [
public## 
override## 
double## 
PositiveInfinity## /
{##0 1
get##2 5
{##6 7
return##8 >
double##? E
.##E F
PositiveInfinity##F V
;##V W
}##X Y
}##Z [
public%% 
override%% 
double%% 
Add%% "
(%%" #
double%%# )
a%%* +
,%%+ ,
double%%- 3
b%%4 5
)%%5 6
{&& 	
return'' 
a'' 
+'' 
b'' 
;'' 
}(( 	
public** 
override** 
double** 
Subtract** '
(**' (
double**( .
a**/ 0
,**0 1
double**2 8
b**9 :
)**: ;
{++ 	
return,, 
a,, 
-,, 
b,, 
;,, 
}-- 	
public// 
override// 
double// 
Multiply// '
(//' (
double//( .
a/// 0
,//0 1
double//2 8
b//9 :
)//: ;
{00 	
return11 
a11 
*11 
b11 
;11 
}22 	
public44 
override44 
double44 (
DistanceSquaredBetweenPoints44 ;
(44; <
double44< B
[44B C
]44C D
a44E F
,44F G
double44H N
[44N O
]44O P
b44Q R
)44R S
{55 	
double66 
distance66 
=66 
Zero66 "
;66" #
int77 

dimensions77 
=77 
a77 
.77 
Length77 %
;77% &
for:: 
(:: 
var:: 
	dimension:: 
=::  
$num::! "
;::" #
	dimension::$ -
<::. /

dimensions::0 :
;::: ;
	dimension::< E
++::E G
)::G H
{;; 
double<< 
distOnThisAxis<< %
=<<& '
Subtract<<( 0
(<<0 1
a<<1 2
[<<2 3
	dimension<<3 <
]<<< =
,<<= >
b<<? @
[<<@ A
	dimension<<A J
]<<J K
)<<K L
;<<L M
double== !
distOnThisAxisSquared== ,
===- .
Multiply==/ 7
(==7 8
distOnThisAxis==8 F
,==F G
distOnThisAxis==H V
)==V W
;==W X
distance?? 
=?? 
Add?? 
(?? 
distance?? '
,??' (!
distOnThisAxisSquared??) >
)??> ?
;??? @
}@@ 
returnBB 
distanceBB 
;BB 
}CC 	
}DD 
}EE 