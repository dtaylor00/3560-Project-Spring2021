†~
ïD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Polygon\Polygon.cs
	namespace-- 	
UnityEngine--
 
.-- 

ProBuilder--  
.--  !
Poly2Tri--! )
{--* +
class.. 
Polygon.. 
:.. 
Triangulatable.. 
{..  !
	protected// 
List// 
<// 
TriangulationPoint// #
>//# $
_points//% ,
=//- .
new/// 2
List//3 7
<//7 8
TriangulationPoint//8 J
>//J K
(//K L
)//L M
;//M N
	protected00 
List00 
<00 
TriangulationPoint00 #
>00# $
_steinerPoints00% 3
;003 4
	protected11 
List11 
<11 
Polygon11 
>11 
_holes11  
;11  !
	protected22 
List22 
<22 
DelaunayTriangle22 !
>22! "

_triangles22# -
;22- .
	protected33 
PolygonPoint33 
_last33 
;33 
public99 
Polygon99	 
(99 
IList99 
<99 
PolygonPoint99 $
>99$ %
points99& ,
)99- .
{99/ 0
if:: 
(:: 
points:: 
.:: 
Count:: 
<:: 
$num:: 
):: 
throw:: 
new:: "
ArgumentException::# 4
(::4 5
$str::5 S
,::S T
$str::U ]
)::] ^
;::^ _
if>> 
(>> 
points>> 
[>> 
$num>> 
]>> 
.>> 
Equals>> 
(>> 
points>> 
[>> 
points>> %
.>>% &
Count>>& +
->>, -
$num>>. /
]>>/ 0
)>>0 1
)>>1 2
points>>3 9
.>>9 :
RemoveAt>>: B
(>>B C
points>>C I
.>>I J
Count>>J O
->>P Q
$num>>R S
)>>S T
;>>T U
_points@@ 

.@@
 
AddRange@@ 
(@@ 
points@@ 
.@@ 
Cast@@ 
<@@  
TriangulationPoint@@  2
>@@2 3
(@@3 4
)@@4 5
)@@5 6
;@@6 7
}AA 
publicGG 
PolygonGG	 
(GG 
IEnumerableGG 
<GG 
PolygonPointGG *
>GG* +
pointsGG, 2
)GG3 4
:GG4 5
thisGG6 :
(GG: ;
(GG< =
pointsGG= C
asGGD F
IListGGG L
<GGL M
PolygonPointGGM Y
>GGY Z
)GGZ [
??GG\ ^
pointsGG_ e
.GGe f
ToArrayGGf m
(GGm n
)GGn o
)GGp q
{GGr s
}GGs t
publicMM 
PolygonMM	 
(MM 
paramsMM 
PolygonPointMM %
[MM% &
]MM& '
pointsMM( .
)MM/ 0
:MM1 2
thisMM3 7
(MM7 8
(MM8 9
IListMM9 >
<MM> ?
PolygonPointMM? K
>MMK L
)MML M
pointsMMM S
)MMS T
{MMU V
}MMW X
publicOO 
TriangulationModeOO	 
TriangulationModeOO ,
{OO- .
getOO/ 2
{OO3 4
returnOO5 ;
TriangulationModeOO< M
.OOM N
PolygonOON U
;OOU V
}OOW X
}OOY Z
publicQQ 
voidQQ	 
AddSteinerPointQQ 
(QQ 
TriangulationPointQQ 1
pointQQ2 7
)QQ8 9
{QQ: ;
ifRR 
(RR 
_steinerPointsRR 
==RR 
nullRR 
)RR 
_steinerPointsRR -
=RR. /
newRR0 3
ListRR4 8
<RR8 9
TriangulationPointRR9 K
>RRK L
(RRL M
)RRM N
;RRN O
_steinerPointsSS 
.SS 
AddSS 
(SS 
pointSS 
)SS 
;SS 
}TT 
publicVV 
voidVV	 
AddSteinerPointsVV 
(VV 
ListVV  $
<VV$ %
TriangulationPointVV% 7
>VV7 8
pointsVV9 ?
)VV@ A
{VVB C
ifWW 
(WW 
_steinerPointsWW 
==WW 
nullWW 
)WW 
_steinerPointsWW -
=WW. /
newWW0 3
ListWW4 8
<WW8 9
TriangulationPointWW9 K
>WWK L
(WWL M
)WWM N
;WWN O
_steinerPointsXX 
.XX 
AddRangeXX 
(XX 
pointsXX !
)XX! "
;XX" #
}YY 
public[[ 
void[[	 
ClearSteinerPoints[[  
([[  !
)[[! "
{[[# $
if\\ 
(\\ 
_steinerPoints\\ 
!=\\ 
null\\ 
)\\ 
_steinerPoints\\ -
.\\- .
Clear\\. 3
(\\3 4
)\\4 5
;\\5 6
}]] 
publiccc 
voidcc	 
AddHolecc 
(cc 
Polygoncc 
polycc #
)cc$ %
{cc& '
ifdd 
(dd 
_holesdd 
==dd 
nulldd 
)dd 
_holesdd 
=dd 
newdd  #
Listdd$ (
<dd( )
Polygondd) 0
>dd0 1
(dd1 2
)dd2 3
;dd3 4
_holesee 	
.ee	 

Addee
 
(ee 
polyee 
)ee 
;ee 
}hh 
publicoo 
voidoo	 
InsertPointAfteroo 
(oo 
PolygonPointoo  ,
pointoo- 2
,oo2 3
PolygonPointoo4 @
newPointooA I
)ooJ K
{ooL M
intqq 
indexqq 
=qq 
_pointsqq 
.qq 
IndexOfqq 
(qq 
pointqq $
)qq$ %
;qq% &
ifrr 
(rr 
indexrr 
==rr 
-rr 
$numrr 
)rr 
throwrr 
newrr 
ArgumentExceptionrr /
(rr/ 0
$str	rr0 É
,
rrÉ Ñ
$str
rrÖ å
)
rrå ç
;
rrç é
newPointss 
.ss 
Nextss 
=ss 
pointss 
.ss 
Nextss 
;ss 
newPointtt 
.tt 
Previoustt 
=tt 
pointtt 
;tt 
pointuu 
.uu 	
Nextuu	 
.uu 
Previousuu 
=uu 
newPointuu !
;uu! "
pointvv 
.vv 	
Nextvv	 
=vv 
newPointvv 
;vv 
_pointsww 

.ww
 
Insertww 
(ww 
indexww 
+ww 
$numww 
,ww 
newPointww %
)ww% &
;ww& '
}xx 
public~~ 
void~~	 
	AddPoints~~ 
(~~ 
IEnumerable~~ $
<~~$ %
PolygonPoint~~% 1
>~~1 2
list~~3 7
)~~8 9
{~~: ;
PolygonPoint 
first 
; 
foreach
ÄÄ 

(
ÄÄ 
PolygonPoint
ÄÄ 
p
ÄÄ 
in
ÄÄ 
list
ÄÄ "
)
ÄÄ" #
{
ÄÄ$ %
p
ÅÅ 
.
ÅÅ 
Previous
ÅÅ 
=
ÅÅ 
_last
ÅÅ 
;
ÅÅ 
if
ÇÇ 
(
ÇÇ 
_last
ÇÇ 
!=
ÇÇ 
null
ÇÇ 
)
ÇÇ 
{
ÇÇ 
p
ÉÉ 
.
ÉÉ 
Next
ÉÉ 
=
ÉÉ 
_last
ÉÉ 
.
ÉÉ 
Next
ÉÉ 
;
ÉÉ 
_last
ÑÑ 

.
ÑÑ
 
Next
ÑÑ 
=
ÑÑ 
p
ÑÑ 
;
ÑÑ 
}
ÖÖ 
_last
ÜÜ 	
=
ÜÜ
 
p
ÜÜ 
;
ÜÜ 
_points
áá 
.
áá 
Add
áá 
(
áá 
p
áá 
)
áá 
;
áá 
}
àà 
first
ââ 
=
ââ	 

(
ââ 
PolygonPoint
ââ 
)
ââ 
_points
ââ  
[
ââ  !
$num
ââ! "
]
ââ" #
;
ââ# $
_last
ää 
.
ää 	
Next
ää	 
=
ää 
first
ää 
;
ää 
first
ãã 
.
ãã 	
Previous
ãã	 
=
ãã 
_last
ãã 
;
ãã 
}
åå 
public
íí 
void
íí	 
AddPoint
íí 
(
íí 
PolygonPoint
íí $
p
íí% &
)
íí' (
{
íí) *
p
ìì 
.
ìì 
Previous
ìì 
=
ìì 
_last
ìì 
;
ìì 
p
îî 
.
îî 
Next
îî 	
=
îî
 
_last
îî 
.
îî 
Next
îî 
;
îî 
_last
ïï 
.
ïï 	
Next
ïï	 
=
ïï 
p
ïï 
;
ïï 
_points
ññ 

.
ññ
 
Add
ññ 
(
ññ 
p
ññ 
)
ññ 
;
ññ 
}
óó 
public
ùù 
void
ùù	 
RemovePoint
ùù 
(
ùù 
PolygonPoint
ùù '
p
ùù( )
)
ùù* +
{
ùù, -
PolygonPoint
ûû 
next
ûû 
,
ûû 
prev
ûû 
;
ûû 
next
†† 
=
†† 	
p
††
 
.
†† 
Next
†† 
;
†† 
prev
°° 
=
°° 	
p
°°
 
.
°° 
Previous
°° 
;
°° 
prev
¢¢ 
.
¢¢ 
Next
¢¢ 
=
¢¢ 
next
¢¢ 
;
¢¢ 
next
££ 
.
££ 
Previous
££ 
=
££ 
prev
££ 
;
££ 
_points
§§ 

.
§§
 
Remove
§§ 
(
§§ 
p
§§ 
)
§§ 
;
§§ 
}
•• 
public
ßß 
IList
ßß	 
<
ßß  
TriangulationPoint
ßß !
>
ßß! "
Points
ßß# )
{
ßß* +
get
ßß, /
{
ßß0 1
return
ßß2 8
_points
ßß9 @
;
ßß@ A
}
ßßB C
}
ßßD E
public
®® 
IList
®®	 
<
®® 
DelaunayTriangle
®® 
>
®®  
	Triangles
®®! *
{
®®+ ,
get
®®- 0
{
®®1 2
return
®®3 9

_triangles
®®: D
;
®®D E
}
®®F G
}
®®H I
public
©© 
IList
©©	 
<
©© 
Polygon
©© 
>
©© 
Holes
©© 
{
©© 
get
©©  #
{
©©$ %
return
©©& ,
_holes
©©- 3
;
©©3 4
}
©©5 6
}
©©6 7
public
´´ 
void
´´	 
AddTriangle
´´ 
(
´´ 
DelaunayTriangle
´´ +
t
´´, -
)
´´. /
{
´´0 1

_triangles
¨¨ 
.
¨¨ 
Add
¨¨ 
(
¨¨ 
t
¨¨ 
)
¨¨ 
;
¨¨ 
}
≠≠ 
public
ØØ 
void
ØØ	 
AddTriangles
ØØ 
(
ØØ 
IEnumerable
ØØ '
<
ØØ' (
DelaunayTriangle
ØØ( 8
>
ØØ8 9
list
ØØ: >
)
ØØ? @
{
ØØA B

_triangles
∞∞ 
.
∞∞ 
AddRange
∞∞ 
(
∞∞ 
list
∞∞ 
)
∞∞ 
;
∞∞ 
}
±± 
public
≥≥ 
void
≥≥	 
ClearTriangles
≥≥ 
(
≥≥ 
)
≥≥ 
{
≥≥  
if
¥¥ 
(
¥¥ 

_triangles
¥¥ 
!=
¥¥ 
null
¥¥ 
)
¥¥ 

_triangles
¥¥ %
.
¥¥% &
Clear
¥¥& +
(
¥¥+ ,
)
¥¥, -
;
¥¥- .
}
µµ 
public
ªª 
void
ªª	 
Prepare
ªª 
(
ªª "
TriangulationContext
ªª +
tcx
ªª, /
)
ªª0 1
{
ªª2 3
if
ºº 
(
ºº 

_triangles
ºº 
==
ºº 
null
ºº 
)
ºº 
{
ºº 

_triangles
ΩΩ 
=
ΩΩ 
new
ΩΩ 
List
ΩΩ 
<
ΩΩ 
DelaunayTriangle
ΩΩ *
>
ΩΩ* +
(
ΩΩ+ ,
_points
ΩΩ, 3
.
ΩΩ3 4
Count
ΩΩ4 9
)
ΩΩ9 :
;
ΩΩ: ;
}
ææ 
else
ææ 	
{
ææ
 

_triangles
øø 
.
øø 
Clear
øø 
(
øø 
)
øø 
;
øø 
}
¿¿ 
for
√√ 
(
√√ 
int
√√ 
i
√√ 
=
√√ 
$num
√√ 
;
√√ 
i
√√ 
<
√√ 
_points
√√ 
.
√√ 
Count
√√ $
-
√√% &
$num
√√' (
;
√√( )
i
√√* +
++
√√+ -
)
√√- .
tcx
√√/ 2
.
√√2 3
NewConstraint
√√3 @
(
√√@ A
_points
√√A H
[
√√H I
i
√√I J
]
√√J K
,
√√K L
_points
√√M T
[
√√T U
i
√√U V
+
√√W X
$num
√√Y Z
]
√√Z [
)
√√[ \
;
√√\ ]
tcx
ƒƒ 
.
ƒƒ 
NewConstraint
ƒƒ 
(
ƒƒ 
_points
ƒƒ 
[
ƒƒ 
$num
ƒƒ 
]
ƒƒ 
,
ƒƒ  
_points
ƒƒ! (
[
ƒƒ( )
_points
ƒƒ) 0
.
ƒƒ0 1
Count
ƒƒ1 6
-
ƒƒ7 8
$num
ƒƒ9 :
]
ƒƒ: ;
)
ƒƒ; <
;
ƒƒ< =
tcx
≈≈ 
.
≈≈ 
Points
≈≈ 
.
≈≈ 
AddRange
≈≈ 
(
≈≈ 
_points
≈≈ 
)
≈≈ 
;
≈≈  
if
»» 
(
»» 
_holes
»» 
!=
»» 
null
»» 
)
»» 
{
»» 
foreach
…… 
(
…… 
Polygon
…… 
p
…… 
in
…… 
_holes
……  
)
……  !
{
……" #
for
   
(
  	 

int
  
 
i
   
=
   
$num
   
;
   
i
   
<
   
p
   
.
   
_points
   "
.
  " #
Count
  # (
-
  ) *
$num
  + ,
;
  , -
i
  . /
++
  / 1
)
  1 2
tcx
  3 6
.
  6 7
NewConstraint
  7 D
(
  D E
p
  E F
.
  F G
_points
  G N
[
  N O
i
  O P
]
  P Q
,
  Q R
p
  S T
.
  T U
_points
  U \
[
  \ ]
i
  ] ^
+
  _ `
$num
  a b
]
  b c
)
  c d
;
  d e
tcx
ÀÀ 
.
ÀÀ 	
NewConstraint
ÀÀ	 
(
ÀÀ 
p
ÀÀ 
.
ÀÀ 
_points
ÀÀ  
[
ÀÀ  !
$num
ÀÀ! "
]
ÀÀ" #
,
ÀÀ# $
p
ÀÀ% &
.
ÀÀ& '
_points
ÀÀ' .
[
ÀÀ. /
p
ÀÀ/ 0
.
ÀÀ0 1
_points
ÀÀ1 8
.
ÀÀ8 9
Count
ÀÀ9 >
-
ÀÀ? @
$num
ÀÀA B
]
ÀÀB C
)
ÀÀC D
;
ÀÀD E
tcx
ÃÃ 
.
ÃÃ 	
Points
ÃÃ	 
.
ÃÃ 
AddRange
ÃÃ 
(
ÃÃ 
p
ÃÃ 
.
ÃÃ 
_points
ÃÃ "
)
ÃÃ" #
;
ÃÃ# $
}
ÕÕ 
}
ŒŒ 
if
–– 
(
–– 
_steinerPoints
–– 
!=
–– 
null
–– 
)
–– 
{
––  
tcx
—— 
.
—— 
Points
—— 
.
—— 
AddRange
—— 
(
—— 
_steinerPoints
—— &
)
——& '
;
——' (
}
““ 
}
”” 
}
’’ 
}÷÷ ◊
üD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Orientation.cs
	namespace   	
UnityEngine  
 
.   

ProBuilder    
.    !
Poly2Tri  ! )
{  * +
enum!! 
Orientation!! 
{!! 
CW"" 
,"" 
CCW"" 	
,""	 

	Collinear"" 
}## 
}$$ ∑:
©D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Util\PolygonGenerator.cs
	namespace"" 	
UnityEngine""
 
."" 

ProBuilder""  
.""  !
Poly2Tri""! )
{""* +
class## 
PolygonGenerator## 
{## 
static$$ 
readonly$$	 
System$$ 
.$$ 
Random$$ 
RNG$$  #
=$$$ %
new$$& )
System$$* 0
.$$0 1
Random$$1 7
($$7 8
)$$8 9
;$$9 :
private&& 	
static&&
 
double&& 
PI_2&& 
=&& 
$num&& "
*&&# $
Math&&% )
.&&) *
PI&&* ,
;&&, -
public(( 
static((	 
Polygon(( 
RandomCircleSweep(( )
((() *
double((* 0
scale((1 6
,((6 7
int((8 ;
vertexCount((< G
)((G H
{((I J
PolygonPoint)) 
point)) 
;)) 
PolygonPoint** 
[** 
]** 
points** 
;** 
double++ 	
radius++
 
=++ 
scale++ 
/++ 
$num++ 
;++ 
points-- 	
=--
 
new-- 
PolygonPoint-- 
[-- 
vertexCount-- (
]--( )
;--) *
for.. 
(.. 
int.. 
i.. 
=.. 
$num.. 
;.. 
i.. 
<.. 
vertexCount.. "
;.." #
i..$ %
++..% '
)..' (
{..) *
do// 
{// 
if00 
(00 	
i00	 

%00 
$num00 
==00 
$num00 
)00 
{00 
radius11 
+=11 
scale11 
/11 
$num11 
*11 
(11 
$num11  
-11! "
RNG11# &
.11& '

NextDouble11' 1
(111 2
)112 3
)113 4
;114 5
}22 
else22 
if22 
(22 
i22 
%22 
$num22 
==22 
$num22 
)22 
{22 
radius33 
+=33 
scale33 
/33 
$num33 
*33 
(33 
$num33  
-33! "
RNG33# &
.33& '

NextDouble33' 1
(331 2
)332 3
)333 4
;334 5
}44 
else44 
{44 
radius55 
+=55 
$num55 
*55 
scale55 
/55 
vertexCount55 (
*55) *
(55+ ,
$num55, /
-550 1
RNG552 5
.555 6

NextDouble556 @
(55@ A
)55A B
)55B C
;55C D
}66 
radius77 
=77 
radius77 
>77 
scale77 
/77 
$num77  
?77! "
scale77# (
/77) *
$num77+ ,
:77- .
radius77/ 5
;775 6
radius88 
=88 
radius88 
<88 
scale88 
/88 
$num88 !
?88" #
scale88$ )
/88* +
$num88, .
:88/ 0
radius881 7
;887 8
}99 
while99 
(99 
radius99 
<99 
scale99 
/99 
$num99  
||99! #
radius99$ *
>99+ ,
scale99- 2
/993 4
$num995 6
)996 7
;997 8
point:: 	
=::
 
new:: 
PolygonPoint:: 
(:: 
radius:: #
*::$ %
Math::& *
.::* +
Cos::+ .
(::. /
(::/ 0
PI_2::0 4
*::5 6
i::7 8
)::8 9
/::: ;
vertexCount::< G
)::G H
,::H I
radius;; 
*;; 
Math;; 
.;; 
Sin;; 
(;; 
(;; 
PI_2;; #
*;;$ %
i;;& '
);;' (
/;;) *
vertexCount;;+ 6
);;6 7
,;;7 8
i;;9 :
);;: ;
;;;; <
points<< 

[<<
 
i<< 
]<< 
=<< 
point<< 
;<< 
}== 
return>> 	
new>>
 
Polygon>> 
(>> 
points>> 
)>> 
;>> 
}?? 
publicAA 
staticAA	 
PolygonAA 
RandomCircleSweep2AA *
(AA* +
doubleAA+ 1
scaleAA2 7
,AA7 8
intAA9 <
vertexCountAA= H
)AAH I
{AAJ K
PolygonPointBB 
pointBB 
;BB 
PolygonPointCC 
[CC 
]CC 
pointsCC 
;CC 
doubleDD 	
radiusDD
 
=DD 
scaleDD 
/DD 
$numDD 
;DD 
pointsFF 	
=FF
 
newFF 
PolygonPointFF 
[FF 
vertexCountFF (
]FF( )
;FF) *
forGG 
(GG 
intGG 
iGG 
=GG 
$numGG 
;GG 
iGG 
<GG 
vertexCountGG "
;GG" #
iGG$ %
++GG% '
)GG' (
{GG) *
doHH 
{HH 
radiusII 
+=II 
scaleII 
/II 
$numII 
*II 
(II 
$numII 
-II  !
RNGII" %
.II% &

NextDoubleII& 0
(II0 1
)II1 2
)II2 3
;II3 4
radiusJJ 
=JJ 
radiusJJ 
>JJ 
scaleJJ 
/JJ 
$numJJ  
?JJ! "
scaleJJ# (
/JJ) *
$numJJ+ ,
:JJ- .
radiusJJ/ 5
;JJ5 6
radiusKK 
=KK 
radiusKK 
<KK 
scaleKK 
/KK 
$numKK !
?KK" #
scaleKK$ )
/KK* +
$numKK, .
:KK/ 0
radiusKK1 7
;KK7 8
}LL 
whileLL 
(LL 
radiusLL 
<LL 
scaleLL 
/LL 
$numLL  
||LL! #
radiusLL$ *
>LL+ ,
scaleLL- 2
/LL3 4
$numLL5 6
)LL6 7
;LL7 8
pointMM 	
=MM
 
newMM 
PolygonPointMM 
(MM 
radiusMM #
*MM$ %
MathMM& *
.MM* +
CosMM+ .
(MM. /
(MM/ 0
PI_2MM0 4
*MM5 6
iMM7 8
)MM8 9
/MM: ;
vertexCountMM< G
)MMG H
,MMH I
radiusNN 
*NN 
MathNN 
.NN 
SinNN 
(NN 
(NN 
PI_2NN #
*NN$ %
iNN& '
)NN' (
/NN) *
vertexCountNN+ 6
)NN6 7
,NN7 8
iNN9 :
)NN: ;
;NN; <
pointsOO 

[OO
 
iOO 
]OO 
=OO 
pointOO 
;OO 
}PP 
returnQQ 	
newQQ
 
PolygonQQ 
(QQ 
pointsQQ 
)QQ 
;QQ 
}RR 
}SS 
}TT ﬁ
°D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Sets\PointSet.cs
	namespace"" 	
UnityEngine""
 
."" 

ProBuilder""  
.""  !
Poly2Tri""! )
{""* +
class## 
PointSet## 
:## 
Triangulatable##  
{##! "
public$$ 
IList$$	 
<$$ 
TriangulationPoint$$ !
>$$! "
Points$$# )
{$$* +
get$$, /
;$$/ 0
private$$1 8
set$$9 <
;$$< =
}$$> ?
public%% 
IList%%	 
<%% 
DelaunayTriangle%% 
>%%  
	Triangles%%! *
{%%+ ,
get%%- 0
;%%0 1
private%%2 9
set%%: =
;%%= >
}%%? @
public'' 
PointSet''	 
('' 
List'' 
<'' 
TriangulationPoint'' )
>'') *
points''+ 1
)''1 2
{''3 4
Points(( 	
=((
 
new(( 
List(( 
<(( 
TriangulationPoint(( '
>((' (
(((( )
points(() /
)((/ 0
;((0 1
})) 
public++ 
virtual++	 
TriangulationMode++ "
TriangulationMode++# 4
{++5 6
get++7 :
{++; <
return++= C
TriangulationMode++D U
.++U V
Unconstrained++V c
;++c d
}++e f
}++f g
public-- 
void--	 
AddTriangle-- 
(-- 
DelaunayTriangle-- *
t--+ ,
)--, -
{--. /
	Triangles.. 
... 
Add.. 
(.. 
t.. 
).. 
;.. 
}// 
public11 
void11	 
AddTriangles11 
(11 
IEnumerable11 &
<11& '
DelaunayTriangle11' 7
>117 8
list119 =
)11= >
{11? @
foreach22 

(22 
var22 
tri22 
in22 
list22 
)22 
	Triangles22 (
.22( )
Add22) ,
(22, -
tri22- 0
)220 1
;221 2
}33 
public55 
void55	 
ClearTriangles55 
(55 
)55 
{55  
	Triangles66 
.66 
Clear66 
(66 
)66 
;66 
}77 
public99 
virtual99	 
void99 
Prepare99 
(99  
TriangulationContext99 2
tcx993 6
)996 7
{998 9
if:: 
(:: 
	Triangles:: 
==:: 
null:: 
):: 
{:: 
	Triangles;; 
=;; 
new;; 
List;; 
<;; 
DelaunayTriangle;; )
>;;) *
(;;* +
Points;;+ 1
.;;1 2
Count;;2 7
);;7 8
;;;8 9
}<< 
else<< 	
{<<
 
	Triangles== 
.== 
Clear== 
(== 
)== 
;== 
}>> 
tcx?? 
.?? 
Points?? 
.?? 
AddRange?? 
(?? 
Points?? 
)?? 
;?? 
}@@ 
}AA 
}BB öE
•D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\TriangulationUtil.cs
	namespace   	
UnityEngine  
 
.   

ProBuilder    
.    !
Poly2Tri  ! )
{  * +
class$$ 
TriangulationUtil$$ 
{$$ 
public%% 
static%%	 
double%% 
EPSILON%% 
=%%  
$num%%! &
;%%& '
public>> 
static>>	 
bool>> 
SmartIncircle>> "
(>>" #
TriangulationPoint>>$ 6
pa>>7 9
,>>9 :
TriangulationPoint>>; M
pb>>N P
,>>P Q
TriangulationPoint>>R d
pc>>e g
,>>g h
TriangulationPoint>>i {
pd>>| ~
)	>> Ä
{
>>Å Ç
double?? 	
pdx??
 
=?? 
pd?? 
.?? 
X?? 
;?? 
double@@ 	
pdy@@
 
=@@ 
pd@@ 
.@@ 
Y@@ 
;@@ 
doubleAA 	
adxAA
 
=AA 
paAA 
.AA 
XAA 
-AA 
pdxAA 
;AA 
doubleBB 	
adyBB
 
=BB 
paBB 
.BB 
YBB 
-BB 
pdyBB 
;BB 
doubleCC 	
bdxCC
 
=CC 
pbCC 
.CC 
XCC 
-CC 
pdxCC 
;CC 
doubleDD 	
bdyDD
 
=DD 
pbDD 
.DD 
YDD 
-DD 
pdyDD 
;DD 
doubleFF 	
adxbdyFF
 
=FF 
adxFF 
*FF 
bdyFF 
;FF 
doubleGG 	
bdxadyGG
 
=GG 
bdxGG 
*GG 
adyGG 
;GG 
doubleHH 	
oabdHH
 
=HH 
adxbdyHH 
-HH 
bdxadyHH  
;HH  !
ifJJ 
(JJ 
oabdJJ 
<=JJ 
$numJJ 
)JJ 
returnJJ 
falseJJ 
;JJ 
doubleLL 	
cdxLL
 
=LL 
pcLL 
.LL 
XLL 
-LL 
pdxLL 
;LL 
doubleMM 	
cdyMM
 
=MM 
pcMM 
.MM 
YMM 
-MM 
pdyMM 
;MM 
doubleOO 	
cdxadyOO
 
=OO 
cdxOO 
*OO 
adyOO 
;OO 
doublePP 	
adxcdyPP
 
=PP 
adxPP 
*PP 
cdyPP 
;PP 
doubleQQ 	
ocadQQ
 
=QQ 
cdxadyQQ 
-QQ 
adxcdyQQ  
;QQ  !
ifSS 
(SS 
ocadSS 
<=SS 
$numSS 
)SS 
returnSS 
falseSS 
;SS 
doubleUU 	
bdxcdyUU
 
=UU 
bdxUU 
*UU 
cdyUU 
;UU 
doubleVV 	
cdxbdyVV
 
=VV 
cdxVV 
*VV 
bdyVV 
;VV 
doubleXX 	
aliftXX
 
=XX 
adxXX 
*XX 
adxXX 
+XX 
adyXX !
*XX" #
adyXX$ '
;XX' (
doubleYY 	
bliftYY
 
=YY 
bdxYY 
*YY 
bdxYY 
+YY 
bdyYY !
*YY" #
bdyYY$ '
;YY' (
doubleZZ 	
cliftZZ
 
=ZZ 
cdxZZ 
*ZZ 
cdxZZ 
+ZZ 
cdyZZ !
*ZZ" #
cdyZZ$ '
;ZZ' (
double\\ 	
det\\
 
=\\ 
alift\\ 
*\\ 
(\\ 
bdxcdy\\ 
-\\  !
cdxbdy\\" (
)\\( )
+\\* +
blift\\, 1
*\\2 3
ocad\\4 8
+\\9 :
clift\\; @
*\\A B
oabd\\C G
;\\G H
return^^ 	
det^^
 
>^^ 
$num^^ 
;^^ 
}__ 
publicaa 
staticaa	 
boolaa 

InScanAreaaa 
(aa  
TriangulationPointaa! 3
paaa4 6
,aa6 7
TriangulationPointaa8 J
pbaaK M
,aaM N
TriangulationPointaaO a
pcaab d
,aad e
TriangulationPointaaf x
pdaay {
)aa| }
{aa~ 
doublebb 	
pdxbb
 
=bb 
pdbb 
.bb 
Xbb 
;bb 
doublecc 	
pdycc
 
=cc 
pdcc 
.cc 
Ycc 
;cc 
doubledd 	
adxdd
 
=dd 
padd 
.dd 
Xdd 
-dd 
pdxdd 
;dd 
doubleee 	
adyee
 
=ee 
paee 
.ee 
Yee 
-ee 
pdyee 
;ee 
doubleff 	
bdxff
 
=ff 
pbff 
.ff 
Xff 
-ff 
pdxff 
;ff 
doublegg 	
bdygg
 
=gg 
pbgg 
.gg 
Ygg 
-gg 
pdygg 
;gg 
doubleii 	
adxbdyii
 
=ii 
adxii 
*ii 
bdyii 
;ii 
doublejj 	
bdxadyjj
 
=jj 
bdxjj 
*jj 
adyjj 
;jj 
doublekk 	
oabdkk
 
=kk 
adxbdykk 
-kk 
bdxadykk  
;kk  !
ifmm 
(mm 
oabdmm 
<=mm 
$nummm 
)mm 
{mm 
returnnn 

falsenn 
;nn 
}oo 
doubleqq 	
cdxqq
 
=qq 
pcqq 
.qq 
Xqq 
-qq 
pdxqq 
;qq 
doublerr 	
cdyrr
 
=rr 
pcrr 
.rr 
Yrr 
-rr 
pdyrr 
;rr 
doublett 	
cdxadytt
 
=tt 
cdxtt 
*tt 
adytt 
;tt 
doubleuu 	
adxcdyuu
 
=uu 
adxuu 
*uu 
cdyuu 
;uu 
doublevv 	
ocadvv
 
=vv 
cdxadyvv 
-vv 
adxcdyvv  
;vv  !
ifxx 
(xx 
ocadxx 
<=xx 
$numxx 
)xx 
{xx 
returnyy 

falseyy 
;yy 
}zz 
return{{ 	
true{{
 
;{{ 
}|| 
public
ÑÑ 
static
ÑÑ	 
Orientation
ÑÑ 
Orient2d
ÑÑ $
(
ÑÑ$ % 
TriangulationPoint
ÑÑ& 8
pa
ÑÑ9 ;
,
ÑÑ; < 
TriangulationPoint
ÑÑ= O
pb
ÑÑP R
,
ÑÑR S 
TriangulationPoint
ÑÑT f
pc
ÑÑg i
)
ÑÑj k
{
ÑÑl m
double
ÖÖ 	
detleft
ÖÖ
 
=
ÖÖ 
(
ÖÖ 
pa
ÖÖ 
.
ÖÖ 
X
ÖÖ 
-
ÖÖ 
pc
ÖÖ 
.
ÖÖ 
X
ÖÖ  
)
ÖÖ  !
*
ÖÖ" #
(
ÖÖ$ %
pb
ÖÖ% '
.
ÖÖ' (
Y
ÖÖ( )
-
ÖÖ* +
pc
ÖÖ, .
.
ÖÖ. /
Y
ÖÖ/ 0
)
ÖÖ0 1
;
ÖÖ1 2
double
ÜÜ 	
detright
ÜÜ
 
=
ÜÜ 
(
ÜÜ 
pa
ÜÜ 
.
ÜÜ 
Y
ÜÜ 
-
ÜÜ 
pc
ÜÜ 
.
ÜÜ  
Y
ÜÜ  !
)
ÜÜ! "
*
ÜÜ# $
(
ÜÜ% &
pb
ÜÜ& (
.
ÜÜ( )
X
ÜÜ) *
-
ÜÜ+ ,
pc
ÜÜ- /
.
ÜÜ/ 0
X
ÜÜ0 1
)
ÜÜ1 2
;
ÜÜ2 3
double
áá 	
val
áá
 
=
áá 
detleft
áá 
-
áá 
detright
áá "
;
áá" #
if
àà 
(
àà 
val
àà 

>
àà 
-
àà 
EPSILON
àà 
&&
àà 
val
àà 
<
àà 
EPSILON
àà &
)
àà& '
{
àà( )
return
ââ 

Orientation
ââ 
.
ââ 
	Collinear
ââ  
;
ââ  !
}
ää 
else
ää 	
if
ää
 
(
ää 
val
ää 
>
ää 
$num
ää 
)
ää 
{
ää 
return
ãã 

Orientation
ãã 
.
ãã 
CCW
ãã 
;
ãã 
}
åå 
return
çç 	
Orientation
çç
 
.
çç 
CW
çç 
;
çç 
}
éé 
}
èè 
}êê ¬
≥D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Delaunay\Sweep\DTSweepEdgeEvent.cs
	namespace## 	
UnityEngine##
 
.## 

ProBuilder##  
.##  !
Poly2Tri##! )
{##* +
class$$ 
DTSweepEdgeEvent$$ 
{$$ 
public%% 
DTSweepConstraint%%	 
ConstrainedEdge%% *
;%%* +
public&& 
bool&&	 
Right&& 
;&& 
}'' 
}(( Àm
±D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Delaunay\Sweep\DTSweepContext.cs
	namespace   	
UnityEngine  
 
.   

ProBuilder    
.    !
Poly2Tri  ! )
{  * +
class&& 
DTSweepContext&& 
:&&  
TriangulationContext&& ,
{&&- .
private)) 	
readonly))
 
float)) 
ALPHA)) 
=))  
$num))! %
;))% &
public++ 
AdvancingFront++	 
Front++ !
;++! "
public,, 
TriangulationPoint,,	 
Head,,  
{,,! "
get,,# &
;,,& '
set,,( +
;,,+ ,
},,- .
public-- 
TriangulationPoint--	 
Tail--  
{--! "
get--# &
;--& '
set--( +
;--+ ,
}--- .
public// 
DTSweepBasin//	 
Basin// 
=//$ %
new//& )
DTSweepBasin//* 6
(//6 7
)//7 8
;//8 9
public00 
DTSweepEdgeEvent00	 
	EdgeEvent00 #
=00$ %
new00& )
DTSweepEdgeEvent00* :
(00: ;
)00; <
;00< =
private22 	"
DTSweepPointComparator22
  
_comparator22! ,
=22- .
new22/ 2"
DTSweepPointComparator223 I
(22I J
)22J K
;22K L
public44 
DTSweepContext44	 
(44 
)44 
{44 
Clear55 
(55 	
)55	 

;55
 
}66 
public88 
override88	 
bool88 
IsDebugEnabled88 %
{88& '
get88( +
{88, -
return99 	
base99
 
.99 
IsDebugEnabled99 
;99 
}:: 
	protected:: 
set:: 
{:: 
if;; 
(;; 
value;; 
&&;; 
DebugContext;; 
==;; 
null;;  $
);;$ %
DebugContext;;& 2
=;;3 4
new;;5 8
DTSweepDebugContext;;9 L
(;;L M
this;;M Q
);;Q R
;;;R S
base<< 
.<< 
IsDebugEnabled<< 
=<< 
value<< 
;<< 
}== 
}== 
public?? 
void??	 
RemoveFromList?? 
(?? 
DelaunayTriangle?? .
triangle??/ 7
)??8 9
{??: ;
	Triangles@@ 
.@@ 
Remove@@ 
(@@ 
triangle@@ 
)@@ 
;@@ 
}JJ 
publicLL 
voidLL	 
	MeshCleanLL 
(LL 
DelaunayTriangleLL )
triangleLL* 2
)LL3 4
{LL5 6
MeshCleanReqMM 
(MM 
triangleMM 
)MM 
;MM 
}NN 
privatePP 	
voidPP
 
MeshCleanReqPP 
(PP 
DelaunayTrianglePP -
trianglePP. 6
)PP7 8
{PP9 :
ifQQ 
(QQ 
triangleQQ 
!=QQ 
nullQQ 
&&QQ 
!QQ 
triangleQQ $
.QQ$ %

IsInteriorQQ% /
)QQ/ 0
{QQ1 2
triangleRR 
.RR 

IsInteriorRR 
=RR 
trueRR 
;RR 
TriangulatableSS 
.SS 
AddTriangleSS 
(SS 
triangleSS '
)SS' (
;SS( )
forUU 
(UU 	
intUU	 
iUU 
=UU 
$numUU 
;UU 
iUU 
<UU 
$numUU 
;UU 
iUU 
++UU 
)UU 
ifVV 
(VV 
!VV 	
triangleVV	 
.VV 
EdgeIsConstrainedVV #
[VV# $
iVV$ %
]VV% &
)VV& '
{WW 
MeshCleanReqXX 
(XX 
triangleXX 
.XX 
	NeighborsXX $
[XX$ %
iXX% &
]XX& '
)XX' (
;XX( )
}YY 
}ZZ 
}[[ 
public]] 
override]]	 
void]] 
Clear]] 
(]] 
)]] 
{]]  
base^^ 
.^^ 
Clear^^ 
(^^ 
)^^ 
;^^ 
	Triangles__ 
.__ 
Clear__ 
(__ 
)__ 
;__ 
}`` 
publicbb 
voidbb	 
AddNodebb 
(bb 
AdvancingFrontNodebb )
nodebb* .
)bb/ 0
{bb1 2
Frontee 
.ee 	
AddNodeee	 
(ee 
nodeee 
)ee 
;ee 
}ff 
publichh 
voidhh	 

RemoveNodehh 
(hh 
AdvancingFrontNodehh ,
nodehh- 1
)hh2 3
{hh4 5
Frontkk 
.kk 	

RemoveNodekk	 
(kk 
nodekk 
)kk 
;kk 
}ll 
publicnn 
AdvancingFrontNodenn	 

LocateNodenn &
(nn& '
TriangulationPointnn( :
pointnn; @
)nnA B
{nnC D
returnoo 	
Frontoo
 
.oo 

LocateNodeoo 
(oo 
pointoo  
)oo  !
;oo! "
}pp 
publicrr 
voidrr	  
CreateAdvancingFrontrr "
(rr" #
)rr# $
{rr% &
AdvancingFrontNodess 
headss 
,ss 
tailss  
,ss  !
middless" (
;ss( )
DelaunayTriangleuu 
	iTriangleuu 
=uu 
newuu  #
DelaunayTriangleuu$ 4
(uu4 5
Pointsuu5 ;
[uu; <
$numuu< =
]uu= >
,uu> ?
Tailuu@ D
,uuD E
HeaduuF J
)uuJ K
;uuK L
	Trianglesvv 
.vv 
Addvv 
(vv 
	iTrianglevv 
)vv 
;vv 
headxx 
=xx 	
newxx
 
AdvancingFrontNodexx  
(xx  !
	iTrianglexx! *
.xx* +
Pointsxx+ 1
[xx1 2
$numxx2 3
]xx3 4
)xx4 5
;xx5 6
headyy 
.yy 
Triangleyy 
=yy 
	iTriangleyy 
;yy 
middlezz 	
=zz
 
newzz 
AdvancingFrontNodezz "
(zz" #
	iTrianglezz# ,
.zz, -
Pointszz- 3
[zz3 4
$numzz4 5
]zz5 6
)zz6 7
;zz7 8
middle{{ 	
.{{	 

Triangle{{
 
={{ 
	iTriangle{{ 
;{{ 
tail|| 
=|| 	
new||
 
AdvancingFrontNode||  
(||  !
	iTriangle||! *
.||* +
Points||+ 1
[||1 2
$num||2 3
]||3 4
)||4 5
;||5 6
Front~~ 
=~~	 

new~~ 
AdvancingFront~~ 
(~~ 
head~~ "
,~~" #
tail~~$ (
)~~( )
;~~) *
Front 
. 	
AddNode	 
( 
middle 
) 
; 
Front
ÉÉ 
.
ÉÉ 	
Head
ÉÉ	 
.
ÉÉ 
Next
ÉÉ 
=
ÉÉ 
middle
ÉÉ 
;
ÉÉ 
middle
ÑÑ 	
.
ÑÑ	 

Next
ÑÑ
 
=
ÑÑ 
Front
ÑÑ 
.
ÑÑ 
Tail
ÑÑ 
;
ÑÑ 
middle
ÖÖ 	
.
ÖÖ	 

Prev
ÖÖ
 
=
ÖÖ 
Front
ÖÖ 
.
ÖÖ 
Head
ÖÖ 
;
ÖÖ 
Front
ÜÜ 
.
ÜÜ 	
Tail
ÜÜ	 
.
ÜÜ 
Prev
ÜÜ 
=
ÜÜ 
middle
ÜÜ 
;
ÜÜ 
}
áá 
public
ëë 
void
ëë	  
MapTriangleToNodes
ëë  
(
ëë  !
DelaunayTriangle
ëë" 2
t
ëë3 4
)
ëë5 6
{
ëë7 8
for
íí 
(
íí 
int
íí 
i
íí 
=
íí 
$num
íí 
;
íí 
i
íí 
<
íí 
$num
íí 
;
íí 
i
íí 
++
íí 
)
íí 
if
ìì 
(
ìì 
t
ìì 
.
ìì 	
	Neighbors
ìì	 
[
ìì 
i
ìì 
]
ìì 
==
ìì 
null
ìì 
)
ìì 
{
îî  
AdvancingFrontNode
ïï 
n
ïï 
=
ïï 
Front
ïï  
.
ïï  !
LocatePoint
ïï! ,
(
ïï, -
t
ïï- .
.
ïï. /
PointCWFrom
ïï/ :
(
ïï: ;
t
ïï; <
.
ïï< =
Points
ïï= C
[
ïïC D
i
ïïD E
]
ïïE F
)
ïïF G
)
ïïG H
;
ïïH I
if
ññ 
(
ññ 
n
ññ 	
!=
ññ
 
null
ññ 
)
ññ 
n
ññ 
.
ññ 
Triangle
ññ 
=
ññ 
t
ññ  !
;
ññ! "
}
óó 
}
òò 
public
öö 
override
öö	 
void
öö "
PrepareTriangulation
öö +
(
öö+ ,
Triangulatable
öö- ;
t
öö< =
)
öö> ?
{
öö@ A
base
õõ 
.
õõ "
PrepareTriangulation
õõ 
(
õõ 
t
õõ 
)
õõ 
;
õõ  
double
ùù 	
xmax
ùù
 
,
ùù 
xmin
ùù 
;
ùù 
double
ûû 	
ymax
ûû
 
,
ûû 
ymin
ûû 
;
ûû 
xmax
†† 
=
†† 	
xmin
††
 
=
†† 
Points
†† 
[
†† 
$num
†† 
]
†† 
.
†† 
X
†† 
;
†† 
ymax
°° 
=
°° 	
ymin
°°
 
=
°° 
Points
°° 
[
°° 
$num
°° 
]
°° 
.
°° 
Y
°° 
;
°° 
foreach
§§ 

(
§§  
TriangulationPoint
§§ 
p
§§  
in
§§! #
Points
§§$ *
)
§§* +
{
§§, -
if
•• 
(
•• 
p
•• 	
.
••	 

X
••
 
>
•• 
xmax
•• 
)
•• 
xmax
•• 
=
•• 
p
•• 
.
•• 
X
•• 
;
•• 
if
¶¶ 
(
¶¶ 
p
¶¶ 	
.
¶¶	 

X
¶¶
 
<
¶¶ 
xmin
¶¶ 
)
¶¶ 
xmin
¶¶ 
=
¶¶ 
p
¶¶ 
.
¶¶ 
X
¶¶ 
;
¶¶ 
if
ßß 
(
ßß 
p
ßß 	
.
ßß	 

Y
ßß
 
>
ßß 
ymax
ßß 
)
ßß 
ymax
ßß 
=
ßß 
p
ßß 
.
ßß 
Y
ßß 
;
ßß 
if
®® 
(
®® 
p
®® 	
.
®®	 

Y
®®
 
<
®® 
ymin
®® 
)
®® 
ymin
®® 
=
®® 
p
®® 
.
®® 
Y
®® 
;
®® 
}
©© 
double
´´ 	
deltaX
´´
 
=
´´ 
ALPHA
´´ 
*
´´ 
(
´´ 
xmax
´´  
-
´´! "
xmin
´´# '
)
´´' (
;
´´( )
double
¨¨ 	
deltaY
¨¨
 
=
¨¨ 
ALPHA
¨¨ 
*
¨¨ 
(
¨¨ 
ymax
¨¨  
-
¨¨! "
ymin
¨¨# '
)
¨¨' (
;
¨¨( ) 
TriangulationPoint
≠≠ 
p1
≠≠ 
=
≠≠ 
new
≠≠  
TriangulationPoint
≠≠ 1
(
≠≠1 2
xmax
≠≠2 6
+
≠≠7 8
deltaX
≠≠9 ?
,
≠≠? @
ymin
≠≠A E
-
≠≠F G
deltaY
≠≠H N
,
≠≠N O
-
≠≠P Q
$num
≠≠Q R
)
≠≠R S
;
≠≠S T 
TriangulationPoint
ÆÆ 
p2
ÆÆ 
=
ÆÆ 
new
ÆÆ  
TriangulationPoint
ÆÆ 1
(
ÆÆ1 2
xmin
ÆÆ2 6
-
ÆÆ7 8
deltaX
ÆÆ9 ?
,
ÆÆ? @
ymin
ÆÆA E
-
ÆÆF G
deltaY
ÆÆH N
,
ÆÆN O
-
ÆÆP Q
$num
ÆÆQ R
)
ÆÆR S
;
ÆÆS T
Head
∞∞ 
=
∞∞ 	
p1
∞∞
 
;
∞∞ 
Tail
±± 
=
±± 	
p2
±±
 
;
±± 
Points
µµ 	
.
µµ	 

Sort
µµ
 
(
µµ 
_comparator
µµ 
)
µµ 
;
µµ 
}
∑∑ 
public
∫∫ 
void
∫∫	 #
FinalizeTriangulation
∫∫ #
(
∫∫# $
)
∫∫$ %
{
∫∫& '
Triangulatable
ªª 
.
ªª 
AddTriangles
ªª 
(
ªª 
	Triangles
ªª (
)
ªª( )
;
ªª) *
	Triangles
ºº 
.
ºº 
Clear
ºº 
(
ºº 
)
ºº 
;
ºº 
}
ΩΩ 
public
øø 
override
øø	 %
TriangulationConstraint
øø )
NewConstraint
øø* 7
(
øø7 8 
TriangulationPoint
øø9 K
a
øøL M
,
øøM N 
TriangulationPoint
øøO a
b
øøb c
)
øød e
{
øøf g
return
¿¿ 	
new
¿¿
 
DTSweepConstraint
¿¿ 
(
¿¿  
a
¿¿  !
,
¿¿! "
b
¿¿# $
)
¿¿$ %
;
¿¿% &
}
¡¡ 
public
√√ 
override
√√	 $
TriangulationAlgorithm
√√ (
	Algorithm
√√) 2
{
√√3 4
get
√√5 8
{
√√9 :
return
√√; A$
TriangulationAlgorithm
√√B X
.
√√X Y
DTSweep
√√Y `
;
√√` a
}
√√b c
}
√√c d
}
ƒƒ 
}≈≈ æ*
ôD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Utility\FixedArray3.cs
	namespace$$ 	
UnityEngine$$
 
.$$ 

ProBuilder$$  
.$$  !
Poly2Tri$$! )
{$$* +
struct%% 
FixedArray3%% 
<%% 
T%% 
>%% 
:%% 
IEnumerable%% $
<%%$ %
T%%% &
>%%& '
where%%( -
T%%. /
:%%/ 0
class%%0 5
{%%6 7
public&& 
T&&	 

_0&& 
,&& 
_1&& 
,&& 
_2&& 
;&& 
public'' 
T''	 

this'' 
['' 
int'' 
index'' 
]'' 
{'' 
get'' "
{''# $
switch(( 	
(((
 
index(( 
)(( 
{(( 
case)) 
$num)) 	
:))	 

return)) 
_0)) 
;)) 
case** 
$num** 	
:**	 

return** 
_1** 
;** 
case++ 
$num++ 	
:++	 

return++ 
_2++ 
;++ 
default,, 

:,,
 
throw,, 
new,, $
IndexOutOfRangeException,, .
(,,. /
),,/ 0
;,,0 1
}-- 
}.. 
set.. 
{.. 	
switch// 	
(//
 
index// 
)// 
{// 
case00 
$num00 	
:00	 

_000 
=00 
value00 
;00 
break00 
;00 
case11 
$num11 	
:11	 

_111 
=11 
value11 
;11 
break11 
;11 
case22 
$num22 	
:22	 

_222 
=22 
value22 
;22 
break22 
;22 
default33 

:33
 
throw33 
new33 $
IndexOutOfRangeException33 .
(33. /
)33/ 0
;330 1
}44 
}55 
}55 
public66 
bool66	 
Contains66 
(66 
T66 
value66 
)66  !
{66" #
for77 
(77 
int77	 
i77 
=77 
$num77 
;77 
i77 
<77 
$num77 
;77 
++77 
i77  
)77! "
if77# %
(77& '
this77( ,
[77, -
i77- .
]77. /
==77/ 1
value771 6
)777 8
return779 ?
true77@ D
;77D E
return88 	
false88
 
;88 
}99 
public:: 
int::	 
IndexOf:: 
(:: 
T:: 
value:: 
):: 
{::  !
for;; 
(;; 
int;;	 
i;; 
=;; 
$num;; 
;;; 
i;; 
<;; 
$num;; 
;;; 
++;; 
i;;  
);;! "
if;;# %
(;;& '
this;;( ,
[;;, -
i;;- .
];;. /
==;;/ 1
value;;1 6
);;7 8
return;;9 ?
i;;@ A
;;;A B
return<< 	
-<<
 
$num<< 
;<< 
}== 
public>> 
void>>	 
Clear>> 
(>> 
)>> 
{>> 
_0?? 
=?? 
_1?? 
=?? 	
_2??	 
=?? 
null?? 
;?? 
}@@ 
publicAA 
voidAA	 
ClearAA 
(AA 
TAA 
valueAA 
)AA 
{AA  
forBB 
(BB 
intBB	 
iBB 
=BB 
$numBB 
;BB 
iBB 
<BB 
$numBB 
;BB 
++BB 
iBB  
)BB! "
ifBB# %
(BB& '
thisBB( ,
[BB, -
iBB- .
]BB. /
==BB/ 1
valueBB1 6
)BB7 8
thisBB9 =
[BB= >
iBB> ?
]BB? @
=BBA B
nullBBC G
;BBG H
}CC 
privateEE 	
IEnumerableEE
 
<EE 
TEE 
>EE 
	EnumerateEE "
(EE" #
)EE# $
{EE% &
forFF 
(FF 
intFF	 
iFF 
=FF 
$numFF 
;FF 
iFF 
<FF 
$numFF 
;FF 
++FF 
iFF 
)FF 
yieldFF $
returnFF% +
thisFF, 0
[FF0 1
iFF1 2
]FF2 3
;FF3 4
}GG 
publicHH 
IEnumeratorHH	 
<HH 
THH 
>HH 
GetEnumeratorHH %
(HH% &
)HH& '
{HH( )
returnHH* 0
	EnumerateHH1 :
(HH: ;
)HH; <
.HH< =
GetEnumeratorHH= J
(HHJ K
)HHK L
;HHL M
}HHN O
IEnumeratorII 
IEnumerableII 
.II 
GetEnumeratorII '
(II' (
)II( )
{II* +
returnII, 2
GetEnumeratorII3 @
(II@ A
)IIA B
;IIB C
}IID E
}JJ 
}KK ÷
¨D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Sets\ConstrainedPointSet.cs
	namespace!! 	
UnityEngine!!
 
.!! 

ProBuilder!!  
.!!  !
Poly2Tri!!! )
{!!* +
class++ 
ConstrainedPointSet++ 
:++ 
PointSet++ %
{++& '
public,, 
int,,	 
[,, 
],, 
	EdgeIndex,, 
{,, 
get,, 
;,, 
private,,  '
set,,( +
;,,+ ,
},,- .
public.. 
ConstrainedPointSet..	 
(.. 
List.. !
<..! "
TriangulationPoint.." 4
>..4 5
points..6 <
,..< =
int..> A
[..A B
]..B C
index..D I
)..I J
:// 
base// 	
(//	 

points//
 
)// 
{// 
	EdgeIndex00 
=00 
index00 
;00 
}11 
public33 
override33	 
TriangulationMode33 #
TriangulationMode33$ 5
{336 7
get338 ;
{33< =
return33> D
TriangulationMode33E V
.33V W
Constrained33W b
;33b c
}33d e
}33f g
public55 
override55	 
void55 
Prepare55 
(55  
TriangulationContext55 3
tcx554 7
)557 8
{559 :
base66 
.66 
Prepare66 
(66 
tcx66 
)66 
;66 
for77 
(77 
int77 
i77 
=77 
$num77 
;77 
i77 
<77 
	EdgeIndex77  
.77  !
Length77! '
;77' (
i77) *
+=77+ -
$num77. /
)77/ 0
{771 2
tcx99 
.99 
NewConstraint99 
(99 
Points99 
[99 
	EdgeIndex99 &
[99& '
i99' (
]99( )
]99) *
,99* +
Points99, 2
[992 3
	EdgeIndex993 <
[99< =
i99= >
+99? @
$num99A B
]99B C
]99C D
)99D E
;99E F
}:: 
};; 
}<< 
}== ˜

£D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\ITriangulatable.cs
	namespace"" 	
UnityEngine""
 
."" 

ProBuilder""  
.""  !
Poly2Tri""! )
{""* +
	interface## 

Triangulatable## 
{## 
void$$ 
Prepare$$ 
($$  
TriangulationContext$$ #
tcx$$$ '
)$$' (
;$$( )
IList&& 
<&& 
TriangulationPoint&& 
>&& 
Points&& "
{&&# $
get&&% (
;&&( )
}&&* +
IList'' 
<'' 
DelaunayTriangle'' 
>'' 
	Triangles'' #
{''$ %
get''& )
;'') *
}''+ ,
void)) 
AddTriangle)) 
()) 
DelaunayTriangle)) #
t))$ %
)))% &
;))& '
void** 
AddTriangles** 
(** 
IEnumerable** 
<**  
DelaunayTriangle**  0
>**0 1
list**2 6
)**6 7
;**7 8
void++ 
ClearTriangles++ 
(++ 
)++ 
;++ 
TriangulationMode-- 
TriangulationMode-- %
{--& '
get--( +
;--+ ,
}--- .
}.. 
}// Ì)
úD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Utility\FixedBitArray3.cs
	namespace$$ 	
UnityEngine$$
 
.$$ 

ProBuilder$$  
.$$  !
Poly2Tri$$! )
{$$* +
struct%% 
FixedBitArray3%% 
:%% 
IEnumerable%% $
<%%$ %
bool%%% )
>%%) *
{%%+ ,
public&& 
bool&&	 
_0&& 
,&& 
_1&& 
,&& 
_2&& 
;&& 
public'' 
bool''	 
this'' 
['' 
int'' 
index'' 
]'' 
{''  !
get''" %
{''& '
switch(( 	
(((
 
index(( 
)(( 
{(( 
case)) 
$num)) 	
:))	 

return)) 
_0)) 
;)) 
case** 
$num** 	
:**	 

return** 
_1** 
;** 
case++ 
$num++ 	
:++	 

return++ 
_2++ 
;++ 
default,, 

:,,
 
throw,, 
new,, $
IndexOutOfRangeException,, .
(,,. /
),,/ 0
;,,0 1
}-- 
}.. 
set.. 
{.. 	
switch// 	
(//
 
index// 
)// 
{// 
case00 
$num00 	
:00	 

_000 
=00 
value00 
;00 
break00 
;00 
case11 
$num11 	
:11	 

_111 
=11 
value11 
;11 
break11 
;11 
case22 
$num22 	
:22	 

_222 
=22 
value22 
;22 
break22 
;22 
default33 

:33
 
throw33 
new33 $
IndexOutOfRangeException33 .
(33. /
)33/ 0
;330 1
}44 
}55 
}55 
public66 
bool66	 
Contains66 
(66 
bool66 
value66 "
)66# $
{66% &
for77 
(77 
int77	 
i77 
=77 
$num77 
;77 
i77 
<77 
$num77 
;77 
++77 
i77  
)77! "
if77# %
(77& '
this77( ,
[77, -
i77- .
]77. /
==77/ 1
value771 6
)777 8
return779 ?
true77@ D
;77D E
return88 	
false88
 
;88 
}99 
public:: 
int::	 
IndexOf:: 
(:: 
bool:: 
value::  
)::! "
{::# $
for;; 
(;; 
int;;	 
i;; 
=;; 
$num;; 
;;; 
i;; 
<;; 
$num;; 
;;; 
++;; 
i;;  
);;! "
if;;# %
(;;& '
this;;( ,
[;;, -
i;;- .
];;. /
==;;/ 1
value;;1 6
);;7 8
return;;9 ?
i;;@ A
;;;A B
return<< 	
-<<
 
$num<< 
;<< 
}== 
public>> 
void>>	 
Clear>> 
(>> 
)>> 
{>> 
_0?? 
=?? 
_1?? 
=?? 	
_2??	 
=?? 
false?? 
;?? 
}@@ 
publicAA 
voidAA	 
ClearAA 
(AA 
boolAA 
valueAA 
)AA  !
{AA" #
forBB 
(BB 
intBB	 
iBB 
=BB 
$numBB 
;BB 
iBB 
<BB 
$numBB 
;BB 
++BB 
iBB  
)BB! "
ifBB# %
(BB& '
thisBB( ,
[BB, -
iBB- .
]BB. /
==BB/ 1
valueBB1 6
)BB7 8
thisBB9 =
[BB= >
iBB> ?
]BB? @
=BBA B
falseBBC H
;BBH I
}CC 
privateEE 	
IEnumerableEE
 
<EE 
boolEE 
>EE 
	EnumerateEE %
(EE% &
)EE& '
{EE( )
forFF 
(FF 
intFF	 
iFF 
=FF 
$numFF 
;FF 
iFF 
<FF 
$numFF 
;FF 
++FF 
iFF 
)FF 
yieldFF $
returnFF% +
thisFF, 0
[FF0 1
iFF1 2
]FF2 3
;FF3 4
}GG 
publicHH 
IEnumeratorHH	 
<HH 
boolHH 
>HH 
GetEnumeratorHH (
(HH( )
)HH) *
{HH+ ,
returnHH- 3
	EnumerateHH4 =
(HH= >
)HH> ?
.HH? @
GetEnumeratorHH@ M
(HHM N
)HHN O
;HHO P
}HHQ R
IEnumeratorII 
IEnumerableII 
.II 
GetEnumeratorII '
(II' (
)II( )
{II* +
returnII, 2
GetEnumeratorII3 @
(II@ A
)IIA B
;IIB C
}IID E
}JJ 
}KK ¶
íD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\AssemblyInfo.cs
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 0
)0 1
]1 2ë
¥D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Delaunay\Sweep\DTSweepConstraint.cs
	namespace   	
UnityEngine  
 
.   

ProBuilder    
.    !
Poly2Tri  ! )
{  * +
class!! 
DTSweepConstraint!! 
:!! #
TriangulationConstraint!! 2
{!!3 4
public&& 
DTSweepConstraint&&	 
(&& 
TriangulationPoint&& .
p1&&/ 1
,&&1 2
TriangulationPoint&&3 E
p2&&F H
)&&I J
{&&K L
P'' 
='' 
p1'' 	
;''	 

Q(( 
=(( 
p2(( 	
;((	 

if)) 
()) 
p1)) 	
.))	 

Y))
 
>)) 
p2)) 
.)) 
Y)) 
))) 
{)) 
Q** 
=** 
p1** 

;**
 
P++ 
=++ 
p2++ 

;++
 
},, 
else,, 	
if,,
 
(,, 
p1,, 
.,, 
Y,, 
==,, 
p2,, 
.,, 
Y,, 
),, 
{,, 
if-- 
(-- 
p1-- 

.--
 
X-- 
>-- 
p2-- 
.-- 
X-- 
)-- 
{-- 
Q.. 
=.. 
p1..	 
;.. 
P// 
=// 
p2//	 
;// 
}00 
else00 

if00 
(00 
p100 
.00 
X00 
==00 
p200 
.00 
X00 
)00 
{00 
}44 
}55 
Q66 
.66 
AddEdge66 
(66 
this66 
)66 
;66 
}77 
}88 
}99 ”<
±D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Delaunay\Sweep\AdvancingFront.cs
	namespace)) 	
UnityEngine))
 
.)) 

ProBuilder))  
.))  !
Poly2Tri))! )
{))* +
class-- 
AdvancingFront-- 
{-- 
public.. 
AdvancingFrontNode..	 
Head..  
;..  !
public// 
AdvancingFrontNode//	 
Tail//  
;//  !
	protected00 
AdvancingFrontNode00 
Search00 %
;00% &
public22 
AdvancingFront22	 
(22 
AdvancingFrontNode22 +
head22, 0
,220 1
AdvancingFrontNode222 D
tail22E I
)22J K
{22L M
this33 
.33 
Head33 
=33 
head33 
;33 
this44 
.44 
Tail44 
=44 
tail44 
;44 
this55 
.55 
Search55 
=55 
head55 
;55 
AddNode66 

(66
 
head66 
)66 
;66 
AddNode77 

(77
 
tail77 
)77 
;77 
}88 
public:: 
void::	 
AddNode:: 
(:: 
AdvancingFrontNode:: )
node::* .
)::/ 0
{::1 2
}::3 4
public;; 
void;;	 

RemoveNode;; 
(;; 
AdvancingFrontNode;; ,
node;;- 1
);;2 3
{;;4 5
};;6 7
public== 
override==	 
string== 
ToString== !
(==! "
)==" #
{==$ %
StringBuilder>> 
sb>> 
=>> 
new>> 
StringBuilder>> '
(>>' (
)>>( )
;>>) *
AdvancingFrontNode?? 
node?? 
=?? 
Head?? !
;??! "
while@@ 
(@@	 

node@@
 
!=@@ 
Tail@@ 
)@@ 
{@@ 
sbAA 
.AA 
AppendAA 
(AA 
nodeAA 
.AA 
PointAA 
.AA 
XAA 
)AA 
.AA 
AppendAA "
(AA" #
$strAA# '
)AA' (
;AA( )
nodeBB 
=BB	 

nodeBB 
.BB 
NextBB 
;BB 
}CC 
sbDD 
.DD 
AppendDD 
(DD 
TailDD 
.DD 
PointDD 
.DD 
XDD 
)DD 
;DD 
returnEE 	
sbEE
 
.EE 
ToStringEE 
(EE 
)EE 
;EE 
}FF 
privateLL 	
AdvancingFrontNodeLL
 
FindSearchNodeLL +
(LL+ ,
doubleLL- 3
xLL4 5
)LL6 7
{LL8 9
returnMM 	
SearchMM
 
;MM 
}NN 
publicSS 
AdvancingFrontNodeSS	 

LocateNodeSS &
(SS& '
TriangulationPointSS( :
pointSS; @
)SSA B
{SSC D
returnTT 	

LocateNodeTT
 
(TT 
pointTT 
.TT 
XTT 
)TT 
;TT 
}UU 
privateWW 	
AdvancingFrontNodeWW
 

LocateNodeWW '
(WW' (
doubleWW) /
xWW0 1
)WW2 3
{WW4 5
AdvancingFrontNodeXX 
nodeXX 
=XX 
FindSearchNodeXX +
(XX+ ,
xXX, -
)XX- .
;XX. /
ifYY 
(YY 
xYY 
<YY	 

nodeYY 
.YY 
ValueYY 
)YY 
{YY 
whileZZ 	
(ZZ
 
(ZZ 
nodeZZ 
=ZZ 
nodeZZ 
.ZZ 
PrevZZ 
)ZZ 
!=ZZ  
nullZZ! %
)ZZ% &
if[[ 
([[ 	
x[[	 

>=[[ 
node[[ 
.[[ 
Value[[ 
)[[ 
{[[ 
Search\\ 
=\\ 
node\\ 
;\\ 
return]] 
node]] 
;]] 
}^^ 
}__ 
else__ 	
{__
 
while`` 	
(``
 
(`` 
node`` 
=`` 
node`` 
.`` 
Next`` 
)`` 
!=``  
null``! %
)``% &
ifaa 
(aa 	
xaa	 

<aa 
nodeaa 
.aa 
Valueaa 
)aa 
{aa 
Searchbb 
=bb 
nodebb 
.bb 
Prevbb 
;bb 
returncc 
nodecc 
.cc 
Prevcc 
;cc 
}dd 
}ee 
returnff 	
nullff
 
;ff 
}gg 
publicll 
AdvancingFrontNodell	 
LocatePointll '
(ll' (
TriangulationPointll) ;
pointll< A
)llB C
{llD E
doublemm 	
pxmm
 
=mm 
pointmm 
.mm 
Xmm 
;mm 
AdvancingFrontNodenn 
nodenn 
=nn 
FindSearchNodenn +
(nn+ ,
pxnn, .
)nn. /
;nn/ 0
doubleoo 	
nxoo
 
=oo 
nodeoo 
.oo 
Pointoo 
.oo 
Xoo 
;oo 
ifqq 
(qq 
pxqq 	
==qq
 
nxqq 
)qq 
{qq 
ifrr 
(rr 
pointrr 
!=rr 
noderr 
.rr 
Pointrr 
)rr 
{rr 
iftt 
(tt 	
pointtt	 
==tt 
nodett 
.tt 
Prevtt 
.tt 
Pointtt !
)tt! "
{tt# $
nodeuu 

=uu 
nodeuu 
.uu 
Prevuu 
;uu 
}vv 
elsevv 
ifvv 
(vv 
pointvv 
==vv 
nodevv 
.vv 
Nextvv "
.vv" #
Pointvv# (
)vv( )
{vv* +
nodeww 

=ww 
nodeww 
.ww 
Nextww 
;ww 
}xx 
elsexx 
{xx 
throwyy 
newyy 
	Exceptionyy 
(yy 
$stryy F
)yyF G
;yyG H
}zz 
}{{ 
}|| 
else|| 	
if||
 
(|| 
px|| 
<|| 
nx|| 
)|| 
{|| 
while}} 	
(}}
 
(}} 
node}} 
=}} 
node}} 
.}} 
Prev}} 
)}} 
!=}}  
null}}! %
)}}% &
if}}' )
(}}* +
point}}+ 0
==}}1 3
node}}4 8
.}}8 9
Point}}9 >
)}}> ?
break}}@ E
;}}E F
}~~ 
else~~ 	
{~~
 
while 	
(
 
( 
node 
= 
node 
. 
Next 
) 
!=  
null! %
)% &
if' )
(* +
point+ 0
==1 3
node4 8
.8 9
Point9 >
)> ?
break@ E
;E F
}
ÄÄ 
Search
ÅÅ 	
=
ÅÅ
 
node
ÅÅ 
;
ÅÅ 
return
ÇÇ 	
node
ÇÇ
 
;
ÇÇ 
}
ÉÉ 
}
ÑÑ 
}ÖÖ ò	
öD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Polygon\PolygonPoint.cs
	namespace%% 	
UnityEngine%%
 
.%% 

ProBuilder%%  
.%%  !
Poly2Tri%%! )
{%%* +
class&& 
PolygonPoint&& 
:&& 
TriangulationPoint&& (
{&&) *
public'' 
PolygonPoint''	 
('' 
double'' 
x'' 
,''  
double''! '
y''( )
,'') *
int''+ .
index''/ 4
=''5 6
INSERTED_INDEX''7 E
)''F G
:''H I
base''J N
(''N O
x''O P
,''P Q
y''R S
,''S T
index''U Z
)''Z [
{''\ ]
}''^ _
public)) 
PolygonPoint))	 
Next)) 
{)) 
get))  
;))  !
set))" %
;))% &
}))' (
public** 
PolygonPoint**	 
Previous** 
{**  
get**! $
;**$ %
set**& )
;**) *
}**+ ,
}++ 
},, Û
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Polygon\PolygonSet.cs
	namespace(( 	
UnityEngine((
 
.(( 

ProBuilder((  
.((  !
Poly2Tri((! )
{((* +
class)) 

PolygonSet)) 
{)) 
	protected** 
List** 
<** 
Polygon** 
>** 
	_polygons** #
=**$ %
new**& )
List*** .
<**. /
Polygon**/ 6
>**6 7
(**7 8
)**8 9
;**9 :
public,, 

PolygonSet,,	 
(,, 
),, 
{,, 
},, 
public.. 

PolygonSet..	 
(.. 
Polygon.. 
poly..  
)..  !
{.." #
	_polygons// 
.// 
Add// 
(// 
poly// 
)// 
;// 
}00 
public22 
void22	 
Add22 
(22 
Polygon22 
p22 
)22 
{22 
	_polygons33 
.33 
Add33 
(33 
p33 
)33 
;33 
}44 
public66 
IEnumerable66	 
<66 
Polygon66 
>66 
Polygons66 &
{66' (
get66) ,
{66- .
return66/ 5
	_polygons666 ?
;66? @
}66A B
}66C D
}77 
}88 æ
´D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\TriangulationConstraint.cs
	namespace'' 	
UnityEngine''
 
.'' 

ProBuilder''  
.''  !
Poly2Tri''! )
{''* +
class(( #
TriangulationConstraint(( 
{((  
public)) 
TriangulationPoint))	 
P)) 
;)) 
public** 
TriangulationPoint**	 
Q** 
;** 
}++ 
},, ˜
πD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Delaunay\Sweep\DTSweepPointComparator.cs
	namespace"" 	
UnityEngine""
 
."" 

ProBuilder""  
.""  !
Poly2Tri""! )
{""* +
class## "
DTSweepPointComparator## 
:## 
	IComparer##  )
<##) *
TriangulationPoint##* <
>##< =
{##> ?
public$$ 
int$$	 
Compare$$ 
($$ 
TriangulationPoint$$ '
p1$$( *
,$$* +
TriangulationPoint$$, >
p2$$? A
)$$A B
{$$C D
if%% 
(%% 
p1%% 	
.%%	 

Y%%
 
<%% 
p2%% 
.%% 
Y%% 
)%% 
{%% 
return&& 

-&& 
$num&& 
;&& 
}'' 
else'' 	
if''
 
('' 
p1'' 
.'' 
Y'' 
>'' 
p2'' 
.'' 
Y'' 
)'' 
{'' 
return(( 

$num(( 
;(( 
})) 
else)) 	
{))
 
if** 
(** 
p1** 

.**
 
X** 
<** 
p2** 
.** 
X** 
)** 
{** 
return++ 
-++ 
$num++ 
;++ 
},, 
else,, 

if,, 
(,, 
p1,, 
.,, 
X,, 
>,, 
p2,, 
.,, 
X,, 
),, 
{,, 
return-- 
$num-- 
;-- 
}.. 
else.. 

{.. 
return// 
$num// 
;// 
}00 
}11 
}22 
}33 
}44 óŒ
≠D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Delaunay\DelaunayTriangle.cs
	namespace-- 	
UnityEngine--
 
.-- 

ProBuilder--  
.--  !
Poly2Tri--! )
{--* +
class.. 
DelaunayTriangle.. 
{.. 
public// 
FixedArray3//	 
<// 
TriangulationPoint// '
>//' (
Points//) /
;/// 0
public00 
FixedArray300	 
<00 
DelaunayTriangle00 %
>00' (
	Neighbors00) 2
;002 3
public11 
FixedBitArray311	 
EdgeIsConstrained11 )
,11) *
EdgeIsDelaunay11+ 9
;119 :
public22 
bool22	 

IsInterior22 
{22 
get22 
;22 
set22  #
;22# $
}22% &
public44 
DelaunayTriangle44	 
(44 
TriangulationPoint44 ,
p144- /
,44/ 0
TriangulationPoint441 C
p244D F
,44F G
TriangulationPoint44H Z
p344[ ]
)44] ^
{44_ `
Points55 	
[55	 

$num55
 
]55 
=55 
p155 
;55 
Points66 	
[66	 

$num66
 
]66 
=66 
p266 
;66 
Points77 	
[77	 

$num77
 
]77 
=77 
p377 
;77 
}88 
public:: 
int::	 
IndexOf:: 
(:: 
TriangulationPoint:: '
p::( )
)::) *
{::+ ,
int;; 
i;; 
=;;	 

Points;; 
.;; 
IndexOf;; 
(;; 
p;; 
);; 
;;; 
if<< 
(<< 
i<< 
==<< 

-<<
 
$num<< 
)<< 
throw<< 
new<< 
	Exception<< !
(<<! "
$str<<" ]
)<<] ^
;<<^ _
return== 	
i==
 
;== 
}>> 
public@@ 
int@@	 
IndexCWFrom@@ 
(@@ 
TriangulationPoint@@ ,
p@@- .
)@@. /
{@@0 1
return@@2 8
(@@9 :
IndexOf@@: A
(@@A B
p@@B C
)@@C D
+@@D E
$num@@E F
)@@F G
%@@G H
$num@@H I
;@@I J
}@@K L
publicAA 
intAA	 
IndexCCWFromAA 
(AA 
TriangulationPointAA ,
pAA- .
)AA. /
{AA0 1
returnAA2 8
(AA9 :
IndexOfAA: A
(AAA B
pAAB C
)AAC D
+AAD E
$numAAE F
)AAF G
%AAG H
$numAAH I
;AAI J
}AAK L
publicCC 
boolCC	 
ContainsCC 
(CC 
TriangulationPointCC )
pCC* +
)CC+ ,
{CC- .
returnCC/ 5
PointsCC6 <
.CC< =
ContainsCC= E
(CCE F
pCCF G
)CCG H
;CCH I
}CCJ K
privateKK 	
voidKK
 
MarkNeighborKK 
(KK 
TriangulationPointKK /
p1KK0 2
,KK2 3
TriangulationPointKK4 F
p2KKG I
,KKI J
DelaunayTriangleKKK [
tKK\ ]
)KK^ _
{KK` a
intLL 
iLL 
=LL	 

	EdgeIndexLL 
(LL 
p1LL 
,LL 
p2LL 
)LL 
;LL 
ifMM 
(MM 
iMM 	
==MM	 
-MM 
$numMM 
)MM 
throwMM 
newMM 
	ExceptionMM #
(MM# $
$strMM% _
)MM` a
;MMa b
	NeighborsNN 
[NN 
iNN 
]NN 
=NN 
tNN 
;NN 
}OO 
publicTT 
voidTT	 
MarkNeighborTT 
(TT 
DelaunayTriangleTT ,
tTT- .
)TT/ 0
{TT1 2
boolVV 
aVV 	
=VV
 
tVV 
.VV 
ContainsVV 
(VV 
PointsVV 
[VV 
$numVV 
]VV  
)VV  !
;VV! "
boolWW 
bWW 	
=WW
 
tWW 
.WW 
ContainsWW 
(WW 
PointsWW 
[WW 
$numWW 
]WW  
)WW  !
;WW! "
boolXX 
cXX 	
=XX
 
tXX 
.XX 
ContainsXX 
(XX 
PointsXX 
[XX 
$numXX 
]XX  
)XX  !
;XX! "
ifZZ 
(ZZ 
bZZ 
&&ZZ 
cZZ 
)ZZ 
{ZZ 
	NeighborsZZ 
[ZZ 
$numZZ 
]ZZ  
=ZZ  !
tZZ! "
;ZZ" #
tZZ$ %
.ZZ% &
MarkNeighborZZ& 2
(ZZ2 3
PointsZZ3 9
[ZZ9 :
$numZZ: ;
]ZZ; <
,ZZ< =
PointsZZ= C
[ZZC D
$numZZD E
]ZZE F
,ZZF G
thisZZG K
)ZZK L
;ZZL M
}ZZN O
else[[ 
if[[ 

([[ 
a[[ 
&&[[ 
c[[ 
)[[ 
{[[ 
	Neighbors[[ 
[[[ 
$num[[ 
][[  
=[[  !
t[[! "
;[[" #
t[[$ %
.[[% &
MarkNeighbor[[& 2
([[2 3
Points[[3 9
[[[9 :
$num[[: ;
][[; <
,[[< =
Points[[= C
[[[C D
$num[[D E
][[E F
,[[F G
this[[G K
)[[K L
;[[L M
}[[N O
else\\ 
if\\ 

(\\ 
a\\ 
&&\\ 
b\\ 
)\\ 
{\\ 
	Neighbors\\ 
[\\ 
$num\\ 
]\\  
=\\  !
t\\! "
;\\" #
t\\$ %
.\\% &
MarkNeighbor\\& 2
(\\2 3
Points\\3 9
[\\9 :
$num\\: ;
]\\; <
,\\< =
Points\\= C
[\\C D
$num\\D E
]\\E F
,\\F G
this\\G K
)\\K L
;\\L M
}\\N O
else]] 
throw]] 
new]] 
	Exception]] 
(]] 
$str]] N
)]]N O
;]]O P
}^^ 
publicbb 
TriangulationPointbb	 
OppositePointbb )
(bb) *
DelaunayTrianglebb* :
tbb; <
,bb< =
TriangulationPointbb> P
pbbQ R
)bbR S
{bbT U
Systemcc 	
.cc	 

Diagnosticscc
 
.cc 
Debugcc 
.cc 
Assertcc "
(cc" #
tcc# $
!=cc% '
thiscc( ,
,cc, -
$strcc. B
)ccB C
;ccC D
returndd 	
PointCWFromdd
 
(dd 
tdd 
.dd 
PointCWFromdd #
(dd# $
pdd$ %
)dd% &
)dd& '
;dd' (
}ee 
publicgg 
DelaunayTrianglegg	 
NeighborCWFromgg (
(gg, -
TriangulationPointgg- ?
pointgg@ E
)ggE F
{ggG H
returnggI O
	NeighborsggP Y
[ggY Z
(ggZ [
Pointsgg[ a
.gga b
IndexOfggb i
(ggi j
pointggj o
)ggo p
+ggp q
$numggq r
)ggr s
%ggs t
$numggt u
]ggu v
;ggv w
}ggx y
publichh 
DelaunayTrianglehh	 
NeighborCCWFromhh )
(hh, -
TriangulationPointhh- ?
pointhh@ E
)hhE F
{hhG H
returnhhI O
	NeighborshhP Y
[hhY Z
(hhZ [
Pointshh[ a
.hha b
IndexOfhhb i
(hhi j
pointhhj o
)hho p
+hhp q
$numhhq r
)hhr s
%hhs t
$numhht u
]hhu v
;hhv w
}hhx y
publicii 
DelaunayTriangleii	 
NeighborAcrossFromii ,
(ii, -
TriangulationPointii- ?
pointii@ E
)iiE F
{iiG H
returniiI O
	NeighborsiiP Y
[iiY Z
Pointsii[ a
.iia b
IndexOfiib i
(iii j
pointiij o
)iio p
]iiu v
;iiv w
}iix y
publickk 
TriangulationPointkk	 
PointCCWFromkk (
(kk( )
TriangulationPointkk) ;
pointkk< A
)kkA B
{kkC D
returnkkE K
PointskkL R
[kkR S
(kkS T
IndexOfkkT [
(kk[ \
pointkk\ a
)kka b
+kkb c
$numkkc d
)kkd e
%kke f
$numkkf g
]kkg h
;kkh i
}kkj k
publicll 
TriangulationPointll	 
PointCWFromll '
(ll( )
TriangulationPointll) ;
pointll< A
)llA B
{llC D
returnllE K
PointsllL R
[llR S
(llS T
IndexOfllT [
(ll[ \
pointll\ a
)lla b
+llb c
$numllc d
)lld e
%lle f
$numllf g
]llg h
;llh i
}llj k
privatenn 	
voidnn
 
RotateCWnn 
(nn 
)nn 
{nn 
varoo 
too 
=oo	 

Pointsoo 
[oo 
$numoo 
]oo 
;oo 
Pointspp 	
[pp	 

$numpp
 
]pp 
=pp 
Pointspp 
[pp 
$numpp 
]pp 
;pp 
Pointsqq 	
[qq	 

$numqq
 
]qq 
=qq 
Pointsqq 
[qq 
$numqq 
]qq 
;qq 
Pointsrr 	
[rr	 

$numrr
 
]rr 
=rr 
trr 
;rr 
}ss 
publiczz 
voidzz	 
Legalizezz 
(zz 
TriangulationPointzz )
oPointzz* 0
,zz0 1
TriangulationPointzz2 D
nPointzzE K
)zzK L
{zzM N
RotateCW{{ 
({{ 
){{ 
;{{ 
Points|| 	
[||	 

IndexCCWFrom||
 
(|| 
oPoint|| 
)|| 
]|| 
=||  !
nPoint||" (
;||( )
}}} 
public 
override	 
string 
ToString !
(! "
)" #
{$ %
return& ,
Points- 3
[3 4
$num4 5
]5 6
+7 8
$str9 <
+= >
Points? E
[E F
$numF G
]G H
+I J
$strK N
+O P
PointsQ W
[W X
$numX Y
]Y Z
;Z [
}\ ]
public
ÑÑ 
void
ÑÑ	 
MarkNeighborEdges
ÑÑ 
(
ÑÑ  
)
ÑÑ  !
{
ÑÑ" #
for
ÖÖ 
(
ÖÖ 
int
ÖÖ 
i
ÖÖ 
=
ÖÖ 
$num
ÖÖ 
;
ÖÖ 
i
ÖÖ 
<
ÖÖ 
$num
ÖÖ 
;
ÖÖ 
i
ÖÖ 
++
ÖÖ 
)
ÖÖ 
if
ÖÖ !
(
ÖÖ" #
EdgeIsConstrained
ÖÖ$ 5
[
ÖÖ5 6
i
ÖÖ6 7
]
ÖÖ7 8
&&
ÖÖ9 ;
	Neighbors
ÖÖ< E
[
ÖÖE F
i
ÖÖF G
]
ÖÖG H
!=
ÖÖI K
null
ÖÖL P
)
ÖÖQ R
{
ÖÖS T
	Neighbors
ÜÜ 
[
ÜÜ 
i
ÜÜ 
]
ÜÜ 
.
ÜÜ !
MarkConstrainedEdge
ÜÜ $
(
ÜÜ$ %
Points
ÜÜ% +
[
ÜÜ+ ,
(
ÜÜ, -
i
ÜÜ- .
+
ÜÜ. /
$num
ÜÜ/ 0
)
ÜÜ0 1
%
ÜÜ1 2
$num
ÜÜ2 3
]
ÜÜ3 4
,
ÜÜ4 5
Points
ÜÜ6 <
[
ÜÜ< =
(
ÜÜ= >
i
ÜÜ> ?
+
ÜÜ? @
$num
ÜÜ@ A
)
ÜÜA B
%
ÜÜB C
$num
ÜÜC D
]
ÜÜD E
)
ÜÜE F
;
ÜÜF G
}
áá 
}
àà 
public
ää 
void
ää	 
MarkEdge
ää 
(
ää 
DelaunayTriangle
ää '
triangle
ää( 0
)
ää0 1
{
ää2 3
for
ãã 
(
ãã 
int
ãã 
i
ãã 
=
ãã 
$num
ãã 
;
ãã 
i
ãã 
<
ãã 
$num
ãã 
;
ãã 
i
ãã 
++
ãã 
)
ãã 
if
ãã !
(
ãã" #
EdgeIsConstrained
ãã$ 5
[
ãã5 6
i
ãã6 7
]
ãã7 8
)
ãã9 :
{
ãã; <
triangle
åå 
.
åå !
MarkConstrainedEdge
åå  
(
åå  !
Points
åå! '
[
åå' (
(
åå( )
i
åå) *
+
åå* +
$num
åå+ ,
)
åå, -
%
åå- .
$num
åå. /
]
åå/ 0
,
åå0 1
Points
åå2 8
[
åå8 9
(
åå9 :
i
åå: ;
+
åå; <
$num
åå< =
)
åå= >
%
åå> ?
$num
åå? @
]
åå@ A
)
ååA B
;
ååB C
}
çç 
}
éé 
public
êê 
void
êê	 
MarkEdge
êê 
(
êê 
List
êê 
<
êê 
DelaunayTriangle
êê ,
>
êê, -
tList
êê. 3
)
êê3 4
{
êê5 6
foreach
ëë 

(
ëë 
DelaunayTriangle
ëë 
t
ëë 
in
ëë  "
tList
ëë# (
)
ëë) *
for
íí 
(
íí 
int
íí	 
i
íí 
=
íí 
$num
íí 
;
íí 
i
íí 
<
íí 
$num
íí 
;
íí 
i
íí 
++
íí 
)
íí  
if
ìì 
(
ìì 
t
ìì 	
.
ìì	 

EdgeIsConstrained
ìì
 
[
ìì 
i
ìì 
]
ìì 
)
ìì  
{
îî !
MarkConstrainedEdge
ïï 
(
ïï 
t
ïï 
.
ïï 
Points
ïï !
[
ïï! "
(
ïï" #
i
ïï# $
+
ïï$ %
$num
ïï% &
)
ïï& '
%
ïï' (
$num
ïï( )
]
ïï) *
,
ïï* +
t
ïï, -
.
ïï- .
Points
ïï. 4
[
ïï4 5
(
ïï5 6
i
ïï6 7
+
ïï7 8
$num
ïï8 9
)
ïï9 :
%
ïï: ;
$num
ïï; <
]
ïï< =
)
ïï> ?
;
ïï? @
}
ññ 
}
óó 
public
ôô 
void
ôô	 !
MarkConstrainedEdge
ôô !
(
ôô! "
int
ôô" %
index
ôô& +
)
ôô+ ,
{
ôô- .
EdgeIsConstrained
öö 
[
öö 
index
öö 
]
öö 
=
öö 
true
öö "
;
öö" #
}
õõ 
public
ùù 
void
ùù	 !
MarkConstrainedEdge
ùù !
(
ùù! "
DTSweepConstraint
ùù" 3
edge
ùù4 8
)
ùù8 9
{
ùù: ;!
MarkConstrainedEdge
ûû 
(
ûû 
edge
ûû 
.
ûû 
P
ûû 
,
ûû 
edge
ûû #
.
ûû# $
Q
ûû$ %
)
ûû% &
;
ûû& '
}
üü 
public
§§ 
void
§§	 !
MarkConstrainedEdge
§§ !
(
§§! " 
TriangulationPoint
§§" 4
p
§§5 6
,
§§6 7 
TriangulationPoint
§§8 J
q
§§K L
)
§§L M
{
§§N O
int
•• 
i
•• 
=
••	 

	EdgeIndex
•• 
(
•• 
p
•• 
,
•• 
q
•• 
)
•• 
;
•• 
if
¶¶ 
(
¶¶ 
i
¶¶ 	
!=
¶¶
 
-
¶¶ 
$num
¶¶ 
)
¶¶ 
EdgeIsConstrained
¶¶ #
[
¶¶# $
i
¶¶$ %
]
¶¶% &
=
¶¶' (
true
¶¶) -
;
¶¶- .
}
ßß 
public
©© 
double
©©	 
Area
©© 
(
©© 
)
©© 
{
©© 
double
™™ 	
b
™™
 
=
™™ 
Points
™™ 
[
™™ 
$num
™™ 
]
™™ 
.
™™ 
X
™™ 
-
™™ 
Points
™™ "
[
™™" #
$num
™™# $
]
™™$ %
.
™™% &
X
™™& '
;
™™' (
double
´´ 	
h
´´
 
=
´´ 
Points
´´ 
[
´´ 
$num
´´ 
]
´´ 
.
´´ 
Y
´´ 
-
´´ 
Points
´´ "
[
´´" #
$num
´´# $
]
´´$ %
.
´´% &
Y
´´& '
;
´´' (
return
≠≠ 	
Math
≠≠
 
.
≠≠ 
Abs
≠≠ 
(
≠≠ 
(
≠≠ 
b
≠≠ 
*
≠≠ 
h
≠≠ 
*
≠≠ 
$num
≠≠  
)
≠≠  !
)
≠≠! "
;
≠≠" #
}
ÆÆ 
public
∞∞  
TriangulationPoint
∞∞	 
Centroid
∞∞ $
(
∞∞$ %
)
∞∞% &
{
∞∞' (
double
±± 	
cx
±±
 
=
±± 
(
±± 
Points
±± 
[
±± 
$num
±± 
]
±± 
.
±± 
X
±± 
+
±± 
Points
±± $
[
±±$ %
$num
±±% &
]
±±& '
.
±±' (
X
±±( )
+
±±* +
Points
±±, 2
[
±±2 3
$num
±±3 4
]
±±4 5
.
±±5 6
X
±±6 7
)
±±7 8
/
±±9 :
$num
±±; =
;
±±= >
double
≤≤ 	
cy
≤≤
 
=
≤≤ 
(
≤≤ 
Points
≤≤ 
[
≤≤ 
$num
≤≤ 
]
≤≤ 
.
≤≤ 
Y
≤≤ 
+
≤≤ 
Points
≤≤ $
[
≤≤$ %
$num
≤≤% &
]
≤≤& '
.
≤≤' (
Y
≤≤( )
+
≤≤* +
Points
≤≤, 2
[
≤≤2 3
$num
≤≤3 4
]
≤≤4 5
.
≤≤5 6
Y
≤≤6 7
)
≤≤7 8
/
≤≤9 :
$num
≤≤; =
;
≤≤= >
return
≥≥ 	
new
≥≥
  
TriangulationPoint
≥≥  
(
≥≥  !
cx
≥≥! #
,
≥≥# $
cy
≥≥% '
)
≥≥' (
;
≥≥( )
}
¥¥ 
public
∫∫ 
int
∫∫	 
	EdgeIndex
∫∫ 
(
∫∫  
TriangulationPoint
∫∫ )
p1
∫∫* ,
,
∫∫, - 
TriangulationPoint
∫∫. @
p2
∫∫A C
)
∫∫C D
{
∫∫E F
int
ªª 
i1
ªª 	
=
ªª
 
Points
ªª 
.
ªª 
IndexOf
ªª 
(
ªª 
p1
ªª 
)
ªª 
;
ªª 
int
ºº 
i2
ºº 	
=
ºº
 
Points
ºº 
.
ºº 
IndexOf
ºº 
(
ºº 
p2
ºº 
)
ºº 
;
ºº 
bool
øø 
a
øø 	
=
øø
 
(
øø 
i1
øø 
==
øø 
$num
øø 
||
øø 
i2
øø 
==
øø 
$num
øø 
)
øø 
;
øø 
bool
¿¿ 
b
¿¿ 	
=
¿¿
 
(
¿¿ 
i1
¿¿ 
==
¿¿ 
$num
¿¿ 
||
¿¿ 
i2
¿¿ 
==
¿¿ 
$num
¿¿ 
)
¿¿ 
;
¿¿ 
bool
¡¡ 
c
¡¡ 	
=
¡¡
 
(
¡¡ 
i1
¡¡ 
==
¡¡ 
$num
¡¡ 
||
¡¡ 
i2
¡¡ 
==
¡¡ 
$num
¡¡ 
)
¡¡ 
;
¡¡ 
if
√√ 
(
√√ 
b
√√ 
&&
√√ 

c
√√
 
)
√√ 
return
√√ 
$num
√√ 
;
√√ 
if
ƒƒ 
(
ƒƒ 
a
ƒƒ 
&&
ƒƒ 

c
ƒƒ
 
)
ƒƒ 
return
ƒƒ 
$num
ƒƒ 
;
ƒƒ 
if
≈≈ 
(
≈≈ 
a
≈≈ 
&&
≈≈ 

b
≈≈
 
)
≈≈ 
return
≈≈ 
$num
≈≈ 
;
≈≈ 
return
∆∆ 	
-
∆∆
 
$num
∆∆ 
;
∆∆ 
}
«« 
public
…… 
bool
……	 #
GetConstrainedEdgeCCW
…… #
(
……& ' 
TriangulationPoint
……( :
p
……; <
)
……= >
{
……? @
return
……A G
EdgeIsConstrained
……H Y
[
……Y Z
(
……Z [
IndexOf
……[ b
(
……b c
p
……c d
)
……d e
+
……e f
$num
……f g
)
……g h
%
……h i
$num
……i j
]
……j k
;
……k l
}
……m n
public
   
bool
  	 "
GetConstrainedEdgeCW
   "
(
  & ' 
TriangulationPoint
  ( :
p
  ; <
)
  = >
{
  ? @
return
  A G
EdgeIsConstrained
  H Y
[
  Y Z
(
  Z [
IndexOf
  [ b
(
  b c
p
  c d
)
  d e
+
  e f
$num
  f g
)
  g h
%
  h i
$num
  i j
]
  j k
;
  k l
}
  m n
public
ÀÀ 
bool
ÀÀ	 &
GetConstrainedEdgeAcross
ÀÀ &
(
ÀÀ& ' 
TriangulationPoint
ÀÀ( :
p
ÀÀ; <
)
ÀÀ= >
{
ÀÀ? @
return
ÀÀA G
EdgeIsConstrained
ÀÀH Y
[
ÀÀY Z
IndexOf
ÀÀ[ b
(
ÀÀb c
p
ÀÀc d
)
ÀÀd e
]
ÀÀj k
;
ÀÀk l
}
ÀÀm n
public
ÃÃ 
void
ÃÃ	 #
SetConstrainedEdgeCCW
ÃÃ #
(
ÃÃ& ' 
TriangulationPoint
ÃÃ( :
p
ÃÃ; <
,
ÃÃ< =
bool
ÃÃ> B
ce
ÃÃC E
)
ÃÃF G
{
ÃÃH I
EdgeIsConstrained
ÃÃJ [
[
ÃÃ[ \
(
ÃÃ\ ]
IndexOf
ÃÃ] d
(
ÃÃd e
p
ÃÃe f
)
ÃÃf g
+
ÃÃg h
$num
ÃÃh i
)
ÃÃi j
%
ÃÃj k
$num
ÃÃk l
]
ÃÃl m
=
ÃÃn o
ce
ÃÃp r
;
ÃÃr s
}
ÃÃt u
public
ÕÕ 
void
ÕÕ	 "
SetConstrainedEdgeCW
ÕÕ "
(
ÕÕ& ' 
TriangulationPoint
ÕÕ( :
p
ÕÕ; <
,
ÕÕ< =
bool
ÕÕ> B
ce
ÕÕC E
)
ÕÕF G
{
ÕÕH I
EdgeIsConstrained
ÕÕJ [
[
ÕÕ[ \
(
ÕÕ\ ]
IndexOf
ÕÕ] d
(
ÕÕd e
p
ÕÕe f
)
ÕÕf g
+
ÕÕg h
$num
ÕÕh i
)
ÕÕi j
%
ÕÕj k
$num
ÕÕk l
]
ÕÕl m
=
ÕÕn o
ce
ÕÕp r
;
ÕÕr s
}
ÕÕt u
public
ŒŒ 
void
ŒŒ	 &
SetConstrainedEdgeAcross
ŒŒ &
(
ŒŒ& ' 
TriangulationPoint
ŒŒ( :
p
ŒŒ; <
,
ŒŒ< =
bool
ŒŒ> B
ce
ŒŒC E
)
ŒŒF G
{
ŒŒH I
EdgeIsConstrained
ŒŒJ [
[
ŒŒ[ \
IndexOf
ŒŒ] d
(
ŒŒd e
p
ŒŒe f
)
ŒŒf g
]
ŒŒl m
=
ŒŒn o
ce
ŒŒp r
;
ŒŒr s
}
ŒŒt u
public
–– 
bool
––	  
GetDelaunayEdgeCCW
––  
(
––# $ 
TriangulationPoint
––% 7
p
––8 9
)
––: ;
{
––< =
return
––> D
EdgeIsDelaunay
––E S
[
––S T
(
––T U
IndexOf
––U \
(
––\ ]
p
––] ^
)
––^ _
+
––_ `
$num
––` a
)
––a b
%
––b c
$num
––c d
]
––d e
;
––e f
}
––g h
public
—— 
bool
——	 
GetDelaunayEdgeCW
—— 
(
——# $ 
TriangulationPoint
——% 7
p
——8 9
)
——: ;
{
——< =
return
——> D
EdgeIsDelaunay
——E S
[
——S T
(
——T U
IndexOf
——U \
(
——\ ]
p
——] ^
)
——^ _
+
——_ `
$num
——` a
)
——a b
%
——b c
$num
——c d
]
——d e
;
——e f
}
——g h
public
““ 
bool
““	 #
GetDelaunayEdgeAcross
““ #
(
““# $ 
TriangulationPoint
““% 7
p
““8 9
)
““: ;
{
““< =
return
““> D
EdgeIsDelaunay
““E S
[
““S T
IndexOf
““U \
(
““\ ]
p
““] ^
)
““^ _
]
““d e
;
““e f
}
““g h
public
”” 
void
””	  
SetDelaunayEdgeCCW
””  
(
””# $ 
TriangulationPoint
””% 7
p
””8 9
,
””9 :
bool
””; ?
ce
””@ B
)
””C D
{
””E F
EdgeIsDelaunay
””G U
[
””U V
(
””V W
IndexOf
””W ^
(
””^ _
p
””_ `
)
””` a
+
””a b
$num
””b c
)
””c d
%
””d e
$num
””e f
]
””f g
=
””h i
ce
””j l
;
””l m
}
””n o
public
‘‘ 
void
‘‘	 
SetDelaunayEdgeCW
‘‘ 
(
‘‘# $ 
TriangulationPoint
‘‘% 7
p
‘‘8 9
,
‘‘9 :
bool
‘‘; ?
ce
‘‘@ B
)
‘‘C D
{
‘‘E F
EdgeIsDelaunay
‘‘G U
[
‘‘U V
(
‘‘V W
IndexOf
‘‘W ^
(
‘‘^ _
p
‘‘_ `
)
‘‘` a
+
‘‘a b
$num
‘‘b c
)
‘‘c d
%
‘‘d e
$num
‘‘e f
]
‘‘f g
=
‘‘h i
ce
‘‘j l
;
‘‘l m
}
‘‘n o
public
’’ 
void
’’	 #
SetDelaunayEdgeAcross
’’ #
(
’’# $ 
TriangulationPoint
’’% 7
p
’’8 9
,
’’9 :
bool
’’; ?
ce
’’@ B
)
’’C D
{
’’E F
EdgeIsDelaunay
’’G U
[
’’U V
IndexOf
’’W ^
(
’’^ _
p
’’_ `
)
’’` a
]
’’f g
=
’’h i
ce
’’j l
;
’’l m
}
’’n o
}
÷÷ 
}◊◊ Ù
•D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\TriangulationMode.cs
	namespace   	
UnityEngine  
 
.   

ProBuilder    
.    !
Poly2Tri  ! )
{  * +
enum!! 
TriangulationMode!! 
{!! 
Unconstrained"" 
,"" 
Constrained"" 
,"" 
Polygon"" #
}## 
}$$ ı
≠D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\TriangulationDebugContext.cs
	namespace   	
UnityEngine  
 
.   

ProBuilder    
.    !
Poly2Tri  ! )
{  * +
abstract!! 	
class!!
 %
TriangulationDebugContext!! )
{!!* +
	protected""  
TriangulationContext""  
_tcx""! %
;""% &
public$$ %
TriangulationDebugContext$$	 "
($$" # 
TriangulationContext$$# 7
tcx$$8 ;
)$$; <
{$$= >
_tcx%% 
=%% 	
tcx%%
 
;%% 
}&& 
public(( 
abstract((	 
void(( 
Clear(( 
((( 
)(( 
;(( 
})) 
}** Ë
µD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Delaunay\Sweep\AdvancingFrontNode.cs
	namespace&& 	
UnityEngine&&
 
.&& 

ProBuilder&&  
.&&  !
Poly2Tri&&! )
{&&* +
class'' 
AdvancingFrontNode'' 
{'' 
public(( 
AdvancingFrontNode((	 
Next((  
;((  !
public)) 
AdvancingFrontNode))	 
Prev))  
;))  !
public** 
double**	 
Value** !
;**! "
public++ 
TriangulationPoint++	 
Point++ !
;++! "
public,, 
DelaunayTriangle,,	 
Triangle,, $
;,,$ %
public.. 
AdvancingFrontNode..	 
(.. 
TriangulationPoint.. .
point../ 4
)..4 5
{..6 7
this// 
.// 
Point// 
=// 
point// 
;// 
Value00 
=00	 

point00 
.00 
X00 
;00 
}11 
public33 
bool33	 
HasNext33 
{33 
get33 
{33 
return33 $
Next33% )
!=33* ,
null33- 1
;331 2
}333 4
}335 6
public44 
bool44	 
HasPrev44 
{44 
get44 
{44 
return44 $
Prev44% )
!=44* ,
null44- 1
;441 2
}443 4
}445 6
}55 
}66 ¡ø
™D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Delaunay\Sweep\DTSweep.cs
	namespace55 	
UnityEngine55
 
.55 

ProBuilder55  
.55  !
Poly2Tri55! )
{55* +
static66 
class66 
DTSweep66 
{66 
private77 	
const77
 
double77 
PI_div277 
=77  
Math77! %
.77% &
PI77& (
/77) *
$num77+ ,
;77, -
private88 	
const88
 
double88 
PI_3div488 
=88  !
$num88" #
*88$ %
Math88& *
.88* +
PI88+ -
/88. /
$num880 1
;881 2
public== 
static==	 
void== 
Triangulate==  
(==  !
DTSweepContext==" 0
tcx==1 4
)==5 6
{==7 8
tcx>> 
.>>  
CreateAdvancingFront>> 
(>> 
)>> 
;>> 
Sweep@@ 
(@@ 	
tcx@@	 
)@@ 
;@@ 
ifQQ 
(QQ 
tcxQQ 

.QQ
 
TriangulationModeQQ 
==QQ 
TriangulationModeQQ  1
.QQ1 2
PolygonQQ2 9
)QQ9 :
{QQ; <
FinalizationPolygonRR 
(RR 
tcxRR 
)RR 
;RR 
}SS 
elseSS 	
{SS
 "
FinalizationConvexHullTT 
(TT 
tcxTT 
)TT 
;TT  
}UU 
tcxWW 
.WW 
DoneWW 
(WW 
)WW 
;WW 
}XX 
private]] 	
static]]
 
void]] 
Sweep]] 
(]] 
DTSweepContext]] +
tcx]], /
)]]0 1
{]]2 3
var^^ 
points^^ 
=^^ 
tcx^^ 
.^^ 
Points^^ 
;^^ 
TriangulationPoint__ 
point__ 
;__ 
AdvancingFrontNode`` 
node`` 
;`` 
forbb 
(bb 
intbb 
ibb 
=bb 
$numbb 
;bb 
ibb 
<bb 
pointsbb 
.bb 
Countbb #
;bb# $
ibb% &
++bb& (
)bb( )
{bb* +
pointcc 	
=cc
 
pointscc 
[cc 
icc 
]cc 
;cc 
nodeee 
=ee	 


PointEventee 
(ee 
tcxee 
,ee 
pointee  
)ee  !
;ee! "
ifgg 
(gg 
pointgg 
.gg 
HasEdgesgg 
)gg 
foreachgg 
(gg  !
DTSweepConstraintgg! 2
egg3 4
ingg5 7
pointgg8 =
.gg= >
Edgesgg> C
)ggC D
{ggE F
ifhh 
(hh 	
tcxhh	 
.hh 
IsDebugEnabledhh 
)hh 
tcxhh  
.hh  !
DTDebugContexthh! /
.hh/ 0
ActiveConstrainthh0 @
=hhA B
ehhC D
;hhD E
	EdgeEventii 
(ii 
tcxii 
,ii 
eii 
,ii 
nodeii 
)ii 
;ii 
}jj 
tcxkk 
.kk 
Updatekk 
(kk 
nullkk 
)kk 
;kk 
}ll 
}mm 
privaterr 	
staticrr
 
voidrr "
FinalizationConvexHullrr ,
(rr, -
DTSweepContextrr. <
tcxrr= @
)rrA B
{rrC D
AdvancingFrontNodess 
n1ss 
,ss 
n2ss 
;ss 
DelaunayTrianglett 
t1tt 
;tt 
TriangulationPointuu 
firstuu 
,uu 
p1uu 
;uu  
n1ww 
=ww 
tcxww 
.ww 
Frontww 
.ww 
Headww 
.ww 
Nextww 
;ww 
n2xx 
=xx 
n1xx 

.xx
 
Nextxx 
;xx 
firstyy 
=yy	 

n1yy 
.yy 
Pointyy 
;yy $
TurnAdvancingFrontConvex{{ 
({{ 
tcx{{ 
,{{  
n1{{! #
,{{# $
n2{{% '
){{' (
;{{( )
n1}} 
=}} 
tcx}} 
.}} 
Front}} 
.}} 
Tail}} 
.}} 
Prev}} 
;}} 
if~~ 
(~~ 
n1~~ 	
.~~	 

Triangle~~
 
.~~ 
Contains~~ 
(~~ 
n1~~ 
.~~ 
Next~~ #
.~~# $
Point~~$ )
)~~) *
&&~~+ -
n1~~. 0
.~~0 1
Triangle~~1 9
.~~9 :
Contains~~: B
(~~B C
n1~~C E
.~~E F
Prev~~F J
.~~J K
Point~~K P
)~~P Q
)~~Q R
{~~S T
t1 
= 
n1	 
. 
Triangle 
. 
NeighborAcrossFrom '
(' (
n1( *
.* +
Point+ 0
)0 1
;1 2 
RotateTrianglePair
ÄÄ 
(
ÄÄ 
n1
ÄÄ 
.
ÄÄ 
Triangle
ÄÄ "
,
ÄÄ" #
n1
ÄÄ$ &
.
ÄÄ& '
Point
ÄÄ' ,
,
ÄÄ, -
t1
ÄÄ. 0
,
ÄÄ0 1
t1
ÄÄ2 4
.
ÄÄ4 5
OppositePoint
ÄÄ5 B
(
ÄÄB C
n1
ÄÄC E
.
ÄÄE F
Triangle
ÄÄF N
,
ÄÄN O
n1
ÄÄP R
.
ÄÄR S
Point
ÄÄS X
)
ÄÄX Y
)
ÄÄY Z
;
ÄÄZ [
tcx
ÅÅ 
.
ÅÅ  
MapTriangleToNodes
ÅÅ 
(
ÅÅ 
n1
ÅÅ 
.
ÅÅ 
Triangle
ÅÅ &
)
ÅÅ& '
;
ÅÅ' (
tcx
ÇÇ 
.
ÇÇ  
MapTriangleToNodes
ÇÇ 
(
ÇÇ 
t1
ÇÇ 
)
ÇÇ 
;
ÇÇ 
}
ÉÉ 
n1
ÑÑ 
=
ÑÑ 
tcx
ÑÑ 
.
ÑÑ 
Front
ÑÑ 
.
ÑÑ 
Head
ÑÑ 
.
ÑÑ 
Next
ÑÑ 
;
ÑÑ 
if
ÖÖ 
(
ÖÖ 
n1
ÖÖ 	
.
ÖÖ	 

Triangle
ÖÖ
 
.
ÖÖ 
Contains
ÖÖ 
(
ÖÖ 
n1
ÖÖ 
.
ÖÖ 
Prev
ÖÖ #
.
ÖÖ# $
Point
ÖÖ$ )
)
ÖÖ) *
&&
ÖÖ+ -
n1
ÖÖ. 0
.
ÖÖ0 1
Triangle
ÖÖ1 9
.
ÖÖ9 :
Contains
ÖÖ: B
(
ÖÖB C
n1
ÖÖC E
.
ÖÖE F
Next
ÖÖF J
.
ÖÖJ K
Point
ÖÖK P
)
ÖÖP Q
)
ÖÖQ R
{
ÖÖS T
t1
ÜÜ 
=
ÜÜ 
n1
ÜÜ	 
.
ÜÜ 
Triangle
ÜÜ 
.
ÜÜ  
NeighborAcrossFrom
ÜÜ '
(
ÜÜ' (
n1
ÜÜ( *
.
ÜÜ* +
Point
ÜÜ+ 0
)
ÜÜ0 1
;
ÜÜ1 2 
RotateTrianglePair
áá 
(
áá 
n1
áá 
.
áá 
Triangle
áá "
,
áá" #
n1
áá$ &
.
áá& '
Point
áá' ,
,
áá, -
t1
áá. 0
,
áá0 1
t1
áá2 4
.
áá4 5
OppositePoint
áá5 B
(
ááB C
n1
ááC E
.
ááE F
Triangle
ááF N
,
ááN O
n1
ááP R
.
ááR S
Point
ááS X
)
ááX Y
)
ááY Z
;
ááZ [
tcx
àà 
.
àà  
MapTriangleToNodes
àà 
(
àà 
n1
àà 
.
àà 
Triangle
àà &
)
àà& '
;
àà' (
tcx
ââ 
.
ââ  
MapTriangleToNodes
ââ 
(
ââ 
t1
ââ 
)
ââ 
;
ââ 
}
ää 
first
éé 
=
éé	 

tcx
éé 
.
éé 
Front
éé 
.
éé 
Head
éé 
.
éé 
Point
éé 
;
éé  
n2
èè 
=
èè 
tcx
èè 
.
èè 
Front
èè 
.
èè 
Tail
èè 
.
èè 
Prev
èè 
;
èè 
t1
êê 
=
êê 
n2
êê 

.
êê
 
Triangle
êê 
;
êê 
p1
ëë 
=
ëë 
n2
ëë 

.
ëë
 
Point
ëë 
;
ëë 
do
íí 
{
íí 
tcx
ìì 
.
ìì 
RemoveFromList
ìì 
(
ìì 
t1
ìì 
)
ìì 
;
ìì 
p1
îî 
=
îî 
t1
îî	 
.
îî 
PointCCWFrom
îî 
(
îî 
p1
îî 
)
îî 
;
îî 
if
ïï 
(
ïï 
p1
ïï 

==
ïï 
first
ïï 
)
ïï 
break
ïï 
;
ïï 
t1
ññ 
=
ññ 
t1
ññ	 
.
ññ 
NeighborCCWFrom
ññ 
(
ññ 
p1
ññ 
)
ññ 
;
ññ  
}
óó 
while
óó 

(
óó 
true
óó 
)
óó 
;
óó 
first
öö 
=
öö	 

tcx
öö 
.
öö 
Front
öö 
.
öö 
Head
öö 
.
öö 
Next
öö 
.
öö 
Point
öö $
;
öö$ %
p1
õõ 
=
õõ 
t1
õõ 

.
õõ
 
PointCWFrom
õõ 
(
õõ 
tcx
õõ 
.
õõ 
Front
õõ  
.
õõ  !
Head
õõ! %
.
õõ% &
Point
õõ& +
)
õõ+ ,
;
õõ, -
t1
úú 
=
úú 
t1
úú 

.
úú
 
NeighborCWFrom
úú 
(
úú 
tcx
úú 
.
úú 
Front
úú #
.
úú# $
Head
úú$ (
.
úú( )
Point
úú) .
)
úú. /
;
úú/ 0
do
ùù 
{
ùù 
tcx
ûû 
.
ûû 
RemoveFromList
ûû 
(
ûû 
t1
ûû 
)
ûû 
;
ûû 
p1
üü 
=
üü 
t1
üü	 
.
üü 
PointCCWFrom
üü 
(
üü 
p1
üü 
)
üü 
;
üü 
t1
†† 
=
†† 
t1
††	 
.
†† 
NeighborCCWFrom
†† 
(
†† 
p1
†† 
)
†† 
;
††  
}
°° 
while
°° 

(
°° 
p1
°° 
!=
°° 
first
°° 
)
°° 
;
°° 
tcx
££ 
.
££ #
FinalizeTriangulation
££ 
(
££ 
)
££ 
;
££ 
}
§§ 
private
©© 	
static
©©
 
void
©© &
TurnAdvancingFrontConvex
©© .
(
©©. /
DTSweepContext
©©0 >
tcx
©©? B
,
©©B C 
AdvancingFrontNode
©©D V
b
©©W X
,
©©X Y 
AdvancingFrontNode
©©Z l
c
©©m n
)
©©o p
{
©©q r 
AdvancingFrontNode
™™ 
first
™™ 
=
™™ 
b
™™ 
;
™™  
while
´´ 
(
´´	 

c
´´
 
!=
´´ 
tcx
´´ 
.
´´ 
Front
´´ 
.
´´ 
Tail
´´ 
)
´´ 
{
´´  
if
¨¨ 
(
¨¨ 
tcx
¨¨ 
.
¨¨ 
IsDebugEnabled
¨¨ 
)
¨¨ 
tcx
¨¨ 
.
¨¨  
DTDebugContext
¨¨  .
.
¨¨. /

ActiveNode
¨¨/ 9
=
¨¨: ;
c
¨¨< =
;
¨¨= >
if
ÆÆ 
(
ÆÆ 
TriangulationUtil
ÆÆ 
.
ÆÆ 
Orient2d
ÆÆ "
(
ÆÆ" #
b
ÆÆ# $
.
ÆÆ$ %
Point
ÆÆ% *
,
ÆÆ* +
c
ÆÆ, -
.
ÆÆ- .
Point
ÆÆ. 3
,
ÆÆ3 4
c
ÆÆ5 6
.
ÆÆ6 7
Next
ÆÆ7 ;
.
ÆÆ; <
Point
ÆÆ< A
)
ÆÆA B
==
ÆÆC E
Orientation
ÆÆF Q
.
ÆÆQ R
CCW
ÆÆR U
)
ÆÆU V
{
ÆÆW X
Fill
∞∞ 	
(
∞∞	 

tcx
∞∞
 
,
∞∞ 
c
∞∞ 
)
∞∞ 
;
∞∞ 
c
±± 
=
±± 
c
±±	 

.
±±
 
Next
±± 
;
±± 
}
≤≤ 
else
≤≤ 

{
≤≤ 
if
¥¥ 
(
¥¥ 	
b
¥¥	 

!=
¥¥ 
first
¥¥ 
&&
¥¥ 
TriangulationUtil
¥¥ (
.
¥¥( )
Orient2d
¥¥) 1
(
¥¥1 2
b
¥¥2 3
.
¥¥3 4
Prev
¥¥4 8
.
¥¥8 9
Point
¥¥9 >
,
¥¥> ?
b
¥¥@ A
.
¥¥A B
Point
¥¥B G
,
¥¥G H
c
¥¥I J
.
¥¥J K
Point
¥¥K P
)
¥¥P Q
==
¥¥R T
Orientation
¥¥U `
.
¥¥` a
CCW
¥¥a d
)
¥¥d e
{
¥¥f g
Fill
∂∂ 

(
∂∂
 
tcx
∂∂ 
,
∂∂ 
b
∂∂ 
)
∂∂ 
;
∂∂ 
b
∑∑ 
=
∑∑ 	
b
∑∑
 
.
∑∑ 
Prev
∑∑ 
;
∑∑ 
}
∏∏ 
else
∏∏ 
{
∏∏ 
b
∫∫ 
=
∫∫ 	
c
∫∫
 
;
∫∫ 
c
ªª 
=
ªª 	
c
ªª
 
.
ªª 
Next
ªª 
;
ªª 
}
ºº 
}
ΩΩ 
}
ææ 
}
øø 
private
¡¡ 	
static
¡¡
 
void
¡¡ !
FinalizationPolygon
¡¡ )
(
¡¡) *
DTSweepContext
¡¡+ 9
tcx
¡¡: =
)
¡¡> ?
{
¡¡@ A
DelaunayTriangle
√√ 
t
√√ 
=
√√ 
tcx
√√ 
.
√√ 
Front
√√ !
.
√√! "
Head
√√" &
.
√√& '
Next
√√' +
.
√√+ ,
Triangle
√√, 4
;
√√4 5 
TriangulationPoint
ƒƒ 
p
ƒƒ 
=
ƒƒ 
tcx
ƒƒ 
.
ƒƒ 
Front
ƒƒ #
.
ƒƒ# $
Head
ƒƒ$ (
.
ƒƒ( )
Next
ƒƒ) -
.
ƒƒ- .
Point
ƒƒ. 3
;
ƒƒ3 4
while
≈≈ 
(
≈≈	 

!
≈≈
 
t
≈≈ 
.
≈≈ "
GetConstrainedEdgeCW
≈≈ !
(
≈≈! "
p
≈≈" #
)
≈≈# $
)
≈≈$ %
t
≈≈& '
=
≈≈( )
t
≈≈* +
.
≈≈+ ,
NeighborCCWFrom
≈≈, ;
(
≈≈; <
p
≈≈< =
)
≈≈= >
;
≈≈> ?
tcx
»» 
.
»» 
	MeshClean
»» 
(
»» 
t
»» 
)
»» 
;
»» 
}
…… 
private
–– 	
static
––
  
AdvancingFrontNode
–– #

PointEvent
––$ .
(
––. /
DTSweepContext
––0 >
tcx
––? B
,
––B C 
TriangulationPoint
––D V
point
––W \
)
––] ^
{
––_ ` 
AdvancingFrontNode
—— 
node
—— 
,
—— 
newNode
—— #
;
——# $
node
”” 
=
”” 	
tcx
””
 
.
”” 

LocateNode
”” 
(
”” 
point
”” 
)
”” 
;
””  
if
‘‘ 
(
‘‘ 
tcx
‘‘ 

.
‘‘
 
IsDebugEnabled
‘‘ 
)
‘‘ 
tcx
‘‘ 
.
‘‘ 
DTDebugContext
‘‘ -
.
‘‘- .

ActiveNode
‘‘. 8
=
‘‘9 :
node
‘‘; ?
;
‘‘? @
newNode
’’ 

=
’’ 
NewFrontTriangle
’’ 
(
’’ 
tcx
’’ !
,
’’! "
point
’’# (
,
’’( )
node
’’* .
)
’’. /
;
’’/ 0
if
ŸŸ 
(
ŸŸ 
point
ŸŸ 
.
ŸŸ 
X
ŸŸ 
<=
ŸŸ 
node
ŸŸ 
.
ŸŸ 
Point
ŸŸ 
.
ŸŸ 
X
ŸŸ 
+
ŸŸ  
TriangulationUtil
ŸŸ! 2
.
ŸŸ2 3
EPSILON
ŸŸ3 :
)
ŸŸ: ;
Fill
ŸŸ< @
(
ŸŸ@ A
tcx
ŸŸA D
,
ŸŸD E
node
ŸŸF J
)
ŸŸJ K
;
ŸŸK L
tcx
€€ 
.
€€ 
AddNode
€€ 
(
€€ 
newNode
€€ 
)
€€ 
;
€€  
FillAdvancingFront
›› 
(
›› 
tcx
›› 
,
›› 
newNode
›› "
)
››" #
;
››# $
return
ﬁﬁ 	
newNode
ﬁﬁ
 
;
ﬁﬁ 
}
ﬂﬂ 
private
‰‰ 	
static
‰‰
  
AdvancingFrontNode
‰‰ #
NewFrontTriangle
‰‰$ 4
(
‰‰4 5
DTSweepContext
‰‰6 D
tcx
‰‰E H
,
‰‰H I 
TriangulationPoint
‰‰J \
point
‰‰] b
,
‰‰b c 
AdvancingFrontNode
‰‰d v
node
‰‰w {
)
‰‰| }
{
‰‰~  
AdvancingFrontNode
ÂÂ 
newNode
ÂÂ 
;
ÂÂ 
DelaunayTriangle
ÊÊ 
triangle
ÊÊ 
;
ÊÊ 
triangle
ËË 
=
ËË 
new
ËË 
DelaunayTriangle
ËË "
(
ËË" #
point
ËË# (
,
ËË( )
node
ËË* .
.
ËË. /
Point
ËË/ 4
,
ËË4 5
node
ËË6 :
.
ËË: ;
Next
ËË; ?
.
ËË? @
Point
ËË@ E
)
ËËE F
;
ËËF G
triangle
ÈÈ 
.
ÈÈ 
MarkNeighbor
ÈÈ 
(
ÈÈ 
node
ÈÈ 
.
ÈÈ 
Triangle
ÈÈ &
)
ÈÈ& '
;
ÈÈ' (
tcx
ÍÍ 
.
ÍÍ 
	Triangles
ÍÍ 
.
ÍÍ 
Add
ÍÍ 
(
ÍÍ 
triangle
ÍÍ 
)
ÍÍ 
;
ÍÍ 
newNode
ÏÏ 

=
ÏÏ 
new
ÏÏ  
AdvancingFrontNode
ÏÏ #
(
ÏÏ# $
point
ÏÏ$ )
)
ÏÏ) *
;
ÏÏ* +
newNode
ÌÌ 

.
ÌÌ
 
Next
ÌÌ 
=
ÌÌ 
node
ÌÌ 
.
ÌÌ 
Next
ÌÌ 
;
ÌÌ 
newNode
ÓÓ 

.
ÓÓ
 
Prev
ÓÓ 
=
ÓÓ 
node
ÓÓ 
;
ÓÓ 
node
ÔÔ 
.
ÔÔ 
Next
ÔÔ 
.
ÔÔ 
Prev
ÔÔ 
=
ÔÔ 
newNode
ÔÔ 
;
ÔÔ 
node
 
.
 
Next
 
=
 
newNode
 
;
 
tcx
ÚÚ 
.
ÚÚ 
AddNode
ÚÚ 
(
ÚÚ 
newNode
ÚÚ 
)
ÚÚ 
;
ÚÚ 
if
ÙÙ 
(
ÙÙ 
tcx
ÙÙ 

.
ÙÙ
 
IsDebugEnabled
ÙÙ 
)
ÙÙ 
tcx
ÙÙ 
.
ÙÙ 
DTDebugContext
ÙÙ -
.
ÙÙ- .

ActiveNode
ÙÙ. 8
=
ÙÙ9 :
newNode
ÙÙ; B
;
ÙÙB C
if
ˆˆ 
(
ˆˆ 
!
ˆˆ 
Legalize
ˆˆ 
(
ˆˆ 
tcx
ˆˆ 
,
ˆˆ 
triangle
ˆˆ 
)
ˆˆ 
)
ˆˆ  
tcx
ˆˆ! $
.
ˆˆ$ % 
MapTriangleToNodes
ˆˆ% 7
(
ˆˆ7 8
triangle
ˆˆ8 @
)
ˆˆ@ A
;
ˆˆA B
return
¯¯ 	
newNode
¯¯
 
;
¯¯ 
}
˘˘ 
private
˚˚ 	
static
˚˚
 
void
˚˚ 
	EdgeEvent
˚˚ 
(
˚˚  
DTSweepContext
˚˚! /
tcx
˚˚0 3
,
˚˚3 4
DTSweepConstraint
˚˚5 F
edge
˚˚G K
,
˚˚K L 
AdvancingFrontNode
˚˚M _
node
˚˚` d
)
˚˚e f
{
˚˚g h
try
¸¸ 
{
˝˝ 
tcx
˛˛ 
.
˛˛ 
	EdgeEvent
˛˛ 
.
˛˛ 
ConstrainedEdge
˛˛ !
=
˛˛" #
edge
˛˛$ (
;
˛˛( )
tcx
ˇˇ 
.
ˇˇ 
	EdgeEvent
ˇˇ 
.
ˇˇ 
Right
ˇˇ 
=
ˇˇ 
edge
ˇˇ 
.
ˇˇ 
P
ˇˇ  
.
ˇˇ  !
X
ˇˇ! "
>
ˇˇ# $
edge
ˇˇ% )
.
ˇˇ) *
Q
ˇˇ* +
.
ˇˇ+ ,
X
ˇˇ, -
;
ˇˇ- .
if
ÅÅ 
(
ÅÅ 
tcx
ÅÅ 
.
ÅÅ 
IsDebugEnabled
ÅÅ 
)
ÅÅ 
{
ÅÅ 
tcx
ÅÅ !
.
ÅÅ! "
DTDebugContext
ÅÅ" 0
.
ÅÅ0 1
PrimaryTriangle
ÅÅ1 @
=
ÅÅA B
node
ÅÅC G
.
ÅÅG H
Triangle
ÅÅH P
;
ÅÅP Q
}
ÅÅR S
if
ÉÉ 
(
ÉÉ "
IsEdgeSideOfTriangle
ÉÉ 
(
ÉÉ 
node
ÉÉ !
.
ÉÉ! "
Triangle
ÉÉ" *
,
ÉÉ* +
edge
ÉÉ, 0
.
ÉÉ0 1
P
ÉÉ1 2
,
ÉÉ2 3
edge
ÉÉ4 8
.
ÉÉ8 9
Q
ÉÉ9 :
)
ÉÉ: ;
)
ÉÉ; <
return
ÑÑ 
;
ÑÑ 
FillEdgeEvent
ââ 
(
ââ 
tcx
ââ 
,
ââ 
edge
ââ 
,
ââ 
node
ââ !
)
ââ! "
;
ââ" #
	EdgeEvent
ãã 
(
ãã 
tcx
ãã 
,
ãã 
edge
ãã 
.
ãã 
P
ãã 
,
ãã 
edge
ãã 
.
ãã  
Q
ãã  !
,
ãã! "
node
ãã# '
.
ãã' (
Triangle
ãã( 0
,
ãã0 1
edge
ãã2 6
.
ãã6 7
Q
ãã7 8
)
ãã8 9
;
ãã9 :
}
åå 
catch
çç 
{
çç	 

}
çç 
}
ìì 
private
ïï 	
static
ïï
 
void
ïï 
FillEdgeEvent
ïï #
(
ïï# $
DTSweepContext
ïï% 3
tcx
ïï4 7
,
ïï7 8
DTSweepConstraint
ïï9 J
edge
ïïK O
,
ïïO P 
AdvancingFrontNode
ïïQ c
node
ïïd h
)
ïïi j
{
ïïk l
if
ññ 
(
ññ 
tcx
ññ 

.
ññ
 
	EdgeEvent
ññ 
.
ññ 
Right
ññ 
)
ññ 
{
ññ %
FillRightAboveEdgeEvent
óó 
(
óó 
tcx
óó 
,
óó  
edge
óó! %
,
óó% &
node
óó' +
)
óó+ ,
;
óó, -
}
òò 
else
òò 	
{
òò
 $
FillLeftAboveEdgeEvent
ôô 
(
ôô 
tcx
ôô 
,
ôô 
edge
ôô  $
,
ôô$ %
node
ôô& *
)
ôô* +
;
ôô+ ,
}
öö 
}
õõ 
private
ùù 	
static
ùù
 
void
ùù '
FillRightConcaveEdgeEvent
ùù /
(
ùù/ 0
DTSweepContext
ùù1 ?
tcx
ùù@ C
,
ùùC D
DTSweepConstraint
ùùE V
edge
ùùW [
,
ùù[ \ 
AdvancingFrontNode
ùù] o
node
ùùp t
)
ùùu v
{
ùùw x
Fill
ûû 
(
ûû 
tcx
ûû 
,
ûû 
node
ûû 
.
ûû 
Next
ûû 
)
ûû 
;
ûû 
if
üü 
(
üü 
node
üü 
.
üü 
Next
üü 
.
üü 
Point
üü 
!=
üü 
edge
üü 
.
üü 
P
üü  
)
üü  !
{
üü" #
if
°° 
(
°° 
TriangulationUtil
°° 
.
°° 
Orient2d
°° "
(
°°" #
edge
°°# '
.
°°' (
Q
°°( )
,
°°) *
node
°°+ /
.
°°/ 0
Next
°°0 4
.
°°4 5
Point
°°5 :
,
°°: ;
edge
°°< @
.
°°@ A
P
°°A B
)
°°B C
==
°°D F
Orientation
°°G R
.
°°R S
CCW
°°S V
)
°°V W
{
°°X Y
if
££ 
(
££ 	
TriangulationUtil
££	 
.
££ 
Orient2d
££ #
(
££# $
node
££$ (
.
££( )
Point
££) .
,
££. /
node
££0 4
.
££4 5
Next
££5 9
.
££9 :
Point
££: ?
,
££? @
node
££A E
.
££E F
Next
££F J
.
££J K
Next
££K O
.
££O P
Point
££P U
)
££U V
==
££W Y
Orientation
££Z e
.
££e f
CCW
££f i
)
££i j
{
££k l'
FillRightConcaveEdgeEvent
•• 
(
••  
tcx
••  #
,
••# $
edge
••% )
,
••) *
node
••+ /
)
••/ 0
;
••0 1
}
¶¶ 
else
¶¶ 
{
¶¶ 
}
®® 
}
©© 
}
™™ 
}
´´ 
private
≠≠ 	
static
≠≠
 
void
≠≠ &
FillRightConvexEdgeEvent
≠≠ .
(
≠≠. /
DTSweepContext
≠≠0 >
tcx
≠≠? B
,
≠≠B C
DTSweepConstraint
≠≠D U
edge
≠≠V Z
,
≠≠Z [ 
AdvancingFrontNode
≠≠\ n
node
≠≠o s
)
≠≠t u
{
≠≠v w
if
ØØ 
(
ØØ 
TriangulationUtil
ØØ 
.
ØØ 
Orient2d
ØØ !
(
ØØ! "
node
ØØ" &
.
ØØ& '
Next
ØØ' +
.
ØØ+ ,
Point
ØØ, 1
,
ØØ1 2
node
ØØ3 7
.
ØØ7 8
Next
ØØ8 <
.
ØØ< =
Next
ØØ= A
.
ØØA B
Point
ØØB G
,
ØØG H
node
ØØI M
.
ØØM N
Next
ØØN R
.
ØØR S
Next
ØØS W
.
ØØW X
Next
ØØX \
.
ØØ\ ]
Point
ØØ] b
)
ØØb c
==
ØØd f
Orientation
ØØg r
.
ØØr s
CCW
ØØs v
)
ØØv w
{
ØØx y'
FillRightConcaveEdgeEvent
±± 
(
±± 
tcx
±± !
,
±±! "
edge
±±# '
,
±±' (
node
±±) -
.
±±- .
Next
±±. 2
)
±±2 3
;
±±3 4
}
≤≤ 
else
≤≤ 	
{
≤≤
 
if
µµ 
(
µµ 
TriangulationUtil
µµ 
.
µµ 
Orient2d
µµ "
(
µµ" #
edge
µµ# '
.
µµ' (
Q
µµ( )
,
µµ) *
node
µµ+ /
.
µµ/ 0
Next
µµ0 4
.
µµ4 5
Next
µµ5 9
.
µµ9 :
Point
µµ: ?
,
µµ? @
edge
µµA E
.
µµE F
P
µµF G
)
µµG H
==
µµI K
Orientation
µµL W
.
µµW X
CCW
µµX [
)
µµ[ \
{
µµ] ^&
FillRightConvexEdgeEvent
∑∑ 
(
∑∑ 
tcx
∑∑ !
,
∑∑! "
edge
∑∑# '
,
∑∑' (
node
∑∑) -
.
∑∑- .
Next
∑∑. 2
)
∑∑2 3
;
∑∑3 4
}
∏∏ 
else
∏∏ 

{
∏∏ 
}
∫∫ 
}
ªª 
}
ºº 
private
ææ 	
static
ææ
 
void
ææ %
FillRightBelowEdgeEvent
ææ -
(
ææ- .
DTSweepContext
ææ/ =
tcx
ææ> A
,
ææA B
DTSweepConstraint
ææC T
edge
ææU Y
,
ææY Z 
AdvancingFrontNode
ææ[ m
node
ææn r
)
ææs t
{
ææu v
if
øø 
(
øø 
tcx
øø 

.
øø
 
IsDebugEnabled
øø 
)
øø 
tcx
øø 
.
øø 
DTDebugContext
øø -
.
øø- .

ActiveNode
øø. 8
=
øø9 :
node
øø; ?
;
øø? @
if
¡¡ 
(
¡¡ 
node
¡¡ 
.
¡¡ 
Point
¡¡ 
.
¡¡ 
X
¡¡ 
<
¡¡ 
edge
¡¡ 
.
¡¡ 
P
¡¡ 
.
¡¡ 
X
¡¡ 
)
¡¡ 
{
¡¡  !
if
¬¬ 
(
¬¬ 
TriangulationUtil
¬¬ 
.
¬¬ 
Orient2d
¬¬ "
(
¬¬" #
node
¬¬# '
.
¬¬' (
Point
¬¬( -
,
¬¬- .
node
¬¬/ 3
.
¬¬3 4
Next
¬¬4 8
.
¬¬8 9
Point
¬¬9 >
,
¬¬> ?
node
¬¬@ D
.
¬¬D E
Next
¬¬E I
.
¬¬I J
Next
¬¬J N
.
¬¬N O
Point
¬¬O T
)
¬¬T U
==
¬¬V X
Orientation
¬¬Y d
.
¬¬d e
CCW
¬¬e h
)
¬¬h i
{
¬¬j k'
FillRightConcaveEdgeEvent
ƒƒ 
(
ƒƒ 
tcx
ƒƒ "
,
ƒƒ" #
edge
ƒƒ$ (
,
ƒƒ( )
node
ƒƒ* .
)
ƒƒ. /
;
ƒƒ/ 0
}
≈≈ 
else
≈≈ 

{
≈≈ &
FillRightConvexEdgeEvent
«« 
(
«« 
tcx
«« !
,
««! "
edge
««# '
,
««' (
node
««) -
)
««- .
;
««. /%
FillRightBelowEdgeEvent
…… 
(
…… 
tcx
……  
,
……  !
edge
……" &
,
……& '
node
……( ,
)
……, -
;
……- .
}
   
}
ÃÃ 
}
ÕÕ 
private
œœ 	
static
œœ
 
void
œœ %
FillRightAboveEdgeEvent
œœ -
(
œœ- .
DTSweepContext
œœ/ =
tcx
œœ> A
,
œœA B
DTSweepConstraint
œœC T
edge
œœU Y
,
œœY Z 
AdvancingFrontNode
œœ[ m
node
œœn r
)
œœs t
{
œœu v
while
–– 
(
––	 

node
––
 
.
–– 
Next
–– 
.
–– 
Point
–– 
.
–– 
X
–– 
<
–– 
edge
–– "
.
––" #
P
––# $
.
––$ %
X
––% &
)
––& '
{
––( )
if
—— 
(
—— 
tcx
—— 
.
—— 
IsDebugEnabled
—— 
)
—— 
{
—— 
tcx
—— !
.
——! "
DTDebugContext
——" 0
.
——0 1

ActiveNode
——1 ;
=
——< =
node
——> B
;
——B C
}
——D E
Orientation
”” 
o1
”” 
=
”” 
TriangulationUtil
”” &
.
””& '
Orient2d
””' /
(
””/ 0
edge
””0 4
.
””4 5
Q
””5 6
,
””6 7
node
””8 <
.
””< =
Next
””= A
.
””A B
Point
””B G
,
””G H
edge
””I M
.
””M N
P
””N O
)
””O P
;
””P Q
if
‘‘ 
(
‘‘ 
o1
‘‘ 

==
‘‘ 
Orientation
‘‘ 
.
‘‘ 
CCW
‘‘ 
)
‘‘ 
{
‘‘  %
FillRightBelowEdgeEvent
’’ 
(
’’ 
tcx
’’  
,
’’  !
edge
’’" &
,
’’& '
node
’’( ,
)
’’, -
;
’’- .
}
÷÷ 
else
÷÷ 

{
÷÷ 
node
◊◊ 	
=
◊◊
 
node
◊◊ 
.
◊◊ 
Next
◊◊ 
;
◊◊ 
}
ÿÿ 
}
ŸŸ 
}
⁄⁄ 
private
‹‹ 	
static
‹‹
 
void
‹‹ %
FillLeftConvexEdgeEvent
‹‹ -
(
‹‹- .
DTSweepContext
‹‹/ =
tcx
‹‹> A
,
‹‹A B
DTSweepConstraint
‹‹C T
edge
‹‹U Y
,
‹‹Y Z 
AdvancingFrontNode
‹‹[ m
node
‹‹n r
)
‹‹s t
{
‹‹u v
if
ﬁﬁ 
(
ﬁﬁ 
TriangulationUtil
ﬁﬁ 
.
ﬁﬁ 
Orient2d
ﬁﬁ !
(
ﬁﬁ! "
node
ﬁﬁ" &
.
ﬁﬁ& '
Prev
ﬁﬁ' +
.
ﬁﬁ+ ,
Point
ﬁﬁ, 1
,
ﬁﬁ1 2
node
ﬁﬁ3 7
.
ﬁﬁ7 8
Prev
ﬁﬁ8 <
.
ﬁﬁ< =
Prev
ﬁﬁ= A
.
ﬁﬁA B
Point
ﬁﬁB G
,
ﬁﬁG H
node
ﬁﬁI M
.
ﬁﬁM N
Prev
ﬁﬁN R
.
ﬁﬁR S
Prev
ﬁﬁS W
.
ﬁﬁW X
Prev
ﬁﬁX \
.
ﬁﬁ\ ]
Point
ﬁﬁ] b
)
ﬁﬁb c
==
ﬁﬁd f
Orientation
ﬁﬁg r
.
ﬁﬁr s
CW
ﬁﬁs u
)
ﬁﬁu v
{
ﬁﬁw x&
FillLeftConcaveEdgeEvent
‡‡ 
(
‡‡ 
tcx
‡‡  
,
‡‡  !
edge
‡‡" &
,
‡‡& '
node
‡‡( ,
.
‡‡, -
Prev
‡‡- 1
)
‡‡1 2
;
‡‡2 3
}
·· 
else
·· 	
{
··
 
if
‰‰ 
(
‰‰ 
TriangulationUtil
‰‰ 
.
‰‰ 
Orient2d
‰‰ "
(
‰‰" #
edge
‰‰# '
.
‰‰' (
Q
‰‰( )
,
‰‰) *
node
‰‰+ /
.
‰‰/ 0
Prev
‰‰0 4
.
‰‰4 5
Prev
‰‰5 9
.
‰‰9 :
Point
‰‰: ?
,
‰‰? @
edge
‰‰A E
.
‰‰E F
P
‰‰F G
)
‰‰G H
==
‰‰I K
Orientation
‰‰L W
.
‰‰W X
CW
‰‰X Z
)
‰‰Z [
{
‰‰\ ]%
FillLeftConvexEdgeEvent
ÊÊ 
(
ÊÊ 
tcx
ÊÊ  
,
ÊÊ  !
edge
ÊÊ" &
,
ÊÊ& '
node
ÊÊ( ,
.
ÊÊ, -
Prev
ÊÊ- 1
)
ÊÊ1 2
;
ÊÊ2 3
}
ÁÁ 
else
ÁÁ 

{
ÁÁ 
}
ÈÈ 
}
ÍÍ 
}
ÎÎ 
private
ÌÌ 	
static
ÌÌ
 
void
ÌÌ &
FillLeftConcaveEdgeEvent
ÌÌ .
(
ÌÌ. /
DTSweepContext
ÌÌ0 >
tcx
ÌÌ? B
,
ÌÌB C
DTSweepConstraint
ÌÌD U
edge
ÌÌV Z
,
ÌÌZ [ 
AdvancingFrontNode
ÌÌ\ n
node
ÌÌo s
)
ÌÌt u
{
ÌÌv w
Fill
ÓÓ 
(
ÓÓ 
tcx
ÓÓ 
,
ÓÓ 
node
ÓÓ 
.
ÓÓ 
Prev
ÓÓ 
)
ÓÓ 
;
ÓÓ 
if
ÔÔ 
(
ÔÔ 
node
ÔÔ 
.
ÔÔ 
Prev
ÔÔ 
.
ÔÔ 
Point
ÔÔ 
!=
ÔÔ 
edge
ÔÔ 
.
ÔÔ 
P
ÔÔ  
)
ÔÔ  !
{
ÔÔ" #
if
ÒÒ 
(
ÒÒ 
TriangulationUtil
ÒÒ 
.
ÒÒ 
Orient2d
ÒÒ "
(
ÒÒ" #
edge
ÒÒ# '
.
ÒÒ' (
Q
ÒÒ( )
,
ÒÒ) *
node
ÒÒ+ /
.
ÒÒ/ 0
Prev
ÒÒ0 4
.
ÒÒ4 5
Point
ÒÒ5 :
,
ÒÒ: ;
edge
ÒÒ< @
.
ÒÒ@ A
P
ÒÒA B
)
ÒÒB C
==
ÒÒD F
Orientation
ÒÒG R
.
ÒÒR S
CW
ÒÒS U
)
ÒÒU V
{
ÒÒW X
if
ÛÛ 
(
ÛÛ 	
TriangulationUtil
ÛÛ	 
.
ÛÛ 
Orient2d
ÛÛ #
(
ÛÛ# $
node
ÛÛ$ (
.
ÛÛ( )
Point
ÛÛ) .
,
ÛÛ. /
node
ÛÛ0 4
.
ÛÛ4 5
Prev
ÛÛ5 9
.
ÛÛ9 :
Point
ÛÛ: ?
,
ÛÛ? @
node
ÛÛA E
.
ÛÛE F
Prev
ÛÛF J
.
ÛÛJ K
Prev
ÛÛK O
.
ÛÛO P
Point
ÛÛP U
)
ÛÛU V
==
ÛÛW Y
Orientation
ÛÛZ e
.
ÛÛe f
CW
ÛÛf h
)
ÛÛh i
{
ÛÛj k&
FillLeftConcaveEdgeEvent
ıı 
(
ıı 
tcx
ıı "
,
ıı" #
edge
ıı$ (
,
ıı( )
node
ıı* .
)
ıı. /
;
ıı/ 0
}
ˆˆ 
else
ˆˆ 
{
ˆˆ 
}
¯¯ 
}
˘˘ 
}
˙˙ 
}
˚˚ 
private
˝˝ 	
static
˝˝
 
void
˝˝ $
FillLeftBelowEdgeEvent
˝˝ ,
(
˝˝, -
DTSweepContext
˝˝. <
tcx
˝˝= @
,
˝˝@ A
DTSweepConstraint
˝˝B S
edge
˝˝T X
,
˝˝X Y 
AdvancingFrontNode
˝˝Z l
node
˝˝m q
)
˝˝r s
{
˝˝t u
if
˛˛ 
(
˛˛ 
tcx
˛˛ 

.
˛˛
 
IsDebugEnabled
˛˛ 
)
˛˛ 
tcx
˛˛ 
.
˛˛ 
DTDebugContext
˛˛ -
.
˛˛- .

ActiveNode
˛˛. 8
=
˛˛9 :
node
˛˛; ?
;
˛˛? @
if
ÄÄ 
(
ÄÄ 
node
ÄÄ 
.
ÄÄ 
Point
ÄÄ 
.
ÄÄ 
X
ÄÄ 
>
ÄÄ 
edge
ÄÄ 
.
ÄÄ 
P
ÄÄ 
.
ÄÄ 
X
ÄÄ 
)
ÄÄ 
{
ÄÄ  !
if
ÅÅ 
(
ÅÅ 
TriangulationUtil
ÅÅ 
.
ÅÅ 
Orient2d
ÅÅ "
(
ÅÅ" #
node
ÅÅ# '
.
ÅÅ' (
Point
ÅÅ( -
,
ÅÅ- .
node
ÅÅ/ 3
.
ÅÅ3 4
Prev
ÅÅ4 8
.
ÅÅ8 9
Point
ÅÅ9 >
,
ÅÅ> ?
node
ÅÅ@ D
.
ÅÅD E
Prev
ÅÅE I
.
ÅÅI J
Prev
ÅÅJ N
.
ÅÅN O
Point
ÅÅO T
)
ÅÅT U
==
ÅÅV X
Orientation
ÅÅY d
.
ÅÅd e
CW
ÅÅe g
)
ÅÅg h
{
ÅÅi j&
FillLeftConcaveEdgeEvent
ÉÉ 
(
ÉÉ 
tcx
ÉÉ !
,
ÉÉ! "
edge
ÉÉ# '
,
ÉÉ' (
node
ÉÉ) -
)
ÉÉ- .
;
ÉÉ. /
}
ÑÑ 
else
ÑÑ 

{
ÑÑ %
FillLeftConvexEdgeEvent
ÜÜ 
(
ÜÜ 
tcx
ÜÜ  
,
ÜÜ  !
edge
ÜÜ" &
,
ÜÜ& '
node
ÜÜ( ,
)
ÜÜ, -
;
ÜÜ- .$
FillLeftBelowEdgeEvent
àà 
(
àà 
tcx
àà 
,
àà  
edge
àà! %
,
àà% &
node
àà' +
)
àà+ ,
;
àà, -
}
ââ 
}
ãã 
}
åå 
private
éé 	
static
éé
 
void
éé $
FillLeftAboveEdgeEvent
éé ,
(
éé, -
DTSweepContext
éé. <
tcx
éé= @
,
éé@ A
DTSweepConstraint
ééB S
edge
ééT X
,
ééX Y 
AdvancingFrontNode
ééZ l
node
éém q
)
éér s
{
éét u
while
èè 
(
èè	 

node
èè
 
.
èè 
Prev
èè 
.
èè 
Point
èè 
.
èè 
X
èè 
>
èè 
edge
èè "
.
èè" #
P
èè# $
.
èè$ %
X
èè% &
)
èè& '
{
èè( )
if
êê 
(
êê 
tcx
êê 
.
êê 
IsDebugEnabled
êê 
)
êê 
tcx
êê 
.
êê  
DTDebugContext
êê  .
.
êê. /

ActiveNode
êê/ 9
=
êê: ;
node
êê< @
;
êê@ A
Orientation
íí 
o1
íí 
=
íí 
TriangulationUtil
íí &
.
íí& '
Orient2d
íí' /
(
íí/ 0
edge
íí0 4
.
íí4 5
Q
íí5 6
,
íí6 7
node
íí8 <
.
íí< =
Prev
íí= A
.
ííA B
Point
ííB G
,
ííG H
edge
ííI M
.
ííM N
P
ííN O
)
ííO P
;
ííP Q
if
ìì 
(
ìì 
o1
ìì 

==
ìì 
Orientation
ìì 
.
ìì 
CW
ìì 
)
ìì 
{
ìì $
FillLeftBelowEdgeEvent
îî 
(
îî 
tcx
îî 
,
îî  
edge
îî! %
,
îî% &
node
îî' +
)
îî+ ,
;
îî, -
}
ïï 
else
ïï 

{
ïï 
node
ññ 	
=
ññ
 
node
ññ 
.
ññ 
Prev
ññ 
;
ññ 
}
óó 
}
òò 
}
ôô 
private
õõ 	
static
õõ
 
bool
õõ "
IsEdgeSideOfTriangle
õõ *
(
õõ* +
DelaunayTriangle
õõ, <
triangle
õõ= E
,
õõE F 
TriangulationPoint
õõG Y
ep
õõZ \
,
õõ\ ] 
TriangulationPoint
õõ^ p
eq
õõq s
)
õõt u
{
õõv w
int
úú 
index
úú 
=
úú 
triangle
úú 
.
úú 
	EdgeIndex
úú !
(
úú! "
ep
úú" $
,
úú$ %
eq
úú& (
)
úú( )
;
úú) *
if
ùù 
(
ùù 
index
ùù 
==
ùù 
-
ùù 
$num
ùù 
)
ùù 
return
ùù 
false
ùù "
;
ùù" #
triangle
ûû 
.
ûû !
MarkConstrainedEdge
ûû 
(
ûû  
index
ûû  %
)
ûû% &
;
ûû& '
triangle
üü 
=
üü 
triangle
üü 
.
üü 
	Neighbors
üü  
[
üü  !
index
üü! &
]
üü& '
;
üü' (
if
†† 
(
†† 
triangle
†† 
!=
†† 
null
†† 
)
†† 
triangle
†† !
.
††! "!
MarkConstrainedEdge
††" 5
(
††5 6
ep
††6 8
,
††8 9
eq
††: <
)
††< =
;
††= >
return
°° 	
true
°°
 
;
°° 
}
¢¢ 
private
§§ 	
static
§§
 
void
§§ 
	EdgeEvent
§§ 
(
§§  
DTSweepContext
§§! /
tcx
§§0 3
,
§§3 4 
TriangulationPoint
§§5 G
ep
§§H J
,
§§J K 
TriangulationPoint
§§L ^
eq
§§_ a
,
§§a b
DelaunayTriangle
§§c s
triangle
§§t |
,
§§| }!
TriangulationPoint§§~ ê
point§§ë ñ
)§§ó ò
{§§ô ö 
TriangulationPoint
•• 
p1
•• 
,
•• 
p2
•• 
;
•• 
if
ßß 
(
ßß 
tcx
ßß 

.
ßß
 
IsDebugEnabled
ßß 
)
ßß 
tcx
ßß 
.
ßß 
DTDebugContext
ßß -
.
ßß- .
PrimaryTriangle
ßß. =
=
ßß= >
triangle
ßß> F
;
ßßF G
if
©© 
(
©© "
IsEdgeSideOfTriangle
©© 
(
©© 
triangle
©© $
,
©©$ %
ep
©©& (
,
©©( )
eq
©©* ,
)
©©, -
)
©©- .
return
©©/ 5
;
©©5 6
p1
´´ 
=
´´ 
triangle
´´ 
.
´´ 
PointCCWFrom
´´ 
(
´´ 
point
´´ #
)
´´# $
;
´´$ %
Orientation
¨¨ 
o1
¨¨ 
=
¨¨ 
TriangulationUtil
¨¨ %
.
¨¨% &
Orient2d
¨¨& .
(
¨¨. /
eq
¨¨/ 1
,
¨¨1 2
p1
¨¨3 5
,
¨¨5 6
ep
¨¨7 9
)
¨¨9 :
;
¨¨: ;
if
≠≠ 
(
≠≠ 
o1
≠≠ 	
==
≠≠
 
Orientation
≠≠ 
.
≠≠ 
	Collinear
≠≠ "
)
≠≠" #
{
≠≠$ %
throw
≥≥ 	
new
≥≥
 "
PointOnEdgeException
≥≥ "
(
≥≥" #
$str
≥≥# \
,
≥≥\ ]
eq
≥≥] _
,
≥≥_ `
p1
≥≥` b
,
≥≥b c
ep
≥≥c e
)
≥≥e f
;
≥≥f g
}
¥¥ 
p2
∂∂ 
=
∂∂ 
triangle
∂∂ 
.
∂∂ 
PointCWFrom
∂∂ 
(
∂∂ 
point
∂∂ "
)
∂∂" #
;
∂∂# $
Orientation
∑∑ 
o2
∑∑ 
=
∑∑ 
TriangulationUtil
∑∑ %
.
∑∑% &
Orient2d
∑∑& .
(
∑∑. /
eq
∑∑/ 1
,
∑∑1 2
p2
∑∑3 5
,
∑∑5 6
ep
∑∑7 9
)
∑∑9 :
;
∑∑: ;
if
∏∏ 
(
∏∏ 
o2
∏∏ 	
==
∏∏
 
Orientation
∏∏ 
.
∏∏ 
	Collinear
∏∏ "
)
∏∏" #
{
∏∏$ %
throw
ΩΩ 	
new
ΩΩ
 "
PointOnEdgeException
ΩΩ "
(
ΩΩ" #
$str
ΩΩ# \
,
ΩΩ\ ]
eq
ΩΩ] _
,
ΩΩ_ `
p2
ΩΩ` b
,
ΩΩb c
ep
ΩΩc e
)
ΩΩe f
;
ΩΩf g
}
ææ 
if
¿¿ 
(
¿¿ 
o1
¿¿ 	
==
¿¿
 
o2
¿¿ 
)
¿¿ 
{
¿¿ 
if
√√ 
(
√√ 
o1
√√ 

==
√√ 
Orientation
√√ 
.
√√ 
CW
√√ 
)
√√ 
{
√√ 
triangle
ƒƒ 
=
ƒƒ 
triangle
ƒƒ 
.
ƒƒ 
NeighborCCWFrom
ƒƒ (
(
ƒƒ( )
point
ƒƒ) .
)
ƒƒ. /
;
ƒƒ/ 0
}
≈≈ 
else
≈≈ 

{
≈≈ 
triangle
∆∆ 
=
∆∆ 
triangle
∆∆ 
.
∆∆ 
NeighborCWFrom
∆∆ '
(
∆∆' (
point
∆∆( -
)
∆∆- .
;
∆∆. /
}
«« 
	EdgeEvent
»» 
(
»» 
tcx
»» 
,
»» 
ep
»» 
,
»» 
eq
»» 
,
»» 
triangle
»» #
,
»»# $
point
»»% *
)
»»* +
;
»»+ ,
}
…… 
else
…… 	
{
……
 
FlipEdgeEvent
ÀÀ 
(
ÀÀ 
tcx
ÀÀ 
,
ÀÀ 
ep
ÀÀ 
,
ÀÀ 
eq
ÀÀ 
,
ÀÀ 
triangle
ÀÀ '
,
ÀÀ' (
point
ÀÀ) .
)
ÀÀ. /
;
ÀÀ/ 0
}
ÃÃ 
}
ÕÕ 
private
›› 	
static
››
 
void
›› 
	SplitEdge
›› 
(
››   
TriangulationPoint
››! 3
ep
››4 6
,
››6 7 
TriangulationPoint
››8 J
eq
››K M
,
››M N 
TriangulationPoint
››O a
p
››b c
)
››d e
{
››f g
DTSweepConstraint
ﬁﬁ 
edge
ﬁﬁ 
=
ﬁﬁ 
eq
ﬁﬁ 
.
ﬁﬁ 
Edges
ﬁﬁ $
.
ﬁﬁ$ %
First
ﬁﬁ% *
(
ﬁﬁ* +
e
ﬁﬁ, -
=>
ﬁﬁ. 0
e
ﬁﬁ1 2
.
ﬁﬁ2 3
Q
ﬁﬁ3 4
==
ﬁﬁ4 6
ep
ﬁﬁ6 8
||
ﬁﬁ9 ;
e
ﬁﬁ< =
.
ﬁﬁ= >
P
ﬁﬁ> ?
==
ﬁﬁ? A
ep
ﬁﬁA C
)
ﬁﬁD E
;
ﬁﬁE F
edge
ﬂﬂ 
.
ﬂﬂ 
P
ﬂﬂ 	
=
ﬂﬂ
 
p
ﬂﬂ 
;
ﬂﬂ 
new
‡‡ 
DTSweepConstraint
‡‡ 
(
‡‡ 
ep
‡‡ 
,
‡‡ 
p
‡‡ 
)
‡‡ 
;
‡‡  
}
ÊÊ 
private
ËË 	
static
ËË
 
void
ËË 
FlipEdgeEvent
ËË #
(
ËË# $
DTSweepContext
ËË% 3
tcx
ËË4 7
,
ËË7 8 
TriangulationPoint
ËË9 K
ep
ËËL N
,
ËËN O 
TriangulationPoint
ËËP b
eq
ËËc e
,
ËËe f
DelaunayTriangle
ËËg w
t
ËËx y
,
ËËy z!
TriangulationPointËË{ ç
pËËé è
)ËËê ë
{ËËí ì
DelaunayTriangle
ÈÈ 
ot
ÈÈ 
=
ÈÈ 
t
ÈÈ 
.
ÈÈ  
NeighborAcrossFrom
ÈÈ -
(
ÈÈ- .
p
ÈÈ. /
)
ÈÈ/ 0
;
ÈÈ0 1 
TriangulationPoint
ÍÍ 
op
ÍÍ 
=
ÍÍ 
ot
ÍÍ 
.
ÍÍ 
OppositePoint
ÍÍ +
(
ÍÍ+ ,
t
ÍÍ, -
,
ÍÍ- .
p
ÍÍ/ 0
)
ÍÍ0 1
;
ÍÍ1 2
if
ÏÏ 
(
ÏÏ 
ot
ÏÏ 	
==
ÏÏ
 
null
ÏÏ 
)
ÏÏ 
{
ÏÏ 
throw
ÔÔ 	
new
ÔÔ
 '
InvalidOperationException
ÔÔ '
(
ÔÔ' (
$str
ÔÔ( Y
)
ÔÔY Z
;
ÔÔZ [
}
 
if
ÚÚ 
(
ÚÚ 
tcx
ÚÚ 

.
ÚÚ
 
IsDebugEnabled
ÚÚ 
)
ÚÚ 
{
ÚÚ 
tcx
ÛÛ 
.
ÛÛ 
DTDebugContext
ÛÛ 
.
ÛÛ 
PrimaryTriangle
ÛÛ &
=
ÛÛ) *
t
ÛÛ+ ,
;
ÛÛ, -
tcx
ÙÙ 
.
ÙÙ 
DTDebugContext
ÙÙ 
.
ÙÙ 
SecondaryTriangle
ÙÙ (
=
ÙÙ) *
ot
ÙÙ+ -
;
ÙÙ- .
}
ıı 
bool
˜˜ 

inScanArea
˜˜ 
=
˜˜ 
TriangulationUtil
˜˜ &
.
˜˜& '

InScanArea
˜˜' 1
(
˜˜1 2
p
˜˜2 3
,
˜˜3 4
t
˜˜5 6
.
˜˜6 7
PointCCWFrom
˜˜7 C
(
˜˜C D
p
˜˜D E
)
˜˜E F
,
˜˜F G
t
˜˜H I
.
˜˜I J
PointCWFrom
˜˜J U
(
˜˜U V
p
˜˜V W
)
˜˜W X
,
˜˜X Y
op
˜˜Z \
)
˜˜\ ]
;
˜˜] ^
if
¯¯ 
(
¯¯ 

inScanArea
¯¯ 
)
¯¯ 
{
¯¯  
RotateTrianglePair
˙˙ 
(
˙˙ 
t
˙˙ 
,
˙˙ 
p
˙˙ 
,
˙˙ 
ot
˙˙ 
,
˙˙  
op
˙˙! #
)
˙˙# $
;
˙˙$ %
tcx
˚˚ 
.
˚˚  
MapTriangleToNodes
˚˚ 
(
˚˚ 
t
˚˚ 
)
˚˚ 
;
˚˚ 
tcx
¸¸ 
.
¸¸  
MapTriangleToNodes
¸¸ 
(
¸¸ 
ot
¸¸ 
)
¸¸ 
;
¸¸ 
if
˛˛ 
(
˛˛ 
p
˛˛ 	
==
˛˛
 
eq
˛˛ 
&&
˛˛ 
op
˛˛ 
==
˛˛ 
ep
˛˛ 
)
˛˛ 
{
˛˛ 
if
ˇˇ 
(
ˇˇ 	
eq
ˇˇ	 
==
ˇˇ 
tcx
ˇˇ 
.
ˇˇ 
	EdgeEvent
ˇˇ 
.
ˇˇ 
ConstrainedEdge
ˇˇ ,
.
ˇˇ, -
Q
ˇˇ- .
&&
ÄÄ 
ep
ÄÄ	 
==
ÄÄ 
tcx
ÄÄ 
.
ÄÄ 
	EdgeEvent
ÄÄ 
.
ÄÄ 
ConstrainedEdge
ÄÄ ,
.
ÄÄ, -
P
ÄÄ- .
)
ÄÄ. /
{
ÄÄ0 1
if
ÅÅ 
(
ÅÅ	 

tcx
ÅÅ
 
.
ÅÅ 
IsDebugEnabled
ÅÅ 
)
ÅÅ 
Console
ÅÅ %
.
ÅÅ% &
	WriteLine
ÅÅ& /
(
ÅÅ/ 0
$str
ÅÅ0 P
)
ÅÅP Q
;
ÅÅQ R
t
ÇÇ 
.
ÇÇ !
MarkConstrainedEdge
ÇÇ 
(
ÇÇ 
ep
ÇÇ 
,
ÇÇ 
eq
ÇÇ  "
)
ÇÇ" #
;
ÇÇ# $
ot
ÉÉ 
.
ÉÉ 	!
MarkConstrainedEdge
ÉÉ	 
(
ÉÉ 
ep
ÉÉ 
,
ÉÉ  
eq
ÉÉ! #
)
ÉÉ# $
;
ÉÉ$ %
Legalize
ÑÑ 
(
ÑÑ 
tcx
ÑÑ 
,
ÑÑ 
t
ÑÑ 
)
ÑÑ 
;
ÑÑ 
Legalize
ÖÖ 
(
ÖÖ 
tcx
ÖÖ 
,
ÖÖ 
ot
ÖÖ 
)
ÖÖ 
;
ÖÖ 
}
ÜÜ 
else
ÜÜ 
{
ÜÜ 
if
áá 
(
áá	 

tcx
áá
 
.
áá 
IsDebugEnabled
áá 
)
áá 
Console
áá %
.
áá% &
	WriteLine
áá& /
(
áá/ 0
$str
áá0 G
)
ááG H
;
ááH I
}
ââ 
}
ää 
else
ää 

{
ää 
if
ãã 
(
ãã 	
tcx
ãã	 
.
ãã 
IsDebugEnabled
ãã 
)
ãã 
Console
ãã $
.
ãã$ %
	WriteLine
ãã% .
(
ãã. /
$str
ãã/ s
)
ããs t
;
ããt u
Orientation
åå 
o
åå 
=
åå 
TriangulationUtil
åå &
.
åå& '
Orient2d
åå' /
(
åå/ 0
eq
åå0 2
,
åå2 3
op
åå4 6
,
åå6 7
ep
åå8 :
)
åå: ;
;
åå; <
t
çç 
=
çç 
NextFlipTriangle
çç	 
(
çç 
tcx
çç 
,
çç 
o
çç  
,
çç  !
t
çç" #
,
çç# $
ot
çç% '
,
çç' (
p
çç) *
,
çç* +
op
çç, .
)
çç. /
;
çç/ 0
FlipEdgeEvent
éé 
(
éé 
tcx
éé 
,
éé 
ep
éé 
,
éé 
eq
éé 
,
éé 
t
éé  !
,
éé! "
p
éé# $
)
éé$ %
;
éé% &
}
èè 
}
êê 
else
êê 	
{
êê
  
TriangulationPoint
ëë 
newP
ëë 
=
ëë 
NextFlipPoint
ëë +
(
ëë+ ,
ep
ëë, .
,
ëë. /
eq
ëë0 2
,
ëë2 3
ot
ëë4 6
,
ëë6 7
op
ëë8 :
)
ëë: ;
;
ëë; <
FlipScanEdgeEvent
íí 
(
íí 
tcx
íí 
,
íí 
ep
íí 
,
íí 
eq
íí !
,
íí! "
t
íí# $
,
íí$ %
ot
íí& (
,
íí( )
newP
íí* .
)
íí. /
;
íí/ 0
	EdgeEvent
ìì 
(
ìì 
tcx
ìì 
,
ìì 
ep
ìì 
,
ìì 
eq
ìì 
,
ìì 
t
ìì 
,
ìì 
p
ìì 
)
ìì  
;
ìì  !
}
îî 
}
ïï 
private
úú 	
static
úú
  
TriangulationPoint
úú #
NextFlipPoint
úú$ 1
(
úú1 2 
TriangulationPoint
úú3 E
ep
úúF H
,
úúH I 
TriangulationPoint
úúJ \
eq
úú] _
,
úú_ `
DelaunayTriangle
úúa q
ot
úúr t
,
úút u!
TriangulationPointúúv à
opúúâ ã
)úúå ç
{úúé è
Orientation
ùù 
o2d
ùù 
=
ùù 
TriangulationUtil
ùù &
.
ùù& '
Orient2d
ùù' /
(
ùù/ 0
eq
ùù0 2
,
ùù2 3
op
ùù4 6
,
ùù6 7
ep
ùù8 :
)
ùù: ;
;
ùù; <
switch
ûû 	
(
ûû
 
o2d
ûû 
)
ûû 
{
ûû 
case
üü 
Orientation
üü 
.
üü 
CW
üü 
:
üü 
return
üü 
ot
üü !
.
üü! "
PointCCWFrom
üü" .
(
üü. /
op
üü/ 1
)
üü1 2
;
üü2 3
case
†† 
Orientation
†† 
.
†† 
CCW
†† 
:
†† 
return
†† 
ot
††  "
.
††" #
PointCWFrom
††# .
(
††. /
op
††/ 1
)
††1 2
;
††2 3
case
°° 
Orientation
°° 
.
°° 
	Collinear
°° 
:
°° 
throw
££ 	
new
££
 "
PointOnEdgeException
££ "
(
££" #
$str
££# P
,
££P Q
eq
££Q S
,
££S T
op
££T V
,
££V W
ep
££W Y
)
££Y Z
;
££Z [
default
§§ 

:
§§
 
throw
•• 	
new
••
 %
NotImplementedException
•• %
(
••% &
$str
••& ?
)
••? @
;
••@ A
}
¶¶ 
}
ßß 
private
¥¥ 	
static
¥¥
 
DelaunayTriangle
¥¥ !
NextFlipTriangle
¥¥" 2
(
¥¥2 3
DTSweepContext
¥¥4 B
tcx
¥¥C F
,
¥¥F G
Orientation
¥¥H S
o
¥¥T U
,
¥¥U V
DelaunayTriangle
¥¥W g
t
¥¥h i
,
¥¥i j
DelaunayTriangle
¥¥k {
ot
¥¥| ~
,
¥¥~ "
TriangulationPoint¥¥Ä í
p¥¥ì î
,¥¥î ï"
TriangulationPoint¥¥ñ ®
op¥¥© ´
)¥¥¨ ≠
{¥¥Æ Ø
int
µµ 
	edgeIndex
µµ 
;
µµ 
if
∂∂ 
(
∂∂ 
o
∂∂ 
==
∂∂	 
Orientation
∂∂ 
.
∂∂ 
CCW
∂∂ 
)
∂∂ 
{
∂∂ 
	edgeIndex
∏∏ 
=
∏∏ 
ot
∏∏ 
.
∏∏ 
	EdgeIndex
∏∏ 
(
∏∏ 
p
∏∏ 
,
∏∏ 
op
∏∏  "
)
∏∏" #
;
∏∏# $
ot
ππ 
.
ππ 
EdgeIsDelaunay
ππ 
[
ππ 
	edgeIndex
ππ 
]
ππ  
=
ππ! "
true
ππ# '
;
ππ' (
Legalize
∫∫ 
(
∫∫ 
tcx
∫∫ 
,
∫∫ 
ot
∫∫ 
)
∫∫ 
;
∫∫ 
ot
ªª 
.
ªª 
EdgeIsDelaunay
ªª 
.
ªª 
Clear
ªª 
(
ªª 
)
ªª 
;
ªª 
return
ºº 

t
ºº 
;
ºº 
}
ΩΩ 
	edgeIndex
øø 
=
øø 
t
øø 
.
øø 
	EdgeIndex
øø 
(
øø 
p
øø 
,
øø 
op
øø  
)
øø  !
;
øø! "
t
¿¿ 
.
¿¿ 
EdgeIsDelaunay
¿¿ 
[
¿¿ 
	edgeIndex
¿¿ 
]
¿¿ 
=
¿¿  
true
¿¿! %
;
¿¿% &
Legalize
¡¡ 
(
¡¡ 
tcx
¡¡ 
,
¡¡ 
t
¡¡ 
)
¡¡ 
;
¡¡ 
t
¬¬ 
.
¬¬ 
EdgeIsDelaunay
¬¬ 
.
¬¬ 
Clear
¬¬ 
(
¬¬ 
)
¬¬ 
;
¬¬ 
return
√√ 	
ot
√√
 
;
√√ 
}
ƒƒ 
private
““ 	
static
““
 
void
““ 
FlipScanEdgeEvent
““ '
(
““' (
DTSweepContext
““) 7
tcx
““8 ;
,
““; < 
TriangulationPoint
““= O
ep
““P R
,
““R S 
TriangulationPoint
““T f
eq
““g i
,
““i j
DelaunayTriangle
““k {
flipTriangle““| à
,““à â 
DelaunayTriangle““ä ö
t““õ ú
,““ú ù"
TriangulationPoint““û ∞
p““± ≤
)““≥ ¥
{““µ ∂
DelaunayTriangle
”” 
ot
”” 
;
””  
TriangulationPoint
‘‘ 
op
‘‘ 
,
‘‘ 
newP
‘‘ 
;
‘‘ 
bool
’’ 

inScanArea
’’ 
;
’’ 
ot
◊◊ 
=
◊◊ 
t
◊◊ 	
.
◊◊	 
 
NeighborAcrossFrom
◊◊
 
(
◊◊ 
p
◊◊ 
)
◊◊ 
;
◊◊  
op
ÿÿ 
=
ÿÿ 
ot
ÿÿ 

.
ÿÿ
 
OppositePoint
ÿÿ 
(
ÿÿ 
t
ÿÿ 
,
ÿÿ 
p
ÿÿ 
)
ÿÿ 
;
ÿÿ 
if
⁄⁄ 
(
⁄⁄ 
ot
⁄⁄ 	
==
⁄⁄
 
null
⁄⁄ 
)
⁄⁄ 
{
⁄⁄ 
throw
›› 	
new
››
 
	Exception
›› 
(
›› 
$str
›› I
)
››I J
;
››J K
}
ﬁﬁ 
if
‡‡ 
(
‡‡ 
tcx
‡‡ 

.
‡‡
 
IsDebugEnabled
‡‡ 
)
‡‡ 
{
‡‡ 
Console
·· 
.
·· 
	WriteLine
·· 
(
·· 
$str
·· 5
)
··5 6
;
··6 7
tcx
‚‚ 
.
‚‚ 
DTDebugContext
‚‚ 
.
‚‚ 
PrimaryTriangle
‚‚ &
=
‚‚' (
t
‚‚) *
;
‚‚* +
tcx
„„ 
.
„„ 
DTDebugContext
„„ 
.
„„ 
SecondaryTriangle
„„ (
=
„„) *
ot
„„+ -
;
„„- .
}
‰‰ 

inScanArea
ÊÊ 
=
ÊÊ 
TriangulationUtil
ÊÊ !
.
ÊÊ! "

InScanArea
ÊÊ" ,
(
ÊÊ, -
eq
ÊÊ- /
,
ÊÊ/ 0
flipTriangle
ÊÊ1 =
.
ÊÊ= >
PointCCWFrom
ÊÊ> J
(
ÊÊJ K
eq
ÊÊK M
)
ÊÊM N
,
ÊÊN O
flipTriangle
ÊÊP \
.
ÊÊ\ ]
PointCWFrom
ÊÊ] h
(
ÊÊh i
eq
ÊÊi k
)
ÊÊk l
,
ÊÊl m
op
ÊÊn p
)
ÊÊp q
;
ÊÊq r
if
ÁÁ 
(
ÁÁ 

inScanArea
ÁÁ 
)
ÁÁ 
{
ÁÁ 
FlipEdgeEvent
ÈÈ 
(
ÈÈ 
tcx
ÈÈ 
,
ÈÈ 
eq
ÈÈ 
,
ÈÈ 
op
ÈÈ 
,
ÈÈ 
ot
ÈÈ !
,
ÈÈ! "
op
ÈÈ# %
)
ÈÈ% &
;
ÈÈ& '
}
ÒÒ 
else
ÒÒ 	
{
ÒÒ
 
newP
ÚÚ 
=
ÚÚ	 

NextFlipPoint
ÚÚ 
(
ÚÚ 
ep
ÚÚ 
,
ÚÚ 
eq
ÚÚ 
,
ÚÚ  
ot
ÚÚ! #
,
ÚÚ# $
op
ÚÚ% '
)
ÚÚ' (
;
ÚÚ( )
FlipScanEdgeEvent
ÛÛ 
(
ÛÛ 
tcx
ÛÛ 
,
ÛÛ 
ep
ÛÛ 
,
ÛÛ 
eq
ÛÛ !
,
ÛÛ! "
flipTriangle
ÛÛ# /
,
ÛÛ/ 0
ot
ÛÛ1 3
,
ÛÛ3 4
newP
ÛÛ5 9
)
ÛÛ9 :
;
ÛÛ: ;
}
ÙÙ 
}
ıı 
private
˙˙ 	
static
˙˙
 
void
˙˙  
FillAdvancingFront
˙˙ (
(
˙˙( )
DTSweepContext
˙˙* 8
tcx
˙˙9 <
,
˙˙< = 
AdvancingFrontNode
˙˙> P
n
˙˙Q R
)
˙˙S T
{
˙˙U V 
AdvancingFrontNode
˚˚ 
node
˚˚ 
;
˚˚ 
double
¸¸ 	
angle
¸¸
 
;
¸¸ 
node
ˇˇ 
=
ˇˇ 	
n
ˇˇ
 
.
ˇˇ 
Next
ˇˇ 
;
ˇˇ 
while
ÄÄ 
(
ÄÄ	 

node
ÄÄ
 
.
ÄÄ 
HasNext
ÄÄ 
)
ÄÄ 
{
ÄÄ 
angle
ÅÅ 	
=
ÅÅ
 
	HoleAngle
ÅÅ 
(
ÅÅ 
node
ÅÅ 
)
ÅÅ 
;
ÅÅ 
if
ÇÇ 
(
ÇÇ 
angle
ÇÇ 
>
ÇÇ 
PI_div2
ÇÇ 
||
ÇÇ 
angle
ÇÇ  
<
ÇÇ! "
-
ÇÇ# $
PI_div2
ÇÇ$ +
)
ÇÇ+ ,
break
ÇÇ- 2
;
ÇÇ2 3
Fill
ÉÉ 
(
ÉÉ 	
tcx
ÉÉ	 
,
ÉÉ 
node
ÉÉ 
)
ÉÉ 
;
ÉÉ 
node
ÑÑ 
=
ÑÑ	 

node
ÑÑ 
.
ÑÑ 
Next
ÑÑ 
;
ÑÑ 
}
ÖÖ 
node
àà 
=
àà 	
n
àà
 
.
àà 
Prev
àà 
;
àà 
while
ââ 
(
ââ	 

node
ââ
 
.
ââ 
HasPrev
ââ 
)
ââ 
{
ââ 
angle
ää 	
=
ää
 
	HoleAngle
ää 
(
ää 
node
ää 
)
ää 
;
ää 
if
ãã 
(
ãã 
angle
ãã 
>
ãã 
PI_div2
ãã 
||
ãã 
angle
ãã  
<
ãã! "
-
ãã# $
PI_div2
ãã$ +
)
ãã+ ,
break
ãã- 2
;
ãã2 3
Fill
åå 
(
åå 	
tcx
åå	 
,
åå 
node
åå 
)
åå 
;
åå 
node
çç 
=
çç	 

node
çç 
.
çç 
Prev
çç 
;
çç 
}
éé 
if
ëë 
(
ëë 
n
ëë 
.
ëë 	
HasNext
ëë	 
&&
ëë 
n
ëë 
.
ëë 
Next
ëë 
.
ëë 
HasNext
ëë "
)
ëë" #
{
ëë$ %
angle
íí 	
=
íí
 

BasinAngle
íí 
(
íí 
n
íí 
)
íí 
;
íí 
if
ìì 
(
ìì 
angle
ìì 
<
ìì 
PI_3div4
ìì 
)
ìì 
	FillBasin
ìì #
(
ìì# $
tcx
ìì$ '
,
ìì' (
n
ìì) *
)
ìì* +
;
ìì+ ,
}
îî 
}
ïï 
private
üü 	
static
üü
 
void
üü 
	FillBasin
üü 
(
üü  
DTSweepContext
üü! /
tcx
üü0 3
,
üü3 4 
AdvancingFrontNode
üü5 G
node
üüH L
)
üüM N
{
üüO P
if
†† 
(
†† 
TriangulationUtil
†† 
.
†† 
Orient2d
†† !
(
††! "
node
††" &
.
††& '
Point
††' ,
,
††, -
node
††. 2
.
††2 3
Next
††3 7
.
††7 8
Point
††8 =
,
††= >
node
††? C
.
††C D
Next
††D H
.
††H I
Next
††I M
.
††M N
Point
††N S
)
††S T
==
††U W
Orientation
††X c
.
††c d
CCW
††d g
)
††g h
{
††i j
tcx
¢¢ 
.
¢¢ 
Basin
¢¢ 
.
¢¢ 
leftNode
¢¢ 
=
¢¢ 
node
¢¢ 
;
¢¢ 
}
££ 
else
££ 	
{
££
 
tcx
§§ 
.
§§ 
Basin
§§ 
.
§§ 
leftNode
§§ 
=
§§ 
node
§§ 
.
§§ 
Next
§§ "
;
§§" #
}
•• 
tcx
®® 
.
®® 
Basin
®® 
.
®® 

bottomNode
®® 
=
®® 
tcx
®® 
.
®® 
Basin
®® #
.
®®# $
leftNode
®®$ ,
;
®®, -
while
©© 
(
©©	 

tcx
©©
 
.
©© 
Basin
©© 
.
©© 

bottomNode
©© 
.
©© 
HasNext
©© &
&&
©©' )
tcx
©©* -
.
©©- .
Basin
©©. 3
.
©©3 4

bottomNode
©©4 >
.
©©> ?
Point
©©? D
.
©©D E
Y
©©E F
>=
©©G I
tcx
©©J M
.
©©M N
Basin
©©N S
.
©©S T

bottomNode
©©T ^
.
©©^ _
Next
©©_ c
.
©©c d
Point
©©d i
.
©©i j
Y
©©j k
)
©©k l
tcx
©©m p
.
©©p q
Basin
©©q v
.
©©v w

bottomNode©©w Å
=©©Ç É
tcx©©Ñ á
.©©á à
Basin©©à ç
.©©ç é

bottomNode©©é ò
.©©ò ô
Next©©ô ù
;©©ù û
if
´´ 
(
´´ 
tcx
´´ 

.
´´
 
Basin
´´ 
.
´´ 

bottomNode
´´ 
==
´´ 
tcx
´´ "
.
´´" #
Basin
´´# (
.
´´( )
leftNode
´´) 1
)
´´1 2
return
´´3 9
;
´´9 :
tcx
≠≠ 
.
≠≠ 
Basin
≠≠ 
.
≠≠ 
	rightNode
≠≠ 
=
≠≠ 
tcx
≠≠ 
.
≠≠ 
Basin
≠≠ "
.
≠≠" #

bottomNode
≠≠# -
;
≠≠- .
while
ÆÆ 
(
ÆÆ	 

tcx
ÆÆ
 
.
ÆÆ 
Basin
ÆÆ 
.
ÆÆ 
	rightNode
ÆÆ 
.
ÆÆ 
HasNext
ÆÆ %
&&
ÆÆ& (
tcx
ÆÆ) ,
.
ÆÆ, -
Basin
ÆÆ- 2
.
ÆÆ2 3
	rightNode
ÆÆ3 <
.
ÆÆ< =
Point
ÆÆ= B
.
ÆÆB C
Y
ÆÆC D
<
ÆÆE F
tcx
ÆÆG J
.
ÆÆJ K
Basin
ÆÆK P
.
ÆÆP Q
	rightNode
ÆÆQ Z
.
ÆÆZ [
Next
ÆÆ[ _
.
ÆÆ_ `
Point
ÆÆ` e
.
ÆÆe f
Y
ÆÆf g
)
ÆÆg h
tcx
ÆÆi l
.
ÆÆl m
Basin
ÆÆm r
.
ÆÆr s
	rightNode
ÆÆs |
=
ÆÆ} ~
tcxÆÆ Ç
.ÆÆÇ É
BasinÆÆÉ à
.ÆÆà â
	rightNodeÆÆâ í
.ÆÆí ì
NextÆÆì ó
;ÆÆó ò
if
∞∞ 
(
∞∞ 
tcx
∞∞ 

.
∞∞
 
Basin
∞∞ 
.
∞∞ 
	rightNode
∞∞ 
==
∞∞ 
tcx
∞∞ !
.
∞∞! "
Basin
∞∞" '
.
∞∞' (

bottomNode
∞∞( 2
)
∞∞2 3
return
∞∞4 :
;
∞∞: ;
tcx
≤≤ 
.
≤≤ 
Basin
≤≤ 
.
≤≤ 
width
≤≤ 
=
≤≤ 
tcx
≤≤ 
.
≤≤ 
Basin
≤≤ 
.
≤≤ 
	rightNode
≤≤ (
.
≤≤( )
Point
≤≤) .
.
≤≤. /
X
≤≤/ 0
-
≤≤1 2
tcx
≤≤3 6
.
≤≤6 7
Basin
≤≤7 <
.
≤≤< =
leftNode
≤≤= E
.
≤≤E F
Point
≤≤F K
.
≤≤K L
X
≤≤L M
;
≤≤M N
tcx
≥≥ 
.
≥≥ 
Basin
≥≥ 
.
≥≥ 
leftHighest
≥≥ 
=
≥≥ 
tcx
≥≥ 
.
≥≥ 
Basin
≥≥ $
.
≥≥$ %
leftNode
≥≥% -
.
≥≥- .
Point
≥≥. 3
.
≥≥3 4
Y
≥≥4 5
>
≥≥6 7
tcx
≥≥8 ;
.
≥≥; <
Basin
≥≥< A
.
≥≥A B
	rightNode
≥≥B K
.
≥≥K L
Point
≥≥L Q
.
≥≥Q R
Y
≥≥R S
;
≥≥S T
FillBasinReq
µµ 
(
µµ 
tcx
µµ 
,
µµ 
tcx
µµ 
.
µµ 
Basin
µµ 
.
µµ 

bottomNode
µµ )
)
µµ) *
;
µµ* +
}
∂∂ 
private
ªª 	
static
ªª
 
void
ªª 
FillBasinReq
ªª "
(
ªª" #
DTSweepContext
ªª$ 2
tcx
ªª3 6
,
ªª6 7 
AdvancingFrontNode
ªª8 J
node
ªªK O
)
ªªP Q
{
ªªR S
if
ºº 
(
ºº 
	IsShallow
ºº 
(
ºº 
tcx
ºº 
,
ºº 
node
ºº 
)
ºº 
)
ºº 
return
ºº #
;
ºº# $
Fill
ææ 
(
ææ 
tcx
ææ 
,
ææ 
node
ææ 
)
ææ 
;
ææ 
if
øø 
(
øø 
node
øø 
.
øø 
Prev
øø 
==
øø 
tcx
øø 
.
øø 
Basin
øø 
.
øø 
leftNode
øø &
&&
øø' )
node
øø* .
.
øø. /
Next
øø/ 3
==
øø4 6
tcx
øø7 :
.
øø: ;
Basin
øø; @
.
øø@ A
	rightNode
øøA J
)
øøJ K
{
øøL M
return
¿¿ 

;
¿¿
 
}
¡¡ 
else
¡¡ 	
if
¡¡
 
(
¡¡ 
node
¡¡ 
.
¡¡ 
Prev
¡¡ 
==
¡¡ 
tcx
¡¡ 
.
¡¡ 
Basin
¡¡ $
.
¡¡$ %
leftNode
¡¡% -
)
¡¡- .
{
¡¡/ 0
Orientation
¬¬ 
o
¬¬ 
=
¬¬ 
TriangulationUtil
¬¬ %
.
¬¬% &
Orient2d
¬¬& .
(
¬¬. /
node
¬¬/ 3
.
¬¬3 4
Point
¬¬4 9
,
¬¬9 :
node
¬¬; ?
.
¬¬? @
Next
¬¬@ D
.
¬¬D E
Point
¬¬E J
,
¬¬J K
node
¬¬L P
.
¬¬P Q
Next
¬¬Q U
.
¬¬U V
Next
¬¬V Z
.
¬¬Z [
Point
¬¬[ `
)
¬¬` a
;
¬¬a b
if
√√ 
(
√√ 
o
√√ 	
==
√√
 
Orientation
√√ 
.
√√ 
CW
√√ 
)
√√ 
return
√√ #
;
√√# $
node
ƒƒ 
=
ƒƒ	 

node
ƒƒ 
.
ƒƒ 
Next
ƒƒ 
;
ƒƒ 
}
≈≈ 
else
≈≈ 	
if
≈≈
 
(
≈≈ 
node
≈≈ 
.
≈≈ 
Next
≈≈ 
==
≈≈ 
tcx
≈≈ 
.
≈≈ 
Basin
≈≈ $
.
≈≈$ %
	rightNode
≈≈% .
)
≈≈. /
{
≈≈0 1
Orientation
∆∆ 
o
∆∆ 
=
∆∆ 
TriangulationUtil
∆∆ %
.
∆∆% &
Orient2d
∆∆& .
(
∆∆. /
node
∆∆/ 3
.
∆∆3 4
Point
∆∆4 9
,
∆∆9 :
node
∆∆; ?
.
∆∆? @
Prev
∆∆@ D
.
∆∆D E
Point
∆∆E J
,
∆∆J K
node
∆∆L P
.
∆∆P Q
Prev
∆∆Q U
.
∆∆U V
Prev
∆∆V Z
.
∆∆Z [
Point
∆∆[ `
)
∆∆` a
;
∆∆a b
if
«« 
(
«« 
o
«« 	
==
««
 
Orientation
«« 
.
«« 
CCW
«« 
)
«« 
return
«« $
;
««$ %
node
»» 
=
»»	 

node
»» 
.
»» 
Prev
»» 
;
»» 
}
…… 
else
…… 	
{
……
 
if
ÀÀ 
(
ÀÀ 
node
ÀÀ 
.
ÀÀ 
Prev
ÀÀ 
.
ÀÀ 
Point
ÀÀ 
.
ÀÀ 
Y
ÀÀ 
<
ÀÀ 
node
ÀÀ  
.
ÀÀ  !
Next
ÀÀ! %
.
ÀÀ% &
Point
ÀÀ& +
.
ÀÀ+ ,
Y
ÀÀ, -
)
ÀÀ- .
{
ÀÀ/ 0
node
ÃÃ 	
=
ÃÃ
 
node
ÃÃ 
.
ÃÃ 
Prev
ÃÃ 
;
ÃÃ 
}
ÕÕ 
else
ÕÕ 

{
ÕÕ 
node
ŒŒ 	
=
ŒŒ
 
node
ŒŒ 
.
ŒŒ 
Next
ŒŒ 
;
ŒŒ 
}
œœ 
}
–– 
FillBasinReq
—— 
(
—— 
tcx
—— 
,
—— 
node
—— 
)
—— 
;
—— 
}
““ 
private
‘‘ 	
static
‘‘
 
bool
‘‘ 
	IsShallow
‘‘ 
(
‘‘  
DTSweepContext
‘‘! /
tcx
‘‘0 3
,
‘‘3 4 
AdvancingFrontNode
‘‘5 G
node
‘‘H L
)
‘‘M N
{
‘‘O P
double
’’ 	
height
’’
 
;
’’ 
if
◊◊ 
(
◊◊ 
tcx
◊◊ 

.
◊◊
 
Basin
◊◊ 
.
◊◊ 
leftHighest
◊◊ 
)
◊◊ 
{
◊◊ 
height
ÿÿ 

=
ÿÿ 
tcx
ÿÿ 
.
ÿÿ 
Basin
ÿÿ 
.
ÿÿ 
leftNode
ÿÿ 
.
ÿÿ  
Point
ÿÿ  %
.
ÿÿ% &
Y
ÿÿ& '
-
ÿÿ( )
node
ÿÿ* .
.
ÿÿ. /
Point
ÿÿ/ 4
.
ÿÿ4 5
Y
ÿÿ5 6
;
ÿÿ6 7
}
ŸŸ 
else
ŸŸ 	
{
ŸŸ
 
height
⁄⁄ 

=
⁄⁄ 
tcx
⁄⁄ 
.
⁄⁄ 
Basin
⁄⁄ 
.
⁄⁄ 
	rightNode
⁄⁄  
.
⁄⁄  !
Point
⁄⁄! &
.
⁄⁄& '
Y
⁄⁄' (
-
⁄⁄) *
node
⁄⁄+ /
.
⁄⁄/ 0
Point
⁄⁄0 5
.
⁄⁄5 6
Y
⁄⁄6 7
;
⁄⁄7 8
}
€€ 
if
‹‹ 
(
‹‹ 
tcx
‹‹ 

.
‹‹
 
Basin
‹‹ 
.
‹‹ 
width
‹‹ 
>
‹‹ 
height
‹‹ 
)
‹‹  
{
‹‹! "
return
›› 

true
›› 
;
›› 
}
ﬁﬁ 
return
ﬂﬂ 	
false
ﬂﬂ
 
;
ﬂﬂ 
}
‡‡ 
private
ÁÁ 	
static
ÁÁ
 
double
ÁÁ 
	HoleAngle
ÁÁ !
(
ÁÁ! " 
AdvancingFrontNode
ÁÁ# 5
node
ÁÁ6 :
)
ÁÁ; <
{
ÁÁ= >
double
ÚÚ 	
px
ÚÚ
 
=
ÚÚ 
node
ÚÚ 
.
ÚÚ 
Point
ÚÚ 
.
ÚÚ 
X
ÚÚ 
;
ÚÚ 
double
ÛÛ 	
py
ÛÛ
 
=
ÛÛ 
node
ÛÛ 
.
ÛÛ 
Point
ÛÛ 
.
ÛÛ 
Y
ÛÛ 
;
ÛÛ 
double
ÙÙ 	
ax
ÙÙ
 
=
ÙÙ 
node
ÙÙ 
.
ÙÙ 
Next
ÙÙ 
.
ÙÙ 
Point
ÙÙ 
.
ÙÙ 
X
ÙÙ  
-
ÙÙ! "
px
ÙÙ# %
;
ÙÙ% &
double
ıı 	
ay
ıı
 
=
ıı 
node
ıı 
.
ıı 
Next
ıı 
.
ıı 
Point
ıı 
.
ıı 
Y
ıı  
-
ıı! "
py
ıı# %
;
ıı% &
double
ˆˆ 	
bx
ˆˆ
 
=
ˆˆ 
node
ˆˆ 
.
ˆˆ 
Prev
ˆˆ 
.
ˆˆ 
Point
ˆˆ 
.
ˆˆ 
X
ˆˆ  
-
ˆˆ! "
px
ˆˆ# %
;
ˆˆ% &
double
˜˜ 	
by
˜˜
 
=
˜˜ 
node
˜˜ 
.
˜˜ 
Prev
˜˜ 
.
˜˜ 
Point
˜˜ 
.
˜˜ 
Y
˜˜  
-
˜˜! "
py
˜˜# %
;
˜˜% &
return
¯¯ 	
Math
¯¯
 
.
¯¯ 
Atan2
¯¯ 
(
¯¯ 
ax
¯¯ 
*
¯¯ 
by
¯¯ 
-
¯¯ 
ay
¯¯ !
*
¯¯" #
bx
¯¯$ &
,
¯¯& '
ax
¯¯( *
*
¯¯+ ,
bx
¯¯- /
+
¯¯0 1
ay
¯¯2 4
*
¯¯5 6
by
¯¯7 9
)
¯¯9 :
;
¯¯: ;
}
˘˘ 
private
˛˛ 	
static
˛˛
 
double
˛˛ 

BasinAngle
˛˛ "
(
˛˛" # 
AdvancingFrontNode
˛˛$ 6
node
˛˛7 ;
)
˛˛< =
{
˛˛> ?
double
ˇˇ 	
ax
ˇˇ
 
=
ˇˇ 
node
ˇˇ 
.
ˇˇ 
Point
ˇˇ 
.
ˇˇ 
X
ˇˇ 
-
ˇˇ 
node
ˇˇ "
.
ˇˇ" #
Next
ˇˇ# '
.
ˇˇ' (
Next
ˇˇ( ,
.
ˇˇ, -
Point
ˇˇ- 2
.
ˇˇ2 3
X
ˇˇ3 4
;
ˇˇ4 5
double
ÄÄ 	
ay
ÄÄ
 
=
ÄÄ 
node
ÄÄ 
.
ÄÄ 
Point
ÄÄ 
.
ÄÄ 
Y
ÄÄ 
-
ÄÄ 
node
ÄÄ "
.
ÄÄ" #
Next
ÄÄ# '
.
ÄÄ' (
Next
ÄÄ( ,
.
ÄÄ, -
Point
ÄÄ- 2
.
ÄÄ2 3
Y
ÄÄ3 4
;
ÄÄ4 5
return
ÅÅ 	
Math
ÅÅ
 
.
ÅÅ 
Atan2
ÅÅ 
(
ÅÅ 
ay
ÅÅ 
,
ÅÅ 
ax
ÅÅ 
)
ÅÅ 
;
ÅÅ 
}
ÇÇ 
private
ââ 	
static
ââ
 
void
ââ 
Fill
ââ 
(
ââ 
DTSweepContext
ââ *
tcx
ââ+ .
,
ââ. / 
AdvancingFrontNode
ââ0 B
node
ââC G
)
ââH I
{
ââJ K
DelaunayTriangle
ää 
triangle
ää 
=
ää 
new
ää "
DelaunayTriangle
ää# 3
(
ää3 4
node
ää4 8
.
ää8 9
Prev
ää9 =
.
ää= >
Point
ää> C
,
ääC D
node
ääE I
.
ääI J
Point
ääJ O
,
ääO P
node
ääQ U
.
ääU V
Next
ääV Z
.
ääZ [
Point
ää[ `
)
ää` a
;
ääa b
triangle
çç 
.
çç 
MarkNeighbor
çç 
(
çç 
node
çç 
.
çç 
Prev
çç "
.
çç" #
Triangle
çç# +
)
çç+ ,
;
çç, -
triangle
éé 
.
éé 
MarkNeighbor
éé 
(
éé 
node
éé 
.
éé 
Triangle
éé &
)
éé& '
;
éé' (
tcx
èè 
.
èè 
	Triangles
èè 
.
èè 
Add
èè 
(
èè 
triangle
èè 
)
èè 
;
èè 
node
íí 
.
íí 
Prev
íí 
.
íí 
Next
íí 
=
íí 
node
íí 
.
íí 
Next
íí 
;
íí 
node
ìì 
.
ìì 
Next
ìì 
.
ìì 
Prev
ìì 
=
ìì 
node
ìì 
.
ìì 
Prev
ìì 
;
ìì 
tcx
îî 
.
îî 

RemoveNode
îî 
(
îî 
node
îî 
)
îî 
;
îî 
if
óó 
(
óó 
!
óó 
Legalize
óó 
(
óó 
tcx
óó 
,
óó 
triangle
óó 
)
óó 
)
óó  
tcx
óó! $
.
óó$ % 
MapTriangleToNodes
óó% 7
(
óó7 8
triangle
óó8 @
)
óó@ A
;
óóA B
}
òò 
private
ùù 	
static
ùù
 
bool
ùù 
Legalize
ùù 
(
ùù 
DTSweepContext
ùù  .
tcx
ùù/ 2
,
ùù2 3
DelaunayTriangle
ùù4 D
t
ùùE F
)
ùùG H
{
ùùI J
for
†† 
(
†† 
int
†† 
i
†† 
=
†† 
$num
†† 
;
†† 
i
†† 
<
†† 
$num
†† 
;
†† 
i
†† 
++
†† 
)
†† 
{
††  
if
££ 
(
££ 
t
££ 	
.
££	 

EdgeIsDelaunay
££
 
[
££ 
i
££ 
]
££ 
)
££ 
continue
££ %
;
££% &
DelaunayTriangle
•• 
ot
•• 
=
•• 
t
•• 
.
•• 
	Neighbors
•• %
[
••% &
i
••& '
]
••' (
;
••( )
if
¶¶ 
(
¶¶ 
ot
¶¶ 

==
¶¶ 
null
¶¶ 
)
¶¶ 
continue
¶¶ 
;
¶¶  
TriangulationPoint
®® 
p
®® 
=
®® 
t
®® 
.
®® 
Points
®® #
[
®®# $
i
®®$ %
]
®®% &
;
®®& ' 
TriangulationPoint
©© 
op
©© 
=
©© 
ot
©© 
.
©© 
OppositePoint
©© ,
(
©©, -
t
©©- .
,
©©. /
p
©©0 1
)
©©1 2
;
©©2 3
int
™™ 
oi
™™ 

=
™™ 
ot
™™ 
.
™™ 
IndexOf
™™ 
(
™™ 
op
™™ 
)
™™ 
;
™™ 
if
≠≠ 
(
≠≠ 
ot
≠≠ 

.
≠≠
 
EdgeIsConstrained
≠≠ 
[
≠≠ 
oi
≠≠ 
]
≠≠  
||
≠≠! #
ot
≠≠$ &
.
≠≠& '
EdgeIsDelaunay
≠≠' 5
[
≠≠5 6
oi
≠≠6 8
]
≠≠8 9
)
≠≠9 :
{
≠≠; <
t
ÆÆ 
.
ÆÆ 
EdgeIsConstrained
ÆÆ 
[
ÆÆ 
i
ÆÆ 
]
ÆÆ 
=
ÆÆ 
ot
ÆÆ  
.
ÆÆ  !
EdgeIsConstrained
ÆÆ! 2
[
ÆÆ2 3
oi
ÆÆ3 5
]
ÆÆ5 6
;
ÆÆ6 7
continue
ØØ 
;
ØØ 
}
∞∞ 
if
≤≤ 
(
≤≤ 
!
≤≤ 	
TriangulationUtil
≤≤	 
.
≤≤ 
SmartIncircle
≤≤ (
(
≤≤( )
p
≤≤) *
,
≤≤* +
t
≤≤+ ,
.
≤≤, -
PointCCWFrom
≤≤- 9
(
≤≤9 :
p
≤≤: ;
)
≤≤; <
,
≤≤< =
t
≤≤= >
.
≤≤> ?
PointCWFrom
≤≤? J
(
≤≤J K
p
≤≤K L
)
≤≤L M
,
≤≤M N
op
≤≤N P
)
≤≤P Q
)
≤≤Q R
continue
≤≤S [
;
≤≤[ \
t
µµ 
.
µµ 
EdgeIsDelaunay
µµ 
[
µµ 
i
µµ 
]
µµ 
=
µµ 
true
µµ 
;
µµ 
ot
∂∂ 
.
∂∂ 
EdgeIsDelaunay
∂∂ 
[
∂∂ 
oi
∂∂ 
]
∂∂ 
=
∂∂ 
true
∂∂  
;
∂∂  ! 
RotateTrianglePair
ππ 
(
ππ 
t
ππ 
,
ππ 
p
ππ 
,
ππ 
ot
ππ 
,
ππ  
op
ππ! #
)
ππ# $
;
ππ$ %
if
øø 
(
øø 
!
øø 	
Legalize
øø	 
(
øø 
tcx
øø 
,
øø 
t
øø 
)
øø 
)
øø 
tcx
øø 
.
øø  
MapTriangleToNodes
øø 1
(
øø1 2
t
øø2 3
)
øø3 4
;
øø4 5
if
¿¿ 
(
¿¿ 
!
¿¿ 	
Legalize
¿¿	 
(
¿¿ 
tcx
¿¿ 
,
¿¿ 
ot
¿¿ 
)
¿¿ 
)
¿¿ 
tcx
¿¿ 
.
¿¿   
MapTriangleToNodes
¿¿  2
(
¿¿2 3
ot
¿¿3 5
)
¿¿5 6
;
¿¿6 7
t
∆∆ 
.
∆∆ 
EdgeIsDelaunay
∆∆ 
[
∆∆ 
i
∆∆ 
]
∆∆ 
=
∆∆ 
false
∆∆ 
;
∆∆  
ot
«« 
.
«« 
EdgeIsDelaunay
«« 
[
«« 
oi
«« 
]
«« 
=
«« 
false
«« !
;
««! "
return
ÀÀ 

true
ÀÀ 
;
ÀÀ 
}
ÃÃ 
return
ÕÕ 	
false
ÕÕ
 
;
ÕÕ 
}
ŒŒ 
private
‹‹ 	
static
‹‹
 
void
‹‹  
RotateTrianglePair
‹‹ (
(
‹‹( )
DelaunayTriangle
‹‹* :
t
‹‹; <
,
‹‹< = 
TriangulationPoint
‹‹> P
p
‹‹Q R
,
‹‹R S
DelaunayTriangle
‹‹T d
ot
‹‹e g
,
‹‹g h 
TriangulationPoint
‹‹i {
op
‹‹| ~
)‹‹ Ä
{‹‹Å Ç
DelaunayTriangle
›› 
n1
›› 
,
›› 
n2
›› 
,
›› 
n3
›› 
,
›› 
n4
››  "
;
››" #
n1
ﬁﬁ 
=
ﬁﬁ 
t
ﬁﬁ 	
.
ﬁﬁ	 

NeighborCCWFrom
ﬁﬁ
 
(
ﬁﬁ 
p
ﬁﬁ 
)
ﬁﬁ 
;
ﬁﬁ 
n2
ﬂﬂ 
=
ﬂﬂ 
t
ﬂﬂ 	
.
ﬂﬂ	 

NeighborCWFrom
ﬂﬂ
 
(
ﬂﬂ 
p
ﬂﬂ 
)
ﬂﬂ 
;
ﬂﬂ 
n3
‡‡ 
=
‡‡ 
ot
‡‡ 

.
‡‡
 
NeighborCCWFrom
‡‡ 
(
‡‡ 
op
‡‡ 
)
‡‡ 
;
‡‡ 
n4
·· 
=
·· 
ot
·· 

.
··
 
NeighborCWFrom
·· 
(
·· 
op
·· 
)
·· 
;
·· 
bool
„„ 
ce1
„„ 
,
„„ 
ce2
„„ 
,
„„ 
ce3
„„ 
,
„„ 
ce4
„„ 
;
„„ 
ce1
‰‰ 
=
‰‰ 
t
‰‰	 

.
‰‰
 #
GetConstrainedEdgeCCW
‰‰  
(
‰‰  !
p
‰‰! "
)
‰‰" #
;
‰‰# $
ce2
ÂÂ 
=
ÂÂ 
t
ÂÂ	 

.
ÂÂ
 "
GetConstrainedEdgeCW
ÂÂ 
(
ÂÂ  
p
ÂÂ  !
)
ÂÂ! "
;
ÂÂ" #
ce3
ÊÊ 
=
ÊÊ 
ot
ÊÊ	 
.
ÊÊ #
GetConstrainedEdgeCCW
ÊÊ !
(
ÊÊ! "
op
ÊÊ" $
)
ÊÊ$ %
;
ÊÊ% &
ce4
ÁÁ 
=
ÁÁ 
ot
ÁÁ	 
.
ÁÁ "
GetConstrainedEdgeCW
ÁÁ  
(
ÁÁ  !
op
ÁÁ! #
)
ÁÁ# $
;
ÁÁ$ %
bool
ÈÈ 
de1
ÈÈ 
,
ÈÈ 
de2
ÈÈ 
,
ÈÈ 
de3
ÈÈ 
,
ÈÈ 
de4
ÈÈ 
;
ÈÈ 
de1
ÍÍ 
=
ÍÍ 
t
ÍÍ	 

.
ÍÍ
  
GetDelaunayEdgeCCW
ÍÍ 
(
ÍÍ 
p
ÍÍ 
)
ÍÍ  
;
ÍÍ  !
de2
ÎÎ 
=
ÎÎ 
t
ÎÎ	 

.
ÎÎ
 
GetDelaunayEdgeCW
ÎÎ 
(
ÎÎ 
p
ÎÎ 
)
ÎÎ 
;
ÎÎ  
de3
ÏÏ 
=
ÏÏ 
ot
ÏÏ	 
.
ÏÏ  
GetDelaunayEdgeCCW
ÏÏ 
(
ÏÏ 
op
ÏÏ !
)
ÏÏ! "
;
ÏÏ" #
de4
ÌÌ 
=
ÌÌ 
ot
ÌÌ	 
.
ÌÌ 
GetDelaunayEdgeCW
ÌÌ 
(
ÌÌ 
op
ÌÌ  
)
ÌÌ  !
;
ÌÌ! "
t
ÔÔ 
.
ÔÔ 
Legalize
ÔÔ 
(
ÔÔ 
p
ÔÔ 
,
ÔÔ 
op
ÔÔ 
)
ÔÔ 
;
ÔÔ 
ot
 
.
 
Legalize
 
(
 
op
 
,
 
p
 
)
 
;
 
ot
ÛÛ 
.
ÛÛ  
SetDelaunayEdgeCCW
ÛÛ 
(
ÛÛ 
p
ÛÛ 
,
ÛÛ 
de1
ÛÛ 
)
ÛÛ  
;
ÛÛ  !
t
ÙÙ 
.
ÙÙ 
SetDelaunayEdgeCW
ÙÙ 
(
ÙÙ 
p
ÙÙ 
,
ÙÙ 
de2
ÙÙ 
)
ÙÙ 
;
ÙÙ 
t
ıı 
.
ıı  
SetDelaunayEdgeCCW
ıı 
(
ıı 
op
ıı 
,
ıı 
de3
ıı 
)
ıı  
;
ıı  !
ot
ˆˆ 
.
ˆˆ 
SetDelaunayEdgeCW
ˆˆ 
(
ˆˆ 
op
ˆˆ 
,
ˆˆ 
de4
ˆˆ 
)
ˆˆ  
;
ˆˆ  !
ot
˘˘ 
.
˘˘ #
SetConstrainedEdgeCCW
˘˘ 
(
˘˘ 
p
˘˘ 
,
˘˘ 
ce1
˘˘ "
)
˘˘" #
;
˘˘# $
t
˙˙ 
.
˙˙ "
SetConstrainedEdgeCW
˙˙ 
(
˙˙ 
p
˙˙ 
,
˙˙ 
ce2
˙˙  
)
˙˙  !
;
˙˙! "
t
˚˚ 
.
˚˚ #
SetConstrainedEdgeCCW
˚˚ 
(
˚˚ 
op
˚˚ 
,
˚˚ 
ce3
˚˚ "
)
˚˚" #
;
˚˚# $
ot
¸¸ 
.
¸¸ "
SetConstrainedEdgeCW
¸¸ 
(
¸¸ 
op
¸¸ 
,
¸¸ 
ce4
¸¸ "
)
¸¸" #
;
¸¸# $
t
ÉÉ 
.
ÉÉ 
	Neighbors
ÉÉ 
.
ÉÉ 
Clear
ÉÉ 
(
ÉÉ 
)
ÉÉ 
;
ÉÉ 
ot
ÑÑ 
.
ÑÑ 
	Neighbors
ÑÑ 
.
ÑÑ 
Clear
ÑÑ 
(
ÑÑ 
)
ÑÑ 
;
ÑÑ 
if
ÖÖ 
(
ÖÖ 
n1
ÖÖ 	
!=
ÖÖ
 
null
ÖÖ 
)
ÖÖ 
ot
ÖÖ 
.
ÖÖ 
MarkNeighbor
ÖÖ "
(
ÖÖ" #
n1
ÖÖ# %
)
ÖÖ% &
;
ÖÖ& '
if
ÜÜ 
(
ÜÜ 
n2
ÜÜ 	
!=
ÜÜ
 
null
ÜÜ 
)
ÜÜ 
t
ÜÜ 
.
ÜÜ 
MarkNeighbor
ÜÜ !
(
ÜÜ! "
n2
ÜÜ" $
)
ÜÜ$ %
;
ÜÜ% &
if
áá 
(
áá 
n3
áá 	
!=
áá
 
null
áá 
)
áá 
t
áá 
.
áá 
MarkNeighbor
áá !
(
áá! "
n3
áá" $
)
áá$ %
;
áá% &
if
àà 
(
àà 
n4
àà 	
!=
àà
 
null
àà 
)
àà 
ot
àà 
.
àà 
MarkNeighbor
àà "
(
àà" #
n4
àà# %
)
àà% &
;
àà& '
t
ââ 
.
ââ 
MarkNeighbor
ââ 
(
ââ 
ot
ââ 
)
ââ 
;
ââ 
}
ää 
}
ãã 
}åå ï
ßD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Util\PointGenerator.cs
	namespace## 	
UnityEngine##
 
.## 

ProBuilder##  
.##  !
Poly2Tri##! )
{##* +
class$$ 
PointGenerator$$ 
{$$ 
static%% 
readonly%%	 
System%% 
.%% 
Random%% 
RNG%%  #
=%%$ %
new%%& )
System%%* 0
.%%0 1
Random%%1 7
(%%7 8
)%%8 9
;%%9 :
public'' 
static''	 
List'' 
<'' 
TriangulationPoint'' '
>''' (
UniformDistribution'') <
(''< =
int''= @
n''A B
,''B C
double''D J
scale''K P
)''P Q
{''R S
List(( 
<(( 
TriangulationPoint(( 
>(( 
points(( "
=((# $
new((% (
List(() -
<((- .
TriangulationPoint((. @
>((@ A
(((A B
)((B C
;((C D
for)) 
()) 
int)) 
i)) 
=)) 
$num)) 
;)) 
i)) 
<)) 
n)) 
;)) 
i)) 
++)) 
))) 
points)) %
.))% &
Add))& )
())) *
new))* -
TriangulationPoint)). @
())@ A
scale))A F
*))G H
())I J
$num))J M
-))N O
RNG))P S
.))S T

NextDouble))T ^
())^ _
)))_ `
)))` a
,))a b
scale))c h
*))i j
())k l
$num))l o
-))p q
RNG))r u
.))u v

NextDouble	))v Ä
(
))Ä Å
)
))Å Ç
)
))Ç É
,
))É Ñ
i
))Ö Ü
)
))Ü á
)
))á à
;
))à â
return** 	
points**
 
;** 
}++ 
public-- 
static--	 
List-- 
<-- 
TriangulationPoint-- '
>--' (
UniformGrid--) 4
(--4 5
int--5 8
n--9 :
,--: ;
double--< B
scale--C H
)--H I
{--J K
double.. 	
x..
 
=.. 
$num.. 
;.. 
double// 	
size//
 
=// 
scale// 
/// 
n// 
;// 
double00 	
	halfScale00
 
=00 
$num00 
*00 
scale00 !
;00! "
List22 
<22 
TriangulationPoint22 
>22 
points22 "
=22# $
new22% (
List22) -
<22- .
TriangulationPoint22. @
>22@ A
(22A B
)22B C
;22C D
for33 
(33 
int33 
i33 
=33 
$num33 
;33 
i33 
<33 
n33 
+33 
$num33 
;33 
i33 
++33 !
)33! "
{33# $
x44 
=44 
	halfScale44 
-44 
i44 
*44 
size44 
;44 
for55 
(55 	
int55	 
j55 
=55 
$num55 
;55 
j55 
<55 
n55 
+55 
$num55 
;55 
j55  
++55  "
)55" #
points55$ *
.55* +
Add55+ .
(55. /
new55/ 2
TriangulationPoint553 E
(55E F
x55F G
,55G H
	halfScale55I R
-55S T
j55U V
*55W X
size55Y ]
,55] ^
i55_ `
)55` a
)55a b
;55b c
}66 
return77 	
points77
 
;77 
}88 
}99 
}:: π
ØD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Delaunay\Sweep\DTSweepBasin.cs
	namespace   	
UnityEngine  
 
.   

ProBuilder    
.    !
Poly2Tri  ! )
{  * +
class!! 
DTSweepBasin!! 
{!! 
public"" 
AdvancingFrontNode""	 
leftNode"" $
;""$ %
public## 
AdvancingFrontNode##	 

bottomNode## &
;##& '
public$$ 
AdvancingFrontNode$$	 
	rightNode$$ %
;$$% &
public%% 
double%%	 
width%% 
;%% 
public&& 
bool&&	 
leftHighest&& 
;&& 
}'' 
}(( ÿ	
∑D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Delaunay\Sweep\PointOnEdgeException.cs
	namespace"" 	
UnityEngine""
 
."" 

ProBuilder""  
.""  !
Poly2Tri""! )
{""* +
class##  
PointOnEdgeException## 
:## #
NotImplementedException## 5
{##6 7
public$$ 
readonly$$	 
TriangulationPoint$$ $
A$$% &
,$$& '
B$$' (
,$$( )
C$$) *
;$$* +
public&&  
PointOnEdgeException&&	 
(&& 
string&& %
message&&& -
,&&- .
TriangulationPoint&&/ A
a&&B C
,&&C D
TriangulationPoint&&E W
b&&X Y
,&&Y Z
TriangulationPoint&&[ m
c&&n o
)&&p q
:'' 
base'' 	
(''	 

message''
 
)'' 
{(( 
A)) 
=)) 
a)) 
;)) 
B** 
=** 
b** 
;** 
C++ 
=++ 
c++ 
;++ 
},, 
}-- 
}.. ¨
™D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\TriangulationAlgorithm.cs
	namespace   	
UnityEngine  
 
.   

ProBuilder    
.    !
Poly2Tri  ! )
{  * +
enum!! "
TriangulationAlgorithm!! 
{!! 
DTSweep"" 	
}## 
}$$ ∆
®D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\TriangulationContext.cs
	namespace"" 	
UnityEngine""
 
."" 

ProBuilder""  
.""  !
Poly2Tri""! )
{""* +
abstract## 	
class##
  
TriangulationContext## $
{##% &
public$$ %
TriangulationDebugContext$$	 "
DebugContext$$# /
{$$0 1
get$$2 5
;$$5 6
	protected$$7 @
set$$A D
;$$D E
}$$F G
public&& 
readonly&&	 
List&& 
<&& 
DelaunayTriangle&& '
>&&' (
	Triangles&&) 2
=&&3 4
new&&5 8
List&&9 =
<&&= >
DelaunayTriangle&&> N
>&&N O
(&&O P
)&&P Q
;&&Q R
public'' 
readonly''	 
List'' 
<'' 
TriangulationPoint'' )
>'') *
Points''+ 1
=''2 3
new''4 7
List''8 <
<''< =
TriangulationPoint''= O
>''O P
(''P Q
)''Q R
;''R S
public(( 
TriangulationMode((	 
TriangulationMode(( ,
{((- .
get((/ 2
;((2 3
	protected((4 =
set((> A
;((A B
}((C D
public)) 
Triangulatable))	 
Triangulatable)) &
{))' (
get))) ,
;)), -
private)). 5
set))6 9
;))9 :
})); <
public++ 
int++	 
	StepCount++ 
{++ 
get++ 
;++ 
private++ %
set++& )
;++) *
}+++ ,
public-- 
void--	 
Done-- 
(-- 
)-- 
{-- 
	StepCount.. 
++.. 
;.. 
}// 
public11 
abstract11	 "
TriangulationAlgorithm11 (
	Algorithm11) 2
{113 4
get115 8
;118 9
}11: ;
public33 
virtual33	 
void33  
PrepareTriangulation33 *
(33* +
Triangulatable33+ 9
t33: ;
)33; <
{33= >
Triangulatable44 
=44 
t44 
;44 
TriangulationMode55 
=55 
t55 
.55 
TriangulationMode55 *
;55* +
t66 
.66 
Prepare66 
(66 
this66 
)66 
;66 
}77 
public99 
abstract99	 #
TriangulationConstraint99 )
NewConstraint99* 7
(997 8
TriangulationPoint998 J
a99K L
,99L M
TriangulationPoint99N `
b99a b
)99b c
;99c d
public;; 
void;;	 
Update;; 
(;; 
string;; 
message;; #
);;# $
{;;% &
};;& '
public== 
virtual==	 
void== 
Clear== 
(== 
)== 
{== 
Points>> 	
.>>	 

Clear>>
 
(>> 
)>> 
;>> 
if?? 
(?? 
DebugContext?? 
!=?? 
null?? 
)?? 
DebugContext?? )
.??) *
Clear??* /
(??/ 0
)??0 1
;??1 2
	StepCount@@ 
=@@ 
$num@@ 
;@@ 
}AA 
publicCC 
virtualCC	 
boolCC 
IsDebugEnabledCC $
{CC% &
getCC' *
;CC* +
	protectedCC, 5
setCC6 9
;CC9 :
}CC; <
publicEE 
DTSweepDebugContextEE	 
DTDebugContextEE +
{EE, -
getEE. 1
{EE2 3
returnEE4 :
DebugContextEE; G
asEEH J
DTSweepDebugContextEEK ^
;EE^ _
}EE` a
}EEb c
}FF 
}GG ≠!
∂D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\Delaunay\Sweep\DTSweepDebugContext.cs
	namespace   	
UnityEngine  
 
.   

ProBuilder    
.    !
Poly2Tri  ! )
{  * +
class!! 
DTSweepDebugContext!! 
:!! %
TriangulationDebugContext!! 6
{!!7 8
public&& 
DelaunayTriangle&&	 
PrimaryTriangle&& +
{&&. /
get&&0 3
{&&4 5
return&&6 <
_primaryTriangle&&= M
;&&O P
}&&Q R
set&&S V
{&&W X
_primaryTriangle&&Y i
=&&l m
value&&n s
;&&s t
_tcx&&u y
.&&y z
Update	&&z Ä
(
&&Ä Å
$str
&&Å ñ
)
&&ñ ó
;
&&ó ò
}
&&õ ú
}
&&ù û
public'' 
DelaunayTriangle''	 
SecondaryTriangle'' -
{''. /
get''0 3
{''4 5
return''6 <
_secondaryTriangle''= O
;''O P
}''Q R
set''S V
{''W X
_secondaryTriangle''Y k
=''l m
value''n s
;''s t
_tcx''u y
.''y z
Update	''z Ä
(
''Ä Å
$str
''Å ò
)
''ò ô
;
''ô ö
}
''õ ú
}
''ù û
public(( 
TriangulationPoint((	 
ActivePoint(( '
{((. /
get((0 3
{((4 5
return((6 <
_activePoint((= I
;((O P
}((Q R
set((S V
{((W X
_activePoint((Y e
=((l m
value((n s
;((s t
_tcx((u y
.((y z
Update	((z Ä
(
((Ä Å
$str
((Å í
)
((í ì
;
((ì î
}
((õ ú
}
((ù û
public)) 
AdvancingFrontNode))	 

ActiveNode)) &
{)). /
get))0 3
{))4 5
return))6 <
_activeNode))= H
;))O P
}))Q R
set))S V
{))W X
_activeNode))Y d
=))l m
value))n s
;))s t
_tcx))u y
.))y z
Update	))z Ä
(
))Ä Å
$str
))Å ë
)
))ë í
;
))í ì
}
))õ ú
}
))ù û
public** 
DTSweepConstraint**	 
ActiveConstraint** ,
{**. /
get**0 3
{**4 5
return**6 <
_activeConstraint**= N
;**O P
}**Q R
set**S V
{**W X
_activeConstraint**Y j
=**l m
value**n s
;**s t
_tcx**u y
.**y z
Update	**z Ä
(
**Ä Å
$str
**Å ó
)
**ó ò
;
**ò ô
}
**õ ú
}
**ù û
public,, 
DTSweepDebugContext,,	 
(,, 
DTSweepContext,, ,
tcx,,- 0
),,1 2
:,,3 4
base,,5 9
(,,9 :
tcx,,: =
),,= >
{,,? @
},,A B
public.. 
bool..	 
IsDebugContext.. 
{.. 
get.. "
{..# $
return..% +
true.., 0
;..0 1
}..2 3
}..4 5
public00 
override00	 
void00 
Clear00 
(00 
)00 
{00  
PrimaryTriangle11 
=11 
null11 
;11 
SecondaryTriangle22 
=22 
null22 
;22 
ActivePoint33 
=33 
null33 
;33 

ActiveNode44 
=44 
null44 
;44 
ActiveConstraint55 
=55 
null55 
;55 
}66 
private88 	
DelaunayTriangle88
 
_primaryTriangle88 +
;88+ ,
private99 	
DelaunayTriangle99
 
_secondaryTriangle99 -
;99- .
private:: 	
TriangulationPoint::
 
_activePoint:: )
;::) *
private;; 	
AdvancingFrontNode;;
 
_activeNode;; (
;;;( )
private<< 	
DTSweepConstraint<<
 
_activeConstraint<< .
;<<. /
}== 
}>> û
¶D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\Triangulation\TriangulationPoint.cs
	namespace"" 	
UnityEngine""
 
."" 

ProBuilder""  
.""  !
Poly2Tri""! )
{""* +
class$$ 
TriangulationPoint$$ 
{$$ 
public'' 
const''	 
int'' 
INSERTED_INDEX'' !
=''" #
-''$ %
$num''% &
;''& '
public** 
const**	 
int** 
INVALID_INDEX**  
=**! "
-**# $
$num**$ %
;**% &
public-- 
List--	 
<-- 
DTSweepConstraint-- 
>--  
Edges--! &
{--' (
get--) ,
;--, -
private--. 5
set--6 9
;--9 :
}--; <
public// 
TriangulationPoint//	 
(// 
double// #
x//$ %
,//% &
double//' -
y//. /
,/// 0
int//1 4
index//5 :
=//; <
INSERTED_INDEX//= K
)//K L
{//M N
X//O P
=//P Q
x//Q R
;//R S
Y//T U
=//U V
y//V W
;//W X
Index//Y ^
=//_ `
index//a f
;//f g
}//h i
public11 
override11	 
string11 
ToString11 !
(11! "
)11" #
{11$ %
return22 	
$str22
 
+22 
X22 
+22 
$str22 
+22 
Y22 
+22 
$str22 !
;22! "
}33 
public55 
double55	 
X55 
,55 
Y55 
;55 
public66 
int66	 
Index66 
;66 
public77 
float77	 
Xf77 
{77 
get77 
{77 
return77  
(77! "
float77" '
)77' (
X77( )
;77) *
}77+ ,
set77- 0
{771 2
X773 4
=774 5
value775 :
;77: ;
}77< =
}77> ?
public88 
float88	 
Yf88 
{88 
get88 
{88 
return88  
(88! "
float88" '
)88' (
Y88( )
;88) *
}88+ ,
set88- 0
{881 2
Y883 4
=884 5
value885 :
;88: ;
}88< =
}88> ?
public:: 
void::	 
AddEdge:: 
(:: 
DTSweepConstraint:: '
e::( )
)::) *
{::+ ,
if;; 
(;; 
Edges;; 
==;; 
null;; 
);; 
Edges;; 
=;; 
new;; !
List;;" &
<;;& '
DTSweepConstraint;;' 8
>;;8 9
(;;9 :
);;: ;
;;;; <
Edges<< 
.<< 	
Add<<	 
(<< 
e<< 
)<< 
;<< 
}== 
public?? 
bool??	 
HasEdges?? 
{?? 
get?? 
{?? 
return?? %
Edges??& +
!=??, .
null??/ 3
;??3 4
}??5 6
}??7 8
}@@ 
}AA ›"
âD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\External\Poly2Tri\P2T.cs
	namespace   	
UnityEngine  
 
.   

ProBuilder    
.    !
Poly2Tri  ! )
{  * +
static!! 
class!! 
P2T!! 
{!! 
private"" 	
static""
 "
TriangulationAlgorithm"" '
_defaultAlgorithm""( 9
="": ;"
TriangulationAlgorithm""< R
.""R S
DTSweep""S Z
;""Z [
public$$ 
static$$	 
void$$ 
Triangulate$$  
($$  !

PolygonSet$$! +
ps$$, .
)$$. /
{$$0 1 
TriangulationContext%% 
tcx%% 
=%% 
CreateContext%% +
(%%+ ,
_defaultAlgorithm%%, =
)%%= >
;%%> ?
foreach&& 

(&& 
Polygon&& 
p&& 
in&& 
ps&& 
.&& 
Polygons&& $
)&&$ %
{&&& '
tcx'' 
.''  
PrepareTriangulation'' 
('' 
p'' 
)'' 
;''  
Triangulate(( 
((( 
tcx(( 
)(( 
;(( 
tcx)) 
.)) 
Clear)) 
()) 
))) 
;)) 
}** 
}++ 
public-- 
static--	 
void-- 
Triangulate--  
(--  !
Polygon--! (
p--) *
)--* +
{--, -
Triangulate.. 
(.. 
_defaultAlgorithm..  
,..  !
p.." #
)..# $
;..$ %
}// 
public11 
static11	 
void11 
Triangulate11  
(11  !
ConstrainedPointSet11! 4
cps115 8
)118 9
{11: ;
Triangulate22 
(22 
_defaultAlgorithm22  
,22  !
cps22" %
)22% &
;22& '
}33 
public55 
static55	 
void55 
Triangulate55  
(55  !
PointSet55! )
ps55* ,
)55, -
{55. /
Triangulate66 
(66 
_defaultAlgorithm66  
,66  !
ps66" $
)66$ %
;66% &
}77 
public99 
static99	  
TriangulationContext99 $
CreateContext99% 2
(992 3"
TriangulationAlgorithm993 I
	algorithm99J S
)99S T
{99U V
switch:: 	
(::
 
	algorithm:: 
):: 
{:: 
case;; "
TriangulationAlgorithm;; 
.;; 
DTSweep;; &
:;;& '
default<< 

:<<
 
return== 

new== 
DTSweepContext== 
(== 
)== 
;==  
}>> 
}?? 
publicAA 
staticAA	 
voidAA 
TriangulateAA  
(AA  !"
TriangulationAlgorithmAA! 7
	algorithmAA8 A
,AAA B
TriangulatableAAC Q
tAAR S
)AAS T
{AAU V 
TriangulationContextBB 
tcxBB 
;BB 
tcxEE 
=EE 
CreateContextEE	 
(EE 
	algorithmEE  
)EE  !
;EE! "
tcxFF 
.FF  
PrepareTriangulationFF 
(FF 
tFF 
)FF 
;FF 
TriangulateGG 
(GG 
tcxGG 
)GG 
;GG 
}II 
publicKK 
staticKK	 
voidKK 
TriangulateKK  
(KK  ! 
TriangulationContextKK! 5
tcxKK6 9
)KK9 :
{KK; <
switchLL 	
(LL
 
tcxLL 
.LL 
	AlgorithmLL 
)LL 
{LL 
caseMM "
TriangulationAlgorithmMM 
.MM 
DTSweepMM &
:MM& '
defaultNN 

:NN
 
DTSweepOO 
.OO 
TriangulateOO 
(OO 
(OO 
DTSweepContextOO '
)OO' (
tcxOO( +
)OO+ ,
;OO, -
breakPP 	
;PP	 

}QQ 
}RR 
publicXX 
staticXX	 
voidXX 
WarmupXX 
(XX 
)XX 
{XX 
}dd 
}ee 
}ff 