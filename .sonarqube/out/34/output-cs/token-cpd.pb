·æ
•D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Shadows\ShadowUtility.cs
	namespace

 	
UnityEngine


 
.

 
Experimental

 "
.

" #
	Rendering

# ,
.

, -
	Universal

- 6
{ 
internal 
class 
ShadowUtility  
{ 
internal 
struct 
Edge 
: 
IComparable *
<* +
Edge+ /
>/ 0
{ 	
public 
int 
vertexIndex0 #
;# $
public 
int 
vertexIndex1 #
;# $
public 
Vector4 
tangent "
;" #
private 
bool 
compareReversed (
;( )
public 
void 
AssignVertexIndices +
(+ ,
int, /
vi00 3
,3 4
int5 8
vi19 <
)< =
{ 
vertexIndex0 
= 
vi0 "
;" #
vertexIndex1 
= 
vi1 "
;" #
compareReversed 
=  !
vi0" %
>& '
vi1( +
;+ ,
} 
public 
int 
Compare 
( 
Edge #
a$ %
,% &
Edge' +
b, -
)- .
{ 
int !
adjustedVertexIndex0A )
=* +
a, -
.- .
compareReversed. =
?> ?
a@ A
.A B
vertexIndex1B N
:O P
aQ R
.R S
vertexIndex0S _
;_ `
int !
adjustedVertexIndex1A )
=* +
a, -
.- .
compareReversed. =
?> ?
a@ A
.A B
vertexIndex0B N
:O P
aQ R
.R S
vertexIndex1S _
;_ `
int   !
adjustedVertexIndex0B   )
=  * +
b  , -
.  - .
compareReversed  . =
?  > ?
b  @ A
.  A B
vertexIndex1  B N
:  O P
b  Q R
.  R S
vertexIndex0  S _
;  _ `
int!! !
adjustedVertexIndex1B!! )
=!!* +
b!!, -
.!!- .
compareReversed!!. =
?!!> ?
b!!@ A
.!!A B
vertexIndex0!!B N
:!!O P
b!!Q R
.!!R S
vertexIndex1!!S _
;!!_ `
int$$ 
deltaVI0$$ 
=$$ !
adjustedVertexIndex0A$$ 4
-$$5 6!
adjustedVertexIndex0B$$7 L
;$$L M
int%% 
deltaVI1%% 
=%% !
adjustedVertexIndex1A%% 4
-%%5 6!
adjustedVertexIndex1B%%7 L
;%%L M
if'' 
('' 
deltaVI0'' 
=='' 
$num''  !
)''! "
return(( 
deltaVI1(( #
;((# $
else)) 
return** 
deltaVI0** #
;**# $
}++ 
public-- 
int-- 
	CompareTo--  
(--  !
Edge--! %
edgeToCompare--& 3
)--3 4
{.. 
return// 
Compare// 
(// 
this// #
,//# $
edgeToCompare//% 2
)//2 3
;//3 4
}00 
}11 	
static33 
Edge33 

CreateEdge33 
(33 
int33 "
triangleIndexA33# 1
,331 2
int333 6
triangleIndexB337 E
,33E F
List33G K
<33K L
Vector333L S
>33S T
vertices33U ]
,33] ^
List33_ c
<33c d
int33d g
>33g h
	triangles33i r
)33r s
{44 	
Edge55 
retEdge55 
=55 
new55 
Edge55 #
(55# $
)55$ %
;55% &
retEdge77 
.77 
AssignVertexIndices77 '
(77' (
	triangles77( 1
[771 2
triangleIndexA772 @
]77@ A
,77A B
	triangles77C L
[77L M
triangleIndexB77M [
]77[ \
)77\ ]
;77] ^
Vector399 
vertex099 
=99 
vertices99 &
[99& '
retEdge99' .
.99. /
vertexIndex099/ ;
]99; <
;99< =
vertex0:: 
.:: 
z:: 
=:: 
$num:: 
;:: 
Vector3;; 
vertex1;; 
=;; 
vertices;; &
[;;& '
retEdge;;' .
.;;. /
vertexIndex1;;/ ;
];;; <
;;;< =
vertex1<< 
.<< 
z<< 
=<< 
$num<< 
;<< 
Vector3>> 
edgeDir>> 
=>> 
Vector3>> %
.>>% &
	Normalize>>& /
(>>/ 0
vertex1>>0 7
->>8 9
vertex0>>: A
)>>A B
;>>B C
retEdge?? 
.?? 
tangent?? 
=?? 
Vector3?? %
.??% &
Cross??& +
(??+ ,
-??, -
Vector3??- 4
.??4 5
forward??5 <
,??< =
edgeDir??> E
)??E F
;??F G
returnAA 
retEdgeAA 
;AA 
}BB 	
staticDD 
voidDD 
PopulateEdgeArrayDD %
(DD% &
ListDD& *
<DD* +
Vector3DD+ 2
>DD2 3
verticesDD4 <
,DD< =
ListDD> B
<DDB C
intDDC F
>DDF G
	trianglesDDH Q
,DDQ R
ListDDS W
<DDW X
EdgeDDX \
>DD\ ]
edgesDD^ c
)DDc d
{EE 	
forFF 
(FF 
intFF 
triangleIndexFF !
=FF! "
$numFF" #
;FF# $
triangleIndexFF$ 1
<FF1 2
	trianglesFF2 ;
.FF; <
CountFF< A
;FFA B
triangleIndexFFB O
+=FFO Q
$numFFQ R
)FFR S
{GG 
edgesHH 
.HH 
AddHH 
(HH 

CreateEdgeHH $
(HH$ %
triangleIndexHH% 2
,HH2 3
triangleIndexHH4 A
+HHB C
$numHHD E
,HHE F
verticesHHG O
,HHO P
	trianglesHHQ Z
)HHZ [
)HH[ \
;HH\ ]
edgesII 
.II 
AddII 
(II 

CreateEdgeII $
(II$ %
triangleIndexII% 2
+II2 3
$numII3 4
,II4 5
triangleIndexII6 C
+IID E
$numIIF G
,IIG H
verticesIII Q
,IIQ R
	trianglesIIS \
)II\ ]
)II] ^
;II^ _
edgesJJ 
.JJ 
AddJJ 
(JJ 

CreateEdgeJJ $
(JJ$ %
triangleIndexJJ% 2
+JJ2 3
$numJJ3 4
,JJ4 5
triangleIndexJJ6 C
,JJC D
verticesJJE M
,JJM N
	trianglesJJO X
)JJX Y
)JJY Z
;JJZ [
}KK 
}LL 	
staticNN 
boolNN 
IsOutsideEdgeNN !
(NN! "
intNN" %
	edgeIndexNN& /
,NN/ 0
ListNN1 5
<NN5 6
EdgeNN6 :
>NN: ;
edgesToProcessNN< J
)NNJ K
{OO 	
intPP 
previousIndexPP 
=PP 
	edgeIndexPP  )
-PP* +
$numPP, -
;PP- .
intQQ 
	nextIndexQQ 
=QQ 
	edgeIndexQQ %
+QQ& '
$numQQ( )
;QQ) *
intRR 
numberOfEdgesRR 
=RR 
edgesToProcessRR  .
.RR. /
CountRR/ 4
;RR4 5
EdgeSS 
currentEdgeSS 
=SS 
edgesToProcessSS -
[SS- .
	edgeIndexSS. 7
]SS7 8
;SS8 9
returnUU 
(UU 
previousIndexUU !
<UU" #
$numUU$ %
||UU& (
(UU) *
currentEdgeUU* 5
.UU5 6
	CompareToUU6 ?
(UU? @
edgesToProcessUU@ N
[UUN O
	edgeIndexUUO X
-UUY Z
$numUU[ \
]UU\ ]
)UU] ^
!=UU_ a
$numUUb c
)UUc d
)UUd e
&&UUf h
(UUi j
	nextIndexUUj s
>=UUt v
numberOfEdges	UUw Ñ
||
UUÖ á
(
UUà â
currentEdge
UUâ î
.
UUî ï
	CompareTo
UUï û
(
UUû ü
edgesToProcess
UUü ≠
[
UU≠ Æ
	edgeIndex
UUÆ ∑
+
UU∏ π
$num
UU∫ ª
]
UUª º
)
UUº Ω
!=
UUæ ¿
$num
UU¡ ¬
)
UU¬ √
)
UU√ ƒ
;
UUƒ ≈
}VV 	
staticXX 
voidXX 
	SortEdgesXX 
(XX 
ListXX "
<XX" #
EdgeXX# '
>XX' (
edgesToProcessXX) 7
)XX7 8
{YY 	
edgesToProcessZZ 
.ZZ 
SortZZ 
(ZZ  
)ZZ  !
;ZZ! "
}[[ 	
static]] 
void]] !
CreateShadowTriangles]] )
(]]) *
List]]* .
<]]. /
Vector3]]/ 6
>]]6 7
vertices]]8 @
,]]@ A
List]]B F
<]]F G
Color]]G L
>]]L M
colors]]N T
,]]T U
List]]V Z
<]]Z [
int]][ ^
>]]^ _
	triangles]]` i
,]]i j
List]]k o
<]]o p
Vector4]]p w
>]]w x
tangents	]]y Å
,
]]Å Ç
List
]]É á
<
]]á à
Edge
]]à å
>
]]å ç
edges
]]é ì
)
]]ì î
{^^ 	
for__ 
(__ 
int__ 
	edgeIndex__ 
=__ 
$num__ 
;__  
	edgeIndex__! *
<__* +
edges__+ 0
.__0 1
Count__1 6
;__6 7
	edgeIndex__8 A
++__A C
)__C D
{`` 
ifaa 
(aa 
IsOutsideEdgeaa  
(aa  !
	edgeIndexaa! *
,aa* +
edgesaa, 1
)aa1 2
)aa2 3
{bb 
Edgecc 
edgecc 
=cc 
edgescc  %
[cc% &
	edgeIndexcc& /
]cc/ 0
;cc0 1
tangentsdd 
[dd 
edgedd !
.dd! "
vertexIndex1dd" .
]dd. /
=dd0 1
-dd2 3
edgedd3 7
.dd7 8
tangentdd8 ?
;dd? @
intff 
newVertexIndexff &
=ff' (
verticesff) 1
.ff1 2
Countff2 7
;ff7 8
verticesgg 
.gg 
Addgg  
(gg  !
verticesgg! )
[gg) *
edgegg* .
.gg. /
vertexIndex0gg/ ;
]gg; <
)gg< =
;gg= >
colorshh 
.hh 
Addhh 
(hh 
colorshh %
[hh% &
edgehh& *
.hh* +
vertexIndex0hh+ 7
]hh7 8
)hh8 9
;hh9 :
tangentsjj 
.jj 
Addjj  
(jj  !
-jj! "
edgejj" &
.jj& '
tangentjj' .
)jj. /
;jj/ 0
	trianglesll 
.ll 
Addll !
(ll! "
edgell" &
.ll& '
vertexIndex0ll' 3
)ll3 4
;ll4 5
	trianglesmm 
.mm 
Addmm !
(mm! "
newVertexIndexmm" 0
)mm0 1
;mm1 2
	trianglesnn 
.nn 
Addnn !
(nn! "
edgenn" &
.nn& '
vertexIndex1nn' 3
)nn3 4
;nn4 5
}oo 
}pp 
}qq 	
staticss 
objectss "
InterpCustomVertexDatass ,
(ss, -
Vec3ss- 1
positionss2 :
,ss: ;
objectss< B
[ssB C
]ssC D
datassE I
,ssI J
floatssK P
[ssP Q
]ssQ R
weightsssS Z
)ssZ [
{tt 	
returnuu 
datauu 
[uu 
$numuu 
]uu 
;uu 
}vv 	
staticxx 
voidxx 
InitializeTangentsxx &
(xx& '
intxx' *
tangentsToAddxx+ 8
,xx8 9
Listxx: >
<xx> ?
Vector4xx? F
>xxF G
tangentsxxH P
)xxP Q
{yy 	
forzz 
(zz 
intzz 
izz 
=zz 
$numzz 
;zz 
izz 
<zz 
tangentsToAddzz  -
;zz- .
izz/ 0
++zz0 2
)zz2 3
tangents{{ 
.{{ 
Add{{ 
({{ 
Vector4{{ $
.{{$ %
zero{{% )
){{) *
;{{* +
}|| 	
public~~ 
static~~ 
void~~ 
GenerateShadowMesh~~ -
(~~- .
Mesh~~. 2
mesh~~3 7
,~~7 8
Vector3~~9 @
[~~@ A
]~~A B
	shapePath~~C L
)~~L M
{ 	
List
ÄÄ 
<
ÄÄ 
Vector3
ÄÄ 
>
ÄÄ 
vertices
ÄÄ "
=
ÄÄ# $
new
ÄÄ% (
List
ÄÄ) -
<
ÄÄ- .
Vector3
ÄÄ. 5
>
ÄÄ5 6
(
ÄÄ6 7
)
ÄÄ7 8
;
ÄÄ8 9
List
ÅÅ 
<
ÅÅ 
int
ÅÅ 
>
ÅÅ 
	triangles
ÅÅ 
=
ÅÅ  !
new
ÅÅ" %
List
ÅÅ& *
<
ÅÅ* +
int
ÅÅ+ .
>
ÅÅ. /
(
ÅÅ/ 0
)
ÅÅ0 1
;
ÅÅ1 2
List
ÇÇ 
<
ÇÇ 
Vector4
ÇÇ 
>
ÇÇ 
tangents
ÇÇ "
=
ÇÇ# $
new
ÇÇ% (
List
ÇÇ) -
<
ÇÇ- .
Vector4
ÇÇ. 5
>
ÇÇ5 6
(
ÇÇ6 7
)
ÇÇ7 8
;
ÇÇ8 9
List
ÉÉ 
<
ÉÉ 
Color
ÉÉ 
>
ÉÉ 
	extrusion
ÉÉ !
=
ÉÉ" #
new
ÉÉ$ '
List
ÉÉ( ,
<
ÉÉ, -
Color
ÉÉ- 2
>
ÉÉ2 3
(
ÉÉ3 4
)
ÉÉ4 5
;
ÉÉ5 6
int
ÜÜ 

pointCount
ÜÜ 
=
ÜÜ 
	shapePath
ÜÜ &
.
ÜÜ& '
Length
ÜÜ' -
;
ÜÜ- .
var
áá 
inputs
áá 
=
áá 
new
áá 
ContourVertex
áá *
[
áá* +
$num
áá+ ,
*
áá- .

pointCount
áá/ 9
]
áá9 :
;
áá: ;
for
àà 
(
àà 
int
àà 
i
àà 
=
àà 
$num
àà 
;
àà 
i
àà 
<
àà 

pointCount
àà  *
;
àà* +
i
àà, -
++
àà- /
)
àà/ 0
{
ââ 
Color
ää 
extrusionData
ää #
=
ää$ %
new
ää& )
Color
ää* /
(
ää/ 0
	shapePath
ää0 9
[
ää9 :
i
ää: ;
]
ää; <
.
ää< =
x
ää= >
,
ää> ?
	shapePath
ää@ I
[
ääI J
i
ääJ K
]
ääK L
.
ääL M
y
ääM N
,
ääN O
	shapePath
ääP Y
[
ääY Z
i
ääZ [
]
ää[ \
.
ää\ ]
x
ää] ^
,
ää^ _
	shapePath
ää` i
[
ääi j
i
ääj k
]
ääk l
.
ääl m
y
ääm n
)
ään o
;
ääo p
int
ãã 
	nextPoint
ãã 
=
ãã 
(
ãã  !
i
ãã! "
+
ãã# $
$num
ãã% &
)
ãã& '
%
ãã( )

pointCount
ãã* 4
;
ãã4 5
inputs
åå 
[
åå 
$num
åå 
*
åå 
i
åå 
]
åå 
=
åå 
new
åå !
ContourVertex
åå" /
(
åå/ 0
)
åå0 1
{
åå2 3
Position
åå4 <
=
åå= >
new
åå? B
Vec3
ååC G
(
ååG H
)
ååH I
{
ååJ K
X
ååL M
=
ååN O
	shapePath
ååP Y
[
ååY Z
i
ååZ [
]
åå[ \
.
åå\ ]
x
åå] ^
,
åå^ _
Y
åå` a
=
ååb c
	shapePath
ååd m
[
ååm n
i
åån o
]
ååo p
.
ååp q
y
ååq r
,
åår s
Z
ååt u
=
ååu v
$num
ååv w
}
ååx y
,
ååy z
Data
åå{ 
=ååÄ Å
extrusionDataååÇ è
}ååê ë
;ååë í
extrusionData
éé 
=
éé 
new
éé  #
Color
éé$ )
(
éé) *
	shapePath
éé* 3
[
éé3 4
i
éé4 5
]
éé5 6
.
éé6 7
x
éé7 8
,
éé8 9
	shapePath
éé: C
[
ééC D
i
ééD E
]
ééE F
.
ééF G
y
ééG H
,
ééH I
	shapePath
ééJ S
[
ééS T
	nextPoint
ééT ]
]
éé] ^
.
éé^ _
x
éé_ `
,
éé` a
	shapePath
ééb k
[
éék l
	nextPoint
éél u
]
ééu v
.
éév w
y
ééw x
)
ééx y
;
ééy z
Vector2
èè 
midPoint
èè  
=
èè! "
$num
èè# '
*
èè( )
(
èè* +
	shapePath
èè+ 4
[
èè4 5
i
èè5 6
]
èè6 7
+
èè8 9
	shapePath
èè: C
[
èèC D
	nextPoint
èèD M
]
èèM N
)
èèN O
;
èèO P
inputs
êê 
[
êê 
$num
êê 
*
êê 
i
êê 
+
êê 
$num
êê 
]
êê 
=
êê 
new
êê  #
ContourVertex
êê$ 1
(
êê1 2
)
êê2 3
{
êê4 5
Position
êê6 >
=
êê? @
new
êêA D
Vec3
êêE I
(
êêI J
)
êêJ K
{
êêL M
X
êêN O
=
êêP Q
midPoint
êêR Z
.
êêZ [
x
êê[ \
,
êê\ ]
Y
êê^ _
=
êê` a
midPoint
êêb j
.
êêj k
y
êêk l
,
êêl m
Z
êên o
=
êêp q
$num
êêr s
}
êês t
,
êêt u
Data
êêv z
=
êê{ |
extrusionDataêê} ä
}êêã å
;êêå ç
}
ëë 
Tess
ìì 
tessI
ìì 
=
ìì 
new
ìì 
Tess
ìì !
(
ìì! "
)
ìì" #
;
ìì# $
tessI
îî 
.
îî 

AddContour
îî 
(
îî 
inputs
îî #
,
îî# $ 
ContourOrientation
îî% 7
.
îî7 8
Original
îî8 @
)
îî@ A
;
îîA B
tessI
ïï 
.
ïï 

Tessellate
ïï 
(
ïï 
WindingRule
ïï (
.
ïï( )
EvenOdd
ïï) 0
,
ïï0 1
ElementType
ïï2 =
.
ïï= >
Polygons
ïï> F
,
ïïF G
$num
ïïH I
,
ïïI J$
InterpCustomVertexData
ïïK a
)
ïïa b
;
ïïb c
var
óó 
indicesI
óó 
=
óó 
tessI
óó  
.
óó  !
Elements
óó! )
.
óó) *
Select
óó* 0
(
óó0 1
i
óó1 2
=>
óó3 5
i
óó6 7
)
óó7 8
.
óó8 9
ToArray
óó9 @
(
óó@ A
)
óóA B
;
óóB C
var
òò 
	verticesI
òò 
=
òò 
tessI
òò !
.
òò! "
Vertices
òò" *
.
òò* +
Select
òò+ 1
(
òò1 2
v
òò2 3
=>
òò4 6
new
òò7 :
Vector3
òò; B
(
òòB C
v
òòC D
.
òòD E
Position
òòE M
.
òòM N
X
òòN O
,
òòO P
v
òòQ R
.
òòR S
Position
òòS [
.
òò[ \
Y
òò\ ]
,
òò] ^
$num
òò_ `
)
òò` a
)
òòa b
.
òòb c
ToArray
òòc j
(
òòj k
)
òòk l
;
òòl m
var
ôô 

extrusionI
ôô 
=
ôô 
tessI
ôô "
.
ôô" #
Vertices
ôô# +
.
ôô+ ,
Select
ôô, 2
(
ôô2 3
v
ôô3 4
=>
ôô5 7
new
ôô8 ;
Color
ôô< A
(
ôôA B
(
ôôB C
(
ôôC D
Color
ôôD I
)
ôôI J
v
ôôJ K
.
ôôK L
Data
ôôL P
)
ôôP Q
.
ôôQ R
r
ôôR S
,
ôôS T
(
ôôU V
(
ôôV W
Color
ôôW \
)
ôô\ ]
v
ôô] ^
.
ôô^ _
Data
ôô_ c
)
ôôc d
.
ôôd e
g
ôôe f
,
ôôf g
(
ôôh i
(
ôôi j
Color
ôôj o
)
ôôo p
v
ôôp q
.
ôôq r
Data
ôôr v
)
ôôv w
.
ôôw x
b
ôôx y
,
ôôy z
(
ôô{ |
(
ôô| }
Colorôô} Ç
)ôôÇ É
vôôÉ Ñ
.ôôÑ Ö
DataôôÖ â
)ôôâ ä
.ôôä ã
aôôã å
)ôôå ç
)ôôç é
.ôôé è
ToArrayôôè ñ
(ôôñ ó
)ôôó ò
;ôôò ô
vertices
õõ 
.
õõ 
AddRange
õõ 
(
õõ 
	verticesI
õõ '
)
õõ' (
;
õõ( )
	triangles
úú 
.
úú 
AddRange
úú 
(
úú 
indicesI
úú '
)
úú' (
;
úú( )
	extrusion
ùù 
.
ùù 
AddRange
ùù 
(
ùù 

extrusionI
ùù )
)
ùù) *
;
ùù* + 
InitializeTangents
üü 
(
üü 
vertices
üü '
.
üü' (
Count
üü( -
,
üü- .
tangents
üü/ 7
)
üü7 8
;
üü8 9
List
°° 
<
°° 
Edge
°° 
>
°° 
edges
°° 
=
°° 
new
°° "
List
°°# '
<
°°' (
Edge
°°( ,
>
°°, -
(
°°- .
)
°°. /
;
°°/ 0
PopulateEdgeArray
¢¢ 
(
¢¢ 
vertices
¢¢ &
,
¢¢& '
	triangles
¢¢( 1
,
¢¢1 2
edges
¢¢3 8
)
¢¢8 9
;
¢¢9 :
	SortEdges
££ 
(
££ 
edges
££ 
)
££ 
;
££ #
CreateShadowTriangles
§§ !
(
§§! "
vertices
§§" *
,
§§* +
	extrusion
§§, 5
,
§§5 6
	triangles
§§7 @
,
§§@ A
tangents
§§B J
,
§§J K
edges
§§L Q
)
§§Q R
;
§§R S
Color
¶¶ 
[
¶¶ 
]
¶¶ 
finalExtrusion
¶¶ "
=
¶¶# $
	extrusion
¶¶% .
.
¶¶. /
ToArray
¶¶/ 6
(
¶¶6 7
)
¶¶7 8
;
¶¶8 9
Vector3
ßß 
[
ßß 
]
ßß 
finalVertices
ßß #
=
ßß$ %
vertices
ßß& .
.
ßß. /
ToArray
ßß/ 6
(
ßß6 7
)
ßß7 8
;
ßß8 9
int
®® 
[
®® 
]
®® 
finalTriangles
®®  
=
®®! "
	triangles
®®# ,
.
®®, -
ToArray
®®- 4
(
®®4 5
)
®®5 6
;
®®6 7
Vector4
©© 
[
©© 
]
©© 
finalTangents
©© #
=
©©$ %
tangents
©©& .
.
©©. /
ToArray
©©/ 6
(
©©6 7
)
©©7 8
;
©©8 9
mesh
´´ 
.
´´ 
Clear
´´ 
(
´´ 
)
´´ 
;
´´ 
mesh
¨¨ 
.
¨¨ 
vertices
¨¨ 
=
¨¨ 
finalVertices
¨¨ )
;
¨¨) *
mesh
≠≠ 
.
≠≠ 
	triangles
≠≠ 
=
≠≠ 
finalTriangles
≠≠ +
;
≠≠+ ,
mesh
ÆÆ 
.
ÆÆ 
tangents
ÆÆ 
=
ÆÆ 
finalTangents
ÆÆ )
;
ÆÆ) *
mesh
ØØ 
.
ØØ 
colors
ØØ 
=
ØØ 
finalExtrusion
ØØ (
;
ØØ( )
}
∞∞ 	
}
±± 
}≤≤ ·
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\XR\XRLayout.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
internal 
struct 
XRLayout 
{ 
internal		 
Camera		 
camera		 
;		 
internal

 
XRSystem

 
xrSystem

 "
;

" #
internal 
XRPass 

CreatePass "
(" #
XRPassCreateInfo# 3
passCreateInfo4 B
)B C
{ 	
XRPass 
pass 
= 
XRPass  
.  !
Create! '
(' (
passCreateInfo( 6
)6 7
;7 8
xrSystem 
. 
AddPassToFrame #
(# $
pass$ (
)( )
;) *
return 
pass 
; 
} 	
internal 
void 
AddViewToPass #
(# $
XRViewCreateInfo$ 4
viewCreateInfo5 C
,C D
XRPassE K
passL P
)P Q
{ 	
pass 
. 
AddView 
( 
viewCreateInfo '
.' (

projMatrix( 2
,2 3
viewCreateInfo4 B
.B C

viewMatrixC M
,M N
viewCreateInfoO ]
.] ^
viewport^ f
,f g
viewCreateInfoh v
.v w
textureArraySlice	w à
)
à â
;
â ä
} 	
} 
} ë
†D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\DeferredPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
internal 
class 
DeferredPass 
:  ! 
ScriptableRenderPass" 6
{ 
DeferredLights 
m_DeferredLights '
;' (
public 
DeferredPass 
( 
RenderPassEvent +
evt, /
,/ 0
DeferredLights1 ?
deferredLights@ N
)N O
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @
DeferredPass@ L
)L M
)M N
;N O
base 
. 
renderPassEvent  
=! "
evt# &
;& '
m_DeferredLights 
= 
deferredLights -
;- .
} 	
public 
override 
void 
	Configure &
(& '
CommandBuffer' 4
cmd5 8
,8 9#
RenderTextureDescriptor: Q"
cameraTextureDescriporR h
)h i
{ 	"
RenderTargetIdentifier " 
lightingAttachmentId# 7
=8 9
m_DeferredLights: J
.J K(
GbufferAttachmentIdentifiersK g
[g h
m_DeferredLightsh x
.x y!
GBufferLightingIndex	y ç
]
ç é
;
é è"
RenderTargetIdentifier "
depthAttachmentId# 4
=5 6
m_DeferredLights7 G
.G H%
DepthAttachmentIdentifierH a
;a b
ConfigureTarget!! 
(!!  
lightingAttachmentId!! 0
,!!0 1
depthAttachmentId!!2 C
)!!C D
;!!D E
}"" 	
public%% 
override%% 
void%% 
Execute%% $
(%%$ %#
ScriptableRenderContext%%% <
context%%= D
,%%D E
ref%%F I
RenderingData%%J W
renderingData%%X e
)%%e f
{&& 	
m_DeferredLights'' 
.'' 
ExecuteDeferredPass'' 0
(''0 1
context''1 8
,''8 9
ref'': =
renderingData''> K
)''K L
;''L M
}(( 	
public++ 
override++ 
void++ 
OnCameraCleanup++ ,
(++, -
CommandBuffer++- :
cmd++; >
)++> ?
{,, 	
m_DeferredLights-- 
.-- 
OnCameraCleanup-- ,
(--, -
cmd--- 0
)--0 1
;--1 2
}.. 	
}// 
}00 õ
πD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\RendererFeatures\ScreenSpaceAmbientOcclusion.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Serializable 
] 
internal 
class /
#ScreenSpaceAmbientOcclusionSettings 6
{ 
[		 	
SerializeField			 
]		 
internal		 !
bool		" &

Downsample		' 1
=		2 3
false		4 9
;		9 :
[

 	
SerializeField

	 
]

 
internal

 !
DepthSource

" -
Source

. 4
=

5 6
DepthSource

7 B
.

B C
DepthNormals

C O
;

O P
[ 	
SerializeField	 
] 
internal !
NormalQuality" /
NormalSamples0 =
=> ?
NormalQuality@ M
.M N
MediumN T
;T U
[ 	
SerializeField	 
] 
internal !
float" '
	Intensity( 1
=2 3
$num4 8
;8 9
[ 	
SerializeField	 
] 
internal !
float" '"
DirectLightingStrength( >
=? @
$numA F
;F G
[ 	
SerializeField	 
] 
internal !
float" '
Radius( .
=/ 0
$num1 7
;7 8
[ 	
SerializeField	 
] 
internal !
int" %
SampleCount& 1
=2 3
$num4 5
;5 6
internal 
enum 
DepthSource !
{ 	
Depth 
= 
$num 
, 
DepthNormals 
= 
$num 
, 
} 	
internal 
enum 
NormalQuality #
{ 	
Low 
, 
Medium 
, 
High 
} 	
} 
[!! +
DisallowMultipleRendererFeature!! $
]!!$ %
internal"" 
class"" '
ScreenSpaceAmbientOcclusion"" .
:""/ 0%
ScriptableRendererFeature""1 J
{## 
[%% 	
SerializeField%%	 
,%% 
HideInInspector%% (
]%%( )
private%%* 1
Shader%%2 8
m_Shader%%9 A
=%%B C
null%%D H
;%%H I
[&& 	
SerializeField&&	 
]&& 
private&&  /
#ScreenSpaceAmbientOcclusionSettings&&! D

m_Settings&&E O
=&&P Q
new&&R U/
#ScreenSpaceAmbientOcclusionSettings&&V y
(&&y z
)&&z {
;&&{ |
private)) 
Material)) 

m_Material)) #
;))# $
private** +
ScreenSpaceAmbientOcclusionPass** /

m_SSAOPass**0 :
=**; <
null**= A
;**A B
private-- 
const-- 
string-- 
k_ShaderName-- )
=--* +
$str--, j
;--j k
private.. 
const.. 
string.. '
k_OrthographicCameraKeyword.. 8
=..9 :
$str..; J
;..J K
private// 
const// 
string// ,
 k_NormalReconstructionLowKeyword// =
=//> ?
$str//@ Y
;//Y Z
private00 
const00 
string00 /
#k_NormalReconstructionMediumKeyword00 @
=00A B
$str00C _
;00_ `
private11 
const11 
string11 -
!k_NormalReconstructionHighKeyword11 >
=11? @
$str11A [
;11[ \
private22 
const22 
string22  
k_SourceDepthKeyword22 1
=222 3
$str224 C
;22C D
private33 
const33 
string33 '
k_SourceDepthNormalsKeyword33 8
=339 :
$str33; R
;33R S
private44 
const44 
string44 "
k_SourceGBufferKeyword44 3
=444 5
$str446 G
;44G H
public77 
override77 
void77 
Create77 #
(77# $
)77$ %
{88 	
if:: 
(:: 

m_SSAOPass:: 
==:: 
null:: "
)::" #
{;; 

m_SSAOPass<< 
=<< 
new<<  +
ScreenSpaceAmbientOcclusionPass<<! @
(<<@ A
)<<A B
;<<B C
}== 
GetMaterial?? 
(?? 
)?? 
;?? 

m_SSAOPass@@ 
.@@ 
profilerTag@@ "
=@@# $
name@@% )
;@@) *

m_SSAOPassAA 
.AA 
renderPassEventAA &
=AA' (
RenderPassEventAA) 8
.AA8 9"
BeforeRenderingOpaquesAA9 O
;AAO P
}BB 	
publicEE 
overrideEE 
voidEE 
AddRenderPassesEE ,
(EE, -
ScriptableRendererEE- ?
rendererEE@ H
,EEH I
refEEJ M
RenderingDataEEN [
renderingDataEE\ i
)EEi j
{FF 	
ifGG 
(GG 
!GG 
GetMaterialGG 
(GG 
)GG 
)GG 
{HH 
DebugII 
.II 
LogErrorFormatII $
(II$ %
$str	JJ ò
,
JJò ô
GetTypeKK 
(KK 
)KK 
.KK 
NameKK "
,KK" #

m_SSAOPassKK$ .
.KK. /
profilerTagKK/ :
)KK: ;
;KK; <
returnLL 
;LL 
}MM 
boolOO 
	shouldAddOO 
=OO 

m_SSAOPassOO '
.OO' (
SetupOO( -
(OO- .

m_SettingsOO. 8
)OO8 9
;OO9 :
ifPP 
(PP 
	shouldAddPP 
)PP 
{QQ 
rendererRR 
.RR 
EnqueuePassRR $
(RR$ %

m_SSAOPassRR% /
)RR/ 0
;RR0 1
}SS 
}TT 	
	protectedWW 
overrideWW 
voidWW 
DisposeWW  '
(WW' (
boolWW( ,
	disposingWW- 6
)WW6 7
{XX 	
	CoreUtilsYY 
.YY 
DestroyYY 
(YY 

m_MaterialYY (
)YY( )
;YY) *
}ZZ 	
private\\ 
bool\\ 
GetMaterial\\  
(\\  !
)\\! "
{]] 	
if^^ 
(^^ 

m_Material^^ 
!=^^ 
null^^ "
)^^" #
{__ 
return`` 
true`` 
;`` 
}aa 
ifcc 
(cc 
m_Shadercc 
==cc 
nullcc  
)cc  !
{dd 
m_Shaderee 
=ee 
Shaderee !
.ee! "
Findee" &
(ee& '
k_ShaderNameee' 3
)ee3 4
;ee4 5
ifff 
(ff 
m_Shaderff 
==ff 
nullff  $
)ff$ %
{gg 
returnhh 
falsehh  
;hh  !
}ii 
}jj 

m_Materialll 
=ll 
	CoreUtilsll "
.ll" # 
CreateEngineMaterialll# 7
(ll7 8
m_Shaderll8 @
)ll@ A
;llA B

m_SSAOPassmm 
.mm 
materialmm 
=mm  !

m_Materialmm" ,
;mm, -
returnnn 

m_Materialnn 
!=nn  
nullnn! %
;nn% &
}oo 	
privaterr 
classrr +
ScreenSpaceAmbientOcclusionPassrr 5
:rr6 7 
ScriptableRenderPassrr8 L
{ss 	
internaluu 
stringuu 
profilerTaguu '
;uu' (
internalvv 
Materialvv 
materialvv &
;vv& '
privateyy /
#ScreenSpaceAmbientOcclusionSettingsyy 7
m_CurrentSettingsyy8 I
;yyI J
privatezz 
ProfilingSamplerzz $
m_ProfilingSamplerzz% 7
=zz8 9
ProfilingSamplerzz: J
.zzJ K
GetzzK N
(zzN O
URPProfileIdzzO [
.zz[ \
SSAOzz\ `
)zz` a
;zza b
private{{ "
RenderTargetIdentifier{{ * 
m_SSAOTexture1Target{{+ ?
={{@ A
new{{B E"
RenderTargetIdentifier{{F \
({{\ ]
s_SSAOTexture1ID{{] m
,{{m n
$num{{o p
,{{p q
CubemapFace{{r }
.{{} ~
Unknown	{{~ Ö
,
{{Ö Ü
-
{{á à
$num
{{à â
)
{{â ä
;
{{ä ã
private|| "
RenderTargetIdentifier|| * 
m_SSAOTexture2Target||+ ?
=||@ A
new||B E"
RenderTargetIdentifier||F \
(||\ ]
s_SSAOTexture2ID||] m
,||m n
$num||o p
,||p q
CubemapFace||r }
.||} ~
Unknown	||~ Ö
,
||Ö Ü
-
||á à
$num
||à â
)
||â ä
;
||ä ã
private}} "
RenderTargetIdentifier}} * 
m_SSAOTexture3Target}}+ ?
=}}@ A
new}}B E"
RenderTargetIdentifier}}F \
(}}\ ]
s_SSAOTexture3ID}}] m
,}}m n
$num}}o p
,}}p q
CubemapFace}}r }
.}}} ~
Unknown	}}~ Ö
,
}}Ö Ü
-
}}á à
$num
}}à â
)
}}â ä
;
}}ä ã
private~~ #
RenderTextureDescriptor~~ +
m_Descriptor~~, 8
;~~8 9
private
ÅÅ 
const
ÅÅ 
string
ÅÅ  -
k_SSAOAmbientOcclusionParamName
ÅÅ! @
=
ÅÅA B
$str
ÅÅC [
;
ÅÅ[ \
private
ÇÇ 
const
ÇÇ 
string
ÇÇ  
k_SSAOTextureName
ÇÇ! 2
=
ÇÇ3 4
$str
ÇÇ5 S
;
ÇÇS T
private
ÖÖ 
static
ÖÖ 
readonly
ÖÖ #
int
ÖÖ$ '
s_BaseMapID
ÖÖ( 3
=
ÖÖ4 5
Shader
ÖÖ6 <
.
ÖÖ< =
PropertyToID
ÖÖ= I
(
ÖÖI J
$str
ÖÖJ T
)
ÖÖT U
;
ÖÖU V
private
ÜÜ 
static
ÜÜ 
readonly
ÜÜ #
int
ÜÜ$ '
s_SSAOParamsID
ÜÜ( 6
=
ÜÜ7 8
Shader
ÜÜ9 ?
.
ÜÜ? @
PropertyToID
ÜÜ@ L
(
ÜÜL M
$str
ÜÜM Z
)
ÜÜZ [
;
ÜÜ[ \
private
áá 
static
áá 
readonly
áá #
int
áá$ '
s_SSAOTexture1ID
áá( 8
=
áá9 :
Shader
áá; A
.
ááA B
PropertyToID
ááB N
(
ááN O
$str
ááO h
)
ááh i
;
áái j
private
àà 
static
àà 
readonly
àà #
int
àà$ '
s_SSAOTexture2ID
àà( 8
=
àà9 :
Shader
àà; A
.
ààA B
PropertyToID
ààB N
(
ààN O
$str
ààO h
)
ààh i
;
àài j
private
ââ 
static
ââ 
readonly
ââ #
int
ââ$ '
s_SSAOTexture3ID
ââ( 8
=
ââ9 :
Shader
ââ; A
.
ââA B
PropertyToID
ââB N
(
ââN O
$str
ââO h
)
ââh i
;
ââi j
private
ãã 
enum
ãã 
ShaderPasses
ãã %
{
åå 
AO
çç 
=
çç 
$num
çç 
,
çç 
BlurHorizontal
éé 
=
éé  
$num
éé! "
,
éé" #
BlurVertical
èè 
=
èè 
$num
èè  
,
èè  !
	BlurFinal
êê 
=
êê 
$num
êê 
}
ëë 
internal
ìì -
ScreenSpaceAmbientOcclusionPass
ìì 4
(
ìì4 5
)
ìì5 6
{
îî 
m_CurrentSettings
ïï !
=
ïï" #
new
ïï$ '1
#ScreenSpaceAmbientOcclusionSettings
ïï( K
(
ïïK L
)
ïïL M
;
ïïM N
}
ññ 
internal
òò 
bool
òò 
Setup
òò 
(
òò  1
#ScreenSpaceAmbientOcclusionSettings
òò  C
featureSettings
òòD S
)
òòS T
{
ôô 
m_CurrentSettings
öö !
=
öö" #
featureSettings
öö$ 3
;
öö3 4
switch
õõ 
(
õõ 
m_CurrentSettings
õõ )
.
õõ) *
Source
õõ* 0
)
õõ0 1
{
úú 
case
ùù 1
#ScreenSpaceAmbientOcclusionSettings
ùù <
.
ùù< =
DepthSource
ùù= H
.
ùùH I
Depth
ùùI N
:
ùùN O
ConfigureInput
ûû &
(
ûû& ''
ScriptableRenderPassInput
ûû' @
.
ûû@ A
Depth
ûûA F
)
ûûF G
;
ûûG H
break
üü 
;
üü 
case
†† 1
#ScreenSpaceAmbientOcclusionSettings
†† <
.
††< =
DepthSource
††= H
.
††H I
DepthNormals
††I U
:
††U V
ConfigureInput
°° &
(
°°& ''
ScriptableRenderPassInput
°°' @
.
°°@ A
Normal
°°A G
)
°°G H
;
°°H I
break
¢¢ 
;
¢¢ 
default
££ 
:
££ 
throw
§§ 
new
§§ !)
ArgumentOutOfRangeException
§§" =
(
§§= >
)
§§> ?
;
§§? @
}
•• 
return
¶¶ 
material
¶¶ 
!=
¶¶  "
null
¶¶# '
&&
ßß 
m_CurrentSettings
ßß ,
.
ßß, -
	Intensity
ßß- 6
>
ßß7 8
$num
ßß9 =
&&
®® 
m_CurrentSettings
®® ,
.
®®, -
Radius
®®- 3
>
®®4 5
$num
®®6 :
&&
©© 
m_CurrentSettings
©© ,
.
©©, -
SampleCount
©©- 8
>
©©9 :
$num
©©; <
;
©©< =
}
™™ 
public
≠≠ 
override
≠≠ 
void
≠≠  
OnCameraSetup
≠≠! .
(
≠≠. /
CommandBuffer
≠≠/ <
cmd
≠≠= @
,
≠≠@ A
ref
≠≠B E
RenderingData
≠≠F S
renderingData
≠≠T a
)
≠≠a b
{
ÆÆ %
RenderTextureDescriptor
ØØ '$
cameraTargetDescriptor
ØØ( >
=
ØØ? @
renderingData
ØØA N
.
ØØN O

cameraData
ØØO Y
.
ØØY Z$
cameraTargetDescriptor
ØØZ p
;
ØØp q
int
∞∞ 
downsampleDivider
∞∞ %
=
∞∞& '
m_CurrentSettings
∞∞( 9
.
∞∞9 :

Downsample
∞∞: D
?
∞∞E F
$num
∞∞G H
:
∞∞I J
$num
∞∞K L
;
∞∞L M
Vector4
≥≥ 

ssaoParams
≥≥ "
=
≥≥# $
new
≥≥% (
Vector4
≥≥) 0
(
≥≥0 1
m_CurrentSettings
¥¥ %
.
¥¥% &
	Intensity
¥¥& /
,
¥¥/ 0
m_CurrentSettings
µµ %
.
µµ% &
Radius
µµ& ,
,
µµ, -
$num
∂∂ 
/
∂∂ 
downsampleDivider
∂∂ ,
,
∂∂, -
m_CurrentSettings
∑∑ %
.
∑∑% &
SampleCount
∑∑& 1
)
∏∏ 
;
∏∏ 
material
ππ 
.
ππ 
	SetVector
ππ "
(
ππ" #
s_SSAOParamsID
ππ# 1
,
ππ1 2

ssaoParams
ππ3 =
)
ππ= >
;
ππ> ?
	CoreUtils
ºº 
.
ºº 

SetKeyword
ºº $
(
ºº$ %
material
ºº% -
,
ºº- .)
k_OrthographicCameraKeyword
ºº/ J
,
ººJ K
renderingData
ººL Y
.
ººY Z

cameraData
ººZ d
.
ººd e
camera
ººe k
.
ººk l
orthographic
ººl x
)
ººx y
;
ººy z
if
ææ 
(
ææ 
m_CurrentSettings
ææ %
.
ææ% &
Source
ææ& ,
==
ææ- /1
#ScreenSpaceAmbientOcclusionSettings
ææ0 S
.
ææS T
DepthSource
ææT _
.
ææ_ `
Depth
ææ` e
)
ææe f
{
øø 
switch
¿¿ 
(
¿¿ 
m_CurrentSettings
¿¿ -
.
¿¿- .
NormalSamples
¿¿. ;
)
¿¿; <
{
¡¡ 
case
¬¬ 1
#ScreenSpaceAmbientOcclusionSettings
¬¬ @
.
¬¬@ A
NormalQuality
¬¬A N
.
¬¬N O
Low
¬¬O R
:
¬¬R S
	CoreUtils
√√ %
.
√√% &

SetKeyword
√√& 0
(
√√0 1
material
√√1 9
,
√√9 :.
 k_NormalReconstructionLowKeyword
√√; [
,
√√[ \
true
√√] a
)
√√a b
;
√√b c
	CoreUtils
ƒƒ %
.
ƒƒ% &

SetKeyword
ƒƒ& 0
(
ƒƒ0 1
material
ƒƒ1 9
,
ƒƒ9 :1
#k_NormalReconstructionMediumKeyword
ƒƒ; ^
,
ƒƒ^ _
false
ƒƒ` e
)
ƒƒe f
;
ƒƒf g
	CoreUtils
≈≈ %
.
≈≈% &

SetKeyword
≈≈& 0
(
≈≈0 1
material
≈≈1 9
,
≈≈9 :/
!k_NormalReconstructionHighKeyword
≈≈; \
,
≈≈\ ]
false
≈≈^ c
)
≈≈c d
;
≈≈d e
break
∆∆ !
;
∆∆! "
case
«« 1
#ScreenSpaceAmbientOcclusionSettings
«« @
.
««@ A
NormalQuality
««A N
.
««N O
Medium
««O U
:
««U V
	CoreUtils
»» %
.
»»% &

SetKeyword
»»& 0
(
»»0 1
material
»»1 9
,
»»9 :.
 k_NormalReconstructionLowKeyword
»»; [
,
»»[ \
false
»»] b
)
»»b c
;
»»c d
	CoreUtils
…… %
.
……% &

SetKeyword
……& 0
(
……0 1
material
……1 9
,
……9 :1
#k_NormalReconstructionMediumKeyword
……; ^
,
……^ _
true
……` d
)
……d e
;
……e f
	CoreUtils
   %
.
  % &

SetKeyword
  & 0
(
  0 1
material
  1 9
,
  9 :/
!k_NormalReconstructionHighKeyword
  ; \
,
  \ ]
false
  ^ c
)
  c d
;
  d e
break
ÀÀ !
;
ÀÀ! "
case
ÃÃ 1
#ScreenSpaceAmbientOcclusionSettings
ÃÃ @
.
ÃÃ@ A
NormalQuality
ÃÃA N
.
ÃÃN O
High
ÃÃO S
:
ÃÃS T
	CoreUtils
ÕÕ %
.
ÕÕ% &

SetKeyword
ÕÕ& 0
(
ÕÕ0 1
material
ÕÕ1 9
,
ÕÕ9 :.
 k_NormalReconstructionLowKeyword
ÕÕ; [
,
ÕÕ[ \
false
ÕÕ] b
)
ÕÕb c
;
ÕÕc d
	CoreUtils
ŒŒ %
.
ŒŒ% &

SetKeyword
ŒŒ& 0
(
ŒŒ0 1
material
ŒŒ1 9
,
ŒŒ9 :1
#k_NormalReconstructionMediumKeyword
ŒŒ; ^
,
ŒŒ^ _
false
ŒŒ` e
)
ŒŒe f
;
ŒŒf g
	CoreUtils
œœ %
.
œœ% &

SetKeyword
œœ& 0
(
œœ0 1
material
œœ1 9
,
œœ9 :/
!k_NormalReconstructionHighKeyword
œœ; \
,
œœ\ ]
true
œœ^ b
)
œœb c
;
œœc d
break
–– !
;
––! "
default
—— 
:
——  
throw
““ !
new
““" %)
ArgumentOutOfRangeException
““& A
(
““A B
)
““B C
;
““C D
}
”” 
}
‘‘ 
switch
÷÷ 
(
÷÷ 
m_CurrentSettings
÷÷ )
.
÷÷) *
Source
÷÷* 0
)
÷÷0 1
{
◊◊ 
case
ÿÿ 1
#ScreenSpaceAmbientOcclusionSettings
ÿÿ <
.
ÿÿ< =
DepthSource
ÿÿ= H
.
ÿÿH I
DepthNormals
ÿÿI U
:
ÿÿU V
	CoreUtils
ŸŸ !
.
ŸŸ! "

SetKeyword
ŸŸ" ,
(
ŸŸ, -
material
ŸŸ- 5
,
ŸŸ5 6"
k_SourceDepthKeyword
ŸŸ7 K
,
ŸŸK L
false
ŸŸM R
)
ŸŸR S
;
ŸŸS T
	CoreUtils
⁄⁄ !
.
⁄⁄! "

SetKeyword
⁄⁄" ,
(
⁄⁄, -
material
⁄⁄- 5
,
⁄⁄5 6)
k_SourceDepthNormalsKeyword
⁄⁄7 R
,
⁄⁄R S
true
⁄⁄T X
)
⁄⁄X Y
;
⁄⁄Y Z
	CoreUtils
€€ !
.
€€! "

SetKeyword
€€" ,
(
€€, -
material
€€- 5
,
€€5 6$
k_SourceGBufferKeyword
€€7 M
,
€€M N
false
€€O T
)
€€T U
;
€€U V
break
‹‹ 
;
‹‹ 
default
›› 
:
›› 
	CoreUtils
ﬁﬁ !
.
ﬁﬁ! "

SetKeyword
ﬁﬁ" ,
(
ﬁﬁ, -
material
ﬁﬁ- 5
,
ﬁﬁ5 6"
k_SourceDepthKeyword
ﬁﬁ7 K
,
ﬁﬁK L
true
ﬁﬁM Q
)
ﬁﬁQ R
;
ﬁﬁR S
	CoreUtils
ﬂﬂ !
.
ﬂﬂ! "

SetKeyword
ﬂﬂ" ,
(
ﬂﬂ, -
material
ﬂﬂ- 5
,
ﬂﬂ5 6)
k_SourceDepthNormalsKeyword
ﬂﬂ7 R
,
ﬂﬂR S
false
ﬂﬂT Y
)
ﬂﬂY Z
;
ﬂﬂZ [
	CoreUtils
‡‡ !
.
‡‡! "

SetKeyword
‡‡" ,
(
‡‡, -
material
‡‡- 5
,
‡‡5 6$
k_SourceGBufferKeyword
‡‡7 M
,
‡‡M N
false
‡‡O T
)
‡‡T U
;
‡‡U V
break
·· 
;
·· 
}
‚‚ 
m_Descriptor
ÂÂ 
=
ÂÂ $
cameraTargetDescriptor
ÂÂ 5
;
ÂÂ5 6
m_Descriptor
ÊÊ 
.
ÊÊ 
msaaSamples
ÊÊ (
=
ÊÊ) *
$num
ÊÊ+ ,
;
ÊÊ, -
m_Descriptor
ÁÁ 
.
ÁÁ 
depthBufferBits
ÁÁ ,
=
ÁÁ- .
$num
ÁÁ/ 0
;
ÁÁ0 1
m_Descriptor
ËË 
.
ËË 
width
ËË "
/=
ËË# %
downsampleDivider
ËË& 7
;
ËË7 8
m_Descriptor
ÈÈ 
.
ÈÈ 
height
ÈÈ #
/=
ÈÈ$ &
downsampleDivider
ÈÈ' 8
;
ÈÈ8 9
m_Descriptor
ÍÍ 
.
ÍÍ 
colorFormat
ÍÍ (
=
ÍÍ) *!
RenderTextureFormat
ÍÍ+ >
.
ÍÍ> ?
ARGB32
ÍÍ? E
;
ÍÍE F
cmd
ÎÎ 
.
ÎÎ 
GetTemporaryRT
ÎÎ "
(
ÎÎ" #
s_SSAOTexture1ID
ÎÎ# 3
,
ÎÎ3 4
m_Descriptor
ÎÎ5 A
,
ÎÎA B

FilterMode
ÎÎC M
.
ÎÎM N
Bilinear
ÎÎN V
)
ÎÎV W
;
ÎÎW X
m_Descriptor
ÌÌ 
.
ÌÌ 
width
ÌÌ "
*=
ÌÌ# %
downsampleDivider
ÌÌ& 7
;
ÌÌ7 8
m_Descriptor
ÓÓ 
.
ÓÓ 
height
ÓÓ #
*=
ÓÓ$ &
downsampleDivider
ÓÓ' 8
;
ÓÓ8 9
cmd
ÔÔ 
.
ÔÔ 
GetTemporaryRT
ÔÔ "
(
ÔÔ" #
s_SSAOTexture2ID
ÔÔ# 3
,
ÔÔ3 4
m_Descriptor
ÔÔ5 A
,
ÔÔA B

FilterMode
ÔÔC M
.
ÔÔM N
Bilinear
ÔÔN V
)
ÔÔV W
;
ÔÔW X
cmd
 
.
 
GetTemporaryRT
 "
(
" #
s_SSAOTexture3ID
# 3
,
3 4
m_Descriptor
5 A
,
A B

FilterMode
C M
.
M N
Bilinear
N V
)
V W
;
W X
ConfigureTarget
ÛÛ 
(
ÛÛ  
s_SSAOTexture2ID
ÛÛ  0
)
ÛÛ0 1
;
ÛÛ1 2
ConfigureClear
ÙÙ 
(
ÙÙ 
	ClearFlag
ÙÙ (
.
ÙÙ( )
None
ÙÙ) -
,
ÙÙ- .
Color
ÙÙ/ 4
.
ÙÙ4 5
white
ÙÙ5 :
)
ÙÙ: ;
;
ÙÙ; <
}
ıı 
public
¯¯ 
override
¯¯ 
void
¯¯  
Execute
¯¯! (
(
¯¯( )%
ScriptableRenderContext
¯¯) @
context
¯¯A H
,
¯¯H I
ref
¯¯J M
RenderingData
¯¯N [
renderingData
¯¯\ i
)
¯¯i j
{
˘˘ 
if
˙˙ 
(
˙˙ 
material
˙˙ 
==
˙˙ 
null
˙˙  $
)
˙˙$ %
{
˚˚ 
Debug
¸¸ 
.
¸¸ 
LogErrorFormat
¸¸ (
(
¸¸( )
$str¸¸) §
,¸¸§ •
GetType¸¸¶ ≠
(¸¸≠ Æ
)¸¸Æ Ø
.¸¸Ø ∞
Name¸¸∞ ¥
,¸¸¥ µ
profilerTag¸¸∂ ¡
)¸¸¡ ¬
;¸¸¬ √
return
˝˝ 
;
˝˝ 
}
˛˛ 
CommandBuffer
ÄÄ 
cmd
ÄÄ !
=
ÄÄ" #
CommandBufferPool
ÄÄ$ 5
.
ÄÄ5 6
Get
ÄÄ6 9
(
ÄÄ9 :
)
ÄÄ: ;
;
ÄÄ; <
using
ÅÅ 
(
ÅÅ 
new
ÅÅ 
ProfilingScope
ÅÅ )
(
ÅÅ) *
cmd
ÅÅ* -
,
ÅÅ- . 
m_ProfilingSampler
ÅÅ/ A
)
ÅÅA B
)
ÅÅB C
{
ÇÇ 
	CoreUtils
ÉÉ 
.
ÉÉ 

SetKeyword
ÉÉ (
(
ÉÉ( )
cmd
ÉÉ) ,
,
ÉÉ, -"
ShaderKeywordStrings
ÉÉ. B
.
ÉÉB C"
ScreenSpaceOcclusion
ÉÉC W
,
ÉÉW X
true
ÉÉY ]
)
ÉÉ] ^
;
ÉÉ^ _
PostProcessUtils
ÑÑ $
.
ÑÑ$ %
SetSourceSize
ÑÑ% 2
(
ÑÑ2 3
cmd
ÑÑ3 6
,
ÑÑ6 7
m_Descriptor
ÑÑ8 D
)
ÑÑD E
;
ÑÑE F
Render
áá 
(
áá 
cmd
áá 
,
áá "
m_SSAOTexture1Target
áá  4
,
áá4 5
ShaderPasses
áá6 B
.
ááB C
AO
ááC E
)
ááE F
;
ááF G!
RenderAndSetBaseMap
ää '
(
ää' (
cmd
ää( +
,
ää+ ,"
m_SSAOTexture1Target
ää- A
,
ääA B"
m_SSAOTexture2Target
ääC W
,
ääW X
ShaderPasses
ääY e
.
ääe f
BlurHorizontal
ääf t
)
äät u
;
ääu v!
RenderAndSetBaseMap
ãã '
(
ãã' (
cmd
ãã( +
,
ãã+ ,"
m_SSAOTexture2Target
ãã- A
,
ããA B"
m_SSAOTexture3Target
ããC W
,
ããW X
ShaderPasses
ããY e
.
ããe f
BlurVertical
ããf r
)
ããr s
;
ããs t!
RenderAndSetBaseMap
åå '
(
åå' (
cmd
åå( +
,
åå+ ,"
m_SSAOTexture3Target
åå- A
,
ååA B"
m_SSAOTexture2Target
ååC W
,
ååW X
ShaderPasses
ååY e
.
ååe f
	BlurFinal
ååf o
)
ååo p
;
ååp q
cmd
èè 
.
èè 
SetGlobalTexture
èè (
(
èè( )
k_SSAOTextureName
èè) :
,
èè: ;"
m_SSAOTexture2Target
èè< P
)
èèP Q
;
èèQ R
cmd
êê 
.
êê 
SetGlobalVector
êê '
(
êê' (-
k_SSAOAmbientOcclusionParamName
êê( G
,
êêG H
new
êêI L
Vector4
êêM T
(
êêT U
$num
êêU W
,
êêW X
$num
êêY [
,
êê[ \
$num
êê] _
,
êê_ `
m_CurrentSettings
êêa r
.
êêr s%
DirectLightingStrengthêês â
)êêâ ä
)êêä ã
;êêã å
}
ëë 
context
ìì 
.
ìì "
ExecuteCommandBuffer
ìì ,
(
ìì, -
cmd
ìì- 0
)
ìì0 1
;
ìì1 2
CommandBufferPool
îî !
.
îî! "
Release
îî" )
(
îî) *
cmd
îî* -
)
îî- .
;
îî. /
}
ïï 
private
óó 
void
óó 
Render
óó 
(
óó  
CommandBuffer
óó  -
cmd
óó. 1
,
óó1 2$
RenderTargetIdentifier
óó3 I
target
óóJ P
,
óóP Q
ShaderPasses
óóR ^
pass
óó_ c
)
óóc d
{
òò 
cmd
ôô 
.
ôô 
SetRenderTarget
ôô #
(
ôô# $
target
öö 
,
öö $
RenderBufferLoadAction
õõ *
.
õõ* +
DontCare
õõ+ 3
,
õõ3 4%
RenderBufferStoreAction
úú +
.
úú+ ,
Store
úú, 1
,
úú1 2
target
ùù 
,
ùù $
RenderBufferLoadAction
ûû *
.
ûû* +
DontCare
ûû+ 3
,
ûû3 4%
RenderBufferStoreAction
üü +
.
üü+ ,
DontCare
üü, 4
)
†† 
;
†† 
cmd
°° 
.
°° 
DrawMesh
°° 
(
°° 
RenderingUtils
°° +
.
°°+ ,
fullscreenMesh
°°, :
,
°°: ;
	Matrix4x4
°°< E
.
°°E F
identity
°°F N
,
°°N O
material
°°P X
,
°°X Y
$num
°°Z [
,
°°[ \
(
°°] ^
int
°°^ a
)
°°a b
pass
°°c g
)
°°g h
;
°°h i
}
¢¢ 
private
§§ 
void
§§ !
RenderAndSetBaseMap
§§ ,
(
§§, -
CommandBuffer
§§- :
cmd
§§; >
,
§§> ?$
RenderTargetIdentifier
§§@ V
baseMap
§§W ^
,
§§^ _$
RenderTargetIdentifier
§§` v
target
§§w }
,
§§} ~
ShaderPasses§§ ã
pass§§å ê
)§§ê ë
{
•• 
cmd
¶¶ 
.
¶¶ 
SetGlobalTexture
¶¶ $
(
¶¶$ %
s_BaseMapID
¶¶% 0
,
¶¶0 1
baseMap
¶¶2 9
)
¶¶9 :
;
¶¶: ;
Render
ßß 
(
ßß 
cmd
ßß 
,
ßß 
target
ßß "
,
ßß" #
pass
ßß$ (
)
ßß( )
;
ßß) *
}
®® 
public
´´ 
override
´´ 
void
´´  
OnCameraCleanup
´´! 0
(
´´0 1
CommandBuffer
´´1 >
cmd
´´? B
)
´´B C
{
¨¨ 
if
≠≠ 
(
≠≠ 
cmd
≠≠ 
==
≠≠ 
null
≠≠ 
)
≠≠  
{
ÆÆ 
throw
ØØ 
new
ØØ #
ArgumentNullException
ØØ 3
(
ØØ3 4
$str
ØØ4 9
)
ØØ9 :
;
ØØ: ;
}
∞∞ 
	CoreUtils
≤≤ 
.
≤≤ 

SetKeyword
≤≤ $
(
≤≤$ %
cmd
≤≤% (
,
≤≤( )"
ShaderKeywordStrings
≤≤* >
.
≤≤> ?"
ScreenSpaceOcclusion
≤≤? S
,
≤≤S T
false
≤≤U Z
)
≤≤Z [
;
≤≤[ \
cmd
≥≥ 
.
≥≥  
ReleaseTemporaryRT
≥≥ &
(
≥≥& '
s_SSAOTexture1ID
≥≥' 7
)
≥≥7 8
;
≥≥8 9
cmd
¥¥ 
.
¥¥  
ReleaseTemporaryRT
¥¥ &
(
¥¥& '
s_SSAOTexture2ID
¥¥' 7
)
¥¥7 8
;
¥¥8 9
cmd
µµ 
.
µµ  
ReleaseTemporaryRT
µµ &
(
µµ& '
s_SSAOTexture3ID
µµ' 7
)
µµ7 8
;
µµ8 9
}
∂∂ 
}
∑∑ 	
}
∏∏ 
}ππ †2
£D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\DepthOfField.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
public 

enum 
DepthOfFieldMode  
{ 
Off 
, 
Gaussian 
, 
Bokeh		 
}

 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' G
)G H
]H I
public 

sealed 
class 
DepthOfField $
:% &
VolumeComponent' 6
,6 7!
IPostProcessComponent8 M
{ 
[ 	
Tooltip	 
( 
$str	 ã
)
ã å
]
å ç
public %
DepthOfFieldModeParameter (
mode) -
=. /
new0 3%
DepthOfFieldModeParameter4 M
(M N
DepthOfFieldModeN ^
.^ _
Off_ b
)b c
;c d
[ 	
Tooltip	 
( 
$str A
)A B
]B C
public 
MinFloatParameter  
gaussianStart! .
=/ 0
new1 4
MinFloatParameter5 F
(F G
$numG J
,J K
$numL N
)N O
;O P
[ 	
Tooltip	 
( 
$str T
)T U
]U V
public 
MinFloatParameter  
gaussianEnd! ,
=- .
new/ 2
MinFloatParameter3 D
(D E
$numE H
,H I
$numJ L
)L M
;M N
[ 	
Tooltip	 
( 
$str m
)m n
]n o
public !
ClampedFloatParameter $
gaussianMaxRadius% 6
=7 8
new9 <!
ClampedFloatParameter= R
(R S
$numS U
,U V
$numW [
,[ \
$num] a
)a b
;b c
[ 	
Tooltip	 
( 
$str l
)l m
]m n
public 
BoolParameter 
highQualitySampling 0
=1 2
new3 6
BoolParameter7 D
(D E
falseE J
)J K
;K L
[ 	
Tooltip	 
( 
$str 6
)6 7
]7 8
public 
MinFloatParameter  
focusDistance! .
=/ 0
new1 4
MinFloatParameter5 F
(F G
$numG J
,J K
$numL P
)P Q
;Q R
[!! 	
Tooltip!!	 
(!! 
$str	!! Ü
)
!!Ü á
]
!!á à
public"" !
ClampedFloatParameter"" $
aperture""% -
="". /
new""0 3!
ClampedFloatParameter""4 I
(""I J
$num""J N
,""N O
$num""P R
,""R S
$num""T W
)""W X
;""X Y
[$$ 	
Tooltip$$	 
($$ 
$str$$ |
)$$| }
]$$} ~
public%% !
ClampedFloatParameter%% $
focalLength%%% 0
=%%1 2
new%%3 6!
ClampedFloatParameter%%7 L
(%%L M
$num%%M P
,%%P Q
$num%%R T
,%%T U
$num%%V Z
)%%Z [
;%%[ \
['' 	
Tooltip''	 
('' 
$str'' 1
)''1 2
]''2 3
public(( 
ClampedIntParameter(( "

bladeCount((# -
=((. /
new((0 3
ClampedIntParameter((4 G
(((G H
$num((H I
,((I J
$num((K L
,((L M
$num((N O
)((O P
;((P Q
[** 	
Tooltip**	 
(** 
$str	** ©
)
**© ™
]
**™ ´
public++ !
ClampedFloatParameter++ $
bladeCurvature++% 3
=++4 5
new++6 9!
ClampedFloatParameter++: O
(++O P
$num++P R
,++R S
$num++T V
,++V W
$num++X Z
)++Z [
;++[ \
[-- 	
Tooltip--	 
(-- 
$str-- >
)--> ?
]--? @
public.. !
ClampedFloatParameter.. $
bladeRotation..% 2
=..3 4
new..5 8!
ClampedFloatParameter..9 N
(..N O
$num..O Q
,..Q R
-..S T
$num..T X
,..X Y
$num..Z ^
)..^ _
;.._ `
public00 
bool00 
IsActive00 
(00 
)00 
{11 	
if22 
(22 
mode22 
.22 
value22 
==22 
DepthOfFieldMode22 .
.22. /
Off22/ 2
||223 5

SystemInfo226 @
.22@ A
graphicsShaderLevel22A T
<22U V
$num22W Y
)22Y Z
return33 
false33 
;33 
return55 
mode55 
.55 
value55 
!=55  
DepthOfFieldMode55! 1
.551 2
Gaussian552 :
||55; =

SystemInfo55> H
.55H I&
supportedRenderTargetCount55I c
>55d e
$num55f g
;55g h
}66 	
public88 
bool88 
IsTileCompatible88 $
(88$ %
)88% &
=>88' )
false88* /
;88/ 0
}99 
[;; 
Serializable;; 
];; 
public<< 

sealed<< 
class<< %
DepthOfFieldModeParameter<< 1
:<<2 3
VolumeParameter<<4 C
<<<C D
DepthOfFieldMode<<D T
><<T U
{<<V W
public<<X ^%
DepthOfFieldModeParameter<<_ x
(<<x y
DepthOfFieldMode	<<y â
value
<<ä è
,
<<è ê
bool
<<ë ï
overrideState
<<ñ £
=
<<§ •
false
<<¶ ´
)
<<´ ¨
:
<<≠ Æ
base
<<Ø ≥
(
<<≥ ¥
value
<<¥ π
,
<<π ∫
overrideState
<<ª »
)
<<» …
{
<<  À
}
<<Ã Õ
}
<<Œ œ
}== Ò
ôD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\AssemblyInfo.cs
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 6
)6 7
]7 8
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str F
)F G
]G H
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str L
)L M
]M N
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str M
)M N
]N O
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str P
)P Q
]Q Rƒ	
ØD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Shadows\CompositeShadowCaster2D.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
[		 
AddComponentMenu		 
(		 
$str		 N
)		N O
]		O P
[

 
ExecuteInEditMode

 
]

 
public 

class #
CompositeShadowCaster2D (
:) *
ShadowCasterGroup2D+ >
{ 
	protected 
void 
OnEnable 
(  
)  !
{ 	&
ShadowCasterGroup2DManager &
.& '
AddGroup' /
(/ 0
this0 4
)4 5
;5 6
} 	
	protected 
void 
	OnDisable  
(  !
)! "
{ 	&
ShadowCasterGroup2DManager &
.& '
RemoveGroup' 2
(2 3
this3 7
)7 8
;8 9
} 	
} 
} ˜
£D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\WhiteBalance.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' F
)F G
]G H
public 

sealed 
class 
WhiteBalance $
:% &
VolumeComponent' 6
,6 7!
IPostProcessComponent8 M
{ 
[ 	
Tooltip	 
( 
$str H
)H I
]I J
public		 !
ClampedFloatParameter		 $
temperature		% 0
=		1 2
new		3 6!
ClampedFloatParameter		7 L
(		L M
$num		M O
,		O P
-		Q R
$num		R U
,		U V
$num		W [
)		[ \
;		\ ]
[ 	
Tooltip	 
( 
$str T
)T U
]U V
public !
ClampedFloatParameter $
tint% )
=* +
new, /!
ClampedFloatParameter0 E
(E F
$numF H
,H I
-J K
$numK N
,N O
$numP T
)T U
;U V
public 
bool 
IsActive 
( 
) 
=> !
temperature" -
.- .
value. 3
!=4 6
$num7 9
||: <
tint= A
.A B
valueB G
!=H J
$numK M
;M N
public 
bool 
IsTileCompatible $
($ %
)% &
=>' )
true* .
;. /
} 
} ‹õ
õD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\DeferredLights.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
static 

class 
DeferredConfig 
{ 
internal 
static 
bool 
IsOpenGL %
{& '
get( +
;+ ,
set- 0
;0 1
}2 3
internal 
static 
bool #
UseCBufferForDepthRange 4
{ 	
get 
{   
return$$ 
IsOpenGL$$ #
;$$# $
}&& 
}'' 	
internal)) 
static)) 
bool)) !
UseCBufferForTileList)) 2
{** 	
get++ 
{,, 
return00 
IsOpenGL00 #
;00# $
}22 
}33 	
internal55 
static55 
bool55 "
UseCBufferForLightData55 3
{66 	
get77 
{88 
return99 
true99 
;99 
}:: 
};; 	
internal== 
static== 
bool== "
UseCBufferForLightList== 3
{>> 	
get?? 
{@@ 
returnDD 
IsOpenGLDD #
;DD# $
}FF 
}GG 	
publicJJ 
constJJ 
intJJ !
kPreferredCBufferSizeJJ .
=JJ/ 0
$numJJ1 3
*JJ4 5
$numJJ6 :
;JJ: ;
publicKK 
constKK 
intKK *
kPreferredStructuredBufferSizeKK 7
=KK8 9
$numKK: =
*KK> ?
$numKK@ D
;KKD E
publicMM 
constMM 
intMM 
kTilePixelWidthMM (
=MM) *
$numMM+ -
;MM- .
publicNN 
constNN 
intNN 
kTilePixelHeightNN )
=NN* +
$numNN, .
;NN. /
publicRR 
constRR 
intRR 
kTilerDepthRR $
=RR% &
$numRR' (
;RR( )
publicSS 
constSS 
intSS 
kTilerSubdivisionsSS +
=SS, -
$numSS. /
;SS/ 0
publicUU 
constUU 
intUU 
kAvgLightPerTileUU )
=UU* +
$numUU, .
;UU. /
public]] 
const]] 
int]] +
kTileDepthInfoIntermediateLevel]] 8
=]]9 :
-]]; <
$num]]< =
;]]= >
publiccc 
constcc 
boolcc !
kHasNativeQuadSupportcc /
=cc0 1
falsecc2 7
;cc7 8
}ee 
internalgg 
enumgg 
	LightFlaggg 
{hh $
SubtractiveMixedLightingjj  
=jj! "
$numjj# $
}kk 
internalnn 
classnn 
DeferredLightsnn !
{oo 
internalpp 
staticpp 
classpp 
ShaderConstantspp -
{qq 	
publicrr 
staticrr 
readonlyrr "
intrr# &
_LitStencilRefrr' 5
=rr6 7
Shaderrr8 >
.rr> ?
PropertyToIDrr? K
(rrK L
$strrrL \
)rr\ ]
;rr] ^
publicss 
staticss 
readonlyss "
intss# &
_LitStencilReadMaskss' :
=ss; <
Shaderss= C
.ssC D
PropertyToIDssD P
(ssP Q
$strssQ f
)ssf g
;ssg h
publictt 
statictt 
readonlytt "
inttt# & 
_LitStencilWriteMasktt' ;
=tt< =
Shadertt> D
.ttD E
PropertyToIDttE Q
(ttQ R
$strttR h
)tth i
;tti j
publicuu 
staticuu 
readonlyuu "
intuu# & 
_SimpleLitStencilRefuu' ;
=uu< =
Shaderuu> D
.uuD E
PropertyToIDuuE Q
(uuQ R
$struuR h
)uuh i
;uui j
publicvv 
staticvv 
readonlyvv "
intvv# &%
_SimpleLitStencilReadMaskvv' @
=vvA B
ShadervvC I
.vvI J
PropertyToIDvvJ V
(vvV W
$strvvW r
)vvr s
;vvs t
publicww 
staticww 
readonlyww "
intww# &&
_SimpleLitStencilWriteMaskww' A
=wwB C
ShaderwwD J
.wwJ K
PropertyToIDwwK W
(wwW X
$strwwX t
)wwt u
;wwu v
publicxx 
staticxx 
readonlyxx "
intxx# &
_StencilRefxx' 2
=xx3 4
Shaderxx5 ;
.xx; <
PropertyToIDxx< H
(xxH I
$strxxI V
)xxV W
;xxW X
publicyy 
staticyy 
readonlyyy "
intyy# &
_StencilReadMaskyy' 7
=yy8 9
Shaderyy: @
.yy@ A
PropertyToIDyyA M
(yyM N
$stryyN `
)yy` a
;yya b
publiczz 
staticzz 
readonlyzz "
intzz# &
_StencilWriteMaskzz' 8
=zz9 :
Shaderzz; A
.zzA B
PropertyToIDzzB N
(zzN O
$strzzO b
)zzb c
;zzc d
public{{ 
static{{ 
readonly{{ "
int{{# &"
_LitPunctualStencilRef{{' =
={{> ?
Shader{{@ F
.{{F G
PropertyToID{{G S
({{S T
$str{{T l
){{l m
;{{m n
public|| 
static|| 
readonly|| "
int||# &'
_LitPunctualStencilReadMask||' B
=||C D
Shader||E K
.||K L
PropertyToID||L X
(||X Y
$str||Y v
)||v w
;||w x
public}} 
static}} 
readonly}} "
int}}# &(
_LitPunctualStencilWriteMask}}' C
=}}D E
Shader}}F L
.}}L M
PropertyToID}}M Y
(}}Y Z
$str}}Z x
)}}x y
;}}y z
public~~ 
static~~ 
readonly~~ "
int~~# &(
_SimpleLitPunctualStencilRef~~' C
=~~D E
Shader~~F L
.~~L M
PropertyToID~~M Y
(~~Y Z
$str~~Z x
)~~x y
;~~y z
public 
static 
readonly "
int# &-
!_SimpleLitPunctualStencilReadMask' H
=I J
ShaderK Q
.Q R
PropertyToIDR ^
(^ _
$str	_ Ç
)
Ç É
;
É Ñ
public
ÄÄ 
static
ÄÄ 
readonly
ÄÄ "
int
ÄÄ# &0
"_SimpleLitPunctualStencilWriteMask
ÄÄ' I
=
ÄÄJ K
Shader
ÄÄL R
.
ÄÄR S
PropertyToID
ÄÄS _
(
ÄÄ_ `
$strÄÄ` Ñ
)ÄÄÑ Ö
;ÄÄÖ Ü
public
ÅÅ 
static
ÅÅ 
readonly
ÅÅ "
int
ÅÅ# &
_LitDirStencilRef
ÅÅ' 8
=
ÅÅ9 :
Shader
ÅÅ; A
.
ÅÅA B
PropertyToID
ÅÅB N
(
ÅÅN O
$str
ÅÅO b
)
ÅÅb c
;
ÅÅc d
public
ÇÇ 
static
ÇÇ 
readonly
ÇÇ "
int
ÇÇ# &$
_LitDirStencilReadMask
ÇÇ' =
=
ÇÇ> ?
Shader
ÇÇ@ F
.
ÇÇF G
PropertyToID
ÇÇG S
(
ÇÇS T
$str
ÇÇT l
)
ÇÇl m
;
ÇÇm n
public
ÉÉ 
static
ÉÉ 
readonly
ÉÉ "
int
ÉÉ# &%
_LitDirStencilWriteMask
ÉÉ' >
=
ÉÉ? @
Shader
ÉÉA G
.
ÉÉG H
PropertyToID
ÉÉH T
(
ÉÉT U
$str
ÉÉU n
)
ÉÉn o
;
ÉÉo p
public
ÑÑ 
static
ÑÑ 
readonly
ÑÑ "
int
ÑÑ# &%
_SimpleLitDirStencilRef
ÑÑ' >
=
ÑÑ? @
Shader
ÑÑA G
.
ÑÑG H
PropertyToID
ÑÑH T
(
ÑÑT U
$str
ÑÑU n
)
ÑÑn o
;
ÑÑo p
public
ÖÖ 
static
ÖÖ 
readonly
ÖÖ "
int
ÖÖ# &*
_SimpleLitDirStencilReadMask
ÖÖ' C
=
ÖÖD E
Shader
ÖÖF L
.
ÖÖL M
PropertyToID
ÖÖM Y
(
ÖÖY Z
$str
ÖÖZ x
)
ÖÖx y
;
ÖÖy z
public
ÜÜ 
static
ÜÜ 
readonly
ÜÜ "
int
ÜÜ# &+
_SimpleLitDirStencilWriteMask
ÜÜ' D
=
ÜÜE F
Shader
ÜÜG M
.
ÜÜM N
PropertyToID
ÜÜN Z
(
ÜÜZ [
$str
ÜÜ[ z
)
ÜÜz {
;
ÜÜ{ |
public
áá 
static
áá 
readonly
áá "
int
áá# &
_ClearStencilRef
áá' 7
=
áá8 9
Shader
áá: @
.
áá@ A
PropertyToID
ááA M
(
ááM N
$str
ááN `
)
áá` a
;
ááa b
public
àà 
static
àà 
readonly
àà "
int
àà# &#
_ClearStencilReadMask
àà' <
=
àà= >
Shader
àà? E
.
ààE F
PropertyToID
ààF R
(
ààR S
$str
ààS j
)
ààj k
;
ààk l
public
ââ 
static
ââ 
readonly
ââ "
int
ââ# &$
_ClearStencilWriteMask
ââ' =
=
ââ> ?
Shader
ââ@ F
.
ââF G
PropertyToID
ââG S
(
ââS T
$str
ââT l
)
ââl m
;
ââm n
public
ãã 
static
ãã 
readonly
ãã "
int
ãã# &
UDepthRanges
ãã' 3
=
ãã4 5
Shader
ãã6 <
.
ãã< =
PropertyToID
ãã= I
(
ããI J
$str
ããJ X
)
ããX Y
;
ããY Z
public
åå 
static
åå 
readonly
åå "
int
åå# &
_DepthRanges
åå' 3
=
åå4 5
Shader
åå6 <
.
åå< =
PropertyToID
åå= I
(
ååI J
$str
ååJ X
)
ååX Y
;
ååY Z
public
çç 
static
çç 
readonly
çç "
int
çç# & 
_DownsamplingWidth
çç' 9
=
çç: ;
Shader
çç< B
.
ççB C
PropertyToID
ççC O
(
ççO P
$str
ççP d
)
ççd e
;
ççe f
public
éé 
static
éé 
readonly
éé "
int
éé# &!
_DownsamplingHeight
éé' :
=
éé; <
Shader
éé= C
.
ééC D
PropertyToID
ééD P
(
ééP Q
$str
ééQ f
)
ééf g
;
éég h
public
èè 
static
èè 
readonly
èè "
int
èè# &
_SourceShiftX
èè' 4
=
èè5 6
Shader
èè7 =
.
èè= >
PropertyToID
èè> J
(
èèJ K
$str
èèK Z
)
èèZ [
;
èè[ \
public
êê 
static
êê 
readonly
êê "
int
êê# &
_SourceShiftY
êê' 4
=
êê5 6
Shader
êê7 =
.
êê= >
PropertyToID
êê> J
(
êêJ K
$str
êêK Z
)
êêZ [
;
êê[ \
public
ëë 
static
ëë 
readonly
ëë "
int
ëë# &
_TileShiftX
ëë' 2
=
ëë3 4
Shader
ëë5 ;
.
ëë; <
PropertyToID
ëë< H
(
ëëH I
$str
ëëI V
)
ëëV W
;
ëëW X
public
íí 
static
íí 
readonly
íí "
int
íí# &
_TileShiftY
íí' 2
=
íí3 4
Shader
íí5 ;
.
íí; <
PropertyToID
íí< H
(
ííH I
$str
ííI V
)
ííV W
;
ííW X
public
ìì 
static
ìì 
readonly
ìì "
int
ìì# &
_tileXCount
ìì' 2
=
ìì3 4
Shader
ìì5 ;
.
ìì; <
PropertyToID
ìì< H
(
ììH I
$str
ììI V
)
ììV W
;
ììW X
public
îî 
static
îî 
readonly
îî "
int
îî# &
_DepthRangeOffset
îî' 8
=
îî9 :
Shader
îî; A
.
îîA B
PropertyToID
îîB N
(
îîN O
$str
îîO b
)
îîb c
;
îîc d
public
ïï 
static
ïï 
readonly
ïï "
int
ïï# &
_BitmaskTex
ïï' 2
=
ïï3 4
Shader
ïï5 ;
.
ïï; <
PropertyToID
ïï< H
(
ïïH I
$str
ïïI V
)
ïïV W
;
ïïW X
public
ññ 
static
ññ 
readonly
ññ "
int
ññ# &
	UTileList
ññ' 0
=
ññ1 2
Shader
ññ3 9
.
ññ9 :
PropertyToID
ññ: F
(
ññF G
$str
ññG R
)
ññR S
;
ññS T
public
óó 
static
óó 
readonly
óó "
int
óó# &
	_TileList
óó' 0
=
óó1 2
Shader
óó3 9
.
óó9 :
PropertyToID
óó: F
(
óóF G
$str
óóG R
)
óóR S
;
óóS T
public
òò 
static
òò 
readonly
òò "
int
òò# &"
UPunctualLightBuffer
òò' ;
=
òò< =
Shader
òò> D
.
òòD E
PropertyToID
òòE Q
(
òòQ R
$str
òòR h
)
òòh i
;
òòi j
public
ôô 
static
ôô 
readonly
ôô "
int
ôô# &"
_PunctualLightBuffer
ôô' ;
=
ôô< =
Shader
ôô> D
.
ôôD E
PropertyToID
ôôE Q
(
ôôQ R
$str
ôôR h
)
ôôh i
;
ôôi j
public
öö 
static
öö 
readonly
öö "
int
öö# &
URelLightList
öö' 4
=
öö5 6
Shader
öö7 =
.
öö= >
PropertyToID
öö> J
(
ööJ K
$str
ööK Z
)
ööZ [
;
öö[ \
public
õõ 
static
õõ 
readonly
õõ "
int
õõ# &
_RelLightList
õõ' 4
=
õõ5 6
Shader
õõ7 =
.
õõ= >
PropertyToID
õõ> J
(
õõJ K
$str
õõK Z
)
õõZ [
;
õõ[ \
public
úú 
static
úú 
readonly
úú "
int
úú# &
_TilePixelWidth
úú' 6
=
úú7 8
Shader
úú9 ?
.
úú? @
PropertyToID
úú@ L
(
úúL M
$str
úúM ^
)
úú^ _
;
úú_ `
public
ùù 
static
ùù 
readonly
ùù "
int
ùù# &
_TilePixelHeight
ùù' 7
=
ùù8 9
Shader
ùù: @
.
ùù@ A
PropertyToID
ùùA M
(
ùùM N
$str
ùùN `
)
ùù` a
;
ùùa b
public
ûû 
static
ûû 
readonly
ûû "
int
ûû# &
_InstanceOffset
ûû' 6
=
ûû7 8
Shader
ûû9 ?
.
ûû? @
PropertyToID
ûû@ L
(
ûûL M
$str
ûûM ^
)
ûû^ _
;
ûû_ `
public
üü 
static
üü 
readonly
üü "
int
üü# &
	_DepthTex
üü' 0
=
üü1 2
Shader
üü3 9
.
üü9 :
PropertyToID
üü: F
(
üüF G
$str
üüG R
)
üüR S
;
üüS T
public
†† 
static
†† 
readonly
†† "
int
††# &
_DepthTexSize
††' 4
=
††5 6
Shader
††7 =
.
††= >
PropertyToID
††> J
(
††J K
$str
††K Z
)
††Z [
;
††[ \
public
°° 
static
°° 
readonly
°° "
int
°°# &
_ScreenSize
°°' 2
=
°°3 4
Shader
°°5 ;
.
°°; <
PropertyToID
°°< H
(
°°H I
$str
°°I V
)
°°V W
;
°°W X
public
££ 
static
££ 
readonly
££ "
int
££# &
_ScreenToWorld
££' 5
=
££6 7
Shader
££8 >
.
££> ?
PropertyToID
££? K
(
££K L
$str
££L \
)
££\ ]
;
££] ^
public
§§ 
static
§§ 
readonly
§§ "
int
§§# &
_unproject0
§§' 2
=
§§3 4
Shader
§§5 ;
.
§§; <
PropertyToID
§§< H
(
§§H I
$str
§§I V
)
§§V W
;
§§W X
public
•• 
static
•• 
readonly
•• "
int
••# &
_unproject1
••' 2
=
••3 4
Shader
••5 ;
.
••; <
PropertyToID
••< H
(
••H I
$str
••I V
)
••V W
;
••W X
public
ßß 
static
ßß 
int
ßß  
_MainLightPosition
ßß 0
=
ßß1 2
Shader
ßß3 9
.
ßß9 :
PropertyToID
ßß: F
(
ßßF G
$str
ßßG [
)
ßß[ \
;
ßß\ ]
public
®® 
static
®® 
int
®® 
_MainLightColor
®® -
=
®®. /
Shader
®®0 6
.
®®6 7
PropertyToID
®®7 C
(
®®C D
$str
®®D U
)
®®U V
;
®®V W
public
©© 
static
©© 
int
©© 
_SpotLightScale
©© -
=
©©. /
Shader
©©0 6
.
©©6 7
PropertyToID
©©7 C
(
©©C D
$str
©©D U
)
©©U V
;
©©V W
public
™™ 
static
™™ 
int
™™ 
_SpotLightBias
™™ ,
=
™™- .
Shader
™™/ 5
.
™™5 6
PropertyToID
™™6 B
(
™™B C
$str
™™C S
)
™™S T
;
™™T U
public
´´ 
static
´´ 
int
´´ 
_SpotLightGuard
´´ -
=
´´. /
Shader
´´0 6
.
´´6 7
PropertyToID
´´7 C
(
´´C D
$str
´´D U
)
´´U V
;
´´V W
public
¨¨ 
static
¨¨ 
int
¨¨ 
_LightPosWS
¨¨ )
=
¨¨* +
Shader
¨¨, 2
.
¨¨2 3
PropertyToID
¨¨3 ?
(
¨¨? @
$str
¨¨@ M
)
¨¨M N
;
¨¨N O
public
≠≠ 
static
≠≠ 
int
≠≠ 
_LightColor
≠≠ )
=
≠≠* +
Shader
≠≠, 2
.
≠≠2 3
PropertyToID
≠≠3 ?
(
≠≠? @
$str
≠≠@ M
)
≠≠M N
;
≠≠N O
public
ÆÆ 
static
ÆÆ 
int
ÆÆ 
_LightAttenuation
ÆÆ /
=
ÆÆ0 1
Shader
ÆÆ2 8
.
ÆÆ8 9
PropertyToID
ÆÆ9 E
(
ÆÆE F
$str
ÆÆF Y
)
ÆÆY Z
;
ÆÆZ [
public
ØØ 
static
ØØ 
int
ØØ %
_LightOcclusionProbInfo
ØØ 5
=
ØØ6 7
Shader
ØØ8 >
.
ØØ> ?
PropertyToID
ØØ? K
(
ØØK L
$str
ØØL e
)
ØØe f
;
ØØf g
public
∞∞ 
static
∞∞ 
int
∞∞ 
_LightDirection
∞∞ -
=
∞∞. /
Shader
∞∞0 6
.
∞∞6 7
PropertyToID
∞∞7 C
(
∞∞C D
$str
∞∞D U
)
∞∞U V
;
∞∞V W
public
±± 
static
±± 
int
±± 
_LightFlags
±± )
=
±±* +
Shader
±±, 2
.
±±2 3
PropertyToID
±±3 ?
(
±±? @
$str
±±@ M
)
±±M N
;
±±N O
public
≤≤ 
static
≤≤ 
int
≤≤ 
_ShadowLightIndex
≤≤ /
=
≤≤0 1
Shader
≤≤2 8
.
≤≤8 9
PropertyToID
≤≤9 E
(
≤≤E F
$str
≤≤F Y
)
≤≤Y Z
;
≤≤Z [
}
≥≥ 	
struct
ππ 
CullLightsJob
ππ 
:
ππ 
IJob
ππ #
{
∫∫ 	
public
ªª 
DeferredTiler
ªª  
tiler
ªª! &
;
ªª& '
[
ºº 
ReadOnly
ºº 
]
ºº 
[
ºº 
Unity
ºº 
.
ºº 
Collections
ºº (
.
ºº( )
LowLevel
ºº) 1
.
ºº1 2
Unsafe
ºº2 8
.
ºº8 95
'NativeDisableContainerSafetyRestriction
ºº9 `
]
ºº` a
public
ΩΩ 
NativeArray
ΩΩ 
<
ΩΩ 
DeferredTiler
ΩΩ ,
.
ΩΩ, -
PrePunctualLight
ΩΩ- =
>
ΩΩ= >
prePunctualLights
ΩΩ? P
;
ΩΩP Q
[
ææ 
ReadOnly
ææ 
]
ææ 
[
ææ 
Unity
ææ 
.
ææ 
Collections
ææ (
.
ææ( )
LowLevel
ææ) 1
.
ææ1 2
Unsafe
ææ2 8
.
ææ8 95
'NativeDisableContainerSafetyRestriction
ææ9 `
]
ææ` a
public
øø 
NativeArray
øø 
<
øø 
ushort
øø %
>
øø% &
coarseTiles
øø' 2
;
øø2 3
[
¿¿ 
ReadOnly
¿¿ 
]
¿¿ 
[
¿¿ 
Unity
¿¿ 
.
¿¿ 
Collections
¿¿ (
.
¿¿( )
LowLevel
¿¿) 1
.
¿¿1 2
Unsafe
¿¿2 8
.
¿¿8 95
'NativeDisableContainerSafetyRestriction
¿¿9 `
]
¿¿` a
public
¡¡ 
NativeArray
¡¡ 
<
¡¡ 
uint
¡¡ #
>
¡¡# $
coarseTileHeaders
¡¡% 6
;
¡¡6 7
public
¬¬ 
int
¬¬  
coarseHeaderOffset
¬¬ )
;
¬¬) *
public
√√ 
int
√√ 
istart
√√ 
;
√√ 
public
ƒƒ 
int
ƒƒ 
iend
ƒƒ 
;
ƒƒ 
public
≈≈ 
int
≈≈ 
jstart
≈≈ 
;
≈≈ 
public
∆∆ 
int
∆∆ 
jend
∆∆ 
;
∆∆ 
public
»» 
void
»» 
Execute
»» 
(
»»  
)
»»  !
{
…… 
int
   
coarseTileOffset
   $
=
  % &
(
  ' (
int
  ( +
)
  + ,
coarseTileHeaders
  , =
[
  = > 
coarseHeaderOffset
  > P
+
  Q R
$num
  S T
]
  T U
;
  U V
int
ÀÀ !
coarseVisLightCount
ÀÀ '
=
ÀÀ( )
(
ÀÀ* +
int
ÀÀ+ .
)
ÀÀ. /
coarseTileHeaders
ÀÀ/ @
[
ÀÀ@ A 
coarseHeaderOffset
ÀÀA S
+
ÀÀT U
$num
ÀÀV W
]
ÀÀW X
;
ÀÀX Y
if
ÕÕ 
(
ÕÕ 
tiler
ÕÕ 
.
ÕÕ 

TilerLevel
ÕÕ $
!=
ÕÕ% '
$num
ÕÕ( )
)
ÕÕ) *
{
ŒŒ 
tiler
œœ 
.
œœ $
CullIntermediateLights
œœ 0
(
œœ0 1
ref
–– 
prePunctualLights
–– -
,
––- .
ref
—— 
coarseTiles
—— '
,
——' (
coarseTileOffset
——) 9
,
——9 :!
coarseVisLightCount
——; N
,
——N O
istart
““ 
,
““ 
iend
““  $
,
““$ %
jstart
““& ,
,
““, -
jend
““. 2
)
”” 
;
”” 
}
‘‘ 
else
’’ 
{
÷÷ 
tiler
◊◊ 
.
◊◊ 
CullFinalLights
◊◊ )
(
◊◊) *
ref
ÿÿ 
prePunctualLights
ÿÿ -
,
ÿÿ- .
ref
ŸŸ 
coarseTiles
ŸŸ '
,
ŸŸ' (
coarseTileOffset
ŸŸ) 9
,
ŸŸ9 :!
coarseVisLightCount
ŸŸ; N
,
ŸŸN O
istart
⁄⁄ 
,
⁄⁄ 
iend
⁄⁄  $
,
⁄⁄$ %
jstart
⁄⁄& ,
,
⁄⁄, -
jend
⁄⁄. 2
)
€€ 
;
€€ 
}
‹‹ 
}
›› 
}
ﬁﬁ 	
struct
‡‡ 
DrawCall
‡‡ 
{
·· 	
public
‚‚ 
ComputeBuffer
‚‚  
tileList
‚‚! )
;
‚‚) *
public
„„ 
ComputeBuffer
„„  !
punctualLightBuffer
„„! 4
;
„„4 5
public
‰‰ 
ComputeBuffer
‰‰  
relLightList
‰‰! -
;
‰‰- .
public
ÂÂ 
int
ÂÂ 
tileListSize
ÂÂ #
;
ÂÂ# $
public
ÊÊ 
int
ÊÊ %
punctualLightBufferSize
ÊÊ .
;
ÊÊ. /
public
ÁÁ 
int
ÁÁ 
relLightListSize
ÁÁ '
;
ÁÁ' (
public
ËË 
int
ËË 
instanceOffset
ËË %
;
ËË% &
public
ÈÈ 
int
ÈÈ 
instanceCount
ÈÈ $
;
ÈÈ$ %
}
ÍÍ 	
static
ÏÏ 
readonly
ÏÏ 
string
ÏÏ 
k_SetupLights
ÏÏ ,
=
ÏÏ- .
$str
ÏÏ/ <
;
ÏÏ< =
static
ÌÌ 
readonly
ÌÌ 
string
ÌÌ 
k_DeferredPass
ÌÌ -
=
ÌÌ. /
$str
ÌÌ0 ?
;
ÌÌ? @
static
ÓÓ 
readonly
ÓÓ 
string
ÓÓ 
k_TileDepthInfo
ÓÓ .
=
ÓÓ/ 0
$str
ÓÓ1 B
;
ÓÓB C
static
ÔÔ 
readonly
ÔÔ 
string
ÔÔ !
k_DeferredTiledPass
ÔÔ 2
=
ÔÔ3 4
$str
ÔÔ5 T
;
ÔÔT U
static
 
readonly
 
string
 #
k_DeferredStencilPass
 4
=
5 6
$str
7 S
;
S T
static
ÒÒ 
readonly
ÒÒ 
string
ÒÒ 
k_DeferredFogPass
ÒÒ 0
=
ÒÒ1 2
$str
ÒÒ3 A
;
ÒÒA B
static
ÚÚ 
readonly
ÚÚ 
string
ÚÚ #
k_ClearStencilPartial
ÚÚ 4
=
ÚÚ5 6
$str
ÚÚ7 N
;
ÚÚN O
static
ÛÛ 
readonly
ÛÛ 
string
ÛÛ #
k_SetupLightConstants
ÛÛ 4
=
ÛÛ5 6
$str
ÛÛ7 N
;
ÛÛN O
static
ÙÙ 
readonly
ÙÙ 
float
ÙÙ  
kStencilShapeGuard
ÙÙ 0
=
ÙÙ1 2
$num
ÙÙ3 ;
;
ÙÙ; <
private
ıı 
static
ıı 
readonly
ıı 
ProfilingSampler
ıı  0$
m_ProfilingSetupLights
ıı1 G
=
ııH I
new
ııJ M
ProfilingSampler
ııN ^
(
ıı^ _
k_SetupLights
ıı_ l
)
ııl m
;
ıım n
private
ˆˆ 
static
ˆˆ 
readonly
ˆˆ 
ProfilingSampler
ˆˆ  0%
m_ProfilingDeferredPass
ˆˆ1 H
=
ˆˆI J
new
ˆˆK N
ProfilingSampler
ˆˆO _
(
ˆˆ_ `
k_DeferredPass
ˆˆ` n
)
ˆˆn o
;
ˆˆo p
private
˜˜ 
static
˜˜ 
readonly
˜˜ 
ProfilingSampler
˜˜  0&
m_ProfilingTileDepthInfo
˜˜1 I
=
˜˜J K
new
˜˜L O
ProfilingSampler
˜˜P `
(
˜˜` a
k_TileDepthInfo
˜˜a p
)
˜˜p q
;
˜˜q r
private
¯¯ 
static
¯¯ 
readonly
¯¯ 
ProfilingSampler
¯¯  0,
m_ProfilingSetupLightConstants
¯¯1 O
=
¯¯P Q
new
¯¯R U
ProfilingSampler
¯¯V f
(
¯¯f g#
k_SetupLightConstants
¯¯g |
)
¯¯| }
;
¯¯} ~
internal
˚˚ 
enum
˚˚ 
GBufferHandles
˚˚ $
{
¸¸ 	
DepthAsColor
˝˝ 
=
˝˝ 
$num
˝˝ 
,
˝˝ 
Albedo
˛˛ 
=
˛˛ 
$num
˛˛ 
,
˛˛ 
SpecularMetallic
ˇˇ 
=
ˇˇ 
$num
ˇˇ  
,
ˇˇ  !
NormalSmoothness
ÄÄ 
=
ÄÄ 
$num
ÄÄ  
,
ÄÄ  !
Lighting
ÅÅ 
=
ÅÅ 
$num
ÅÅ 
,
ÅÅ 

ShadowMask
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
,
ÇÇ 
Count
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
}
ÑÑ 	
internal
ÜÜ 
int
ÜÜ 
GbufferDepthIndex
ÜÜ &
{
ÜÜ' (
get
ÜÜ) ,
{
ÜÜ- .
return
ÜÜ/ 5
UseRenderPass
ÜÜ6 C
?
ÜÜD E
$num
ÜÜF G
:
ÜÜH I
-
ÜÜJ K
$num
ÜÜK L
;
ÜÜL M
}
ÜÜN O
}
ÜÜP Q
internal
áá 
int
áá  
GBufferAlbedoIndex
áá '
{
áá( )
get
áá* -
{
áá. /
return
áá0 6
GbufferDepthIndex
áá7 H
+
ááI J
$num
ááK L
;
ááL M
}
ááN O
}
ááP Q
internal
àà 
int
àà *
GBufferSpecularMetallicIndex
àà 1
{
àà2 3
get
àà4 7
{
àà8 9
return
àà: @ 
GBufferAlbedoIndex
ààA S
+
ààT U
$num
ààV W
;
ààW X
}
ààY Z
}
àà[ \
internal
ââ 
int
ââ *
GBufferNormalSmoothnessIndex
ââ 1
{
ââ2 3
get
ââ4 7
{
ââ8 9
return
ââ: @*
GBufferSpecularMetallicIndex
ââA ]
+
ââ^ _
$num
ââ` a
;
ââa b
}
ââc d
}
ââe f
internal
ää 
int
ää "
GBufferLightingIndex
ää )
{
ää* +
get
ää, /
{
ää0 1
return
ää2 8*
GBufferNormalSmoothnessIndex
ää9 U
+
ääV W
$num
ääX Y
;
ääY Z
}
ää[ \
}
ää] ^
internal
ãã 
int
ãã 
GBufferShadowMask
ãã &
{
ãã' (
get
ãã) ,
{
ãã- .
return
ãã/ 5
UseShadowMask
ãã6 C
?
ããD E"
GBufferLightingIndex
ããF Z
+
ãã[ \
$num
ãã] ^
:
ãã_ `
-
ããa b
$num
ããb c
;
ããc d
}
ããe f
}
ããg h
internal
åå 
int
åå 
GBufferSliceCount
åå &
{
åå' (
get
åå) ,
{
åå- .
return
åå/ 5
$num
åå6 7
+
åå8 9
(
åå: ;
UseRenderPass
åå; H
?
ååI J
$num
ååK L
:
ååM N
$num
ååO P
)
ååP Q
+
ååR S
(
ååT U
UseShadowMask
ååU b
?
ååc d
$num
ååe f
:
ååg h
$num
ååi j
)
ååj k
;
ååk l
}
ååm n
}
ååo p
internal
éé 
GraphicsFormat
éé 
GetGBufferFormat
éé  0
(
éé0 1
int
éé1 4
index
éé5 :
)
éé: ;
{
èè 	
if
êê 
(
êê 
index
êê 
==
êê  
GBufferAlbedoIndex
êê +
)
êê+ ,
return
ëë 
QualitySettings
ëë &
.
ëë& '
activeColorSpace
ëë' 7
==
ëë8 :

ColorSpace
ëë; E
.
ëëE F
Linear
ëëF L
?
ëëM N
GraphicsFormat
ëëO ]
.
ëë] ^
R8G8B8A8_SRGB
ëë^ k
:
ëël m
GraphicsFormat
ëën |
.
ëë| }
R8G8B8A8_UNormëë} ã
;ëëã å
else
íí 
if
íí 
(
íí 
index
íí 
==
íí *
GBufferSpecularMetallicIndex
íí :
)
íí: ;
return
ìì 
QualitySettings
ìì &
.
ìì& '
activeColorSpace
ìì' 7
==
ìì8 :

ColorSpace
ìì; E
.
ììE F
Linear
ììF L
?
ììM N
GraphicsFormat
ììO ]
.
ìì] ^
R8G8B8A8_SRGB
ìì^ k
:
ììl m
GraphicsFormat
ììn |
.
ìì| }
R8G8B8A8_UNormìì} ã
;ììã å
else
îî 
if
îî 
(
îî 
index
îî 
==
îî *
GBufferNormalSmoothnessIndex
îî :
)
îî: ;
return
ïï 
this
ïï 
.
ïï $
AccurateGbufferNormals
ïï 2
?
ïï3 4
GraphicsFormat
ïï5 C
.
ïïC D
R8G8B8A8_UNorm
ïïD R
:
ïïS T
GraphicsFormat
ïïU c
.
ïïc d
R8G8B8A8_SNorm
ïïd r
;
ïïr s
else
ññ 
if
ññ 
(
ññ 
index
ññ 
==
ññ "
GBufferLightingIndex
ññ 2
)
ññ2 3
return
óó 
GraphicsFormat
óó %
.
óó% &
None
óó& *
;
óó* +
else
òò 
if
òò 
(
òò 
index
òò 
==
òò 
GbufferDepthIndex
òò /
)
òò/ 0
return
ôô 
GraphicsFormat
ôô %
.
ôô% &

R32_SFloat
ôô& 0
;
ôô0 1
else
öö 
if
öö 
(
öö 
index
öö 
==
öö 
GBufferShadowMask
öö /
)
öö/ 0
return
õõ 
GraphicsFormat
õõ %
.
õõ% &
R8G8B8A8_UNorm
õõ& 4
;
õõ4 5
else
úú 
return
ùù 
GraphicsFormat
ùù %
.
ùù% &
None
ùù& *
;
ùù* +
}
ûû 	
internal
°° 
bool
°° 
UseShadowMask
°° #
{
°°$ %
get
°°& )
{
°°* +
return
°°, 2
this
°°3 7
.
°°7 8 
MixedLightingSetup
°°8 J
==
°°K M 
MixedLightingSetup
°°N `
.
°°` a
Subtractive
°°a l
;
°°l m
}
°°n o
}
°°p q
internal
££ 
bool
££ 
UseRenderPass
££ #
{
££$ %
get
££& )
;
££) *
set
££+ .
;
££. /
}
££0 1
internal
•• 
bool
•• 
HasDepthPrepass
•• %
{
••& '
get
••( +
;
••+ ,
set
••- 0
;
••0 1
}
••2 3
internal
ßß 
bool
ßß 
	IsOverlay
ßß 
{
ßß  !
get
ßß" %
;
ßß% &
set
ßß' *
;
ßß* +
}
ßß, -
internal
©© 
bool
©© $
AccurateGbufferNormals
©© ,
{
©©- .
get
©©/ 2
;
©©2 3
set
©©4 7
;
©©7 8
}
©©9 :
internal
´´ 
bool
´´ "
TiledDeferredShading
´´ *
{
´´+ ,
get
´´- 0
;
´´0 1
set
´´2 5
;
´´5 6
}
´´7 8
internal
≠≠  
MixedLightingSetup
≠≠ # 
MixedLightingSetup
≠≠$ 6
{
≠≠7 8
get
≠≠9 <
;
≠≠< =
set
≠≠> A
;
≠≠A B
}
≠≠C D
internal
ØØ 
bool
ØØ 
UseJobSystem
ØØ "
{
ØØ# $
get
ØØ% (
;
ØØ( )
set
ØØ* -
;
ØØ- .
}
ØØ/ 0
internal
±± 
int
±± 
RenderWidth
±±  
{
±±! "
get
±±# &
;
±±& '
set
±±( +
;
±±+ ,
}
±±- .
internal
≥≥ 
int
≥≥ 
RenderHeight
≥≥ !
{
≥≥" #
get
≥≥$ '
;
≥≥' (
set
≥≥) ,
;
≥≥, -
}
≥≥. /
internal
∂∂  
RenderTargetHandle
∂∂ #
[
∂∂# $
]
∂∂$ % 
GbufferAttachments
∂∂& 8
{
∂∂9 :
get
∂∂; >
;
∂∂> ?
set
∂∂@ C
;
∂∂C D
}
∂∂E F
internal
∏∏  
RenderTargetHandle
∏∏ #
DepthAttachment
∏∏$ 3
{
∏∏4 5
get
∏∏6 9
;
∏∏9 :
set
∏∏; >
;
∏∏> ?
}
∏∏@ A
internal
∫∫  
RenderTargetHandle
∫∫ #
DepthCopyTexture
∫∫$ 4
{
∫∫5 6
get
∫∫7 :
;
∫∫: ;
set
∫∫< ?
;
∫∫? @
}
∫∫A B
internal
ºº  
RenderTargetHandle
ºº #
DepthInfoTexture
ºº$ 4
{
ºº5 6
get
ºº7 :
;
ºº: ;
set
ºº< ?
;
ºº? @
}
ººA B
internal
ææ  
RenderTargetHandle
ææ #"
TileDepthInfoTexture
ææ$ 8
{
ææ9 :
get
ææ; >
;
ææ> ?
set
ææ@ C
;
ææC D
}
ææE F
internal
¿¿ $
RenderTargetIdentifier
¿¿ '
[
¿¿' (
]
¿¿( )*
GbufferAttachmentIdentifiers
¿¿* F
{
¿¿G H
get
¿¿I L
;
¿¿L M
set
¿¿N Q
;
¿¿Q R
}
¿¿S T
internal
¡¡ $
RenderTargetIdentifier
¡¡ ''
DepthAttachmentIdentifier
¡¡( A
{
¡¡B C
get
¡¡D G
;
¡¡G H
set
¡¡I L
;
¡¡L M
}
¡¡N O
internal
¬¬ $
RenderTargetIdentifier
¬¬ '(
DepthCopyTextureIdentifier
¬¬( B
{
¬¬C D
get
¬¬E H
;
¬¬H I
set
¬¬J M
;
¬¬M N
}
¬¬O P
internal
√√ $
RenderTargetIdentifier
√√ '(
DepthInfoTextureIdentifier
√√( B
{
√√C D
get
√√E H
;
√√H I
set
√√J M
;
√√M N
}
√√O P
internal
ƒƒ $
RenderTargetIdentifier
ƒƒ ',
TileDepthInfoTextureIdentifier
ƒƒ( F
{
ƒƒG H
get
ƒƒI L
;
ƒƒL M
set
ƒƒN Q
;
ƒƒQ R
}
ƒƒS T
int
«« !
m_CachedRenderWidth
«« 
=
««  !
$num
««" #
;
««# $
int
…… "
m_CachedRenderHeight
……  
=
……! "
$num
……# $
;
……$ %
	Matrix4x4
ÀÀ &
m_CachedProjectionMatrix
ÀÀ *
;
ÀÀ* +
DeferredTiler
ŒŒ 
[
ŒŒ 
]
ŒŒ 
m_Tilers
ŒŒ  
;
ŒŒ  !
int
œœ 
[
œœ 
]
œœ "
m_TileDataCapacities
œœ "
;
œœ" #
bool
““  
m_HasTileVisLights
““ 
;
““  
NativeArray
‘‘ 
<
‘‘ 
ushort
‘‘ 
>
‘‘  
m_stencilVisLights
‘‘ .
;
‘‘. /
NativeArray
÷÷ 
<
÷÷ 
ushort
÷÷ 
>
÷÷ &
m_stencilVisLightOffsets
÷÷ 4
;
÷÷4 5.
 AdditionalLightsShadowCasterPass
ÿÿ (0
"m_AdditionalLightsShadowCasterPass
ÿÿ) K
;
ÿÿK L
Mesh
€€ 
m_SphereMesh
€€ 
;
€€ 
Mesh
›› 
m_HemisphereMesh
›› 
;
›› 
Mesh
ﬂﬂ 
m_FullscreenMesh
ﬂﬂ 
;
ﬂﬂ 
int
‚‚ %
m_MaxDepthRangePerBatch
‚‚ #
;
‚‚# $
int
‰‰  
m_MaxTilesPerBatch
‰‰ 
;
‰‰ 
int
ÊÊ (
m_MaxPunctualLightPerBatch
ÊÊ &
;
ÊÊ& '
int
ËË *
m_MaxRelLightIndicesPerBatch
ËË (
;
ËË( )
Material
ÎÎ %
m_TileDepthInfoMaterial
ÎÎ (
;
ÎÎ( )
Material
ÌÌ $
m_TileDeferredMaterial
ÌÌ '
;
ÌÌ' (
Material
ÔÔ '
m_StencilDeferredMaterial
ÔÔ *
;
ÔÔ* +
	Matrix4x4
ÚÚ 
[
ÚÚ 
]
ÚÚ 
m_ScreenToWorld
ÚÚ #
=
ÚÚ$ %
new
ÚÚ& )
	Matrix4x4
ÚÚ* 3
[
ÚÚ3 4
$num
ÚÚ4 5
]
ÚÚ5 6
;
ÚÚ6 7
ProfilingSampler
ÙÙ 1
#m_ProfilingSamplerDeferredTiledPass
ÙÙ <
=
ÙÙ= >
new
ÙÙ? B
ProfilingSampler
ÙÙC S
(
ÙÙS T!
k_DeferredTiledPass
ÙÙT g
)
ÙÙg h
;
ÙÙh i
ProfilingSampler
ıı 3
%m_ProfilingSamplerDeferredStencilPass
ıı >
=
ıı? @
new
ııA D
ProfilingSampler
ııE U
(
ııU V#
k_DeferredStencilPass
ııV k
)
ıık l
;
ııl m
ProfilingSampler
ˆˆ /
!m_ProfilingSamplerDeferredFogPass
ˆˆ :
=
ˆˆ; <
new
ˆˆ= @
ProfilingSampler
ˆˆA Q
(
ˆˆQ R
k_DeferredFogPass
ˆˆR c
)
ˆˆc d
;
ˆˆd e
ProfilingSampler
˜˜ 7
)m_ProfilingSamplerClearStencilPartialPass
˜˜ B
=
˜˜C D
new
˜˜E H
ProfilingSampler
˜˜I Y
(
˜˜Y Z#
k_ClearStencilPartial
˜˜Z o
)
˜˜o p
;
˜˜p q
internal
˙˙ 
DeferredLights
˙˙ 
(
˙˙  
Material
˙˙  (#
tileDepthInfoMaterial
˙˙) >
,
˙˙> ?
Material
˙˙@ H"
tileDeferredMaterial
˙˙I ]
,
˙˙] ^
Material
˙˙_ g%
stencilDeferredMaterial
˙˙h 
)˙˙ Ä
{
˚˚ 	
DeferredConfig
˛˛ 
.
˛˛ 
IsOpenGL
˛˛ #
=
˛˛$ %

SystemInfo
˛˛& 0
.
˛˛0 1 
graphicsDeviceType
˛˛1 C
==
˛˛D F 
GraphicsDeviceType
˛˛G Y
.
˛˛Y Z

OpenGLCore
˛˛Z d
||
ˇˇ# %

SystemInfo
ˇˇ& 0
.
ˇˇ0 1 
graphicsDeviceType
ˇˇ1 C
==
ˇˇD F 
GraphicsDeviceType
ˇˇG Y
.
ˇˇY Z
	OpenGLES2
ˇˇZ c
||
ÄÄ# %

SystemInfo
ÄÄ& 0
.
ÄÄ0 1 
graphicsDeviceType
ÄÄ1 C
==
ÄÄD F 
GraphicsDeviceType
ÄÄG Y
.
ÄÄY Z
	OpenGLES3
ÄÄZ c
;
ÄÄc d%
m_TileDepthInfoMaterial
ÇÇ #
=
ÇÇ$ %#
tileDepthInfoMaterial
ÇÇ& ;
;
ÇÇ; <$
m_TileDeferredMaterial
ÉÉ "
=
ÉÉ# $"
tileDeferredMaterial
ÉÉ% 9
;
ÉÉ9 :'
m_StencilDeferredMaterial
ÑÑ %
=
ÑÑ& '%
stencilDeferredMaterial
ÑÑ( ?
;
ÑÑ? @
if
ÜÜ 
(
ÜÜ $
m_TileDeferredMaterial
ÜÜ &
!=
ÜÜ' )
null
ÜÜ* .
)
ÜÜ. /
{
áá $
m_TileDeferredMaterial
àà &
.
àà& '
SetInt
àà' -
(
àà- .
ShaderConstants
àà. =
.
àà= >
_LitStencilRef
àà> L
,
ààL M
(
ààN O
int
ààO R
)
ààR S
StencilUsage
ààS _
.
àà_ `
MaterialLit
àà` k
)
ààk l
;
ààl m$
m_TileDeferredMaterial
ââ &
.
ââ& '
SetInt
ââ' -
(
ââ- .
ShaderConstants
ââ. =
.
ââ= >!
_LitStencilReadMask
ââ> Q
,
ââQ R
(
ââS T
int
ââT W
)
ââW X
StencilUsage
ââX d
.
ââd e
MaterialMask
ââe q
)
ââq r
;
ââr s$
m_TileDeferredMaterial
ää &
.
ää& '
SetInt
ää' -
(
ää- .
ShaderConstants
ää. =
.
ää= >"
_LitStencilWriteMask
ää> R
,
ääR S
$num
ääT U
)
ääU V
;
ääV W$
m_TileDeferredMaterial
ãã &
.
ãã& '
SetInt
ãã' -
(
ãã- .
ShaderConstants
ãã. =
.
ãã= >"
_SimpleLitStencilRef
ãã> R
,
ããR S
(
ããT U
int
ããU X
)
ããX Y
StencilUsage
ããY e
.
ããe f
MaterialSimpleLit
ããf w
)
ããw x
;
ããx y$
m_TileDeferredMaterial
åå &
.
åå& '
SetInt
åå' -
(
åå- .
ShaderConstants
åå. =
.
åå= >'
_SimpleLitStencilReadMask
åå> W
,
ååW X
(
ååY Z
int
ååZ ]
)
åå] ^
StencilUsage
åå^ j
.
ååj k
MaterialMask
ååk w
)
ååw x
;
ååx y$
m_TileDeferredMaterial
çç &
.
çç& '
SetInt
çç' -
(
çç- .
ShaderConstants
çç. =
.
çç= >(
_SimpleLitStencilWriteMask
çç> X
,
ççX Y
$num
ççZ [
)
çç[ \
;
çç\ ]
}
éé 
if
ëë 
(
ëë '
m_StencilDeferredMaterial
ëë )
!=
ëë* ,
null
ëë- 1
)
ëë1 2
{
íí '
m_StencilDeferredMaterial
ìì )
.
ìì) *
SetInt
ìì* 0
(
ìì0 1
ShaderConstants
ìì1 @
.
ìì@ A
_StencilRef
ììA L
,
ììL M
(
ììN O
int
ììO R
)
ììR S
StencilUsage
ììS _
.
ìì_ `
MaterialUnlit
ìì` m
)
ììm n
;
ììn o'
m_StencilDeferredMaterial
îî )
.
îî) *
SetInt
îî* 0
(
îî0 1
ShaderConstants
îî1 @
.
îî@ A
_StencilReadMask
îîA Q
,
îîQ R
(
îîS T
int
îîT W
)
îîW X
StencilUsage
îîX d
.
îîd e
MaterialMask
îîe q
)
îîq r
;
îîr s'
m_StencilDeferredMaterial
ïï )
.
ïï) *
SetInt
ïï* 0
(
ïï0 1
ShaderConstants
ïï1 @
.
ïï@ A
_StencilWriteMask
ïïA R
,
ïïR S
(
ïïT U
int
ïïU X
)
ïïX Y
StencilUsage
ïïY e
.
ïïe f
StencilLight
ïïf r
)
ïïr s
;
ïïs t'
m_StencilDeferredMaterial
ññ )
.
ññ) *
SetInt
ññ* 0
(
ññ0 1
ShaderConstants
ññ1 @
.
ññ@ A$
_LitPunctualStencilRef
ññA W
,
ññW X
(
ññY Z
int
ññZ ]
)
ññ] ^
StencilUsage
ññ^ j
.
ññj k
StencilLight
ññk w
|
ññx y
(
ññz {
int
ññ{ ~
)
ññ~ 
StencilUsageññ ã
.ññã å
MaterialLitññå ó
)ññó ò
;ññò ô'
m_StencilDeferredMaterial
óó )
.
óó) *
SetInt
óó* 0
(
óó0 1
ShaderConstants
óó1 @
.
óó@ A)
_LitPunctualStencilReadMask
óóA \
,
óó\ ]
(
óó^ _
int
óó_ b
)
óób c
StencilUsage
óóc o
.
óóo p
StencilLight
óóp |
|
óó} ~
(óó Ä
intóóÄ É
)óóÉ Ñ
StencilUsageóóÑ ê
.óóê ë
MaterialMaskóóë ù
)óóù û
;óóû ü'
m_StencilDeferredMaterial
òò )
.
òò) *
SetInt
òò* 0
(
òò0 1
ShaderConstants
òò1 @
.
òò@ A*
_LitPunctualStencilWriteMask
òòA ]
,
òò] ^
(
òò_ `
int
òò` c
)
òòc d
StencilUsage
òòd p
.
òòp q
StencilLight
òòq }
)
òò} ~
;
òò~ '
m_StencilDeferredMaterial
ôô )
.
ôô) *
SetInt
ôô* 0
(
ôô0 1
ShaderConstants
ôô1 @
.
ôô@ A*
_SimpleLitPunctualStencilRef
ôôA ]
,
ôô] ^
(
ôô_ `
int
ôô` c
)
ôôc d
StencilUsage
ôôd p
.
ôôp q
StencilLight
ôôq }
|
ôô~ 
(ôôÄ Å
intôôÅ Ñ
)ôôÑ Ö
StencilUsageôôÖ ë
.ôôë í!
MaterialSimpleLitôôí £
)ôô£ §
;ôô§ •'
m_StencilDeferredMaterial
öö )
.
öö) *
SetInt
öö* 0
(
öö0 1
ShaderConstants
öö1 @
.
öö@ A/
!_SimpleLitPunctualStencilReadMask
ööA b
,
ööb c
(
ööd e
int
ööe h
)
ööh i
StencilUsage
ööi u
.
ööu v
StencilLightööv Ç
|ööÉ Ñ
(ööÖ Ü
intööÜ â
)ööâ ä
StencilUsageööä ñ
.ööñ ó
MaterialMaskööó £
)öö£ §
;öö§ •'
m_StencilDeferredMaterial
õõ )
.
õõ) *
SetInt
õõ* 0
(
õõ0 1
ShaderConstants
õõ1 @
.
õõ@ A0
"_SimpleLitPunctualStencilWriteMask
õõA c
,
õõc d
(
õõe f
int
õõf i
)
õõi j
StencilUsage
õõj v
.
õõv w
StencilLightõõw É
)õõÉ Ñ
;õõÑ Ö'
m_StencilDeferredMaterial
úú )
.
úú) *
SetInt
úú* 0
(
úú0 1
ShaderConstants
úú1 @
.
úú@ A
_LitDirStencilRef
úúA R
,
úúR S
(
úúT U
int
úúU X
)
úúX Y
StencilUsage
úúY e
.
úúe f
MaterialLit
úúf q
)
úúq r
;
úúr s'
m_StencilDeferredMaterial
ùù )
.
ùù) *
SetInt
ùù* 0
(
ùù0 1
ShaderConstants
ùù1 @
.
ùù@ A$
_LitDirStencilReadMask
ùùA W
,
ùùW X
(
ùùY Z
int
ùùZ ]
)
ùù] ^
StencilUsage
ùù^ j
.
ùùj k
MaterialMask
ùùk w
)
ùùw x
;
ùùx y'
m_StencilDeferredMaterial
ûû )
.
ûû) *
SetInt
ûû* 0
(
ûû0 1
ShaderConstants
ûû1 @
.
ûû@ A%
_LitDirStencilWriteMask
ûûA X
,
ûûX Y
$num
ûûZ [
)
ûû[ \
;
ûû\ ]'
m_StencilDeferredMaterial
üü )
.
üü) *
SetInt
üü* 0
(
üü0 1
ShaderConstants
üü1 @
.
üü@ A%
_SimpleLitDirStencilRef
üüA X
,
üüX Y
(
üüZ [
int
üü[ ^
)
üü^ _
StencilUsage
üü_ k
.
üük l
MaterialSimpleLit
üül }
)
üü} ~
;
üü~ '
m_StencilDeferredMaterial
†† )
.
††) *
SetInt
††* 0
(
††0 1
ShaderConstants
††1 @
.
††@ A*
_SimpleLitDirStencilReadMask
††A ]
,
††] ^
(
††_ `
int
††` c
)
††c d
StencilUsage
††d p
.
††p q
MaterialMask
††q }
)
††} ~
;
††~ '
m_StencilDeferredMaterial
°° )
.
°°) *
SetInt
°°* 0
(
°°0 1
ShaderConstants
°°1 @
.
°°@ A+
_SimpleLitDirStencilWriteMask
°°A ^
,
°°^ _
$num
°°` a
)
°°a b
;
°°b c'
m_StencilDeferredMaterial
¢¢ )
.
¢¢) *
SetInt
¢¢* 0
(
¢¢0 1
ShaderConstants
¢¢1 @
.
¢¢@ A
_ClearStencilRef
¢¢A Q
,
¢¢Q R
$num
¢¢S T
)
¢¢T U
;
¢¢U V'
m_StencilDeferredMaterial
££ )
.
££) *
SetInt
££* 0
(
££0 1
ShaderConstants
££1 @
.
££@ A#
_ClearStencilReadMask
££A V
,
££V W
(
££X Y
int
££Y \
)
££\ ]
StencilUsage
££] i
.
££i j
MaterialMask
££j v
)
££v w
;
££w x'
m_StencilDeferredMaterial
§§ )
.
§§) *
SetInt
§§* 0
(
§§0 1
ShaderConstants
§§1 @
.
§§@ A$
_ClearStencilWriteMask
§§A W
,
§§W X
(
§§Y Z
int
§§Z ]
)
§§] ^
StencilUsage
§§^ j
.
§§j k
MaterialMask
§§k w
)
§§w x
;
§§x y
}
•• %
m_MaxDepthRangePerBatch
®® #
=
®®$ %
(
®®& '
DeferredConfig
®®' 5
.
®®5 6%
UseCBufferForDepthRange
®®6 M
?
®®N O
DeferredConfig
®®P ^
.
®®^ _#
kPreferredCBufferSize
®®_ t
:
®®u v
DeferredConfig®®w Ö
.®®Ö Ü.
kPreferredStructuredBufferSize®®Ü §
)®®§ •
/®®¶ ß
sizeof®®® Æ
(®®Æ Ø
uint®®Ø ≥
)®®≥ ¥
;®®¥ µ 
m_MaxTilesPerBatch
©© 
=
©©  
(
©©! "
DeferredConfig
©©" 0
.
©©0 1#
UseCBufferForTileList
©©1 F
?
©©G H
DeferredConfig
©©I W
.
©©W X#
kPreferredCBufferSize
©©X m
:
©©n o
DeferredConfig
©©p ~
.
©©~ -
kPreferredStructuredBufferSize©© ù
)©©ù û
/©©ü †
System©©° ß
.©©ß ®
Runtime©©® Ø
.©©Ø ∞
InteropServices©©∞ ø
.©©ø ¿
Marshal©©¿ «
.©©« »
SizeOf©©» Œ
(©©Œ œ
typeof©©œ ’
(©©’ ÷
TileData©©÷ ﬁ
)©©ﬁ ﬂ
)©©ﬂ ‡
;©©‡ ·(
m_MaxPunctualLightPerBatch
™™ &
=
™™' (
(
™™) *
DeferredConfig
™™* 8
.
™™8 9$
UseCBufferForLightData
™™9 O
?
™™P Q
DeferredConfig
™™R `
.
™™` a#
kPreferredCBufferSize
™™a v
:
™™w x
DeferredConfig™™y á
.™™á à.
kPreferredStructuredBufferSize™™à ¶
)™™¶ ß
/™™® ©
System™™™ ∞
.™™∞ ±
Runtime™™± ∏
.™™∏ π
InteropServices™™π »
.™™» …
Marshal™™… –
.™™– —
SizeOf™™— ◊
(™™◊ ÿ
typeof™™ÿ ﬁ
(™™ﬁ ﬂ!
PunctualLightData™™ﬂ 
)™™ Ò
)™™Ò Ú
;™™Ú Û*
m_MaxRelLightIndicesPerBatch
´´ (
=
´´) *
(
´´+ ,
DeferredConfig
´´, :
.
´´: ;$
UseCBufferForLightList
´´; Q
?
´´R S
DeferredConfig
´´T b
.
´´b c#
kPreferredCBufferSize
´´c x
:
´´y z
DeferredConfig´´{ â
.´´â ä.
kPreferredStructuredBufferSize´´ä ®
)´´® ©
/´´™ ´
sizeof´´¨ ≤
(´´≤ ≥
uint´´≥ ∑
)´´∑ ∏
;´´∏ π
m_Tilers
≠≠ 
=
≠≠ 
new
≠≠ 
DeferredTiler
≠≠ (
[
≠≠( )
DeferredConfig
≠≠) 7
.
≠≠7 8
kTilerDepth
≠≠8 C
]
≠≠C D
;
≠≠D E"
m_TileDataCapacities
ÆÆ  
=
ÆÆ! "
new
ÆÆ# &
int
ÆÆ' *
[
ÆÆ* +
DeferredConfig
ÆÆ+ 9
.
ÆÆ9 :
kTilerDepth
ÆÆ: E
]
ÆÆE F
;
ÆÆF G
for
≤≤ 
(
≤≤ 
int
≤≤ 

tilerLevel
≤≤ 
=
≤≤  !
$num
≤≤" #
;
≤≤# $

tilerLevel
≤≤% /
<
≤≤0 1
DeferredConfig
≤≤2 @
.
≤≤@ A
kTilerDepth
≤≤A L
;
≤≤L M
++
≤≤N P

tilerLevel
≤≤P Z
)
≤≤Z [
{
≥≥ 
int
¥¥ 
scale
¥¥ 
=
¥¥ 
(
¥¥ 
int
¥¥  
)
¥¥  !
Mathf
¥¥! &
.
¥¥& '
Pow
¥¥' *
(
¥¥* +
DeferredConfig
¥¥+ 9
.
¥¥9 : 
kTilerSubdivisions
¥¥: L
,
¥¥L M

tilerLevel
¥¥N X
)
¥¥X Y
;
¥¥Y Z
m_Tilers
µµ 
[
µµ 

tilerLevel
µµ #
]
µµ# $
=
µµ% &
new
µµ' *
DeferredTiler
µµ+ 8
(
µµ8 9
DeferredConfig
∂∂ "
.
∂∂" #
kTilePixelWidth
∂∂# 2
*
∂∂3 4
scale
∂∂5 :
,
∂∂: ;
DeferredConfig
∑∑ "
.
∑∑" #
kTilePixelHeight
∑∑# 3
*
∑∑4 5
scale
∑∑6 ;
,
∑∑; <
DeferredConfig
∏∏ "
.
∏∏" #
kAvgLightPerTile
∏∏# 3
*
∏∏4 5
scale
∏∏6 ;
*
∏∏< =
scale
∏∏> C
,
∏∏C D

tilerLevel
ππ 
)
∫∫ 
;
∫∫ "
m_TileDataCapacities
ºº $
[
ºº$ %

tilerLevel
ºº% /
]
ºº/ 0
=
ºº1 2
$num
ºº3 4
;
ºº4 5
}
ΩΩ 
this
øø 
.
øø $
AccurateGbufferNormals
øø '
=
øø( )
true
øø* .
;
øø. /
this
¿¿ 
.
¿¿ "
TiledDeferredShading
¿¿ %
=
¿¿& '
true
¿¿( ,
;
¿¿, -
this
¡¡ 
.
¡¡ 
UseJobSystem
¡¡ 
=
¡¡ 
true
¡¡  $
;
¡¡$ % 
m_HasTileVisLights
¬¬ 
=
¬¬  
false
¬¬! &
;
¬¬& '
}
√√ 	
internal
≈≈ 
ref
≈≈ 
DeferredTiler
≈≈ "
GetTiler
≈≈# +
(
≈≈+ ,
int
≈≈, /
i
≈≈0 1
)
≈≈1 2
{
∆∆ 	
return
«« 
ref
«« 
m_Tilers
«« 
[
««  
i
««  !
]
««! "
;
««" #
}
»» 	
internal
   
void
   
SetupLights
   !
(
  ! "%
ScriptableRenderContext
  " 9
context
  : A
,
  A B
ref
  C F
RenderingData
  G T
renderingData
  U b
)
  b c
{
ÀÀ 	
Profiler
ÃÃ 
.
ÃÃ 
BeginSample
ÃÃ  
(
ÃÃ  !
k_SetupLights
ÃÃ! .
)
ÃÃ. /
;
ÃÃ/ 0 
DeferredShaderData
ŒŒ 
.
ŒŒ 
instance
ŒŒ '
.
ŒŒ' (
ResetBuffers
ŒŒ( 4
(
ŒŒ4 5
)
ŒŒ5 6
;
ŒŒ6 7
this
–– 
.
–– 
RenderWidth
–– 
=
–– 
renderingData
–– ,
.
––, -

cameraData
––- 7
.
––7 8$
cameraTargetDescriptor
––8 N
.
––N O
width
––O T
;
––T U
this
—— 
.
—— 
RenderHeight
—— 
=
—— 
renderingData
——  -
.
——- .

cameraData
——. 8
.
——8 9$
cameraTargetDescriptor
——9 O
.
——O P
height
——P V
;
——V W
if
”” 
(
”” 
this
”” 
.
”” "
TiledDeferredShading
”” )
)
””) *
{
‘‘ 
if
÷÷ 
(
÷÷ !
m_CachedRenderWidth
÷÷ '
!=
÷÷( *
renderingData
÷÷+ 8
.
÷÷8 9

cameraData
÷÷9 C
.
÷÷C D$
cameraTargetDescriptor
÷÷D Z
.
÷÷Z [
width
÷÷[ `
||
◊◊ "
m_CachedRenderHeight
◊◊ +
!=
◊◊, .
renderingData
◊◊/ <
.
◊◊< =

cameraData
◊◊= G
.
◊◊G H$
cameraTargetDescriptor
◊◊H ^
.
◊◊^ _
height
◊◊_ e
||
ÿÿ &
m_CachedProjectionMatrix
ÿÿ /
!=
ÿÿ0 2
renderingData
ÿÿ3 @
.
ÿÿ@ A

cameraData
ÿÿA K
.
ÿÿK L
camera
ÿÿL R
.
ÿÿR S
projectionMatrix
ÿÿS c
)
ÿÿc d
{
ŸŸ !
m_CachedRenderWidth
⁄⁄ '
=
⁄⁄( )
renderingData
⁄⁄* 7
.
⁄⁄7 8

cameraData
⁄⁄8 B
.
⁄⁄B C$
cameraTargetDescriptor
⁄⁄C Y
.
⁄⁄Y Z
width
⁄⁄Z _
;
⁄⁄_ `"
m_CachedRenderHeight
€€ (
=
€€) *
renderingData
€€+ 8
.
€€8 9

cameraData
€€9 C
.
€€C D$
cameraTargetDescriptor
€€D Z
.
€€Z [
height
€€[ a
;
€€a b&
m_CachedProjectionMatrix
‹‹ ,
=
‹‹- .
renderingData
‹‹/ <
.
‹‹< =

cameraData
‹‹= G
.
‹‹G H
camera
‹‹H N
.
‹‹N O
projectionMatrix
‹‹O _
;
‹‹_ `
for
ﬁﬁ 
(
ﬁﬁ 
int
ﬁﬁ 

tilerIndex
ﬁﬁ '
=
ﬁﬁ( )
$num
ﬁﬁ* +
;
ﬁﬁ+ ,

tilerIndex
ﬁﬁ- 7
<
ﬁﬁ8 9
m_Tilers
ﬁﬁ: B
.
ﬁﬁB C
Length
ﬁﬁC I
;
ﬁﬁI J
++
ﬁﬁK M

tilerIndex
ﬁﬁM W
)
ﬁﬁW X
{
ﬂﬂ 
m_Tilers
‡‡  
[
‡‡  !

tilerIndex
‡‡! +
]
‡‡+ ,
.
‡‡, -
PrecomputeTiles
‡‡- <
(
‡‡< =
renderingData
‡‡= J
.
‡‡J K

cameraData
‡‡K U
.
‡‡U V
camera
‡‡V \
.
‡‡\ ]
projectionMatrix
‡‡] m
,
‡‡m n
renderingData
·· )
.
··) *

cameraData
··* 4
.
··4 5
camera
··5 ;
.
··; <
orthographic
··< H
,
··H I!
m_CachedRenderWidth
··J ]
,
··] ^"
m_CachedRenderHeight
··_ s
)
··s t
;
··t u
}
‚‚ 
}
„„ 
for
ÊÊ 
(
ÊÊ 
int
ÊÊ 

tilerIndex
ÊÊ #
=
ÊÊ$ %
$num
ÊÊ& '
;
ÊÊ' (

tilerIndex
ÊÊ) 3
<
ÊÊ4 5
m_Tilers
ÊÊ6 >
.
ÊÊ> ?
Length
ÊÊ? E
;
ÊÊE F
++
ÊÊG I

tilerIndex
ÊÊI S
)
ÊÊS T
m_Tilers
ÁÁ 
[
ÁÁ 

tilerIndex
ÁÁ '
]
ÁÁ' (
.
ÁÁ( )
Setup
ÁÁ) .
(
ÁÁ. /"
m_TileDataCapacities
ÁÁ/ C
[
ÁÁC D

tilerIndex
ÁÁD N
]
ÁÁN O
)
ÁÁO P
;
ÁÁP Q
}
ËË 
NativeArray
ÎÎ 
<
ÎÎ 
DeferredTiler
ÎÎ %
.
ÎÎ% &
PrePunctualLight
ÎÎ& 6
>
ÎÎ6 7
prePunctualLights
ÎÎ8 I
;
ÎÎI J
PrecomputeLights
ÔÔ 
(
ÔÔ 
out
 
prePunctualLights
 %
,
% &
out
ÒÒ  
m_stencilVisLights
ÒÒ &
,
ÒÒ& '
out
ÚÚ &
m_stencilVisLightOffsets
ÚÚ ,
,
ÚÚ, -
ref
ÛÛ 
renderingData
ÛÛ !
.
ÛÛ! "
	lightData
ÛÛ" +
.
ÛÛ+ ,
visibleLights
ÛÛ, 9
,
ÛÛ9 :
renderingData
ÙÙ 
.
ÙÙ 
	lightData
ÙÙ '
.
ÙÙ' (#
additionalLightsCount
ÙÙ( =
!=
ÙÙ> @
$num
ÙÙA B
||
ÙÙC E
renderingData
ÙÙF S
.
ÙÙS T
	lightData
ÙÙT ]
.
ÙÙ] ^
mainLightIndex
ÙÙ^ l
>=
ÙÙm o
$num
ÙÙp q
,
ÙÙq r
renderingData
ıı 
.
ıı 

cameraData
ıı (
.
ıı( )
camera
ıı) /
.
ıı/ 0!
worldToCameraMatrix
ıı0 C
,
ııC D
renderingData
ˆˆ 
.
ˆˆ 

cameraData
ˆˆ (
.
ˆˆ( )
camera
ˆˆ) /
.
ˆˆ/ 0
orthographic
ˆˆ0 <
,
ˆˆ< =
renderingData
˜˜ 
.
˜˜ 

cameraData
˜˜ (
.
˜˜( )
camera
˜˜) /
.
˜˜/ 0
nearClipPlane
˜˜0 =
)
¯¯ 
;
¯¯ 
{
˙˙ 
CommandBuffer
˚˚ 
cmd
˚˚ !
=
˚˚" #
CommandBufferPool
˚˚$ 5
.
˚˚5 6
Get
˚˚6 9
(
˚˚9 :
)
˚˚: ;
;
˚˚; <
using
¸¸ 
(
¸¸ 
new
¸¸ 
ProfilingScope
¸¸ )
(
¸¸) *
cmd
¸¸* -
,
¸¸- .,
m_ProfilingSetupLightConstants
¸¸/ M
)
¸¸M N
)
¸¸N O
{
˝˝ '
SetupShaderLightConstants
ˇˇ -
(
ˇˇ- .
cmd
ˇˇ. 1
,
ˇˇ1 2
ref
ˇˇ3 6
renderingData
ˇˇ7 D
)
ˇˇD E
;
ˇˇE F
	CoreUtils
ÇÇ 
.
ÇÇ 

SetKeyword
ÇÇ (
(
ÇÇ( )
cmd
ÇÇ) ,
,
ÇÇ, -"
ShaderKeywordStrings
ÇÇ. B
.
ÇÇB C"
_GBUFFER_NORMALS_OCT
ÇÇC W
,
ÇÇW X
this
ÇÇY ]
.
ÇÇ] ^$
AccurateGbufferNormals
ÇÇ^ t
)
ÇÇt u
;
ÇÇu v
	CoreUtils
ÉÉ 
.
ÉÉ 

SetKeyword
ÉÉ (
(
ÉÉ( )
cmd
ÉÉ) ,
,
ÉÉ, -"
ShaderKeywordStrings
ÉÉ. B
.
ÉÉB C&
MixedLightingSubtractive
ÉÉC [
,
ÉÉ[ \
renderingData
ÉÉ] j
.
ÉÉj k
	lightData
ÉÉk t
.
ÉÉt u$
supportsMixedLightingÉÉu ä
&&ÉÉã ç
thisÉÉé í
.ÉÉí ì"
MixedLightingSetupÉÉì •
==ÉÉ¶ ®"
MixedLightingSetupÉÉ© ª
.ÉÉª º
SubtractiveÉÉº «
)ÉÉ« »
;ÉÉ» …
}
ÑÑ 
context
ÜÜ 
.
ÜÜ "
ExecuteCommandBuffer
ÜÜ ,
(
ÜÜ, -
cmd
ÜÜ- 0
)
ÜÜ0 1
;
ÜÜ1 2
CommandBufferPool
áá !
.
áá! "
Release
áá" )
(
áá) *
cmd
áá* -
)
áá- .
;
áá. /
}
àà 
if
ää 
(
ää 
this
ää 
.
ää "
TiledDeferredShading
ää )
)
ää) *
{
ãã 

SortLights
éé 
(
éé 
ref
éé 
prePunctualLights
éé 0
)
éé0 1
;
éé1 2
NativeArray
êê 
<
êê 
ushort
êê "
>
êê" #
defaultIndices
êê$ 2
=
êê3 4
new
êê5 8
NativeArray
êê9 D
<
êêD E
ushort
êêE K
>
êêK L
(
êêL M
prePunctualLights
êêM ^
.
êê^ _
Length
êê_ e
,
êêe f
	Allocator
êêg p
.
êêp q
Temp
êêq u
,
êêu v!
NativeArrayOptionsêêw â
.êêâ ä#
UninitializedMemoryêêä ù
)êêù û
;êêû ü
for
ëë 
(
ëë 
int
ëë 
i
ëë 
=
ëë 
$num
ëë 
;
ëë 
i
ëë  !
<
ëë" #
prePunctualLights
ëë$ 5
.
ëë5 6
Length
ëë6 <
;
ëë< =
++
ëë> @
i
ëë@ A
)
ëëA B
defaultIndices
íí "
[
íí" #
i
íí# $
]
íí$ %
=
íí& '
(
íí( )
ushort
íí) /
)
íí/ 0
i
íí0 1
;
íí1 2
NativeArray
îî 
<
îî 
uint
îî  
>
îî  !
defaultHeaders
îî" 0
=
îî1 2
new
îî3 6
NativeArray
îî7 B
<
îîB C
uint
îîC G
>
îîG H
(
îîH I
$num
îîI J
,
îîJ K
	Allocator
îîL U
.
îîU V
Temp
îîV Z
,
îîZ [ 
NativeArrayOptions
îî\ n
.
îîn o"
UninitializedMemoryîîo Ç
)îîÇ É
;îîÉ Ñ
defaultHeaders
ïï 
[
ïï 
$num
ïï  
]
ïï  !
=
ïï" #
$num
ïï$ %
;
ïï% &
defaultHeaders
ññ 
[
ññ 
$num
ññ  
]
ññ  !
=
ññ" #
(
ññ$ %
uint
ññ% )
)
ññ) *
prePunctualLights
ññ* ;
.
ññ; <
Length
ññ< B
;
ññB C
ref
ôô 
DeferredTiler
ôô !
coarsestTiler
ôô" /
=
ôô0 1
ref
ôô2 5
m_Tilers
ôô6 >
[
ôô> ?
m_Tilers
ôô? G
.
ôôG H
Length
ôôH N
-
ôôO P
$num
ôôQ R
]
ôôR S
;
ôôS T
if
öö 
(
öö 
m_Tilers
öö 
.
öö 
Length
öö #
!=
öö$ &
$num
öö' (
)
öö( )
{
õõ 
NativeArray
úú 
<
úú  
	JobHandle
úú  )
>
úú) *

jobHandles
úú+ 5
=
úú6 7
new
úú8 ;
NativeArray
úú< G
<
úúG H
	JobHandle
úúH Q
>
úúQ R
(
úúR S
)
úúS T
;
úúT U
int
ùù 
	jobOffset
ùù !
=
ùù" #
$num
ùù$ %
;
ùù% &
int
ûû 
jobCount
ûû  
=
ûû! "
$num
ûû# $
;
ûû$ %
if
†† 
(
†† 
this
†† 
.
†† 
UseJobSystem
†† )
)
††) *
{
°° 
int
¢¢ 
totalJobCount
¢¢ )
=
¢¢* +
$num
¢¢, -
;
¢¢- .
for
££ 
(
££ 
int
££  
t
££! "
=
££# $
m_Tilers
££% -
.
££- .
Length
££. 4
-
££5 6
$num
££7 8
;
££8 9
t
££: ;
>
££< =
$num
££> ?
;
££? @
--
££A C
t
££C D
)
££D E
{
§§ 
ref
•• 
DeferredTiler
••  -
coarseTiler
••. 9
=
••: ;
ref
••< ?
m_Tilers
••@ H
[
••H I
t
••I J
]
••J K
;
••K L
totalJobCount
¶¶ )
+=
¶¶* ,
coarseTiler
¶¶- 8
.
¶¶8 9

TileXCount
¶¶9 C
*
¶¶D E
coarseTiler
¶¶F Q
.
¶¶Q R

TileYCount
¶¶R \
;
¶¶\ ]
}
ßß 

jobHandles
®® "
=
®®# $
new
®®% (
NativeArray
®®) 4
<
®®4 5
	JobHandle
®®5 >
>
®®> ?
(
®®? @
totalJobCount
®®@ M
,
®®M N
	Allocator
®®O X
.
®®X Y
Temp
®®Y ]
,
®®] ^ 
NativeArrayOptions
®®_ q
.
®®q r"
UninitializedMemory®®r Ö
)®®Ö Ü
;®®Ü á
}
©© 
CullLightsJob
¨¨ !
coarsestJob
¨¨" -
=
¨¨. /
new
¨¨0 3
CullLightsJob
¨¨4 A
{
≠≠ 
tiler
ÆÆ 
=
ÆÆ 
coarsestTiler
ÆÆ  -
,
ÆÆ- .
prePunctualLights
ØØ )
=
ØØ* +
prePunctualLights
ØØ, =
,
ØØ= >
coarseTiles
∞∞ #
=
∞∞$ %
defaultIndices
∞∞& 4
,
∞∞4 5
coarseTileHeaders
±± )
=
±±* +
defaultHeaders
±±, :
,
±±: ; 
coarseHeaderOffset
≤≤ *
=
≤≤+ ,
$num
≤≤- .
,
≤≤. /
istart
≥≥ 
=
≥≥  
$num
≥≥! "
,
≥≥" #
iend
¥¥ 
=
¥¥ 
coarsestTiler
¥¥ ,
.
¥¥, -

TileXCount
¥¥- 7
,
¥¥7 8
jstart
µµ 
=
µµ  
$num
µµ! "
,
µµ" #
jend
∂∂ 
=
∂∂ 
coarsestTiler
∂∂ ,
.
∂∂, -

TileYCount
∂∂- 7
,
∂∂7 8
}
∑∑ 
;
∑∑ 
if
∏∏ 
(
∏∏ 
this
∏∏ 
.
∏∏ 
UseJobSystem
∏∏ )
)
∏∏) *
{
ππ 

jobHandles
∫∫ "
[
∫∫" #
jobCount
∫∫# +
++
∫∫+ -
]
∫∫- .
=
∫∫/ 0
coarsestJob
∫∫1 <
.
∫∫< =
Schedule
∫∫= E
(
∫∫E F
)
∫∫F G
;
∫∫G H
	JobHandle
ºº !
.
ºº! "!
ScheduleBatchedJobs
ºº" 5
(
ºº5 6
)
ºº6 7
;
ºº7 8
}
ΩΩ 
else
ææ 
coarsestJob
øø #
.
øø# $
Execute
øø$ +
(
øø+ ,
)
øø, -
;
øø- .
for
¬¬ 
(
¬¬ 
int
¬¬ 
t
¬¬ 
=
¬¬  
m_Tilers
¬¬! )
.
¬¬) *
Length
¬¬* 0
-
¬¬1 2
$num
¬¬3 4
;
¬¬4 5
t
¬¬6 7
>
¬¬8 9
$num
¬¬: ;
;
¬¬; <
--
¬¬= ?
t
¬¬? @
)
¬¬@ A
{
√√ 
ref
ƒƒ 
DeferredTiler
ƒƒ )
	fineTiler
ƒƒ* 3
=
ƒƒ4 5
ref
ƒƒ6 9
m_Tilers
ƒƒ: B
[
ƒƒB C
t
ƒƒC D
-
ƒƒE F
$num
ƒƒG H
]
ƒƒH I
;
ƒƒI J
ref
≈≈ 
DeferredTiler
≈≈ )
coarseTiler
≈≈* 5
=
≈≈6 7
ref
≈≈8 ;
m_Tilers
≈≈< D
[
≈≈D E
t
≈≈E F
]
≈≈F G
;
≈≈G H
int
∆∆ 
fineTileXCount
∆∆ *
=
∆∆+ ,
	fineTiler
∆∆- 6
.
∆∆6 7

TileXCount
∆∆7 A
;
∆∆A B
int
«« 
fineTileYCount
«« *
=
««+ ,
	fineTiler
««- 6
.
««6 7

TileYCount
««7 A
;
««A B
int
»» 
coarseTileXCount
»» ,
=
»»- .
coarseTiler
»»/ :
.
»»: ;

TileXCount
»»; E
;
»»E F
int
…… 
coarseTileYCount
…… ,
=
……- .
coarseTiler
……/ :
.
……: ;

TileYCount
……; E
;
……E F
int
   
subdivX
   #
=
  $ %
(
  & '
t
  ' (
==
  ) +
m_Tilers
  , 4
.
  4 5
Length
  5 ;
-
  < =
$num
  > ?
)
  ? @
?
  A B
coarseTileXCount
  C S
:
  T U
DeferredConfig
  V d
.
  d e 
kTilerSubdivisions
  e w
;
  w x
int
ÀÀ 
subdivY
ÀÀ #
=
ÀÀ$ %
(
ÀÀ& '
t
ÀÀ' (
==
ÀÀ) +
m_Tilers
ÀÀ, 4
.
ÀÀ4 5
Length
ÀÀ5 ;
-
ÀÀ< =
$num
ÀÀ> ?
)
ÀÀ? @
?
ÀÀA B
coarseTileYCount
ÀÀC S
:
ÀÀT U
DeferredConfig
ÀÀV d
.
ÀÀd e 
kTilerSubdivisions
ÀÀe w
;
ÀÀw x
int
ÃÃ #
superCoarseTileXCount
ÃÃ 1
=
ÃÃ2 3
(
ÃÃ4 5
coarseTileXCount
ÃÃ5 E
+
ÃÃF G
subdivX
ÃÃH O
-
ÃÃP Q
$num
ÃÃR S
)
ÃÃS T
/
ÃÃU V
subdivX
ÃÃW ^
;
ÃÃ^ _
int
ÕÕ #
superCoarseTileYCount
ÕÕ 1
=
ÕÕ2 3
(
ÕÕ4 5
coarseTileYCount
ÕÕ5 E
+
ÕÕF G
subdivY
ÕÕH O
-
ÕÕP Q
$num
ÕÕR S
)
ÕÕS T
/
ÕÕU V
subdivY
ÕÕW ^
;
ÕÕ^ _
NativeArray
ŒŒ #
<
ŒŒ# $
ushort
ŒŒ$ *
>
ŒŒ* +
coarseTiles
ŒŒ, 7
=
ŒŒ8 9
coarseTiler
ŒŒ: E
.
ŒŒE F
Tiles
ŒŒF K
;
ŒŒK L
NativeArray
œœ #
<
œœ# $
uint
œœ$ (
>
œœ( )
coarseTileHeaders
œœ* ;
=
œœ< =
coarseTiler
œœ> I
.
œœI J
TileHeaders
œœJ U
;
œœU V
int
–– 
	fineStepX
–– %
=
––& '
coarseTiler
––( 3
.
––3 4
TilePixelWidth
––4 B
/
––C D
	fineTiler
––E N
.
––N O
TilePixelWidth
––O ]
;
––] ^
int
—— 
	fineStepY
—— %
=
——& '
coarseTiler
——( 3
.
——3 4
TilePixelHeight
——4 C
/
——D E
	fineTiler
——F O
.
——O P
TilePixelHeight
——P _
;
——_ `
for
”” 
(
”” 
int
””  
j
””! "
=
””# $
$num
””% &
;
””& '
j
””( )
<
””* +
coarseTileYCount
””, <
;
””< =
++
””> @
j
””@ A
)
””A B
for
‘‘ 
(
‘‘ 
int
‘‘  
i
‘‘! "
=
‘‘# $
$num
‘‘% &
;
‘‘& '
i
‘‘( )
<
‘‘* +
coarseTileXCount
‘‘, <
;
‘‘< =
++
‘‘> @
i
‘‘@ A
)
‘‘A B
{
’’ 
int
÷÷ 
fine_istart
÷÷  +
=
÷÷, -
i
÷÷. /
*
÷÷0 1
	fineStepX
÷÷2 ;
;
÷÷; <
int
◊◊ 
fine_jstart
◊◊  +
=
◊◊, -
j
◊◊. /
*
◊◊0 1
	fineStepY
◊◊2 ;
;
◊◊; <
int
ÿÿ 
	fine_iend
ÿÿ  )
=
ÿÿ* +
Mathf
ÿÿ, 1
.
ÿÿ1 2
Min
ÿÿ2 5
(
ÿÿ5 6
fine_istart
ÿÿ6 A
+
ÿÿB C
	fineStepX
ÿÿD M
,
ÿÿM N
fineTileXCount
ÿÿO ]
)
ÿÿ] ^
;
ÿÿ^ _
int
ŸŸ 
	fine_jend
ŸŸ  )
=
ŸŸ* +
Mathf
ŸŸ, 1
.
ŸŸ1 2
Min
ŸŸ2 5
(
ŸŸ5 6
fine_jstart
ŸŸ6 A
+
ŸŸB C
	fineStepY
ŸŸD M
,
ŸŸM N
fineTileYCount
ŸŸO ]
)
ŸŸ] ^
;
ŸŸ^ _
int
⁄⁄  
coarseHeaderOffset
⁄⁄  2
=
⁄⁄3 4
coarseTiler
⁄⁄5 @
.
⁄⁄@ A!
GetTileHeaderOffset
⁄⁄A T
(
⁄⁄T U
i
⁄⁄U V
,
⁄⁄V W
j
⁄⁄X Y
)
⁄⁄Y Z
;
⁄⁄Z [
CullLightsJob
‹‹ )
job
‹‹* -
=
‹‹. /
new
‹‹0 3
CullLightsJob
‹‹4 A
{
›› 
tiler
ﬁﬁ  %
=
ﬁﬁ& '
m_Tilers
ﬁﬁ( 0
[
ﬁﬁ0 1
t
ﬁﬁ1 2
-
ﬁﬁ2 3
$num
ﬁﬁ3 4
]
ﬁﬁ4 5
,
ﬁﬁ5 6
prePunctualLights
ﬂﬂ  1
=
ﬂﬂ2 3
prePunctualLights
ﬂﬂ4 E
,
ﬂﬂE F
coarseTiles
‡‡  +
=
‡‡, -
coarseTiles
‡‡. 9
,
‡‡9 :
coarseTileHeaders
··  1
=
··2 3
coarseTileHeaders
··4 E
,
··E F 
coarseHeaderOffset
‚‚  2
=
‚‚3 4 
coarseHeaderOffset
‚‚5 G
,
‚‚G H
istart
„„  &
=
„„' (
fine_istart
„„) 4
,
„„4 5
iend
‰‰  $
=
‰‰% &
	fine_iend
‰‰' 0
,
‰‰0 1
jstart
ÂÂ  &
=
ÂÂ' (
fine_jstart
ÂÂ) 4
,
ÂÂ4 5
jend
ÊÊ  $
=
ÊÊ% &
	fine_jend
ÊÊ' 0
,
ÊÊ0 1
}
ÁÁ 
;
ÁÁ 
if
ÈÈ 
(
ÈÈ  
this
ÈÈ  $
.
ÈÈ$ %
UseJobSystem
ÈÈ% 1
)
ÈÈ1 2

jobHandles
ÍÍ  *
[
ÍÍ* +
jobCount
ÍÍ+ 3
++
ÍÍ3 5
]
ÍÍ5 6
=
ÍÍ7 8
job
ÍÍ9 <
.
ÍÍ< =
Schedule
ÍÍ= E
(
ÍÍE F

jobHandles
ÍÍF P
[
ÍÍP Q
	jobOffset
ÍÍQ Z
+
ÍÍ[ \
(
ÍÍ] ^
i
ÍÍ^ _
/
ÍÍ` a
subdivX
ÍÍb i
)
ÍÍi j
+
ÍÍk l
(
ÍÍm n
j
ÍÍn o
/
ÍÍp q
subdivY
ÍÍr y
)
ÍÍy z
*
ÍÍ{ |$
superCoarseTileXCountÍÍ} í
]ÍÍí ì
)ÍÍì î
;ÍÍî ï
else
ÎÎ  
job
ÏÏ  #
.
ÏÏ# $
Execute
ÏÏ$ +
(
ÏÏ+ ,
)
ÏÏ, -
;
ÏÏ- .
}
ÌÌ 
	jobOffset
ÔÔ !
+=
ÔÔ" $#
superCoarseTileXCount
ÔÔ% :
*
ÔÔ; <#
superCoarseTileYCount
ÔÔ= R
;
ÔÔR S
}
 
if
ÚÚ 
(
ÚÚ 
this
ÚÚ 
.
ÚÚ 
UseJobSystem
ÚÚ )
)
ÚÚ) *
{
ÛÛ 
	JobHandle
ÙÙ !
.
ÙÙ! "
CompleteAll
ÙÙ" -
(
ÙÙ- .

jobHandles
ÙÙ. 8
)
ÙÙ8 9
;
ÙÙ9 :

jobHandles
ıı "
.
ıı" #
Dispose
ıı# *
(
ıı* +
)
ıı+ ,
;
ıı, -
}
ˆˆ 
}
˜˜ 
else
¯¯ 
{
˘˘ 
coarsestTiler
˙˙ !
.
˙˙! "
CullFinalLights
˙˙" 1
(
˙˙1 2
ref
˚˚ 
prePunctualLights
˚˚ -
,
˚˚- .
ref
¸¸ 
defaultIndices
¸¸ *
,
¸¸* +
$num
¸¸, -
,
¸¸- .
prePunctualLights
¸¸/ @
.
¸¸@ A
Length
¸¸A G
,
¸¸G H
$num
˝˝ 
,
˝˝ 
coarsestTiler
˝˝ (
.
˝˝( )

TileXCount
˝˝) 3
,
˝˝3 4
$num
˝˝5 6
,
˝˝6 7
coarsestTiler
˝˝8 E
.
˝˝E F

TileYCount
˝˝F P
)
˛˛ 
;
˛˛ 
}
ˇˇ 
defaultIndices
ÅÅ 
.
ÅÅ 
Dispose
ÅÅ &
(
ÅÅ& '
)
ÅÅ' (
;
ÅÅ( )
defaultHeaders
ÇÇ 
.
ÇÇ 
Dispose
ÇÇ &
(
ÇÇ& '
)
ÇÇ' (
;
ÇÇ( )
}
ÉÉ 
if
ÜÜ 
(
ÜÜ 
prePunctualLights
ÜÜ !
.
ÜÜ! "
	IsCreated
ÜÜ" +
)
ÜÜ+ ,
prePunctualLights
áá !
.
áá! "
Dispose
áá" )
(
áá) *
)
áá* +
;
áá+ ,
Profiler
ââ 
.
ââ 
	EndSample
ââ 
(
ââ 
)
ââ  
;
ââ  !
}
ää 	
public
åå 
void
åå &
ResolveMixedLightingMode
åå ,
(
åå, -
ref
åå- 0
RenderingData
åå1 >
renderingData
åå? L
)
ååL M
{
çç 	
this
èè 
.
èè  
MixedLightingSetup
èè #
=
èè$ % 
MixedLightingSetup
èè& 8
.
èè8 9
None
èè9 =
;
èè= >
if
ëë 
(
ëë 
!
ëë 
renderingData
ëë 
.
ëë 
	lightData
ëë (
.
ëë( )#
supportsMixedLighting
ëë) >
)
ëë> ?
return
íí 
;
íí 
NativeArray
îî 
<
îî 
VisibleLight
îî $
>
îî$ %
visibleLights
îî& 3
=
îî4 5
renderingData
îî6 C
.
îîC D
	lightData
îîD M
.
îîM N
visibleLights
îîN [
;
îî[ \
for
ïï 
(
ïï 
int
ïï 

lightIndex
ïï 
=
ïï  !
$num
ïï" #
;
ïï# $

lightIndex
ïï% /
<
ïï0 1
renderingData
ïï2 ?
.
ïï? @
	lightData
ïï@ I
.
ïïI J
visibleLights
ïïJ W
.
ïïW X
Length
ïïX ^
;
ïï^ _
++
ïï` b

lightIndex
ïïb l
)
ïïl m
{
ññ 
Light
óó 
light
óó 
=
óó 
visibleLights
óó +
[
óó+ ,

lightIndex
óó, 6
]
óó6 7
.
óó7 8
light
óó8 =
;
óó= >
if
öö 
(
öö 
light
öö 
!=
öö 
null
öö !
&&
õõ 
light
õõ 
.
õõ 
bakingOutput
õõ &
.
õõ& '
mixedLightingMode
õõ' 8
==
õõ9 ;
MixedLightingMode
õõ< M
.
õõM N
Subtractive
õõN Y
&&
úú 
light
úú 
.
úú 
bakingOutput
úú &
.
úú& '
lightmapBakeType
úú' 7
==
úú8 :
LightmapBakeType
úú; K
.
úúK L
Mixed
úúL Q
&&
ùù 
light
ùù 
.
ùù 
shadows
ùù !
!=
ùù" $
LightShadows
ùù% 1
.
ùù1 2
None
ùù2 6
)
ùù6 7
{
ûû 
this
üü 
.
üü  
MixedLightingSetup
üü +
=
üü, - 
MixedLightingSetup
üü. @
.
üü@ A
Subtractive
üüA L
;
üüL M
break
†† 
;
†† 
}
°° 
}
¢¢ 
}
•• 	
public
ßß 
bool
ßß )
IsRuntimeSupportedThisFrame
ßß /
(
ßß/ 0
)
ßß0 1
{
®® 	
return
´´ 
this
´´ 
.
´´ 
GBufferSliceCount
´´ )
<=
´´* ,

SystemInfo
´´- 7
.
´´7 8(
supportedRenderTargetCount
´´8 R
&&
´´S U
!
´´V W
DeferredConfig
´´W e
.
´´e f
IsOpenGL
´´f n
;
´´n o
}
¨¨ 	
public
ÆÆ 
void
ÆÆ 
Setup
ÆÆ 
(
ÆÆ 
ref
ÆÆ 
RenderingData
ÆÆ +
renderingData
ÆÆ, 9
,
ÆÆ9 :.
 AdditionalLightsShadowCasterPass
ØØ ,.
 additionalLightsShadowCasterPass
ØØ- M
,
ØØM N
bool
∞∞ 
hasDepthPrepass
∞∞  
,
∞∞  !
bool
±± 
	isOverlay
±± 
,
±±  
RenderTargetHandle
≤≤ 
depthCopyTexture
≤≤ /
,
≤≤/ 0 
RenderTargetHandle
≥≥ 
depthInfoTexture
≥≥ /
,
≥≥/ 0 
RenderTargetHandle
¥¥ "
tileDepthInfoTexture
¥¥ 3
,
¥¥3 4 
RenderTargetHandle
µµ 
depthAttachment
µµ .
,
µµ. / 
RenderTargetHandle
∂∂ 
[
∂∂ 
]
∂∂  
gbufferHandles
∂∂! /
)
∂∂/ 0
{
∑∑ 	0
"m_AdditionalLightsShadowCasterPass
∏∏ .
=
∏∏/ 0.
 additionalLightsShadowCasterPass
∏∏1 Q
;
∏∏Q R
this
ππ 
.
ππ 
HasDepthPrepass
ππ  
=
ππ! "
hasDepthPrepass
ππ# 2
;
ππ2 3
this
∫∫ 
.
∫∫ 
	IsOverlay
∫∫ 
=
∫∫ 
	isOverlay
∫∫ &
;
∫∫& '
this
ºº 
.
ºº 
DepthCopyTexture
ºº !
=
ºº" #
depthCopyTexture
ºº$ 4
;
ºº4 5
this
ΩΩ 
.
ΩΩ 
DepthInfoTexture
ΩΩ !
=
ΩΩ" #
depthInfoTexture
ΩΩ$ 4
;
ΩΩ4 5
this
ææ 
.
ææ "
TileDepthInfoTexture
ææ %
=
ææ& '"
tileDepthInfoTexture
ææ( <
;
ææ< =
if
¡¡ 
(
¡¡ 
this
¡¡ 
.
¡¡  
GbufferAttachments
¡¡ '
==
¡¡( *
null
¡¡+ /
||
¡¡0 2
this
¡¡3 7
.
¡¡7 8 
GbufferAttachments
¡¡8 J
.
¡¡J K
Length
¡¡K Q
!=
¡¡R T
this
¡¡U Y
.
¡¡Y Z
GBufferSliceCount
¡¡Z k
)
¡¡k l
this
¬¬ 
.
¬¬  
GbufferAttachments
¬¬ '
=
¬¬( )
new
¬¬* - 
RenderTargetHandle
¬¬. @
[
¬¬@ A
this
¬¬A E
.
¬¬E F
GBufferSliceCount
¬¬F W
]
¬¬W X
;
¬¬X Y
this
√√ 
.
√√  
GbufferAttachments
√√ #
[
√√# $
this
√√$ (
.
√√( ) 
GBufferAlbedoIndex
√√) ;
]
√√; <
=
√√= >
gbufferHandles
√√? M
[
√√M N
(
√√N O
int
√√O R
)
√√R S
GBufferHandles
√√S a
.
√√a b
Albedo
√√b h
]
√√h i
;
√√i j
this
ƒƒ 
.
ƒƒ  
GbufferAttachments
ƒƒ #
[
ƒƒ# $
this
ƒƒ$ (
.
ƒƒ( )*
GBufferSpecularMetallicIndex
ƒƒ) E
]
ƒƒE F
=
ƒƒG H
gbufferHandles
ƒƒI W
[
ƒƒW X
(
ƒƒX Y
int
ƒƒY \
)
ƒƒ\ ]
GBufferHandles
ƒƒ] k
.
ƒƒk l
SpecularMetallic
ƒƒl |
]
ƒƒ| }
;
ƒƒ} ~
this
≈≈ 
.
≈≈  
GbufferAttachments
≈≈ #
[
≈≈# $
this
≈≈$ (
.
≈≈( )*
GBufferNormalSmoothnessIndex
≈≈) E
]
≈≈E F
=
≈≈G H
gbufferHandles
≈≈I W
[
≈≈W X
(
≈≈X Y
int
≈≈Y \
)
≈≈\ ]
GBufferHandles
≈≈] k
.
≈≈k l
NormalSmoothness
≈≈l |
]
≈≈| }
;
≈≈} ~
this
∆∆ 
.
∆∆  
GbufferAttachments
∆∆ #
[
∆∆# $
this
∆∆$ (
.
∆∆( )"
GBufferLightingIndex
∆∆) =
]
∆∆= >
=
∆∆? @
gbufferHandles
∆∆A O
[
∆∆O P
(
∆∆P Q
int
∆∆Q T
)
∆∆T U
GBufferHandles
∆∆U c
.
∆∆c d
Lighting
∆∆d l
]
∆∆l m
;
∆∆m n
if
«« 
(
«« 
this
«« 
.
«« 
GbufferDepthIndex
«« &
>=
««' )
$num
««* +
)
««+ ,
this
»» 
.
»»  
GbufferAttachments
»» '
[
»»' (
this
»»( ,
.
»», -
GbufferDepthIndex
»»- >
]
»»> ?
=
»»@ A
gbufferHandles
»»B P
[
»»P Q
(
»»Q R
int
»»R U
)
»»U V
GBufferHandles
»»V d
.
»»d e
DepthAsColor
»»e q
]
»»q r
;
»»r s
if
…… 
(
…… 
this
…… 
.
…… 
GBufferShadowMask
…… &
>=
……' )
$num
……* +
)
……+ ,
this
   
.
    
GbufferAttachments
   '
[
  ' (
this
  ( ,
.
  , -
GBufferShadowMask
  - >
]
  > ?
=
  @ A
gbufferHandles
  B P
[
  P Q
(
  Q R
int
  R U
)
  U V
GBufferHandles
  V d
.
  d e

ShadowMask
  e o
]
  o p
;
  p q
this
ÀÀ 
.
ÀÀ 
DepthAttachment
ÀÀ  
=
ÀÀ! "
depthAttachment
ÀÀ# 2
;
ÀÀ2 3
this
ÕÕ 
.
ÕÕ (
DepthCopyTextureIdentifier
ÕÕ +
=
ÕÕ, -
this
ÕÕ. 2
.
ÕÕ2 3
DepthCopyTexture
ÕÕ3 C
.
ÕÕC D

Identifier
ÕÕD N
(
ÕÕN O
)
ÕÕO P
;
ÕÕP Q
this
ŒŒ 
.
ŒŒ (
DepthInfoTextureIdentifier
ŒŒ +
=
ŒŒ, -
this
ŒŒ. 2
.
ŒŒ2 3
DepthInfoTexture
ŒŒ3 C
.
ŒŒC D

Identifier
ŒŒD N
(
ŒŒN O
)
ŒŒO P
;
ŒŒP Q
this
œœ 
.
œœ ,
TileDepthInfoTextureIdentifier
œœ /
=
œœ0 1
this
œœ2 6
.
œœ6 7"
TileDepthInfoTexture
œœ7 K
.
œœK L

Identifier
œœL V
(
œœV W
)
œœW X
;
œœX Y
if
–– 
(
–– 
this
–– 
.
–– *
GbufferAttachmentIdentifiers
–– 1
==
––2 4
null
––5 9
||
––: <
this
––= A
.
––A B*
GbufferAttachmentIdentifiers
––B ^
.
––^ _
Length
––_ e
!=
––f h
this
––i m
.
––m n!
GbufferAttachments––n Ä
.––Ä Å
Length––Å á
)––á à
this
—— 
.
—— *
GbufferAttachmentIdentifiers
—— 1
=
——2 3
new
——4 7$
RenderTargetIdentifier
——8 N
[
——N O
this
——O S
.
——S T 
GbufferAttachments
——T f
.
——f g
Length
——g m
]
——m n
;
——n o
for
““ 
(
““ 
int
““ 
i
““ 
=
““ 
$num
““ 
;
““ 
i
““ 
<
““ 
this
““  $
.
““$ % 
GbufferAttachments
““% 7
.
““7 8
Length
““8 >
;
““> ?
++
““@ B
i
““B C
)
““C D
this
”” 
.
”” *
GbufferAttachmentIdentifiers
”” 1
[
””1 2
i
””2 3
]
””3 4
=
””5 6
this
””7 ;
.
””; < 
GbufferAttachments
””< N
[
””N O
i
””O P
]
””P Q
.
””Q R

Identifier
””R \
(
””\ ]
)
””] ^
;
””^ _
this
‘‘ 
.
‘‘ '
DepthAttachmentIdentifier
‘‘ *
=
‘‘+ ,
depthAttachment
‘‘- <
.
‘‘< =

Identifier
‘‘= G
(
‘‘G H
)
‘‘H I
;
‘‘I J
if
ÿÿ 
(
ÿÿ 
renderingData
ÿÿ 
.
ÿÿ 

cameraData
ÿÿ (
.
ÿÿ( )
xr
ÿÿ) +
.
ÿÿ+ ,
enabled
ÿÿ, 3
)
ÿÿ3 4
{
ŸŸ 
this
⁄⁄ 
.
⁄⁄ (
DepthCopyTextureIdentifier
⁄⁄ /
=
⁄⁄0 1
new
⁄⁄2 5$
RenderTargetIdentifier
⁄⁄6 L
(
⁄⁄L M
this
⁄⁄M Q
.
⁄⁄Q R(
DepthCopyTextureIdentifier
⁄⁄R l
,
⁄⁄l m
$num
⁄⁄n o
,
⁄⁄o p
CubemapFace
⁄⁄q |
.
⁄⁄| }
Unknown⁄⁄} Ñ
,⁄⁄Ñ Ö
-⁄⁄Ü á
$num⁄⁄á à
)⁄⁄à â
;⁄⁄â ä
this
€€ 
.
€€ (
DepthInfoTextureIdentifier
€€ /
=
€€0 1
new
€€2 5$
RenderTargetIdentifier
€€6 L
(
€€L M
this
€€M Q
.
€€Q R(
DepthInfoTextureIdentifier
€€R l
,
€€l m
$num
€€n o
,
€€o p
CubemapFace
€€q |
.
€€| }
Unknown€€} Ñ
,€€Ñ Ö
-€€Ü á
$num€€á à
)€€à â
;€€â ä
this
‹‹ 
.
‹‹ ,
TileDepthInfoTextureIdentifier
‹‹ 3
=
‹‹4 5
new
‹‹6 9$
RenderTargetIdentifier
‹‹: P
(
‹‹P Q
this
‹‹Q U
.
‹‹U V,
TileDepthInfoTextureIdentifier
‹‹V t
,
‹‹t u
$num
‹‹v w
,
‹‹w x
CubemapFace‹‹y Ñ
.‹‹Ñ Ö
Unknown‹‹Ö å
,‹‹å ç
-‹‹é è
$num‹‹è ê
)‹‹ê ë
;‹‹ë í
for
ﬁﬁ 
(
ﬁﬁ 
int
ﬁﬁ 
i
ﬁﬁ 
=
ﬁﬁ 
$num
ﬁﬁ 
;
ﬁﬁ 
i
ﬁﬁ  !
<
ﬁﬁ" #
this
ﬁﬁ$ (
.
ﬁﬁ( )*
GbufferAttachmentIdentifiers
ﬁﬁ) E
.
ﬁﬁE F
Length
ﬁﬁF L
;
ﬁﬁL M
++
ﬁﬁN P
i
ﬁﬁP Q
)
ﬁﬁQ R
this
ﬂﬂ 
.
ﬂﬂ *
GbufferAttachmentIdentifiers
ﬂﬂ 5
[
ﬂﬂ5 6
i
ﬂﬂ6 7
]
ﬂﬂ7 8
=
ﬂﬂ9 :
new
ﬂﬂ; >$
RenderTargetIdentifier
ﬂﬂ? U
(
ﬂﬂU V
this
ﬂﬂV Z
.
ﬂﬂZ [*
GbufferAttachmentIdentifiers
ﬂﬂ[ w
[
ﬂﬂw x
i
ﬂﬂx y
]
ﬂﬂy z
,
ﬂﬂz {
$num
ﬂﬂ| }
,
ﬂﬂ} ~
CubemapFaceﬂﬂ ä
.ﬂﬂä ã
Unknownﬂﬂã í
,ﬂﬂí ì
-ﬂﬂî ï
$numﬂﬂï ñ
)ﬂﬂñ ó
;ﬂﬂó ò
this
‡‡ 
.
‡‡ '
DepthAttachmentIdentifier
‡‡ .
=
‡‡/ 0
new
‡‡1 4$
RenderTargetIdentifier
‡‡5 K
(
‡‡K L
this
‡‡L P
.
‡‡P Q'
DepthAttachmentIdentifier
‡‡Q j
,
‡‡j k
$num
‡‡l m
,
‡‡m n
CubemapFace
‡‡o z
.
‡‡z {
Unknown‡‡{ Ç
,‡‡Ç É
-‡‡Ñ Ö
$num‡‡Ö Ü
)‡‡Ü á
;‡‡á à
}
„„  
m_HasTileVisLights
ÊÊ 
=
ÊÊ  
this
ÊÊ! %
.
ÊÊ% &"
TiledDeferredShading
ÊÊ& :
&&
ÊÊ; = 
CheckHasTileLights
ÊÊ> P
(
ÊÊP Q
ref
ÊÊQ T
renderingData
ÊÊU b
.
ÊÊb c
	lightData
ÊÊc l
.
ÊÊl m
visibleLights
ÊÊm z
)
ÊÊz {
;
ÊÊ{ |
}
ÁÁ 	
public
ÈÈ 
void
ÈÈ 
OnCameraCleanup
ÈÈ #
(
ÈÈ# $
CommandBuffer
ÈÈ$ 1
cmd
ÈÈ2 5
)
ÈÈ5 6
{
ÍÍ 	
	CoreUtils
ÏÏ 
.
ÏÏ 

SetKeyword
ÏÏ  
(
ÏÏ  !
cmd
ÏÏ! $
,
ÏÏ$ %"
ShaderKeywordStrings
ÏÏ& :
.
ÏÏ: ;"
_GBUFFER_NORMALS_OCT
ÏÏ; O
,
ÏÏO P
false
ÏÏQ V
)
ÏÏV W
;
ÏÏW X
	CoreUtils
ÌÌ 
.
ÌÌ 

SetKeyword
ÌÌ  
(
ÌÌ  !
cmd
ÌÌ! $
,
ÌÌ$ %"
ShaderKeywordStrings
ÌÌ& :
.
ÌÌ: ;&
MixedLightingSubtractive
ÌÌ; S
,
ÌÌS T
false
ÌÌU Z
)
ÌÌZ [
;
ÌÌ[ \
for
ÔÔ 
(
ÔÔ 
int
ÔÔ 

tilerIndex
ÔÔ 
=
ÔÔ  !
$num
ÔÔ" #
;
ÔÔ# $

tilerIndex
ÔÔ% /
<
ÔÔ0 1
m_Tilers
ÔÔ2 :
.
ÔÔ: ;
Length
ÔÔ; A
;
ÔÔA B
++
ÔÔC E

tilerIndex
ÔÔF P
)
ÔÔP Q
{
 "
m_TileDataCapacities
ÒÒ $
[
ÒÒ$ %

tilerIndex
ÒÒ% /
]
ÒÒ/ 0
=
ÒÒ1 2
max
ÒÒ3 6
(
ÒÒ6 7"
m_TileDataCapacities
ÒÒ7 K
[
ÒÒK L

tilerIndex
ÒÒL V
]
ÒÒV W
,
ÒÒW X
m_Tilers
ÒÒY a
[
ÒÒa b

tilerIndex
ÒÒb l
]
ÒÒl m
.
ÒÒm n
TileDataCapacity
ÒÒn ~
)
ÒÒ~ 
;ÒÒ Ä
m_Tilers
ÚÚ 
[
ÚÚ 

tilerIndex
ÚÚ #
]
ÚÚ# $
.
ÚÚ$ %
OnCameraCleanup
ÚÚ% 4
(
ÚÚ4 5
)
ÚÚ5 6
;
ÚÚ6 7
}
ÛÛ 
if
ıı 
(
ıı  
m_stencilVisLights
ıı "
.
ıı" #
	IsCreated
ıı# ,
)
ıı, - 
m_stencilVisLights
ˆˆ "
.
ˆˆ" #
Dispose
ˆˆ# *
(
ˆˆ* +
)
ˆˆ+ ,
;
ˆˆ, -
if
˜˜ 
(
˜˜ &
m_stencilVisLightOffsets
˜˜ (
.
˜˜( )
	IsCreated
˜˜) 2
)
˜˜2 3&
m_stencilVisLightOffsets
¯¯ (
.
¯¯( )
Dispose
¯¯) 0
(
¯¯0 1
)
¯¯1 2
;
¯¯2 3
}
˘˘ 	
internal
˚˚ 
static
˚˚ 
StencilState
˚˚ $
OverwriteStencil
˚˚% 5
(
˚˚5 6
StencilState
˚˚6 B
s
˚˚C D
,
˚˚D E
int
˚˚F I
stencilWriteMask
˚˚J Z
)
˚˚Z [
{
¸¸ 	
if
˝˝ 
(
˝˝ 
!
˝˝ 
s
˝˝ 
.
˝˝ 
enabled
˝˝ 
)
˝˝ 
{
˛˛ 
return
ˇˇ 
new
ˇˇ 
StencilState
ˇˇ '
(
ˇˇ' (
true
ÄÄ 
,
ÄÄ 
$num
ÅÅ 
,
ÅÅ 
(
ÅÅ 
byte
ÅÅ 
)
ÅÅ 
stencilWriteMask
ÅÅ -
,
ÅÅ- .
CompareFunction
ÇÇ #
.
ÇÇ# $
Always
ÇÇ$ *
,
ÇÇ* +
	StencilOp
ÇÇ, 5
.
ÇÇ5 6
Replace
ÇÇ6 =
,
ÇÇ= >
	StencilOp
ÇÇ? H
.
ÇÇH I
Keep
ÇÇI M
,
ÇÇM N
	StencilOp
ÇÇO X
.
ÇÇX Y
Keep
ÇÇY ]
,
ÇÇ] ^
CompareFunction
ÉÉ #
.
ÉÉ# $
Always
ÉÉ$ *
,
ÉÉ* +
	StencilOp
ÉÉ, 5
.
ÉÉ5 6
Replace
ÉÉ6 =
,
ÉÉ= >
	StencilOp
ÉÉ? H
.
ÉÉH I
Keep
ÉÉI M
,
ÉÉM N
	StencilOp
ÉÉO X
.
ÉÉX Y
Keep
ÉÉY ]
)
ÑÑ 
;
ÑÑ 
}
ÖÖ 
CompareFunction
áá 
	funcFront
áá %
=
áá& '
s
áá( )
.
áá) *"
compareFunctionFront
áá* >
!=
áá? A
CompareFunction
ááB Q
.
ááQ R
Disabled
ááR Z
?
áá[ \
s
áá] ^
.
áá^ _"
compareFunctionFront
áá_ s
:
áát u
CompareFunctionááv Ö
.ááÖ Ü
AlwaysááÜ å
;ááå ç
CompareFunction
àà 
funcBack
àà $
=
àà% &
s
àà' (
.
àà( )!
compareFunctionBack
àà) <
!=
àà= ?
CompareFunction
àà@ O
.
ààO P
Disabled
ààP X
?
ààY Z
s
àà[ \
.
àà\ ]!
compareFunctionBack
àà] p
:
ààq r
CompareFunctionààs Ç
.ààÇ É
AlwaysààÉ â
;ààâ ä
	StencilOp
ââ 
	passFront
ââ 
=
ââ  !
s
ââ" #
.
ââ# $ 
passOperationFront
ââ$ 6
;
ââ6 7
	StencilOp
ää 
	failFront
ää 
=
ää  !
s
ää" #
.
ää# $ 
failOperationFront
ää$ 6
;
ää6 7
	StencilOp
ãã 

zfailFront
ãã  
=
ãã! "
s
ãã# $
.
ãã$ %!
zFailOperationFront
ãã% 8
;
ãã8 9
	StencilOp
åå 
passBack
åå 
=
åå  
s
åå! "
.
åå" #
passOperationBack
åå# 4
;
åå4 5
	StencilOp
çç 
failBack
çç 
=
çç  
s
çç! "
.
çç" #
failOperationBack
çç# 4
;
çç4 5
	StencilOp
éé 
	zfailBack
éé 
=
éé  !
s
éé" #
.
éé# $ 
zFailOperationBack
éé$ 6
;
éé6 7
return
êê 
new
êê 
StencilState
êê #
(
êê# $
true
ëë 
,
ëë 
(
íí 
byte
íí 
)
íí 
(
íí 
s
íí 
.
íí 
readMask
íí !
&
íí" #
$num
íí$ (
)
íí( )
,
íí) *
(
íí+ ,
byte
íí, 0
)
íí0 1
(
íí1 2
s
íí2 3
.
íí3 4
	writeMask
íí4 =
|
íí> ?
stencilWriteMask
íí@ P
)
ííP Q
,
ííQ R
	funcFront
ìì 
,
ìì 
	passFront
ìì $
,
ìì$ %
	failFront
ìì& /
,
ìì/ 0

zfailFront
ìì1 ;
,
ìì; <
funcBack
îî 
,
îî 
passBack
îî "
,
îî" #
failBack
îî$ ,
,
îî, -
	zfailBack
îî. 7
)
ïï 
;
ïï 
}
ññ 	
internal
òò 
static
òò 
RenderStateBlock
òò (
OverwriteStencil
òò) 9
(
òò9 :
RenderStateBlock
òò: J
block
òòK P
,
òòP Q
int
òòR U
stencilWriteMask
òòV f
,
òòf g
int
òòh k

stencilRef
òòl v
)
òòv w
{
ôô 	
if
öö 
(
öö 
!
öö 
block
öö 
.
öö 
stencilState
öö #
.
öö# $
enabled
öö$ +
)
öö+ ,
{
õõ 
block
úú 
.
úú 
stencilState
úú "
=
úú# $
new
úú% (
StencilState
úú) 5
(
úú5 6
true
ùù 
,
ùù 
$num
ûû 
,
ûû 
(
ûû 
byte
ûû 
)
ûû 
stencilWriteMask
ûû -
,
ûû- .
CompareFunction
üü #
.
üü# $
Always
üü$ *
,
üü* +
	StencilOp
üü, 5
.
üü5 6
Replace
üü6 =
,
üü= >
	StencilOp
üü? H
.
üüH I
Keep
üüI M
,
üüM N
	StencilOp
üüO X
.
üüX Y
Keep
üüY ]
,
üü] ^
CompareFunction
†† #
.
††# $
Always
††$ *
,
††* +
	StencilOp
††, 5
.
††5 6
Replace
††6 =
,
††= >
	StencilOp
††? H
.
††H I
Keep
††I M
,
††M N
	StencilOp
††O X
.
††X Y
Keep
††Y ]
)
°° 
;
°° 
}
¢¢ 
else
££ 
{
§§ 
StencilState
•• 
s
•• 
=
••  
block
••! &
.
••& '
stencilState
••' 3
;
••3 4
CompareFunction
¶¶ 
	funcFront
¶¶  )
=
¶¶* +
s
¶¶, -
.
¶¶- ."
compareFunctionFront
¶¶. B
!=
¶¶C E
CompareFunction
¶¶F U
.
¶¶U V
Disabled
¶¶V ^
?
¶¶_ `
s
¶¶a b
.
¶¶b c"
compareFunctionFront
¶¶c w
:
¶¶x y
CompareFunction¶¶z â
.¶¶â ä
Always¶¶ä ê
;¶¶ê ë
CompareFunction
ßß 
funcBack
ßß  (
=
ßß) *
s
ßß+ ,
.
ßß, -!
compareFunctionBack
ßß- @
!=
ßßA C
CompareFunction
ßßD S
.
ßßS T
Disabled
ßßT \
?
ßß] ^
s
ßß_ `
.
ßß` a!
compareFunctionBack
ßßa t
:
ßßu v
CompareFunctionßßw Ü
.ßßÜ á
Alwaysßßá ç
;ßßç é
	StencilOp
®® 
	passFront
®® #
=
®®$ %
s
®®& '
.
®®' ( 
passOperationFront
®®( :
;
®®: ;
	StencilOp
©© 
	failFront
©© #
=
©©$ %
s
©©& '
.
©©' ( 
failOperationFront
©©( :
;
©©: ;
	StencilOp
™™ 

zfailFront
™™ $
=
™™% &
s
™™' (
.
™™( )!
zFailOperationFront
™™) <
;
™™< =
	StencilOp
´´ 
passBack
´´ "
=
´´# $
s
´´% &
.
´´& '
passOperationBack
´´' 8
;
´´8 9
	StencilOp
¨¨ 
failBack
¨¨ "
=
¨¨# $
s
¨¨% &
.
¨¨& '
failOperationBack
¨¨' 8
;
¨¨8 9
	StencilOp
≠≠ 
	zfailBack
≠≠ #
=
≠≠$ %
s
≠≠& '
.
≠≠' ( 
zFailOperationBack
≠≠( :
;
≠≠: ;
block
ØØ 
.
ØØ 
stencilState
ØØ "
=
ØØ# $
new
ØØ% (
StencilState
ØØ) 5
(
ØØ5 6
true
∞∞ 
,
∞∞ 
(
±± 
byte
±± 
)
±± 
(
±± 
s
±± 
.
±± 
readMask
±± %
&
±±& '
$num
±±( ,
)
±±, -
,
±±- .
(
±±/ 0
byte
±±0 4
)
±±4 5
(
±±5 6
s
±±6 7
.
±±7 8
	writeMask
±±8 A
|
±±B C
stencilWriteMask
±±D T
)
±±T U
,
±±U V
	funcFront
≤≤ 
,
≤≤ 
	passFront
≤≤ (
,
≤≤( )
	failFront
≤≤* 3
,
≤≤3 4

zfailFront
≤≤5 ?
,
≤≤? @
funcBack
≥≥ 
,
≥≥ 
passBack
≥≥ &
,
≥≥& '
failBack
≥≥( 0
,
≥≥0 1
	zfailBack
≥≥2 ;
)
¥¥ 
;
¥¥ 
}
µµ 
block
∑∑ 
.
∑∑ 
mask
∑∑ 
|=
∑∑ 
RenderStateMask
∑∑ )
.
∑∑) *
Stencil
∑∑* 1
;
∑∑1 2
block
∏∏ 
.
∏∏ 
stencilReference
∏∏ "
=
∏∏# $
(
∏∏% &
block
∏∏& +
.
∏∏+ ,
stencilReference
∏∏, <
&
∏∏= >
(
∏∏? @
int
∏∏@ C
)
∏∏C D
StencilUsage
∏∏D P
.
∏∏P Q
UserMask
∏∏Q Y
)
∏∏Y Z
|
∏∏[ \

stencilRef
∏∏] g
;
∏∏g h
return
∫∫ 
block
∫∫ 
;
∫∫ 
}
ªª 	
internal
ΩΩ 
bool
ΩΩ 
HasTileLights
ΩΩ #
(
ΩΩ# $
)
ΩΩ$ %
{
ææ 	
return
øø  
m_HasTileVisLights
øø %
;
øø% &
}
¿¿ 	
internal
¬¬ 
bool
¬¬ (
HasTileDepthRangeExtraPass
¬¬ 0
(
¬¬0 1
)
¬¬1 2
{
√√ 	
ref
ƒƒ 
DeferredTiler
ƒƒ 
tiler
ƒƒ #
=
ƒƒ$ %
ref
ƒƒ& )
m_Tilers
ƒƒ* 2
[
ƒƒ2 3
$num
ƒƒ3 4
]
ƒƒ4 5
;
ƒƒ5 6
int
≈≈ 
tilePixelWidth
≈≈ 
=
≈≈  
tiler
≈≈! &
.
≈≈& '
TilePixelWidth
≈≈' 5
;
≈≈5 6
int
∆∆ 
tilePixelHeight
∆∆ 
=
∆∆  !
tiler
∆∆" '
.
∆∆' (
TilePixelHeight
∆∆( 7
;
∆∆7 8
int
«« 
tileMipLevel
«« 
=
«« 
(
««  
int
««  #
)
««# $
Mathf
««$ )
.
««) *
Log
««* -
(
««- .
Mathf
««. 3
.
««3 4
Min
««4 7
(
««7 8
tilePixelWidth
««8 F
,
««F G
tilePixelHeight
««H W
)
««W X
,
««X Y
$num
««Z [
)
««[ \
;
««\ ]
return
»» 
DeferredConfig
»» !
.
»»! "-
kTileDepthInfoIntermediateLevel
»»" A
>=
»»B D
$num
»»E F
&&
»»G I
DeferredConfig
»»J X
.
»»X Y-
kTileDepthInfoIntermediateLevel
»»Y x
<
»»y z
tileMipLevel»»{ á
;»»á à
}
…… 	
internal
ÀÀ 
void
ÀÀ &
ExecuteTileDepthInfoPass
ÀÀ .
(
ÀÀ. /%
ScriptableRenderContext
ÀÀ/ F
context
ÀÀG N
,
ÀÀN O
ref
ÀÀP S
RenderingData
ÀÀT a
renderingData
ÀÀb o
)
ÀÀo p
{
ÃÃ 	
if
ÕÕ 
(
ÕÕ %
m_TileDepthInfoMaterial
ÕÕ '
==
ÕÕ( *
null
ÕÕ+ /
)
ÕÕ/ 0
{
ŒŒ 
Debug
œœ 
.
œœ 
LogErrorFormat
œœ $
(
œœ$ %
$strœœ% å
,œœå ç'
m_TileDepthInfoMaterialœœé •
,œœ• ¶
GetTypeœœß Æ
(œœÆ Ø
)œœØ ∞
.œœ∞ ±
Nameœœ± µ
)œœµ ∂
;œœ∂ ∑
return
–– 
;
–– 
}
—— 

Assertions
”” 
.
”” 
Assert
”” 
.
”” 
IsTrue
”” $
(
””$ %
m_Tilers
‘‘ 
[
‘‘ 
$num
‘‘ 
]
‘‘ 
.
‘‘ 
TilePixelWidth
‘‘ *
==
‘‘+ -
m_Tilers
‘‘. 6
[
‘‘6 7
$num
‘‘7 8
]
‘‘8 9
.
‘‘9 :
TilePixelHeight
‘‘: I
||
‘‘J L
DeferredConfig
‘‘M [
.
‘‘[ \-
kTileDepthInfoIntermediateLevel
‘‘\ {
<=
‘‘| ~
$num‘‘ Ä
,‘‘Ä Å
$str
’’ u
)
÷÷ 
;
÷÷ 
uint
ÿÿ 
invalidDepthRange
ÿÿ "
=
ÿÿ# $
(
ÿÿ% &
uint
ÿÿ& *
)
ÿÿ* +
Mathf
ÿÿ+ 0
.
ÿÿ0 1
FloatToHalf
ÿÿ1 <
(
ÿÿ< =
-
ÿÿ= >
$num
ÿÿ> B
)
ÿÿB C
|
ÿÿD E
(
ÿÿF G
(
ÿÿG H
(
ÿÿH I
uint
ÿÿI M
)
ÿÿM N
Mathf
ÿÿN S
.
ÿÿS T
FloatToHalf
ÿÿT _
(
ÿÿ_ `
-
ÿÿ` a
$num
ÿÿa e
)
ÿÿe f
)
ÿÿf g
<<
ÿÿh j
$num
ÿÿk m
)
ÿÿm n
;
ÿÿn o
ref
⁄⁄ 
DeferredTiler
⁄⁄ 
tiler
⁄⁄ #
=
⁄⁄$ %
ref
⁄⁄& )
m_Tilers
⁄⁄* 2
[
⁄⁄2 3
$num
⁄⁄3 4
]
⁄⁄4 5
;
⁄⁄5 6
int
€€ 

tileXCount
€€ 
=
€€ 
tiler
€€ "
.
€€" #

TileXCount
€€# -
;
€€- .
int
‹‹ 

tileYCount
‹‹ 
=
‹‹ 
tiler
‹‹ "
.
‹‹" #

TileYCount
‹‹# -
;
‹‹- .
int
›› 
tilePixelWidth
›› 
=
››  
tiler
››! &
.
››& '
TilePixelWidth
››' 5
;
››5 6
int
ﬁﬁ 
tilePixelHeight
ﬁﬁ 
=
ﬁﬁ  !
tiler
ﬁﬁ" '
.
ﬁﬁ' (
TilePixelHeight
ﬁﬁ( 7
;
ﬁﬁ7 8
int
ﬂﬂ 
tileMipLevel
ﬂﬂ 
=
ﬂﬂ 
(
ﬂﬂ  
int
ﬂﬂ  #
)
ﬂﬂ# $
Mathf
ﬂﬂ$ )
.
ﬂﬂ) *
Log
ﬂﬂ* -
(
ﬂﬂ- .
Mathf
ﬂﬂ. 3
.
ﬂﬂ3 4
Min
ﬂﬂ4 7
(
ﬂﬂ7 8
tilePixelWidth
ﬂﬂ8 F
,
ﬂﬂF G
tilePixelHeight
ﬂﬂH W
)
ﬂﬂW X
,
ﬂﬂX Y
$num
ﬂﬂZ [
)
ﬂﬂ[ \
;
ﬂﬂ\ ]
int
‡‡ "
intermediateMipLevel
‡‡ $
=
‡‡% &
DeferredConfig
‡‡' 5
.
‡‡5 6-
kTileDepthInfoIntermediateLevel
‡‡6 U
>=
‡‡V X
$num
‡‡Y Z
&&
‡‡[ ]
DeferredConfig
‡‡^ l
.
‡‡l m.
kTileDepthInfoIntermediateLevel‡‡m å
<‡‡ç é
tileMipLevel‡‡è õ
?‡‡ú ù
DeferredConfig‡‡û ¨
.‡‡¨ ≠/
kTileDepthInfoIntermediateLevel‡‡≠ Ã
:‡‡Õ Œ
tileMipLevel‡‡œ €
;‡‡€ ‹
int
·· 
tileShiftMipLevel
·· !
=
··" #
tileMipLevel
··$ 0
-
··1 2"
intermediateMipLevel
··3 G
;
··G H
int
‚‚ 
	alignment
‚‚ 
=
‚‚ 
$num
‚‚ 
<<
‚‚  "
intermediateMipLevel
‚‚! 5
;
‚‚5 6
int
„„ 
depthInfoWidth
„„ 
=
„„  
(
„„! "
this
„„" &
.
„„& '
RenderWidth
„„' 2
+
„„3 4
	alignment
„„5 >
-
„„? @
$num
„„A B
)
„„B C
>>
„„D F"
intermediateMipLevel
„„G [
;
„„[ \
int
‰‰ 
depthInfoHeight
‰‰ 
=
‰‰  !
(
‰‰" #
this
‰‰# '
.
‰‰' (
RenderHeight
‰‰( 4
+
‰‰5 6
	alignment
‰‰7 @
-
‰‰A B
$num
‰‰C D
)
‰‰D E
>>
‰‰F H"
intermediateMipLevel
‰‰I ]
;
‰‰] ^
NativeArray
ÂÂ 
<
ÂÂ 
ushort
ÂÂ 
>
ÂÂ 
tiles
ÂÂ  %
=
ÂÂ& '
tiler
ÂÂ( -
.
ÂÂ- .
Tiles
ÂÂ. 3
;
ÂÂ3 4
NativeArray
ÊÊ 
<
ÊÊ 
uint
ÊÊ 
>
ÊÊ 
tileHeaders
ÊÊ )
=
ÊÊ* +
tiler
ÊÊ, 1
.
ÊÊ1 2
TileHeaders
ÊÊ2 =
;
ÊÊ= >
NativeArray
ËË 
<
ËË 
uint
ËË 
>
ËË 
depthRanges
ËË )
=
ËË* +
new
ËË, /
NativeArray
ËË0 ;
<
ËË; <
uint
ËË< @
>
ËË@ A
(
ËËA B%
m_MaxDepthRangePerBatch
ËËB Y
,
ËËY Z
	Allocator
ËË[ d
.
ËËd e
Temp
ËËe i
,
ËËi j 
NativeArrayOptions
ËËk }
.
ËË} ~"
UninitializedMemoryËË~ ë
)ËËë í
;ËËí ì
CommandBuffer
ÍÍ 
cmd
ÍÍ 
=
ÍÍ 
CommandBufferPool
ÍÍ  1
.
ÍÍ1 2
Get
ÍÍ2 5
(
ÍÍ5 6
)
ÍÍ6 7
;
ÍÍ7 8
using
ÎÎ 
(
ÎÎ 
new
ÎÎ 
ProfilingScope
ÎÎ %
(
ÎÎ% &
cmd
ÎÎ& )
,
ÎÎ) *&
m_ProfilingTileDepthInfo
ÎÎ+ C
)
ÎÎC D
)
ÎÎD E
{
ÏÏ $
RenderTargetIdentifier
ÌÌ &
depthSurface
ÌÌ' 3
=
ÌÌ4 5
this
ÌÌ6 :
.
ÌÌ: ;'
DepthAttachmentIdentifier
ÌÌ; T
;
ÌÌT U$
RenderTargetIdentifier
ÓÓ &
depthInfoSurface
ÓÓ' 7
=
ÓÓ8 9
(
ÓÓ: ;
tileMipLevel
ÓÓ; G
==
ÓÓH J"
intermediateMipLevel
ÓÓK _
)
ÓÓ_ `
?
ÓÓa b
this
ÓÓc g
.
ÓÓg h-
TileDepthInfoTextureIdentifierÓÓh Ü
:ÓÓá à
thisÓÓâ ç
.ÓÓç é*
DepthInfoTextureIdentifierÓÓé ®
;ÓÓ® ©
cmd
 
.
 
SetGlobalTexture
 $
(
$ %
ShaderConstants
% 4
.
4 5
	_DepthTex
5 >
,
> ?
depthSurface
@ L
)
L M
;
M N
cmd
ÒÒ 
.
ÒÒ 
SetGlobalVector
ÒÒ #
(
ÒÒ# $
ShaderConstants
ÒÒ$ 3
.
ÒÒ3 4
_DepthTexSize
ÒÒ4 A
,
ÒÒA B
new
ÒÒC F
Vector4
ÒÒG N
(
ÒÒN O
this
ÒÒO S
.
ÒÒS T
RenderWidth
ÒÒT _
,
ÒÒ_ `
this
ÒÒa e
.
ÒÒe f
RenderHeight
ÒÒf r
,
ÒÒr s
$num
ÒÒt x
/
ÒÒy z
this
ÒÒ{ 
.ÒÒ Ä
RenderWidthÒÒÄ ã
,ÒÒã å
$numÒÒç ë
/ÒÒí ì
thisÒÒî ò
.ÒÒò ô
RenderHeightÒÒô •
)ÒÒ• ¶
)ÒÒ¶ ß
;ÒÒß ®
cmd
ÚÚ 
.
ÚÚ 
SetGlobalInt
ÚÚ  
(
ÚÚ  !
ShaderConstants
ÚÚ! 0
.
ÚÚ0 1 
_DownsamplingWidth
ÚÚ1 C
,
ÚÚC D
tilePixelWidth
ÚÚE S
)
ÚÚS T
;
ÚÚT U
cmd
ÛÛ 
.
ÛÛ 
SetGlobalInt
ÛÛ  
(
ÛÛ  !
ShaderConstants
ÛÛ! 0
.
ÛÛ0 1!
_DownsamplingHeight
ÛÛ1 D
,
ÛÛD E
tilePixelHeight
ÛÛF U
)
ÛÛU V
;
ÛÛV W
cmd
ÙÙ 
.
ÙÙ 
SetGlobalInt
ÙÙ  
(
ÙÙ  !
ShaderConstants
ÙÙ! 0
.
ÙÙ0 1
_SourceShiftX
ÙÙ1 >
,
ÙÙ> ?"
intermediateMipLevel
ÙÙ@ T
)
ÙÙT U
;
ÙÙU V
cmd
ıı 
.
ıı 
SetGlobalInt
ıı  
(
ıı  !
ShaderConstants
ıı! 0
.
ıı0 1
_SourceShiftY
ıı1 >
,
ıı> ?"
intermediateMipLevel
ıı@ T
)
ııT U
;
ııU V
cmd
ˆˆ 
.
ˆˆ 
SetGlobalInt
ˆˆ  
(
ˆˆ  !
ShaderConstants
ˆˆ! 0
.
ˆˆ0 1
_TileShiftX
ˆˆ1 <
,
ˆˆ< =
tileShiftMipLevel
ˆˆ> O
)
ˆˆO P
;
ˆˆP Q
cmd
˜˜ 
.
˜˜ 
SetGlobalInt
˜˜  
(
˜˜  !
ShaderConstants
˜˜! 0
.
˜˜0 1
_TileShiftY
˜˜1 <
,
˜˜< =
tileShiftMipLevel
˜˜> O
)
˜˜O P
;
˜˜P Q
	Matrix4x4
˘˘ 
proj
˘˘ 
=
˘˘  
renderingData
˘˘! .
.
˘˘. /

cameraData
˘˘/ 9
.
˘˘9 :
camera
˘˘: @
.
˘˘@ A
projectionMatrix
˘˘A Q
;
˘˘Q R
	Matrix4x4
˙˙ 
clip
˙˙ 
=
˙˙  
new
˙˙! $
	Matrix4x4
˙˙% .
(
˙˙. /
new
˙˙/ 2
Vector4
˙˙3 :
(
˙˙: ;
$num
˙˙; <
,
˙˙< =
$num
˙˙> ?
,
˙˙? @
$num
˙˙A B
,
˙˙B C
$num
˙˙D E
)
˙˙E F
,
˙˙F G
new
˙˙H K
Vector4
˙˙L S
(
˙˙S T
$num
˙˙T U
,
˙˙U V
$num
˙˙W X
,
˙˙X Y
$num
˙˙Z [
,
˙˙[ \
$num
˙˙] ^
)
˙˙^ _
,
˙˙_ `
new
˙˙a d
Vector4
˙˙e l
(
˙˙l m
$num
˙˙m n
,
˙˙n o
$num
˙˙p q
,
˙˙q r
$num
˙˙s w
,
˙˙w x
$num
˙˙y z
)
˙˙z {
,
˙˙{ |
new˙˙} Ä
Vector4˙˙Å à
(˙˙à â
$num˙˙â ä
,˙˙ä ã
$num˙˙å ç
,˙˙ç é
$num˙˙è ì
,˙˙ì î
$num˙˙ï ñ
)˙˙ñ ó
)˙˙ó ò
;˙˙ò ô
	Matrix4x4
˚˚ 
projScreenInv
˚˚ '
=
˚˚( )
	Matrix4x4
˚˚* 3
.
˚˚3 4
Inverse
˚˚4 ;
(
˚˚; <
clip
˚˚< @
*
˚˚A B
proj
˚˚C G
)
˚˚G H
;
˚˚H I
cmd
¸¸ 
.
¸¸ 
SetGlobalVector
¸¸ #
(
¸¸# $
ShaderConstants
¸¸$ 3
.
¸¸3 4
_unproject0
¸¸4 ?
,
¸¸? @
projScreenInv
¸¸A N
.
¸¸N O
GetRow
¸¸O U
(
¸¸U V
$num
¸¸V W
)
¸¸W X
)
¸¸X Y
;
¸¸Y Z
cmd
˝˝ 
.
˝˝ 
SetGlobalVector
˝˝ #
(
˝˝# $
ShaderConstants
˝˝$ 3
.
˝˝3 4
_unproject1
˝˝4 ?
,
˝˝? @
projScreenInv
˝˝A N
.
˝˝N O
GetRow
˝˝O U
(
˝˝U V
$num
˝˝V W
)
˝˝W X
)
˝˝X Y
;
˝˝Y Z
string
ˇˇ 
shaderVariant
ˇˇ $
=
ˇˇ% &
null
ˇˇ' +
;
ˇˇ+ ,
if
ÄÄ 
(
ÄÄ 
tilePixelWidth
ÄÄ "
==
ÄÄ# %
tilePixelHeight
ÄÄ& 5
)
ÄÄ5 6
{
ÅÅ 
if
ÇÇ 
(
ÇÇ "
intermediateMipLevel
ÇÇ ,
==
ÇÇ- /
$num
ÇÇ0 1
)
ÇÇ1 2
shaderVariant
ÉÉ %
=
ÉÉ& '"
ShaderKeywordStrings
ÉÉ( <
.
ÉÉ< =!
DOWNSAMPLING_SIZE_2
ÉÉ= P
;
ÉÉP Q
else
ÑÑ 
if
ÑÑ 
(
ÑÑ "
intermediateMipLevel
ÑÑ 1
==
ÑÑ2 4
$num
ÑÑ5 6
)
ÑÑ6 7
shaderVariant
ÖÖ %
=
ÖÖ& '"
ShaderKeywordStrings
ÖÖ( <
.
ÖÖ< =!
DOWNSAMPLING_SIZE_4
ÖÖ= P
;
ÖÖP Q
else
ÜÜ 
if
ÜÜ 
(
ÜÜ "
intermediateMipLevel
ÜÜ 1
==
ÜÜ2 4
$num
ÜÜ5 6
)
ÜÜ6 7
shaderVariant
áá %
=
áá& '"
ShaderKeywordStrings
áá( <
.
áá< =!
DOWNSAMPLING_SIZE_8
áá= P
;
ááP Q
else
àà 
if
àà 
(
àà "
intermediateMipLevel
àà 1
==
àà2 4
$num
àà5 6
)
àà6 7
shaderVariant
ââ %
=
ââ& '"
ShaderKeywordStrings
ââ( <
.
ââ< ="
DOWNSAMPLING_SIZE_16
ââ= Q
;
ââQ R
}
ää 
if
åå 
(
åå 
shaderVariant
åå !
!=
åå" $
null
åå% )
)
åå) *
cmd
çç 
.
çç !
EnableShaderKeyword
çç +
(
çç+ ,
shaderVariant
çç, 9
)
çç9 :
;
çç: ;
int
èè 
tileY
èè 
=
èè 
$num
èè 
;
èè 
int
êê 
tileYIncrement
êê "
=
êê# $
(
êê% &
DeferredConfig
êê& 4
.
êê4 5%
UseCBufferForDepthRange
êê5 L
?
êêM N
DeferredConfig
êêO ]
.
êê] ^#
kPreferredCBufferSize
êê^ s
:
êêt u
DeferredConfigêêv Ñ
.êêÑ Ö.
kPreferredStructuredBufferSizeêêÖ £
)êê£ §
/êê• ¶
(êêß ®

tileXCountêê® ≤
*êê≥ ¥
$numêêµ ∂
)êê∂ ∑
;êê∑ ∏
while
íí 
(
íí 
tileY
íí 
<
íí 

tileYCount
íí )
)
íí) *
{
ìì 
int
îî 
tileYEnd
îî  
=
îî! "
Mathf
îî# (
.
îî( )
Min
îî) ,
(
îî, -

tileYCount
îî- 7
,
îî7 8
tileY
îî9 >
+
îî? @
tileYIncrement
îîA O
)
îîO P
;
îîP Q
for
ññ 
(
ññ 
int
ññ 
j
ññ 
=
ññ  
tileY
ññ! &
;
ññ& '
j
ññ( )
<
ññ* +
tileYEnd
ññ, 4
;
ññ4 5
++
ññ6 8
j
ññ8 9
)
ññ9 :
{
óó 
for
òò 
(
òò 
int
òò  
i
òò! "
=
òò# $
$num
òò% &
;
òò& '
i
òò( )
<
òò* +

tileXCount
òò, 6
;
òò6 7
++
òò8 :
i
òò: ;
)
òò; <
{
ôô 
int
öö 
headerOffset
öö  ,
=
öö- .
tiler
öö/ 4
.
öö4 5!
GetTileHeaderOffset
öö5 H
(
ööH I
i
ööI J
,
ööJ K
j
ööL M
)
ööM N
;
ööN O
int
õõ 
tileLightCount
õõ  .
=
õõ/ 0
(
õõ1 2
int
õõ2 5
)
õõ5 6
tileHeaders
õõ6 A
[
õõA B
headerOffset
õõB N
+
õõO P
$num
õõQ R
]
õõR S
;
õõS T
uint
úú  
listDepthRange
úú! /
=
úú0 1
tileLightCount
úú2 @
==
úúA C
$num
úúD E
?
úúF G
invalidDepthRange
úúH Y
:
úúZ [
tileHeaders
úú\ g
[
úúg h
headerOffset
úúh t
+
úúu v
$num
úúw x
]
úúx y
;
úúy z
depthRanges
ùù '
[
ùù' (
i
ùù( )
+
ùù* +
(
ùù, -
j
ùù- .
-
ùù/ 0
tileY
ùù1 6
)
ùù6 7
*
ùù8 9

tileXCount
ùù: D
]
ùùD E
=
ùùF G
listDepthRange
ùùH V
;
ùùV W
}
ûû 
}
üü 
ComputeBuffer
°° !
_depthRanges
°°" .
=
°°/ 0 
DeferredShaderData
°°1 C
.
°°C D
instance
°°D L
.
°°L M
ReserveBuffer
°°M Z
<
°°Z [
uint
°°[ _
>
°°_ `
(
°°` a%
m_MaxDepthRangePerBatch
°°a x
,
°°x y
DeferredConfig°°z à
.°°à â'
UseCBufferForDepthRange°°â †
)°°† °
;°°° ¢
_depthRanges
¢¢  
.
¢¢  !
SetData
¢¢! (
(
¢¢( )
depthRanges
¢¢) 4
,
¢¢4 5
$num
¢¢6 7
,
¢¢7 8
$num
¢¢9 :
,
¢¢: ;
depthRanges
¢¢< G
.
¢¢G H
Length
¢¢H N
)
¢¢N O
;
¢¢O P
if
§§ 
(
§§ 
DeferredConfig
§§ &
.
§§& '%
UseCBufferForDepthRange
§§' >
)
§§> ?
cmd
•• 
.
•• %
SetGlobalConstantBuffer
•• 3
(
••3 4
_depthRanges
••4 @
,
••@ A
ShaderConstants
••B Q
.
••Q R
UDepthRanges
••R ^
,
••^ _
$num
••` a
,
••a b%
m_MaxDepthRangePerBatch
••c z
*
••{ |
$num
••} ~
)
••~ 
;•• Ä
else
¶¶ 
cmd
ßß 
.
ßß 
SetGlobalBuffer
ßß +
(
ßß+ ,
ShaderConstants
ßß, ;
.
ßß; <
_DepthRanges
ßß< H
,
ßßH I
_depthRanges
ßßJ V
)
ßßV W
;
ßßW X
cmd
©© 
.
©© 
SetGlobalInt
©© $
(
©©$ %
ShaderConstants
©©% 4
.
©©4 5
_tileXCount
©©5 @
,
©©@ A

tileXCount
©©B L
)
©©L M
;
©©M N
cmd
™™ 
.
™™ 
SetGlobalInt
™™ $
(
™™$ %
ShaderConstants
™™% 4
.
™™4 5
_DepthRangeOffset
™™5 F
,
™™F G
tileY
™™H M
*
™™N O

tileXCount
™™P Z
)
™™Z [
;
™™[ \
cmd
¨¨ 
.
¨¨ 
EnableScissorRect
¨¨ )
(
¨¨) *
new
¨¨* -
Rect
¨¨. 2
(
¨¨2 3
$num
¨¨3 4
,
¨¨4 5
tileY
¨¨6 ;
<<
¨¨< >
tileShiftMipLevel
¨¨? P
,
¨¨P Q
depthInfoWidth
¨¨R `
,
¨¨` a
(
¨¨b c
tileYEnd
¨¨c k
-
¨¨l m
tileY
¨¨n s
)
¨¨s t
<<
¨¨u w 
tileShiftMipLevel¨¨x â
)¨¨â ä
)¨¨ä ã
;¨¨ã å
cmd
≠≠ 
.
≠≠ 
Blit
≠≠ 
(
≠≠ 
depthSurface
≠≠ )
,
≠≠) *
depthInfoSurface
≠≠+ ;
,
≠≠; <%
m_TileDepthInfoMaterial
≠≠= T
,
≠≠T U
$num
≠≠V W
)
≠≠W X
;
≠≠X Y
tileY
ØØ 
=
ØØ 
tileYEnd
ØØ $
;
ØØ$ %
}
∞∞ 
cmd
≤≤ 
.
≤≤  
DisableScissorRect
≤≤ &
(
≤≤& '
)
≤≤' (
;
≤≤( )
if
¥¥ 
(
¥¥ 
shaderVariant
¥¥ !
!=
¥¥" $
null
¥¥% )
)
¥¥) *
cmd
µµ 
.
µµ "
DisableShaderKeyword
µµ ,
(
µµ, -
shaderVariant
µµ- :
)
µµ: ;
;
µµ; <
}
∂∂ 
context
∏∏ 
.
∏∏ "
ExecuteCommandBuffer
∏∏ (
(
∏∏( )
cmd
∏∏) ,
)
∏∏, -
;
∏∏- .
CommandBufferPool
ππ 
.
ππ 
Release
ππ %
(
ππ% &
cmd
ππ& )
)
ππ) *
;
ππ* +
depthRanges
ªª 
.
ªª 
Dispose
ªª 
(
ªª  
)
ªª  !
;
ªª! "
}
ºº 	
internal
ææ 
void
ææ *
ExecuteDownsampleBitmaskPass
ææ 2
(
ææ2 3%
ScriptableRenderContext
ææ3 J
context
ææK R
,
ææR S
ref
ææT W
RenderingData
ææX e
renderingData
ææf s
)
ææs t
{
øø 	
if
¿¿ 
(
¿¿ %
m_TileDepthInfoMaterial
¿¿ '
==
¿¿( *
null
¿¿+ /
)
¿¿/ 0
{
¡¡ 
Debug
¬¬ 
.
¬¬ 
LogErrorFormat
¬¬ $
(
¬¬$ %
$str¬¬% å
,¬¬å ç'
m_TileDepthInfoMaterial¬¬é •
,¬¬• ¶
GetType¬¬ß Æ
(¬¬Æ Ø
)¬¬Ø ∞
.¬¬∞ ±
Name¬¬± µ
)¬¬µ ∂
;¬¬∂ ∑
return
√√ 
;
√√ 
}
ƒƒ 
CommandBuffer
∆∆ 
cmd
∆∆ 
=
∆∆ 
CommandBufferPool
∆∆  1
.
∆∆1 2
Get
∆∆2 5
(
∆∆5 6
)
∆∆6 7
;
∆∆7 8
using
«« 
(
«« 
new
«« 
ProfilingScope
«« %
(
««% &
cmd
««& )
,
««) *&
m_ProfilingTileDepthInfo
««+ C
)
««C D
)
««D E
{
»» $
RenderTargetIdentifier
…… &
depthInfoSurface
……' 7
=
……8 9
this
……: >
.
……> ?(
DepthInfoTextureIdentifier
……? Y
;
……Y Z$
RenderTargetIdentifier
   &"
tileDepthInfoSurface
  ' ;
=
  < =
this
  > B
.
  B C,
TileDepthInfoTextureIdentifier
  C a
;
  a b
ref
ÃÃ 
DeferredTiler
ÃÃ !
tiler
ÃÃ" '
=
ÃÃ( )
ref
ÃÃ* -
m_Tilers
ÃÃ. 6
[
ÃÃ6 7
$num
ÃÃ7 8
]
ÃÃ8 9
;
ÃÃ9 :
int
ÕÕ 
tilePixelWidth
ÕÕ "
=
ÕÕ# $
tiler
ÕÕ% *
.
ÕÕ* +
TilePixelWidth
ÕÕ+ 9
;
ÕÕ9 :
int
ŒŒ 
tilePixelHeight
ŒŒ #
=
ŒŒ$ %
tiler
ŒŒ& +
.
ŒŒ+ ,
TilePixelHeight
ŒŒ, ;
;
ŒŒ; <
int
œœ 
tileWidthLevel
œœ "
=
œœ# $
(
œœ% &
int
œœ& )
)
œœ) *
Mathf
œœ* /
.
œœ/ 0
Log
œœ0 3
(
œœ3 4
tilePixelWidth
œœ4 B
,
œœB C
$num
œœD E
)
œœE F
;
œœF G
int
–– 
tileHeightLevel
–– #
=
––$ %
(
––& '
int
––' *
)
––* +
Mathf
––+ 0
.
––0 1
Log
––1 4
(
––4 5
tilePixelHeight
––5 D
,
––D E
$num
––F G
)
––G H
;
––H I
int
—— "
intermediateMipLevel
—— (
=
——) *
DeferredConfig
——+ 9
.
——9 :-
kTileDepthInfoIntermediateLevel
——: Y
;
——Y Z
int
““ 
diffWidthLevel
““ "
=
““# $
tileWidthLevel
““% 3
-
““4 5"
intermediateMipLevel
““6 J
;
““J K
int
”” 
diffHeightLevel
”” #
=
””$ %
tileHeightLevel
””& 5
-
””6 7"
intermediateMipLevel
””8 L
;
””L M
cmd
’’ 
.
’’ 
SetGlobalTexture
’’ $
(
’’$ %
ShaderConstants
’’% 4
.
’’4 5
_BitmaskTex
’’5 @
,
’’@ A
depthInfoSurface
’’B R
)
’’R S
;
’’S T
cmd
÷÷ 
.
÷÷ 
SetGlobalInt
÷÷  
(
÷÷  !
ShaderConstants
÷÷! 0
.
÷÷0 1 
_DownsamplingWidth
÷÷1 C
,
÷÷C D
tilePixelWidth
÷÷E S
)
÷÷S T
;
÷÷T U
cmd
◊◊ 
.
◊◊ 
SetGlobalInt
◊◊  
(
◊◊  !
ShaderConstants
◊◊! 0
.
◊◊0 1!
_DownsamplingHeight
◊◊1 D
,
◊◊D E
tilePixelHeight
◊◊F U
)
◊◊U V
;
◊◊V W
int
ŸŸ 
	alignment
ŸŸ 
=
ŸŸ 
$num
ŸŸ  !
<<
ŸŸ" $
DeferredConfig
ŸŸ% 3
.
ŸŸ3 4-
kTileDepthInfoIntermediateLevel
ŸŸ4 S
;
ŸŸS T
int
⁄⁄ 
depthInfoWidth
⁄⁄ "
=
⁄⁄# $
(
⁄⁄% &
this
⁄⁄& *
.
⁄⁄* +
RenderWidth
⁄⁄+ 6
+
⁄⁄7 8
	alignment
⁄⁄9 B
-
⁄⁄C D
$num
⁄⁄E F
)
⁄⁄F G
>>
⁄⁄H J
DeferredConfig
⁄⁄K Y
.
⁄⁄Y Z-
kTileDepthInfoIntermediateLevel
⁄⁄Z y
;
⁄⁄y z
int
€€ 
depthInfoHeight
€€ #
=
€€$ %
(
€€& '
this
€€' +
.
€€+ ,
RenderHeight
€€, 8
+
€€9 :
	alignment
€€; D
-
€€E F
$num
€€G H
)
€€H I
>>
€€J L
DeferredConfig
€€M [
.
€€[ \-
kTileDepthInfoIntermediateLevel
€€\ {
;
€€{ |
cmd
‹‹ 
.
‹‹ 
SetGlobalVector
‹‹ #
(
‹‹# $
$str
‹‹$ 5
,
‹‹5 6
new
‹‹7 :
Vector4
‹‹; B
(
‹‹B C
depthInfoWidth
‹‹C Q
,
‹‹Q R
depthInfoHeight
‹‹S b
,
‹‹b c
$num
‹‹d h
/
‹‹i j
depthInfoWidth
‹‹k y
,
‹‹y z
$num
‹‹{ 
/‹‹Ä Å
depthInfoHeight‹‹Ç ë
)‹‹ë í
)‹‹í ì
;‹‹ì î
string
ﬁﬁ 
shaderVariant
ﬁﬁ $
=
ﬁﬁ% &
null
ﬁﬁ' +
;
ﬁﬁ+ ,
if
ﬂﬂ 
(
ﬂﬂ 
diffWidthLevel
ﬂﬂ "
==
ﬂﬂ# %
$num
ﬂﬂ& '
&&
ﬂﬂ( *
diffHeightLevel
ﬂﬂ+ :
==
ﬂﬂ; =
$num
ﬂﬂ> ?
)
ﬂﬂ? @
shaderVariant
‡‡ !
=
‡‡" #"
ShaderKeywordStrings
‡‡$ 8
.
‡‡8 9!
DOWNSAMPLING_SIZE_2
‡‡9 L
;
‡‡L M
else
·· 
if
·· 
(
·· 
diffWidthLevel
·· '
==
··( *
$num
··+ ,
&&
··- /
diffHeightLevel
··0 ?
==
··@ B
$num
··C D
)
··D E
shaderVariant
‚‚ !
=
‚‚" #"
ShaderKeywordStrings
‚‚$ 8
.
‚‚8 9!
DOWNSAMPLING_SIZE_4
‚‚9 L
;
‚‚L M
else
„„ 
if
„„ 
(
„„ 
diffWidthLevel
„„ '
==
„„( *
$num
„„+ ,
&&
„„- /
diffHeightLevel
„„0 ?
==
„„@ B
$num
„„C D
)
„„D E
shaderVariant
‰‰ !
=
‰‰" #"
ShaderKeywordStrings
‰‰$ 8
.
‰‰8 9!
DOWNSAMPLING_SIZE_8
‰‰9 L
;
‰‰L M
if
ÊÊ 
(
ÊÊ 
shaderVariant
ÊÊ !
!=
ÊÊ" $
null
ÊÊ% )
)
ÊÊ) *
cmd
ÁÁ 
.
ÁÁ !
EnableShaderKeyword
ÁÁ +
(
ÁÁ+ ,
shaderVariant
ÁÁ, 9
)
ÁÁ9 :
;
ÁÁ: ;
cmd
ÈÈ 
.
ÈÈ 
Blit
ÈÈ 
(
ÈÈ 
depthInfoSurface
ÈÈ )
,
ÈÈ) *"
tileDepthInfoSurface
ÈÈ+ ?
,
ÈÈ? @%
m_TileDepthInfoMaterial
ÈÈA X
,
ÈÈX Y
$num
ÈÈZ [
)
ÈÈ[ \
;
ÈÈ\ ]
if
ÎÎ 
(
ÎÎ 
shaderVariant
ÎÎ !
!=
ÎÎ" $
null
ÎÎ% )
)
ÎÎ) *
cmd
ÏÏ 
.
ÏÏ "
DisableShaderKeyword
ÏÏ ,
(
ÏÏ, -
shaderVariant
ÏÏ- :
)
ÏÏ: ;
;
ÏÏ; <
}
ÌÌ 
context
ÔÔ 
.
ÔÔ "
ExecuteCommandBuffer
ÔÔ (
(
ÔÔ( )
cmd
ÔÔ) ,
)
ÔÔ, -
;
ÔÔ- .
CommandBufferPool
 
.
 
Release
 %
(
% &
cmd
& )
)
) *
;
* +
}
ÒÒ 	
internal
ÛÛ 
void
ÛÛ !
ClearStencilPartial
ÛÛ )
(
ÛÛ) *
CommandBuffer
ÛÛ* 7
cmd
ÛÛ8 ;
)
ÛÛ; <
{
ÙÙ 	
if
ıı 
(
ıı 
m_FullscreenMesh
ıı  
==
ıı! #
null
ıı$ (
)
ıı( )
m_FullscreenMesh
ˆˆ  
=
ˆˆ! ""
CreateFullscreenMesh
ˆˆ# 7
(
ˆˆ7 8
)
ˆˆ8 9
;
ˆˆ9 :
using
¯¯ 
(
¯¯ 
new
¯¯ 
ProfilingScope
¯¯ %
(
¯¯% &
cmd
¯¯& )
,
¯¯) *7
)m_ProfilingSamplerClearStencilPartialPass
¯¯+ T
)
¯¯T U
)
¯¯U V
{
˘˘ 
cmd
˙˙ 
.
˙˙ 
DrawMesh
˙˙ 
(
˙˙ 
m_FullscreenMesh
˙˙ -
,
˙˙- .
	Matrix4x4
˙˙/ 8
.
˙˙8 9
identity
˙˙9 A
,
˙˙A B'
m_StencilDeferredMaterial
˙˙C \
,
˙˙\ ]
$num
˙˙^ _
,
˙˙_ `
$num
˙˙a b
)
˙˙b c
;
˙˙c d
}
˚˚ 
}
¸¸ 	
internal
˛˛ 
void
˛˛ !
ExecuteDeferredPass
˛˛ )
(
˛˛) *%
ScriptableRenderContext
˛˛* A
context
˛˛B I
,
˛˛I J
ref
˛˛K N
RenderingData
˛˛O \
renderingData
˛˛] j
)
˛˛j k
{
ˇˇ 	
CommandBuffer
ÄÄ 
cmd
ÄÄ 
=
ÄÄ 
CommandBufferPool
ÄÄ  1
.
ÄÄ1 2
Get
ÄÄ2 5
(
ÄÄ5 6
)
ÄÄ6 7
;
ÄÄ7 8
using
ÅÅ 
(
ÅÅ 
new
ÅÅ 
ProfilingScope
ÅÅ %
(
ÅÅ% &
cmd
ÅÅ& )
,
ÅÅ) *%
m_ProfilingDeferredPass
ÅÅ+ B
)
ÅÅB C
)
ÅÅC D
{
ÇÇ 
if
ÜÜ 
(
ÜÜ 
renderingData
ÜÜ !
.
ÜÜ! "
	lightData
ÜÜ" +
.
ÜÜ+ ,#
supportsMixedLighting
ÜÜ, A
&&
ÜÜB D
this
ÜÜE I
.
ÜÜI J 
MixedLightingSetup
ÜÜJ \
==
ÜÜ] _ 
MixedLightingSetup
ÜÜ` r
.
ÜÜr s
Subtractive
ÜÜs ~
)
ÜÜ~ 
cmd
áá 
.
áá !
EnableShaderKeyword
áá +
(
áá+ ,"
ShaderKeywordStrings
áá, @
.
áá@ A,
_DEFERRED_SUBTRACTIVE_LIGHTING
ááA _
)
áá_ `
;
áá` a"
SetupMatrixConstants
ää $
(
ää$ %
cmd
ää% (
,
ää( )
ref
ää* -
renderingData
ää. ;
)
ää; <
;
ää< =
RenderTileLights
åå  
(
åå  !
context
åå! (
,
åå( )
cmd
åå* -
,
åå- .
ref
åå/ 2
renderingData
åå3 @
)
åå@ A
;
ååA B!
RenderStencilLights
éé #
(
éé# $
context
éé$ +
,
éé+ ,
cmd
éé- 0
,
éé0 1
ref
éé2 5
renderingData
éé6 C
)
ééC D
;
ééD E
if
êê 
(
êê 
renderingData
êê !
.
êê! "
	lightData
êê" +
.
êê+ ,#
supportsMixedLighting
êê, A
&&
êêB D
this
êêE I
.
êêI J 
MixedLightingSetup
êêJ \
==
êê] _ 
MixedLightingSetup
êê` r
.
êêr s
Subtractive
êês ~
)
êê~ 
cmd
ëë 
.
ëë "
DisableShaderKeyword
ëë ,
(
ëë, -"
ShaderKeywordStrings
ëë- A
.
ëëA B,
_DEFERRED_SUBTRACTIVE_LIGHTING
ëëB `
)
ëë` a
;
ëëa b
	RenderFog
îî 
(
îî 
context
îî !
,
îî! "
cmd
îî# &
,
îî& '
ref
îî( +
renderingData
îî, 9
)
îî9 :
;
îî: ;
}
ïï 
context
óó 
.
óó "
ExecuteCommandBuffer
óó (
(
óó( )
cmd
óó) ,
)
óó, -
;
óó- .
CommandBufferPool
òò 
.
òò 
Release
òò %
(
òò% &
cmd
òò& )
)
òò) *
;
òò* +
}
ôô 	
void
úú '
SetupShaderLightConstants
úú &
(
úú& '
CommandBuffer
úú' 4
cmd
úú5 8
,
úú8 9
ref
úú: =
RenderingData
úú> K
renderingData
úúL Y
)
úúY Z
{
ùù 	%
SetupMainLightConstants
†† #
(
††# $
cmd
††$ '
,
††' (
ref
††) ,
renderingData
††- :
.
††: ;
	lightData
††; D
)
††D E
;
††E F
}
°° 	
void
§§ %
SetupMainLightConstants
§§ $
(
§§$ %
CommandBuffer
§§% 2
cmd
§§3 6
,
§§6 7
ref
§§8 ;
	LightData
§§< E
	lightData
§§F O
)
§§O P
{
•• 	
Vector4
¶¶ 
lightPos
¶¶ 
,
¶¶ 

lightColor
¶¶ (
,
¶¶( )
lightAttenuation
¶¶* :
,
¶¶: ;
lightSpotDir
¶¶< H
,
¶¶H I#
lightOcclusionChannel
¶¶J _
;
¶¶_ `%
UniversalRenderPipeline
ßß #
.
ßß# $-
InitializeLightConstants_Common
ßß$ C
(
ßßC D
	lightData
ßßD M
.
ßßM N
visibleLights
ßßN [
,
ßß[ \
	lightData
ßß] f
.
ßßf g
mainLightIndex
ßßg u
,
ßßu v
out
ßßw z
lightPosßß{ É
,ßßÉ Ñ
outßßÖ à

lightColorßßâ ì
,ßßì î
outßßï ò 
lightAttenuationßßô ©
,ßß© ™
outßß´ Æ
lightSpotDirßßØ ª
,ßßª º
outßßΩ ¿%
lightOcclusionChannelßß¡ ÷
)ßß÷ ◊
;ßß◊ ÿ
cmd
©© 
.
©© 
SetGlobalVector
©© 
(
©©  
ShaderConstants
©©  /
.
©©/ 0 
_MainLightPosition
©©0 B
,
©©B C
lightPos
©©D L
)
©©L M
;
©©M N
cmd
™™ 
.
™™ 
SetGlobalVector
™™ 
(
™™  
ShaderConstants
™™  /
.
™™/ 0
_MainLightColor
™™0 ?
,
™™? @

lightColor
™™A K
)
™™K L
;
™™L M
}
´´ 	
void
≠≠ "
SetupMatrixConstants
≠≠ !
(
≠≠! "
CommandBuffer
≠≠" /
cmd
≠≠0 3
,
≠≠3 4
ref
≠≠5 8
RenderingData
≠≠9 F
renderingData
≠≠G T
)
≠≠T U
{
ÆÆ 	
ref
ØØ 

CameraData
ØØ 

cameraData
ØØ %
=
ØØ& '
ref
ØØ( +
renderingData
ØØ, 9
.
ØØ9 :

cameraData
ØØ: D
;
ØØD E
int
≤≤ 
eyeCount
≤≤ 
=
≤≤ 

cameraData
≤≤ %
.
≤≤% &
xr
≤≤& (
.
≤≤( )
enabled
≤≤) 0
&&
≤≤1 3

cameraData
≤≤4 >
.
≤≤> ?
xr
≤≤? A
.
≤≤A B
singlePassEnabled
≤≤B S
?
≤≤T U
$num
≤≤V W
:
≤≤X Y
$num
≤≤Z [
;
≤≤[ \
	Matrix4x4
∂∂ 
[
∂∂ 
]
∂∂ 
screenToWorld
∂∂ %
=
∂∂& '
m_ScreenToWorld
∂∂( 7
;
∂∂7 8
for
∏∏ 
(
∏∏ 
int
∏∏ 
eyeIndex
∏∏ 
=
∏∏ 
$num
∏∏  !
;
∏∏! "
eyeIndex
∏∏# +
<
∏∏, -
eyeCount
∏∏. 6
;
∏∏6 7
eyeIndex
∏∏8 @
++
∏∏@ B
)
∏∏B C
{
ππ 
	Matrix4x4
∫∫ 
proj
∫∫ 
=
∫∫  

cameraData
∫∫! +
.
∫∫+ ,!
GetProjectionMatrix
∫∫, ?
(
∫∫? @
eyeIndex
∫∫@ H
)
∫∫H I
;
∫∫I J
	Matrix4x4
ªª 
view
ªª 
=
ªª  

cameraData
ªª! +
.
ªª+ ,
GetViewMatrix
ªª, 9
(
ªª9 :
eyeIndex
ªª: B
)
ªªB C
;
ªªC D
	Matrix4x4
ºº 
gpuProj
ºº !
=
ºº" #
GL
ºº$ &
.
ºº& '$
GetGPUProjectionMatrix
ºº' =
(
ºº= >
proj
ºº> B
,
ººB C
false
ººD I
)
ººI J
;
ººJ K
	Matrix4x4
øø 
toScreen
øø "
=
øø# $
new
øø% (
	Matrix4x4
øø) 2
(
øø2 3
new
¿¿ 
Vector4
¿¿ 
(
¿¿  
$num
¿¿  $
*
¿¿% &
this
¿¿' +
.
¿¿+ ,
RenderWidth
¿¿, 7
,
¿¿7 8
$num
¿¿9 =
,
¿¿= >
$num
¿¿? C
,
¿¿C D
$num
¿¿E I
)
¿¿I J
,
¿¿J K
new
¡¡ 
Vector4
¡¡ 
(
¡¡  
$num
¡¡  $
,
¡¡$ %
$num
¡¡& *
*
¡¡+ ,
this
¡¡- 1
.
¡¡1 2
RenderHeight
¡¡2 >
,
¡¡> ?
$num
¡¡@ D
,
¡¡D E
$num
¡¡F J
)
¡¡J K
,
¡¡K L
new
¬¬ 
Vector4
¬¬ 
(
¬¬  
$num
¬¬  $
,
¬¬$ %
$num
¬¬& *
,
¬¬* +
$num
¬¬, 0
,
¬¬0 1
$num
¬¬2 6
)
¬¬6 7
,
¬¬7 8
new
√√ 
Vector4
√√ 
(
√√  
$num
√√  $
*
√√% &
this
√√' +
.
√√+ ,
RenderWidth
√√, 7
,
√√7 8
$num
√√9 =
*
√√> ?
this
√√@ D
.
√√D E
RenderHeight
√√E Q
,
√√Q R
$num
√√S W
,
√√W X
$num
√√Y ]
)
√√] ^
)
ƒƒ 
;
ƒƒ 
	Matrix4x4
∆∆ 

zScaleBias
∆∆ $
=
∆∆% &
	Matrix4x4
∆∆' 0
.
∆∆0 1
identity
∆∆1 9
;
∆∆9 :
if
«« 
(
«« 
DeferredConfig
«« "
.
««" #
IsOpenGL
««# +
)
««+ ,
{
»» 

zScaleBias
   
=
    
new
  ! $
	Matrix4x4
  % .
(
  . /
new
ÀÀ 
Vector4
ÀÀ #
(
ÀÀ# $
$num
ÀÀ$ (
,
ÀÀ( )
$num
ÀÀ* .
,
ÀÀ. /
$num
ÀÀ0 4
,
ÀÀ4 5
$num
ÀÀ6 :
)
ÀÀ: ;
,
ÀÀ; <
new
ÃÃ 
Vector4
ÃÃ #
(
ÃÃ# $
$num
ÃÃ$ (
,
ÃÃ( )
$num
ÃÃ* .
,
ÃÃ. /
$num
ÃÃ0 4
,
ÃÃ4 5
$num
ÃÃ6 :
)
ÃÃ: ;
,
ÃÃ; <
new
ÕÕ 
Vector4
ÕÕ #
(
ÕÕ# $
$num
ÕÕ$ (
,
ÕÕ( )
$num
ÕÕ* .
,
ÕÕ. /
$num
ÕÕ0 4
,
ÕÕ4 5
$num
ÕÕ6 :
)
ÕÕ: ;
,
ÕÕ; <
new
ŒŒ 
Vector4
ŒŒ #
(
ŒŒ# $
$num
ŒŒ$ (
,
ŒŒ( )
$num
ŒŒ* .
,
ŒŒ. /
$num
ŒŒ0 4
,
ŒŒ4 5
$num
ŒŒ6 :
)
ŒŒ: ;
)
œœ 
;
œœ 
}
–– 
screenToWorld
““ 
[
““ 
eyeIndex
““ &
]
““& '
=
““( )
	Matrix4x4
““* 3
.
““3 4
Inverse
““4 ;
(
““; <
toScreen
““< D
*
““E F

zScaleBias
““G Q
*
““R S
gpuProj
““T [
*
““\ ]
view
““^ b
)
““b c
;
““c d
}
”” 
cmd
’’ 
.
’’ "
SetGlobalMatrixArray
’’ $
(
’’$ %
ShaderConstants
’’% 4
.
’’4 5
_ScreenToWorld
’’5 C
,
’’C D
screenToWorld
’’E R
)
’’R S
;
’’S T
}
÷÷ 	
void
ÿÿ 

SortLights
ÿÿ 
(
ÿÿ 
ref
ÿÿ 
NativeArray
ÿÿ '
<
ÿÿ' (
DeferredTiler
ÿÿ( 5
.
ÿÿ5 6
PrePunctualLight
ÿÿ6 F
>
ÿÿF G
prePunctualLights
ÿÿH Y
)
ÿÿY Z
{
ŸŸ 	
DeferredTiler
⁄⁄ 
.
⁄⁄ 
PrePunctualLight
⁄⁄ *
[
⁄⁄* +
]
⁄⁄+ ,
array
⁄⁄- 2
=
⁄⁄3 4
prePunctualLights
⁄⁄5 F
.
⁄⁄F G
ToArray
⁄⁄G N
(
⁄⁄N O
)
⁄⁄O P
;
⁄⁄P Q
System
€€ 
.
€€ 
Array
€€ 
.
€€ 
Sort
€€ 
<
€€ 
DeferredTiler
€€ +
.
€€+ ,
PrePunctualLight
€€, <
>
€€< =
(
€€= >
array
€€> C
,
€€C D
new
€€E H"
SortPrePunctualLight
€€I ]
(
€€] ^
)
€€^ _
)
€€_ `
;
€€` a
prePunctualLights
‹‹ 
.
‹‹ 
CopyFrom
‹‹ &
(
‹‹& '
array
‹‹' ,
)
‹‹, -
;
‹‹- .
}
›› 	
bool
ﬂﬂ  
CheckHasTileLights
ﬂﬂ 
(
ﬂﬂ  
ref
ﬂﬂ  #
NativeArray
ﬂﬂ$ /
<
ﬂﬂ/ 0
VisibleLight
ﬂﬂ0 <
>
ﬂﬂ< =
visibleLights
ﬂﬂ> K
)
ﬂﬂK L
{
‡‡ 	
for
·· 
(
·· 
int
·· 
visLightIndex
·· "
=
··# $
$num
··% &
;
··& '
visLightIndex
··( 5
<
··6 7
visibleLights
··8 E
.
··E F
Length
··F L
;
··L M
++
··N P
visLightIndex
··P ]
)
··] ^
{
‚‚ 
if
„„ 
(
„„ 
IsTileLight
„„ 
(
„„  
visibleLights
„„  -
[
„„- .
visLightIndex
„„. ;
]
„„; <
)
„„< =
)
„„= >
return
‰‰ 
true
‰‰ 
;
‰‰  
}
ÂÂ 
return
ÁÁ 
false
ÁÁ 
;
ÁÁ 
}
ËË 	
void
ÍÍ 
PrecomputeLights
ÍÍ 
(
ÍÍ 
out
ÍÍ !
NativeArray
ÍÍ" -
<
ÍÍ- .
DeferredTiler
ÍÍ. ;
.
ÍÍ; <
PrePunctualLight
ÍÍ< L
>
ÍÍL M
prePunctualLights
ÍÍN _
,
ÍÍ_ `
out
ÎÎ !
NativeArray
ÎÎ" -
<
ÎÎ- .
ushort
ÎÎ. 4
>
ÎÎ4 5
stencilVisLights
ÎÎ6 F
,
ÎÎF G
out
ÏÏ !
NativeArray
ÏÏ" -
<
ÏÏ- .
ushort
ÏÏ. 4
>
ÏÏ4 5$
stencilVisLightOffsets
ÏÏ6 L
,
ÏÏL M
ref
ÌÌ !
NativeArray
ÌÌ" -
<
ÌÌ- .
VisibleLight
ÌÌ. :
>
ÌÌ: ;
visibleLights
ÌÌ< I
,
ÌÌI J
bool
ÓÓ "!
hasAdditionalLights
ÓÓ# 6
,
ÓÓ6 7
	Matrix4x4
ÔÔ '
view
ÔÔ( ,
,
ÔÔ, -
bool
 "
isOrthographic
# 1
,
1 2
float
ÒÒ #
zNear
ÒÒ$ )
)
ÒÒ) *
{
ÚÚ 	
const
ÛÛ 
int
ÛÛ 
lightTypeCount
ÛÛ $
=
ÛÛ% &
(
ÛÛ' (
int
ÛÛ( +
)
ÛÛ+ ,
	LightType
ÛÛ, 5
.
ÛÛ5 6
Disc
ÛÛ6 :
+
ÛÛ; <
$num
ÛÛ= >
;
ÛÛ> ?
if
ıı 
(
ıı 
!
ıı !
hasAdditionalLights
ıı $
)
ıı$ %
{
ˆˆ 
prePunctualLights
˜˜ !
=
˜˜" #
new
˜˜$ '
NativeArray
˜˜( 3
<
˜˜3 4
DeferredTiler
˜˜4 A
.
˜˜A B
PrePunctualLight
˜˜B R
>
˜˜R S
(
˜˜S T
$num
˜˜T U
,
˜˜U V
	Allocator
˜˜W `
.
˜˜` a
Temp
˜˜a e
,
˜˜e f 
NativeArrayOptions
˜˜g y
.
˜˜y z"
UninitializedMemory˜˜z ç
)˜˜ç é
;˜˜é è
stencilVisLights
¯¯  
=
¯¯! "
new
¯¯# &
NativeArray
¯¯' 2
<
¯¯2 3
ushort
¯¯3 9
>
¯¯9 :
(
¯¯: ;
$num
¯¯; <
,
¯¯< =
	Allocator
¯¯> G
.
¯¯G H
Temp
¯¯H L
,
¯¯L M 
NativeArrayOptions
¯¯N `
.
¯¯` a!
UninitializedMemory
¯¯a t
)
¯¯t u
;
¯¯u v$
stencilVisLightOffsets
˘˘ &
=
˘˘' (
new
˘˘) ,
NativeArray
˘˘- 8
<
˘˘8 9
ushort
˘˘9 ?
>
˘˘? @
(
˘˘@ A
lightTypeCount
˘˘A O
,
˘˘O P
	Allocator
˘˘Q Z
.
˘˘Z [
Temp
˘˘[ _
,
˘˘_ ` 
NativeArrayOptions
˘˘a s
.
˘˘s t"
UninitializedMemory˘˘t á
)˘˘á à
;˘˘à â
return
˙˙ 
;
˙˙ 
}
˚˚ 
NativeArray
˛˛ 
<
˛˛ 
int
˛˛ 
>
˛˛ 
tileLightOffsets
˛˛ -
=
˛˛. /
new
˛˛0 3
NativeArray
˛˛4 ?
<
˛˛? @
int
˛˛@ C
>
˛˛C D
(
˛˛D E
lightTypeCount
˛˛E S
,
˛˛S T
	Allocator
˛˛U ^
.
˛˛^ _
Temp
˛˛_ c
,
˛˛c d 
NativeArrayOptions
˛˛e w
.
˛˛w x
ClearMemory˛˛x É
)˛˛É Ñ
;˛˛Ñ Ö
NativeArray
ˇˇ 
<
ˇˇ 
int
ˇˇ 
>
ˇˇ 
tileLightCounts
ˇˇ ,
=
ˇˇ- .
new
ˇˇ/ 2
NativeArray
ˇˇ3 >
<
ˇˇ> ?
int
ˇˇ? B
>
ˇˇB C
(
ˇˇC D
lightTypeCount
ˇˇD R
,
ˇˇR S
	Allocator
ˇˇT ]
.
ˇˇ] ^
Temp
ˇˇ^ b
,
ˇˇb c 
NativeArrayOptions
ˇˇd v
.
ˇˇv w
ClearMemoryˇˇw Ç
)ˇˇÇ É
;ˇˇÉ Ñ
NativeArray
Ä	Ä	 
<
Ä	Ä	 
int
Ä	Ä	 
>
Ä	Ä	  
stencilLightCounts
Ä	Ä	 /
=
Ä	Ä	0 1
new
Ä	Ä	2 5
NativeArray
Ä	Ä	6 A
<
Ä	Ä	A B
int
Ä	Ä	B E
>
Ä	Ä	E F
(
Ä	Ä	F G
lightTypeCount
Ä	Ä	G U
,
Ä	Ä	U V
	Allocator
Ä	Ä	W `
.
Ä	Ä	` a
Temp
Ä	Ä	a e
,
Ä	Ä	e f 
NativeArrayOptions
Ä	Ä	g y
.
Ä	Ä	y z
ClearMemoryÄ	Ä	z Ö
)Ä	Ä	Ö Ü
;Ä	Ä	Ü á$
stencilVisLightOffsets
Å	Å	 "
=
Å	Å	# $
new
Å	Å	% (
NativeArray
Å	Å	) 4
<
Å	Å	4 5
ushort
Å	Å	5 ;
>
Å	Å	; <
(
Å	Å	< =
lightTypeCount
Å	Å	= K
,
Å	Å	K L
	Allocator
Å	Å	M V
.
Å	Å	V W
Temp
Å	Å	W [
,
Å	Å	[ \ 
NativeArrayOptions
Å	Å	] o
.
Å	Å	o p
ClearMemory
Å	Å	p {
)
Å	Å	{ |
;
Å	Å	| }
for
Ñ	Ñ	 
(
Ñ	Ñ	 
ushort
Ñ	Ñ	 
visLightIndex
Ñ	Ñ	 %
=
Ñ	Ñ	& '
$num
Ñ	Ñ	( )
;
Ñ	Ñ	) *
visLightIndex
Ñ	Ñ	+ 8
<
Ñ	Ñ	9 :
visibleLights
Ñ	Ñ	; H
.
Ñ	Ñ	H I
Length
Ñ	Ñ	I O
;
Ñ	Ñ	O P
++
Ñ	Ñ	Q S
visLightIndex
Ñ	Ñ	S `
)
Ñ	Ñ	` a
{
Ö	Ö	 
VisibleLight
Ü	Ü	 
vl
Ü	Ü	 
=
Ü	Ü	  !
visibleLights
Ü	Ü	" /
[
Ü	Ü	/ 0
visLightIndex
Ü	Ü	0 =
]
Ü	Ü	= >
;
Ü	Ü	> ?
if
à	à	 
(
à	à	 
this
à	à	 
.
à	à	 "
TiledDeferredShading
à	à	 -
&&
à	à	. 0
IsTileLight
à	à	1 <
(
à	à	< =
vl
à	à	= ?
)
à	à	? @
)
à	à	@ A
++
â	â	 
tileLightOffsets
â	â	 &
[
â	â	& '
(
â	â	' (
int
â	â	( +
)
â	â	+ ,
vl
â	â	, .
.
â	â	. /
	lightType
â	â	/ 8
]
â	â	8 9
;
â	â	9 :
else
ä	ä	 
++
ã	ã	 $
stencilVisLightOffsets
ã	ã	 ,
[
ã	ã	, -
(
ã	ã	- .
int
ã	ã	. 1
)
ã	ã	1 2
vl
ã	ã	2 4
.
ã	ã	4 5
	lightType
ã	ã	5 >
]
ã	ã	> ?
;
ã	ã	? @
}
å	å	 
int
é	é	 !
totalTileLightCount
é	é	 #
=
é	é	$ %
tileLightOffsets
é	é	& 6
[
é	é	6 7
(
é	é	7 8
int
é	é	8 ;
)
é	é	; <
	LightType
é	é	< E
.
é	é	E F
Point
é	é	F K
]
é	é	K L
+
é	é	M N
tileLightOffsets
é	é	O _
[
é	é	_ `
(
é	é	` a
int
é	é	a d
)
é	é	d e
	LightType
é	é	e n
.
é	é	n o
Spot
é	é	o s
]
é	é	s t
;
é	é	t u
int
è	è	 $
totalStencilLightCount
è	è	 &
=
è	è	' ($
stencilVisLightOffsets
è	è	) ?
[
è	è	? @
(
è	è	@ A
int
è	è	A D
)
è	è	D E
	LightType
è	è	E N
.
è	è	N O
Spot
è	è	O S
]
è	è	S T
+
è	è	U V$
stencilVisLightOffsets
è	è	W m
[
è	è	m n
(
è	è	n o
int
è	è	o r
)
è	è	r s
	LightType
è	è	s |
.
è	è	| }
Directionalè	è	} à
]è	è	à â
+è	è	ä ã&
stencilVisLightOffsetsè	è	å ¢
[è	è	¢ £
(è	è	£ §
intè	è	§ ß
)è	è	ß ®
	LightTypeè	è	® ±
.è	è	± ≤
Pointè	è	≤ ∑
]è	è	∑ ∏
;è	è	∏ π
prePunctualLights
ê	ê	 
=
ê	ê	 
new
ê	ê	  #
NativeArray
ê	ê	$ /
<
ê	ê	/ 0
DeferredTiler
ê	ê	0 =
.
ê	ê	= >
PrePunctualLight
ê	ê	> N
>
ê	ê	N O
(
ê	ê	O P!
totalTileLightCount
ê	ê	P c
,
ê	ê	c d
	Allocator
ê	ê	e n
.
ê	ê	n o
Temp
ê	ê	o s
,
ê	ê	s t!
NativeArrayOptionsê	ê	u á
.ê	ê	á à#
UninitializedMemoryê	ê	à õ
)ê	ê	õ ú
;ê	ê	ú ù
stencilVisLights
ë	ë	 
=
ë	ë	 
new
ë	ë	 "
NativeArray
ë	ë	# .
<
ë	ë	. /
ushort
ë	ë	/ 5
>
ë	ë	5 6
(
ë	ë	6 7$
totalStencilLightCount
ë	ë	7 M
,
ë	ë	M N
	Allocator
ë	ë	O X
.
ë	ë	X Y
Temp
ë	ë	Y ]
,
ë	ë	] ^ 
NativeArrayOptions
ë	ë	_ q
.
ë	ë	q r"
UninitializedMemoryë	ë	r Ö
)ë	ë	Ö Ü
;ë	ë	Ü á
for
î	î	 
(
î	î	 
int
î	î	 
i
î	î	 
=
î	î	 
$num
î	î	 
,
î	î	 
toffset
î	î	 #
=
î	î	$ %
$num
î	î	& '
;
î	î	' (
i
î	î	) *
<
î	î	+ ,
tileLightOffsets
î	î	- =
.
î	î	= >
Length
î	î	> D
;
î	î	D E
++
î	î	F H
i
î	î	H I
)
î	î	I J
{
ï	ï	 
int
ñ	ñ	 
c
ñ	ñ	 
=
ñ	ñ	 
tileLightOffsets
ñ	ñ	 (
[
ñ	ñ	( )
i
ñ	ñ	) *
]
ñ	ñ	* +
;
ñ	ñ	+ ,
tileLightOffsets
ó	ó	  
[
ó	ó	  !
i
ó	ó	! "
]
ó	ó	" #
=
ó	ó	$ %
toffset
ó	ó	& -
;
ó	ó	- .
toffset
ò	ò	 
+=
ò	ò	 
c
ò	ò	 
;
ò	ò	 
}
ô	ô	 
for
ö	ö	 
(
ö	ö	 
int
ö	ö	 
i
ö	ö	 
=
ö	ö	 
$num
ö	ö	 
,
ö	ö	 
soffset
ö	ö	 #
=
ö	ö	$ %
$num
ö	ö	& '
;
ö	ö	' (
i
ö	ö	) *
<
ö	ö	+ ,$
stencilVisLightOffsets
ö	ö	- C
.
ö	ö	C D
Length
ö	ö	D J
;
ö	ö	J K
++
ö	ö	L N
i
ö	ö	N O
)
ö	ö	O P
{
õ	õ	 
int
ú	ú	 
c
ú	ú	 
=
ú	ú	 $
stencilVisLightOffsets
ú	ú	 .
[
ú	ú	. /
i
ú	ú	/ 0
]
ú	ú	0 1
;
ú	ú	1 2$
stencilVisLightOffsets
ù	ù	 &
[
ù	ù	& '
i
ù	ù	' (
]
ù	ù	( )
=
ù	ù	* +
(
ù	ù	, -
ushort
ù	ù	- 3
)
ù	ù	3 4
soffset
ù	ù	4 ;
;
ù	ù	; <
soffset
û	û	 
+=
û	û	 
c
û	û	 
;
û	û	 
}
ü	ü	 
for
¢	¢	 
(
¢	¢	 
ushort
¢	¢	 
visLightIndex
¢	¢	 %
=
¢	¢	& '
$num
¢	¢	( )
;
¢	¢	) *
visLightIndex
¢	¢	+ 8
<
¢	¢	9 :
visibleLights
¢	¢	; H
.
¢	¢	H I
Length
¢	¢	I O
;
¢	¢	O P
++
¢	¢	Q S
visLightIndex
¢	¢	S `
)
¢	¢	` a
{
£	£	 
VisibleLight
§	§	 
vl
§	§	 
=
§	§	  !
visibleLights
§	§	" /
[
§	§	/ 0
visLightIndex
§	§	0 =
]
§	§	= >
;
§	§	> ?
if
¶	¶	 
(
¶	¶	 
this
¶	¶	 
.
¶	¶	 "
TiledDeferredShading
¶	¶	 -
&&
¶	¶	. 0
IsTileLight
¶	¶	1 <
(
¶	¶	< =
vl
¶	¶	= ?
)
¶	¶	? @
)
¶	¶	@ A
{
ß	ß	 
DeferredTiler
®	®	 !
.
®	®	! "
PrePunctualLight
®	®	" 2
ppl
®	®	3 6
;
®	®	6 7
ppl
©	©	 
.
©	©	 
posVS
©	©	 
=
©	©	 
view
©	©	  $
.
©	©	$ %
MultiplyPoint
©	©	% 2
(
©	©	2 3
vl
©	©	3 5
.
©	©	5 6 
localToWorldMatrix
©	©	6 H
.
©	©	H I
	GetColumn
©	©	I R
(
©	©	R S
$num
©	©	S T
)
©	©	T U
)
©	©	U V
;
©	©	V W
ppl
™	™	 
.
™	™	 
radius
™	™	 
=
™	™	  
vl
™	™	! #
.
™	™	# $
range
™	™	$ )
;
™	™	) *
ppl
´	´	 
.
´	´	 
minDist
´	´	 
=
´	´	  !
max
´	´	" %
(
´	´	% &
$num
´	´	& *
,
´	´	* +
length
´	´	, 2
(
´	´	2 3
ppl
´	´	3 6
.
´	´	6 7
posVS
´	´	7 <
)
´	´	< =
-
´	´	> ?
ppl
´	´	@ C
.
´	´	C D
radius
´	´	D J
)
´	´	J K
;
´	´	K L
ppl
≠	≠	 
.
≠	≠	 
	screenPos
≠	≠	 !
=
≠	≠	" #
new
≠	≠	$ '
Vector2
≠	≠	( /
(
≠	≠	/ 0
ppl
≠	≠	0 3
.
≠	≠	3 4
posVS
≠	≠	4 9
.
≠	≠	9 :
x
≠	≠	: ;
,
≠	≠	; <
ppl
≠	≠	= @
.
≠	≠	@ A
posVS
≠	≠	A F
.
≠	≠	F G
y
≠	≠	G H
)
≠	≠	H I
;
≠	≠	I J
if
Ø	Ø	 
(
Ø	Ø	 
!
Ø	Ø	 
isOrthographic
Ø	Ø	 '
&&
Ø	Ø	( *
ppl
Ø	Ø	+ .
.
Ø	Ø	. /
posVS
Ø	Ø	/ 4
.
Ø	Ø	4 5
z
Ø	Ø	5 6
<=
Ø	Ø	7 9
zNear
Ø	Ø	: ?
)
Ø	Ø	? @
ppl
∞	∞	 
.
∞	∞	 
	screenPos
∞	∞	 %
=
∞	∞	& '
ppl
∞	∞	( +
.
∞	∞	+ ,
	screenPos
∞	∞	, 5
*
∞	∞	6 7
(
∞	∞	8 9
-
∞	∞	9 :
zNear
∞	∞	: ?
/
∞	∞	@ A
ppl
∞	∞	B E
.
∞	∞	E F
posVS
∞	∞	F K
.
∞	∞	K L
z
∞	∞	L M
)
∞	∞	M N
;
∞	∞	N O
ppl
≤	≤	 
.
≤	≤	 
visLightIndex
≤	≤	 %
=
≤	≤	& '
visLightIndex
≤	≤	( 5
;
≤	≤	5 6
int
¥	¥	 
i
¥	¥	 
=
¥	¥	 
tileLightCounts
¥	¥	 +
[
¥	¥	+ ,
(
¥	¥	, -
int
¥	¥	- 0
)
¥	¥	0 1
vl
¥	¥	1 3
.
¥	¥	3 4
	lightType
¥	¥	4 =
]
¥	¥	= >
++
¥	¥	> @
;
¥	¥	@ A
prePunctualLights
µ	µ	 %
[
µ	µ	% &
tileLightOffsets
µ	µ	& 6
[
µ	µ	6 7
(
µ	µ	7 8
int
µ	µ	8 ;
)
µ	µ	; <
vl
µ	µ	< >
.
µ	µ	> ?
	lightType
µ	µ	? H
]
µ	µ	H I
+
µ	µ	J K
i
µ	µ	L M
]
µ	µ	M N
=
µ	µ	O P
ppl
µ	µ	Q T
;
µ	µ	T U
}
∂	∂	 
else
∑	∑	 
{
∏	∏	 
int
∫	∫	 
i
∫	∫	 
=
∫	∫	  
stencilLightCounts
∫	∫	 .
[
∫	∫	. /
(
∫	∫	/ 0
int
∫	∫	0 3
)
∫	∫	3 4
vl
∫	∫	4 6
.
∫	∫	6 7
	lightType
∫	∫	7 @
]
∫	∫	@ A
++
∫	∫	A C
;
∫	∫	C D
stencilVisLights
ª	ª	 $
[
ª	ª	$ %$
stencilVisLightOffsets
ª	ª	% ;
[
ª	ª	; <
(
ª	ª	< =
int
ª	ª	= @
)
ª	ª	@ A
vl
ª	ª	A C
.
ª	ª	C D
	lightType
ª	ª	D M
]
ª	ª	M N
+
ª	ª	O P
i
ª	ª	Q R
]
ª	ª	R S
=
ª	ª	T U
visLightIndex
ª	ª	V c
;
ª	ª	c d
}
º	º	 
}
Ω	Ω	 
tileLightOffsets
æ	æ	 
.
æ	æ	 
Dispose
æ	æ	 $
(
æ	æ	$ %
)
æ	æ	% &
;
æ	æ	& '
tileLightCounts
ø	ø	 
.
ø	ø	 
Dispose
ø	ø	 #
(
ø	ø	# $
)
ø	ø	$ %
;
ø	ø	% & 
stencilLightCounts
¿	¿	 
.
¿	¿	 
Dispose
¿	¿	 &
(
¿	¿	& '
)
¿	¿	' (
;
¿	¿	( )
}
¡	¡	 	
void
√	√	 
RenderTileLights
√	√	 
(
√	√	 %
ScriptableRenderContext
√	√	 5
context
√	√	6 =
,
√	√	= >
CommandBuffer
√	√	? L
cmd
√	√	M P
,
√	√	P Q
ref
√	√	R U
RenderingData
√	√	V c
renderingData
√	√	d q
)
√	√	q r
{
ƒ	ƒ	 	
if
≈	≈	 
(
≈	≈	 
!
≈	≈	  
m_HasTileVisLights
≈	≈	 #
)
≈	≈	# $
return
∆	∆	 
;
∆	∆	 
if
»	»	 
(
»	»	 $
m_TileDeferredMaterial
»	»	 &
==
»	»	' )
null
»	»	* .
)
»	»	. /
{
…	…	 
Debug
 	 	 
.
 	 	 
LogErrorFormat
 	 	 $
(
 	 	$ %
$str 	 	% å
, 	 	å ç&
m_TileDeferredMaterial 	 	é §
, 	 	§ •
GetType 	 	¶ ≠
( 	 	≠ Æ
) 	 	Æ Ø
. 	 	Ø ∞
Name 	 	∞ ¥
) 	 	¥ µ
; 	 	µ ∂
return
À	À	 
;
À	À	 
}
Ã	Ã	 
Profiler
Œ	Œ	 
.
Œ	Œ	 
BeginSample
Œ	Œ	  
(
Œ	Œ	  !!
k_DeferredTiledPass
Œ	Œ	! 4
)
Œ	Œ	4 5
;
Œ	Œ	5 6
DrawCall
—	—	 
[
—	—	 
]
—	—	 
	drawCalls
—	—	  
=
—	—	! "
new
—	—	# &
DrawCall
—	—	' /
[
—	—	/ 0
$num
—	—	0 3
]
—	—	3 4
;
—	—	4 5
int
“	“	 
drawCallCount
“	“	 
=
“	“	 
$num
“	“	  !
;
“	“	! "
{
‘	‘	 
ref
’	’	 
DeferredTiler
’	’	 !
tiler
’	’	" '
=
’	’	( )
ref
’	’	* -
m_Tilers
’	’	. 6
[
’	’	6 7
$num
’	’	7 8
]
’	’	8 9
;
’	’	9 :
int
◊	◊	 
sizeof_TileData
◊	◊	 #
=
◊	◊	$ %
$num
◊	◊	& (
;
◊	◊	( )
int
ÿ	ÿ	 "
sizeof_vec4_TileData
ÿ	ÿ	 (
=
ÿ	ÿ	) *
sizeof_TileData
ÿ	ÿ	+ :
>>
ÿ	ÿ	; =
$num
ÿ	ÿ	> ?
;
ÿ	ÿ	? @
int
Ÿ	Ÿ	 &
sizeof_PunctualLightData
Ÿ	Ÿ	 ,
=
Ÿ	Ÿ	- .
System
Ÿ	Ÿ	/ 5
.
Ÿ	Ÿ	5 6
Runtime
Ÿ	Ÿ	6 =
.
Ÿ	Ÿ	= >
InteropServices
Ÿ	Ÿ	> M
.
Ÿ	Ÿ	M N
Marshal
Ÿ	Ÿ	N U
.
Ÿ	Ÿ	U V
SizeOf
Ÿ	Ÿ	V \
(
Ÿ	Ÿ	\ ]
typeof
Ÿ	Ÿ	] c
(
Ÿ	Ÿ	c d
PunctualLightData
Ÿ	Ÿ	d u
)
Ÿ	Ÿ	u v
)
Ÿ	Ÿ	v w
;
Ÿ	Ÿ	w x
int
⁄	⁄	 +
sizeof_vec4_PunctualLightData
⁄	⁄	 1
=
⁄	⁄	2 3&
sizeof_PunctualLightData
⁄	⁄	4 L
>>
⁄	⁄	M O
$num
⁄	⁄	P Q
;
⁄	⁄	Q R
int
‹	‹	 

tileXCount
‹	‹	 
=
‹	‹	  
tiler
‹	‹	! &
.
‹	‹	& '

TileXCount
‹	‹	' 1
;
‹	‹	1 2
int
›	›	 

tileYCount
›	›	 
=
›	›	  
tiler
›	›	! &
.
›	›	& '

TileYCount
›	›	' 1
;
›	›	1 2
int
ﬁ	ﬁ	 
maxLightPerTile
ﬁ	ﬁ	 #
=
ﬁ	ﬁ	$ %
tiler
ﬁ	ﬁ	& +
.
ﬁ	ﬁ	+ ,
MaxLightPerTile
ﬁ	ﬁ	, ;
;
ﬁ	ﬁ	; <
NativeArray
ﬂ	ﬂ	 
<
ﬂ	ﬂ	 
ushort
ﬂ	ﬂ	 "
>
ﬂ	ﬂ	" #
tiles
ﬂ	ﬂ	$ )
=
ﬂ	ﬂ	* +
tiler
ﬂ	ﬂ	, 1
.
ﬂ	ﬂ	1 2
Tiles
ﬂ	ﬂ	2 7
;
ﬂ	ﬂ	7 8
NativeArray
‡	‡	 
<
‡	‡	 
uint
‡	‡	  
>
‡	‡	  !
tileHeaders
‡	‡	" -
=
‡	‡	. /
tiler
‡	‡	0 5
.
‡	‡	5 6
TileHeaders
‡	‡	6 A
;
‡	‡	A B
int
‚	‚	 
instanceOffset
‚	‚	 "
=
‚	‚	# $
$num
‚	‚	% &
;
‚	‚	& '
int
„	„	 
	tileCount
„	„	 
=
„	„	 
$num
„	„	  !
;
„	„	! "
int
‰	‰	 

lightCount
‰	‰	 
=
‰	‰	  
$num
‰	‰	! "
;
‰	‰	" #
int
Â	Â	 
relLightIndices
Â	Â	 #
=
Â	Â	$ %
$num
Â	Â	& '
;
Â	Â	' (
ComputeBuffer
Á	Á	 
	_tileList
Á	Á	 '
=
Á	Á	( ) 
DeferredShaderData
Á	Á	* <
.
Á	Á	< =
instance
Á	Á	= E
.
Á	Á	E F
ReserveBuffer
Á	Á	F S
<
Á	Á	S T
TileData
Á	Á	T \
>
Á	Á	\ ]
(
Á	Á	] ^ 
m_MaxTilesPerBatch
Á	Á	^ p
,
Á	Á	p q
DeferredConfigÁ	Á	r Ä
.Á	Á	Ä Å%
UseCBufferForTileListÁ	Á	Å ñ
)Á	Á	ñ ó
;Á	Á	ó ò
ComputeBuffer
Ë	Ë	 "
_punctualLightBuffer
Ë	Ë	 2
=
Ë	Ë	3 4 
DeferredShaderData
Ë	Ë	5 G
.
Ë	Ë	G H
instance
Ë	Ë	H P
.
Ë	Ë	P Q
ReserveBuffer
Ë	Ë	Q ^
<
Ë	Ë	^ _
PunctualLightData
Ë	Ë	_ p
>
Ë	Ë	p q
(
Ë	Ë	q r)
m_MaxPunctualLightPerBatchË	Ë	r å
,Ë	Ë	å ç
DeferredConfigË	Ë	é ú
.Ë	Ë	ú ù&
UseCBufferForLightDataË	Ë	ù ≥
)Ë	Ë	≥ ¥
;Ë	Ë	¥ µ
ComputeBuffer
È	È	 
_relLightList
È	È	 +
=
È	È	, - 
DeferredShaderData
È	È	. @
.
È	È	@ A
instance
È	È	A I
.
È	È	I J
ReserveBuffer
È	È	J W
<
È	È	W X
uint
È	È	X \
>
È	È	\ ]
(
È	È	] ^*
m_MaxRelLightIndicesPerBatch
È	È	^ z
,
È	È	z {
DeferredConfigÈ	È	| ä
.È	È	ä ã&
UseCBufferForLightListÈ	È	ã °
)È	È	° ¢
;È	È	¢ £
NativeArray
Î	Î	 
<
Î	Î	 
uint4
Î	Î	 !
>
Î	Î	! "
tileList
Î	Î	# +
=
Î	Î	, -
new
Î	Î	. 1
NativeArray
Î	Î	2 =
<
Î	Î	= >
uint4
Î	Î	> C
>
Î	Î	C D
(
Î	Î	D E 
m_MaxTilesPerBatch
Î	Î	E W
*
Î	Î	X Y"
sizeof_vec4_TileData
Î	Î	Z n
,
Î	Î	n o
	Allocator
Î	Î	p y
.
Î	Î	y z
Temp
Î	Î	z ~
,
Î	Î	~ "
NativeArrayOptionsÎ	Î	Ä í
.Î	Î	í ì#
UninitializedMemoryÎ	Î	ì ¶
)Î	Î	¶ ß
;Î	Î	ß ®
NativeArray
Ï	Ï	 
<
Ï	Ï	 
uint4
Ï	Ï	 !
>
Ï	Ï	! "!
punctualLightBuffer
Ï	Ï	# 6
=
Ï	Ï	7 8
new
Ï	Ï	9 <
NativeArray
Ï	Ï	= H
<
Ï	Ï	H I
uint4
Ï	Ï	I N
>
Ï	Ï	N O
(
Ï	Ï	O P(
m_MaxPunctualLightPerBatch
Ï	Ï	P j
*
Ï	Ï	k l,
sizeof_vec4_PunctualLightDataÏ	Ï	m ä
,Ï	Ï	ä ã
	AllocatorÏ	Ï	å ï
.Ï	Ï	ï ñ
TempÏ	Ï	ñ ö
,Ï	Ï	ö õ"
NativeArrayOptionsÏ	Ï	ú Æ
.Ï	Ï	Æ Ø#
UninitializedMemoryÏ	Ï	Ø ¬
)Ï	Ï	¬ √
;Ï	Ï	√ ƒ
NativeArray
Ì	Ì	 
<
Ì	Ì	 
uint
Ì	Ì	  
>
Ì	Ì	  !
relLightList
Ì	Ì	" .
=
Ì	Ì	/ 0
new
Ì	Ì	1 4
NativeArray
Ì	Ì	5 @
<
Ì	Ì	@ A
uint
Ì	Ì	A E
>
Ì	Ì	E F
(
Ì	Ì	F G*
m_MaxRelLightIndicesPerBatch
Ì	Ì	G c
,
Ì	Ì	c d
	Allocator
Ì	Ì	e n
.
Ì	Ì	n o
Temp
Ì	Ì	o s
,
Ì	Ì	s t!
NativeArrayOptionsÌ	Ì	u á
.Ì	Ì	á à#
UninitializedMemoryÌ	Ì	à õ
)Ì	Ì	õ ú
;Ì	Ì	ú ù
NativeArray
		 
<
		 
ushort
		 "
>
		" #
trimmedLights
		$ 1
=
		2 3
new
		4 7
NativeArray
		8 C
<
		C D
ushort
		D J
>
		J K
(
		K L
maxLightPerTile
		L [
,
		[ \
	Allocator
		] f
.
		f g
Temp
		g k
,
		k l 
NativeArrayOptions
		m 
.		 Ä#
UninitializedMemory		Ä ì
)		ì î
;		î ï
NativeArray
Ò	Ò	 
<
Ò	Ò	 
ushort
Ò	Ò	 "
>
Ò	Ò	" #!
visLightToRelLights
Ò	Ò	$ 7
=
Ò	Ò	8 9
new
Ò	Ò	: =
NativeArray
Ò	Ò	> I
<
Ò	Ò	I J
ushort
Ò	Ò	J P
>
Ò	Ò	P Q
(
Ò	Ò	Q R
renderingData
Ò	Ò	R _
.
Ò	Ò	_ `
	lightData
Ò	Ò	` i
.
Ò	Ò	i j
visibleLights
Ò	Ò	j w
.
Ò	Ò	w x
Length
Ò	Ò	x ~
,
Ò	Ò	~ 
	AllocatorÒ	Ò	Ä â
.Ò	Ò	â ä
TempÒ	Ò	ä é
,Ò	Ò	é è"
NativeArrayOptionsÒ	Ò	ê ¢
.Ò	Ò	¢ £#
UninitializedMemoryÒ	Ò	£ ∂
)Ò	Ò	∂ ∑
;Ò	Ò	∑ ∏
BitArray
Ú	Ú	 

usedLights
Ú	Ú	 #
=
Ú	Ú	$ %
new
Ú	Ú	& )
BitArray
Ú	Ú	* 2
(
Ú	Ú	2 3
renderingData
Ú	Ú	3 @
.
Ú	Ú	@ A
	lightData
Ú	Ú	A J
.
Ú	Ú	J K
visibleLights
Ú	Ú	K X
.
Ú	Ú	X Y
Length
Ú	Ú	Y _
,
Ú	Ú	_ `
	Allocator
Ú	Ú	a j
.
Ú	Ú	j k
Temp
Ú	Ú	k o
,
Ú	Ú	o p!
NativeArrayOptionsÚ	Ú	q É
.Ú	Ú	É Ñ
ClearMemoryÚ	Ú	Ñ è
)Ú	Ú	è ê
;Ú	Ú	ê ë
for
Ù	Ù	 
(
Ù	Ù	 
int
Ù	Ù	 
j
Ù	Ù	 
=
Ù	Ù	 
$num
Ù	Ù	 
;
Ù	Ù	 
j
Ù	Ù	  !
<
Ù	Ù	" #

tileYCount
Ù	Ù	$ .
;
Ù	Ù	. /
++
Ù	Ù	0 2
j
Ù	Ù	2 3
)
Ù	Ù	3 4
{
ı	ı	 
for
ˆ	ˆ	 
(
ˆ	ˆ	 
int
ˆ	ˆ	 
i
ˆ	ˆ	 
=
ˆ	ˆ	  
$num
ˆ	ˆ	! "
;
ˆ	ˆ	" #
i
ˆ	ˆ	$ %
<
ˆ	ˆ	& '

tileXCount
ˆ	ˆ	( 2
;
ˆ	ˆ	2 3
++
ˆ	ˆ	4 6
i
ˆ	ˆ	6 7
)
ˆ	ˆ	7 8
{
˜	˜	 
int
¯	¯	 

tileOffset
¯	¯	 &
;
¯	¯	& '
int
˘	˘	 
tileLightCount
˘	˘	 *
;
˘	˘	* +
tiler
˙	˙	 
.
˙	˙	 #
GetTileOffsetAndCount
˙	˙	 3
(
˙	˙	3 4
i
˙	˙	4 5
,
˙	˙	5 6
j
˙	˙	7 8
,
˙	˙	8 9
out
˙	˙	: =

tileOffset
˙	˙	> H
,
˙	˙	H I
out
˙	˙	J M
tileLightCount
˙	˙	N \
)
˙	˙	\ ]
;
˙	˙	] ^
if
˚	˚	 
(
˚	˚	 
tileLightCount
˚	˚	 *
==
˚	˚	+ -
$num
˚	˚	. /
)
˚	˚	/ 0
continue
¸	¸	 $
;
¸	¸	$ %
int
ˇ	ˇ	 
trimmedLightCount
ˇ	ˇ	 -
=
ˇ	ˇ	. /

TrimLights
ˇ	ˇ	0 :
(
ˇ	ˇ	: ;
ref
ˇ	ˇ	; >
trimmedLights
ˇ	ˇ	? L
,
ˇ	ˇ	L M
ref
ˇ	ˇ	N Q
tiles
ˇ	ˇ	R W
,
ˇ	ˇ	W X

tileOffset
ˇ	ˇ	Y c
,
ˇ	ˇ	c d
tileLightCount
ˇ	ˇ	e s
,
ˇ	ˇ	s t
ref
ˇ	ˇ	u x

usedLightsˇ	ˇ	y É
)ˇ	ˇ	É Ñ
;ˇ	ˇ	Ñ Ö

Assertions
Ä
Ä
 "
.
Ä
Ä
" #
Assert
Ä
Ä
# )
.
Ä
Ä
) *
IsTrue
Ä
Ä
* 0
(
Ä
Ä
0 1
trimmedLightCount
Ä
Ä
1 B
<=
Ä
Ä
C E
maxLightPerTile
Ä
Ä
F U
)
Ä
Ä
U V
;
Ä
Ä
V W
bool
Ñ
Ñ
 
tileListIsFull
Ñ
Ñ
 +
=
Ñ
Ñ
, -
(
Ñ
Ñ
. /
	tileCount
Ñ
Ñ
/ 8
==
Ñ
Ñ
9 ; 
m_MaxTilesPerBatch
Ñ
Ñ
< N
)
Ñ
Ñ
N O
;
Ñ
Ñ
O P
bool
Ö
Ö
 
lightBufferIsFull
Ö
Ö
 .
=
Ö
Ö
/ 0
(
Ö
Ö
1 2

lightCount
Ö
Ö
2 <
+
Ö
Ö
= >
trimmedLightCount
Ö
Ö
? P
>
Ö
Ö
Q R(
m_MaxPunctualLightPerBatch
Ö
Ö
S m
)
Ö
Ö
m n
;
Ö
Ö
n o
bool
Ü
Ü
  
relLightListIsFull
Ü
Ü
 /
=
Ü
Ü
0 1
(
Ü
Ü
2 3
relLightIndices
Ü
Ü
3 B
+
Ü
Ü
C D
tileLightCount
Ü
Ü
E S
>
Ü
Ü
T U*
m_MaxRelLightIndicesPerBatch
Ü
Ü
V r
)
Ü
Ü
r s
;
Ü
Ü
s t
if
à
à
 
(
à
à
 
tileListIsFull
à
à
 *
||
à
à
+ -
lightBufferIsFull
à
à
. ?
||
à
à
@ B 
relLightListIsFull
à
à
C U
)
à
à
U V
{
â
â
 
	drawCalls
ä
ä
 %
[
ä
ä
% &
drawCallCount
ä
ä
& 3
++
ä
ä
3 5
]
ä
ä
5 6
=
ä
ä
7 8
new
ä
ä
9 <
DrawCall
ä
ä
= E
{
ã
ã
 
tileList
å
å
  (
=
å
å
) *
	_tileList
å
å
+ 4
,
å
å
4 5!
punctualLightBuffer
ç
ç
  3
=
ç
ç
4 5"
_punctualLightBuffer
ç
ç
6 J
,
ç
ç
J K
relLightList
é
é
  ,
=
é
é
- .
_relLightList
é
é
/ <
,
é
é
< =
tileListSize
è
è
  ,
=
è
è
- .
	tileCount
è
è
/ 8
*
è
è
9 :
sizeof_TileData
è
è
; J
,
è
è
J K%
punctualLightBufferSize
ê
ê
  7
=
ê
ê
8 9

lightCount
ê
ê
: D
*
ê
ê
E F&
sizeof_PunctualLightData
ê
ê
G _
,
ê
ê
_ `
relLightListSize
ë
ë
  0
=
ë
ë
1 2
Align
ë
ë
3 8
(
ë
ë
8 9
relLightIndices
ë
ë
9 H
,
ë
ë
H I
$num
ë
ë
J K
)
ë
ë
K L
*
ë
ë
M N
$num
ë
ë
O P
,
ë
ë
P Q
instanceOffset
í
í
  .
=
í
í
/ 0
instanceOffset
í
í
1 ?
,
í
í
? @
instanceCount
ì
ì
  -
=
ì
ì
. /
	tileCount
ì
ì
0 9
-
ì
ì
: ;
instanceOffset
ì
ì
< J
}
î
î
 
;
î
î
 
if
ñ
ñ
 
(
ñ
ñ
  
tileListIsFull
ñ
ñ
  .
)
ñ
ñ
. /
{
ó
ó
 
	_tileList
ò
ò
  )
.
ò
ò
) *
SetData
ò
ò
* 1
(
ò
ò
1 2
tileList
ò
ò
2 :
,
ò
ò
: ;
$num
ò
ò
< =
,
ò
ò
= >
$num
ò
ò
? @
,
ò
ò
@ A
tileList
ò
ò
B J
.
ò
ò
J K
Length
ò
ò
K Q
)
ò
ò
Q R
;
ò
ò
R S
	_tileList
ô
ô
  )
=
ô
ô
* + 
DeferredShaderData
ô
ô
, >
.
ô
ô
> ?
instance
ô
ô
? G
.
ô
ô
G H
ReserveBuffer
ô
ô
H U
<
ô
ô
U V
TileData
ô
ô
V ^
>
ô
ô
^ _
(
ô
ô
_ ` 
m_MaxTilesPerBatch
ô
ô
` r
,
ô
ô
r s
DeferredConfigô
ô
t Ç
.ô
ô
Ç É%
UseCBufferForTileListô
ô
É ò
)ô
ô
ò ô
;ô
ô
ô ö
	tileCount
ö
ö
  )
=
ö
ö
* +
$num
ö
ö
, -
;
ö
ö
- .
}
õ
õ
 
if
ù
ù
 
(
ù
ù
  
lightBufferIsFull
ù
ù
  1
)
ù
ù
1 2
{
û
û
 "
_punctualLightBuffer
ü
ü
  4
.
ü
ü
4 5
SetData
ü
ü
5 <
(
ü
ü
< =!
punctualLightBuffer
ü
ü
= P
,
ü
ü
P Q
$num
ü
ü
R S
,
ü
ü
S T
$num
ü
ü
U V
,
ü
ü
V W!
punctualLightBuffer
ü
ü
X k
.
ü
ü
k l
Length
ü
ü
l r
)
ü
ü
r s
;
ü
ü
s t"
_punctualLightBuffer
†
†
  4
=
†
†
5 6 
DeferredShaderData
†
†
7 I
.
†
†
I J
instance
†
†
J R
.
†
†
R S
ReserveBuffer
†
†
S `
<
†
†
` a
PunctualLightData
†
†
a r
>
†
†
r s
(
†
†
s t)
m_MaxPunctualLightPerBatch†
†
t é
,†
†
é è
DeferredConfig†
†
ê û
.†
†
û ü&
UseCBufferForLightData†
†
ü µ
)†
†
µ ∂
;†
†
∂ ∑

lightCount
°
°
  *
=
°
°
+ ,
$num
°
°
- .
;
°
°
. /
trimmedLightCount
§
§
  1
=
§
§
2 3
tileLightCount
§
§
4 B
;
§
§
B C
for
•
•
  #
(
•
•
$ %
int
•
•
% (
l
•
•
) *
=
•
•
+ ,
$num
•
•
- .
;
•
•
. /
l
•
•
0 1
<
•
•
2 3
tileLightCount
•
•
4 B
;
•
•
B C
++
•
•
D F
l
•
•
F G
)
•
•
G H
trimmedLights
¶
¶
$ 1
[
¶
¶
1 2
l
¶
¶
2 3
]
¶
¶
3 4
=
¶
¶
5 6
tiles
¶
¶
7 <
[
¶
¶
< =

tileOffset
¶
¶
= G
+
¶
¶
H I
l
¶
¶
J K
]
¶
¶
K L
;
¶
¶
L M

usedLights
ß
ß
  *
.
ß
ß
* +
Clear
ß
ß
+ 0
(
ß
ß
0 1
)
ß
ß
1 2
;
ß
ß
2 3
}
®
®
 
if
™
™
 
(
™
™
   
relLightListIsFull
™
™
  2
)
™
™
2 3
{
´
´
 
_relLightList
¨
¨
  -
.
¨
¨
- .
SetData
¨
¨
. 5
(
¨
¨
5 6
relLightList
¨
¨
6 B
,
¨
¨
B C
$num
¨
¨
D E
,
¨
¨
E F
$num
¨
¨
G H
,
¨
¨
H I
relLightList
¨
¨
J V
.
¨
¨
V W
Length
¨
¨
W ]
)
¨
¨
] ^
;
¨
¨
^ _
_relLightList
≠
≠
  -
=
≠
≠
. / 
DeferredShaderData
≠
≠
0 B
.
≠
≠
B C
instance
≠
≠
C K
.
≠
≠
K L
ReserveBuffer
≠
≠
L Y
<
≠
≠
Y Z
uint
≠
≠
Z ^
>
≠
≠
^ _
(
≠
≠
_ `*
m_MaxRelLightIndicesPerBatch
≠
≠
` |
,
≠
≠
| }
DeferredConfig≠
≠
~ å
.≠
≠
å ç&
UseCBufferForLightList≠
≠
ç £
)≠
≠
£ §
;≠
≠
§ •
relLightIndices
Æ
Æ
  /
=
Æ
Æ
0 1
$num
Æ
Æ
2 3
;
Æ
Æ
3 4
}
Ø
Ø
 
instanceOffset
±
±
 *
=
±
±
+ ,
	tileCount
±
±
- 6
;
±
±
6 7
}
≤
≤
 
int
µ
µ
 
headerOffset
µ
µ
 (
=
µ
µ
) *
tiler
µ
µ
+ 0
.
µ
µ
0 1!
GetTileHeaderOffset
µ
µ
1 D
(
µ
µ
D E
i
µ
µ
E F
,
µ
µ
F G
j
µ
µ
H I
)
µ
µ
I J
;
µ
µ
J K
uint
∂
∂
 
listBitMask
∂
∂
 (
=
∂
∂
) *
tileHeaders
∂
∂
+ 6
[
∂
∂
6 7
headerOffset
∂
∂
7 C
+
∂
∂
D E
$num
∂
∂
F G
]
∂
∂
G H
;
∂
∂
H I
StoreTileData
∑
∑
 %
(
∑
∑
% &
ref
∑
∑
& )
tileList
∑
∑
* 2
,
∑
∑
2 3
	tileCount
∑
∑
4 =
,
∑
∑
= >

PackTileID
∑
∑
? I
(
∑
∑
I J
(
∑
∑
J K
uint
∑
∑
K O
)
∑
∑
O P
i
∑
∑
P Q
,
∑
∑
Q R
(
∑
∑
S T
uint
∑
∑
T X
)
∑
∑
X Y
j
∑
∑
Y Z
)
∑
∑
Z [
,
∑
∑
[ \
listBitMask
∑
∑
] h
,
∑
∑
h i
(
∑
∑
j k
ushort
∑
∑
k q
)
∑
∑
q r
relLightIndices∑
∑
r Å
,∑
∑
Å Ç
(∑
∑
É Ñ
ushort∑
∑
Ñ ä
)∑
∑
ä ã
tileLightCount∑
∑
ã ô
)∑
∑
ô ö
;∑
∑
ö õ
++
∏
∏
 
	tileCount
∏
∏
 #
;
∏
∏
# $
for
ª
ª
 
(
ª
ª
 
int
ª
ª
  
l
ª
ª
! "
=
ª
ª
# $
$num
ª
ª
% &
;
ª
ª
& '
l
ª
ª
( )
<
ª
ª
* +
trimmedLightCount
ª
ª
, =
;
ª
ª
= >
++
ª
ª
? A
l
ª
ª
A B
)
ª
ª
B C
{
º
º
 
int
Ω
Ω
 
visLightIndex
Ω
Ω
  -
=
Ω
Ω
. /
trimmedLights
Ω
Ω
0 =
[
Ω
Ω
= >
l
Ω
Ω
> ?
]
Ω
Ω
? @
;
Ω
Ω
@ A$
StorePunctualLightData
æ
æ
 2
(
æ
æ
2 3
ref
æ
æ
3 6!
punctualLightBuffer
æ
æ
7 J
,
æ
æ
J K

lightCount
æ
æ
L V
,
æ
æ
V W
ref
æ
æ
X [
renderingData
æ
æ
\ i
.
æ
æ
i j
	lightData
æ
æ
j s
.
æ
æ
s t
visibleLightsæ
æ
t Å
,æ
æ
Å Ç
visLightIndexæ
æ
É ê
)æ
æ
ê ë
;æ
æ
ë í!
visLightToRelLights
ø
ø
 /
[
ø
ø
/ 0
visLightIndex
ø
ø
0 =
]
ø
ø
= >
=
ø
ø
? @
(
ø
ø
A B
ushort
ø
ø
B H
)
ø
ø
H I

lightCount
ø
ø
I S
;
ø
ø
S T
++
¿
¿
 

lightCount
¿
¿
 (
;
¿
¿
( )

usedLights
¡
¡
 &
.
¡
¡
& '
Set
¡
¡
' *
(
¡
¡
* +
visLightIndex
¡
¡
+ 8
,
¡
¡
8 9
true
¡
¡
: >
)
¡
¡
> ?
;
¡
¡
? @
}
¬
¬
 
for
≈
≈
 
(
≈
≈
 
int
≈
≈
  
l
≈
≈
! "
=
≈
≈
# $
$num
≈
≈
% &
;
≈
≈
& '
l
≈
≈
( )
<
≈
≈
* +
tileLightCount
≈
≈
, :
;
≈
≈
: ;
++
≈
≈
< >
l
≈
≈
> ?
)
≈
≈
? @
{
∆
∆
 
ushort
«
«
 "
visLightIndex
«
«
# 0
=
«
«
4 5
tiles
«
«
6 ;
[
«
«
; <

tileOffset
«
«
< F
+
«
«
X Y
l
«
«
Z [
]
«
«
[ \
;
«
«
\ ]
ushort
»
»
 "
relLightBitRange
»
»
# 3
=
»
»
4 5
tiles
»
»
6 ;
[
»
»
; <

tileOffset
»
»
< F
+
»
»
G H
tileLightCount
»
»
I W
+
»
»
X Y
l
»
»
Z [
]
»
»
[ \
;
»
»
\ ]
ushort
…
…
 "
relLightIndex
…
…
# 0
=
…
…
1 2!
visLightToRelLights
…
…
3 F
[
…
…
F G
visLightIndex
…
…
G T
]
…
…
T U
;
…
…
U V
relLightList
 
 
 (
[
 
 
( )
relLightIndices
 
 
) 8
++
 
 
8 :
]
 
 
: ;
=
 
 
< =
(
 
 
> ?
uint
 
 
? C
)
 
 
C D
relLightIndex
 
 
D Q
|
 
 
R S
(
 
 
T U
uint
 
 
U Y
)
 
 
Y Z
(
 
 
Z [
relLightBitRange
 
 
[ k
<<
 
 
l n
$num
 
 
o q
)
 
 
q r
;
 
 
r s
}
À
À
 
}
Ã
Ã
 
}
Õ
Õ
 
int
œ
œ
 
instanceCount
œ
œ
 !
=
œ
œ
" #
	tileCount
œ
œ
$ -
-
œ
œ
. /
instanceOffset
œ
œ
0 >
;
œ
œ
> ?
if
–
–
 
(
–
–
 
instanceCount
–
–
 !
>
–
–
" #
$num
–
–
$ %
)
–
–
% &
{
—
—
 
	_tileList
“
“
 
.
“
“
 
SetData
“
“
 %
(
“
“
% &
tileList
“
“
& .
,
“
“
. /
$num
“
“
0 1
,
“
“
1 2
$num
“
“
3 4
,
“
“
4 5
tileList
“
“
6 >
.
“
“
> ?
Length
“
“
? E
)
“
“
E F
;
“
“
F G"
_punctualLightBuffer
”
”
 (
.
”
”
( )
SetData
”
”
) 0
(
”
”
0 1!
punctualLightBuffer
”
”
1 D
,
”
”
D E
$num
”
”
F G
,
”
”
G H
$num
”
”
I J
,
”
”
J K!
punctualLightBuffer
”
”
L _
.
”
”
_ `
Length
”
”
` f
)
”
”
f g
;
”
”
g h
_relLightList
‘
‘
 !
.
‘
‘
! "
SetData
‘
‘
" )
(
‘
‘
) *
relLightList
‘
‘
* 6
,
‘
‘
6 7
$num
‘
‘
8 9
,
‘
‘
9 :
$num
‘
‘
; <
,
‘
‘
< =
relLightList
‘
‘
> J
.
‘
‘
J K
Length
‘
‘
K Q
)
‘
‘
Q R
;
‘
‘
R S
	drawCalls
÷
÷
 
[
÷
÷
 
drawCallCount
÷
÷
 +
++
÷
÷
+ -
]
÷
÷
- .
=
÷
÷
/ 0
new
÷
÷
1 4
DrawCall
÷
÷
5 =
{
◊
◊
 
tileList
ÿ
ÿ
  
=
ÿ
ÿ
! "
	_tileList
ÿ
ÿ
# ,
,
ÿ
ÿ
, -!
punctualLightBuffer
Ÿ
Ÿ
 +
=
Ÿ
Ÿ
, -"
_punctualLightBuffer
Ÿ
Ÿ
. B
,
Ÿ
Ÿ
B C
relLightList
⁄
⁄
 $
=
⁄
⁄
% &
_relLightList
⁄
⁄
' 4
,
⁄
⁄
4 5
tileListSize
€
€
 $
=
€
€
% &
	tileCount
€
€
' 0
*
€
€
1 2
sizeof_TileData
€
€
3 B
,
€
€
B C%
punctualLightBufferSize
‹
‹
 /
=
‹
‹
0 1

lightCount
‹
‹
2 <
*
‹
‹
= >&
sizeof_PunctualLightData
‹
‹
? W
,
‹
‹
W X
relLightListSize
›
›
 (
=
›
›
) *
Align
›
›
+ 0
(
›
›
0 1
relLightIndices
›
›
1 @
,
›
›
@ A
$num
›
›
B C
)
›
›
C D
*
›
›
E F
$num
›
›
G H
,
›
›
H I
instanceOffset
ﬁ
ﬁ
 &
=
ﬁ
ﬁ
' (
instanceOffset
ﬁ
ﬁ
) 7
,
ﬁ
ﬁ
7 8
instanceCount
ﬂ
ﬂ
 %
=
ﬂ
ﬂ
& '
instanceCount
ﬂ
ﬂ
( 5
}
‡
‡
 
;
‡
‡
 
}
·
·
 
tileList
„
„
 
.
„
„
 
Dispose
„
„
  
(
„
„
  !
)
„
„
! "
;
„
„
" #!
punctualLightBuffer
‰
‰
 #
.
‰
‰
# $
Dispose
‰
‰
$ +
(
‰
‰
+ ,
)
‰
‰
, -
;
‰
‰
- .
relLightList
Â
Â
 
.
Â
Â
 
Dispose
Â
Â
 $
(
Â
Â
$ %
)
Â
Â
% &
;
Â
Â
& '
trimmedLights
Ê
Ê
 
.
Ê
Ê
 
Dispose
Ê
Ê
 %
(
Ê
Ê
% &
)
Ê
Ê
& '
;
Ê
Ê
' (!
visLightToRelLights
Á
Á
 #
.
Á
Á
# $
Dispose
Á
Á
$ +
(
Á
Á
+ ,
)
Á
Á
, -
;
Á
Á
- .

usedLights
Ë
Ë
 
.
Ë
Ë
 
Dispose
Ë
Ë
 "
(
Ë
Ë
" #
)
Ë
Ë
# $
;
Ë
Ë
$ %
}
È
È
 
using
Ï
Ï
 
(
Ï
Ï
 
new
Ï
Ï
 
ProfilingScope
Ï
Ï
 %
(
Ï
Ï
% &
cmd
Ï
Ï
& )
,
Ï
Ï
) *1
#m_ProfilingSamplerDeferredTiledPass
Ï
Ï
+ N
)
Ï
Ï
N O
)
Ï
Ï
O P
{
Ì
Ì
 
MeshTopology
Ó
Ó
 
topology
Ó
Ó
 %
=
Ó
Ó
& '
DeferredConfig
Ó
Ó
( 6
.
Ó
Ó
6 7#
kHasNativeQuadSupport
Ó
Ó
7 L
?
Ó
Ó
M N
MeshTopology
Ó
Ó
O [
.
Ó
Ó
[ \
Quads
Ó
Ó
\ a
:
Ó
Ó
b c
MeshTopology
Ó
Ó
d p
.
Ó
Ó
p q
	Triangles
Ó
Ó
q z
;
Ó
Ó
z {
int
Ô
Ô
 
vertexCount
Ô
Ô
 
=
Ô
Ô
  !
DeferredConfig
Ô
Ô
" 0
.
Ô
Ô
0 1#
kHasNativeQuadSupport
Ô
Ô
1 F
?
Ô
Ô
G H
$num
Ô
Ô
I J
:
Ô
Ô
K L
$num
Ô
Ô
M N
;
Ô
Ô
N O
Vector4
Ú
Ú
 

screenSize
Ú
Ú
 "
=
Ú
Ú
# $
new
Ú
Ú
% (
Vector4
Ú
Ú
) 0
(
Ú
Ú
0 1
this
Ú
Ú
1 5
.
Ú
Ú
5 6
RenderWidth
Ú
Ú
6 A
,
Ú
Ú
A B
this
Ú
Ú
C G
.
Ú
Ú
G H
RenderHeight
Ú
Ú
H T
,
Ú
Ú
T U
$num
Ú
Ú
V Z
/
Ú
Ú
[ \
this
Ú
Ú
] a
.
Ú
Ú
a b
RenderWidth
Ú
Ú
b m
,
Ú
Ú
m n
$num
Ú
Ú
o s
/
Ú
Ú
t u
this
Ú
Ú
v z
.
Ú
Ú
z {
RenderHeightÚ
Ú
{ á
)Ú
Ú
á à
;Ú
Ú
à â
cmd
Û
Û
 
.
Û
Û
 
SetGlobalVector
Û
Û
 #
(
Û
Û
# $
ShaderConstants
Û
Û
$ 3
.
Û
Û
3 4
_ScreenSize
Û
Û
4 ?
,
Û
Û
? @

screenSize
Û
Û
A K
)
Û
Û
K L
;
Û
Û
L M
int
ı
ı
 
	tileWidth
ı
ı
 
=
ı
ı
 
m_Tilers
ı
ı
  (
[
ı
ı
( )
$num
ı
ı
) *
]
ı
ı
* +
.
ı
ı
+ ,
TilePixelWidth
ı
ı
, :
;
ı
ı
: ;
int
ˆ
ˆ
 

tileHeight
ˆ
ˆ
 
=
ˆ
ˆ
  
m_Tilers
ˆ
ˆ
! )
[
ˆ
ˆ
) *
$num
ˆ
ˆ
* +
]
ˆ
ˆ
+ ,
.
ˆ
ˆ
, -
TilePixelHeight
ˆ
ˆ
- <
;
ˆ
ˆ
< =
cmd
˜
˜
 
.
˜
˜
 
SetGlobalInt
˜
˜
  
(
˜
˜
  !
ShaderConstants
˜
˜
! 0
.
˜
˜
0 1
_TilePixelWidth
˜
˜
1 @
,
˜
˜
@ A
	tileWidth
˜
˜
B K
)
˜
˜
K L
;
˜
˜
L M
cmd
¯
¯
 
.
¯
¯
 
SetGlobalInt
¯
¯
  
(
¯
¯
  !
ShaderConstants
¯
¯
! 0
.
¯
¯
0 1
_TilePixelHeight
¯
¯
1 A
,
¯
¯
A B

tileHeight
¯
¯
C M
)
¯
¯
M N
;
¯
¯
N O
cmd
˙
˙
 
.
˙
˙
 
SetGlobalTexture
˙
˙
 $
(
˙
˙
$ %
this
˙
˙
% )
.
˙
˙
) *"
TileDepthInfoTexture
˙
˙
* >
.
˙
˙
> ?
id
˙
˙
? A
,
˙
˙
A B
this
˙
˙
C G
.
˙
˙
G H,
TileDepthInfoTextureIdentifier
˙
˙
H f
)
˙
˙
f g
;
˙
˙
g h
for
¸
¸
 
(
¸
¸
 
int
¸
¸
 
i
¸
¸
 
=
¸
¸
 
$num
¸
¸
 
;
¸
¸
 
i
¸
¸
  !
<
¸
¸
" #
drawCallCount
¸
¸
$ 1
;
¸
¸
1 2
++
¸
¸
3 5
i
¸
¸
5 6
)
¸
¸
6 7
{
˝
˝
 
DrawCall
˛
˛
 
dc
˛
˛
 
=
˛
˛
  !
	drawCalls
˛
˛
" +
[
˛
˛
+ ,
i
˛
˛
, -
]
˛
˛
- .
;
˛
˛
. /
if
ÄÄ 
(
ÄÄ 
DeferredConfig
ÄÄ &
.
ÄÄ& '#
UseCBufferForTileList
ÄÄ' <
)
ÄÄ< =
cmd
ÅÅ 
.
ÅÅ %
SetGlobalConstantBuffer
ÅÅ 3
(
ÅÅ3 4
dc
ÅÅ4 6
.
ÅÅ6 7
tileList
ÅÅ7 ?
,
ÅÅ? @
ShaderConstants
ÅÅA P
.
ÅÅP Q
	UTileList
ÅÅQ Z
,
ÅÅZ [
$num
ÅÅ\ ]
,
ÅÅ] ^
dc
ÅÅ_ a
.
ÅÅa b
tileListSize
ÅÅb n
)
ÅÅn o
;
ÅÅo p
else
ÇÇ 
cmd
ÉÉ 
.
ÉÉ 
SetGlobalBuffer
ÉÉ +
(
ÉÉ+ ,
ShaderConstants
ÉÉ, ;
.
ÉÉ; <
	_TileList
ÉÉ< E
,
ÉÉE F
dc
ÉÉG I
.
ÉÉI J
tileList
ÉÉJ R
)
ÉÉR S
;
ÉÉS T
if
ÖÖ 
(
ÖÖ 
DeferredConfig
ÖÖ &
.
ÖÖ& '$
UseCBufferForLightData
ÖÖ' =
)
ÖÖ= >
cmd
ÜÜ 
.
ÜÜ %
SetGlobalConstantBuffer
ÜÜ 3
(
ÜÜ3 4
dc
ÜÜ4 6
.
ÜÜ6 7!
punctualLightBuffer
ÜÜ7 J
,
ÜÜJ K
ShaderConstants
ÜÜL [
.
ÜÜ[ \"
UPunctualLightBuffer
ÜÜ\ p
,
ÜÜp q
$num
ÜÜr s
,
ÜÜs t
dc
ÜÜu w
.
ÜÜw x&
punctualLightBufferSizeÜÜx è
)ÜÜè ê
;ÜÜê ë
else
áá 
cmd
àà 
.
àà 
SetGlobalBuffer
àà +
(
àà+ ,
ShaderConstants
àà, ;
.
àà; <"
_PunctualLightBuffer
àà< P
,
ààP Q
dc
ààR T
.
ààT U!
punctualLightBuffer
ààU h
)
ààh i
;
àài j
if
ää 
(
ää 
DeferredConfig
ää &
.
ää& '$
UseCBufferForLightList
ää' =
)
ää= >
cmd
ãã 
.
ãã %
SetGlobalConstantBuffer
ãã 3
(
ãã3 4
dc
ãã4 6
.
ãã6 7
relLightList
ãã7 C
,
ããC D
ShaderConstants
ããE T
.
ããT U
URelLightList
ããU b
,
ããb c
$num
ããd e
,
ããe f
dc
ããg i
.
ããi j
relLightListSize
ããj z
)
ããz {
;
ãã{ |
else
åå 
cmd
çç 
.
çç 
SetGlobalBuffer
çç +
(
çç+ ,
ShaderConstants
çç, ;
.
çç; <
_RelLightList
çç< I
,
ççI J
dc
ççK M
.
ççM N
relLightList
ççN Z
)
ççZ [
;
çç[ \
cmd
èè 
.
èè 
SetGlobalInt
èè $
(
èè$ %
ShaderConstants
èè% 4
.
èè4 5
_InstanceOffset
èè5 D
,
èèD E
dc
èèF H
.
èèH I
instanceOffset
èèI W
)
èèW X
;
èèX Y
cmd
êê 
.
êê 
DrawProcedural
êê &
(
êê& '
	Matrix4x4
êê' 0
.
êê0 1
identity
êê1 9
,
êê9 :$
m_TileDeferredMaterial
êê; Q
,
êêQ R
$num
êêS T
,
êêT U
topology
êêV ^
,
êê^ _
vertexCount
êê` k
,
êêk l
dc
êêm o
.
êêo p
instanceCount
êêp }
)
êê} ~
;
êê~ 
cmd
ëë 
.
ëë 
DrawProcedural
ëë &
(
ëë& '
	Matrix4x4
ëë' 0
.
ëë0 1
identity
ëë1 9
,
ëë9 :$
m_TileDeferredMaterial
ëë; Q
,
ëëQ R
$num
ëëS T
,
ëëT U
topology
ëëV ^
,
ëë^ _
vertexCount
ëë` k
,
ëëk l
dc
ëëm o
.
ëëo p
instanceCount
ëëp }
)
ëë} ~
;
ëë~ 
}
íí 
}
ìì 
Profiler
ïï 
.
ïï 
	EndSample
ïï 
(
ïï 
)
ïï  
;
ïï  !
}
ññ 	
void
òò !
RenderStencilLights
òò  
(
òò  !%
ScriptableRenderContext
òò! 8
context
òò9 @
,
òò@ A
CommandBuffer
òòB O
cmd
òòP S
,
òòS T
ref
òòU X
RenderingData
òòY f
renderingData
òòg t
)
òòt u
{
ôô 	
if
öö 
(
öö  
m_stencilVisLights
öö "
.
öö" #
Length
öö# )
==
öö* ,
$num
öö- .
)
öö. /
return
õõ 
;
õõ 
if
ùù 
(
ùù '
m_StencilDeferredMaterial
ùù )
==
ùù* ,
null
ùù- 1
)
ùù1 2
{
ûû 
Debug
üü 
.
üü 
LogErrorFormat
üü $
(
üü$ %
$strüü% å
,üüå ç)
m_StencilDeferredMaterialüüé ß
,üüß ®
GetTypeüü© ∞
(üü∞ ±
)üü± ≤
.üü≤ ≥
Nameüü≥ ∑
)üü∑ ∏
;üü∏ π
return
†† 
;
†† 
}
°° 
Profiler
££ 
.
££ 
BeginSample
££  
(
££  !#
k_DeferredStencilPass
££! 6
)
££6 7
;
££7 8
if
•• 
(
•• 
m_SphereMesh
•• 
==
•• 
null
••  $
)
••$ %
m_SphereMesh
¶¶ 
=
¶¶ 
CreateSphereMesh
¶¶ /
(
¶¶/ 0
)
¶¶0 1
;
¶¶1 2
if
ßß 
(
ßß 
m_HemisphereMesh
ßß  
==
ßß! #
null
ßß$ (
)
ßß( )
m_HemisphereMesh
®®  
=
®®! ""
CreateHemisphereMesh
®®# 7
(
®®7 8
)
®®8 9
;
®®9 :
if
©© 
(
©© 
m_FullscreenMesh
©©  
==
©©! #
null
©©$ (
)
©©( )
m_FullscreenMesh
™™  
=
™™! ""
CreateFullscreenMesh
™™# 7
(
™™7 8
)
™™8 9
;
™™9 :
using
¨¨ 
(
¨¨ 
new
¨¨ 
ProfilingScope
¨¨ %
(
¨¨% &
cmd
¨¨& )
,
¨¨) *3
%m_ProfilingSamplerDeferredStencilPass
¨¨+ P
)
¨¨P Q
)
¨¨Q R
{
≠≠ 
NativeArray
ÆÆ 
<
ÆÆ 
VisibleLight
ÆÆ (
>
ÆÆ( )
visibleLights
ÆÆ* 7
=
ÆÆ8 9
renderingData
ÆÆ: G
.
ÆÆG H
	lightData
ÆÆH Q
.
ÆÆQ R
visibleLights
ÆÆR _
;
ÆÆ_ `,
RenderStencilDirectionalLights
∞∞ .
(
∞∞. /
cmd
∞∞/ 2
,
∞∞2 3
ref
∞∞4 7
renderingData
∞∞8 E
,
∞∞E F
visibleLights
∞∞G T
,
∞∞T U
renderingData
∞∞V c
.
∞∞c d
	lightData
∞∞d m
.
∞∞m n
mainLightIndex
∞∞n |
)
∞∞| }
;
∞∞} ~&
RenderStencilPointLights
±± (
(
±±( )
cmd
±±) ,
,
±±, -
ref
±±. 1
renderingData
±±2 ?
,
±±? @
visibleLights
±±A N
)
±±N O
;
±±O P%
RenderStencilSpotLights
≤≤ '
(
≤≤' (
cmd
≤≤( +
,
≤≤+ ,
ref
≤≤- 0
renderingData
≤≤1 >
,
≤≤> ?
visibleLights
≤≤@ M
)
≤≤M N
;
≤≤N O
}
≥≥ 
Profiler
µµ 
.
µµ 
	EndSample
µµ 
(
µµ 
)
µµ  
;
µµ  !
}
∂∂ 	
void
∏∏ ,
RenderStencilDirectionalLights
∏∏ +
(
∏∏+ ,
CommandBuffer
∏∏, 9
cmd
∏∏: =
,
∏∏= >
ref
∏∏? B
RenderingData
∏∏C P
renderingData
∏∏Q ^
,
∏∏^ _
NativeArray
∏∏` k
<
∏∏k l
VisibleLight
∏∏l x
>
∏∏x y
visibleLights∏∏z á
,∏∏á à
int∏∏â å
mainLightIndex∏∏ç õ
)∏∏õ ú
{
ππ 	
cmd
∫∫ 
.
∫∫ !
EnableShaderKeyword
∫∫ #
(
∫∫# $"
ShaderKeywordStrings
∫∫$ 8
.
∫∫8 9
_DIRECTIONAL
∫∫9 E
)
∫∫E F
;
∫∫F G
for
¿¿ 
(
¿¿ 
int
¿¿ 
soffset
¿¿ 
=
¿¿ &
m_stencilVisLightOffsets
¿¿ 7
[
¿¿7 8
(
¿¿8 9
int
¿¿9 <
)
¿¿< =
	LightType
¿¿= F
.
¿¿F G
Directional
¿¿G R
]
¿¿R S
;
¿¿S T
soffset
¿¿U \
<
¿¿] ^ 
m_stencilVisLights
¿¿_ q
.
¿¿q r
Length
¿¿r x
;
¿¿x y
++
¿¿z |
soffset¿¿| É
)¿¿É Ñ
{
¡¡ 
ushort
¬¬ 
visLightIndex
¬¬ $
=
¬¬% & 
m_stencilVisLights
¬¬' 9
[
¬¬9 :
soffset
¬¬: A
]
¬¬A B
;
¬¬B C
VisibleLight
√√ 
vl
√√ 
=
√√  !
visibleLights
√√" /
[
√√/ 0
visLightIndex
√√0 =
]
√√= >
;
√√> ?
if
ƒƒ 
(
ƒƒ 
vl
ƒƒ 
.
ƒƒ 
	lightType
ƒƒ  
!=
ƒƒ! #
	LightType
ƒƒ$ -
.
ƒƒ- .
Directional
ƒƒ. 9
)
ƒƒ9 :
break
≈≈ 
;
≈≈ 
Vector4
«« 
lightDir
««  
,
««  !

lightColor
««" ,
,
««, -
lightAttenuation
««. >
,
««> ?
lightSpotDir
««@ L
,
««L M#
lightOcclusionChannel
««N c
;
««c d%
UniversalRenderPipeline
»» '
.
»»' (-
InitializeLightConstants_Common
»»( G
(
»»G H
visibleLights
»»H U
,
»»U V
visLightIndex
»»W d
,
»»d e
out
»»f i
lightDir
»»j r
,
»»r s
out
»»t w

lightColor»»x Ç
,»»Ç É
out»»Ñ á 
lightAttenuation»»à ò
,»»ò ô
out»»ö ù
lightSpotDir»»û ™
,»»™ ´
out»»¨ Ø%
lightOcclusionChannel»»∞ ≈
)»»≈ ∆
;»»∆ «
int
   

lightFlags
   
=
    
$num
  ! "
;
  " #
if
ÀÀ 
(
ÀÀ 
vl
ÀÀ 
.
ÀÀ 
light
ÀÀ 
.
ÀÀ 
bakingOutput
ÀÀ )
.
ÀÀ) *
lightmapBakeType
ÀÀ* :
==
ÀÀ; =
LightmapBakeType
ÀÀ> N
.
ÀÀN O
Mixed
ÀÀO T
)
ÀÀT U

lightFlags
ÃÃ 
|=
ÃÃ !
(
ÃÃ" #
int
ÃÃ# &
)
ÃÃ& '
	LightFlag
ÃÃ' 0
.
ÃÃ0 1&
SubtractiveMixedLighting
ÃÃ1 I
;
ÃÃI J
bool
——  
hasDeferredShadows
—— '
;
——' (
if
““ 
(
““ 
visLightIndex
““ !
==
““" $
mainLightIndex
““% 3
)
““3 4
{
””  
hasDeferredShadows
‘‘ &
=
‘‘' (
vl
‘‘) +
.
‘‘+ ,
light
‘‘, 1
&&
‘‘2 4
vl
‘‘5 7
.
‘‘7 8
light
‘‘8 =
.
‘‘= >
shadows
‘‘> E
!=
‘‘F H
LightShadows
‘‘I U
.
‘‘U V
None
‘‘V Z
;
‘‘Z [
cmd
’’ 
.
’’ "
DisableShaderKeyword
’’ ,
(
’’, -"
ShaderKeywordStrings
’’- A
.
’’A B0
"_DEFERRED_ADDITIONAL_LIGHT_SHADOWS
’’B d
)
’’d e
;
’’e f
}
÷÷ 
else
◊◊ 
{
ÿÿ 
int
ŸŸ 
shadowLightIndex
ŸŸ (
=
ŸŸ) *0
"m_AdditionalLightsShadowCasterPass
ŸŸ+ M
!=
ŸŸN P
null
ŸŸQ U
?
ŸŸV W0
"m_AdditionalLightsShadowCasterPass
ŸŸX z
.
ŸŸz {0
!GetShadowLightIndexFromLightIndexŸŸ{ ú
(ŸŸú ù
visLightIndexŸŸù ™
)ŸŸ™ ´
:ŸŸ¨ ≠
-ŸŸÆ Ø
$numŸŸØ ∞
;ŸŸ∞ ± 
hasDeferredShadows
⁄⁄ &
=
⁄⁄' (
vl
⁄⁄) +
.
⁄⁄+ ,
light
⁄⁄, 1
&&
⁄⁄2 4
vl
⁄⁄5 7
.
⁄⁄7 8
light
⁄⁄8 =
.
⁄⁄= >
shadows
⁄⁄> E
!=
⁄⁄F H
LightShadows
⁄⁄I U
.
⁄⁄U V
None
⁄⁄V Z
&&
⁄⁄[ ]
shadowLightIndex
⁄⁄^ n
>=
⁄⁄o q
$num
⁄⁄r s
;
⁄⁄s t
	CoreUtils
€€ 
.
€€ 

SetKeyword
€€ (
(
€€( )
cmd
€€) ,
,
€€, -"
ShaderKeywordStrings
€€. B
.
€€B C0
"_DEFERRED_ADDITIONAL_LIGHT_SHADOWS
€€C e
,
€€e f 
hasDeferredShadows
€€g y
)
€€y z
;
€€z {
cmd
›› 
.
›› 
SetGlobalInt
›› $
(
››$ %
ShaderConstants
››% 4
.
››4 5
_ShadowLightIndex
››5 F
,
››F G
shadowLightIndex
››H X
)
››X Y
;
››Y Z
}
ﬁﬁ 
bool
‡‡ 
hasSoftShadow
‡‡ "
=
‡‡# $ 
hasDeferredShadows
‡‡% 7
&&
‡‡8 :
renderingData
‡‡; H
.
‡‡H I

shadowData
‡‡I S
.
‡‡S T!
supportsSoftShadows
‡‡T g
&&
‡‡h j
vl
‡‡k m
.
‡‡m n
light
‡‡n s
.
‡‡s t
shadows
‡‡t {
==
‡‡| ~
LightShadows‡‡ ã
.‡‡ã å
Soft‡‡å ê
;‡‡ê ë
	CoreUtils
·· 
.
·· 

SetKeyword
·· $
(
··$ %
cmd
··% (
,
··( )"
ShaderKeywordStrings
··* >
.
··> ?
SoftShadows
··? J
,
··J K
hasSoftShadow
··L Y
)
··Y Z
;
··Z [
cmd
„„ 
.
„„ 
SetGlobalVector
„„ #
(
„„# $
ShaderConstants
„„$ 3
.
„„3 4
_LightColor
„„4 ?
,
„„? @

lightColor
„„A K
)
„„K L
;
„„L M
cmd
‰‰ 
.
‰‰ 
SetGlobalVector
‰‰ #
(
‰‰# $
ShaderConstants
‰‰$ 3
.
‰‰3 4
_LightDirection
‰‰4 C
,
‰‰C D
lightDir
‰‰E M
)
‰‰M N
;
‰‰N O
cmd
ÂÂ 
.
ÂÂ 
SetGlobalInt
ÂÂ  
(
ÂÂ  !
ShaderConstants
ÂÂ! 0
.
ÂÂ0 1
_LightFlags
ÂÂ1 <
,
ÂÂ< =

lightFlags
ÂÂ> H
)
ÂÂH I
;
ÂÂI J
cmd
ËË 
.
ËË 
DrawMesh
ËË 
(
ËË 
m_FullscreenMesh
ËË -
,
ËË- .
	Matrix4x4
ËË/ 8
.
ËË8 9
identity
ËË9 A
,
ËËA B'
m_StencilDeferredMaterial
ËËC \
,
ËË\ ]
$num
ËË^ _
,
ËË_ `
$num
ËËa b
)
ËËb c
;
ËËc d
cmd
ÈÈ 
.
ÈÈ 
DrawMesh
ÈÈ 
(
ÈÈ 
m_FullscreenMesh
ÈÈ -
,
ÈÈ- .
	Matrix4x4
ÈÈ/ 8
.
ÈÈ8 9
identity
ÈÈ9 A
,
ÈÈA B'
m_StencilDeferredMaterial
ÈÈC \
,
ÈÈ\ ]
$num
ÈÈ^ _
,
ÈÈ_ `
$num
ÈÈa b
)
ÈÈb c
;
ÈÈc d
}
ÍÍ 
cmd
ÏÏ 
.
ÏÏ "
DisableShaderKeyword
ÏÏ $
(
ÏÏ$ %"
ShaderKeywordStrings
ÏÏ% 9
.
ÏÏ9 :0
"_DEFERRED_ADDITIONAL_LIGHT_SHADOWS
ÏÏ: \
)
ÏÏ\ ]
;
ÏÏ] ^
cmd
ÌÌ 
.
ÌÌ "
DisableShaderKeyword
ÌÌ $
(
ÌÌ$ %"
ShaderKeywordStrings
ÌÌ% 9
.
ÌÌ9 :
SoftShadows
ÌÌ: E
)
ÌÌE F
;
ÌÌF G
cmd
ÓÓ 
.
ÓÓ "
DisableShaderKeyword
ÓÓ $
(
ÓÓ$ %"
ShaderKeywordStrings
ÓÓ% 9
.
ÓÓ9 :
_DIRECTIONAL
ÓÓ: F
)
ÓÓF G
;
ÓÓG H
}
ÔÔ 	
void
ÒÒ &
RenderStencilPointLights
ÒÒ %
(
ÒÒ% &
CommandBuffer
ÒÒ& 3
cmd
ÒÒ4 7
,
ÒÒ7 8
ref
ÒÒ9 <
RenderingData
ÒÒ= J
renderingData
ÒÒK X
,
ÒÒX Y
NativeArray
ÒÒZ e
<
ÒÒe f
VisibleLight
ÒÒf r
>
ÒÒr s
visibleLightsÒÒt Å
)ÒÒÅ Ç
{
ÚÚ 	
cmd
ÛÛ 
.
ÛÛ !
EnableShaderKeyword
ÛÛ #
(
ÛÛ# $"
ShaderKeywordStrings
ÛÛ$ 8
.
ÛÛ8 9
_POINT
ÛÛ9 ?
)
ÛÛ? @
;
ÛÛ@ A
for
ıı 
(
ıı 
int
ıı 
soffset
ıı 
=
ıı &
m_stencilVisLightOffsets
ıı 7
[
ıı7 8
(
ıı8 9
int
ıı9 <
)
ıı< =
	LightType
ıı= F
.
ııF G
Point
ııG L
]
ııL M
;
ııM N
soffset
ııO V
<
ııW X 
m_stencilVisLights
ııY k
.
ıık l
Length
ııl r
;
ıır s
++
ııt v
soffset
ııv }
)
ıı} ~
{
ˆˆ 
ushort
˜˜ 
visLightIndex
˜˜ $
=
˜˜% & 
m_stencilVisLights
˜˜' 9
[
˜˜9 :
soffset
˜˜: A
]
˜˜A B
;
˜˜B C
VisibleLight
¯¯ 
vl
¯¯ 
=
¯¯  !
visibleLights
¯¯" /
[
¯¯/ 0
visLightIndex
¯¯0 =
]
¯¯= >
;
¯¯> ?
if
˘˘ 
(
˘˘ 
vl
˘˘ 
.
˘˘ 
	lightType
˘˘  
!=
˘˘! #
	LightType
˘˘$ -
.
˘˘- .
Point
˘˘. 3
)
˘˘3 4
break
˙˙ 
;
˙˙ 
Vector3
¸¸ 
posWS
¸¸ 
=
¸¸ 
vl
¸¸  "
.
¸¸" # 
localToWorldMatrix
¸¸# 5
.
¸¸5 6
	GetColumn
¸¸6 ?
(
¸¸? @
$num
¸¸@ A
)
¸¸A B
;
¸¸B C
	Matrix4x4
˛˛ 
transformMatrix
˛˛ )
=
˛˛* +
new
˛˛, /
	Matrix4x4
˛˛0 9
(
˛˛9 :
new
ˇˇ 
Vector4
ˇˇ 
(
ˇˇ  
vl
ˇˇ  "
.
ˇˇ" #
range
ˇˇ# (
,
ˇˇ( )
$num
ˇˇ* .
,
ˇˇ. /
$num
ˇˇ0 4
,
ˇˇ4 5
$num
ˇˇ6 :
)
ˇˇ: ;
,
ˇˇ; <
new
ÄÄ 
Vector4
ÄÄ 
(
ÄÄ  
$num
ÄÄ  $
,
ÄÄ$ %
vl
ÄÄ& (
.
ÄÄ( )
range
ÄÄ) .
,
ÄÄ. /
$num
ÄÄ0 4
,
ÄÄ4 5
$num
ÄÄ6 :
)
ÄÄ: ;
,
ÄÄ; <
new
ÅÅ 
Vector4
ÅÅ 
(
ÅÅ  
$num
ÅÅ  $
,
ÅÅ$ %
$num
ÅÅ& *
,
ÅÅ* +
vl
ÅÅ, .
.
ÅÅ. /
range
ÅÅ/ 4
,
ÅÅ4 5
$num
ÅÅ6 :
)
ÅÅ: ;
,
ÅÅ; <
new
ÇÇ 
Vector4
ÇÇ 
(
ÇÇ  
posWS
ÇÇ  %
.
ÇÇ% &
x
ÇÇ& '
,
ÇÇ' (
posWS
ÇÇ) .
.
ÇÇ. /
y
ÇÇ/ 0
,
ÇÇ0 1
posWS
ÇÇ2 7
.
ÇÇ7 8
z
ÇÇ8 9
,
ÇÇ9 :
$num
ÇÇ; ?
)
ÇÇ? @
)
ÉÉ 
;
ÉÉ 
Vector4
ÖÖ 
lightPos
ÖÖ  
,
ÖÖ  !

lightColor
ÖÖ" ,
,
ÖÖ, -
lightAttenuation
ÖÖ. >
,
ÖÖ> ?
lightSpotDir
ÖÖ@ L
,
ÖÖL M#
lightOcclusionChannel
ÖÖN c
;
ÖÖc d%
UniversalRenderPipeline
ÜÜ '
.
ÜÜ' (-
InitializeLightConstants_Common
ÜÜ( G
(
ÜÜG H
visibleLights
ÜÜH U
,
ÜÜU V
visLightIndex
ÜÜW d
,
ÜÜd e
out
ÜÜf i
lightPos
ÜÜj r
,
ÜÜr s
out
ÜÜt w

lightColorÜÜx Ç
,ÜÜÇ É
outÜÜÑ á 
lightAttenuationÜÜà ò
,ÜÜò ô
outÜÜö ù
lightSpotDirÜÜû ™
,ÜÜ™ ´
outÜÜ¨ Ø%
lightOcclusionChannelÜÜ∞ ≈
)ÜÜ≈ ∆
;ÜÜ∆ «
int
àà 

lightFlags
àà 
=
àà  
$num
àà! "
;
àà" #
if
ââ 
(
ââ 
vl
ââ 
.
ââ 
light
ââ 
.
ââ 
bakingOutput
ââ )
.
ââ) *
lightmapBakeType
ââ* :
==
ââ; =
LightmapBakeType
ââ> N
.
ââN O
Mixed
ââO T
)
ââT U

lightFlags
ää 
|=
ää !
(
ää" #
int
ää# &
)
ää& '
	LightFlag
ää' 0
.
ää0 1&
SubtractiveMixedLighting
ää1 I
;
ääI J
int
åå 
shadowLightIndex
åå $
=
åå% &0
"m_AdditionalLightsShadowCasterPass
åå' I
!=
ååJ L
null
ååM Q
?
ååR S0
"m_AdditionalLightsShadowCasterPass
ååT v
.
ååv w0
!GetShadowLightIndexFromLightIndexååw ò
(ååò ô
visLightIndexååô ¶
)åå¶ ß
:åå® ©
-åå™ ´
$numåå´ ¨
;åå¨ ≠
bool
çç /
!hasDeferredAdditionalLightShadows
çç 6
=
çç7 8
vl
çç9 ;
.
çç; <
light
çç< A
&&
ççB D
vl
ççE G
.
ççG H
light
ççH M
.
ççM N
shadows
ççN U
!=
ççV X
LightShadows
ççY e
.
ççe f
None
ççf j
&&
ççk m
shadowLightIndex
ççn ~
>=çç Å
$numççÇ É
;ççÉ Ñ
bool
éé 
hasSoftShadow
éé "
=
éé# $/
!hasDeferredAdditionalLightShadows
éé% F
&&
ééG I
renderingData
ééJ W
.
ééW X

shadowData
ééX b
.
ééb c!
supportsSoftShadows
ééc v
&&
ééw y
vl
ééz |
.
éé| }
lightéé} Ç
.ééÇ É
shadowsééÉ ä
==ééã ç
LightShadowsééé ö
.ééö õ
Softééõ ü
;ééü †
	CoreUtils
êê 
.
êê 

SetKeyword
êê $
(
êê$ %
cmd
êê% (
,
êê( )"
ShaderKeywordStrings
êê* >
.
êê> ?0
"_DEFERRED_ADDITIONAL_LIGHT_SHADOWS
êê? a
,
êêa b0
!hasDeferredAdditionalLightShadowsêêc Ñ
)êêÑ Ö
;êêÖ Ü
	CoreUtils
ëë 
.
ëë 

SetKeyword
ëë $
(
ëë$ %
cmd
ëë% (
,
ëë( )"
ShaderKeywordStrings
ëë* >
.
ëë> ?
SoftShadows
ëë? J
,
ëëJ K
hasSoftShadow
ëëL Y
)
ëëY Z
;
ëëZ [
cmd
ìì 
.
ìì 
SetGlobalVector
ìì #
(
ìì# $
ShaderConstants
ìì$ 3
.
ìì3 4
_LightPosWS
ìì4 ?
,
ìì? @
lightPos
ììA I
)
ììI J
;
ììJ K
cmd
îî 
.
îî 
SetGlobalVector
îî #
(
îî# $
ShaderConstants
îî$ 3
.
îî3 4
_LightColor
îî4 ?
,
îî? @

lightColor
îîA K
)
îîK L
;
îîL M
cmd
ïï 
.
ïï 
SetGlobalVector
ïï #
(
ïï# $
ShaderConstants
ïï$ 3
.
ïï3 4
_LightAttenuation
ïï4 E
,
ïïE F
lightAttenuation
ïïG W
)
ïïW X
;
ïïX Y
cmd
ññ 
.
ññ 
SetGlobalVector
ññ #
(
ññ# $
ShaderConstants
ññ$ 3
.
ññ3 4%
_LightOcclusionProbInfo
ññ4 K
,
ññK L#
lightOcclusionChannel
ññM b
)
ññb c
;
ññc d
cmd
óó 
.
óó 
SetGlobalInt
óó  
(
óó  !
ShaderConstants
óó! 0
.
óó0 1
_LightFlags
óó1 <
,
óó< =

lightFlags
óó> H
)
óóH I
;
óóI J
cmd
òò 
.
òò 
SetGlobalInt
òò  
(
òò  !
ShaderConstants
òò! 0
.
òò0 1
_ShadowLightIndex
òò1 B
,
òòB C
shadowLightIndex
òòD T
)
òòT U
;
òòU V
cmd
õõ 
.
õõ 
DrawMesh
õõ 
(
õõ 
m_SphereMesh
õõ )
,
õõ) *
transformMatrix
õõ+ :
,
õõ: ;'
m_StencilDeferredMaterial
õõ< U
,
õõU V
$num
õõW X
,
õõX Y
$num
õõZ [
)
õõ[ \
;
õõ\ ]
cmd
ûû 
.
ûû 
DrawMesh
ûû 
(
ûû 
m_SphereMesh
ûû )
,
ûû) *
transformMatrix
ûû+ :
,
ûû: ;'
m_StencilDeferredMaterial
ûû< U
,
ûûU V
$num
ûûW X
,
ûûX Y
$num
ûûZ [
)
ûû[ \
;
ûû\ ]
cmd
üü 
.
üü 
DrawMesh
üü 
(
üü 
m_SphereMesh
üü )
,
üü) *
transformMatrix
üü+ :
,
üü: ;'
m_StencilDeferredMaterial
üü< U
,
üüU V
$num
üüW X
,
üüX Y
$num
üüZ [
)
üü[ \
;
üü\ ]
}
†† 
cmd
¢¢ 
.
¢¢ "
DisableShaderKeyword
¢¢ $
(
¢¢$ %"
ShaderKeywordStrings
¢¢% 9
.
¢¢9 :0
"_DEFERRED_ADDITIONAL_LIGHT_SHADOWS
¢¢: \
)
¢¢\ ]
;
¢¢] ^
cmd
££ 
.
££ "
DisableShaderKeyword
££ $
(
££$ %"
ShaderKeywordStrings
££% 9
.
££9 :
SoftShadows
££: E
)
££E F
;
££F G
cmd
§§ 
.
§§ "
DisableShaderKeyword
§§ $
(
§§$ %"
ShaderKeywordStrings
§§% 9
.
§§9 :
_POINT
§§: @
)
§§@ A
;
§§A B
}
•• 	
void
ßß %
RenderStencilSpotLights
ßß $
(
ßß$ %
CommandBuffer
ßß% 2
cmd
ßß3 6
,
ßß6 7
ref
ßß8 ;
RenderingData
ßß< I
renderingData
ßßJ W
,
ßßW X
NativeArray
ßßY d
<
ßßd e
VisibleLight
ßße q
>
ßßq r
visibleLightsßßs Ä
)ßßÄ Å
{
®® 	
cmd
©© 
.
©© !
EnableShaderKeyword
©© #
(
©©# $"
ShaderKeywordStrings
©©$ 8
.
©©8 9
_SPOT
©©9 >
)
©©> ?
;
©©? @
for
´´ 
(
´´ 
int
´´ 
soffset
´´ 
=
´´ &
m_stencilVisLightOffsets
´´ 7
[
´´7 8
(
´´8 9
int
´´9 <
)
´´< =
	LightType
´´= F
.
´´F G
Spot
´´G K
]
´´K L
;
´´L M
soffset
´´N U
<
´´V W 
m_stencilVisLights
´´X j
.
´´j k
Length
´´k q
;
´´q r
++
´´s u
soffset
´´u |
)
´´| }
{
¨¨ 
ushort
≠≠ 
visLightIndex
≠≠ $
=
≠≠% & 
m_stencilVisLights
≠≠' 9
[
≠≠9 :
soffset
≠≠: A
]
≠≠A B
;
≠≠B C
VisibleLight
ÆÆ 
vl
ÆÆ 
=
ÆÆ  !
visibleLights
ÆÆ" /
[
ÆÆ/ 0
visLightIndex
ÆÆ0 =
]
ÆÆ= >
;
ÆÆ> ?
if
ØØ 
(
ØØ 
vl
ØØ 
.
ØØ 
	lightType
ØØ  
!=
ØØ! #
	LightType
ØØ$ -
.
ØØ- .
Spot
ØØ. 2
)
ØØ2 3
break
∞∞ 
;
∞∞ 
float
≤≤ 
alpha
≤≤ 
=
≤≤ 
Mathf
≤≤ #
.
≤≤# $
Deg2Rad
≤≤$ +
*
≤≤, -
vl
≤≤. 0
.
≤≤0 1
	spotAngle
≤≤1 :
*
≤≤; <
$num
≤≤= A
;
≤≤A B
float
≥≥ 
cosAlpha
≥≥ 
=
≥≥  
Mathf
≥≥! &
.
≥≥& '
Cos
≥≥' *
(
≥≥* +
alpha
≥≥+ 0
)
≥≥0 1
;
≥≥1 2
float
¥¥ 
sinAlpha
¥¥ 
=
¥¥  
Mathf
¥¥! &
.
¥¥& '
Sin
¥¥' *
(
¥¥* +
alpha
¥¥+ 0
)
¥¥0 1
;
¥¥1 2
float
∑∑ 
guard
∑∑ 
=
∑∑ 
Mathf
∑∑ #
.
∑∑# $
Lerp
∑∑$ (
(
∑∑( )
$num
∑∑) -
,
∑∑- . 
kStencilShapeGuard
∑∑/ A
,
∑∑A B
sinAlpha
∑∑C K
)
∑∑K L
;
∑∑L M
Vector4
ππ 
lightPos
ππ  
,
ππ  !

lightColor
ππ" ,
,
ππ, -
lightAttenuation
ππ. >
,
ππ> ?
lightSpotDir
ππ@ L
,
ππL M#
lightOcclusionChannel
ππN c
;
ππc d%
UniversalRenderPipeline
∫∫ '
.
∫∫' (-
InitializeLightConstants_Common
∫∫( G
(
∫∫G H
visibleLights
∫∫H U
,
∫∫U V
visLightIndex
∫∫W d
,
∫∫d e
out
∫∫f i
lightPos
∫∫j r
,
∫∫r s
out
∫∫t w

lightColor∫∫x Ç
,∫∫Ç É
out∫∫Ñ á 
lightAttenuation∫∫à ò
,∫∫ò ô
out∫∫ö ù
lightSpotDir∫∫û ™
,∫∫™ ´
out∫∫¨ Ø%
lightOcclusionChannel∫∫∞ ≈
)∫∫≈ ∆
;∫∫∆ «
int
ºº 

lightFlags
ºº 
=
ºº  
$num
ºº! "
;
ºº" #
if
ΩΩ 
(
ΩΩ 
vl
ΩΩ 
.
ΩΩ 
light
ΩΩ 
.
ΩΩ 
bakingOutput
ΩΩ )
.
ΩΩ) *
lightmapBakeType
ΩΩ* :
==
ΩΩ; =
LightmapBakeType
ΩΩ> N
.
ΩΩN O
Mixed
ΩΩO T
)
ΩΩT U

lightFlags
ææ 
|=
ææ !
(
ææ" #
int
ææ# &
)
ææ& '
	LightFlag
ææ' 0
.
ææ0 1&
SubtractiveMixedLighting
ææ1 I
;
ææI J
int
¿¿ 
shadowLightIndex
¿¿ $
=
¿¿% &0
"m_AdditionalLightsShadowCasterPass
¿¿' I
!=
¿¿J L
null
¿¿M Q
?
¿¿R S0
"m_AdditionalLightsShadowCasterPass
¿¿T v
.
¿¿v w0
!GetShadowLightIndexFromLightIndex¿¿w ò
(¿¿ò ô
visLightIndex¿¿ô ¶
)¿¿¶ ß
:¿¿® ©
-¿¿™ ´
$num¿¿´ ¨
;¿¿¨ ≠
bool
¡¡ /
!hasDeferredAdditionalLightShadows
¡¡ 6
=
¡¡7 8
vl
¡¡9 ;
.
¡¡; <
light
¡¡< A
&&
¡¡B D
vl
¡¡E G
.
¡¡G H
light
¡¡H M
.
¡¡M N
shadows
¡¡N U
!=
¡¡V X
LightShadows
¡¡Y e
.
¡¡e f
None
¡¡f j
&&
¡¡k m
shadowLightIndex
¡¡n ~
>=¡¡ Å
$num¡¡Ç É
;¡¡É Ñ
bool
¬¬ 
hasSoftShadow
¬¬ "
=
¬¬# $/
!hasDeferredAdditionalLightShadows
¬¬% F
&&
¬¬G I
renderingData
¬¬J W
.
¬¬W X

shadowData
¬¬X b
.
¬¬b c!
supportsSoftShadows
¬¬c v
&&
¬¬w y
vl
¬¬z |
.
¬¬| }
light¬¬} Ç
.¬¬Ç É
shadows¬¬É ä
==¬¬ã ç
LightShadows¬¬é ö
.¬¬ö õ
Soft¬¬õ ü
;¬¬ü †
	CoreUtils
ƒƒ 
.
ƒƒ 

SetKeyword
ƒƒ $
(
ƒƒ$ %
cmd
ƒƒ% (
,
ƒƒ( )"
ShaderKeywordStrings
ƒƒ* >
.
ƒƒ> ?0
"_DEFERRED_ADDITIONAL_LIGHT_SHADOWS
ƒƒ? a
,
ƒƒa b0
!hasDeferredAdditionalLightShadowsƒƒc Ñ
)ƒƒÑ Ö
;ƒƒÖ Ü
	CoreUtils
≈≈ 
.
≈≈ 

SetKeyword
≈≈ $
(
≈≈$ %
cmd
≈≈% (
,
≈≈( )"
ShaderKeywordStrings
≈≈* >
.
≈≈> ?
SoftShadows
≈≈? J
,
≈≈J K
hasSoftShadow
≈≈L Y
)
≈≈Y Z
;
≈≈Z [
cmd
«« 
.
«« 
SetGlobalVector
«« #
(
««# $
ShaderConstants
««$ 3
.
««3 4
_SpotLightScale
««4 C
,
««C D
new
««E H
Vector4
««I P
(
««P Q
sinAlpha
««Q Y
,
««Y Z
sinAlpha
««[ c
,
««c d
$num
««e i
-
««j k
cosAlpha
««l t
,
««t u
vl
««v x
.
««x y
range
««y ~
)
««~ 
)«« Ä
;««Ä Å
cmd
»» 
.
»» 
SetGlobalVector
»» #
(
»»# $
ShaderConstants
»»$ 3
.
»»3 4
_SpotLightBias
»»4 B
,
»»B C
new
»»D G
Vector4
»»H O
(
»»O P
$num
»»P T
,
»»T U
$num
»»V Z
,
»»Z [
cosAlpha
»»\ d
,
»»d e
$num
»»f j
)
»»j k
)
»»k l
;
»»l m
cmd
…… 
.
…… 
SetGlobalVector
…… #
(
……# $
ShaderConstants
……$ 3
.
……3 4
_SpotLightGuard
……4 C
,
……C D
new
……E H
Vector4
……I P
(
……P Q
guard
……Q V
,
……V W
guard
……X ]
,
……] ^
guard
……_ d
,
……d e
cosAlpha
……f n
*
……o p
vl
……q s
.
……s t
range
……t y
)
……y z
)
……z {
;
……{ |
cmd
   
.
   
SetGlobalVector
   #
(
  # $
ShaderConstants
  $ 3
.
  3 4
_LightPosWS
  4 ?
,
  ? @
lightPos
  A I
)
  I J
;
  J K
cmd
ÀÀ 
.
ÀÀ 
SetGlobalVector
ÀÀ #
(
ÀÀ# $
ShaderConstants
ÀÀ$ 3
.
ÀÀ3 4
_LightColor
ÀÀ4 ?
,
ÀÀ? @

lightColor
ÀÀA K
)
ÀÀK L
;
ÀÀL M
cmd
ÃÃ 
.
ÃÃ 
SetGlobalVector
ÃÃ #
(
ÃÃ# $
ShaderConstants
ÃÃ$ 3
.
ÃÃ3 4
_LightAttenuation
ÃÃ4 E
,
ÃÃE F
lightAttenuation
ÃÃG W
)
ÃÃW X
;
ÃÃX Y
cmd
ÕÕ 
.
ÕÕ 
SetGlobalVector
ÕÕ #
(
ÕÕ# $
ShaderConstants
ÕÕ$ 3
.
ÕÕ3 4
_LightDirection
ÕÕ4 C
,
ÕÕC D
new
ÕÕE H
Vector3
ÕÕI P
(
ÕÕP Q
lightSpotDir
ÕÕQ ]
.
ÕÕ] ^
x
ÕÕ^ _
,
ÕÕ_ `
lightSpotDir
ÕÕa m
.
ÕÕm n
y
ÕÕn o
,
ÕÕo p
lightSpotDir
ÕÕq }
.
ÕÕ} ~
z
ÕÕ~ 
)ÕÕ Ä
)ÕÕÄ Å
;ÕÕÅ Ç
cmd
ŒŒ 
.
ŒŒ 
SetGlobalVector
ŒŒ #
(
ŒŒ# $
ShaderConstants
ŒŒ$ 3
.
ŒŒ3 4%
_LightOcclusionProbInfo
ŒŒ4 K
,
ŒŒK L#
lightOcclusionChannel
ŒŒM b
)
ŒŒb c
;
ŒŒc d
cmd
œœ 
.
œœ 
SetGlobalInt
œœ  
(
œœ  !
ShaderConstants
œœ! 0
.
œœ0 1
_LightFlags
œœ1 <
,
œœ< =

lightFlags
œœ> H
)
œœH I
;
œœI J
cmd
–– 
.
–– 
SetGlobalInt
––  
(
––  !
ShaderConstants
––! 0
.
––0 1
_ShadowLightIndex
––1 B
,
––B C
shadowLightIndex
––D T
)
––T U
;
––U V
cmd
”” 
.
”” 
DrawMesh
”” 
(
”” 
m_HemisphereMesh
”” -
,
””- .
vl
””/ 1
.
””1 2 
localToWorldMatrix
””2 D
,
””D E'
m_StencilDeferredMaterial
””F _
,
””_ `
$num
””a b
,
””b c
$num
””d e
)
””e f
;
””f g
cmd
÷÷ 
.
÷÷ 
DrawMesh
÷÷ 
(
÷÷ 
m_HemisphereMesh
÷÷ -
,
÷÷- .
vl
÷÷/ 1
.
÷÷1 2 
localToWorldMatrix
÷÷2 D
,
÷÷D E'
m_StencilDeferredMaterial
÷÷F _
,
÷÷_ `
$num
÷÷a b
,
÷÷b c
$num
÷÷d e
)
÷÷e f
;
÷÷f g
cmd
◊◊ 
.
◊◊ 
DrawMesh
◊◊ 
(
◊◊ 
m_HemisphereMesh
◊◊ -
,
◊◊- .
vl
◊◊/ 1
.
◊◊1 2 
localToWorldMatrix
◊◊2 D
,
◊◊D E'
m_StencilDeferredMaterial
◊◊F _
,
◊◊_ `
$num
◊◊a b
,
◊◊b c
$num
◊◊d e
)
◊◊e f
;
◊◊f g
}
ÿÿ 
cmd
⁄⁄ 
.
⁄⁄ "
DisableShaderKeyword
⁄⁄ $
(
⁄⁄$ %"
ShaderKeywordStrings
⁄⁄% 9
.
⁄⁄9 :0
"_DEFERRED_ADDITIONAL_LIGHT_SHADOWS
⁄⁄: \
)
⁄⁄\ ]
;
⁄⁄] ^
cmd
€€ 
.
€€ "
DisableShaderKeyword
€€ $
(
€€$ %"
ShaderKeywordStrings
€€% 9
.
€€9 :
SoftShadows
€€: E
)
€€E F
;
€€F G
cmd
‹‹ 
.
‹‹ "
DisableShaderKeyword
‹‹ $
(
‹‹$ %"
ShaderKeywordStrings
‹‹% 9
.
‹‹9 :
_SPOT
‹‹: ?
)
‹‹? @
;
‹‹@ A
}
›› 	
void
ﬂﬂ 
	RenderFog
ﬂﬂ 
(
ﬂﬂ %
ScriptableRenderContext
ﬂﬂ .
context
ﬂﬂ/ 6
,
ﬂﬂ6 7
CommandBuffer
ﬂﬂ8 E
cmd
ﬂﬂF I
,
ﬂﬂI J
ref
ﬂﬂK N
RenderingData
ﬂﬂO \
renderingData
ﬂﬂ] j
)
ﬂﬂj k
{
‡‡ 	
if
‚‚ 
(
‚‚ 
!
‚‚ 
RenderSettings
‚‚ 
.
‚‚  
fog
‚‚  #
||
‚‚$ &
renderingData
‚‚' 4
.
‚‚4 5

cameraData
‚‚5 ?
.
‚‚? @
camera
‚‚@ F
.
‚‚F G
orthographic
‚‚G S
)
‚‚S T
return
„„ 
;
„„ 
if
ÂÂ 
(
ÂÂ 
m_FullscreenMesh
ÂÂ  
==
ÂÂ! #
null
ÂÂ$ (
)
ÂÂ( )
m_FullscreenMesh
ÊÊ  
=
ÊÊ! ""
CreateFullscreenMesh
ÊÊ# 7
(
ÊÊ7 8
)
ÊÊ8 9
;
ÊÊ9 :
using
ËË 
(
ËË 
new
ËË 
ProfilingScope
ËË %
(
ËË% &
cmd
ËË& )
,
ËË) */
!m_ProfilingSamplerDeferredFogPass
ËË+ L
)
ËËL M
)
ËËM N
{
ÈÈ 
cmd
ÎÎ 
.
ÎÎ 
DrawMesh
ÎÎ 
(
ÎÎ 
m_FullscreenMesh
ÎÎ -
,
ÎÎ- .
	Matrix4x4
ÎÎ/ 8
.
ÎÎ8 9
identity
ÎÎ9 A
,
ÎÎA B'
m_StencilDeferredMaterial
ÎÎC \
,
ÎÎ\ ]
$num
ÎÎ^ _
,
ÎÎ_ `
$num
ÎÎa b
)
ÎÎb c
;
ÎÎc d
}
ÏÏ 
}
ÌÌ 	
int
ÔÔ 

TrimLights
ÔÔ 
(
ÔÔ 
ref
ÔÔ 
NativeArray
ÔÔ &
<
ÔÔ& '
ushort
ÔÔ' -
>
ÔÔ- .
trimmedLights
ÔÔ/ <
,
ÔÔ< =
ref
ÔÔ> A
NativeArray
ÔÔB M
<
ÔÔM N
ushort
ÔÔN T
>
ÔÔT U
tiles
ÔÔV [
,
ÔÔ[ \
int
ÔÔ] `
offset
ÔÔa g
,
ÔÔg h
int
ÔÔi l

lightCount
ÔÔm w
,
ÔÔw x
ref
ÔÔy |
BitArrayÔÔ} Ö

usedLightsÔÔÜ ê
)ÔÔê ë
{
 	
int
ÒÒ 
	trimCount
ÒÒ 
=
ÒÒ 
$num
ÒÒ 
;
ÒÒ 
for
ÚÚ 
(
ÚÚ 
int
ÚÚ 
i
ÚÚ 
=
ÚÚ 
$num
ÚÚ 
;
ÚÚ 
i
ÚÚ 
<
ÚÚ 

lightCount
ÚÚ  *
;
ÚÚ* +
++
ÚÚ, .
i
ÚÚ. /
)
ÚÚ/ 0
{
ÛÛ 
ushort
ÙÙ 
visLightIndex
ÙÙ $
=
ÙÙ% &
tiles
ÙÙ' ,
[
ÙÙ, -
offset
ÙÙ- 3
+
ÙÙ4 5
i
ÙÙ6 7
]
ÙÙ7 8
;
ÙÙ8 9
if
ıı 
(
ıı 

usedLights
ıı 
.
ıı 
IsSet
ıı $
(
ıı$ %
visLightIndex
ıı% 2
)
ıı2 3
)
ıı3 4
continue
ˆˆ 
;
ˆˆ 
trimmedLights
˜˜ 
[
˜˜ 
	trimCount
˜˜ '
++
˜˜' )
]
˜˜) *
=
˜˜+ ,
visLightIndex
˜˜- :
;
˜˜: ;
}
¯¯ 
return
˘˘ 
	trimCount
˘˘ 
;
˘˘ 
}
˙˙ 	
void
¸¸ $
StorePunctualLightData
¸¸ #
(
¸¸# $
ref
¸¸$ '
NativeArray
¸¸( 3
<
¸¸3 4
uint4
¸¸4 9
>
¸¸9 :!
punctualLightBuffer
¸¸; N
,
¸¸N O
int
¸¸P S

storeIndex
¸¸T ^
,
¸¸^ _
ref
¸¸` c
NativeArray
¸¸d o
<
¸¸o p
VisibleLight
¸¸p |
>
¸¸| }
visibleLights¸¸~ ã
,¸¸ã å
int¸¸ç ê
index¸¸ë ñ
)¸¸ñ ó
{
˝˝ 	
int
˛˛ 

lightFlags
˛˛ 
=
˛˛ 
$num
˛˛ 
;
˛˛ 
if
ˇˇ 
(
ˇˇ 
visibleLights
ˇˇ 
[
ˇˇ 
index
ˇˇ #
]
ˇˇ# $
.
ˇˇ$ %
light
ˇˇ% *
.
ˇˇ* +
bakingOutput
ˇˇ+ 7
.
ˇˇ7 8
lightmapBakeType
ˇˇ8 H
==
ˇˇI K
LightmapBakeType
ˇˇL \
.
ˇˇ\ ]
Mixed
ˇˇ] b
)
ˇˇb c

lightFlags
ÄÄ 
|=
ÄÄ 
(
ÄÄ 
int
ÄÄ "
)
ÄÄ" #
	LightFlag
ÄÄ# ,
.
ÄÄ, -&
SubtractiveMixedLighting
ÄÄ- E
;
ÄÄE F
Vector4
ÖÖ 
lightPos
ÖÖ 
,
ÖÖ 

lightColor
ÖÖ (
,
ÖÖ( )
lightAttenuation
ÖÖ* :
,
ÖÖ: ;
lightSpotDir
ÖÖ< H
,
ÖÖH I#
lightOcclusionChannel
ÖÖJ _
;
ÖÖ_ `%
UniversalRenderPipeline
ÜÜ #
.
ÜÜ# $-
InitializeLightConstants_Common
ÜÜ$ C
(
ÜÜC D
visibleLights
ÜÜD Q
,
ÜÜQ R
index
ÜÜS X
,
ÜÜX Y
out
ÜÜZ ]
lightPos
ÜÜ^ f
,
ÜÜf g
out
ÜÜh k

lightColor
ÜÜl v
,
ÜÜv w
out
ÜÜx {
lightAttenuationÜÜ| å
,ÜÜå ç
outÜÜé ë
lightSpotDirÜÜí û
,ÜÜû ü
outÜÜ† £%
lightOcclusionChannelÜÜ§ π
)ÜÜπ ∫
;ÜÜ∫ ª!
punctualLightBuffer
àà 
[
àà  

storeIndex
àà  *
*
àà+ ,
$num
àà- .
+
àà/ 0
$num
àà1 2
]
àà2 3
=
àà4 5
new
àà6 9
uint4
àà: ?
(
àà? @
FloatToUInt
àà@ K
(
ààK L
lightPos
ààL T
.
ààT U
x
ààU V
)
ààV W
,
ààW X
FloatToUInt
ààY d
(
ààd e
lightPos
ààe m
.
ààm n
y
ààn o
)
àào p
,
ààp q
FloatToUInt
ààr }
(
àà} ~
lightPosàà~ Ü
.ààÜ á
zààá à
)ààà â
,ààâ ä
FloatToUIntààã ñ
(ààñ ó
visibleLightsààó §
[àà§ •
indexàà• ™
]àà™ ´
.àà´ ¨
rangeàà¨ ±
*àà≤ ≥
visibleLightsàà¥ ¡
[àà¡ ¬
indexàà¬ «
]àà« »
.àà» …
rangeàà… Œ
)ààŒ œ
)ààœ –
;àà– —!
punctualLightBuffer
ââ 
[
ââ  

storeIndex
ââ  *
*
ââ+ ,
$num
ââ- .
+
ââ/ 0
$num
ââ1 2
]
ââ2 3
=
ââ4 5
new
ââ6 9
uint4
ââ: ?
(
ââ? @
FloatToUInt
ââ@ K
(
ââK L

lightColor
ââL V
.
ââV W
x
ââW X
)
ââX Y
,
ââY Z
FloatToUInt
ââ[ f
(
ââf g

lightColor
ââg q
.
ââq r
y
ââr s
)
ââs t
,
âât u
FloatToUIntââv Å
(ââÅ Ç

lightColorââÇ å
.ââå ç
zââç é
)ââé è
,ââè ê
$numââë í
)ââí ì
;ââì î!
punctualLightBuffer
ää 
[
ää  

storeIndex
ää  *
*
ää+ ,
$num
ää- .
+
ää/ 0
$num
ää1 2
]
ää2 3
=
ää4 5
new
ää6 9
uint4
ää: ?
(
ää? @
FloatToUInt
ää@ K
(
ääK L
lightAttenuation
ääL \
.
ää\ ]
x
ää] ^
)
ää^ _
,
ää_ `
FloatToUInt
ääa l
(
ääl m
lightAttenuation
ääm }
.
ää} ~
y
ää~ 
)ää Ä
,ääÄ Å
FloatToUIntääÇ ç
(ääç é 
lightAttenuationääé û
.ääû ü
zääü †
)ää† °
,ää° ¢
FloatToUIntää£ Æ
(ääÆ Ø 
lightAttenuationääØ ø
.ääø ¿
wää¿ ¡
)ää¡ ¬
)ää¬ √
;ää√ ƒ!
punctualLightBuffer
ãã 
[
ãã  

storeIndex
ãã  *
*
ãã+ ,
$num
ãã- .
+
ãã/ 0
$num
ãã1 2
]
ãã2 3
=
ãã4 5
new
ãã6 9
uint4
ãã: ?
(
ãã? @
FloatToUInt
ãã@ K
(
ããK L
lightSpotDir
ããL X
.
ããX Y
x
ããY Z
)
ããZ [
,
ãã[ \
FloatToUInt
ãã] h
(
ããh i
lightSpotDir
ããi u
.
ããu v
y
ããv w
)
ããw x
,
ããx y
FloatToUIntããz Ö
(ããÖ Ü
lightSpotDirããÜ í
.ããí ì
zããì î
)ããî ï
,ããï ñ
(ããó ò
uintããò ú
)ããú ù

lightFlagsããù ß
)ããß ®
;ãã® ©!
punctualLightBuffer
åå 
[
åå  

storeIndex
åå  *
*
åå+ ,
$num
åå- .
+
åå/ 0
$num
åå1 2
]
åå2 3
=
åå4 5
new
åå6 9
uint4
åå: ?
(
åå? @
FloatToUInt
åå@ K
(
ååK L#
lightOcclusionChannel
ååL a
.
ååa b
x
ååb c
)
ååc d
,
ååd e
FloatToUInt
ååf q
(
ååq r$
lightOcclusionChannelåår á
.ååá à
yååà â
)ååâ ä
,ååä ã
FloatToUIntååå ó
(ååó ò%
lightOcclusionChannelååò ≠
.åå≠ Æ
zååÆ Ø
)ååØ ∞
,åå∞ ±
FloatToUIntåå≤ Ω
(ååΩ æ%
lightOcclusionChannelååæ ”
.åå” ‘
wåå‘ ’
)åå’ ÷
)åå÷ ◊
;åå◊ ÿ
}
çç 	
void
èè 
StoreTileData
èè 
(
èè 
ref
èè 
NativeArray
èè *
<
èè* +
uint4
èè+ 0
>
èè0 1
tileList
èè2 :
,
èè: ;
int
èè< ?

storeIndex
èè@ J
,
èèJ K
uint
èèL P
tileID
èèQ W
,
èèW X
uint
èèY ]
listBitMask
èè^ i
,
èèi j
ushort
èèk q
relLightOffsetèèr Ä
,èèÄ Å
ushortèèÇ à

lightCountèèâ ì
)èèì î
{
êê 	
tileList
íí 
[
íí 

storeIndex
íí 
]
íí  
=
íí! "
new
íí# &
uint4
íí' ,
{
íí- .
x
íí/ 0
=
íí1 2
tileID
íí3 9
,
íí9 :
y
íí; <
=
íí= >
listBitMask
íí? J
,
ííJ K
z
ííL M
=
ííN O
relLightOffset
ííP ^
|
íí_ `
(
íía b
(
ííb c
uint
ííc g
)
ííg h

lightCount
ííh r
<<
íís u
$num
íív x
)
ííx y
,
ííy z
w
íí{ |
=
íí} ~
$numíí Ä
}ííÅ Ç
;ííÇ É
}
ìì 	
[
ïï 	

MethodImpl
ïï	 
(
ïï 
MethodImplOptions
ïï %
.
ïï% & 
AggressiveInlining
ïï& 8
)
ïï8 9
]
ïï9 :
bool
ññ 
IsTileLight
ññ 
(
ññ 
VisibleLight
ññ %
visibleLight
ññ& 2
)
ññ2 3
{
óó 	
return
öö 
(
öö 
visibleLight
öö  
.
öö  !
	lightType
öö! *
==
öö+ -
	LightType
öö. 7
.
öö7 8
Point
öö8 =
&&
öö> @
(
ööA B
visibleLight
ööB N
.
ööN O
light
ööO T
==
ööU W
null
ööX \
||
öö] _
visibleLight
öö` l
.
ööl m
light
ööm r
.
öör s
shadows
öös z
==
öö{ }
LightShadowsöö~ ä
.ööä ã
Noneööã è
)ööè ê
)ööê ë
||
õõ 
(
õõ 
visibleLight
õõ  
.
õõ  !
	lightType
õõ! *
==
õõ, .
	LightType
õõ/ 8
.
õõ8 9
Spot
õõ9 =
&&
õõ> @
(
õõA B
visibleLight
õõB N
.
õõN O
light
õõO T
==
õõU W
null
õõX \
||
õõ] _
visibleLight
õõ` l
.
õõl m
light
õõm r
.
õõr s
shadows
õõs z
==
õõ{ }
LightShadowsõõ~ ä
.õõä ã
Noneõõã è
)õõè ê
)õõê ë
;õõë í
}
úú 	
static
ûû 
Mesh
ûû 
CreateSphereMesh
ûû $
(
ûû$ %
)
ûû% &
{
üü 	
Vector3
££ 
[
££ 
]
££ 
	positions
££ 
=
££  !
{
££" #
new
§§ 
Vector3
§§ 
(
§§ 
$num
§§ #
,
§§# $
$num
§§& ,
,
§§, -
-
§§. /
$num
§§/ 5
)
§§5 6
,
§§6 7
new
§§8 ;
Vector3
§§< C
(
§§C D
$num
§§E K
,
§§K L
-
§§M N
$num
§§N T
,
§§T U
-
§§V W
$num
§§W ]
)
§§] ^
,
§§^ _
new
•• 
Vector3
•• 
(
•• 
-
•• 
$num
•• #
,
••# $
-
••% &
$num
••& ,
,
••, -
-
••. /
$num
••/ 5
)
••5 6
,
••6 7
new
••8 ;
Vector3
••< C
(
••C D
$num
••E K
,
••K L
$num
••N T
,
••T U
-
••V W
$num
••W ]
)
••] ^
,
••^ _
new
¶¶ 
Vector3
¶¶ 
(
¶¶ 
-
¶¶ 
$num
¶¶ #
,
¶¶# $
$num
¶¶& ,
,
¶¶, -
-
¶¶. /
$num
¶¶/ 5
)
¶¶5 6
,
¶¶6 7
new
¶¶8 ;
Vector3
¶¶< C
(
¶¶C D
$num
¶¶E K
,
¶¶K L
$num
¶¶N T
,
¶¶T U
-
¶¶V W
$num
¶¶W ]
)
¶¶] ^
,
¶¶^ _
new
ßß 
Vector3
ßß 
(
ßß 
-
ßß 
$num
ßß #
,
ßß# $
-
ßß% &
$num
ßß& ,
,
ßß, -
-
ßß. /
$num
ßß/ 5
)
ßß5 6
,
ßß6 7
new
ßß8 ;
Vector3
ßß< C
(
ßßC D
$num
ßßE K
,
ßßK L
-
ßßM N
$num
ßßN T
,
ßßT U
-
ßßV W
$num
ßßW ]
)
ßß] ^
,
ßß^ _
new
®® 
Vector3
®® 
(
®® 
$num
®® #
,
®®# $
-
®®% &
$num
®®& ,
,
®®, -
-
®®. /
$num
®®/ 5
)
®®5 6
,
®®6 7
new
®®8 ;
Vector3
®®< C
(
®®C D
-
®®D E
$num
®®E K
,
®®K L
$num
®®N T
,
®®T U
-
®®V W
$num
®®W ]
)
®®] ^
,
®®^ _
new
©© 
Vector3
©© 
(
©© 
-
©© 
$num
©© #
,
©©# $
-
©©% &
$num
©©& ,
,
©©, -
-
©©. /
$num
©©/ 5
)
©©5 6
,
©©6 7
new
©©8 ;
Vector3
©©< C
(
©©C D
$num
©©E K
,
©©K L
-
©©M N
$num
©©N T
,
©©T U
$num
©©W ]
)
©©] ^
,
©©^ _
new
™™ 
Vector3
™™ 
(
™™ 
-
™™ 
$num
™™ #
,
™™# $
-
™™% &
$num
™™& ,
,
™™, -
$num
™™/ 5
)
™™5 6
,
™™6 7
new
™™8 ;
Vector3
™™< C
(
™™C D
$num
™™E K
,
™™K L
-
™™M N
$num
™™N T
,
™™T U
$num
™™W ]
)
™™] ^
,
™™^ _
new
´´ 
Vector3
´´ 
(
´´ 
-
´´ 
$num
´´ #
,
´´# $
-
´´% &
$num
´´& ,
,
´´, -
$num
´´/ 5
)
´´5 6
,
´´6 7
new
´´8 ;
Vector3
´´< C
(
´´C D
$num
´´E K
,
´´K L
$num
´´N T
,
´´T U
-
´´V W
$num
´´W ]
)
´´] ^
,
´´^ _
new
¨¨ 
Vector3
¨¨ 
(
¨¨ 
$num
¨¨ #
,
¨¨# $
$num
¨¨& ,
,
¨¨, -
-
¨¨. /
$num
¨¨/ 5
)
¨¨5 6
,
¨¨6 7
new
¨¨8 ;
Vector3
¨¨< C
(
¨¨C D
$num
¨¨E K
,
¨¨K L
-
¨¨M N
$num
¨¨N T
,
¨¨T U
$num
¨¨W ]
)
¨¨] ^
,
¨¨^ _
new
≠≠ 
Vector3
≠≠ 
(
≠≠ 
$num
≠≠ #
,
≠≠# $
$num
≠≠& ,
,
≠≠, -
$num
≠≠/ 5
)
≠≠5 6
,
≠≠6 7
new
≠≠8 ;
Vector3
≠≠< C
(
≠≠C D
-
≠≠D E
$num
≠≠E K
,
≠≠K L
-
≠≠M N
$num
≠≠N T
,
≠≠T U
$num
≠≠W ]
)
≠≠] ^
,
≠≠^ _
new
ÆÆ 
Vector3
ÆÆ 
(
ÆÆ 
$num
ÆÆ #
,
ÆÆ# $
-
ÆÆ% &
$num
ÆÆ& ,
,
ÆÆ, -
$num
ÆÆ/ 5
)
ÆÆ5 6
,
ÆÆ6 7
new
ÆÆ8 ;
Vector3
ÆÆ< C
(
ÆÆC D
$num
ÆÆE K
,
ÆÆK L
-
ÆÆM N
$num
ÆÆN T
,
ÆÆT U
$num
ÆÆW ]
)
ÆÆ] ^
,
ÆÆ^ _
new
ØØ 
Vector3
ØØ 
(
ØØ 
-
ØØ 
$num
ØØ #
,
ØØ# $
-
ØØ% &
$num
ØØ& ,
,
ØØ, -
$num
ØØ/ 5
)
ØØ5 6
,
ØØ6 7
new
ØØ8 ;
Vector3
ØØ< C
(
ØØC D
$num
ØØE K
,
ØØK L
$num
ØØN T
,
ØØT U
$num
ØØW ]
)
ØØ] ^
,
ØØ^ _
new
∞∞ 
Vector3
∞∞ 
(
∞∞ 
$num
∞∞ #
,
∞∞# $
-
∞∞% &
$num
∞∞& ,
,
∞∞, -
$num
∞∞/ 5
)
∞∞5 6
,
∞∞6 7
new
∞∞8 ;
Vector3
∞∞< C
(
∞∞C D
-
∞∞D E
$num
∞∞E K
,
∞∞K L
-
∞∞M N
$num
∞∞N T
,
∞∞T U
$num
∞∞W ]
)
∞∞] ^
,
∞∞^ _
new
±± 
Vector3
±± 
(
±± 
$num
±± #
,
±±# $
$num
±±& ,
,
±±, -
$num
±±/ 5
)
±±5 6
,
±±6 7
new
±±8 ;
Vector3
±±< C
(
±±C D
$num
±±E K
,
±±K L
$num
±±N T
,
±±T U
$num
±±W ]
)
±±] ^
,
±±^ _
new
≤≤ 
Vector3
≤≤ 
(
≤≤ 
$num
≤≤ #
,
≤≤# $
$num
≤≤& ,
,
≤≤, -
$num
≤≤/ 5
)
≤≤5 6
,
≤≤6 7
new
≤≤8 ;
Vector3
≤≤< C
(
≤≤C D
$num
≤≤E K
,
≤≤K L
$num
≤≤N T
,
≤≤T U
$num
≤≤W ]
)
≤≤] ^
,
≤≤^ _
new
≥≥ 
Vector3
≥≥ 
(
≥≥ 
-
≥≥ 
$num
≥≥ #
,
≥≥# $
$num
≥≥& ,
,
≥≥, -
$num
≥≥/ 5
)
≥≥5 6
,
≥≥6 7
new
≥≥8 ;
Vector3
≥≥< C
(
≥≥C D
-
≥≥D E
$num
≥≥E K
,
≥≥K L
$num
≥≥N T
,
≥≥T U
$num
≥≥W ]
)
≥≥] ^
,
≥≥^ _
new
¥¥ 
Vector3
¥¥ 
(
¥¥ 
$num
¥¥ #
,
¥¥# $
$num
¥¥& ,
,
¥¥, -
$num
¥¥/ 5
)
¥¥5 6
,
¥¥6 7
new
¥¥8 ;
Vector3
¥¥< C
(
¥¥C D
-
¥¥D E
$num
¥¥E K
,
¥¥K L
$num
¥¥N T
,
¥¥T U
$num
¥¥W ]
)
¥¥] ^
,
¥¥^ _
new
µµ 
Vector3
µµ 
(
µµ 
$num
µµ #
,
µµ# $
$num
µµ& ,
,
µµ, -
-
µµ. /
$num
µµ/ 5
)
µµ5 6
,
µµ6 7
new
µµ8 ;
Vector3
µµ< C
(
µµC D
-
µµD E
$num
µµE K
,
µµK L
$num
µµN T
,
µµT U
$num
µµW ]
)
µµ] ^
,
µµ^ _
new
∂∂ 
Vector3
∂∂ 
(
∂∂ 
-
∂∂ 
$num
∂∂ #
,
∂∂# $
$num
∂∂& ,
,
∂∂, -
$num
∂∂/ 5
)
∂∂5 6
,
∂∂6 7
new
∂∂8 ;
Vector3
∂∂< C
(
∂∂C D
-
∂∂D E
$num
∂∂E K
,
∂∂K L
$num
∂∂N T
,
∂∂T U
$num
∂∂W ]
)
∂∂] ^
,
∂∂^ _
new
∑∑ 
Vector3
∑∑ 
(
∑∑ 
$num
∑∑ #
,
∑∑# $
$num
∑∑& ,
,
∑∑, -
$num
∑∑/ 5
)
∑∑5 6
,
∑∑6 7
new
∑∑8 ;
Vector3
∑∑< C
(
∑∑C D
-
∑∑D E
$num
∑∑E K
,
∑∑K L
$num
∑∑N T
,
∑∑T U
-
∑∑V W
$num
∑∑W ]
)
∑∑] ^
,
∑∑^ _
new
∏∏ 
Vector3
∏∏ 
(
∏∏ 
-
∏∏ 
$num
∏∏ #
,
∏∏# $
$num
∏∏& ,
,
∏∏, -
-
∏∏. /
$num
∏∏/ 5
)
∏∏5 6
,
∏∏6 7
new
∏∏8 ;
Vector3
∏∏< C
(
∏∏C D
-
∏∏D E
$num
∏∏E K
,
∏∏K L
$num
∏∏N T
,
∏∏T U
$num
∏∏W ]
)
∏∏] ^
,
∏∏^ _
}
ππ 
;
ππ 
int
ªª 
[
ªª 
]
ªª 
indices
ªª 
=
ªª 
{
ªª 
$num
ºº 
,
ºº 
$num
ºº 
,
ºº 
$num
ºº 
,
ºº 
$num
ºº 
,
ºº 
$num
ºº! "
,
ºº" #
$num
ºº% &
,
ºº& '
$num
ºº) *
,
ºº* +
$num
ºº- .
,
ºº. /
$num
ºº1 2
,
ºº2 3
$num
ºº5 6
,
ºº6 7
$num
ºº9 :
,
ºº: ;
$num
ºº= >
,
ºº> ?
$num
ººA B
,
ººB C
$num
ººE F
,
ººF G
$num
ººI J
,
ººJ K
$num
ººM N
,
ººN O
$num
ººQ R
,
ººR S
$num
ººU V
,
ººV W
$num
ΩΩ 
,
ΩΩ 
$num
ΩΩ 
,
ΩΩ 
$num
ΩΩ 
,
ΩΩ 
$num
ΩΩ 
,
ΩΩ 
$num
ΩΩ! "
,
ΩΩ" #
$num
ΩΩ% &
,
ΩΩ& '
$num
ΩΩ) *
,
ΩΩ* +
$num
ΩΩ- .
,
ΩΩ. /
$num
ΩΩ1 2
,
ΩΩ2 3
$num
ΩΩ5 6
,
ΩΩ6 7
$num
ΩΩ9 :
,
ΩΩ: ;
$num
ΩΩ= >
,
ΩΩ> ?
$num
ΩΩA B
,
ΩΩB C
$num
ΩΩE F
,
ΩΩF G
$num
ΩΩH J
,
ΩΩJ K
$num
ΩΩL N
,
ΩΩN O
$num
ΩΩQ R
,
ΩΩR S
$num
ΩΩU V
,
ΩΩV W
$num
ææ 
,
ææ 
$num
ææ 
,
ææ 
$num
ææ 
,
ææ 
$num
ææ 
,
ææ 
$num
ææ  "
,
ææ" #
$num
ææ$ &
,
ææ& '
$num
ææ( *
,
ææ* +
$num
ææ, .
,
ææ. /
$num
ææ1 2
,
ææ2 3
$num
ææ5 6
,
ææ6 7
$num
ææ8 :
,
ææ: ;
$num
ææ= >
,
ææ> ?
$num
ææA B
,
ææB C
$num
ææD F
,
ææF G
$num
ææH J
,
ææJ K
$num
ææL N
,
ææN O
$num
ææP R
,
ææR S
$num
ææU V
,
ææV W
$num
øø 
,
øø 
$num
øø 
,
øø 
$num
øø 
,
øø 
$num
øø 
,
øø 
$num
øø  "
,
øø" #
$num
øø% &
,
øø& '
$num
øø) *
,
øø* +
$num
øø, .
,
øø. /
$num
øø1 2
,
øø2 3
$num
øø5 6
,
øø6 7
$num
øø8 :
,
øø: ;
$num
øø< >
,
øø> ?
$num
øø@ B
,
øøB C
$num
øøD F
,
øøF G
$num
øøI J
,
øøJ K
$num
øøL N
,
øøN O
$num
øøP R
,
øøR S
$num
øøU V
,
øøV W
$num
¿¿ 
,
¿¿ 
$num
¿¿ 
,
¿¿ 
$num
¿¿ 
,
¿¿ 
$num
¿¿ 
,
¿¿ 
$num
¿¿  "
,
¿¿" #
$num
¿¿$ &
,
¿¿& '
$num
¿¿( *
,
¿¿* +
$num
¿¿, .
,
¿¿. /
$num
¿¿0 2
,
¿¿2 3
$num
¿¿4 6
,
¿¿6 7
$num
¿¿8 :
,
¿¿: ;
$num
¿¿< >
,
¿¿> ?
$num
¿¿@ B
,
¿¿B C
$num
¿¿D F
,
¿¿F G
$num
¿¿H J
,
¿¿J K
$num
¿¿L N
,
¿¿N O
$num
¿¿P R
,
¿¿R S
$num
¿¿T V
,
¿¿V W
$num
¡¡ 
,
¡¡ 
$num
¡¡ 
,
¡¡ 
$num
¡¡ 
,
¡¡ 
$num
¡¡ 
,
¡¡ 
$num
¡¡  "
,
¡¡" #
$num
¡¡$ &
,
¡¡& '
$num
¡¡( *
,
¡¡* +
$num
¡¡, .
,
¡¡. /
$num
¡¡0 2
,
¡¡2 3
$num
¡¡4 6
,
¡¡6 7
$num
¡¡8 :
,
¡¡: ;
$num
¡¡< >
,
¡¡> ?
$num
¡¡@ B
,
¡¡B C
$num
¡¡D F
,
¡¡F G
$num
¡¡H J
,
¡¡J K
$num
¡¡L N
,
¡¡N O
$num
¡¡P R
,
¡¡R S
$num
¡¡T V
,
¡¡V W
$num
¬¬ 
,
¬¬ 
$num
¬¬ 
,
¬¬ 
$num
¬¬ 
,
¬¬ 
$num
¬¬ 
,
¬¬ 
$num
¬¬  "
,
¬¬" #
$num
¬¬$ &
,
¬¬& '
$num
¬¬( *
,
¬¬* +
$num
¬¬, .
,
¬¬. /
$num
¬¬0 2
,
¬¬2 3
$num
¬¬4 6
,
¬¬6 7
$num
¬¬8 :
,
¬¬: ;
$num
¬¬< >
,
¬¬> ?
$num
¬¬@ B
,
¬¬B C
$num
¬¬D F
,
¬¬F G
$num
¬¬H J
,
¬¬J K
$num
¬¬L N
,
¬¬N O
$num
¬¬P R
,
¬¬R S
$num
¬¬T V
,
¬¬V W
$num
√√ 
,
√√ 
$num
√√ 
,
√√ 
$num
√√ 
,
√√ 
$num
√√ 
,
√√ 
$num
√√  "
,
√√" #
$num
√√$ &
,
√√& '
$num
√√( *
,
√√* +
$num
√√, .
,
√√. /
$num
√√0 2
,
√√2 3
$num
√√4 6
,
√√6 7
$num
√√8 :
,
√√: ;
$num
√√< >
,
√√> ?
$num
√√@ B
,
√√B C
$num
√√D F
,
√√F G
$num
√√H J
,
√√J K
$num
√√L N
,
√√N O
$num
√√P R
,
√√R S
$num
√√T V
,
√√V W
$num
ƒƒ 
,
ƒƒ 
$num
ƒƒ 
,
ƒƒ 
$num
ƒƒ 
,
ƒƒ 
$num
ƒƒ 
,
ƒƒ 
$num
ƒƒ  "
,
ƒƒ" #
$num
ƒƒ$ &
,
ƒƒ& '
$num
ƒƒ( *
,
ƒƒ* +
$num
ƒƒ, .
,
ƒƒ. /
$num
ƒƒ0 2
,
ƒƒ2 3
$num
ƒƒ4 6
,
ƒƒ6 7
$num
ƒƒ8 :
,
ƒƒ: ;
$num
ƒƒ< >
,
ƒƒ> ?
$num
ƒƒ@ B
,
ƒƒB C
$num
ƒƒD F
,
ƒƒF G
$num
ƒƒH J
,
ƒƒJ K
$num
ƒƒL N
,
ƒƒN O
$num
ƒƒP R
,
ƒƒR S
$num
ƒƒT V
,
ƒƒV W
$num
≈≈ 
,
≈≈ 
$num
≈≈ 
,
≈≈ 
$num
≈≈ 
,
≈≈ 
$num
≈≈ 
,
≈≈ 
$num
≈≈  "
,
≈≈" #
$num
≈≈$ &
,
≈≈& '
$num
≈≈( *
,
≈≈* +
$num
≈≈, .
,
≈≈. /
$num
≈≈0 2
,
≈≈2 3
$num
≈≈5 6
,
≈≈6 7
$num
≈≈8 :
,
≈≈: ;
$num
≈≈< >
,
≈≈> ?
$num
≈≈@ B
,
≈≈B C
$num
≈≈D F
,
≈≈F G
$num
≈≈H J
,
≈≈J K
$num
≈≈L N
,
≈≈N O
$num
≈≈P R
,
≈≈R S
$num
≈≈U V
,
≈≈V W
$num
∆∆ 
,
∆∆ 
$num
∆∆ 
,
∆∆ 
$num
∆∆ 
,
∆∆ 
$num
∆∆ 
,
∆∆ 
$num
∆∆  "
,
∆∆" #
$num
∆∆$ &
,
∆∆& '
$num
∆∆( *
,
∆∆* +
$num
∆∆, .
,
∆∆. /
$num
∆∆0 2
,
∆∆2 3
$num
∆∆4 6
,
∆∆6 7
$num
∆∆8 :
,
∆∆: ;
$num
∆∆< >
,
∆∆> ?
$num
∆∆@ B
,
∆∆B C
$num
∆∆D F
,
∆∆F G
$num
∆∆H J
,
∆∆J K
$num
∆∆L N
,
∆∆N O
$num
∆∆P R
,
∆∆R S
$num
∆∆T V
,
∆∆V W
$num
«« 
,
«« 
$num
«« 
,
«« 
$num
«« 
,
«« 
$num
«« 
,
«« 
$num
««  "
,
««" #
$num
««$ &
,
««& '
$num
««) *
,
««* +
$num
««, .
,
««. /
$num
««0 2
,
««2 3
$num
««4 6
,
««6 7
$num
««8 :
,
««: ;
$num
««< >
,
««> ?
$num
««A B
,
««B C
$num
««D F
,
««F G
$num
««I J
,
««J K
$num
««M N
,
««N O
$num
««P R
,
««R S
$num
««U V
,
««V W
$num
»» 
,
»» 
$num
»» 
,
»» 
$num
»» 
,
»» 
$num
»» 
,
»» 
$num
»»  "
,
»»" #
$num
»»$ &
,
»»& '
$num
»»( *
,
»»* +
$num
»», .
,
»». /
$num
»»0 2
,
»»2 3
$num
»»4 6
,
»»6 7
$num
»»8 :
,
»»: ;
$num
»»< >
,
»»> ?
$num
»»@ B
,
»»B C
$num
»»D F
,
»»F G
$num
»»H J
,
»»J K
$num
»»L N
,
»»N O
$num
»»P R
,
»»R S
$num
»»T V
,
»»V W
$num
…… 
,
…… 
$num
…… 
,
…… 
$num
…… 
,
…… 
$num
…… 
,
…… 
$num
……  "
,
……" #
$num
……$ &
,
……& '
}
   
;
   
Mesh
ÕÕ 
mesh
ÕÕ 
=
ÕÕ 
new
ÕÕ 
Mesh
ÕÕ  
(
ÕÕ  !
)
ÕÕ! "
;
ÕÕ" #
mesh
ŒŒ 
.
ŒŒ 
indexFormat
ŒŒ 
=
ŒŒ 
IndexFormat
ŒŒ *
.
ŒŒ* +
UInt16
ŒŒ+ 1
;
ŒŒ1 2
mesh
œœ 
.
œœ 
vertices
œœ 
=
œœ 
	positions
œœ %
;
œœ% &
mesh
–– 
.
–– 
	triangles
–– 
=
–– 
indices
–– $
;
––$ %
return
““ 
mesh
““ 
;
““ 
}
”” 	
static
’’ 
Mesh
’’ "
CreateHemisphereMesh
’’ (
(
’’( )
)
’’) *
{
÷÷ 	
Vector3
⁄⁄ 
[
⁄⁄ 
]
⁄⁄ 
	positions
⁄⁄  
=
⁄⁄! "
{
⁄⁄# $
new
€€ 
Vector3
€€ 
(
€€ 
$num
€€ %
,
€€% &
$num
€€' 0
,
€€0 1
$num
€€2 ;
)
€€; <
,
€€< =
new
€€> A
Vector3
€€B I
(
€€I J
$num
€€J S
,
€€S T
$num
€€U ^
,
€€^ _
$num
€€` i
)
€€i j
,
€€j k
new
‹‹ 
Vector3
‹‹ 
(
‹‹ 
$num
‹‹ %
,
‹‹% &
$num
‹‹' 0
,
‹‹0 1
$num
‹‹2 ;
)
‹‹; <
,
‹‹< =
new
‹‹> A
Vector3
‹‹B I
(
‹‹I J
$num
‹‹J S
,
‹‹S T
$num
‹‹U ^
,
‹‹^ _
$num
‹‹` i
)
‹‹i j
,
‹‹j k
new
›› 
Vector3
›› 
(
›› 
$num
›› %
,
››% &
$num
››' 0
,
››0 1
$num
››2 ;
)
››; <
,
››< =
new
››> A
Vector3
››B I
(
››I J
-
››J K
$num
››K T
,
››T U
$num
››V _
,
››_ `
$num
››a j
)
››j k
,
››k l
new
ﬁﬁ 
Vector3
ﬁﬁ 
(
ﬁﬁ 
-
ﬁﬁ 
$num
ﬁﬁ &
,
ﬁﬁ& '
$num
ﬁﬁ( 1
,
ﬁﬁ1 2
$num
ﬁﬁ3 <
)
ﬁﬁ< =
,
ﬁﬁ= >
new
ﬁﬁ? B
Vector3
ﬁﬁC J
(
ﬁﬁJ K
-
ﬁﬁK L
$num
ﬁﬁL U
,
ﬁﬁU V
$num
ﬁﬁW `
,
ﬁﬁ` a
$num
ﬁﬁb k
)
ﬁﬁk l
,
ﬁﬁl m
new
ﬂﬂ 
Vector3
ﬂﬂ 
(
ﬂﬂ 
-
ﬂﬂ 
$num
ﬂﬂ &
,
ﬂﬂ& '
$num
ﬂﬂ( 1
,
ﬂﬂ1 2
$num
ﬂﬂ3 <
)
ﬂﬂ< =
,
ﬂﬂ= >
new
ﬂﬂ? B
Vector3
ﬂﬂC J
(
ﬂﬂJ K
-
ﬂﬂK L
$num
ﬂﬂL U
,
ﬂﬂU V
-
ﬂﬂW X
$num
ﬂﬂX a
,
ﬂﬂa b
$num
ﬂﬂc l
)
ﬂﬂl m
,
ﬂﬂm n
new
‡‡ 
Vector3
‡‡ 
(
‡‡ 
-
‡‡ 
$num
‡‡ &
,
‡‡& '
-
‡‡( )
$num
‡‡) 2
,
‡‡2 3
$num
‡‡4 =
)
‡‡= >
,
‡‡> ?
new
‡‡@ C
Vector3
‡‡D K
(
‡‡K L
-
‡‡L M
$num
‡‡M V
,
‡‡V W
-
‡‡X Y
$num
‡‡Y b
,
‡‡b c
$num
‡‡d m
)
‡‡m n
,
‡‡n o
new
·· 
Vector3
·· 
(
·· 
-
·· 
$num
·· &
,
··& '
-
··( )
$num
··) 2
,
··2 3
$num
··4 =
)
··= >
,
··> ?
new
··@ C
Vector3
··D K
(
··K L
$num
··L U
,
··U V
-
··W X
$num
··X a
,
··a b
$num
··c l
)
··l m
,
··m n
new
‚‚ 
Vector3
‚‚ 
(
‚‚ 
$num
‚‚ %
,
‚‚% &
-
‚‚' (
$num
‚‚( 1
,
‚‚1 2
$num
‚‚3 <
)
‚‚< =
,
‚‚= >
new
‚‚? B
Vector3
‚‚C J
(
‚‚J K
$num
‚‚K T
,
‚‚T U
-
‚‚V W
$num
‚‚W `
,
‚‚` a
$num
‚‚b k
)
‚‚k l
,
‚‚l m
new
„„ 
Vector3
„„ 
(
„„ 
$num
„„ %
,
„„% &
-
„„' (
$num
„„( 1
,
„„1 2
$num
„„3 <
)
„„< =
,
„„= >
new
„„? B
Vector3
„„C J
(
„„J K
$num
„„K T
,
„„T U
$num
„„V _
,
„„_ `
$num
„„a j
)
„„j k
,
„„k l
new
‰‰ 
Vector3
‰‰ 
(
‰‰ 
$num
‰‰ %
,
‰‰% &
$num
‰‰' 0
,
‰‰0 1
$num
‰‰2 ;
)
‰‰; <
,
‰‰< =
new
‰‰> A
Vector3
‰‰B I
(
‰‰I J
$num
‰‰J S
,
‰‰S T
-
‰‰U V
$num
‰‰V _
,
‰‰_ `
$num
‰‰a j
)
‰‰j k
,
‰‰k l
new
ÂÂ 
Vector3
ÂÂ 
(
ÂÂ 
$num
ÂÂ %
,
ÂÂ% &
$num
ÂÂ' 0
,
ÂÂ0 1
$num
ÂÂ2 ;
)
ÂÂ; <
,
ÂÂ< =
new
ÂÂ> A
Vector3
ÂÂB I
(
ÂÂI J
-
ÂÂJ K
$num
ÂÂK T
,
ÂÂT U
$num
ÂÂV _
,
ÂÂ_ `
$num
ÂÂa j
)
ÂÂj k
,
ÂÂk l
new
ÊÊ 
Vector3
ÊÊ 
(
ÊÊ 
$num
ÊÊ %
,
ÊÊ% &
-
ÊÊ' (
$num
ÊÊ( 1
,
ÊÊ1 2
$num
ÊÊ3 <
)
ÊÊ< =
,
ÊÊ= >
new
ÊÊ? B
Vector3
ÊÊC J
(
ÊÊJ K
$num
ÊÊK T
,
ÊÊT U
-
ÊÊV W
$num
ÊÊW `
,
ÊÊ` a
$num
ÊÊb k
)
ÊÊk l
,
ÊÊl m
new
ÁÁ 
Vector3
ÁÁ 
(
ÁÁ 
$num
ÁÁ %
,
ÁÁ% &
-
ÁÁ' (
$num
ÁÁ( 1
,
ÁÁ1 2
$num
ÁÁ3 <
)
ÁÁ< =
,
ÁÁ= >
new
ÁÁ? B
Vector3
ÁÁC J
(
ÁÁJ K
$num
ÁÁK T
,
ÁÁT U
$num
ÁÁV _
,
ÁÁ_ `
$num
ÁÁa j
)
ÁÁj k
,
ÁÁk l
new
ËË 
Vector3
ËË 
(
ËË 
$num
ËË %
,
ËË% &
$num
ËË' 0
,
ËË0 1
$num
ËË2 ;
)
ËË; <
,
ËË< =
new
ËË> A
Vector3
ËËB I
(
ËËI J
$num
ËËJ S
,
ËËS T
$num
ËËU ^
,
ËË^ _
$num
ËË` i
)
ËËi j
,
ËËj k
new
ÈÈ 
Vector3
ÈÈ 
(
ÈÈ 
-
ÈÈ 
$num
ÈÈ &
,
ÈÈ& '
$num
ÈÈ( 1
,
ÈÈ1 2
$num
ÈÈ3 <
)
ÈÈ< =
,
ÈÈ= >
new
ÈÈ? B
Vector3
ÈÈC J
(
ÈÈJ K
-
ÈÈK L
$num
ÈÈL U
,
ÈÈU V
$num
ÈÈW `
,
ÈÈ` a
$num
ÈÈb k
)
ÈÈk l
,
ÈÈl m
new
ÍÍ 
Vector3
ÍÍ 
(
ÍÍ 
-
ÍÍ 
$num
ÍÍ &
,
ÍÍ& '
$num
ÍÍ( 1
,
ÍÍ1 2
$num
ÍÍ3 <
)
ÍÍ< =
,
ÍÍ= >
new
ÍÍ? B
Vector3
ÍÍC J
(
ÍÍJ K
-
ÍÍK L
$num
ÍÍL U
,
ÍÍU V
-
ÍÍW X
$num
ÍÍX a
,
ÍÍa b
$num
ÍÍc l
)
ÍÍl m
,
ÍÍm n
new
ÎÎ 
Vector3
ÎÎ 
(
ÎÎ 
-
ÎÎ 
$num
ÎÎ &
,
ÎÎ& '
-
ÎÎ( )
$num
ÎÎ) 2
,
ÎÎ2 3
$num
ÎÎ4 =
)
ÎÎ= >
,
ÎÎ> ?
new
ÎÎ@ C
Vector3
ÎÎD K
(
ÎÎK L
-
ÎÎL M
$num
ÎÎM V
,
ÎÎV W
-
ÎÎX Y
$num
ÎÎY b
,
ÎÎb c
$num
ÎÎd m
)
ÎÎm n
,
ÎÎn o
new
ÏÏ 
Vector3
ÏÏ 
(
ÏÏ 
$num
ÏÏ %
,
ÏÏ% &
-
ÏÏ' (
$num
ÏÏ( 1
,
ÏÏ1 2
$num
ÏÏ3 <
)
ÏÏ< =
,
ÏÏ= >
new
ÏÏ? B
Vector3
ÏÏC J
(
ÏÏJ K
$num
ÏÏK T
,
ÏÏT U
$num
ÏÏV _
,
ÏÏ_ `
$num
ÏÏa j
)
ÏÏj k
,
ÏÏk l
new
ÌÌ 
Vector3
ÌÌ 
(
ÌÌ 
$num
ÌÌ %
,
ÌÌ% &
-
ÌÌ' (
$num
ÌÌ( 1
,
ÌÌ1 2
$num
ÌÌ3 <
)
ÌÌ< =
,
ÌÌ= >
new
ÌÌ? B
Vector3
ÌÌC J
(
ÌÌJ K
$num
ÌÌK T
,
ÌÌT U
$num
ÌÌV _
,
ÌÌ_ `
$num
ÌÌa j
)
ÌÌj k
,
ÌÌk l
new
ÓÓ 
Vector3
ÓÓ 
(
ÓÓ 
$num
ÓÓ %
,
ÓÓ% &
$num
ÓÓ' 0
,
ÓÓ0 1
$num
ÓÓ2 ;
)
ÓÓ; <
,
ÓÓ< =
new
ÓÓ> A
Vector3
ÓÓB I
(
ÓÓI J
$num
ÓÓJ S
,
ÓÓS T
$num
ÓÓU ^
,
ÓÓ^ _
$num
ÓÓ` i
)
ÓÓi j
,
ÓÓj k
new
ÔÔ 
Vector3
ÔÔ 
(
ÔÔ 
-
ÔÔ 
$num
ÔÔ &
,
ÔÔ& '
$num
ÔÔ( 1
,
ÔÔ1 2
$num
ÔÔ3 <
)
ÔÔ< =
,
ÔÔ= >
new
ÔÔ? B
Vector3
ÔÔC J
(
ÔÔJ K
-
ÔÔK L
$num
ÔÔL U
,
ÔÔU V
$num
ÔÔW `
,
ÔÔ` a
$num
ÔÔb k
)
ÔÔk l
}
 
;
 
int
ÚÚ 
[
ÚÚ 
]
ÚÚ 
indices
ÚÚ 
=
ÚÚ 
{
ÚÚ 
$num
ÛÛ 
,
ÛÛ 
$num
ÛÛ 
,
ÛÛ 
$num
ÛÛ 
,
ÛÛ 
$num
ÛÛ 
,
ÛÛ 
$num
ÛÛ 
,
ÛÛ 
$num
ÛÛ  
,
ÛÛ  !
$num
ÛÛ" #
,
ÛÛ# $
$num
ÛÛ% &
,
ÛÛ& '
$num
ÛÛ( )
,
ÛÛ) *
$num
ÛÛ+ ,
,
ÛÛ, -
$num
ÛÛ. /
,
ÛÛ/ 0
$num
ÛÛ1 2
,
ÛÛ2 3
$num
ÛÛ4 5
,
ÛÛ5 6
$num
ÛÛ7 8
,
ÛÛ8 9
$num
ÛÛ: ;
,
ÛÛ; <
$num
ÛÛ= >
,
ÛÛ> ?
$num
ÙÙ 
,
ÙÙ 
$num
ÙÙ 
,
ÙÙ 
$num
ÙÙ 
,
ÙÙ 
$num
ÙÙ 
,
ÙÙ 
$num
ÙÙ 
,
ÙÙ 
$num
ÙÙ  
,
ÙÙ  !
$num
ÙÙ" #
,
ÙÙ# $
$num
ÙÙ% &
,
ÙÙ& '
$num
ÙÙ( )
,
ÙÙ) *
$num
ÙÙ+ -
,
ÙÙ- .
$num
ÙÙ/ 0
,
ÙÙ0 1
$num
ÙÙ2 3
,
ÙÙ3 4
$num
ÙÙ5 7
,
ÙÙ7 8
$num
ÙÙ9 ;
,
ÙÙ; <
$num
ÙÙ= >
,
ÙÙ> ?
$num
ÙÙ@ B
,
ÙÙB C
$num
ıı 
,
ıı 
$num
ıı 
,
ıı 
$num
ıı 
,
ıı 
$num
ıı 
,
ıı 
$num
ıı  
,
ıı  !
$num
ıı" $
,
ıı$ %
$num
ıı& (
,
ıı( )
$num
ıı* +
,
ıı+ ,
$num
ıı- /
,
ıı/ 0
$num
ıı1 3
,
ıı3 4
$num
ıı5 6
,
ıı6 7
$num
ıı8 :
,
ıı: ;
$num
ıı< >
,
ıı> ?
$num
ıı@ A
,
ııA B
$num
ııC D
,
ııD E
$num
ııF H
,
ııH I
$num
ˆˆ 
,
ˆˆ 
$num
ˆˆ 
,
ˆˆ 
$num
ˆˆ 
,
ˆˆ 
$num
ˆˆ 
,
ˆˆ 
$num
ˆˆ  "
,
ˆˆ" #
$num
ˆˆ$ &
,
ˆˆ& '
$num
ˆˆ( *
,
ˆˆ* +
$num
ˆˆ, .
,
ˆˆ. /
$num
ˆˆ0 2
,
ˆˆ2 3
$num
ˆˆ4 6
,
ˆˆ6 7
$num
ˆˆ8 :
,
ˆˆ: ;
$num
ˆˆ< >
,
ˆˆ> ?
$num
ˆˆ@ B
,
ˆˆB C
$num
ˆˆD F
,
ˆˆF G
$num
ˆˆH J
,
ˆˆJ K
$num
ˆˆL N
,
ˆˆN O
$num
˜˜ 
,
˜˜ 
$num
˜˜ 
,
˜˜ 
$num
˜˜ 
,
˜˜ 
$num
˜˜ 
,
˜˜ 
$num
˜˜  "
,
˜˜" #
$num
˜˜$ %
,
˜˜% &
$num
˜˜' )
,
˜˜) *
$num
˜˜+ -
,
˜˜- .
$num
˜˜/ 1
,
˜˜1 2
$num
˜˜3 5
,
˜˜5 6
$num
˜˜7 8
,
˜˜8 9
$num
˜˜: <
,
˜˜< =
$num
˜˜> @
,
˜˜@ A
$num
˜˜B D
,
˜˜D E
$num
˜˜F G
,
˜˜G H
$num
˜˜I K
,
˜˜K L
$num
¯¯ 
,
¯¯ 
$num
¯¯ 
,
¯¯ 
$num
¯¯ 
,
¯¯ 
$num
¯¯ 
,
¯¯ 
$num
¯¯ !
,
¯¯! "
$num
¯¯# %
,
¯¯% &
$num
¯¯' )
,
¯¯) *
$num
¯¯+ -
,
¯¯- .
$num
¯¯/ 1
,
¯¯1 2
$num
¯¯3 5
,
¯¯5 6
$num
¯¯7 9
,
¯¯9 :
$num
¯¯; =
,
¯¯= >
$num
¯¯? A
,
¯¯A B
$num
¯¯C E
,
¯¯E F
$num
¯¯G I
,
¯¯I J
$num
¯¯K M
,
¯¯M N
$num
˘˘ 
,
˘˘ 
$num
˘˘ 
,
˘˘ 
$num
˘˘ 
,
˘˘ 
$num
˘˘ 
,
˘˘ 
$num
˘˘  "
,
˘˘" #
$num
˘˘$ &
,
˘˘& '
$num
˘˘( *
,
˘˘* +
$num
˘˘, .
,
˘˘. /
$num
˘˘0 2
,
˘˘2 3
$num
˘˘4 5
,
˘˘5 6
$num
˘˘7 9
,
˘˘9 :
$num
˘˘; =
,
˘˘= >
$num
˘˘? A
,
˘˘A B
$num
˘˘C E
,
˘˘E F
$num
˘˘G I
,
˘˘I J
$num
˘˘K M
,
˘˘M N
$num
˙˙ 
,
˙˙ 
$num
˙˙ 
,
˙˙ 
$num
˙˙ 
,
˙˙ 
$num
˙˙ 
,
˙˙ 
$num
˙˙ !
,
˙˙! "
$num
˙˙# %
,
˙˙% &
$num
˙˙' )
,
˙˙) *
$num
˙˙+ -
,
˙˙- .
$num
˙˙/ 1
,
˙˙1 2
$num
˙˙3 5
,
˙˙5 6
$num
˙˙7 9
,
˙˙9 :
$num
˙˙; =
,
˙˙= >
$num
˙˙? A
,
˙˙A B
$num
˙˙C E
,
˙˙E F
$num
˙˙G I
,
˙˙I J
$num
˙˙K M
,
˙˙M N
$num
˚˚ 
,
˚˚ 
$num
˚˚ 
,
˚˚ 
$num
˚˚ 
,
˚˚ 
$num
˚˚ 
,
˚˚ 
$num
˚˚  "
,
˚˚" #
$num
˚˚$ &
,
˚˚& '
$num
˚˚( *
,
˚˚* +
$num
˚˚, .
,
˚˚. /
$num
˚˚0 2
,
˚˚2 3
$num
˚˚4 6
,
˚˚6 7
$num
˚˚8 :
,
˚˚: ;
$num
˚˚< >
,
˚˚> ?
$num
˚˚@ B
,
˚˚B C
$num
˚˚D E
,
˚˚E F
$num
˚˚G I
,
˚˚I J
$num
˚˚K M
,
˚˚M N
$num
¸¸ 
,
¸¸ 
$num
¸¸ 
,
¸¸ 
$num
¸¸ 
,
¸¸ 
$num
¸¸ 
,
¸¸ 
$num
¸¸  "
,
¸¸" #
$num
¸¸$ &
,
¸¸& '
$num
¸¸( *
,
¸¸* +
$num
¸¸, .
,
¸¸. /
$num
¸¸0 2
,
¸¸2 3
$num
¸¸4 6
,
¸¸6 7
$num
¸¸8 :
,
¸¸: ;
$num
¸¸< >
,
¸¸> ?
$num
¸¸@ B
,
¸¸B C
$num
¸¸D F
,
¸¸F G
$num
¸¸H J
,
¸¸J K
$num
¸¸L M
,
¸¸M N
$num
˝˝ 
,
˝˝ 
$num
˝˝ 
,
˝˝ 
$num
˝˝ 
,
˝˝ 
$num
˝˝ 
,
˝˝ 
$num
˝˝ 
,
˝˝  
$num
˝˝! #
,
˝˝# $
$num
˝˝% '
,
˝˝' (
$num
˝˝) +
,
˝˝+ ,
$num
˝˝- .
,
˝˝. /
$num
˝˝0 2
,
˝˝2 3
$num
˝˝4 5
,
˝˝5 6
$num
˝˝7 9
,
˝˝9 :
$num
˝˝; =
,
˝˝= >
$num
˝˝? A
,
˝˝A B
$num
˝˝C D
,
˝˝D E
$num
˝˝F G
,
˝˝G H
$num
˛˛ 
,
˛˛ 
$num
˛˛ 
,
˛˛ 
$num
˛˛ 
,
˛˛ 
$num
˛˛ 
,
˛˛ 
$num
˛˛  "
,
˛˛" #
$num
˛˛$ &
,
˛˛& '
$num
˛˛( *
,
˛˛* +
$num
˛˛, .
,
˛˛. /
$num
˛˛0 2
,
˛˛2 3
$num
˛˛4 6
,
˛˛6 7
$num
˛˛8 9
,
˛˛9 :
$num
˛˛; <
,
˛˛< =
$num
˛˛> @
,
˛˛@ A
$num
˛˛B C
,
˛˛C D
$num
˛˛E G
,
˛˛G H
$num
˛˛I J
,
˛˛J K
$num
ˇˇ 
,
ˇˇ 
$num
ˇˇ 
,
ˇˇ 
$num
ˇˇ 
,
ˇˇ 
$num
ˇˇ 
,
ˇˇ 
$num
ˇˇ !
,
ˇˇ! "
$num
ˇˇ# $
,
ˇˇ$ %
$num
ˇˇ& (
,
ˇˇ( )
$num
ˇˇ* ,
,
ˇˇ, -
$num
ˇˇ. 0
,
ˇˇ0 1
$num
ˇˇ2 3
,
ˇˇ3 4
$num
ˇˇ5 6
,
ˇˇ6 7
$num
ˇˇ8 :
,
ˇˇ: ;
$num
ˇˇ< >
,
ˇˇ> ?
$num
ˇˇ@ B
,
ˇˇB C
$num
ˇˇD F
,
ˇˇF G
$num
ˇˇH J
,
ˇˇJ K
$num
ÄÄ 
,
ÄÄ 
$num
ÄÄ 
,
ÄÄ 
$num
ÄÄ 
,
ÄÄ 
$num
ÄÄ 
,
ÄÄ 
$num
ÄÄ  "
,
ÄÄ" #
$num
ÄÄ$ %
,
ÄÄ% &
$num
ÄÄ' )
,
ÄÄ) *
$num
ÄÄ+ -
,
ÄÄ- .
$num
ÄÄ/ 1
,
ÄÄ1 2
$num
ÄÄ3 5
,
ÄÄ5 6
$num
ÄÄ7 9
,
ÄÄ9 :
$num
ÄÄ; =
,
ÄÄ= >
$num
ÄÄ? A
,
ÄÄA B
$num
ÄÄC E
,
ÄÄE F
$num
ÄÄG I
,
ÄÄI J
$num
ÄÄK M
,
ÄÄM N
$num
ÅÅ 
,
ÅÅ 
$num
ÅÅ 
,
ÅÅ 
$num
ÅÅ 
,
ÅÅ 
$num
ÅÅ 
,
ÅÅ 
$num
ÅÅ  "
,
ÅÅ" #
$num
ÅÅ$ &
,
ÅÅ& '
$num
ÅÅ( *
,
ÅÅ* +
$num
ÅÅ, .
,
ÅÅ. /
$num
ÅÅ0 2
,
ÅÅ2 3
$num
ÅÅ4 6
,
ÅÅ6 7
$num
ÅÅ8 :
,
ÅÅ: ;
$num
ÅÅ< >
,
ÅÅ> ?
$num
ÅÅ@ B
,
ÅÅB C
$num
ÅÅD F
,
ÅÅF G
$num
ÅÅH J
,
ÅÅJ K
$num
ÅÅL N
}
ÇÇ 
;
ÇÇ 
Mesh
ÑÑ 
mesh
ÑÑ 
=
ÑÑ 
new
ÑÑ 
Mesh
ÑÑ  
(
ÑÑ  !
)
ÑÑ! "
;
ÑÑ" #
mesh
ÖÖ 
.
ÖÖ 
indexFormat
ÖÖ 
=
ÖÖ 
IndexFormat
ÖÖ *
.
ÖÖ* +
UInt16
ÖÖ+ 1
;
ÖÖ1 2
mesh
ÜÜ 
.
ÜÜ 
vertices
ÜÜ 
=
ÜÜ 
	positions
ÜÜ %
;
ÜÜ% &
mesh
áá 
.
áá 
	triangles
áá 
=
áá 
indices
áá $
;
áá$ %
return
ââ 
mesh
ââ 
;
ââ 
}
ää 	
static
åå 
Mesh
åå "
CreateFullscreenMesh
åå (
(
åå( )
)
åå) *
{
çç 	
Vector3
êê 
[
êê 
]
êê 
	positions
êê  
=
êê! "
{
êê# $
new
ëë 
Vector3
ëë 
(
ëë 
-
ëë 
$num
ëë !
,
ëë! "
$num
ëë$ (
,
ëë( )
$num
ëë* .
)
ëë. /
,
ëë/ 0
new
íí 
Vector3
íí 
(
íí 
-
íí 
$num
íí !
,
íí! "
-
íí# $
$num
íí$ (
,
íí( )
$num
íí* .
)
íí. /
,
íí/ 0
new
ìì 
Vector3
ìì 
(
ìì 
$num
ìì !
,
ìì! "
$num
ìì$ (
,
ìì( )
$num
ìì* .
)
ìì. /
}
îî 
;
îî 
int
ññ 
[
ññ 
]
ññ 
indices
ññ 
=
ññ 
{
ññ 
$num
ññ  
,
ññ  !
$num
ññ" #
,
ññ# $
$num
ññ% &
}
ññ' (
;
ññ( )
Mesh
òò 
mesh
òò 
=
òò 
new
òò 
Mesh
òò  
(
òò  !
)
òò! "
;
òò" #
mesh
ôô 
.
ôô 
indexFormat
ôô 
=
ôô 
IndexFormat
ôô *
.
ôô* +
UInt16
ôô+ 1
;
ôô1 2
mesh
öö 
.
öö 
vertices
öö 
=
öö 
	positions
öö %
;
öö% &
mesh
õõ 
.
õõ 
	triangles
õõ 
=
õõ 
indices
õõ $
;
õõ$ %
return
ùù 
mesh
ùù 
;
ùù 
}
ûû 	
static
†† 
int
†† 
Align
†† 
(
†† 
int
†† 
s
†† 
,
†† 
int
††  #
	alignment
††$ -
)
††- .
{
°° 	
return
¢¢ 
(
¢¢ 
(
¢¢ 
s
¢¢ 
+
¢¢ 
	alignment
¢¢ "
-
¢¢# $
$num
¢¢% &
)
¢¢& '
/
¢¢( )
	alignment
¢¢* 3
)
¢¢3 4
*
¢¢5 6
	alignment
¢¢7 @
;
¢¢@ A
}
££ 	
static
¶¶ 
uint
¶¶ 

PackTileID
¶¶ 
(
¶¶ 
uint
¶¶ #
i
¶¶$ %
,
¶¶% &
uint
¶¶' +
j
¶¶, -
)
¶¶- .
{
ßß 	
return
®® 
i
®® 
|
®® 
(
®® 
j
®® 
<<
®® 
$num
®® 
)
®®  
;
®®  !
}
©© 	
static
´´ 
uint
´´ 
FloatToUInt
´´ 
(
´´  
float
´´  %
val
´´& )
)
´´) *
{
¨¨ 	
byte
ÆÆ 
[
ÆÆ 
]
ÆÆ 
bytes
ÆÆ 
=
ÆÆ 
System
ÆÆ !
.
ÆÆ! "
BitConverter
ÆÆ" .
.
ÆÆ. /
GetBytes
ÆÆ/ 7
(
ÆÆ7 8
val
ÆÆ8 ;
)
ÆÆ; <
;
ÆÆ< =
return
ØØ 
bytes
ØØ 
[
ØØ 
$num
ØØ 
]
ØØ 
|
ØØ 
(
ØØ 
(
ØØ  
(
ØØ  !
uint
ØØ! %
)
ØØ% &
bytes
ØØ& +
[
ØØ+ ,
$num
ØØ, -
]
ØØ- .
)
ØØ. /
<<
ØØ0 2
$num
ØØ3 4
)
ØØ4 5
|
ØØ6 7
(
ØØ8 9
(
ØØ9 :
(
ØØ: ;
uint
ØØ; ?
)
ØØ? @
bytes
ØØ@ E
[
ØØE F
$num
ØØF G
]
ØØG H
)
ØØH I
<<
ØØJ L
$num
ØØM O
)
ØØO P
|
ØØQ R
(
ØØS T
(
ØØT U
(
ØØU V
uint
ØØV Z
)
ØØZ [
bytes
ØØ[ `
[
ØØ` a
$num
ØØa b
]
ØØb c
)
ØØc d
<<
ØØe g
$num
ØØh j
)
ØØj k
;
ØØk l
}
±± 	
static
≥≥ 
uint
≥≥ 
Half2ToUInt
≥≥ 
(
≥≥  
float
≥≥  %
x
≥≥& '
,
≥≥' (
float
≥≥) .
y
≥≥/ 0
)
≥≥0 1
{
¥¥ 	
uint
µµ 
hx
µµ 
=
µµ 
Mathf
µµ 
.
µµ 
FloatToHalf
µµ '
(
µµ' (
x
µµ( )
)
µµ) *
;
µµ* +
uint
∂∂ 
hy
∂∂ 
=
∂∂ 
Mathf
∂∂ 
.
∂∂ 
FloatToHalf
∂∂ '
(
∂∂' (
y
∂∂( )
)
∂∂) *
;
∂∂* +
return
∑∑ 
hx
∑∑ 
|
∑∑ 
(
∑∑ 
hy
∑∑ 
<<
∑∑ 
$num
∑∑ !
)
∑∑! "
;
∑∑" #
}
∏∏ 	
}
ππ 
class
ªª 	"
SortPrePunctualLight
ªª
 
:
ªª  
System
ªª! '
.
ªª' (
Collections
ªª( 3
.
ªª3 4
Generic
ªª4 ;
.
ªª; <
	IComparer
ªª< E
<
ªªE F
DeferredTiler
ªªF S
.
ªªS T
PrePunctualLight
ªªT d
>
ªªd e
{
ºº 
public
ΩΩ 
int
ΩΩ 
Compare
ΩΩ 
(
ΩΩ 
DeferredTiler
ΩΩ (
.
ΩΩ( )
PrePunctualLight
ΩΩ) 9
a
ΩΩ: ;
,
ΩΩ; <
DeferredTiler
ΩΩ= J
.
ΩΩJ K
PrePunctualLight
ΩΩK [
b
ΩΩ\ ]
)
ΩΩ] ^
{
ææ 	
if
øø 
(
øø 
a
øø 
.
øø 
minDist
øø 
<
øø 
b
øø 
.
øø 
minDist
øø %
)
øø% &
return
¿¿ 
-
¿¿ 
$num
¿¿ 
;
¿¿ 
else
¡¡ 
if
¡¡ 
(
¡¡ 
a
¡¡ 
.
¡¡ 
minDist
¡¡ 
>
¡¡  
b
¡¡! "
.
¡¡" #
minDist
¡¡# *
)
¡¡* +
return
¬¬ 
$num
¬¬ 
;
¬¬ 
else
√√ 
return
ƒƒ 
$num
ƒƒ 
;
ƒƒ 
}
≈≈ 	
}
∆∆ 
struct
»» 

BitArray
»» 
:
»» 
System
»» 
.
»» 
IDisposable
»» (
{
…… 
NativeArray
   
<
   
uint
   
>
   
m_Mem
   
;
    
int
ÀÀ 

m_BitCount
ÀÀ 
;
ÀÀ 
int
ÃÃ 

m_IntCount
ÃÃ 
;
ÃÃ 
public
ŒŒ 
BitArray
ŒŒ 
(
ŒŒ 
int
ŒŒ 
bitCount
ŒŒ $
,
ŒŒ$ %
	Allocator
ŒŒ& /
	allocator
ŒŒ0 9
,
ŒŒ9 : 
NativeArrayOptions
ŒŒ; M
options
ŒŒN U
=
ŒŒV W 
NativeArrayOptions
ŒŒX j
.
ŒŒj k
ClearMemory
ŒŒk v
)
ŒŒv w
{
œœ 	

m_BitCount
–– 
=
–– 
bitCount
–– !
;
––! "

m_IntCount
—— 
=
—— 
(
—— 
bitCount
—— "
+
——# $
$num
——% '
)
——' (
>>
——) +
$num
——, -
;
——- .
m_Mem
““ 
=
““ 
new
““ 
NativeArray
““ #
<
““# $
uint
““$ (
>
““( )
(
““) *

m_IntCount
““* 4
,
““4 5
	allocator
““6 ?
,
““? @
options
““A H
)
““H I
;
““I J
}
”” 	
public
’’ 
void
’’ 
Dispose
’’ 
(
’’ 
)
’’ 
{
÷÷ 	
m_Mem
◊◊ 
.
◊◊ 
Dispose
◊◊ 
(
◊◊ 
)
◊◊ 
;
◊◊ 
}
ÿÿ 	
public
⁄⁄ 
void
⁄⁄ 
Clear
⁄⁄ 
(
⁄⁄ 
)
⁄⁄ 
{
€€ 	
for
‹‹ 
(
‹‹ 
int
‹‹ 
i
‹‹ 
=
‹‹ 
$num
‹‹ 
;
‹‹ 
i
‹‹ 
<
‹‹ 

m_IntCount
‹‹  *
;
‹‹* +
++
‹‹, .
i
‹‹. /
)
‹‹/ 0
m_Mem
›› 
[
›› 
i
›› 
]
›› 
=
›› 
$num
›› 
;
›› 
}
ﬁﬁ 	
public
‡‡ 
bool
‡‡ 
IsSet
‡‡ 
(
‡‡ 
int
‡‡ 
bitIndex
‡‡ &
)
‡‡& '
{
·· 	
return
‚‚ 
(
‚‚ 
m_Mem
‚‚ 
[
‚‚ 
bitIndex
‚‚ "
>>
‚‚# %
$num
‚‚& '
]
‚‚' (
&
‚‚) *
(
‚‚+ ,
$num
‚‚, .
<<
‚‚/ 1
(
‚‚2 3
bitIndex
‚‚3 ;
&
‚‚< =
$num
‚‚> @
)
‚‚@ A
)
‚‚A B
)
‚‚B C
!=
‚‚D F
$num
‚‚G H
;
‚‚H I
}
„„ 	
public
ÂÂ 
void
ÂÂ 
Set
ÂÂ 
(
ÂÂ 
int
ÂÂ 
bitIndex
ÂÂ $
,
ÂÂ$ %
bool
ÂÂ& *
val
ÂÂ+ .
)
ÂÂ. /
{
ÊÊ 	
if
ÁÁ 
(
ÁÁ 
val
ÁÁ 
)
ÁÁ 
m_Mem
ËË 
[
ËË 
bitIndex
ËË 
>>
ËË !
$num
ËË" #
]
ËË# $
|=
ËË% '
$num
ËË( *
<<
ËË+ -
(
ËË. /
bitIndex
ËË/ 7
&
ËË8 9
$num
ËË: <
)
ËË< =
;
ËË= >
else
ÈÈ 
m_Mem
ÍÍ 
[
ÍÍ 
bitIndex
ÍÍ 
>>
ÍÍ !
$num
ÍÍ" #
]
ÍÍ# $
&=
ÍÍ% '
~
ÍÍ( )
(
ÍÍ) *
$num
ÍÍ* ,
<<
ÍÍ- /
(
ÍÍ0 1
bitIndex
ÍÍ1 9
&
ÍÍ: ;
$num
ÍÍ< >
)
ÍÍ> ?
)
ÍÍ? @
;
ÍÍ@ A
}
ÎÎ 	
}
ÏÏ 
;
ÏÏ 
}ÌÌ æ
§D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Passes\IRenderPass2D.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
internal 
	interface 
IRenderPass2D $
{ 
Renderer2DData 
rendererData #
{$ %
get& )
;) *
}+ ,
} 
} ¢;
´D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\RendererFeatures\RenderObjects.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
[ 
	MovedFrom 
( 
$str 8
)8 9
]9 :
public: @
enumA E
RenderQueueTypeF U
{		 
Opaque

 
,

 
Transparent 
, 
} 
[ 
ExcludeFromPreset 
] 
[ 
	MovedFrom 
( 
$str 8
)8 9
]9 :
public: @
classA F
RenderObjectsG T
:U V%
ScriptableRendererFeatureW p
{ 
[ 	
System	 
. 
Serializable 
] 
public 
class !
RenderObjectsSettings *
{ 	
public 
string 
passTag !
=" #
$str$ :
;: ;
public 
RenderPassEvent "
Event# (
=) *
RenderPassEvent+ :
.: ;!
AfterRenderingOpaques; P
;P Q
public 
FilterSettings !
filterSettings" 0
=1 2
new3 6
FilterSettings7 E
(E F
)F G
;G H
public 
Material 
overrideMaterial ,
=- .
null/ 3
;3 4
public 
int %
overrideMaterialPassIndex 0
=1 2
$num3 4
;4 5
public 
bool 
overrideDepthState *
=+ ,
false- 2
;2 3
public 
CompareFunction " 
depthCompareFunction# 7
=8 9
CompareFunction: I
.I J
	LessEqualJ S
;S T
public 
bool 
enableWrite #
=$ %
true& *
;* +
public   
StencilStateData   #
stencilSettings  $ 3
=  4 5
new  6 9
StencilStateData  : J
(  J K
)  K L
;  L M
public""  
CustomCameraSettings"" '
cameraSettings""( 6
=""7 8
new""9 < 
CustomCameraSettings""= Q
(""Q R
)""R S
;""S T
}## 	
[%% 	
System%%	 
.%% 
Serializable%% 
]%% 
public&& 
class&& 
FilterSettings&& #
{'' 	
public)) 
RenderQueueType)) "
RenderQueueType))# 2
;))2 3
public** 
	LayerMask** 
	LayerMask** &
;**& '
public++ 
string++ 
[++ 
]++ 
	PassNames++ %
;++% &
public-- 
FilterSettings-- !
(--! "
)--" #
{.. 
RenderQueueType// 
=//  !
RenderQueueType//" 1
.//1 2
Opaque//2 8
;//8 9
	LayerMask00 
=00 
$num00 
;00 
}11 
}22 	
[44 	
System44	 
.44 
Serializable44 
]44 
public55 
class55  
CustomCameraSettings55 )
{66 	
public77 
bool77 
overrideCamera77 &
=77' (
false77) .
;77. /
public88 
bool88 
restoreCamera88 %
=88& '
true88( ,
;88, -
public99 
Vector499 
offset99 !
;99! "
public:: 
float:: 
cameraFieldOfView:: *
=::+ ,
$num::- 2
;::2 3
};; 	
public== !
RenderObjectsSettings== $
settings==% -
===. /
new==0 3!
RenderObjectsSettings==4 I
(==I J
)==J K
;==K L
RenderObjectsPass?? 
renderObjectsPass?? +
;??+ ,
publicAA 
overrideAA 
voidAA 
CreateAA #
(AA# $
)AA$ %
{BB 	
FilterSettingsCC 
filterCC !
=CC" #
settingsCC$ ,
.CC, -
filterSettingsCC- ;
;CC; <
ifJJ 
(JJ 
settingsJJ 
.JJ 
EventJJ 
<JJ  
RenderPassEventJJ! 0
.JJ0 1$
BeforeRenderingPrepassesJJ1 I
)JJI J
settingsKK 
.KK 
EventKK 
=KK  
RenderPassEventKK! 0
.KK0 1$
BeforeRenderingPrepassesKK1 I
;KKI J
renderObjectsPassMM 
=MM 
newMM  #
RenderObjectsPassMM$ 5
(MM5 6
settingsMM6 >
.MM> ?
passTagMM? F
,MMF G
settingsMMH P
.MMP Q
EventMMQ V
,MMV W
filterMMX ^
.MM^ _
	PassNamesMM_ h
,MMh i
filterNN 
.NN 
RenderQueueTypeNN &
,NN& '
filterNN( .
.NN. /
	LayerMaskNN/ 8
,NN8 9
settingsNN: B
.NNB C
cameraSettingsNNC Q
)NNQ R
;NNR S
renderObjectsPassPP 
.PP 
overrideMaterialPP .
=PP/ 0
settingsPP1 9
.PP9 :
overrideMaterialPP: J
;PPJ K
renderObjectsPassQQ 
.QQ %
overrideMaterialPassIndexQQ 7
=QQ8 9
settingsQQ: B
.QQB C%
overrideMaterialPassIndexQQC \
;QQ\ ]
ifSS 
(SS 
settingsSS 
.SS 
overrideDepthStateSS +
)SS+ ,
renderObjectsPassTT !
.TT! "
SetDetphStateTT" /
(TT/ 0
settingsTT0 8
.TT8 9
enableWriteTT9 D
,TTD E
settingsTTF N
.TTN O 
depthCompareFunctionTTO c
)TTc d
;TTd e
ifVV 
(VV 
settingsVV 
.VV 
stencilSettingsVV (
.VV( ) 
overrideStencilStateVV) =
)VV= >
renderObjectsPassWW !
.WW! "
SetStencilStateWW" 1
(WW1 2
settingsWW2 :
.WW: ;
stencilSettingsWW; J
.WWJ K
stencilReferenceWWK [
,WW[ \
settingsXX 
.XX 
stencilSettingsXX ,
.XX, -"
stencilCompareFunctionXX- C
,XXC D
settingsXXE M
.XXM N
stencilSettingsXXN ]
.XX] ^
passOperationXX^ k
,XXk l
settingsYY 
.YY 
stencilSettingsYY ,
.YY, -
failOperationYY- :
,YY: ;
settingsYY< D
.YYD E
stencilSettingsYYE T
.YYT U
zFailOperationYYU c
)YYc d
;YYd e
}ZZ 	
public\\ 
override\\ 
void\\ 
AddRenderPasses\\ ,
(\\, -
ScriptableRenderer\\- ?
renderer\\@ H
,\\H I
ref\\J M
RenderingData\\N [
renderingData\\\ i
)\\i j
{]] 	
renderer^^ 
.^^ 
EnqueuePass^^  
(^^  !
renderObjectsPass^^! 2
)^^2 3
;^^3 4
}__ 	
}`` 
}aa Ë
úD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Light2DPoint.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
public 

sealed 
partial 
class 
Light2D  '
{ 
public 
enum 
PointLightQuality %
{		 	
Fast

 
=

 
$num

 
,

 
Accurate 
= 
$num 
} 	
[ 	
SerializeField	 
] 
float "
m_PointLightInnerAngle 5
=6 7
$num8 >
;> ?
[ 	
SerializeField	 
] 
float "
m_PointLightOuterAngle 5
=6 7
$num8 >
;> ?
[ 	
SerializeField	 
] 
float #
m_PointLightInnerRadius 6
=7 8
$num9 =
;= >
[ 	
SerializeField	 
] 
float #
m_PointLightOuterRadius 6
=7 8
$num9 =
;= >
[ 	
SerializeField	 
] 
float  
m_PointLightDistance 3
=4 5
$num6 :
;: ;
[ 	
UnityEngine	 
. 

Animations 
.  

NotKeyable  *
]* +
[ 	
SerializeField	 
] 
PointLightQuality *
m_PointLightQuality+ >
=? @
PointLightQualityA R
.R S
AccurateS [
;[ \
public 
float  
pointLightInnerAngle )
{ 	
get 
=> "
m_PointLightInnerAngle )
;) *
set 
=> "
m_PointLightInnerAngle )
=* +
value, 1
;1 2
} 	
public 
float  
pointLightOuterAngle )
{   	
get!! 
=>!! "
m_PointLightOuterAngle!! )
;!!) *
set"" 
=>"" "
m_PointLightOuterAngle"" )
=""* +
value"", 1
;""1 2
}## 	
public%% 
float%% !
pointLightInnerRadius%% *
{&& 	
get'' 
=>'' #
m_PointLightInnerRadius'' *
;''* +
set(( 
=>(( #
m_PointLightInnerRadius(( *
=((+ ,
value((- 2
;((2 3
})) 	
public++ 
float++ !
pointLightOuterRadius++ *
{,, 	
get-- 
=>-- #
m_PointLightOuterRadius-- *
;--* +
set.. 
=>.. #
m_PointLightOuterRadius.. *
=..+ ,
value..- 2
;..2 3
}// 	
public11 
float11 
pointLightDistance11 '
=>11( * 
m_PointLightDistance11+ ?
;11? @
public22 
PointLightQuality22  
pointLightQuality22! 2
=>223 5
m_PointLightQuality226 I
;22I J
internal44 
bool44 
isPointLight44 "
=>44# %
m_LightType44& 1
==442 4
	LightType445 >
.44> ?
Point44? D
;44D E
}55 
}66 õÏ
öD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\ForwardLights.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
public		 

class		 
ForwardLights		 
{

 
static 
class 
LightConstantBuffer (
{ 	
public 
static 
int 
_MainLightPosition 0
;0 1
public 
static 
int 
_MainLightColor -
;- .
public 
static 
int ,
 _MainLightOcclusionProbesChannel >
;> ?
public 
static 
int "
_AdditionalLightsCount 4
;4 5
public 
static 
int %
_AdditionalLightsPosition 7
;7 8
public 
static 
int "
_AdditionalLightsColor 4
;4 5
public 
static 
int (
_AdditionalLightsAttenuation :
;: ;
public 
static 
int $
_AdditionalLightsSpotDir 6
;6 7
public 
static 
int 1
%_AdditionalLightOcclusionProbeChannel C
;C D
} 	
int &
m_AdditionalLightsBufferId &
;& '
int '
m_AdditionalLightsIndicesId '
;' (
const 
string !
k_SetupLightConstants *
=+ ,
$str- D
;D E
private 
static 
readonly 
ProfilingSampler  0
m_ProfilingSampler1 C
=D E
newF I
ProfilingSamplerJ Z
(Z [!
k_SetupLightConstants[ p
)p q
;q r
MixedLightingSetup  
m_MixedLightingSetup /
;/ 0
Vector4   
[   
]   &
m_AdditionalLightPositions   ,
;  , -
Vector4!! 
[!! 
]!! #
m_AdditionalLightColors!! )
;!!) *
Vector4"" 
["" 
]"" )
m_AdditionalLightAttenuations"" /
;""/ 0
Vector4## 
[## 
]## +
m_AdditionalLightSpotDirections## 1
;##1 2
Vector4$$ 
[$$ 
]$$ 3
'm_AdditionalLightOcclusionProbeChannels$$ 9
;$$9 :
bool&& !
m_UseStructuredBuffer&& "
;&&" #
public(( 
ForwardLights(( 
((( 
)(( 
{)) 	!
m_UseStructuredBuffer** !
=**" #
RenderingUtils**$ 2
.**2 3
useStructuredBuffer**3 F
;**F G
LightConstantBuffer,, 
.,,  
_MainLightPosition,,  2
=,,3 4
Shader,,5 ;
.,,; <
PropertyToID,,< H
(,,H I
$str,,I ]
),,] ^
;,,^ _
LightConstantBuffer-- 
.--  
_MainLightColor--  /
=--0 1
Shader--2 8
.--8 9
PropertyToID--9 E
(--E F
$str--F W
)--W X
;--X Y
LightConstantBuffer.. 
...  ,
 _MainLightOcclusionProbesChannel..  @
=..A B
Shader..C I
...I J
PropertyToID..J V
(..V W
$str..W r
)..r s
;..s t
LightConstantBuffer// 
.//  "
_AdditionalLightsCount//  6
=//7 8
Shader//9 ?
.//? @
PropertyToID//@ L
(//L M
$str//M e
)//e f
;//f g
if11 
(11 !
m_UseStructuredBuffer11 %
)11% &
{22 &
m_AdditionalLightsBufferId33 *
=33+ ,
Shader33- 3
.333 4
PropertyToID334 @
(33@ A
$str33A Z
)33Z [
;33[ \'
m_AdditionalLightsIndicesId44 +
=44, -
Shader44. 4
.444 5
PropertyToID445 A
(44A B
$str44B \
)44\ ]
;44] ^
}55 
else66 
{77 
LightConstantBuffer88  
.88  !%
_AdditionalLightsPosition88! :
=88; <
Shader88= C
.88C D
PropertyToID88D P
(88P Q
$str88Q l
)88l m
;88m n
LightConstantBuffer99  
.99  !"
_AdditionalLightsColor99! 7
=998 9
Shader99: @
.99@ A
PropertyToID99A M
(99M N
$str99N f
)99f g
;99g h
LightConstantBuffer::  
.::  !(
_AdditionalLightsAttenuation::! =
=::> ?
Shader::@ F
.::F G
PropertyToID::G S
(::S T
$str::T r
)::r s
;::s t
LightConstantBuffer;;  
.;;  !$
_AdditionalLightsSpotDir;;! 9
=;;: ;
Shader;;< B
.;;B C
PropertyToID;;C O
(;;O P
$str;;P j
);;j k
;;;k l
LightConstantBuffer<<  
.<<  !1
%_AdditionalLightOcclusionProbeChannel<<! F
=<<G H
Shader<<I O
.<<O P
PropertyToID<<P \
(<<\ ]
$str<<] 
)	<< Ä
;
<<Ä Å
int>> 
	maxLights>> 
=>> #
UniversalRenderPipeline>> 4
.>>4 5&
maxVisibleAdditionalLights>>5 O
;>>O P&
m_AdditionalLightPositions?? '
=??( )
new??* -
Vector4??. 5
[??5 6
	maxLights??6 ?
]??? @
;??@ A#
m_AdditionalLightColors@@ $
=@@% &
new@@' *
Vector4@@+ 2
[@@2 3
	maxLights@@3 <
]@@< =
;@@= >)
m_AdditionalLightAttenuationsAA *
=AA+ ,
newAA- 0
Vector4AA1 8
[AA8 9
	maxLightsAA9 B
]AAB C
;AAC D+
m_AdditionalLightSpotDirectionsBB ,
=BB- .
newBB/ 2
Vector4BB3 :
[BB: ;
	maxLightsBB; D
]BBD E
;BBE F3
'm_AdditionalLightOcclusionProbeChannelsCC 4
=CC5 6
newCC7 :
Vector4CC; B
[CCB C
	maxLightsCCC L
]CCL M
;CCM N
}DD 
}EE 	
publicGG 
voidGG 
SetupGG 
(GG #
ScriptableRenderContextGG 1
contextGG2 9
,GG9 :
refGG; >
RenderingDataGG? L
renderingDataGGM Z
)GGZ [
{HH 	
intII !
additionalLightsCountII %
=II& '
renderingDataII( 5
.II5 6
	lightDataII6 ?
.II? @!
additionalLightsCountII@ U
;IIU V
boolJJ %
additionalLightsPerVertexJJ *
=JJ+ ,
renderingDataJJ- :
.JJ: ;
	lightDataJJ; D
.JJD E*
shadeAdditionalLightsPerVertexJJE c
;JJc d
CommandBufferKK 
cmdKK 
=KK 
CommandBufferPoolKK  1
.KK1 2
GetKK2 5
(KK5 6
)KK6 7
;KK7 8
usingLL 
(LL 
newLL 
ProfilingScopeLL %
(LL% &
cmdLL& )
,LL) *
m_ProfilingSamplerLL+ =
)LL= >
)LL> ?
{MM %
SetupShaderLightConstantsNN )
(NN) *
cmdNN* -
,NN- .
refNN/ 2
renderingDataNN3 @
)NN@ A
;NNA B
	CoreUtilsPP 
.PP 

SetKeywordPP $
(PP$ %
cmdPP% (
,PP( ) 
ShaderKeywordStringsPP* >
.PP> ?"
AdditionalLightsVertexPP? U
,PPU V!
additionalLightsCountQQ )
>QQ* +
$numQQ, -
&&QQ. 0%
additionalLightsPerVertexQQ1 J
)QQJ K
;QQK L
	CoreUtilsRR 
.RR 

SetKeywordRR $
(RR$ %
cmdRR% (
,RR( ) 
ShaderKeywordStringsRR* >
.RR> ?!
AdditionalLightsPixelRR? T
,RRT U!
additionalLightsCountSS )
>SS* +
$numSS, -
&&SS. 0
!SS1 2%
additionalLightsPerVertexSS2 K
)SSK L
;SSL M
boolUU 
isShadowMaskUU !
=UU" #
renderingDataUU$ 1
.UU1 2
	lightDataUU2 ;
.UU; <!
supportsMixedLightingUU< Q
&&UUR T 
m_MixedLightingSetupUUU i
==UUj l
MixedLightingSetupUUm 
.	UU Ä

ShadowMask
UUÄ ä
;
UUä ã
boolVV 
isShadowMaskAlwaysVV '
=VV( )
isShadowMaskVV* 6
&&VV7 9
QualitySettingsVV: I
.VVI J
shadowmaskModeVVJ X
==VVY [
ShadowmaskModeVV\ j
.VVj k

ShadowmaskVVk u
;VVu v
boolWW 
isSubtractiveWW "
=WW# $
renderingDataWW% 2
.WW2 3
	lightDataWW3 <
.WW< =!
supportsMixedLightingWW= R
&&WWS U 
m_MixedLightingSetupWWV j
==WWk m
MixedLightingSetup	WWn Ä
.
WWÄ Å
Subtractive
WWÅ å
;
WWå ç
	CoreUtilsXX 
.XX 

SetKeywordXX $
(XX$ %
cmdXX% (
,XX( ) 
ShaderKeywordStringsXX* >
.XX> ? 
LightmapShadowMixingXX? S
,XXS T
isSubtractiveXXU b
||XXc e
isShadowMaskAlwaysXXf x
)XXx y
;XXy z
	CoreUtilsYY 
.YY 

SetKeywordYY $
(YY$ %
cmdYY% (
,YY( ) 
ShaderKeywordStringsYY* >
.YY> ?
ShadowsShadowMaskYY? P
,YYP Q
isShadowMaskYYR ^
)YY^ _
;YY_ `
	CoreUtilsZZ 
.ZZ 

SetKeywordZZ $
(ZZ$ %
cmdZZ% (
,ZZ( ) 
ShaderKeywordStringsZZ* >
.ZZ> ?$
MixedLightingSubtractiveZZ? W
,ZZW X
isSubtractiveZZY f
)ZZf g
;ZZg h
}[[ 
context\\ 
.\\  
ExecuteCommandBuffer\\ (
(\\( )
cmd\\) ,
)\\, -
;\\- .
CommandBufferPool]] 
.]] 
Release]] %
(]]% &
cmd]]& )
)]]) *
;]]* +
}^^ 	
void`` $
InitializeLightConstants`` %
(``% &
NativeArray``& 1
<``1 2
VisibleLight``2 >
>``> ?
lights``@ F
,``F G
int``H K

lightIndex``L V
,``V W
out``X [
Vector4``\ c
lightPos``d l
,``l m
out``n q
Vector4``r y

lightColor	``z Ñ
,
``Ñ Ö
out
``Ü â
Vector4
``ä ë
lightAttenuation
``í ¢
,
``¢ £
out
``§ ß
Vector4
``® Ø
lightSpotDir
``∞ º
,
``º Ω
out
``æ ¡
Vector4
``¬ …(
lightOcclusionProbeChannel
``  ‰
)
``‰ Â
{aa 	#
UniversalRenderPipelinebb #
.bb# $+
InitializeLightConstants_Commonbb$ C
(bbC D
lightsbbD J
,bbJ K

lightIndexbbL V
,bbV W
outbbX [
lightPosbb\ d
,bbd e
outbbf i

lightColorbbj t
,bbt u
outbbv y
lightAttenuation	bbz ä
,
bbä ã
out
bbå è
lightSpotDir
bbê ú
,
bbú ù
out
bbû °(
lightOcclusionProbeChannel
bb¢ º
)
bbº Ω
;
bbΩ æ
ifff 
(ff 

lightIndexff 
<ff 
$numff 
)ff 
returngg 
;gg 
VisibleLightii 
	lightDataii "
=ii# $
lightsii% +
[ii+ ,

lightIndexii, 6
]ii6 7
;ii7 8
Lightjj 
lightjj 
=jj 
	lightDatajj #
.jj# $
lightjj$ )
;jj) *
ifll 
(ll 
lightll 
==ll 
nullll 
)ll 
returnmm 
;mm 
ifoo 
(oo 
lightoo 
.oo 
bakingOutputoo "
.oo" #
lightmapBakeTypeoo# 3
==oo4 6
LightmapBakeTypeoo7 G
.ooG H
MixedooH M
&&ooN P
	lightDatapp 
.pp 
lightpp 
.pp  
shadowspp  '
!=pp( *
LightShadowspp+ 7
.pp7 8
Nonepp8 <
&&pp= ? 
m_MixedLightingSetupqq $
==qq% '
MixedLightingSetupqq( :
.qq: ;
Noneqq; ?
)qq? @
{rr 
switchss 
(ss 
lightss 
.ss 
bakingOutputss *
.ss* +
mixedLightingModess+ <
)ss< =
{tt 
caseuu 
MixedLightingModeuu *
.uu* +
Subtractiveuu+ 6
:uu6 7 
m_MixedLightingSetupvv ,
=vv- .
MixedLightingSetupvv/ A
.vvA B
SubtractivevvB M
;vvM N
breakww 
;ww 
casexx 
MixedLightingModexx *
.xx* +

Shadowmaskxx+ 5
:xx5 6 
m_MixedLightingSetupyy ,
=yy- .
MixedLightingSetupyy/ A
.yyA B

ShadowMaskyyB L
;yyL M
breakzz 
;zz 
}{{ 
}|| 
}}} 	
void %
SetupShaderLightConstants &
(& '
CommandBuffer' 4
cmd5 8
,8 9
ref: =
RenderingData> K
renderingDataL Y
)Y Z
{
ÄÄ 	"
m_MixedLightingSetup
ÅÅ  
=
ÅÅ! " 
MixedLightingSetup
ÅÅ# 5
.
ÅÅ5 6
None
ÅÅ6 :
;
ÅÅ: ;%
SetupMainLightConstants
ÖÖ #
(
ÖÖ# $
cmd
ÖÖ$ '
,
ÖÖ' (
ref
ÖÖ) ,
renderingData
ÖÖ- :
.
ÖÖ: ;
	lightData
ÖÖ; D
)
ÖÖD E
;
ÖÖE F+
SetupAdditionalLightConstants
ÜÜ )
(
ÜÜ) *
cmd
ÜÜ* -
,
ÜÜ- .
ref
ÜÜ/ 2
renderingData
ÜÜ3 @
)
ÜÜ@ A
;
ÜÜA B
}
áá 	
void
ââ %
SetupMainLightConstants
ââ $
(
ââ$ %
CommandBuffer
ââ% 2
cmd
ââ3 6
,
ââ6 7
ref
ââ8 ;
	LightData
ââ< E
	lightData
ââF O
)
ââO P
{
ää 	
Vector4
ãã 
lightPos
ãã 
,
ãã 

lightColor
ãã (
,
ãã( )
lightAttenuation
ãã* :
,
ãã: ;
lightSpotDir
ãã< H
,
ããH I#
lightOcclusionChannel
ããJ _
;
ãã_ `&
InitializeLightConstants
åå $
(
åå$ %
	lightData
åå% .
.
åå. /
visibleLights
åå/ <
,
åå< =
	lightData
åå> G
.
ååG H
mainLightIndex
ååH V
,
ååV W
out
ååX [
lightPos
åå\ d
,
ååd e
out
ååf i

lightColor
ååj t
,
ååt u
out
ååv y
lightAttenuationååz ä
,ååä ã
outååå è
lightSpotDirååê ú
,ååú ù
outååû °%
lightOcclusionChannelåå¢ ∑
)åå∑ ∏
;åå∏ π
cmd
éé 
.
éé 
SetGlobalVector
éé 
(
éé  !
LightConstantBuffer
éé  3
.
éé3 4 
_MainLightPosition
éé4 F
,
ééF G
lightPos
ééH P
)
ééP Q
;
ééQ R
cmd
èè 
.
èè 
SetGlobalVector
èè 
(
èè  !
LightConstantBuffer
èè  3
.
èè3 4
_MainLightColor
èè4 C
,
èèC D

lightColor
èèE O
)
èèO P
;
èèP Q
cmd
êê 
.
êê 
SetGlobalVector
êê 
(
êê  !
LightConstantBuffer
êê  3
.
êê3 4.
 _MainLightOcclusionProbesChannel
êê4 T
,
êêT U#
lightOcclusionChannel
êêV k
)
êêk l
;
êêl m
}
ëë 	
void
ìì +
SetupAdditionalLightConstants
ìì *
(
ìì* +
CommandBuffer
ìì+ 8
cmd
ìì9 <
,
ìì< =
ref
ìì> A
RenderingData
ììB O
renderingData
ììP ]
)
ìì] ^
{
îî 	
ref
ïï 
	LightData
ïï 
	lightData
ïï #
=
ïï$ %
ref
ïï& )
renderingData
ïï* 7
.
ïï7 8
	lightData
ïï8 A
;
ïïA B
var
ññ 
cullResults
ññ 
=
ññ 
renderingData
ññ +
.
ññ+ ,
cullResults
ññ, 7
;
ññ7 8
var
óó 
lights
óó 
=
óó 
	lightData
óó "
.
óó" #
visibleLights
óó# 0
;
óó0 1
int
òò &
maxAdditionalLightsCount
òò (
=
òò) *%
UniversalRenderPipeline
òò+ B
.
òòB C(
maxVisibleAdditionalLights
òòC ]
;
òò] ^
int
ôô #
additionalLightsCount
ôô %
=
ôô& '(
SetupPerObjectLightIndices
ôô( B
(
ôôB C
cullResults
ôôC N
,
ôôN O
ref
ôôP S
	lightData
ôôT ]
)
ôô] ^
;
ôô^ _
if
öö 
(
öö #
additionalLightsCount
öö %
>
öö& '
$num
öö( )
)
öö) *
{
õõ 
if
úú 
(
úú #
m_UseStructuredBuffer
úú )
)
úú) *
{
ùù 
NativeArray
ûû 
<
ûû  
ShaderInput
ûû  +
.
ûû+ ,
	LightData
ûû, 5
>
ûû5 6"
additionalLightsData
ûû7 K
=
ûûL M
new
ûûN Q
NativeArray
ûûR ]
<
ûû] ^
ShaderInput
ûû^ i
.
ûûi j
	LightData
ûûj s
>
ûûs t
(
ûût u$
additionalLightsCountûûu ä
,ûûä ã
	Allocatorûûå ï
.ûûï ñ
Tempûûñ ö
)ûûö õ
;ûûõ ú
for
üü 
(
üü 
int
üü 
i
üü 
=
üü  
$num
üü! "
,
üü" #
	lightIter
üü$ -
=
üü. /
$num
üü0 1
;
üü1 2
i
üü3 4
<
üü5 6
lights
üü7 =
.
üü= >
Length
üü> D
&&
üüE G
	lightIter
üüH Q
<
üüR S&
maxAdditionalLightsCount
üüT l
;
üül m
++
üün p
i
üüp q
)
üüq r
{
†† 
VisibleLight
°° $
light
°°% *
=
°°+ ,
lights
°°- 3
[
°°3 4
i
°°4 5
]
°°5 6
;
°°6 7
if
¢¢ 
(
¢¢ 
	lightData
¢¢ %
.
¢¢% &
mainLightIndex
¢¢& 4
!=
¢¢5 7
i
¢¢8 9
)
¢¢9 :
{
££ 
ShaderInput
§§ '
.
§§' (
	LightData
§§( 1
data
§§2 6
;
§§6 7&
InitializeLightConstants
•• 4
(
••4 5
lights
••5 ;
,
••; <
i
••= >
,
••> ?
out
¶¶  #
data
¶¶$ (
.
¶¶( )
position
¶¶) 1
,
¶¶1 2
out
¶¶3 6
data
¶¶7 ;
.
¶¶; <
color
¶¶< A
,
¶¶A B
out
¶¶C F
data
¶¶G K
.
¶¶K L
attenuation
¶¶L W
,
¶¶W X
out
ßß  #
data
ßß$ (
.
ßß( )
spotDirection
ßß) 6
,
ßß6 7
out
ßß8 ;
data
ßß< @
.
ßß@ A$
occlusionProbeChannels
ßßA W
)
ßßW X
;
ßßX Y"
additionalLightsData
®® 0
[
®®0 1
	lightIter
®®1 :
]
®®: ;
=
®®< =
data
®®> B
;
®®B C
	lightIter
©© %
++
©©% '
;
©©' (
}
™™ 
}
´´ 
var
≠≠ 
lightDataBuffer
≠≠ '
=
≠≠( )

ShaderData
≠≠* 4
.
≠≠4 5
instance
≠≠5 =
.
≠≠= > 
GetLightDataBuffer
≠≠> P
(
≠≠P Q#
additionalLightsCount
≠≠Q f
)
≠≠f g
;
≠≠g h
lightDataBuffer
ÆÆ #
.
ÆÆ# $
SetData
ÆÆ$ +
(
ÆÆ+ ,"
additionalLightsData
ÆÆ, @
)
ÆÆ@ A
;
ÆÆA B
int
∞∞ 
lightIndices
∞∞ $
=
∞∞% &
cullResults
∞∞' 2
.
∞∞2 3/
!lightAndReflectionProbeIndexCount
∞∞3 T
;
∞∞T U
var
±±  
lightIndicesBuffer
±± *
=
±±+ ,

ShaderData
±±- 7
.
±±7 8
instance
±±8 @
.
±±@ A#
GetLightIndicesBuffer
±±A V
(
±±V W
lightIndices
±±W c
)
±±c d
;
±±d e
cmd
≥≥ 
.
≥≥ 
SetGlobalBuffer
≥≥ '
(
≥≥' ((
m_AdditionalLightsBufferId
≥≥( B
,
≥≥B C
lightDataBuffer
≥≥D S
)
≥≥S T
;
≥≥T U
cmd
¥¥ 
.
¥¥ 
SetGlobalBuffer
¥¥ '
(
¥¥' ()
m_AdditionalLightsIndicesId
¥¥( C
,
¥¥C D 
lightIndicesBuffer
¥¥E W
)
¥¥W X
;
¥¥X Y"
additionalLightsData
∂∂ (
.
∂∂( )
Dispose
∂∂) 0
(
∂∂0 1
)
∂∂1 2
;
∂∂2 3
}
∑∑ 
else
∏∏ 
{
ππ 
for
∫∫ 
(
∫∫ 
int
∫∫ 
i
∫∫ 
=
∫∫  
$num
∫∫! "
,
∫∫" #
	lightIter
∫∫$ -
=
∫∫. /
$num
∫∫0 1
;
∫∫1 2
i
∫∫3 4
<
∫∫5 6
lights
∫∫7 =
.
∫∫= >
Length
∫∫> D
&&
∫∫E G
	lightIter
∫∫H Q
<
∫∫R S&
maxAdditionalLightsCount
∫∫T l
;
∫∫l m
++
∫∫n p
i
∫∫p q
)
∫∫q r
{
ªª 
VisibleLight
ºº $
light
ºº% *
=
ºº+ ,
lights
ºº- 3
[
ºº3 4
i
ºº4 5
]
ºº5 6
;
ºº6 7
if
ΩΩ 
(
ΩΩ 
	lightData
ΩΩ %
.
ΩΩ% &
mainLightIndex
ΩΩ& 4
!=
ΩΩ5 7
i
ΩΩ8 9
)
ΩΩ9 :
{
ææ &
InitializeLightConstants
øø 4
(
øø4 5
lights
øø5 ;
,
øø; <
i
øø= >
,
øø> ?
out
øø@ C(
m_AdditionalLightPositions
øøD ^
[
øø^ _
	lightIter
øø_ h
]
øøh i
,
øøi j
out
¿¿  #%
m_AdditionalLightColors
¿¿$ ;
[
¿¿; <
	lightIter
¿¿< E
]
¿¿E F
,
¿¿F G
out
¡¡  #+
m_AdditionalLightAttenuations
¡¡$ A
[
¡¡A B
	lightIter
¡¡B K
]
¡¡K L
,
¡¡L M
out
¬¬  #-
m_AdditionalLightSpotDirections
¬¬$ C
[
¬¬C D
	lightIter
¬¬D M
]
¬¬M N
,
¬¬N O
out
√√  #5
'm_AdditionalLightOcclusionProbeChannels
√√$ K
[
√√K L
	lightIter
√√L U
]
√√U V
)
√√V W
;
√√W X
	lightIter
ƒƒ %
++
ƒƒ% '
;
ƒƒ' (
}
≈≈ 
}
∆∆ 
cmd
»» 
.
»» "
SetGlobalVectorArray
»» ,
(
»», -!
LightConstantBuffer
»»- @
.
»»@ A'
_AdditionalLightsPosition
»»A Z
,
»»Z [(
m_AdditionalLightPositions
»»\ v
)
»»v w
;
»»w x
cmd
…… 
.
…… "
SetGlobalVectorArray
…… ,
(
……, -!
LightConstantBuffer
……- @
.
……@ A$
_AdditionalLightsColor
……A W
,
……W X%
m_AdditionalLightColors
……Y p
)
……p q
;
……q r
cmd
   
.
   "
SetGlobalVectorArray
   ,
(
  , -!
LightConstantBuffer
  - @
.
  @ A*
_AdditionalLightsAttenuation
  A ]
,
  ] ^+
m_AdditionalLightAttenuations
  _ |
)
  | }
;
  } ~
cmd
ÀÀ 
.
ÀÀ "
SetGlobalVectorArray
ÀÀ ,
(
ÀÀ, -!
LightConstantBuffer
ÀÀ- @
.
ÀÀ@ A&
_AdditionalLightsSpotDir
ÀÀA Y
,
ÀÀY Z-
m_AdditionalLightSpotDirections
ÀÀ[ z
)
ÀÀz {
;
ÀÀ{ |
cmd
ÃÃ 
.
ÃÃ "
SetGlobalVectorArray
ÃÃ ,
(
ÃÃ, -!
LightConstantBuffer
ÃÃ- @
.
ÃÃ@ A3
%_AdditionalLightOcclusionProbeChannel
ÃÃA f
,
ÃÃf g6
'm_AdditionalLightOcclusionProbeChannelsÃÃh è
)ÃÃè ê
;ÃÃê ë
}
ÕÕ 
cmd
œœ 
.
œœ 
SetGlobalVector
œœ #
(
œœ# $!
LightConstantBuffer
œœ$ 7
.
œœ7 8$
_AdditionalLightsCount
œœ8 N
,
œœN O
new
œœP S
Vector4
œœT [
(
œœ[ \
	lightData
œœ\ e
.
œœe f0
!maxPerObjectAdditionalLightsCountœœf á
,œœá à
$num
–– 
,
–– 
$num
–– 
,
–– 
$num
––  $
)
––$ %
)
––% &
;
––& '
}
—— 
else
““ 
{
”” 
cmd
‘‘ 
.
‘‘ 
SetGlobalVector
‘‘ #
(
‘‘# $!
LightConstantBuffer
‘‘$ 7
.
‘‘7 8$
_AdditionalLightsCount
‘‘8 N
,
‘‘N O
Vector4
‘‘P W
.
‘‘W X
zero
‘‘X \
)
‘‘\ ]
;
‘‘] ^
}
’’ 
}
÷÷ 	
int
ÿÿ (
SetupPerObjectLightIndices
ÿÿ &
(
ÿÿ& '
CullingResults
ÿÿ' 5
cullResults
ÿÿ6 A
,
ÿÿA B
ref
ÿÿC F
	LightData
ÿÿG P
	lightData
ÿÿQ Z
)
ÿÿZ [
{
ŸŸ 	
if
⁄⁄ 
(
⁄⁄ 
	lightData
⁄⁄ 
.
⁄⁄ #
additionalLightsCount
⁄⁄ /
==
⁄⁄0 2
$num
⁄⁄3 4
)
⁄⁄4 5
return
€€ 
	lightData
€€  
.
€€  !#
additionalLightsCount
€€! 6
;
€€6 7
var
›› 
visibleLights
›› 
=
›› 
	lightData
››  )
.
››) *
visibleLights
››* 7
;
››7 8
var
ﬁﬁ $
perObjectLightIndexMap
ﬁﬁ &
=
ﬁﬁ' (
cullResults
ﬁﬁ) 4
.
ﬁﬁ4 5
GetLightIndexMap
ﬁﬁ5 E
(
ﬁﬁE F
	Allocator
ﬁﬁF O
.
ﬁﬁO P
Temp
ﬁﬁP T
)
ﬁﬁT U
;
ﬁﬁU V
int
ﬂﬂ *
globalDirectionalLightsCount
ﬂﬂ ,
=
ﬂﬂ- .
$num
ﬂﬂ/ 0
;
ﬂﬂ0 1
int
‡‡ #
additionalLightsCount
‡‡ %
=
‡‡& '
$num
‡‡( )
;
‡‡) *
for
‰‰ 
(
‰‰ 
int
‰‰ 
i
‰‰ 
=
‰‰ 
$num
‰‰ 
;
‰‰ 
i
‰‰ 
<
‰‰ 
visibleLights
‰‰  -
.
‰‰- .
Length
‰‰. 4
;
‰‰4 5
++
‰‰6 8
i
‰‰8 9
)
‰‰9 :
{
ÂÂ 
if
ÊÊ 
(
ÊÊ #
additionalLightsCount
ÊÊ )
>=
ÊÊ* ,%
UniversalRenderPipeline
ÊÊ- D
.
ÊÊD E(
maxVisibleAdditionalLights
ÊÊE _
)
ÊÊ_ `
break
ÁÁ 
;
ÁÁ 
VisibleLight
ÈÈ 
light
ÈÈ "
=
ÈÈ# $
visibleLights
ÈÈ% 2
[
ÈÈ2 3
i
ÈÈ3 4
]
ÈÈ4 5
;
ÈÈ5 6
if
ÍÍ 
(
ÍÍ 
i
ÍÍ 
==
ÍÍ 
	lightData
ÍÍ "
.
ÍÍ" #
mainLightIndex
ÍÍ# 1
)
ÍÍ1 2
{
ÎÎ $
perObjectLightIndexMap
ÏÏ *
[
ÏÏ* +
i
ÏÏ+ ,
]
ÏÏ, -
=
ÏÏ. /
-
ÏÏ0 1
$num
ÏÏ1 2
;
ÏÏ2 3
++
ÌÌ *
globalDirectionalLightsCount
ÌÌ 2
;
ÌÌ2 3
}
ÓÓ 
else
ÔÔ 
{
 $
perObjectLightIndexMap
ÒÒ *
[
ÒÒ* +
i
ÒÒ+ ,
]
ÒÒ, -
-=
ÒÒ. 0*
globalDirectionalLightsCount
ÒÒ1 M
;
ÒÒM N
++
ÚÚ #
additionalLightsCount
ÚÚ +
;
ÚÚ+ ,
}
ÛÛ 
}
ÙÙ 
for
˜˜ 
(
˜˜ 
int
˜˜ 
i
˜˜ 
=
˜˜ *
globalDirectionalLightsCount
˜˜ 5
+
˜˜6 7#
additionalLightsCount
˜˜8 M
;
˜˜M N
i
˜˜O P
<
˜˜Q R$
perObjectLightIndexMap
˜˜S i
.
˜˜i j
Length
˜˜j p
;
˜˜p q
++
˜˜r t
i
˜˜t u
)
˜˜u v$
perObjectLightIndexMap
¯¯ &
[
¯¯& '
i
¯¯' (
]
¯¯( )
=
¯¯* +
-
¯¯, -
$num
¯¯- .
;
¯¯. /
cullResults
˙˙ 
.
˙˙ 
SetLightIndexMap
˙˙ (
(
˙˙( )$
perObjectLightIndexMap
˙˙) ?
)
˙˙? @
;
˙˙@ A
if
¸¸ 
(
¸¸ #
m_UseStructuredBuffer
¸¸ %
&&
¸¸& (#
additionalLightsCount
¸¸) >
>
¸¸? @
$num
¸¸A B
)
¸¸B C
{
˝˝ 
int
˛˛ ,
lightAndReflectionProbeIndices
˛˛ 2
=
˛˛3 4
cullResults
˛˛5 @
.
˛˛@ A/
!lightAndReflectionProbeIndexCount
˛˛A b
;
˛˛b c

Assertions
ˇˇ 
.
ˇˇ 
Assert
ˇˇ !
.
ˇˇ! "
IsTrue
ˇˇ" (
(
ˇˇ( ),
lightAndReflectionProbeIndices
ˇˇ) G
>
ˇˇH I
$num
ˇˇJ K
,
ˇˇK L
$strˇˇM ´
)ˇˇ´ ¨
;ˇˇ¨ ≠
cullResults
ÄÄ 
.
ÄÄ 0
"FillLightAndReflectionProbeIndices
ÄÄ >
(
ÄÄ> ?

ShaderData
ÄÄ? I
.
ÄÄI J
instance
ÄÄJ R
.
ÄÄR S#
GetLightIndicesBuffer
ÄÄS h
(
ÄÄh i-
lightAndReflectionProbeIndicesÄÄi á
)ÄÄá à
)ÄÄà â
;ÄÄâ ä
}
ÅÅ $
perObjectLightIndexMap
ÉÉ "
.
ÉÉ" #
Dispose
ÉÉ# *
(
ÉÉ* +
)
ÉÉ+ ,
;
ÉÉ, -
return
ÑÑ #
additionalLightsCount
ÑÑ (
;
ÑÑ( )
}
ÖÖ 	
}
ÜÜ 
}áá ±?
ûD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Light2DManager.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
internal		 
static		 
class		 
Light2DManager		 (
{

 
private 
static 
SortingLayer #
[# $
]$ %
s_SortingLayers& 5
;5 6
public 
static 
List 
< 
Light2D "
>" #
lights$ *
{+ ,
get- 0
;0 1
}2 3
=4 5
new6 9
List: >
<> ?
Light2D? F
>F G
(G H
)H I
;I J
public 
static 
void 
RegisterLight (
(( )
Light2D) 0
light1 6
)6 7
{ 	
Debug 
. 
Assert 
( 
! 
lights  
.  !
Contains! )
() *
light* /
)/ 0
)0 1
;1 2
lights 
. 
Add 
( 
light 
) 
; '
ErrorIfDuplicateGlobalLight '
(' (
light( -
)- .
;. /
} 	
public 
static 
void 
DeregisterLight *
(* +
Light2D+ 2
light3 8
)8 9
{ 	
Debug 
. 
Assert 
( 
lights 
.  
Contains  (
(( )
light) .
). /
)/ 0
;0 1
lights 
. 
Remove 
( 
light 
)  
;  !
} 	
public 
static 
void '
ErrorIfDuplicateGlobalLight 6
(6 7
Light2D7 >
light? D
)D E
{ 	
if   
(   
light   
.   
	lightType   
!=    "
Light2D  # *
.  * +
	LightType  + 4
.  4 5
Global  5 ;
)  ; <
return!! 
;!! 
foreach## 
(## 
var## 
sortingLayer## %
in##& (
light##) .
.##. /!
affectedSortingLayers##/ D
)##D E
{$$ 
if&& 
(&& (
ContainsDuplicateGlobalLight&& /
(&&/ 0
sortingLayer&&0 <
,&&< =
light&&> C
.&&C D
blendStyleIndex&&D S
)&&S T
)&&T U
Debug'' 
.'' 
LogError'' "
(''" #
$str''# I
+''J K
SortingLayer''L X
.''X Y
IDToName''Y a
(''a b
sortingLayer''b n
)''n o
+''p q
$str	''r ë
+
''í ì
light
''î ô
.
''ô ö
blendStyleIndex
''ö ©
)
''© ™
;
''™ ´
}(( 
})) 	
public++ 
static++ 
bool++ 
GetGlobalColor++ )
(++) *
int++* -
sortingLayerIndex++. ?
,++? @
int++A D
blendStyleIndex++E T
,++T U
out++V Y
Color++Z _
color++` e
)++e f
{,, 	
var-- 
foundGlobalColor-- !
=--" #
false--$ )
;--) *
color.. 
=.. 
Color.. 
... 
black.. 
;..  
foreach11 
(11 
var11 
light11 
in11  
lights11! '
)11' (
{22 
if33 
(33 
light33 
.33 
	lightType33 #
!=33$ &
Light2D33' .
.33. /
	LightType33/ 8
.338 9
Global339 ?
||33@ B
light44 
.44 
blendStyleIndex44 )
!=44* ,
blendStyleIndex44- <
||44= ?
!55 
light55 
.55 

IsLitLayer55 %
(55% &
sortingLayerIndex55& 7
)557 8
)558 9
continue66 
;66 
var88  
inCurrentPrefabStage88 (
=88) *
true88+ /
;88/ 0 
inCurrentPrefabStage;; $
=;;% &
PrefabStageUtility;;' 9
.;;9 :!
GetCurrentPrefabStage;;: O
(;;O P
);;P Q
?;;Q R
.;;R S"
IsPartOfPrefabContents;;S i
(;;i j
light;;j o
.;;o p

gameObject;;p z
);;z {
??;;| ~
true	;; É
;
;;É Ñ
if>> 
(>>  
inCurrentPrefabStage>> (
)>>( )
{?? 
color@@ 
=@@ 
light@@ !
.@@! "
color@@" '
*@@( )
light@@* /
.@@/ 0
	intensity@@0 9
;@@9 :
returnAA 
trueAA 
;AA  
}BB 
elseCC 
{DD 
ifEE 
(EE 
!EE 
foundGlobalColorEE )
)EE) *
{FF 
colorGG 
=GG 
lightGG  %
.GG% &
colorGG& +
*GG, -
lightGG. 3
.GG3 4
	intensityGG4 =
;GG= >
foundGlobalColorHH (
=HH) *
trueHH+ /
;HH/ 0
}II 
}JJ 
}KK 
returnMM 
foundGlobalColorMM #
;MM# $
}NN 	
privatePP 
staticPP 
boolPP (
ContainsDuplicateGlobalLightPP 8
(PP8 9
intPP9 <
sortingLayerIndexPP= N
,PPN O
intPPP S
blendStyleIndexPPT c
)PPc d
{QQ 	
varRR 
globalLightCountRR  
=RR! "
$numRR# $
;RR$ %
foreachUU 
(UU 
varUU 
lightUU 
inUU  
lightsUU! '
)UU' (
{VV 
ifWW 
(WW 
lightWW 
.WW 
	lightTypeWW #
==WW$ &
Light2DWW' .
.WW. /
	LightTypeWW/ 8
.WW8 9
GlobalWW9 ?
&&WW@ B
lightXX 
.XX 
blendStyleIndexXX )
==XX* ,
blendStyleIndexXX- <
&&XX= ?
lightYY 
.YY 

IsLitLayerYY $
(YY$ %
sortingLayerIndexYY% 6
)YY6 7
)YY7 8
{ZZ 
if]] 
(]] 
PrefabStageUtility]] *
.]]* +
GetPrefabStage]]+ 9
(]]9 :
light]]: ?
.]]? @

gameObject]]@ J
)]]J K
==]]L N
PrefabStageUtility]]O a
.]]a b!
GetCurrentPrefabStage]]b w
(]]w x
)]]x y
)]]y z
{__ 
if`` 
(`` 
globalLightCount`` ,
>``- .
$num``/ 0
)``0 1
returnaa "
trueaa# '
;aa' (
globalLightCountcc (
++cc( *
;cc* +
}dd 
}ee 
}ff 
returnhh 
falsehh 
;hh 
}ii 	
publickk 
statickk 
SortingLayerkk "
[kk" #
]kk# $!
GetCachedSortingLayerkk% :
(kk: ;
)kk; <
{ll 	
s_SortingLayersmm 
??=mm 
SortingLayermm  ,
.mm, -
layersmm- 3
;mm3 4
ifpp 
(pp 
!pp 
Applicationpp 
.pp 
	isPlayingpp %
)pp% &
s_SortingLayersqq 
=qq  !
SortingLayerqq" .
.qq. /
layersqq/ 5
;qq5 6
returnss 
s_SortingLayersss "
;ss" #
}tt 	
}vv 
}ww ˙
üD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\DeferredShaderData.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
class 	
DeferredShaderData
 
: 
IDisposable *
{		 
static

 
DeferredShaderData

 !

m_Instance

" ,
=

- .
null

/ 3
;

3 4
struct 
ComputeBufferInfo  
{ 	
public 
uint 
	frameUsed !
;! "
public 
ComputeBufferType $
type% )
;) *
} 	
NativeArray 
< 
PreTile 
> 
[ 
] 

m_PreTiles )
=* +
null, 0
;0 1
ComputeBuffer 
[ 
] 
	m_Buffers !
=" #
null$ (
;( )
ComputeBufferInfo 
[ 
] 
m_BufferInfos )
;) *
int 
m_BufferCount 
= 
$num 
; 
int 
m_CachedBufferIndex 
=  !
$num" #
;# $
uint 
m_FrameIndex 
= 
$num 
; 
DeferredShaderData   
(   
)   
{!! 	

m_PreTiles"" 
="" 
new"" 
NativeArray"" (
<""( )
PreTile"") 0
>""0 1
[""1 2
DeferredConfig""2 @
.""@ A
kTilerDepth""A L
]""L M
;""M N
	m_Buffers## 
=## 
new## 
ComputeBuffer## )
[##) *
$num##* ,
]##, -
;##- .
m_BufferInfos$$ 
=$$ 
new$$ 
ComputeBufferInfo$$  1
[$$1 2
$num$$2 4
]$$4 5
;$$5 6
}%% 	
internal'' 
static'' 
DeferredShaderData'' *
instance''+ 3
{(( 	
get)) 
{** 
if++ 
(++ 

m_Instance++ 
==++ !
null++" &
)++& '

m_Instance,, 
=,,  
new,,! $
DeferredShaderData,,% 7
(,,7 8
),,8 9
;,,9 :
return.. 

m_Instance.. !
;..! "
}// 
}00 	
public22 
void22 
Dispose22 
(22 
)22 
{33 	
DisposeNativeArrays44 
(44  
ref44  #

m_PreTiles44$ .
)44. /
;44/ 0
for66 
(66 
int66 
i66 
=66 
$num66 
;66 
i66 
<66 
	m_Buffers66  )
.66) *
Length66* 0
;660 1
++662 4
i664 5
)665 6
{77 
if88 
(88 
	m_Buffers88 
[88 
i88 
]88  
!=88! #
null88$ (
)88( )
{99 
	m_Buffers:: 
[:: 
i:: 
]::  
.::  !
Dispose::! (
(::( )
)::) *
;::* +
	m_Buffers;; 
[;; 
i;; 
];;  
=;;! "
null;;# '
;;;' (
}<< 
}== 
m_BufferCount>> 
=>> 
$num>> 
;>> 
}?? 	
internalAA 
voidAA 
ResetBuffersAA "
(AA" #
)AA# $
{BB 	
++CC 
m_FrameIndexCC 
;CC 
}DD 	
internalFF 
NativeArrayFF 
<FF 
PreTileFF $
>FF$ %
GetPreTilesFF& 1
(FF1 2
intFF2 5
levelFF6 ;
,FF; <
intFF= @
countFFA F
)FFF G
{GG 	
returnHH "
GetOrUpdateNativeArrayHH )
<HH) *
PreTileHH* 1
>HH1 2
(HH2 3
refHH3 6

m_PreTilesHH7 A
,HHA B
levelHHC H
,HHH I
countHHJ O
)HHO P
;HHP Q
}II 	
internalKK 
ComputeBufferKK 
ReserveBufferKK ,
<KK, -
TKK- .
>KK. /
(KK/ 0
intKK0 3
countKK4 9
,KK9 :
boolKK; ?
	asCBufferKK@ I
)KKI J
whereKKK P
TKKQ R
:KKS T
structKKU [
{LL 	
intMM 
strideMM 
=MM 
MarshalMM  
.MM  !
SizeOfMM! '
<MM' (
TMM( )
>MM) *
(MM* +
)MM+ ,
;MM, -
intNN 
paddedCountNN 
=NN 
	asCBufferNN '
?NN( )
AlignNN* /
(NN/ 0
strideNN0 6
*NN7 8
countNN9 >
,NN> ?
$numNN@ B
)NNB C
/NND E
strideNNF L
:NNM N
countNNO T
;NNT U
returnOO 
GetOrUpdateBufferOO $
(OO$ %
paddedCountOO% 0
,OO0 1
strideOO2 8
,OO8 9
	asCBufferOO: C
)OOC D
;OOD E
}PP 	
NativeArrayRR 
<RR 
TRR 
>RR "
GetOrUpdateNativeArrayRR -
<RR- .
TRR. /
>RR/ 0
(RR0 1
refRR1 4
NativeArrayRR5 @
<RR@ A
TRRA B
>RRB C
[RRC D
]RRD E
nativeArraysRRF R
,RRR S
intRRT W
levelRRX ]
,RR] ^
intRR_ b
countRRc h
)RRh i
whereRRj o
TRRp q
:RRr s
structRRt z
{SS 	
ifTT 
(TT 
!TT 
nativeArraysTT 
[TT 
levelTT #
]TT# $
.TT$ %
	IsCreatedTT% .
)TT. /
{UU 
nativeArraysVV 
[VV 
levelVV "
]VV" #
=VV$ %
newVV& )
NativeArrayVV* 5
<VV5 6
TVV6 7
>VV7 8
(VV8 9
countVV9 >
,VV> ?
	AllocatorVV@ I
.VVI J

PersistentVVJ T
)VVT U
;VVU V
}WW 
elseXX 
ifXX 
(XX 
countXX 
>XX 
nativeArraysXX )
[XX) *
levelXX* /
]XX/ 0
.XX0 1
LengthXX1 7
)XX7 8
{YY 
nativeArraysZZ 
[ZZ 
levelZZ "
]ZZ" #
.ZZ# $
DisposeZZ$ +
(ZZ+ ,
)ZZ, -
;ZZ- .
nativeArrays[[ 
[[[ 
level[[ "
][[" #
=[[$ %
new[[& )
NativeArray[[* 5
<[[5 6
T[[6 7
>[[7 8
([[8 9
count[[9 >
,[[> ?
	Allocator[[@ I
.[[I J

Persistent[[J T
)[[T U
;[[U V
}\\ 
return^^ 
nativeArrays^^ 
[^^  
level^^  %
]^^% &
;^^& '
}__ 	
voidaa 
DisposeNativeArraysaa  
<aa  !
Taa! "
>aa" #
(aa# $
refaa$ '
NativeArrayaa( 3
<aa3 4
Taa4 5
>aa5 6
[aa6 7
]aa7 8
nativeArraysaa9 E
)aaE F
whereaaG L
TaaM N
:aaO P
structaaQ W
{bb 	
forcc 
(cc 
intcc 
icc 
=cc 
$numcc 
;cc 
icc 
<cc 
nativeArrayscc  ,
.cc, -
Lengthcc- 3
;cc3 4
++cc5 7
icc7 8
)cc8 9
{dd 
ifee 
(ee 
nativeArraysee  
[ee  !
iee! "
]ee" #
.ee# $
	IsCreatedee$ -
)ee- .
nativeArraysff  
[ff  !
iff! "
]ff" #
.ff# $
Disposeff$ +
(ff+ ,
)ff, -
;ff- .
}gg 
}hh 	
ComputeBufferjj 
GetOrUpdateBufferjj '
(jj' (
intjj( +
countjj, 1
,jj1 2
intjj3 6
stridejj7 =
,jj= >
booljj? C
isConstantBufferjjD T
)jjT U
{kk 	
ComputeBufferTypell 
typell "
=ll# $
isConstantBufferll% 5
?ll6 7
ComputeBufferTypell8 I
.llI J
ConstantllJ R
:llS T
ComputeBufferTypellU f
.llf g

Structuredllg q
;llq r
intpp 
maxQueuedFramespp 
=pp  !
QualitySettingspp" 1
.pp1 2
maxQueuedFramespp2 A
;ppA B

Assertionsqq 
.qq 
Assertqq 
.qq 
IsTrueqq $
(qq$ %
maxQueuedFramesqq% 4
>=qq5 7
$numqq8 9
,qq9 :
$strqq; d
)qqd e
;qqe f
fortt 
(tt 
inttt 
itt 
=tt 
$numtt 
;tt 
itt 
<tt 
m_BufferCounttt  -
;tt- .
++tt/ 1
itt1 2
)tt2 3
{uu 
intvv 
bufferIndexvv 
=vv  !
(vv" #
m_CachedBufferIndexvv# 6
+vv7 8
ivv9 :
+vv; <
$numvv= >
)vv> ?
%vv@ A
m_BufferCountvvB O
;vvO P
ifxx 
(xx 
IsLessCircularxx "
(xx" #
m_BufferInfosxx# 0
[xx0 1
bufferIndexxx1 <
]xx< =
.xx= >
	frameUsedxx> G
+xxH I
(xxJ K
uintxxK O
)xxO P
maxQueuedFramesxxP _
,xx_ `
m_FrameIndexxxa m
)xxm n
&&yy 
m_BufferInfosyy $
[yy$ %
bufferIndexyy% 0
]yy0 1
.yy1 2
typeyy2 6
==yy7 9
typeyy: >
&&yy? A
	m_BuffersyyB K
[yyK L
bufferIndexyyL W
]yyW X
.yyX Y
countyyY ^
==yy_ a
countyyb g
&&yyh j
	m_Buffersyyk t
[yyt u
bufferIndex	yyu Ä
]
yyÄ Å
.
yyÅ Ç
stride
yyÇ à
==
yyâ ã
stride
yyå í
)
yyí ì
{zz 
m_BufferInfos{{ !
[{{! "
bufferIndex{{" -
]{{- .
.{{. /
	frameUsed{{/ 8
={{9 :
m_FrameIndex{{; G
;{{G H
m_CachedBufferIndex|| '
=||( )
bufferIndex||* 5
;||5 6
return}} 
	m_Buffers}} $
[}}$ %
bufferIndex}}% 0
]}}0 1
;}}1 2
}~~ 
} 
if
ÅÅ 
(
ÅÅ 
m_BufferCount
ÅÅ 
==
ÅÅ  
	m_Buffers
ÅÅ! *
.
ÅÅ* +
Length
ÅÅ+ 1
)
ÅÅ1 2
{
ÇÇ 
ComputeBuffer
ÉÉ 
[
ÉÉ 
]
ÉÉ 

newBuffers
ÉÉ  *
=
ÉÉ+ ,
new
ÉÉ- 0
ComputeBuffer
ÉÉ1 >
[
ÉÉ> ?
m_BufferCount
ÉÉ? L
*
ÉÉM N
$num
ÉÉO P
]
ÉÉP Q
;
ÉÉQ R
for
ÑÑ 
(
ÑÑ 
int
ÑÑ 
i
ÑÑ 
=
ÑÑ 
$num
ÑÑ 
;
ÑÑ 
i
ÑÑ  !
<
ÑÑ" #
m_BufferCount
ÑÑ$ 1
;
ÑÑ1 2
++
ÑÑ3 5
i
ÑÑ5 6
)
ÑÑ6 7

newBuffers
ÖÖ 
[
ÖÖ 
i
ÖÖ  
]
ÖÖ  !
=
ÖÖ" #
	m_Buffers
ÖÖ$ -
[
ÖÖ- .
i
ÖÖ. /
]
ÖÖ/ 0
;
ÖÖ0 1
	m_Buffers
ÜÜ 
=
ÜÜ 

newBuffers
ÜÜ &
;
ÜÜ& '
ComputeBufferInfo
àà !
[
àà! "
]
àà" #
newBufferInfos
àà$ 2
=
àà3 4
new
àà5 8
ComputeBufferInfo
àà9 J
[
ààJ K
m_BufferCount
ààK X
*
ààY Z
$num
àà[ \
]
àà\ ]
;
àà] ^
for
ââ 
(
ââ 
int
ââ 
i
ââ 
=
ââ 
$num
ââ 
;
ââ 
i
ââ  !
<
ââ" #
m_BufferCount
ââ$ 1
;
ââ1 2
++
ââ3 5
i
ââ5 6
)
ââ6 7
newBufferInfos
ää "
[
ää" #
i
ää# $
]
ää$ %
=
ää& '
m_BufferInfos
ää( 5
[
ää5 6
i
ää6 7
]
ää7 8
;
ää8 9
m_BufferInfos
ãã 
=
ãã 
newBufferInfos
ãã  .
;
ãã. /
}
åå 
	m_Buffers
èè 
[
èè 
m_BufferCount
èè #
]
èè# $
=
èè% &
new
èè' *
ComputeBuffer
èè+ 8
(
èè8 9
count
èè9 >
,
èè> ?
stride
èè@ F
,
èèF G
type
èèH L
,
èèL M
ComputeBufferMode
èèN _
.
èè_ `
	Immutable
èè` i
)
èèi j
;
èèj k
m_BufferInfos
êê 
[
êê 
m_BufferCount
êê '
]
êê' (
.
êê( )
	frameUsed
êê) 2
=
êê3 4
m_FrameIndex
êê5 A
;
êêA B
m_BufferInfos
ëë 
[
ëë 
m_BufferCount
ëë '
]
ëë' (
.
ëë( )
type
ëë) -
=
ëë. /
type
ëë0 4
;
ëë4 5!
m_CachedBufferIndex
íí 
=
íí  !
m_BufferCount
íí" /
;
íí/ 0
return
ìì 
	m_Buffers
ìì 
[
ìì 
m_BufferCount
ìì *
++
ìì* ,
]
ìì, -
;
ìì- .
}
îî 	
void
ññ 
DisposeBuffers
ññ 
(
ññ 
ComputeBuffer
ññ )
[
ññ) *
,
ññ* +
]
ññ+ ,
buffers
ññ- 4
)
ññ4 5
{
óó 	
for
òò 
(
òò 
int
òò 
i
òò 
=
òò 
$num
òò 
;
òò 
i
òò 
<
òò 
buffers
òò  '
.
òò' (
	GetLength
òò( 1
(
òò1 2
$num
òò2 3
)
òò3 4
;
òò4 5
++
òò6 8
i
òò8 9
)
òò9 :
{
ôô 
for
öö 
(
öö 
int
öö 
j
öö 
=
öö 
$num
öö 
;
öö 
j
öö  !
<
öö" #
buffers
öö$ +
.
öö+ ,
	GetLength
öö, 5
(
öö5 6
$num
öö6 7
)
öö7 8
;
öö8 9
++
öö: <
j
öö< =
)
öö= >
{
õõ 
if
ùù 
(
ùù 
buffers
ùù 
[
ùù  
i
ùù  !
,
ùù! "
j
ùù# $
]
ùù$ %
!=
ùù& (
null
ùù) -
)
ùù- .
{
ûû 
buffers
üü 
[
üü  
i
üü  !
,
üü! "
j
üü# $
]
üü$ %
.
üü% &
Dispose
üü& -
(
üü- .
)
üü. /
;
üü/ 0
buffers
†† 
[
††  
i
††  !
,
††! "
j
††# $
]
††$ %
=
††& '
null
††( ,
;
††, -
}
°° 
}
¢¢ 
}
££ 
}
§§ 	
static
¶¶ 
bool
¶¶ 
IsLessCircular
¶¶ "
(
¶¶" #
uint
¶¶# '
a
¶¶( )
,
¶¶) *
uint
¶¶+ /
b
¶¶0 1
)
¶¶1 2
{
ßß 	
return
®® 
a
®® 
!=
®® 
b
®® 
?
®® 
(
®® 
b
®® 
-
®®  
a
®®! "
)
®®" #
<
®®$ %
$num
®®& 0
:
®®1 2
false
®®3 8
;
®®8 9
}
©© 	
static
´´ 
int
´´ 
Align
´´ 
(
´´ 
int
´´ 
s
´´ 
,
´´ 
int
´´  #
	alignment
´´$ -
)
´´- .
{
¨¨ 	
return
≠≠ 
(
≠≠ 
(
≠≠ 
s
≠≠ 
+
≠≠ 
	alignment
≠≠ "
-
≠≠# $
$num
≠≠% &
)
≠≠& '
/
≠≠( )
	alignment
≠≠* 3
)
≠≠3 4
*
≠≠5 6
	alignment
≠≠7 @
;
≠≠@ A
}
ÆÆ 	
}
ØØ 
}∞∞ À
¢D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\SplitToning.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' E
)E F
]F G
public 

sealed 
class 
SplitToning #
:$ %
VolumeComponent& 5
,5 6!
IPostProcessComponent7 L
{ 
[ 	
Tooltip	 
( 
$str 0
)0 1
]1 2
public		 
ColorParameter		 
shadows		 %
=		& '
new		( +
ColorParameter		, :
(		: ;
Color		; @
.		@ A
grey		A E
,		E F
false		G L
,		L M
false		N S
,		S T
true		U Y
)		Y Z
;		Z [
[ 	
Tooltip	 
( 
$str 3
)3 4
]4 5
public 
ColorParameter 

highlights (
=) *
new+ .
ColorParameter/ =
(= >
Color> C
.C D
greyD H
,H I
falseJ O
,O P
falseQ V
,V W
trueX \
)\ ]
;] ^
[ 	
Tooltip	 
( 
$str L
)L M
]M N
public !
ClampedFloatParameter $
balance% ,
=- .
new/ 2!
ClampedFloatParameter3 H
(H I
$numI K
,K L
-M N
$numN R
,R S
$numT X
)X Y
;Y Z
public 
bool 
IsActive 
( 
) 
=> !
shadows" )
!=* ,
Color- 2
.2 3
grey3 7
||8 :

highlights; E
!=F H
ColorI N
.N O
greyO S
;S T
public 
bool 
IsTileCompatible $
($ %
)% &
=>' )
true* .
;. /
} 
} Ã
¢D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\ColorLookup.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' E
)E F
]F G
public 

sealed 
class 
ColorLookup #
:$ %
VolumeComponent& 5
,5 6!
IPostProcessComponent7 L
{ 
[		 	
Tooltip			 
(		 
$str		 =
)		= >
]		> ?
public

 
TextureParameter

 
texture

  '
=

( )
new

* -
TextureParameter

. >
(

> ?
null

? C
)

C D
;

D E
[ 	
Tooltip	 
( 
$str ^
)^ _
]_ `
public !
ClampedFloatParameter $
contribution% 1
=2 3
new4 7!
ClampedFloatParameter8 M
(M N
$numN P
,P Q
$numR T
,T U
$numV X
)X Y
;Y Z
public 
bool 
IsActive 
( 
) 
=> !
contribution" .
.. /
value/ 4
>5 6
$num7 9
&&: <
ValidateLUT= H
(H I
)I J
;J K
public 
bool 
IsTileCompatible $
($ %
)% &
=>' )
true* .
;. /
public 
bool 
ValidateLUT 
(  
)  !
{ 	
var 
asset 
= #
UniversalRenderPipeline /
./ 0
asset0 5
;5 6
if 
( 
asset 
== 
null 
||  
texture! (
.( )
value) .
==/ 1
null2 6
)6 7
return 
false 
; 
int 
lutSize 
= 
asset 
.  
colorGradingLutSize  3
;3 4
if 
( 
texture 
. 
value 
. 
height $
!=% '
lutSize( /
)/ 0
return 
false 
; 
bool 
valid 
= 
false 
; 
switch 
( 
texture 
. 
value !
)! "
{   
case!! 
	Texture2D!! 
t!!  
:!!  !
valid"" 
|="" 
t"" 
."" 
width"" $
==""% '
lutSize""( /
*""0 1
lutSize""2 9
&&## 
!## !
GraphicsFormatUtility## 3
.##3 4
IsSRGBFormat##4 @
(##@ A
t##A B
.##B C
graphicsFormat##C Q
)##Q R
;##R S
break$$ 
;$$ 
case%% 
RenderTexture%% "
rt%%# %
:%%% &
valid&& 
|=&& 
rt&& 
.&&  
	dimension&&  )
==&&* ,
TextureDimension&&- =
.&&= >
Tex2D&&> C
&&'' 
rt'' 
.''  
width''  %
==''& (
lutSize'') 0
*''1 2
lutSize''3 :
&&(( 
!(( 
rt((  
.((  !
sRGB((! %
;((% &
break)) 
;)) 
}** 
return,, 
valid,, 
;,, 
}-- 	
}.. 
}// í7
¢D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\DrawSkyboxPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
public 

class 
DrawSkyboxPass 
:  ! 
ScriptableRenderPass" 6
{		 
public

 
DrawSkyboxPass

 
(

 
RenderPassEvent

 -
evt

. 1
)

1 2
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @
DrawSkyboxPass@ N
)N O
)O P
;P Q
renderPassEvent 
= 
evt !
;! "
} 	
public 
override 
void 
Execute $
($ %#
ScriptableRenderContext% <
context= D
,D E
refF I
RenderingDataJ W
renderingDataX e
)e f
{ 	
if 
( 
renderingData 
. 

cameraData (
.( )
xr) +
.+ ,
enabled, 3
)3 4
{ 
if 
( 
renderingData !
.! "

cameraData" ,
., -
xr- /
./ 0
singlePassEnabled0 A
)A B
{ 
renderingData !
.! "

cameraData" ,
., -
camera- 3
.3 4%
SetStereoProjectionMatrix4 M
(M N
CameraN T
.T U
StereoscopicEyeU d
.d e
Lefte i
,i j
renderingDatak x
.x y

cameraData	y É
.
É Ñ!
GetProjectionMatrix
Ñ ó
(
ó ò
$num
ò ô
)
ô ö
)
ö õ
;
õ ú
renderingData !
.! "

cameraData" ,
., -
camera- 3
.3 4
SetStereoViewMatrix4 G
(G H
CameraH N
.N O
StereoscopicEyeO ^
.^ _
Left_ c
,c d
renderingDatae r
.r s

cameraDatas }
.} ~
GetViewMatrix	~ ã
(
ã å
$num
å ç
)
ç é
)
é è
;
è ê
renderingData !
.! "

cameraData" ,
., -
camera- 3
.3 4%
SetStereoProjectionMatrix4 M
(M N
CameraN T
.T U
StereoscopicEyeU d
.d e
Righte j
,j k
renderingDatal y
.y z

cameraData	z Ñ
.
Ñ Ö!
GetProjectionMatrix
Ö ò
(
ò ô
$num
ô ö
)
ö õ
)
õ ú
;
ú ù
renderingData !
.! "

cameraData" ,
., -
camera- 3
.3 4
SetStereoViewMatrix4 G
(G H
CameraH N
.N O
StereoscopicEyeO ^
.^ _
Right_ d
,d e
renderingDataf s
.s t

cameraDatat ~
.~ 
GetViewMatrix	 å
(
å ç
$num
ç é
)
é è
)
è ê
;
ê ë
CommandBuffer!! !
cmd!!" %
=!!& '
CommandBufferPool!!( 9
.!!9 :
Get!!: =
(!!= >
)!!> ?
;!!? @
cmd$$ 
.$$ 
SetSinglePassStereo$$ +
($$+ ,

SystemInfo$$, 6
.$$6 7
supportsMultiview$$7 H
?$$I J 
SinglePassStereoMode$$K _
.$$_ `
	Multiview$$` i
:$$j k!
SinglePassStereoMode	$$l Ä
.
$$Ä Å

Instancing
$$Å ã
)
$$ã å
;
$$å ç
context%% 
.%%  
ExecuteCommandBuffer%% 0
(%%0 1
cmd%%1 4
)%%4 5
;%%5 6
cmd&& 
.&& 
Clear&& 
(&& 
)&& 
;&&  
context)) 
.)) 

DrawSkybox)) &
())& '
renderingData))' 4
.))4 5

cameraData))5 ?
.))? @
camera))@ F
)))F G
;))G H
cmd,, 
.,, 
SetSinglePassStereo,, +
(,,+ , 
SinglePassStereoMode,,, @
.,,@ A
None,,A E
),,E F
;,,F G
context-- 
.--  
ExecuteCommandBuffer-- 0
(--0 1
cmd--1 4
)--4 5
;--5 6
CommandBufferPool00 %
.00% &
Release00& -
(00- .
cmd00. 1
)001 2
;002 3
renderingData22 !
.22! "

cameraData22" ,
.22, -
camera22- 3
.223 4)
ResetStereoProjectionMatrices224 Q
(22Q R
)22R S
;22S T
renderingData33 !
.33! "

cameraData33" ,
.33, -
camera33- 3
.333 4#
ResetStereoViewMatrices334 K
(33K L
)33L M
;33M N
}44 
else55 
{66 
renderingData77 !
.77! "

cameraData77" ,
.77, -
camera77- 3
.773 4
projectionMatrix774 D
=77E F
renderingData77G T
.77T U

cameraData77U _
.77_ `
GetProjectionMatrix77` s
(77s t
$num77t u
)77u v
;77v w
renderingData88 !
.88! "

cameraData88" ,
.88, -
camera88- 3
.883 4
worldToCameraMatrix884 G
=88H I
renderingData88J W
.88W X

cameraData88X b
.88b c
GetViewMatrix88c p
(88p q
$num88q r
)88r s
;88s t
context:: 
.:: 

DrawSkybox:: &
(::& '
renderingData::' 4
.::4 5

cameraData::5 ?
.::? @
camera::@ F
)::F G
;::G H
context<< 
.<< 
Submit<< "
(<<" #
)<<# $
;<<$ %
renderingData>> !
.>>! "

cameraData>>" ,
.>>, -
camera>>- 3
.>>3 4!
ResetProjectionMatrix>>4 I
(>>I J
)>>J K
;>>K L
renderingData?? !
.??! "

cameraData??" ,
.??, -
camera??- 3
.??3 4$
ResetWorldToCameraMatrix??4 L
(??L M
)??M N
;??N O
}@@ 
}AA 
elseBB 
{DD 
contextEE 
.EE 

DrawSkyboxEE "
(EE" #
renderingDataEE# 0
.EE0 1

cameraDataEE1 ;
.EE; <
cameraEE< B
)EEB C
;EEC D
}FF 
}GG 	
}HH 
}II œ4
ßD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Renderer2DDataAuthoring.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
public 

partial 
class 
Renderer2DData '
{ 
[

 	
SerializeField

	 
]

 )
Renderer2DDefaultMaterialType %!
m_DefaultMaterialType& ;
=< =)
Renderer2DDefaultMaterialType> [
.[ \
Lit\ _
;_ `
[ 	
SerializeField	 
, 
Reload 
(  
$str  J
)J K
]K L
Material #
m_DefaultCustomMaterial (
=) *
null+ /
;/ 0
[ 	
SerializeField	 
, 
Reload 
(  
$str  J
)J K
]K L
Material  
m_DefaultLitMaterial %
=& '
null( ,
;, -
[ 	
SerializeField	 
, 
Reload 
(  
$str  L
)L M
]M N
Material "
m_DefaultUnlitMaterial '
=( )
null* .
;. /
internal 
override 
Shader  
GetDefaultShader! 1
(1 2
)2 3
{ 	
return 
Shader 
. 
Find 
( 
$str P
)P Q
;Q R
} 	
internal 
override 
Material "
GetDefaultMaterial# 5
(5 6
DefaultMaterialType6 I
materialTypeJ V
)V W
{ 	
if 
( 
materialType 
== 
DefaultMaterialType  3
.3 4
Sprite4 :
||; =
materialType> J
==K M
DefaultMaterialTypeN a
.a b
Particleb j
)j k
{ 
if 
( !
m_DefaultMaterialType )
==* ,)
Renderer2DDefaultMaterialType- J
.J K
LitK N
)N O
return    
m_DefaultLitMaterial   /
;  / 0
else!! 
if!! 
(!! !
m_DefaultMaterialType!! .
==!!/ 1)
Renderer2DDefaultMaterialType!!2 O
.!!O P
Unlit!!P U
)!!U V
return"" "
m_DefaultUnlitMaterial"" 1
;""1 2
else## 
return$$ #
m_DefaultCustomMaterial$$ 2
;$$2 3
}%% 
return'' 
null'' 
;'' 
}(( 	
private** 
void** 
OnEnableInEditor** %
(**% &
)**& '
{++ 	
const-- 
string-- 
suggestedNamesKey-- *
=--+ ,
$str--- R
;--R S
const.. 
string.. 
maskTex..  
=..! "
$str..# -
;..- .
const// 
string// 
	normalMap// "
=//# $
$str//% 1
;//1 2
string00 
suggestedNamesPrefs00 &
=00' (
EditorPrefs00) 4
.004 5
	GetString005 >
(00> ?
suggestedNamesKey00? P
)00P Q
;00Q R
if22 
(22 
string22 
.22 
IsNullOrEmpty22 $
(22$ %
suggestedNamesPrefs22% 8
)228 9
)229 :
EditorPrefs33 
.33 
	SetString33 %
(33% &
suggestedNamesKey33& 7
,337 8
maskTex339 @
+33A B
$str33C F
+33G H
	normalMap33I R
)33R S
;33S T
else44 
{55 
if66 
(66 
!66 
suggestedNamesPrefs66 (
.66( )
Contains66) 1
(661 2
maskTex662 9
)669 :
)66: ;
suggestedNamesPrefs77 '
+=77( *
(77+ ,
$str77, /
+770 1
maskTex772 9
)779 :
;77: ;
if99 
(99 
!99 
suggestedNamesPrefs99 (
.99( )
Contains99) 1
(991 2
	normalMap992 ;
)99; <
)99< =
suggestedNamesPrefs:: '
+=::( *
(::+ ,
$str::, /
+::0 1
	normalMap::2 ;
)::; <
;::< =
EditorPrefs<< 
.<< 
	SetString<< %
(<<% &
suggestedNamesKey<<& 7
,<<7 8
suggestedNamesPrefs<<9 L
)<<L M
;<<M N
}== 
ResourceReloader?? 
.?? 
TryReloadAllNullIn?? /
(??/ 0
this??0 4
,??4 5(
UniversalRenderPipelineAsset??6 R
.??R S
packagePath??S ^
)??^ _
;??_ `
ResourceReloader@@ 
.@@ 
TryReloadAllNullIn@@ /
(@@/ 0
m_PostProcessData@@0 A
,@@A B(
UniversalRenderPipelineAsset@@C _
.@@_ `
packagePath@@` k
)@@k l
;@@l m
}AA 	
privateCC 
voidCC 
AwakeCC 
(CC 
)CC 
{DD 	
ifEE 
(EE 
m_LightBlendStylesEE "
!=EE# %
nullEE& *
)EE* +
returnFF 
;FF 
m_LightBlendStylesHH 
=HH  
newHH! $
Light2DBlendStyleHH% 6
[HH6 7
$numHH7 8
]HH8 9
;HH9 :
forJJ 
(JJ 
intJJ 
iJJ 
=JJ 
$numJJ 
;JJ 
iJJ 
<JJ 
m_LightBlendStylesJJ  2
.JJ2 3
LengthJJ3 9
;JJ9 :
++JJ; =
iJJ= >
)JJ> ?
{KK 
m_LightBlendStylesLL "
[LL" #
iLL# $
]LL$ %
.LL% &
nameLL& *
=LL+ ,
$strLL- ;
+LL< =
iLL> ?
;LL? @
m_LightBlendStylesMM "
[MM" #
iMM# $
]MM$ %
.MM% &
	blendModeMM& /
=MM0 1
Light2DBlendStyleMM2 C
.MMC D
	BlendModeMMD M
.MMM N
MultiplyMMN V
;MMV W
m_LightBlendStylesNN "
[NN" #
iNN# $
]NN$ %
.NN% &
renderTextureScaleNN& 8
=NN9 :
$numNN; ?
;NN? @
}OO 
}PP 	
}RR 
}SS °
ûD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Data\XRSystemData.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[		 
Serializable		 
]		 
public

 

class

 
XRSystemData

 
:

 
ScriptableObject

  0
{ 
[ 	
System	 
. 
Diagnostics 
. 
CodeAnalysis (
.( )
SuppressMessage) 8
(8 9
$str9 P
,P Q
$strR Z
)Z [
][ \
internal 
class #
CreateXRSystemDataAsset .
:/ 0
EndNameEditAction1 B
{ 	
public 
override 
void  
Action! '
(' (
int( +

instanceId, 6
,6 7
string8 >
pathName? G
,G H
stringI O
resourceFileP \
)\ ]
{ 
var 
instance 
= 
CreateInstance -
<- .
XRSystemData. :
>: ;
(; <
)< =
;= >
AssetDatabase 
. 
CreateAsset )
() *
instance* 2
,2 3
pathName4 <
)< =
;= >
ResourceReloader  
.  !
ReloadAllNullIn! 0
(0 1
instance1 9
,9 :(
UniversalRenderPipelineAsset; W
.W X
packagePathX c
)c d
;d e
	Selection 
. 
activeObject &
=' (
instance) 1
;1 2
} 
} 	
[ 	
MenuItem	 
( 
$str T
,T U
priorityV ^
=_ `
	CoreUtilsa j
.j k%
assetCreateMenuPriority3	k É
)
É Ñ
]
Ñ Ö
static 
void 
CreateXRSystemData &
(& '
)' (
{ 	
ProjectWindowUtil 
. 1
%StartNameEditingIfProjectWindowExists C
(C D
$numD E
,E F
CreateInstanceG U
<U V#
CreateXRSystemDataAssetV m
>m n
(n o
)o p
,p q
$str	r å
,
å ç
null
é í
,
í ì
null
î ò
)
ò ô
;
ô ö
} 	
[   	
Serializable  	 
,   
ReloadGroup   "
]  " #
public!! 
sealed!! 
class!! 
ShaderResources!! +
{"" 	
[## 
Reload## 
(## 
$str## 7
)##7 8
]##8 9
public$$ 
Shader$$ 
xrOcclusionMeshPS$$ +
;$$+ ,
[&& 
Reload&& 
(&& 
$str&& 4
)&&4 5
]&&5 6
public'' 
Shader'' 
xrMirrorViewPS'' (
;''( )
}(( 	
public** 
ShaderResources** 
shaders** &
;**& '
}++ 
},, µ
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\SampleCount.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
enum5 9
SampleCount: E
{ 
One 
= 
$num 
, 
Two 
= 
$num 
, 
Four		 
=		 
$num		 
,		 
}

 
} êo
üD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\GBufferPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
internal		 
class		 
GBufferPass		 
:		   
ScriptableRenderPass		! 5
{

 
static 
ShaderTagId 
s_ShaderTagLit )
=* +
new, /
ShaderTagId0 ;
(; <
$str< A
)A B
;B C
static 
ShaderTagId  
s_ShaderTagSimpleLit /
=0 1
new2 5
ShaderTagId6 A
(A B
$strB M
)M N
;N O
static 
ShaderTagId 
s_ShaderTagUnlit +
=, -
new. 1
ShaderTagId2 =
(= >
$str> E
)E F
;F G
static 
ShaderTagId '
s_ShaderTagUniversalGBuffer 6
=7 8
new9 <
ShaderTagId= H
(H I
$strI [
)[ \
;\ ]
static 
ShaderTagId ,
 s_ShaderTagUniversalMaterialType ;
=< =
new> A
ShaderTagIdB M
(M N
$strN e
)e f
;f g
ProfilingSampler 
m_ProfilingSampler +
=, -
new. 1
ProfilingSampler2 B
(B C
$strC S
)S T
;T U
DeferredLights 
m_DeferredLights '
;' (
ShaderTagId 
[ 
] 
m_ShaderTagValues '
;' (
RenderStateBlock 
[ 
] 
m_RenderStateBlocks .
;. /
FilteringSettings 
m_FilteringSettings -
;- .
RenderStateBlock 
m_RenderStateBlock +
;+ ,
public 
GBufferPass 
( 
RenderPassEvent *
evt+ .
,. /
RenderQueueRange0 @
renderQueueRangeA Q
,Q R
	LayerMaskS \
	layerMask] f
,f g
StencilStateh t
stencilState	u Å
,
Å Ç
int
É Ü
stencilReference
á ó
,
ó ò
DeferredLights
ô ß
deferredLights
® ∂
)
∂ ∑
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @
GBufferPass@ K
)K L
)L M
;M N
base 
. 
renderPassEvent  
=! "
evt# &
;& '
m_DeferredLights   
=   
deferredLights   -
;  - .
m_FilteringSettings!! 
=!!  !
new!!" %
FilteringSettings!!& 7
(!!7 8
renderQueueRange!!8 H
,!!H I
	layerMask!!J S
)!!S T
;!!T U
m_RenderStateBlock"" 
=""  
new""! $
RenderStateBlock""% 5
(""5 6
RenderStateMask""6 E
.""E F
Nothing""F M
)""M N
;""N O
m_RenderStateBlock$$ 
.$$ 
stencilState$$ +
=$$, -
stencilState$$. :
;$$: ;
m_RenderStateBlock%% 
.%% 
stencilReference%% /
=%%0 1
stencilReference%%2 B
;%%B C
m_RenderStateBlock&& 
.&& 
mask&& #
=&&$ %
RenderStateMask&&& 5
.&&5 6
Stencil&&6 =
;&&= >
m_ShaderTagValues(( 
=(( 
new((  #
ShaderTagId(($ /
[((/ 0
$num((0 1
]((1 2
;((2 3
m_ShaderTagValues)) 
[)) 
$num)) 
]))  
=))! "
s_ShaderTagLit))# 1
;))1 2
m_ShaderTagValues** 
[** 
$num** 
]**  
=**! " 
s_ShaderTagSimpleLit**# 7
;**7 8
m_ShaderTagValues++ 
[++ 
$num++ 
]++  
=++! "
s_ShaderTagUnlit++# 3
;++3 4
m_ShaderTagValues,, 
[,, 
$num,, 
],,  
=,,! "
new,,# &
ShaderTagId,,' 2
(,,2 3
),,3 4
;,,4 5
m_RenderStateBlocks.. 
=..  !
new.." %
RenderStateBlock..& 6
[..6 7
$num..7 8
]..8 9
;..9 :
m_RenderStateBlocks// 
[//  
$num//  !
]//! "
=//# $
DeferredLights//% 3
.//3 4
OverwriteStencil//4 D
(//D E
m_RenderStateBlock//E W
,//W X
(//Y Z
int//Z ]
)//] ^
StencilUsage//^ j
.//j k
MaterialMask//k w
,//w x
(//y z
int//z }
)//} ~
StencilUsage	//~ ä
.
//ä ã
MaterialLit
//ã ñ
)
//ñ ó
;
//ó ò
m_RenderStateBlocks00 
[00  
$num00  !
]00! "
=00# $
DeferredLights00% 3
.003 4
OverwriteStencil004 D
(00D E
m_RenderStateBlock00E W
,00W X
(00Y Z
int00Z ]
)00] ^
StencilUsage00^ j
.00j k
MaterialMask00k w
,00w x
(00y z
int00z }
)00} ~
StencilUsage	00~ ä
.
00ä ã
MaterialSimpleLit
00ã ú
)
00ú ù
;
00ù û
m_RenderStateBlocks11 
[11  
$num11  !
]11! "
=11# $
DeferredLights11% 3
.113 4
OverwriteStencil114 D
(11D E
m_RenderStateBlock11E W
,11W X
(11Y Z
int11Z ]
)11] ^
StencilUsage11^ j
.11j k
MaterialMask11k w
,11w x
(11y z
int11z }
)11} ~
StencilUsage	11~ ä
.
11ä ã
MaterialUnlit
11ã ò
)
11ò ô
;
11ô ö
m_RenderStateBlocks22 
[22  
$num22  !
]22! "
=22# $
m_RenderStateBlocks22% 8
[228 9
$num229 :
]22: ;
;22; <
}33 	
public55 
override55 
void55 
	Configure55 &
(55& '
CommandBuffer55' 4
cmd555 8
,558 9#
RenderTextureDescriptor55: Q#
cameraTextureDescriptor55R i
)55i j
{66 	
RenderTargetHandle77 
[77 
]77  
gbufferAttachments77! 3
=774 5
m_DeferredLights776 F
.77F G
GbufferAttachments77G Y
;77Y Z
for:: 
(:: 
int:: 
i:: 
=:: 
$num:: 
;:: 
i:: 
<:: 
gbufferAttachments::  2
.::2 3
Length::3 9
;::9 :
++::; =
i::= >
)::> ?
{;; 
if== 
(== 
i== 
!=== 
m_DeferredLights== )
.==) * 
GBufferLightingIndex==* >
)==> ?
{>> #
RenderTextureDescriptor?? +
gbufferSlice??, 8
=??9 :#
cameraTextureDescriptor??; R
;??R S
gbufferSlice@@  
.@@  !
depthBufferBits@@! 0
=@@1 2
$num@@3 4
;@@4 5
gbufferSliceAA  
.AA  !
stencilFormatAA! .
=AA/ 0
GraphicsFormatAA1 ?
.AA? @
NoneAA@ D
;AAD E
gbufferSliceBB  
.BB  !
graphicsFormatBB! /
=BB0 1
m_DeferredLightsBB2 B
.BBB C
GetGBufferFormatBBC S
(BBS T
iBBT U
)BBU V
;BBV W
cmdCC 
.CC 
GetTemporaryRTCC &
(CC& '
m_DeferredLightsCC' 7
.CC7 8
GbufferAttachmentsCC8 J
[CCJ K
iCCK L
]CCL M
.CCM N
idCCN P
,CCP Q
gbufferSliceCCR ^
)CC^ _
;CC_ `
}DD 
}EE 
ConfigureTargetGG 
(GG 
m_DeferredLightsGG ,
.GG, -(
GbufferAttachmentIdentifiersGG- I
,GGI J
m_DeferredLightsGGK [
.GG[ \%
DepthAttachmentIdentifierGG\ u
)GGu v
;GGv w
ConfigureClearJJ 
(JJ 
	ClearFlagJJ $
.JJ$ %
NoneJJ% )
,JJ) *
ColorJJ+ 0
.JJ0 1
blackJJ1 6
)JJ6 7
;JJ7 8
}KK 	
publicMM 
overrideMM 
voidMM 
ExecuteMM $
(MM$ %#
ScriptableRenderContextMM% <
contextMM= D
,MMD E
refMMF I
RenderingDataMMJ W
renderingDataMMX e
)MMe f
{NN 	
CommandBufferOO 
gbufferCommandsOO )
=OO* +
CommandBufferPoolOO, =
.OO= >
GetOO> A
(OOA B
)OOB C
;OOC D
usingPP 
(PP 
newPP 
ProfilingScopePP %
(PP% &
gbufferCommandsPP& 5
,PP5 6
m_ProfilingSamplerPP7 I
)PPI J
)PPJ K
{QQ 
ifUU 
(UU 
m_DeferredLightsUU $
.UU$ %
	IsOverlayUU% .
)UU. /
m_DeferredLightsVV $
.VV$ %
ClearStencilPartialVV% 8
(VV8 9
gbufferCommandsVV9 H
)VVH I
;VVI J
contextXX 
.XX  
ExecuteCommandBufferXX ,
(XX, -
gbufferCommandsXX- <
)XX< =
;XX= >
gbufferCommandsYY 
.YY  
ClearYY  %
(YY% &
)YY& '
;YY' (
ref[[ 

CameraData[[ 

cameraData[[ )
=[[* +
ref[[, /
renderingData[[0 =
.[[= >

cameraData[[> H
;[[H I
Camera\\ 
camera\\ 
=\\ 

cameraData\\  *
.\\* +
camera\\+ 1
;\\1 2
ShaderTagId]] 
lightModeTag]] (
=]]) *'
s_ShaderTagUniversalGBuffer]]+ F
;]]F G
DrawingSettings^^ 
drawingSettings^^  /
=^^0 1!
CreateDrawingSettings^^2 G
(^^G H
lightModeTag^^H T
,^^T U
ref^^V Y
renderingData^^Z g
,^^g h
renderingData^^i v
.^^v w

cameraData	^^w Å
.
^^Å Ç$
defaultOpaqueSortFlags
^^Ç ò
)
^^ò ô
;
^^ô ö
ShaderTagId__ $
universalMaterialTypeTag__ 4
=__5 6,
 s_ShaderTagUniversalMaterialType__7 W
;__W X
NativeArrayaa 
<aa 
ShaderTagIdaa '
>aa' (
	tagValuesaa) 2
=aa3 4
newaa5 8
NativeArrayaa9 D
<aaD E
ShaderTagIdaaE P
>aaP Q
(aaQ R
m_ShaderTagValuesaaR c
,aac d
	Allocatoraae n
.aan o
Tempaao s
)aas t
;aat u
NativeArraybb 
<bb 
RenderStateBlockbb ,
>bb, -
stateBlocksbb. 9
=bb: ;
newbb< ?
NativeArraybb@ K
<bbK L
RenderStateBlockbbL \
>bb\ ]
(bb] ^
m_RenderStateBlocksbb^ q
,bbq r
	Allocatorbbs |
.bb| }
Temp	bb} Å
)
bbÅ Ç
;
bbÇ É
contextcc 
.cc 
DrawRendererscc %
(cc% &
renderingDatacc& 3
.cc3 4
cullResultscc4 ?
,cc? @
refccA D
drawingSettingsccE T
,ccT U
refccV Y
m_FilteringSettingsccZ m
,ccm n%
universalMaterialTypeTag	cco á
,
ccá à
false
ccâ é
,
ccé è
	tagValues
ccê ô
,
ccô ö
stateBlocks
ccõ ¶
)
cc¶ ß
;
ccß ®
	tagValuesdd 
.dd 
Disposedd !
(dd! "
)dd" #
;dd# $
stateBlocksee 
.ee 
Disposeee #
(ee# $
)ee$ %
;ee% &
RenderingUtilshh 
.hh "
RenderObjectsWithErrorhh 5
(hh5 6
contexthh6 =
,hh= >
refhh? B
renderingDatahhC P
.hhP Q
cullResultshhQ \
,hh\ ]
camerahh^ d
,hhd e
m_FilteringSettingshhf y
,hhy z
SortingCriteria	hh{ ä
.
hhä ã
None
hhã è
)
hhè ê
;
hhê ë
}ii 
contextjj 
.jj  
ExecuteCommandBufferjj (
(jj( )
gbufferCommandsjj) 8
)jj8 9
;jj9 :
CommandBufferPoolkk 
.kk 
Releasekk %
(kk% &
gbufferCommandskk& 5
)kk5 6
;kk6 7
}ll 	
publicnn 
overridenn 
voidnn 
OnCameraCleanupnn ,
(nn, -
CommandBuffernn- :
cmdnn; >
)nn> ?
{oo 	
RenderTargetHandlepp 
[pp 
]pp  
gbufferAttachmentspp! 3
=pp4 5
m_DeferredLightspp6 F
.ppF G
GbufferAttachmentsppG Y
;ppY Z
forrr 
(rr 
intrr 
irr 
=rr 
$numrr 
;rr 
irr 
<rr 
gbufferAttachmentsrr  2
.rr2 3
Lengthrr3 9
;rr9 :
++rr; =
irr= >
)rr> ?
ifss 
(ss 
iss 
!=ss 
m_DeferredLightsss )
.ss) * 
GBufferLightingIndexss* >
)ss> ?
cmdtt 
.tt 
ReleaseTemporaryRTtt *
(tt* +
gbufferAttachmentstt+ =
[tt= >
itt> ?
]tt? @
.tt@ A
idttA C
)ttC D
;ttD E
}uu 	
}vv 
}ww Îl
°D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\CopyDepthPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
public 

class 
CopyDepthPass 
:   
ScriptableRenderPass! 5
{ 
private 
RenderTargetHandle "
source# )
{* +
get, /
;/ 0
set1 4
;4 5
}6 7
private 
RenderTargetHandle "
destination# .
{/ 0
get1 4
;4 5
set6 9
;9 :
}; <
internal 
bool 

AllocateRT  
{" #
get$ '
;' (
set) ,
;, -
}. /
Material 
m_CopyDepthMaterial $
;$ %
public 
CopyDepthPass 
( 
RenderPassEvent ,
evt- 0
,0 1
Material2 :
copyDepthMaterial; L
)L M
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @
CopyDepthPass@ M
)M N
)N O
;O P

AllocateRT 
= 
true 
; 
m_CopyDepthMaterial 
=  !
copyDepthMaterial" 3
;3 4
renderPassEvent 
= 
evt !
;! "
} 	
public!! 
void!! 
Setup!! 
(!! 
RenderTargetHandle!! ,
source!!- 3
,!!3 4
RenderTargetHandle!!5 G
destination!!H S
)!!S T
{"" 	
this## 
.## 
source## 
=## 
source##  
;##  !
this$$ 
.$$ 
destination$$ 
=$$ 
destination$$ *
;$$* +
this%% 
.%% 

AllocateRT%% 
=%% 

AllocateRT%% (
&&%%) +
!%%, -
destination%%- 8
.%%8 9%
HasInternalRenderTargetId%%9 R
(%%R S
)%%S T
;%%T U
}&& 	
public(( 
override(( 
void(( 
OnCameraSetup(( *
(((* +
CommandBuffer((+ 8
cmd((9 <
,((< =
ref((> A
RenderingData((B O
renderingData((P ]
)((] ^
{)) 	
var** 

descriptor** 
=** 
renderingData** *
.*** +

cameraData**+ 5
.**5 6"
cameraTargetDescriptor**6 L
;**L M

descriptor++ 
.++ 
colorFormat++ "
=++# $
RenderTextureFormat++% 8
.++8 9
Depth++9 >
;++> ?

descriptor,, 
.,, 
depthBufferBits,, &
=,,' (
$num,,) +
;,,+ ,

descriptor-- 
.-- 
msaaSamples-- "
=--# $
$num--% &
;--& '
if.. 
(.. 
this.. 
... 

AllocateRT.. 
)..  
cmd// 
.// 
GetTemporaryRT// "
(//" #
destination//# .
.//. /
id/// 1
,//1 2

descriptor//3 =
,//= >

FilterMode//? I
.//I J
Point//J O
)//O P
;//P Q
ConfigureTarget22 
(22 
new22 "
RenderTargetIdentifier22  6
(226 7
destination227 B
.22B C

Identifier22C M
(22M N
)22N O
,22O P
$num22Q R
,22R S
CubemapFace22T _
.22_ `
Unknown22` g
,22g h
-22i j
$num22j k
)22k l
)22l m
;22m n
ConfigureClear33 
(33 
	ClearFlag33 $
.33$ %
None33% )
,33) *
Color33+ 0
.330 1
black331 6
)336 7
;337 8
}44 	
public77 
override77 
void77 
Execute77 $
(77$ %#
ScriptableRenderContext77% <
context77= D
,77D E
ref77F I
RenderingData77J W
renderingData77X e
)77e f
{88 	
if99 
(99 
m_CopyDepthMaterial99 #
==99$ &
null99' +
)99+ ,
{:: 
Debug;; 
.;; 
LogErrorFormat;; $
(;;$ %
$str	;;% å
,
;;å ç!
m_CopyDepthMaterial
;;é °
,
;;° ¢
GetType
;;£ ™
(
;;™ ´
)
;;´ ¨
.
;;¨ ≠
Name
;;≠ ±
)
;;± ≤
;
;;≤ ≥
return<< 
;<< 
}== 
CommandBuffer>> 
cmd>> 
=>> 
CommandBufferPool>>  1
.>>1 2
Get>>2 5
(>>5 6
)>>6 7
;>>7 8
using?? 
(?? 
new?? 
ProfilingScope?? %
(??% &
cmd??& )
,??) *
ProfilingSampler??+ ;
.??; <
Get??< ?
(??? @
URPProfileId??@ L
.??L M
	CopyDepth??M V
)??V W
)??W X
)??X Y
{@@ #
RenderTextureDescriptorAA '

descriptorAA( 2
=AA3 4
renderingDataAA5 B
.AAB C

cameraDataAAC M
.AAM N"
cameraTargetDescriptorAAN d
;AAd e
intBB 
cameraSamplesBB !
=BB" #

descriptorBB$ .
.BB. /
msaaSamplesBB/ :
;BB: ;

CameraDataDD 

cameraDataDD %
=DD& '
renderingDataDD( 5
.DD5 6

cameraDataDD6 @
;DD@ A
switchFF 
(FF 
cameraSamplesFF %
)FF% &
{GG 
caseHH 
$numHH 
:HH 
cmdII 
.II  
DisableShaderKeywordII 0
(II0 1 
ShaderKeywordStringsII1 E
.IIE F

DepthMsaa2IIF P
)IIP Q
;IIQ R
cmdJJ 
.JJ  
DisableShaderKeywordJJ 0
(JJ0 1 
ShaderKeywordStringsJJ1 E
.JJE F

DepthMsaa4JJF P
)JJP Q
;JJQ R
cmdKK 
.KK 
EnableShaderKeywordKK /
(KK/ 0 
ShaderKeywordStringsKK0 D
.KKD E

DepthMsaa8KKE O
)KKO P
;KKP Q
breakLL 
;LL 
caseNN 
$numNN 
:NN 
cmdOO 
.OO  
DisableShaderKeywordOO 0
(OO0 1 
ShaderKeywordStringsOO1 E
.OOE F

DepthMsaa2OOF P
)OOP Q
;OOQ R
cmdPP 
.PP 
EnableShaderKeywordPP /
(PP/ 0 
ShaderKeywordStringsPP0 D
.PPD E

DepthMsaa4PPE O
)PPO P
;PPP Q
cmdQQ 
.QQ  
DisableShaderKeywordQQ 0
(QQ0 1 
ShaderKeywordStringsQQ1 E
.QQE F

DepthMsaa8QQF P
)QQP Q
;QQQ R
breakRR 
;RR 
caseTT 
$numTT 
:TT 
cmdUU 
.UU 
EnableShaderKeywordUU /
(UU/ 0 
ShaderKeywordStringsUU0 D
.UUD E

DepthMsaa2UUE O
)UUO P
;UUP Q
cmdVV 
.VV  
DisableShaderKeywordVV 0
(VV0 1 
ShaderKeywordStringsVV1 E
.VVE F

DepthMsaa4VVF P
)VVP Q
;VVQ R
cmdWW 
.WW  
DisableShaderKeywordWW 0
(WW0 1 
ShaderKeywordStringsWW1 E
.WWE F

DepthMsaa8WWF P
)WWP Q
;WWQ R
breakXX 
;XX 
default[[ 
:[[ 
cmd\\ 
.\\  
DisableShaderKeyword\\ 0
(\\0 1 
ShaderKeywordStrings\\1 E
.\\E F

DepthMsaa2\\F P
)\\P Q
;\\Q R
cmd]] 
.]]  
DisableShaderKeyword]] 0
(]]0 1 
ShaderKeywordStrings]]1 E
.]]E F

DepthMsaa4]]F P
)]]P Q
;]]Q R
cmd^^ 
.^^  
DisableShaderKeyword^^ 0
(^^0 1 
ShaderKeywordStrings^^1 E
.^^E F

DepthMsaa8^^F P
)^^P Q
;^^Q R
break__ 
;__ 
}`` 
cmdbb 
.bb 
SetGlobalTexturebb $
(bb$ %
$strbb% =
,bb= >
sourcebb? E
.bbE F

IdentifierbbF P
(bbP Q
)bbQ R
)bbR S
;bbS T
ifgg 
(gg 
renderingDatagg !
.gg! "

cameraDatagg" ,
.gg, -
xrgg- /
.gg/ 0
enabledgg0 7
)gg7 8
{hh 
booloo &
isRenderToBackBufferTargetoo 3
=oo4 5
destinationoo6 A
.ooA B

IdentifierooB L
(ooL M
)ooM N
==ooO Q

cameraDataooR \
.oo\ ]
xroo] _
.oo_ `
renderTargetoo` l
&&oom o
!oop q

cameraDataooq {
.oo{ |
xroo| ~
.oo~ (
renderTargetIsRenderTexture	oo ö
;
ooö õ
boolpp 
yflippp 
=pp  &
isRenderToBackBufferTargetpp! ;
&&pp< >

SystemInfopp? I
.ppI J!
graphicsUVStartsAtTopppJ _
;pp_ `
floatqq 
flipSignqq "
=qq# $
(qq% &
yflipqq& +
)qq+ ,
?qq- .
-qq/ 0
$numqq0 4
:qq5 6
$numqq7 ;
;qq; <
Vector4rr 
scaleBiasRtrr '
=rr( )
(rr* +
flipSignrr+ 3
<rr4 5
$numrr6 :
)rr: ;
?ss 
newss 
Vector4ss %
(ss% &
flipSignss& .
,ss. /
$numss0 4
,ss4 5
-ss6 7
$numss7 ;
,ss; <
$numss= A
)ssA B
:tt 
newtt 
Vector4tt %
(tt% &
flipSigntt& .
,tt. /
$numtt0 4
,tt4 5
$numtt6 :
,tt: ;
$numtt< @
)tt@ A
;ttA B
cmduu 
.uu 
SetGlobalVectoruu '
(uu' (
ShaderPropertyIduu( 8
.uu8 9
scaleBiasRtuu9 D
,uuD E
scaleBiasRtuuF Q
)uuQ R
;uuR S
cmdww 
.ww 
DrawProceduralww &
(ww& '
	Matrix4x4ww' 0
.ww0 1
identityww1 9
,ww9 :
m_CopyDepthMaterialww; N
,wwN O
$numwwP Q
,wwQ R
MeshTopologywwS _
.ww_ `
Quadsww` e
,wwe f
$numwwg h
)wwh i
;wwi j
}xx 
elseyy 
{{{ 
float
ÑÑ 
flipSign
ÑÑ "
=
ÑÑ# $
(
ÑÑ% &

cameraData
ÑÑ& 0
.
ÑÑ0 1-
IsCameraProjectionMatrixFlipped
ÑÑ1 P
(
ÑÑP Q
)
ÑÑQ R
)
ÑÑR S
?
ÑÑT U
-
ÑÑV W
$num
ÑÑW [
:
ÑÑ\ ]
$num
ÑÑ^ b
;
ÑÑb c
Vector4
ÖÖ 
scaleBiasRt
ÖÖ '
=
ÖÖ( )
(
ÖÖ* +
flipSign
ÖÖ+ 3
<
ÖÖ4 5
$num
ÖÖ6 :
)
ÖÖ: ;
?
ÜÜ 
new
ÜÜ 
Vector4
ÜÜ %
(
ÜÜ% &
flipSign
ÜÜ& .
,
ÜÜ. /
$num
ÜÜ0 4
,
ÜÜ4 5
-
ÜÜ6 7
$num
ÜÜ7 ;
,
ÜÜ; <
$num
ÜÜ= A
)
ÜÜA B
:
áá 
new
áá 
Vector4
áá %
(
áá% &
flipSign
áá& .
,
áá. /
$num
áá0 4
,
áá4 5
$num
áá6 :
,
áá: ;
$num
áá< @
)
áá@ A
;
ááA B
cmd
àà 
.
àà 
SetGlobalVector
àà '
(
àà' (
ShaderPropertyId
àà( 8
.
àà8 9
scaleBiasRt
àà9 D
,
ààD E
scaleBiasRt
ààF Q
)
ààQ R
;
ààR S
cmd
ää 
.
ää 
DrawMesh
ää  
(
ää  !
RenderingUtils
ää! /
.
ää/ 0
fullscreenMesh
ää0 >
,
ää> ?
	Matrix4x4
ää@ I
.
ääI J
identity
ääJ R
,
ääR S!
m_CopyDepthMaterial
ääT g
)
ääg h
;
ääh i
}
ãã 
}
åå 
context
éé 
.
éé "
ExecuteCommandBuffer
éé (
(
éé( )
cmd
éé) ,
)
éé, -
;
éé- .
CommandBufferPool
èè 
.
èè 
Release
èè %
(
èè% &
cmd
èè& )
)
èè) *
;
èè* +
}
êê 	
public
ìì 
override
ìì 
void
ìì 
OnCameraCleanup
ìì ,
(
ìì, -
CommandBuffer
ìì- :
cmd
ìì; >
)
ìì> ?
{
îî 	
if
ïï 
(
ïï 
cmd
ïï 
==
ïï 
null
ïï 
)
ïï 
throw
ññ 
new
ññ #
ArgumentNullException
ññ /
(
ññ/ 0
$str
ññ0 5
)
ññ5 6
;
ññ6 7
if
òò 
(
òò 
this
òò 
.
òò 

AllocateRT
òò 
)
òò  
cmd
ôô 
.
ôô  
ReleaseTemporaryRT
ôô &
(
ôô& '
destination
ôô' 2
.
ôô2 3
id
ôô3 5
)
ôô5 6
;
ôô6 7
destination
öö 
=
öö  
RenderTargetHandle
öö ,
.
öö, -
CameraTarget
öö- 9
;
öö9 :
}
õõ 	
}
úú 
}ùù œ
°D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Data\RenderStateData.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
System 
. 
Serializable 
] 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
class5 :
StencilStateData; K
{ 
public 
bool  
overrideStencilState (
=) *
false+ 0
;0 1
public		 
int		 
stencilReference		 #
=		$ %
$num		& '
;		' (
public

 
CompareFunction

 "
stencilCompareFunction

 5
=

6 7
CompareFunction

8 G
.

G H
Always

H N
;

N O
public 
	StencilOp 
passOperation &
=' (
	StencilOp) 2
.2 3
Keep3 7
;7 8
public 
	StencilOp 
failOperation &
=' (
	StencilOp) 2
.2 3
Keep3 7
;7 8
public 
	StencilOp 
zFailOperation '
=( )
	StencilOp* 3
.3 4
Keep4 8
;8 9
} 
} Îr
£D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\ScriptableRendererData.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public 

abstract 
class "
ScriptableRendererData 0
:1 2
ScriptableObject3 C
{ 
internal 
bool 
isInvalidated #
{$ %
get& )
;) *
set+ .
;. /
}0 1
	protected 
abstract 
ScriptableRenderer -
Create. 4
(4 5
)5 6
;6 7
[ 	
SerializeField	 
] 
internal !
List" &
<& '%
ScriptableRendererFeature' @
>@ A
m_RendererFeaturesB T
=U V
newW Z
List[ _
<_ `%
ScriptableRendererFeature` y
>y z
(z {
$num{ }
)} ~
;~ 
[ 	
SerializeField	 
] 
internal !
List" &
<& '
long' +
>+ , 
m_RendererFeatureMap- A
=B C
newD G
ListH L
<L M
longM Q
>Q R
(R S
$numS U
)U V
;V W
public"" 
List"" 
<"" %
ScriptableRendererFeature"" -
>""- .
rendererFeatures""/ ?
{## 	
get$$ 
=>$$ 
m_RendererFeatures$$ %
;$$% &
}%% 	
public++ 
new++ 
void++ 
SetDirty++  
(++  !
)++! "
{,, 	
isInvalidated-- 
=-- 
true--  
;--  !
}.. 	
internal00 
ScriptableRenderer00 #"
InternalCreateRenderer00$ :
(00: ;
)00; <
{11 	
isInvalidated22 
=22 
false22 !
;22! "
return33 
Create33 
(33 
)33 
;33 
}44 	
	protected66 
virtual66 
void66 

OnValidate66 )
(66) *
)66* +
{77 	
SetDirty88 
(88 
)88 
;88 
if:: 
(:: 
m_RendererFeatures:: "
.::" #
Contains::# +
(::+ ,
null::, 0
)::0 1
)::1 2$
ValidateRendererFeatures;; (
(;;( )
);;) *
;;;* +
}== 	
	protected?? 
virtual?? 
void?? 
OnEnable?? '
(??' (
)??( )
{@@ 	
SetDirtyAA 
(AA 
)AA 
;AA 
}BB 	
internalEE 
virtualEE 
MaterialEE !
GetDefaultMaterialEE" 4
(EE4 5
DefaultMaterialTypeEE5 H
materialTypeEEI U
)EEU V
{FF 	
returnGG 
nullGG 
;GG 
}HH 	
internalJJ 
virtualJJ 
ShaderJJ 
GetDefaultShaderJJ  0
(JJ0 1
)JJ1 2
{KK 	
returnLL 
nullLL 
;LL 
}MM 	
internalOO 
boolOO $
ValidateRendererFeaturesOO .
(OO. /
)OO/ 0
{PP 	
varRR 
	subassetsRR 
=RR 
AssetDatabaseRR )
.RR) *
LoadAllAssetsAtPathRR* =
(RR= >
AssetDatabaseRR> K
.RRK L
GetAssetPathRRL X
(RRX Y
thisRRY ]
)RR] ^
)RR^ _
;RR_ `
varSS 
	linkedIdsSS 
=SS 
newSS 
ListSS  $
<SS$ %
longSS% )
>SS) *
(SS* +
)SS+ ,
;SS, -
varTT 
loadedAssetsTT 
=TT 
newTT "

DictionaryTT# -
<TT- .
longTT. 2
,TT2 3
objectTT4 :
>TT: ;
(TT; <
)TT< =
;TT= >
varUU 
mapValidUU 
=UU  
m_RendererFeatureMapUU /
!=UU0 2
nullUU3 7
&&UU8 : 
m_RendererFeatureMapUU; O
?UUO P
.UUP Q
CountUUQ V
==UUW Y
m_RendererFeaturesUUZ l
?UUl m
.UUm n
CountUUn s
;UUs t
varVV 
debugOutputVV 
=VV 
$"VV  
{VV  !
nameVV! %
}VV% &!
\nValid Sub-assets:\nVV& ;
"VV; <
;VV< =
foreachYY 
(YY 
varYY 
assetYY 
inYY !
	subassetsYY" +
)YY+ ,
{ZZ 
if[[ 
([[ 
asset[[ 
==[[ 
null[[ !
||[[" $
asset[[% *
.[[* +
GetType[[+ 2
([[2 3
)[[3 4
.[[4 5
BaseType[[5 =
!=[[> @
typeof[[A G
([[G H%
ScriptableRendererFeature[[H a
)[[a b
)[[b c
continue[[d l
;[[l m
AssetDatabase\\ 
.\\ ,
 TryGetGUIDAndLocalFileIdentifier\\ >
(\\> ?
asset\\? D
,\\D E
out\\F I
var\\J M
guid\\N R
,\\R S
out\\T W
long\\X \
localId\\] d
)\\d e
;\\e f
loadedAssets]] 
.]] 
Add]]  
(]]  !
localId]]! (
,]]( )
asset]]* /
)]]/ 0
;]]0 1
debugOutput^^ 
+=^^ 
$"^^ !
-^^! "
{^^" #
asset^^# (
.^^( )
name^^) -
}^^- .
\n--localId=^^. :
{^^: ;
localId^^; B
}^^B C
\n^^C E
"^^E F
;^^F G
}__ 
forbb 
(bb 
varbb 
ibb 
=bb 
$numbb 
;bb 
ibb 
<bb 
m_RendererFeaturesbb  2
?bb2 3
.bb3 4
Countbb4 9
;bb9 :
ibb; <
++bb< >
)bb> ?
{cc 
ifdd 
(dd 
!dd 
m_RendererFeaturesdd '
[dd' (
idd( )
]dd) *
)dd* +
continuedd, 4
;dd4 5
ifee 
(ee 
AssetDatabaseee !
.ee! ",
 TryGetGUIDAndLocalFileIdentifieree" B
(eeB C
m_RendererFeatureseeC U
[eeU V
ieeV W
]eeW X
,eeX Y
outeeZ ]
varee^ a
guideeb f
,eef g
outeeh k
longeel p
localIdeeq x
)eex y
)eey z
{ff 
	linkedIdsgg 
.gg 
Addgg !
(gg! "
localIdgg" )
)gg) *
;gg* +
}hh 
}ii 
varkk 
mapDebugkk 
=kk 
mapValidkk #
?kk$ %
$strkk& /
:kk0 1
$strkk2 W
;kkW X
debugOutputll 
+=ll 
$"ll  
Feature List Status(ll 1
{ll1 2
mapDebugll2 :
}ll: ;
):\nll; ?
"ll? @
;ll@ A
foroo 
(oo 
varoo 
ioo 
=oo 
$numoo 
;oo 
ioo 
<oo 
m_RendererFeaturesoo  2
?oo2 3
.oo3 4
Countoo4 9
;oo9 :
ioo; <
++oo< >
)oo> ?
{pp 
ifqq 
(qq 
m_RendererFeaturesqq &
[qq& '
iqq' (
]qq( )
==qq* ,
nullqq- 1
)qq1 2
{rr 
ifss 
(ss 
mapValidss  
&&ss! # 
m_RendererFeatureMapss$ 8
[ss8 9
iss9 :
]ss: ;
!=ss< >
$numss? @
)ss@ A
{tt 
varuu 
localIduu #
=uu$ % 
m_RendererFeatureMapuu& :
[uu: ;
iuu; <
]uu< =
;uu= >
loadedAssetsvv $
.vv$ %
TryGetValuevv% 0
(vv0 1
localIdvv1 8
,vv8 9
outvv: =
varvv> A
assetvvB G
)vvG H
;vvH I
m_RendererFeaturesww *
[ww* +
iww+ ,
]ww, -
=ww. /
(ww0 1%
ScriptableRendererFeatureww1 J
)wwJ K
assetwwL Q
;wwQ R
}xx 
elseyy 
{zz 
m_RendererFeatures{{ *
[{{* +
i{{+ ,
]{{, -
={{. /
({{0 1%
ScriptableRendererFeature{{1 J
){{J K
GetUnusedAsset{{L Z
({{Z [
ref{{[ ^
	linkedIds{{_ h
,{{h i
ref{{j m
loadedAssets{{n z
){{z {
;{{{ |
}|| 
}}} 
debugOutput 
+= 
m_RendererFeatures 1
[1 2
i2 3
]3 4
!=5 7
null8 <
?= >
$"? A
-A B
{B C
iC D
}D E
	:Linked\nE N
"N O
:P Q
$"R T
-T U
{U V
iV W
}W X

:Missing\nX b
"b c
;c d
}
ÄÄ 
	UpdateMap
ÇÇ 
(
ÇÇ 
)
ÇÇ 
;
ÇÇ 
if
ÑÑ 
(
ÑÑ 
!
ÑÑ  
m_RendererFeatures
ÑÑ #
.
ÑÑ# $
Contains
ÑÑ$ ,
(
ÑÑ, -
null
ÑÑ- 1
)
ÑÑ1 2
)
ÑÑ2 3
return
ÖÖ 
true
ÖÖ 
;
ÖÖ 
Debug
áá 
.
áá 
LogError
áá 
(
áá 
$"
áá 
{
áá 
name
áá "
}
áá" #b
T is missing RendererFeatures\nThis could be due to missing scripts or compile error.
áá# w
"
ááw x
,
ááx y
this
ááz ~
)
áá~ 
;áá Ä
return
àà 
false
àà 
;
àà 
}
ââ 	
internal
ãã 
bool
ãã #
DuplicateFeatureCheck
ãã +
(
ãã+ ,
Type
ãã, 0
type
ãã1 5
)
ãã5 6
{
åå 	
var
çç 
isSingleFeature
çç 
=
çç  !
type
çç" &
.
çç& ' 
GetCustomAttribute
çç' 9
(
çç9 :
typeof
çç: @
(
çç@ A-
DisallowMultipleRendererFeature
ççA `
)
çç` a
)
çça b
;
ççb c
return
éé 
isSingleFeature
éé "
!=
éé# %
null
éé& *
&&
éé+ - 
m_RendererFeatures
éé. @
.
éé@ A
Select
ééA G
(
ééG H
renderFeature
ééH U
=>
ééV X
renderFeature
ééY f
.
ééf g
GetType
éég n
(
één o
)
ééo p
)
éép q
.
ééq r
Any
éér u
(
ééu v
t
éév w
=>
ééx z
t
éé{ |
==
éé} 
typeééÄ Ñ
)ééÑ Ö
;ééÖ Ü
}
èè 	
private
ëë 
static
ëë 
object
ëë 
GetUnusedAsset
ëë ,
(
ëë, -
ref
ëë- 0
List
ëë1 5
<
ëë5 6
long
ëë6 :
>
ëë: ;
usedIds
ëë< C
,
ëëC D
ref
ëëE H

Dictionary
ëëI S
<
ëëS T
long
ëëT X
,
ëëX Y
object
ëëZ `
>
ëë` a
assets
ëëb h
)
ëëh i
{
íí 	
foreach
ìì 
(
ìì 
var
ìì 
asset
ìì 
in
ìì !
assets
ìì" (
)
ìì( )
{
îî 
var
ïï 
alreadyLinked
ïï !
=
ïï" #
usedIds
ïï$ +
.
ïï+ ,
Any
ïï, /
(
ïï/ 0
used
ïï0 4
=>
ïï5 7
asset
ïï8 =
.
ïï= >
Key
ïï> A
==
ïïB D
used
ïïE I
)
ïïI J
;
ïïJ K
if
óó 
(
óó 
alreadyLinked
óó !
)
óó! "
continue
òò 
;
òò 
usedIds
öö 
.
öö 
Add
öö 
(
öö 
asset
öö !
.
öö! "
Key
öö" %
)
öö% &
;
öö& '
return
õõ 
asset
õõ 
.
õõ 
Value
õõ "
;
õõ" #
}
úú 
return
ûû 
null
ûû 
;
ûû 
}
üü 	
private
°° 
void
°° 
	UpdateMap
°° 
(
°° 
)
°°  
{
¢¢ 	
if
££ 
(
££ "
m_RendererFeatureMap
££ $
.
££$ %
Count
££% *
!=
££+ - 
m_RendererFeatures
££. @
.
££@ A
Count
££A F
)
££F G
{
§§ "
m_RendererFeatureMap
•• $
.
••$ %
Clear
••% *
(
••* +
)
••+ ,
;
••, -"
m_RendererFeatureMap
¶¶ $
.
¶¶$ %
AddRange
¶¶% -
(
¶¶- .
new
¶¶. 1
long
¶¶2 6
[
¶¶6 7 
m_RendererFeatures
¶¶7 I
.
¶¶I J
Count
¶¶J O
]
¶¶O P
)
¶¶P Q
;
¶¶Q R
}
ßß 
for
©© 
(
©© 
int
©© 
i
©© 
=
©© 
$num
©© 
;
©© 
i
©© 
<
©© 
rendererFeatures
©©  0
.
©©0 1
Count
©©1 6
;
©©6 7
i
©©8 9
++
©©9 ;
)
©©; <
{
™™ 
if
´´ 
(
´´  
m_RendererFeatures
´´ %
[
´´% &
i
´´& '
]
´´' (
==
´´) +
null
´´, 0
)
´´0 1
continue
´´2 :
;
´´: ;
if
¨¨ 
(
¨¨ 
!
¨¨ 
AssetDatabase
¨¨ "
.
¨¨" #.
 TryGetGUIDAndLocalFileIdentifier
¨¨# C
(
¨¨C D 
m_RendererFeatures
¨¨D V
[
¨¨V W
i
¨¨W X
]
¨¨X Y
,
¨¨Y Z
out
¨¨[ ^
var
¨¨_ b
guid
¨¨c g
,
¨¨g h
out
¨¨i l
long
¨¨m q
localId
¨¨r y
)
¨¨y z
)
¨¨z {
continue¨¨| Ñ
;¨¨Ñ Ö"
m_RendererFeatureMap
ÆÆ $
[
ÆÆ$ %
i
ÆÆ% &
]
ÆÆ& '
=
ÆÆ( )
localId
ÆÆ* 1
;
ÆÆ1 2
}
ØØ 
}
∞∞ 	
}
≤≤ 
}≥≥ ôí
®D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\ScriptableRenderPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Flags 

]
 
public 

enum %
ScriptableRenderPassInput )
{ 
None 
= 
$num 
, 
Depth 
= 
$num 
<< 
$num 
, 
Normal 
= 
$num 
<< 
$num 
, 
Color 
= 
$num 
<< 
$num 
, 
} 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
enum5 9
RenderPassEvent: I
{ 
BeforeRendering!! 
=!! 
$num!! 
,!! "
BeforeRenderingShadows'' 
=''  
$num''! #
,''# $!
AfterRenderingShadows-- 
=-- 
$num--  #
,--# $$
BeforeRenderingPrepasses33  
=33! "
$num33# &
,33& '#
AfterRenderingPrePasses99 
=99  !
$num99" %
,99% &"
BeforeRenderingOpaques>> 
=>>  
$num>>! $
,>>$ %!
AfterRenderingOpaquesCC 
=CC 
$numCC  #
,CC# $!
BeforeRenderingSkyboxHH 
=HH 
$numHH  #
,HH# $ 
AfterRenderingSkyboxMM 
=MM 
$numMM "
,MM" #'
BeforeRenderingTransparentsRR #
=RR$ %
$numRR& )
,RR) *&
AfterRenderingTransparentsWW "
=WW# $
$numWW% (
,WW( ))
BeforeRenderingPostProcessing\\ %
=\\& '
$num\\( +
,\\+ ,(
AfterRenderingPostProcessingaa $
=aa% &
$numaa' *
,aa* +
AfterRenderingff 
=ff 
$numff 
,ff 
}gg 
[ll 
	MovedFromll 
(ll 
$strll +
)ll+ ,
]ll, -
publicll. 4
abstractll5 =
partialll> E
classllF K 
ScriptableRenderPassllL `
{mm 
publicnn 
RenderPassEventnn 
renderPassEventnn .
{nn/ 0
getnn1 4
;nn4 5
setnn6 9
;nn9 :
}nn; <
publicpp "
RenderTargetIdentifierpp %
[pp% &
]pp& '
colorAttachmentspp( 8
{qq 	
getrr 
=>rr 
m_ColorAttachmentsrr %
;rr% &
}ss 	
publicuu "
RenderTargetIdentifieruu %
colorAttachmentuu& 5
{vv 	
getww 
=>ww 
m_ColorAttachmentsww %
[ww% &
$numww& '
]ww' (
;ww( )
}xx 	
publiczz "
RenderTargetIdentifierzz %
depthAttachmentzz& 5
{{{ 	
get|| 
=>|| 
m_DepthAttachment|| $
;||$ %
}}} 	
public
ÉÉ '
ScriptableRenderPassInput
ÉÉ (
input
ÉÉ) .
{
ÑÑ 	
get
ÖÖ 
=>
ÖÖ 
m_Input
ÖÖ 
;
ÖÖ 
}
ÜÜ 	
public
àà 
	ClearFlag
àà 
	clearFlag
àà "
{
ââ 	
get
ää 
=>
ää 
m_ClearFlag
ää 
;
ää 
}
ãã 	
public
çç 
Color
çç 

clearColor
çç 
{
éé 	
get
èè 
=>
èè 
m_ClearColor
èè 
;
èè  
}
êê 	
	protected
ìì 
internal
ìì 
ProfilingSampler
ìì +
profilingSampler
ìì, <
{
ìì= >
get
ìì? B
;
ììB C
set
ììD G
;
ììG H
}
ììI J
internal
îî 
bool
îî "
overrideCameraTarget
îî *
{
îî+ ,
get
îî- 0
;
îî0 1
set
îî2 5
;
îî5 6
}
îî7 8
internal
ïï 
bool
ïï 
isBlitRenderPass
ïï &
{
ïï' (
get
ïï) ,
;
ïï, -
set
ïï. 1
;
ïï1 2
}
ïï3 4$
RenderTargetIdentifier
óó 
[
óó 
]
óó   
m_ColorAttachments
óó! 3
=
óó4 5
new
óó6 9$
RenderTargetIdentifier
óó: P
[
óóP Q
]
óóQ R
{
óóR S&
BuiltinRenderTextureType
óóS k
.
óók l
CameraTarget
óól x
}
óóx y
;
óóy z$
RenderTargetIdentifier
òò 
m_DepthAttachment
òò 0
=
òò1 2&
BuiltinRenderTextureType
òò3 K
.
òòK L
CameraTarget
òòL X
;
òòX Y'
ScriptableRenderPassInput
ôô !
m_Input
ôô" )
=
ôô* +'
ScriptableRenderPassInput
ôô, E
.
ôôE F
None
ôôF J
;
ôôJ K
	ClearFlag
öö 
m_ClearFlag
öö 
=
öö 
	ClearFlag
öö  )
.
öö) *
None
öö* .
;
öö. /
Color
õõ 
m_ClearColor
õõ 
=
õõ 
Color
õõ "
.
õõ" #
black
õõ# (
;
õõ( )
public
ùù "
ScriptableRenderPass
ùù #
(
ùù# $
)
ùù$ %
{
ûû 	
renderPassEvent
üü 
=
üü 
RenderPassEvent
üü -
.
üü- .#
AfterRenderingOpaques
üü. C
;
üüC D 
m_ColorAttachments
†† 
=
††  
new
††! $$
RenderTargetIdentifier
††% ;
[
††; <
]
††< =
{
††= >&
BuiltinRenderTextureType
††> V
.
††V W
CameraTarget
††W c
,
††c d
$num
††e f
,
††f g
$num
††h i
,
††i j
$num
††k l
,
††l m
$num
††n o
,
††o p
$num
††q r
,
††r s
$num
††t u
,
††u v
$num
††w x
}
††x y
;
††y z
m_DepthAttachment
°° 
=
°° &
BuiltinRenderTextureType
°°  8
.
°°8 9
CameraTarget
°°9 E
;
°°E F
m_ClearFlag
¢¢ 
=
¢¢ 
	ClearFlag
¢¢ #
.
¢¢# $
None
¢¢$ (
;
¢¢( )
m_ClearColor
££ 
=
££ 
Color
££  
.
££  !
black
££! &
;
££& '"
overrideCameraTarget
§§  
=
§§! "
false
§§# (
;
§§( )
isBlitRenderPass
•• 
=
•• 
false
•• $
;
••$ %
profilingSampler
¶¶ 
=
¶¶ 
new
¶¶ "
ProfilingSampler
¶¶# 3
(
¶¶3 4
nameof
¶¶4 :
(
¶¶: ;"
ScriptableRenderPass
¶¶; O
)
¶¶O P
)
¶¶P Q
;
¶¶Q R
}
ßß 	
public
ØØ 
void
ØØ 
ConfigureInput
ØØ "
(
ØØ" #'
ScriptableRenderPassInput
ØØ# <
	passInput
ØØ= F
)
ØØF G
{
∞∞ 	
m_Input
±± 
=
±± 
	passInput
±± 
;
±±  
}
≤≤ 	
public
ªª 
void
ªª 
ConfigureTarget
ªª #
(
ªª# $$
RenderTargetIdentifier
ªª$ :
colorAttachment
ªª; J
,
ªªJ K$
RenderTargetIdentifier
ªªL b
depthAttachment
ªªc r
)
ªªr s
{
ºº 	
m_DepthAttachment
ΩΩ 
=
ΩΩ 
depthAttachment
ΩΩ  /
;
ΩΩ/ 0
ConfigureTarget
ææ 
(
ææ 
colorAttachment
ææ +
)
ææ+ ,
;
ææ, -
}
øø 	
public
»» 
void
»» 
ConfigureTarget
»» #
(
»»# $$
RenderTargetIdentifier
»»$ :
[
»»: ;
]
»»; <
colorAttachments
»»= M
,
»»M N$
RenderTargetIdentifier
»»O e
depthAttachment
»»f u
)
»»u v
{
…… 	"
overrideCameraTarget
    
=
  ! "
true
  # '
;
  ' (
uint
ÃÃ !
nonNullColorBuffers
ÃÃ $
=
ÃÃ% &
RenderingUtils
ÃÃ' 5
.
ÃÃ5 6&
GetValidColorBufferCount
ÃÃ6 N
(
ÃÃN O
colorAttachments
ÃÃO _
)
ÃÃ_ `
;
ÃÃ` a
if
ÕÕ 
(
ÕÕ !
nonNullColorBuffers
ÕÕ #
>
ÕÕ$ %

SystemInfo
ÕÕ& 0
.
ÕÕ0 1(
supportedRenderTargetCount
ÕÕ1 K
)
ÕÕK L
Debug
ŒŒ 
.
ŒŒ 
LogError
ŒŒ 
(
ŒŒ 
$str
ŒŒ /
+
ŒŒ0 1!
nonNullColorBuffers
ŒŒ2 E
+
ŒŒF G
$strŒŒH É
+ŒŒÑ Ö

SystemInfoŒŒÜ ê
.ŒŒê ë*
supportedRenderTargetCountŒŒë ´
)ŒŒ´ ¨
;ŒŒ¨ ≠ 
m_ColorAttachments
–– 
=
––  
colorAttachments
––! 1
;
––1 2
m_DepthAttachment
—— 
=
—— 
depthAttachment
——  /
;
——/ 0
}
““ 	
public
⁄⁄ 
void
⁄⁄ 
ConfigureTarget
⁄⁄ #
(
⁄⁄# $$
RenderTargetIdentifier
⁄⁄$ :
colorAttachment
⁄⁄; J
)
⁄⁄J K
{
€€ 	"
overrideCameraTarget
‹‹  
=
‹‹! "
true
‹‹# '
;
‹‹' ( 
m_ColorAttachments
ﬁﬁ 
[
ﬁﬁ 
$num
ﬁﬁ  
]
ﬁﬁ  !
=
ﬁﬁ" #
colorAttachment
ﬁﬁ$ 3
;
ﬁﬁ3 4
for
ﬂﬂ 
(
ﬂﬂ 
int
ﬂﬂ 
i
ﬂﬂ 
=
ﬂﬂ 
$num
ﬂﬂ 
;
ﬂﬂ 
i
ﬂﬂ 
<
ﬂﬂ  
m_ColorAttachments
ﬂﬂ  2
.
ﬂﬂ2 3
Length
ﬂﬂ3 9
;
ﬂﬂ9 :
++
ﬂﬂ; =
i
ﬂﬂ= >
)
ﬂﬂ> ? 
m_ColorAttachments
‡‡ "
[
‡‡" #
i
‡‡# $
]
‡‡$ %
=
‡‡& '
$num
‡‡( )
;
‡‡) *
}
·· 	
public
ÈÈ 
void
ÈÈ 
ConfigureTarget
ÈÈ #
(
ÈÈ# $$
RenderTargetIdentifier
ÈÈ$ :
[
ÈÈ: ;
]
ÈÈ; <
colorAttachments
ÈÈ= M
)
ÈÈM N
{
ÍÍ 	
ConfigureTarget
ÎÎ 
(
ÎÎ 
colorAttachments
ÎÎ ,
,
ÎÎ, -&
BuiltinRenderTextureType
ÎÎ. F
.
ÎÎF G
CameraTarget
ÎÎG S
)
ÎÎS T
;
ÎÎT U
}
ÏÏ 	
public
ÙÙ 
void
ÙÙ 
ConfigureClear
ÙÙ "
(
ÙÙ" #
	ClearFlag
ÙÙ# ,
	clearFlag
ÙÙ- 6
,
ÙÙ6 7
Color
ÙÙ8 =

clearColor
ÙÙ> H
)
ÙÙH I
{
ıı 	
m_ClearFlag
ˆˆ 
=
ˆˆ 
	clearFlag
ˆˆ #
;
ˆˆ# $
m_ClearColor
˜˜ 
=
˜˜ 

clearColor
˜˜ %
;
˜˜% &
}
¯¯ 	
public
ÑÑ 
virtual
ÑÑ 
void
ÑÑ 
OnCameraSetup
ÑÑ )
(
ÑÑ) *
CommandBuffer
ÑÑ* 7
cmd
ÑÑ8 ;
,
ÑÑ; <
ref
ÑÑ= @
RenderingData
ÑÑA N
renderingData
ÑÑO \
)
ÑÑ\ ]
{
ÖÖ 	
}
ÖÖ	 

public
ëë 
virtual
ëë 
void
ëë 
	Configure
ëë %
(
ëë% &
CommandBuffer
ëë& 3
cmd
ëë4 7
,
ëë7 8%
RenderTextureDescriptor
ëë9 P%
cameraTextureDescriptor
ëëQ h
)
ëëh i
{
íí 	
}
íí	 

public
úú 
virtual
úú 
void
úú 
OnCameraCleanup
úú +
(
úú+ ,
CommandBuffer
úú, 9
cmd
úú: =
)
úú= >
{
ùù 	
}
üü 	
public
©© 
virtual
©© 
void
©© *
OnFinishCameraStackRendering
©© 8
(
©©8 9
CommandBuffer
©©9 F
cmd
©©G J
)
©©J K
{
™™ 	
}
™™	 

public
±± 
abstract
±± 
void
±± 
Execute
±± $
(
±±$ %%
ScriptableRenderContext
±±% <
context
±±= D
,
±±D E
ref
±±F I
RenderingData
±±J W
renderingData
±±X e
)
±±e f
;
±±f g
public
ΩΩ 
void
ΩΩ 
Blit
ΩΩ 
(
ΩΩ 
CommandBuffer
ΩΩ &
cmd
ΩΩ' *
,
ΩΩ* +$
RenderTargetIdentifier
ΩΩ, B
source
ΩΩC I
,
ΩΩI J$
RenderTargetIdentifier
ΩΩK a
destination
ΩΩb m
,
ΩΩm n
Material
ΩΩo w
materialΩΩx Ä
=ΩΩÅ Ç
nullΩΩÉ á
,ΩΩá à
intΩΩâ å
	passIndexΩΩç ñ
=ΩΩó ò
$numΩΩô ö
)ΩΩö õ
{
ææ 	 
ScriptableRenderer
øø 
.
øø 
SetRenderTarget
øø .
(
øø. /
cmd
øø/ 2
,
øø2 3
destination
øø4 ?
,
øø? @&
BuiltinRenderTextureType
øøA Y
.
øøY Z
CameraTarget
øøZ f
,
øøf g
	clearFlag
øøh q
,
øøq r

clearColor
øøs }
)
øø} ~
;
øø~ 
cmd
¿¿ 
.
¿¿ 
Blit
¿¿ 
(
¿¿ 
source
¿¿ 
,
¿¿ 
destination
¿¿ (
,
¿¿( )
material
¿¿* 2
,
¿¿2 3
	passIndex
¿¿4 =
)
¿¿= >
;
¿¿> ?
}
¡¡ 	
public
ÀÀ 
DrawingSettings
ÀÀ #
CreateDrawingSettings
ÀÀ 4
(
ÀÀ4 5
ShaderTagId
ÀÀ5 @
shaderTagId
ÀÀA L
,
ÀÀL M
ref
ÀÀN Q
RenderingData
ÀÀR _
renderingData
ÀÀ` m
,
ÀÀm n
SortingCriteria
ÀÀo ~
sortingCriteriaÀÀ é
)ÀÀé è
{
ÃÃ 	
Camera
ÕÕ 
camera
ÕÕ 
=
ÕÕ 
renderingData
ÕÕ )
.
ÕÕ) *

cameraData
ÕÕ* 4
.
ÕÕ4 5
camera
ÕÕ5 ;
;
ÕÕ; <
SortingSettings
ŒŒ 
sortingSettings
ŒŒ +
=
ŒŒ, -
new
ŒŒ. 1
SortingSettings
ŒŒ2 A
(
ŒŒA B
camera
ŒŒB H
)
ŒŒH I
{
ŒŒJ K
criteria
ŒŒL T
=
ŒŒU V
sortingCriteria
ŒŒW f
}
ŒŒg h
;
ŒŒh i
DrawingSettings
œœ 
settings
œœ $
=
œœ% &
new
œœ' *
DrawingSettings
œœ+ :
(
œœ: ;
shaderTagId
œœ; F
,
œœF G
sortingSettings
œœH W
)
œœW X
{
–– 
perObjectData
—— 
=
—— 
renderingData
——  -
.
——- .
perObjectData
——. ;
,
——; <
mainLightIndex
““ 
=
““  
renderingData
““! .
.
““. /
	lightData
““/ 8
.
““8 9
mainLightIndex
““9 G
,
““G H#
enableDynamicBatching
”” %
=
””& '
renderingData
””( 5
.
””5 6%
supportsDynamicBatching
””6 M
,
””M N
enableInstancing
÷÷  
=
÷÷! "
camera
÷÷# )
.
÷÷) *

cameraType
÷÷* 4
==
÷÷5 7

CameraType
÷÷8 B
.
÷÷B C
Preview
÷÷C J
?
÷÷K L
false
÷÷M R
:
÷÷S T
true
÷÷U Y
,
÷÷Y Z
}
◊◊ 
;
◊◊ 
return
ÿÿ 
settings
ÿÿ 
;
ÿÿ 
}
ŸŸ 	
public
„„ 
DrawingSettings
„„ #
CreateDrawingSettings
„„ 4
(
„„4 5
List
„„5 9
<
„„9 :
ShaderTagId
„„: E
>
„„E F
shaderTagIdList
„„G V
,
„„V W
ref
‰‰ 
RenderingData
‰‰ 
renderingData
‰‰ +
,
‰‰+ ,
SortingCriteria
‰‰- <
sortingCriteria
‰‰= L
)
‰‰L M
{
ÂÂ 	
if
ÊÊ 
(
ÊÊ 
shaderTagIdList
ÊÊ 
==
ÊÊ  "
null
ÊÊ# '
||
ÊÊ( *
shaderTagIdList
ÊÊ+ :
.
ÊÊ: ;
Count
ÊÊ; @
==
ÊÊA C
$num
ÊÊD E
)
ÊÊE F
{
ÁÁ 
Debug
ËË 
.
ËË 

LogWarning
ËË  
(
ËË  !
$str
ËË! |
)
ËË| }
;
ËË} ~
return
ÈÈ #
CreateDrawingSettings
ÈÈ ,
(
ÈÈ, -
new
ÈÈ- 0
ShaderTagId
ÈÈ1 <
(
ÈÈ< =
$str
ÈÈ= P
)
ÈÈP Q
,
ÈÈQ R
ref
ÈÈS V
renderingData
ÈÈW d
,
ÈÈd e
sortingCriteria
ÈÈf u
)
ÈÈu v
;
ÈÈv w
}
ÍÍ 
DrawingSettings
ÏÏ 
settings
ÏÏ $
=
ÏÏ% &#
CreateDrawingSettings
ÏÏ' <
(
ÏÏ< =
shaderTagIdList
ÏÏ= L
[
ÏÏL M
$num
ÏÏM N
]
ÏÏN O
,
ÏÏO P
ref
ÏÏQ T
renderingData
ÏÏU b
,
ÏÏb c
sortingCriteria
ÏÏd s
)
ÏÏs t
;
ÏÏt u
for
ÌÌ 
(
ÌÌ 
int
ÌÌ 
i
ÌÌ 
=
ÌÌ 
$num
ÌÌ 
;
ÌÌ 
i
ÌÌ 
<
ÌÌ 
shaderTagIdList
ÌÌ  /
.
ÌÌ/ 0
Count
ÌÌ0 5
;
ÌÌ5 6
++
ÌÌ7 9
i
ÌÌ9 :
)
ÌÌ: ;
settings
ÓÓ 
.
ÓÓ 
SetShaderPassName
ÓÓ *
(
ÓÓ* +
i
ÓÓ+ ,
,
ÓÓ, -
shaderTagIdList
ÓÓ. =
[
ÓÓ= >
i
ÓÓ> ?
]
ÓÓ? @
)
ÓÓ@ A
;
ÓÓA B
return
ÔÔ 
settings
ÔÔ 
;
ÔÔ 
}
 	
public
ÚÚ 
static
ÚÚ 
bool
ÚÚ 
operator
ÚÚ #
<
ÚÚ$ %
(
ÚÚ% &"
ScriptableRenderPass
ÚÚ& :
lhs
ÚÚ; >
,
ÚÚ> ?"
ScriptableRenderPass
ÚÚ@ T
rhs
ÚÚU X
)
ÚÚX Y
{
ÛÛ 	
return
ÙÙ 
lhs
ÙÙ 
.
ÙÙ 
renderPassEvent
ÙÙ &
<
ÙÙ' (
rhs
ÙÙ) ,
.
ÙÙ, -
renderPassEvent
ÙÙ- <
;
ÙÙ< =
}
ıı 	
public
˜˜ 
static
˜˜ 
bool
˜˜ 
operator
˜˜ #
>
˜˜$ %
(
˜˜% &"
ScriptableRenderPass
˜˜& :
lhs
˜˜; >
,
˜˜> ?"
ScriptableRenderPass
˜˜@ T
rhs
˜˜U X
)
˜˜X Y
{
¯¯ 	
return
˘˘ 
lhs
˘˘ 
.
˘˘ 
renderPassEvent
˘˘ &
>
˘˘' (
rhs
˘˘) ,
.
˘˘, -
renderPassEvent
˘˘- <
;
˘˘< =
}
˙˙ 	
}
˚˚ 
}¸¸ —&
ûD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\SceneViewDrawMode.cs
	namespace 	
UnityEditor
 
. 
	Rendering 
.  
	Universal  )
{ 
internal 
static 
class 
SceneViewDrawMode +
{ 
static		 
HashSet		 
<		 
	SceneView		  
>		  !)
sceneViewHaveValidateFunction		" ?
=		@ A
new		B E
HashSet		F M
<		M N
	SceneView		N W
>		W X
(		X Y
)		Y Z
;		Z [
static 
bool 
RejectDrawMode "
(" #
	SceneView# ,
., -

CameraMode- 7

cameraMode8 B
)B C
{ 	
if 
( 

cameraMode 
. 
drawMode #
==$ &
DrawCameraMode' 5
.5 6
ShadowCascades6 D
||E G

cameraMode 
. 
drawMode #
==$ &
DrawCameraMode' 5
.5 6
RenderPaths6 A
||B D

cameraMode 
. 
drawMode #
==$ &
DrawCameraMode' 5
.5 6
AlphaChannel6 B
||C E

cameraMode 
. 
drawMode #
==$ &
DrawCameraMode' 5
.5 6
Overdraw6 >
||? A

cameraMode 
. 
drawMode #
==$ &
DrawCameraMode' 5
.5 6
Mipmaps6 =
||> @

cameraMode 
. 
drawMode #
==$ &
DrawCameraMode' 5
.5 6

SpriteMask6 @
||A C

cameraMode 
. 
drawMode #
==$ &
DrawCameraMode' 5
.5 6
DeferredDiffuse6 E
||F H

cameraMode 
. 
drawMode #
==$ &
DrawCameraMode' 5
.5 6
DeferredSpecular6 F
||G I

cameraMode 
. 
drawMode #
==$ &
DrawCameraMode' 5
.5 6
DeferredSmoothness6 H
||I K

cameraMode 
. 
drawMode #
==$ &
DrawCameraMode' 5
.5 6
DeferredNormal6 D
||E G

cameraMode 
. 
drawMode #
==$ &
DrawCameraMode' 5
.5 6
ValidateAlbedo6 D
||E G

cameraMode 
. 
drawMode #
==$ &
DrawCameraMode' 5
.5 6!
ValidateMetalSpecular6 K
) 
return 
false 
; 
return 
true 
; 
} 	
static 
void !
UpdateSceneViewStates )
() *
)* +
{   	
foreach!! 
(!! 
	SceneView!! 
	sceneView!! (
in!!) +
	SceneView!!, 5
.!!5 6

sceneViews!!6 @
)!!@ A
{"" 
if## 
(## )
sceneViewHaveValidateFunction## 1
.##1 2
Contains##2 :
(##: ;
	sceneView##; D
)##D E
)##E F
continue$$ 
;$$ 
	sceneView'' 
.''  
onValidateCameraMode'' .
+=''/ 1
RejectDrawMode''2 @
;''@ A)
sceneViewHaveValidateFunction(( -
.((- .
Add((. 1
(((1 2
	sceneView((2 ;
)((; <
;((< =
})) 
}** 	
public,, 
static,, 
void,, 
SetupDrawMode,, (
(,,( )
),,) *
{-- 	
EditorApplication.. 
... 
update.. $
-=..% '!
UpdateSceneViewStates..( =
;..= >
EditorApplication// 
.// 
update// $
+=//% '!
UpdateSceneViewStates//( =
;//= >
}00 	
public22 
static22 
void22 
ResetDrawMode22 (
(22( )
)22) *
{33 	
EditorApplication44 
.44 
update44 $
-=44% '!
UpdateSceneViewStates44( =
;44= >
foreach66 
(66 
var66 
	sceneView66 "
in66# %)
sceneViewHaveValidateFunction66& C
)66C D
	sceneView77 
.77  
onValidateCameraMode77 .
-=77/ 1
RejectDrawMode772 @
;77@ A)
sceneViewHaveValidateFunction88 )
.88) *
Clear88* /
(88/ 0
)880 1
;881 2
}99 	
}:: 
};; Är
¶D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Shadows\ShadowCaster2D.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
[ 
ExecuteInEditMode 
] 
[ %
DisallowMultipleComponent 
] 
[ 
AddComponentMenu 
( 
$str D
)D E
]E F
public 

class 
ShadowCaster2D 
:  !
ShadowCasterGroup2D" 5
{ 
[ 	
SerializeField	 
] 
bool 
m_HasRenderer +
=, -
false. 3
;3 4
[ 	
SerializeField	 
] 
bool #
m_UseRendererSilhouette 5
=6 7
true8 <
;< =
[ 	
SerializeField	 
] 
bool 
m_CastsShadows ,
=- .
true/ 3
;3 4
[ 	
SerializeField	 
] 
bool 
m_SelfShadows +
=, -
false. 3
;3 4
[ 	
SerializeField	 
] 
int 
[ 
] "
m_ApplyToSortingLayers 5
=6 7
null8 <
;< =
[ 	
SerializeField	 
] 
Vector3  
[  !
]! "
m_ShapePath# .
=/ 0
null1 5
;5 6
[ 	
SerializeField	 
] 
int 
m_ShapePathHash ,
=- .
$num/ 0
;0 1
[ 	
SerializeField	 
] 
Mesh 
m_Mesh $
;$ %
[ 	
SerializeField	 
] 
int 
m_InstanceId )
;) *
internal 
ShadowCasterGroup2D $
m_ShadowCasterGroup% 8
=9 :
null; ?
;? @
internal 
ShadowCasterGroup2D $'
m_PreviousShadowCasterGroup% @
=A B
nullC G
;G H
internal 
Mesh 
mesh 
=> 
m_Mesh $
;$ %
internal 
Vector3 
[ 
] 
	shapePath $
=>% '
m_ShapePath( 3
;3 4
internal   
int   
shapePathHash   "
{  # $
get  % (
{  ) *
return  + 1
m_ShapePathHash  2 A
;  A B
}  C D
set  E H
{  I J
m_ShapePathHash  K Z
=  [ \
value  ] b
;  b c
}  d e
}  f g
int"" !
m_PreviousShadowGroup"" !
=""" #
$num""$ %
;""% &
bool## "
m_PreviousCastsShadows## #
=##$ %
true##& *
;##* +
int$$ 
m_PreviousPathHash$$ 
=$$  
$num$$! "
;$$" #
public** 
bool** !
useRendererSilhouette** )
{++ 	
set,, 
{,, #
m_UseRendererSilhouette,, )
=,,* +
value,,, 1
;,,1 2
},,3 4
get-- 
{-- 
return-- #
m_UseRendererSilhouette-- 0
&&--1 3
m_HasRenderer--4 A
;--A B
}--D E
}.. 	
public33 
bool33 
selfShadows33 
{44 	
set55 
{55 
m_SelfShadows55 
=55  !
value55" '
;55' (
}55) *
get66 
{66 
return66 
m_SelfShadows66 &
;66& '
}66( )
}77 	
public<< 
bool<< 
castsShadows<<  
{== 	
set>> 
{>> 
m_CastsShadows>>  
=>>! "
value>># (
;>>( )
}>>* +
get?? 
{?? 
return?? 
m_CastsShadows?? '
;??' (
}??) *
}@@ 	
staticBB 
intBB 
[BB 
]BB #
SetDefaultSortingLayersBB ,
(BB, -
)BB- .
{CC 	
intDD 

layerCountDD 
=DD 
SortingLayerDD )
.DD) *
layersDD* 0
.DD0 1
LengthDD1 7
;DD7 8
intEE 
[EE 
]EE 
	allLayersEE 
=EE 
newEE !
intEE" %
[EE% &

layerCountEE& 0
]EE0 1
;EE1 2
forGG 
(GG 
intGG 

layerIndexGG 
=GG 
$numGG  
;GG  !

layerIndexGG! +
<GG, -

layerCountGG. 8
;GG8 9

layerIndexGG9 C
++GGC E
)GGE F
{HH 
	allLayersII 
[II 

layerIndexII $
]II$ %
=II& '
SortingLayerII( 4
.II4 5
layersII5 ;
[II; <

layerIndexII< F
]IIF G
.IIG H
idIIH J
;IIJ K
}JJ 
returnLL 
	allLayersLL 
;LL 
}MM 	
internalOO 
boolOO 
IsShadowedLayerOO %
(OO% &
intOO& )
layerOO* /
)OO/ 0
{PP 	
returnQQ "
m_ApplyToSortingLayersQQ )
!=QQ* ,
nullQQ- 1
?QQ2 3
ArrayQQ4 9
.QQ9 :
IndexOfQQ: A
(QQA B"
m_ApplyToSortingLayersQQB X
,QQX Y
layerQQZ _
)QQ_ `
>=QQa c
$numQQd e
:QQf g
falseQQh m
;QQm n
}RR 	
privateTT 
voidTT 
AwakeTT 
(TT 
)TT 
{UU 	
ifVV 
(VV "
m_ApplyToSortingLayersVV &
==VV' )
nullVV* .
)VV. /"
m_ApplyToSortingLayersWW &
=WW' (#
SetDefaultSortingLayersWW) @
(WW@ A
)WWA B
;WWB C
BoundsYY 
boundsYY 
=YY 
newYY 
BoundsYY  &
(YY& '
	transformYY' 0
.YY0 1
positionYY1 9
,YY9 :
Vector3YY; B
.YYB C
oneYYC F
)YYF G
;YYG H
Renderer[[ 
renderer[[ 
=[[ 
GetComponent[[  ,
<[[, -
Renderer[[- 5
>[[5 6
([[6 7
)[[7 8
;[[8 9
if\\ 
(\\ 
renderer\\ 
!=\\ 
null\\  
)\\  !
{]] 
bounds^^ 
=^^ 
renderer^^ !
.^^! "
bounds^^" (
;^^( )
}__ 
elseaa 
{bb 

Collider2Dcc 
collidercc #
=cc$ %
GetComponentcc& 2
<cc2 3

Collider2Dcc3 =
>cc= >
(cc> ?
)cc? @
;cc@ A
ifdd 
(dd 
colliderdd 
!=dd 
nulldd  $
)dd$ %
boundsee 
=ee 
collideree %
.ee% &
boundsee& ,
;ee, -
}ff 
Vector3ii 
	relOffsetii 
=ii 
boundsii  &
.ii& '
centerii' -
-ii. /
	transformii0 9
.ii9 :
positionii: B
;iiB C
ifkk 
(kk 
m_ShapePathkk 
==kk 
nullkk #
||kk$ &
m_ShapePathkk' 2
.kk2 3
Lengthkk3 9
==kk: <
$numkk= >
)kk> ?
{ll 
m_ShapePathmm 
=mm 
newmm !
Vector3mm" )
[mm) *
]mm* +
{nn 
	relOffsetoo 
+oo 
newoo  #
Vector3oo$ +
(oo+ ,
-oo, -
boundsoo- 3
.oo3 4
extentsoo4 ;
.oo; <
xoo< =
,oo= >
-oo? @
boundsoo@ F
.ooF G
extentsooG N
.ooN O
yooO P
)ooP Q
,ooQ R
	relOffsetpp 
+pp 
newpp  #
Vector3pp$ +
(pp+ ,
boundspp, 2
.pp2 3
extentspp3 :
.pp: ;
xpp; <
,pp< =
-pp> ?
boundspp? E
.ppE F
extentsppF M
.ppM N
yppN O
)ppO P
,ppP Q
	relOffsetqq 
+qq 
newqq  #
Vector3qq$ +
(qq+ ,
boundsqq, 2
.qq2 3
extentsqq3 :
.qq: ;
xqq; <
,qq< =
boundsqq> D
.qqD E
extentsqqE L
.qqL M
yqqM N
)qqN O
,qqO P
	relOffsetrr 
+rr 
newrr  #
Vector3rr$ +
(rr+ ,
-rr, -
boundsrr- 3
.rr3 4
extentsrr4 ;
.rr; <
xrr< =
,rr= >
boundsrr? E
.rrE F
extentsrrF M
.rrM N
yrrN O
)rrO P
}ss 
;ss 
}tt 
}uu 	
	protectedww 
voidww 
OnEnableww 
(ww  
)ww  !
{xx 	
ifyy 
(yy 
m_Meshyy 
==yy 
nullyy 
||yy !
m_InstanceIdyy" .
!=yy/ 1
GetInstanceIDyy2 ?
(yy? @
)yy@ A
)yyA B
{zz 
m_Mesh{{ 
={{ 
new{{ 
Mesh{{ !
({{! "
){{" #
;{{# $
ShadowUtility|| 
.|| 
GenerateShadowMesh|| 0
(||0 1
m_Mesh||1 7
,||7 8
m_ShapePath||9 D
)||D E
;||E F
m_InstanceId}} 
=}} 
GetInstanceID}} ,
(}}, -
)}}- .
;}}. /
}~~ !
m_ShadowCasterGroup
ÄÄ 
=
ÄÄ  !
null
ÄÄ" &
;
ÄÄ& '
}
ÅÅ 	
	protected
ÉÉ 
void
ÉÉ 
	OnDisable
ÉÉ  
(
ÉÉ  !
)
ÉÉ! "
{
ÑÑ 	(
ShadowCasterGroup2DManager
ÖÖ &
.
ÖÖ& ')
RemoveFromShadowCasterGroup
ÖÖ' B
(
ÖÖB C
this
ÖÖC G
,
ÖÖG H!
m_ShadowCasterGroup
ÖÖI \
)
ÖÖ\ ]
;
ÖÖ] ^
}
ÜÜ 	
public
àà 
void
àà 
Update
àà 
(
àà 
)
àà 
{
ââ 	
Renderer
ää 
renderer
ää 
=
ää 
GetComponent
ää  ,
<
ää, -
Renderer
ää- 5
>
ää5 6
(
ää6 7
)
ää7 8
;
ää8 9
m_HasRenderer
ãã 
=
ãã 
renderer
ãã $
!=
ãã% '
null
ãã( ,
;
ãã, -
bool
çç 
rebuildMesh
çç 
=
çç 
LightUtility
çç +
.
çç+ ,
CheckForChange
çç, :
(
çç: ;
m_ShapePathHash
çç; J
,
ççJ K
ref
ççL O 
m_PreviousPathHash
ççP b
)
ççb c
;
ççc d
if
éé 
(
éé 
rebuildMesh
éé 
)
éé 
ShadowUtility
èè 
.
èè  
GenerateShadowMesh
èè 0
(
èè0 1
m_Mesh
èè1 7
,
èè7 8
m_ShapePath
èè9 D
)
èèD E
;
èèE F)
m_PreviousShadowCasterGroup
ëë '
=
ëë( )!
m_ShadowCasterGroup
ëë* =
;
ëë= >
bool
íí 
addedToNewGroup
íí  
=
íí! "(
ShadowCasterGroup2DManager
íí# =
.
íí= >$
AddToShadowCasterGroup
íí> T
(
ííT U
this
ííU Y
,
ííY Z
ref
íí[ ^!
m_ShadowCasterGroup
íí_ r
)
íír s
;
íís t
if
ìì 
(
ìì 
addedToNewGroup
ìì 
&&
ìì  "!
m_ShadowCasterGroup
ìì# 6
!=
ìì7 9
null
ìì: >
)
ìì> ?
{
îî 
if
ïï 
(
ïï )
m_PreviousShadowCasterGroup
ïï /
==
ïï0 2
this
ïï3 7
)
ïï7 8(
ShadowCasterGroup2DManager
ññ .
.
ññ. /
RemoveGroup
ññ/ :
(
ññ: ;
this
ññ; ?
)
ññ? @
;
ññ@ A(
ShadowCasterGroup2DManager
òò *
.
òò* +)
RemoveFromShadowCasterGroup
òò+ F
(
òòF G
this
òòG K
,
òòK L)
m_PreviousShadowCasterGroup
òòM h
)
òòh i
;
òòi j
if
ôô 
(
ôô !
m_ShadowCasterGroup
ôô '
==
ôô( *
this
ôô+ /
)
ôô/ 0(
ShadowCasterGroup2DManager
öö .
.
öö. /
AddGroup
öö/ 7
(
öö7 8
this
öö8 <
)
öö< =
;
öö= >
}
õõ 
if
ùù 
(
ùù 
LightUtility
ùù 
.
ùù 
CheckForChange
ùù +
(
ùù+ ,
m_ShadowGroup
ùù, 9
,
ùù9 :
ref
ùù; >#
m_PreviousShadowGroup
ùù? T
)
ùùT U
)
ùùU V
{
ûû (
ShadowCasterGroup2DManager
üü *
.
üü* +
RemoveGroup
üü+ 6
(
üü6 7
this
üü7 ;
)
üü; <
;
üü< =(
ShadowCasterGroup2DManager
†† *
.
††* +
AddGroup
††+ 3
(
††3 4
this
††4 8
)
††8 9
;
††9 :
}
°° 
if
££ 
(
££ 
LightUtility
££ 
.
££ 
CheckForChange
££ +
(
££+ ,
m_CastsShadows
££, :
,
££: ;
ref
££< ?$
m_PreviousCastsShadows
££@ V
)
££V W
)
££W X
{
§§ 
if
•• 
(
•• 
m_CastsShadows
•• !
)
••! "(
ShadowCasterGroup2DManager
¶¶ .
.
¶¶. /
AddGroup
¶¶/ 7
(
¶¶7 8
this
¶¶8 <
)
¶¶< =
;
¶¶= >
else
ßß (
ShadowCasterGroup2DManager
®® .
.
®®. /
RemoveGroup
®®/ :
(
®®: ;
this
®®; ?
)
®®? @
;
®®@ A
}
©© 
}
™™ 	
void
≠≠ 
Reset
≠≠ 
(
≠≠ 
)
≠≠ 
{
ÆÆ 	
Awake
ØØ 
(
ØØ 
)
ØØ 
;
ØØ 
OnEnable
∞∞ 
(
∞∞ 
)
∞∞ 
;
∞∞ 
}
±± 	
}
¥¥ 
}µµ ⁄€
ñD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\XR\XRPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
internal 
struct 
XRPassCreateInfo $
{ 
public 
int 
multipassId 
; 
public 
int 
cullingPassId  
;  !
public 
RenderTexture 
renderTarget )
;) *
public #
RenderTextureDescriptor &
renderTargetDesc' 7
;7 8
public 
bool '
renderTargetIsRenderTexture /
;/ 0
public '
ScriptableCullingParameters *
cullingParameters+ <
;< =
public 
XRPass 
. 
CustomMirrorView &
customMirrorView' 7
;7 8
} 
internal 
struct 
XRViewCreateInfo $
{ 
public 
	Matrix4x4 

projMatrix #
;# $
public 
	Matrix4x4 

viewMatrix #
;# $
public 
Rect 
viewport 
; 
public 
int 
textureArraySlice $
;$ %
}   
internal"" 
struct"" 
XRView"" 
{## 
internal$$ 
readonly$$ 
	Matrix4x4$$ #

projMatrix$$$ .
;$$. /
internal%% 
readonly%% 
	Matrix4x4%% #

viewMatrix%%$ .
;%%. /
internal&& 
readonly&& 
Rect&& 
viewport&& '
;&&' (
internal'' 
readonly'' 
Mesh'' 
occlusionMesh'' ,
;'', -
internal(( 
readonly(( 
int(( 
textureArraySlice(( /
;((/ 0
internal** 
XRView** 
(** 
	Matrix4x4** !
proj**" &
,**& '
	Matrix4x4**( 1
view**2 6
,**6 7
Rect**8 <
vp**= ?
,**? @
int**A D
dstSlice**E M
)**M N
{++ 	

projMatrix,, 
=,, 
proj,, 
;,, 

viewMatrix-- 
=-- 
view-- 
;-- 
viewport.. 
=.. 
vp.. 
;.. 
occlusionMesh// 
=// 
null//  
;//  !
textureArraySlice00 
=00 
dstSlice00  (
;00( )
}11 	
internal33 
XRView33 
(33 
XRDisplaySubsystem33 *
.33* +
XRRenderPass33+ 7

renderPass338 B
,33B C
XRDisplaySubsystem33D V
.33V W
XRRenderParameter33W h
renderParameter33i x
)33x y
{44 	

projMatrix55 
=55 
renderParameter55 (
.55( )

projection55) 3
;553 4

viewMatrix66 
=66 
renderParameter66 (
.66( )
view66) -
;66- .
viewport77 
=77 
renderParameter77 &
.77& '
viewport77' /
;77/ 0
occlusionMesh88 
=88 
renderParameter88 +
.88+ ,
occlusionMesh88, 9
;889 :
textureArraySlice99 
=99 
renderParameter99  /
.99/ 0
textureArraySlice990 A
;99A B
viewport<< 
.<< 
x<< 
*=<< 

renderPass<< )
.<<) *
renderTargetDesc<<* :
.<<: ;
width<<; @
;<<@ A
viewport== 
.== 
width== 
*=== 

renderPass== )
.==) *
renderTargetDesc==* :
.==: ;
width==; @
;==@ A
viewport>> 
.>> 
y>> 
*=>> 

renderPass>> )
.>>) *
renderTargetDesc>>* :
.>>: ;
height>>; A
;>>A B
viewport?? 
.?? 
height?? 
*=?? 

renderPass?? )
.??) *
renderTargetDesc??* :
.??: ;
height??; A
;??A B
}@@ 	
}AA 
classCC 	
XRPassCC
 
{DD 
internalEE 
ListEE 
<EE 
XRViewEE 
>EE 
viewsEE #
=EE$ %
newEE& )
ListEE* .
<EE. /
XRViewEE/ 5
>EE5 6
(EE6 7
$numEE7 8
)EE8 9
;EE9 :
internalGG 
boolGG 
enabledGG 
{GG# $
getGG% (
=>GG) +
viewsGG, 1
.GG1 2
CountGG2 7
>GG8 9
$numGG: ;
;GG; <
}GG= >
internalHH 
boolHH 
xrSdkEnabledHH "
{HH# $
getHH% (
;HH( )
privateHH* 1
setHH2 5
;HH5 6
}HH7 8
internalII 
boolII 
	copyDepthII 
{II# $
getII% (
;II( )
privateII* 1
setII2 5
;II5 6
}II7 8
internalKK 
intKK 
multipassIdKK  
{KK$ %
getKK& )
;KK) *
privateKK+ 2
setKK3 6
;KK6 7
}KK8 9
internalLL 
intLL 
cullingPassIdLL "
{LL$ %
getLL& )
;LL) *
privateLL+ 2
setLL3 6
;LL6 7
}LL8 9
internalOO "
RenderTargetIdentifierOO '
renderTargetOO) 5
{OO: ;
getOO< ?
;OO? @
privateOOA H
setOOI L
;OOL M
}OON O
internalPP #
RenderTextureDescriptorPP (
renderTargetDescPP) 9
{PP: ;
getPP< ?
;PP? @
privatePPA H
setPPI L
;PPL M
}PPN O
staticQQ "
RenderTargetIdentifierQQ '
	invalidRTQQ) 2
=QQ3 4
-QQ5 6
$numQQ6 7
;QQ7 8
internalRR 
boolRR 
renderTargetValidRR) :
{RR; <
getRR= @
=>RRA C
renderTargetRRD P
!=RRQ S
	invalidRTRRT ]
;RR] ^
}RR_ `
internalSS 
boolSS '
renderTargetIsRenderTextureSS) D
{SSE F
getSSG J
;SSJ K
privateSSL S
setSST W
;SSW X
}SSY Z
internalVV 
	Matrix4x4VV 
GetProjMatrixVV (
(VV( )
intVV) ,
	viewIndexVV- 6
=VV7 8
$numVV9 :
)VV: ;
{VV= >
returnVV? E
viewsVVF K
[VVK L
	viewIndexVVL U
]VVU V
.VVV W

projMatrixVVW a
;VVa b
}VVc d
internalWW 
	Matrix4x4WW 
GetViewMatrixWW (
(WW( )
intWW) ,
	viewIndexWW- 6
=WW7 8
$numWW9 :
)WW: ;
{WW= >
returnWW? E
viewsWWF K
[WWK L
	viewIndexWWL U
]WWU V
.WWV W

viewMatrixWWW a
;WWa b
}WWc d
internalXX 
intXX  
GetTextureArraySliceXX )
(XX) *
intXX* -
	viewIndexXX. 7
=XX8 9
$numXX: ;
)XX; <
{XX= >
returnXX? E
viewsXXF K
[XXK L
	viewIndexXXL U
]XXU V
.XXV W
textureArraySliceXXW h
;XXh i
}XXj k
internalYY 
RectYY 
GetViewportYY !
(YY! "
intYY" %
	viewIndexYY& /
=YY0 1
$numYY2 3
)YY3 4
{YY= >
returnYY? E
viewsYYF K
[YYK L
	viewIndexYYL U
]YYU V
.YYV W
viewportYYW _
;YY_ `
}YYa b
internal\\ '
ScriptableCullingParameters\\ ,
cullingParams\\- :
{\\; <
get\\= @
;\\@ A
private\\B I
set\\J M
;\\M N
}\\O P
internal__ 
int__ 
	viewCount__ 
{__  
get__! $
=>__% '
views__( -
.__- .
Count__. 3
;__3 4
}__5 6
internal`` 
bool`` 
singlePassEnabled`` '
{``( )
get``* -
=>``. 0
	viewCount``1 :
>``; <
$num``= >
;``> ?
}``@ A
Materialcc !
occlusionMeshMaterialcc &
=cc' (
nullcc) -
;cc- .
Meshdd !
occlusionMeshCombineddd "
=dd# $
nulldd% )
;dd) *
intee )
occlusionMeshCombinedHashCodeee )
=ee* +
$numee, -
;ee- .
internalgg 
boolgg $
isOcclusionMeshSupportedgg .
{gg/ 0
getgg1 4
=>gg5 7
enabledgg8 ?
&&gg@ B
xrSdkEnabledggC O
&&ggP R!
occlusionMeshMaterialggS h
!=ggi k
nullggl p
;ggp q
}ggr s
internalii 
boolii !
hasValidOcclusionMeshii +
{jj 	
getkk 
{ll 
ifmm 
(mm $
isOcclusionMeshSupportedmm ,
)mm, -
{nn 
ifoo 
(oo 
singlePassEnabledoo )
)oo) *
returnpp !
occlusionMeshCombinedpp 4
!=pp5 7
nullpp8 <
;pp< =
elseqq 
returnrr 
viewsrr $
[rr$ %
$numrr% &
]rr& '
.rr' (
occlusionMeshrr( 5
!=rr6 8
nullrr9 =
;rr= >
}ss 
returnuu 
falseuu 
;uu 
}vv 
}ww 	
internalzz 
delegatezz 
voidzz 
CustomMirrorViewzz /
(zz/ 0
XRPasszz0 6
passzz7 ;
,zz; <
CommandBufferzz= J
cmdzzK N
,zzN O
RenderTexturezzP ]
rtzz^ `
,zz` a
Rectzzb f
viewportzzg o
)zzo p
;zzp q
CustomMirrorView{{ 
customMirrorView{{ )
={{* +
null{{, 0
;{{0 1
internal|| 
void|| 
SetCustomMirrorView|| )
(||) *
CustomMirrorView||* :
callback||; C
)||C D
=>||E G
customMirrorView||H X
=||Y Z
callback||[ c
;||c d
const~~ 
string~~ 
k_XRCustomMirrorTag~~ (
=~~) *
$str~~+ B
;~~B C
static 
ProfilingSampler +
_XRCustomMirrorProfilingSampler  ?
=@ A
newB E
ProfilingSamplerF V
(V W
k_XRCustomMirrorTagW j
)j k
;k l
const
ÄÄ 
string
ÄÄ 
k_XROcclusionTag
ÄÄ %
=
ÄÄ& '
$str
ÄÄ( ;
;
ÄÄ; <
static
ÅÅ 
ProfilingSampler
ÅÅ *
_XROcclusionProfilingSampler
ÅÅ  <
=
ÅÅ= >
new
ÅÅ? B
ProfilingSampler
ÅÅC S
(
ÅÅS T
k_XROcclusionTag
ÅÅT d
)
ÅÅd e
;
ÅÅe f
internal
ÉÉ 
static
ÉÉ 
XRPass
ÉÉ 
Create
ÉÉ %
(
ÉÉ% &
XRPassCreateInfo
ÉÉ& 6

createInfo
ÉÉ7 A
)
ÉÉA B
{
ÑÑ 	
XRPass
ÖÖ 
passInfo
ÖÖ 
=
ÖÖ 
GenericPool
ÖÖ )
<
ÖÖ) *
XRPass
ÖÖ* 0
>
ÖÖ0 1
.
ÖÖ1 2
Get
ÖÖ2 5
(
ÖÖ5 6
)
ÖÖ6 7
;
ÖÖ7 8
passInfo
áá 
.
áá 
multipassId
áá  
=
áá! "

createInfo
áá# -
.
áá- .
multipassId
áá. 9
;
áá9 :
passInfo
àà 
.
àà 
cullingPassId
àà "
=
àà# $

createInfo
àà% /
.
àà/ 0
cullingPassId
àà0 =
;
àà= >
passInfo
ââ 
.
ââ 
cullingParams
ââ "
=
ââ# $

createInfo
ââ% /
.
ââ/ 0
cullingParameters
ââ0 A
;
ââA B
passInfo
ää 
.
ää 
customMirrorView
ää %
=
ää& '

createInfo
ää( 2
.
ää2 3
customMirrorView
ää3 C
;
ääC D
passInfo
ãã 
.
ãã 
views
ãã 
.
ãã 
Clear
ãã  
(
ãã  !
)
ãã! "
;
ãã" #
if
çç 
(
çç 

createInfo
çç 
.
çç 
renderTarget
çç '
!=
çç( *
null
çç+ /
)
çç/ 0
{
éé 
passInfo
èè 
.
èè 
renderTarget
èè %
=
èè& '
new
èè( +$
RenderTargetIdentifier
èè, B
(
èèB C

createInfo
èèC M
.
èèM N
renderTarget
èèN Z
,
èèZ [
$num
èè\ ]
,
èè] ^
CubemapFace
èè_ j
.
èèj k
Unknown
èèk r
,
èèr s
-
èèt u
$num
èèu v
)
èèv w
;
èèw x
passInfo
êê 
.
êê 
renderTargetDesc
êê )
=
êê* +

createInfo
êê, 6
.
êê6 7
renderTarget
êê7 C
.
êêC D

descriptor
êêD N
;
êêN O
passInfo
ëë 
.
ëë )
renderTargetIsRenderTexture
ëë 4
=
ëë5 6

createInfo
ëë7 A
.
ëëA B)
renderTargetIsRenderTexture
ëëB ]
;
ëë] ^
}
íí 
else
ìì 
{
îî 
passInfo
ïï 
.
ïï 
renderTarget
ïï %
=
ïï& '
	invalidRT
ïï( 1
;
ïï1 2
passInfo
ññ 
.
ññ 
renderTargetDesc
ññ )
=
ññ* +

createInfo
ññ, 6
.
ññ6 7
renderTargetDesc
ññ7 G
;
ññG H
passInfo
óó 
.
óó )
renderTargetIsRenderTexture
óó 4
=
óó5 6

createInfo
óó7 A
.
óóA B)
renderTargetIsRenderTexture
óóB ]
;
óó] ^
}
òò 
passInfo
öö 
.
öö #
occlusionMeshMaterial
öö *
=
öö+ ,
null
öö- 1
;
öö1 2
passInfo
õõ 
.
õõ 
xrSdkEnabled
õõ !
=
õõ" #
false
õõ$ )
;
õõ) *
passInfo
úú 
.
úú 
	copyDepth
úú 
=
úú  
false
úú! &
;
úú& '
return
ûû 
passInfo
ûû 
;
ûû 
}
üü 	
internal
°° 
void
°° 

UpdateView
°°  
(
°°  !
int
°°! $
viewId
°°% +
,
°°+ , 
XRDisplaySubsystem
°°- ?
.
°°? @
XRRenderPass
°°@ L
xrSdkRenderPass
°°M \
,
°°\ ] 
XRDisplaySubsystem
°°^ p
.
°°p q 
XRRenderParameter°°q Ç$
xrSdkRenderParameter°°É ó
)°°ó ò
{
¢¢ 	
if
££ 
(
££ 
viewId
££ 
>=
££ 
views
££ 
.
££  
Count
££  %
)
££% &
throw
§§ 
new
§§ %
NotImplementedException
§§ 1
(
§§1 2
$"
§§2 4P
BInvalid XR setup to update, trying to update non-existing xr view.
§§4 v
"
§§v w
)
§§w x
;
§§x y
views
¶¶ 
[
¶¶ 
viewId
¶¶ 
]
¶¶ 
=
¶¶ 
new
¶¶ 
XRView
¶¶  &
(
¶¶& '
xrSdkRenderPass
¶¶' 6
,
¶¶6 7"
xrSdkRenderParameter
¶¶8 L
)
¶¶L M
;
¶¶M N
}
ßß 	
internal
©© 
void
©© 

UpdateView
©©  
(
©©  !
int
©©! $
viewId
©©% +
,
©©+ ,
	Matrix4x4
©©- 6
proj
©©7 ;
,
©©; <
	Matrix4x4
©©= F
view
©©G K
,
©©K L
Rect
©©M Q
vp
©©R T
,
©©T U
int
©©V Y
textureArraySlice
©©Z k
=
©©l m
-
©©n o
$num
©©o p
)
©©p q
{
™™ 	
if
´´ 
(
´´ 
viewId
´´ 
>=
´´ 
views
´´ 
.
´´  
Count
´´  %
)
´´% &
throw
¨¨ 
new
¨¨ %
NotImplementedException
¨¨ 1
(
¨¨1 2
$"
¨¨2 4P
BInvalid XR setup to update, trying to update non-existing xr view.
¨¨4 v
"
¨¨v w
)
¨¨w x
;
¨¨x y
views
ÆÆ 
[
ÆÆ 
viewId
ÆÆ 
]
ÆÆ 
=
ÆÆ 
new
ÆÆ 
XRView
ÆÆ  &
(
ÆÆ& '
proj
ÆÆ' +
,
ÆÆ+ ,
view
ÆÆ- 1
,
ÆÆ1 2
vp
ÆÆ3 5
,
ÆÆ5 6
textureArraySlice
ÆÆ7 H
)
ÆÆH I
;
ÆÆI J
}
ØØ 	
internal
±± 
void
±± !
UpdateCullingParams
±± )
(
±±) *
int
±±* -
cullingPassId
±±. ;
,
±±; <)
ScriptableCullingParameters
±±= X
cullingParams
±±Y f
)
±±f g
{
≤≤ 	
this
≥≥ 
.
≥≥ 
cullingPassId
≥≥ 
=
≥≥  
cullingPassId
≥≥! .
;
≥≥. /
this
¥¥ 
.
¥¥ 
cullingParams
¥¥ 
=
¥¥  
cullingParams
¥¥! .
;
¥¥. /
}
µµ 	
internal
∑∑ 
void
∑∑ 
AddView
∑∑ 
(
∑∑ 
	Matrix4x4
∑∑ '
proj
∑∑( ,
,
∑∑, -
	Matrix4x4
∑∑. 7
view
∑∑8 <
,
∑∑< =
Rect
∑∑> B
vp
∑∑C E
,
∑∑E F
int
∑∑G J
textureArraySlice
∑∑K \
=
∑∑] ^
-
∑∑_ `
$num
∑∑` a
)
∑∑a b
{
∏∏ 	
AddViewInternal
ππ 
(
ππ 
new
ππ 
XRView
ππ  &
(
ππ& '
proj
ππ' +
,
ππ+ ,
view
ππ- 1
,
ππ1 2
vp
ππ3 5
,
ππ5 6
textureArraySlice
ππ7 H
)
ππH I
)
ππI J
;
ππJ K
}
∫∫ 	
internal
ºº 
static
ºº 
XRPass
ºº 
Create
ºº %
(
ºº% & 
XRDisplaySubsystem
ºº& 8
.
ºº8 9
XRRenderPass
ºº9 E
xrRenderPass
ººF R
,
ººR S
int
ººT W
multipassId
ººX c
,
ººc d*
ScriptableCullingParametersººe Ä!
cullingParametersººÅ í
,ººí ì
Materialººî ú%
occlusionMeshMaterialººù ≤
)ºº≤ ≥
{
ΩΩ 	
XRPass
ææ 
passInfo
ææ 
=
ææ 
GenericPool
ææ )
<
ææ) *
XRPass
ææ* 0
>
ææ0 1
.
ææ1 2
Get
ææ2 5
(
ææ5 6
)
ææ6 7
;
ææ7 8
passInfo
¿¿ 
.
¿¿ 
multipassId
¿¿  
=
¿¿! "
multipassId
¿¿# .
;
¿¿. /
passInfo
¡¡ 
.
¡¡ 
cullingPassId
¡¡ "
=
¡¡# $
xrRenderPass
¡¡% 1
.
¡¡1 2
cullingPassIndex
¡¡2 B
;
¡¡B C
passInfo
¬¬ 
.
¬¬ 
cullingParams
¬¬ "
=
¬¬# $
cullingParameters
¬¬% 6
;
¬¬6 7
passInfo
√√ 
.
√√ 
views
√√ 
.
√√ 
Clear
√√  
(
√√  !
)
√√! "
;
√√" #
passInfo
∆∆ 
.
∆∆ 
renderTarget
∆∆ !
=
∆∆" #
new
∆∆$ '$
RenderTargetIdentifier
∆∆( >
(
∆∆> ?
xrRenderPass
∆∆? K
.
∆∆K L
renderTarget
∆∆L X
,
∆∆X Y
$num
∆∆Z [
,
∆∆[ \
CubemapFace
∆∆] h
.
∆∆h i
Unknown
∆∆i p
,
∆∆p q
-
∆∆r s
$num
∆∆s t
)
∆∆t u
;
∆∆u v%
RenderTextureDescriptor
»» #
xrDesc
»»$ *
=
»»+ ,
xrRenderPass
»»- 9
.
»»9 :
renderTargetDesc
»»: J
;
»»J K%
RenderTextureDescriptor
…… #
rtDesc
……$ *
=
……+ ,
new
……- 0%
RenderTextureDescriptor
……1 H
(
……H I
xrDesc
……I O
.
……O P
width
……P U
,
……U V
xrDesc
……W ]
.
……] ^
height
……^ d
,
……d e
xrDesc
……f l
.
……l m
colorFormat
……m x
,
……x y
xrDesc……z Ä
.……Ä Å
depthBufferBits……Å ê
,……ê ë
xrDesc……í ò
.……ò ô
mipCount……ô °
)……° ¢
;……¢ £
rtDesc
   
.
   
	dimension
   
=
    
xrRenderPass
  ! -
.
  - .
renderTargetDesc
  . >
.
  > ?
	dimension
  ? H
;
  H I
rtDesc
ÀÀ 
.
ÀÀ 
volumeDepth
ÀÀ 
=
ÀÀ  
xrRenderPass
ÀÀ! -
.
ÀÀ- .
renderTargetDesc
ÀÀ. >
.
ÀÀ> ?
volumeDepth
ÀÀ? J
;
ÀÀJ K
rtDesc
ÃÃ 
.
ÃÃ 
vrUsage
ÃÃ 
=
ÃÃ  
xrRenderPass
ÃÃ! -
.
ÃÃ- .
renderTargetDesc
ÃÃ. >
.
ÃÃ> ?
vrUsage
ÃÃ? F
;
ÃÃF G
rtDesc
ÕÕ 
.
ÕÕ 
sRGB
ÕÕ 
=
ÕÕ  
xrRenderPass
ÕÕ! -
.
ÕÕ- .
renderTargetDesc
ÕÕ. >
.
ÕÕ> ?
sRGB
ÕÕ? C
;
ÕÕC D
passInfo
—— 
.
—— 
renderTargetDesc
—— %
=
——& '
rtDesc
——( .
;
——. /
passInfo
‘‘ 
.
‘‘ )
renderTargetIsRenderTexture
‘‘ 0
=
‘‘1 2
false
‘‘3 8
;
‘‘8 9
passInfo
’’ 
.
’’ #
occlusionMeshMaterial
’’ *
=
’’+ ,#
occlusionMeshMaterial
’’- B
;
’’B C
passInfo
÷÷ 
.
÷÷ 
xrSdkEnabled
÷÷ !
=
÷÷" #
true
÷÷$ (
;
÷÷( )
passInfo
◊◊ 
.
◊◊ 
	copyDepth
◊◊ 
=
◊◊  
xrRenderPass
◊◊! -
.
◊◊- . 
shouldFillOutDepth
◊◊. @
;
◊◊@ A
passInfo
ÿÿ 
.
ÿÿ 
customMirrorView
ÿÿ %
=
ÿÿ& '
null
ÿÿ( ,
;
ÿÿ, -
Debug
⁄⁄ 
.
⁄⁄ 
Assert
⁄⁄ 
(
⁄⁄ 
passInfo
⁄⁄ !
.
⁄⁄! "
renderTargetValid
⁄⁄" 3
,
⁄⁄3 4
$str
⁄⁄5 e
)
⁄⁄e f
;
⁄⁄f g
return
‹‹ 
passInfo
‹‹ 
;
‹‹ 
}
›› 	
internal
ﬂﬂ 
void
ﬂﬂ 
AddView
ﬂﬂ 
(
ﬂﬂ  
XRDisplaySubsystem
ﬂﬂ 0
.
ﬂﬂ0 1
XRRenderPass
ﬂﬂ1 =
xrSdkRenderPass
ﬂﬂ> M
,
ﬂﬂM N 
XRDisplaySubsystem
ﬂﬂO a
.
ﬂﬂa b
XRRenderParameter
ﬂﬂb s#
xrSdkRenderParameterﬂﬂt à
)ﬂﬂà â
{
‡‡ 	
AddViewInternal
·· 
(
·· 
new
·· 
XRView
··  &
(
··& '
xrSdkRenderPass
··' 6
,
··6 7"
xrSdkRenderParameter
··8 L
)
··L M
)
··M N
;
··N O
}
‚‚ 	
internal
‰‰ 
static
‰‰ 
void
‰‰ 
Release
‰‰ $
(
‰‰$ %
XRPass
‰‰% +
xrPass
‰‰, 2
)
‰‰2 3
{
ÂÂ 	
GenericPool
ÊÊ 
<
ÊÊ 
XRPass
ÊÊ 
>
ÊÊ 
.
ÊÊ  
Release
ÊÊ  '
(
ÊÊ' (
xrPass
ÊÊ( .
)
ÊÊ. /
;
ÊÊ/ 0
}
ÁÁ 	
internal
ÈÈ 
void
ÈÈ 
AddViewInternal
ÈÈ %
(
ÈÈ% &
XRView
ÈÈ& ,
xrView
ÈÈ- 3
)
ÈÈ3 4
{
ÍÍ 	
int
ÏÏ 
maxSupportedViews
ÏÏ !
=
ÏÏ" #
Math
ÏÏ$ (
.
ÏÏ( )
Min
ÏÏ) ,
(
ÏÏ, -
	TextureXR
ÏÏ- 6
.
ÏÏ6 7
slices
ÏÏ7 =
,
ÏÏ= >
$num
ÏÏ? @
)
ÏÏ] ^
;
ÏÏ^ _
if
ÓÓ 
(
ÓÓ 
views
ÓÓ 
.
ÓÓ 
Count
ÓÓ 
<
ÓÓ 
maxSupportedViews
ÓÓ /
)
ÓÓ/ 0
{
ÔÔ 
views
 
.
 
Add
 
(
 
xrView
  
)
  !
;
! "
}
ÒÒ 
else
ÚÚ 
{
ÛÛ 
throw
ÙÙ 
new
ÙÙ %
NotImplementedException
ÙÙ 1
(
ÙÙ1 2
$"
ÙÙ2 4^
OInvalid XR setup for single-pass, trying to add too many views! Max supported: ÙÙ4 É
{ÙÙÉ Ñ!
maxSupportedViewsÙÙÑ ï
}ÙÙï ñ
"ÙÙñ ó
)ÙÙó ò
;ÙÙò ô
}
ıı 
}
ˆˆ 	
internal
˘˘ 
void
˘˘ !
UpdateOcclusionMesh
˘˘ )
(
˘˘) *
)
˘˘* +
{
˙˙ 	
if
˚˚ 
(
˚˚ &
isOcclusionMeshSupported
˚˚ (
&&
˚˚) +1
#TryGetOcclusionMeshCombinedHashCode
˚˚, O
(
˚˚O P
out
˚˚P S
var
˚˚T W
hashCode
˚˚X `
)
˚˚` a
)
˚˚a b
{
¸¸ 
if
˝˝ 
(
˝˝ #
occlusionMeshCombined
˝˝ )
==
˝˝* ,
null
˝˝- 1
||
˝˝2 4
hashCode
˝˝5 =
!=
˝˝> @+
occlusionMeshCombinedHashCode
˝˝A ^
)
˝˝^ _
{
˛˛ )
CreateOcclusionMeshCombined
ˇˇ /
(
ˇˇ/ 0
)
ˇˇ0 1
;
ˇˇ1 2+
occlusionMeshCombinedHashCode
ÄÄ 1
=
ÄÄ2 3
hashCode
ÄÄ4 <
;
ÄÄ< =
}
ÅÅ 
}
ÇÇ 
else
ÉÉ 
{
ÑÑ #
occlusionMeshCombined
ÖÖ %
=
ÖÖ& '
null
ÖÖ( ,
;
ÖÖ, -+
occlusionMeshCombinedHashCode
ÜÜ -
=
ÜÜ. /
$num
ÜÜ0 1
;
ÜÜ1 2
}
áá 
}
àà 	
private
ää 
bool
ää 1
#TryGetOcclusionMeshCombinedHashCode
ää 8
(
ää8 9
out
ää9 <
int
ää= @
hashCode
ääA I
)
ääI J
{
ãã 	
hashCode
åå 
=
åå 
$num
åå 
;
åå 
for
éé 
(
éé 
int
éé 
viewId
éé 
=
éé 
$num
éé 
;
éé  
viewId
éé! '
<
éé( )
	viewCount
éé* 3
;
éé3 4
++
éé5 7
viewId
éé7 =
)
éé= >
{
èè 
if
êê 
(
êê 
views
êê 
[
êê 
viewId
êê  
]
êê  !
.
êê! "
occlusionMesh
êê" /
!=
êê0 2
null
êê3 7
)
êê7 8
{
ëë 
hashCode
íí 
=
íí 
hashCode
íí '
*
íí( )
$num
íí* ,
+
íí- .
views
íí/ 4
[
íí4 5
viewId
íí5 ;
]
íí; <
.
íí< =
occlusionMesh
íí= J
.
ííJ K
GetHashCode
ííK V
(
ííV W
)
ííW X
;
ííX Y
}
ìì 
else
îî 
{
ïï 
hashCode
ññ 
=
ññ 
$num
ññ  
;
ññ  !
return
óó 
false
óó  
;
óó  !
}
òò 
}
ôô 
return
õõ 
true
õõ 
;
õõ 
}
úú 	
private
üü 
void
üü )
CreateOcclusionMeshCombined
üü 0
(
üü0 1
)
üü1 2
{
†† 	#
occlusionMeshCombined
°° !
=
°°" #
new
°°$ '
Mesh
°°( ,
(
°°, -
)
°°- .
;
°°. /#
occlusionMeshCombined
¢¢ !
.
¢¢! "
indexFormat
¢¢" -
=
¢¢. /
IndexFormat
¢¢0 ;
.
¢¢; <
UInt16
¢¢< B
;
¢¢B C
int
§§ !
combinedVertexCount
§§ #
=
§§$ %
$num
§§& '
;
§§' (
uint
••  
combinedIndexCount
•• #
=
••$ %
$num
••& '
;
••' (
for
ßß 
(
ßß 
int
ßß 
viewId
ßß 
=
ßß 
$num
ßß 
;
ßß  
viewId
ßß! '
<
ßß( )
	viewCount
ßß* 3
;
ßß3 4
++
ßß5 7
viewId
ßß7 =
)
ßß= >
{
®® 
Mesh
©© 
mesh
©© 
=
©© 
views
©© !
[
©©! "
viewId
©©" (
]
©©( )
.
©©) *
occlusionMesh
©©* 7
;
©©7 8
Debug
´´ 
.
´´ 
Assert
´´ 
(
´´ 
mesh
´´ !
!=
´´" $
null
´´% )
)
´´) *
;
´´* +
Debug
¨¨ 
.
¨¨ 
Assert
¨¨ 
(
¨¨ 
mesh
¨¨ !
.
¨¨! "
subMeshCount
¨¨" .
==
¨¨/ 1
$num
¨¨2 3
)
¨¨3 4
;
¨¨4 5
Debug
≠≠ 
.
≠≠ 
Assert
≠≠ 
(
≠≠ 
mesh
≠≠ !
.
≠≠! "
indexFormat
≠≠" -
==
≠≠. 0
IndexFormat
≠≠1 <
.
≠≠< =
UInt16
≠≠= C
)
≠≠C D
;
≠≠D E!
combinedVertexCount
ØØ #
+=
ØØ$ &
mesh
ØØ' +
.
ØØ+ ,
vertexCount
ØØ, 7
;
ØØ7 8 
combinedIndexCount
∞∞ "
+=
∞∞# %
mesh
∞∞& *
.
∞∞* +
GetIndexCount
∞∞+ 8
(
∞∞8 9
$num
∞∞9 :
)
∞∞: ;
;
∞∞; <
}
±± 
Vector3
≥≥ 
[
≥≥ 
]
≥≥ 
vertices
≥≥ 
=
≥≥  
new
≥≥! $
Vector3
≥≥% ,
[
≥≥, -!
combinedVertexCount
≥≥- @
]
≥≥@ A
;
≥≥A B
ushort
¥¥ 
[
¥¥ 
]
¥¥ 
indices
¥¥ 
=
¥¥ 
new
¥¥ "
ushort
¥¥# )
[
¥¥) * 
combinedIndexCount
¥¥* <
]
¥¥< =
;
¥¥= >
int
µµ 
vertexStart
µµ 
=
µµ 
$num
µµ 
;
µµ  
int
∂∂ 

indexStart
∂∂ 
=
∂∂ 
$num
∂∂ 
;
∂∂ 
for
∏∏ 
(
∏∏ 
int
∏∏ 
viewId
∏∏ 
=
∏∏ 
$num
∏∏ 
;
∏∏  
viewId
∏∏! '
<
∏∏( )
	viewCount
∏∏* 3
;
∏∏3 4
++
∏∏5 7
viewId
∏∏7 =
)
∏∏= >
{
ππ 
Mesh
∫∫ 
mesh
∫∫ 
=
∫∫ 
views
∫∫ !
[
∫∫! "
viewId
∫∫" (
]
∫∫( )
.
∫∫) *
occlusionMesh
∫∫* 7
;
∫∫7 8
var
ªª 
meshIndices
ªª 
=
ªª  !
mesh
ªª" &
.
ªª& '

GetIndices
ªª' 1
(
ªª1 2
$num
ªª2 3
)
ªª3 4
;
ªª4 5
{
ææ 
mesh
øø 
.
øø 
vertices
øø !
.
øø! "
CopyTo
øø" (
(
øø( )
vertices
øø) 1
,
øø1 2
vertexStart
øø3 >
)
øø> ?
;
øø? @
for
¡¡ 
(
¡¡ 
int
¡¡ 
i
¡¡ 
=
¡¡  
$num
¡¡! "
;
¡¡" #
i
¡¡$ %
<
¡¡& '
mesh
¡¡( ,
.
¡¡, -
vertices
¡¡- 5
.
¡¡5 6
Length
¡¡6 <
;
¡¡< =
i
¡¡> ?
++
¡¡? A
)
¡¡A B
vertices
¬¬  
[
¬¬  !
vertexStart
¬¬! ,
+
¬¬- .
i
¬¬/ 0
]
¬¬0 1
.
¬¬1 2
z
¬¬2 3
=
¬¬4 5
viewId
¬¬6 <
;
¬¬< =
}
√√ 
for
∆∆ 
(
∆∆ 
int
∆∆ 
i
∆∆ 
=
∆∆ 
$num
∆∆ 
;
∆∆ 
i
∆∆  !
<
∆∆" #
meshIndices
∆∆$ /
.
∆∆/ 0
Length
∆∆0 6
;
∆∆6 7
i
∆∆8 9
++
∆∆9 ;
)
∆∆; <
{
«« 
int
»» 
newIndex
»»  
=
»»! "
vertexStart
»»# .
+
»»/ 0
meshIndices
»»1 <
[
»»< =
i
»»= >
]
»»> ?
;
»»? @
Debug
…… 
.
…… 
Assert
……  
(
……  !
meshIndices
……! ,
[
……, -
i
……- .
]
……. /
<
……0 1
ushort
……2 8
.
……8 9
MaxValue
……9 A
)
……A B
;
……B C
indices
ÀÀ 
[
ÀÀ 

indexStart
ÀÀ &
+
ÀÀ' (
i
ÀÀ) *
]
ÀÀ* +
=
ÀÀ, -
(
ÀÀ. /
ushort
ÀÀ/ 5
)
ÀÀ5 6
newIndex
ÀÀ6 >
;
ÀÀ> ?
}
ÃÃ 
vertexStart
ŒŒ 
+=
ŒŒ 
mesh
ŒŒ #
.
ŒŒ# $
vertexCount
ŒŒ$ /
;
ŒŒ/ 0

indexStart
œœ 
+=
œœ 
meshIndices
œœ )
.
œœ) *
Length
œœ* 0
;
œœ0 1
}
–– #
occlusionMeshCombined
““ !
.
““! "
vertices
““" *
=
““+ ,
vertices
““- 5
;
““5 6#
occlusionMeshCombined
”” !
.
””! "

SetIndices
””" ,
(
””, -
indices
””- 4
,
””4 5
MeshTopology
””6 B
.
””B C
	Triangles
””C L
,
””L M
$num
””N O
)
””O P
;
””P Q
}
‘‘ 	
Vector4
÷÷ 
[
÷÷ 
]
÷÷ 
stereoEyeIndices
÷÷ "
=
÷÷# $
new
÷÷% (
Vector4
÷÷) 0
[
÷÷0 1
$num
÷÷1 2
]
÷÷2 3
{
÷÷4 5
Vector4
÷÷6 =
.
÷÷= >
zero
÷÷> B
,
÷÷C D
Vector4
÷÷E L
.
÷÷L M
one
÷÷M P
}
÷÷Q R
;
÷÷R S
internal
ÿÿ 
void
ÿÿ 
StartSinglePass
ÿÿ %
(
ÿÿ% &
CommandBuffer
ÿÿ& 3
cmd
ÿÿ4 7
)
ÿÿ7 8
{
ŸŸ 	
if
⁄⁄ 
(
⁄⁄ 
enabled
⁄⁄ 
)
⁄⁄ 
{
€€ 
if
‹‹ 
(
‹‹ 
singlePassEnabled
‹‹ %
)
‹‹% &
{
›› 
if
ﬁﬁ 
(
ﬁﬁ 
	viewCount
ﬁﬁ !
<=
ﬁﬁ" $
	TextureXR
ﬁﬁ% .
.
ﬁﬁ. /
slices
ﬁﬁ/ 5
)
ﬁﬁ5 6
{
ﬂﬂ 
if
‡‡ 
(
‡‡ 

SystemInfo
‡‡ &
.
‡‡& '
supportsMultiview
‡‡' 8
)
‡‡8 9
{
·· 
cmd
‚‚ 
.
‚‚  !
EnableShaderKeyword
‚‚  3
(
‚‚3 4
$str
‚‚4 I
)
‚‚I J
;
‚‚J K
cmd
„„ 
.
„„  "
SetGlobalVectorArray
„„  4
(
„„4 5
$str
„„5 M
,
„„M N
stereoEyeIndices
„„O _
)
„„_ `
;
„„` a
}
‰‰ 
else
ÂÂ 
{
ÊÊ 
cmd
ÁÁ 
.
ÁÁ  !
EnableShaderKeyword
ÁÁ  3
(
ÁÁ3 4
$str
ÁÁ4 J
)
ÁÁJ K
;
ÁÁK L
cmd
ËË 
.
ËË  #
SetInstanceMultiplier
ËË  5
(
ËË5 6
(
ËË6 7
uint
ËË7 ;
)
ËË; <
	viewCount
ËË< E
)
ËËE F
;
ËËF G
}
ÈÈ 
}
ÍÍ 
else
ÎÎ 
{
ÏÏ 
throw
ÌÌ 
new
ÌÌ !%
NotImplementedException
ÌÌ" 9
(
ÌÌ9 :
$"
ÌÌ: <a
RInvalid XR setup for single-pass, trying to render too many views! Max supported: ÌÌ< é
{ÌÌé è
	TextureXRÌÌè ò
.ÌÌò ô
slicesÌÌô ü
}ÌÌü †
"ÌÌ† °
)ÌÌ° ¢
;ÌÌ¢ £
}
ÓÓ 
}
ÔÔ 
}
 
}
ÒÒ 	
internal
ÛÛ 
void
ÛÛ 
StopSinglePass
ÛÛ $
(
ÛÛ$ %
CommandBuffer
ÛÛ% 2
cmd
ÛÛ3 6
)
ÛÛ6 7
{
ÙÙ 	
if
ıı 
(
ıı 
enabled
ıı 
)
ıı 
{
ˆˆ 
if
˜˜ 
(
˜˜ 
singlePassEnabled
˜˜ %
)
˜˜% &
{
¯¯ 
if
˘˘ 
(
˘˘ 

SystemInfo
˘˘ "
.
˘˘" #
supportsMultiview
˘˘# 4
)
˘˘4 5
{
˙˙ 
cmd
˚˚ 
.
˚˚ "
DisableShaderKeyword
˚˚ 0
(
˚˚0 1
$str
˚˚1 F
)
˚˚F G
;
˚˚G H
}
¸¸ 
else
˝˝ 
{
˛˛ 
cmd
ˇˇ 
.
ˇˇ "
DisableShaderKeyword
ˇˇ 0
(
ˇˇ0 1
$str
ˇˇ1 G
)
ˇˇG H
;
ˇˇH I
cmd
ÄÄ 
.
ÄÄ #
SetInstanceMultiplier
ÄÄ 1
(
ÄÄ1 2
$num
ÄÄ2 3
)
ÄÄ3 4
;
ÄÄ4 5
}
ÅÅ 
}
ÇÇ 
}
ÉÉ 
}
ÑÑ 	
internal
ÜÜ 
void
ÜÜ 
	EndCamera
ÜÜ 
(
ÜÜ  
CommandBuffer
ÜÜ  -
cmd
ÜÜ. 1
,
ÜÜ1 2

CameraData
ÜÜ3 =

cameraData
ÜÜ> H
)
ÜÜH I
{
áá 	
if
àà 
(
àà 
!
àà 
enabled
àà 
)
àà 
return
ââ 
;
ââ 
StopSinglePass
ãã 
(
ãã 
cmd
ãã 
)
ãã 
;
ãã  
if
éé 
(
éé 
customMirrorView
éé  
!=
éé! #
null
éé$ (
)
éé( )
{
èè 
using
êê 
(
êê 
new
êê 
ProfilingScope
êê )
(
êê) *
cmd
êê* -
,
êê- .-
_XRCustomMirrorProfilingSampler
êê/ N
)
êêN O
)
êêO P
{
ëë 
customMirrorView
íí $
(
íí$ %
this
íí% )
,
íí) *
cmd
íí+ .
,
íí. /

cameraData
íí0 :
.
íí: ;
targetTexture
íí; H
,
ííH I

cameraData
ííJ T
.
ííT U
	pixelRect
ííU ^
)
íí^ _
;
íí_ `
}
ìì 
}
îî 
}
ïï 	
internal
óó 
void
óó !
RenderOcclusionMesh
óó )
(
óó) *
CommandBuffer
óó* 7
cmd
óó8 ;
)
óó; <
{
òò 	
if
ôô 
(
ôô &
isOcclusionMeshSupported
ôô (
)
ôô( )
{
öö 
using
õõ 
(
õõ 
new
õõ 
ProfilingScope
õõ )
(
õõ) *
cmd
õõ* -
,
õõ- .*
_XROcclusionProfilingSampler
õõ/ K
)
õõK L
)
õõL M
{
úú 
if
ùù 
(
ùù 
singlePassEnabled
ùù )
)
ùù) *
{
ûû 
if
üü 
(
üü #
occlusionMeshCombined
üü 1
!=
üü2 4
null
üü5 9
&&
üü: <

SystemInfo
üü= G
.
üüG H<
.supportsRenderTargetArrayIndexFromVertexShader
üüH v
)
üüv w
{
†† 
StopSinglePass
°° *
(
°°* +
cmd
°°+ .
)
°°. /
;
°°/ 0
cmd
££ 
.
££  !
EnableShaderKeyword
££  3
(
££3 4
$str
££4 P
)
££P Q
;
££Q R
cmd
§§ 
.
§§  
DrawMesh
§§  (
(
§§( )#
occlusionMeshCombined
§§) >
,
§§> ?
	Matrix4x4
§§@ I
.
§§I J
identity
§§J R
,
§§R S#
occlusionMeshMaterial
§§T i
)
§§i j
;
§§j k
cmd
•• 
.
••  "
DisableShaderKeyword
••  4
(
••4 5
$str
••5 Q
)
••Q R
;
••R S
StartSinglePass
ßß +
(
ßß+ ,
cmd
ßß, /
)
ßß/ 0
;
ßß0 1
}
®® 
}
©© 
else
™™ 
if
™™ 
(
™™ 
views
™™ "
[
™™" #
$num
™™# $
]
™™$ %
.
™™% &
occlusionMesh
™™& 3
!=
™™4 6
null
™™7 ;
)
™™; <
{
´´ 
cmd
¨¨ 
.
¨¨ 
DrawMesh
¨¨ $
(
¨¨$ %
views
¨¨% *
[
¨¨* +
$num
¨¨+ ,
]
¨¨, -
.
¨¨- .
occlusionMesh
¨¨. ;
,
¨¨; <
	Matrix4x4
¨¨= F
.
¨¨F G
identity
¨¨G O
,
¨¨O P#
occlusionMeshMaterial
¨¨Q f
)
¨¨f g
;
¨¨g h
}
≠≠ 
}
ÆÆ 
}
ØØ 
}
∞∞ 	
private
≥≥ 
	Matrix4x4
≥≥ 
[
≥≥ 
]
≥≥ $
stereoProjectionMatrix
≥≥ 2
=
≥≥3 4
new
≥≥5 8
	Matrix4x4
≥≥9 B
[
≥≥B C
$num
≥≥C D
]
≥≥D E
;
≥≥E F
private
¥¥ 
	Matrix4x4
¥¥ 
[
¥¥ 
]
¥¥ 
stereoViewMatrix
¥¥ ,
=
¥¥- .
new
¥¥/ 2
	Matrix4x4
¥¥3 <
[
¥¥< =
$num
¥¥= >
]
¥¥> ?
;
¥¥? @
private
µµ 
	Matrix4x4
µµ 
[
µµ 
]
µµ *
stereoCameraProjectionMatrix
µµ 8
=
µµ9 :
new
µµ; >
	Matrix4x4
µµ? H
[
µµH I
$num
µµI J
]
µµJ K
;
µµK L
internal
∑∑ 
void
∑∑ 0
"UpdateGPUViewAndProjectionMatrices
∑∑ 8
(
∑∑8 9
CommandBuffer
∑∑9 F
cmd
∑∑G J
,
∑∑J K
ref
∑∑L O

CameraData
∑∑P Z

cameraData
∑∑[ e
,
∑∑e f
bool
∑∑g k
isRenderToTexture
∑∑l }
)
∑∑} ~
{
∏∏ 	
	Matrix4x4
ππ 
projectionMatrix
ππ &
=
ππ' (
GL
ππ) +
.
ππ+ ,$
GetGPUProjectionMatrix
ππ, B
(
ππB C

cameraData
ππC M
.
ππM N
xr
ππN P
.
ππP Q
GetProjMatrix
ππQ ^
(
ππ^ _
$num
ππ_ `
)
ππ` a
,
ππa b
isRenderToTexture
ππc t
)
ππt u
;
ππu v
RenderingUtils
∫∫ 
.
∫∫ *
SetViewAndProjectionMatrices
∫∫ 7
(
∫∫7 8
cmd
∫∫8 ;
,
∫∫; <

cameraData
∫∫= G
.
∫∫G H
xr
∫∫H J
.
∫∫J K
GetViewMatrix
∫∫K X
(
∫∫X Y
$num
∫∫Y Z
)
∫∫Z [
,
∫∫[ \
projectionMatrix
∫∫] m
,
∫∫m n
true
∫∫o s
)
∫∫s t
;
∫∫t u
if
ºº 
(
ºº 

cameraData
ºº 
.
ºº 
xr
ºº 
.
ºº 
singlePassEnabled
ºº /
)
ºº/ 0
{
ΩΩ 
for
ææ 
(
ææ 
int
ææ 
i
ææ 
=
ææ 
$num
ææ 
;
ææ 
i
ææ  !
<
ææ" #
$num
ææ$ %
;
ææ% &
i
ææ' (
++
ææ( *
)
ææ* +
{
øø *
stereoCameraProjectionMatrix
¿¿ 0
[
¿¿0 1
i
¿¿1 2
]
¿¿2 3
=
¿¿4 5

cameraData
¿¿6 @
.
¿¿@ A
xr
¿¿A C
.
¿¿C D
GetProjMatrix
¿¿D Q
(
¿¿Q R
i
¿¿R S
)
¿¿S T
;
¿¿T U
stereoViewMatrix
¡¡ $
[
¡¡$ %
i
¡¡% &
]
¡¡& '
=
¡¡( )

cameraData
¡¡* 4
.
¡¡4 5
xr
¡¡5 7
.
¡¡7 8
GetViewMatrix
¡¡8 E
(
¡¡E F
i
¡¡F G
)
¡¡G H
;
¡¡H I$
stereoProjectionMatrix
¬¬ *
[
¬¬* +
i
¬¬+ ,
]
¬¬, -
=
¬¬. /
GL
¬¬0 2
.
¬¬2 3$
GetGPUProjectionMatrix
¬¬3 I
(
¬¬I J*
stereoCameraProjectionMatrix
¬¬J f
[
¬¬f g
i
¬¬g h
]
¬¬h i
,
¬¬i j
isRenderToTexture
¬¬k |
)
¬¬| }
;
¬¬} ~
}
√√ 
RenderingUtils
ƒƒ 
.
ƒƒ 0
"SetStereoViewAndProjectionMatrices
ƒƒ A
(
ƒƒA B
cmd
ƒƒB E
,
ƒƒE F
stereoViewMatrix
ƒƒG W
,
ƒƒW X$
stereoProjectionMatrix
ƒƒY o
,
ƒƒo p+
stereoCameraProjectionMatrixƒƒq ç
,ƒƒç é
trueƒƒè ì
)ƒƒì î
;ƒƒî ï
}
≈≈ 
}
∆∆ 	
}
«« 
}»» û≥
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\ShadowUtils.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
struct5 ;
ShadowSliceData< K
{ 
public 
	Matrix4x4 

viewMatrix #
;# $
public		 
	Matrix4x4		 
projectionMatrix		 )
;		) *
public

 
	Matrix4x4

 
shadowTransform

 (
;

( )
public 
int 
offsetX 
; 
public 
int 
offsetY 
; 
public 
int 

resolution 
; 
public 
void 
Clear 
( 
) 
{ 	

viewMatrix 
= 
	Matrix4x4 "
." #
identity# +
;+ ,
projectionMatrix 
= 
	Matrix4x4 (
.( )
identity) 1
;1 2
shadowTransform 
= 
	Matrix4x4 '
.' (
identity( 0
;0 1
offsetX 
= 
offsetY 
= 
$num  !
;! "

resolution 
= 
$num 
; 
} 	
} 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
static5 ;
class< A
ShadowUtilsB M
{ 
private 
static 
readonly 
RenderTextureFormat  3
m_ShadowmapFormat4 E
;E F
private 
static 
readonly 
bool  $&
m_ForceShadowPointSampling% ?
;? @
static 
ShadowUtils 
( 
) 
{ 	
m_ShadowmapFormat   
=   
RenderingUtils    .
.  . /'
SupportsRenderTextureFormat  / J
(  J K
RenderTextureFormat  K ^
.  ^ _
	Shadowmap  _ h
)  h i
&&  j l
(  m n

SystemInfo  n x
.  x y
graphicsDeviceType	  y ã
!=
  å é 
GraphicsDeviceType
  è °
.
  ° ¢
	OpenGLES2
  ¢ ´
)
  ´ ¨
?!! 
RenderTextureFormat!! %
.!!% &
	Shadowmap!!& /
:"" 
RenderTextureFormat"" %
.""% &
Depth""& +
;""+ ,&
m_ForceShadowPointSampling## &
=##' (

SystemInfo##) 3
.##3 4
graphicsDeviceType##4 F
==##G I
GraphicsDeviceType##J \
.##\ ]
Metal##] b
&&##c e
GraphicsSettings$$  
.$$  !
HasShaderDefine$$! 0
($$0 1
Graphics$$1 9
.$$9 :

activeTier$$: D
,$$D E
BuiltinShaderDefine$$F Y
.$$Y Z4
'UNITY_METAL_SHADOWS_USE_POINT_FILTERING	$$Z Å
)
$$Å Ç
;
$$Ç É
}%% 	
public'' 
static'' 
bool'' )
ExtractDirectionalLightMatrix'' 8
(''8 9
ref''9 <
CullingResults''= K
cullResults''L W
,''W X
ref''Y \

ShadowData''] g

shadowData''h r
,''r s
int''t w
shadowLightIndex	''x à
,
''à â
int
''ä ç
cascadeIndex
''é ö
,
''ö õ
int
''ú ü
shadowmapWidth
''† Æ
,
''Æ Ø
int
''∞ ≥
shadowmapHeight
''¥ √
,
''√ ƒ
int
''≈ »
shadowResolution
''… Ÿ
,
''Ÿ ⁄
float
''€ ‡
shadowNearPlane
''· 
,
'' Ò
out
''Ú ı
Vector4
''ˆ ˝"
cascadeSplitDistance
''˛ í
,
''í ì
out
''î ó
ShadowSliceData
''ò ß
shadowSliceData
''® ∑
,
''∑ ∏
out
''π º
	Matrix4x4
''Ω ∆

viewMatrix
''« —
,
''— “
out
''” ÷
	Matrix4x4
''◊ ‡

projMatrix
''· Î
)
''Î Ï
{(( 	
ShadowSplitData)) 
	splitData)) %
;))% &
bool** 
success** 
=** 
cullResults** &
.**& '@
4ComputeDirectionalShadowMatricesAndCullingPrimitives**' [
(**[ \
shadowLightIndex**\ l
,**l m
cascadeIndex++ 
,++ 

shadowData++ (
.++( )(
mainLightShadowCascadesCount++) E
,++E F

shadowData++G Q
.++Q R(
mainLightShadowCascadesSplit++R n
,++n o
shadowResolution	++p Ä
,
++Ä Å
shadowNearPlane
++Ç ë
,
++ë í
out
++ì ñ

viewMatrix
++ó °
,
++° ¢
out
++£ ¶

projMatrix
++ß ±
,
++± ≤
out,, 
	splitData,, 
),, 
;,,  
cascadeSplitDistance..  
=..! "
	splitData..# ,
..., -
cullingSphere..- :
;..: ;
shadowSliceData// 
.// 
offsetX// #
=//$ %
(//& '
cascadeIndex//' 3
%//4 5
$num//6 7
)//7 8
*//9 :
shadowResolution//; K
;//K L
shadowSliceData00 
.00 
offsetY00 #
=00$ %
(00& '
cascadeIndex00' 3
/004 5
$num006 7
)007 8
*009 :
shadowResolution00; K
;00K L
shadowSliceData11 
.11 

resolution11 &
=11' (
shadowResolution11) 9
;119 :
shadowSliceData22 
.22 

viewMatrix22 &
=22' (

viewMatrix22) 3
;223 4
shadowSliceData33 
.33 
projectionMatrix33 ,
=33- .

projMatrix33/ 9
;339 :
shadowSliceData44 
.44 
shadowTransform44 +
=44, -
GetShadowTransform44. @
(44@ A

projMatrix44A K
,44K L

viewMatrix44M W
)44W X
;44X Y
if88 
(88 

shadowData88 
.88 (
mainLightShadowCascadesCount88 7
>888 9
$num88: ;
)88; <
ApplySliceTransform99 #
(99# $
ref99$ '
shadowSliceData99( 7
,997 8
shadowmapWidth999 G
,99G H
shadowmapHeight99I X
)99X Y
;99Y Z
return;; 
success;; 
;;; 
}<< 	
public>> 
static>> 
bool>> "
ExtractSpotLightMatrix>> 1
(>>1 2
ref>>2 5
CullingResults>>6 D
cullResults>>E P
,>>P Q
ref>>R U

ShadowData>>V `

shadowData>>a k
,>>k l
int>>m p
shadowLightIndex	>>q Å
,
>>Å Ç
out
>>É Ü
	Matrix4x4
>>á ê
shadowMatrix
>>ë ù
,
>>ù û
out
>>ü ¢
	Matrix4x4
>>£ ¨

viewMatrix
>>≠ ∑
,
>>∑ ∏
out
>>π º
	Matrix4x4
>>Ω ∆

projMatrix
>>« —
)
>>— “
{?? 	
ShadowSplitData@@ 
	splitData@@ %
;@@% &
boolAA 
successAA 
=AA 
cullResultsAA &
.AA& '9
-ComputeSpotShadowMatricesAndCullingPrimitivesAA' T
(AAT U
shadowLightIndexAAU e
,AAe f
outAAg j

viewMatrixAAk u
,AAu v
outAAw z

projMatrix	AA{ Ö
,
AAÖ Ü
out
AAá ä
	splitData
AAã î
)
AAî ï
;
AAï ñ
shadowMatrixBB 
=BB 
GetShadowTransformBB -
(BB- .

projMatrixBB. 8
,BB8 9

viewMatrixBB: D
)BBD E
;BBE F
returnCC 
successCC 
;CC 
}DD 	
publicFF 
staticFF 
voidFF 
RenderShadowSliceFF ,
(FF, -
CommandBufferFF- :
cmdFF; >
,FF> ?
refFF@ C#
ScriptableRenderContextFFD [
contextFF\ c
,FFc d
refGG 
ShadowSliceDataGG 
shadowSliceDataGG  /
,GG/ 0
refGG1 4!
ShadowDrawingSettingsGG5 J
settingsGGK S
,GGS T
	Matrix4x4HH 
projHH 
,HH 
	Matrix4x4HH %
viewHH& *
)HH* +
{II 	
cmdJJ 
.JJ 
SetViewportJJ 
(JJ 
newJJ 
RectJJ  $
(JJ$ %
shadowSliceDataJJ% 4
.JJ4 5
offsetXJJ5 <
,JJ< =
shadowSliceDataJJ> M
.JJM N
offsetYJJN U
,JJU V
shadowSliceDataJJW f
.JJf g

resolutionJJg q
,JJq r
shadowSliceData	JJs Ç
.
JJÇ É

resolution
JJÉ ç
)
JJç é
)
JJé è
;
JJè ê
cmdKK 
.KK %
SetViewProjectionMatricesKK )
(KK) *
viewKK* .
,KK. /
projKK0 4
)KK4 5
;KK5 6
contextLL 
.LL  
ExecuteCommandBufferLL (
(LL( )
cmdLL) ,
)LL, -
;LL- .
cmdMM 
.MM 
ClearMM 
(MM 
)MM 
;MM 
contextNN 
.NN 
DrawShadowsNN 
(NN  
refNN  #
settingsNN$ ,
)NN, -
;NN- .
cmdOO 
.OO 
DisableScissorRectOO "
(OO" #
)OO# $
;OO$ %
contextPP 
.PP  
ExecuteCommandBufferPP (
(PP( )
cmdPP) ,
)PP, -
;PP- .
cmdQQ 
.QQ 
ClearQQ 
(QQ 
)QQ 
;QQ 
}RR 	
publicTT 
staticTT 
voidTT 
RenderShadowSliceTT ,
(TT, -
CommandBufferTT- :
cmdTT; >
,TT> ?
refTT@ C#
ScriptableRenderContextTTD [
contextTT\ c
,TTc d
refUU 
ShadowSliceDataUU 
shadowSliceDataUU  /
,UU/ 0
refUU1 4!
ShadowDrawingSettingsUU5 J
settingsUUK S
)UUS T
{VV 	
RenderShadowSliceWW 
(WW 
cmdWW !
,WW! "
refWW# &
contextWW' .
,WW. /
refWW0 3
shadowSliceDataWW4 C
,WWC D
refWWE H
settingsWWI Q
,WWQ R
shadowSliceDataXX 
.XX  
projectionMatrixXX  0
,XX0 1
shadowSliceDataXX2 A
.XXA B

viewMatrixXXB L
)XXL M
;XXM N
}YY 	
public[[ 
static[[ 
int[[ '
GetMaxTileResolutionInAtlas[[ 5
([[5 6
int[[6 9

atlasWidth[[: D
,[[D E
int[[F I
atlasHeight[[J U
,[[U V
int[[W Z
	tileCount[[[ d
)[[d e
{\\ 	
int]] 

resolution]] 
=]] 
Mathf]] "
.]]" #
Min]]# &
(]]& '

atlasWidth]]' 1
,]]1 2
atlasHeight]]3 >
)]]> ?
;]]? @
int^^ 
currentTileCount^^  
=^^! "

atlasWidth^^# -
/^^. /

resolution^^0 :
*^^; <
atlasHeight^^= H
/^^I J

resolution^^K U
;^^U V
while__ 
(__ 
currentTileCount__ #
<__$ %
	tileCount__& /
)__/ 0
{`` 

resolutionaa 
=aa 

resolutionaa '
>>aa( *
$numaa+ ,
;aa, -
currentTileCountbb  
=bb! "

atlasWidthbb# -
/bb. /

resolutionbb0 :
*bb; <
atlasHeightbb= H
/bbI J

resolutionbbK U
;bbU V
}cc 
returndd 

resolutiondd 
;dd 
}ee 	
publicgg 
staticgg 
voidgg 
ApplySliceTransformgg .
(gg. /
refgg/ 2
ShadowSliceDatagg3 B
shadowSliceDataggC R
,ggR S
intggT W

atlasWidthggX b
,ggb c
intggd g
atlasHeightggh s
)ggs t
{hh 	
	Matrix4x4ii 
sliceTransformii $
=ii% &
	Matrix4x4ii' 0
.ii0 1
identityii1 9
;ii9 :
floatjj 
oneOverAtlasWidthjj #
=jj$ %
$numjj& *
/jj+ ,

atlasWidthjj- 7
;jj7 8
floatkk 
oneOverAtlasHeightkk $
=kk% &
$numkk' +
/kk, -
atlasHeightkk. 9
;kk9 :
sliceTransformll 
.ll 
m00ll 
=ll  
shadowSliceDatall! 0
.ll0 1

resolutionll1 ;
*ll< =
oneOverAtlasWidthll> O
;llO P
sliceTransformmm 
.mm 
m11mm 
=mm  
shadowSliceDatamm! 0
.mm0 1

resolutionmm1 ;
*mm< =
oneOverAtlasHeightmm> P
;mmP Q
sliceTransformnn 
.nn 
m03nn 
=nn  
shadowSliceDatann! 0
.nn0 1
offsetXnn1 8
*nn9 :
oneOverAtlasWidthnn; L
;nnL M
sliceTransformoo 
.oo 
m13oo 
=oo  
shadowSliceDataoo! 0
.oo0 1
offsetYoo1 8
*oo9 :
oneOverAtlasHeightoo; M
;ooM N
shadowSliceDatarr 
.rr 
shadowTransformrr +
=rr, -
sliceTransformrr. <
*rr= >
shadowSliceDatarr? N
.rrN O
shadowTransformrrO ^
;rr^ _
}ss 	
publicuu 
staticuu 
Vector4uu 
GetShadowBiasuu +
(uu+ ,
refuu, /
VisibleLightuu0 <
shadowLightuu= H
,uuH I
intuuJ M
shadowLightIndexuuN ^
,uu^ _
refuu` c

ShadowDatauud n

shadowDatauuo y
,uuy z
	Matrix4x4	uu{ Ñ#
lightProjectionMatrix
uuÖ ö
,
uuö õ
float
uuú °
shadowResolution
uu¢ ≤
)
uu≤ ≥
{vv 	
ifww 
(ww 
shadowLightIndexww  
<ww! "
$numww# $
||ww% '
shadowLightIndexww( 8
>=ww9 ;

shadowDataww< F
.wwF G
biaswwG K
.wwK L
CountwwL Q
)wwQ R
{xx 
Debugyy 
.yy 

LogWarningyy  
(yy  !
stringyy! '
.yy' (
Formatyy( .
(yy. /
$stryy/ P
,yyP Q
shadowLightIndexyyR b
)yyb c
)yyc d
;yyd e
returnzz 
Vector4zz 
.zz 
zerozz #
;zz# $
}{{ 
float}} 
frustumSize}} 
;}} 
if~~ 
(~~ 
shadowLight~~ 
.~~ 
	lightType~~ %
==~~& (
	LightType~~) 2
.~~2 3
Directional~~3 >
)~~> ?
{ 
frustumSize
ÅÅ 
=
ÅÅ 
$num
ÅÅ "
/
ÅÅ# $#
lightProjectionMatrix
ÅÅ% :
.
ÅÅ: ;
m00
ÅÅ; >
;
ÅÅ> ?
}
ÇÇ 
else
ÉÉ 
if
ÉÉ 
(
ÉÉ 
shadowLight
ÉÉ  
.
ÉÉ  !
	lightType
ÉÉ! *
==
ÉÉ+ -
	LightType
ÉÉ. 7
.
ÉÉ7 8
Spot
ÉÉ8 <
)
ÉÉ< =
{
ÑÑ 
frustumSize
ãã 
=
ãã 
Mathf
ãã #
.
ãã# $
Tan
ãã$ '
(
ãã' (
shadowLight
ãã( 3
.
ãã3 4
	spotAngle
ãã4 =
*
ãã> ?
$num
ãã@ D
*
ããE F
Mathf
ããG L
.
ããL M
Deg2Rad
ããM T
)
ããT U
*
ããV W
shadowLight
ããX c
.
ããc d
range
ããd i
;
ããi j
}
åå 
else
çç 
{
éé 
Debug
èè 
.
èè 

LogWarning
èè  
(
èè  !
$str
èè! o
)
èèo p
;
èèp q
frustumSize
êê 
=
êê 
$num
êê "
;
êê" #
}
ëë 
float
îî 
	texelSize
îî 
=
îî 
frustumSize
îî )
/
îî* +
shadowResolution
îî, <
;
îî< =
float
ïï 
	depthBias
ïï 
=
ïï 
-
ïï 

shadowData
ïï )
.
ïï) *
bias
ïï* .
[
ïï. /
shadowLightIndex
ïï/ ?
]
ïï? @
.
ïï@ A
x
ïïA B
*
ïïC D
	texelSize
ïïE N
;
ïïN O
float
ññ 

normalBias
ññ 
=
ññ 
-
ññ  

shadowData
ññ  *
.
ññ* +
bias
ññ+ /
[
ññ/ 0
shadowLightIndex
ññ0 @
]
ññ@ A
.
ññA B
y
ññB C
*
ññD E
	texelSize
ññF O
;
ññO P
if
òò 
(
òò 

shadowData
òò 
.
òò !
supportsSoftShadows
òò .
)
òò. /
{
ôô 
const
üü 
float
üü 
kernelRadius
üü (
=
üü) *
$num
üü+ /
;
üü/ 0
	depthBias
†† 
*=
†† 
kernelRadius
†† )
;
††) *

normalBias
°° 
*=
°° 
kernelRadius
°° *
;
°°* +
}
¢¢ 
return
§§ 
new
§§ 
Vector4
§§ 
(
§§ 
	depthBias
§§ (
,
§§( )

normalBias
§§* 4
,
§§4 5
$num
§§6 :
,
§§: ;
$num
§§< @
)
§§@ A
;
§§A B
}
•• 	
public
ßß 
static
ßß 
void
ßß -
SetupShadowCasterConstantBuffer
ßß :
(
ßß: ;
CommandBuffer
ßß; H
cmd
ßßI L
,
ßßL M
ref
ßßN Q
VisibleLight
ßßR ^
shadowLight
ßß_ j
,
ßßj k
Vector4
ßßl s

shadowBias
ßßt ~
)
ßß~ 
{
®® 	
Vector3
©© 
lightDirection
©© "
=
©©# $
-
©©% &
shadowLight
©©& 1
.
©©1 2 
localToWorldMatrix
©©2 D
.
©©D E
	GetColumn
©©E N
(
©©N O
$num
©©O P
)
©©P Q
;
©©Q R
cmd
™™ 
.
™™ 
SetGlobalVector
™™ 
(
™™  
$str
™™  -
,
™™- .

shadowBias
™™/ 9
)
™™9 :
;
™™: ;
cmd
´´ 
.
´´ 
SetGlobalVector
´´ 
(
´´  
$str
´´  1
,
´´1 2
new
´´3 6
Vector4
´´7 >
(
´´> ?
lightDirection
´´? M
.
´´M N
x
´´N O
,
´´O P
lightDirection
´´Q _
.
´´_ `
y
´´` a
,
´´a b
lightDirection
´´c q
.
´´q r
z
´´r s
,
´´s t
$num
´´u y
)
´´y z
)
´´z {
;
´´{ |
}
¨¨ 	
public
ÆÆ 
static
ÆÆ 
RenderTexture
ÆÆ #'
GetTemporaryShadowTexture
ÆÆ$ =
(
ÆÆ= >
int
ÆÆ> A
width
ÆÆB G
,
ÆÆG H
int
ÆÆI L
height
ÆÆM S
,
ÆÆS T
int
ÆÆU X
bits
ÆÆY ]
)
ÆÆ] ^
{
ØØ 	
var
∞∞ 
shadowTexture
∞∞ 
=
∞∞ 
RenderTexture
∞∞  -
.
∞∞- .
GetTemporary
∞∞. :
(
∞∞: ;
width
∞∞; @
,
∞∞@ A
height
∞∞B H
,
∞∞H I
bits
∞∞J N
,
∞∞N O
m_ShadowmapFormat
∞∞P a
)
∞∞a b
;
∞∞b c
shadowTexture
±± 
.
±± 

filterMode
±± $
=
±±% &(
m_ForceShadowPointSampling
±±' A
?
±±B C

FilterMode
±±D N
.
±±N O
Point
±±O T
:
±±U V

FilterMode
±±W a
.
±±a b
Bilinear
±±b j
;
±±j k
shadowTexture
≤≤ 
.
≤≤ 
wrapMode
≤≤ "
=
≤≤# $
TextureWrapMode
≤≤% 4
.
≤≤4 5
Clamp
≤≤5 :
;
≤≤: ;
return
¥¥ 
shadowTexture
¥¥  
;
¥¥  !
}
µµ 	
static
∑∑ 
	Matrix4x4
∑∑  
GetShadowTransform
∑∑ +
(
∑∑+ ,
	Matrix4x4
∑∑, 5
proj
∑∑6 :
,
∑∑: ;
	Matrix4x4
∑∑< E
view
∑∑F J
)
∑∑J K
{
∏∏ 	
if
ªª 
(
ªª 

SystemInfo
ªª 
.
ªª !
usesReversedZBuffer
ªª .
)
ªª. /
{
ºº 
proj
ΩΩ 
.
ΩΩ 
m20
ΩΩ 
=
ΩΩ 
-
ΩΩ 
proj
ΩΩ  
.
ΩΩ  !
m20
ΩΩ! $
;
ΩΩ$ %
proj
ææ 
.
ææ 
m21
ææ 
=
ææ 
-
ææ 
proj
ææ  
.
ææ  !
m21
ææ! $
;
ææ$ %
proj
øø 
.
øø 
m22
øø 
=
øø 
-
øø 
proj
øø  
.
øø  !
m22
øø! $
;
øø$ %
proj
¿¿ 
.
¿¿ 
m23
¿¿ 
=
¿¿ 
-
¿¿ 
proj
¿¿  
.
¿¿  !
m23
¿¿! $
;
¿¿$ %
}
¡¡ 
	Matrix4x4
√√ 
worldToShadow
√√ #
=
√√$ %
proj
√√& *
*
√√+ ,
view
√√- 1
;
√√1 2
var
≈≈ !
textureScaleAndBias
≈≈ #
=
≈≈$ %
	Matrix4x4
≈≈& /
.
≈≈/ 0
identity
≈≈0 8
;
≈≈8 9!
textureScaleAndBias
∆∆ 
.
∆∆  
m00
∆∆  #
=
∆∆$ %
$num
∆∆& *
;
∆∆* +!
textureScaleAndBias
«« 
.
««  
m11
««  #
=
««$ %
$num
««& *
;
««* +!
textureScaleAndBias
»» 
.
»»  
m22
»»  #
=
»»$ %
$num
»»& *
;
»»* +!
textureScaleAndBias
…… 
.
……  
m03
……  #
=
……$ %
$num
……& *
;
……* +!
textureScaleAndBias
   
.
    
m23
    #
=
  $ %
$num
  & *
;
  * +!
textureScaleAndBias
ÀÀ 
.
ÀÀ  
m13
ÀÀ  #
=
ÀÀ$ %
$num
ÀÀ& *
;
ÀÀ* +
return
ŒŒ !
textureScaleAndBias
ŒŒ &
*
ŒŒ' (
worldToShadow
ŒŒ) 6
;
ŒŒ6 7
}
œœ 	
}
–– 
}—— ñ‹
®D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\External\LibTessDotNet\Tess.cs
	namespace%% 	
UnityEngine%%
 
.%% 
Experimental%% "
.%%" #
	Rendering%%# ,
.%%, -
	Universal%%- 6
{&& 
	namespace)) 	
LibTessDotNet))
 
{** 
internal++ 
enum++ 
WindingRule++ 
{,, 
EvenOdd-- 
,-- 
NonZero.. 
,.. 
Positive// 
,// 
Negative00 
,00 
	AbsGeqTwo11 
}22 
internal44 
enum44 
ElementType44 
{55 
Polygons66 
,66 
ConnectedPolygons77 
,77 
BoundaryContours88 
}99 
internal;; 
enum;; 
ContourOrientation;; $
{<< 
Original== 
,== 
	Clockwise>> 
,>> 
CounterClockwise?? 
}@@ 
internalBB 
structBB 
ContourVertexBB !
{CC 
publicDD 
Vec3DD 
PositionDD 
;DD 
publicEE 
objectEE 
DataEE 
;EE 
publicGG 
overrideGG 
stringGG 
ToStringGG '
(GG' (
)GG( )
{HH 	
returnII 
stringII 
.II 
FormatII  
(II  !
$strII! +
,II+ ,
PositionII- 5
,II5 6
DataII7 ;
)II; <
;II< =
}JJ 	
}KK 
internalMM 
delegateMM 
objectMM 
CombineCallbackMM ,
(MM, -
Vec3MM- 1
positionMM2 :
,MM: ;
objectMM< B
[MMB C
]MMC D
dataMME I
,MMI J
RealMMK O
[MMO P
]MMP Q
weightsMMR Y
)MMY Z
;MMZ [
internalOO 
partialOO 
classOO 
TessOO 
{PP 
privateQQ 
MeshQQ 
_meshQQ 
;QQ 
privateRR 
Vec3RR 
_normalRR 
;RR 
privateSS 
Vec3SS 
_sUnitSS 
;SS 
privateTT 
Vec3TT 
_tUnitTT 
;TT 
privateVV 
RealVV 
_bminXVV 
,VV 
_bminYVV #
,VV# $
_bmaxXVV% +
,VV+ ,
_bmaxYVV- 3
;VV3 4
privateXX 
WindingRuleXX 
_windingRuleXX (
;XX( )
privateZZ 
DictZZ 
<ZZ 
ActiveRegionZZ !
>ZZ! "
_dictZZ# (
;ZZ( )
private[[ 
PriorityQueue[[ 
<[[ 
	MeshUtils[[ '
.[[' (
Vertex[[( .
>[[. /
_pq[[0 3
;[[3 4
private\\ 
	MeshUtils\\ 
.\\ 
Vertex\\  
_event\\! '
;\\' (
private^^ 
CombineCallback^^ 
_combineCallback^^  0
;^^0 1
private`` 
ContourVertex`` 
[`` 
]`` 
	_vertices``  )
;``) *
privateaa 
intaa 
_vertexCountaa  
;aa  !
privatebb 
intbb 
[bb 
]bb 
	_elementsbb 
;bb  
privatecc 
intcc 
_elementCountcc !
;cc! "
publicee 
Vec3ee 
Normalee 
{ee 
getee  
{ee! "
returnee# )
_normalee* 1
;ee1 2
}ee3 4
setee5 8
{ee9 :
_normalee; B
=eeC D
valueeeE J
;eeJ K
}eeL M
}eeN O
publicgg 
Realgg 
SUnitXgg 
=gg 
$numgg 
;gg 
publichh 
Realhh 
SUnitYhh 
=hh 
$numhh 
;hh 
publicll 
Realll 
SentinelCoordll !
=ll" #
$numll$ )
;ll) *
publicrr 
boolrr 
NoEmptyPolygonsrr #
=rr$ %
falserr& +
;rr+ ,
publicww 
boolww 

UsePoolingww 
=ww  
falseww! &
;ww& '
publicyy 
ContourVertexyy 
[yy 
]yy 
Verticesyy '
{yy( )
getyy* -
{yy. /
returnyy0 6
	_verticesyy7 @
;yy@ A
}yyB C
}yyD E
publiczz 
intzz 
VertexCountzz 
{zz  
getzz! $
{zz% &
returnzz' -
_vertexCountzz. :
;zz: ;
}zz< =
}zz> ?
public|| 
int|| 
[|| 
]|| 
Elements|| 
{|| 
get||  #
{||$ %
return||& ,
	_elements||- 6
;||6 7
}||8 9
}||: ;
public}} 
int}} 
ElementCount}} 
{}}  !
get}}" %
{}}& '
return}}( .
_elementCount}}/ <
;}}< =
}}}> ?
}}}@ A
public 
Tess 
( 
) 
{
ÄÄ 	
_normal
ÅÅ 
=
ÅÅ 
Vec3
ÅÅ 
.
ÅÅ 
Zero
ÅÅ 
;
ÅÅ  
_bminX
ÇÇ 
=
ÇÇ 
_bminY
ÇÇ 
=
ÇÇ 
_bmaxX
ÇÇ $
=
ÇÇ% &
_bmaxY
ÇÇ' -
=
ÇÇ. /
$num
ÇÇ0 1
;
ÇÇ1 2
_windingRule
ÑÑ 
=
ÑÑ 
WindingRule
ÑÑ &
.
ÑÑ& '
EvenOdd
ÑÑ' .
;
ÑÑ. /
_mesh
ÖÖ 
=
ÖÖ 
null
ÖÖ 
;
ÖÖ 
	_vertices
áá 
=
áá 
null
áá 
;
áá 
_vertexCount
àà 
=
àà 
$num
àà 
;
àà 
	_elements
ââ 
=
ââ 
null
ââ 
;
ââ 
_elementCount
ää 
=
ää 
$num
ää 
;
ää 
}
ãã 	
private
çç 
void
çç 
ComputeNormal
çç "
(
çç" #
ref
çç# &
Vec3
çç' +
norm
çç, 0
)
çç0 1
{
éé 	
var
èè 
v
èè 
=
èè 
_mesh
èè 
.
èè 
_vHead
èè  
.
èè  !
_next
èè! &
;
èè& '
var
ëë 
minVal
ëë 
=
ëë 
new
ëë 
Real
ëë !
[
ëë! "
$num
ëë" #
]
ëë# $
{
ëë% &
v
ëë' (
.
ëë( )
_coords
ëë) 0
.
ëë0 1
X
ëë1 2
,
ëë2 3
v
ëë4 5
.
ëë5 6
_coords
ëë6 =
.
ëë= >
Y
ëë> ?
,
ëë? @
v
ëëA B
.
ëëB C
_coords
ëëC J
.
ëëJ K
Z
ëëK L
}
ëëM N
;
ëëN O
var
íí 
minVert
íí 
=
íí 
new
íí 
	MeshUtils
íí '
.
íí' (
Vertex
íí( .
[
íí. /
$num
íí/ 0
]
íí0 1
{
íí2 3
v
íí4 5
,
íí5 6
v
íí7 8
,
íí8 9
v
íí: ;
}
íí< =
;
íí= >
var
ìì 
maxVal
ìì 
=
ìì 
new
ìì 
Real
ìì !
[
ìì! "
$num
ìì" #
]
ìì# $
{
ìì% &
v
ìì' (
.
ìì( )
_coords
ìì) 0
.
ìì0 1
X
ìì1 2
,
ìì2 3
v
ìì4 5
.
ìì5 6
_coords
ìì6 =
.
ìì= >
Y
ìì> ?
,
ìì? @
v
ììA B
.
ììB C
_coords
ììC J
.
ììJ K
Z
ììK L
}
ììM N
;
ììN O
var
îî 
maxVert
îî 
=
îî 
new
îî 
	MeshUtils
îî '
.
îî' (
Vertex
îî( .
[
îî. /
$num
îî/ 0
]
îî0 1
{
îî2 3
v
îî4 5
,
îî5 6
v
îî7 8
,
îî8 9
v
îî: ;
}
îî< =
;
îî= >
for
ññ 
(
ññ 
;
ññ 
v
ññ 
!=
ññ 
_mesh
ññ 
.
ññ 
_vHead
ññ $
;
ññ$ %
v
ññ& '
=
ññ( )
v
ññ* +
.
ññ+ ,
_next
ññ, 1
)
ññ1 2
{
óó 
if
òò 
(
òò 
v
òò 
.
òò 
_coords
òò 
.
òò 
X
òò 
<
òò  !
minVal
òò" (
[
òò( )
$num
òò) *
]
òò* +
)
òò+ ,
{
òò- .
minVal
òò/ 5
[
òò5 6
$num
òò6 7
]
òò7 8
=
òò9 :
v
òò; <
.
òò< =
_coords
òò= D
.
òòD E
X
òòE F
;
òòF G
minVert
òòH O
[
òòO P
$num
òòP Q
]
òòQ R
=
òòS T
v
òòU V
;
òòV W
}
òòX Y
if
ôô 
(
ôô 
v
ôô 
.
ôô 
_coords
ôô 
.
ôô 
Y
ôô 
<
ôô  !
minVal
ôô" (
[
ôô( )
$num
ôô) *
]
ôô* +
)
ôô+ ,
{
ôô- .
minVal
ôô/ 5
[
ôô5 6
$num
ôô6 7
]
ôô7 8
=
ôô9 :
v
ôô; <
.
ôô< =
_coords
ôô= D
.
ôôD E
Y
ôôE F
;
ôôF G
minVert
ôôH O
[
ôôO P
$num
ôôP Q
]
ôôQ R
=
ôôS T
v
ôôU V
;
ôôV W
}
ôôX Y
if
öö 
(
öö 
v
öö 
.
öö 
_coords
öö 
.
öö 
Z
öö 
<
öö  !
minVal
öö" (
[
öö( )
$num
öö) *
]
öö* +
)
öö+ ,
{
öö- .
minVal
öö/ 5
[
öö5 6
$num
öö6 7
]
öö7 8
=
öö9 :
v
öö; <
.
öö< =
_coords
öö= D
.
ööD E
Z
ööE F
;
ööF G
minVert
ööH O
[
ööO P
$num
ööP Q
]
ööQ R
=
ööS T
v
ööU V
;
ööV W
}
ööX Y
if
õõ 
(
õõ 
v
õõ 
.
õõ 
_coords
õõ 
.
õõ 
X
õõ 
>
õõ  !
maxVal
õõ" (
[
õõ( )
$num
õõ) *
]
õõ* +
)
õõ+ ,
{
õõ- .
maxVal
õõ/ 5
[
õõ5 6
$num
õõ6 7
]
õõ7 8
=
õõ9 :
v
õõ; <
.
õõ< =
_coords
õõ= D
.
õõD E
X
õõE F
;
õõF G
maxVert
õõH O
[
õõO P
$num
õõP Q
]
õõQ R
=
õõS T
v
õõU V
;
õõV W
}
õõX Y
if
úú 
(
úú 
v
úú 
.
úú 
_coords
úú 
.
úú 
Y
úú 
>
úú  !
maxVal
úú" (
[
úú( )
$num
úú) *
]
úú* +
)
úú+ ,
{
úú- .
maxVal
úú/ 5
[
úú5 6
$num
úú6 7
]
úú7 8
=
úú9 :
v
úú; <
.
úú< =
_coords
úú= D
.
úúD E
Y
úúE F
;
úúF G
maxVert
úúH O
[
úúO P
$num
úúP Q
]
úúQ R
=
úúS T
v
úúU V
;
úúV W
}
úúX Y
if
ùù 
(
ùù 
v
ùù 
.
ùù 
_coords
ùù 
.
ùù 
Z
ùù 
>
ùù  !
maxVal
ùù" (
[
ùù( )
$num
ùù) *
]
ùù* +
)
ùù+ ,
{
ùù- .
maxVal
ùù/ 5
[
ùù5 6
$num
ùù6 7
]
ùù7 8
=
ùù9 :
v
ùù; <
.
ùù< =
_coords
ùù= D
.
ùùD E
Z
ùùE F
;
ùùF G
maxVert
ùùH O
[
ùùO P
$num
ùùP Q
]
ùùQ R
=
ùùS T
v
ùùU V
;
ùùV W
}
ùùX Y
}
ûû 
int
¢¢ 
i
¢¢ 
=
¢¢ 
$num
¢¢ 
;
¢¢ 
if
££ 
(
££ 
maxVal
££ 
[
££ 
$num
££ 
]
££ 
-
££ 
minVal
££ "
[
££" #
$num
££# $
]
££$ %
>
££& '
maxVal
££( .
[
££. /
$num
££/ 0
]
££0 1
-
££2 3
minVal
££4 :
[
££: ;
$num
££; <
]
££< =
)
££= >
{
££? @
i
££A B
=
££C D
$num
££E F
;
££F G
}
££H I
if
§§ 
(
§§ 
maxVal
§§ 
[
§§ 
$num
§§ 
]
§§ 
-
§§ 
minVal
§§ "
[
§§" #
$num
§§# $
]
§§$ %
>
§§& '
maxVal
§§( .
[
§§. /
i
§§/ 0
]
§§0 1
-
§§2 3
minVal
§§4 :
[
§§: ;
i
§§; <
]
§§< =
)
§§= >
{
§§? @
i
§§A B
=
§§C D
$num
§§E F
;
§§F G
}
§§H I
if
•• 
(
•• 
minVal
•• 
[
•• 
i
•• 
]
•• 
>=
•• 
maxVal
•• #
[
••# $
i
••$ %
]
••% &
)
••& '
{
¶¶ 
norm
®® 
=
®® 
new
®® 
Vec3
®® 
{
®®  !
X
®®" #
=
®®$ %
$num
®®& '
,
®®' (
Y
®®) *
=
®®+ ,
$num
®®- .
,
®®. /
Z
®®0 1
=
®®2 3
$num
®®4 5
}
®®6 7
;
®®7 8
return
©© 
;
©© 
}
™™ 
Real
ÆÆ 
maxLen2
ÆÆ 
=
ÆÆ 
$num
ÆÆ 
,
ÆÆ 
tLen2
ÆÆ #
;
ÆÆ# $
var
ØØ 
v1
ØØ 
=
ØØ 
minVert
ØØ 
[
ØØ 
i
ØØ 
]
ØØ 
;
ØØ  
var
∞∞ 
v2
∞∞ 
=
∞∞ 
maxVert
∞∞ 
[
∞∞ 
i
∞∞ 
]
∞∞ 
;
∞∞  
Vec3
±± 
d1
±± 
,
±± 
d2
±± 
,
±± 
tNorm
±± 
;
±± 
Vec3
≤≤ 
.
≤≤ 
Sub
≤≤ 
(
≤≤ 
ref
≤≤ 
v1
≤≤ 
.
≤≤ 
_coords
≤≤ #
,
≤≤# $
ref
≤≤% (
v2
≤≤) +
.
≤≤+ ,
_coords
≤≤, 3
,
≤≤3 4
out
≤≤5 8
d1
≤≤9 ;
)
≤≤; <
;
≤≤< =
for
≥≥ 
(
≥≥ 
v
≥≥ 
=
≥≥ 
_mesh
≥≥ 
.
≥≥ 
_vHead
≥≥ !
.
≥≥! "
_next
≥≥" '
;
≥≥' (
v
≥≥) *
!=
≥≥+ -
_mesh
≥≥. 3
.
≥≥3 4
_vHead
≥≥4 :
;
≥≥: ;
v
≥≥< =
=
≥≥> ?
v
≥≥@ A
.
≥≥A B
_next
≥≥B G
)
≥≥G H
{
¥¥ 
Vec3
µµ 
.
µµ 
Sub
µµ 
(
µµ 
ref
µµ 
v
µµ 
.
µµ 
_coords
µµ &
,
µµ& '
ref
µµ( +
v2
µµ, .
.
µµ. /
_coords
µµ/ 6
,
µµ6 7
out
µµ8 ;
d2
µµ< >
)
µµ> ?
;
µµ? @
tNorm
∂∂ 
.
∂∂ 
X
∂∂ 
=
∂∂ 
d1
∂∂ 
.
∂∂ 
Y
∂∂ 
*
∂∂  
d2
∂∂! #
.
∂∂# $
Z
∂∂$ %
-
∂∂& '
d1
∂∂( *
.
∂∂* +
Z
∂∂+ ,
*
∂∂- .
d2
∂∂/ 1
.
∂∂1 2
Y
∂∂2 3
;
∂∂3 4
tNorm
∑∑ 
.
∑∑ 
Y
∑∑ 
=
∑∑ 
d1
∑∑ 
.
∑∑ 
Z
∑∑ 
*
∑∑  
d2
∑∑! #
.
∑∑# $
X
∑∑$ %
-
∑∑& '
d1
∑∑( *
.
∑∑* +
X
∑∑+ ,
*
∑∑- .
d2
∑∑/ 1
.
∑∑1 2
Z
∑∑2 3
;
∑∑3 4
tNorm
∏∏ 
.
∏∏ 
Z
∏∏ 
=
∏∏ 
d1
∏∏ 
.
∏∏ 
X
∏∏ 
*
∏∏  
d2
∏∏! #
.
∏∏# $
Y
∏∏$ %
-
∏∏& '
d1
∏∏( *
.
∏∏* +
Y
∏∏+ ,
*
∏∏- .
d2
∏∏/ 1
.
∏∏1 2
X
∏∏2 3
;
∏∏3 4
tLen2
ππ 
=
ππ 
tNorm
ππ 
.
ππ 
X
ππ 
*
ππ  
tNorm
ππ  %
.
ππ% &
X
ππ& '
+
ππ( )
tNorm
ππ* /
.
ππ/ 0
Y
ππ0 1
*
ππ1 2
tNorm
ππ2 7
.
ππ7 8
Y
ππ8 9
+
ππ: ;
tNorm
ππ< A
.
ππA B
Z
ππB C
*
ππC D
tNorm
ππD I
.
ππI J
Z
ππJ K
;
ππK L
if
∫∫ 
(
∫∫ 
tLen2
∫∫ 
>
∫∫ 
maxLen2
∫∫ #
)
∫∫# $
{
ªª 
maxLen2
ºº 
=
ºº 
tLen2
ºº #
;
ºº# $
norm
ΩΩ 
=
ΩΩ 
tNorm
ΩΩ  
;
ΩΩ  !
}
ææ 
}
øø 
if
¡¡ 
(
¡¡ 
maxLen2
¡¡ 
<=
¡¡ 
$num
¡¡ 
)
¡¡  
{
¬¬ 
norm
ƒƒ 
=
ƒƒ 
Vec3
ƒƒ 
.
ƒƒ 
Zero
ƒƒ  
;
ƒƒ  !
i
≈≈ 
=
≈≈ 
Vec3
≈≈ 
.
≈≈ 
LongAxis
≈≈ !
(
≈≈! "
ref
≈≈" %
d1
≈≈& (
)
≈≈( )
;
≈≈) *
norm
∆∆ 
[
∆∆ 
i
∆∆ 
]
∆∆ 
=
∆∆ 
$num
∆∆ 
;
∆∆ 
}
«« 
}
»» 	
private
   
void
   
CheckOrientation
   %
(
  % &
)
  & '
{
ÀÀ 	
Real
ŒŒ 
area
ŒŒ 
=
ŒŒ 
$num
ŒŒ 
;
ŒŒ 
for
œœ 
(
œœ 
var
œœ 
f
œœ 
=
œœ 
_mesh
œœ 
.
œœ 
_fHead
œœ %
.
œœ% &
_next
œœ& +
;
œœ+ ,
f
œœ- .
!=
œœ/ 1
_mesh
œœ2 7
.
œœ7 8
_fHead
œœ8 >
;
œœ> ?
f
œœ@ A
=
œœB C
f
œœD E
.
œœE F
_next
œœF K
)
œœK L
{
–– 
if
—— 
(
—— 
f
—— 
.
—— 
_anEdge
—— 
.
—— 
_winding
—— &
<=
——' )
$num
——* +
)
——+ ,
{
““ 
continue
”” 
;
”” 
}
‘‘ 
area
’’ 
+=
’’ 
	MeshUtils
’’ !
.
’’! "
FaceArea
’’" *
(
’’* +
f
’’+ ,
)
’’, -
;
’’- .
}
÷÷ 
if
◊◊ 
(
◊◊ 
area
◊◊ 
<
◊◊ 
$num
◊◊ 
)
◊◊ 
{
ÿÿ 
for
⁄⁄ 
(
⁄⁄ 
var
⁄⁄ 
v
⁄⁄ 
=
⁄⁄ 
_mesh
⁄⁄ "
.
⁄⁄" #
_vHead
⁄⁄# )
.
⁄⁄) *
_next
⁄⁄* /
;
⁄⁄/ 0
v
⁄⁄1 2
!=
⁄⁄3 5
_mesh
⁄⁄6 ;
.
⁄⁄; <
_vHead
⁄⁄< B
;
⁄⁄B C
v
⁄⁄D E
=
⁄⁄F G
v
⁄⁄H I
.
⁄⁄I J
_next
⁄⁄J O
)
⁄⁄O P
{
€€ 
v
‹‹ 
.
‹‹ 
_t
‹‹ 
=
‹‹ 
-
‹‹ 
v
‹‹ 
.
‹‹ 
_t
‹‹  
;
‹‹  !
}
›› 
Vec3
ﬁﬁ 
.
ﬁﬁ 
Neg
ﬁﬁ 
(
ﬁﬁ 
ref
ﬁﬁ 
_tUnit
ﬁﬁ #
)
ﬁﬁ# $
;
ﬁﬁ$ %
}
ﬂﬂ 
}
‡‡ 	
private
‚‚ 
void
‚‚ 
ProjectPolygon
‚‚ #
(
‚‚# $
)
‚‚$ %
{
„„ 	
var
‰‰ 
norm
‰‰ 
=
‰‰ 
_normal
‰‰ 
;
‰‰ 
bool
ÊÊ 
computedNormal
ÊÊ 
=
ÊÊ  !
false
ÊÊ" '
;
ÊÊ' (
if
ÁÁ 
(
ÁÁ 
norm
ÁÁ 
.
ÁÁ 
X
ÁÁ 
==
ÁÁ 
$num
ÁÁ 
&&
ÁÁ !
norm
ÁÁ" &
.
ÁÁ& '
Y
ÁÁ' (
==
ÁÁ) +
$num
ÁÁ, 0
&&
ÁÁ1 3
norm
ÁÁ4 8
.
ÁÁ8 9
Z
ÁÁ9 :
==
ÁÁ; =
$num
ÁÁ> B
)
ÁÁB C
{
ËË 
ComputeNormal
ÈÈ 
(
ÈÈ 
ref
ÈÈ !
norm
ÈÈ" &
)
ÈÈ& '
;
ÈÈ' (
_normal
ÍÍ 
=
ÍÍ 
norm
ÍÍ 
;
ÍÍ 
computedNormal
ÎÎ 
=
ÎÎ  
true
ÎÎ! %
;
ÎÎ% &
}
ÏÏ 
int
ÓÓ 
i
ÓÓ 
=
ÓÓ 
Vec3
ÓÓ 
.
ÓÓ 
LongAxis
ÓÓ !
(
ÓÓ! "
ref
ÓÓ" %
norm
ÓÓ& *
)
ÓÓ* +
;
ÓÓ+ ,
_sUnit
 
[
 
i
 
]
 
=
 
$num
 
;
 
_sUnit
ÒÒ 
[
ÒÒ 
(
ÒÒ 
i
ÒÒ 
+
ÒÒ 
$num
ÒÒ 
)
ÒÒ 
%
ÒÒ 
$num
ÒÒ 
]
ÒÒ 
=
ÒÒ  !
SUnitX
ÒÒ" (
;
ÒÒ( )
_sUnit
ÚÚ 
[
ÚÚ 
(
ÚÚ 
i
ÚÚ 
+
ÚÚ 
$num
ÚÚ 
)
ÚÚ 
%
ÚÚ 
$num
ÚÚ 
]
ÚÚ 
=
ÚÚ  !
SUnitY
ÚÚ" (
;
ÚÚ( )
_tUnit
ÙÙ 
[
ÙÙ 
i
ÙÙ 
]
ÙÙ 
=
ÙÙ 
$num
ÙÙ 
;
ÙÙ 
_tUnit
ıı 
[
ıı 
(
ıı 
i
ıı 
+
ıı 
$num
ıı 
)
ıı 
%
ıı 
$num
ıı 
]
ıı 
=
ıı  !
norm
ıı" &
[
ıı& '
i
ıı' (
]
ıı( )
>
ıı* +
$num
ıı, 0
?
ıı1 2
-
ıı3 4
SUnitY
ıı4 :
:
ıı; <
SUnitY
ıı= C
;
ııC D
_tUnit
ˆˆ 
[
ˆˆ 
(
ˆˆ 
i
ˆˆ 
+
ˆˆ 
$num
ˆˆ 
)
ˆˆ 
%
ˆˆ 
$num
ˆˆ 
]
ˆˆ 
=
ˆˆ  !
norm
ˆˆ" &
[
ˆˆ& '
i
ˆˆ' (
]
ˆˆ( )
>
ˆˆ* +
$num
ˆˆ, 0
?
ˆˆ1 2
SUnitX
ˆˆ3 9
:
ˆˆ: ;
-
ˆˆ< =
SUnitX
ˆˆ= C
;
ˆˆC D
for
˘˘ 
(
˘˘ 
var
˘˘ 
v
˘˘ 
=
˘˘ 
_mesh
˘˘ 
.
˘˘ 
_vHead
˘˘ %
.
˘˘% &
_next
˘˘& +
;
˘˘+ ,
v
˘˘- .
!=
˘˘/ 1
_mesh
˘˘2 7
.
˘˘7 8
_vHead
˘˘8 >
;
˘˘> ?
v
˘˘@ A
=
˘˘B C
v
˘˘D E
.
˘˘E F
_next
˘˘F K
)
˘˘K L
{
˙˙ 
Vec3
˚˚ 
.
˚˚ 
Dot
˚˚ 
(
˚˚ 
ref
˚˚ 
v
˚˚ 
.
˚˚ 
_coords
˚˚ &
,
˚˚& '
ref
˚˚( +
_sUnit
˚˚, 2
,
˚˚2 3
out
˚˚4 7
v
˚˚8 9
.
˚˚9 :
_s
˚˚: <
)
˚˚< =
;
˚˚= >
Vec3
¸¸ 
.
¸¸ 
Dot
¸¸ 
(
¸¸ 
ref
¸¸ 
v
¸¸ 
.
¸¸ 
_coords
¸¸ &
,
¸¸& '
ref
¸¸( +
_tUnit
¸¸, 2
,
¸¸2 3
out
¸¸4 7
v
¸¸8 9
.
¸¸9 :
_t
¸¸: <
)
¸¸< =
;
¸¸= >
}
˝˝ 
if
˛˛ 
(
˛˛ 
computedNormal
˛˛ 
)
˛˛ 
{
ˇˇ 
CheckOrientation
ÄÄ  
(
ÄÄ  !
)
ÄÄ! "
;
ÄÄ" #
}
ÅÅ 
bool
ÑÑ 
first
ÑÑ 
=
ÑÑ 
true
ÑÑ 
;
ÑÑ 
for
ÖÖ 
(
ÖÖ 
var
ÖÖ 
v
ÖÖ 
=
ÖÖ 
_mesh
ÖÖ 
.
ÖÖ 
_vHead
ÖÖ %
.
ÖÖ% &
_next
ÖÖ& +
;
ÖÖ+ ,
v
ÖÖ- .
!=
ÖÖ/ 1
_mesh
ÖÖ2 7
.
ÖÖ7 8
_vHead
ÖÖ8 >
;
ÖÖ> ?
v
ÖÖ@ A
=
ÖÖB C
v
ÖÖD E
.
ÖÖE F
_next
ÖÖF K
)
ÖÖK L
{
ÜÜ 
if
áá 
(
áá 
first
áá 
)
áá 
{
àà 
_bminX
ââ 
=
ââ 
_bmaxX
ââ #
=
ââ$ %
v
ââ& '
.
ââ' (
_s
ââ( *
;
ââ* +
_bminY
ää 
=
ää 
_bmaxY
ää #
=
ää$ %
v
ää& '
.
ää' (
_t
ää( *
;
ää* +
first
ãã 
=
ãã 
false
ãã !
;
ãã! "
}
åå 
else
çç 
{
éé 
if
èè 
(
èè 
v
èè 
.
èè 
_s
èè 
<
èè 
_bminX
èè %
)
èè% &
_bminX
èè' -
=
èè. /
v
èè0 1
.
èè1 2
_s
èè2 4
;
èè4 5
if
êê 
(
êê 
v
êê 
.
êê 
_s
êê 
>
êê 
_bmaxX
êê %
)
êê% &
_bmaxX
êê' -
=
êê. /
v
êê0 1
.
êê1 2
_s
êê2 4
;
êê4 5
if
ëë 
(
ëë 
v
ëë 
.
ëë 
_t
ëë 
<
ëë 
_bminY
ëë %
)
ëë% &
_bminY
ëë' -
=
ëë. /
v
ëë0 1
.
ëë1 2
_t
ëë2 4
;
ëë4 5
if
íí 
(
íí 
v
íí 
.
íí 
_t
íí 
>
íí 
_bmaxY
íí %
)
íí% &
_bmaxY
íí' -
=
íí. /
v
íí0 1
.
íí1 2
_t
íí2 4
;
íí4 5
}
ìì 
}
îî 
}
ïï 	
private
≥≥ 
void
≥≥ "
TessellateMonoRegion
≥≥ )
(
≥≥) *
	MeshUtils
≥≥* 3
.
≥≥3 4
Face
≥≥4 8
face
≥≥9 =
)
≥≥= >
{
¥¥ 	
var
ππ 
up
ππ 
=
ππ 
face
ππ 
.
ππ 
_anEdge
ππ !
;
ππ! "
Debug
∫∫ 
.
∫∫ 
Assert
∫∫ 
(
∫∫ 
up
∫∫ 
.
∫∫ 
_Lnext
∫∫ "
!=
∫∫# %
up
∫∫& (
&&
∫∫) +
up
∫∫, .
.
∫∫. /
_Lnext
∫∫/ 5
.
∫∫5 6
_Lnext
∫∫6 <
!=
∫∫= ?
up
∫∫@ B
)
∫∫B C
;
∫∫C D
while
ºº 
(
ºº 
Geom
ºº 
.
ºº 
VertLeq
ºº 
(
ºº  
up
ºº  "
.
ºº" #
_Dst
ºº# '
,
ºº' (
up
ºº) +
.
ºº+ ,
_Org
ºº, 0
)
ºº0 1
)
ºº1 2
up
ºº3 5
=
ºº6 7
up
ºº8 :
.
ºº: ;
_Lprev
ºº; A
;
ººA B
while
ΩΩ 
(
ΩΩ 
Geom
ΩΩ 
.
ΩΩ 
VertLeq
ΩΩ 
(
ΩΩ  
up
ΩΩ  "
.
ΩΩ" #
_Org
ΩΩ# '
,
ΩΩ' (
up
ΩΩ) +
.
ΩΩ+ ,
_Dst
ΩΩ, 0
)
ΩΩ0 1
)
ΩΩ1 2
up
ΩΩ3 5
=
ΩΩ6 7
up
ΩΩ8 :
.
ΩΩ: ;
_Lnext
ΩΩ; A
;
ΩΩA B
var
øø 
lo
øø 
=
øø 
up
øø 
.
øø 
_Lprev
øø 
;
øø 
while
¡¡ 
(
¡¡ 
up
¡¡ 
.
¡¡ 
_Lnext
¡¡ 
!=
¡¡ 
lo
¡¡  "
)
¡¡" #
{
¬¬ 
if
√√ 
(
√√ 
Geom
√√ 
.
√√ 
VertLeq
√√  
(
√√  !
up
√√! #
.
√√# $
_Dst
√√$ (
,
√√( )
lo
√√* ,
.
√√, -
_Org
√√- 1
)
√√1 2
)
√√2 3
{
ƒƒ 
while
»» 
(
»» 
lo
»» 
.
»» 
_Lnext
»» $
!=
»»% '
up
»»( *
&&
»»+ -
(
»». /
Geom
»»/ 3
.
»»3 4
EdgeGoesLeft
»»4 @
(
»»@ A
lo
»»A C
.
»»C D
_Lnext
»»D J
)
»»J K
||
…… 
Geom
…… 
.
……  
EdgeSign
……  (
(
……( )
lo
……) +
.
……+ ,
_Org
……, 0
,
……0 1
lo
……2 4
.
……4 5
_Dst
……5 9
,
……9 :
lo
……; =
.
……= >
_Lnext
……> D
.
……D E
_Dst
……E I
)
……I J
<=
……K M
$num
……N R
)
……R S
)
……S T
{
   
lo
ÀÀ 
=
ÀÀ 
_mesh
ÀÀ "
.
ÀÀ" #
Connect
ÀÀ# *
(
ÀÀ* +
lo
ÀÀ+ -
.
ÀÀ- .
_Lnext
ÀÀ. 4
,
ÀÀ4 5
lo
ÀÀ6 8
)
ÀÀ8 9
.
ÀÀ9 :
_Sym
ÀÀ: >
;
ÀÀ> ?
}
ÃÃ 
lo
ÕÕ 
=
ÕÕ 
lo
ÕÕ 
.
ÕÕ 
_Lprev
ÕÕ "
;
ÕÕ" #
}
ŒŒ 
else
œœ 
{
–– 
while
““ 
(
““ 
lo
““ 
.
““ 
_Lnext
““ $
!=
““% '
up
““( *
&&
““+ -
(
““. /
Geom
““/ 3
.
““3 4
EdgeGoesRight
““4 A
(
““A B
up
““B D
.
““D E
_Lprev
““E K
)
““K L
||
”” 
Geom
”” 
.
””  
EdgeSign
””  (
(
””( )
up
””) +
.
””+ ,
_Dst
””, 0
,
””0 1
up
””2 4
.
””4 5
_Org
””5 9
,
””9 :
up
””; =
.
””= >
_Lprev
””> D
.
””D E
_Org
””E I
)
””I J
>=
””K M
$num
””N R
)
””R S
)
””S T
{
‘‘ 
up
’’ 
=
’’ 
_mesh
’’ "
.
’’" #
Connect
’’# *
(
’’* +
up
’’+ -
,
’’- .
up
’’/ 1
.
’’1 2
_Lprev
’’2 8
)
’’8 9
.
’’9 :
_Sym
’’: >
;
’’> ?
}
÷÷ 
up
◊◊ 
=
◊◊ 
up
◊◊ 
.
◊◊ 
_Lnext
◊◊ "
;
◊◊" #
}
ÿÿ 
}
ŸŸ 
Debug
›› 
.
›› 
Assert
›› 
(
›› 
lo
›› 
.
›› 
_Lnext
›› "
!=
››# %
up
››& (
)
››( )
;
››) *
while
ﬁﬁ 
(
ﬁﬁ 
lo
ﬁﬁ 
.
ﬁﬁ 
_Lnext
ﬁﬁ 
.
ﬁﬁ 
_Lnext
ﬁﬁ #
!=
ﬁﬁ$ &
up
ﬁﬁ' )
)
ﬁﬁ) *
{
ﬂﬂ 
lo
‡‡ 
=
‡‡ 
_mesh
‡‡ 
.
‡‡ 
Connect
‡‡ "
(
‡‡" #
lo
‡‡# %
.
‡‡% &
_Lnext
‡‡& ,
,
‡‡, -
lo
‡‡. 0
)
‡‡0 1
.
‡‡1 2
_Sym
‡‡2 6
;
‡‡6 7
}
·· 
}
‚‚ 	
private
ÈÈ 
void
ÈÈ  
TessellateInterior
ÈÈ '
(
ÈÈ' (
)
ÈÈ( )
{
ÍÍ 	
	MeshUtils
ÎÎ 
.
ÎÎ 
Face
ÎÎ 
f
ÎÎ 
,
ÎÎ 
next
ÎÎ "
;
ÎÎ" #
for
ÏÏ 
(
ÏÏ 
f
ÏÏ 
=
ÏÏ 
_mesh
ÏÏ 
.
ÏÏ 
_fHead
ÏÏ !
.
ÏÏ! "
_next
ÏÏ" '
;
ÏÏ' (
f
ÏÏ) *
!=
ÏÏ+ -
_mesh
ÏÏ. 3
.
ÏÏ3 4
_fHead
ÏÏ4 :
;
ÏÏ: ;
f
ÏÏ< =
=
ÏÏ> ?
next
ÏÏ@ D
)
ÏÏD E
{
ÌÌ 
next
ÔÔ 
=
ÔÔ 
f
ÔÔ 
.
ÔÔ 
_next
ÔÔ 
;
ÔÔ 
if
 
(
 
f
 
.
 
_inside
 
)
 
{
ÒÒ "
TessellateMonoRegion
ÚÚ (
(
ÚÚ( )
f
ÚÚ) *
)
ÚÚ* +
;
ÚÚ+ ,
}
ÛÛ 
}
ÙÙ 
}
ıı 	
private
˝˝ 
void
˝˝ 
DiscardExterior
˝˝ $
(
˝˝$ %
)
˝˝% &
{
˛˛ 	
	MeshUtils
ˇˇ 
.
ˇˇ 
Face
ˇˇ 
f
ˇˇ 
,
ˇˇ 
next
ˇˇ "
;
ˇˇ" #
for
ÅÅ 
(
ÅÅ 
f
ÅÅ 
=
ÅÅ 
_mesh
ÅÅ 
.
ÅÅ 
_fHead
ÅÅ !
.
ÅÅ! "
_next
ÅÅ" '
;
ÅÅ' (
f
ÅÅ) *
!=
ÅÅ+ -
_mesh
ÅÅ. 3
.
ÅÅ3 4
_fHead
ÅÅ4 :
;
ÅÅ: ;
f
ÅÅ< =
=
ÅÅ> ?
next
ÅÅ@ D
)
ÅÅD E
{
ÇÇ 
next
ÑÑ 
=
ÑÑ 
f
ÑÑ 
.
ÑÑ 
_next
ÑÑ 
;
ÑÑ 
if
ÖÖ 
(
ÖÖ 
!
ÖÖ 
f
ÖÖ 
.
ÖÖ 
_inside
ÖÖ 
)
ÖÖ  !
{
ÖÖ" #
_mesh
ÜÜ 
.
ÜÜ 
ZapFace
ÜÜ !
(
ÜÜ! "
f
ÜÜ" #
)
ÜÜ# $
;
ÜÜ$ %
}
áá 
}
àà 
}
ââ 	
private
îî 
void
îî 
SetWindingNumber
îî %
(
îî% &
int
îî& )
value
îî* /
,
îî/ 0
bool
îî1 5
keepOnlyBoundary
îî6 F
)
îîF G
{
ïï 	
	MeshUtils
ññ 
.
ññ 
Edge
ññ 
e
ññ 
,
ññ 
eNext
ññ #
;
ññ# $
for
òò 
(
òò 
e
òò 
=
òò 
_mesh
òò 
.
òò 
_eHead
òò !
.
òò! "
_next
òò" '
;
òò' (
e
òò) *
!=
òò+ -
_mesh
òò. 3
.
òò3 4
_eHead
òò4 :
;
òò: ;
e
òò< =
=
òò> ?
eNext
òò@ E
)
òòE F
{
ôô 
eNext
öö 
=
öö 
e
öö 
.
öö 
_next
öö 
;
öö  
if
õõ 
(
õõ 
e
õõ 
.
õõ 
_Rface
õõ 
.
õõ 
_inside
õõ $
!=
õõ% '
e
õõ( )
.
õõ) *
_Lface
õõ* 0
.
õõ0 1
_inside
õõ1 8
)
õõ8 9
{
úú 
e
üü 
.
üü 
_winding
üü 
=
üü  
(
üü! "
e
üü" #
.
üü# $
_Lface
üü$ *
.
üü* +
_inside
üü+ 2
)
üü2 3
?
üü4 5
value
üü6 ;
:
üü< =
-
üü> ?
value
üü? D
;
üüD E
}
†† 
else
°° 
{
¢¢ 
if
•• 
(
•• 
!
•• 
keepOnlyBoundary
•• )
)
••) *
{
¶¶ 
e
ßß 
.
ßß 
_winding
ßß "
=
ßß# $
$num
ßß% &
;
ßß& '
}
®® 
else
©© 
{
™™ 
_mesh
´´ 
.
´´ 
Delete
´´ $
(
´´$ %
e
´´% &
)
´´& '
;
´´' (
}
¨¨ 
}
≠≠ 
}
ÆÆ 
}
∞∞ 	
private
≤≤ 
int
≤≤ 
GetNeighbourFace
≤≤ $
(
≤≤$ %
	MeshUtils
≤≤% .
.
≤≤. /
Edge
≤≤/ 3
edge
≤≤4 8
)
≤≤8 9
{
≥≥ 	
if
¥¥ 
(
¥¥ 
edge
¥¥ 
.
¥¥ 
_Rface
¥¥ 
==
¥¥ 
null
¥¥ #
)
¥¥# $
return
µµ 
	MeshUtils
µµ  
.
µµ  !
Undef
µµ! &
;
µµ& '
if
∂∂ 
(
∂∂ 
!
∂∂ 
edge
∂∂ 
.
∂∂ 
_Rface
∂∂ 
.
∂∂ 
_inside
∂∂ $
)
∂∂$ %
return
∑∑ 
	MeshUtils
∑∑  
.
∑∑  !
Undef
∑∑! &
;
∑∑& '
return
∏∏ 
edge
∏∏ 
.
∏∏ 
_Rface
∏∏ 
.
∏∏ 
_n
∏∏ !
;
∏∏! "
}
ππ 	
private
ªª 
void
ªª 
OutputPolymesh
ªª #
(
ªª# $
ElementType
ªª$ /
elementType
ªª0 ;
,
ªª; <
int
ªª= @
polySize
ªªA I
)
ªªI J
{
ºº 	
	MeshUtils
ΩΩ 
.
ΩΩ 
Vertex
ΩΩ 
v
ΩΩ 
;
ΩΩ 
	MeshUtils
ææ 
.
ææ 
Face
ææ 
f
ææ 
;
ææ 
	MeshUtils
øø 
.
øø 
Edge
øø 
edge
øø 
;
øø  
int
¿¿ 
maxFaceCount
¿¿ 
=
¿¿ 
$num
¿¿  
;
¿¿  !
int
¡¡ 
maxVertexCount
¡¡ 
=
¡¡  
$num
¡¡! "
;
¡¡" #
int
¬¬ 
	faceVerts
¬¬ 
,
¬¬ 
i
¬¬ 
;
¬¬ 
if
ƒƒ 
(
ƒƒ 
polySize
ƒƒ 
<
ƒƒ 
$num
ƒƒ 
)
ƒƒ 
{
≈≈ 
polySize
∆∆ 
=
∆∆ 
$num
∆∆ 
;
∆∆ 
}
«« 
if
   
(
   
polySize
   
>
   
$num
   
)
   
{
ÀÀ 
_mesh
ÃÃ 
.
ÃÃ 
MergeConvexFaces
ÃÃ &
(
ÃÃ& '
polySize
ÃÃ' /
)
ÃÃ/ 0
;
ÃÃ0 1
}
ÕÕ 
for
–– 
(
–– 
v
–– 
=
–– 
_mesh
–– 
.
–– 
_vHead
–– !
.
––! "
_next
––" '
;
––' (
v
––) *
!=
––+ -
_mesh
––. 3
.
––3 4
_vHead
––4 :
;
––: ;
v
––< =
=
––> ?
v
––@ A
.
––A B
_next
––B G
)
––G H
v
—— 
.
—— 
_n
—— 
=
—— 
	MeshUtils
——  
.
——  !
Undef
——! &
;
——& '
for
‘‘ 
(
‘‘ 
f
‘‘ 
=
‘‘ 
_mesh
‘‘ 
.
‘‘ 
_fHead
‘‘ !
.
‘‘! "
_next
‘‘" '
;
‘‘' (
f
‘‘) *
!=
‘‘+ -
_mesh
‘‘. 3
.
‘‘3 4
_fHead
‘‘4 :
;
‘‘: ;
f
‘‘< =
=
‘‘> ?
f
‘‘@ A
.
‘‘A B
_next
‘‘B G
)
‘‘G H
{
’’ 
f
÷÷ 
.
÷÷ 
_n
÷÷ 
=
÷÷ 
	MeshUtils
÷÷  
.
÷÷  !
Undef
÷÷! &
;
÷÷& '
if
◊◊ 
(
◊◊ 
!
◊◊ 
f
◊◊ 
.
◊◊ 
_inside
◊◊ 
)
◊◊ 
continue
◊◊  (
;
◊◊( )
if
ŸŸ 
(
ŸŸ 
NoEmptyPolygons
ŸŸ #
)
ŸŸ# $
{
⁄⁄ 
var
€€ 
area
€€ 
=
€€ 
	MeshUtils
€€ (
.
€€( )
FaceArea
€€) 1
(
€€1 2
f
€€2 3
)
€€3 4
;
€€4 5
if
‹‹ 
(
‹‹ 
Math
‹‹ 
.
‹‹ 
Abs
‹‹  
(
‹‹  !
area
‹‹! %
)
‹‹% &
<
‹‹' (
Real
‹‹) -
.
‹‹- .
Epsilon
‹‹. 5
)
‹‹5 6
{
›› 
continue
ﬁﬁ  
;
ﬁﬁ  !
}
ﬂﬂ 
}
‡‡ 
edge
‚‚ 
=
‚‚ 
f
‚‚ 
.
‚‚ 
_anEdge
‚‚  
;
‚‚  !
	faceVerts
„„ 
=
„„ 
$num
„„ 
;
„„ 
do
‰‰ 
{
‰‰ 
v
ÂÂ 
=
ÂÂ 
edge
ÂÂ 
.
ÂÂ 
_Org
ÂÂ !
;
ÂÂ! "
if
ÊÊ 
(
ÊÊ 
v
ÊÊ 
.
ÊÊ 
_n
ÊÊ 
==
ÊÊ 
	MeshUtils
ÊÊ  )
.
ÊÊ) *
Undef
ÊÊ* /
)
ÊÊ/ 0
{
ÁÁ 
v
ËË 
.
ËË 
_n
ËË 
=
ËË 
maxVertexCount
ËË -
;
ËË- .
maxVertexCount
ÈÈ &
++
ÈÈ& (
;
ÈÈ( )
}
ÍÍ 
	faceVerts
ÎÎ 
++
ÎÎ 
;
ÎÎ  
edge
ÏÏ 
=
ÏÏ 
edge
ÏÏ 
.
ÏÏ  
_Lnext
ÏÏ  &
;
ÏÏ& '
}
ÌÌ 
while
ÓÓ 
(
ÓÓ 
edge
ÓÓ 
!=
ÓÓ 
f
ÓÓ  
.
ÓÓ  !
_anEdge
ÓÓ! (
)
ÓÓ( )
;
ÓÓ) *
Debug
 
.
 
Assert
 
(
 
	faceVerts
 &
<=
' )
polySize
* 2
)
2 3
;
3 4
f
ÚÚ 
.
ÚÚ 
_n
ÚÚ 
=
ÚÚ 
maxFaceCount
ÚÚ #
;
ÚÚ# $
++
ÛÛ 
maxFaceCount
ÛÛ 
;
ÛÛ 
}
ÙÙ 
_elementCount
ˆˆ 
=
ˆˆ 
maxFaceCount
ˆˆ (
;
ˆˆ( )
if
˜˜ 
(
˜˜ 
elementType
˜˜ 
==
˜˜ 
ElementType
˜˜ *
.
˜˜* +
ConnectedPolygons
˜˜+ <
)
˜˜< =
maxFaceCount
¯¯ 
*=
¯¯ 
$num
¯¯  !
;
¯¯! "
	_elements
˘˘ 
=
˘˘ 
new
˘˘ 
int
˘˘ 
[
˘˘  
maxFaceCount
˘˘  ,
*
˘˘- .
polySize
˘˘/ 7
]
˘˘7 8
;
˘˘8 9
_vertexCount
˚˚ 
=
˚˚ 
maxVertexCount
˚˚ )
;
˚˚) *
	_vertices
¸¸ 
=
¸¸ 
new
¸¸ 
ContourVertex
¸¸ )
[
¸¸) *
_vertexCount
¸¸* 6
]
¸¸6 7
;
¸¸7 8
for
ˇˇ 
(
ˇˇ 
v
ˇˇ 
=
ˇˇ 
_mesh
ˇˇ 
.
ˇˇ 
_vHead
ˇˇ !
.
ˇˇ! "
_next
ˇˇ" '
;
ˇˇ' (
v
ˇˇ) *
!=
ˇˇ+ -
_mesh
ˇˇ. 3
.
ˇˇ3 4
_vHead
ˇˇ4 :
;
ˇˇ: ;
v
ˇˇ< =
=
ˇˇ> ?
v
ˇˇ@ A
.
ˇˇA B
_next
ˇˇB G
)
ˇˇG H
{
ÄÄ 
if
ÅÅ 
(
ÅÅ 
v
ÅÅ 
.
ÅÅ 
_n
ÅÅ 
!=
ÅÅ 
	MeshUtils
ÅÅ %
.
ÅÅ% &
Undef
ÅÅ& +
)
ÅÅ+ ,
{
ÇÇ 
	_vertices
ÑÑ 
[
ÑÑ 
v
ÑÑ 
.
ÑÑ  
_n
ÑÑ  "
]
ÑÑ" #
.
ÑÑ# $
Position
ÑÑ$ ,
=
ÑÑ- .
v
ÑÑ/ 0
.
ÑÑ0 1
_coords
ÑÑ1 8
;
ÑÑ8 9
	_vertices
ÖÖ 
[
ÖÖ 
v
ÖÖ 
.
ÖÖ  
_n
ÖÖ  "
]
ÖÖ" #
.
ÖÖ# $
Data
ÖÖ$ (
=
ÖÖ) *
v
ÖÖ+ ,
.
ÖÖ, -
_data
ÖÖ- 2
;
ÖÖ2 3
}
ÜÜ 
}
áá 
int
ää 
elementIndex
ää 
=
ää 
$num
ää  
;
ää  !
for
ãã 
(
ãã 
f
ãã 
=
ãã 
_mesh
ãã 
.
ãã 
_fHead
ãã !
.
ãã! "
_next
ãã" '
;
ãã' (
f
ãã) *
!=
ãã+ -
_mesh
ãã. 3
.
ãã3 4
_fHead
ãã4 :
;
ãã: ;
f
ãã< =
=
ãã> ?
f
ãã@ A
.
ããA B
_next
ããB G
)
ããG H
{
åå 
if
çç 
(
çç 
!
çç 
f
çç 
.
çç 
_inside
çç 
)
çç 
continue
çç  (
;
çç( )
if
èè 
(
èè 
NoEmptyPolygons
èè #
)
èè# $
{
êê 
var
ëë 
area
ëë 
=
ëë 
	MeshUtils
ëë (
.
ëë( )
FaceArea
ëë) 1
(
ëë1 2
f
ëë2 3
)
ëë3 4
;
ëë4 5
if
íí 
(
íí 
Math
íí 
.
íí 
Abs
íí  
(
íí  !
area
íí! %
)
íí% &
<
íí' (
Real
íí) -
.
íí- .
Epsilon
íí. 5
)
íí5 6
{
ìì 
continue
îî  
;
îî  !
}
ïï 
}
ññ 
edge
ôô 
=
ôô 
f
ôô 
.
ôô 
_anEdge
ôô  
;
ôô  !
	faceVerts
öö 
=
öö 
$num
öö 
;
öö 
do
õõ 
{
õõ 
v
úú 
=
úú 
edge
úú 
.
úú 
_Org
úú !
;
úú! "
	_elements
ùù 
[
ùù 
elementIndex
ùù *
++
ùù* ,
]
ùù, -
=
ùù. /
v
ùù0 1
.
ùù1 2
_n
ùù2 4
;
ùù4 5
	faceVerts
ûû 
++
ûû 
;
ûû  
edge
üü 
=
üü 
edge
üü 
.
üü  
_Lnext
üü  &
;
üü& '
}
†† 
while
†† 
(
†† 
edge
†† 
!=
††  
f
††! "
.
††" #
_anEdge
††# *
)
††* +
;
††+ ,
for
¢¢ 
(
¢¢ 
i
¢¢ 
=
¢¢ 
	faceVerts
¢¢ "
;
¢¢" #
i
¢¢$ %
<
¢¢& '
polySize
¢¢( 0
;
¢¢0 1
++
¢¢2 4
i
¢¢4 5
)
¢¢5 6
{
££ 
	_elements
§§ 
[
§§ 
elementIndex
§§ *
++
§§* ,
]
§§, -
=
§§. /
	MeshUtils
§§0 9
.
§§9 :
Undef
§§: ?
;
§§? @
}
•• 
if
®® 
(
®® 
elementType
®® 
==
®®  "
ElementType
®®# .
.
®®. /
ConnectedPolygons
®®/ @
)
®®@ A
{
©© 
edge
™™ 
=
™™ 
f
™™ 
.
™™ 
_anEdge
™™ $
;
™™$ %
do
´´ 
{
¨¨ 
	_elements
≠≠ !
[
≠≠! "
elementIndex
≠≠" .
++
≠≠. 0
]
≠≠0 1
=
≠≠2 3
GetNeighbourFace
≠≠4 D
(
≠≠D E
edge
≠≠E I
)
≠≠I J
;
≠≠J K
edge
ÆÆ 
=
ÆÆ 
edge
ÆÆ #
.
ÆÆ# $
_Lnext
ÆÆ$ *
;
ÆÆ* +
}
ØØ 
while
ØØ 
(
ØØ 
edge
ØØ !
!=
ØØ" $
f
ØØ% &
.
ØØ& '
_anEdge
ØØ' .
)
ØØ. /
;
ØØ/ 0
for
±± 
(
±± 
i
±± 
=
±± 
	faceVerts
±± &
;
±±& '
i
±±( )
<
±±* +
polySize
±±, 4
;
±±4 5
++
±±6 8
i
±±8 9
)
±±9 :
{
≤≤ 
	_elements
≥≥ !
[
≥≥! "
elementIndex
≥≥" .
++
≥≥. 0
]
≥≥0 1
=
≥≥2 3
	MeshUtils
≥≥4 =
.
≥≥= >
Undef
≥≥> C
;
≥≥C D
}
¥¥ 
}
µµ 
}
∂∂ 
}
∑∑ 	
private
ππ 
void
ππ 
OutputContours
ππ #
(
ππ# $
)
ππ$ %
{
∫∫ 	
	MeshUtils
ªª 
.
ªª 
Face
ªª 
f
ªª 
;
ªª 
	MeshUtils
ºº 
.
ºº 
Edge
ºº 
edge
ºº 
,
ºº  
start
ºº! &
;
ºº& '
int
ΩΩ 
	startVert
ΩΩ 
=
ΩΩ 
$num
ΩΩ 
;
ΩΩ 
int
ææ 
	vertCount
ææ 
=
ææ 
$num
ææ 
;
ææ 
_vertexCount
¿¿ 
=
¿¿ 
$num
¿¿ 
;
¿¿ 
_elementCount
¡¡ 
=
¡¡ 
$num
¡¡ 
;
¡¡ 
for
√√ 
(
√√ 
f
√√ 
=
√√ 
_mesh
√√ 
.
√√ 
_fHead
√√ !
.
√√! "
_next
√√" '
;
√√' (
f
√√) *
!=
√√+ -
_mesh
√√. 3
.
√√3 4
_fHead
√√4 :
;
√√: ;
f
√√< =
=
√√> ?
f
√√@ A
.
√√A B
_next
√√B G
)
√√G H
{
ƒƒ 
if
≈≈ 
(
≈≈ 
!
≈≈ 
f
≈≈ 
.
≈≈ 
_inside
≈≈ 
)
≈≈ 
continue
≈≈  (
;
≈≈( )
start
«« 
=
«« 
edge
«« 
=
«« 
f
««  
.
««  !
_anEdge
««! (
;
««( )
do
»» 
{
…… 
++
   
_vertexCount
   "
;
  " #
edge
ÀÀ 
=
ÀÀ 
edge
ÀÀ 
.
ÀÀ  
_Lnext
ÀÀ  &
;
ÀÀ& '
}
ÃÃ 
while
ÕÕ 
(
ÕÕ 
edge
ÕÕ 
!=
ÕÕ 
start
ÕÕ $
)
ÕÕ$ %
;
ÕÕ% &
++
œœ 
_elementCount
œœ 
;
œœ  
}
–– 
	_elements
““ 
=
““ 
new
““ 
int
““ 
[
““  
_elementCount
““  -
*
““. /
$num
““0 1
]
““1 2
;
““2 3
	_vertices
”” 
=
”” 
new
”” 
ContourVertex
”” )
[
””) *
_vertexCount
””* 6
]
””6 7
;
””7 8
int
’’ 
	vertIndex
’’ 
=
’’ 
$num
’’ 
;
’’ 
int
÷÷ 
elementIndex
÷÷ 
=
÷÷ 
$num
÷÷  
;
÷÷  !
	startVert
ÿÿ 
=
ÿÿ 
$num
ÿÿ 
;
ÿÿ 
for
⁄⁄ 
(
⁄⁄ 
f
⁄⁄ 
=
⁄⁄ 
_mesh
⁄⁄ 
.
⁄⁄ 
_fHead
⁄⁄ !
.
⁄⁄! "
_next
⁄⁄" '
;
⁄⁄' (
f
⁄⁄) *
!=
⁄⁄+ -
_mesh
⁄⁄. 3
.
⁄⁄3 4
_fHead
⁄⁄4 :
;
⁄⁄: ;
f
⁄⁄< =
=
⁄⁄> ?
f
⁄⁄@ A
.
⁄⁄A B
_next
⁄⁄B G
)
⁄⁄G H
{
€€ 
if
‹‹ 
(
‹‹ 
!
‹‹ 
f
‹‹ 
.
‹‹ 
_inside
‹‹ 
)
‹‹ 
continue
‹‹  (
;
‹‹( )
	vertCount
ﬁﬁ 
=
ﬁﬁ 
$num
ﬁﬁ 
;
ﬁﬁ 
start
ﬂﬂ 
=
ﬂﬂ 
edge
ﬂﬂ 
=
ﬂﬂ 
f
ﬂﬂ  
.
ﬂﬂ  !
_anEdge
ﬂﬂ! (
;
ﬂﬂ( )
do
‡‡ 
{
‡‡ 
	_vertices
·· 
[
·· 
	vertIndex
·· '
]
··' (
.
··( )
Position
··) 1
=
··2 3
edge
··4 8
.
··8 9
_Org
··9 =
.
··= >
_coords
··> E
;
··E F
	_vertices
‚‚ 
[
‚‚ 
	vertIndex
‚‚ '
]
‚‚' (
.
‚‚( )
Data
‚‚) -
=
‚‚. /
edge
‚‚0 4
.
‚‚4 5
_Org
‚‚5 9
.
‚‚9 :
_data
‚‚: ?
;
‚‚? @
++
„„ 
	vertIndex
„„ 
;
„„  
++
‰‰ 
	vertCount
‰‰ 
;
‰‰  
edge
ÂÂ 
=
ÂÂ 
edge
ÂÂ 
.
ÂÂ  
_Lnext
ÂÂ  &
;
ÂÂ& '
}
ÊÊ 
while
ÊÊ 
(
ÊÊ 
edge
ÊÊ 
!=
ÊÊ  
start
ÊÊ! &
)
ÊÊ& '
;
ÊÊ' (
	_elements
ËË 
[
ËË 
elementIndex
ËË &
++
ËË& (
]
ËË( )
=
ËË* +
	startVert
ËË, 5
;
ËË5 6
	_elements
ÈÈ 
[
ÈÈ 
elementIndex
ÈÈ &
++
ÈÈ& (
]
ÈÈ( )
=
ÈÈ* +
	vertCount
ÈÈ, 5
;
ÈÈ5 6
	startVert
ÎÎ 
+=
ÎÎ 
	vertCount
ÎÎ &
;
ÎÎ& '
}
ÏÏ 
}
ÌÌ 	
private
ÔÔ 
Real
ÔÔ 

SignedArea
ÔÔ 
(
ÔÔ  
ContourVertex
ÔÔ  -
[
ÔÔ- .
]
ÔÔ. /
vertices
ÔÔ0 8
)
ÔÔ8 9
{
 	
Real
ÒÒ 
area
ÒÒ 
=
ÒÒ 
$num
ÒÒ 
;
ÒÒ 
for
ÛÛ 
(
ÛÛ 
int
ÛÛ 
i
ÛÛ 
=
ÛÛ 
$num
ÛÛ 
;
ÛÛ 
i
ÛÛ 
<
ÛÛ 
vertices
ÛÛ  (
.
ÛÛ( )
Length
ÛÛ) /
;
ÛÛ/ 0
i
ÛÛ1 2
++
ÛÛ2 4
)
ÛÛ4 5
{
ÙÙ 
var
ıı 
v0
ıı 
=
ıı 
vertices
ıı !
[
ıı! "
i
ıı" #
]
ıı# $
;
ıı$ %
var
ˆˆ 
v1
ˆˆ 
=
ˆˆ 
vertices
ˆˆ !
[
ˆˆ! "
(
ˆˆ" #
i
ˆˆ# $
+
ˆˆ% &
$num
ˆˆ' (
)
ˆˆ( )
%
ˆˆ* +
vertices
ˆˆ, 4
.
ˆˆ4 5
Length
ˆˆ5 ;
]
ˆˆ; <
;
ˆˆ< =
area
¯¯ 
+=
¯¯ 
v0
¯¯ 
.
¯¯ 
Position
¯¯ #
.
¯¯# $
X
¯¯$ %
*
¯¯& '
v1
¯¯( *
.
¯¯* +
Position
¯¯+ 3
.
¯¯3 4
Y
¯¯4 5
;
¯¯5 6
area
˘˘ 
-=
˘˘ 
v0
˘˘ 
.
˘˘ 
Position
˘˘ #
.
˘˘# $
Y
˘˘$ %
*
˘˘& '
v1
˘˘( *
.
˘˘* +
Position
˘˘+ 3
.
˘˘3 4
X
˘˘4 5
;
˘˘5 6
}
˙˙ 
return
¸¸ 
$num
¸¸ 
*
¸¸ 
area
¸¸ 
;
¸¸ 
}
˝˝ 	
public
ˇˇ 
void
ˇˇ 

AddContour
ˇˇ 
(
ˇˇ 
ContourVertex
ˇˇ ,
[
ˇˇ, -
]
ˇˇ- .
vertices
ˇˇ/ 7
)
ˇˇ7 8
{
ÄÄ 	

AddContour
ÅÅ 
(
ÅÅ 
vertices
ÅÅ 
,
ÅÅ   
ContourOrientation
ÅÅ! 3
.
ÅÅ3 4
Original
ÅÅ4 <
)
ÅÅ< =
;
ÅÅ= >
}
ÇÇ 	
public
ÑÑ 
void
ÑÑ 

AddContour
ÑÑ 
(
ÑÑ 
ContourVertex
ÑÑ ,
[
ÑÑ, -
]
ÑÑ- .
vertices
ÑÑ/ 7
,
ÑÑ7 8 
ContourOrientation
ÑÑ9 K
forceOrientation
ÑÑL \
)
ÑÑ\ ]
{
ÖÖ 	
if
ÜÜ 
(
ÜÜ 
_mesh
ÜÜ 
==
ÜÜ 
null
ÜÜ 
)
ÜÜ 
{
áá 
_mesh
àà 
=
àà 
new
àà 
Mesh
àà  
(
àà  !
)
àà! "
;
àà" #
}
ââ 
bool
ãã 
reverse
ãã 
=
ãã 
false
ãã  
;
ãã  !
if
åå 
(
åå 
forceOrientation
åå  
!=
åå! # 
ContourOrientation
åå$ 6
.
åå6 7
Original
åå7 ?
)
åå? @
{
çç 
var
éé 
area
éé 
=
éé 

SignedArea
éé %
(
éé% &
vertices
éé& .
)
éé. /
;
éé/ 0
reverse
èè 
=
èè 
(
èè 
forceOrientation
èè +
==
èè, . 
ContourOrientation
èè/ A
.
èèA B
	Clockwise
èèB K
&&
èèL N
area
èèO S
<
èèT U
$num
èèV Z
)
èèZ [
||
èè\ ^
(
èè_ `
forceOrientation
èè` p
==
èèq s!
ContourOrientationèèt Ü
.èèÜ á 
CounterClockwiseèèá ó
&&èèò ö
areaèèõ ü
>èè† °
$numèè¢ ¶
)èè¶ ß
;èèß ®
}
êê 
	MeshUtils
íí 
.
íí 
Edge
íí 
e
íí 
=
íí 
null
íí #
;
íí# $
for
ìì 
(
ìì 
int
ìì 
i
ìì 
=
ìì 
$num
ìì 
;
ìì 
i
ìì 
<
ìì 
vertices
ìì  (
.
ìì( )
Length
ìì) /
;
ìì/ 0
++
ìì1 3
i
ìì3 4
)
ìì4 5
{
îî 
if
ïï 
(
ïï 
e
ïï 
==
ïï 
null
ïï 
)
ïï 
{
ññ 
e
óó 
=
óó 
_mesh
óó 
.
óó 
MakeEdge
óó &
(
óó& '
)
óó' (
;
óó( )
_mesh
òò 
.
òò 
Splice
òò  
(
òò  !
e
òò! "
,
òò" #
e
òò$ %
.
òò% &
_Sym
òò& *
)
òò* +
;
òò+ ,
}
ôô 
else
öö 
{
õõ 
_mesh
ûû 
.
ûû 
	SplitEdge
ûû #
(
ûû# $
e
ûû$ %
)
ûû% &
;
ûû& '
e
üü 
=
üü 
e
üü 
.
üü 
_Lnext
üü  
;
üü  !
}
†† 
int
¢¢ 
index
¢¢ 
=
¢¢ 
reverse
¢¢ #
?
¢¢$ %
vertices
¢¢& .
.
¢¢. /
Length
¢¢/ 5
-
¢¢6 7
$num
¢¢8 9
-
¢¢: ;
i
¢¢< =
:
¢¢> ?
i
¢¢@ A
;
¢¢A B
e
§§ 
.
§§ 
_Org
§§ 
.
§§ 
_coords
§§ 
=
§§  
vertices
§§! )
[
§§) *
index
§§* /
]
§§/ 0
.
§§0 1
Position
§§1 9
;
§§9 :
e
•• 
.
•• 
_Org
•• 
.
•• 
_data
•• 
=
•• 
vertices
•• '
[
••' (
index
••( -
]
••- .
.
••. /
Data
••/ 3
;
••3 4
e
´´ 
.
´´ 
_winding
´´ 
=
´´ 
$num
´´ 
;
´´ 
e
¨¨ 
.
¨¨ 
_Sym
¨¨ 
.
¨¨ 
_winding
¨¨ 
=
¨¨  !
-
¨¨" #
$num
¨¨# $
;
¨¨$ %
}
≠≠ 
}
ÆÆ 	
public
∞∞ 
void
∞∞ 

Tessellate
∞∞ 
(
∞∞ 
WindingRule
∞∞ *
windingRule
∞∞+ 6
,
∞∞6 7
ElementType
∞∞8 C
elementType
∞∞D O
,
∞∞O P
int
∞∞Q T
polySize
∞∞U ]
)
∞∞] ^
{
±± 	

Tessellate
≤≤ 
(
≤≤ 
windingRule
≤≤ "
,
≤≤" #
elementType
≤≤$ /
,
≤≤/ 0
polySize
≤≤1 9
,
≤≤9 :
null
≤≤; ?
)
≤≤? @
;
≤≤@ A
}
≥≥ 	
public
µµ 
void
µµ 

Tessellate
µµ 
(
µµ 
WindingRule
µµ *
windingRule
µµ+ 6
,
µµ6 7
ElementType
µµ8 C
elementType
µµD O
,
µµO P
int
µµQ T
polySize
µµU ]
,
µµ] ^
CombineCallback
µµ_ n
combineCallback
µµo ~
)
µµ~ 
{
∂∂ 	
_normal
∑∑ 
=
∑∑ 
Vec3
∑∑ 
.
∑∑ 
Zero
∑∑ 
;
∑∑  
	_vertices
∏∏ 
=
∏∏ 
null
∏∏ 
;
∏∏ 
	_elements
ππ 
=
ππ 
null
ππ 
;
ππ 
_windingRule
ªª 
=
ªª 
windingRule
ªª &
;
ªª& '
_combineCallback
ºº 
=
ºº 
combineCallback
ºº .
;
ºº. /
if
ææ 
(
ææ 
_mesh
ææ 
==
ææ 
null
ææ 
)
ææ 
{
øø 
return
¿¿ 
;
¿¿ 
}
¡¡ 
ProjectPolygon
≈≈ 
(
≈≈ 
)
≈≈ 
;
≈≈ 
ComputeInterior
ÃÃ 
(
ÃÃ 
)
ÃÃ 
;
ÃÃ 
if
—— 
(
—— 
elementType
—— 
==
—— 
ElementType
—— *
.
——* +
BoundaryContours
——+ ;
)
——; <
{
““ 
SetWindingNumber
””  
(
””  !
$num
””! "
,
””" #
true
””$ (
)
””( )
;
””) *
}
‘‘ 
else
’’ 
{
÷÷  
TessellateInterior
◊◊ "
(
◊◊" #
)
◊◊# $
;
◊◊$ %
}
ÿÿ 
_mesh
⁄⁄ 
.
⁄⁄ 
Check
⁄⁄ 
(
⁄⁄ 
)
⁄⁄ 
;
⁄⁄ 
if
‹‹ 
(
‹‹ 
elementType
‹‹ 
==
‹‹ 
ElementType
‹‹ *
.
‹‹* +
BoundaryContours
‹‹+ ;
)
‹‹; <
{
›› 
OutputContours
ﬁﬁ 
(
ﬁﬁ 
)
ﬁﬁ  
;
ﬁﬁ  !
}
ﬂﬂ 
else
‡‡ 
{
·· 
OutputPolymesh
‚‚ 
(
‚‚ 
elementType
‚‚ *
,
‚‚* +
polySize
‚‚, 4
)
‚‚4 5
;
‚‚5 6
}
„„ 
if
ÂÂ 
(
ÂÂ 

UsePooling
ÂÂ 
)
ÂÂ 
{
ÊÊ 
_mesh
ÁÁ 
.
ÁÁ 
Free
ÁÁ 
(
ÁÁ 
)
ÁÁ 
;
ÁÁ 
}
ËË 
_mesh
ÈÈ 
=
ÈÈ 
null
ÈÈ 
;
ÈÈ 
}
ÍÍ 	
}
ÎÎ 
}ÏÏ 
}ÓÓ áΩ
™D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\UniversalAdditionalCameraData.cs
	namespace

 	
UnityEngine


 
.

 
	Rendering

 
.

  
LWRP

  $
{ 
[ 
Obsolete 
( 
$str t
,t u
truev z
)z {
]{ |
public 

class $
LWRPAdditionalCameraData )
{ 
} 
} 
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
enum5 9 
CameraOverrideOption: N
{ 
Off 
, 
On 

,
 
UsePipelineSettings 
, 
} 
["" 
	MovedFrom"" 
("" 
$str"" +
)""+ ,
]"", -
public"". 4
enum""5 9"
RendererOverrideOption"": P
{## 
Custom$$ 
,$$ 
UsePipelineSettings%% 
,%% 
}&& 
public.. 

enum.. 
AntialiasingMode..  
{// 
None00 
,00 '
FastApproximateAntialiasing11 #
,11# $-
!SubpixelMorphologicalAntiAliasing22 )
,22) *
}44 
public;; 

enum;; 
CameraRenderType;;  
{<< 
Base== 
,== 
Overlay>> 
,>> 
}?? 
publicDD 

enumDD 
AntialiasingQualityDD #
{EE 
LowFF 
,FF 
MediumGG 
,GG 
HighHH 
}II 
publicNN 

staticNN 
classNN 
CameraExtensionsNN (
{OO 
publicWW 
staticWW )
UniversalAdditionalCameraDataWW 3,
 GetUniversalAdditionalCameraDataWW4 T
(WWT U
thisWWU Y
CameraWWZ `
cameraWWa g
)WWg h
{XX 	
varYY 

gameObjectYY 
=YY 
cameraYY #
.YY# $

gameObjectYY$ .
;YY. /
boolZZ 
componentExistsZZ  
=ZZ! "

gameObjectZZ# -
.ZZ- .
TryGetComponentZZ. =
<ZZ= >)
UniversalAdditionalCameraDataZZ> [
>ZZ[ \
(ZZ\ ]
outZZ] `
varZZa d

cameraDataZZe o
)ZZo p
;ZZp q
if[[ 
([[ 
![[ 
componentExists[[  
)[[  !

cameraData\\ 
=\\ 

gameObject\\ '
.\\' (
AddComponent\\( 4
<\\4 5)
UniversalAdditionalCameraData\\5 R
>\\R S
(\\S T
)\\T U
;\\U V
return^^ 

cameraData^^ 
;^^ 
}__ 	
}`` 
staticbb 

classbb 
CameraTypeUtilitybb "
{cc 
staticdd 
stringdd 
[dd 
]dd 
s_CameraTypeNamesdd )
=dd* +
Enumdd, 0
.dd0 1
GetNamesdd1 9
(dd9 :
typeofdd: @
(dd@ A
CameraRenderTypeddA Q
)ddQ R
)ddR S
.ddS T
ToArrayddT [
(dd[ \
)dd\ ]
;dd] ^
publicff 
staticff 
stringff 
GetNameff $
(ff$ %
thisff% )
CameraRenderTypeff* :
typeff; ?
)ff? @
{gg 	
inthh 
typeInthh 
=hh 
(hh 
inthh 
)hh 
typehh #
;hh# $
ifii 
(ii 
typeIntii 
<ii 
$numii 
||ii 
typeIntii &
>=ii' )
s_CameraTypeNamesii* ;
.ii; <
Lengthii< B
)iiB C
typeIntjj 
=jj 
(jj 
intjj 
)jj 
CameraRenderTypejj /
.jj/ 0
Basejj0 4
;jj4 5
returnkk 
s_CameraTypeNameskk $
[kk$ %
typeIntkk% ,
]kk, -
;kk- .
}ll 	
}mm 
[oo %
DisallowMultipleComponentoo 
]oo 
[pp 
RequireComponentpp 
(pp 
typeofpp 
(pp 
Camerapp #
)pp# $
)pp$ %
]pp% &
[qq )
ImageEffectAllowedInSceneViewqq "
]qq" #
[rr 
	MovedFromrr 
(rr 
$strrr +
)rr+ ,
]rr, -
publicrr. 4
classrr5 :)
UniversalAdditionalCameraDatarr; X
:rrY Z
MonoBehaviourrr[ h
,rrh i+
ISerializationCallbackReceiver	rrj à
{ss 
[tt 	 
FormerlySerializedAstt	 
(tt 
$strtt -
)tt- .
,tt. /
SerializeFieldtt0 >
]tt> ?
booluu 
m_RenderShadowsuu 
=uu 
trueuu #
;uu# $
[ww 	
SerializeFieldww	 
]ww  
CameraOverrideOptionxx (
m_RequiresDepthTextureOptionxx 9
=xx: ; 
CameraOverrideOptionxx< P
.xxP Q
UsePipelineSettingsxxQ d
;xxd e
[zz 	
SerializeFieldzz	 
]zz  
CameraOverrideOption{{ )
m_RequiresOpaqueTextureOption{{ :
={{; < 
CameraOverrideOption{{= Q
.{{Q R
UsePipelineSettings{{R e
;{{e f
[}} 	
SerializeField}}	 
]}} 
CameraRenderType}} )
m_CameraType}}* 6
=}}7 8
CameraRenderType}}9 I
.}}I J
Base}}J N
;}}N O
[~~ 
SerializeField~~ 
]~~ 
List~~ 
<~~ 
Camera~~ 
>~~ 
	m_Cameras~~  )
=~~* +
new~~, /
List~~0 4
<~~4 5
Camera~~5 ;
>~~; <
(~~< =
)~~= >
;~~> ?
[ 
SerializeField 
] 
int 
m_RendererIndex &
=' (
-) *
$num* +
;+ ,
[
ÅÅ 	
SerializeField
ÅÅ	 
]
ÅÅ 
	LayerMask
ÅÅ "
m_VolumeLayerMask
ÅÅ# 4
=
ÅÅ5 6
$num
ÅÅ7 8
;
ÅÅ8 9
[
ÇÇ 	
SerializeField
ÇÇ	 
]
ÇÇ 
	Transform
ÇÇ "
m_VolumeTrigger
ÇÇ# 2
=
ÇÇ3 4
null
ÇÇ5 9
;
ÇÇ9 :
[
ÑÑ 	
SerializeField
ÑÑ	 
]
ÑÑ 
bool
ÑÑ $
m_RenderPostProcessing
ÑÑ 4
=
ÑÑ5 6
false
ÑÑ7 <
;
ÑÑ< =
[
ÖÖ 	
SerializeField
ÖÖ	 
]
ÖÖ 
AntialiasingMode
ÖÖ )
m_Antialiasing
ÖÖ* 8
=
ÖÖ9 :
AntialiasingMode
ÖÖ; K
.
ÖÖK L
None
ÖÖL P
;
ÖÖP Q
[
ÜÜ 	
SerializeField
ÜÜ	 
]
ÜÜ !
AntialiasingQuality
ÜÜ ,#
m_AntialiasingQuality
ÜÜ- B
=
ÜÜC D!
AntialiasingQuality
ÜÜE X
.
ÜÜX Y
High
ÜÜY ]
;
ÜÜ] ^
[
áá 	
SerializeField
áá	 
]
áá 
bool
áá 
	m_StopNaN
áá '
=
áá( )
false
áá* /
;
áá/ 0
[
àà 	
SerializeField
àà	 
]
àà 
bool
àà 
m_Dithering
àà )
=
àà* +
false
àà, 1
;
àà1 2
[
ââ 	
SerializeField
ââ	 
]
ââ 
bool
ââ 
m_ClearDepth
ââ *
=
ââ+ ,
true
ââ- 1
;
ââ1 2
[
ää 	
SerializeField
ää	 
]
ää 
bool
ää  
m_AllowXRRendering
ää 0
=
ää1 2
true
ää3 7
;
ää7 8
[
çç 	"
FormerlySerializedAs
çç	 
(
çç 
$str
çç 4
)
çç4 5
,
çç5 6
SerializeField
çç7 E
]
ççE F
bool
éé $
m_RequiresDepthTexture
éé #
=
éé$ %
false
éé& +
;
éé+ ,
[
êê 	"
FormerlySerializedAs
êê	 
(
êê 
$str
êê 4
)
êê4 5
,
êê5 6
SerializeField
êê7 E
]
êêE F
bool
ëë $
m_RequiresColorTexture
ëë #
=
ëë$ %
false
ëë& +
;
ëë+ ,
[
ìì 	
HideInInspector
ìì	 
]
ìì 
[
ìì 
SerializeField
ìì )
]
ìì) *
float
ìì+ 0
	m_Version
ìì1 :
=
ìì; <
$num
ìì= >
;
ìì> ?
public
ïï 
float
ïï 
version
ïï 
=>
ïï 
	m_Version
ïï  )
;
ïï) *
static
óó +
UniversalAdditionalCameraData
óó ,+
s_DefaultAdditionalCameraData
óó- J
=
óóK L
null
óóM Q
;
óóQ R
internal
òò 
static
òò +
UniversalAdditionalCameraData
òò 5)
defaultAdditionalCameraData
òò6 Q
{
ôô 	
get
öö 
{
õõ 
if
úú 
(
úú +
s_DefaultAdditionalCameraData
úú 1
==
úú2 4
null
úú5 9
)
úú9 :+
s_DefaultAdditionalCameraData
ùù 1
=
ùù2 3
new
ùù4 7+
UniversalAdditionalCameraData
ùù8 U
(
ùùU V
)
ùùV W
;
ùùW X
return
üü +
s_DefaultAdditionalCameraData
üü 4
;
üü4 5
}
†† 
}
°° 	
public
¶¶ 
bool
¶¶ 
renderShadows
¶¶ !
{
ßß 	
get
®® 
=>
®® 
m_RenderShadows
®® "
;
®®" #
set
©© 
=>
©© 
m_RenderShadows
©© "
=
©©# $
value
©©% *
;
©©* +
}
™™ 	
public
±± "
CameraOverrideOption
±± #!
requiresDepthOption
±±$ 7
{
≤≤ 	
get
≥≥ 
=>
≥≥ *
m_RequiresDepthTextureOption
≥≥ /
;
≥≥/ 0
set
¥¥ 
=>
¥¥ *
m_RequiresDepthTextureOption
¥¥ /
=
¥¥0 1
value
¥¥2 7
;
¥¥7 8
}
µµ 	
public
ªª "
CameraOverrideOption
ªª #!
requiresColorOption
ªª$ 7
{
ºº 	
get
ΩΩ 
=>
ΩΩ +
m_RequiresOpaqueTextureOption
ΩΩ 0
;
ΩΩ0 1
set
ææ 
=>
ææ +
m_RequiresOpaqueTextureOption
ææ 0
=
ææ1 2
value
ææ3 8
;
ææ8 9
}
øø 	
public
≈≈ 
CameraRenderType
≈≈ 

renderType
≈≈  *
{
∆∆ 	
get
«« 
=>
«« 
m_CameraType
«« 
;
««  
set
»» 
=>
»» 
m_CameraType
»» 
=
»»  !
value
»»" '
;
»»' (
}
…… 	
public
–– 
List
–– 
<
–– 
Camera
–– 
>
–– 
cameraStack
–– '
{
—— 	
get
““ 
{
”” 
if
‘‘ 
(
‘‘ 

renderType
‘‘ 
!=
‘‘ !
CameraRenderType
‘‘" 2
.
‘‘2 3
Base
‘‘3 7
)
‘‘7 8
{
’’ 
var
÷÷ 
camera
÷÷ 
=
÷÷  

gameObject
÷÷! +
.
÷÷+ ,
GetComponent
÷÷, 8
<
÷÷8 9
Camera
÷÷9 ?
>
÷÷? @
(
÷÷@ A
)
÷÷A B
;
÷÷B C
Debug
◊◊ 
.
◊◊ 

LogWarning
◊◊ $
(
◊◊$ %
string
◊◊% +
.
◊◊+ ,
Format
◊◊, 2
(
◊◊2 3
$str◊◊3 Ä
,◊◊Ä Å
camera◊◊Ç à
.◊◊à â
name◊◊â ç
,◊◊ç é

renderType◊◊è ô
)◊◊ô ö
)◊◊ö õ
;◊◊õ ú
return
ÿÿ 
null
ÿÿ 
;
ÿÿ  
}
ŸŸ 
if
€€ 
(
€€  
scriptableRenderer
€€ &
.
€€& '(
supportedRenderingFeatures
€€' A
.
€€A B
cameraStacking
€€B P
==
€€Q S
false
€€T Y
)
€€Y Z
{
‹‹ 
var
›› 
camera
›› 
=
››  

gameObject
››! +
.
››+ ,
GetComponent
››, 8
<
››8 9
Camera
››9 ?
>
››? @
(
››@ A
)
››A B
;
››B C
Debug
ﬁﬁ 
.
ﬁﬁ 

LogWarning
ﬁﬁ $
(
ﬁﬁ$ %
string
ﬁﬁ% +
.
ﬁﬁ+ ,
Format
ﬁﬁ, 2
(
ﬁﬁ2 3
$strﬁﬁ3 ö
,ﬁﬁö õ
cameraﬁﬁú ¢
.ﬁﬁ¢ £
nameﬁﬁ£ ß
)ﬁﬁß ®
)ﬁﬁ® ©
;ﬁﬁ© ™
return
ﬂﬂ 
null
ﬂﬂ 
;
ﬂﬂ  
}
‡‡ 
return
·· 
	m_Cameras
··  
;
··  !
}
‚‚ 
}
„„ 	
internal
ÂÂ 
void
ÂÂ 
UpdateCameraStack
ÂÂ '
(
ÂÂ' (
)
ÂÂ( )
{
ÊÊ 	
Undo
ËË 
.
ËË 
RecordObject
ËË 
(
ËË 
this
ËË "
,
ËË" #
$str
ËË$ 9
)
ËË9 :
;
ËË: ;
int
ÍÍ 
prev
ÍÍ 
=
ÍÍ 
	m_Cameras
ÍÍ  
.
ÍÍ  !
Count
ÍÍ! &
;
ÍÍ& '
	m_Cameras
ÎÎ 
.
ÎÎ 
	RemoveAll
ÎÎ 
(
ÎÎ  
cam
ÎÎ  #
=>
ÎÎ$ &
cam
ÎÎ' *
==
ÎÎ+ -
null
ÎÎ. 2
)
ÎÎ2 3
;
ÎÎ3 4
int
ÏÏ 
curr
ÏÏ 
=
ÏÏ 
	m_Cameras
ÏÏ  
.
ÏÏ  !
Count
ÏÏ! &
;
ÏÏ& '
int
ÌÌ 
removedCamsCount
ÌÌ  
=
ÌÌ! "
prev
ÌÌ# '
-
ÌÌ( )
curr
ÌÌ* .
;
ÌÌ. /
if
ÓÓ 
(
ÓÓ 
removedCamsCount
ÓÓ  
!=
ÓÓ! #
$num
ÓÓ$ %
)
ÓÓ% &
{
ÔÔ 
Debug
 
.
 

LogWarning
  
(
  !
name
! %
+
& '
$str
( ,
+
- .
removedCamsCount
/ ?
+
@ A
$str
B S
+
T U
(
V W
removedCamsCount
W g
>
h i
$num
j k
?
l m
$str
n q
:
r s
$str
t v
)
v w
+
x y
$strz ∏
)∏ π
;π ∫
}
ÒÒ 
}
ÚÚ 	
public
˜˜ 
bool
˜˜ 

clearDepth
˜˜ 
{
¯¯ 	
get
˘˘ 
=>
˘˘ 
m_ClearDepth
˘˘ 
;
˘˘  
}
˙˙ 	
public
ÄÄ 
bool
ÄÄ "
requiresDepthTexture
ÄÄ (
{
ÅÅ 	
get
ÇÇ 
{
ÉÉ 
if
ÑÑ 
(
ÑÑ *
m_RequiresDepthTextureOption
ÑÑ 0
==
ÑÑ1 3"
CameraOverrideOption
ÑÑ4 H
.
ÑÑH I!
UsePipelineSettings
ÑÑI \
)
ÑÑ\ ]
{
ÖÖ 
return
ÜÜ %
UniversalRenderPipeline
ÜÜ 2
.
ÜÜ2 3
asset
ÜÜ3 8
.
ÜÜ8 9(
supportsCameraDepthTexture
ÜÜ9 S
;
ÜÜS T
}
áá 
else
àà 
{
ââ 
return
ää *
m_RequiresDepthTextureOption
ää 7
==
ää8 :"
CameraOverrideOption
ää; O
.
ääO P
On
ääP R
;
ääR S
}
ãã 
}
åå 
set
çç 
{
çç *
m_RequiresDepthTextureOption
çç .
=
çç/ 0
(
çç1 2
value
çç2 7
)
çç7 8
?
çç9 :"
CameraOverrideOption
çç; O
.
ççO P
On
ççP R
:
ççS T"
CameraOverrideOption
ççU i
.
ççi j
Off
ççj m
;
ççm n
}
çço p
}
éé 	
public
îî 
bool
îî "
requiresColorTexture
îî (
{
ïï 	
get
ññ 
{
óó 
if
òò 
(
òò +
m_RequiresOpaqueTextureOption
òò 1
==
òò2 4"
CameraOverrideOption
òò5 I
.
òòI J!
UsePipelineSettings
òòJ ]
)
òò] ^
{
ôô 
return
öö %
UniversalRenderPipeline
öö 2
.
öö2 3
asset
öö3 8
.
öö8 9)
supportsCameraOpaqueTexture
öö9 T
;
ööT U
}
õõ 
else
úú 
{
ùù 
return
ûû +
m_RequiresOpaqueTextureOption
ûû 8
==
ûû9 ;"
CameraOverrideOption
ûû< P
.
ûûP Q
On
ûûQ S
;
ûûS T
}
üü 
}
†† 
set
°° 
{
°° +
m_RequiresOpaqueTextureOption
°° /
=
°°0 1
(
°°2 3
value
°°3 8
)
°°8 9
?
°°: ;"
CameraOverrideOption
°°< P
.
°°P Q
On
°°Q S
:
°°T U"
CameraOverrideOption
°°V j
.
°°j k
Off
°°k n
;
°°n o
}
°°p q
}
¢¢ 	
public
ßß  
ScriptableRenderer
ßß ! 
scriptableRenderer
ßß" 4
{
®® 	
get
©© 
=>
©© %
UniversalRenderPipeline
©© *
.
©©* +
asset
©©+ 0
?
©©0 1
.
©©1 2
GetRenderer
©©2 =
(
©©= >
m_RendererIndex
©©> M
)
©©M N
;
©©N O
}
™™ 	
public
∞∞ 
void
∞∞ 
SetRenderer
∞∞ 
(
∞∞  
int
∞∞  #
index
∞∞$ )
)
∞∞) *
{
±± 	
m_RendererIndex
≤≤ 
=
≤≤ 
index
≤≤ #
;
≤≤# $
}
≥≥ 	
public
µµ 
	LayerMask
µµ 
volumeLayerMask
µµ (
{
∂∂ 	
get
∑∑ 
=>
∑∑ 
m_VolumeLayerMask
∑∑ $
;
∑∑$ %
set
∏∏ 
=>
∏∏ 
m_VolumeLayerMask
∏∏ $
=
∏∏% &
value
∏∏' ,
;
∏∏, -
}
ππ 	
public
ªª 
	Transform
ªª 
volumeTrigger
ªª &
{
ºº 	
get
ΩΩ 
=>
ΩΩ 
m_VolumeTrigger
ΩΩ "
;
ΩΩ" #
set
ææ 
=>
ææ 
m_VolumeTrigger
ææ "
=
ææ# $
value
ææ% *
;
ææ* +
}
øø 	
public
ƒƒ 
bool
ƒƒ "
renderPostProcessing
ƒƒ (
{
≈≈ 	
get
∆∆ 
=>
∆∆ $
m_RenderPostProcessing
∆∆ )
;
∆∆) *
set
«« 
=>
«« $
m_RenderPostProcessing
«« )
=
««* +
value
««, 1
;
««1 2
}
»» 	
public
ŒŒ 
AntialiasingMode
ŒŒ 
antialiasing
ŒŒ  ,
{
œœ 	
get
–– 
=>
–– 
m_Antialiasing
–– !
;
––! "
set
—— 
=>
—— 
m_Antialiasing
—— !
=
——" #
value
——$ )
;
——) *
}
““ 	
public
ÿÿ !
AntialiasingQuality
ÿÿ "!
antialiasingQuality
ÿÿ# 6
{
ŸŸ 	
get
⁄⁄ 
=>
⁄⁄ #
m_AntialiasingQuality
⁄⁄ (
;
⁄⁄( )
set
€€ 
=>
€€ #
m_AntialiasingQuality
€€ (
=
€€) *
value
€€+ 0
;
€€0 1
}
‹‹ 	
public
ﬁﬁ 
bool
ﬁﬁ 
stopNaN
ﬁﬁ 
{
ﬂﬂ 	
get
‡‡ 
=>
‡‡ 
	m_StopNaN
‡‡ 
;
‡‡ 
set
·· 
=>
·· 
	m_StopNaN
·· 
=
·· 
value
·· $
;
··$ %
}
‚‚ 	
public
‰‰ 
bool
‰‰ 
	dithering
‰‰ 
{
ÂÂ 	
get
ÊÊ 
=>
ÊÊ 
m_Dithering
ÊÊ 
;
ÊÊ 
set
ÁÁ 
=>
ÁÁ 
m_Dithering
ÁÁ 
=
ÁÁ  
value
ÁÁ! &
;
ÁÁ& '
}
ËË 	
public
ÌÌ 
bool
ÌÌ 
allowXRRendering
ÌÌ $
{
ÓÓ 	
get
ÔÔ 
=>
ÔÔ  
m_AllowXRRendering
ÔÔ %
;
ÔÔ% &
set
 
=>
  
m_AllowXRRendering
 %
=
& '
value
( -
;
- .
}
ÒÒ 	
public
ÛÛ 
void
ÛÛ 
OnBeforeSerialize
ÛÛ %
(
ÛÛ% &
)
ÛÛ& '
{
ÙÙ 	
}
ıı 	
public
˜˜ 
void
˜˜  
OnAfterDeserialize
˜˜ &
(
˜˜& '
)
˜˜' (
{
¯¯ 	
if
˘˘ 
(
˘˘ 
version
˘˘ 
<=
˘˘ 
$num
˘˘ 
)
˘˘ 
{
˙˙ *
m_RequiresDepthTextureOption
˚˚ ,
=
˚˚- .
(
˚˚/ 0$
m_RequiresDepthTexture
˚˚0 F
)
˚˚F G
?
˚˚H I"
CameraOverrideOption
˚˚J ^
.
˚˚^ _
On
˚˚_ a
:
˚˚b c"
CameraOverrideOption
˚˚d x
.
˚˚x y
Off
˚˚y |
;
˚˚| }+
m_RequiresOpaqueTextureOption
¸¸ -
=
¸¸. /
(
¸¸0 1$
m_RequiresColorTexture
¸¸1 G
)
¸¸G H
?
¸¸I J"
CameraOverrideOption
¸¸K _
.
¸¸_ `
On
¸¸` b
:
¸¸c d"
CameraOverrideOption
¸¸e y
.
¸¸y z
Off
¸¸z }
;
¸¸} ~
}
˝˝ 
}
˛˛ 	
public
ÄÄ 
void
ÄÄ 
OnDrawGizmos
ÄÄ  
(
ÄÄ  !
)
ÄÄ! "
{
ÅÅ 	
string
ÇÇ 
path
ÇÇ 
=
ÇÇ 
$str
ÇÇ X
;
ÇÇX Y
string
ÉÉ 
	gizmoName
ÉÉ 
=
ÉÉ 
$str
ÉÉ !
;
ÉÉ! "
Color
ÑÑ 
tint
ÑÑ 
=
ÑÑ 
Color
ÑÑ 
.
ÑÑ 
white
ÑÑ $
;
ÑÑ$ %
if
ÜÜ 
(
ÜÜ 
m_CameraType
ÜÜ 
==
ÜÜ 
CameraRenderType
ÜÜ  0
.
ÜÜ0 1
Base
ÜÜ1 5
)
ÜÜ5 6
{
áá 
	gizmoName
àà 
=
àà 
$"
àà 
{
àà 
path
àà #
}
àà# $
Camera_Base.png
àà$ 3
"
àà3 4
;
àà4 5
}
ââ 
else
ää 
if
ää 
(
ää 
m_CameraType
ää !
==
ää" $
CameraRenderType
ää% 5
.
ää5 6
Overlay
ää6 =
)
ää= >
{
ãã 
	gizmoName
åå 
=
åå 
$"
åå 
{
åå 
path
åå #
}
åå# $ 
Camera_Overlay.png
åå$ 6
"
åå6 7
;
åå7 8
}
çç 
if
ëë 
(
ëë 
	Selection
ëë 
.
ëë 
activeObject
ëë &
==
ëë' )

gameObject
ëë* 4
)
ëë4 5
{
íí 
tint
îî 
=
îî 
	SceneView
îî  
.
îî  !"
selectedOutlineColor
îî! 5
;
îî5 6
}
ïï 
if
óó 
(
óó 
!
óó 
string
óó 
.
óó 
IsNullOrEmpty
óó %
(
óó% &
	gizmoName
óó& /
)
óó/ 0
)
óó0 1
{
òò 
Gizmos
ôô 
.
ôô 
DrawIcon
ôô 
(
ôô  
	transform
ôô  )
.
ôô) *
position
ôô* 2
,
ôô2 3
	gizmoName
ôô4 =
,
ôô= >
true
ôô? C
,
ôôC D
tint
ôôE I
)
ôôI J
;
ôôJ K
}
öö 
if
úú 
(
úú "
renderPostProcessing
úú $
)
úú$ %
{
ùù 
Gizmos
ûû 
.
ûû 
DrawIcon
ûû 
(
ûû  
	transform
ûû  )
.
ûû) *
position
ûû* 2
,
ûû2 3
$"
ûû4 6
{
ûû6 7
path
ûû7 ;
}
ûû; <'
Camera_PostProcessing.png
ûû< U
"
ûûU V
,
ûûV W
true
ûûX \
,
ûû\ ]
tint
ûû^ b
)
ûûb c
;
ûûc d
}
üü 
}
ßß 	
}
®® 
}©© ñ+
®D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\External\LibTessDotNet\Dict.cs
	namespace$$ 	
UnityEngine$$
 
.$$ 
Experimental$$ "
.$$" #
	Rendering$$# ,
.$$, -
	Universal$$- 6
{%% 
	namespace'' 	
LibTessDotNet''
 
{(( 
internal)) 
class)) 
Dict)) 
<)) 
TValue)) 
>)) 
where))  %
TValue))& ,
:))- .
class))/ 4
{** 
public++ 
class++ 
Node++ 
{,, 	
internal-- 
TValue-- 
_key--  
;--  !
internal.. 
Node.. 
_prev.. 
,..  
_next..! &
;..& '
public00 
TValue00 
Key00 
{00 
get00  #
{00$ %
return00& ,
_key00- 1
;001 2
}003 4
}005 6
public11 
Node11 
Prev11 
{11 
get11 "
{11# $
return11% +
_prev11, 1
;111 2
}113 4
}115 6
public22 
Node22 
Next22 
{22 
get22 "
{22# $
return22% +
_next22, 1
;221 2
}223 4
}225 6
}33 	
public55 
delegate55 
bool55 
LessOrEqual55 (
(55( )
TValue55) /
lhs550 3
,553 4
TValue555 ;
rhs55< ?
)55? @
;55@ A
private77 
LessOrEqual77 
_leq77  
;77  !
Node88 
_head88 
;88 
public:: 
Dict:: 
(:: 
LessOrEqual:: 
leq::  #
)::# $
{;; 	
_leq<< 
=<< 
leq<< 
;<< 
_head>> 
=>> 
new>> 
Node>> 
{>> 
_key>> #
=>>$ %
null>>& *
}>>+ ,
;>>, -
_head?? 
.?? 
_prev?? 
=?? 
_head?? 
;??  
_head@@ 
.@@ 
_next@@ 
=@@ 
_head@@ 
;@@  
}AA 	
publicCC 
NodeCC 
InsertCC 
(CC 
TValueCC !
keyCC" %
)CC% &
{DD 	
returnEE 
InsertBeforeEE 
(EE  
_headEE  %
,EE% &
keyEE' *
)EE* +
;EE+ ,
}FF 	
publicHH 
NodeHH 
InsertBeforeHH  
(HH  !
NodeHH! %
nodeHH& *
,HH* +
TValueHH, 2
keyHH3 6
)HH6 7
{II 	
doJJ 
{JJ 
nodeKK 
=KK 
nodeKK 
.KK 
_prevKK !
;KK! "
}LL 
whileLL 
(LL 
nodeLL 
.LL 
_keyLL 
!=LL !
nullLL" &
&&LL' )
!LL* +
_leqLL+ /
(LL/ 0
nodeLL0 4
.LL4 5
_keyLL5 9
,LL9 :
keyLL; >
)LL> ?
)LL? @
;LL@ A
varNN 
newNodeNN 
=NN 
newNN 
NodeNN "
{NN# $
_keyNN% )
=NN* +
keyNN, /
}NN0 1
;NN1 2
newNodeOO 
.OO 
_nextOO 
=OO 
nodeOO  
.OO  !
_nextOO! &
;OO& '
nodePP 
.PP 
_nextPP 
.PP 
_prevPP 
=PP 
newNodePP &
;PP& '
newNodeQQ 
.QQ 
_prevQQ 
=QQ 
nodeQQ  
;QQ  !
nodeRR 
.RR 
_nextRR 
=RR 
newNodeRR  
;RR  !
returnTT 
newNodeTT 
;TT 
}UU 	
publicWW 
NodeWW 
FindWW 
(WW 
TValueWW 
keyWW  #
)WW# $
{XX 	
varYY 
nodeYY 
=YY 
_headYY 
;YY 
doZZ 
{ZZ 
node[[ 
=[[ 
node[[ 
.[[ 
_next[[ !
;[[! "
}\\ 
while\\ 
(\\ 
node\\ 
.\\ 
_key\\ 
!=\\ !
null\\" &
&&\\' )
!\\* +
_leq\\+ /
(\\/ 0
key\\0 3
,\\3 4
node\\5 9
.\\9 :
_key\\: >
)\\> ?
)\\? @
;\\@ A
return]] 
node]] 
;]] 
}^^ 	
public`` 
Node`` 
Min`` 
(`` 
)`` 
{aa 	
returnbb 
_headbb 
.bb 
_nextbb 
;bb 
}cc 	
publicee 
voidee 
Removeee 
(ee 
Nodeee 
nodeee  $
)ee$ %
{ff 	
nodegg 
.gg 
_nextgg 
.gg 
_prevgg 
=gg 
nodegg #
.gg# $
_prevgg$ )
;gg) *
nodehh 
.hh 
_prevhh 
.hh 
_nexthh 
=hh 
nodehh #
.hh# $
_nexthh$ )
;hh) *
}ii 	
}jj 
}kk 
}mm “N
°D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\FinalBlitPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
public

 

class

 
FinalBlitPass

 
:

   
ScriptableRenderPass

! 5
{ 
RenderTargetHandle 
m_Source #
;# $
Material 
m_BlitMaterial 
;  
public 
FinalBlitPass 
( 
RenderPassEvent ,
evt- 0
,0 1
Material2 :
blitMaterial; G
)G H
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @
FinalBlitPass@ M
)M N
)N O
;O P
m_BlitMaterial 
= 
blitMaterial )
;) *
renderPassEvent 
= 
evt !
;! "
} 	
public 
void 
Setup 
( #
RenderTextureDescriptor 1
baseDescriptor2 @
,@ A
RenderTargetHandleB T
colorHandleU `
)` a
{ 	
m_Source 
= 
colorHandle "
;" #
} 	
public"" 
override"" 
void"" 
Execute"" $
(""$ %#
ScriptableRenderContext""% <
context""= D
,""D E
ref""F I
RenderingData""J W
renderingData""X e
)""e f
{## 	
if$$ 
($$ 
m_BlitMaterial$$ 
==$$ !
null$$" &
)$$& '
{%% 
Debug&& 
.&& 
LogErrorFormat&& $
(&&$ %
$str	&&% å
,
&&å ç
m_BlitMaterial
&&é ú
,
&&ú ù
GetType
&&û •
(
&&• ¶
)
&&¶ ß
.
&&ß ®
Name
&&® ¨
)
&&¨ ≠
;
&&≠ Æ
return'' 
;'' 
}(( 
ref,, 

CameraData,, 

cameraData,, %
=,,& '
ref,,( +
renderingData,,, 9
.,,9 :

cameraData,,: D
;,,D E"
RenderTargetIdentifier-- "
cameraTarget--# /
=--0 1
(--2 3

cameraData--3 =
.--= >
targetTexture--> K
!=--L N
null--O S
)--S T
?--U V
new--W Z"
RenderTargetIdentifier--[ q
(--q r

cameraData--r |
.--| }
targetTexture	--} ä
)
--ä ã
:
--å ç&
BuiltinRenderTextureType
--é ¶
.
--¶ ß
CameraTarget
--ß ≥
;
--≥ ¥
bool// 
isSceneViewCamera// "
=//# $

cameraData//% /
./// 0
isSceneViewCamera//0 A
;//A B
CommandBuffer00 
cmd00 
=00 
CommandBufferPool00  1
.001 2
Get002 5
(005 6
)006 7
;007 8
using11 
(11 
new11 
ProfilingScope11 %
(11% &
cmd11& )
,11) *
ProfilingSampler11+ ;
.11; <
Get11< ?
(11? @
URPProfileId11@ L
.11L M
	FinalBlit11M V
)11V W
)11W X
)11X Y
{22 
	CoreUtils44 
.44 

SetKeyword44 $
(44$ %
cmd44% (
,44( ) 
ShaderKeywordStrings44* >
.44> ?"
LinearToSRGBConversion44? U
,44U V

cameraData55 
.55 !
requireSrgbConversion55 4
)554 5
;555 6
cmd77 
.77 
SetGlobalTexture77 $
(77$ %
ShaderPropertyId77% 5
.775 6
	sourceTex776 ?
,77? @
m_Source77A I
.77I J

Identifier77J T
(77T U
)77U V
)77V W
;77W X
if:: 
(:: 

cameraData:: 
.:: 
xr:: !
.::! "
enabled::" )
)::) *
{;; 
int<< 

depthSlice<< "
=<<# $

cameraData<<% /
.<</ 0
xr<<0 2
.<<2 3
singlePassEnabled<<3 D
?<<E F
-<<G H
$num<<H I
:<<J K

cameraData<<L V
.<<V W
xr<<W Y
.<<Y Z 
GetTextureArraySlice<<Z n
(<<n o
)<<o p
;<<p q
cameraTarget==  
===! "
new>> "
RenderTargetIdentifier>> 2
(>>2 3

cameraData>>3 =
.>>= >
xr>>> @
.>>@ A
renderTarget>>A M
,>>M N
$num>>O P
,>>P Q
CubemapFace>>R ]
.>>] ^
Unknown>>^ e
,>>e f

depthSlice>>g q
)>>q r
;>>r s
	CoreUtils@@ 
.@@ 
SetRenderTarget@@ -
(@@- .
cmdAA 
,AA 
cameraTargetBB $
,BB$ %"
RenderBufferLoadActionCC .
.CC. /
LoadCC/ 3
,CC3 4#
RenderBufferStoreActionDD /
.DD/ 0
StoreDD0 5
,DD5 6
	ClearFlagEE !
.EE! "
NoneEE" &
,EE& '
ColorFF 
.FF 
blackFF #
)FF# $
;FF$ %
cmdHH 
.HH 
SetViewportHH #
(HH# $

cameraDataHH$ .
.HH. /
	pixelRectHH/ 8
)HH8 9
;HH9 :
boolMM 
yflipMM 
=MM  
!MM! "

cameraDataMM" ,
.MM, -
xrMM- /
.MM/ 0'
renderTargetIsRenderTextureMM0 K
&&MML N

SystemInfoMMO Y
.MMY Z!
graphicsUVStartsAtTopMMZ o
;MMo p
Vector4NN 
	scaleBiasNN %
=NN& '
yflipNN( -
?NN. /
newNN0 3
Vector4NN4 ;
(NN; <
$numNN< =
,NN= >
-NN? @
$numNN@ A
,NNA B
$numNNC D
,NND E
$numNNF G
)NNG H
:NNI J
newNNK N
Vector4NNO V
(NNV W
$numNNW X
,NNX Y
$numNNZ [
,NN[ \
$numNN] ^
,NN^ _
$numNN` a
)NNa b
;NNb c
cmdOO 
.OO 
SetGlobalVectorOO '
(OO' (
ShaderPropertyIdOO( 8
.OO8 9
	scaleBiasOO9 B
,OOB C
	scaleBiasOOD M
)OOM N
;OON O
cmdQQ 
.QQ 
DrawProceduralQQ &
(QQ& '
	Matrix4x4QQ' 0
.QQ0 1
identityQQ1 9
,QQ9 :
m_BlitMaterialQQ; I
,QQI J
$numQQK L
,QQL M
MeshTopologyQQN Z
.QQZ [
QuadsQQ[ `
,QQ` a
$numQQb c
)QQc d
;QQd e
}RR 
elseSS 
ifUU 
(UU 
isSceneViewCameraUU %
||UU& (

cameraDataUU) 3
.UU3 4
isDefaultViewportUU4 E
)UUE F
{VV 
cmdXX 
.XX 
SetRenderTargetXX '
(XX' ($
BuiltinRenderTextureTypeXX( @
.XX@ A
CameraTargetXXA M
,XXM N"
RenderBufferLoadActionYY .
.YY. /
DontCareYY/ 7
,YY7 8#
RenderBufferStoreActionYY9 P
.YYP Q
StoreYYQ V
,YYV W"
RenderBufferLoadActionZZ .
.ZZ. /
DontCareZZ/ 7
,ZZ7 8#
RenderBufferStoreActionZZ9 P
.ZZP Q
DontCareZZQ Y
)ZZY Z
;ZZZ [
cmd[[ 
.[[ 
Blit[[ 
([[ 
m_Source[[ %
.[[% &

Identifier[[& 0
([[0 1
)[[1 2
,[[2 3
cameraTarget[[4 @
,[[@ A
m_BlitMaterial[[B P
)[[P Q
;[[Q R
}\\ 
else]] 
{^^ 
	CoreUtilsbb 
.bb 
SetRenderTargetbb -
(bb- .
cmdcc 
,cc 
cameraTargetdd $
,dd$ %"
RenderBufferLoadActionee .
.ee. /
Loadee/ 3
,ee3 4#
RenderBufferStoreActionff /
.ff/ 0
Storeff0 5
,ff5 6
	ClearFlaggg !
.gg! "
Nonegg" &
,gg& '
Colorhh 
.hh 
blackhh #
)hh# $
;hh$ %
Camerajj 
camerajj !
=jj" #

cameraDatajj$ .
.jj. /
camerajj/ 5
;jj5 6
cmdkk 
.kk %
SetViewProjectionMatriceskk 1
(kk1 2
	Matrix4x4kk2 ;
.kk; <
identitykk< D
,kkD E
	Matrix4x4kkF O
.kkO P
identitykkP X
)kkX Y
;kkY Z
cmdll 
.ll 
SetViewportll #
(ll# $

cameraDatall$ .
.ll. /
	pixelRectll/ 8
)ll8 9
;ll9 :
cmdmm 
.mm 
DrawMeshmm  
(mm  !
RenderingUtilsmm! /
.mm/ 0
fullscreenMeshmm0 >
,mm> ?
	Matrix4x4mm@ I
.mmI J
identitymmJ R
,mmR S
m_BlitMaterialmmT b
)mmb c
;mmc d
cmdnn 
.nn %
SetViewProjectionMatricesnn 1
(nn1 2
camerann2 8
.nn8 9
worldToCameraMatrixnn9 L
,nnL M
camerannN T
.nnT U
projectionMatrixnnU e
)nne f
;nnf g
}oo 
}pp 
contextrr 
.rr  
ExecuteCommandBufferrr (
(rr( )
cmdrr) ,
)rr, -
;rr- .
CommandBufferPoolss 
.ss 
Releasess %
(ss% &
cmdss& )
)ss) *
;ss* +
}tt 	
}uu 
}vv ‹ì
ÆD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Data\UniversalRenderPipelineAsset.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
LWRP  $
{ 
[ 
Obsolete 
( 
$str s
,s t
trueu y
)y z
]z {
public 

class *
LightweightRenderPipelineAsset /
{ 
} 
} 
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
enum5 9
ShadowQuality: G
{ 
Disabled 
, 
HardShadows 
, 
SoftShadows 
, 
} 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
enum5 9
ShadowResolution: J
{ 
_256   
=   
$num   
,   
_512!! 
=!! 
$num!! 
,!! 
_1024"" 
="" 
$num"" 
,"" 
_2048## 
=## 
$num## 
,## 
_4096$$ 
=$$ 
$num$$ 
}%% 
['' 
	MovedFrom'' 
('' 
$str'' +
)''+ ,
]'', -
public''. 4
enum''5 9
MsaaQuality'': E
{(( 
Disabled)) 
=)) 
$num)) 
,)) 
_2x** 
=** 
$num** 
,** 
_4x++ 
=++ 
$num++ 
,++ 
_8x,, 
=,, 
$num,, 
}-- 
[// 
	MovedFrom// 
(// 
$str// +
)//+ ,
]//, -
public//. 4
enum//5 9
Downsampling//: F
{00 
None11 
,11 
_2xBilinear22 
,22 
_4xBox33 
,33 
_4xBilinear44 
}55 
internal77 
enum77 
DefaultMaterialType77 %
{88 
Standard99 
,99 
Particle:: 
,:: 
Terrain;; 
,;; 
Sprite<< 
,<< 
UnityBuiltinDefault== 
}>> 
[@@ 
	MovedFrom@@ 
(@@ 
$str@@ +
)@@+ ,
]@@, -
public@@. 4
enum@@5 9
LightRenderingMode@@: L
{AA 
DisabledBB 
=BB 
$numBB 
,BB 
	PerVertexCC 
=CC 
$numCC 
,CC 
PerPixelDD 
=DD 
$numDD 
,DD 
}EE 
[GG 
	MovedFromGG 
(GG 
$strGG +
)GG+ ,
]GG, -
publicGG. 4
enumGG5 9!
ShaderVariantLogLevelGG: O
{HH 
DisabledII 
,II "
OnlyUniversalRPShadersJJ 
,JJ 

AllShadersKK 
,KK 
}LL 
[NN 
ObsoleteNN 
(NN 
$strNN ?
,NN? @
falseNNA F
)NNF G
]NNG H
publicOO 

enumOO 
PipelineDebugLevelOO "
{PP 
DisabledQQ 
,QQ 
	ProfilingRR 
,RR 
}SS 
[UU 
	MovedFromUU 
(UU 
$strUU +
)UU+ ,
]UU, -
publicUU. 4
enumUU5 9
RendererTypeUU: F
{VV 
CustomWW 
,WW 
ForwardRendererXX 
,XX 
_2DRendererYY 
,YY 
}ZZ 
public\\ 

enum\\ 
ColorGradingMode\\  
{]] 
LowDynamicRange^^ 
,^^ 
HighDynamicRange__ 
}`` 
[bb 
ExcludeFromPresetbb 
]bb 
publiccc 

partialcc 
classcc (
UniversalRenderPipelineAssetcc 5
:cc6 7
RenderPipelineAssetcc8 K
,ccK L*
ISerializationCallbackReceiverccM k
{dd 
Shaderee 
m_DefaultShaderee 
;ee 
ScriptableRendererff 
[ff 
]ff 
m_Renderersff (
=ff) *
newff+ .
ScriptableRendererff/ A
[ffA B
$numffB C
]ffC D
;ffD E
[ii 	
SerializeFieldii	 
]ii 
intii 
k_AssetVersionii +
=ii, -
$numii. /
;ii/ 0
[jj 	
SerializeFieldjj	 
]jj 
intjj "
k_AssetPreviousVersionjj 3
=jj4 5
$numjj6 7
;jj7 8
[mm 	
SerializeFieldmm	 
]mm 
RendererTypemm %
m_RendererTypemm& 4
=mm5 6
RendererTypemm7 C
.mmC D
ForwardRenderermmD S
;mmS T
[nn 	
EditorBrowsablenn	 
(nn  
EditorBrowsableStatenn -
.nn- .
Nevernn. 3
)nn3 4
]nn4 5
[oo 	
SerializeFieldoo	 
]oo 
internaloo !"
ScriptableRendererDataoo" 8
m_RendererDataoo9 G
=ooH I
nullooJ N
;ooN O
[rr 	
SerializeFieldrr	 
]rr 
internalrr !"
ScriptableRendererDatarr" 8
[rr8 9
]rr9 :
m_RendererDataListrr; M
=rrN O
newrrP S"
ScriptableRendererDatarrT j
[rrj k
$numrrk l
]rrl m
;rrm n
[ss 	
SerializeFieldss	 
]ss 
internalss !
intss" %"
m_DefaultRendererIndexss& <
=ss= >
$numss? @
;ss@ A
[vv 	
SerializeFieldvv	 
]vv 
boolvv !
m_RequireDepthTexturevv 3
=vv4 5
falsevv6 ;
;vv; <
[ww 	
SerializeFieldww	 
]ww 
boolww "
m_RequireOpaqueTextureww 4
=ww5 6
falseww7 <
;ww< =
[xx 	
SerializeFieldxx	 
]xx 
Downsamplingxx % 
m_OpaqueDownsamplingxx& :
=xx; <
Downsamplingxx= I
.xxI J
_2xBilinearxxJ U
;xxU V
[yy 	
SerializeFieldyy	 
]yy 
boolyy "
m_SupportsTerrainHolesyy 4
=yy5 6
trueyy7 ;
;yy; <
[|| 	
SerializeField||	 
]|| 
bool|| 
m_SupportsHDR|| +
=||, -
true||. 2
;||2 3
[}} 	
SerializeField}}	 
]}} 
MsaaQuality}} $
m_MSAA}}% +
=}}, -
MsaaQuality}}. 9
.}}9 :
Disabled}}: B
;}}B C
[~~ 	
SerializeField~~	 
]~~ 
float~~ 
m_RenderScale~~ ,
=~~- .
$num~~/ 3
;~~3 4
[
ÇÇ 	
SerializeField
ÇÇ	 
]
ÇÇ  
LightRenderingMode
ÇÇ +&
m_MainLightRenderingMode
ÇÇ, D
=
ÇÇE F 
LightRenderingMode
ÇÇG Y
.
ÇÇY Z
PerPixel
ÇÇZ b
;
ÇÇb c
[
ÉÉ 	
SerializeField
ÉÉ	 
]
ÉÉ 
bool
ÉÉ )
m_MainLightShadowsSupported
ÉÉ 9
=
ÉÉ: ;
true
ÉÉ< @
;
ÉÉ@ A
[
ÑÑ 	
SerializeField
ÑÑ	 
]
ÑÑ 
ShadowResolution
ÑÑ ),
m_MainLightShadowmapResolution
ÑÑ* H
=
ÑÑI J
ShadowResolution
ÑÑK [
.
ÑÑ[ \
_2048
ÑÑ\ a
;
ÑÑa b
[
áá 	
SerializeField
áá	 
]
áá  
LightRenderingMode
áá +-
m_AdditionalLightsRenderingMode
áá, K
=
ááL M 
LightRenderingMode
ááN `
.
áá` a
PerPixel
ááa i
;
áái j
[
àà 	
SerializeField
àà	 
]
àà 
int
àà .
 m_AdditionalLightsPerObjectLimit
àà =
=
àà> ?
$num
àà@ A
;
ààA B
[
ââ 	
SerializeField
ââ	 
]
ââ 
bool
ââ /
!m_AdditionalLightShadowsSupported
ââ ?
=
ââ@ A
false
ââB G
;
ââG H
[
ää 	
SerializeField
ää	 
]
ää 
ShadowResolution
ää )3
%m_AdditionalLightsShadowmapResolution
ää* O
=
ääP Q
ShadowResolution
ääR b
.
ääb c
_512
ääc g
;
ääg h
[
çç 	
SerializeField
çç	 
]
çç 
float
çç 
m_ShadowDistance
çç /
=
çç0 1
$num
çç2 7
;
çç7 8
[
éé 	
SerializeField
éé	 
]
éé 
int
éé "
m_ShadowCascadeCount
éé 1
=
éé2 3
$num
éé4 5
;
éé5 6
[
èè 	
SerializeField
èè	 
]
èè 
float
èè 
m_Cascade2Split
èè .
=
èè/ 0
$num
èè1 6
;
èè6 7
[
êê 	
SerializeField
êê	 
]
êê 
Vector2
êê  
m_Cascade3Split
êê! 0
=
êê1 2
new
êê3 6
Vector2
êê7 >
(
êê> ?
$num
êê? C
,
êêC D
$num
êêE I
)
êêI J
;
êêJ K
[
ëë 	
SerializeField
ëë	 
]
ëë 
Vector3
ëë  
m_Cascade4Split
ëë! 0
=
ëë1 2
new
ëë3 6
Vector3
ëë7 >
(
ëë> ?
$num
ëë? E
,
ëëE F
$num
ëëG K
,
ëëK L
$num
ëëM S
)
ëëS T
;
ëëT U
[
íí 	
SerializeField
íí	 
]
íí 
float
íí 
m_ShadowDepthBias
íí 0
=
íí1 2
$num
íí3 7
;
íí7 8
[
ìì 	
SerializeField
ìì	 
]
ìì 
float
ìì  
m_ShadowNormalBias
ìì 1
=
ìì2 3
$num
ìì4 8
;
ìì8 9
[
îî 	
SerializeField
îî	 
]
îî 
bool
îî $
m_SoftShadowsSupported
îî 4
=
îî5 6
false
îî7 <
;
îî< =
[
óó 	
SerializeField
óó	 
]
óó 
bool
óó 
m_UseSRPBatcher
óó -
=
óó. /
true
óó0 4
;
óó4 5
[
òò 	
SerializeField
òò	 
]
òò 
bool
òò '
m_SupportsDynamicBatching
òò 7
=
òò8 9
false
òò: ?
;
òò? @
[
ôô 	
SerializeField
ôô	 
]
ôô 
bool
ôô &
m_MixedLightingSupported
ôô 6
=
ôô7 8
true
ôô9 =
;
ôô= >
[
öö 	
SerializeField
öö	 
]
öö 
[
öö 
Obsolete
öö !
]
öö! " 
PipelineDebugLevel
öö# 5
m_DebugLevel
öö6 B
;
ööB C
[
ùù 	
SerializeField
ùù	 
]
ùù 
bool
ùù &
m_UseAdaptivePerformance
ùù 6
=
ùù7 8
true
ùù9 =
;
ùù= >
[
†† 	
SerializeField
††	 
]
†† 
ColorGradingMode
†† ) 
m_ColorGradingMode
††* <
=
††= >
ColorGradingMode
††? O
.
††O P
LowDynamicRange
††P _
;
††_ `
[
°° 	
SerializeField
°°	 
]
°° 
int
°° #
m_ColorGradingLutSize
°° 2
=
°°3 4
$num
°°5 7
;
°°7 8
[
§§ 	
SerializeField
§§	 
]
§§ 
ShadowQuality
§§ &
m_ShadowType
§§' 3
=
§§4 5
ShadowQuality
§§6 C
.
§§C D
HardShadows
§§D O
;
§§O P
[
•• 	
SerializeField
••	 
]
•• 
bool
•• %
m_LocalShadowsSupported
•• 5
=
••6 7
false
••8 =
;
••= >
[
¶¶ 	
SerializeField
¶¶	 
]
¶¶ 
ShadowResolution
¶¶ )+
m_LocalShadowsAtlasResolution
¶¶* G
=
¶¶H I
ShadowResolution
¶¶J Z
.
¶¶Z [
_256
¶¶[ _
;
¶¶_ `
[
ßß 	
SerializeField
ßß	 
]
ßß 
int
ßß 
m_MaxPixelLights
ßß -
=
ßß. /
$num
ßß0 1
;
ßß1 2
[
®® 	
SerializeField
®®	 
]
®® 
ShadowResolution
®® )%
m_ShadowAtlasResolution
®®* A
=
®®B C
ShadowResolution
®®D T
.
®®T U
_256
®®U Y
;
®®Y Z
[
™™ 	
SerializeField
™™	 
]
™™ #
ShaderVariantLogLevel
™™ .%
m_ShaderVariantLogLevel
™™/ F
=
™™G H#
ShaderVariantLogLevel
™™I ^
.
™™^ _
Disabled
™™_ g
;
™™g h
public
ØØ 
const
ØØ 
int
ØØ 
k_MinLutSize
ØØ %
=
ØØ& '
$num
ØØ( *
;
ØØ* +
public
∞∞ 
const
∞∞ 
int
∞∞ 
k_MaxLutSize
∞∞ %
=
∞∞& '
$num
∞∞( *
;
∞∞* +
internal
≤≤ 
const
≤≤ 
int
≤≤ %
k_ShadowCascadeMinCount
≤≤ 2
=
≤≤3 4
$num
≤≤5 6
;
≤≤6 7
internal
≥≥ 
const
≥≥ 
int
≥≥ %
k_ShadowCascadeMaxCount
≥≥ 2
=
≥≥3 4
$num
≥≥5 6
;
≥≥6 7
[
∂∂ 	
NonSerialized
∂∂	 
]
∂∂ 
internal
∑∑ 4
&UniversalRenderPipelineEditorResources
∑∑ 7$
m_EditorResourcesAsset
∑∑8 N
;
∑∑N O
public
ππ 
static
ππ 
readonly
ππ 
string
ππ %
packagePath
ππ& 1
=
ππ2 3
$str
ππ4 c
;
ππc d
public
∫∫ 
static
∫∫ 
readonly
∫∫ 
string
∫∫ %!
editorResourcesGUID
∫∫& 9
=
∫∫: ;
$str
∫∫< ^
;
∫∫^ _
public
ºº 
static
ºº *
UniversalRenderPipelineAsset
ºº 2
Create
ºº3 9
(
ºº9 :$
ScriptableRendererData
ºº: P
rendererData
ººQ ]
=
ºº^ _
null
ºº` d
)
ººd e
{
ΩΩ 	
var
øø 
instance
øø 
=
øø 
CreateInstance
øø )
<
øø) **
UniversalRenderPipelineAsset
øø* F
>
øøF G
(
øøG H
)
øøH I
;
øøI J
if
¿¿ 
(
¿¿ 
rendererData
¿¿ 
!=
¿¿ 
null
¿¿  $
)
¿¿$ %
instance
¡¡ 
.
¡¡  
m_RendererDataList
¡¡ +
[
¡¡+ ,
$num
¡¡, -
]
¡¡- .
=
¡¡/ 0
rendererData
¡¡1 =
;
¡¡= >
else
¬¬ 
instance
√√ 
.
√√  
m_RendererDataList
√√ +
[
√√+ ,
$num
√√, -
]
√√- .
=
√√/ 0
CreateInstance
√√1 ?
<
√√? @!
ForwardRendererData
√√@ S
>
√√S T
(
√√T U
)
√√U V
;
√√V W
instance
∆∆ 
.
∆∆ $
m_EditorResourcesAsset
∆∆ +
=
∆∆, -
instance
∆∆. 6
.
∆∆6 7
editorResources
∆∆7 F
;
∆∆F G
return
»» 
instance
»» 
;
»» 
}
…… 	
[
ÀÀ 	
System
ÀÀ	 
.
ÀÀ 
Diagnostics
ÀÀ 
.
ÀÀ 
CodeAnalysis
ÀÀ (
.
ÀÀ( )
SuppressMessage
ÀÀ) 8
(
ÀÀ8 9
$str
ÀÀ9 P
,
ÀÀP Q
$str
ÀÀR Z
)
ÀÀZ [
]
ÀÀ[ \
internal
ÃÃ 
class
ÃÃ *
CreateUniversalPipelineAsset
ÃÃ 3
:
ÃÃ4 5
EndNameEditAction
ÃÃ6 G
{
ÕÕ 	
public
ŒŒ 
override
ŒŒ 
void
ŒŒ  
Action
ŒŒ! '
(
ŒŒ' (
int
ŒŒ( +

instanceId
ŒŒ, 6
,
ŒŒ6 7
string
ŒŒ8 >
pathName
ŒŒ? G
,
ŒŒG H
string
ŒŒI O
resourceFile
ŒŒP \
)
ŒŒ\ ]
{
œœ 
AssetDatabase
—— 
.
—— 
CreateAsset
—— )
(
——) *
Create
——* 0
(
——0 1!
CreateRendererAsset
——1 D
(
——D E
pathName
——E M
,
——M N
RendererType
——O [
.
——[ \
ForwardRenderer
——\ k
)
——k l
)
——l m
,
——m n
pathName
——o w
)
——w x
;
——x y
}
““ 
}
”” 	
[
’’ 	
MenuItem
’’	 
(
’’ 
$str
’’ g
,
’’g h
priority
’’i q
=
’’r s
	CoreUtils
’’t }
.
’’} ~'
assetCreateMenuPriority1’’~ ñ
)’’ñ ó
]’’ó ò
static
÷÷ 
void
÷÷ %
CreateUniversalPipeline
÷÷ +
(
÷÷+ ,
)
÷÷, -
{
◊◊ 	
ProjectWindowUtil
ÿÿ 
.
ÿÿ 3
%StartNameEditingIfProjectWindowExists
ÿÿ C
(
ÿÿC D
$num
ÿÿD E
,
ÿÿE F
CreateInstance
ÿÿG U
<
ÿÿU V*
CreateUniversalPipelineAsset
ÿÿV r
>
ÿÿr s
(
ÿÿs t
)
ÿÿt u
,
ÿÿu v
$str
ŸŸ 4
,
ŸŸ4 5
null
ŸŸ6 :
,
ŸŸ: ;
null
ŸŸ< @
)
ŸŸ@ A
;
ŸŸA B
}
⁄⁄ 	
static
‹‹ $
ScriptableRendererData
‹‹ %!
CreateRendererAsset
‹‹& 9
(
‹‹9 :
string
‹‹: @
path
‹‹A E
,
‹‹E F
RendererType
‹‹G S
type
‹‹T X
,
‹‹X Y
bool
‹‹Z ^
relativePath
‹‹_ k
=
‹‹l m
true
‹‹n r
)
‹‹r s
{
›› 	$
ScriptableRendererData
ﬁﬁ "
data
ﬁﬁ# '
=
ﬁﬁ( ) 
CreateRendererData
ﬁﬁ* <
(
ﬁﬁ< =
type
ﬁﬁ= A
)
ﬁﬁA B
;
ﬁﬁB C
string
ﬂﬂ 
dataPath
ﬂﬂ 
;
ﬂﬂ 
if
‡‡ 
(
‡‡ 
relativePath
‡‡ 
)
‡‡ 
dataPath
·· 
=
·· 
$"
‚‚ 
{
‚‚ 
Path
‚‚ 
.
‚‚ 
Combine
‚‚ #
(
‚‚# $
Path
‚‚$ (
.
‚‚( )
GetDirectoryName
‚‚) 9
(
‚‚9 :
path
‚‚: >
)
‚‚> ?
,
‚‚? @
Path
‚‚A E
.
‚‚E F)
GetFileNameWithoutExtension
‚‚F a
(
‚‚a b
path
‚‚b f
)
‚‚f g
)
‚‚g h
}
‚‚h i
	_Renderer
‚‚i r
{
‚‚r s
Path
‚‚s w
.
‚‚w x
GetExtension‚‚x Ñ
(‚‚Ñ Ö
path‚‚Ö â
)‚‚â ä
}‚‚ä ã
"‚‚ã å
;‚‚å ç
else
„„ 
dataPath
‰‰ 
=
‰‰ 
path
‰‰ 
;
‰‰  
AssetDatabase
ÂÂ 
.
ÂÂ 
CreateAsset
ÂÂ %
(
ÂÂ% &
data
ÂÂ& *
,
ÂÂ* +
dataPath
ÂÂ, 4
)
ÂÂ4 5
;
ÂÂ5 6
return
ÊÊ 
data
ÊÊ 
;
ÊÊ 
}
ÁÁ 	
static
ÈÈ $
ScriptableRendererData
ÈÈ % 
CreateRendererData
ÈÈ& 8
(
ÈÈ8 9
RendererType
ÈÈ9 E
type
ÈÈF J
)
ÈÈJ K
{
ÍÍ 	
switch
ÎÎ 
(
ÎÎ 
type
ÎÎ 
)
ÎÎ 
{
ÏÏ 
case
ÌÌ 
RendererType
ÌÌ !
.
ÌÌ! "
ForwardRenderer
ÌÌ" 1
:
ÌÌ1 2
return
ÓÓ 
CreateInstance
ÓÓ )
<
ÓÓ) *!
ForwardRendererData
ÓÓ* =
>
ÓÓ= >
(
ÓÓ> ?
)
ÓÓ? @
;
ÓÓ@ A
case
 
RendererType
 !
.
! "
_2DRenderer
" -
:
- .
return
ÒÒ 
CreateInstance
ÒÒ )
<
ÒÒ) *
Experimental
ÒÒ* 6
.
ÒÒ6 7
	Rendering
ÒÒ7 @
.
ÒÒ@ A
	Universal
ÒÒA J
.
ÒÒJ K
Renderer2DData
ÒÒK Y
>
ÒÒY Z
(
ÒÒZ [
)
ÒÒ[ \
;
ÒÒ\ ]
default
ÛÛ 
:
ÛÛ 
return
ÙÙ 
CreateInstance
ÙÙ )
<
ÙÙ) *!
ForwardRendererData
ÙÙ* =
>
ÙÙ= >
(
ÙÙ> ?
)
ÙÙ? @
;
ÙÙ@ A
}
ıı 
}
ˆˆ 	
static
˘˘ 
void
˘˘ 4
&CreateUniversalPipelineEditorResources
˘˘ :
(
˘˘: ;
)
˘˘; <
{
˙˙ 	
var
˚˚ 
instance
˚˚ 
=
˚˚ 
CreateInstance
˚˚ )
<
˚˚) *4
&UniversalRenderPipelineEditorResources
˚˚* P
>
˚˚P Q
(
˚˚Q R
)
˚˚R S
;
˚˚S T
ResourceReloader
¸¸ 
.
¸¸ 
ReloadAllNullIn
¸¸ ,
(
¸¸, -
instance
¸¸- 5
,
¸¸5 6
packagePath
¸¸7 B
)
¸¸B C
;
¸¸C D
AssetDatabase
˝˝ 
.
˝˝ 
CreateAsset
˝˝ %
(
˝˝% &
instance
˝˝& .
,
˝˝. /
string
˝˝0 6
.
˝˝6 7
Format
˝˝7 =
(
˝˝= >
$str
˝˝> P
,
˝˝P Q
typeof
˝˝R X
(
˝˝X Y4
&UniversalRenderPipelineEditorResources
˝˝Y 
)˝˝ Ä
.˝˝Ä Å
Name˝˝Å Ö
)˝˝Ö Ü
)˝˝Ü á
;˝˝á à
}
˛˛ 	4
&UniversalRenderPipelineEditorResources
ÄÄ .
editorResources
ÄÄ/ >
{
ÅÅ 	
get
ÇÇ 
{
ÉÉ 
if
ÑÑ 
(
ÑÑ $
m_EditorResourcesAsset
ÑÑ *
!=
ÑÑ+ -
null
ÑÑ. 2
&&
ÑÑ3 5
!
ÑÑ6 7$
m_EditorResourcesAsset
ÑÑ7 M
.
ÑÑM N
Equals
ÑÑN T
(
ÑÑT U
null
ÑÑU Y
)
ÑÑY Z
)
ÑÑZ [
return
ÖÖ $
m_EditorResourcesAsset
ÖÖ 1
;
ÖÖ1 2
string
áá 
resourcePath
áá #
=
áá$ %
AssetDatabase
áá& 3
.
áá3 4
GUIDToAssetPath
áá4 C
(
ááC D!
editorResourcesGUID
ááD W
)
ááW X
;
ááX Y
var
àà 
objs
àà 
=
àà #
InternalEditorUtility
àà 0
.
àà0 1)
LoadSerializedFileAndForget
àà1 L
(
ààL M
resourcePath
ààM Y
)
ààY Z
;
ààZ [$
m_EditorResourcesAsset
ââ &
=
ââ' (
objs
ââ) -
!=
ââ. 0
null
ââ1 5
&&
ââ6 8
objs
ââ9 =
.
ââ= >
Length
ââ> D
>
ââE F
$num
ââG H
?
ââI J
objs
ââK O
.
ââO P
First
ââP U
(
ââU V
)
ââV W
as
ââX Z5
&UniversalRenderPipelineEditorResourcesââ[ Å
:ââÇ É
nullââÑ à
;ââà â
return
ää $
m_EditorResourcesAsset
ää -
;
ää- .
}
ãã 
}
åå 	
public
èè $
ScriptableRendererData
èè %%
LoadBuiltinRendererData
èè& =
(
èè= >
RendererType
èè> J
type
èèK O
=
èèP Q
RendererType
èèR ^
.
èè^ _
ForwardRenderer
èè_ n
)
èèn o
{
êê 	
EditorUtility
íí 
.
íí 
SetDirty
íí "
(
íí" #
this
íí# '
)
íí' (
;
íí( )
return
ìì  
m_RendererDataList
ìì %
[
ìì% &
$num
ìì& '
]
ìì' (
=
ìì) *!
CreateRendererAsset
îî #
(
îî# $
$str
îî$ B
,
îîB C
type
îîD H
,
îîH I
false
îîJ O
)
îîO P
;
îîP Q
}
ôô 	
	protected
õõ 
override
õõ 
RenderPipeline
õõ )
CreatePipeline
õõ* 8
(
õõ8 9
)
õõ9 :
{
úú 	
if
ùù 
(
ùù  
m_RendererDataList
ùù "
==
ùù# %
null
ùù& *
)
ùù* + 
m_RendererDataList
ûû "
=
ûû# $
new
ûû% ($
ScriptableRendererData
ûû) ?
[
ûû? @
$num
ûû@ A
]
ûûA B
;
ûûB C
if
°° 
(
°°  
m_RendererDataList
°° "
[
°°" #
$num
°°# $
]
°°$ %
==
°°& (
null
°°) -
)
°°- .
{
¢¢ 
if
§§ 
(
§§ $
k_AssetPreviousVersion
§§ )
!=
§§* ,
k_AssetVersion
§§- ;
)
§§; <
return
•• 
null
•• 
;
••  
Debug
ßß 
.
ßß 
LogError
ßß 
(
ßß 
$"
®® Ñ
uDefault Renderer is missing, make sure there is a Renderer assigned as the default on the current Universal RP asset:®® ã
{®®ã å'
UniversalRenderPipeline®®å £
.®®£ §
asset®®§ ©
.®®© ™
name®®™ Æ
}®®Æ Ø
"®®Ø ∞
,®®∞ ±
this
©© 
)
©© 
;
©© 
return
™™ 
null
™™ 
;
™™ 
}
´´ 
CreateRenderers
≠≠ 
(
≠≠ 
)
≠≠ 
;
≠≠ 
return
ÆÆ 
new
ÆÆ %
UniversalRenderPipeline
ÆÆ .
(
ÆÆ. /
this
ÆÆ/ 3
)
ÆÆ3 4
;
ÆÆ4 5
}
ØØ 	
void
±± 
DestroyRenderers
±± 
(
±± 
)
±± 
{
≤≤ 	
if
≥≥ 
(
≥≥ 
m_Renderers
≥≥ 
==
≥≥ 
null
≥≥ #
)
≥≥# $
return
¥¥ 
;
¥¥ 
for
∂∂ 
(
∂∂ 
int
∂∂ 
i
∂∂ 
=
∂∂ 
$num
∂∂ 
;
∂∂ 
i
∂∂ 
<
∂∂ 
m_Renderers
∂∂  +
.
∂∂+ ,
Length
∂∂, 2
;
∂∂2 3
i
∂∂4 5
++
∂∂5 7
)
∂∂7 8
DestroyRenderer
∑∑ 
(
∑∑  
ref
∑∑  #
m_Renderers
∑∑$ /
[
∑∑/ 0
i
∑∑0 1
]
∑∑1 2
)
∑∑2 3
;
∑∑3 4
}
∏∏ 	
void
∫∫ 
DestroyRenderer
∫∫ 
(
∫∫ 
ref
∫∫   
ScriptableRenderer
∫∫! 3
renderer
∫∫4 <
)
∫∫< =
{
ªª 	
if
ºº 
(
ºº 
renderer
ºº 
!=
ºº 
null
ºº  
)
ºº  !
{
ΩΩ 
renderer
ææ 
.
ææ 
Dispose
ææ  
(
ææ  !
)
ææ! "
;
ææ" #
renderer
øø 
=
øø 
null
øø 
;
øø  
}
¿¿ 
}
¡¡ 	
	protected
√√ 
override
√√ 
void
√√ 

OnValidate
√√  *
(
√√* +
)
√√+ ,
{
ƒƒ 	
DestroyRenderers
≈≈ 
(
≈≈ 
)
≈≈ 
;
≈≈ 
base
…… 
.
…… 

OnValidate
…… 
(
…… 
)
…… 
;
…… 
}
   	
	protected
ÃÃ 
override
ÃÃ 
void
ÃÃ 
	OnDisable
ÃÃ  )
(
ÃÃ) *
)
ÃÃ* +
{
ÕÕ 	
DestroyRenderers
ŒŒ 
(
ŒŒ 
)
ŒŒ 
;
ŒŒ 
base
““ 
.
““ 
	OnDisable
““ 
(
““ 
)
““ 
;
““ 
}
”” 	
void
’’ 
CreateRenderers
’’ 
(
’’ 
)
’’ 
{
÷÷ 	
DestroyRenderers
◊◊ 
(
◊◊ 
)
◊◊ 
;
◊◊ 
if
ŸŸ 
(
ŸŸ 
m_Renderers
ŸŸ 
==
ŸŸ 
null
ŸŸ #
||
ŸŸ$ &
m_Renderers
ŸŸ' 2
.
ŸŸ2 3
Length
ŸŸ3 9
!=
ŸŸ: < 
m_RendererDataList
ŸŸ= O
.
ŸŸO P
Length
ŸŸP V
)
ŸŸV W
m_Renderers
⁄⁄ 
=
⁄⁄ 
new
⁄⁄ ! 
ScriptableRenderer
⁄⁄" 4
[
⁄⁄4 5 
m_RendererDataList
⁄⁄5 G
.
⁄⁄G H
Length
⁄⁄H N
]
⁄⁄N O
;
⁄⁄O P
for
‹‹ 
(
‹‹ 
int
‹‹ 
i
‹‹ 
=
‹‹ 
$num
‹‹ 
;
‹‹ 
i
‹‹ 
<
‹‹  
m_RendererDataList
‹‹  2
.
‹‹2 3
Length
‹‹3 9
;
‹‹9 :
++
‹‹; =
i
‹‹= >
)
‹‹> ?
{
›› 
if
ﬁﬁ 
(
ﬁﬁ  
m_RendererDataList
ﬁﬁ &
[
ﬁﬁ& '
i
ﬁﬁ' (
]
ﬁﬁ( )
!=
ﬁﬁ* ,
null
ﬁﬁ- 1
)
ﬁﬁ1 2
m_Renderers
ﬂﬂ 
[
ﬂﬂ  
i
ﬂﬂ  !
]
ﬂﬂ! "
=
ﬂﬂ# $ 
m_RendererDataList
ﬂﬂ% 7
[
ﬂﬂ7 8
i
ﬂﬂ8 9
]
ﬂﬂ9 :
.
ﬂﬂ: ;$
InternalCreateRenderer
ﬂﬂ; Q
(
ﬂﬂQ R
)
ﬂﬂR S
;
ﬂﬂS T
}
‡‡ 
}
·· 	
Material
„„ 
GetMaterial
„„ 
(
„„ !
DefaultMaterialType
„„ 0
materialType
„„1 =
)
„„= >
{
‰‰ 	
if
ÊÊ 
(
ÊÊ $
scriptableRendererData
ÊÊ &
==
ÊÊ' )
null
ÊÊ* .
||
ÊÊ/ 1
editorResources
ÊÊ2 A
==
ÊÊB D
null
ÊÊE I
)
ÊÊI J
return
ÁÁ 
null
ÁÁ 
;
ÁÁ 
var
ÈÈ 
material
ÈÈ 
=
ÈÈ $
scriptableRendererData
ÈÈ 1
.
ÈÈ1 2 
GetDefaultMaterial
ÈÈ2 D
(
ÈÈD E
materialType
ÈÈE Q
)
ÈÈQ R
;
ÈÈR S
if
ÍÍ 
(
ÍÍ 
material
ÍÍ 
!=
ÍÍ 
null
ÍÍ  
)
ÍÍ  !
return
ÎÎ 
material
ÎÎ 
;
ÎÎ  
switch
ÌÌ 
(
ÌÌ 
materialType
ÌÌ  
)
ÌÌ  !
{
ÓÓ 
case
ÔÔ !
DefaultMaterialType
ÔÔ (
.
ÔÔ( )
Standard
ÔÔ) 1
:
ÔÔ1 2
return
 
editorResources
 *
.
* +
	materials
+ 4
.
4 5
lit
5 8
;
8 9
case
ÚÚ !
DefaultMaterialType
ÚÚ (
.
ÚÚ( )
Particle
ÚÚ) 1
:
ÚÚ1 2
return
ÛÛ 
editorResources
ÛÛ *
.
ÛÛ* +
	materials
ÛÛ+ 4
.
ÛÛ4 5
particleLit
ÛÛ5 @
;
ÛÛ@ A
case
ıı !
DefaultMaterialType
ıı (
.
ıı( )
Terrain
ıı) 0
:
ıı0 1
return
ˆˆ 
editorResources
ˆˆ *
.
ˆˆ* +
	materials
ˆˆ+ 4
.
ˆˆ4 5

terrainLit
ˆˆ5 ?
;
ˆˆ? @
default
˘˘ 
:
˘˘ 
return
˙˙ 
null
˙˙ 
;
˙˙  
}
˚˚ 
}
ˇˇ 	
public
ÑÑ  
ScriptableRenderer
ÑÑ ! 
scriptableRenderer
ÑÑ" 4
{
ÖÖ 	
get
ÜÜ 
{
áá 
if
àà 
(
àà  
m_RendererDataList
àà &
?
àà& '
.
àà' (
Length
àà( .
>
àà/ 0$
m_DefaultRendererIndex
àà1 G
&&
ààH J 
m_RendererDataList
ààK ]
[
àà] ^$
m_DefaultRendererIndex
àà^ t
]
ààt u
==
ààv x
null
àày }
)
àà} ~
{
ââ 
Debug
ää 
.
ää 
LogError
ää "
(
ää" #
$str
ää# a
,
ääa b
this
ääc g
)
ääg h
;
ääh i
return
ãã 
null
ãã 
;
ãã  
}
åå 
if
éé 
(
éé $
scriptableRendererData
éé *
.
éé* +
isInvalidated
éé+ 8
||
éé9 ;
m_Renderers
éé< G
[
ééG H$
m_DefaultRendererIndex
ééH ^
]
éé^ _
==
éé` b
null
ééc g
)
éég h
{
èè 
DestroyRenderer
êê #
(
êê# $
ref
êê$ '
m_Renderers
êê( 3
[
êê3 4$
m_DefaultRendererIndex
êê4 J
]
êêJ K
)
êêK L
;
êêL M
m_Renderers
ëë 
[
ëë  $
m_DefaultRendererIndex
ëë  6
]
ëë6 7
=
ëë8 9$
scriptableRendererData
ëë: P
.
ëëP Q$
InternalCreateRenderer
ëëQ g
(
ëëg h
)
ëëh i
;
ëëi j
}
íí 
return
îî 
m_Renderers
îî "
[
îî" #$
m_DefaultRendererIndex
îî# 9
]
îî9 :
;
îî: ;
}
ïï 
}
ññ 	
public
ùù  
ScriptableRenderer
ùù !
GetRenderer
ùù" -
(
ùù- .
int
ùù. 1
index
ùù2 7
)
ùù7 8
{
ûû 	
if
üü 
(
üü 
index
üü 
==
üü 
-
üü 
$num
üü 
)
üü 
index
†† 
=
†† $
m_DefaultRendererIndex
†† .
;
††. /
if
¢¢ 
(
¢¢ 
index
¢¢ 
>=
¢¢  
m_RendererDataList
¢¢ +
.
¢¢+ ,
Length
¢¢, 2
||
¢¢3 5
index
¢¢6 ;
<
¢¢< =
$num
¢¢> ?
||
¢¢@ B 
m_RendererDataList
¢¢C U
[
¢¢U V
index
¢¢V [
]
¢¢[ \
==
¢¢] _
null
¢¢` d
)
¢¢d e
{
££ 
Debug
§§ 
.
§§ 

LogWarning
§§  
(
§§  !
$"
••  
Renderer at index 
•• (
{
••( )
index
••) .
.
••. /
ToString
••/ 7
(
••7 8
)
••8 9
}
••9 :<
. is missing, falling back to Default Renderer 
••: h
{
••h i 
m_RendererDataList
••i {
[
••{ |%
m_DefaultRendererIndex••| í
]••í ì
.••ì î
name••î ò
}••ò ô
"••ô ö
,••ö õ
this
¶¶ 
)
¶¶ 
;
¶¶ 
index
ßß 
=
ßß $
m_DefaultRendererIndex
ßß .
;
ßß. /
}
®® 
if
´´ 
(
´´ 
m_Renderers
´´ 
==
´´ 
null
´´ #
||
´´$ &
m_Renderers
´´' 2
.
´´2 3
Length
´´3 9
<
´´: ; 
m_RendererDataList
´´< N
.
´´N O
Length
´´O U
)
´´U V
CreateRenderers
¨¨ 
(
¨¨  
)
¨¨  !
;
¨¨! "
if
∞∞ 
(
∞∞  
m_RendererDataList
∞∞ "
[
∞∞" #
index
∞∞# (
]
∞∞( )
.
∞∞) *
isInvalidated
∞∞* 7
||
∞∞8 :
m_Renderers
∞∞; F
[
∞∞F G
index
∞∞G L
]
∞∞L M
==
∞∞N P
null
∞∞Q U
)
∞∞U V
{
±± 
DestroyRenderer
≤≤ 
(
≤≤  
ref
≤≤  #
m_Renderers
≤≤$ /
[
≤≤/ 0
index
≤≤0 5
]
≤≤5 6
)
≤≤6 7
;
≤≤7 8
m_Renderers
≥≥ 
[
≥≥ 
index
≥≥ !
]
≥≥! "
=
≥≥# $ 
m_RendererDataList
≥≥% 7
[
≥≥7 8
index
≥≥8 =
]
≥≥= >
.
≥≥> ?$
InternalCreateRenderer
≥≥? U
(
≥≥U V
)
≥≥V W
;
≥≥W X
}
¥¥ 
return
∂∂ 
m_Renderers
∂∂ 
[
∂∂ 
index
∂∂ $
]
∂∂$ %
;
∂∂% &
}
∑∑ 	
internal
ππ $
ScriptableRendererData
ππ '$
scriptableRendererData
ππ( >
{
∫∫ 	
get
ªª 
{
ºº 
if
ΩΩ 
(
ΩΩ  
m_RendererDataList
ΩΩ &
[
ΩΩ& '$
m_DefaultRendererIndex
ΩΩ' =
]
ΩΩ= >
==
ΩΩ? A
null
ΩΩB F
)
ΩΩF G
CreatePipeline
ææ "
(
ææ" #
)
ææ# $
;
ææ$ %
return
¿¿  
m_RendererDataList
¿¿ )
[
¿¿) *$
m_DefaultRendererIndex
¿¿* @
]
¿¿@ A
;
¿¿A B
}
¡¡ 
}
¬¬ 	
internal
≈≈ 

GUIContent
≈≈ 
[
≈≈ 
]
≈≈ !
rendererDisplayList
≈≈ 1
{
∆∆ 	
get
«« 
{
»» 

GUIContent
…… 
[
…… 
]
…… 
list
…… !
=
……" #
new
……$ '

GUIContent
……( 2
[
……2 3 
m_RendererDataList
……3 E
.
……E F
Length
……F L
+
……M N
$num
……O P
]
……P Q
;
……Q R
list
   
[
   
$num
   
]
   
=
   
new
   

GUIContent
   (
(
  ( )
$"
  ) + 
Default Renderer (
  + =
{
  = >%
RendererDataDisplayName
  > U
(
  U V 
m_RendererDataList
  V h
[
  h i$
m_DefaultRendererIndex
  i 
]   Ä
)  Ä Å
}  Å Ç
)  Ç É
"  É Ñ
)  Ñ Ö
;  Ö Ü
for
ÃÃ 
(
ÃÃ 
var
ÃÃ 
i
ÃÃ 
=
ÃÃ 
$num
ÃÃ 
;
ÃÃ 
i
ÃÃ  !
<
ÃÃ" #
list
ÃÃ$ (
.
ÃÃ( )
Length
ÃÃ) /
;
ÃÃ/ 0
i
ÃÃ1 2
++
ÃÃ2 4
)
ÃÃ4 5
{
ÕÕ 
list
ŒŒ 
[
ŒŒ 
i
ŒŒ 
]
ŒŒ 
=
ŒŒ 
new
ŒŒ !

GUIContent
ŒŒ" ,
(
ŒŒ, -
$"
ŒŒ- /
{
ŒŒ/ 0
(
ŒŒ0 1
i
ŒŒ1 2
-
ŒŒ3 4
$num
ŒŒ5 6
)
ŒŒ6 7
.
ŒŒ7 8
ToString
ŒŒ8 @
(
ŒŒ@ A
)
ŒŒA B
}
ŒŒB C
: 
ŒŒC E
{
ŒŒE F%
RendererDataDisplayName
ŒŒF ]
(
ŒŒ] ^ 
m_RendererDataList
ŒŒ^ p
[
ŒŒp q
i
ŒŒq r
-
ŒŒr s
$num
ŒŒs t
]
ŒŒt u
)
ŒŒu v
}
ŒŒv w
"
ŒŒw x
)
ŒŒx y
;
ŒŒy z
}
œœ 
return
–– 
list
–– 
;
–– 
}
—— 
}
““ 	
string
‘‘ %
RendererDataDisplayName
‘‘ &
(
‘‘& '$
ScriptableRendererData
‘‘' =
data
‘‘> B
)
‘‘B C
{
’’ 	
if
÷÷ 
(
÷÷ 
data
÷÷ 
!=
÷÷ 
null
÷÷ 
)
÷÷ 
return
◊◊ 
data
◊◊ 
.
◊◊ 
name
◊◊  
;
◊◊  !
return
ŸŸ 
$str
ŸŸ 0
;
ŸŸ0 1
}
⁄⁄ 	
internal
ﬁﬁ 
int
ﬁﬁ 
[
ﬁﬁ 
]
ﬁﬁ 
rendererIndexList
ﬁﬁ (
{
ﬂﬂ 	
get
‡‡ 
{
·· 
int
‚‚ 
[
‚‚ 
]
‚‚ 
list
‚‚ 
=
‚‚ 
new
‚‚  
int
‚‚! $
[
‚‚$ % 
m_RendererDataList
‚‚% 7
.
‚‚7 8
Length
‚‚8 >
+
‚‚? @
$num
‚‚A B
]
‚‚B C
;
‚‚C D
for
„„ 
(
„„ 
int
„„ 
i
„„ 
=
„„ 
$num
„„ 
;
„„ 
i
„„  !
<
„„" #
list
„„$ (
.
„„( )
Length
„„) /
;
„„/ 0
i
„„1 2
++
„„2 4
)
„„4 5
{
‰‰ 
list
ÂÂ 
[
ÂÂ 
i
ÂÂ 
]
ÂÂ 
=
ÂÂ 
i
ÂÂ 
-
ÂÂ  !
$num
ÂÂ" #
;
ÂÂ# $
}
ÊÊ 
return
ÁÁ 
list
ÁÁ 
;
ÁÁ 
}
ËË 
}
ÈÈ 	
public
ÎÎ 
bool
ÎÎ (
supportsCameraDepthTexture
ÎÎ .
{
ÏÏ 	
get
ÌÌ 
{
ÌÌ 
return
ÌÌ #
m_RequireDepthTexture
ÌÌ .
;
ÌÌ. /
}
ÌÌ0 1
set
ÓÓ 
{
ÓÓ #
m_RequireDepthTexture
ÓÓ '
=
ÓÓ( )
value
ÓÓ* /
;
ÓÓ/ 0
}
ÓÓ1 2
}
ÔÔ 	
public
ÒÒ 
bool
ÒÒ )
supportsCameraOpaqueTexture
ÒÒ /
{
ÚÚ 	
get
ÛÛ 
{
ÛÛ 
return
ÛÛ $
m_RequireOpaqueTexture
ÛÛ /
;
ÛÛ/ 0
}
ÛÛ1 2
set
ÙÙ 
{
ÙÙ $
m_RequireOpaqueTexture
ÙÙ (
=
ÙÙ) *
value
ÙÙ+ 0
;
ÙÙ0 1
}
ÙÙ2 3
}
ıı 	
public
˜˜ 
Downsampling
˜˜  
opaqueDownsampling
˜˜ .
{
¯¯ 	
get
˘˘ 
{
˘˘ 
return
˘˘ "
m_OpaqueDownsampling
˘˘ -
;
˘˘- .
}
˘˘/ 0
}
˙˙ 	
public
¸¸ 
bool
¸¸ "
supportsTerrainHoles
¸¸ (
{
˝˝ 	
get
˛˛ 
{
˛˛ 
return
˛˛ $
m_SupportsTerrainHoles
˛˛ /
;
˛˛/ 0
}
˛˛1 2
}
ˇˇ 	
public
ÅÅ 
bool
ÅÅ 
supportsHDR
ÅÅ 
{
ÇÇ 	
get
ÉÉ 
{
ÉÉ 
return
ÉÉ 
m_SupportsHDR
ÉÉ &
;
ÉÉ& '
}
ÉÉ( )
set
ÑÑ 
{
ÑÑ 
m_SupportsHDR
ÑÑ 
=
ÑÑ  !
value
ÑÑ" '
;
ÑÑ' (
}
ÑÑ) *
}
ÖÖ 	
public
áá 
int
áá 
msaaSampleCount
áá "
{
àà 	
get
ââ 
{
ââ 
return
ââ 
(
ââ 
int
ââ 
)
ââ 
m_MSAA
ââ $
;
ââ$ %
}
ââ& '
set
ää 
{
ää 
m_MSAA
ää 
=
ää 
(
ää 
MsaaQuality
ää '
)
ää' (
value
ää( -
;
ää- .
}
ää/ 0
}
ãã 	
public
çç 
float
çç 
renderScale
çç  
{
éé 	
get
èè 
{
èè 
return
èè 
m_RenderScale
èè &
;
èè& '
}
èè( )
set
êê 
{
êê 
m_RenderScale
êê 
=
êê  !!
ValidateRenderScale
êê" 5
(
êê5 6
value
êê6 ;
)
êê; <
;
êê< =
}
êê> ?
}
ëë 	
public
ìì  
LightRenderingMode
ìì !$
mainLightRenderingMode
ìì" 8
{
îî 	
get
ïï 
{
ïï 
return
ïï &
m_MainLightRenderingMode
ïï 1
;
ïï1 2
}
ïï3 4
}
ññ 	
public
òò 
bool
òò &
supportsMainLightShadows
òò ,
{
ôô 	
get
öö 
{
öö 
return
öö )
m_MainLightShadowsSupported
öö 4
;
öö4 5
}
öö6 7
}
õõ 	
public
ùù 
int
ùù *
mainLightShadowmapResolution
ùù /
{
ûû 	
get
üü 
{
üü 
return
üü 
(
üü 
int
üü 
)
üü ,
m_MainLightShadowmapResolution
üü <
;
üü< =
}
üü> ?
}
†† 	
public
¢¢  
LightRenderingMode
¢¢ !+
additionalLightsRenderingMode
¢¢" ?
{
££ 	
get
§§ 
{
§§ 
return
§§ -
m_AdditionalLightsRenderingMode
§§ 8
;
§§8 9
}
§§: ;
}
•• 	
public
ßß 
int
ßß &
maxAdditionalLightsCount
ßß +
{
®® 	
get
©© 
{
©© 
return
©© .
 m_AdditionalLightsPerObjectLimit
©© 9
;
©©9 :
}
©©; <
set
™™ 
{
™™ .
 m_AdditionalLightsPerObjectLimit
™™ 2
=
™™3 4%
ValidatePerObjectLights
™™5 L
(
™™L M
value
™™M R
)
™™R S
;
™™S T
}
™™U V
}
´´ 	
public
≠≠ 
bool
≠≠ ,
supportsAdditionalLightShadows
≠≠ 2
{
ÆÆ 	
get
ØØ 
{
ØØ 
return
ØØ /
!m_AdditionalLightShadowsSupported
ØØ :
;
ØØ: ;
}
ØØ< =
}
∞∞ 	
public
≤≤ 
int
≤≤ 1
#additionalLightsShadowmapResolution
≤≤ 6
{
≥≥ 	
get
¥¥ 
{
¥¥ 
return
¥¥ 
(
¥¥ 
int
¥¥ 
)
¥¥ 3
%m_AdditionalLightsShadowmapResolution
¥¥ C
;
¥¥C D
}
¥¥E F
}
µµ 	
public
∫∫ 
float
∫∫ 
shadowDistance
∫∫ #
{
ªª 	
get
ºº 
{
ºº 
return
ºº 
m_ShadowDistance
ºº )
;
ºº) *
}
ºº+ ,
set
ΩΩ 
{
ΩΩ 
m_ShadowDistance
ΩΩ "
=
ΩΩ# $
Mathf
ΩΩ% *
.
ΩΩ* +
Max
ΩΩ+ .
(
ΩΩ. /
$num
ΩΩ/ 3
,
ΩΩ3 4
value
ΩΩ5 :
)
ΩΩ: ;
;
ΩΩ; <
}
ΩΩ= >
}
ææ 	
public
√√ 
int
√√  
shadowCascadeCount
√√ %
{
ƒƒ 	
get
≈≈ 
{
≈≈ 
return
≈≈ "
m_ShadowCascadeCount
≈≈ -
;
≈≈- .
}
≈≈/ 0
set
∆∆ 
{
«« 
if
»» 
(
»» 
value
»» 
<
»» %
k_ShadowCascadeMinCount
»» 3
||
»»4 6
value
»»7 <
>
»»= >%
k_ShadowCascadeMaxCount
»»? V
)
»»V W
{
…… 
throw
   
new
   
ArgumentException
   /
(
  / 0
$"
  0 2
Value (
  2 9
{
  9 :
value
  : ?
}
  ? @$
) needs to be between 
  @ V
{
  V W%
k_ShadowCascadeMinCount
  W n
}
  n o
 and 
  o t
{
  t u&
k_ShadowCascadeMaxCount  u å
}  å ç
.  ç é
"  é è
)  è ê
;  ê ë
}
ÀÀ "
m_ShadowCascadeCount
ÃÃ $
=
ÃÃ% &
value
ÃÃ' ,
;
ÃÃ, -
}
ÕÕ 
}
ŒŒ 	
public
‘‘ 
float
‘‘ 
cascade2Split
‘‘ "
{
’’ 	
get
÷÷ 
{
÷÷ 
return
÷÷ 
m_Cascade2Split
÷÷ (
;
÷÷( )
}
÷÷* +
}
◊◊ 	
public
›› 
Vector2
›› 
cascade3Split
›› $
{
ﬁﬁ 	
get
ﬂﬂ 
{
ﬂﬂ 
return
ﬂﬂ 
m_Cascade3Split
ﬂﬂ (
;
ﬂﬂ( )
}
ﬂﬂ* +
}
‡‡ 	
public
ÊÊ 
Vector3
ÊÊ 
cascade4Split
ÊÊ $
{
ÁÁ 	
get
ËË 
{
ËË 
return
ËË 
m_Cascade4Split
ËË (
;
ËË( )
}
ËË* +
}
ÈÈ 	
public
ÓÓ 
float
ÓÓ 
shadowDepthBias
ÓÓ $
{
ÔÔ 	
get
 
{
 
return
 
m_ShadowDepthBias
 *
;
* +
}
, -
set
ÒÒ 
{
ÒÒ 
m_ShadowDepthBias
ÒÒ #
=
ÒÒ$ % 
ValidateShadowBias
ÒÒ& 8
(
ÒÒ8 9
value
ÒÒ9 >
)
ÒÒ> ?
;
ÒÒ? @
}
ÒÒA B
}
ÚÚ 	
public
˜˜ 
float
˜˜ 
shadowNormalBias
˜˜ %
{
¯¯ 	
get
˘˘ 
{
˘˘ 
return
˘˘  
m_ShadowNormalBias
˘˘ +
;
˘˘+ ,
}
˘˘- .
set
˙˙ 
{
˙˙  
m_ShadowNormalBias
˙˙ $
=
˙˙% & 
ValidateShadowBias
˙˙' 9
(
˙˙9 :
value
˙˙: ?
)
˙˙? @
;
˙˙@ A
}
˙˙B C
}
˚˚ 	
public
ÄÄ 
bool
ÄÄ !
supportsSoftShadows
ÄÄ '
{
ÅÅ 	
get
ÇÇ 
{
ÇÇ 
return
ÇÇ $
m_SoftShadowsSupported
ÇÇ /
;
ÇÇ/ 0
}
ÇÇ1 2
}
ÉÉ 	
public
ÖÖ 
bool
ÖÖ %
supportsDynamicBatching
ÖÖ +
{
ÜÜ 	
get
áá 
{
áá 
return
áá '
m_SupportsDynamicBatching
áá 2
;
áá2 3
}
áá4 5
set
àà 
{
àà '
m_SupportsDynamicBatching
àà +
=
àà, -
value
àà. 3
;
àà3 4
}
àà5 6
}
ââ 	
public
ãã 
bool
ãã #
supportsMixedLighting
ãã )
{
åå 	
get
çç 
{
çç 
return
çç &
m_MixedLightingSupported
çç 1
;
çç1 2
}
çç3 4
}
éé 	
public
êê #
ShaderVariantLogLevel
êê $#
shaderVariantLogLevel
êê% :
{
ëë 	
get
íí 
{
íí 
return
íí %
m_ShaderVariantLogLevel
íí 0
;
íí0 1
}
íí2 3
set
ìì 
{
ìì %
m_ShaderVariantLogLevel
ìì )
=
ìì* +
value
ìì, 1
;
ìì1 2
}
ìì3 4
}
îî 	
[
ññ 	
Obsolete
ññ	 
(
ññ 
$str
ññ Z
,
ññZ [
false
ññ\ a
)
ñña b
]
ññb c
public
óó  
PipelineDebugLevel
óó !

debugLevel
óó" ,
{
òò 	
get
ôô 
=>
ôô  
PipelineDebugLevel
ôô %
.
ôô% &
Disabled
ôô& .
;
ôô/ 0
}
öö 	
public
úú 
bool
úú 
useSRPBatcher
úú !
{
ùù 	
get
ûû 
{
ûû 
return
ûû 
m_UseSRPBatcher
ûû (
;
ûû( )
}
ûû* +
set
üü 
{
üü 
m_UseSRPBatcher
üü !
=
üü" #
value
üü$ )
;
üü) *
}
üü+ ,
}
†† 	
public
¢¢ 
ColorGradingMode
¢¢ 
colorGradingMode
¢¢  0
{
££ 	
get
§§ 
{
§§ 
return
§§  
m_ColorGradingMode
§§ +
;
§§+ ,
}
§§- .
set
•• 
{
••  
m_ColorGradingMode
•• $
=
••% &
value
••' ,
;
••, -
}
••. /
}
¶¶ 	
public
®® 
int
®® !
colorGradingLutSize
®® &
{
©© 	
get
™™ 
{
™™ 
return
™™ #
m_ColorGradingLutSize
™™ .
;
™™. /
}
™™0 1
set
´´ 
{
´´ #
m_ColorGradingLutSize
´´ '
=
´´( )
Mathf
´´* /
.
´´/ 0
Clamp
´´0 5
(
´´5 6
value
´´6 ;
,
´´; <
k_MinLutSize
´´= I
,
´´I J
k_MaxLutSize
´´K W
)
´´W X
;
´´X Y
}
´´Z [
}
¨¨ 	
public
≤≤ 
bool
≤≤ $
useAdaptivePerformance
≤≤ *
{
≥≥ 	
get
¥¥ 
{
¥¥ 
return
¥¥ &
m_UseAdaptivePerformance
¥¥ 1
;
¥¥1 2
}
¥¥3 4
set
µµ 
{
µµ &
m_UseAdaptivePerformance
µµ *
=
µµ+ ,
value
µµ- 2
;
µµ2 3
}
µµ4 5
}
∂∂ 	
public
∏∏ 
override
∏∏ 
Material
∏∏  
defaultMaterial
∏∏! 0
{
ππ 	
get
∫∫ 
{
∫∫ 
return
∫∫ 
GetMaterial
∫∫ $
(
∫∫$ %!
DefaultMaterialType
∫∫% 8
.
∫∫8 9
Standard
∫∫9 A
)
∫∫A B
;
∫∫B C
}
∫∫D E
}
ªª 	
public
ΩΩ 
override
ΩΩ 
Material
ΩΩ  %
defaultParticleMaterial
ΩΩ! 8
{
ææ 	
get
øø 
{
øø 
return
øø 
GetMaterial
øø $
(
øø$ %!
DefaultMaterialType
øø% 8
.
øø8 9
Particle
øø9 A
)
øøA B
;
øøB C
}
øøD E
}
¿¿ 	
public
¬¬ 
override
¬¬ 
Material
¬¬  !
defaultLineMaterial
¬¬! 4
{
√√ 	
get
ƒƒ 
{
ƒƒ 
return
ƒƒ 
GetMaterial
ƒƒ $
(
ƒƒ$ %!
DefaultMaterialType
ƒƒ% 8
.
ƒƒ8 9
Particle
ƒƒ9 A
)
ƒƒA B
;
ƒƒB C
}
ƒƒD E
}
≈≈ 	
public
«« 
override
«« 
Material
««  $
defaultTerrainMaterial
««! 7
{
»» 	
get
…… 
{
…… 
return
…… 
GetMaterial
…… $
(
……$ %!
DefaultMaterialType
……% 8
.
……8 9
Terrain
……9 @
)
……@ A
;
……A B
}
……C D
}
   	
public
ÃÃ 
override
ÃÃ 
Material
ÃÃ  
defaultUIMaterial
ÃÃ! 2
{
ÕÕ 	
get
ŒŒ 
{
ŒŒ 
return
ŒŒ 
GetMaterial
ŒŒ $
(
ŒŒ$ %!
DefaultMaterialType
ŒŒ% 8
.
ŒŒ8 9!
UnityBuiltinDefault
ŒŒ9 L
)
ŒŒL M
;
ŒŒM N
}
ŒŒO P
}
œœ 	
public
—— 
override
—— 
Material
——  '
defaultUIOverdrawMaterial
——! :
{
““ 	
get
”” 
{
”” 
return
”” 
GetMaterial
”” $
(
””$ %!
DefaultMaterialType
””% 8
.
””8 9!
UnityBuiltinDefault
””9 L
)
””L M
;
””M N
}
””O P
}
‘‘ 	
public
÷÷ 
override
÷÷ 
Material
÷÷  ,
defaultUIETC1SupportedMaterial
÷÷! ?
{
◊◊ 	
get
ÿÿ 
{
ÿÿ 
return
ÿÿ 
GetMaterial
ÿÿ $
(
ÿÿ$ %!
DefaultMaterialType
ÿÿ% 8
.
ÿÿ8 9!
UnityBuiltinDefault
ÿÿ9 L
)
ÿÿL M
;
ÿÿM N
}
ÿÿO P
}
ŸŸ 	
public
€€ 
override
€€ 
Material
€€  
default2DMaterial
€€! 2
{
‹‹ 	
get
›› 
{
›› 
return
›› 
GetMaterial
›› $
(
››$ %!
DefaultMaterialType
››% 8
.
››8 9
Sprite
››9 ?
)
››? @
;
››@ A
}
››B C
}
ﬁﬁ 	
public
‡‡ 
override
‡‡ 
Shader
‡‡ 
defaultShader
‡‡ ,
{
·· 	
get
‚‚ 
{
„„ 
if
ÍÍ 
(
ÍÍ $
scriptableRendererData
ÍÍ *
!=
ÍÍ+ -
null
ÍÍ. 2
)
ÍÍ2 3
{
ÎÎ 
Shader
ÏÏ 
defaultShader
ÏÏ (
=
ÏÏ) *$
scriptableRendererData
ÏÏ+ A
.
ÏÏA B
GetDefaultShader
ÏÏB R
(
ÏÏR S
)
ÏÏS T
;
ÏÏT U
if
ÌÌ 
(
ÌÌ 
defaultShader
ÌÌ %
!=
ÌÌ& (
null
ÌÌ) -
)
ÌÌ- .
return
ÓÓ 
defaultShader
ÓÓ ,
;
ÓÓ, -
}
ÔÔ 
if
ÒÒ 
(
ÒÒ 
m_DefaultShader
ÒÒ #
==
ÒÒ$ &
null
ÒÒ' +
)
ÒÒ+ ,
{
ÚÚ 
string
ÛÛ 
path
ÛÛ 
=
ÛÛ  !
AssetDatabase
ÛÛ" /
.
ÛÛ/ 0
GUIDToAssetPath
ÛÛ0 ?
(
ÛÛ? @
ShaderUtils
ÛÛ@ K
.
ÛÛK L
GetShaderGUID
ÛÛL Y
(
ÛÛY Z
ShaderPathID
ÛÛZ f
.
ÛÛf g
Lit
ÛÛg j
)
ÛÛj k
)
ÛÛk l
;
ÛÛl m
m_DefaultShader
ÙÙ #
=
ÙÙ% &
AssetDatabase
ÙÙ' 4
.
ÙÙ4 5
LoadAssetAtPath
ÙÙ5 D
<
ÙÙD E
Shader
ÙÙE K
>
ÙÙK L
(
ÙÙL M
path
ÙÙM Q
)
ÙÙQ R
;
ÙÙR S
}
ıı 
if
¯¯ 
(
¯¯ 
m_DefaultShader
¯¯ #
==
¯¯$ &
null
¯¯' +
)
¯¯+ ,
m_DefaultShader
˘˘ #
=
˘˘$ %
Shader
˘˘& ,
.
˘˘, -
Find
˘˘- 1
(
˘˘1 2
ShaderUtils
˘˘2 =
.
˘˘= >
GetShaderPath
˘˘> K
(
˘˘K L
ShaderPathID
˘˘L X
.
˘˘X Y
Lit
˘˘Y \
)
˘˘\ ]
)
˘˘] ^
;
˘˘^ _
return
˚˚ 
m_DefaultShader
˚˚ &
;
˚˚& '
}
¸¸ 
}
˝˝ 	
public
ÄÄ 
override
ÄÄ 
Shader
ÄÄ '
autodeskInteractiveShader
ÄÄ 8
{
ÅÅ 	
get
ÇÇ 
{
ÇÇ 
return
ÇÇ 
editorResources
ÇÇ (
?
ÇÇ( )
.
ÇÇ) *
shaders
ÇÇ* 1
.
ÇÇ1 2#
autodeskInteractivePS
ÇÇ2 G
;
ÇÇG H
}
ÇÇI J
}
ÉÉ 	
public
ÖÖ 
override
ÖÖ 
Shader
ÖÖ 2
$autodeskInteractiveTransparentShader
ÖÖ C
{
ÜÜ 	
get
áá 
{
áá 
return
áá 
editorResources
áá (
?
áá( )
.
áá) *
shaders
áá* 1
.
áá1 2.
 autodeskInteractiveTransparentPS
áá2 R
;
ááR S
}
ááT U
}
àà 	
public
ää 
override
ää 
Shader
ää -
autodeskInteractiveMaskedShader
ää >
{
ãã 	
get
åå 
{
åå 
return
åå 
editorResources
åå (
?
åå( )
.
åå) *
shaders
åå* 1
.
åå1 2)
autodeskInteractiveMaskedPS
åå2 M
;
ååM N
}
ååO P
}
çç 	
public
èè 
override
èè 
Shader
èè $
terrainDetailLitShader
èè 5
{
êê 	
get
ëë 
{
ëë 
return
ëë 
editorResources
ëë (
?
ëë( )
.
ëë) *
shaders
ëë* 1
.
ëë1 2 
terrainDetailLitPS
ëë2 D
;
ëëD E
}
ëëF G
}
íí 	
public
îî 
override
îî 
Shader
îî &
terrainDetailGrassShader
îî 7
{
ïï 	
get
ññ 
{
ññ 
return
ññ 
editorResources
ññ (
?
ññ( )
.
ññ) *
shaders
ññ* 1
.
ññ1 2"
terrainDetailGrassPS
ññ2 F
;
ññF G
}
ññH I
}
óó 	
public
ôô 
override
ôô 
Shader
ôô /
!terrainDetailGrassBillboardShader
ôô @
{
öö 	
get
õõ 
{
õõ 
return
õõ 
editorResources
õõ (
?
õõ( )
.
õõ) *
shaders
õõ* 1
.
õõ1 2+
terrainDetailGrassBillboardPS
õõ2 O
;
õõO P
}
õõQ R
}
úú 	
public
ûû 
override
ûû 
Shader
ûû %
defaultSpeedTree7Shader
ûû 6
{
üü 	
get
†† 
{
†† 
return
†† 
editorResources
†† (
?
††( )
.
††) *
shaders
††* 1
.
††1 2!
defaultSpeedTree7PS
††2 E
;
††E F
}
††G H
}
°° 	
public
££ 
override
££ 
Shader
££ %
defaultSpeedTree8Shader
££ 6
{
§§ 	
get
•• 
{
•• 
return
•• 
editorResources
•• (
?
••( )
.
••) *
shaders
••* 1
.
••1 2!
defaultSpeedTree8PS
••2 E
;
••E F
}
••G H
}
¶¶ 	
public
©© 
void
©© 
OnBeforeSerialize
©© %
(
©©% &
)
©©& '
{
™™ 	
}
´´ 	
public
≠≠ 
void
≠≠  
OnAfterDeserialize
≠≠ &
(
≠≠& '
)
≠≠' (
{
ÆÆ 	
if
ØØ 
(
ØØ 
k_AssetVersion
ØØ 
<
ØØ  
$num
ØØ! "
)
ØØ" #
{
∞∞ $
m_SoftShadowsSupported
±± &
=
±±' (
(
±±) *
m_ShadowType
±±* 6
==
±±7 9
ShadowQuality
±±: G
.
±±G H
SoftShadows
±±H S
)
±±S T
;
±±T U$
k_AssetPreviousVersion
≤≤ &
=
≤≤' (
k_AssetVersion
≤≤) 7
;
≤≤7 8
k_AssetVersion
≥≥ 
=
≥≥  
$num
≥≥! "
;
≥≥" #
}
¥¥ 
if
∂∂ 
(
∂∂ 
k_AssetVersion
∂∂ 
<
∂∂  
$num
∂∂! "
)
∂∂" #
{
∑∑ /
!m_AdditionalLightShadowsSupported
∏∏ 1
=
∏∏2 3%
m_LocalShadowsSupported
∏∏4 K
;
∏∏K L3
%m_AdditionalLightsShadowmapResolution
ππ 5
=
ππ6 7+
m_LocalShadowsAtlasResolution
ππ8 U
;
ππU V.
 m_AdditionalLightsPerObjectLimit
∫∫ 0
=
∫∫1 2
m_MaxPixelLights
∫∫3 C
;
∫∫C D,
m_MainLightShadowmapResolution
ªª .
=
ªª/ 0%
m_ShadowAtlasResolution
ªª1 H
;
ªªH I$
k_AssetPreviousVersion
ºº &
=
ºº' (
k_AssetVersion
ºº) 7
;
ºº7 8
k_AssetVersion
ΩΩ 
=
ΩΩ  
$num
ΩΩ! "
;
ΩΩ" #
}
ææ 
if
¿¿ 
(
¿¿ 
k_AssetVersion
¿¿ 
<
¿¿  
$num
¿¿! "
)
¿¿" #
{
¡¡ 
if
¬¬ 
(
¬¬ 
m_RendererType
¬¬ "
==
¬¬# %
RendererType
¬¬& 2
.
¬¬2 3
Custom
¬¬3 9
)
¬¬9 :
{
√√  
m_RendererDataList
ƒƒ &
[
ƒƒ& '
$num
ƒƒ' (
]
ƒƒ( )
=
ƒƒ* +
m_RendererData
ƒƒ, :
;
ƒƒ: ;
}
≈≈ $
k_AssetPreviousVersion
∆∆ &
=
∆∆' (
k_AssetVersion
∆∆) 7
;
∆∆7 8
k_AssetVersion
«« 
=
««  
$num
««! "
;
««" #
}
»» 
if
   
(
   
k_AssetVersion
   
<
    
$num
  ! "
)
  " #
{
ÀÀ 
int
œœ 
value
œœ 
=
œœ 
(
œœ 
int
œœ  
)
œœ  !
m_ShadowCascades
œœ! 1
;
œœ1 2
if
–– 
(
–– 
value
–– 
==
–– 
$num
–– 
)
–– 
{
—— "
m_ShadowCascadeCount
““ (
=
““) *
$num
““+ ,
;
““, -
}
”” 
else
‘‘ 
{
’’ "
m_ShadowCascadeCount
÷÷ (
=
÷÷) *
value
÷÷+ 0
+
÷÷1 2
$num
÷÷3 4
;
÷÷4 5
}
◊◊ 
k_AssetVersion
ÿÿ 
=
ÿÿ  
$num
ÿÿ! "
;
ÿÿ" #
}
⁄⁄ 
if
ﬁﬁ 
(
ﬁﬁ $
k_AssetPreviousVersion
ﬁﬁ &
!=
ﬁﬁ' )
k_AssetVersion
ﬁﬁ* 8
)
ﬁﬁ8 9
{
ﬂﬂ 
EditorApplication
‡‡ !
.
‡‡! "
	delayCall
‡‡" +
+=
‡‡, .
(
‡‡/ 0
)
‡‡0 1
=>
‡‡2 4
UpgradeAsset
‡‡5 A
(
‡‡A B
this
‡‡B F
)
‡‡F G
;
‡‡G H
}
·· 
}
„„ 	
static
ÊÊ 
void
ÊÊ 
UpgradeAsset
ÊÊ  
(
ÊÊ  !*
UniversalRenderPipelineAsset
ÊÊ! =
asset
ÊÊ> C
)
ÊÊC D
{
ÁÁ 	
if
ËË 
(
ËË 
asset
ËË 
.
ËË $
k_AssetPreviousVersion
ËË +
<
ËË, -
$num
ËË. /
)
ËË/ 0
{
ÈÈ 
if
ÍÍ 
(
ÍÍ 
asset
ÍÍ 
.
ÍÍ 
m_RendererType
ÍÍ (
==
ÍÍ) +
RendererType
ÍÍ, 8
.
ÍÍ8 9
ForwardRenderer
ÍÍ9 H
)
ÍÍH I
{
ÎÎ 
var
ÏÏ 
data
ÏÏ 
=
ÏÏ 
AssetDatabase
ÏÏ ,
.
ÏÏ, -
LoadAssetAtPath
ÏÏ- <
<
ÏÏ< =!
ForwardRendererData
ÏÏ= P
>
ÏÏP Q
(
ÏÏQ R
$str
ÏÏR p
)
ÏÏp q
;
ÏÏq r
if
ÌÌ 
(
ÌÌ 
data
ÌÌ 
)
ÌÌ 
{
ÓÓ 
asset
ÔÔ 
.
ÔÔ  
m_RendererDataList
ÔÔ 0
[
ÔÔ0 1
$num
ÔÔ1 2
]
ÔÔ2 3
=
ÔÔ4 5
data
ÔÔ6 :
;
ÔÔ: ;
}
 
else
ÒÒ 
{
ÚÚ 
asset
ÛÛ 
.
ÛÛ %
LoadBuiltinRendererData
ÛÛ 5
(
ÛÛ5 6
)
ÛÛ6 7
;
ÛÛ7 8
}
ÙÙ 
asset
ıı 
.
ıı 
m_RendererData
ıı (
=
ıı) *
null
ıı+ /
;
ıı/ 0
}
ˆˆ 
asset
¯¯ 
.
¯¯ $
k_AssetPreviousVersion
¯¯ ,
=
¯¯- .
$num
¯¯/ 0
;
¯¯0 1
}
˘˘ 
}
˙˙ 	
float
˝˝  
ValidateShadowBias
˝˝  
(
˝˝  !
float
˝˝! &
value
˝˝' ,
)
˝˝, -
{
˛˛ 	
return
ˇˇ 
Mathf
ˇˇ 
.
ˇˇ 
Max
ˇˇ 
(
ˇˇ 
$num
ˇˇ !
,
ˇˇ! "
Mathf
ˇˇ# (
.
ˇˇ( )
Min
ˇˇ) ,
(
ˇˇ, -
value
ˇˇ- 2
,
ˇˇ2 3%
UniversalRenderPipeline
ˇˇ4 K
.
ˇˇK L
maxShadowBias
ˇˇL Y
)
ˇˇY Z
)
ˇˇZ [
;
ˇˇ[ \
}
ÄÄ 	
int
ÇÇ %
ValidatePerObjectLights
ÇÇ #
(
ÇÇ# $
int
ÇÇ$ '
value
ÇÇ( -
)
ÇÇ- .
{
ÉÉ 	
return
ÑÑ 
System
ÑÑ 
.
ÑÑ 
Math
ÑÑ 
.
ÑÑ 
Max
ÑÑ "
(
ÑÑ" #
$num
ÑÑ# $
,
ÑÑ$ %
System
ÑÑ& ,
.
ÑÑ, -
Math
ÑÑ- 1
.
ÑÑ1 2
Min
ÑÑ2 5
(
ÑÑ5 6
value
ÑÑ6 ;
,
ÑÑ; <%
UniversalRenderPipeline
ÑÑ= T
.
ÑÑT U 
maxPerObjectLights
ÑÑU g
)
ÑÑg h
)
ÑÑh i
;
ÑÑi j
}
ÖÖ 	
float
áá !
ValidateRenderScale
áá !
(
áá! "
float
áá" '
value
áá( -
)
áá- .
{
àà 	
return
ââ 
Mathf
ââ 
.
ââ 
Max
ââ 
(
ââ %
UniversalRenderPipeline
ââ 4
.
ââ4 5
minRenderScale
ââ5 C
,
ââC D
Mathf
ââE J
.
ââJ K
Min
ââK N
(
ââN O
value
ââO T
,
ââT U%
UniversalRenderPipeline
ââV m
.
ââm n
maxRenderScale
âân |
)
ââ| }
)
ââ} ~
;
ââ~ 
}
ää 	
internal
ëë 
bool
ëë &
ValidateRendererDataList
ëë .
(
ëë. /
bool
ëë/ 3
partial
ëë4 ;
=
ëë< =
false
ëë> C
)
ëëC D
{
íí 	
var
ìì 
emptyEntries
ìì 
=
ìì 
$num
ìì  
;
ìì  !
for
îî 
(
îî 
int
îî 
i
îî 
=
îî 
$num
îî 
;
îî 
i
îî 
<
îî  
m_RendererDataList
îî  2
.
îî2 3
Length
îî3 9
;
îî9 :
i
îî; <
++
îî< >
)
îî> ?
emptyEntries
îî@ L
+=
îîM O"
ValidateRendererData
îîP d
(
îîd e
i
îîe f
)
îîf g
?
îîh i
$num
îîj k
:
îîl m
$num
îîn o
;
îîo p
if
ïï 
(
ïï 
partial
ïï 
)
ïï 
return
ññ 
emptyEntries
ññ #
==
ññ$ &
$num
ññ' (
;
ññ( )
return
óó 
emptyEntries
óó 
!=
óó  " 
m_RendererDataList
óó# 5
.
óó5 6
Length
óó6 <
;
óó< =
}
òò 	
internal
öö 
bool
öö "
ValidateRendererData
öö *
(
öö* +
int
öö+ .
index
öö/ 4
)
öö4 5
{
õõ 	
if
ùù 
(
ùù 
index
ùù 
==
ùù 
-
ùù 
$num
ùù 
)
ùù 
index
ùù "
=
ùù# $$
m_DefaultRendererIndex
ùù% ;
;
ùù; <
return
ûû 
index
ûû 
<
ûû  
m_RendererDataList
ûû -
.
ûû- .
Length
ûû. 4
?
ûû5 6 
m_RendererDataList
ûû7 I
[
ûûI J
index
ûûJ O
]
ûûO P
!=
ûûQ S
null
ûûT X
:
ûûY Z
false
ûû[ `
;
ûû` a
}
üü 	
}
†† 
}°° √8
°D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\DepthOnlyPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
public 

class 
DepthOnlyPass 
:   
ScriptableRenderPass! 5
{ 
int 
kDepthBufferBits 
= 
$num !
;! "
private 
RenderTargetHandle "!
depthAttachmentHandle# 8
{9 :
get; >
;> ?
set@ C
;C D
}E F
internal #
RenderTextureDescriptor (

descriptor) 3
{4 5
get6 9
;9 :
private; B
setC F
;F G
}H I
FilteringSettings 
m_FilteringSettings -
;- .
ShaderTagId 
m_ShaderTagId !
=" #
new$ '
ShaderTagId( 3
(3 4
$str4 ?
)? @
;@ A
public 
DepthOnlyPass 
( 
RenderPassEvent ,
evt- 0
,0 1
RenderQueueRange2 B
renderQueueRangeC S
,S T
	LayerMaskU ^
	layerMask_ h
)h i
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @
DepthOnlyPass@ M
)M N
)N O
;O P
m_FilteringSettings 
=  !
new" %
FilteringSettings& 7
(7 8
renderQueueRange8 H
,H I
	layerMaskJ S
)S T
;T U
renderPassEvent 
= 
evt !
;! "
} 	
public"" 
void"" 
Setup"" 
("" #
RenderTextureDescriptor## #
baseDescriptor##$ 2
,##2 3
RenderTargetHandle$$ !
depthAttachmentHandle$$ 4
)$$4 5
{%% 	
this&& 
.&& !
depthAttachmentHandle&& &
=&&' (!
depthAttachmentHandle&&) >
;&&> ?
baseDescriptor'' 
.'' 
colorFormat'' &
=''' (
RenderTextureFormat'') <
.''< =
Depth''= B
;''B C
baseDescriptor(( 
.(( 
depthBufferBits(( *
=((+ ,
kDepthBufferBits((- =
;((= >
baseDescriptor++ 
.++ 
msaaSamples++ &
=++' (
$num++) *
;++* +

descriptor,, 
=,, 
baseDescriptor,, '
;,,' (
}-- 	
public// 
override// 
void// 
OnCameraSetup// *
(//* +
CommandBuffer//+ 8
cmd//9 <
,//< =
ref//> A
RenderingData//B O
renderingData//P ]
)//] ^
{00 	
cmd11 
.11 
GetTemporaryRT11 
(11 !
depthAttachmentHandle11 4
.114 5
id115 7
,117 8

descriptor119 C
,11C D

FilterMode11E O
.11O P
Point11P U
)11U V
;11V W
ConfigureTarget22 
(22 
new22 "
RenderTargetIdentifier22  6
(226 7!
depthAttachmentHandle227 L
.22L M

Identifier22M W
(22W X
)22X Y
,22Y Z
$num22[ \
,22\ ]
CubemapFace22^ i
.22i j
Unknown22j q
,22q r
-22s t
$num22t u
)22u v
)22v w
;22w x
ConfigureClear33 
(33 
	ClearFlag33 $
.33$ %
All33% (
,33( )
Color33* /
.33/ 0
black330 5
)335 6
;336 7
}44 	
public77 
override77 
void77 
Execute77 $
(77$ %#
ScriptableRenderContext77% <
context77= D
,77D E
ref77F I
RenderingData77J W
renderingData77X e
)77e f
{88 	
CommandBuffer;; 
cmd;; 
=;; 
CommandBufferPool;;  1
.;;1 2
Get;;2 5
(;;5 6
);;6 7
;;;7 8
using<< 
(<< 
new<< 
ProfilingScope<< %
(<<% &
cmd<<& )
,<<) *
ProfilingSampler<<+ ;
.<<; <
Get<<< ?
(<<? @
URPProfileId<<@ L
.<<L M
DepthPrepass<<M Y
)<<Y Z
)<<Z [
)<<[ \
{== 
context>> 
.>>  
ExecuteCommandBuffer>> ,
(>>, -
cmd>>- 0
)>>0 1
;>>1 2
cmd?? 
.?? 
Clear?? 
(?? 
)?? 
;?? 
varAA 
	sortFlagsAA 
=AA 
renderingDataAA  -
.AA- .

cameraDataAA. 8
.AA8 9"
defaultOpaqueSortFlagsAA9 O
;AAO P
varBB 
drawSettingsBB  
=BB! "!
CreateDrawingSettingsBB# 8
(BB8 9
m_ShaderTagIdBB9 F
,BBF G
refBBH K
renderingDataBBL Y
,BBY Z
	sortFlagsBB[ d
)BBd e
;BBe f
drawSettingsCC 
.CC 
perObjectDataCC *
=CC+ ,
PerObjectDataCC- :
.CC: ;
NoneCC; ?
;CC? @
contextEE 
.EE 
DrawRenderersEE %
(EE% &
renderingDataEE& 3
.EE3 4
cullResultsEE4 ?
,EE? @
refEEA D
drawSettingsEEE Q
,EEQ R
refEES V
m_FilteringSettingsEEW j
)EEj k
;EEk l
}GG 
contextHH 
.HH  
ExecuteCommandBufferHH (
(HH( )
cmdHH) ,
)HH, -
;HH- .
CommandBufferPoolII 
.II 
ReleaseII %
(II% &
cmdII& )
)II) *
;II* +
}JJ 	
publicMM 
overrideMM 
voidMM 
OnCameraCleanupMM ,
(MM, -
CommandBufferMM- :
cmdMM; >
)MM> ?
{NN 	
ifOO 
(OO 
cmdOO 
==OO 
nullOO 
)OO 
throwPP 
newPP !
ArgumentNullExceptionPP /
(PP/ 0
$strPP0 5
)PP5 6
;PP6 7
ifRR 
(RR !
depthAttachmentHandleRR %
!=RR& (
RenderTargetHandleRR) ;
.RR; <
CameraTargetRR< H
)RRH I
{SS 
cmdTT 
.TT 
ReleaseTemporaryRTTT &
(TT& '!
depthAttachmentHandleTT' <
.TT< =
idTT= ?
)TT? @
;TT@ A!
depthAttachmentHandleUU %
=UU& '
RenderTargetHandleUU( :
.UU: ;
CameraTargetUU; G
;UUG H
}VV 
}WW 	
}XX 
}YY á
ßD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\ColorAdjustments.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' J
)J K
]K L
public 

sealed 
class 
ColorAdjustments (
:) *
VolumeComponent+ :
,: ;!
IPostProcessComponent< Q
{ 
[ 	
Tooltip	 
( 
$str	 ∂
)
∂ ∑
]
∑ ∏
public		 
FloatParameter		 
postExposure		 *
=		+ ,
new		- 0
FloatParameter		1 ?
(		? @
$num		@ B
)		B C
;		C D
[ 	
Tooltip	 
( 
$str H
)H I
]I J
public !
ClampedFloatParameter $
contrast% -
=. /
new0 3!
ClampedFloatParameter4 I
(I J
$numJ L
,L M
-N O
$numO S
,S T
$numU Y
)Y Z
;Z [
[ 	
Tooltip	 
( 
$str :
): ;
]; <
public 
ColorParameter 
colorFilter )
=* +
new, /
ColorParameter0 >
(> ?
Color? D
.D E
whiteE J
,J K
trueL P
,P Q
falseR W
,W X
trueY ]
)] ^
;^ _
[ 	
Tooltip	 
( 
$str /
)/ 0
]0 1
public !
ClampedFloatParameter $
hueShift% -
=. /
new0 3!
ClampedFloatParameter4 I
(I J
$numJ L
,L M
-N O
$numO S
,S T
$numU Y
)Y Z
;Z [
[ 	
Tooltip	 
( 
$str 6
)6 7
]7 8
public !
ClampedFloatParameter $

saturation% /
=0 1
new2 5!
ClampedFloatParameter6 K
(K L
$numL N
,N O
-P Q
$numQ U
,U V
$numW [
)[ \
;\ ]
public 
bool 
IsActive 
( 
) 
{ 	
return 
postExposure 
.  
value  %
!=& (
$num) +
|| 
contrast 
. 
value !
!=" $
$num% '
|| 
colorFilter 
!= !
Color" '
.' (
white( -
|| 
hueShift 
!= 
$num !
|| 

saturation 
!=  
$num! #
;# $
} 	
public   
bool   
IsTileCompatible   $
(  $ %
)  % &
=>  ' )
true  * .
;  . /
}!! 
}"" ‘5
¶D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\TileDepthRangePass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
internal 
class 
TileDepthRangePass %
:& ' 
ScriptableRenderPass( <
{		 
DeferredLights

 
m_DeferredLights

 '
;

' (
int 
m_PassIndex 
= 
$num 
; 
public 
TileDepthRangePass !
(! "
RenderPassEvent" 1
evt2 5
,5 6
DeferredLights7 E
deferredLightsF T
,T U
intV Y
	passIndexZ c
)c d
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @
TileDepthRangePass@ R
)R S
)S T
;T U
base 
. 
renderPassEvent  
=! "
evt# &
;& '
m_DeferredLights 
= 
deferredLights -
;- .
m_PassIndex 
= 
	passIndex #
;# $
} 	
public 
override 
void 
	Configure &
(& '
CommandBuffer' 4
cmd5 8
,8 9#
RenderTextureDescriptor: Q#
cameraTextureDescriptorR i
)i j
{ 	
RenderTargetHandle 
	outputTex (
;( )#
RenderTextureDescriptor #
desc$ (
;( )
if 
( 
m_PassIndex 
== 
$num  
&&! #
m_DeferredLights$ 4
.4 5&
HasTileDepthRangeExtraPass5 O
(O P
)P Q
)Q R
{ 
int 
	alignment 
= 
$num  !
<<" $
DeferredConfig% 3
.3 4+
kTileDepthInfoIntermediateLevel4 S
;S T
int 
depthInfoWidth "
=# $
(% &
m_DeferredLights& 6
.6 7
RenderWidth7 B
+C D
	alignmentE N
-O P
$numQ R
)R S
>>T V
DeferredConfigW e
.e f,
kTileDepthInfoIntermediateLevel	f Ö
;
Ö Ü
int 
depthInfoHeight #
=$ %
(& '
m_DeferredLights' 7
.7 8
RenderHeight8 D
+E F
	alignmentG P
-Q R
$numS T
)T U
>>V X
DeferredConfigY g
.g h,
kTileDepthInfoIntermediateLevel	h á
;
á à
	outputTex   
=   
m_DeferredLights   ,
.  , -
DepthInfoTexture  - =
;  = >
desc!! 
=!! 
new!! #
RenderTextureDescriptor!! 2
(!!2 3
depthInfoWidth!!3 A
,!!A B
depthInfoHeight!!C R
,!!R S
UnityEngine!!T _
.!!_ `
Experimental!!` l
.!!l m
	Rendering!!m v
.!!v w
GraphicsFormat	!!w Ö
.
!!Ö Ü
R32_UInt
!!Ü é
,
!!é è
$num
!!ê ë
)
!!ë í
;
!!í ì
}"" 
else## 
{$$ 
int%% 
tileDepthRangeWidth%% '
=%%( )
m_DeferredLights%%* :
.%%: ;
GetTiler%%; C
(%%C D
$num%%D E
)%%E F
.%%F G

TileXCount%%G Q
;%%Q R
int&&  
tileDepthRangeHeight&& (
=&&) *
m_DeferredLights&&+ ;
.&&; <
GetTiler&&< D
(&&D E
$num&&E F
)&&F G
.&&G H

TileYCount&&H R
;&&R S
	outputTex(( 
=(( 
m_DeferredLights(( ,
.((, - 
TileDepthInfoTexture((- A
;((A B
desc)) 
=)) 
new)) #
RenderTextureDescriptor)) 2
())2 3
tileDepthRangeWidth))3 F
,))F G 
tileDepthRangeHeight))H \
,))\ ]
UnityEngine))^ i
.))i j
Experimental))j v
.))v w
	Rendering	))w Ä
.
))Ä Å
GraphicsFormat
))Å è
.
))è ê
R32_UInt
))ê ò
,
))ò ô
$num
))ö õ
)
))õ ú
;
))ú ù
}** 
cmd++ 
.++ 
GetTemporaryRT++ 
(++ 
	outputTex++ (
.++( )
id++) +
,+++ ,
desc++- 1
,++1 2

FilterMode++3 =
.++= >
Point++> C
)++C D
;++D E
base,, 
.,, 
ConfigureTarget,,  
(,,  !
	outputTex,,! *
.,,* +

Identifier,,+ 5
(,,5 6
),,6 7
),,7 8
;,,8 9
}-- 	
public00 
override00 
void00 
Execute00 $
(00$ %#
ScriptableRenderContext00% <
context00= D
,00D E
ref00F I
RenderingData00J W
renderingData00X e
)00e f
{11 	
if22 
(22 
m_PassIndex22 
==22 
$num22  
)22  !
m_DeferredLights33  
.33  !$
ExecuteTileDepthInfoPass33! 9
(339 :
context33: A
,33A B
ref33C F
renderingData33G T
)33T U
;33U V
else44 
m_DeferredLights55  
.55  !(
ExecuteDownsampleBitmaskPass55! =
(55= >
context55> E
,55E F
ref55G J
renderingData55K X
)55X Y
;55Y Z
}66 	
public99 
override99 
void99 
OnCameraCleanup99 ,
(99, -
CommandBuffer99- :
cmd99; >
)99> ?
{:: 	
if;; 
(;; 
cmd;; 
==;; 
null;; 
);; 
throw<< 
new<< !
ArgumentNullException<< /
(<</ 0
$str<<0 5
)<<5 6
;<<6 7
cmd>> 
.>> 
ReleaseTemporaryRT>> "
(>>" #
m_DeferredLights>># 3
.>>3 4 
TileDepthInfoTexture>>4 H
.>>H I
id>>I K
)>>K L
;>>L M
m_DeferredLights?? 
.??  
TileDepthInfoTexture?? 1
=??2 3
RenderTargetHandle??4 F
.??F G
CameraTarget??G S
;??S T
}@@ 	
}AA 
}BB á
´D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Shadows\ShadowCasterGroup2D.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
public 

abstract 
class 
ShadowCasterGroup2D -
:. /
MonoBehaviour0 =
{		 
[

 	
SerializeField

	 
]

 
internal

 !
int

" %
m_ShadowGroup

& 3
=

4 5
$num

6 7
;

7 8
List 
< 
ShadowCaster2D 
> 
m_ShadowCasters ,
;, -
public 
List 
< 
ShadowCaster2D "
>" #
GetShadowCasters$ 4
(4 5
)5 6
{7 8
return9 ?
m_ShadowCasters@ O
;O P
}Q R
public 
int 
GetShadowGroup !
(! "
)" #
{$ %
return& ,
m_ShadowGroup- :
;: ;
}< =
public 
void "
RegisterShadowCaster2D *
(* +
ShadowCaster2D+ 9
shadowCaster2D: H
)H I
{ 	
if 
( 
m_ShadowCasters 
==  "
null# '
)' (
m_ShadowCasters 
=  !
new" %
List& *
<* +
ShadowCaster2D+ 9
>9 :
(: ;
); <
;< =
m_ShadowCasters 
. 
Add 
(  
shadowCaster2D  .
). /
;/ 0
} 	
public 
void $
UnregisterShadowCaster2D ,
(, -
ShadowCaster2D- ;
shadowCaster2D< J
)J K
{ 	
if 
( 
m_ShadowCasters 
!=  "
null# '
)' (
m_ShadowCasters 
.  
Remove  &
(& '
shadowCaster2D' 5
)5 6
;6 7
} 	
} 
} Æ	
ùD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\ComponentUtility.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
public 

static 
class 
ComponentUtility (
{ 
public 
static 
bool 
IsUniversalCamera ,
(, -
Camera- 3
camera4 :
): ;
=>		 
camera		 
.		 
GetComponent		 "
<		" #)
UniversalAdditionalCameraData		# @
>		@ A
(		A B
)		B C
!=		D F
null		G K
;		K L
public 
static 
bool 
IsUniversalLight +
(+ ,
Light, 1
light2 7
)7 8
=> 
light 
. 
GetComponent !
<! "(
UniversalAdditionalLightData" >
>> ?
(? @
)@ A
!=B D
nullE I
;I J
} 
} Ëx
•D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\RenderObjectsPass.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
[ 
	MovedFrom 
( 
$str 8
)8 9
]9 :
public; A
classB G
RenderObjectsPassH Y
:Z [ 
ScriptableRenderPass\ p
{		 
RenderQueueType

 
renderQueueType

 '
;

' (
FilteringSettings 
m_FilteringSettings -
;- .
RenderObjects 
.  
CustomCameraSettings *
m_CameraSettings+ ;
;; <
string 
m_ProfilerTag 
; 
ProfilingSampler 
m_ProfilingSampler +
;+ ,
public 
Material 
overrideMaterial (
{) *
get+ .
;. /
set0 3
;3 4
}5 6
public 
int %
overrideMaterialPassIndex ,
{- .
get/ 2
;2 3
set4 7
;7 8
}9 :
List 
< 
ShaderTagId 
> 
m_ShaderTagIdList +
=, -
new. 1
List2 6
<6 7
ShaderTagId7 B
>B C
(C D
)D E
;E F
public 
void 
SetDetphState !
(! "
bool" &
writeEnabled' 3
,3 4
CompareFunction5 D
functionE M
=N O
CompareFunctionP _
._ `
Less` d
)d e
{ 	
m_RenderStateBlock 
. 
mask #
|=$ &
RenderStateMask' 6
.6 7
Depth7 <
;< =
m_RenderStateBlock 
. 

depthState )
=* +
new, /

DepthState0 :
(: ;
writeEnabled; G
,G H
functionI Q
)Q R
;R S
} 	
public 
void 
SetStencilState #
(# $
int$ '
	reference( 1
,1 2
CompareFunction3 B
compareFunctionC R
,R S
	StencilOpT ]
passOp^ d
,d e
	StencilOpf o
failOpp v
,v w
	StencilOp	x Å
zFailOp
Ç â
)
â ä
{ 	
StencilState 
stencilState %
=& '
StencilState( 4
.4 5
defaultValue5 A
;A B
stencilState 
. 
enabled  
=! "
true# '
;' (
stencilState 
. 
SetCompareFunction +
(+ ,
compareFunction, ;
); <
;< =
stencilState   
.   
SetPassOperation   )
(  ) *
passOp  * 0
)  0 1
;  1 2
stencilState!! 
.!! 
SetFailOperation!! )
(!!) *
failOp!!* 0
)!!0 1
;!!1 2
stencilState"" 
."" 
SetZFailOperation"" *
(""* +
zFailOp""+ 2
)""2 3
;""3 4
m_RenderStateBlock$$ 
.$$ 
mask$$ #
|=$$$ &
RenderStateMask$$' 6
.$$6 7
Stencil$$7 >
;$$> ?
m_RenderStateBlock%% 
.%% 
stencilReference%% /
=%%0 1
	reference%%2 ;
;%%; <
m_RenderStateBlock&& 
.&& 
stencilState&& +
=&&, -
stencilState&&. :
;&&: ;
}'' 	
RenderStateBlock)) 
m_RenderStateBlock)) +
;))+ ,
public++ 
RenderObjectsPass++  
(++  !
string++! '
profilerTag++( 3
,++3 4
RenderPassEvent++5 D
renderPassEvent++E T
,++T U
string++V \
[++\ ]
]++] ^

shaderTags++_ i
,++i j
RenderQueueType++k z
renderQueueType	++{ ä
,
++ä ã
int
++å è
	layerMask
++ê ô
,
++ô ö
RenderObjects
++õ ®
.
++® ©"
CustomCameraSettings
++© Ω
cameraSettings
++æ Ã
)
++Ã Õ
{,, 	
base-- 
.-- 
profilingSampler-- !
=--" #
new--$ '
ProfilingSampler--( 8
(--8 9
nameof--9 ?
(--? @
RenderObjectsPass--@ Q
)--Q R
)--R S
;--S T
m_ProfilerTag// 
=// 
profilerTag// '
;//' (
m_ProfilingSampler00 
=00  
new00! $
ProfilingSampler00% 5
(005 6
profilerTag006 A
)00A B
;00B C
this11 
.11 
renderPassEvent11  
=11! "
renderPassEvent11# 2
;112 3
this22 
.22 
renderQueueType22  
=22! "
renderQueueType22# 2
;222 3
this33 
.33 
overrideMaterial33 !
=33" #
null33$ (
;33( )
this44 
.44 %
overrideMaterialPassIndex44 *
=44+ ,
$num44- .
;44. /
RenderQueueRange55 
renderQueueRange55 -
=55. /
(550 1
renderQueueType551 @
==55A C
RenderQueueType55D S
.55S T
Transparent55T _
)55_ `
?66 
RenderQueueRange66 "
.66" #
transparent66# .
:77 
RenderQueueRange77 "
.77" #
opaque77# )
;77) *
m_FilteringSettings88 
=88  !
new88" %
FilteringSettings88& 7
(887 8
renderQueueRange888 H
,88H I
	layerMask88J S
)88S T
;88T U
if:: 
(:: 

shaderTags:: 
!=:: 
null:: "
&&::# %

shaderTags::& 0
.::0 1
Length::1 7
>::8 9
$num::: ;
)::; <
{;; 
foreach<< 
(<< 
var<< 
passName<< %
in<<& (

shaderTags<<) 3
)<<3 4
m_ShaderTagIdList== %
.==% &
Add==& )
(==) *
new==* -
ShaderTagId==. 9
(==9 :
passName==: B
)==B C
)==C D
;==D E
}>> 
else?? 
{@@ 
m_ShaderTagIdListAA !
.AA! "
AddAA" %
(AA% &
newAA& )
ShaderTagIdAA* 5
(AA5 6
$strAA6 G
)AAG H
)AAH I
;AAI J
m_ShaderTagIdListBB !
.BB! "
AddBB" %
(BB% &
newBB& )
ShaderTagIdBB* 5
(BB5 6
$strBB6 H
)BBH I
)BBI J
;BBJ K
m_ShaderTagIdListCC !
.CC! "
AddCC" %
(CC% &
newCC& )
ShaderTagIdCC* 5
(CC5 6
$strCC6 L
)CCL M
)CCM N
;CCN O
m_ShaderTagIdListDD !
.DD! "
AddDD" %
(DD% &
newDD& )
ShaderTagIdDD* 5
(DD5 6
$strDD6 J
)DDJ K
)DDK L
;DDL M
}EE 
m_RenderStateBlockGG 
=GG  
newGG! $
RenderStateBlockGG% 5
(GG5 6
RenderStateMaskGG6 E
.GGE F
NothingGGF M
)GGM N
;GGN O
m_CameraSettingsHH 
=HH 
cameraSettingsHH -
;HH- .
}JJ 	
internalLL 
RenderObjectsPassLL "
(LL" #
URPProfileIdLL# /
	profileIdLL0 9
,LL9 :
RenderPassEventLL; J
renderPassEventLLK Z
,LLZ [
stringLL\ b
[LLb c
]LLc d

shaderTagsLLe o
,LLo p
RenderQueueType	LLq Ä
renderQueueType
LLÅ ê
,
LLê ë
int
LLí ï
	layerMask
LLñ ü
,
LLü †
RenderObjects
LL° Æ
.
LLÆ Ø"
CustomCameraSettings
LLØ √
cameraSettings
LLƒ “
)
LL“ ”
:MM 	
thisMM
 
(MM 
	profileIdMM 
.MM 
GetTypeMM  
(MM  !
)MM! "
.MM" #
NameMM# '
,MM' (
renderPassEventMM) 8
,MM8 9

shaderTagsMM: D
,MMD E
renderQueueTypeMMF U
,MMU V
	layerMaskMMW `
,MM` a
cameraSettingsMMb p
)MMp q
{NN 	
m_ProfilingSamplerOO 
=OO  
ProfilingSamplerOO! 1
.OO1 2
GetOO2 5
(OO5 6
	profileIdOO6 ?
)OO? @
;OO@ A
}PP 	
publicRR 
overrideRR 
voidRR 
ExecuteRR $
(RR$ %#
ScriptableRenderContextRR% <
contextRR= D
,RRD E
refRRF I
RenderingDataRRJ W
renderingDataRRX e
)RRe f
{SS 	
SortingCriteriaTT 
sortingCriteriaTT +
=TT, -
(TT. /
renderQueueTypeTT/ >
==TT? A
RenderQueueTypeTTB Q
.TTQ R
TransparentTTR ]
)TT] ^
?UU 
SortingCriteriaUU !
.UU! "
CommonTransparentUU" 3
:VV 
renderingDataVV 
.VV  

cameraDataVV  *
.VV* +"
defaultOpaqueSortFlagsVV+ A
;VVA B
DrawingSettingsXX 
drawingSettingsXX +
=XX, -!
CreateDrawingSettingsXX. C
(XXC D
m_ShaderTagIdListXXD U
,XXU V
refXXW Z
renderingDataXX[ h
,XXh i
sortingCriteriaXXj y
)XXy z
;XXz {
drawingSettingsYY 
.YY 
overrideMaterialYY ,
=YY- .
overrideMaterialYY/ ?
;YY? @
drawingSettingsZZ 
.ZZ %
overrideMaterialPassIndexZZ 5
=ZZ6 7%
overrideMaterialPassIndexZZ8 Q
;ZZQ R
ref\\ 

CameraData\\ 

cameraData\\ %
=\\& '
ref\\( +
renderingData\\, 9
.\\9 :

cameraData\\: D
;\\D E
Camera]] 
camera]] 
=]] 

cameraData]] &
.]]& '
camera]]' -
;]]- .
Rect`` 
	pixelRect`` 
=`` 
renderingData`` *
.``* +

cameraData``+ 5
.``5 6
	pixelRect``6 ?
;``? @
floataa 
cameraAspectaa 
=aa  
(aa! "
floataa" '
)aa' (
	pixelRectaa) 2
.aa2 3
widthaa3 8
/aa9 :
(aa; <
floataa< A
)aaA B
	pixelRectaaC L
.aaL M
heightaaM S
;aaS T
CommandBufferee 
cmdee 
=ee 
CommandBufferPoolee  1
.ee1 2
Getee2 5
(ee5 6
)ee6 7
;ee7 8
usingff 
(ff 
newff 
ProfilingScopeff %
(ff% &
cmdff& )
,ff) *
m_ProfilingSamplerff+ =
)ff= >
)ff> ?
{gg 
ifhh 
(hh 
m_CameraSettingshh $
.hh$ %
overrideCamerahh% 3
)hh3 4
{ii 
ifjj 
(jj 

cameraDatajj "
.jj" #
xrjj# %
.jj% &
enabledjj& -
)jj- .
{kk 
Debugll 
.ll 

LogWarningll (
(ll( )
$str	ll) ®
)
ll® ©
;
ll© ™
}mm 
elsenn 
{oo 
	Matrix4x4pp !
projectionMatrixpp" 2
=pp3 4
	Matrix4x4pp5 >
.pp> ?
Perspectivepp? J
(ppJ K
m_CameraSettingsppK [
.pp[ \
cameraFieldOfViewpp\ m
,ppm n
cameraAspectppo {
,pp{ |
cameraqq "
.qq" #
nearClipPlaneqq# 0
,qq0 1
cameraqq2 8
.qq8 9
farClipPlaneqq9 E
)qqE F
;qqF G
projectionMatrixrr (
=rr) *
GLrr+ -
.rr- ."
GetGPUProjectionMatrixrr. D
(rrD E
projectionMatrixrrE U
,rrU V

cameraDatarrW a
.rra b,
IsCameraProjectionMatrixFlipped	rrb Å
(
rrÅ Ç
)
rrÇ É
)
rrÉ Ñ
;
rrÑ Ö
	Matrix4x4tt !

viewMatrixtt" ,
=tt- .

cameraDatatt/ 9
.tt9 :
GetViewMatrixtt: G
(ttG H
)ttH I
;ttI J
Vector4uu 
cameraTranslationuu  1
=uu2 3

viewMatrixuu4 >
.uu> ?
	GetColumnuu? H
(uuH I
$numuuI J
)uuJ K
;uuK L

viewMatrixvv "
.vv" #
	SetColumnvv# ,
(vv, -
$numvv- .
,vv. /
cameraTranslationvv0 A
+vvB C
m_CameraSettingsvvD T
.vvT U
offsetvvU [
)vv[ \
;vv\ ]
RenderingUtilsxx &
.xx& '(
SetViewAndProjectionMatricesxx' C
(xxC D
cmdxxD G
,xxG H

viewMatrixxxI S
,xxS T
projectionMatrixxxU e
,xxe f
falsexxg l
)xxl m
;xxm n
}yy 
}zz 
context|| 
.||  
ExecuteCommandBuffer|| ,
(||, -
cmd||- 0
)||0 1
;||1 2
cmd}} 
.}} 
Clear}} 
(}} 
)}} 
;}} 
context 
. 
DrawRenderers %
(% &
renderingData& 3
.3 4
cullResults4 ?
,? @
refA D
drawingSettingsE T
,T U
refV Y
m_FilteringSettingsZ m
,m n
ref
ÄÄ  
m_RenderStateBlock
ÄÄ *
)
ÄÄ* +
;
ÄÄ+ ,
if
ÇÇ 
(
ÇÇ 
m_CameraSettings
ÇÇ $
.
ÇÇ$ %
overrideCamera
ÇÇ% 3
&&
ÇÇ4 6
m_CameraSettings
ÇÇ7 G
.
ÇÇG H
restoreCamera
ÇÇH U
&&
ÇÇV X
!
ÇÇY Z

cameraData
ÇÇZ d
.
ÇÇd e
xr
ÇÇe g
.
ÇÇg h
enabled
ÇÇh o
)
ÇÇo p
{
ÉÉ 
RenderingUtils
ÑÑ "
.
ÑÑ" #*
SetViewAndProjectionMatrices
ÑÑ# ?
(
ÑÑ? @
cmd
ÑÑ@ C
,
ÑÑC D

cameraData
ÑÑE O
.
ÑÑO P
GetViewMatrix
ÑÑP ]
(
ÑÑ] ^
)
ÑÑ^ _
,
ÑÑ_ `

cameraData
ÑÑa k
.
ÑÑk l%
GetGPUProjectionMatrixÑÑl Ç
(ÑÑÇ É
)ÑÑÉ Ñ
,ÑÑÑ Ö
falseÑÑÜ ã
)ÑÑã å
;ÑÑå ç
}
ÖÖ 
}
ÜÜ 
context
áá 
.
áá "
ExecuteCommandBuffer
áá (
(
áá( )
cmd
áá) ,
)
áá, -
;
áá- .
CommandBufferPool
àà 
.
àà 
Release
àà %
(
àà% &
cmd
àà& )
)
àà) *
;
àà* +
}
ââ 	
}
ää 
}ãã ˙ 
∞D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\ShadowsMidtonesHighlights.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' V
)V W
]W X
public 

sealed 
class %
ShadowsMidtonesHighlights 1
:2 3
VolumeComponent4 C
,C D!
IPostProcessComponentE Z
{ 
[ 	
Tooltip	 
( 
$str ?
)? @
]@ A
public		 
Vector4Parameter		 
shadows		  '
=		( )
new		* -
Vector4Parameter		. >
(		> ?
new		? B
Vector4		C J
(		J K
$num		K M
,		M N
$num		O Q
,		Q R
$num		S U
,		U V
$num		W Y
)		Y Z
)		Z [
;		[ \
[ 	
Tooltip	 
( 
$str @
)@ A
]A B
public 
Vector4Parameter 
midtones  (
=) *
new+ .
Vector4Parameter/ ?
(? @
new@ C
Vector4D K
(K L
$numL N
,N O
$numP R
,R S
$numT V
,V W
$numX Z
)Z [
)[ \
;\ ]
[ 	
Tooltip	 
( 
$str @
)@ A
]A B
public 
Vector4Parameter 

highlights  *
=+ ,
new- 0
Vector4Parameter1 A
(A B
newB E
Vector4F M
(M N
$numN P
,P Q
$numR T
,T U
$numV X
,X Y
$numZ \
)\ ]
)] ^
;^ _
[ 	
Tooltip	 
( 
$str N
)N O
]O P
public 
MinFloatParameter  
shadowsStart! -
=. /
new0 3
MinFloatParameter4 E
(E F
$numF H
,H I
$numJ L
)L M
;M N
[ 	
Tooltip	 
( 
$str L
)L M
]M N
public 
MinFloatParameter  

shadowsEnd! +
=, -
new. 1
MinFloatParameter2 C
(C D
$numD H
,H I
$numJ L
)L M
;M N
[ 	
Tooltip	 
( 
$str Q
)Q R
]R S
public 
MinFloatParameter  
highlightsStart! 0
=1 2
new3 6
MinFloatParameter7 H
(H I
$numI N
,N O
$numP R
)R S
;S T
[ 	
Tooltip	 
( 
$str O
)O P
]P Q
public 
MinFloatParameter  
highlightsEnd! .
=/ 0
new1 4
MinFloatParameter5 F
(F G
$numG I
,I J
$numK M
)M N
;N O
public 
bool 
IsActive 
( 
) 
{ 	
var 
defaultState 
= 
new "
Vector4# *
(* +
$num+ -
,- .
$num/ 1
,1 2
$num3 5
,5 6
$num7 9
)9 :
;: ;
return   
shadows   
!=   
defaultState   *
||!! 
midtones!! 
!=!! 
defaultState!! +
||"" 

highlights"" 
!=""  
defaultState""! -
;""- .
}## 	
public%% 
bool%% 
IsTileCompatible%% $
(%%$ %
)%%% &
=>%%' )
true%%* .
;%%. /
}&& 
}'' Õ
ôD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\StencilUsage.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
enum 
StencilUsage	 
{ 
UserMask 
= 
$num (
,( )
StencilLight 
= 
$num (
,( )
MaterialMask 
= 
$num (
,( )
MaterialUnlit 
= 
$num (
,( )
MaterialLit 
= 
$num (
,( )
MaterialSimpleLit 
= 
$num (
} 
} ú"
°D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\MotionBlur.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
public 

enum 
MotionBlurMode 
{ 

CameraOnly 
, 
CameraAndObjects 
}		 
public 

enum 
MotionBlurQuality !
{ 
Low 
, 
Medium 
, 
High 
} 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' D
)D E
]E F
public 

sealed 
class 

MotionBlur "
:# $
VolumeComponent% 4
,4 5!
IPostProcessComponent6 K
{ 
[ 	
Tooltip	 
( 
$str	 à
)
à â
]
â ä
public #
MotionBlurModeParameter &
mode' +
=, -
new. 1#
MotionBlurModeParameter2 I
(I J
MotionBlurModeJ X
.X Y

CameraOnlyY c
)c d
;d e
[ 	
Tooltip	 
( 
$str 
)	 Ä
]
Ä Å
public &
MotionBlurQualityParameter )
quality* 1
=2 3
new4 7&
MotionBlurQualityParameter8 R
(R S
MotionBlurQualityS d
.d e
Lowe h
)h i
;i j
[ 	
Tooltip	 
( 
$str _
)_ `
]` a
public !
ClampedFloatParameter $
	intensity% .
=/ 0
new1 4!
ClampedFloatParameter5 J
(J K
$numK M
,M N
$numO Q
,Q R
$numS U
)U V
;V W
[ 	
Tooltip	 
( 
$str	 º
)
º Ω
]
Ω æ
public !
ClampedFloatParameter $
clamp% *
=+ ,
new- 0!
ClampedFloatParameter1 F
(F G
$numG L
,L M
$numN P
,P Q
$numR V
)V W
;W X
public!! 
bool!! 
IsActive!! 
(!! 
)!! 
=>!! !
	intensity!!" +
.!!+ ,
value!!, 1
>!!2 3
$num!!4 6
&&!!7 9
mode!!: >
==!!? A
MotionBlurMode!!B P
.!!P Q

CameraOnly!!Q [
;!![ \
public## 
bool## 
IsTileCompatible## $
(##$ %
)##% &
=>##' )
false##* /
;##/ 0
}$$ 
[&& 
Serializable&& 
]&& 
public'' 

sealed'' 
class'' #
MotionBlurModeParameter'' /
:''0 1
VolumeParameter''2 A
<''A B
MotionBlurMode''B P
>''P Q
{''R S
public''T Z#
MotionBlurModeParameter''[ r
(''r s
MotionBlurMode	''s Å
value
''Ç á
,
''á à
bool
''â ç
overrideState
''é õ
=
''ú ù
false
''û £
)
''£ §
:
''• ¶
base
''ß ´
(
''´ ¨
value
''¨ ±
,
''± ≤
overrideState
''≥ ¿
)
''¿ ¡
{
''¬ √
}
''ƒ ≈
}
''∆ «
[)) 
Serializable)) 
])) 
public** 

sealed** 
class** &
MotionBlurQualityParameter** 2
:**3 4
VolumeParameter**5 D
<**D E
MotionBlurQuality**E V
>**V W
{**X Y
public**Z `&
MotionBlurQualityParameter**a {
(**{ |
MotionBlurQuality	**| ç
value
**é ì
,
**ì î
bool
**ï ô
overrideState
**ö ß
=
**® ©
false
**™ Ø
)
**Ø ∞
:
**± ≤
base
**≥ ∑
(
**∑ ∏
value
**∏ Ω
,
**Ω æ
overrideState
**ø Ã
)
**Ã Õ
{
**Œ œ
}
**– —
}
**“ ”
}++ ú 
úD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\Bloom.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' >
)> ?
]? @
public 

sealed 
class 
Bloom 
: 
VolumeComponent  /
,/ 0!
IPostProcessComponent1 F
{ 
[ 	
Tooltip	 
( 
$str ^
)^ _
]_ `
public		 
MinFloatParameter		  
	threshold		! *
=		+ ,
new		- 0
MinFloatParameter		1 B
(		B C
$num		C G
,		G H
$num		I K
)		K L
;		L M
[ 	
Tooltip	 
( 
$str 0
)0 1
]1 2
public 
MinFloatParameter  
	intensity! *
=+ ,
new- 0
MinFloatParameter1 B
(B C
$numC E
,E F
$numG I
)I J
;J K
[ 	
Tooltip	 
( 
$str 9
)9 :
]: ;
public !
ClampedFloatParameter $
scatter% ,
=- .
new/ 2!
ClampedFloatParameter3 H
(H I
$numI M
,M N
$numO Q
,Q R
$numS U
)U V
;V W
[ 	
Tooltip	 
( 
$str =
)= >
]> ?
public 
MinFloatParameter  
clamp! &
=' (
new) ,
MinFloatParameter- >
(> ?
$num? E
,E F
$numG I
)I J
;J K
[ 	
Tooltip	 
( 
$str 3
)3 4
]4 5
public 
ColorParameter 
tint "
=# $
new% (
ColorParameter) 7
(7 8
Color8 =
.= >
white> C
,C D
falseE J
,J K
falseL Q
,Q R
trueS W
)W X
;X Y
[ 	
Tooltip	 
( 
$str	 £
)
£ §
]
§ •
public 
BoolParameter  
highQualityFiltering 1
=2 3
new4 7
BoolParameter8 E
(E F
falseF K
)K L
;L M
[ 	
Tooltip	 
( 
$str \
)\ ]
]] ^
public 
ClampedIntParameter "
skipIterations# 1
=2 3
new4 7
ClampedIntParameter8 K
(K L
$numL M
,M N
$numO P
,P Q
$numR T
)T U
;U V
[ 	
Tooltip	 
( 
$str P
)P Q
]Q R
public 
TextureParameter 
dirtTexture  +
=, -
new. 1
TextureParameter2 B
(B C
nullC G
)G H
;H I
[   	
Tooltip  	 
(   
$str   '
)  ' (
]  ( )
public!! 
MinFloatParameter!!  
dirtIntensity!!! .
=!!/ 0
new!!1 4
MinFloatParameter!!5 F
(!!F G
$num!!G I
,!!I J
$num!!K M
)!!M N
;!!N O
public## 
bool## 
IsActive## 
(## 
)## 
=>## !
	intensity##" +
.##+ ,
value##, 1
>##2 3
$num##4 6
;##6 7
public%% 
bool%% 
IsTileCompatible%% $
(%%$ %
)%%% &
=>%%' )
false%%* /
;%%/ 0
}&& 
}'' ç
™D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\ChromaticAberration.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' M
)M N
]N O
public 

sealed 
class 
ChromaticAberration +
:, -
VolumeComponent. =
,= >!
IPostProcessComponent? T
{ 
[ 	
Tooltip	 
( 
$str 3
)3 4
]4 5
public		 !
ClampedFloatParameter		 $
	intensity		% .
=		/ 0
new		1 4!
ClampedFloatParameter		5 J
(		J K
$num		K M
,		M N
$num		O Q
,		Q R
$num		S U
)		U V
;		V W
public 
bool 
IsActive 
( 
) 
=> !
	intensity" +
.+ ,
value, 1
>2 3
$num4 6
;6 7
public 
bool 
IsTileCompatible $
($ %
)% &
=>' )
false* /
;/ 0
} 
} ⁄"
óD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Deprecated.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
public		 

abstract		 
partial		 
class		 ! 
ScriptableRenderPass		" 6
{

 
[ 	
EditorBrowsable	 
(  
EditorBrowsableState -
.- .
Never. 3
)3 4
]4 5
public 
virtual 
void 
FrameCleanup (
(( )
CommandBuffer) 6
cmd7 :
): ;
=>< >
OnCameraCleanup? N
(N O
cmdO R
)R S
;S T
} 
[ 
Obsolete 
( 
$str H
,H I
falseJ O
)O P
]P Q
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
enum5 9 
ShadowCascadesOption: N
{ 

NoCascades 
, 
TwoCascades 
, 
FourCascades 
, 
} 
public 

partial 
class (
UniversalRenderPipelineAsset 5
{ 
[ 	
Obsolete	 
( 
$str L
,L M
falseN S
)S T
]T U
[ 	
SerializeField	 
]  
ShadowCascadesOption -
m_ShadowCascades. >
=? @ 
ShadowCascadesOptionA U
.U V

NoCascadesV `
;` a
[ 	
Obsolete	 
( 
$str L
,L M
falseN S
)S T
]T U
public  
ShadowCascadesOption #
shadowCascadeOption$ 7
{ 	
get   
{!! 
return"" 
shadowCascadeCount"" )
switch""* 0
{## 
$num$$ 
=>$$  
ShadowCascadesOption$$ -
.$$- .

NoCascades$$. 8
,$$8 9
$num%% 
=>%%  
ShadowCascadesOption%% -
.%%- .
TwoCascades%%. 9
,%%9 :
$num&& 
=>&&  
ShadowCascadesOption&& -
.&&- .
FourCascades&&. :
,&&: ;
_'' 
=>'' 
throw'' 
new'' "%
InvalidOperationException''# <
(''< =
$str	''= ò
)
''ò ô
}(( 
;(( 
})) 
set** 
{++ 
switch,, 
(,, 
value,, 
),, 
{-- 
case..  
ShadowCascadesOption.. -
...- .

NoCascades... 8
:..8 9
shadowCascadeCount// *
=//+ ,
$num//- .
;//. /
break00 
;00 
case11  
ShadowCascadesOption11 -
.11- .
TwoCascades11. 9
:119 :
shadowCascadeCount22 *
=22+ ,
$num22- .
;22. /
break33 
;33 
case44  
ShadowCascadesOption44 -
.44- .
FourCascades44. :
:44: ;
shadowCascadeCount55 *
=55+ ,
$num55- .
;55. /
break66 
;66 
default77 
:77 
throw88 
new88 !%
InvalidOperationException88" ;
(88; <
$str	88< ó
)
88ó ò
;
88ò ô
}99 
}:: 
};; 	
}== 
[?? 
	MovedFrom?? 
(?? 
$str?? +
)??+ ,
]??, -
public@@ 

abstract@@ 
partial@@ 
class@@ !
ScriptableRenderer@@" 4
{AA 
[CC 	
ObsoleteCC	 
(CC 
$strCC m
)CCm n
]CCn o
[DD 	
EditorBrowsableDD	 
(DD  
EditorBrowsableStateDD -
.DD- .
NeverDD. 3
)DD3 4
]DD4 5
publicEE "
RenderTargetIdentifierEE %
cameraDepthEE& 1
{FF 	
getGG 
=>GG 
m_CameraDepthTargetGG &
;GG& '
}HH 	
}II 
}JJ Â
•D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\LensDistortion.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' H
)H I
]I J
public 

sealed 
class 
LensDistortion &
:' (
VolumeComponent) 8
,8 9!
IPostProcessComponent: O
{ 
[ 	
Tooltip	 
( 
$str +
)+ ,
], -
public		 !
ClampedFloatParameter		 $
	intensity		% .
=		/ 0
new		1 4!
ClampedFloatParameter		5 J
(		J K
$num		K M
,		M N
-		O P
$num		P R
,		R S
$num		T V
)		V W
;		W X
[ 	
Tooltip	 
( 
$str b
)b c
]c d
public !
ClampedFloatParameter $
xMultiplier% 0
=1 2
new3 6!
ClampedFloatParameter7 L
(L M
$numM O
,O P
$numQ S
,S T
$numU W
)W X
;X Y
[ 	
Tooltip	 
( 
$str b
)b c
]c d
public !
ClampedFloatParameter $
yMultiplier% 0
=1 2
new3 6!
ClampedFloatParameter7 L
(L M
$numM O
,O P
$numQ S
,S T
$numU W
)W X
;X Y
[ 	
Tooltip	 
( 
$str +
)+ ,
], -
public 
Vector2Parameter 
center  &
=' (
new) ,
Vector2Parameter- =
(= >
new> A
Vector2B I
(I J
$numJ N
,N O
$numP T
)T U
)U V
;V W
[ 	
Tooltip	 
( 
$str )
)) *
]* +
public !
ClampedFloatParameter $
scale% *
=+ ,
new- 0!
ClampedFloatParameter1 F
(F G
$numG I
,I J
$numK P
,P Q
$numR T
)T U
;U V
public 
bool 
IsActive 
( 
) 
{ 	
return 
Mathf 
. 
Abs 
( 
	intensity &
.& '
value' ,
), -
>. /
$num0 1
&& 
( 
xMultiplier 
.  
value  %
>& '
$num( *
||+ -
yMultiplier. 9
.9 :
value: ?
>@ A
$numB D
)D E
;E F
} 	
public 
bool 
IsTileCompatible $
($ %
)% &
=>' )
false* /
;/ 0
} 
} ±O
ûD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Renderer2DData.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
[ 
Serializable 
, 
ReloadGroup 
, 
ExcludeFromPreset  1
]1 2
[ 
	MovedFrom 
( 
$str 8
)8 9
]9 :
[ 
HelpURL 
( 
$str	 ñ
)
ñ ó
]
ó ò
public 

partial 
class 
Renderer2DData '
:( )"
ScriptableRendererData* @
{ 
public 
enum )
Renderer2DDefaultMaterialType 1
{ 	
Lit 
, 
Unlit 
, 
Custom 
} 	
[ 	
SerializeField	 
]  
TransparencySortMode "
m_TransparencySortMode 3
=4 5 
TransparencySortMode6 J
.J K
DefaultK R
;R S
[ 	
SerializeField	 
] 
Vector3 "
m_TransparencySortAxis &
=' (
Vector3) 0
.0 1
up1 3
;3 4
[!! 	
SerializeField!!	 
]!! 
float"" 
m_HDREmulationScale"" !
=""" #
$num""$ %
;""% &
[$$ 	
SerializeField$$	 
,$$  
FormerlySerializedAs$$ -
($$- .
$str$$. A
)$$A B
]$$B C
Light2DBlendStyle%% 
[%% 
]%% 
m_LightBlendStyles%% .
=%%/ 0
null%%1 5
;%%5 6
['' 	
SerializeField''	 
]'' 
bool(( #
m_UseDepthStencilBuffer(( $
=((% &
true((' +
;((+ ,
[** 	
SerializeField**	 
,** 
Reload** 
(**  
$str**  A
)**A B
]**B C
Shader++ 
m_ShapeLightShader++ !
=++" #
null++$ (
;++( )
[-- 	
SerializeField--	 
,-- 
Reload-- 
(--  
$str--  L
)--L M
]--M N
Shader.. $
m_ShapeLightVolumeShader.. '
=..( )
null..* .
;... /
[00 	
SerializeField00	 
,00 
Reload00 
(00  
$str00  A
)00A B
]00B C
Shader11 
m_PointLightShader11 !
=11" #
null11$ (
;11( )
[33 	
SerializeField33	 
,33 
Reload33 
(33  
$str33  L
)33L M
]33M N
Shader44 $
m_PointLightVolumeShader44 '
=44( )
null44* .
;44. /
[66 	
SerializeField66	 
,66 
Reload66 
(66  
$str66  ;
)66; <
]66< =
Shader77 
m_BlitShader77 
=77 
null77 "
;77" #
[99 	
SerializeField99	 
,99 
Reload99 
(99  
$str99  A
)99A B
]99B C
Shader:: 
m_ShadowGroupShader:: "
=::# $
null::% )
;::) *
[<< 	
SerializeField<<	 
,<< 
Reload<< 
(<<  
$str<<  F
)<<F G
]<<G H
Shader== $
m_RemoveSelfShadowShader== '
===( )
null==* .
;==. /
[?? 	
SerializeField??	 
,?? 
Reload?? 
(??  
$str??  D
)??D E
]??E F
PostProcessData@@ 
m_PostProcessData@@ )
=@@* +
null@@, 0
;@@0 1
publicBB 
floatBB 
hdrEmulationScaleBB &
=>BB' )
m_HDREmulationScaleBB* =
;BB= >
publicCC 
Light2DBlendStyleCC  
[CC  !
]CC! "
lightBlendStylesCC# 3
=>CC4 6
m_LightBlendStylesCC7 I
;CCI J
internalDD 
boolDD !
useDepthStencilBufferDD +
=>DD, .#
m_UseDepthStencilBufferDD/ F
;DDF G
internalFF 
ShaderFF 
shapeLightShaderFF (
=>FF) +
m_ShapeLightShaderFF, >
;FF> ?
internalGG 
ShaderGG "
shapeLightVolumeShaderGG .
=>GG/ 1$
m_ShapeLightVolumeShaderGG2 J
;GGJ K
internalHH 
ShaderHH 
pointLightShaderHH (
=>HH) +
m_PointLightShaderHH, >
;HH> ?
internalII 
ShaderII "
pointLightVolumeShaderII .
=>II/ 1$
m_PointLightVolumeShaderII2 J
;IIJ K
internalJJ 
ShaderJJ 

blitShaderJJ "
=>JJ# %
m_BlitShaderJJ& 2
;JJ2 3
internalKK 
ShaderKK 
shadowGroupShaderKK )
=>KK* ,
m_ShadowGroupShaderKK- @
;KK@ A
internalLL 
ShaderLL "
removeSelfShadowShaderLL .
=>LL/ 1$
m_RemoveSelfShadowShaderLL2 J
;LLJ K
internalMM 
PostProcessDataMM  
postProcessDataMM! 0
=>MM1 3
m_PostProcessDataMM4 E
;MME F
internalNN  
TransparencySortModeNN % 
transparencySortModeNN& :
=>NN; ="
m_TransparencySortModeNN> T
;NNT U
internalOO 
Vector3OO  
transparencySortAxisOO -
=>OO. 0"
m_TransparencySortAxisOO1 G
;OOG H
	protectedQQ 
overrideQQ 
ScriptableRendererQQ -
CreateQQ. 4
(QQ4 5
)QQ5 6
{RR 	
ifTT 
(TT 
!TT 
ApplicationTT 
.TT 
	isPlayingTT &
)TT& '
{UU 
ResourceReloaderVV  
.VV  !
TryReloadAllNullInVV! 3
(VV3 4
thisVV4 8
,VV8 9(
UniversalRenderPipelineAssetVV: V
.VVV W
packagePathVVW b
)VVb c
;VVc d
ResourceReloaderWW  
.WW  !
TryReloadAllNullInWW! 3
(WW3 4
m_PostProcessDataWW4 E
,WWE F(
UniversalRenderPipelineAssetWWG c
.WWc d
packagePathWWd o
)WWo p
;WWp q
}XX 
returnZZ 
newZZ 

Renderer2DZZ !
(ZZ! "
thisZZ" &
)ZZ& '
;ZZ' (
}[[ 	
	protected]] 
override]] 
void]] 
OnEnable]]  (
(]]( )
)]]) *
{^^ 	
base__ 
.__ 
OnEnable__ 
(__ 
)__ 
;__ 
OnEnableInEditoraa 
(aa 
)aa 
;aa 
fordd 
(dd 
vardd 
idd 
=dd 
$numdd 
;dd 
idd 
<dd 
m_LightBlendStylesdd  2
.dd2 3
Lengthdd3 9
;dd9 :
++dd; =
idd= >
)dd> ?
{ee 
m_LightBlendStylesff "
[ff" #
iff# $
]ff$ %
.ff% &
renderTargetHandleff& 8
.ff8 9
Initff9 =
(ff= >
$"ff> @
_ShapeLightTextureff@ R
{ffR S
iffS T
}ffT U
"ffU V
)ffV W
;ffW X
}gg 
normalsRenderTargetii 
.ii  
Initii  $
(ii$ %
$strii% 1
)ii1 2
;ii2 3
shadowsRenderTargetjj 
.jj  
Initjj  $
(jj$ %
$strjj% 1
)jj1 2
;jj2 3
constll 
intll 
totalMaterialsll $
=ll% &
$numll' *
;ll* +
ifmm 
(mm 
shadowMaterialsmm 
==mm !
nullmm" &
||mm' )
shadowMaterialsmm* 9
.mm9 :
Lengthmm: @
==mmA C
$nummmD E
)mmE F
shadowMaterialsnn 
=nn  !
newnn" %
Materialnn& .
[nn. /
totalMaterialsnn/ =
]nn= >
;nn> ?
ifoo 
(oo %
removeSelfShadowMaterialsoo (
==oo) +
nulloo, 0
||oo1 3%
removeSelfShadowMaterialsoo4 M
.ooM N
LengthooN T
==ooU W
$numooX Y
)ooY Z%
removeSelfShadowMaterialspp )
=pp* +
newpp, /
Materialpp0 8
[pp8 9
totalMaterialspp9 G
]ppG H
;ppH I
}qq 	
internaltt 

Dictionarytt 
<tt 
uinttt  
,tt  !
Materialtt" *
>tt* +
lightMaterialstt, :
{tt; <
gettt= @
;tt@ A
}ttB C
=ttD E
newttF I

DictionaryttJ T
<ttT U
uintttU Y
,ttY Z
Materialtt[ c
>ttc d
(ttd e
)tte f
;ttf g
internaluu 
Materialuu 
[uu 
]uu 
shadowMaterialsuu +
{uu, -
getuu. 1
;uu1 2
privateuu3 :
setuu; >
;uu> ?
}uu@ A
internalvv 
Materialvv 
[vv 
]vv %
removeSelfShadowMaterialsvv 5
{vv6 7
getvv8 ;
;vv; <
privatevv= D
setvvE H
;vvH I
}vvJ K
internalxx 
RenderTargetHandlexx #
normalsRenderTargetxx$ 7
;xx7 8
internalyy 
RenderTargetHandleyy #
shadowsRenderTargetyy$ 7
;yy7 8
internal|| 
ILight2DCullResult|| #
lightCullResult||$ 3
{||4 5
get||6 9
;||9 :
set||; >
;||> ?
}||@ A
}}} 
}~~ ªå
ßD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Shadows\ShadowRendering.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
internal 
static 
class 
ShadowRendering )
{ 
private 
static 
readonly 
int  #
k_LightPosID$ 0
=1 2
Shader3 9
.9 :
PropertyToID: F
(F G
$strG R
)R S
;S T
private		 
static		 
readonly		 
int		  #"
k_ShadowStencilGroupID		$ :
=		; <
Shader		= C
.		C D
PropertyToID		D P
(		P Q
$str		Q f
)		f g
;		g h
private

 
static

 
readonly

 
int

  #
k_ShadowIntensityID

$ 7
=

8 9
Shader

: @
.

@ A
PropertyToID

A M
(

M N
$str

N `
)

` a
;

a b
private 
static 
readonly 
int  #%
k_ShadowVolumeIntensityID$ =
=> ?
Shader@ F
.F G
PropertyToIDG S
(S T
$strT l
)l m
;m n
private 
static 
readonly 
int  #
k_ShadowRadiusID$ 4
=5 6
Shader7 =
.= >
PropertyToID> J
(J K
$strK Z
)Z [
;[ \
private 
static 
Material 
GetShadowMaterial  1
(1 2
this2 6
Renderer2DData7 E
rendererDataF R
,R S
intT W
indexX ]
)] ^
{ 	
var 
shadowMaterialIndex #
=$ %
index& +
%, -
$num. 1
;1 2
if 
( 
rendererData 
. 
shadowMaterials ,
[, -
shadowMaterialIndex- @
]@ A
==B D
nullE I
)I J
{ 
rendererData 
. 
shadowMaterials ,
[, -
shadowMaterialIndex- @
]@ A
=B C
	CoreUtilsD M
.M N 
CreateEngineMaterialN b
(b c
rendererDatac o
.o p
shadowGroupShader	p Å
)
Å Ç
;
Ç É
rendererData 
. 
shadowMaterials ,
[, -
shadowMaterialIndex- @
]@ A
.A B
SetFloatB J
(J K"
k_ShadowStencilGroupIDK a
,a b
indexc h
)h i
;i j
} 
return 
rendererData 
.  
shadowMaterials  /
[/ 0
shadowMaterialIndex0 C
]C D
;D E
} 	
private 
static 
Material '
GetRemoveSelfShadowMaterial  ;
(; <
this< @
Renderer2DDataA O
rendererDataP \
,\ ]
int^ a
indexb g
)g h
{ 	
var 
shadowMaterialIndex #
=$ %
index& +
%, -
$num. 1
;1 2
if 
( 
rendererData 
. %
removeSelfShadowMaterials 6
[6 7
shadowMaterialIndex7 J
]J K
==L N
nullO S
)S T
{ 
rendererData 
. %
removeSelfShadowMaterials 6
[6 7
shadowMaterialIndex7 J
]J K
=L M
	CoreUtilsN W
.W X 
CreateEngineMaterialX l
(l m
rendererDatam y
.y z#
removeSelfShadowShader	z ê
)
ê ë
;
ë í
rendererData   
.   %
removeSelfShadowMaterials   6
[  6 7
shadowMaterialIndex  7 J
]  J K
.  K L
SetFloat  L T
(  T U"
k_ShadowStencilGroupID  U k
,  k l
index  m r
)  r s
;  s t
}!! 
return## 
rendererData## 
.##  %
removeSelfShadowMaterials##  9
[##9 :
shadowMaterialIndex##: M
]##M N
;##N O
}$$ 	
private&& 
static&& 
void&& %
CreateShadowRenderTexture&& 5
(&&5 6
IRenderPass2D&&6 C
pass&&D H
,&&H I
RenderingData&&J W
renderingData&&X e
,&&e f
CommandBuffer&&g t
cmd&&u x
,&&x y
int&&z }
blendStyleIndex	&&~ ç
)
&&ç é
{'' 	
var(( 
renderTextureScale(( "
=((# $
Mathf((% *
.((* +
Clamp((+ 0
(((0 1
pass((1 5
.((5 6
rendererData((6 B
.((B C
lightBlendStyles((C S
[((S T
blendStyleIndex((T c
]((c d
.((d e
renderTextureScale((e w
,((w x
$num((y ~
,((~ 
$num
((Ä Ñ
)
((Ñ Ö
;
((Ö Ü
var)) 
width)) 
=)) 
()) 
int)) 
))) 
()) 
renderingData)) +
.))+ ,

cameraData)), 6
.))6 7"
cameraTargetDescriptor))7 M
.))M N
width))N S
*))T U
renderTextureScale))V h
)))h i
;))i j
var** 
height** 
=** 
(** 
int** 
)** 
(** 
renderingData** ,
.**, -

cameraData**- 7
.**7 8"
cameraTargetDescriptor**8 N
.**N O
height**O U
***V W
renderTextureScale**X j
)**j k
;**k l
var,, 

descriptor,, 
=,, 
new,,  #
RenderTextureDescriptor,,! 8
(,,8 9
width,,9 >
,,,> ?
height,,@ F
),,F G
;,,G H

descriptor-- 
.-- 
	useMipMap--  
=--! "
false--# (
;--( )

descriptor.. 
... 
autoGenerateMips.. '
=..( )
false..* /
;../ 0

descriptor// 
.// 
depthBufferBits// &
=//' (
$num//) +
;//+ ,

descriptor00 
.00 
graphicsFormat00 %
=00& '
GraphicsFormat00( 6
.006 7
R8G8B8A8_UNorm007 E
;00E F

descriptor11 
.11 
msaaSamples11 "
=11# $
$num11% &
;11& '

descriptor22 
.22 
	dimension22  
=22! "
TextureDimension22# 3
.223 4
Tex2D224 9
;229 :
cmd44 
.44 
GetTemporaryRT44 
(44 
pass44 #
.44# $
rendererData44$ 0
.440 1
shadowsRenderTarget441 D
.44D E
id44E G
,44G H

descriptor44I S
,44S T

FilterMode44U _
.44_ `
Bilinear44` h
)44h i
;44i j
}55 	
public77 
static77 
void77 
RenderShadows77 (
(77( )
IRenderPass2D77) 6
pass777 ;
,77; <
RenderingData77= J
renderingData77K X
,77X Y
CommandBuffer77Z g
	cmdBuffer77h q
,77q r
int77s v
layerToRender	77w Ñ
,
77Ñ Ö
Light2D
77Ü ç
light
77é ì
,
77ì î
float
77ï ö
shadowIntensity
77õ ™
,
77™ ´$
RenderTargetIdentifier
77¨ ¬
renderTexture
77√ –
,
77– —$
RenderTargetIdentifier
77“ Ë
depthTexture
77È ı
)
77ı ˆ
{88 	
	cmdBuffer99 
.99 
SetGlobalFloat99 $
(99$ %
k_ShadowIntensityID99% 8
,998 9
$num99: ;
-99< =
light99> C
.99C D
shadowIntensity99D S
)99S T
;99T U
	cmdBuffer:: 
.:: 
SetGlobalFloat:: $
(::$ %%
k_ShadowVolumeIntensityID::% >
,::> ?
$num::@ A
-::B C
light::D I
.::I J!
shadowVolumeIntensity::J _
)::_ `
;::` a
if<< 
(<< 
shadowIntensity<< 
><<  !
$num<<" #
)<<# $
{== %
CreateShadowRenderTexture>> )
(>>) *
pass>>* .
,>>. /
renderingData>>0 =
,>>= >
	cmdBuffer>>? H
,>>H I
light>>J O
.>>O P
blendStyleIndex>>P _
)>>_ `
;>>` a
	cmdBuffer@@ 
.@@ 
SetRenderTarget@@ )
(@@) *
pass@@* .
.@@. /
rendererData@@/ ;
.@@; <
shadowsRenderTarget@@< O
.@@O P

Identifier@@P Z
(@@Z [
)@@[ \
,@@\ ]"
RenderBufferLoadAction@@^ t
.@@t u
Load@@u y
,@@y z$
RenderBufferStoreAction	@@{ í
.
@@í ì
Store
@@ì ò
,
@@ò ô$
RenderBufferLoadAction
@@ö ∞
.
@@∞ ±
DontCare
@@± π
,
@@π ∫%
RenderBufferStoreAction
@@ª “
.
@@“ ”
DontCare
@@” €
)
@@€ ‹
;
@@‹ ›
	cmdBufferAA 
.AA 
ClearRenderTargetAA +
(AA+ ,
trueAA, 0
,AA0 1
trueAA2 6
,AA6 7
ColorAA8 =
.AA= >
blackAA> C
)AAC D
;AAD E
varCC 
shadowRadiusCC  
=CC! "
$numCC# (
*CC) *
lightCC+ 0
.CC0 1
boundingSphereCC1 ?
.CC? @
radiusCC@ F
;CCF G
	cmdBufferEE 
.EE 
SetGlobalVectorEE )
(EE) *
k_LightPosIDEE* 6
,EE6 7
lightEE8 =
.EE= >
	transformEE> G
.EEG H
positionEEH P
)EEP Q
;EEQ R
	cmdBufferFF 
.FF 
SetGlobalFloatFF (
(FF( )
k_ShadowRadiusIDFF) 9
,FF9 :
shadowRadiusFF; G
)FFG H
;FFH I
varHH 
shadowMaterialHH "
=HH# $
passHH% )
.HH) *
rendererDataHH* 6
.HH6 7
GetShadowMaterialHH7 H
(HHH I
$numHHI J
)HHJ K
;HHK L
varII $
removeSelfShadowMaterialII ,
=II- .
passII/ 3
.II3 4
rendererDataII4 @
.II@ A'
GetRemoveSelfShadowMaterialIIA \
(II\ ]
$numII] ^
)II^ _
;II_ `
varJJ 
shadowCasterGroupsJJ &
=JJ' (&
ShadowCasterGroup2DManagerJJ) C
.JJC D
shadowCasterGroupsJJD V
;JJV W
ifKK 
(KK 
shadowCasterGroupsKK &
!=KK' )
nullKK* .
&&KK/ 1
shadowCasterGroupsKK2 D
.KKD E
CountKKE J
>KKK L
$numKKM N
)KKN O
{LL 
varMM $
previousShadowGroupIndexMM 0
=MM1 2
-MM3 4
$numMM4 5
;MM5 6
varNN "
incrementingGroupIndexNN .
=NN/ 0
$numNN1 2
;NN2 3
forOO 
(OO 
varOO 
groupOO "
=OO# $
$numOO% &
;OO& '
groupOO( -
<OO. /
shadowCasterGroupsOO0 B
.OOB C
CountOOC H
;OOH I
groupOOJ O
++OOO Q
)OOQ R
{PP 
varQQ 
shadowCasterGroupQQ -
=QQ. /
shadowCasterGroupsQQ0 B
[QQB C
groupQQC H
]QQH I
;QQI J
varSS 
shadowCastersSS )
=SS* +
shadowCasterGroupSS, =
.SS= >
GetShadowCastersSS> N
(SSN O
)SSO P
;SSP Q
varUU 
shadowGroupIndexUU ,
=UU- .
shadowCasterGroupUU/ @
.UU@ A
GetShadowGroupUUA O
(UUO P
)UUP Q
;UUQ R
ifVV 
(VV 
LightUtilityVV (
.VV( )
CheckForChangeVV) 7
(VV7 8
shadowGroupIndexVV8 H
,VVH I
refVVJ M$
previousShadowGroupIndexVVN f
)VVf g
||VVh j
shadowGroupIndexVVk {
==VV| ~
$num	VV Ä
)
VVÄ Å
{WW "
incrementingGroupIndexXX 2
++XX2 4
;XX4 5
shadowMaterialYY *
=YY+ ,
passYY- 1
.YY1 2
rendererDataYY2 >
.YY> ?
GetShadowMaterialYY? P
(YYP Q"
incrementingGroupIndexYYQ g
)YYg h
;YYh i$
removeSelfShadowMaterialZZ 4
=ZZ5 6
passZZ7 ;
.ZZ; <
rendererDataZZ< H
.ZZH I'
GetRemoveSelfShadowMaterialZZI d
(ZZd e"
incrementingGroupIndexZZe {
)ZZ{ |
;ZZ| }
}[[ 
if]] 
(]] 
shadowCasters]] )
!=]]* ,
null]]- 1
)]]1 2
{^^ 
for`` 
(``  !
var``! $
i``% &
=``' (
$num``) *
;``* +
i``, -
<``. /
shadowCasters``0 =
.``= >
Count``> C
;``C D
i``E F
++``F H
)``H I
{aa 
varbb  #
shadowCasterbb$ 0
=bb1 2
shadowCastersbb3 @
[bb@ A
ibbA B
]bbB C
;bbC D
ifdd  "
(dd# $
shadowCasterdd$ 0
!=dd1 3
nulldd4 8
&&dd9 ;
shadowMaterialdd< J
!=ddK M
nullddN R
&&ddS U
shadowCasterddV b
.ddb c
IsShadowedLayerddc r
(ddr s
layerToRender	dds Ä
)
ddÄ Å
)
ddÅ Ç
{ee  !
ifff$ &
(ff' (
shadowCasterff( 4
.ff4 5
castsShadowsff5 A
)ffA B
	cmdBuffergg( 1
.gg1 2
DrawMeshgg2 :
(gg: ;
shadowCastergg; G
.ggG H
meshggH L
,ggL M
shadowCasterggN Z
.ggZ [
	transformgg[ d
.ggd e
localToWorldMatrixgge w
,ggw x
shadowMaterial	ggy á
)
ggá à
;
ggà â
}hh  !
}ii 
forkk 
(kk  !
varkk! $
ikk% &
=kk' (
$numkk) *
;kk* +
ikk, -
<kk. /
shadowCasterskk0 =
.kk= >
Countkk> C
;kkC D
ikkE F
++kkF H
)kkH I
{ll 
varmm  #
shadowCastermm$ 0
=mm1 2
shadowCastersmm3 @
[mm@ A
immA B
]mmB C
;mmC D
ifoo  "
(oo# $
shadowCasteroo$ 0
!=oo1 3
nulloo4 8
&&oo9 ;
shadowMaterialoo< J
!=ooK M
nullooN R
&&ooS U
shadowCasterooV b
.oob c
IsShadowedLayerooc r
(oor s
layerToRender	oos Ä
)
ooÄ Å
)
ooÅ Ç
{pp  !
ifqq$ &
(qq' (
shadowCasterqq( 4
.qq4 5!
useRendererSilhouetteqq5 J
)qqJ K
{rr$ %
varss( +
rendererss, 4
=ss5 6
shadowCasterss7 C
.ssC D
GetComponentssD P
<ssP Q
RendererssQ Y
>ssY Z
(ssZ [
)ss[ \
;ss\ ]
iftt( *
(tt+ ,
renderertt, 4
!=tt5 7
nulltt8 <
)tt< =
{uu( )
ifvv, .
(vv/ 0
!vv0 1
shadowCastervv1 =
.vv= >
selfShadowsvv> I
)vvI J
	cmdBufferww0 9
.ww9 :
DrawRendererww: F
(wwF G
rendererwwG O
,wwO P$
removeSelfShadowMaterialwwQ i
)wwi j
;wwj k
elsexx, 0
	cmdBufferyy0 9
.yy9 :
DrawRendereryy: F
(yyF G
rendereryyG O
,yyO P
shadowMaterialyyQ _
,yy_ `
$numyya b
,yyb c
$numyyd e
)yye f
;yyf g
}zz( )
}{{$ %
else||$ (
{}}$ %
if~~( *
(~~+ ,
!~~, -
shadowCaster~~- 9
.~~9 :
selfShadows~~: E
)~~E F
{( )
var
ÄÄ, /
meshMat
ÄÄ0 7
=
ÄÄ8 9
shadowCaster
ÄÄ: F
.
ÄÄF G
	transform
ÄÄG P
.
ÄÄP Q 
localToWorldMatrix
ÄÄQ c
;
ÄÄc d
	cmdBuffer
ÅÅ, 5
.
ÅÅ5 6
DrawMesh
ÅÅ6 >
(
ÅÅ> ?
shadowCaster
ÅÅ? K
.
ÅÅK L
mesh
ÅÅL P
,
ÅÅP Q
meshMat
ÅÅR Y
,
ÅÅY Z&
removeSelfShadowMaterial
ÅÅ[ s
)
ÅÅs t
;
ÅÅt u
}
ÇÇ( )
}
ÉÉ$ %
}
ÑÑ  !
}
ÖÖ 
}
ÜÜ 
}
áá 
}
àà 
	cmdBuffer
ää 
.
ää  
ReleaseTemporaryRT
ää ,
(
ää, -
pass
ää- 1
.
ää1 2
rendererData
ää2 >
.
ää> ?!
shadowsRenderTarget
ää? R
.
ääR S
id
ääS U
)
ääU V
;
ääV W
	cmdBuffer
ãã 
.
ãã 
SetRenderTarget
ãã )
(
ãã) *
renderTexture
ãã* 7
,
ãã7 8
depthTexture
ãã9 E
)
ããE F
;
ããF G
}
åå 
}
çç 	
}
éé 
}èè £!
†D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Light2DAuthoring.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
public 

sealed 
partial 
class 
Light2D  '
{ 
private		 
const		 
string		 
s_IconsPath		 (
=		) *
$str		+ ~
;		~ 
private

 
static

 
readonly

 
string

  &
[

& '
]

' ( 
s_LightIconFileNames

) =
=

> ?
new

@ C
[

D E
]

E F
{ 	
$str !
,! "
$str 
,  
$str 
, 
$str 
, 
$str 
} 	
;	 

private 
void 
OnDrawGizmos !
(! "
)" #
{ 	
Gizmos 
. 
color 
= 
Color  
.  !
blue! %
;% &
Gizmos 
. 
DrawIcon 
( 
	transform %
.% &
position& .
,. /
s_IconsPath0 ;
+< = 
s_LightIconFileNames> R
[R S
(S T
intT W
)W X
m_LightTypeX c
]c d
,d e
truef j
)j k
;k l
} 	
void 
Reset 
( 
) 
{ 	
m_ShapePath 
= 
new 
Vector3 %
[% &
]& '
{( )
new* -
Vector3. 5
(5 6
-6 7
$num7 ;
,; <
-= >
$num> B
)B C
,C D
newE H
Vector3I P
(P Q
$numQ U
,U V
-W X
$numX \
)\ ]
,] ^
new_ b
Vector3c j
(j k
$numk o
,o p
$numq u
)u v
,v w
newx {
Vector3	| É
(
É Ñ
-
Ñ Ö
$num
Ö â
,
â ä
$num
ã è
)
è ê
}
ë í
;
í ì
} 	
internal 
List 
< 
Vector2 
> 
GetFalloffShape .
(. /
)/ 0
{ 	
var   
shape   
=   
new   
List    
<    !
Vector2  ! (
>  ( )
(  ) *
)  * +
;  + ,
var!! 
extrusionDir!! 
=!! 
LightUtility!! +
.!!+ ,
GetFalloffShape!!, ;
(!!; <
m_ShapePath!!< G
)!!G H
;!!H I
for"" 
("" 
var"" 
i"" 
="" 
$num"" 
;"" 
i"" 
<"" 
m_ShapePath""  +
.""+ ,
Length"", 2
;""2 3
i""4 5
++""5 7
)""7 8
{## 
shape$$ 
.$$ 
Add$$ 
($$ 
new$$ 
Vector2$$ %
{%% 
x&& 
=&& 
m_ShapePath&& #
[&&# $
i&&$ %
]&&% &
.&&& '
x&&' (
+&&) *
this&&+ /
.&&/ 0!
shapeLightFalloffSize&&0 E
*&&F G
extrusionDir&&H T
[&&T U
i&&U V
]&&V W
.&&W X
x&&X Y
,&&Y Z
y'' 
='' 
m_ShapePath'' #
[''# $
i''$ %
]''% &
.''& '
y''' (
+'') *
this''+ /
.''/ 0!
shapeLightFalloffSize''0 E
*''F G
extrusionDir''H T
[''T U
i''U V
]''V W
.''W X
y''X Y
}(( 
)(( 
;(( 
})) 
return** 
shape** 
;** 
}++ 	
}.. 
}// ¬
üD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\Vignette.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' A
)A B
]B C
public 

sealed 
class 
Vignette  
:! "
VolumeComponent# 2
,2 3!
IPostProcessComponent4 I
{ 
[ 	
Tooltip	 
( 
$str "
)" #
]# $
public		 
ColorParameter		 
color		 #
=		$ %
new		& )
ColorParameter		* 8
(		8 9
Color		9 >
.		> ?
black		? D
,		D E
false		F K
,		K L
false		M R
,		R S
true		T X
)		X Y
;		Y Z
[ 	
Tooltip	 
( 
$str O
)O P
]P Q
public 
Vector2Parameter 
center  &
=' (
new) ,
Vector2Parameter- =
(= >
new> A
Vector2B I
(I J
$numJ N
,N O
$numP T
)T U
)U V
;V W
[ 	
Tooltip	 
( 
$str 2
)2 3
]3 4
public !
ClampedFloatParameter $
	intensity% .
=/ 0
new1 4!
ClampedFloatParameter5 J
(J K
$numK M
,M N
$numO Q
,Q R
$numS U
)U V
;V W
[ 	
Tooltip	 
( 
$str 6
)6 7
]7 8
public !
ClampedFloatParameter $

smoothness% /
=0 1
new2 5!
ClampedFloatParameter6 K
(K L
$numL P
,P Q
$numR W
,W X
$numY [
)[ \
;\ ]
[ 	
Tooltip	 
( 
$str f
)f g
]g h
public 
BoolParameter 
rounded $
=% &
new' *
BoolParameter+ 8
(8 9
false9 >
)> ?
;? @
public 
bool 
IsActive 
( 
) 
=> !
	intensity" +
.+ ,
value, 1
>2 3
$num4 6
;6 7
public 
bool 
IsTileCompatible $
($ %
)% &
=>' )
true* .
;. /
} 
} ©)
∏D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Data\UniversalRenderPipelineEditorResources.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
LWRP  $
{ 
[ 
Obsolete 
( 
$str }
,} ~
true	 É
)
É Ñ
]
Ñ Ö
public 

class 4
(LightweightRenderPipelineEditorResources 9
{ 
}		 
}

 
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
class5 :2
&UniversalRenderPipelineEditorResources; a
:b c
ScriptableObjectd t
{ 
[ 	
Serializable	 
, 
ReloadGroup "
]" #
public 
sealed 
class 
ShaderResources +
{ 	
[ 
Reload 
( 
$str S
)S T
]T U
public 
Shader !
autodeskInteractivePS /
;/ 0
[ 
Reload 
( 
$str _
)_ `
]` a
public 
Shader ,
 autodeskInteractiveTransparentPS :
;: ;
[ 
Reload 
( 
$str Z
)Z [
][ \
public 
Shader '
autodeskInteractiveMaskedPS 5
;5 6
[ 
Reload 
( 
$str =
)= >
]> ?
public 
Shader 
terrainDetailLitPS ,
;, -
[   
Reload   
(   
$str   8
)  8 9
]  9 :
public!! 
Shader!!  
terrainDetailGrassPS!! .
;!!. /
[## 
Reload## 
(## 
$str## A
)##A B
]##B C
public$$ 
Shader$$ )
terrainDetailGrassBillboardPS$$ 7
;$$7 8
[&& 
Reload&& 
(&& 
$str&& 6
)&&6 7
]&&7 8
public'' 
Shader'' 
defaultSpeedTree7PS'' -
;''- .
[)) 
Reload)) 
()) 
$str)) 6
)))6 7
]))7 8
public** 
Shader** 
defaultSpeedTree8PS** -
;**- .
}++ 	
[-- 	
Serializable--	 
,-- 
ReloadGroup-- "
]--" #
public.. 
sealed.. 
class.. 
MaterialResources.. -
{// 	
[00 
Reload00 
(00 
$str00 /
)00/ 0
]000 1
public11 
Material11 
lit11 
;11  
[33 
Reload33 
(33 
$str33 8
)338 9
]339 :
public44 
Material44 
particleLit44 '
;44' (
[66 
Reload66 
(66 
$str66 6
)666 7
]667 8
public77 
Material77 

terrainLit77 &
;77& '
}88 	
public:: 
ShaderResources:: 
shaders:: &
;::& '
public;; 
MaterialResources;;  
	materials;;! *
;;;* +
}<< 
[?? 
UnityEditor?? 
.?? 
CustomEditor?? 
(?? 
typeof?? $
(??$ %2
&UniversalRenderPipelineEditorResources??% K
)??K L
,??L M
true??N R
)??R S
]??S T
class@@ 	8
,UniversalRenderPipelineEditorResourcesEditor@@
 6
:@@7 8
UnityEditor@@9 D
.@@D E
Editor@@E K
{AA 
publicBB 
overrideBB 
voidBB 
OnInspectorGUIBB +
(BB+ ,
)BB, -
{CC 	 
DrawDefaultInspectorDD  
(DD  !
)DD! "
;DD" #
ifGG 
(GG 
UnityEditorGG 
.GG 
EditorPrefsGG '
.GG' (
GetBoolGG( /
(GG/ 0
$strGG0 ?
)GG? @
&&GGA C
	GUILayoutGGD M
.GGM N
ButtonGGN T
(GGT U
$strGGU a
)GGa b
)GGb c
{HH 
varII 
	resourcesII 
=II 
targetII  &
asII' )2
&UniversalRenderPipelineEditorResourcesII* P
;IIP Q
	resourcesJJ 
.JJ 
	materialsJJ #
=JJ$ %
nullJJ& *
;JJ* +
	resourcesKK 
.KK 
shadersKK !
=KK" #
nullKK$ (
;KK( )
ResourceReloaderLL  
.LL  !
ReloadAllNullInLL! 0
(LL0 1
targetLL1 7
,LL7 8(
UniversalRenderPipelineAssetLL9 U
.LLU V
packagePathLLV a
)LLa b
;LLb c
}MM 
}NN 	
}OO 
}QQ ÿ´
öD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Renderer2D.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
internal 
class 

Renderer2D 
: 
ScriptableRenderer  2
{ 
ColorGradingLutPass		 !
m_ColorGradingLutPass		 1
;		1 2 
Render2DLightingPass

 "
m_Render2DLightingPass

 3
;

3 4
PostProcessPass 
m_PostProcessPass )
;) *
FinalBlitPass 
m_FinalBlitPass %
;% &
PostProcessPass "
m_FinalPostProcessPass .
;. /
Light2DCullResult 
m_LightCullResult +
;+ ,
private 
static 
readonly 
ProfilingSampler  0
m_ProfilingSampler1 C
=D E
newF I
ProfilingSamplerJ Z
(Z [
$str[ s
)s t
;t u
bool #
m_UseDepthStencilBuffer $
=% &
true' +
;+ ,
bool  
m_CreateColorTexture !
;! "
bool  
m_CreateDepthTexture !
;! "
readonly 
RenderTargetHandle # 
k_ColorTextureHandle$ 8
;8 9
readonly 
RenderTargetHandle # 
k_DepthTextureHandle$ 8
;8 9
readonly 
RenderTargetHandle #)
k_AfterPostProcessColorHandle$ A
;A B
readonly 
RenderTargetHandle ##
k_ColorGradingLutHandle$ ;
;; <
Material 
m_BlitMaterial 
;  
Renderer2DData 
m_Renderer2DData '
;' (
internal 
bool 
createColorTexture (
=>) + 
m_CreateColorTexture, @
;@ A
internal   
bool   
createDepthTexture   (
=>  ) + 
m_CreateDepthTexture  , @
;  @ A
public"" 

Renderer2D"" 
("" 
Renderer2DData"" (
data"") -
)""- .
:""/ 0
base""1 5
(""5 6
data""6 :
)"": ;
{## 	
m_BlitMaterial$$ 
=$$ 
	CoreUtils$$ &
.$$& ' 
CreateEngineMaterial$$' ;
($$; <
data$$< @
.$$@ A

blitShader$$A K
)$$K L
;$$L M!
m_ColorGradingLutPass&& !
=&&" #
new&&$ '
ColorGradingLutPass&&( ;
(&&; <
RenderPassEvent&&< K
.&&K L"
BeforeRenderingOpaques&&L b
,&&b c
data&&d h
.&&h i
postProcessData&&i x
)&&x y
;&&y z"
m_Render2DLightingPass'' "
=''# $
new''% ( 
Render2DLightingPass'') =
(''= >
data''> B
)''B C
;''C D
m_PostProcessPass(( 
=(( 
new((  #
PostProcessPass(($ 3
(((3 4
RenderPassEvent((4 C
.((C D)
BeforeRenderingPostProcessing((D a
,((a b
data((c g
.((g h
postProcessData((h w
,((w x
m_BlitMaterial	((y á
)
((á à
;
((à â"
m_FinalPostProcessPass)) "
=))# $
new))% (
PostProcessPass))) 8
())8 9
RenderPassEvent))9 H
.))H I(
AfterRenderingPostProcessing))I e
,))e f
data))g k
.))k l
postProcessData))l {
,)){ |
m_BlitMaterial	))} ã
)
))ã å
;
))å ç
m_FinalBlitPass** 
=** 
new** !
FinalBlitPass**" /
(**/ 0
RenderPassEvent**0 ?
.**? @
AfterRendering**@ N
+**O P
$num**Q R
,**R S
m_BlitMaterial**T b
)**b c
;**c d#
m_UseDepthStencilBuffer,, #
=,,$ %
data,,& *
.,,* +!
useDepthStencilBuffer,,+ @
;,,@ A 
k_ColorTextureHandle00  
.00  !
Init00! %
(00% &
$str00& ;
)00; <
;00< = 
k_DepthTextureHandle11  
.11  !
Init11! %
(11% &
$str11& >
)11> ?
;11? @)
k_AfterPostProcessColorHandle22 )
.22) *
Init22* .
(22. /
$str22/ I
)22I J
;22J K#
k_ColorGradingLutHandle33 #
.33# $
Init33$ (
(33( )
$str33) >
)33> ?
;33? @
m_Renderer2DData55 
=55 
data55 #
;55# $&
supportedRenderingFeatures77 &
=77' (
new77) ,
RenderingFeatures77- >
(77> ?
)77? @
{88 
cameraStacking99 
=99  
true99! %
,99% &
}:: 
;:: 
m_LightCullResult<< 
=<< 
new<<  #
Light2DCullResult<<$ 5
(<<5 6
)<<6 7
;<<7 8
m_Renderer2DData== 
.== 
lightCullResult== ,
===- .
m_LightCullResult==/ @
;==@ A
}>> 	
	protected@@ 
override@@ 
void@@ 
Dispose@@  '
(@@' (
bool@@( ,
	disposing@@- 6
)@@6 7
{AA 	
m_PostProcessPassCC 
.CC 
CleanupCC %
(CC% &
)CC& '
;CC' ("
m_FinalPostProcessPassDD "
.DD" #
CleanupDD# *
(DD* +
)DD+ ,
;DD, -!
m_ColorGradingLutPassEE !
.EE! "
CleanupEE" )
(EE) *
)EE* +
;EE+ ,
	CoreUtilsGG 
.GG 
DestroyGG 
(GG 
m_BlitMaterialGG ,
)GG, -
;GG- .
}HH 	
publicJJ 
Renderer2DDataJJ 
GetRenderer2DDataJJ /
(JJ/ 0
)JJ0 1
{KK 	
returnLL 
m_Renderer2DDataLL #
;LL# $
}MM 	
voidOO  
CreateRenderTexturesOO !
(OO! "
refPP 

CameraDataPP 

cameraDataPP %
,PP% &
boolQQ #
forceCreateColorTextureQQ (
,QQ( )

FilterModeRR "
colorTextureFilterModeRR -
,RR- .
CommandBufferSS 
cmdSS 
,SS 
outTT 
RenderTargetHandleTT "
colorTargetHandleTT# 4
,TT4 5
outUU 
RenderTargetHandleUU "
depthTargetHandleUU# 4
)UU4 5
{VV 	
refWW 
varWW "
cameraTargetDescriptorWW *
=WW+ ,
refWW- 0

cameraDataWW1 ;
.WW; <"
cameraTargetDescriptorWW< R
;WWR S
ifYY 
(YY 

cameraDataYY 
.YY 

renderTypeYY %
==YY& (
CameraRenderTypeYY) 9
.YY9 :
BaseYY: >
)YY> ?
{ZZ  
m_CreateColorTexture[[ $
=[[% &#
forceCreateColorTexture[[' >
||\\ 

cameraData\\ !
.\\! "
postProcessEnabled\\" 4
||]] 

cameraData]] !
.]]! "
isHdrEnabled]]" .
||^^ 

cameraData^^ !
.^^! "
isSceneViewCamera^^" 3
||__ 
!__ 

cameraData__ "
.__" #
isDefaultViewport__# 4
||`` 
!`` #
m_UseDepthStencilBuffer`` /
||aa 
!aa 

cameraDataaa "
.aa" #
resolveFinalTargetaa# 5
||bb 
!bb 
Mathfbb 
.bb 
Approximatelybb +
(bb+ ,

cameraDatabb, 6
.bb6 7
renderScalebb7 B
,bbB C
$numbbD H
)bbH I
;bbI J 
m_CreateDepthTexturedd $
=dd% &
!dd' (

cameraDatadd( 2
.dd2 3
resolveFinalTargetdd3 E
&&ddF H#
m_UseDepthStencilBufferddI `
;dd` a
colorTargetHandleff !
=ff" # 
m_CreateColorTextureff$ 8
?ff9 : 
k_ColorTextureHandleff; O
:ffP Q
RenderTargetHandleffR d
.ffd e
CameraTargetffe q
;ffq r
depthTargetHandlegg !
=gg" # 
m_CreateDepthTexturegg$ 8
?gg9 : 
k_DepthTextureHandlegg; O
:ggP Q
colorTargetHandleggR c
;ggc d
ifii 
(ii  
m_CreateColorTextureii (
)ii( )
{jj 
varkk 
colorDescriptorkk '
=kk( )"
cameraTargetDescriptorkk* @
;kk@ A
colorDescriptorll #
.ll# $
depthBufferBitsll$ 3
=ll4 5 
m_CreateDepthTexturell6 J
||llK M
!llN O#
m_UseDepthStencilBufferllO f
?llg h
$numlli j
:llk l
$numllm o
;llo p
cmdmm 
.mm 
GetTemporaryRTmm &
(mm& ' 
k_ColorTextureHandlemm' ;
.mm; <
idmm< >
,mm> ?
colorDescriptormm@ O
,mmO P"
colorTextureFilterModemmQ g
)mmg h
;mmh i
}nn 
ifpp 
(pp  
m_CreateDepthTexturepp (
)pp( )
{qq 
varrr 
depthDescriptorrr '
=rr( )"
cameraTargetDescriptorrr* @
;rr@ A
depthDescriptorss #
.ss# $
colorFormatss$ /
=ss0 1
RenderTextureFormatss2 E
.ssE F
DepthssF K
;ssK L
depthDescriptortt #
.tt# $
depthBufferBitstt$ 3
=tt4 5
$numtt6 8
;tt8 9
depthDescriptoruu #
.uu# $
bindMSuu$ *
=uu+ ,
depthDescriptoruu- <
.uu< =
msaaSamplesuu= H
>uuI J
$numuuK L
&&uuM O
!uuP Q

SystemInfouuQ [
.uu[ \*
supportsMultisampleAutoResolveuu\ z
&&uu{ }
(uu~ 

SystemInfo	uu â
.
uuâ ä*
supportsMultisampledTextures
uuä ¶
!=
uuß ©
$num
uu™ ´
)
uu´ ¨
;
uu¨ ≠
cmdvv 
.vv 
GetTemporaryRTvv &
(vv& ' 
k_DepthTextureHandlevv' ;
.vv; <
idvv< >
,vv> ?
depthDescriptorvv@ O
,vvO P

FilterModevvQ [
.vv[ \
Pointvv\ a
)vva b
;vvb c
}ww 
}xx 
elseyy 
{zz  
m_CreateColorTexture}} $
=}}% &
true}}' +
;}}+ , 
m_CreateDepthTexture~~ $
=~~% &
true~~' +
;~~+ ,
colorTargetHandle
ÄÄ !
=
ÄÄ" #"
k_ColorTextureHandle
ÄÄ$ 8
;
ÄÄ8 9
depthTargetHandle
ÅÅ !
=
ÅÅ" #"
k_DepthTextureHandle
ÅÅ$ 8
;
ÅÅ8 9
}
ÇÇ 
}
ÉÉ 	
public
ÖÖ 
override
ÖÖ 
void
ÖÖ 
Setup
ÖÖ "
(
ÖÖ" #%
ScriptableRenderContext
ÖÖ# :
context
ÖÖ; B
,
ÖÖB C
ref
ÖÖD G
RenderingData
ÖÖH U
renderingData
ÖÖV c
)
ÖÖc d
{
ÜÜ 	
ref
áá 

CameraData
áá 

cameraData
áá %
=
áá& '
ref
áá( +
renderingData
áá, 9
.
áá9 :

cameraData
áá: D
;
ááD E
ref
àà 
var
àà $
cameraTargetDescriptor
àà *
=
àà+ ,
ref
àà- 0

cameraData
àà1 ;
.
àà; <$
cameraTargetDescriptor
àà< R
;
ààR S
bool
ââ !
stackHasPostProcess
ââ $
=
ââ% &
renderingData
ââ' 4
.
ââ4 5#
postProcessingEnabled
ââ5 J
;
ââJ K
bool
ää 
lastCameraInStack
ää "
=
ää# $

cameraData
ää% /
.
ää/ 0 
resolveFinalTarget
ää0 B
;
ääB C
var
ãã $
colorTextureFilterMode
ãã &
=
ãã' (

FilterMode
ãã) 3
.
ãã3 4
Bilinear
ãã4 <
;
ãã< = 
PixelPerfectCamera
çç 
ppc
çç "
=
çç# $
null
çç% )
;
çç) *
bool
éé  
ppcUsesOffscreenRT
éé #
=
éé$ %
false
éé& +
;
éé+ ,
bool
èè 
ppcUpscaleRT
èè 
=
èè 
false
èè  %
;
èè% &
if
íí 
(
íí 

cameraData
íí 
.
íí 

renderType
íí %
==
íí& (
CameraRenderType
íí) 9
.
íí9 :
Base
íí: >
&&
íí? A
lastCameraInStack
ííB S
)
ííS T
{
ìì 

cameraData
îî 
.
îî 
camera
îî !
.
îî! "
TryGetComponent
îî" 1
(
îî1 2
out
îî2 5
ppc
îî6 9
)
îî9 :
;
îî: ;
if
ïï 
(
ïï 
ppc
ïï 
!=
ïï 
null
ïï 
)
ïï  
{
ññ 
if
óó 
(
óó 
ppc
óó 
.
óó 
offscreenRTSize
óó +
!=
óó, .

Vector2Int
óó/ 9
.
óó9 :
zero
óó: >
)
óó> ?
{
òò  
ppcUsesOffscreenRT
ôô *
=
ôô+ ,
true
ôô- 1
;
ôô1 2$
cameraTargetDescriptor
ùù .
.
ùù. /
width
ùù/ 4
=
ùù5 6
ppc
ùù7 :
.
ùù: ;
offscreenRTSize
ùù; J
.
ùùJ K
x
ùùK L
;
ùùL M$
cameraTargetDescriptor
ûû .
.
ûû. /
height
ûû/ 5
=
ûû6 7
ppc
ûû8 ;
.
ûû; <
offscreenRTSize
ûû< K
.
ûûK L
y
ûûL M
;
ûûM N
}
üü $
colorTextureFilterMode
°° *
=
°°+ ,
ppc
°°- 0
.
°°0 1!
finalBlitFilterMode
°°1 D
;
°°D E
ppcUpscaleRT
¢¢  
=
¢¢! "
ppc
¢¢# &
.
¢¢& '
	upscaleRT
¢¢' 0
&&
¢¢1 3
ppc
¢¢4 7
.
¢¢7 8
	isRunning
¢¢8 A
;
¢¢A B
}
££ 
}
§§  
RenderTargetHandle
¶¶ 
colorTargetHandle
¶¶ 0
;
¶¶0 1 
RenderTargetHandle
ßß 
depthTargetHandle
ßß 0
;
ßß0 1
CommandBuffer
©© 
cmd
©© 
=
©© 
CommandBufferPool
©©  1
.
©©1 2
Get
©©2 5
(
©©5 6
)
©©6 7
;
©©7 8
using
™™ 
(
™™ 
new
™™ 
ProfilingScope
™™ %
(
™™% &
cmd
™™& )
,
™™) * 
m_ProfilingSampler
™™+ =
)
™™= >
)
™™> ?
{
´´ "
CreateRenderTextures
¨¨ $
(
¨¨$ %
ref
¨¨% (

cameraData
¨¨) 3
,
¨¨3 4 
ppcUsesOffscreenRT
¨¨5 G
,
¨¨G H$
colorTextureFilterMode
¨¨I _
,
¨¨_ `
cmd
¨¨a d
,
¨¨d e
out
≠≠ 
colorTargetHandle
≠≠ )
,
≠≠) *
out
≠≠+ .
depthTargetHandle
≠≠/ @
)
≠≠@ A
;
≠≠A B
}
ÆÆ 
context
ØØ 
.
ØØ "
ExecuteCommandBuffer
ØØ (
(
ØØ( )
cmd
ØØ) ,
)
ØØ, -
;
ØØ- .
CommandBufferPool
∞∞ 
.
∞∞ 
Release
∞∞ %
(
∞∞% &
cmd
∞∞& )
)
∞∞) *
;
∞∞* +#
ConfigureCameraTarget
≤≤ !
(
≤≤! "
colorTargetHandle
≤≤" 3
.
≤≤3 4

Identifier
≤≤4 >
(
≤≤> ?
)
≤≤? @
,
≤≤@ A
depthTargetHandle
≤≤B S
.
≤≤S T

Identifier
≤≤T ^
(
≤≤^ _
)
≤≤_ `
)
≤≤` a
;
≤≤a b
if
µµ 
(
µµ !
stackHasPostProcess
µµ #
&&
µµ$ &

cameraData
µµ' 1
.
µµ1 2

renderType
µµ2 <
==
µµ= ?
CameraRenderType
µµ@ P
.
µµP Q
Base
µµQ U
)
µµU V
{
∂∂ #
m_ColorGradingLutPass
∑∑ %
.
∑∑% &
Setup
∑∑& +
(
∑∑+ ,%
k_ColorGradingLutHandle
∑∑, C
)
∑∑C D
;
∑∑D E
EnqueuePass
∏∏ 
(
∏∏ #
m_ColorGradingLutPass
∏∏ 1
)
∏∏1 2
;
∏∏2 3
}
ππ $
m_Render2DLightingPass
ªª "
.
ªª" #
ConfigureTarget
ªª# 2
(
ªª2 3
colorTargetHandle
ªª3 D
.
ªªD E

Identifier
ªªE O
(
ªªO P
)
ªªP Q
,
ªªQ R
depthTargetHandle
ªªS d
.
ªªd e

Identifier
ªªe o
(
ªªo p
)
ªªp q
)
ªªq r
;
ªªr s
EnqueuePass
ºº 
(
ºº $
m_Render2DLightingPass
ºº .
)
ºº. /
;
ºº/ 0
bool
¡¡ )
requireFinalPostProcessPass
¡¡ ,
=
¡¡- .
lastCameraInStack
¬¬ !
&&
¬¬" $
!
¬¬% &
ppcUpscaleRT
¬¬& 2
&&
¬¬3 5!
stackHasPostProcess
¬¬6 I
&&
¬¬J L

cameraData
¬¬M W
.
¬¬W X
antialiasing
¬¬X d
==
¬¬e g
AntialiasingMode
¬¬h x
.
¬¬x y*
FastApproximateAntialiasing¬¬y î
;¬¬î ï
if
ƒƒ 
(
ƒƒ 

cameraData
ƒƒ 
.
ƒƒ  
postProcessEnabled
ƒƒ -
)
ƒƒ- .
{
≈≈  
RenderTargetHandle
∆∆ "#
postProcessDestHandle
∆∆# 8
=
∆∆9 :
lastCameraInStack
«« %
&&
««& (
!
««) *
ppcUpscaleRT
««* 6
&&
««7 9
!
««: ;)
requireFinalPostProcessPass
««; V
?
««W X 
RenderTargetHandle
««Y k
.
««k l
CameraTarget
««l x
:
««y z,
k_AfterPostProcessColorHandle««{ ò
;««ò ô
m_PostProcessPass
…… !
.
……! "
Setup
……" '
(
……' ($
cameraTargetDescriptor
   *
,
  * +
colorTargetHandle
ÀÀ %
,
ÀÀ% &#
postProcessDestHandle
ÃÃ )
,
ÃÃ) *
depthTargetHandle
ÕÕ %
,
ÕÕ% &%
k_ColorGradingLutHandle
ŒŒ +
,
ŒŒ+ ,)
requireFinalPostProcessPass
œœ /
,
œœ/ 0#
postProcessDestHandle
–– )
==
––* , 
RenderTargetHandle
––- ?
.
––? @
CameraTarget
––@ L
)
––L M
;
––M N
EnqueuePass
““ 
(
““ 
m_PostProcessPass
““ -
)
““- .
;
““. /
colorTargetHandle
”” !
=
””" ##
postProcessDestHandle
””$ 9
;
””9 :
}
‘‘ 
if
÷÷ 
(
÷÷ )
requireFinalPostProcessPass
÷÷ +
)
÷÷+ ,
{
◊◊ $
m_FinalPostProcessPass
ÿÿ &
.
ÿÿ& '
SetupFinalPass
ÿÿ' 5
(
ÿÿ5 6
colorTargetHandle
ÿÿ6 G
)
ÿÿG H
;
ÿÿH I
EnqueuePass
ŸŸ 
(
ŸŸ $
m_FinalPostProcessPass
ŸŸ 2
)
ŸŸ2 3
;
ŸŸ3 4
}
⁄⁄ 
else
€€ 
if
€€ 
(
€€ 
lastCameraInStack
€€ &
&&
€€' )
colorTargetHandle
€€* ;
!=
€€< > 
RenderTargetHandle
€€? Q
.
€€Q R
CameraTarget
€€R ^
)
€€^ _
{
‹‹ 
m_FinalBlitPass
›› 
.
››  
Setup
››  %
(
››% &$
cameraTargetDescriptor
››& <
,
››< =
colorTargetHandle
››> O
)
››O P
;
››P Q
EnqueuePass
ﬁﬁ 
(
ﬁﬁ 
m_FinalBlitPass
ﬁﬁ +
)
ﬁﬁ+ ,
;
ﬁﬁ, -
}
ﬂﬂ 
}
‡‡ 	
public
‚‚ 
override
‚‚ 
void
‚‚ $
SetupCullingParameters
‚‚ 3
(
‚‚3 4
ref
‚‚4 7)
ScriptableCullingParameters
‚‚8 S
cullingParameters
‚‚T e
,
‚‚e f
ref
‚‚g j

CameraData
‚‚k u

cameraData‚‚v Ä
)‚‚Ä Å
{
„„ 	
cullingParameters
‰‰ 
.
‰‰ 
cullingOptions
‰‰ ,
=
‰‰- .
CullingOptions
‰‰/ =
.
‰‰= >
None
‰‰> B
;
‰‰B C
cullingParameters
ÂÂ 
.
ÂÂ 
isOrthographic
ÂÂ ,
=
ÂÂ- .

cameraData
ÂÂ/ 9
.
ÂÂ9 :
camera
ÂÂ: @
.
ÂÂ@ A
orthographic
ÂÂA M
;
ÂÂM N
cullingParameters
ÊÊ 
.
ÊÊ 
shadowDistance
ÊÊ ,
=
ÊÊ- .
$num
ÊÊ/ 3
;
ÊÊ3 4
m_LightCullResult
ÁÁ 
.
ÁÁ 
SetupCulling
ÁÁ *
(
ÁÁ* +
ref
ÁÁ+ .
cullingParameters
ÁÁ/ @
,
ÁÁ@ A

cameraData
ÁÁB L
.
ÁÁL M
camera
ÁÁM S
)
ÁÁS T
;
ÁÁT U
}
ËË 	
public
ÍÍ 
override
ÍÍ 
void
ÍÍ 
FinishRendering
ÍÍ ,
(
ÍÍ, -
CommandBuffer
ÍÍ- :
cmd
ÍÍ; >
)
ÍÍ> ?
{
ÎÎ 	
if
ÏÏ 
(
ÏÏ "
m_CreateColorTexture
ÏÏ $
)
ÏÏ$ %
cmd
ÌÌ 
.
ÌÌ  
ReleaseTemporaryRT
ÌÌ &
(
ÌÌ& '"
k_ColorTextureHandle
ÌÌ' ;
.
ÌÌ; <
id
ÌÌ< >
)
ÌÌ> ?
;
ÌÌ? @
if
ÔÔ 
(
ÔÔ "
m_CreateDepthTexture
ÔÔ $
)
ÔÔ$ %
cmd
 
.
  
ReleaseTemporaryRT
 &
(
& '"
k_DepthTextureHandle
' ;
.
; <
id
< >
)
> ?
;
? @
}
ÒÒ 	
}
ÚÚ 
}ÛÛ ›Œ
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\XR\XRSystem.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
internal 
partial 
class 
XRSystem #
{ 
internal 
readonly 
XRPass  
	emptyPass! *
=+ ,
new- 0
XRPass1 7
(7 8
)8 9
;9 :
List 
< 
XRPass 
> 
framePasses  
=! "
new# &
List' +
<+ ,
XRPass, 2
>2 3
(3 4
)4 5
;5 6
static 
List 
< 
XRDisplaySubsystem &
>& '
displayList( 3
=4 5
new6 9
List: >
<> ?
XRDisplaySubsystem? Q
>Q R
(R S
)S T
;T U
XRDisplaySubsystem 
display( /
=0 1
null2 6
;6 7
static 
int 
	msaaLevel( 1
=2 3
$num4 5
;5 6
Material !
occlusionMeshMaterial( =
=> ?
null@ D
;D E
Material 
mirrorViewMaterial( :
=; <
null= A
;A B!
MaterialPropertyBlock &
mirrorViewMaterialProperty( B
=C D
newE H!
MaterialPropertyBlockI ^
(^ _
)_ `
;` a
RenderTexture   
testRenderTexture   '
=  ( )
null  * .
;  . /
const"" 
string"" 
k_XRMirrorTag"" "
=""# $
$str""% 5
;""5 6
static## 
ProfilingSampler## %
_XRMirrorProfilingSampler##  9
=##: ;
new##< ?
ProfilingSampler##@ P
(##P Q
k_XRMirrorTag##Q ^
)##^ _
;##_ `
internal%% 
XRSystem%% 
(%% 
)%% 
{&& 	
RefreshXrSdk'' 
('' 
)'' 
;'' 
	TextureXR)) 
.)) 
maxViews)) 
=))  
Math))! %
.))% &
Max))& )
())) *
	TextureXR))* 3
.))3 4
slices))4 :
,)): ;
GetMaxViews))< G
())G H
)))H I
)))I J
;))J K
}** 	
internal,, 
void,, "
InitializeXRSystemData,, ,
(,,, -
XRSystemData,,- 9
data,,: >
),,> ?
{-- 	
if.. 
(.. 
data.. 
).. 
{// 
if00 
(00 !
occlusionMeshMaterial00 )
!=00* ,
null00- 1
)001 2
	CoreUtils11 
.11 
Destroy11 %
(11% &!
occlusionMeshMaterial11& ;
)11; <
;11< =
if33 
(33 
mirrorViewMaterial33 &
!=33' )
null33* .
)33. /
	CoreUtils44 
.44 
Destroy44 %
(44% &
mirrorViewMaterial44& 8
)448 9
;449 :!
occlusionMeshMaterial66 %
=66& '
	CoreUtils66( 1
.661 2 
CreateEngineMaterial662 F
(66F G
data66G K
.66K L
shaders66L S
.66S T
xrOcclusionMeshPS66T e
)66e f
;66f g
mirrorViewMaterial77 "
=77# $
	CoreUtils77% .
.77. / 
CreateEngineMaterial77/ C
(77C D
data77D H
.77H I
shaders77I P
.77P Q
xrMirrorViewPS77Q _
)77_ `
;77` a
}88 
}99 	
static;; 
void;; 
GetDisplaySubsystem;; '
(;;' (
);;( )
{<< 	
SubsystemManager?? 
.?? 
GetInstances?? )
(??) *
displayList??* 5
)??5 6
;??6 7
}CC 	
[FF 	)
RuntimeInitializeOnLoadMethodFF	 &
(FF& '%
RuntimeInitializeLoadTypeFF' @
.FF@ A
BeforeSplashScreenFFA S
)FFS T
]FFT U
internalGG 
staticGG 
voidGG 
XRSystemInitGG )
(GG) *
)GG* +
{HH 	
ifII 
(II 
GraphicsSettingsII  
.II  !!
currentRenderPipelineII! 6
==II7 9
nullII: >
)II> ?
returnJJ 
;JJ 
GetDisplaySubsystemLL 
(LL  
)LL  !
;LL! "
forOO 
(OO 
intOO 
iOO 
=OO 
$numOO 
;OO 
iOO 
<OO 
displayListOO  +
.OO+ ,
CountOO, 1
;OO1 2
iOO3 4
++OO4 6
)OO6 7
{PP 
displayListQQ 
[QQ 
iQQ 
]QQ 
.QQ !
disableLegacyRendererQQ 4
=QQ5 6
trueQQ7 ;
;QQ; <
displayListRR 
[RR 
iRR 
]RR 
.RR 
textureLayoutRR ,
=RR- .
XRDisplaySubsystemRR/ A
.RRA B
TextureLayoutRRB O
.RRO P
Texture2DArrayRRP ^
;RR^ _
displayListSS 
[SS 
iSS 
]SS 
.SS 
sRGBSS #
=SS$ %
QualitySettingsSS& 5
.SS5 6
activeColorSpaceSS6 F
==SSG I

ColorSpaceSSJ T
.SST U
LinearSSU [
;SS[ \
}TT 
}UU 	
internalWW 
staticWW 
voidWW 
UpdateMSAALevelWW ,
(WW, -
intWW- 0
levelWW1 6
)WW6 7
{XX 	
ifYY 
(YY 
	msaaLevelYY 
==YY 
levelYY "
)YY" #
returnZZ 
;ZZ 
level\\ 
=\\ 
Mathf\\ 
.\\ 
NextPowerOfTwo\\ (
(\\( )
level\\) .
)\\. /
;\\/ 0
level]] 
=]] 
Mathf]] 
.]] 
Clamp]] 
(]]  
level]]  %
,]]% &
(]]' (
int]]( +
)]]+ ,
MsaaQuality]], 7
.]]7 8
Disabled]]8 @
,]]@ A
(]]B C
int]]C F
)]]F G
MsaaQuality]]G R
.]]R S
_8x]]S V
)]]V W
;]]W X
GetDisplaySubsystem__ 
(__  
)__  !
;__! "
forbb 
(bb 
intbb 
ibb 
=bb 
$numbb 
;bb 
ibb 
<bb 
displayListbb  +
.bb+ ,
Countbb, 1
;bb1 2
ibb3 4
++bb4 6
)bb6 7
displayListcc 
[cc 
icc 
]cc 
.cc 
SetMSAALevelcc +
(cc+ ,
levelcc, 1
)cc1 2
;cc2 3
	msaaLevelee 
=ee 
levelee 
;ee 
}ff 	
internalhh 
statichh 
inthh 
GetMSAALevelhh (
(hh( )
)hh) *
{ii 	
returnjj 
	msaaLeveljj 
;jj 
}kk 	
internalmm 
staticmm 
voidmm 
UpdateRenderScalemm .
(mm. /
floatmm/ 4
renderScalemm5 @
)mm@ A
{nn 	
GetDisplaySubsystemoo 
(oo  
)oo  !
;oo! "
forqq 
(qq 
intqq 
iqq 
=qq 
$numqq 
;qq 
iqq 
<qq 
displayListqq  +
.qq+ ,
Countqq, 1
;qq1 2
iqq3 4
++qq4 6
)qq6 7
displayListrr 
[rr 
irr 
]rr 
.rr #
scaleOfAllRenderTargetsrr 6
=rr7 8
renderScalerr9 D
;rrD E
}ss 	
internalvv 
intvv 
GetMaxViewsvv  
(vv  !
)vv! "
{ww 	
intxx 
maxViewsxx 
=xx 
$numxx 
;xx 
ifzz 
(zz 
displayzz 
!=zz 
nullzz 
)zz  
{{{ 
maxViews}} 
=}} 
$num}} 
;}} 
}~~ 
else
ÄÄ 
if
ÄÄ 
(
ÄÄ &
XRGraphicsAutomatedTests
ÄÄ -
.
ÄÄ- .
enabled
ÄÄ. 5
)
ÄÄ5 6
{
ÅÅ 
maxViews
ÇÇ 
=
ÇÇ 
Math
ÇÇ 
.
ÇÇ  
Max
ÇÇ  #
(
ÇÇ# $
maxViews
ÇÇ$ ,
,
ÇÇ, -
$num
ÇÇ. /
)
ÇÇ/ 0
;
ÇÇ0 1
}
ÉÉ 
return
ÜÜ 
maxViews
ÜÜ 
;
ÜÜ 
}
áá 	
internal
ââ 
List
ââ 
<
ââ 
XRPass
ââ 
>
ââ 

SetupFrame
ââ (
(
ââ( )

CameraData
ââ) 3

cameraData
ââ4 >
)
ââ> ?
{
ää 	
Camera
ãã 
camera
ãã 
=
ãã 

cameraData
ãã &
.
ãã& '
camera
ãã' -
;
ãã- .
bool
åå 
	xrEnabled
åå 
=
åå 
RefreshXrSdk
åå )
(
åå) *
)
åå* +
;
åå+ ,
if
éé 
(
éé 
display
éé 
!=
éé 
null
éé 
)
éé  
{
èè 
display
ëë 
.
ëë 
textureLayout
ëë %
=
ëë& ' 
XRDisplaySubsystem
ëë( :
.
ëë: ;
TextureLayout
ëë; H
.
ëëH I
Texture2DArray
ëëI W
;
ëëW X
display
íí 
.
íí 
zNear
íí 
=
íí 
camera
íí  &
.
íí& '
nearClipPlane
íí' 4
;
íí4 5
display
ìì 
.
ìì 
zFar
ìì 
=
ìì 
camera
ìì  &
.
ìì& '
farClipPlane
ìì' 3
;
ìì3 4
display
îî 
.
îî 
sRGB
îî 
=
îî 
QualitySettings
îî  /
.
îî/ 0
activeColorSpace
îî0 @
==
îîA C

ColorSpace
îîD N
.
îîN O
Linear
îîO U
;
îîU V
}
ïï 
if
óó 
(
óó 
framePasses
óó 
.
óó 
Count
óó !
>
óó" #
$num
óó$ %
)
óó% &
{
òò 
Debug
ôô 
.
ôô 

LogWarning
ôô  
(
ôô  !
$str
ôô! J
)
ôôJ K
;
ôôK L
ReleaseFrame
öö 
(
öö 
)
öö 
;
öö 
}
õõ 
if
ùù 
(
ùù 
camera
ùù 
==
ùù 
null
ùù 
)
ùù 
return
ûû 
framePasses
ûû "
;
ûû" #
bool
°° 
isGameCamera
°° 
=
°° 
(
°°  !
camera
°°! '
.
°°' (

cameraType
°°( 2
==
°°3 5

CameraType
°°6 @
.
°°@ A
Game
°°A E
||
°°F H
camera
°°I O
.
°°O P

cameraType
°°P Z
==
°°[ ]

CameraType
°°^ h
.
°°h i
VR
°°i k
)
°°k l
;
°°l m
bool
¢¢ 
xrSupported
¢¢ 
=
¢¢ 
isGameCamera
¢¢ +
&&
¢¢, .
camera
¢¢/ 5
.
¢¢5 6
targetTexture
¢¢6 C
==
¢¢D F
null
¢¢G K
&&
¢¢L N

cameraData
¢¢O Y
.
¢¢Y Z
xrRendering
¢¢Z e
;
¢¢e f
if
•• 
(
•• &
XRGraphicsAutomatedTests
•• (
.
••( )
enabled
••) 0
&&
••1 3&
XRGraphicsAutomatedTests
••4 L
.
••L M
running
••M T
&&
••U W
isGameCamera
••X d
&&
••e g'
LayoutSinglePassTestMode••h Ä
(••Ä Å

cameraData••Å ã
,••ã å
new••ç ê
XRLayout••ë ô
(••ô ö
)••ö õ
{••ú ù
camera••û §
=••• ¶
camera••ß ≠
,••≠ Æ
xrSystem••Ø ∑
=••∏ π
this••∫ æ
}••ø ¿
)••¿ ¡
)••¡ ¬
{
¶¶ 
}
®® 
else
©© 
if
´´ 
(
´´ 
	xrEnabled
´´ 
&&
´´ 
xrSupported
´´ (
)
´´( )
{
¨¨ 
if
ØØ 
(
ØØ 
Application
ØØ 
.
ØØ  
platform
ØØ  (
==
ØØ) +
RuntimePlatform
ØØ, ;
.
ØØ; <
Android
ØØ< C
)
ØØC D
QualitySettings
∞∞ #
.
∞∞# $

vSyncCount
∞∞$ .
=
∞∞/ 0
$num
∞∞1 2
;
∞∞2 3
else
±± 
QualitySettings
≤≤ #
.
≤≤# $

vSyncCount
≤≤$ .
=
≤≤/ 0
$num
≤≤1 2
;
≤≤2 3#
CreateLayoutFromXrSdk
¥¥ %
(
¥¥% &
camera
¥¥& ,
,
¥¥, -
singlePassAllowed
¥¥. ?
:
¥¥? @
true
¥¥A E
)
¥¥E F
;
¥¥F G
}
µµ 
else
∂∂ 
{
∑∑ 
AddPassToFrame
∏∏ 
(
∏∏ 
	emptyPass
∏∏ (
)
∏∏( )
;
∏∏) *
}
ππ 
return
ªª 
framePasses
ªª 
;
ªª 
}
ºº 	
internal
ææ 
void
ææ 
ReleaseFrame
ææ "
(
ææ" #
)
ææ# $
{
øø 	
foreach
¿¿ 
(
¿¿ 
XRPass
¿¿ 
xrPass
¿¿ "
in
¿¿# %
framePasses
¿¿& 1
)
¿¿1 2
{
¡¡ 
if
¬¬ 
(
¬¬ 
xrPass
¬¬ 
!=
¬¬ 
	emptyPass
¬¬ '
)
¬¬' (
XRPass
√√ 
.
√√ 
Release
√√ "
(
√√" #
xrPass
√√# )
)
√√) *
;
√√* +
}
ƒƒ 
framePasses
∆∆ 
.
∆∆ 
Clear
∆∆ 
(
∆∆ 
)
∆∆ 
;
∆∆  
if
»» 
(
»» 
testRenderTexture
»» !
)
»»! "
RenderTexture
…… 
.
…… 
ReleaseTemporary
…… .
(
……. /
testRenderTexture
……/ @
)
……@ A
;
……A B
}
   	
internal
ÃÃ 
bool
ÃÃ 
RefreshXrSdk
ÃÃ "
(
ÃÃ" #
)
ÃÃ# $
{
ÕÕ 	!
GetDisplaySubsystem
ŒŒ 
(
ŒŒ  
)
ŒŒ  !
;
ŒŒ! "
if
–– 
(
–– 
displayList
–– 
.
–– 
Count
–– !
>
––" #
$num
––$ %
)
––% &
{
—— 
if
““ 
(
““ 
displayList
““ 
.
““  
Count
““  %
>
““& '
$num
““( )
)
““) *
throw
”” 
new
”” %
NotImplementedException
”” 5
(
””5 6
$str
””6 W
)
””W X
;
””X Y
display
’’ 
=
’’ 
displayList
’’ %
[
’’% &
$num
’’& '
]
’’' (
;
’’( )
display
÷÷ 
.
÷÷ #
disableLegacyRenderer
÷÷ -
=
÷÷. /
true
÷÷0 4
;
÷÷4 5
	TextureXR
ŸŸ 
.
ŸŸ 
maxViews
ŸŸ "
=
ŸŸ# $
Math
ŸŸ% )
.
ŸŸ) *
Max
ŸŸ* -
(
ŸŸ- .
	TextureXR
ŸŸ. 7
.
ŸŸ7 8
slices
ŸŸ8 >
,
ŸŸ> ?
GetMaxViews
ŸŸ@ K
(
ŸŸK L
)
ŸŸL M
)
ŸŸM N
;
ŸŸN O
return
€€ 
display
€€ 
.
€€ 
running
€€ &
;
€€& '
}
‹‹ 
else
›› 
{
ﬁﬁ 
display
ﬂﬂ 
=
ﬂﬂ 
null
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 
return
‚‚ 
false
‚‚ 
;
‚‚ 
}
„„ 	
internal
ÊÊ 
void
ÊÊ 
UpdateCameraData
ÊÊ &
(
ÊÊ& '
ref
ÊÊ' *

CameraData
ÊÊ+ 5
baseCameraData
ÊÊ6 D
,
ÊÊD E
in
ÊÊF H
XRPass
ÊÊI O
xr
ÊÊP R
)
ÊÊR S
{
ÁÁ 	
Rect
ÈÈ 

cameraRect
ÈÈ 
=
ÈÈ 
baseCameraData
ÈÈ ,
.
ÈÈ, -
camera
ÈÈ- 3
.
ÈÈ3 4
rect
ÈÈ4 8
;
ÈÈ8 9
Rect
ÍÍ 

xrViewport
ÍÍ 
=
ÍÍ 
xr
ÍÍ  
.
ÍÍ  !
GetViewport
ÍÍ! ,
(
ÍÍ, -
)
ÍÍ- .
;
ÍÍ. /
baseCameraData
ÎÎ 
.
ÎÎ 
	pixelRect
ÎÎ $
=
ÎÎ% &
new
ÎÎ' *
Rect
ÎÎ+ /
(
ÎÎ/ 0

cameraRect
ÎÎ0 :
.
ÎÎ: ;
x
ÎÎ; <
*
ÎÎ= >

xrViewport
ÎÎ? I
.
ÎÎI J
width
ÎÎJ O
+
ÎÎP Q

xrViewport
ÎÎR \
.
ÎÎ\ ]
x
ÎÎ] ^
,
ÎÎ^ _

cameraRect
ÏÏ0 :
.
ÏÏ: ;
y
ÏÏ; <
*
ÏÏ= >

xrViewport
ÏÏ? I
.
ÏÏI J
height
ÏÏJ P
+
ÏÏQ R

xrViewport
ÏÏS ]
.
ÏÏ] ^
y
ÏÏ^ _
,
ÏÏ_ `

cameraRect
ÌÌ0 :
.
ÌÌ: ;
width
ÌÌ; @
*
ÌÌA B

xrViewport
ÌÌC M
.
ÌÌM N
width
ÌÌN S
,
ÌÌS T

cameraRect
ÓÓ0 :
.
ÓÓ: ;
height
ÓÓ; A
*
ÓÓB C

xrViewport
ÓÓD N
.
ÓÓN O
height
ÓÓO U
)
ÓÓU V
;
ÓÓV W
Rect
ÔÔ 
camPixelRect
ÔÔ 
=
ÔÔ 
baseCameraData
ÔÔ  .
.
ÔÔ. /
	pixelRect
ÔÔ/ 8
;
ÔÔ8 9
baseCameraData
 
.
 

pixelWidth
 %
=
' (
(
) *
int
* -
)
- .
System
. 4
.
4 5
Math
5 9
.
9 :
Round
: ?
(
? @
camPixelRect
@ L
.
L M
width
M R
+
S T
camPixelRect
U a
.
a b
x
b c
)
c d
-
e f
(
g h
int
h k
)
k l
System
l r
.
r s
Math
s w
.
w x
Round
x }
(
} ~
camPixelRect~ ä
.ä ã
xã å
)å ç
;ç é
baseCameraData
ÒÒ 
.
ÒÒ 
pixelHeight
ÒÒ &
=
ÒÒ' (
(
ÒÒ) *
int
ÒÒ* -
)
ÒÒ- .
System
ÒÒ. 4
.
ÒÒ4 5
Math
ÒÒ5 9
.
ÒÒ9 :
Round
ÒÒ: ?
(
ÒÒ? @
camPixelRect
ÒÒ@ L
.
ÒÒL M
height
ÒÒM S
+
ÒÒT U
camPixelRect
ÒÒV b
.
ÒÒb c
y
ÒÒc d
)
ÒÒd e
-
ÒÒf g
(
ÒÒh i
int
ÒÒi l
)
ÒÒl m
System
ÒÒm s
.
ÒÒs t
Math
ÒÒt x
.
ÒÒx y
Round
ÒÒy ~
(
ÒÒ~ 
camPixelRectÒÒ ã
.ÒÒã å
yÒÒå ç
)ÒÒç é
;ÒÒé è
baseCameraData
ÚÚ 
.
ÚÚ 
aspectRatio
ÚÚ &
=
ÚÚ' (
(
ÚÚ) *
float
ÚÚ* /
)
ÚÚ/ 0
baseCameraData
ÚÚ0 >
.
ÚÚ> ?

pixelWidth
ÚÚ? I
/
ÚÚJ K
(
ÚÚL M
float
ÚÚM R
)
ÚÚR S
baseCameraData
ÚÚS a
.
ÚÚa b
pixelHeight
ÚÚb m
;
ÚÚm n
bool
ÙÙ !
isDefaultXRViewport
ÙÙ $
=
ÙÙ% &
(
ÙÙ' (
!
ÙÙ( )
(
ÙÙ) *
Math
ÙÙ* .
.
ÙÙ. /
Abs
ÙÙ/ 2
(
ÙÙ2 3

xrViewport
ÙÙ3 =
.
ÙÙ= >
x
ÙÙ> ?
)
ÙÙ? @
>
ÙÙA B
$num
ÙÙC G
||
ÙÙH J
Math
ÙÙK O
.
ÙÙO P
Abs
ÙÙP S
(
ÙÙS T

xrViewport
ÙÙT ^
.
ÙÙ^ _
y
ÙÙ_ `
)
ÙÙ` a
>
ÙÙb c
$num
ÙÙd h
||
ÙÙi k
Math
ıı, 0
.
ıı0 1
Abs
ıı1 4
(
ıı4 5

xrViewport
ıı5 ?
.
ıı? @
width
ıı@ E
)
ııE F
<
ııG H
xr
ııI K
.
ııK L
renderTargetDesc
ııL \
.
ıı\ ]
width
ıı] b
||
ııc e
Math
ˆˆ, 0
.
ˆˆ0 1
Abs
ˆˆ1 4
(
ˆˆ4 5

xrViewport
ˆˆ5 ?
.
ˆˆ? @
height
ˆˆ@ F
)
ˆˆF G
<
ˆˆH I
xr
ˆˆJ L
.
ˆˆL M
renderTargetDesc
ˆˆM ]
.
ˆˆ] ^
height
ˆˆ^ d
)
ˆˆd e
)
ˆˆe f
;
ˆˆf g
baseCameraData
˜˜ 
.
˜˜ 
isDefaultViewport
˜˜ ,
=
˜˜- .
baseCameraData
˜˜/ =
.
˜˜= >
isDefaultViewport
˜˜> O
&&
˜˜P R!
isDefaultXRViewport
˜˜S f
;
˜˜f g
var
˙˙  
originalTargetDesc
˙˙ "
=
˙˙# $
baseCameraData
˙˙% 3
.
˙˙3 4$
cameraTargetDescriptor
˙˙4 J
;
˙˙J K
baseCameraData
˚˚ 
.
˚˚ $
cameraTargetDescriptor
˚˚ 1
=
˚˚2 3
xr
˚˚4 6
.
˚˚6 7
renderTargetDesc
˚˚7 G
;
˚˚G H
if
¸¸ 
(
¸¸ 
baseCameraData
¸¸ 
.
¸¸ 
isHdrEnabled
¸¸ +
)
¸¸+ ,
{
˝˝ 
baseCameraData
˛˛ 
.
˛˛ $
cameraTargetDescriptor
˛˛ 5
.
˛˛5 6
graphicsFormat
˛˛6 D
=
˛˛E F 
originalTargetDesc
˛˛G Y
.
˛˛Y Z
graphicsFormat
˛˛Z h
;
˛˛h i
}
ˇˇ 
baseCameraData
ÄÄ 
.
ÄÄ $
cameraTargetDescriptor
ÄÄ 1
.
ÄÄ1 2
msaaSamples
ÄÄ2 =
=
ÄÄ> ? 
originalTargetDesc
ÄÄ@ R
.
ÄÄR S
msaaSamples
ÄÄS ^
;
ÄÄ^ _
baseCameraData
ÅÅ 
.
ÅÅ $
cameraTargetDescriptor
ÅÅ 1
.
ÅÅ1 2
width
ÅÅ2 7
=
ÅÅ8 9
baseCameraData
ÅÅ: H
.
ÅÅH I

pixelWidth
ÅÅI S
;
ÅÅS T
baseCameraData
ÇÇ 
.
ÇÇ $
cameraTargetDescriptor
ÇÇ 1
.
ÇÇ1 2
height
ÇÇ2 8
=
ÇÇ9 :
baseCameraData
ÇÇ; I
.
ÇÇI J
pixelHeight
ÇÇJ U
;
ÇÇU V
}
ÉÉ 	
internal
ÜÜ 
void
ÜÜ 
UpdateFromCamera
ÜÜ &
(
ÜÜ& '
ref
ÜÜ' *
XRPass
ÜÜ+ 1
xrPass
ÜÜ2 8
,
ÜÜ8 9

CameraData
ÜÜ: D

cameraData
ÜÜE O
)
ÜÜO P
{
áá 	
bool
àà 
isGameCamera
àà 
=
àà 
(
àà  !

cameraData
àà! +
.
àà+ ,
camera
àà, 2
.
àà2 3

cameraType
àà3 =
==
àà> @

CameraType
ààA K
.
ààK L
Game
ààL P
||
ààQ S

cameraData
ààT ^
.
àà^ _
camera
àà_ e
.
ààe f

cameraType
ààf p
==
ààq s

CameraType
ààt ~
.
àà~ 
VRàà Å
)ààÅ Ç
;ààÇ É
if
ââ 
(
ââ &
XRGraphicsAutomatedTests
ââ (
.
ââ( )
enabled
ââ) 0
&&
ââ1 3&
XRGraphicsAutomatedTests
ââ4 L
.
ââL M
running
ââM T
&&
ââU W
isGameCamera
ââX d
)
ââd e
{
ää 
	Matrix4x4
åå 

projMatrix
åå $
=
åå% &

cameraData
åå' 1
.
åå1 2
camera
åå2 8
.
åå8 9
projectionMatrix
åå9 I
;
ååI J
	Matrix4x4
çç 

viewMatrix
çç $
=
çç% &

cameraData
çç' 1
.
çç1 2
camera
çç2 8
.
çç8 9!
worldToCameraMatrix
çç9 L
;
ççL M
Rect
éé 
viewport
éé "
=
éé# $
new
éé% (
Rect
éé) -
(
éé- .
$num
éé. /
,
éé/ 0
$num
éé1 2
,
éé2 3
testRenderTexture
éé4 E
.
ééE F
width
ééF K
,
ééK L
testRenderTexture
ééM ^
.
éé^ _
height
éé_ e
)
éée f
;
ééf g
int
èè 
textureArraySlice
èè +
=
èè, -
-
èè. /
$num
èè/ 0
;
èè0 1
xrPass
êê 
.
êê 

UpdateView
êê !
(
êê! "
$num
êê" #
,
êê# $

projMatrix
êê% /
,
êê/ 0

viewMatrix
êê1 ;
,
êê; <
viewport
êê= E
,
êêE F
textureArraySlice
êêG X
)
êêX Y
;
êêY Z

cameraData
ìì 
.
ìì 
camera
ìì !
.
ìì! "%
TryGetCullingParameters
ìì" 9
(
ìì9 :
false
ìì: ?
,
ìì? @
out
ììA D
var
ììE H
cullingParams
ììI V
)
ììV W
;
ììW X
cullingParams
îî 
.
îî $
stereoProjectionMatrix
îî 4
=
îî5 6

cameraData
îî7 A
.
îîA B
camera
îîB H
.
îîH I
projectionMatrix
îîI Y
;
îîY Z
cullingParams
ïï 
.
ïï 
stereoViewMatrix
ïï .
=
ïï/ 0

cameraData
ïï1 ;
.
ïï; <
camera
ïï< B
.
ïïB C!
worldToCameraMatrix
ïïC V
;
ïïV W
cullingParams
òò 
.
òò 
cullingOptions
òò ,
&=
òò- /
~
òò0 1
CullingOptions
òò1 ?
.
òò? @
Stereo
òò@ F
;
òòF G
xrPass
ôô 
.
ôô !
UpdateCullingParams
ôô *
(
ôô* +
$num
ôô+ ,
,
ôô, -
cullingParams
ôô. ;
)
ôô; <
;
ôô< =
}
öö 
else
õõ 
if
õõ 
(
õõ 
xrPass
õõ 
.
õõ 
enabled
õõ #
&&
õõ$ &
display
õõ' .
!=
õõ/ 1
null
õõ2 6
)
õõ6 7
{
úú 
display
ùù 
.
ùù 
GetRenderPass
ùù %
(
ùù% &
xrPass
ùù& ,
.
ùù, -
multipassId
ùù- 8
,
ùù8 9
out
ùù: =
var
ùù> A

renderPass
ùùB L
)
ùùL M
;
ùùM N
display
ûû 
.
ûû "
GetCullingParameters
ûû ,
(
ûû, -

cameraData
ûû- 7
.
ûû7 8
camera
ûû8 >
,
ûû> ?

renderPass
ûû@ J
.
ûûJ K
cullingPassIndex
ûûK [
,
ûû[ \
out
ûû] `
var
ûûa d
cullingParams
ûûe r
)
ûûr s
;
ûûs t
cullingParams
†† 
.
†† 
cullingOptions
†† ,
&=
††- /
~
††0 1
CullingOptions
††1 ?
.
††? @
Stereo
††@ F
;
††F G
xrPass
¢¢ 
.
¢¢ !
UpdateCullingParams
¢¢ *
(
¢¢* +
cullingPassId
¢¢+ 8
:
¢¢8 9

renderPass
¢¢: D
.
¢¢D E
cullingPassIndex
¢¢E U
,
¢¢U V
cullingParams
¢¢W d
)
¢¢d e
;
¢¢e f
if
££ 
(
££ 
xrPass
££ 
.
££ 
singlePassEnabled
££ ,
)
££, -
{
§§ 
for
¶¶ 
(
¶¶ 
int
¶¶ 
renderParamIndex
¶¶ -
=
¶¶. /
$num
¶¶0 1
;
¶¶1 2
renderParamIndex
¶¶3 C
<
¶¶D E

renderPass
¶¶F P
.
¶¶P Q%
GetRenderParameterCount
¶¶Q h
(
¶¶h i
)
¶¶i j
;
¶¶j k
++
¶¶l n
renderParamIndex
¶¶n ~
)
¶¶~ 
{
ßß 

renderPass
®® "
.
®®" # 
GetRenderParameter
®®# 5
(
®®5 6

cameraData
®®6 @
.
®®@ A
camera
®®A G
,
®®G H
renderParamIndex
®®I Y
,
®®Y Z
out
®®[ ^
var
®®_ b
renderParam
®®c n
)
®®n o
;
®®o p
xrPass
©© 
.
©© 

UpdateView
©© )
(
©©) *
renderParamIndex
©©* :
,
©©: ;

renderPass
©©< F
,
©©F G
renderParam
©©H S
)
©©S T
;
©©T U
}
™™ 
}
´´ 
else
¨¨ 
{
≠≠ 

renderPass
ÆÆ 
.
ÆÆ  
GetRenderParameter
ÆÆ 1
(
ÆÆ1 2

cameraData
ÆÆ2 <
.
ÆÆ< =
camera
ÆÆ= C
,
ÆÆC D
$num
ÆÆE F
,
ÆÆF G
out
ÆÆH K
var
ÆÆL O
renderParam
ÆÆP [
)
ÆÆ[ \
;
ÆÆ\ ]
xrPass
ØØ 
.
ØØ 

UpdateView
ØØ %
(
ØØ% &
$num
ØØ& '
,
ØØ' (

renderPass
ØØ) 3
,
ØØ3 4
renderParam
ØØ5 @
)
ØØ@ A
;
ØØA B
}
∞∞ 
}
±± 
}
≤≤ 	
void
¥¥ #
CreateLayoutFromXrSdk
¥¥ "
(
¥¥" #
Camera
¥¥# )
camera
¥¥* 0
,
¥¥0 1
bool
¥¥2 6
singlePassAllowed
¥¥7 H
)
¥¥H I
{
µµ 	
bool
∂∂ 
CanUseSinglePass
∂∂ !
(
∂∂! " 
XRDisplaySubsystem
∂∂" 4
.
∂∂4 5
XRRenderPass
∂∂5 A

renderPass
∂∂B L
)
∂∂L M
{
∑∑ 
if
∏∏ 
(
∏∏ 

renderPass
∏∏ 
.
∏∏ 
renderTargetDesc
∏∏ /
.
∏∏/ 0
	dimension
∏∏0 9
!=
∏∏: <
TextureDimension
∏∏= M
.
∏∏M N

Tex2DArray
∏∏N X
)
∏∏X Y
return
ππ 
false
ππ  
;
ππ  !
if
ªª 
(
ªª 

renderPass
ªª 
.
ªª %
GetRenderParameterCount
ªª 6
(
ªª6 7
)
ªª7 8
!=
ªª9 ;
$num
ªª< =
||
ªª> @

renderPass
ªªA K
.
ªªK L
renderTargetDesc
ªªL \
.
ªª\ ]
volumeDepth
ªª] h
!=
ªªi k
$num
ªªl m
)
ªªm n
return
ºº 
false
ºº  
;
ºº  !

renderPass
ææ 
.
ææ  
GetRenderParameter
ææ -
(
ææ- .
camera
ææ. 4
,
ææ4 5
$num
ææ6 7
,
ææ7 8
out
ææ9 <
var
ææ= @
renderParam0
ææA M
)
ææM N
;
ææN O

renderPass
øø 
.
øø  
GetRenderParameter
øø -
(
øø- .
camera
øø. 4
,
øø4 5
$num
øø6 7
,
øø7 8
out
øø9 <
var
øø= @
renderParam1
øøA M
)
øøM N
;
øøN O
if
¡¡ 
(
¡¡ 
renderParam0
¡¡  
.
¡¡  !
textureArraySlice
¡¡! 2
!=
¡¡3 5
$num
¡¡6 7
||
¡¡8 :
renderParam1
¡¡; G
.
¡¡G H
textureArraySlice
¡¡H Y
!=
¡¡Z \
$num
¡¡] ^
)
¡¡^ _
return
¬¬ 
false
¬¬  
;
¬¬  !
if
ƒƒ 
(
ƒƒ 
renderParam0
ƒƒ  
.
ƒƒ  !
viewport
ƒƒ! )
!=
ƒƒ* ,
renderParam1
ƒƒ- 9
.
ƒƒ9 :
viewport
ƒƒ: B
)
ƒƒB C
return
≈≈ 
false
≈≈  
;
≈≈  !
return
«« 
true
«« 
;
«« 
}
»» 
for
   
(
   
int
   
renderPassIndex
   $
=
  % &
$num
  ' (
;
  ( )
renderPassIndex
  * 9
<
  : ;
display
  < C
.
  C D 
GetRenderPassCount
  D V
(
  V W
)
  W X
;
  X Y
++
  Z \
renderPassIndex
  \ k
)
  k l
{
ÀÀ 
display
ÃÃ 
.
ÃÃ 
GetRenderPass
ÃÃ %
(
ÃÃ% &
renderPassIndex
ÃÃ& 5
,
ÃÃ5 6
out
ÃÃ7 :
var
ÃÃ; >

renderPass
ÃÃ? I
)
ÃÃI J
;
ÃÃJ K
display
ÕÕ 
.
ÕÕ "
GetCullingParameters
ÕÕ ,
(
ÕÕ, -
camera
ÕÕ- 3
,
ÕÕ3 4

renderPass
ÕÕ5 ?
.
ÕÕ? @
cullingPassIndex
ÕÕ@ P
,
ÕÕP Q
out
ÕÕR U
var
ÕÕV Y
cullingParams
ÕÕZ g
)
ÕÕg h
;
ÕÕh i
cullingParams
–– 
.
–– 
cullingOptions
–– ,
&=
––- /
~
––0 1
CullingOptions
––1 ?
.
––? @
Stereo
––@ F
;
––F G
if
““ 
(
““ 
singlePassAllowed
““ %
&&
““& (
CanUseSinglePass
““) 9
(
““9 :

renderPass
““: D
)
““D E
)
““E F
{
”” 
var
‘‘ 
xrPass
‘‘ 
=
‘‘  
XRPass
‘‘! '
.
‘‘' (
Create
‘‘( .
(
‘‘. /

renderPass
‘‘/ 9
,
‘‘9 :
multipassId
‘‘; F
:
‘‘F G
framePasses
‘‘H S
.
‘‘S T
Count
‘‘T Y
,
‘‘Y Z
cullingParams
‘‘[ h
,
‘‘h i#
occlusionMeshMaterial
‘‘j 
)‘‘ Ä
;‘‘Ä Å
for
÷÷ 
(
÷÷ 
int
÷÷ 
renderParamIndex
÷÷ -
=
÷÷. /
$num
÷÷0 1
;
÷÷1 2
renderParamIndex
÷÷3 C
<
÷÷D E

renderPass
÷÷F P
.
÷÷P Q%
GetRenderParameterCount
÷÷Q h
(
÷÷h i
)
÷÷i j
;
÷÷j k
++
÷÷l n
renderParamIndex
÷÷n ~
)
÷÷~ 
{
◊◊ 

renderPass
ÿÿ "
.
ÿÿ" # 
GetRenderParameter
ÿÿ# 5
(
ÿÿ5 6
camera
ÿÿ6 <
,
ÿÿ< =
renderParamIndex
ÿÿ> N
,
ÿÿN O
out
ÿÿP S
var
ÿÿT W
renderParam
ÿÿX c
)
ÿÿc d
;
ÿÿd e
xrPass
ŸŸ 
.
ŸŸ 
AddView
ŸŸ &
(
ŸŸ& '

renderPass
ŸŸ' 1
,
ŸŸ1 2
renderParam
ŸŸ3 >
)
ŸŸ> ?
;
ŸŸ? @
}
⁄⁄ 
AddPassToFrame
‹‹ "
(
‹‹" #
xrPass
‹‹# )
)
‹‹) *
;
‹‹* +
}
›› 
else
ﬁﬁ 
{
ﬂﬂ 
for
‡‡ 
(
‡‡ 
int
‡‡ 
renderParamIndex
‡‡ -
=
‡‡. /
$num
‡‡0 1
;
‡‡1 2
renderParamIndex
‡‡3 C
<
‡‡D E

renderPass
‡‡F P
.
‡‡P Q%
GetRenderParameterCount
‡‡Q h
(
‡‡h i
)
‡‡i j
;
‡‡j k
++
‡‡l n
renderParamIndex
‡‡n ~
)
‡‡~ 
{
·· 

renderPass
‚‚ "
.
‚‚" # 
GetRenderParameter
‚‚# 5
(
‚‚5 6
camera
‚‚6 <
,
‚‚< =
renderParamIndex
‚‚> N
,
‚‚N O
out
‚‚P S
var
‚‚T W
renderParam
‚‚X c
)
‚‚c d
;
‚‚d e
var
‰‰ 
xrPass
‰‰ "
=
‰‰# $
XRPass
‰‰% +
.
‰‰+ ,
Create
‰‰, 2
(
‰‰2 3

renderPass
‰‰3 =
,
‰‰= >
multipassId
‰‰? J
:
‰‰J K
framePasses
‰‰L W
.
‰‰W X
Count
‰‰X ]
,
‰‰] ^
cullingParams
‰‰_ l
,
‰‰l m$
occlusionMeshMaterial‰‰n É
)‰‰É Ñ
;‰‰Ñ Ö
xrPass
ÂÂ 
.
ÂÂ 
AddView
ÂÂ &
(
ÂÂ& '

renderPass
ÂÂ' 1
,
ÂÂ1 2
renderParam
ÂÂ3 >
)
ÂÂ> ?
;
ÂÂ? @
AddPassToFrame
ÁÁ &
(
ÁÁ& '
xrPass
ÁÁ' -
)
ÁÁ- .
;
ÁÁ. /
}
ËË 
}
ÈÈ 
}
ÍÍ 
}
ÎÎ 	
internal
ÌÌ 
void
ÌÌ 
Dispose
ÌÌ 
(
ÌÌ 
)
ÌÌ 
{
ÓÓ 	
	CoreUtils
ÔÔ 
.
ÔÔ 
Destroy
ÔÔ 
(
ÔÔ #
occlusionMeshMaterial
ÔÔ 3
)
ÔÔ3 4
;
ÔÔ4 5
	CoreUtils
 
.
 
Destroy
 
(
  
mirrorViewMaterial
 0
)
0 1
;
1 2
}
ÒÒ 	
internal
ÛÛ 
void
ÛÛ 
AddPassToFrame
ÛÛ $
(
ÛÛ$ %
XRPass
ÛÛ% +
xrPass
ÛÛ, 2
)
ÛÛ2 3
{
ÙÙ 	
xrPass
ıı 
.
ıı !
UpdateOcclusionMesh
ıı &
(
ıı& '
)
ıı' (
;
ıı( )
framePasses
ˆˆ 
.
ˆˆ 
Add
ˆˆ 
(
ˆˆ 
xrPass
ˆˆ "
)
ˆˆ" #
;
ˆˆ# $
}
˜˜ 	
internal
˘˘ 
static
˘˘ 
class
˘˘ 
XRShaderIDs
˘˘ )
{
˙˙ 	
public
˚˚ 
static
˚˚ 
readonly
˚˚ "
int
˚˚# &"
_SourceTexArraySlice
˚˚' ;
=
˚˚< =
Shader
˚˚> D
.
˚˚D E
PropertyToID
˚˚E Q
(
˚˚Q R
$str
˚˚R h
)
˚˚h i
;
˚˚i j
public
¸¸ 
static
¸¸ 
readonly
¸¸ "
int
¸¸# &
	_SRGBRead
¸¸' 0
=
¸¸< =
Shader
¸¸> D
.
¸¸D E
PropertyToID
¸¸E Q
(
¸¸Q R
$str
¸¸R ]
)
¸¸] ^
;
¸¸^ _
public
˝˝ 
static
˝˝ 
readonly
˝˝ "
int
˝˝# &

_SRGBWrite
˝˝' 1
=
˝˝< =
Shader
˝˝> D
.
˝˝D E
PropertyToID
˝˝E Q
(
˝˝Q R
$str
˝˝R ^
)
˝˝^ _
;
˝˝_ `
}
˛˛ 	
internal
ÄÄ 
void
ÄÄ 
RenderMirrorView
ÄÄ &
(
ÄÄ& '
CommandBuffer
ÄÄ' 4
cmd
ÄÄ5 8
,
ÄÄ8 9
Camera
ÄÄ: @
camera
ÄÄA G
)
ÄÄG H
{
ÅÅ 	
if
ÉÉ 
(
ÉÉ 
Application
ÉÉ 
.
ÉÉ 
platform
ÉÉ $
==
ÉÉ% '
RuntimePlatform
ÉÉ( 7
.
ÉÉ7 8
Android
ÉÉ8 ?
)
ÉÉ? @
return
ÑÑ 
;
ÑÑ 
if
ÜÜ 
(
ÜÜ 
display
ÜÜ 
==
ÜÜ 
null
ÜÜ 
||
ÜÜ  "
!
ÜÜ# $
display
ÜÜ$ +
.
ÜÜ+ ,
running
ÜÜ, 3
||
ÜÜ4 6
!
ÜÜ7 8 
mirrorViewMaterial
ÜÜ8 J
)
ÜÜJ K
return
áá 
;
áá 
using
ââ 
(
ââ 
new
ââ 
ProfilingScope
ââ %
(
ââ% &
cmd
ââ& )
,
ââ) *'
_XRMirrorProfilingSampler
ââ+ D
)
ââD E
)
ââE F
{
ää 
cmd
ãã 
.
ãã 
SetRenderTarget
ãã #
(
ãã# $
camera
ãã$ *
.
ãã* +
targetTexture
ãã+ 8
!=
ãã9 ;
null
ãã< @
?
ããB C
camera
ããD J
.
ããJ K
targetTexture
ããK X
:
ããY Z
new
ãã[ ^$
RenderTargetIdentifier
ãã_ u
(
ããu v'
BuiltinRenderTextureTypeããv é
.ããé è
CameraTargetããè õ
)ããõ ú
)ããú ù
;ããù û
bool
åå 
yflip
åå 
=
åå 
camera
åå #
.
åå# $
targetTexture
åå$ 1
!=
åå2 4
null
åå5 9
||
åå: <
camera
åå= C
.
ååC D

cameraType
ååD N
==
ååO Q

CameraType
ååR \
.
åå\ ]
	SceneView
åå] f
||
ååg i
camera
ååj p
.
ååp q

cameraType
ååq {
==
åå| ~

CameraTypeåå â
.ååâ ä
Previewååä ë
;ååë í
int
çç 
mirrorBlitMode
çç "
=
çç# $
display
çç% ,
.
çç, -(
GetPreferredMirrorBlitMode
çç- G
(
ççG H
)
ççH I
;
ççI J
if
éé 
(
éé 
display
éé 
.
éé #
GetMirrorViewBlitDesc
éé 1
(
éé1 2
null
éé2 6
,
éé6 7
out
éé8 ;
var
éé< ?
blitDesc
éé@ H
,
ééH I
mirrorBlitMode
ééJ X
)
ééX Y
)
ééY Z
{
èè 
if
êê 
(
êê 
blitDesc
êê  
.
êê  !!
nativeBlitAvailable
êê! 4
)
êê4 5
{
ëë 
display
íí 
.
íí  -
AddGraphicsThreadMirrorViewBlit
íí  ?
(
íí? @
cmd
íí@ C
,
ííC D
blitDesc
ííE M
.
ííM N%
nativeBlitInvalidStates
ííN e
,
ííe f
mirrorBlitMode
ííg u
)
ííu v
;
íív w
}
ìì 
else
îî 
{
ïï 
for
ññ 
(
ññ 
int
ññ  
i
ññ! "
=
ññ# $
$num
ññ% &
;
ññ& '
i
ññ( )
<
ññ* +
blitDesc
ññ, 4
.
ññ4 5
blitParamsCount
ññ5 D
;
ññD E
++
ññF H
i
ññH I
)
ññI J
{
óó 
blitDesc
òò $
.
òò$ %
GetBlitParameter
òò% 5
(
òò5 6
i
òò6 7
,
òò7 8
out
òò9 <
var
òò= @
	blitParam
òòA J
)
òòJ K
;
òòK L
Vector4
öö #
	scaleBias
öö$ -
=
öö. /
yflip
öö0 5
?
öö6 7
new
öö8 ;
Vector4
öö< C
(
ööC D
	blitParam
ööD M
.
ööM N
srcRect
ööN U
.
ööU V
width
ööV [
,
öö[ \
-
öö] ^
	blitParam
öö^ g
.
öög h
srcRect
ööh o
.
ööo p
height
ööp v
,
ööv w
	blitParamööx Å
.ööÅ Ç
srcRectööÇ â
.ööâ ä
xööä ã
,ööã å
	blitParamööç ñ
.ööñ ó
srcRectööó û
.ööû ü
heightööü •
+öö¶ ß
	blitParamöö® ±
.öö± ≤
srcRectöö≤ π
.ööπ ∫
yöö∫ ª
)ööª º
:ööΩ æ
new
õõ8 ;
Vector4
õõ< C
(
õõC D
	blitParam
õõD M
.
õõM N
srcRect
õõN U
.
õõU V
width
õõV [
,
õõ[ \
	blitParam
õõ] f
.
õõf g
srcRect
õõg n
.
õõn o
height
õõo u
,
õõu v
	blitParamõõw Ä
.õõÄ Å
srcRectõõÅ à
.õõà â
xõõâ ä
,õõä ã
	blitParamõõå ï
.õõï ñ
srcRectõõñ ù
.õõù û
yõõû ü
)õõü †
;õõ† °
Vector4
úú #
scaleBiasRt
úú$ /
=
úú0 1
new
úú2 5
Vector4
úú6 =
(
úú= >
	blitParam
úú> G
.
úúG H
destRect
úúH P
.
úúP Q
width
úúQ V
,
úúV W
	blitParam
úúX a
.
úúa b
destRect
úúb j
.
úúj k
height
úúk q
,
úúq r
	blitParam
úús |
.
úú| }
destRectúú} Ö
.úúÖ Ü
xúúÜ á
,úúá à
	blitParamúúâ í
.úúí ì
destRectúúì õ
.úúõ ú
yúúú ù
)úúù û
;úúû ü(
mirrorViewMaterialProperty
üü 6
.
üü6 7
SetInt
üü7 =
(
üü= >
XRShaderIDs
üü> I
.
üüI J
	_SRGBRead
üüJ S
,
üüS T
(
üüU V
	blitParam
üüV _
.
üü_ `
srcTex
üü` f
.
üüf g
sRGB
üüg k
)
üük l
?
üüm n
$num
üüo p
:
üüq r
$num
üüs t
)
üüt u
;
üüu v(
mirrorViewMaterialProperty
°° 6
.
°°6 7
SetInt
°°7 =
(
°°= >
XRShaderIDs
°°> I
.
°°I J

_SRGBWrite
°°J T
,
°°T U
(
°°V W
QualitySettings
°°W f
.
°°f g
activeColorSpace
°°g w
==
°°x z

ColorSpace°°{ Ö
.°°Ö Ü
Linear°°Ü å
)°°å ç
?°°é è
$num°°ê ë
:°°í ì
$num°°î ï
)°°ï ñ
;°°ñ ó(
mirrorViewMaterialProperty
¢¢ 6
.
¢¢6 7

SetTexture
¢¢7 A
(
¢¢A B
ShaderPropertyId
¢¢B R
.
¢¢R S
	sourceTex
¢¢S \
,
¢¢\ ]
	blitParam
¢¢^ g
.
¢¢g h
srcTex
¢¢h n
)
¢¢n o
;
¢¢o p(
mirrorViewMaterialProperty
££ 6
.
££6 7
	SetVector
££7 @
(
££@ A
ShaderPropertyId
££A Q
.
££Q R
	scaleBias
££R [
,
££[ \
	scaleBias
££] f
)
££f g
;
££g h(
mirrorViewMaterialProperty
§§ 6
.
§§6 7
	SetVector
§§7 @
(
§§@ A
ShaderPropertyId
§§A Q
.
§§Q R
scaleBiasRt
§§R ]
,
§§] ^
scaleBiasRt
§§_ j
)
§§j k
;
§§k l(
mirrorViewMaterialProperty
•• 6
.
••6 7
SetInt
••7 =
(
••= >
XRShaderIDs
••> I
.
••I J"
_SourceTexArraySlice
••J ^
,
••^ _
	blitParam
••` i
.
••i j
srcTexArraySlice
••j z
)
••z {
;
••{ |
int
ßß 

shaderPass
ßß  *
=
ßß+ ,
(
ßß- .
	blitParam
ßß. 7
.
ßß7 8
srcTex
ßß8 >
.
ßß> ?
	dimension
ßß? H
==
ßßI K
TextureDimension
ßßL \
.
ßß\ ]

Tex2DArray
ßß] g
)
ßßg h
?
ßßi j
$num
ßßk l
:
ßßm n
$num
ßßo p
;
ßßp q
cmd
®® 
.
®®  
DrawProcedural
®®  .
(
®®. /
	Matrix4x4
®®/ 8
.
®®8 9
identity
®®9 A
,
®®A B 
mirrorViewMaterial
®®C U
,
®®U V

shaderPass
®®W a
,
®®a b
MeshTopology
®®c o
.
®®o p
Quads
®®p u
,
®®u v
$num
®®w x
,
®®x y
$num
®®z {
,
®®{ |)
mirrorViewMaterialProperty®®} ó
)®®ó ò
;®®ò ô
}
©© 
}
™™ 
}
´´ 
else
¨¨ 
{
≠≠ 
cmd
ÆÆ 
.
ÆÆ 
ClearRenderTarget
ÆÆ )
(
ÆÆ) *
true
ÆÆ* .
,
ÆÆ. /
true
ÆÆ0 4
,
ÆÆ4 5
Color
ÆÆ6 ;
.
ÆÆ; <
black
ÆÆ< A
)
ÆÆA B
;
ÆÆB C
}
ØØ 
}
∞∞ 
}
±± 	
static
¥¥ #
MaterialPropertyBlock
¥¥ $,
testMirrorViewMaterialProperty
¥¥% C
=
¥¥D E
new
¥¥F I#
MaterialPropertyBlock
¥¥J _
(
¥¥_ `
)
¥¥` a
;
¥¥a b
static
µµ 
Material
µµ $
testMirrorViewMaterial
µµ .
=
µµ/ 0
null
µµ1 5
;
µµ5 6
static
∑∑ 
void
∑∑ %
copyToTestRenderTexture
∑∑ +
(
∑∑+ ,
XRPass
∑∑, 2
pass
∑∑3 7
,
∑∑7 8
CommandBuffer
∑∑9 F
cmd
∑∑G J
,
∑∑J K
RenderTexture
∑∑L Y
rt
∑∑Z \
,
∑∑\ ]
Rect
∑∑^ b
viewport
∑∑c k
)
∑∑k l
{
∏∏ 	
cmd
ππ 
.
ππ 
SetViewport
ππ 
(
ππ 
viewport
ππ $
)
ππ$ %
;
ππ% &
cmd
∫∫ 
.
∫∫ 
SetRenderTarget
∫∫ 
(
∫∫  
rt
∫∫  "
==
∫∫# %
null
∫∫& *
?
∫∫+ ,
new
∫∫- 0$
RenderTargetIdentifier
∫∫1 G
(
∫∫G H&
BuiltinRenderTextureType
∫∫H `
.
∫∫` a
CameraTarget
∫∫a m
)
∫∫m n
:
∫∫o p
rt
∫∫q s
)
∫∫s t
;
∫∫t u
Vector4
ºº 
	scaleBias
ºº 
=
ºº 
new
ºº  #
Vector4
ºº$ +
(
ºº+ ,
$num
ºº, 0
,
ºº0 1
$num
ºº2 6
,
ºº6 7
$num
ºº8 <
,
ºº< =
$num
ºº> B
)
ººB C
;
ººC D
Vector4
ΩΩ 
scaleBiasRT
ΩΩ 
=
ΩΩ  !
new
ΩΩ" %
Vector4
ΩΩ& -
(
ΩΩ- .
$num
ΩΩ. 2
,
ΩΩ2 3
$num
ΩΩ4 8
,
ΩΩ8 9
$num
ΩΩ: >
,
ΩΩ> ?
$num
ΩΩ@ D
)
ΩΩD E
;
ΩΩE F
if
øø 
(
øø 
rt
øø 
==
øø 
null
øø 
)
øø 
{
¿¿ 
	scaleBias
¡¡ 
.
¡¡ 
y
¡¡ 
=
¡¡ 
-
¡¡ 
$num
¡¡ #
;
¡¡# $
	scaleBias
¬¬ 
.
¬¬ 
w
¬¬ 
=
¬¬ 
$num
¬¬ "
;
¬¬" #
}
√√ ,
testMirrorViewMaterialProperty
≈≈ *
.
≈≈* +
	SetVector
≈≈+ 4
(
≈≈4 5
ShaderPropertyId
≈≈5 E
.
≈≈E F
	scaleBias
≈≈F O
,
≈≈O P
	scaleBias
≈≈Q Z
)
≈≈Z [
;
≈≈[ \,
testMirrorViewMaterialProperty
∆∆ *
.
∆∆* +
	SetVector
∆∆+ 4
(
∆∆4 5
ShaderPropertyId
∆∆5 E
.
∆∆E F
scaleBiasRt
∆∆F Q
,
∆∆Q R
scaleBiasRT
∆∆S ^
)
∆∆^ _
;
∆∆_ `,
testMirrorViewMaterialProperty
…… *
.
……* +
SetInt
……+ 1
(
……1 2
XRShaderIDs
……2 =
.
……= >"
_SourceTexArraySlice
……> R
,
……R S
$num
……T U
)
……U V
;
……V W
cmd
ÀÀ 
.
ÀÀ 
DrawProcedural
ÀÀ 
(
ÀÀ 
	Matrix4x4
ÀÀ (
.
ÀÀ( )
identity
ÀÀ) 1
,
ÀÀ1 2$
testMirrorViewMaterial
ÀÀ3 I
,
ÀÀI J
$num
ÀÀK L
,
ÀÀL M
MeshTopology
ÀÀN Z
.
ÀÀZ [
Quads
ÀÀ[ `
,
ÀÀ` a
$num
ÀÀb c
,
ÀÀc d
$num
ÀÀe f
,
ÀÀf g-
testMirrorViewMaterialPropertyÀÀh Ü
)ÀÀÜ á
;ÀÀá à
}
ÃÃ 	
static
ŒŒ 
XRPass
ŒŒ 
.
ŒŒ 
CustomMirrorView
ŒŒ &
testMirrorView
ŒŒ' 5
=
ŒŒ6 7%
copyToTestRenderTexture
ŒŒ8 O
;
ŒŒO P
bool
–– &
LayoutSinglePassTestMode
–– %
(
––% &

CameraData
––& 0

cameraData
––1 ;
,
––; <
XRLayout
––= E
frameLayout
––F Q
)
––Q R
{
—— 	
Camera
““ 
camera
““ 
=
““ 
frameLayout
““ '
.
““' (
camera
““( .
;
““. /
if
‘‘ 
(
‘‘ 
camera
‘‘ 
==
‘‘ 
null
‘‘ 
)
‘‘ 
return
’’ 
false
’’ 
;
’’ 
if
◊◊ 
(
◊◊ 
camera
◊◊ 
.
◊◊ %
TryGetCullingParameters
◊◊ .
(
◊◊. /
false
◊◊/ 4
,
◊◊4 5
out
◊◊6 9
var
◊◊: =
cullingParams
◊◊> K
)
◊◊K L
)
◊◊L M
{
ÿÿ 
cullingParams
ŸŸ 
.
ŸŸ $
stereoProjectionMatrix
ŸŸ 4
=
ŸŸ5 6
camera
ŸŸ7 =
.
ŸŸ= >
projectionMatrix
ŸŸ> N
;
ŸŸN O
cullingParams
⁄⁄ 
.
⁄⁄ 
stereoViewMatrix
⁄⁄ .
=
⁄⁄/ 0
camera
⁄⁄1 7
.
⁄⁄7 8!
worldToCameraMatrix
⁄⁄8 K
;
⁄⁄K L
{
ﬁﬁ %
RenderTextureDescriptor
ﬂﬂ +
rtDesc
ﬂﬂ, 2
=
ﬂﬂ3 4

cameraData
ﬂﬂ5 ?
.
ﬂﬂ? @$
cameraTargetDescriptor
ﬂﬂ@ V
;
ﬂﬂV W
rtDesc
‡‡ 
.
‡‡ 
	dimension
‡‡ $
=
‡‡% &
TextureDimension
‡‡' 7
.
‡‡7 8

Tex2DArray
‡‡8 B
;
‡‡B C
rtDesc
·· 
.
·· 
volumeDepth
·· &
=
··' (
$num
··) *
;
··* +
if
„„ 
(
„„ 
!
„„ 

cameraData
„„ #
.
„„# $
isDefaultViewport
„„$ 5
)
„„5 6
{
‰‰ 
if
ÂÂ 
(
ÂÂ 

cameraData
ÂÂ &
.
ÂÂ& '
targetTexture
ÂÂ' 4
==
ÂÂ5 7
null
ÂÂ8 <
)
ÂÂ< =
{
ÊÊ 
rtDesc
ÁÁ "
.
ÁÁ" #
width
ÁÁ# (
=
ÁÁ) *
(
ÁÁ+ ,
int
ÁÁ, /
)
ÁÁ/ 0
(
ÁÁ0 1
rtDesc
ÁÁ1 7
.
ÁÁ7 8
width
ÁÁ8 =
/
ÁÁ> ?

cameraData
ÁÁ@ J
.
ÁÁJ K
camera
ÁÁK Q
.
ÁÁQ R
rect
ÁÁR V
.
ÁÁV W
width
ÁÁW \
)
ÁÁ\ ]
;
ÁÁ] ^
rtDesc
ËË "
.
ËË" #
height
ËË# )
=
ËË* +
(
ËË, -
int
ËË- 0
)
ËË0 1
(
ËË1 2
rtDesc
ËË2 8
.
ËË8 9
height
ËË9 ?
/
ËË@ A

cameraData
ËËB L
.
ËËL M
camera
ËËM S
.
ËËS T
rect
ËËT X
.
ËËX Y
height
ËËY _
)
ËË_ `
;
ËË` a
}
ÈÈ 
else
ÍÍ 
{
ÎÎ 
rtDesc
ÏÏ "
.
ÏÏ" #
width
ÏÏ# (
=
ÏÏ) *
(
ÏÏ+ ,
int
ÏÏ, /
)
ÏÏ/ 0
(
ÏÏ0 1

cameraData
ÏÏ1 ;
.
ÏÏ; <
targetTexture
ÏÏ< I
.
ÏÏI J
width
ÏÏJ O
)
ÏÏO P
;
ÏÏP Q
rtDesc
ÌÌ "
.
ÌÌ" #
height
ÌÌ# )
=
ÌÌ* +
(
ÌÌ, -
int
ÌÌ- 0
)
ÌÌ0 1
(
ÌÌ1 2

cameraData
ÌÌ2 <
.
ÌÌ< =
targetTexture
ÌÌ= J
.
ÌÌJ K
height
ÌÌK Q
)
ÌÌQ R
;
ÌÌR S
}
ÓÓ 
}
ÔÔ 
testRenderTexture
 %
=
& '
RenderTexture
( 5
.
5 6
GetTemporary
6 B
(
B C
rtDesc
C I
)
I J
;
J K$
testMirrorViewMaterial
ÚÚ *
=
ÚÚ+ , 
mirrorViewMaterial
ÚÚ- ?
;
ÚÚ? @,
testMirrorViewMaterialProperty
ÛÛ 2
.
ÛÛ2 3
SetInt
ÛÛ3 9
(
ÛÛ9 :
XRShaderIDs
ÛÛ: E
.
ÛÛE F
	_SRGBRead
ÛÛF O
,
ÛÛO P
(
ÛÛQ R
testRenderTexture
ÛÛR c
.
ÛÛc d
sRGB
ÛÛd h
)
ÛÛh i
?
ÛÛj k
$num
ÛÛl m
:
ÛÛn o
$num
ÛÛp q
)
ÛÛq r
;
ÛÛr s,
testMirrorViewMaterialProperty
ÙÙ 2
.
ÙÙ2 3
SetInt
ÙÙ3 9
(
ÙÙ9 :
XRShaderIDs
ÙÙ: E
.
ÙÙE F

_SRGBWrite
ÙÙF P
,
ÙÙP Q
(
ÙÙR S
QualitySettings
ÙÙS b
.
ÙÙb c
activeColorSpace
ÙÙc s
==
ÙÙt v

ColorSpaceÙÙw Å
.ÙÙÅ Ç
LinearÙÙÇ à
)ÙÙà â
?ÙÙä ã
$numÙÙå ç
:ÙÙé è
$numÙÙê ë
)ÙÙë í
;ÙÙí ì,
testMirrorViewMaterialProperty
ıı 2
.
ıı2 3

SetTexture
ıı3 =
(
ıı= >
ShaderPropertyId
ıı> N
.
ııN O
	sourceTex
ııO X
,
ııX Y
testRenderTexture
ııZ k
)
ıık l
;
ııl m
}
ˆˆ 
var
¯¯ 
passInfo
¯¯ 
=
¯¯ 
new
¯¯ "
XRPassCreateInfo
¯¯# 3
{
˘˘ 
multipassId
˙˙ 
=
˙˙  !
$num
˙˙" #
,
˙˙# $
cullingPassId
˚˚ !
=
˚˚" #
$num
˚˚$ %
,
˚˚% &
cullingParameters
¸¸ %
=
¸¸& '
cullingParams
¸¸( 5
,
¸¸5 6
renderTarget
˝˝  
=
˝˝! "
testRenderTexture
˝˝# 4
,
˝˝4 5)
renderTargetIsRenderTexture
˛˛ /
=
˛˛0 1
true
˛˛2 6
,
˛˛6 7
customMirrorView
ˇˇ $
=
ˇˇ% &
testMirrorView
ˇˇ' 5
}
ÄÄ 
;
ÄÄ 
var
ÇÇ 
	viewInfo2
ÇÇ 
=
ÇÇ 
new
ÇÇ  #
XRViewCreateInfo
ÇÇ$ 4
{
ÉÉ 

projMatrix
ÑÑ 
=
ÑÑ  
camera
ÑÑ! '
.
ÑÑ' (
projectionMatrix
ÑÑ( 8
,
ÑÑ8 9

viewMatrix
ÖÖ 
=
ÖÖ  
camera
ÖÖ! '
.
ÖÖ' (!
worldToCameraMatrix
ÖÖ( ;
,
ÖÖ; <
viewport
ÜÜ 
=
ÜÜ 
new
ÜÜ "
Rect
ÜÜ# '
(
ÜÜ' (
$num
ÜÜ( )
,
ÜÜ) *
$num
ÜÜ+ ,
,
ÜÜ, -
testRenderTexture
ÜÜ. ?
.
ÜÜ? @
width
ÜÜ@ E
,
ÜÜE F
testRenderTexture
ÜÜG X
.
ÜÜX Y
height
ÜÜY _
)
ÜÜ_ `
,
ÜÜ` a
textureArraySlice
áá %
=
áá& '
-
áá( )
$num
áá) *
}
àà 
;
àà 
var
ãã 
	viewInfo1
ãã 
=
ãã 
	viewInfo2
ãã  )
;
ãã) *
var
åå 
planes
åå 
=
åå 
	viewInfo1
åå &
.
åå& '

projMatrix
åå' 1
.
åå1 2!
decomposeProjection
åå2 E
;
ååE F
planes
çç 
.
çç 
left
çç 
*=
çç 
$num
çç $
;
çç$ %
planes
éé 
.
éé 
right
éé 
*=
éé 
$num
éé  %
;
éé% &
planes
èè 
.
èè 
top
èè 
*=
èè 
$num
èè #
;
èè# $
planes
êê 
.
êê 
bottom
êê 
*=
êê  
$num
êê! &
;
êê& '
	viewInfo1
ëë 
.
ëë 

projMatrix
ëë $
=
ëë% &
	Matrix4x4
ëë' 0
.
ëë0 1
Frustum
ëë1 8
(
ëë8 9
planes
ëë9 ?
)
ëë? @
;
ëë@ A
	viewInfo1
íí 
.
íí 

viewMatrix
íí $
*=
íí% '
	Matrix4x4
íí( 1
.
íí1 2
	Translate
íí2 ;
(
íí; <
new
íí< ?
Vector3
íí@ G
(
ííG H
$num
ííH L
,
ííL M
$num
ííN S
,
ííS T
-
ííU V
$num
ííV [
)
íí[ \
)
íí\ ]
;
íí] ^
{
ïï 
XRPass
ññ 
pass
ññ 
=
ññ  !
frameLayout
ññ" -
.
ññ- .

CreatePass
ññ. 8
(
ññ8 9
passInfo
ññ9 A
)
ññA B
;
ññB C
frameLayout
òò 
.
òò  
AddViewToPass
òò  -
(
òò- .
	viewInfo1
òò. 7
,
òò7 8
pass
òò9 =
)
òò= >
;
òò> ?
frameLayout
ôô 
.
ôô  
AddViewToPass
ôô  -
(
ôô- .
	viewInfo2
ôô. 7
,
ôô7 8
pass
ôô9 =
)
ôô= >
;
ôô> ?
}
öö 
return
ùù 
true
ùù 
;
ùù 
}
ûû 
return
†† 
false
†† 
;
†† 
}
°° 	
}
££ 
}§§ ó
¢D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\Tonemapping.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
public 

enum 
TonemappingMode 
{ 
None 
, 
Neutral 
, 
ACES		 
,		 
}

 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' D
)D E
]E F
public 

sealed 
class 
Tonemapping #
:$ %
VolumeComponent& 5
,5 6!
IPostProcessComponent7 L
{ 
[ 	
Tooltip	 
( 
$str W
)W X
]X Y
public $
TonemappingModeParameter '
mode( ,
=- .
new/ 2$
TonemappingModeParameter3 K
(K L
TonemappingModeL [
.[ \
None\ `
)` a
;a b
public 
bool 
IsActive 
( 
) 
=> !
mode" &
.& '
value' ,
!=- /
TonemappingMode0 ?
.? @
None@ D
;D E
public 
bool 
IsTileCompatible $
($ %
)% &
=>' )
true* .
;. /
} 
[ 
Serializable 
] 
public 

sealed 
class $
TonemappingModeParameter 0
:1 2
VolumeParameter3 B
<B C
TonemappingModeC R
>R S
{T U
publicV \$
TonemappingModeParameter] u
(u v
TonemappingMode	v Ö
value
Ü ã
,
ã å
bool
ç ë
overrideState
í ü
=
† °
false
¢ ß
)
ß ®
:
© ™
base
´ Ø
(
Ø ∞
value
∞ µ
,
µ ∂
overrideState
∑ ƒ
)
ƒ ≈
{
∆ «
}
» …
}
  À
} ∫π
üD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\ScriptableRenderer.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
public 

abstract 
partial 
class !
ScriptableRenderer" 4
:5 6
IDisposable7 B
{ 
private 
static 
class 
	Profiling &
{ 	
private 
const 
string  
k_Name! '
=( )
nameof* 0
(0 1
ScriptableRenderer1 C
)C D
;D E
public 
static 
readonly "
ProfilingSampler# 3'
setPerCameraShaderVariables4 O
=P Q
newR U
ProfilingSamplerV f
(f g
$"g i
{i j
k_Namej p
}p q
.q r
{r s
nameofs y
(y z(
SetPerCameraShaderVariables	z ï
)
ï ñ
}
ñ ó
"
ó ò
)
ò ô
;
ô ö
public 
static 
readonly "
ProfilingSampler# 3
sortRenderPasses4 D
=P Q
newR U
ProfilingSamplerV f
(f g
$"g i
Sort Render Passesi {
"{ |
)| }
;} ~
public 
static 
readonly "
ProfilingSampler# 3
setupLights4 ?
=P Q
newR U
ProfilingSamplerV f
(f g
$"g i
{i j
k_Namej p
}p q
.q r
{r s
nameofs y
(y z
SetupLights	z Ö
)
Ö Ü
}
Ü á
"
á à
)
à â
;
â ä
public 
static 
readonly "
ProfilingSampler# 3
setupCamera4 ?
=P Q
newR U
ProfilingSamplerV f
(f g
$"g i$
Setup Camera Parameters	i Ä
"
Ä Å
)
Å Ç
;
Ç É
public 
static 
readonly "
ProfilingSampler# 3
addRenderPasses4 C
=P Q
newR U
ProfilingSamplerV f
(f g
$"g i
{i j
k_Namej p
}p q
.q r
{r s
nameofs y
(y z
AddRenderPasses	z â
)
â ä
}
ä ã
"
ã å
)
å ç
;
ç é
public   
static   
readonly   "
ProfilingSampler  # 3
clearRenderingState  4 G
=  P Q
new  R U
ProfilingSampler  V f
(  f g
$"  g i
{  i j
k_Name  j p
}  p q
.  q r
{  r s
nameof  s y
(  y z 
ClearRenderingState	  z ç
)
  ç é
}
  é è
"
  è ê
)
  ê ë
;
  ë í
public!! 
static!! 
readonly!! "
ProfilingSampler!!# 3"
internalStartRendering!!4 J
=!!P Q
new!!R U
ProfilingSampler!!V f
(!!f g
$"!!g i
{!!i j
k_Name!!j p
}!!p q
.!!q r
{!!r s
nameof!!s y
(!!y z#
InternalStartRendering	!!z ê
)
!!ê ë
}
!!ë í
"
!!í ì
)
!!ì î
;
!!î ï
public"" 
static"" 
readonly"" "
ProfilingSampler""# 3#
internalFinishRendering""4 K
=""P Q
new""R U
ProfilingSampler""V f
(""f g
$"""g i
{""i j
k_Name""j p
}""p q
.""q r
{""r s
nameof""s y
(""y z$
InternalFinishRendering	""z ë
)
""ë í
}
""í ì
"
""ì î
)
""î ï
;
""ï ñ
public$$ 
static$$ 
class$$ 
RenderBlock$$  +
{%% 
private&& 
const&& 
string&& $
k_Name&&% +
=&&, -
nameof&&. 4
(&&4 5
RenderPassBlock&&5 D
)&&D E
;&&E F
public'' 
static'' 
readonly'' &
ProfilingSampler''' 7
beforeRendering''8 G
=''Q R
new''S V
ProfilingSampler''W g
(''g h
$"''h j
{''j k
k_Name''k q
}''q r
.''r s
{''s t
nameof''t z
(''z {
RenderPassBlock	''{ ä
.
''ä ã
BeforeRendering
''ã ö
)
''ö õ
}
''õ ú
"
''ú ù
)
''ù û
;
''û ü
public(( 
static(( 
readonly(( &
ProfilingSampler((' 7
mainRenderingOpaque((8 K
=((Q R
new((S V
ProfilingSampler((W g
(((g h
$"((h j
{((j k
k_Name((k q
}((q r
.((r s
{((s t
nameof((t z
(((z {
RenderPassBlock	(({ ä
.
((ä ã!
MainRenderingOpaque
((ã û
)
((û ü
}
((ü †
"
((† °
)
((° ¢
;
((¢ £
public)) 
static)) 
readonly)) &
ProfilingSampler))' 7$
mainRenderingTransparent))8 P
=))Q R
new))S V
ProfilingSampler))W g
())g h
$"))h j
{))j k
k_Name))k q
}))q r
.))r s
{))s t
nameof))t z
())z {
RenderPassBlock	)){ ä
.
))ä ã&
MainRenderingTransparent
))ã £
)
))£ §
}
))§ •
"
))• ¶
)
))¶ ß
;
))ß ®
public** 
static** 
readonly** &
ProfilingSampler**' 7
afterRendering**8 F
=**Q R
new**S V
ProfilingSampler**W g
(**g h
$"**h j
{**j k
k_Name**k q
}**q r
.**r s
{**s t
nameof**t z
(**z {
RenderPassBlock	**{ ä
.
**ä ã
AfterRendering
**ã ô
)
**ô ö
}
**ö õ
"
**õ ú
)
**ú ù
;
**ù û
}++ 
public-- 
static-- 
class-- 

RenderPass--  *
{.. 
private// 
const// 
string// $
k_Name//% +
=//, -
nameof//. 4
(//4 5 
ScriptableRenderPass//5 I
)//I J
;//J K
public00 
static00 
readonly00 &
ProfilingSampler00' 7
	configure008 A
=00B C
new00D G
ProfilingSampler00H X
(00X Y
$"00Y [
{00[ \
k_Name00\ b
}00b c
.00c d
{00d e
nameof00e k
(00k l!
ScriptableRenderPass	00l Ä
.
00Ä Å
	Configure
00Å ä
)
00ä ã
}
00ã å
"
00å ç
)
00ç é
;
00é è
}11 
}22 	
	protected77 
ProfilingSampler77 "
profilingExecute77# 3
{774 5
get776 9
;779 :
set77; >
;77> ?
}77@ A
public== 
class== 
RenderingFeatures== &
{>> 	
publicEE 
boolEE 
cameraStackingEE &
{EE' (
getEE) ,
;EE, -
setEE. 1
;EE1 2
}EE3 4
=EE5 6
falseEE7 <
;EE< =
publicJJ 
boolJJ 
msaaJJ 
{JJ 
getJJ "
;JJ" #
setJJ$ '
;JJ' (
}JJ) *
=JJ+ ,
trueJJ- 1
;JJ1 2
}KK 	
internalRR 
staticRR 
ScriptableRendererRR *
currentRR+ 2
=RR3 4
nullRR5 9
;RR9 :
public^^ 
static^^ 
void^^ 
SetCameraMatrices^^ ,
(^^, -
CommandBuffer^^- :
cmd^^; >
,^^> ?
ref^^@ C

CameraData^^D N

cameraData^^O Y
,^^Y Z
bool^^[ _
setInverseMatrices^^` r
)^^r s
{__ 	
ifaa 
(aa 

cameraDataaa 
.aa 
xraa 
.aa 
enabledaa %
)aa% &
{bb 

cameraDatacc 
.cc 
xrcc 
.cc .
"UpdateGPUViewAndProjectionMatricescc @
(cc@ A
cmdccA D
,ccD E
refccF I

cameraDataccJ T
,ccT U

cameraDataccV `
.cc` a
xrcca c
.ccc d'
renderTargetIsRenderTextureccd 
)	cc Ä
;
ccÄ Å
returndd 
;dd 
}ee 
	Matrix4x4hh 

viewMatrixhh  
=hh! "

cameraDatahh# -
.hh- .
GetViewMatrixhh. ;
(hh; <
)hh< =
;hh= >
	Matrix4x4ii 
projectionMatrixii &
=ii' (

cameraDataii) 3
.ii3 4
GetProjectionMatrixii4 G
(iiG H
)iiH I
;iiI J
cmdnn 
.nn %
SetViewProjectionMatricesnn )
(nn) *

viewMatrixnn* 4
,nn4 5
projectionMatrixnn6 F
)nnF G
;nnG H
ifpp 
(pp 
setInverseMatricespp "
)pp" #
{qq 
	Matrix4x4rr 
gpuProjectionMatrixrr -
=rr. /

cameraDatarr0 :
.rr: ;"
GetGPUProjectionMatrixrr; Q
(rrQ R
)rrR S
;rrS T
	Matrix4x4ss #
viewAndProjectionMatrixss 1
=ss2 3
gpuProjectionMatrixss4 G
*ssH I

viewMatrixssJ T
;ssT U
	Matrix4x4tt 
inverseViewMatrixtt +
=tt, -
	Matrix4x4tt. 7
.tt7 8
Inversett8 ?
(tt? @

viewMatrixtt@ J
)ttJ K
;ttK L
	Matrix4x4uu #
inverseProjectionMatrixuu 1
=uu2 3
	Matrix4x4uu4 =
.uu= >
Inverseuu> E
(uuE F
gpuProjectionMatrixuuF Y
)uuY Z
;uuZ [
	Matrix4x4vv !
inverseViewProjectionvv /
=vv0 1
inverseViewMatrixvv2 C
*vvD E#
inverseProjectionMatrixvvF ]
;vv] ^
	Matrix4x4{{ 
worldToCameraMatrix{{ -
={{. /
	Matrix4x4{{0 9
.{{9 :
Scale{{: ?
({{? @
new{{@ C
Vector3{{D K
({{K L
$num{{L P
,{{P Q
$num{{R V
,{{V W
-{{X Y
$num{{Y ]
){{] ^
){{^ _
*{{` a

viewMatrix{{b l
;{{l m
	Matrix4x4|| 
cameraToWorldMatrix|| -
=||. /
worldToCameraMatrix||0 C
.||C D
inverse||D K
;||K L
cmd}} 
.}} 
SetGlobalMatrix}} #
(}}# $
ShaderPropertyId}}$ 4
.}}4 5
worldToCameraMatrix}}5 H
,}}H I
worldToCameraMatrix}}J ]
)}}] ^
;}}^ _
cmd~~ 
.~~ 
SetGlobalMatrix~~ #
(~~# $
ShaderPropertyId~~$ 4
.~~4 5
cameraToWorldMatrix~~5 H
,~~H I
cameraToWorldMatrix~~J ]
)~~] ^
;~~^ _
cmd
ÄÄ 
.
ÄÄ 
SetGlobalMatrix
ÄÄ #
(
ÄÄ# $
ShaderPropertyId
ÄÄ$ 4
.
ÄÄ4 5
inverseViewMatrix
ÄÄ5 F
,
ÄÄF G
inverseViewMatrix
ÄÄH Y
)
ÄÄY Z
;
ÄÄZ [
cmd
ÅÅ 
.
ÅÅ 
SetGlobalMatrix
ÅÅ #
(
ÅÅ# $
ShaderPropertyId
ÅÅ$ 4
.
ÅÅ4 5%
inverseProjectionMatrix
ÅÅ5 L
,
ÅÅL M%
inverseProjectionMatrix
ÅÅN e
)
ÅÅe f
;
ÅÅf g
cmd
ÇÇ 
.
ÇÇ 
SetGlobalMatrix
ÇÇ #
(
ÇÇ# $
ShaderPropertyId
ÇÇ$ 4
.
ÇÇ4 5,
inverseViewAndProjectionMatrix
ÇÇ5 S
,
ÇÇS T#
inverseViewProjection
ÇÇU j
)
ÇÇj k
;
ÇÇk l
}
ÉÉ 
}
ÜÜ 	
void
çç )
SetPerCameraShaderVariables
çç (
(
çç( )
CommandBuffer
çç) 6
cmd
çç7 :
,
çç: ;
ref
çç< ?

CameraData
çç@ J

cameraData
ççK U
)
ççU V
{
éé 	
using
èè 
var
èè 
	profScope
èè 
=
èè  !
new
èè" %
ProfilingScope
èè& 4
(
èè4 5
cmd
èè5 8
,
èè8 9
	Profiling
èè: C
.
èèC D)
setPerCameraShaderVariables
èèD _
)
èè_ `
;
èè` a
Camera
ëë 
camera
ëë 
=
ëë 

cameraData
ëë &
.
ëë& '
camera
ëë' -
;
ëë- .
Rect
ìì 
	pixelRect
ìì 
=
ìì 

cameraData
ìì '
.
ìì' (
	pixelRect
ìì( 1
;
ìì1 2
float
îî 
scaledCameraWidth
îî #
=
îî$ %
(
îî& '
float
îî' ,
)
îî, -
	pixelRect
îî- 6
.
îî6 7
width
îî7 <
*
îî= >

cameraData
îî? I
.
îîI J
renderScale
îîJ U
;
îîU V
float
ïï  
scaledCameraHeight
ïï $
=
ïï% &
(
ïï' (
float
ïï( -
)
ïï- .
	pixelRect
ïï. 7
.
ïï7 8
height
ïï8 >
*
ïï? @

cameraData
ïïA K
.
ïïK L
renderScale
ïïL W
;
ïïW X
float
ññ 
cameraWidth
ññ 
=
ññ 
(
ññ  !
float
ññ! &
)
ññ& '
	pixelRect
ññ' 0
.
ññ0 1
width
ññ1 6
;
ññ6 7
float
óó 
cameraHeight
óó 
=
óó  
(
óó! "
float
óó" '
)
óó' (
	pixelRect
óó( 1
.
óó1 2
height
óó2 8
;
óó8 9
if
öö 
(
öö 

cameraData
öö 
.
öö 
xr
öö 
.
öö 
enabled
öö $
)
öö$ %
{
õõ 
scaledCameraWidth
úú !
=
úú" #
(
úú$ %
float
úú% *
)
úú* +

cameraData
úú+ 5
.
úú5 6$
cameraTargetDescriptor
úú6 L
.
úúL M
width
úúM R
;
úúR S 
scaledCameraHeight
ùù "
=
ùù# $
(
ùù% &
float
ùù& +
)
ùù+ ,

cameraData
ùù, 6
.
ùù6 7$
cameraTargetDescriptor
ùù7 M
.
ùùM N
height
ùùN T
;
ùùT U
cameraWidth
ûû 
=
ûû 
(
ûû 
float
ûû $
)
ûû$ %

cameraData
ûû% /
.
ûû/ 0$
cameraTargetDescriptor
ûû0 F
.
ûûF G
width
ûûG L
;
ûûL M
cameraHeight
üü 
=
üü 
(
üü  
float
üü  %
)
üü% &

cameraData
üü& 0
.
üü0 1$
cameraTargetDescriptor
üü1 G
.
üüG H
height
üüH N
;
üüN O
}
†† 
if
¢¢ 
(
¢¢ 
camera
¢¢ 
.
¢¢ $
allowDynamicResolution
¢¢ -
)
¢¢- .
{
££ 
scaledCameraWidth
§§ !
*=
§§" $#
ScalableBufferManager
§§% :
.
§§: ;
widthScaleFactor
§§; K
;
§§K L 
scaledCameraHeight
•• "
*=
••# %#
ScalableBufferManager
••& ;
.
••; <
heightScaleFactor
••< M
;
••M N
}
¶¶ 
float
®® 
near
®® 
=
®® 
camera
®® 
.
®®  
nearClipPlane
®®  -
;
®®- .
float
©© 
far
©© 
=
©© 
camera
©© 
.
©© 
farClipPlane
©© +
;
©©+ ,
float
™™ 
invNear
™™ 
=
™™ 
Mathf
™™ !
.
™™! "
Approximately
™™" /
(
™™/ 0
near
™™0 4
,
™™4 5
$num
™™6 :
)
™™: ;
?
™™< =
$num
™™> B
:
™™C D
$num
™™E I
/
™™J K
near
™™L P
;
™™P Q
float
´´ 
invFar
´´ 
=
´´ 
Mathf
´´  
.
´´  !
Approximately
´´! .
(
´´. /
far
´´/ 2
,
´´2 3
$num
´´4 8
)
´´8 9
?
´´: ;
$num
´´< @
:
´´A B
$num
´´C G
/
´´H I
far
´´J M
;
´´M N
float
¨¨ 
isOrthographic
¨¨  
=
¨¨! "
camera
¨¨# )
.
¨¨) *
orthographic
¨¨* 6
?
¨¨7 8
$num
¨¨9 =
:
¨¨> ?
$num
¨¨@ D
;
¨¨D E
float
µµ 
zc0
µµ 
=
µµ 
$num
µµ 
-
µµ 
far
µµ "
*
µµ# $
invNear
µµ% ,
;
µµ, -
float
∂∂ 
zc1
∂∂ 
=
∂∂ 
far
∂∂ 
*
∂∂ 
invNear
∂∂ %
;
∂∂% &
Vector4
∏∏ 
zBufferParams
∏∏ !
=
∏∏" #
new
∏∏$ '
Vector4
∏∏( /
(
∏∏/ 0
zc0
∏∏0 3
,
∏∏3 4
zc1
∏∏5 8
,
∏∏8 9
zc0
∏∏: =
*
∏∏> ?
invFar
∏∏@ F
,
∏∏F G
zc1
∏∏H K
*
∏∏L M
invFar
∏∏N T
)
∏∏T U
;
∏∏U V
if
∫∫ 
(
∫∫ 

SystemInfo
∫∫ 
.
∫∫ !
usesReversedZBuffer
∫∫ .
)
∫∫. /
{
ªª 
zBufferParams
ºº 
.
ºº 
y
ºº 
+=
ºº  "
zBufferParams
ºº# 0
.
ºº0 1
x
ºº1 2
;
ºº2 3
zBufferParams
ΩΩ 
.
ΩΩ 
x
ΩΩ 
=
ΩΩ  !
-
ΩΩ" #
zBufferParams
ΩΩ# 0
.
ΩΩ0 1
x
ΩΩ1 2
;
ΩΩ2 3
zBufferParams
ææ 
.
ææ 
w
ææ 
+=
ææ  "
zBufferParams
ææ# 0
.
ææ0 1
z
ææ1 2
;
ææ2 3
zBufferParams
øø 
.
øø 
z
øø 
=
øø  !
-
øø" #
zBufferParams
øø# 0
.
øø0 1
z
øø1 2
;
øø2 3
}
¿¿ 
Vector4
…… 
orthoParams
…… 
=
……  !
new
……" %
Vector4
……& -
(
……- .
camera
……. 4
.
……4 5
orthographicSize
……5 E
*
……F G

cameraData
……H R
.
……R S
aspectRatio
……S ^
,
……^ _
camera
……` f
.
……f g
orthographicSize
……g w
,
……w x
$num
……y }
,
……} ~
isOrthographic…… ç
)……ç é
;……é è
cmd
ÃÃ 
.
ÃÃ 
SetGlobalVector
ÃÃ 
(
ÃÃ  
ShaderPropertyId
ÃÃ  0
.
ÃÃ0 1!
worldSpaceCameraPos
ÃÃ1 D
,
ÃÃD E
camera
ÃÃF L
.
ÃÃL M
	transform
ÃÃM V
.
ÃÃV W
position
ÃÃW _
)
ÃÃ_ `
;
ÃÃ` a
cmd
ÕÕ 
.
ÕÕ 
SetGlobalVector
ÕÕ 
(
ÕÕ  
ShaderPropertyId
ÕÕ  0
.
ÕÕ0 1
screenParams
ÕÕ1 =
,
ÕÕ= >
new
ÕÕ? B
Vector4
ÕÕC J
(
ÕÕJ K
cameraWidth
ÕÕK V
,
ÕÕV W
cameraHeight
ÕÕX d
,
ÕÕd e
$num
ÕÕf j
+
ÕÕk l
$num
ÕÕm q
/
ÕÕr s
cameraWidth
ÕÕt 
,ÕÕ Ä
$numÕÕÅ Ö
+ÕÕÜ á
$numÕÕà å
/ÕÕç é
cameraHeightÕÕè õ
)ÕÕõ ú
)ÕÕú ù
;ÕÕù û
cmd
ŒŒ 
.
ŒŒ 
SetGlobalVector
ŒŒ 
(
ŒŒ  
ShaderPropertyId
ŒŒ  0
.
ŒŒ0 1 
scaledScreenParams
ŒŒ1 C
,
ŒŒC D
new
ŒŒE H
Vector4
ŒŒI P
(
ŒŒP Q
scaledCameraWidth
ŒŒQ b
,
ŒŒb c 
scaledCameraHeight
ŒŒd v
,
ŒŒv w
$num
ŒŒx |
+
ŒŒ} ~
$numŒŒ É
/ŒŒÑ Ö!
scaledCameraWidthŒŒÜ ó
,ŒŒó ò
$numŒŒô ù
+ŒŒû ü
$numŒŒ† §
/ŒŒ• ¶"
scaledCameraHeightŒŒß π
)ŒŒπ ∫
)ŒŒ∫ ª
;ŒŒª º
cmd
œœ 
.
œœ 
SetGlobalVector
œœ 
(
œœ  
ShaderPropertyId
œœ  0
.
œœ0 1
zBufferParams
œœ1 >
,
œœ> ?
zBufferParams
œœ@ M
)
œœM N
;
œœN O
cmd
–– 
.
–– 
SetGlobalVector
–– 
(
––  
ShaderPropertyId
––  0
.
––0 1
orthoParams
––1 <
,
––< =
orthoParams
––> I
)
––I J
;
––J K
}
—— 	
void
⁄⁄ !
SetShaderTimeValues
⁄⁄  
(
⁄⁄  !
CommandBuffer
⁄⁄! .
cmd
⁄⁄/ 2
,
⁄⁄2 3
float
⁄⁄4 9
time
⁄⁄: >
,
⁄⁄> ?
float
⁄⁄@ E
	deltaTime
⁄⁄F O
,
⁄⁄O P
float
⁄⁄Q V
smoothDeltaTime
⁄⁄W f
)
⁄⁄f g
{
€€ 	
float
‹‹ 

timeEights
‹‹ 
=
‹‹ 
time
‹‹ #
/
‹‹$ %
$num
‹‹& (
;
‹‹( )
float
›› 

timeFourth
›› 
=
›› 
time
›› #
/
››$ %
$num
››& (
;
››( )
float
ﬁﬁ 
timeHalf
ﬁﬁ 
=
ﬁﬁ 
time
ﬁﬁ !
/
ﬁﬁ" #
$num
ﬁﬁ$ &
;
ﬁﬁ& '
Vector4
·· 

timeVector
·· 
=
··  
time
··! %
*
··& '
new
··( +
Vector4
··, 3
(
··3 4
$num
··4 6
/
··7 8
$num
··9 <
,
··< =
$num
··> @
,
··@ A
$num
··B D
,
··D E
$num
··F H
)
··H I
;
··I J
Vector4
‚‚ 
sinTimeVector
‚‚ !
=
‚‚" #
new
‚‚$ '
Vector4
‚‚( /
(
‚‚/ 0
Mathf
‚‚0 5
.
‚‚5 6
Sin
‚‚6 9
(
‚‚9 :

timeEights
‚‚: D
)
‚‚D E
,
‚‚E F
Mathf
‚‚G L
.
‚‚L M
Sin
‚‚M P
(
‚‚P Q

timeFourth
‚‚Q [
)
‚‚[ \
,
‚‚\ ]
Mathf
‚‚^ c
.
‚‚c d
Sin
‚‚d g
(
‚‚g h
timeHalf
‚‚h p
)
‚‚p q
,
‚‚q r
Mathf
‚‚s x
.
‚‚x y
Sin
‚‚y |
(
‚‚| }
time‚‚} Å
)‚‚Å Ç
)‚‚Ç É
;‚‚É Ñ
Vector4
„„ 
cosTimeVector
„„ !
=
„„" #
new
„„$ '
Vector4
„„( /
(
„„/ 0
Mathf
„„0 5
.
„„5 6
Cos
„„6 9
(
„„9 :

timeEights
„„: D
)
„„D E
,
„„E F
Mathf
„„G L
.
„„L M
Cos
„„M P
(
„„P Q

timeFourth
„„Q [
)
„„[ \
,
„„\ ]
Mathf
„„^ c
.
„„c d
Cos
„„d g
(
„„g h
timeHalf
„„h p
)
„„p q
,
„„q r
Mathf
„„s x
.
„„x y
Cos
„„y |
(
„„| }
time„„} Å
)„„Å Ç
)„„Ç É
;„„É Ñ
Vector4
‰‰ 
deltaTimeVector
‰‰ #
=
‰‰$ %
new
‰‰& )
Vector4
‰‰* 1
(
‰‰1 2
	deltaTime
‰‰2 ;
,
‰‰; <
$num
‰‰= ?
/
‰‰@ A
	deltaTime
‰‰B K
,
‰‰K L
smoothDeltaTime
‰‰M \
,
‰‰\ ]
$num
‰‰^ `
/
‰‰a b
smoothDeltaTime
‰‰c r
)
‰‰r s
;
‰‰s t
Vector4
ÂÂ "
timeParametersVector
ÂÂ (
=
ÂÂ) *
new
ÂÂ+ .
Vector4
ÂÂ/ 6
(
ÂÂ6 7
time
ÂÂ7 ;
,
ÂÂ; <
Mathf
ÂÂ= B
.
ÂÂB C
Sin
ÂÂC F
(
ÂÂF G
time
ÂÂG K
)
ÂÂK L
,
ÂÂL M
Mathf
ÂÂN S
.
ÂÂS T
Cos
ÂÂT W
(
ÂÂW X
time
ÂÂX \
)
ÂÂ\ ]
,
ÂÂ] ^
$num
ÂÂ_ c
)
ÂÂc d
;
ÂÂd e
cmd
ÁÁ 
.
ÁÁ 
SetGlobalVector
ÁÁ 
(
ÁÁ  
ShaderPropertyId
ÁÁ  0
.
ÁÁ0 1
time
ÁÁ1 5
,
ÁÁ5 6

timeVector
ÁÁ7 A
)
ÁÁA B
;
ÁÁB C
cmd
ËË 
.
ËË 
SetGlobalVector
ËË 
(
ËË  
ShaderPropertyId
ËË  0
.
ËË0 1
sinTime
ËË1 8
,
ËË8 9
sinTimeVector
ËË: G
)
ËËG H
;
ËËH I
cmd
ÈÈ 
.
ÈÈ 
SetGlobalVector
ÈÈ 
(
ÈÈ  
ShaderPropertyId
ÈÈ  0
.
ÈÈ0 1
cosTime
ÈÈ1 8
,
ÈÈ8 9
cosTimeVector
ÈÈ: G
)
ÈÈG H
;
ÈÈH I
cmd
ÍÍ 
.
ÍÍ 
SetGlobalVector
ÍÍ 
(
ÍÍ  
ShaderPropertyId
ÍÍ  0
.
ÍÍ0 1
	deltaTime
ÍÍ1 :
,
ÍÍ: ;
deltaTimeVector
ÍÍ< K
)
ÍÍK L
;
ÍÍL M
cmd
ÎÎ 
.
ÎÎ 
SetGlobalVector
ÎÎ 
(
ÎÎ  
ShaderPropertyId
ÎÎ  0
.
ÎÎ0 1
timeParameters
ÎÎ1 ?
,
ÎÎ? @"
timeParametersVector
ÎÎA U
)
ÎÎU V
;
ÎÎV W
}
ÏÏ 	
public
ÛÛ $
RenderTargetIdentifier
ÛÛ %
cameraColorTarget
ÛÛ& 7
{
ÙÙ 	
get
ıı 
{
ˆˆ 
if
˜˜ 
(
˜˜ 
!
˜˜ 
(
˜˜ #
m_IsPipelineExecuting
˜˜ +
||
˜˜, .&
isCameraColorTargetValid
˜˜/ G
)
˜˜G H
)
˜˜H I
{
¯¯ 
Debug
˘˘ 
.
˘˘ 

LogWarning
˘˘ $
(
˘˘$ %
$str˘˘% ‰
)˘˘‰ Â
;˘˘Â Ê
}
¸¸ 
return
˛˛ !
m_CameraColorTarget
˛˛ *
;
˛˛* +
}
ˇˇ 
}
ÄÄ 	
public
áá $
RenderTargetIdentifier
áá %
cameraDepthTarget
áá& 7
{
àà 	
get
ââ 
{
ää 
if
ãã 
(
ãã 
!
ãã #
m_IsPipelineExecuting
ãã *
)
ãã* +
{
åå 
Debug
çç 
.
çç 

LogWarning
çç $
(
çç$ %
$strçç% ‰
)çç‰ Â
;ççÂ Ê
}
êê 
return
íí !
m_CameraDepthTarget
íí *
;
íí* +
}
ìì 
}
îî 	
	protected
öö 
List
öö 
<
öö '
ScriptableRendererFeature
öö 0
>
öö0 1
rendererFeatures
öö2 B
{
õõ 	
get
úú 
=>
úú  
m_RendererFeatures
úú %
;
úú% &
}
ùù 	
	protected
££ 
List
££ 
<
££ "
ScriptableRenderPass
££ +
>
££+ ,#
activeRenderPassQueue
££- B
{
§§ 	
get
•• 
=>
•• %
m_ActiveRenderPassQueue
•• *
;
••* +
}
¶¶ 	
public
¨¨ 
RenderingFeatures
¨¨  (
supportedRenderingFeatures
¨¨! ;
{
¨¨< =
get
¨¨> A
;
¨¨A B
set
¨¨C F
;
¨¨F G
}
¨¨H I
=
¨¨J K
new
¨¨L O
RenderingFeatures
¨¨P a
(
¨¨a b
)
¨¨b c
;
¨¨c d
public
≤≤  
GraphicsDeviceType
≤≤ !
[
≤≤! "
]
≤≤" #,
unsupportedGraphicsDeviceTypes
≤≤$ B
{
≤≤C D
get
≤≤E H
;
≤≤H I
set
≤≤J M
;
≤≤M N
}
≤≤O P
=
≤≤Q R
new
≤≤S V 
GraphicsDeviceType
≤≤W i
[
≤≤i j
$num
≤≤j k
]
≤≤k l
;
≤≤l m
static
¥¥ 
class
¥¥ 
RenderPassBlock
¥¥ $
{
µµ 	
public
∏∏ 
static
∏∏ 
readonly
∏∏ "
int
∏∏# &
BeforeRendering
∏∏' 6
=
∏∏7 8
$num
∏∏9 :
;
∏∏: ;
public
ºº 
static
ºº 
readonly
ºº "
int
ºº# &!
MainRenderingOpaque
ºº' :
=
ºº; <
$num
ºº= >
;
ºº> ?
public
ΩΩ 
static
ΩΩ 
readonly
ΩΩ "
int
ΩΩ# &&
MainRenderingTransparent
ΩΩ' ?
=
ΩΩ@ A
$num
ΩΩB C
;
ΩΩC D
public
¿¿ 
static
¿¿ 
readonly
¿¿ "
int
¿¿# &
AfterRendering
¿¿' 5
=
¿¿6 7
$num
¿¿8 9
;
¿¿9 :
}
¡¡ 	
const
√√ 
int
√√ $
k_RenderPassBlockCount
√√ (
=
√√) *
$num
√√+ ,
;
√√, -
List
≈≈ 
<
≈≈ "
ScriptableRenderPass
≈≈ !
>
≈≈! "%
m_ActiveRenderPassQueue
≈≈# :
=
≈≈; <
new
≈≈= @
List
≈≈A E
<
≈≈E F"
ScriptableRenderPass
≈≈F Z
>
≈≈Z [
(
≈≈[ \
$num
≈≈\ ^
)
≈≈^ _
;
≈≈_ `
List
∆∆ 
<
∆∆ '
ScriptableRendererFeature
∆∆ &
>
∆∆& ' 
m_RendererFeatures
∆∆( :
=
∆∆; <
new
∆∆= @
List
∆∆A E
<
∆∆E F'
ScriptableRendererFeature
∆∆F _
>
∆∆_ `
(
∆∆` a
$num
∆∆a c
)
∆∆c d
;
∆∆d e$
RenderTargetIdentifier
«« !
m_CameraColorTarget
«« 2
;
««2 3$
RenderTargetIdentifier
»» !
m_CameraDepthTarget
»» 2
;
»»2 3
bool
   1
#m_FirstTimeCameraColorTargetIsBound
   0
=
  1 2
true
  3 7
;
  7 8
bool
ÀÀ 1
#m_FirstTimeCameraDepthTargetIsBound
ÀÀ 0
=
ÀÀ1 2
true
ÀÀ3 7
;
ÀÀ7 8
bool
œœ #
m_IsPipelineExecuting
œœ "
=
œœ# $
false
œœ% *
;
œœ* +
internal
—— 
bool
—— &
isCameraColorTargetValid
—— .
=
——/ 0
false
——1 6
;
——6 7
static
”” $
RenderTargetIdentifier
”” %
[
””% &
]
””& '&
m_ActiveColorAttachments
””( @
=
””A B
new
””C F$
RenderTargetIdentifier
””G ]
[
””] ^
]
””^ _
{
””_ `
$num
””` a
,
””a b
$num
””c d
,
””d e
$num
””f g
,
””g h
$num
””i j
,
””j k
$num
””l m
,
””m n
$num
””o p
,
””p q
$num
””r s
,
””s t
$num
””u v
}
””w x
;
””x y
static
‘‘ $
RenderTargetIdentifier
‘‘ %%
m_ActiveDepthAttachment
‘‘& =
;
‘‘= >
static
⁄⁄ $
RenderTargetIdentifier
⁄⁄ %
[
⁄⁄% &
]
⁄⁄& '
[
⁄⁄' (
]
⁄⁄( ),
m_TrimmedColorAttachmentCopies
⁄⁄* H
=
⁄⁄I J
new
⁄⁄K N$
RenderTargetIdentifier
⁄⁄O e
[
⁄⁄e f
]
⁄⁄f g
[
⁄⁄g h
]
⁄⁄h i
{
€€ 	
new
‹‹ $
RenderTargetIdentifier
‹‹ &
[
‹‹& '
$num
‹‹' (
]
‹‹( )
,
‹‹) *
new
›› $
RenderTargetIdentifier
›› &
[
››& '
]
››' (
{
››( )
$num
››) *
}
››* +
,
››+ ,
new
ﬁﬁ $
RenderTargetIdentifier
ﬁﬁ &
[
ﬁﬁ& '
]
ﬁﬁ' (
{
ﬁﬁ( )
$num
ﬁﬁ) *
,
ﬁﬁ* +
$num
ﬁﬁ, -
}
ﬁﬁ- .
,
ﬁﬁ. /
new
ﬂﬂ $
RenderTargetIdentifier
ﬂﬂ &
[
ﬂﬂ& '
]
ﬂﬂ' (
{
ﬂﬂ( )
$num
ﬂﬂ) *
,
ﬂﬂ* +
$num
ﬂﬂ, -
,
ﬂﬂ- .
$num
ﬂﬂ/ 0
}
ﬂﬂ0 1
,
ﬂﬂ1 2
new
‡‡ $
RenderTargetIdentifier
‡‡ &
[
‡‡& '
]
‡‡' (
{
‡‡( )
$num
‡‡) *
,
‡‡* +
$num
‡‡, -
,
‡‡- .
$num
‡‡/ 0
,
‡‡0 1
$num
‡‡2 3
}
‡‡3 4
,
‡‡4 5
new
·· $
RenderTargetIdentifier
·· &
[
··& '
]
··' (
{
··( )
$num
··) *
,
··* +
$num
··, -
,
··- .
$num
··/ 0
,
··0 1
$num
··2 3
,
··3 4
$num
··5 6
}
··6 7
,
··7 8
new
‚‚ $
RenderTargetIdentifier
‚‚ &
[
‚‚& '
]
‚‚' (
{
‚‚( )
$num
‚‚) *
,
‚‚* +
$num
‚‚, -
,
‚‚- .
$num
‚‚/ 0
,
‚‚0 1
$num
‚‚2 3
,
‚‚3 4
$num
‚‚5 6
,
‚‚6 7
$num
‚‚8 9
}
‚‚9 :
,
‚‚: ;
new
„„ $
RenderTargetIdentifier
„„ &
[
„„& '
]
„„' (
{
„„( )
$num
„„) *
,
„„* +
$num
„„, -
,
„„- .
$num
„„/ 0
,
„„0 1
$num
„„2 3
,
„„3 4
$num
„„5 6
,
„„6 7
$num
„„8 9
,
„„9 :
$num
„„; <
}
„„< =
,
„„= >
new
‰‰ $
RenderTargetIdentifier
‰‰ &
[
‰‰& '
]
‰‰' (
{
‰‰( )
$num
‰‰) *
,
‰‰* +
$num
‰‰, -
,
‰‰- .
$num
‰‰/ 0
,
‰‰0 1
$num
‰‰2 3
,
‰‰3 4
$num
‰‰5 6
,
‰‰6 7
$num
‰‰8 9
,
‰‰9 :
$num
‰‰; <
,
‰‰< =
$num
‰‰> ?
}
‰‰@ A
,
‰‰A B
}
ÂÂ 	
;
ÂÂ	 

internal
ÁÁ 
static
ÁÁ 
void
ÁÁ #
ConfigureActiveTarget
ÁÁ 2
(
ÁÁ2 3$
RenderTargetIdentifier
ÁÁ3 I
colorAttachment
ÁÁJ Y
,
ÁÁY Z$
RenderTargetIdentifier
ËË "
depthAttachment
ËË# 2
)
ËË2 3
{
ÈÈ 	&
m_ActiveColorAttachments
ÍÍ $
[
ÍÍ$ %
$num
ÍÍ% &
]
ÍÍ& '
=
ÍÍ( )
colorAttachment
ÍÍ* 9
;
ÍÍ9 :
for
ÎÎ 
(
ÎÎ 
int
ÎÎ 
i
ÎÎ 
=
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
i
ÎÎ 
<
ÎÎ &
m_ActiveColorAttachments
ÎÎ  8
.
ÎÎ8 9
Length
ÎÎ9 ?
;
ÎÎ? @
++
ÎÎA C
i
ÎÎC D
)
ÎÎD E&
m_ActiveColorAttachments
ÏÏ (
[
ÏÏ( )
i
ÏÏ) *
]
ÏÏ* +
=
ÏÏ, -
$num
ÏÏ. /
;
ÏÏ/ 0%
m_ActiveDepthAttachment
ÓÓ #
=
ÓÓ$ %
depthAttachment
ÓÓ& 5
;
ÓÓ5 6
}
ÔÔ 	
public
ÒÒ  
ScriptableRenderer
ÒÒ !
(
ÒÒ! "$
ScriptableRendererData
ÒÒ" 8
data
ÒÒ9 =
)
ÒÒ= >
{
ÚÚ 	
profilingExecute
ÛÛ 
=
ÛÛ 
new
ÛÛ "
ProfilingSampler
ÛÛ# 3
(
ÛÛ3 4
$"
ÛÛ4 6
{
ÛÛ6 7
nameof
ÛÛ7 =
(
ÛÛ= > 
ScriptableRenderer
ÛÛ> P
)
ÛÛP Q
}
ÛÛQ R
.
ÛÛR S
{
ÛÛS T
nameof
ÛÛT Z
(
ÛÛZ [ 
ScriptableRenderer
ÛÛ[ m
.
ÛÛm n
Execute
ÛÛn u
)
ÛÛu v
}
ÛÛv w
: 
ÛÛw y
{
ÛÛy z
data
ÛÛz ~
.
ÛÛ~ 
nameÛÛ É
}ÛÛÉ Ñ
"ÛÛÑ Ö
)ÛÛÖ Ü
;ÛÛÜ á
foreach
ıı 
(
ıı 
var
ıı 
feature
ıı  
in
ıı! #
data
ıı$ (
.
ıı( )
rendererFeatures
ıı) 9
)
ıı9 :
{
ˆˆ 
if
˜˜ 
(
˜˜ 
feature
˜˜ 
==
˜˜ 
null
˜˜ #
)
˜˜# $
continue
¯¯ 
;
¯¯ 
feature
˙˙ 
.
˙˙ 
Create
˙˙ 
(
˙˙ 
)
˙˙  
;
˙˙  ! 
m_RendererFeatures
˚˚ "
.
˚˚" #
Add
˚˚# &
(
˚˚& '
feature
˚˚' .
)
˚˚. /
;
˚˚/ 0
}
¸¸ 
Clear
˝˝ 
(
˝˝ 
CameraRenderType
˝˝ "
.
˝˝" #
Base
˝˝# '
)
˝˝' (
;
˝˝( )
}
˛˛ 	
public
ÄÄ 
void
ÄÄ 
Dispose
ÄÄ 
(
ÄÄ 
)
ÄÄ 
{
ÅÅ 	
for
ÉÉ 
(
ÉÉ 
int
ÉÉ 
i
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
;
ÉÉ 
i
ÉÉ 
<
ÉÉ  
m_RendererFeatures
ÉÉ  2
.
ÉÉ2 3
Count
ÉÉ3 8
;
ÉÉ8 9
++
ÉÉ: <
i
ÉÉ< =
)
ÉÉ= >
{
ÑÑ 
if
ÖÖ 
(
ÖÖ 
rendererFeatures
ÖÖ $
[
ÖÖ$ %
i
ÖÖ% &
]
ÖÖ& '
==
ÖÖ( *
null
ÖÖ+ /
)
ÖÖ/ 0
continue
ÜÜ 
;
ÜÜ 
rendererFeatures
àà  
[
àà  !
i
àà! "
]
àà" #
.
àà# $
Dispose
àà$ +
(
àà+ ,
)
àà, -
;
àà- .
}
ââ 
Dispose
ãã 
(
ãã 
true
ãã 
)
ãã 
;
ãã 
GC
åå 
.
åå 
SuppressFinalize
åå 
(
åå  
this
åå  $
)
åå$ %
;
åå% &
}
çç 	
	protected
èè 
virtual
èè 
void
èè 
Dispose
èè &
(
èè& '
bool
èè' +
	disposing
èè, 5
)
èè5 6
{
êê 	
}
ëë 	
public
òò 
void
òò #
ConfigureCameraTarget
òò )
(
òò) *$
RenderTargetIdentifier
òò* @
colorTarget
òòA L
,
òòL M$
RenderTargetIdentifier
òòN d
depthTarget
òòe p
)
òòp q
{
ôô 	!
m_CameraColorTarget
öö 
=
öö  !
colorTarget
öö" -
;
öö- .!
m_CameraDepthTarget
õõ 
=
õõ  !
depthTarget
õõ" -
;
õõ- .
}
úú 	
internal
üü 
void
üü (
ConfigureCameraColorTarget
üü 0
(
üü0 1$
RenderTargetIdentifier
üü1 G
colorTarget
üüH S
)
üüS T
{
†† 	!
m_CameraColorTarget
°° 
=
°°  !
colorTarget
°°" -
;
°°- .
}
¢¢ 	
public
¨¨ 
abstract
¨¨ 
void
¨¨ 
Setup
¨¨ "
(
¨¨" #%
ScriptableRenderContext
¨¨# :
context
¨¨; B
,
¨¨B C
ref
¨¨D G
RenderingData
¨¨H U
renderingData
¨¨V c
)
¨¨c d
;
¨¨d e
public
¥¥ 
virtual
¥¥ 
void
¥¥ 
SetupLights
¥¥ '
(
¥¥' (%
ScriptableRenderContext
¥¥( ?
context
¥¥@ G
,
¥¥G H
ref
¥¥I L
RenderingData
¥¥M Z
renderingData
¥¥[ h
)
¥¥h i
{
µµ 	
}
∂∂ 	
public
ææ 
virtual
ææ 
void
ææ $
SetupCullingParameters
ææ 2
(
ææ2 3
ref
ææ3 6)
ScriptableCullingParameters
ææ7 R
cullingParameters
ææS d
,
ææd e
ref
øø 

CameraData
øø 

cameraData
øø %
)
øø% &
{
¿¿ 	
}
¡¡ 	
public
«« 
virtual
«« 
void
«« 
FinishRendering
«« +
(
««+ ,
CommandBuffer
««, 9
cmd
««: =
)
««= >
{
»» 	
}
…… 	
public
–– 
void
–– 
Execute
–– 
(
–– %
ScriptableRenderContext
–– 3
context
––4 ;
,
––; <
ref
––= @
RenderingData
––A N
renderingData
––O \
)
––\ ]
{
—— 	#
m_IsPipelineExecuting
““ !
=
““" #
true
““$ (
;
““( )
ref
”” 

CameraData
”” 

cameraData
”” %
=
””& '
ref
””( +
renderingData
””, 9
.
””9 :

cameraData
””: D
;
””D E
Camera
‘‘ 
camera
‘‘ 
=
‘‘ 

cameraData
‘‘ &
.
‘‘& '
camera
‘‘' -
;
‘‘- .
CommandBuffer
÷÷ 
cmd
÷÷ 
=
÷÷ 
CommandBufferPool
÷÷  1
.
÷÷1 2
Get
÷÷2 5
(
÷÷5 6
)
÷÷6 7
;
÷÷7 8
using
◊◊ 
(
◊◊ 
new
◊◊ 
ProfilingScope
◊◊ %
(
◊◊% &
cmd
◊◊& )
,
◊◊) *
profilingExecute
◊◊+ ;
)
◊◊; <
)
◊◊< =
{
ÿÿ $
InternalStartRendering
ŸŸ &
(
ŸŸ& '
context
ŸŸ' .
,
ŸŸ. /
ref
ŸŸ0 3
renderingData
ŸŸ4 A
)
ŸŸA B
;
ŸŸB C
float
‡‡ 
time
‡‡ 
=
‡‡ 
Application
‡‡ (
.
‡‡( )
	isPlaying
‡‡) 2
?
‡‡3 4
Time
‡‡5 9
.
‡‡9 :
time
‡‡: >
:
‡‡? @
Time
‡‡A E
.
‡‡E F"
realtimeSinceStartup
‡‡F Z
;
‡‡Z [
float
‰‰ 
	deltaTime
‰‰ 
=
‰‰  !
Time
‰‰" &
.
‰‰& '
	deltaTime
‰‰' 0
;
‰‰0 1
float
ÂÂ 
smoothDeltaTime
ÂÂ %
=
ÂÂ& '
Time
ÂÂ( ,
.
ÂÂ, -
smoothDeltaTime
ÂÂ- <
;
ÂÂ< =!
ClearRenderingState
ËË #
(
ËË# $
cmd
ËË$ '
)
ËË' (
;
ËË( ))
SetPerCameraShaderVariables
ÈÈ +
(
ÈÈ+ ,
cmd
ÈÈ, /
,
ÈÈ/ 0
ref
ÈÈ1 4

cameraData
ÈÈ5 ?
)
ÈÈ? @
;
ÈÈ@ A!
SetShaderTimeValues
ÍÍ #
(
ÍÍ# $
cmd
ÍÍ$ '
,
ÍÍ' (
time
ÍÍ) -
,
ÍÍ- .
	deltaTime
ÍÍ/ 8
,
ÍÍ8 9
smoothDeltaTime
ÍÍ: I
)
ÍÍI J
;
ÍÍJ K
context
ÎÎ 
.
ÎÎ "
ExecuteCommandBuffer
ÎÎ ,
(
ÎÎ, -
cmd
ÎÎ- 0
)
ÎÎ0 1
;
ÎÎ1 2
cmd
ÏÏ 
.
ÏÏ 
Clear
ÏÏ 
(
ÏÏ 
)
ÏÏ 
;
ÏÏ 
using
ÌÌ 
(
ÌÌ 
new
ÌÌ 
ProfilingScope
ÌÌ )
(
ÌÌ) *
cmd
ÌÌ* -
,
ÌÌ- .
	Profiling
ÌÌ/ 8
.
ÌÌ8 9
sortRenderPasses
ÌÌ9 I
)
ÌÌI J
)
ÌÌJ K
{
ÓÓ 

SortStable
 
(
 %
m_ActiveRenderPassQueue
 6
)
6 7
;
7 8
}
ÒÒ 
using
ÛÛ 
var
ÛÛ 
renderBlocks
ÛÛ &
=
ÛÛ' (
new
ÛÛ) ,
RenderBlocks
ÛÛ- 9
(
ÛÛ9 :%
m_ActiveRenderPassQueue
ÛÛ: Q
)
ÛÛQ R
;
ÛÛR S
using
ıı 
(
ıı 
new
ıı 
ProfilingScope
ıı )
(
ıı) *
cmd
ıı* -
,
ıı- .
	Profiling
ıı/ 8
.
ıı8 9
setupLights
ıı9 D
)
ııD E
)
ııE F
{
ˆˆ 
SetupLights
˜˜ 
(
˜˜  
context
˜˜  '
,
˜˜' (
ref
˜˜) ,
renderingData
˜˜- :
)
˜˜: ;
;
˜˜; <
}
¯¯ 
using
˙˙ 
(
˙˙ 
new
˙˙ 
ProfilingScope
˙˙ )
(
˙˙) *
cmd
˙˙* -
,
˙˙- .
	Profiling
˙˙/ 8
.
˙˙8 9
RenderBlock
˙˙9 D
.
˙˙D E
beforeRendering
˙˙E T
)
˙˙T U
)
˙˙U V
{
˚˚ 
ExecuteBlock
ˇˇ  
(
ˇˇ  !
RenderPassBlock
ˇˇ! 0
.
ˇˇ0 1
BeforeRendering
ˇˇ1 @
,
ˇˇ@ A
in
ˇˇB D
renderBlocks
ˇˇE Q
,
ˇˇQ R
context
ˇˇS Z
,
ˇˇZ [
ref
ˇˇ\ _
renderingData
ˇˇ` m
)
ˇˇm n
;
ˇˇn o
}
ÄÄ 
using
ÇÇ 
(
ÇÇ 
new
ÇÇ 
ProfilingScope
ÇÇ )
(
ÇÇ) *
cmd
ÇÇ* -
,
ÇÇ- .
	Profiling
ÇÇ/ 8
.
ÇÇ8 9
setupCamera
ÇÇ9 D
)
ÇÇD E
)
ÇÇE F
{
ÉÉ 
context
åå 
.
åå #
SetupCameraProperties
åå 1
(
åå1 2
camera
åå2 8
)
åå8 9
;
åå9 :
SetCameraMatrices
çç %
(
çç% &
cmd
çç& )
,
çç) *
ref
çç+ .

cameraData
çç/ 9
,
çç9 :
true
çç; ?
)
çç? @
;
çç@ A!
SetShaderTimeValues
êê '
(
êê' (
cmd
êê( +
,
êê+ ,
time
êê- 1
,
êê1 2
	deltaTime
êê3 <
,
êê< =
smoothDeltaTime
êê> M
)
êêM N
;
êêN O
}
ññ 
context
òò 
.
òò "
ExecuteCommandBuffer
òò ,
(
òò, -
cmd
òò- 0
)
òò0 1
;
òò1 2
cmd
ôô 
.
ôô 
Clear
ôô 
(
ôô 
)
ôô 
;
ôô 
BeginXRRendering
õõ  
(
õõ  !
cmd
õõ! $
,
õõ$ %
context
õõ& -
,
õõ- .
ref
õõ/ 2
renderingData
õõ3 @
.
õõ@ A

cameraData
õõA K
)
õõK L
;
õõL M
if
†† 
(
†† 
renderBlocks
††  
.
††  !
	GetLength
††! *
(
††* +
RenderPassBlock
††+ :
.
††: ;!
MainRenderingOpaque
††; N
)
††N O
>
††P Q
$num
††R S
)
††S T
{
°° 
using
¢¢ 
var
¢¢ 
	profScope
¢¢ '
=
¢¢( )
new
¢¢* -
ProfilingScope
¢¢. <
(
¢¢< =
cmd
¢¢= @
,
¢¢@ A
	Profiling
¢¢B K
.
¢¢K L
RenderBlock
¢¢L W
.
¢¢W X!
mainRenderingOpaque
¢¢X k
)
¢¢k l
;
¢¢l m
ExecuteBlock
££  
(
££  !
RenderPassBlock
££! 0
.
££0 1!
MainRenderingOpaque
££1 D
,
££D E
in
££F H
renderBlocks
££I U
,
££U V
context
££W ^
,
££^ _
ref
££` c
renderingData
££d q
)
££q r
;
££r s
}
§§ 
if
ßß 
(
ßß 
renderBlocks
ßß  
.
ßß  !
	GetLength
ßß! *
(
ßß* +
RenderPassBlock
ßß+ :
.
ßß: ;&
MainRenderingTransparent
ßß; S
)
ßßS T
>
ßßU V
$num
ßßW X
)
ßßX Y
{
®® 
using
©© 
var
©© 
	profScope
©© '
=
©©( )
new
©©* -
ProfilingScope
©©. <
(
©©< =
cmd
©©= @
,
©©@ A
	Profiling
©©B K
.
©©K L
RenderBlock
©©L W
.
©©W X&
mainRenderingTransparent
©©X p
)
©©p q
;
©©q r
ExecuteBlock
™™  
(
™™  !
RenderPassBlock
™™! 0
.
™™0 1&
MainRenderingTransparent
™™1 I
,
™™I J
in
™™K M
renderBlocks
™™N Z
,
™™Z [
context
™™\ c
,
™™c d
ref
™™e h
renderingData
™™i v
)
™™v w
;
™™w x
}
´´ 

DrawGizmos
ÆÆ 
(
ÆÆ 
context
ÆÆ "
,
ÆÆ" #
camera
ÆÆ$ *
,
ÆÆ* +
GizmoSubset
ÆÆ, 7
.
ÆÆ7 8
PreImageEffects
ÆÆ8 G
)
ÆÆG H
;
ÆÆH I
if
±± 
(
±± 
renderBlocks
±±  
.
±±  !
	GetLength
±±! *
(
±±* +
RenderPassBlock
±±+ :
.
±±: ;
AfterRendering
±±; I
)
±±I J
>
±±K L
$num
±±M N
)
±±N O
{
≤≤ 
using
≥≥ 
var
≥≥ 
	profScope
≥≥ '
=
≥≥( )
new
≥≥* -
ProfilingScope
≥≥. <
(
≥≥< =
cmd
≥≥= @
,
≥≥@ A
	Profiling
≥≥B K
.
≥≥K L
RenderBlock
≥≥L W
.
≥≥W X
afterRendering
≥≥X f
)
≥≥f g
;
≥≥g h
ExecuteBlock
¥¥  
(
¥¥  !
RenderPassBlock
¥¥! 0
.
¥¥0 1
AfterRendering
¥¥1 ?
,
¥¥? @
in
¥¥A C
renderBlocks
¥¥D P
,
¥¥P Q
context
¥¥R Y
,
¥¥Y Z
ref
¥¥[ ^
renderingData
¥¥_ l
)
¥¥l m
;
¥¥m n
}
µµ 
EndXRRendering
∑∑ 
(
∑∑ 
cmd
∑∑ "
,
∑∑" #
context
∑∑$ +
,
∑∑+ ,
ref
∑∑- 0
renderingData
∑∑1 >
.
∑∑> ?

cameraData
∑∑? I
)
∑∑I J
;
∑∑J K
DrawWireOverlay
ππ 
(
ππ  
context
ππ  '
,
ππ' (
camera
ππ) /
)
ππ/ 0
;
ππ0 1

DrawGizmos
∫∫ 
(
∫∫ 
context
∫∫ "
,
∫∫" #
camera
∫∫$ *
,
∫∫* +
GizmoSubset
∫∫, 7
.
∫∫7 8
PostImageEffects
∫∫8 H
)
∫∫H I
;
∫∫I J%
InternalFinishRendering
ºº '
(
ºº' (
context
ºº( /
,
ºº/ 0

cameraData
ºº1 ;
.
ºº; < 
resolveFinalTarget
ºº< N
)
ººN O
;
ººO P
}
ΩΩ 
context
øø 
.
øø "
ExecuteCommandBuffer
øø (
(
øø( )
cmd
øø) ,
)
øø, -
;
øø- .
CommandBufferPool
¿¿ 
.
¿¿ 
Release
¿¿ %
(
¿¿% &
cmd
¿¿& )
)
¿¿) *
;
¿¿* +
}
¡¡ 	
public
«« 
void
«« 
EnqueuePass
«« 
(
««  "
ScriptableRenderPass
««  4
pass
««5 9
)
««9 :
{
»» 	%
m_ActiveRenderPassQueue
…… #
.
……# $
Add
……$ '
(
……' (
pass
……( ,
)
……, -
;
……- .
}
   	
	protected
—— 
static
—— 
	ClearFlag
—— " 
GetCameraClearFlag
——# 5
(
——5 6
ref
——6 9

CameraData
——: D

cameraData
——E O
)
——O P
{
““ 	
var
”” 
cameraClearFlags
””  
=
””! "

cameraData
””# -
.
””- .
camera
””. 4
.
””4 5

clearFlags
””5 ?
;
””? @
if
ÍÍ 
(
ÍÍ 

cameraData
ÍÍ 
.
ÍÍ 

renderType
ÍÍ %
==
ÍÍ& (
CameraRenderType
ÍÍ) 9
.
ÍÍ9 :
Overlay
ÍÍ: A
)
ÍÍA B
return
ÎÎ 
(
ÎÎ 

cameraData
ÎÎ "
.
ÎÎ" #

clearDepth
ÎÎ# -
)
ÎÎ- .
?
ÎÎ/ 0
	ClearFlag
ÎÎ1 :
.
ÎÎ: ;
Depth
ÎÎ; @
:
ÎÎA B
	ClearFlag
ÎÎC L
.
ÎÎL M
None
ÎÎM Q
;
ÎÎQ R
if
ÓÓ 
(
ÓÓ 
Application
ÓÓ 
.
ÓÓ 
isMobilePlatform
ÓÓ ,
)
ÓÓ, -
return
ÔÔ 
	ClearFlag
ÔÔ  
.
ÔÔ  !
All
ÔÔ! $
;
ÔÔ$ %
if
ÒÒ 
(
ÒÒ 
(
ÒÒ 
cameraClearFlags
ÒÒ !
==
ÒÒ" $
CameraClearFlags
ÒÒ% 5
.
ÒÒ5 6
Skybox
ÒÒ6 <
&&
ÒÒ= ?
RenderSettings
ÒÒ@ N
.
ÒÒN O
skybox
ÒÒO U
!=
ÒÒV X
null
ÒÒY ]
)
ÒÒ] ^
||
ÒÒ_ a
cameraClearFlags
ÚÚ  
==
ÚÚ! #
CameraClearFlags
ÚÚ$ 4
.
ÚÚ4 5
Nothing
ÚÚ5 <
)
ÚÚ< =
return
ÛÛ 
	ClearFlag
ÛÛ  
.
ÛÛ  !
Depth
ÛÛ! &
;
ÛÛ& '
return
ıı 
	ClearFlag
ıı 
.
ıı 
All
ıı  
;
ıı  !
}
ˆˆ 	
	protected
˝˝ 
void
˝˝ 
AddRenderPasses
˝˝ &
(
˝˝& '
ref
˝˝' *
RenderingData
˝˝+ 8
renderingData
˝˝9 F
)
˝˝F G
{
˛˛ 	
using
ˇˇ 
var
ˇˇ 
	profScope
ˇˇ 
=
ˇˇ  !
new
ˇˇ" %
ProfilingScope
ˇˇ& 4
(
ˇˇ4 5
null
ˇˇ5 9
,
ˇˇ9 :
	Profiling
ˇˇ; D
.
ˇˇD E
addRenderPasses
ˇˇE T
)
ˇˇT U
;
ˇˇU V
for
ÇÇ 
(
ÇÇ 
int
ÇÇ 
i
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
;
ÇÇ 
i
ÇÇ 
<
ÇÇ 
rendererFeatures
ÇÇ  0
.
ÇÇ0 1
Count
ÇÇ1 6
;
ÇÇ6 7
++
ÇÇ8 :
i
ÇÇ: ;
)
ÇÇ; <
{
ÉÉ 
if
ÑÑ 
(
ÑÑ 
!
ÑÑ 
rendererFeatures
ÑÑ %
[
ÑÑ% &
i
ÑÑ& '
]
ÑÑ' (
.
ÑÑ( )
isActive
ÑÑ) 1
)
ÑÑ1 2
{
ÖÖ 
continue
ÜÜ 
;
ÜÜ 
}
áá 
rendererFeatures
àà  
[
àà  !
i
àà! "
]
àà" #
.
àà# $
AddRenderPasses
àà$ 3
(
àà3 4
this
àà4 8
,
àà8 9
ref
àà: =
renderingData
àà> K
)
ààK L
;
ààL M
}
ââ 
int
åå 
count
åå 
=
åå #
activeRenderPassQueue
åå -
.
åå- .
Count
åå. 3
;
åå3 4
for
çç 
(
çç 
int
çç 
i
çç 
=
çç 
count
çç 
-
çç  
$num
çç! "
;
çç" #
i
çç$ %
>=
çç& (
$num
çç) *
;
çç* +
i
çç, -
--
çç- /
)
çç/ 0
{
éé 
if
èè 
(
èè #
activeRenderPassQueue
èè )
[
èè) *
i
èè* +
]
èè+ ,
==
èè- /
null
èè0 4
)
èè4 5#
activeRenderPassQueue
êê )
.
êê) *
RemoveAt
êê* 2
(
êê2 3
i
êê3 4
)
êê4 5
;
êê5 6
}
ëë 
}
íí 	
void
îî !
ClearRenderingState
îî  
(
îî  !
CommandBuffer
îî! .
cmd
îî/ 2
)
îî2 3
{
ïï 	
using
ññ 
var
ññ 
	profScope
ññ 
=
ññ  !
new
ññ" %
ProfilingScope
ññ& 4
(
ññ4 5
cmd
ññ5 8
,
ññ8 9
	Profiling
ññ: C
.
ññC D!
clearRenderingState
ññD W
)
ññW X
;
ññX Y
cmd
ôô 
.
ôô "
DisableShaderKeyword
ôô $
(
ôô$ %"
ShaderKeywordStrings
ôô% 9
.
ôô9 :
MainLightShadows
ôô: J
)
ôôJ K
;
ôôK L
cmd
öö 
.
öö "
DisableShaderKeyword
öö $
(
öö$ %"
ShaderKeywordStrings
öö% 9
.
öö9 :%
MainLightShadowCascades
öö: Q
)
ööQ R
;
ööR S
cmd
õõ 
.
õõ "
DisableShaderKeyword
õõ $
(
õõ$ %"
ShaderKeywordStrings
õõ% 9
.
õõ9 :$
AdditionalLightsVertex
õõ: P
)
õõP Q
;
õõQ R
cmd
úú 
.
úú "
DisableShaderKeyword
úú $
(
úú$ %"
ShaderKeywordStrings
úú% 9
.
úú9 :#
AdditionalLightsPixel
úú: O
)
úúO P
;
úúP Q
cmd
ùù 
.
ùù "
DisableShaderKeyword
ùù $
(
ùù$ %"
ShaderKeywordStrings
ùù% 9
.
ùù9 :$
AdditionalLightShadows
ùù: P
)
ùùP Q
;
ùùQ R
cmd
ûû 
.
ûû "
DisableShaderKeyword
ûû $
(
ûû$ %"
ShaderKeywordStrings
ûû% 9
.
ûû9 :
SoftShadows
ûû: E
)
ûûE F
;
ûûF G
cmd
üü 
.
üü "
DisableShaderKeyword
üü $
(
üü$ %"
ShaderKeywordStrings
üü% 9
.
üü9 :&
MixedLightingSubtractive
üü: R
)
üüR S
;
üüS T
cmd
†† 
.
†† "
DisableShaderKeyword
†† $
(
††$ %"
ShaderKeywordStrings
††% 9
.
††9 :"
LightmapShadowMixing
††: N
)
††N O
;
††O P
cmd
°° 
.
°° "
DisableShaderKeyword
°° $
(
°°$ %"
ShaderKeywordStrings
°°% 9
.
°°9 :
ShadowsShadowMask
°°: K
)
°°K L
;
°°L M
cmd
¢¢ 
.
¢¢ "
DisableShaderKeyword
¢¢ $
(
¢¢$ %"
ShaderKeywordStrings
¢¢% 9
.
¢¢9 :$
LinearToSRGBConversion
¢¢: P
)
¢¢P Q
;
¢¢Q R
}
££ 	
internal
•• 
void
•• 
Clear
•• 
(
•• 
CameraRenderType
•• ,

cameraType
••- 7
)
••7 8
{
¶¶ 	&
m_ActiveColorAttachments
ßß $
[
ßß$ %
$num
ßß% &
]
ßß& '
=
ßß( )&
BuiltinRenderTextureType
ßß* B
.
ßßB C
CameraTarget
ßßC O
;
ßßO P
for
®® 
(
®® 
int
®® 
i
®® 
=
®® 
$num
®® 
;
®® 
i
®® 
<
®® &
m_ActiveColorAttachments
®®  8
.
®®8 9
Length
®®9 ?
;
®®? @
++
®®A C
i
®®C D
)
®®D E&
m_ActiveColorAttachments
©© (
[
©©( )
i
©©) *
]
©©* +
=
©©, -
$num
©©. /
;
©©/ 0%
m_ActiveDepthAttachment
´´ #
=
´´$ %&
BuiltinRenderTextureType
´´& >
.
´´> ?
CameraTarget
´´? K
;
´´K L1
#m_FirstTimeCameraColorTargetIsBound
≠≠ /
=
≠≠0 1

cameraType
≠≠2 <
==
≠≠= ?
CameraRenderType
≠≠@ P
.
≠≠P Q
Base
≠≠Q U
;
≠≠U V1
#m_FirstTimeCameraDepthTargetIsBound
ÆÆ /
=
ÆÆ0 1
true
ÆÆ2 6
;
ÆÆ6 7%
m_ActiveRenderPassQueue
∞∞ #
.
∞∞# $
Clear
∞∞$ )
(
∞∞) *
)
∞∞* +
;
∞∞+ ,!
m_CameraColorTarget
≤≤ 
=
≤≤  !&
BuiltinRenderTextureType
≤≤" :
.
≤≤: ;
CameraTarget
≤≤; G
;
≤≤G H!
m_CameraDepthTarget
≥≥ 
=
≥≥  !&
BuiltinRenderTextureType
≥≥" :
.
≥≥: ;
CameraTarget
≥≥; G
;
≥≥G H
}
¥¥ 	
void
∂∂ 
ExecuteBlock
∂∂ 
(
∂∂ 
int
∂∂ 

blockIndex
∂∂ (
,
∂∂( )
in
∂∂* ,
RenderBlocks
∂∂- 9
renderBlocks
∂∂: F
,
∂∂F G%
ScriptableRenderContext
∑∑ #
context
∑∑$ +
,
∑∑+ ,
ref
∑∑- 0
RenderingData
∑∑1 >
renderingData
∑∑? L
,
∑∑L M
bool
∑∑N R
submit
∑∑S Y
=
∑∑Z [
false
∑∑\ a
)
∑∑a b
{
∏∏ 	
foreach
ππ 
(
ππ 
int
ππ 
	currIndex
ππ "
in
ππ# %
renderBlocks
ππ& 2
.
ππ2 3
GetRange
ππ3 ;
(
ππ; <

blockIndex
ππ< F
)
ππF G
)
ππG H
{
∫∫ 
var
ªª 

renderPass
ªª 
=
ªª  %
m_ActiveRenderPassQueue
ªª! 8
[
ªª8 9
	currIndex
ªª9 B
]
ªªB C
;
ªªC D
ExecuteRenderPass
ºº !
(
ºº! "
context
ºº" )
,
ºº) *

renderPass
ºº+ 5
,
ºº5 6
ref
ºº7 :
renderingData
ºº; H
)
ººH I
;
ººI J
}
ΩΩ 
if
øø 
(
øø 
submit
øø 
)
øø 
context
¿¿ 
.
¿¿ 
Submit
¿¿ 
(
¿¿ 
)
¿¿  
;
¿¿  !
}
¡¡ 	
void
√√ 
ExecuteRenderPass
√√ 
(
√√ %
ScriptableRenderContext
√√ 6
context
√√7 >
,
√√> ?"
ScriptableRenderPass
√√@ T

renderPass
√√U _
,
√√_ `
ref
√√a d
RenderingData
√√e r
renderingData√√s Ä
)√√Ä Å
{
ƒƒ 	
using
≈≈ 
var
≈≈ 
	profScope
≈≈ 
=
≈≈  !
new
≈≈" %
ProfilingScope
≈≈& 4
(
≈≈4 5
null
≈≈5 9
,
≈≈9 :

renderPass
≈≈; E
.
≈≈E F
profilingSampler
≈≈F V
)
≈≈V W
;
≈≈W X
ref
«« 

CameraData
«« 

cameraData
«« %
=
««& '
ref
««( +
renderingData
««, 9
.
««9 :

cameraData
««: D
;
««D E
CommandBuffer
…… 
cmd
…… 
=
…… 
CommandBufferPool
……  1
.
……1 2
Get
……2 5
(
……5 6
)
……6 7
;
……7 8
using
ÃÃ 
(
ÃÃ 
new
ÃÃ 
ProfilingScope
ÃÃ %
(
ÃÃ% &
cmd
ÃÃ& )
,
ÃÃ) *
	Profiling
ÃÃ+ 4
.
ÃÃ4 5

RenderPass
ÃÃ5 ?
.
ÃÃ? @
	configure
ÃÃ@ I
)
ÃÃI J
)
ÃÃJ K
{
ÕÕ 

renderPass
ŒŒ 
.
ŒŒ 
	Configure
ŒŒ $
(
ŒŒ$ %
cmd
ŒŒ% (
,
ŒŒ( )

cameraData
ŒŒ* 4
.
ŒŒ4 5$
cameraTargetDescriptor
ŒŒ5 K
)
ŒŒK L
;
ŒŒL M&
SetRenderPassAttachments
œœ (
(
œœ( )
cmd
œœ) ,
,
œœ, -

renderPass
œœ. 8
,
œœ8 9
ref
œœ: =

cameraData
œœ> H
)
œœH I
;
œœI J
}
–– 
context
”” 
.
”” "
ExecuteCommandBuffer
”” (
(
””( )
cmd
””) ,
)
””, -
;
””- .
CommandBufferPool
‘‘ 
.
‘‘ 
Release
‘‘ %
(
‘‘% &
cmd
‘‘& )
)
‘‘) *
;
‘‘* +

renderPass
÷÷ 
.
÷÷ 
Execute
÷÷ 
(
÷÷ 
context
÷÷ &
,
÷÷& '
ref
÷÷( +
renderingData
÷÷, 9
)
÷÷9 :
;
÷÷: ;
}
◊◊ 	
void
ŸŸ &
SetRenderPassAttachments
ŸŸ %
(
ŸŸ% &
CommandBuffer
ŸŸ& 3
cmd
ŸŸ4 7
,
ŸŸ7 8"
ScriptableRenderPass
ŸŸ9 M

renderPass
ŸŸN X
,
ŸŸX Y
ref
ŸŸZ ]

CameraData
ŸŸ^ h

cameraData
ŸŸi s
)
ŸŸs t
{
⁄⁄ 	
Camera
€€ 
camera
€€ 
=
€€ 

cameraData
€€ &
.
€€& '
camera
€€' -
;
€€- .
	ClearFlag
‹‹ 
cameraClearFlag
‹‹ %
=
‹‹& ' 
GetCameraClearFlag
‹‹( :
(
‹‹: ;
ref
‹‹; >

cameraData
‹‹? I
)
‹‹I J
;
‹‹J K
uint
·· $
validColorBuffersCount
·· '
=
··( )
RenderingUtils
··* 8
.
··8 9&
GetValidColorBufferCount
··9 Q
(
··Q R

renderPass
··R \
.
··\ ]
colorAttachments
··] m
)
··m n
;
··n o
if
‚‚ 
(
‚‚ $
validColorBuffersCount
‚‚ &
==
‚‚' )
$num
‚‚* +
)
‚‚+ ,
return
„„ 
;
„„ 
if
ÊÊ 
(
ÊÊ 
RenderingUtils
ÊÊ 
.
ÊÊ 
IsMRT
ÊÊ $
(
ÊÊ$ %

renderPass
ÊÊ% /
.
ÊÊ/ 0
colorAttachments
ÊÊ0 @
)
ÊÊ@ A
)
ÊÊA B
{
ÁÁ 
bool
ÓÓ (
needCustomCameraColorClear
ÓÓ /
=
ÓÓ0 1
false
ÓÓ2 7
;
ÓÓ7 8
bool
ÔÔ (
needCustomCameraDepthClear
ÔÔ /
=
ÔÔ0 1
false
ÔÔ2 7
;
ÔÔ7 8
int
ÒÒ $
cameraColorTargetIndex
ÒÒ *
=
ÒÒ+ ,
RenderingUtils
ÒÒ- ;
.
ÒÒ; <
IndexOf
ÒÒ< C
(
ÒÒC D

renderPass
ÒÒD N
.
ÒÒN O
colorAttachments
ÒÒO _
,
ÒÒ_ `!
m_CameraColorTarget
ÒÒa t
)
ÒÒt u
;
ÒÒu v
if
ÚÚ 
(
ÚÚ $
cameraColorTargetIndex
ÚÚ *
!=
ÚÚ+ -
-
ÚÚ. /
$num
ÚÚ/ 0
&&
ÚÚ1 3
(
ÚÚ4 51
#m_FirstTimeCameraColorTargetIsBound
ÚÚ5 X
)
ÚÚX Y
)
ÚÚY Z
{
ÛÛ 1
#m_FirstTimeCameraColorTargetIsBound
ÙÙ 7
=
ÙÙ8 9
false
ÙÙ: ?
;
ÙÙ? @(
needCustomCameraColorClear
˝˝ .
=
˝˝/ 0
(
˝˝1 2
cameraClearFlag
˝˝2 A
&
˝˝B C
	ClearFlag
˝˝D M
.
˝˝M N
Color
˝˝N S
)
˝˝S T
!=
˝˝U W
(
˝˝X Y

renderPass
˝˝Y c
.
˝˝c d
	clearFlag
˝˝d m
&
˝˝n o
	ClearFlag
˝˝p y
.
˝˝y z
Color
˝˝z 
)˝˝ Ä
||
˛˛ 
	CoreUtils
˛˛ $
.
˛˛$ %+
ConvertSRGBToActiveColorSpace
˛˛% B
(
˛˛B C
camera
˛˛C I
.
˛˛I J
backgroundColor
˛˛J Y
)
˛˛Y Z
!=
˛˛[ ]

renderPass
˛˛^ h
.
˛˛h i

clearColor
˛˛i s
;
˛˛s t
}
ˇˇ 
if
áá 
(
áá 

renderPass
áá 
.
áá 
depthAttachment
áá .
==
áá/ 1!
m_CameraDepthTarget
áá2 E
&&
ááF H1
#m_FirstTimeCameraDepthTargetIsBound
ááI l
)
áál m
{
àà 1
#m_FirstTimeCameraDepthTargetIsBound
ââ 7
=
ââ8 9
false
ââ: ?
;
ââ? @(
needCustomCameraDepthClear
ää .
=
ää/ 0
(
ää1 2
cameraClearFlag
ää2 A
&
ääB C
	ClearFlag
ääD M
.
ääM N
Depth
ääN S
)
ääS T
!=
ääU W
(
ääX Y

renderPass
ääY c
.
ääc d
	clearFlag
ääd m
&
ään o
	ClearFlag
ääp y
.
ääy z
Depth
ääz 
)ää Ä
;ääÄ Å
}
ãã 
if
ëë 
(
ëë (
needCustomCameraColorClear
ëë .
)
ëë. /
{
íí 
if
ïï 
(
ïï 
(
ïï 
cameraClearFlag
ïï (
&
ïï) *
	ClearFlag
ïï+ 4
.
ïï4 5
Color
ïï5 :
)
ïï: ;
!=
ïï< >
$num
ïï? @
)
ïï@ A
SetRenderTarget
ññ '
(
ññ' (
cmd
ññ( +
,
ññ+ ,

renderPass
ññ- 7
.
ññ7 8
colorAttachments
ññ8 H
[
ññH I$
cameraColorTargetIndex
ññI _
]
ññ_ `
,
ññ` a

renderPass
ññb l
.
ññl m
depthAttachment
ññm |
,
ññ| }
	ClearFlagññ~ á
.ññá à
Colorññà ç
,ññç é
	CoreUtilsññè ò
.ññò ô-
ConvertSRGBToActiveColorSpaceññô ∂
(ññ∂ ∑
cameraññ∑ Ω
.ññΩ æ
backgroundColorññæ Õ
)ññÕ Œ
)ññŒ œ
;ññœ –
if
òò 
(
òò 
(
òò 

renderPass
òò #
.
òò# $
	clearFlag
òò$ -
&
òò. /
	ClearFlag
òò0 9
.
òò9 :
Color
òò: ?
)
òò? @
!=
òòA C
$num
òòD E
)
òòE F
{
ôô 
uint
öö 
otherTargetsCount
öö .
=
öö/ 0
RenderingUtils
öö1 ?
.
öö? @
CountDistinct
öö@ M
(
ööM N

renderPass
ööN X
.
ööX Y
colorAttachments
ööY i
,
ööi j!
m_CameraColorTarget
öök ~
)
öö~ 
;öö Ä
var
õõ "
nonCameraAttachments
õõ 0
=
õõ1 2,
m_TrimmedColorAttachmentCopies
õõ3 Q
[
õõQ R
otherTargetsCount
õõR c
]
õõc d
;
õõd e
int
úú 

writeIndex
úú &
=
úú' (
$num
úú) *
;
úú* +
for
ùù 
(
ùù 
int
ùù  
	readIndex
ùù! *
=
ùù+ ,
$num
ùù- .
;
ùù. /
	readIndex
ùù0 9
<
ùù: ;

renderPass
ùù< F
.
ùùF G
colorAttachments
ùùG W
.
ùùW X
Length
ùùX ^
;
ùù^ _
++
ùù` b
	readIndex
ùùb k
)
ùùk l
{
ûû 
if
üü 
(
üü  

renderPass
üü  *
.
üü* +
colorAttachments
üü+ ;
[
üü; <
	readIndex
üü< E
]
üüE F
!=
üüG I!
m_CameraColorTarget
üüJ ]
&&
üü^ `

renderPass
üüa k
.
üük l
colorAttachments
üül |
[
üü| }
	readIndexüü} Ü
]üüÜ á
!=üüà ä
$numüüã å
)üüå ç
{
†† "
nonCameraAttachments
°°  4
[
°°4 5

writeIndex
°°5 ?
]
°°? @
=
°°A B

renderPass
°°C M
.
°°M N
colorAttachments
°°N ^
[
°°^ _
	readIndex
°°_ h
]
°°h i
;
°°i j
++
¢¢  "

writeIndex
¢¢" ,
;
¢¢, -
}
££ 
}
§§ 
if
¶¶ 
(
¶¶ 

writeIndex
¶¶ &
!=
¶¶' )
otherTargetsCount
¶¶* ;
)
¶¶; <
Debug
ßß !
.
ßß! "
LogError
ßß" *
(
ßß* +
$str
ßß+ j
+
ßßk l

writeIndex
ßßm w
+
ßßx y
$strßßz è
+ßßê ë!
otherTargetsCountßßí £
)ßß£ §
;ßß§ •
SetRenderTarget
®® '
(
®®' (
cmd
®®( +
,
®®+ ,"
nonCameraAttachments
®®- A
,
®®A B!
m_CameraDepthTarget
®®C V
,
®®V W
	ClearFlag
®®X a
.
®®a b
Color
®®b g
,
®®g h

renderPass
®®i s
.
®®s t

clearColor
®®t ~
)
®®~ 
;®® Ä
}
©© 
}
™™ 
	ClearFlag
≠≠ 
finalClearFlag
≠≠ (
=
≠≠) *
	ClearFlag
≠≠+ 4
.
≠≠4 5
None
≠≠5 9
;
≠≠9 :
finalClearFlag
ÆÆ 
|=
ÆÆ !(
needCustomCameraDepthClear
ÆÆ" <
?
ÆÆ= >
(
ÆÆ? @
cameraClearFlag
ÆÆ@ O
&
ÆÆP Q
	ClearFlag
ÆÆR [
.
ÆÆ[ \
Depth
ÆÆ\ a
)
ÆÆa b
:
ÆÆc d
(
ÆÆe f

renderPass
ÆÆf p
.
ÆÆp q
	clearFlag
ÆÆq z
&
ÆÆ{ |
	ClearFlagÆÆ} Ü
.ÆÆÜ á
DepthÆÆá å
)ÆÆå ç
;ÆÆç é
finalClearFlag
ØØ 
|=
ØØ !(
needCustomCameraColorClear
ØØ" <
?
ØØ= >
$num
ØØ? @
:
ØØA B
(
ØØC D

renderPass
ØØD N
.
ØØN O
	clearFlag
ØØO X
&
ØØY Z
	ClearFlag
ØØ[ d
.
ØØd e
Color
ØØe j
)
ØØj k
;
ØØk l
if
≤≤ 
(
≤≤ 
!
≤≤ 
RenderingUtils
≤≤ #
.
≤≤# $
SequenceEqual
≤≤$ 1
(
≤≤1 2

renderPass
≤≤2 <
.
≤≤< =
colorAttachments
≤≤= M
,
≤≤M N&
m_ActiveColorAttachments
≤≤O g
)
≤≤g h
||
≤≤i k

renderPass
≤≤l v
.
≤≤v w
depthAttachment≤≤w Ü
!=≤≤á â'
m_ActiveDepthAttachment≤≤ä °
||≤≤¢ §
finalClearFlag≤≤• ≥
!=≤≤¥ ∂
	ClearFlag≤≤∑ ¿
.≤≤¿ ¡
None≤≤¡ ≈
)≤≤≈ ∆
{
≥≥ 
int
¥¥ 
lastValidRTindex
¥¥ (
=
¥¥) *
RenderingUtils
¥¥+ 9
.
¥¥9 :
	LastValid
¥¥: C
(
¥¥C D

renderPass
¥¥D N
.
¥¥N O
colorAttachments
¥¥O _
)
¥¥_ `
;
¥¥` a
if
µµ 
(
µµ 
lastValidRTindex
µµ (
>=
µµ) +
$num
µµ, -
)
µµ- .
{
∂∂ 
int
∑∑ 
rtCount
∑∑ #
=
∑∑$ %
lastValidRTindex
∑∑& 6
+
∑∑7 8
$num
∑∑9 :
;
∑∑: ;
var
∏∏  
trimmedAttachments
∏∏ .
=
∏∏/ 0,
m_TrimmedColorAttachmentCopies
∏∏1 O
[
∏∏O P
rtCount
∏∏P W
]
∏∏W X
;
∏∏X Y
for
ππ 
(
ππ 
int
ππ  
i
ππ! "
=
ππ# $
$num
ππ% &
;
ππ& '
i
ππ( )
<
ππ* +
rtCount
ππ, 3
;
ππ3 4
++
ππ5 7
i
ππ7 8
)
ππ8 9 
trimmedAttachments
∫∫ .
[
∫∫. /
i
∫∫/ 0
]
∫∫0 1
=
∫∫2 3

renderPass
∫∫4 >
.
∫∫> ?
colorAttachments
∫∫? O
[
∫∫O P
i
∫∫P Q
]
∫∫Q R
;
∫∫R S
SetRenderTarget
ªª '
(
ªª' (
cmd
ªª( +
,
ªª+ , 
trimmedAttachments
ªª- ?
,
ªª? @

renderPass
ªªA K
.
ªªK L
depthAttachment
ªªL [
,
ªª[ \
finalClearFlag
ªª] k
,
ªªk l

renderPass
ªªm w
.
ªªw x

clearColorªªx Ç
)ªªÇ É
;ªªÉ Ñ
if
ææ 
(
ææ 

cameraData
ææ &
.
ææ& '
xr
ææ' )
.
ææ) *
enabled
ææ* 1
)
ææ1 2
{
øø 
int
¬¬ 
xrTargetIndex
¬¬  -
=
¬¬. /
RenderingUtils
¬¬0 >
.
¬¬> ?
IndexOf
¬¬? F
(
¬¬F G

renderPass
¬¬G Q
.
¬¬Q R
colorAttachments
¬¬R b
,
¬¬b c

cameraData
¬¬d n
.
¬¬n o
xr
¬¬o q
.
¬¬q r
renderTarget
¬¬r ~
)
¬¬~ 
;¬¬ Ä
bool
√√  (
isRenderToBackBufferTarget
√√! ;
=
√√< =
(
√√> ?
xrTargetIndex
√√? L
!=
√√M O
-
√√P Q
$num
√√Q R
)
√√R S
&&
√√T V
!
√√W X

cameraData
√√X b
.
√√b c
xr
√√c e
.
√√e f*
renderTargetIsRenderTexture√√f Å
;√√Å Ç

cameraData
ƒƒ &
.
ƒƒ& '
xr
ƒƒ' )
.
ƒƒ) *0
"UpdateGPUViewAndProjectionMatrices
ƒƒ* L
(
ƒƒL M
cmd
ƒƒM P
,
ƒƒP Q
ref
ƒƒR U

cameraData
ƒƒV `
,
ƒƒ` a
!
ƒƒb c(
isRenderToBackBufferTarget
ƒƒc }
)
ƒƒ} ~
;
ƒƒ~ 
}
≈≈ 
}
«« 
}
»» 
}
…… 
else
   
{
ÀÀ $
RenderTargetIdentifier
ŒŒ &!
passColorAttachment
ŒŒ' :
=
ŒŒ; <

renderPass
ŒŒ= G
.
ŒŒG H
colorAttachment
ŒŒH W
;
ŒŒW X$
RenderTargetIdentifier
œœ &!
passDepthAttachment
œœ' :
=
œœ; <

renderPass
œœ= G
.
œœG H
depthAttachment
œœH W
;
œœW X
if
”” 
(
”” 
!
”” 

renderPass
”” 
.
””  "
overrideCameraTarget
””  4
)
””4 5
{
‘‘ 
if
◊◊ 
(
◊◊ 

renderPass
◊◊ "
.
◊◊" #
renderPassEvent
◊◊# 2
<
◊◊3 4
RenderPassEvent
◊◊5 D
.
◊◊D E$
BeforeRenderingOpaques
◊◊E [
)
◊◊[ \
return
ÿÿ 
;
ÿÿ !
passColorAttachment
€€ '
=
€€( )!
m_CameraColorTarget
€€* =
;
€€= >!
passDepthAttachment
‹‹ '
=
‹‹( )!
m_CameraDepthTarget
‹‹* =
;
‹‹= >
}
›› 
	ClearFlag
ﬂﬂ 
finalClearFlag
ﬂﬂ (
=
ﬂﬂ) *
	ClearFlag
ﬂﬂ+ 4
.
ﬂﬂ4 5
None
ﬂﬂ5 9
;
ﬂﬂ9 :
Color
‡‡ 
finalClearColor
‡‡ %
;
‡‡% &
if
‚‚ 
(
‚‚ !
passColorAttachment
‚‚ '
==
‚‚( *!
m_CameraColorTarget
‚‚+ >
&&
‚‚? A
(
‚‚B C1
#m_FirstTimeCameraColorTargetIsBound
‚‚C f
)
‚‚f g
)
‚‚g h
{
„„ 1
#m_FirstTimeCameraColorTargetIsBound
‰‰ 7
=
‰‰8 9
false
‰‰: ?
;
‰‰? @
finalClearFlag
ÊÊ "
|=
ÊÊ# %
(
ÊÊ& '
cameraClearFlag
ÊÊ' 6
&
ÊÊ7 8
	ClearFlag
ÊÊ9 B
.
ÊÊB C
Color
ÊÊC H
)
ÊÊH I
;
ÊÊI J
finalClearColor
ÁÁ #
=
ÁÁ$ %
	CoreUtils
ÁÁ& /
.
ÁÁ/ 0+
ConvertSRGBToActiveColorSpace
ÁÁ0 M
(
ÁÁM N
camera
ÁÁN T
.
ÁÁT U
backgroundColor
ÁÁU d
)
ÁÁd e
;
ÁÁe f
if
ÈÈ 
(
ÈÈ 1
#m_FirstTimeCameraDepthTargetIsBound
ÈÈ ;
)
ÈÈ; <
{
ÍÍ 1
#m_FirstTimeCameraDepthTargetIsBound
ÌÌ ;
=
ÌÌ< =
false
ÌÌ> C
;
ÌÌC D
finalClearFlag
ÓÓ &
|=
ÓÓ' )
(
ÓÓ* +
cameraClearFlag
ÓÓ+ :
&
ÓÓ; <
	ClearFlag
ÓÓ= F
.
ÓÓF G
Depth
ÓÓG L
)
ÓÓL M
;
ÓÓM N
}
ÔÔ 
}
 
else
ÒÒ 
{
ÚÚ 
finalClearFlag
ÛÛ "
|=
ÛÛ# %
(
ÛÛ& '

renderPass
ÛÛ' 1
.
ÛÛ1 2
	clearFlag
ÛÛ2 ;
&
ÛÛ< =
	ClearFlag
ÛÛ> G
.
ÛÛG H
Color
ÛÛH M
)
ÛÛM N
;
ÛÛN O
finalClearColor
ÙÙ #
=
ÙÙ$ %

renderPass
ÙÙ& 0
.
ÙÙ0 1

clearColor
ÙÙ1 ;
;
ÙÙ; <
}
ıı 
if
¯¯ 
(
¯¯ 
(
¯¯ !
m_CameraDepthTarget
¯¯ (
!=
¯¯) +&
BuiltinRenderTextureType
¯¯, D
.
¯¯D E
CameraTarget
¯¯E Q
)
¯¯Q R
&&
¯¯S U
(
¯¯V W!
passDepthAttachment
¯¯W j
==
¯¯k m"
m_CameraDepthTarget¯¯n Å
||¯¯Ç Ñ#
passColorAttachment¯¯Ö ò
==¯¯ô õ#
m_CameraDepthTarget¯¯ú Ø
)¯¯Ø ∞
&&¯¯± ≥3
#m_FirstTimeCameraDepthTargetIsBound¯¯¥ ◊
)¯¯◊ ÿ
{
˘˘ 1
#m_FirstTimeCameraDepthTargetIsBound
˙˙ 7
=
˙˙8 9
false
˙˙: ?
;
˙˙? @
finalClearFlag
¸¸ "
|=
¸¸# %
(
¸¸& '
cameraClearFlag
¸¸' 6
&
¸¸7 8
	ClearFlag
¸¸9 B
.
¸¸B C
Depth
¸¸C H
)
¸¸H I
;
¸¸I J
}
ˇˇ 
else
ÄÄ 
finalClearFlag
ÅÅ "
|=
ÅÅ# %
(
ÅÅ& '

renderPass
ÅÅ' 1
.
ÅÅ1 2
	clearFlag
ÅÅ2 ;
&
ÅÅ< =
	ClearFlag
ÅÅ> G
.
ÅÅG H
Depth
ÅÅH M
)
ÅÅM N
;
ÅÅN O
if
ÑÑ 
(
ÑÑ !
passColorAttachment
ÑÑ '
!=
ÑÑ( *&
m_ActiveColorAttachments
ÑÑ+ C
[
ÑÑC D
$num
ÑÑD E
]
ÑÑE F
||
ÑÑG I!
passDepthAttachment
ÑÑJ ]
!=
ÑÑ^ `%
m_ActiveDepthAttachment
ÑÑa x
||
ÑÑy {
finalClearFlagÑÑ| ä
!=ÑÑã ç
	ClearFlagÑÑé ó
.ÑÑó ò
NoneÑÑò ú
)ÑÑú ù
{
ÖÖ 
SetRenderTarget
ÜÜ #
(
ÜÜ# $
cmd
ÜÜ$ '
,
ÜÜ' (!
passColorAttachment
ÜÜ) <
,
ÜÜ< =!
passDepthAttachment
ÜÜ> Q
,
ÜÜQ R
finalClearFlag
ÜÜS a
,
ÜÜa b
finalClearColor
ÜÜc r
)
ÜÜr s
;
ÜÜs t
if
ââ 
(
ââ 

cameraData
ââ "
.
ââ" #
xr
ââ# %
.
ââ% &
enabled
ââ& -
)
ââ- .
{
ää 
bool
çç (
isRenderToBackBufferTarget
çç 7
=
çç8 9
(
çç: ;!
passColorAttachment
çç; N
==
ççO Q

cameraData
ççR \
.
çç\ ]
xr
çç] _
.
çç_ `
renderTarget
çç` l
)
ççl m
&&
ççn p
!
ççq r

cameraData
ççr |
.
çç| }
xr
çç} 
.çç Ä+
renderTargetIsRenderTextureççÄ õ
;ççõ ú

cameraData
éé "
.
éé" #
xr
éé# %
.
éé% &0
"UpdateGPUViewAndProjectionMatrices
éé& H
(
ééH I
cmd
ééI L
,
ééL M
ref
ééN Q

cameraData
ééR \
,
éé\ ]
!
éé^ _(
isRenderToBackBufferTarget
éé_ y
)
ééy z
;
ééz {
}
èè 
}
ëë 
}
íí 
}
ìì 	
void
ïï 
BeginXRRendering
ïï 
(
ïï 
CommandBuffer
ïï +
cmd
ïï, /
,
ïï/ 0%
ScriptableRenderContext
ïï1 H
context
ïïI P
,
ïïP Q
ref
ïïR U

CameraData
ïïV `

cameraData
ïïa k
)
ïïk l
{
ññ 	
if
òò 
(
òò 

cameraData
òò 
.
òò 
xr
òò 
.
òò 
enabled
òò %
)
òò% &
{
ôô 

cameraData
öö 
.
öö 
xr
öö 
.
öö 
StartSinglePass
öö -
(
öö- .
cmd
öö. 1
)
öö1 2
;
öö2 3
cmd
õõ 
.
õõ !
EnableShaderKeyword
õõ '
(
õõ' ("
ShaderKeywordStrings
õõ( <
.
õõ< =
UseDrawProcedural
õõ= N
)
õõN O
;
õõO P
context
úú 
.
úú "
ExecuteCommandBuffer
úú ,
(
úú, -
cmd
úú- 0
)
úú0 1
;
úú1 2
cmd
ùù 
.
ùù 
Clear
ùù 
(
ùù 
)
ùù 
;
ùù 
}
ûû 
}
†† 	
void
¢¢ 
EndXRRendering
¢¢ 
(
¢¢ 
CommandBuffer
¢¢ )
cmd
¢¢* -
,
¢¢- .%
ScriptableRenderContext
¢¢/ F
context
¢¢G N
,
¢¢N O
ref
¢¢P S

CameraData
¢¢T ^

cameraData
¢¢_ i
)
¢¢i j
{
££ 	
if
•• 
(
•• 

cameraData
•• 
.
•• 
xr
•• 
.
•• 
enabled
•• %
)
••% &
{
¶¶ 

cameraData
ßß 
.
ßß 
xr
ßß 
.
ßß 
StopSinglePass
ßß ,
(
ßß, -
cmd
ßß- 0
)
ßß0 1
;
ßß1 2
cmd
®® 
.
®® "
DisableShaderKeyword
®® (
(
®®( )"
ShaderKeywordStrings
®®) =
.
®®= >
UseDrawProcedural
®®> O
)
®®O P
;
®®P Q
context
©© 
.
©© "
ExecuteCommandBuffer
©© ,
(
©©, -
cmd
©©- 0
)
©©0 1
;
©©1 2
cmd
™™ 
.
™™ 
Clear
™™ 
(
™™ 
)
™™ 
;
™™ 
}
´´ 
}
≠≠ 	
internal
ØØ 
static
ØØ 
void
ØØ 
SetRenderTarget
ØØ ,
(
ØØ, -
CommandBuffer
ØØ- :
cmd
ØØ; >
,
ØØ> ?$
RenderTargetIdentifier
ØØ@ V
colorAttachment
ØØW f
,
ØØf g$
RenderTargetIdentifier
ØØh ~
depthAttachmentØØ é
,ØØé è
	ClearFlagØØê ô
	clearFlagØØö £
,ØØ£ §
ColorØØ• ™

clearColorØØ´ µ
)ØØµ ∂
{
∞∞ 	&
m_ActiveColorAttachments
±± $
[
±±$ %
$num
±±% &
]
±±& '
=
±±( )
colorAttachment
±±* 9
;
±±9 :
for
≤≤ 
(
≤≤ 
int
≤≤ 
i
≤≤ 
=
≤≤ 
$num
≤≤ 
;
≤≤ 
i
≤≤ 
<
≤≤ &
m_ActiveColorAttachments
≤≤  8
.
≤≤8 9
Length
≤≤9 ?
;
≤≤? @
++
≤≤A C
i
≤≤C D
)
≤≤D E&
m_ActiveColorAttachments
≥≥ (
[
≥≥( )
i
≥≥) *
]
≥≥* +
=
≥≥, -
$num
≥≥. /
;
≥≥/ 0%
m_ActiveDepthAttachment
µµ #
=
µµ$ %
depthAttachment
µµ& 5
;
µµ5 6$
RenderBufferLoadAction
∑∑ "
colorLoadAction
∑∑# 2
=
∑∑3 4
(
∑∑5 6
(
∑∑6 7
uint
∑∑7 ;
)
∑∑; <
	clearFlag
∑∑< E
&
∑∑F G
(
∑∑H I
uint
∑∑I M
)
∑∑M N
	ClearFlag
∑∑N W
.
∑∑W X
Color
∑∑X ]
)
∑∑] ^
!=
∑∑_ a
$num
∑∑b c
?
∑∑d e$
RenderBufferLoadAction
∏∏ &
.
∏∏& '
DontCare
∏∏' /
:
∏∏0 1$
RenderBufferLoadAction
∏∏2 H
.
∏∏H I
Load
∏∏I M
;
∏∏M N$
RenderBufferLoadAction
∫∫ "
depthLoadAction
∫∫# 2
=
∫∫3 4
(
∫∫5 6
(
∫∫6 7
uint
∫∫7 ;
)
∫∫; <
	clearFlag
∫∫< E
&
∫∫F G
(
∫∫H I
uint
∫∫I M
)
∫∫M N
	ClearFlag
∫∫N W
.
∫∫W X
Depth
∫∫X ]
)
∫∫] ^
!=
∫∫_ a
$num
∫∫b c
?
∫∫d e$
RenderBufferLoadAction
ªª &
.
ªª& '
DontCare
ªª' /
:
ªª0 1$
RenderBufferLoadAction
ªª2 H
.
ªªH I
Load
ªªI M
;
ªªM N
SetRenderTarget
ΩΩ 
(
ΩΩ 
cmd
ΩΩ 
,
ΩΩ  
colorAttachment
ΩΩ! 0
,
ΩΩ0 1
colorLoadAction
ΩΩ2 A
,
ΩΩA B%
RenderBufferStoreAction
ΩΩC Z
.
ΩΩZ [
Store
ΩΩ[ `
,
ΩΩ` a
depthAttachment
ææ 
,
ææ  
depthLoadAction
ææ! 0
,
ææ0 1%
RenderBufferStoreAction
ææ2 I
.
ææI J
Store
ææJ O
,
ææO P
	clearFlag
ææQ Z
,
ææZ [

clearColor
ææ\ f
)
ææf g
;
ææg h
}
øø 	
static
¡¡ 
void
¡¡ 
SetRenderTarget
¡¡ #
(
¡¡# $
CommandBuffer
¬¬ 
cmd
¬¬ 
,
¬¬ $
RenderTargetIdentifier
√√ "
colorAttachment
√√# 2
,
√√2 3$
RenderBufferLoadAction
ƒƒ "
colorLoadAction
ƒƒ# 2
,
ƒƒ2 3%
RenderBufferStoreAction
≈≈ #
colorStoreAction
≈≈$ 4
,
≈≈4 5
	ClearFlag
∆∆ 

clearFlags
∆∆  
,
∆∆  !
Color
«« 

clearColor
«« 
)
«« 
{
»» 	
	CoreUtils
…… 
.
…… 
SetRenderTarget
…… %
(
……% &
cmd
……& )
,
……) *
colorAttachment
……+ :
,
……: ;
colorLoadAction
……< K
,
……K L
colorStoreAction
……M ]
,
……] ^

clearFlags
……_ i
,
……i j

clearColor
……k u
)
……u v
;
……v w
}
   	
static
ÃÃ 
void
ÃÃ 
SetRenderTarget
ÃÃ #
(
ÃÃ# $
CommandBuffer
ÕÕ 
cmd
ÕÕ 
,
ÕÕ $
RenderTargetIdentifier
ŒŒ "
colorAttachment
ŒŒ# 2
,
ŒŒ2 3$
RenderBufferLoadAction
œœ "
colorLoadAction
œœ# 2
,
œœ2 3%
RenderBufferStoreAction
–– #
colorStoreAction
––$ 4
,
––4 5$
RenderTargetIdentifier
—— "
depthAttachment
——# 2
,
——2 3$
RenderBufferLoadAction
““ "
depthLoadAction
““# 2
,
““2 3%
RenderBufferStoreAction
”” #
depthStoreAction
””$ 4
,
””4 5
	ClearFlag
‘‘ 

clearFlags
‘‘  
,
‘‘  !
Color
’’ 

clearColor
’’ 
)
’’ 
{
÷÷ 	
if
ÿÿ 
(
ÿÿ 
depthAttachment
ÿÿ 
==
ÿÿ  "&
BuiltinRenderTextureType
ÿÿ# ;
.
ÿÿ; <
CameraTarget
ÿÿ< H
)
ÿÿH I
{
ŸŸ 
SetRenderTarget
⁄⁄ 
(
⁄⁄  
cmd
⁄⁄  #
,
⁄⁄# $
colorAttachment
⁄⁄% 4
,
⁄⁄4 5
colorLoadAction
⁄⁄6 E
,
⁄⁄E F
colorStoreAction
⁄⁄G W
,
⁄⁄W X

clearFlags
⁄⁄Y c
,
⁄⁄c d

clearColor
⁄⁄e o
)
⁄⁄o p
;
⁄⁄p q
}
€€ 
else
‹‹ 
{
›› 
	CoreUtils
ﬁﬁ 
.
ﬁﬁ 
SetRenderTarget
ﬁﬁ )
(
ﬁﬁ) *
cmd
ﬁﬁ* -
,
ﬁﬁ- .
colorAttachment
ﬁﬁ/ >
,
ﬁﬁ> ?
colorLoadAction
ﬁﬁ@ O
,
ﬁﬁO P
colorStoreAction
ﬁﬁQ a
,
ﬁﬁa b
depthAttachment
ﬂﬂ '
,
ﬂﬂ' (
depthLoadAction
ﬂﬂ) 8
,
ﬂﬂ8 9
depthStoreAction
ﬂﬂ: J
,
ﬂﬂJ K

clearFlags
ﬂﬂL V
,
ﬂﬂV W

clearColor
ﬂﬂX b
)
ﬂﬂb c
;
ﬂﬂc d
}
‡‡ 
}
·· 	
static
„„ 
void
„„ 
SetRenderTarget
„„ #
(
„„# $
CommandBuffer
„„$ 1
cmd
„„2 5
,
„„5 6$
RenderTargetIdentifier
„„7 M
[
„„M N
]
„„N O
colorAttachments
„„P `
,
„„` a$
RenderTargetIdentifier
„„b x
depthAttachment„„y à
,„„à â
	ClearFlag„„ä ì
	clearFlag„„î ù
,„„ù û
Color„„ü §

clearColor„„• Ø
)„„Ø ∞
{
‰‰ 	&
m_ActiveColorAttachments
ÂÂ $
=
ÂÂ% &
colorAttachments
ÂÂ' 7
;
ÂÂ7 8%
m_ActiveDepthAttachment
ÊÊ #
=
ÊÊ$ %
depthAttachment
ÊÊ& 5
;
ÊÊ5 6
	CoreUtils
ËË 
.
ËË 
SetRenderTarget
ËË %
(
ËË% &
cmd
ËË& )
,
ËË) *
colorAttachments
ËË+ ;
,
ËË; <
depthAttachment
ËË= L
,
ËËL M
	clearFlag
ËËN W
,
ËËW X

clearColor
ËËY c
)
ËËc d
;
ËËd e
}
ÈÈ 	
[
ÎÎ 	
Conditional
ÎÎ	 
(
ÎÎ 
$str
ÎÎ #
)
ÎÎ# $
]
ÎÎ$ %
void
ÏÏ 

DrawGizmos
ÏÏ 
(
ÏÏ %
ScriptableRenderContext
ÏÏ /
context
ÏÏ0 7
,
ÏÏ7 8
Camera
ÏÏ9 ?
camera
ÏÏ@ F
,
ÏÏF G
GizmoSubset
ÏÏH S
gizmoSubset
ÏÏT _
)
ÏÏ_ `
{
ÌÌ 	
if
ÔÔ 
(
ÔÔ 
UnityEditor
ÔÔ 
.
ÔÔ 
Handles
ÔÔ #
.
ÔÔ# $ 
ShouldRenderGizmos
ÔÔ$ 6
(
ÔÔ6 7
)
ÔÔ7 8
)
ÔÔ8 9
context
 
.
 

DrawGizmos
 "
(
" #
camera
# )
,
) *
gizmoSubset
+ 6
)
6 7
;
7 8
}
ÚÚ 	
[
ÙÙ 	
Conditional
ÙÙ	 
(
ÙÙ 
$str
ÙÙ #
)
ÙÙ# $
]
ÙÙ$ %
void
ıı 
DrawWireOverlay
ıı 
(
ıı %
ScriptableRenderContext
ıı 4
context
ıı5 <
,
ıı< =
Camera
ıı> D
camera
ııE K
)
ııK L
{
ˆˆ 	
context
˜˜ 
.
˜˜ 
DrawWireOverlay
˜˜ #
(
˜˜# $
camera
˜˜$ *
)
˜˜* +
;
˜˜+ ,
}
¯¯ 	
void
˙˙ $
InternalStartRendering
˙˙ #
(
˙˙# $%
ScriptableRenderContext
˙˙$ ;
context
˙˙< C
,
˙˙C D
ref
˙˙E H
RenderingData
˙˙I V
renderingData
˙˙W d
)
˙˙d e
{
˚˚ 	
CommandBuffer
¸¸ 
cmd
¸¸ 
=
¸¸ 
CommandBufferPool
¸¸  1
.
¸¸1 2
Get
¸¸2 5
(
¸¸5 6
)
¸¸6 7
;
¸¸7 8
using
˝˝ 
(
˝˝ 
new
˝˝ 
ProfilingScope
˝˝ %
(
˝˝% &
cmd
˝˝& )
,
˝˝) *
	Profiling
˝˝+ 4
.
˝˝4 5$
internalStartRendering
˝˝5 K
)
˝˝K L
)
˝˝L M
{
˛˛ 
for
ˇˇ 
(
ˇˇ 
int
ˇˇ 
i
ˇˇ 
=
ˇˇ 
$num
ˇˇ 
;
ˇˇ 
i
ˇˇ  !
<
ˇˇ" #%
m_ActiveRenderPassQueue
ˇˇ$ ;
.
ˇˇ; <
Count
ˇˇ< A
;
ˇˇA B
++
ˇˇC E
i
ˇˇE F
)
ˇˇF G
{
ÄÄ %
m_ActiveRenderPassQueue
ÅÅ +
[
ÅÅ+ ,
i
ÅÅ, -
]
ÅÅ- .
.
ÅÅ. /
OnCameraSetup
ÅÅ/ <
(
ÅÅ< =
cmd
ÅÅ= @
,
ÅÅ@ A
ref
ÅÅB E
renderingData
ÅÅF S
)
ÅÅS T
;
ÅÅT U
}
ÇÇ 
}
ÉÉ 
context
ÖÖ 
.
ÖÖ "
ExecuteCommandBuffer
ÖÖ (
(
ÖÖ( )
cmd
ÖÖ) ,
)
ÖÖ, -
;
ÖÖ- .
CommandBufferPool
ÜÜ 
.
ÜÜ 
Release
ÜÜ %
(
ÜÜ% &
cmd
ÜÜ& )
)
ÜÜ) *
;
ÜÜ* +
}
áá 	
void
ââ %
InternalFinishRendering
ââ $
(
ââ$ %%
ScriptableRenderContext
ââ% <
context
ââ= D
,
ââD E
bool
ââF J 
resolveFinalTarget
ââK ]
)
ââ] ^
{
ää 	
CommandBuffer
ãã 
cmd
ãã 
=
ãã 
CommandBufferPool
ãã  1
.
ãã1 2
Get
ãã2 5
(
ãã5 6
)
ãã6 7
;
ãã7 8
using
åå 
(
åå 
new
åå 
ProfilingScope
åå %
(
åå% &
cmd
åå& )
,
åå) *
	Profiling
åå+ 4
.
åå4 5%
internalFinishRendering
åå5 L
)
ååL M
)
ååM N
{
çç 
for
èè 
(
èè 
int
èè 
i
èè 
=
èè 
$num
èè 
;
èè 
i
èè  !
<
èè" #%
m_ActiveRenderPassQueue
èè$ ;
.
èè; <
Count
èè< A
;
èèA B
++
èèC E
i
èèE F
)
èèF G%
m_ActiveRenderPassQueue
êê +
[
êê+ ,
i
êê, -
]
êê- .
.
êê. /
FrameCleanup
êê/ ;
(
êê; <
cmd
êê< ?
)
êê? @
;
êê@ A
if
ìì 
(
ìì  
resolveFinalTarget
ìì &
)
ìì& '
{
îî 
for
ïï 
(
ïï 
int
ïï 
i
ïï 
=
ïï  
$num
ïï! "
;
ïï" #
i
ïï$ %
<
ïï& '%
m_ActiveRenderPassQueue
ïï( ?
.
ïï? @
Count
ïï@ E
;
ïïE F
++
ïïG I
i
ïïI J
)
ïïJ K%
m_ActiveRenderPassQueue
ññ /
[
ññ/ 0
i
ññ0 1
]
ññ1 2
.
ññ2 3*
OnFinishCameraStackRendering
ññ3 O
(
ññO P
cmd
ññP S
)
ññS T
;
ññT U
FinishRendering
òò #
(
òò# $
cmd
òò$ '
)
òò' (
;
òò( )#
m_IsPipelineExecuting
õõ )
=
õõ* +
false
õõ, 1
;
õõ1 2
}
úú 
}
ùù 
context
üü 
.
üü "
ExecuteCommandBuffer
üü (
(
üü( )
cmd
üü) ,
)
üü, -
;
üü- .
CommandBufferPool
†† 
.
†† 
Release
†† %
(
††% &
cmd
††& )
)
††) *
;
††* +
}
°° 	
internal
££ 
static
££ 
void
££ 

SortStable
££ '
(
££' (
List
££( ,
<
££, -"
ScriptableRenderPass
££- A
>
££A B
list
££C G
)
££G H
{
§§ 	
int
•• 
j
•• 
;
•• 
for
¶¶ 
(
¶¶ 
int
¶¶ 
i
¶¶ 
=
¶¶ 
$num
¶¶ 
;
¶¶ 
i
¶¶ 
<
¶¶ 
list
¶¶  $
.
¶¶$ %
Count
¶¶% *
;
¶¶* +
++
¶¶, .
i
¶¶. /
)
¶¶/ 0
{
ßß "
ScriptableRenderPass
®® $
curr
®®% )
=
®®* +
list
®®, 0
[
®®0 1
i
®®1 2
]
®®2 3
;
®®3 4
j
™™ 
=
™™ 
i
™™ 
-
™™ 
$num
™™ 
;
™™ 
for
´´ 
(
´´ 
;
´´ 
j
´´ 
>=
´´ 
$num
´´ 
&&
´´  
curr
´´! %
<
´´& '
list
´´( ,
[
´´, -
j
´´- .
]
´´. /
;
´´/ 0
--
´´1 3
j
´´3 4
)
´´4 5
list
¨¨ 
[
¨¨ 
j
¨¨ 
+
¨¨ 
$num
¨¨ 
]
¨¨ 
=
¨¨  !
list
¨¨" &
[
¨¨& '
j
¨¨' (
]
¨¨( )
;
¨¨) *
list
ÆÆ 
[
ÆÆ 
j
ÆÆ 
+
ÆÆ 
$num
ÆÆ 
]
ÆÆ 
=
ÆÆ 
curr
ÆÆ "
;
ÆÆ" #
}
ØØ 
}
∞∞ 	
internal
≤≤ 
struct
≤≤ 
RenderBlocks
≤≤ $
:
≤≤% &
IDisposable
≤≤' 2
{
≥≥ 	
private
¥¥ 
NativeArray
¥¥ 
<
¥¥  
RenderPassEvent
¥¥  /
>
¥¥/ 0 
m_BlockEventLimits
¥¥1 C
;
¥¥C D
private
µµ 
NativeArray
µµ 
<
µµ  
int
µµ  #
>
µµ# $
m_BlockRanges
µµ% 2
;
µµ2 3
private
∂∂ 
NativeArray
∂∂ 
<
∂∂  
int
∂∂  #
>
∂∂# $!
m_BlockRangeLengths
∂∂% 8
;
∂∂8 9
public
∑∑ 
RenderBlocks
∑∑ 
(
∑∑  
List
∑∑  $
<
∑∑$ %"
ScriptableRenderPass
∑∑% 9
>
∑∑9 :#
activeRenderPassQueue
∑∑; P
)
∑∑P Q
{
∏∏  
m_BlockEventLimits
∫∫ "
=
∫∫# $
new
∫∫% (
NativeArray
∫∫) 4
<
∫∫4 5
RenderPassEvent
∫∫5 D
>
∫∫D E
(
∫∫E F$
k_RenderPassBlockCount
∫∫F \
,
∫∫\ ]
	Allocator
∫∫^ g
.
∫∫g h
Temp
∫∫h l
)
∫∫l m
;
∫∫m n
m_BlockRanges
ªª 
=
ªª 
new
ªª  #
NativeArray
ªª$ /
<
ªª/ 0
int
ªª0 3
>
ªª3 4
(
ªª4 5 
m_BlockEventLimits
ªª5 G
.
ªªG H
Length
ªªH N
+
ªªO P
$num
ªªQ R
,
ªªR S
	Allocator
ªªT ]
.
ªª] ^
Temp
ªª^ b
)
ªªb c
;
ªªc d!
m_BlockRangeLengths
ºº #
=
ºº$ %
new
ºº& )
NativeArray
ºº* 5
<
ºº5 6
int
ºº6 9
>
ºº9 :
(
ºº: ;
m_BlockRanges
ºº; H
.
ººH I
Length
ººI O
,
ººO P
	Allocator
ººQ Z
.
ººZ [
Temp
ºº[ _
)
ºº_ `
;
ºº` a 
m_BlockEventLimits
ææ "
[
ææ" #
RenderPassBlock
ææ# 2
.
ææ2 3
BeforeRendering
ææ3 B
]
ææB C
=
ææD E
RenderPassEvent
ææF U
.
ææU V&
BeforeRenderingPrepasses
ææV n
;
ææn o 
m_BlockEventLimits
øø "
[
øø" #
RenderPassBlock
øø# 2
.
øø2 3!
MainRenderingOpaque
øø3 F
]
øøF G
=
øøH I
RenderPassEvent
øøJ Y
.
øøY Z#
AfterRenderingOpaques
øøZ o
;
øøo p 
m_BlockEventLimits
¿¿ "
[
¿¿" #
RenderPassBlock
¿¿# 2
.
¿¿2 3&
MainRenderingTransparent
¿¿3 K
]
¿¿K L
=
¿¿M N
RenderPassEvent
¿¿O ^
.
¿¿^ _*
AfterRenderingPostProcessing
¿¿_ {
;
¿¿{ | 
m_BlockEventLimits
¡¡ "
[
¡¡" #
RenderPassBlock
¡¡# 2
.
¡¡2 3
AfterRendering
¡¡3 A
]
¡¡A B
=
¡¡C D
(
¡¡E F
RenderPassEvent
¡¡F U
)
¡¡U V
Int32
¡¡W \
.
¡¡\ ]
MaxValue
¡¡] e
;
¡¡e f
FillBlockRanges
∆∆ 
(
∆∆  #
activeRenderPassQueue
∆∆  5
)
∆∆5 6
;
∆∆6 7 
m_BlockEventLimits
«« "
.
««" #
Dispose
««# *
(
««* +
)
««+ ,
;
««, -
for
…… 
(
…… 
int
…… 
i
…… 
=
…… 
$num
…… 
;
…… 
i
……  !
<
……" #
m_BlockRanges
……$ 1
.
……1 2
Length
……2 8
-
……9 :
$num
……; <
;
……< =
i
……> ?
++
……? A
)
……A B
{
   !
m_BlockRangeLengths
ÀÀ '
[
ÀÀ' (
i
ÀÀ( )
]
ÀÀ) *
=
ÀÀ+ ,
m_BlockRanges
ÀÀ- :
[
ÀÀ: ;
i
ÀÀ; <
+
ÀÀ= >
$num
ÀÀ? @
]
ÀÀ@ A
-
ÀÀB C
m_BlockRanges
ÀÀD Q
[
ÀÀQ R
i
ÀÀR S
]
ÀÀS T
;
ÀÀT U
}
ÃÃ 
}
ÕÕ 
public
–– 
void
–– 
Dispose
–– 
(
––  
)
––  !
{
—— !
m_BlockRangeLengths
““ #
.
““# $
Dispose
““$ +
(
““+ ,
)
““, -
;
““- .
m_BlockRanges
”” 
.
”” 
Dispose
”” %
(
””% &
)
””& '
;
””' (
}
‘‘ 
void
◊◊ 
FillBlockRanges
◊◊  
(
◊◊  !
List
◊◊! %
<
◊◊% &"
ScriptableRenderPass
◊◊& :
>
◊◊: ;#
activeRenderPassQueue
◊◊< Q
)
◊◊Q R
{
ÿÿ 
int
ŸŸ 
currRangeIndex
ŸŸ "
=
ŸŸ# $
$num
ŸŸ% &
;
ŸŸ& '
int
⁄⁄ 
currRenderPass
⁄⁄ "
=
⁄⁄# $
$num
⁄⁄% &
;
⁄⁄& '
m_BlockRanges
€€ 
[
€€ 
currRangeIndex
€€ ,
++
€€, .
]
€€. /
=
€€0 1
$num
€€2 3
;
€€3 4
for
ﬂﬂ 
(
ﬂﬂ 
int
ﬂﬂ 
i
ﬂﬂ 
=
ﬂﬂ 
$num
ﬂﬂ 
;
ﬂﬂ 
i
ﬂﬂ  !
<
ﬂﬂ" # 
m_BlockEventLimits
ﬂﬂ$ 6
.
ﬂﬂ6 7
Length
ﬂﬂ7 =
-
ﬂﬂ> ?
$num
ﬂﬂ@ A
;
ﬂﬂA B
++
ﬂﬂC E
i
ﬂﬂE F
)
ﬂﬂF G
{
‡‡ 
while
·· 
(
·· 
currRenderPass
·· )
<
··* +#
activeRenderPassQueue
··, A
.
··A B
Count
··B G
&&
··H J#
activeRenderPassQueue
‚‚ 0
[
‚‚0 1
currRenderPass
‚‚1 ?
]
‚‚? @
.
‚‚@ A
renderPassEvent
‚‚A P
<
‚‚Q R 
m_BlockEventLimits
‚‚S e
[
‚‚e f
i
‚‚f g
]
‚‚g h
)
‚‚h i
currRenderPass
„„ &
++
„„& (
;
„„( )
m_BlockRanges
ÂÂ !
[
ÂÂ! "
currRangeIndex
ÂÂ" 0
++
ÂÂ0 2
]
ÂÂ2 3
=
ÂÂ4 5
currRenderPass
ÂÂ6 D
;
ÂÂD E
}
ÊÊ 
m_BlockRanges
ËË 
[
ËË 
currRangeIndex
ËË ,
]
ËË, -
=
ËË. /#
activeRenderPassQueue
ËË0 E
.
ËËE F
Count
ËËF K
;
ËËK L
}
ÈÈ 
public
ÎÎ 
int
ÎÎ 
	GetLength
ÎÎ  
(
ÎÎ  !
int
ÎÎ! $
index
ÎÎ% *
)
ÎÎ* +
{
ÏÏ 
return
ÌÌ !
m_BlockRangeLengths
ÌÌ *
[
ÌÌ* +
index
ÌÌ+ 0
]
ÌÌ0 1
;
ÌÌ1 2
}
ÓÓ 
public
ÒÒ 
struct
ÒÒ 

BlockRange
ÒÒ $
:
ÒÒ% &
IDisposable
ÒÒ' 2
{
ÚÚ 
int
ÛÛ 
	m_Current
ÛÛ 
;
ÛÛ 
int
ÙÙ 
m_End
ÙÙ 
;
ÙÙ 
public
ıı 

BlockRange
ıı !
(
ıı! "
int
ıı" %
begin
ıı& +
,
ıı+ ,
int
ıı- 0
end
ıı1 4
)
ıı4 5
{
ˆˆ 

Assertions
˜˜ 
.
˜˜ 
Assert
˜˜ %
.
˜˜% &
IsTrue
˜˜& ,
(
˜˜, -
begin
˜˜- 2
<=
˜˜3 5
end
˜˜6 9
)
˜˜9 :
;
˜˜: ;
	m_Current
¯¯ 
=
¯¯ 
begin
¯¯  %
<
¯¯& '
end
¯¯( +
?
¯¯, -
begin
¯¯. 3
:
¯¯4 5
end
¯¯6 9
;
¯¯9 :
m_End
˘˘ 
=
˘˘ 
end
˘˘ !
>=
˘˘" $
begin
˘˘% *
?
˘˘+ ,
end
˘˘- 0
:
˘˘1 2
begin
˘˘3 8
;
˘˘8 9
	m_Current
˙˙ 
-=
˙˙  
$num
˙˙! "
;
˙˙" #
}
˚˚ 
public
˝˝ 

BlockRange
˝˝ !
GetEnumerator
˝˝" /
(
˝˝/ 0
)
˝˝0 1
{
˝˝2 3
return
˝˝4 :
this
˝˝; ?
;
˝˝? @
}
˝˝A B
public
˛˛ 
bool
˛˛ 
MoveNext
˛˛ $
(
˛˛$ %
)
˛˛% &
{
˛˛' (
return
˛˛) /
++
˛˛0 2
	m_Current
˛˛2 ;
<
˛˛< =
m_End
˛˛> C
;
˛˛C D
}
˛˛E F
public
ˇˇ 
int
ˇˇ 
Current
ˇˇ "
{
ˇˇ# $
get
ˇˇ% (
=>
ˇˇ) +
	m_Current
ˇˇ, 5
;
ˇˇ5 6
}
ˇˇ7 8
public
Ä	Ä	 
void
Ä	Ä	 
Dispose
Ä	Ä	 #
(
Ä	Ä	# $
)
Ä	Ä	$ %
{
Ä	Ä	& '
}
Ä	Ä	' (
}
Å	Å	 
public
É	É	 

BlockRange
É	É	 
GetRange
É	É	 &
(
É	É	& '
int
É	É	' *
index
É	É	+ 0
)
É	É	0 1
{
Ñ	Ñ	 
return
Ö	Ö	 
new
Ö	Ö	 

BlockRange
Ö	Ö	 %
(
Ö	Ö	% &
m_BlockRanges
Ö	Ö	& 3
[
Ö	Ö	3 4
index
Ö	Ö	4 9
]
Ö	Ö	9 :
,
Ö	Ö	: ;
m_BlockRanges
Ö	Ö	< I
[
Ö	Ö	I J
index
Ö	Ö	J O
+
Ö	Ö	P Q
$num
Ö	Ö	R S
]
Ö	Ö	S T
)
Ö	Ö	T U
;
Ö	Ö	U V
}
Ü	Ü	 
}
á	á	 	
}
à	à	 
}â	â	 ÔV
≥D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Passes\Utility\Light2DLookupTexture.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
internal 
static 
class  
Light2DLookupTexture .
{ 
private 
static 
	Texture2D  %
s_PointLightLookupTexture! :
;: ;
private 
static 
	Texture2D  "
s_FalloffLookupTexture! 7
;7 8
public

 
static

 
Texture

 !
GetLightLookupTexture

 3
(

3 4
)

4 5
{ 	
if 
( %
s_PointLightLookupTexture )
==* ,
null- 1
)1 2%
s_PointLightLookupTexture )
=* +)
CreatePointLightLookupTexture, I
(I J
)J K
;K L
return %
s_PointLightLookupTexture ,
;, -
} 	
public 
static 
Texture #
GetFalloffLookupTexture 5
(5 6
)6 7
{ 	
if 
( "
s_FalloffLookupTexture &
==' )
null* .
). /"
s_FalloffLookupTexture &
=' (&
CreateFalloffLookupTexture) C
(C D
)D E
;E F
return "
s_FalloffLookupTexture )
;) *
} 	
private 
static 
	Texture2D  )
CreatePointLightLookupTexture! >
(> ?
)? @
{ 	
const 
int 
WIDTH 
= 
$num !
;! "
const 
int 
HEIGHT 
= 
$num "
;" #
var 
textureFormat 
= 
GraphicsFormat  .
.. /
R8G8B8A8_UNorm/ =
;= >
if 
( 
RenderingUtils 
. "
SupportsGraphicsFormat 5
(5 6
GraphicsFormat6 D
.D E
R16G16B16A16_SFloatE X
,X Y
FormatUsageZ e
.e f
	SetPixelsf o
)o p
)p q
textureFormat 
= 
GraphicsFormat  .
.. /
R16G16B16A16_SFloat/ B
;B C
else   
if   
(   
RenderingUtils   #
.  # $"
SupportsGraphicsFormat  $ :
(  : ;
GraphicsFormat  ; I
.  I J
R32G32B32A32_SFloat  J ]
,  ] ^
FormatUsage  _ j
.  j k
	SetPixels  k t
)  t u
)  u v
textureFormat!! 
=!! 
GraphicsFormat!!  .
.!!. /
R32G32B32A32_SFloat!!/ B
;!!B C
var## 
texture## 
=## 
new## 
	Texture2D## '
(##' (
WIDTH##( -
,##- .
HEIGHT##/ 5
,##5 6
textureFormat##7 D
,##D E 
TextureCreationFlags##F Z
.##Z [
None##[ _
)##_ `
;##` a
texture$$ 
.$$ 

filterMode$$ 
=$$  

FilterMode$$! +
.$$+ ,
Bilinear$$, 4
;$$4 5
texture%% 
.%% 
wrapMode%% 
=%% 
TextureWrapMode%% .
.%%. /
Clamp%%/ 4
;%%4 5
var&& 
center&& 
=&& 
new&& 
Vector2&& $
(&&$ %
WIDTH&&% *
/&&+ ,
$num&&- 1
,&&1 2
HEIGHT&&3 9
/&&: ;
$num&&< @
)&&@ A
;&&A B
for(( 
((( 
var(( 
y(( 
=(( 
$num(( 
;(( 
y(( 
<(( 
HEIGHT((  &
;((& '
y((( )
++(() +
)((+ ,
{)) 
for** 
(** 
var** 
x** 
=** 
$num** 
;** 
x**  !
<**" #
WIDTH**$ )
;**) *
x**+ ,
++**, .
)**. /
{++ 
var,, 
pos,, 
=,, 
new,, !
Vector2,," )
(,,) *
x,,* +
,,,+ ,
y,,- .
),,. /
;,,/ 0
var-- 
distance--  
=--! "
Vector2--# *
.--* +
Distance--+ 3
(--3 4
pos--4 7
,--7 8
center--9 ?
)--? @
;--@ A
var.. 
relPos.. 
=..  
pos..! $
-..% &
center..' -
;..- .
var// 
	direction// !
=//" #
center//$ *
-//+ ,
pos//- 0
;//0 1
	direction00 
.00 
	Normalize00 '
(00' (
)00( )
;00) *
float77 
red77 
;77 
if88 
(88 
x88 
==88 
WIDTH88 "
-88# $
$num88% &
||88' )
y88* +
==88, .
HEIGHT88/ 5
-886 7
$num888 9
)889 :
red99 
=99 
$num99 
;99  
else:: 
red;; 
=;; 
Mathf;; #
.;;# $
Clamp;;$ )
(;;) *
$num;;* +
-;;, -
(;;. /
$num;;/ 3
*;;4 5
distance;;6 >
/;;? @
WIDTH;;A F
);;F G
,;;G H
$num;;I M
,;;M N
$num;;O S
);;S T
;;;T U
var== 
cosAngle==  
===! "
Vector2==# *
.==* +
Dot==+ .
(==. /
Vector2==/ 6
.==6 7
down==7 ;
,==; <
relPos=== C
.==C D

normalized==D N
)==N O
;==O P
var>> 
angle>> 
=>> 
Mathf>>  %
.>>% &
Acos>>& *
(>>* +
cosAngle>>+ 3
)>>3 4
/>>5 6
Mathf>>7 <
.>>< =
PI>>= ?
;>>? @
var@@ 
green@@ 
=@@ 
Mathf@@  %
.@@% &
Clamp@@& +
(@@+ ,
$num@@, -
-@@. /
angle@@0 5
,@@5 6
$num@@7 ;
,@@; <
$num@@= A
)@@A B
;@@B C
varAA 
blueAA 
=AA 
	directionAA (
.AA( )
xAA) *
;AA* +
varBB 
alphaBB 
=BB 
	directionBB  )
.BB) *
yBB* +
;BB+ ,
varDD 
colorDD 
=DD 
newDD  #
ColorDD$ )
(DD) *
redDD* -
,DD- .
greenDD/ 4
,DD4 5
blueDD6 :
,DD: ;
alphaDD< A
)DDA B
;DDB C
textureFF 
.FF 
SetPixelFF $
(FF$ %
xFF% &
,FF& '
yFF( )
,FF) *
colorFF+ 0
)FF0 1
;FF1 2
}GG 
}HH 
textureII 
.II 
ApplyII 
(II 
)II 
;II 
returnJJ 
textureJJ 
;JJ 
}KK 	
privateMM 
staticMM 
	Texture2DMM  &
CreateFalloffLookupTextureMM! ;
(MM; <
)MM< =
{NN 	
constOO 
intOO 
WIDTHOO 
=OO 
$numOO "
;OO" #
constPP 
intPP 
HEIGHTPP 
=PP 
$numPP "
;PP" #
constRR 
GraphicsFormatRR  
textureFormatRR! .
=RR/ 0
GraphicsFormatRR1 ?
.RR? @
R8G8B8A8_SRGBRR@ M
;RRM N
varSS 
textureSS 
=SS 
newSS 
	Texture2DSS '
(SS' (
WIDTHSS( -
,SS- .
HEIGHTSS/ 5
-SS5 6
$numSS6 8
,SS8 9
textureFormatSS: G
,SSG H 
TextureCreationFlagsSSI ]
.SS] ^
NoneSS^ b
)SSb c
;SSc d
textureTT 
.TT 

filterModeTT 
=TT  

FilterModeTT! +
.TT+ ,
BilinearTT, 4
;TT4 5
textureUU 
.UU 
wrapModeUU 
=UU 
TextureWrapModeUU .
.UU. /
ClampUU/ 4
;UU4 5
forVV 
(VV 
varVV 
yVV 
=VV 
$numVV 
;VV 
yVV 
<VV 
HEIGHTVV %
;VV% &
yVV' (
++VV( *
)VV* +
{WW 
varXX 
	baseValueXX 
=XX 
(XX  !
floatXX! &
)XX& '
(XX' (
yXX( )
+XX) *
$numXX* ,
)XX, -
/XX. /
(XX/ 0
HEIGHTXX0 6
+XX6 7
$numXX7 9
)XX9 :
;XX: ;
varYY 
	lineValueYY 
=YY 
-YY  !
	baseValueYY! *
+YY+ ,
$numYY- .
;YY. /
varZZ 
exponentZZ 
=ZZ 
MathfZZ $
.ZZ$ %
LogZZ% (
(ZZ( )
	lineValueZZ) 2
)ZZ2 3
/ZZ4 5
MathfZZ6 ;
.ZZ; <
LogZZ< ?
(ZZ? @
	baseValueZZ@ I
)ZZI J
;ZZJ K
for\\ 
(\\ 
var\\ 
x\\ 
=\\ 
$num\\ 
;\\ 
x\\  !
<\\" #
WIDTH\\$ )
;\\) *
x\\+ ,
++\\, .
)\\. /
{]] 
var^^ 
t^^ 
=^^ 
(^^ 
float^^ "
)^^" #
x^^# $
/^^% &
WIDTH^^' ,
;^^, -
var__ 
red__ 
=__ 
Mathf__ #
.__# $
Pow__$ '
(__' (
t__( )
,__) *
exponent__+ 3
)__3 4
;__4 5
var`` 
color`` 
=`` 
new``  #
Color``$ )
(``) *
red``* -
,``- .
$num``/ 0
,``0 1
$num``2 3
,``3 4
$num``5 6
)``6 7
;``7 8
ifaa 
(aa 
yaa 
>=aa 
$numaa 
&&aa !
yaa" #
<aa$ %
$numaa& )
)aa) *
texturebb 
.bb  
SetPixelbb  (
(bb( )
xbb) *
,bb* +
ybb, -
-bb- .
$numbb. 0
,bb0 1
colorbb2 7
)bb7 8
;bb8 9
}cc 
}dd 
textureee 
.ee 
Applyee 
(ee 
)ee 
;ee 
returnff 
textureff 
;ff 
}gg 	
}
ÇÇ 
}ÉÉ µç
óD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Light2D.cs
	namespace

 	
UnityEngine


 
.

 
Experimental

 "
.

" #
	Rendering

# ,
.

, -
	Universal

- 6
{ 
[ 
ExecuteAlways 
, %
DisallowMultipleComponent -
]- .
[ 
AddComponentMenu 
( 
$str <
)< =
]= >
[ 
HelpURL 
( 
$str	 ê
)
ê ë
]
ë í
public 

sealed 
partial 
class 
Light2D  '
:( )
MonoBehaviour* 7
{ 
public 
enum 
	LightType 
{ 	

Parametric 
= 
$num 
, 
Freeform 
= 
$num 
, 
Sprite 
= 
$num 
, 
Point 
= 
$num 
, 
Global 
= 
$num 
} 	
["" 	
UnityEngine""	 
."" 

Animations"" 
.""  

NotKeyable""  *
]""* +
[$$ 	
SerializeField$$	 
]$$ 
	LightType$$ "
m_LightType$$# .
=$$/ 0
	LightType$$1 :
.$$: ;

Parametric$$; E
;$$E F
[%% 	
SerializeField%%	 
,%%  
FormerlySerializedAs%% -
(%%- .
$str%%. E
)%%E F
]%%F G
int&& 
m_BlendStyleIndex&& 
=&& 
$num&&  !
;&&! "
[(( 	
SerializeField((	 
](( 
float(( 
m_FalloffIntensity(( 1
=((2 3
$num((4 8
;((8 9
[** 	

ColorUsage**	 
(** 
false** 
)** 
]** 
[++ 	
SerializeField++	 
]++ 
Color++ 
m_Color++ &
=++' (
Color++) .
.++. /
white++/ 4
;++4 5
[,, 	
SerializeField,,	 
],, 
float,, 
m_Intensity,, *
=,,+ ,
$num,,- .
;,,. /
[.. 	
SerializeField..	 
].. 
float..  
m_LightVolumeOpacity.. 3
=..4 5
$num..6 :
;..: ;
[// 	
SerializeField//	 
]// 
int// 
[// 
]// "
m_ApplyToSortingLayers// 5
=//6 7
new//8 ;
int//< ?
[//? @
$num//@ A
]//A B
;//B C
[00 	
SerializeField00	 
]00 
Sprite00 
m_LightCookieSprite00  3
=004 5
null006 :
;00: ;
[11 	
SerializeField11	 
]11 
bool11 
m_UseNormalMap11 ,
=11- .
false11/ 4
;114 5
[33 	
SerializeField33	 
]33 
int33 
m_LightOrder33 )
=33* +
$num33, -
;33- .
[44 	
SerializeField44	 
]44 
bool44 !
m_AlphaBlendOnOverlap44 3
=444 5
false446 ;
;44; <
[66 	
Range66	 
(66 
$num66 
,66 
$num66 
)66 
]66 
[77 	
SerializeField77	 
]77 
float77 
m_ShadowIntensity77 0
=774 5
$num776 :
;77: ;
[88 	
Range88	 
(88 
$num88 
,88 
$num88 
)88 
]88 
[99 	
SerializeField99	 
]99 
float99 #
m_ShadowVolumeIntensity99 6
=997 8
$num999 =
;99= >
int<< '
m_PreviousLightCookieSprite<< '
;<<' (
Mesh== 
m_Mesh== 
;== 
internal?? 
int?? 
[?? 
]?? !
affectedSortingLayers?? ,
=>??- /"
m_ApplyToSortingLayers??0 F
;??F G
privateAA 
intAA '
lightCookieSpriteInstanceIDAA /
=>AA0 2
m_LightCookieSpriteAA3 F
?AAF G
.AAG H
GetInstanceIDAAH U
(AAU V
)AAV W
??AAX Z
$numAA[ \
;AA\ ]
privateCC 
BoundsCC 
m_LocalBoundsCC $
;CC$ %
internalDD 
BoundingSphereDD 
boundingSphereDD  .
{DD/ 0
getDD1 4
;DD4 5
privateDD6 =
setDD> A
;DDA B
}DDC D
internalFF 
MeshFF 
	lightMeshFF 
=>FF  "
m_MeshFF# )
;FF) *
publicKK 
	LightTypeKK 
	lightTypeKK "
{LL 	
getMM 
=>MM 
m_LightTypeMM 
;MM 
setNN 
{OO 
ifPP 
(PP 
m_LightTypePP 
!=PP !
valuePP" '
)PP' (

UpdateMeshQQ 
(QQ 
)QQ  
;QQ  !
m_LightTypeSS 
=SS 
valueSS #
;SS# $
Light2DManagerTT 
.TT '
ErrorIfDuplicateGlobalLightTT :
(TT: ;
thisTT; ?
)TT? @
;TT@ A
}UU 
}VV 	
public[[ 
int[[ 
blendStyleIndex[[ "
{[[# $
get[[% (
=>[[) +
m_BlendStyleIndex[[, =
;[[= >
set[[? B
=>[[C E
m_BlendStyleIndex[[F W
=[[X Y
value[[Z _
;[[_ `
}[[a b
public`` 
float`` 
shadowIntensity`` $
{``% &
get``' *
=>``+ -
m_ShadowIntensity``. ?
;``? @
set``A D
=>``E G
m_ShadowIntensity``H Y
=``Z [
Mathf``\ a
.``a b
Clamp01``b i
(``i j
value``j o
)``o p
;``p q
}``r s
publicee 
floatee !
shadowVolumeIntensityee *
{ee+ ,
getee- 0
=>ee1 3#
m_ShadowVolumeIntensityee4 K
;eeK L
seteeM P
=>eeQ S#
m_ShadowVolumeIntensityeeT k
=eel m
Mathfeen s
.ees t
Clamp01eet {
(ee{ |
value	ee| Å
)
eeÅ Ç
;
eeÇ É
}
eeÑ Ö
publicjj 
Colorjj 
colorjj 
{jj 
getjj  
=>jj! #
m_Colorjj$ +
;jj+ ,
setjj- 0
=>jj1 3
m_Colorjj4 ;
=jj< =
valuejj> C
;jjC D
}jjE F
publicoo 
floatoo 
	intensityoo 
{oo  
getoo! $
=>oo% '
m_Intensityoo( 3
;oo3 4
setoo5 8
=>oo9 ;
m_Intensityoo< G
=ooH I
valueooJ O
;ooO P
}ooQ R
publictt 
floattt 
volumeOpacitytt "
=>tt# % 
m_LightVolumeOpacitytt& :
;tt: ;
publicuu 
Spriteuu 
lightCookieSpriteuu '
=>uu( *
m_LightCookieSpriteuu+ >
;uu> ?
publicvv 
floatvv 
falloffIntensityvv %
=>vv& (
m_FalloffIntensityvv) ;
;vv; <
publicww 
boolww 
useNormalMapww  
=>ww! #
m_UseNormalMapww$ 2
;ww2 3
publicxx 
boolxx 
alphaBlendOnOverlapxx '
=>xx( *!
m_AlphaBlendOnOverlapxx+ @
;xx@ A
publicyy 
intyy 

lightOrderyy 
{yy 
getyy  #
=>yy$ &
m_LightOrderyy' 3
;yy3 4
setyy5 8
=>yy9 ;
m_LightOrderyy< H
=yyI J
valueyyK P
;yyP Q
}yyR S
internal{{ 
int{{ 
GetTopMostLitLayer{{ '
({{' (
){{( )
{|| 	
var}} 
largestIndex}} 
=}} 
-}}  
$num}}  !
;}}! "
var~~ 
largestLayer~~ 
=~~ 
$num~~  
;~~  !
var
ÄÄ 
layers
ÄÄ 
=
ÄÄ 
Light2DManager
ÄÄ '
.
ÄÄ' (#
GetCachedSortingLayer
ÄÄ( =
(
ÄÄ= >
)
ÄÄ> ?
;
ÄÄ? @
for
ÅÅ 
(
ÅÅ 
var
ÅÅ 
i
ÅÅ 
=
ÅÅ 
$num
ÅÅ 
;
ÅÅ 
i
ÅÅ 
<
ÅÅ $
m_ApplyToSortingLayers
ÅÅ  6
.
ÅÅ6 7
Length
ÅÅ7 =
;
ÅÅ= >
++
ÅÅ? A
i
ÅÅA B
)
ÅÅB C
{
ÇÇ 
for
ÉÉ 
(
ÉÉ 
var
ÉÉ 
layer
ÉÉ 
=
ÉÉ 
layers
ÉÉ  &
.
ÉÉ& '
Length
ÉÉ' -
-
ÉÉ. /
$num
ÉÉ0 1
;
ÉÉ1 2
layer
ÉÉ3 8
>=
ÉÉ9 ;
largestLayer
ÉÉ< H
;
ÉÉH I
--
ÉÉJ L
layer
ÉÉL Q
)
ÉÉQ R
{
ÑÑ 
if
ÖÖ 
(
ÖÖ 
layers
ÖÖ 
[
ÖÖ 
layer
ÖÖ $
]
ÖÖ$ %
.
ÖÖ% &
id
ÖÖ& (
==
ÖÖ) +$
m_ApplyToSortingLayers
ÖÖ, B
[
ÖÖB C
i
ÖÖC D
]
ÖÖD E
)
ÖÖE F
{
ÜÜ 
largestIndex
áá $
=
áá% &
i
áá' (
;
áá( )
largestLayer
àà $
=
àà% &
layer
àà' ,
;
àà, -
}
ââ 
}
ää 
}
ãã 
if
çç 
(
çç 
largestIndex
çç 
>=
çç 
$num
çç  !
)
çç! "
return
éé $
m_ApplyToSortingLayers
éé -
[
éé- .
largestIndex
éé. :
]
éé: ;
;
éé; <
else
èè 
return
êê 
-
êê 
$num
êê 
;
êê 
}
ëë 	
internal
ìì 
void
ìì 

UpdateMesh
ìì  
(
ìì  !
)
ìì! "
{
îî 	
switch
ïï 
(
ïï 
m_LightType
ïï 
)
ïï  
{
ññ 
case
óó 
	LightType
óó 
.
óó 
Freeform
óó '
:
óó' (
m_LocalBounds
òò !
=
òò" #
LightUtility
òò$ 0
.
òò0 1
GenerateShapeMesh
òò1 B
(
òòB C
m_Mesh
òòC I
,
òòI J
m_ShapePath
òòK V
,
òòV W%
m_ShapeLightFalloffSize
òòX o
)
òòo p
;
òòp q
break
ôô 
;
ôô 
case
öö 
	LightType
öö 
.
öö 

Parametric
öö )
:
öö) *
m_LocalBounds
õõ !
=
õõ" #
LightUtility
õõ$ 0
.
õõ0 1$
GenerateParametricMesh
õõ1 G
(
õõG H
m_Mesh
õõH N
,
õõN O*
m_ShapeLightParametricRadius
õõP l
,
õõl m&
m_ShapeLightFalloffSizeõõn Ö
,õõÖ Ü1
!m_ShapeLightParametricAngleOffsetõõá ®
,õõ® ©+
m_ShapeLightParametricSidesõõ™ ≈
)õõ≈ ∆
;õõ∆ «
break
úú 
;
úú 
case
ùù 
	LightType
ùù 
.
ùù 
Sprite
ùù %
:
ùù% &
m_LocalBounds
ûû !
=
ûû" #
LightUtility
ûû$ 0
.
ûû0 1 
GenerateSpriteMesh
ûû1 C
(
ûûC D
m_Mesh
ûûD J
,
ûûJ K!
m_LightCookieSprite
ûûL _
)
ûû_ `
;
ûû` a
break
üü 
;
üü 
case
†† 
	LightType
†† 
.
†† 
Point
†† $
:
††$ %
m_LocalBounds
°° !
=
°°" #
LightUtility
°°$ 0
.
°°0 1$
GenerateParametricMesh
°°1 G
(
°°G H
m_Mesh
°°H N
,
°°N O
$num
°°P Y
,
°°Y Z
$num
°°[ \
,
°°\ ]
$num
°°^ _
,
°°_ `
$num
°°a b
)
°°b c
;
°°c d
break
¢¢ 
;
¢¢ 
}
££ 
}
§§ 	
internal
¶¶ 
void
¶¶ "
UpdateBoundingSphere
¶¶ *
(
¶¶* +
)
¶¶+ ,
{
ßß 	
if
®® 
(
®® 
isPointLight
®® 
)
®® 
{
©© 
boundingSphere
™™ 
=
™™  
new
™™! $
BoundingSphere
™™% 3
(
™™3 4
	transform
™™4 =
.
™™= >
position
™™> F
,
™™F G%
m_PointLightOuterRadius
™™H _
)
™™_ `
;
™™` a
return
´´ 
;
´´ 
}
¨¨ 
var
ÆÆ 
maxBound
ÆÆ 
=
ÆÆ 
	transform
ÆÆ $
.
ÆÆ$ %
TransformPoint
ÆÆ% 3
(
ÆÆ3 4
Vector3
ÆÆ4 ;
.
ÆÆ; <
Max
ÆÆ< ?
(
ÆÆ? @
m_LocalBounds
ÆÆ@ M
.
ÆÆM N
max
ÆÆN Q
,
ÆÆQ R
m_LocalBounds
ÆÆS `
.
ÆÆ` a
max
ÆÆa d
+
ÆÆe f
(
ÆÆg h
Vector3
ÆÆh o
)
ÆÆo p(
m_ShapeLightFalloffOffsetÆÆp â
)ÆÆâ ä
)ÆÆä ã
;ÆÆã å
var
ØØ 
minBound
ØØ 
=
ØØ 
	transform
ØØ $
.
ØØ$ %
TransformPoint
ØØ% 3
(
ØØ3 4
Vector3
ØØ4 ;
.
ØØ; <
Min
ØØ< ?
(
ØØ? @
m_LocalBounds
ØØ@ M
.
ØØM N
min
ØØN Q
,
ØØQ R
m_LocalBounds
ØØS `
.
ØØ` a
min
ØØa d
+
ØØe f
(
ØØg h
Vector3
ØØh o
)
ØØo p(
m_ShapeLightFalloffOffsetØØp â
)ØØâ ä
)ØØä ã
;ØØã å
var
∞∞ 
center
∞∞ 
=
∞∞ 
$num
∞∞ 
*
∞∞ 
(
∞∞  !
maxBound
∞∞! )
+
∞∞* +
minBound
∞∞, 4
)
∞∞4 5
;
∞∞5 6
var
±± 
radius
±± 
=
±± 
Vector3
±±  
.
±±  !
	Magnitude
±±! *
(
±±* +
maxBound
±±+ 3
-
±±4 5
center
±±6 <
)
±±< =
;
±±= >
boundingSphere
≥≥ 
=
≥≥ 
new
≥≥  
BoundingSphere
≥≥! /
(
≥≥/ 0
center
≥≥0 6
,
≥≥6 7
radius
≥≥8 >
)
≥≥> ?
;
≥≥? @
}
¥¥ 	
internal
∂∂ 
bool
∂∂ 

IsLitLayer
∂∂  
(
∂∂  !
int
∂∂! $
layer
∂∂% *
)
∂∂* +
{
∑∑ 	
return
∏∏ $
m_ApplyToSortingLayers
∏∏ )
!=
∏∏* ,
null
∏∏- 1
?
∏∏2 3
Array
∏∏4 9
.
∏∏9 :
IndexOf
∏∏: A
(
∏∏A B$
m_ApplyToSortingLayers
∏∏B X
,
∏∏X Y
layer
∏∏Z _
)
∏∏_ `
>=
∏∏a c
$num
∏∏d e
:
∏∏f g
false
∏∏h m
;
∏∏m n
}
ππ 	
private
ªª 
void
ªª 
Awake
ªª 
(
ªª 
)
ªª 
{
ºº 	
m_Mesh
ΩΩ 
=
ΩΩ 
new
ΩΩ 
Mesh
ΩΩ 
(
ΩΩ 
)
ΩΩ 
;
ΩΩ  

UpdateMesh
ææ 
(
ææ 
)
ææ 
;
ææ 
}
øø 	
void
¡¡ 
OnEnable
¡¡ 
(
¡¡ 
)
¡¡ 
{
¬¬ 	)
m_PreviousLightCookieSprite
√√ '
=
√√( ))
lightCookieSpriteInstanceID
√√* E
;
√√E F
Light2DManager
ƒƒ 
.
ƒƒ 
RegisterLight
ƒƒ (
(
ƒƒ( )
this
ƒƒ) -
)
ƒƒ- .
;
ƒƒ. /
}
≈≈ 	
private
«« 
void
«« 
	OnDisable
«« 
(
«« 
)
««  
{
»» 	
Light2DManager
…… 
.
…… 
DeregisterLight
…… *
(
……* +
this
……+ /
)
……/ 0
;
……0 1
}
   	
private
ÃÃ 
void
ÃÃ 

LateUpdate
ÃÃ 
(
ÃÃ  
)
ÃÃ  !
{
ÕÕ 	
if
ŒŒ 
(
ŒŒ 
m_LightType
ŒŒ 
==
ŒŒ 
	LightType
ŒŒ (
.
ŒŒ( )
Global
ŒŒ) /
)
ŒŒ/ 0
return
œœ 
;
œœ 
if
““ 
(
““ 
LightUtility
““ 
.
““ 
CheckForChange
““ +
(
““+ ,%
m_ShapeLightFalloffSize
““, C
,
““C D
ref
““E H-
m_PreviousShapeLightFalloffSize
““I h
)
““h i
||
““j l
LightUtility
”” 
.
”” 
CheckForChange
”” +
(
””+ ,*
m_ShapeLightParametricRadius
””, H
,
””H I
ref
””J M2
$m_PreviousShapeLightParametricRadius
””N r
)
””r s
||
””t v
LightUtility
‘‘ 
.
‘‘ 
CheckForChange
‘‘ +
(
‘‘+ ,)
m_ShapeLightParametricSides
‘‘, G
,
‘‘G H
ref
‘‘I L1
#m_PreviousShapeLightParametricSides
‘‘M p
)
‘‘p q
||
‘‘r t
LightUtility
’’ 
.
’’ 
CheckForChange
’’ +
(
’’+ ,/
!m_ShapeLightParametricAngleOffset
’’, M
,
’’M N
ref
’’O R7
)m_PreviousShapeLightParametricAngleOffset
’’S |
)
’’| }
||’’~ Ä
LightUtility
÷÷ 
.
÷÷ 
CheckForChange
÷÷ +
(
÷÷+ ,)
lightCookieSpriteInstanceID
÷÷, G
,
÷÷G H
ref
÷÷I L)
m_PreviousLightCookieSprite
÷÷M h
)
÷÷h i
)
÷÷i j
{
◊◊ 

UpdateMesh
ÿÿ 
(
ÿÿ 
)
ÿÿ 
;
ÿÿ 
}
ŸŸ "
UpdateBoundingSphere
€€  
(
€€  !
)
€€! "
;
€€" #
}
‹‹ 	
}
›› 
}ﬁﬁ ˝⁄
öD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\DeferredTiler.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
internal 
struct 
DeferredTiler !
{ 
internal 
struct 
PrePunctualLight (
{ 	
public 
float3 
posVS 
;  
public 
float 
radius 
;  
public 
float 
minDist  
;  !
public 
float2 
	screenPos #
;# $
public 
ushort 
visLightIndex '
;' (
} 	
enum 

ClipResult 
{ 	
Unknown 
, 
In 
, 
Out   
,   
}!! 	
int## 
m_TilePixelWidth## 
;## 
int$$ 
m_TilePixelHeight$$ 
;$$ 
int%% 
m_TileXCount%% 
;%% 
int&& 
m_TileYCount&& 
;&& 
int)) 
m_TileHeaderSize)) 
;)) 
int++ 
m_AvgLightPerTile++ 
;++ 
int-- 
m_TilerLevel-- 
;-- 
FrustumPlanes00 
m_FrustumPlanes00 %
;00% &
bool22 
m_IsOrthographic22 
;22 
[88 	
Unity88	 
.88 
Collections88 
.88 
LowLevel88 #
.88# $
Unsafe88$ *
.88* +3
'NativeDisableContainerSafetyRestriction88+ R
]88R S
NativeArray99 
<99 
int99 
>99 

m_Counters99 #
;99# $
[AA 	
UnityAA	 
.AA 
CollectionsAA 
.AA 
LowLevelAA #
.AA# $
UnsafeAA$ *
.AA* +3
'NativeDisableContainerSafetyRestrictionAA+ R
]AAR S
NativeArrayBB 
<BB 
ushortBB 
>BB 

m_TileDataBB &
;BB& '
[FF 	
UnityFF	 
.FF 
CollectionsFF 
.FF 
LowLevelFF #
.FF# $
UnsafeFF$ *
.FF* +3
'NativeDisableContainerSafetyRestrictionFF+ R
]FFR S
NativeArrayGG 
<GG 
uintGG 
>GG 
m_TileHeadersGG '
;GG' (
[JJ 	
UnityJJ	 
.JJ 
CollectionsJJ 
.JJ 
LowLevelJJ #
.JJ# $
UnsafeJJ$ *
.JJ* +3
'NativeDisableContainerSafetyRestrictionJJ+ R
]JJR S
NativeArrayKK 
<KK 
PreTileKK 
>KK 

m_PreTilesKK '
;KK' (
publicMM 
DeferredTilerMM 
(MM 
intMM  
tilePixelWidthMM! /
,MM/ 0
intMM1 4
tilePixelHeightMM5 D
,MMD E
intMMF I
avgLightPerTileMMJ Y
,MMY Z
intMM[ ^

tilerLevelMM_ i
)MMi j
{NN 	
m_TilePixelWidthOO 
=OO 
tilePixelWidthOO -
;OO- .
m_TilePixelHeightPP 
=PP 
tilePixelHeightPP  /
;PP/ 0
m_TileXCountQQ 
=QQ 
$numQQ 
;QQ 
m_TileYCountRR 
=RR 
$numRR 
;RR 
m_TileHeaderSizeVV 
=VV 

tilerLevelVV )
==VV* ,
$numVV- .
?VV/ 0
$numVV1 2
:VV3 4
$numVV5 6
;VV6 7
m_AvgLightPerTileWW 
=WW 
avgLightPerTileWW  /
;WW/ 0
m_TilerLevelXX 
=XX 

tilerLevelXX %
;XX% &
m_FrustumPlanesYY 
=YY 
newYY !
FrustumPlanesYY" /
{YY0 1
leftYY2 6
=YY7 8
$numYY9 :
,YY: ;
rightYY< A
=YYB C
$numYYD E
,YYE F
bottomYYG M
=YYN O
$numYYP Q
,YYQ R
topYYS V
=YYW X
$numYYY Z
,YYZ [
zNearYY\ a
=YYb c
$numYYd e
,YYe f
zFarYYg k
=YYl m
$numYYn o
}YYp q
;YYq r
m_IsOrthographicZZ 
=ZZ 
falseZZ $
;ZZ$ %

m_Counters[[ 
=[[ 
new[[ 
NativeArray[[ (
<[[( )
int[[) ,
>[[, -
([[- .
)[[. /
;[[/ 0

m_TileData\\ 
=\\ 
new\\ 
NativeArray\\ (
<\\( )
ushort\\) /
>\\/ 0
(\\0 1
)\\1 2
;\\2 3
m_TileHeaders]] 
=]] 
new]] 
NativeArray]]  +
<]]+ ,
uint]], 0
>]]0 1
(]]1 2
)]]2 3
;]]3 4

m_PreTiles^^ 
=^^ 
new^^ 
NativeArray^^ (
<^^( )
PreTile^^) 0
>^^0 1
(^^1 2
)^^2 3
;^^3 4
}__ 	
publicaa 
intaa 

TilerLevelaa 
{bb 	
getcc 
{cc 
returncc 
m_TilerLevelcc %
;cc% &
}cc' (
}dd 	
publicff 
intff 

TileXCountff 
{gg 	
gethh 
{hh 
returnhh 
m_TileXCounthh %
;hh% &
}hh' (
}ii 	
publickk 
intkk 

TileYCountkk 
{ll 	
getmm 
{mm 
returnmm 
m_TileYCountmm %
;mm% &
}mm' (
}nn 	
publicpp 
intpp 
TilePixelWidthpp !
{qq 	
getrr 
{rr 
returnrr 
m_TilePixelWidthrr )
;rr) *
}rr+ ,
}ss 	
publicuu 
intuu 
TilePixelHeightuu "
{vv 	
getww 
{ww 
returnww 
m_TilePixelHeightww *
;ww* +
}ww, -
}xx 	
publiczz 
intzz 
TileHeaderSizezz !
{{{ 	
get|| 
{|| 
return|| 
m_TileHeaderSize|| )
;||) *
}||+ ,
}}} 	
public 
int 
MaxLightPerTile "
{
ÄÄ 	
get
ÅÅ 
{
ÅÅ 
return
ÅÅ 

m_Counters
ÅÅ #
.
ÅÅ# $
	IsCreated
ÅÅ$ -
?
ÅÅ. /

m_Counters
ÅÅ0 :
[
ÅÅ: ;
$num
ÅÅ; <
]
ÅÅ< =
:
ÅÅ> ?
$num
ÅÅ@ A
;
ÅÅA B
}
ÅÅC D
}
ÇÇ 	
public
ÑÑ 
int
ÑÑ 
TileDataCapacity
ÑÑ #
{
ÖÖ 	
get
ÜÜ 
{
ÜÜ 
return
ÜÜ 

m_Counters
ÜÜ #
.
ÜÜ# $
	IsCreated
ÜÜ$ -
?
ÜÜ. /

m_Counters
ÜÜ0 :
[
ÜÜ: ;
$num
ÜÜ; <
]
ÜÜ< =
:
ÜÜ> ?
$num
ÜÜ@ A
;
ÜÜA B
}
ÜÜC D
}
áá 	
public
ââ 
NativeArray
ââ 
<
ââ 
ushort
ââ !
>
ââ! "
Tiles
ââ# (
{
ää 	
get
ãã 
{
ãã 
return
ãã 

m_TileData
ãã #
;
ãã# $
}
ãã% &
}
åå 	
public
éé 
NativeArray
éé 
<
éé 
uint
éé 
>
éé  
TileHeaders
éé! ,
{
èè 	
get
êê 
{
êê 
return
êê 
m_TileHeaders
êê &
;
êê& '
}
êê( )
}
ëë 	
[
ìì 	

MethodImpl
ìì	 
(
ìì 
MethodImplOptions
ìì %
.
ìì% & 
AggressiveInlining
ìì& 8
)
ìì8 9
]
ìì9 :
public
îî 
void
îî #
GetTileOffsetAndCount
îî )
(
îî) *
int
îî* -
i
îî. /
,
îî/ 0
int
îî1 4
j
îî5 6
,
îî6 7
out
îî8 ;
int
îî< ?
offset
îî@ F
,
îîF G
out
îîH K
int
îîL O
count
îîP U
)
îîU V
{
ïï 	
int
ññ 
headerOffset
ññ 
=
ññ !
GetTileHeaderOffset
ññ 2
(
ññ2 3
i
ññ3 4
,
ññ4 5
j
ññ6 7
)
ññ7 8
;
ññ8 9
offset
óó 
=
óó 
(
óó 
int
óó 
)
óó 
m_TileHeaders
óó '
[
óó' (
headerOffset
óó( 4
+
óó5 6
$num
óó7 8
]
óó8 9
;
óó9 :
count
òò 
=
òò 
(
òò 
int
òò 
)
òò 
m_TileHeaders
òò &
[
òò& '
headerOffset
òò' 3
+
òò4 5
$num
òò6 7
]
òò7 8
;
òò8 9
}
ôô 	
[
õõ 	

MethodImpl
õõ	 
(
õõ 
MethodImplOptions
õõ %
.
õõ% & 
AggressiveInlining
õõ& 8
)
õõ8 9
]
õõ9 :
public
úú 
int
úú !
GetTileHeaderOffset
úú &
(
úú& '
int
úú' *
i
úú+ ,
,
úú, -
int
úú. 1
j
úú2 3
)
úú3 4
{
ùù 	
return
ûû 
(
ûû 
i
ûû 
+
ûû 
j
ûû 
*
ûû 
m_TileXCount
ûû (
)
ûû( )
*
ûû* +
m_TileHeaderSize
ûû, <
;
ûû< =
}
üü 	
public
¢¢ 
void
¢¢ 
Setup
¢¢ 
(
¢¢ 
int
¢¢ 
tileDataCapacity
¢¢ .
)
¢¢. /
{
££ 	
if
§§ 
(
§§ 
tileDataCapacity
§§  
<=
§§! #
$num
§§$ %
)
§§% &
tileDataCapacity
••  
=
••! "
m_TileXCount
••# /
*
••0 1
m_TileYCount
••2 >
*
••? @
m_AvgLightPerTile
••A R
;
••R S

m_Counters
ßß 
=
ßß 
new
ßß 
NativeArray
ßß (
<
ßß( )
int
ßß) ,
>
ßß, -
(
ßß- .
$num
ßß. /
,
ßß/ 0
	Allocator
ßß1 :
.
ßß: ;
Temp
ßß; ?
,
ßß? @ 
NativeArrayOptions
ßßA S
.
ßßS T!
UninitializedMemory
ßßT g
)
ßßg h
;
ßßh i

m_TileData
®® 
=
®® 
new
®® 
NativeArray
®® (
<
®®( )
ushort
®®) /
>
®®/ 0
(
®®0 1
tileDataCapacity
®®1 A
,
®®A B
	Allocator
®®C L
.
®®L M
Temp
®®M Q
,
®®Q R 
NativeArrayOptions
®®S e
.
®®e f!
UninitializedMemory
®®f y
)
®®y z
;
®®z {
m_TileHeaders
©© 
=
©© 
new
©© 
NativeArray
©©  +
<
©©+ ,
uint
©©, 0
>
©©0 1
(
©©1 2
m_TileXCount
©©2 >
*
©©? @
m_TileYCount
©©A M
*
©©N O
m_TileHeaderSize
©©P `
,
©©` a
	Allocator
©©b k
.
©©k l
Temp
©©l p
,
©©p q!
NativeArrayOptions©©r Ñ
.©©Ñ Ö#
UninitializedMemory©©Ö ò
)©©ò ô
;©©ô ö

m_Counters
´´ 
[
´´ 
$num
´´ 
]
´´ 
=
´´ 
$num
´´ 
;
´´ 

m_Counters
¨¨ 
[
¨¨ 
$num
¨¨ 
]
¨¨ 
=
¨¨ 
$num
¨¨ 
;
¨¨ 

m_Counters
≠≠ 
[
≠≠ 
$num
≠≠ 
]
≠≠ 
=
≠≠ 
tileDataCapacity
≠≠ ,
;
≠≠, -
}
ÆÆ 	
public
∞∞ 
void
∞∞ 
OnCameraCleanup
∞∞ #
(
∞∞# $
)
∞∞$ %
{
±± 	
if
≤≤ 
(
≤≤ 
m_TileHeaders
≤≤ 
.
≤≤ 
	IsCreated
≤≤ '
)
≤≤' (
m_TileHeaders
≥≥ 
.
≥≥ 
Dispose
≥≥ %
(
≥≥% &
)
≥≥& '
;
≥≥' (
if
¥¥ 
(
¥¥ 

m_TileData
¥¥ 
.
¥¥ 
	IsCreated
¥¥ $
)
¥¥$ %

m_TileData
µµ 
.
µµ 
Dispose
µµ "
(
µµ" #
)
µµ# $
;
µµ$ %
if
∂∂ 
(
∂∂ 

m_Counters
∂∂ 
.
∂∂ 
	IsCreated
∂∂ $
)
∂∂$ %

m_Counters
∑∑ 
.
∑∑ 
Dispose
∑∑ "
(
∑∑" #
)
∑∑# $
;
∑∑$ %
}
∏∏ 	
public
∫∫ 
void
∫∫ 
PrecomputeTiles
∫∫ #
(
∫∫# $
	Matrix4x4
∫∫$ -
proj
∫∫. 2
,
∫∫2 3
bool
∫∫4 8
isOrthographic
∫∫9 G
,
∫∫G H
int
∫∫I L
renderWidth
∫∫M X
,
∫∫X Y
int
∫∫Z ]
renderHeight
∫∫^ j
)
∫∫j k
{
ªª 	
m_TileXCount
ºº 
=
ºº 
(
ºº 
renderWidth
ºº '
+
ºº( )
m_TilePixelWidth
ºº* :
-
ºº; <
$num
ºº= >
)
ºº> ?
/
ºº@ A
m_TilePixelWidth
ººB R
;
ººR S
m_TileYCount
ΩΩ 
=
ΩΩ 
(
ΩΩ 
renderHeight
ΩΩ (
+
ΩΩ) *
m_TilePixelHeight
ΩΩ+ <
-
ΩΩ= >
$num
ΩΩ? @
)
ΩΩ@ A
/
ΩΩB C
m_TilePixelHeight
ΩΩD U
;
ΩΩU V

m_PreTiles
øø 
=
øø  
DeferredShaderData
øø +
.
øø+ ,
instance
øø, 4
.
øø4 5
GetPreTiles
øø5 @
(
øø@ A
m_TilerLevel
øøA M
,
øøM N
m_TileXCount
øøO [
*
øø\ ]
m_TileYCount
øø^ j
)
øøj k
;
øøk l
int
¬¬ !
adjustedRenderWidth
¬¬ #
=
¬¬$ %
Align
¬¬& +
(
¬¬+ ,
renderWidth
¬¬, 7
,
¬¬7 8
m_TilePixelWidth
¬¬9 I
)
¬¬I J
;
¬¬J K
int
√√ "
adjustedRenderHeight
√√ $
=
√√% &
Align
√√' ,
(
√√, -
renderHeight
√√- 9
,
√√9 :
m_TilePixelHeight
√√; L
)
√√L M
;
√√M N
m_FrustumPlanes
∆∆ 
=
∆∆ 
proj
∆∆ "
.
∆∆" #!
decomposeProjection
∆∆# 6
;
∆∆6 7
m_FrustumPlanes
«« 
.
«« 
right
«« !
=
««" #
m_FrustumPlanes
««$ 3
.
««3 4
left
««4 8
+
««9 :
(
««; <
m_FrustumPlanes
««< K
.
««K L
right
««L Q
-
««R S
m_FrustumPlanes
««T c
.
««c d
left
««d h
)
««h i
*
««j k
(
««l m"
adjustedRenderWidth««m Ä
/««Å Ç
(««É Ñ
float««Ñ â
)««â ä
renderWidth««ä ï
)««ï ñ
;««ñ ó
m_FrustumPlanes
»» 
.
»» 
bottom
»» "
=
»»# $
m_FrustumPlanes
»»% 4
.
»»4 5
top
»»5 8
+
»»9 :
(
»»; <
m_FrustumPlanes
»»< K
.
»»K L
bottom
»»L R
-
»»S T
m_FrustumPlanes
»»U d
.
»»d e
top
»»e h
)
»»h i
*
»»j k
(
»»l m#
adjustedRenderHeight»»m Å
/»»Ç É
(»»Ñ Ö
float»»Ö ä
)»»ä ã
renderHeight»»ã ó
)»»ó ò
;»»ò ô
m_IsOrthographic
…… 
=
…… 
isOrthographic
…… -
;
……- .
float
ÃÃ 
tileWidthWS
ÃÃ 
=
ÃÃ 
(
ÃÃ  !
m_FrustumPlanes
ÃÃ! 0
.
ÃÃ0 1
right
ÃÃ1 6
-
ÃÃ7 8
m_FrustumPlanes
ÃÃ9 H
.
ÃÃH I
left
ÃÃI M
)
ÃÃM N
/
ÃÃO P
m_TileXCount
ÃÃQ ]
;
ÃÃ] ^
float
ÕÕ 
tileHeightWS
ÕÕ 
=
ÕÕ  
(
ÕÕ! "
m_FrustumPlanes
ÕÕ" 1
.
ÕÕ1 2
top
ÕÕ2 5
-
ÕÕ6 7
m_FrustumPlanes
ÕÕ8 G
.
ÕÕG H
bottom
ÕÕH N
)
ÕÕN O
/
ÕÕP Q
m_TileYCount
ÕÕR ^
;
ÕÕ^ _
if
œœ 
(
œœ 
!
œœ 
isOrthographic
œœ 
)
œœ  
{
–– 
for
—— 
(
—— 
int
—— 
j
—— 
=
—— 
$num
—— 
;
—— 
j
——  !
<
——" #
m_TileYCount
——$ 0
;
——0 1
++
——2 4
j
——4 5
)
——5 6
{
““ 
float
”” 
tileTop
”” !
=
””" #
m_FrustumPlanes
””$ 3
.
””3 4
top
””4 7
-
””8 9
tileHeightWS
””: F
*
””G H
j
””I J
;
””J K
float
‘‘ 

tileBottom
‘‘ $
=
‘‘% &
tileTop
‘‘' .
-
‘‘/ 0
tileHeightWS
‘‘1 =
;
‘‘= >
for
÷÷ 
(
÷÷ 
int
÷÷ 
i
÷÷ 
=
÷÷  
$num
÷÷! "
;
÷÷" #
i
÷÷$ %
<
÷÷& '
m_TileXCount
÷÷( 4
;
÷÷4 5
++
÷÷6 8
i
÷÷8 9
)
÷÷9 :
{
◊◊ 
float
ÿÿ 
tileLeft
ÿÿ &
=
ÿÿ' (
m_FrustumPlanes
ÿÿ) 8
.
ÿÿ8 9
left
ÿÿ9 =
+
ÿÿ> ?
tileWidthWS
ÿÿ@ K
*
ÿÿL M
i
ÿÿN O
;
ÿÿO P
float
ŸŸ 
	tileRight
ŸŸ '
=
ŸŸ( )
tileLeft
ŸŸ* 2
+
ŸŸ3 4
tileWidthWS
ŸŸ5 @
;
ŸŸ@ A
PreTile
›› 
preTile
››  '
;
››' (
preTile
ﬁﬁ 
.
ﬁﬁ  
	planeLeft
ﬁﬁ  )
=
ﬁﬁ* +
	MakePlane
ﬁﬁ, 5
(
ﬁﬁ5 6
new
ﬁﬁ6 9
float3
ﬁﬁ: @
(
ﬁﬁ@ A
tileLeft
ﬁﬁA I
,
ﬁﬁI J

tileBottom
ﬁﬁK U
,
ﬁﬁU V
-
ﬁﬁW X
m_FrustumPlanes
ﬁﬁX g
.
ﬁﬁg h
zNear
ﬁﬁh m
)
ﬁﬁm n
,
ﬁﬁn o
new
ﬁﬁp s
float3
ﬁﬁt z
(
ﬁﬁz {
tileLeftﬁﬁ{ É
,ﬁﬁÉ Ñ
tileTopﬁﬁÖ å
,ﬁﬁå ç
-ﬁﬁé è
m_FrustumPlanesﬁﬁè û
.ﬁﬁû ü
zNearﬁﬁü §
)ﬁﬁ§ •
)ﬁﬁ• ¶
;ﬁﬁ¶ ß
preTile
ﬂﬂ 
.
ﬂﬂ  

planeRight
ﬂﬂ  *
=
ﬂﬂ+ ,
	MakePlane
ﬂﬂ- 6
(
ﬂﬂ6 7
new
ﬂﬂ7 :
float3
ﬂﬂ; A
(
ﬂﬂA B
	tileRight
ﬂﬂB K
,
ﬂﬂK L
tileTop
ﬂﬂM T
,
ﬂﬂT U
-
ﬂﬂV W
m_FrustumPlanes
ﬂﬂW f
.
ﬂﬂf g
zNear
ﬂﬂg l
)
ﬂﬂl m
,
ﬂﬂm n
new
ﬂﬂo r
float3
ﬂﬂs y
(
ﬂﬂy z
	tileRightﬂﬂz É
,ﬂﬂÉ Ñ

tileBottomﬂﬂÖ è
,ﬂﬂè ê
-ﬂﬂë í
m_FrustumPlanesﬂﬂí °
.ﬂﬂ° ¢
zNearﬂﬂ¢ ß
)ﬂﬂß ®
)ﬂﬂ® ©
;ﬂﬂ© ™
preTile
‡‡ 
.
‡‡  
planeBottom
‡‡  +
=
‡‡, -
	MakePlane
‡‡. 7
(
‡‡7 8
new
‡‡8 ;
float3
‡‡< B
(
‡‡B C
	tileRight
‡‡C L
,
‡‡L M

tileBottom
‡‡N X
,
‡‡X Y
-
‡‡Z [
m_FrustumPlanes
‡‡[ j
.
‡‡j k
zNear
‡‡k p
)
‡‡p q
,
‡‡q r
new
‡‡s v
float3
‡‡w }
(
‡‡} ~
tileLeft‡‡~ Ü
,‡‡Ü á

tileBottom‡‡à í
,‡‡í ì
-‡‡î ï
m_FrustumPlanes‡‡ï §
.‡‡§ •
zNear‡‡• ™
)‡‡™ ´
)‡‡´ ¨
;‡‡¨ ≠
preTile
·· 
.
··  
planeTop
··  (
=
··) *
	MakePlane
··+ 4
(
··4 5
new
··5 8
float3
··9 ?
(
··? @
tileLeft
··@ H
,
··H I
tileTop
··J Q
,
··Q R
-
··S T
m_FrustumPlanes
··T c
.
··c d
zNear
··d i
)
··i j
,
··j k
new
··l o
float3
··p v
(
··v w
	tileRight··w Ä
,··Ä Å
tileTop··Ç â
,··â ä
-··ã å
m_FrustumPlanes··å õ
.··õ ú
zNear··ú °
)··° ¢
)··¢ £
;··£ §

m_PreTiles
„„ "
[
„„" #
i
„„# $
+
„„% &
j
„„' (
*
„„) *
m_TileXCount
„„+ 7
]
„„7 8
=
„„9 :
preTile
„„; B
;
„„B C
}
‰‰ 
}
ÂÂ 
}
ÊÊ 
else
ÁÁ 
{
ËË 
for
ÈÈ 
(
ÈÈ 
int
ÈÈ 
j
ÈÈ 
=
ÈÈ 
$num
ÈÈ 
;
ÈÈ 
j
ÈÈ  !
<
ÈÈ" #
m_TileYCount
ÈÈ$ 0
;
ÈÈ0 1
++
ÈÈ2 4
j
ÈÈ4 5
)
ÈÈ5 6
{
ÍÍ 
float
ÎÎ 
tileTop
ÎÎ !
=
ÎÎ" #
m_FrustumPlanes
ÎÎ$ 3
.
ÎÎ3 4
top
ÎÎ4 7
-
ÎÎ8 9
tileHeightWS
ÎÎ: F
*
ÎÎG H
j
ÎÎI J
;
ÎÎJ K
float
ÏÏ 

tileBottom
ÏÏ $
=
ÏÏ% &
tileTop
ÏÏ' .
-
ÏÏ/ 0
tileHeightWS
ÏÏ1 =
;
ÏÏ= >
for
ÓÓ 
(
ÓÓ 
int
ÓÓ 
i
ÓÓ 
=
ÓÓ  
$num
ÓÓ! "
;
ÓÓ" #
i
ÓÓ$ %
<
ÓÓ& '
m_TileXCount
ÓÓ( 4
;
ÓÓ4 5
++
ÓÓ6 8
i
ÓÓ8 9
)
ÓÓ9 :
{
ÔÔ 
float
 
tileLeft
 &
=
' (
m_FrustumPlanes
) 8
.
8 9
left
9 =
+
> ?
tileWidthWS
@ K
*
L M
i
N O
;
O P
float
ÒÒ 
	tileRight
ÒÒ '
=
ÒÒ( )
tileLeft
ÒÒ* 2
+
ÒÒ3 4
tileWidthWS
ÒÒ5 @
;
ÒÒ@ A
PreTile
ÙÙ 
preTile
ÙÙ  '
;
ÙÙ' (
preTile
ıı 
.
ıı  
	planeLeft
ıı  )
=
ıı* +
	MakePlane
ıı, 5
(
ıı5 6
new
ıı6 9
float3
ıı: @
(
ıı@ A
tileLeft
ııA I
,
ııI J

tileBottom
ııK U
,
ııU V
-
ııW X
m_FrustumPlanes
ııX g
.
ııg h
zNear
ııh m
)
ıım n
,
ıın o
new
ııp s
float3
ııt z
(
ıız {
tileLeftıı{ É
,ııÉ Ñ

tileBottomııÖ è
,ııè ê
-ııë í
m_FrustumPlanesııí °
.ıı° ¢
zNearıı¢ ß
-ıı® ©
$numıı™ Æ
)ııÆ Ø
,ııØ ∞
newıı± ¥
float3ııµ ª
(ııª º
tileLeftııº ƒ
,ııƒ ≈
tileTopıı∆ Õ
,ııÕ Œ
-ııœ –
m_FrustumPlanesıı– ﬂ
.ııﬂ ‡
zNearıı‡ Â
)ııÂ Ê
)ııÊ Á
;ııÁ Ë
preTile
ˆˆ 
.
ˆˆ  

planeRight
ˆˆ  *
=
ˆˆ+ ,
	MakePlane
ˆˆ- 6
(
ˆˆ6 7
new
ˆˆ7 :
float3
ˆˆ; A
(
ˆˆA B
	tileRight
ˆˆB K
,
ˆˆK L
tileTop
ˆˆM T
,
ˆˆT U
-
ˆˆV W
m_FrustumPlanes
ˆˆW f
.
ˆˆf g
zNear
ˆˆg l
)
ˆˆl m
,
ˆˆm n
new
ˆˆo r
float3
ˆˆs y
(
ˆˆy z
	tileRightˆˆz É
,ˆˆÉ Ñ
tileTopˆˆÖ å
,ˆˆå ç
-ˆˆé è
m_FrustumPlanesˆˆè û
.ˆˆû ü
zNearˆˆü §
-ˆˆ• ¶
$numˆˆß ´
)ˆˆ´ ¨
,ˆˆ¨ ≠
newˆˆÆ ±
float3ˆˆ≤ ∏
(ˆˆ∏ π
	tileRightˆˆπ ¬
,ˆˆ¬ √

tileBottomˆˆƒ Œ
,ˆˆŒ œ
-ˆˆ– —
m_FrustumPlanesˆˆ— ‡
.ˆˆ‡ ·
zNearˆˆ· Ê
)ˆˆÊ Á
)ˆˆÁ Ë
;ˆˆË È
preTile
˜˜ 
.
˜˜  
planeBottom
˜˜  +
=
˜˜, -
	MakePlane
˜˜. 7
(
˜˜7 8
new
˜˜8 ;
float3
˜˜< B
(
˜˜B C
	tileRight
˜˜C L
,
˜˜L M

tileBottom
˜˜N X
,
˜˜X Y
-
˜˜Z [
m_FrustumPlanes
˜˜[ j
.
˜˜j k
zNear
˜˜k p
)
˜˜p q
,
˜˜q r
new
˜˜s v
float3
˜˜w }
(
˜˜} ~
	tileRight˜˜~ á
,˜˜á à

tileBottom˜˜â ì
,˜˜ì î
-˜˜ï ñ
m_FrustumPlanes˜˜ñ •
.˜˜• ¶
zNear˜˜¶ ´
-˜˜¨ ≠
$num˜˜Æ ≤
)˜˜≤ ≥
,˜˜≥ ¥
new˜˜µ ∏
float3˜˜π ø
(˜˜ø ¿
tileLeft˜˜¿ »
,˜˜» …

tileBottom˜˜  ‘
,˜˜‘ ’
-˜˜÷ ◊
m_FrustumPlanes˜˜◊ Ê
.˜˜Ê Á
zNear˜˜Á Ï
)˜˜Ï Ì
)˜˜Ì Ó
;˜˜Ó Ô
preTile
¯¯ 
.
¯¯  
planeTop
¯¯  (
=
¯¯) *
	MakePlane
¯¯+ 4
(
¯¯4 5
new
¯¯5 8
float3
¯¯9 ?
(
¯¯? @
tileLeft
¯¯@ H
,
¯¯H I
tileTop
¯¯J Q
,
¯¯Q R
-
¯¯S T
m_FrustumPlanes
¯¯T c
.
¯¯c d
zNear
¯¯d i
)
¯¯i j
,
¯¯j k
new
¯¯l o
float3
¯¯p v
(
¯¯v w
tileLeft
¯¯w 
,¯¯ Ä
tileTop¯¯Å à
,¯¯à â
-¯¯ä ã
m_FrustumPlanes¯¯ã ö
.¯¯ö õ
zNear¯¯õ †
-¯¯° ¢
$num¯¯£ ß
)¯¯ß ®
,¯¯® ©
new¯¯™ ≠
float3¯¯Æ ¥
(¯¯¥ µ
	tileRight¯¯µ æ
,¯¯æ ø
tileTop¯¯¿ «
,¯¯« »
-¯¯…  
m_FrustumPlanes¯¯  Ÿ
.¯¯Ÿ ⁄
zNear¯¯⁄ ﬂ
)¯¯ﬂ ‡
)¯¯‡ ·
;¯¯· ‚

m_PreTiles
˙˙ "
[
˙˙" #
i
˙˙# $
+
˙˙% &
j
˙˙' (
*
˙˙) *
m_TileXCount
˙˙+ 7
]
˙˙7 8
=
˙˙9 :
preTile
˙˙; B
;
˙˙B C
}
˚˚ 
}
¸¸ 
}
˝˝ 
}
˛˛ 	
unsafe
ÑÑ 
public
ÑÑ 
void
ÑÑ 
CullFinalLights
ÑÑ *
(
ÑÑ* +
ref
ÑÑ+ .
NativeArray
ÑÑ/ :
<
ÑÑ: ;
PrePunctualLight
ÑÑ; K
>
ÑÑK L
punctualLights
ÑÑM [
,
ÑÑ[ \
ref
ÖÖ+ .
NativeArray
ÖÖ/ :
<
ÖÖ: ;
ushort
ÖÖ; A
>
ÖÖA B
lightIndices
ÖÖC O
,
ÖÖO P
int
ÖÖQ T
lightStartIndex
ÖÖU d
,
ÖÖd e
int
ÖÖf i

lightCount
ÖÖj t
,
ÖÖt u
int
ÜÜ+ .
istart
ÜÜ/ 5
,
ÜÜ5 6
int
ÜÜ7 :
iend
ÜÜ; ?
,
ÜÜ? @
int
ÜÜA D
jstart
ÜÜE K
,
ÜÜK L
int
ÜÜM P
jend
ÜÜQ U
)
ÜÜU V
{
áá 	
PrePunctualLight
ââ 
*
ââ 
_punctualLights
ââ -
=
ââ. /
(
ââ0 1
PrePunctualLight
ââ1 A
*
ââA B
)
ââB C&
NativeArrayUnsafeUtility
ââC [
.
ââ[ \1
#GetUnsafeBufferPointerWithoutChecks
ââ\ 
(ââ Ä
punctualLightsââÄ é
)ââé è
;ââè ê
ushort
ää 
*
ää 
_lightIndices
ää !
=
ää" #
(
ää$ %
ushort
ää% +
*
ää+ ,
)
ää, -&
NativeArrayUnsafeUtility
ää- E
.
ääE F1
#GetUnsafeBufferPointerWithoutChecks
ääF i
(
ääi j
lightIndices
ääj v
)
ääv w
;
ääw x
uint
ãã 
*
ãã 
_tileHeaders
ãã 
=
ãã  
(
ãã! "
uint
ãã" &
*
ãã& '
)
ãã' (&
NativeArrayUnsafeUtility
ãã( @
.
ãã@ A1
#GetUnsafeBufferPointerWithoutChecks
ããA d
(
ããd e
m_TileHeaders
ããe r
)
ããr s
;
ããs t
if
çç 
(
çç 

lightCount
çç 
==
çç 
$num
çç 
)
çç  
{
éé 
for
èè 
(
èè 
int
èè 
j
èè 
=
èè 
jstart
èè #
;
èè# $
j
èè% &
<
èè' (
jend
èè) -
;
èè- .
++
èè/ 1
j
èè1 2
)
èè2 3
for
êê 
(
êê 
int
êê 
i
êê 
=
êê 
istart
êê #
;
êê# $
i
êê% &
<
êê' (
iend
êê) -
;
êê- .
++
êê/ 1
i
êê1 2
)
êê2 3
{
ëë 
int
íí 
headerOffset
íí $
=
íí% &!
GetTileHeaderOffset
íí' :
(
íí: ;
i
íí; <
,
íí< =
j
íí> ?
)
íí? @
;
íí@ A
_tileHeaders
ìì  
[
ìì  !
headerOffset
ìì! -
+
ìì. /
$num
ìì0 1
]
ìì1 2
=
ìì3 4
$num
ìì5 6
;
ìì6 7
_tileHeaders
îî  
[
îî  !
headerOffset
îî! -
+
îî. /
$num
îî0 1
]
îî1 2
=
îî3 4
$num
îî5 6
;
îî6 7
_tileHeaders
ïï  
[
ïï  !
headerOffset
ïï! -
+
ïï. /
$num
ïï0 1
]
ïï1 2
=
ïï3 4
$num
ïï5 6
;
ïï6 7
_tileHeaders
ññ  
[
ññ  !
headerOffset
ññ! -
+
ññ. /
$num
ññ0 1
]
ññ1 2
=
ññ3 4
$num
ññ5 6
;
ññ6 7
}
óó 
return
òò 
;
òò 
}
ôô 
ushort
ûû 
*
ûû 
tiles
ûû 
=
ûû 

stackalloc
ûû &
ushort
ûû' -
[
ûû- .

lightCount
ûû. 8
*
ûû8 9
$num
ûû9 :
]
ûû: ;
;
ûû; <
float2
üü 
*
üü 
depthRanges
üü 
=
üü  !

stackalloc
üü" ,
float2
üü- 3
[
üü3 4

lightCount
üü4 >
]
üü> ?
;
üü? @
int
°° 
maxLightPerTile
°° 
=
°°  !
$num
°°" #
;
°°# $
int
¢¢ 
lightEndIndex
¢¢ 
=
¢¢ 
lightStartIndex
¢¢  /
+
¢¢0 1

lightCount
¢¢2 <
;
¢¢< =
float2
££ 
tileSize
££ 
=
££ 
new
££ !
float2
££" (
(
££( )
(
££) *
m_FrustumPlanes
££* 9
.
££9 :
right
££: ?
-
££@ A
m_FrustumPlanes
££B Q
.
££Q R
left
££R V
)
££V W
/
££X Y
m_TileXCount
££Z f
,
££f g
(
££h i
m_FrustumPlanes
££i x
.
££x y
top
££y |
-
££} ~
m_FrustumPlanes££ é
.££é è
bottom££è ï
)££ï ñ
/££ó ò
m_TileYCount££ô •
)££• ¶
;££¶ ß
float2
§§ 
tileExtents
§§ 
=
§§  
tileSize
§§! )
*
§§* +
$num
§§, 0
;
§§0 1
float2
•• 
tileExtentsInv
•• !
=
••" #
new
••$ '
float2
••( .
(
••. /
$num
••/ 3
/
••4 5
tileExtents
••6 A
.
••A B
x
••B C
,
••C D
$num
••E I
/
••J K
tileExtents
••L W
.
••W X
y
••X Y
)
••Y Z
;
••Z [
for
ßß 
(
ßß 
int
ßß 
j
ßß 
=
ßß 
jstart
ßß 
;
ßß  
j
ßß! "
<
ßß# $
jend
ßß% )
;
ßß) *
++
ßß+ -
j
ßß- .
)
ßß. /
{
®® 
float
©© 
tileYCentre
©© !
=
©©" #
m_FrustumPlanes
©©$ 3
.
©©3 4
top
©©4 7
-
©©8 9
(
©©: ;
tileExtents
©©; F
.
©©F G
y
©©G H
+
©©I J
j
©©K L
*
©©M N
tileSize
©©O W
.
©©W X
y
©©X Y
)
©©Y Z
;
©©Z [
for
´´ 
(
´´ 
int
´´ 
i
´´ 
=
´´ 
istart
´´ #
;
´´# $
i
´´% &
<
´´' (
iend
´´) -
;
´´- .
++
´´/ 1
i
´´1 2
)
´´2 3
{
¨¨ 
float
≠≠ 
tileXCentre
≠≠ %
=
≠≠& '
m_FrustumPlanes
≠≠( 7
.
≠≠7 8
left
≠≠8 <
+
≠≠= >
tileExtents
≠≠? J
.
≠≠J K
x
≠≠K L
+
≠≠M N
i
≠≠O P
*
≠≠Q R
tileSize
≠≠S [
.
≠≠[ \
x
≠≠\ ]
;
≠≠] ^
PreTile
ØØ 
preTile
ØØ #
=
ØØ$ %

m_PreTiles
ØØ& 0
[
ØØ0 1
i
ØØ1 2
+
ØØ3 4
j
ØØ5 6
*
ØØ7 8
m_TileXCount
ØØ9 E
]
ØØE F
;
ØØF G
int
∞∞ 
culledLightCount
∞∞ (
=
∞∞) *
$num
∞∞+ ,
;
∞∞, -
float
≥≥ 
listMinDepth
≥≥ &
=
≥≥' (
float
≥≥) .
.
≥≥. /
MaxValue
≥≥/ 7
;
≥≥7 8
float
¥¥ 
listMaxDepth
¥¥ &
=
¥¥' (
-
¥¥) *
float
¥¥* /
.
¥¥/ 0
MaxValue
¥¥0 8
;
¥¥8 9
if
∏∏ 
(
∏∏ 
!
∏∏ 
m_IsOrthographic
∏∏ )
)
∏∏) *
{
ππ 
for
∫∫ 
(
∫∫ 
int
∫∫  
vi
∫∫! #
=
∫∫$ %
lightStartIndex
∫∫& 5
;
∫∫5 6
vi
∫∫7 9
<
∫∫: ;
lightEndIndex
∫∫< I
;
∫∫I J
++
∫∫K M
vi
∫∫M O
)
∫∫O P
{
ªª 
ushort
ºº "

lightIndex
ºº# -
=
ºº. /
_lightIndices
ºº0 =
[
ºº= >
vi
ºº> @
]
ºº@ A
;
ººA B
PrePunctualLight
ΩΩ ,
ppl
ΩΩ- 0
=
ΩΩ1 2
_punctualLights
ΩΩ3 B
[
ΩΩB C

lightIndex
ΩΩC M
]
ΩΩM N
;
ΩΩN O
float2
¡¡ "

tileCentre
¡¡# -
=
¡¡. /
new
¡¡0 3
float2
¡¡4 :
(
¡¡: ;
tileXCentre
¡¡; F
,
¡¡F G
tileYCentre
¡¡H S
)
¡¡S T
;
¡¡T U
float2
¬¬ "
dir
¬¬# &
=
¬¬' (
ppl
¬¬) ,
.
¬¬, -
	screenPos
¬¬- 6
-
¬¬7 8

tileCentre
¬¬9 C
;
¬¬C D
float2
√√ "
d
√√# $
=
√√% &
abs
√√' *
(
√√* +
dir
√√+ .
*
√√/ 0
tileExtentsInv
√√1 ?
)
√√? @
;
√√@ A
float
≈≈ !
sInv
≈≈" &
=
≈≈' (
$num
≈≈) -
/
≈≈. /
max3
≈≈0 4
(
≈≈4 5
d
≈≈5 6
.
≈≈6 7
x
≈≈7 8
,
≈≈8 9
d
≈≈: ;
.
≈≈; <
y
≈≈< =
,
≈≈= >
$num
≈≈? C
)
≈≈C D
;
≈≈D E
float3
∆∆ "
tileOffCentre
∆∆# 0
=
∆∆1 2
new
∆∆3 6
float3
∆∆7 =
(
∆∆= >

tileCentre
∆∆> H
.
∆∆H I
x
∆∆I J
+
∆∆K L
dir
∆∆M P
.
∆∆P Q
x
∆∆Q R
*
∆∆S T
sInv
∆∆U Y
,
∆∆Y Z

tileCentre
∆∆[ e
.
∆∆e f
y
∆∆f g
+
∆∆h i
dir
∆∆j m
.
∆∆m n
y
∆∆n o
*
∆∆p q
sInv
∆∆r v
,
∆∆v w
-
∆∆x y
m_FrustumPlanes∆∆y à
.∆∆à â
zNear∆∆â é
)∆∆é è
;∆∆è ê
float3
«« "

tileOrigin
««# -
=
««. /
new
««0 3
float3
««4 :
(
««: ;
$num
««; ?
)
««? @
;
««@ A
float
…… !
t0
……" $
,
……$ %
t1
……& (
;
……( )
if
ÀÀ 
(
ÀÀ  
!
ÀÀ  !$
IntersectionLineSphere
ÀÀ! 7
(
ÀÀ7 8
ppl
ÀÀ8 ;
.
ÀÀ; <
posVS
ÀÀ< A
,
ÀÀA B
ppl
ÀÀC F
.
ÀÀF G
radius
ÀÀG M
,
ÀÀM N

tileOrigin
ÀÀO Y
,
ÀÀY Z
tileOffCentre
ÀÀ[ h
,
ÀÀh i
out
ÀÀj m
t0
ÀÀn p
,
ÀÀp q
out
ÀÀr u
t1
ÀÀv x
)
ÀÀx y
)
ÀÀy z
continue
ÃÃ  (
;
ÃÃ( )
listMinDepth
ŒŒ (
=
ŒŒ) *
listMinDepth
ŒŒ+ 7
<
ŒŒ8 9
t0
ŒŒ: <
?
ŒŒ= >
listMinDepth
ŒŒ? K
:
ŒŒL M
t0
ŒŒN P
;
ŒŒP Q
listMaxDepth
œœ (
=
œœ) *
listMaxDepth
œœ+ 7
>
œœ8 9
t1
œœ: <
?
œœ= >
listMaxDepth
œœ? K
:
œœL M
t1
œœN P
;
œœP Q
depthRanges
–– '
[
––' (
culledLightCount
––( 8
]
––8 9
=
––: ;
new
––< ?
float2
––@ F
(
––F G
t0
––G I
,
––I J
t1
––K M
)
––M N
;
––N O
tiles
”” !
[
””! "
culledLightCount
””" 2
]
””2 3
=
””4 5
ppl
””6 9
.
””9 :
visLightIndex
””: G
;
””G H
++
‘‘ 
culledLightCount
‘‘ .
;
‘‘. /
}
’’ 
}
÷÷ 
else
◊◊ 
{
ÿÿ 
for
ŸŸ 
(
ŸŸ 
int
ŸŸ  
vi
ŸŸ! #
=
ŸŸ$ %
lightStartIndex
ŸŸ& 5
;
ŸŸ5 6
vi
ŸŸ7 9
<
ŸŸ: ;
lightEndIndex
ŸŸ< I
;
ŸŸI J
++
ŸŸK M
vi
ŸŸM O
)
ŸŸO P
{
⁄⁄ 
ushort
€€ "

lightIndex
€€# -
=
€€. /
_lightIndices
€€0 =
[
€€= >
vi
€€> @
]
€€@ A
;
€€A B
PrePunctualLight
‹‹ ,
ppl
‹‹- 0
=
‹‹1 2
_punctualLights
‹‹3 B
[
‹‹B C

lightIndex
‹‹C M
]
‹‹M N
;
‹‹N O
float2
‡‡ "

tileCentre
‡‡# -
=
‡‡. /
new
‡‡0 3
float2
‡‡4 :
(
‡‡: ;
tileXCentre
‡‡; F
,
‡‡F G
tileYCentre
‡‡H S
)
‡‡S T
;
‡‡T U
float2
·· "
dir
··# &
=
··' (
ppl
··) ,
.
··, -
	screenPos
··- 6
-
··7 8

tileCentre
··9 C
;
··C D
float2
‚‚ "
d
‚‚# $
=
‚‚% &
abs
‚‚' *
(
‚‚* +
dir
‚‚+ .
*
‚‚/ 0
tileExtentsInv
‚‚1 ?
)
‚‚? @
;
‚‚@ A
float
‰‰ !
sInv
‰‰" &
=
‰‰' (
$num
‰‰) -
/
‰‰. /
max3
‰‰0 4
(
‰‰4 5
d
‰‰5 6
.
‰‰6 7
x
‰‰7 8
,
‰‰8 9
d
‰‰: ;
.
‰‰; <
y
‰‰< =
,
‰‰= >
$num
‰‰? C
)
‰‰C D
;
‰‰D E
float3
ÂÂ "
tileOffCentre
ÂÂ# 0
=
ÂÂ1 2
new
ÂÂ3 6
float3
ÂÂ7 =
(
ÂÂ= >
$num
ÂÂ> ?
,
ÂÂ? @
$num
ÂÂA B
,
ÂÂB C
-
ÂÂD E
m_FrustumPlanes
ÂÂE T
.
ÂÂT U
zNear
ÂÂU Z
)
ÂÂZ [
;
ÂÂ[ \
float3
ÊÊ "

tileOrigin
ÊÊ# -
=
ÊÊ. /
new
ÊÊ0 3
float3
ÊÊ4 :
(
ÊÊ: ;

tileCentre
ÊÊ; E
.
ÊÊE F
x
ÊÊF G
+
ÊÊH I
dir
ÊÊJ M
.
ÊÊM N
x
ÊÊN O
*
ÊÊP Q
sInv
ÊÊR V
,
ÊÊV W

tileCentre
ÊÊX b
.
ÊÊb c
y
ÊÊc d
+
ÊÊe f
dir
ÊÊg j
.
ÊÊj k
y
ÊÊk l
*
ÊÊm n
sInv
ÊÊo s
,
ÊÊs t
$num
ÊÊu y
)
ÊÊy z
;
ÊÊz {
float
ËË !
t0
ËË" $
,
ËË$ %
t1
ËË& (
;
ËË( )
if
ÍÍ 
(
ÍÍ  
!
ÍÍ  !$
IntersectionLineSphere
ÍÍ! 7
(
ÍÍ7 8
ppl
ÍÍ8 ;
.
ÍÍ; <
posVS
ÍÍ< A
,
ÍÍA B
ppl
ÍÍC F
.
ÍÍF G
radius
ÍÍG M
,
ÍÍM N

tileOrigin
ÍÍO Y
,
ÍÍY Z
tileOffCentre
ÍÍ[ h
,
ÍÍh i
out
ÍÍj m
t0
ÍÍn p
,
ÍÍp q
out
ÍÍr u
t1
ÍÍv x
)
ÍÍx y
)
ÍÍy z
continue
ÎÎ  (
;
ÎÎ( )
listMinDepth
ÌÌ (
=
ÌÌ) *
listMinDepth
ÌÌ+ 7
<
ÌÌ8 9
t0
ÌÌ: <
?
ÌÌ= >
listMinDepth
ÌÌ? K
:
ÌÌL M
t0
ÌÌN P
;
ÌÌP Q
listMaxDepth
ÓÓ (
=
ÓÓ) *
listMaxDepth
ÓÓ+ 7
>
ÓÓ8 9
t1
ÓÓ: <
?
ÓÓ= >
listMaxDepth
ÓÓ? K
:
ÓÓL M
t1
ÓÓN P
;
ÓÓP Q
depthRanges
ÔÔ '
[
ÔÔ' (
culledLightCount
ÔÔ( 8
]
ÔÔ8 9
=
ÔÔ: ;
new
ÔÔ< ?
float2
ÔÔ@ F
(
ÔÔF G
t0
ÔÔG I
,
ÔÔI J
t1
ÔÔK M
)
ÔÔM N
;
ÔÔN O
tiles
ÚÚ !
[
ÚÚ! "
culledLightCount
ÚÚ" 2
]
ÚÚ2 3
=
ÚÚ4 5
ppl
ÚÚ6 9
.
ÚÚ9 :
visLightIndex
ÚÚ: G
;
ÚÚG H
++
ÛÛ 
culledLightCount
ÛÛ .
;
ÛÛ. /
}
ÙÙ 
}
ıı 
listMinDepth
¯¯  
=
¯¯! "
max2
¯¯# '
(
¯¯' (
listMinDepth
¯¯( 4
*
¯¯5 6
m_FrustumPlanes
¯¯7 F
.
¯¯F G
zNear
¯¯G L
,
¯¯L M
m_FrustumPlanes
¯¯N ]
.
¯¯] ^
zNear
¯¯^ c
)
¯¯c d
;
¯¯d e
listMaxDepth
˘˘  
=
˘˘! "
min2
˘˘# '
(
˘˘' (
listMaxDepth
˘˘( 4
*
˘˘5 6
m_FrustumPlanes
˘˘7 F
.
˘˘F G
zNear
˘˘G L
,
˘˘L M
m_FrustumPlanes
˘˘N ]
.
˘˘] ^
zFar
˘˘^ b
)
˘˘b c
;
˘˘c d
uint
¸¸ 
bitMask
¸¸  
=
¸¸! "
$num
¸¸# $
;
¸¸$ %
float
˝˝ 
depthRangeInv
˝˝ '
=
˝˝( )
$num
˝˝* .
/
˝˝/ 0
(
˝˝1 2
listMaxDepth
˝˝2 >
-
˝˝? @
listMinDepth
˝˝A M
)
˝˝M N
;
˝˝N O
for
˛˛ 
(
˛˛ 
int
˛˛ 
culledLightIndex
˛˛ -
=
˛˛. /
$num
˛˛0 1
;
˛˛1 2
culledLightIndex
˛˛3 C
<
˛˛D E
culledLightCount
˛˛F V
;
˛˛V W
++
˛˛X Z
culledLightIndex
˛˛Z j
)
˛˛j k
{
ˇˇ 
float
ÄÄ 
lightMinDepth
ÄÄ +
=
ÄÄ, -
max2
ÄÄ. 2
(
ÄÄ2 3
depthRanges
ÄÄ3 >
[
ÄÄ> ?
culledLightIndex
ÄÄ? O
]
ÄÄO P
.
ÄÄP Q
x
ÄÄQ R
*
ÄÄS T
m_FrustumPlanes
ÄÄU d
.
ÄÄd e
zNear
ÄÄe j
,
ÄÄj k
m_FrustumPlanes
ÄÄl {
.
ÄÄ{ |
zNearÄÄ| Å
)ÄÄÅ Ç
;ÄÄÇ É
float
ÅÅ 
lightMaxDepth
ÅÅ +
=
ÅÅ, -
min2
ÅÅ. 2
(
ÅÅ2 3
depthRanges
ÅÅ3 >
[
ÅÅ> ?
culledLightIndex
ÅÅ? O
]
ÅÅO P
.
ÅÅP Q
y
ÅÅQ R
*
ÅÅS T
m_FrustumPlanes
ÅÅU d
.
ÅÅd e
zNear
ÅÅe j
,
ÅÅj k
m_FrustumPlanes
ÅÅl {
.
ÅÅ{ |
zFarÅÅ| Ä
)ÅÅÄ Å
;ÅÅÅ Ç
int
ÇÇ 
firstBit
ÇÇ $
=
ÇÇ% &
(
ÇÇ' (
int
ÇÇ( +
)
ÇÇ+ ,
(
ÇÇ, -
(
ÇÇ- .
lightMinDepth
ÇÇ. ;
-
ÇÇ< =
listMinDepth
ÇÇ> J
)
ÇÇJ K
*
ÇÇL M
$num
ÇÇN S
*
ÇÇT U
depthRangeInv
ÇÇV c
)
ÇÇc d
;
ÇÇd e
int
ÉÉ 
lastBit
ÉÉ #
=
ÉÉ$ %
(
ÉÉ& '
int
ÉÉ' *
)
ÉÉ* +
(
ÉÉ+ ,
(
ÉÉ, -
lightMaxDepth
ÉÉ- :
-
ÉÉ; <
listMinDepth
ÉÉ= I
)
ÉÉI J
*
ÉÉK L
$num
ÉÉM R
*
ÉÉS T
depthRangeInv
ÉÉU b
)
ÉÉb c
;
ÉÉc d
int
ÑÑ 
bitCount
ÑÑ $
=
ÑÑ% &
min
ÑÑ' *
(
ÑÑ* +
lastBit
ÑÑ+ 2
-
ÑÑ3 4
firstBit
ÑÑ5 =
+
ÑÑ> ?
$num
ÑÑ@ A
,
ÑÑA B
$num
ÑÑC E
-
ÑÑF G
firstBit
ÑÑH P
)
ÑÑP Q
;
ÑÑQ R
bitMask
ÖÖ 
|=
ÖÖ  "
(
ÖÖ# $
uint
ÖÖ$ (
)
ÖÖ( )
(
ÖÖ) *
(
ÖÖ* +
$num
ÖÖ+ 5
>>
ÖÖ6 8
(
ÖÖ9 :
$num
ÖÖ: <
-
ÖÖ= >
bitCount
ÖÖ? G
)
ÖÖG H
)
ÖÖH I
<<
ÖÖJ L
firstBit
ÖÖM U
)
ÖÖU V
;
ÖÖV W
tiles
áá 
[
áá 
culledLightCount
áá .
+
áá/ 0
culledLightIndex
áá1 A
]
ááA B
=
ááC D
(
ááE F
ushort
ááF L
)
ááL M
(
ááM N
(
ááN O
uint
ááO S
)
ááS T
firstBit
ááT \
|
áá] ^
(
áá_ `
uint
áá` d
)
áád e
(
ááe f
bitCount
ááf n
<<
ááo q
$num
áár s
)
áás t
)
áát u
;
ááu v
}
àà 
float
ëë 
a
ëë 
=
ëë 
$num
ëë #
*
ëë$ %
depthRangeInv
ëë& 3
;
ëë3 4
float
íí 
b
íí 
=
íí 
-
íí 
listMinDepth
íí +
*
íí, -
a
íí. /
;
íí/ 0
int
îî 
tileDataSize
îî $
=
îî% &
culledLightCount
îî' 7
*
îî8 9
$num
îî: ;
;
îî; <
int
ïï 

tileOffset
ïï "
=
ïï# $
culledLightCount
ïï% 5
>
ïï6 7
$num
ïï8 9
?
ïï: ;
AddTileData
ïï< G
(
ïïG H
tiles
ïïH M
,
ïïM N
ref
ïïO R
tileDataSize
ïïS _
)
ïï_ `
:
ïïa b
$num
ïïc d
;
ïïd e
int
óó 
headerOffset
óó $
=
óó% &!
GetTileHeaderOffset
óó' :
(
óó: ;
i
óó; <
,
óó< =
j
óó> ?
)
óó? @
;
óó@ A
_tileHeaders
òò  
[
òò  !
headerOffset
òò! -
+
òò. /
$num
òò0 1
]
òò1 2
=
òò3 4
(
òò5 6
uint
òò6 :
)
òò: ;

tileOffset
òò; E
;
òòE F
_tileHeaders
ôô  
[
ôô  !
headerOffset
ôô! -
+
ôô. /
$num
ôô0 1
]
ôô1 2
=
ôô3 4
(
ôô5 6
uint
ôô6 :
)
ôô: ;
(
ôô; <
tileDataSize
ôô< H
==
ôôI K
$num
ôôL M
?
ôôN O
$num
ôôP Q
:
ôôR S
culledLightCount
ôôT d
)
ôôd e
;
ôôe f
_tileHeaders
öö  
[
öö  !
headerOffset
öö! -
+
öö. /
$num
öö0 1
]
öö1 2
=
öö3 4
	_f32tof16
öö5 >
(
öö> ?
a
öö? @
)
öö@ A
|
ööB C
(
ööD E
	_f32tof16
ööE N
(
ööN O
b
ööO P
)
ööP Q
<<
ööR T
$num
ööU W
)
ööW X
;
ööX Y
_tileHeaders
õõ  
[
õõ  !
headerOffset
õõ! -
+
õõ. /
$num
õõ0 1
]
õõ1 2
=
õõ3 4
bitMask
õõ5 <
;
õõ< =
maxLightPerTile
ùù #
=
ùù$ %
max
ùù& )
(
ùù) *
maxLightPerTile
ùù* 9
,
ùù9 :
culledLightCount
ùù; K
)
ùùK L
;
ùùL M
}
ûû 
}
üü 

m_Counters
°° 
[
°° 
$num
°° 
]
°° 
=
°° 
max
°° 
(
°°  

m_Counters
°°  *
[
°°* +
$num
°°+ ,
]
°°, -
,
°°- .
maxLightPerTile
°°/ >
)
°°> ?
;
°°? @
}
¢¢ 	
unsafe
•• 
public
•• 
void
•• $
CullIntermediateLights
•• 1
(
••1 2
ref
••2 5
NativeArray
••6 A
<
••A B
PrePunctualLight
••B R
>
••R S
punctualLights
••T b
,
••b c
ref
¶¶2 5
NativeArray
¶¶6 A
<
¶¶A B
ushort
¶¶B H
>
¶¶H I
lightIndices
¶¶J V
,
¶¶V W
int
¶¶X [
lightStartIndex
¶¶\ k
,
¶¶k l
int
¶¶m p

lightCount
¶¶q {
,
¶¶{ |
int
ßß2 5
istart
ßß6 <
,
ßß< =
int
ßß> A
iend
ßßB F
,
ßßF G
int
ßßH K
jstart
ßßL R
,
ßßR S
int
ßßT W
jend
ßßX \
)
ßß\ ]
{
®® 	
PrePunctualLight
™™ 
*
™™ 
_punctualLights
™™ -
=
™™. /
(
™™0 1
PrePunctualLight
™™1 A
*
™™A B
)
™™B C&
NativeArrayUnsafeUtility
™™C [
.
™™[ \1
#GetUnsafeBufferPointerWithoutChecks
™™\ 
(™™ Ä
punctualLights™™Ä é
)™™é è
;™™è ê
ushort
´´ 
*
´´ 
_lightIndices
´´ !
=
´´" #
(
´´$ %
ushort
´´% +
*
´´+ ,
)
´´, -&
NativeArrayUnsafeUtility
´´- E
.
´´E F1
#GetUnsafeBufferPointerWithoutChecks
´´F i
(
´´i j
lightIndices
´´j v
)
´´v w
;
´´w x
uint
¨¨ 
*
¨¨ 
_tileHeaders
¨¨ 
=
¨¨  
(
¨¨! "
uint
¨¨" &
*
¨¨& '
)
¨¨' (&
NativeArrayUnsafeUtility
¨¨( @
.
¨¨@ A1
#GetUnsafeBufferPointerWithoutChecks
¨¨A d
(
¨¨d e
m_TileHeaders
¨¨e r
)
¨¨r s
;
¨¨s t
if
ÆÆ 
(
ÆÆ 

lightCount
ÆÆ 
==
ÆÆ 
$num
ÆÆ 
)
ÆÆ  
{
ØØ 
for
∞∞ 
(
∞∞ 
int
∞∞ 
j
∞∞ 
=
∞∞ 
jstart
∞∞ #
;
∞∞# $
j
∞∞% &
<
∞∞' (
jend
∞∞) -
;
∞∞- .
++
∞∞/ 1
j
∞∞1 2
)
∞∞2 3
for
±± 
(
±± 
int
±± 
i
±± 
=
±± 
istart
±± #
;
±±# $
i
±±% &
<
±±' (
iend
±±) -
;
±±- .
++
±±/ 1
i
±±1 2
)
±±2 3
{
≤≤ 
int
≥≥ 
headerOffset
≥≥ $
=
≥≥% &!
GetTileHeaderOffset
≥≥' :
(
≥≥: ;
i
≥≥; <
,
≥≥< =
j
≥≥> ?
)
≥≥? @
;
≥≥@ A
_tileHeaders
¥¥  
[
¥¥  !
headerOffset
¥¥! -
+
¥¥. /
$num
¥¥0 1
]
¥¥1 2
=
¥¥3 4
$num
¥¥5 6
;
¥¥6 7
_tileHeaders
µµ  
[
µµ  !
headerOffset
µµ! -
+
µµ. /
$num
µµ0 1
]
µµ1 2
=
µµ3 4
$num
µµ5 6
;
µµ6 7
}
∂∂ 
return
∑∑ 
;
∑∑ 
}
∏∏ 
ushort
ªª 
*
ªª 
tiles
ªª 
=
ªª 

stackalloc
ªª &
ushort
ªª' -
[
ªª- .

lightCount
ªª. 8
]
ªª8 9
;
ªª9 :
int
ΩΩ 
lightEndIndex
ΩΩ 
=
ΩΩ 
lightStartIndex
ΩΩ  /
+
ΩΩ0 1

lightCount
ΩΩ2 <
;
ΩΩ< =
for
øø 
(
øø 
int
øø 
j
øø 
=
øø 
jstart
øø 
;
øø  
j
øø! "
<
øø# $
jend
øø% )
;
øø) *
++
øø+ -
j
øø- .
)
øø. /
{
¿¿ 
for
¡¡ 
(
¡¡ 
int
¡¡ 
i
¡¡ 
=
¡¡ 
istart
¡¡ #
;
¡¡# $
i
¡¡% &
<
¡¡' (
iend
¡¡) -
;
¡¡- .
++
¡¡/ 1
i
¡¡1 2
)
¡¡2 3
{
¬¬ 
PreTile
√√ 
preTile
√√ #
=
√√$ %

m_PreTiles
√√& 0
[
√√0 1
i
√√1 2
+
√√3 4
j
√√5 6
*
√√7 8
m_TileXCount
√√9 E
]
√√E F
;
√√F G
int
ƒƒ 
culledLightCount
ƒƒ (
=
ƒƒ) *
$num
ƒƒ+ ,
;
ƒƒ, -
for
∆∆ 
(
∆∆ 
int
∆∆ 
vi
∆∆ 
=
∆∆  !
lightStartIndex
∆∆" 1
;
∆∆1 2
vi
∆∆3 5
<
∆∆6 7
lightEndIndex
∆∆8 E
;
∆∆E F
++
∆∆G I
vi
∆∆I K
)
∆∆K L
{
«« 
ushort
»» 

lightIndex
»» )
=
»»* +
_lightIndices
»», 9
[
»»9 :
vi
»»: <
]
»»< =
;
»»= >
PrePunctualLight
…… (
ppl
……) ,
=
……- .
_punctualLights
……/ >
[
……> ?

lightIndex
……? I
]
……I J
;
……J K
if
ÃÃ 
(
ÃÃ 
!
ÃÃ 
Clip
ÃÃ !
(
ÃÃ! "
ref
ÃÃ" %
preTile
ÃÃ& -
,
ÃÃ- .
ppl
ÃÃ/ 2
.
ÃÃ2 3
posVS
ÃÃ3 8
,
ÃÃ8 9
ppl
ÃÃ: =
.
ÃÃ= >
radius
ÃÃ> D
)
ÃÃD E
)
ÃÃE F
continue
ÕÕ $
;
ÕÕ$ %
tiles
œœ 
[
œœ 
culledLightCount
œœ .
]
œœ. /
=
œœ0 1

lightIndex
œœ2 <
;
œœ< =
++
–– 
culledLightCount
–– *
;
––* +
}
—— 
int
‘‘ 

tileOffset
‘‘ "
=
‘‘# $
culledLightCount
‘‘% 5
>
‘‘6 7
$num
‘‘8 9
?
‘‘: ;
AddTileData
‘‘< G
(
‘‘G H
tiles
‘‘H M
,
‘‘M N
ref
‘‘O R
culledLightCount
‘‘S c
)
‘‘c d
:
‘‘e f
$num
‘‘g h
;
‘‘h i
int
÷÷ 
headerOffset
÷÷ $
=
÷÷% &!
GetTileHeaderOffset
÷÷' :
(
÷÷: ;
i
÷÷; <
,
÷÷< =
j
÷÷> ?
)
÷÷? @
;
÷÷@ A
_tileHeaders
◊◊  
[
◊◊  !
headerOffset
◊◊! -
+
◊◊. /
$num
◊◊0 1
]
◊◊1 2
=
◊◊3 4
(
◊◊5 6
uint
◊◊6 :
)
◊◊: ;

tileOffset
◊◊; E
;
◊◊E F
_tileHeaders
ÿÿ  
[
ÿÿ  !
headerOffset
ÿÿ! -
+
ÿÿ. /
$num
ÿÿ0 1
]
ÿÿ1 2
=
ÿÿ3 4
(
ÿÿ5 6
uint
ÿÿ6 :
)
ÿÿ: ;
culledLightCount
ÿÿ; K
;
ÿÿK L
}
ŸŸ 
}
⁄⁄ 
}
€€ 	
[
›› 	

MethodImpl
››	 
(
›› 
MethodImplOptions
›› %
.
››% & 
AggressiveInlining
››& 8
)
››8 9
]
››9 :
unsafe
ﬁﬁ 
int
ﬁﬁ 
AddTileData
ﬁﬁ 
(
ﬁﬁ 
ushort
ﬁﬁ %
*
ﬁﬁ% &
	lightData
ﬁﬁ' 0
,
ﬁﬁ0 1
ref
ﬁﬁ2 5
int
ﬁﬁ6 9
size
ﬁﬁ: >
)
ﬁﬁ> ?
{
ﬂﬂ 	
int
‡‡ 
*
‡‡ 
	_Counters
‡‡ 
=
‡‡ 
(
‡‡ 
int
‡‡ !
*
‡‡! "
)
‡‡" #

m_Counters
‡‡# -
.
‡‡- .
GetUnsafePtr
‡‡. :
(
‡‡: ;
)
‡‡; <
;
‡‡< =
int
·· 
tileDataSize
·· 
=
·· 
System
·· %
.
··% &
	Threading
··& /
.
··/ 0
Interlocked
··0 ;
.
··; <
Add
··< ?
(
··? @
ref
··@ C
	_Counters
··D M
[
··M N
$num
··N O
]
··O P
,
··P Q
size
··R V
)
··V W
;
··W X
int
‚‚ 
offset
‚‚ 
=
‚‚ 
tileDataSize
‚‚ %
-
‚‚& '
size
‚‚( ,
;
‚‚, -
if
‰‰ 
(
‰‰ 
tileDataSize
‰‰ 
<=
‰‰ 

m_TileData
‰‰  *
.
‰‰* +
Length
‰‰+ 1
)
‰‰1 2
{
ÂÂ 
ushort
ÊÊ 
*
ÊÊ 
	_TileData
ÊÊ !
=
ÊÊ" #
(
ÊÊ$ %
ushort
ÊÊ% +
*
ÊÊ+ ,
)
ÊÊ, -

m_TileData
ÊÊ- 7
.
ÊÊ7 8
GetUnsafePtr
ÊÊ8 D
(
ÊÊD E
)
ÊÊE F
;
ÊÊF G
UnsafeUtility
ÁÁ 
.
ÁÁ 
MemCpy
ÁÁ $
(
ÁÁ$ %
	_TileData
ÁÁ% .
+
ÁÁ/ 0
offset
ÁÁ1 7
,
ÁÁ7 8
	lightData
ÁÁ9 B
,
ÁÁB C
size
ÁÁD H
*
ÁÁI J
$num
ÁÁK L
)
ÁÁL M
;
ÁÁM N
return
ËË 
offset
ËË 
;
ËË 
}
ÈÈ 
else
ÍÍ 
{
ÎÎ 

m_Counters
ÔÔ 
[
ÔÔ 
$num
ÔÔ 
]
ÔÔ 
=
ÔÔ 
max
ÔÔ  #
(
ÔÔ# $

m_Counters
ÔÔ$ .
[
ÔÔ. /
$num
ÔÔ/ 0
]
ÔÔ0 1
,
ÔÔ1 2
tileDataSize
ÔÔ3 ?
)
ÔÔ? @
;
ÔÔ@ A
size
 
=
 
$num
 
;
 
return
ÒÒ 
$num
ÒÒ 
;
ÒÒ 
}
ÚÚ 
}
çç 	
[
ìì 	

MethodImpl
ìì	 
(
ìì 
MethodImplOptions
ìì %
.
ìì% & 
AggressiveInlining
ìì& 8
)
ìì8 9
]
ìì9 :
unsafe
îî 
static
îî 
bool
îî $
IntersectionLineSphere
îî 1
(
îî1 2
float3
îî2 8
centre
îî9 ?
,
îî? @
float
îîA F
radius
îîG M
,
îîM N
float3
îîO U
	raySource
îîV _
,
îî_ `
float3
îîa g
rayDirection
îîh t
,
îît u
out
îîv y
float
îîz 
t0îîÄ Ç
,îîÇ É
outîîÑ á
floatîîà ç
t1îîé ê
)îîê ë
{
ïï 	
float
ññ 
A
ññ 
=
ññ 
dot
ññ 
(
ññ 
rayDirection
ññ &
,
ññ& '
rayDirection
ññ( 4
)
ññ4 5
;
ññ5 6
float
óó 
B
óó 
=
óó 
dot
óó 
(
óó 
	raySource
óó #
-
óó$ %
centre
óó& ,
,
óó, -
rayDirection
óó. :
)
óó: ;
;
óó; <
float
òò 
C
òò 
=
òò 
dot
òò 
(
òò 
	raySource
òò #
,
òò# $
	raySource
òò% .
)
òò. /
+
ôô 
dot
ôô 
(
ôô 
centre
ôô  
,
ôô  !
centre
ôô" (
)
ôô( )
-
öö 
(
öö 
radius
öö 
*
öö 
radius
öö  &
)
öö& '
-
õõ 
$num
õõ 
*
õõ 
dot
õõ 
(
õõ 
	raySource
õõ '
,
õõ' (
centre
õõ) /
)
õõ/ 0
;
õõ0 1
float
úú 
discriminant
úú 
=
úú  
(
úú! "
B
úú" #
*
úú$ %
B
úú& '
)
úú' (
-
úú) *
A
úú+ ,
*
úú- .
C
úú/ 0
;
úú0 1
if
ùù 
(
ùù 
discriminant
ùù 
>
ùù 
$num
ùù  
)
ùù  !
{
ûû 
float
üü 
sqrt_discriminant
üü '
=
üü( )
sqrt
üü* .
(
üü. /
discriminant
üü/ ;
)
üü; <
;
üü< =
float
†† 
A_inv
†† 
=
†† 
$num
†† "
/
††# $
A
††% &
;
††& '
t0
°° 
=
°° 
(
°° 
-
°° 
B
°° 
-
°° 
sqrt_discriminant
°° ,
)
°°, -
*
°°. /
A_inv
°°0 5
;
°°5 6
t1
¢¢ 
=
¢¢ 
(
¢¢ 
-
¢¢ 
B
¢¢ 
+
¢¢ 
sqrt_discriminant
¢¢ ,
)
¢¢, -
*
¢¢. /
A_inv
¢¢0 5
;
¢¢5 6
return
££ 
true
££ 
;
££ 
}
§§ 
else
•• 
{
¶¶ 
t0
ßß 
=
ßß 
$num
ßß 
;
ßß 
t1
®® 
=
®® 
$num
®® 
;
®® 
return
©© 
false
©© 
;
©© 
}
™™ 
}
´´ 	
[
ÆÆ 	

MethodImpl
ÆÆ	 
(
ÆÆ 
MethodImplOptions
ÆÆ %
.
ÆÆ% & 
AggressiveInlining
ÆÆ& 8
)
ÆÆ8 9
]
ÆÆ9 :
static
ØØ 
bool
ØØ 
Clip
ØØ 
(
ØØ 
ref
ØØ 
PreTile
ØØ $
tile
ØØ% )
,
ØØ) *
float3
ØØ+ 1
posVS
ØØ2 7
,
ØØ7 8
float
ØØ9 >
radius
ØØ? E
)
ØØE F
{
∞∞ 	
float
¥¥ 
radiusSq
¥¥ 
=
¥¥ 
radius
¥¥ #
*
¥¥$ %
radius
¥¥& ,
;
¥¥, -
int
µµ 
insideCount
µµ 
=
µµ 
$num
µµ 
;
µµ  

ClipResult
∂∂ 
res
∂∂ 
;
∂∂ 
res
∏∏ 
=
∏∏ 
ClipPartial
∏∏ 
(
∏∏ 
tile
∏∏ "
.
∏∏" #
	planeLeft
∏∏# ,
,
∏∏, -
tile
∏∏. 2
.
∏∏2 3
planeBottom
∏∏3 >
,
∏∏> ?
tile
∏∏@ D
.
∏∏D E
planeTop
∏∏E M
,
∏∏M N
posVS
∏∏O T
,
∏∏T U
radius
∏∏V \
,
∏∏\ ]
radiusSq
∏∏^ f
,
∏∏f g
ref
∏∏h k
insideCount
∏∏l w
)
∏∏w x
;
∏∏x y
if
ππ 
(
ππ 
res
ππ 
!=
ππ 

ClipResult
ππ !
.
ππ! "
Unknown
ππ" )
)
ππ) *
return
∫∫ 
res
∫∫ 
==
∫∫ 

ClipResult
∫∫ (
.
∫∫( )
In
∫∫) +
;
∫∫+ ,
res
ºº 
=
ºº 
ClipPartial
ºº 
(
ºº 
tile
ºº "
.
ºº" #

planeRight
ºº# -
,
ºº- .
tile
ºº/ 3
.
ºº3 4
planeBottom
ºº4 ?
,
ºº? @
tile
ººA E
.
ººE F
planeTop
ººF N
,
ººN O
posVS
ººP U
,
ººU V
radius
ººW ]
,
ºº] ^
radiusSq
ºº_ g
,
ººg h
ref
ººi l
insideCount
ººm x
)
ººx y
;
ººy z
if
ΩΩ 
(
ΩΩ 
res
ΩΩ 
!=
ΩΩ 

ClipResult
ΩΩ !
.
ΩΩ! "
Unknown
ΩΩ" )
)
ΩΩ) *
return
ææ 
res
ææ 
==
ææ 

ClipResult
ææ (
.
ææ( )
In
ææ) +
;
ææ+ ,
res
¿¿ 
=
¿¿ 
ClipPartial
¿¿ 
(
¿¿ 
tile
¿¿ "
.
¿¿" #
planeTop
¿¿# +
,
¿¿+ ,
tile
¿¿- 1
.
¿¿1 2
	planeLeft
¿¿2 ;
,
¿¿; <
tile
¿¿= A
.
¿¿A B

planeRight
¿¿B L
,
¿¿L M
posVS
¿¿N S
,
¿¿S T
radius
¿¿U [
,
¿¿[ \
radiusSq
¿¿] e
,
¿¿e f
ref
¿¿g j
insideCount
¿¿k v
)
¿¿v w
;
¿¿w x
if
¡¡ 
(
¡¡ 
res
¡¡ 
!=
¡¡ 

ClipResult
¡¡ !
.
¡¡! "
Unknown
¡¡" )
)
¡¡) *
return
¬¬ 
res
¬¬ 
==
¬¬ 

ClipResult
¬¬ (
.
¬¬( )
In
¬¬) +
;
¬¬+ ,
res
ƒƒ 
=
ƒƒ 
ClipPartial
ƒƒ 
(
ƒƒ 
tile
ƒƒ "
.
ƒƒ" #
planeBottom
ƒƒ# .
,
ƒƒ. /
tile
ƒƒ0 4
.
ƒƒ4 5
	planeLeft
ƒƒ5 >
,
ƒƒ> ?
tile
ƒƒ@ D
.
ƒƒD E

planeRight
ƒƒE O
,
ƒƒO P
posVS
ƒƒQ V
,
ƒƒV W
radius
ƒƒX ^
,
ƒƒ^ _
radiusSq
ƒƒ` h
,
ƒƒh i
ref
ƒƒj m
insideCount
ƒƒn y
)
ƒƒy z
;
ƒƒz {
if
≈≈ 
(
≈≈ 
res
≈≈ 
!=
≈≈ 

ClipResult
≈≈ !
.
≈≈! "
Unknown
≈≈" )
)
≈≈) *
return
∆∆ 
res
∆∆ 
==
∆∆ 

ClipResult
∆∆ (
.
∆∆( )
In
∆∆) +
;
∆∆+ ,
return
»» 
insideCount
»» 
==
»» !
$num
»»" #
;
»»# $
}
…… 	
[
ÃÃ 	

MethodImpl
ÃÃ	 
(
ÃÃ 
MethodImplOptions
ÃÃ %
.
ÃÃ% & 
AggressiveInlining
ÃÃ& 8
)
ÃÃ8 9
]
ÃÃ9 :
static
ÕÕ 

ClipResult
ÕÕ 
ClipPartial
ÕÕ %
(
ÕÕ% &
float4
ÕÕ& ,
plane
ÕÕ- 2
,
ÕÕ2 3
float4
ÕÕ4 :

sidePlaneA
ÕÕ; E
,
ÕÕE F
float4
ÕÕG M

sidePlaneB
ÕÕN X
,
ÕÕX Y
float3
ÕÕZ `
posVS
ÕÕa f
,
ÕÕf g
float
ÕÕh m
radius
ÕÕn t
,
ÕÕt u
float
ÕÕv {
radiusSqÕÕ| Ñ
,ÕÕÑ Ö
refÕÕÜ â
intÕÕä ç
insideCountÕÕé ô
)ÕÕô ö
{
ŒŒ 	
float
œœ 
d
œœ 
=
œœ 
DistanceToPlane
œœ %
(
œœ% &
plane
œœ& +
,
œœ+ ,
posVS
œœ- 2
)
œœ2 3
;
œœ3 4
if
–– 
(
–– 
d
–– 
+
–– 
radius
–– 
<=
–– 
$num
–– "
)
––" #
return
—— 

ClipResult
—— !
.
——! "
Out
——" %
;
——% &
else
““ 
if
““ 
(
““ 
d
““ 
<
““ 
$num
““ 
)
““ 
{
”” 
float3
‘‘ 
p
‘‘ 
=
‘‘ 
posVS
‘‘  
-
‘‘! "
plane
‘‘# (
.
‘‘( )
xyz
‘‘) ,
*
‘‘- .
d
‘‘/ 0
;
‘‘0 1
float
’’ 
rSq
’’ 
=
’’ 
radiusSq
’’ $
-
’’% &
d
’’' (
*
’’) *
d
’’+ ,
;
’’, -
if
÷÷ 
(
÷÷ 
SignedSq
÷÷ 
(
÷÷ 
DistanceToPlane
÷÷ ,
(
÷÷, -

sidePlaneA
÷÷- 7
,
÷÷7 8
p
÷÷9 :
)
÷÷: ;
)
÷÷; <
>=
÷÷= ?
-
÷÷@ A
rSq
÷÷A D
&&
◊◊ 
SignedSq
◊◊ 
(
◊◊ 
DistanceToPlane
◊◊ ,
(
◊◊, -

sidePlaneB
◊◊- 7
,
◊◊7 8
p
◊◊9 :
)
◊◊: ;
)
◊◊; <
>=
◊◊= ?
-
◊◊@ A
rSq
◊◊A D
)
◊◊D E
return
ÿÿ 

ClipResult
ÿÿ %
.
ÿÿ% &
In
ÿÿ& (
;
ÿÿ( )
}
ŸŸ 
else
⁄⁄ 
++
€€ 
insideCount
€€ 
;
€€ 
return
›› 

ClipResult
›› 
.
›› 
Unknown
›› %
;
››% &
}
ﬁﬁ 	
[
‡‡ 	

MethodImpl
‡‡	 
(
‡‡ 
MethodImplOptions
‡‡ %
.
‡‡% & 
AggressiveInlining
‡‡& 8
)
‡‡8 9
]
‡‡9 :
static
·· 
float4
·· 
	MakePlane
·· 
(
··  
float3
··  &
pb
··' )
,
··) *
float3
··+ 1
pc
··2 4
)
··4 5
{
‚‚ 	
float3
„„ 
v0
„„ 
=
„„ 
pb
„„ 
;
„„ 
float3
‰‰ 
v1
‰‰ 
=
‰‰ 
pc
‰‰ 
;
‰‰ 
float3
ÂÂ 
n
ÂÂ 
=
ÂÂ 
cross
ÂÂ 
(
ÂÂ 
v0
ÂÂ 
,
ÂÂ  
v1
ÂÂ! #
)
ÂÂ# $
;
ÂÂ$ %
n
ÊÊ 
=
ÊÊ 
	normalize
ÊÊ 
(
ÊÊ 
n
ÊÊ 
)
ÊÊ 
;
ÊÊ 
return
ÈÈ 
new
ÈÈ 
float4
ÈÈ 
(
ÈÈ 
n
ÈÈ 
.
ÈÈ  
x
ÈÈ  !
,
ÈÈ! "
n
ÈÈ# $
.
ÈÈ$ %
y
ÈÈ% &
,
ÈÈ& '
n
ÈÈ( )
.
ÈÈ) *
z
ÈÈ* +
,
ÈÈ+ ,
$num
ÈÈ- 1
)
ÈÈ1 2
;
ÈÈ2 3
}
ÍÍ 	
[
ÏÏ 	

MethodImpl
ÏÏ	 
(
ÏÏ 
MethodImplOptions
ÏÏ %
.
ÏÏ% & 
AggressiveInlining
ÏÏ& 8
)
ÏÏ8 9
]
ÏÏ9 :
static
ÌÌ 
float4
ÌÌ 
	MakePlane
ÌÌ 
(
ÌÌ  
float3
ÌÌ  &
pa
ÌÌ' )
,
ÌÌ) *
float3
ÌÌ+ 1
pb
ÌÌ2 4
,
ÌÌ4 5
float3
ÌÌ6 <
pc
ÌÌ= ?
)
ÌÌ? @
{
ÓÓ 	
float3
ÔÔ 
v0
ÔÔ 
=
ÔÔ 
pb
ÔÔ 
-
ÔÔ 
pa
ÔÔ 
;
ÔÔ  
float3
 
v1
 
=
 
pc
 
-
 
pa
 
;
  
float3
ÒÒ 
n
ÒÒ 
=
ÒÒ 
cross
ÒÒ 
(
ÒÒ 
v0
ÒÒ 
,
ÒÒ  
v1
ÒÒ! #
)
ÒÒ# $
;
ÒÒ$ %
n
ÚÚ 
=
ÚÚ 
	normalize
ÚÚ 
(
ÚÚ 
n
ÚÚ 
)
ÚÚ 
;
ÚÚ 
return
ÙÙ 
new
ÙÙ 
float4
ÙÙ 
(
ÙÙ 
n
ÙÙ 
.
ÙÙ  
x
ÙÙ  !
,
ÙÙ! "
n
ÙÙ# $
.
ÙÙ$ %
y
ÙÙ% &
,
ÙÙ& '
n
ÙÙ( )
.
ÙÙ) *
z
ÙÙ* +
,
ÙÙ+ ,
-
ÙÙ- .
dot
ÙÙ. 1
(
ÙÙ1 2
n
ÙÙ2 3
,
ÙÙ3 4
pa
ÙÙ5 7
)
ÙÙ7 8
)
ÙÙ8 9
;
ÙÙ9 :
}
ıı 	
[
˜˜ 	

MethodImpl
˜˜	 
(
˜˜ 
MethodImplOptions
˜˜ %
.
˜˜% & 
AggressiveInlining
˜˜& 8
)
˜˜8 9
]
˜˜9 :
static
¯¯ 
float
¯¯ 
DistanceToPlane
¯¯ $
(
¯¯$ %
float4
¯¯% +
plane
¯¯, 1
,
¯¯1 2
float3
¯¯3 9
p
¯¯: ;
)
¯¯; <
{
˘˘ 	
return
˙˙ 
plane
˙˙ 
.
˙˙ 
x
˙˙ 
*
˙˙ 
p
˙˙ 
.
˙˙ 
x
˙˙  
+
˙˙! "
plane
˙˙# (
.
˙˙( )
y
˙˙) *
*
˙˙+ ,
p
˙˙- .
.
˙˙. /
y
˙˙/ 0
+
˙˙1 2
plane
˙˙3 8
.
˙˙8 9
z
˙˙9 :
*
˙˙; <
p
˙˙= >
.
˙˙> ?
z
˙˙? @
+
˙˙A B
plane
˙˙C H
.
˙˙H I
w
˙˙I J
;
˙˙J K
}
˚˚ 	
[
˝˝ 	

MethodImpl
˝˝	 
(
˝˝ 
MethodImplOptions
˝˝ %
.
˝˝% & 
AggressiveInlining
˝˝& 8
)
˝˝8 9
]
˝˝9 :
static
˛˛ 
float
˛˛ 
SignedSq
˛˛ 
(
˛˛ 
float
˛˛ #
f
˛˛$ %
)
˛˛% &
{
ˇˇ 	
return
ÇÇ 
(
ÇÇ 
f
ÇÇ 
<
ÇÇ 
$num
ÇÇ 
?
ÇÇ 
-
ÇÇ  
$num
ÇÇ  $
:
ÇÇ% &
$num
ÇÇ' +
)
ÇÇ+ ,
*
ÇÇ- .
(
ÇÇ/ 0
f
ÇÇ0 1
*
ÇÇ2 3
f
ÇÇ4 5
)
ÇÇ5 6
;
ÇÇ6 7
}
ÉÉ 	
[
ÜÜ 	

MethodImpl
ÜÜ	 
(
ÜÜ 
MethodImplOptions
ÜÜ %
.
ÜÜ% & 
AggressiveInlining
ÜÜ& 8
)
ÜÜ8 9
]
ÜÜ9 :
static
áá 
float
áá 
min2
áá 
(
áá 
float
áá 
a
áá  !
,
áá! "
float
áá# (
b
áá) *
)
áá* +
{
àà 	
return
ââ 
a
ââ 
<
ââ 
b
ââ 
?
ââ 
a
ââ 
:
ââ 
b
ââ  
;
ââ  !
}
ää 	
[
çç 	

MethodImpl
çç	 
(
çç 
MethodImplOptions
çç %
.
çç% & 
AggressiveInlining
çç& 8
)
çç8 9
]
çç9 :
static
éé 
float
éé 
max2
éé 
(
éé 
float
éé 
a
éé  !
,
éé! "
float
éé# (
b
éé) *
)
éé* +
{
èè 	
return
êê 
a
êê 
>
êê 
b
êê 
?
êê 
a
êê 
:
êê 
b
êê  
;
êê  !
}
ëë 	
[
ìì 	

MethodImpl
ìì	 
(
ìì 
MethodImplOptions
ìì %
.
ìì% & 
AggressiveInlining
ìì& 8
)
ìì8 9
]
ìì9 :
static
îî 
float
îî 
max3
îî 
(
îî 
float
îî 
a
îî  !
,
îî! "
float
îî# (
b
îî) *
,
îî* +
float
îî, 1
c
îî2 3
)
îî3 4
{
ïï 	
return
ññ 
a
ññ 
>
ññ 
b
ññ 
?
ññ 
(
ññ 
a
ññ 
>
ññ 
c
ññ  !
?
ññ" #
a
ññ$ %
:
ññ& '
c
ññ( )
)
ññ) *
:
ññ+ ,
(
ññ- .
b
ññ. /
>
ññ0 1
c
ññ2 3
?
ññ4 5
b
ññ6 7
:
ññ8 9
c
ññ: ;
)
ññ; <
;
ññ< =
}
óó 	
[
öö 	

MethodImpl
öö	 
(
öö 
MethodImplOptions
öö %
.
öö% & 
AggressiveInlining
öö& 8
)
öö8 9
]
öö9 :
public
õõ 
static
õõ 
uint
õõ 
	_f32tof16
õõ $
(
õõ$ %
float
õõ% *
x
õõ+ ,
)
õõ, -
{
úú 	
const
ùù 
int
ùù 
infinity_32
ùù !
=
ùù" #
$num
ùù$ '
<<
ùù( *
$num
ùù+ -
;
ùù- .
const
ûû 
uint
ûû 
msk
ûû 
=
ûû 
$num
ûû (
;
ûû( )
uint
†† 
ux
†† 
=
†† 
asuint
†† 
(
†† 
x
†† 
)
†† 
;
††  
uint
°° 
uux
°° 
=
°° 
ux
°° 
&
°° 
msk
°° 
;
°°  
uint
¢¢ 
h
¢¢ 
=
¢¢ 
(
¢¢ 
uint
¢¢ 
)
¢¢ 
(
¢¢ 
asuint
¢¢ "
(
¢¢" #
min2
¢¢# '
(
¢¢' (
asfloat
¢¢( /
(
¢¢/ 0
uux
¢¢0 3
)
¢¢3 4
*
¢¢5 6
$num
¢¢7 F
,
¢¢F G
$num
¢¢H T
)
¢¢T U
)
¢¢U V
+
¢¢W X
$num
¢¢Y _
)
¢¢_ `
>>
¢¢a c
$num
¢¢d f
;
¢¢f g
h
££ 
=
££ 
select
££ 
(
££ 
h
££ 
,
££ 
select
££  
(
££  !
$num
££! (
,
££( )
$num
££* 1
,
££1 2
(
££3 4
int
££4 7
)
££7 8
uux
££8 ;
>
££< =
infinity_32
££> I
)
££I J
,
££J K
(
££L M
int
££M P
)
££P Q
uux
££Q T
>=
££U W
infinity_32
££X c
)
££c d
;
££d e
return
§§ 
h
§§ 
|
§§ 
(
§§ 
ux
§§ 
&
§§ 
~
§§ 
msk
§§ !
)
§§! "
>>
§§# %
$num
§§& (
;
§§( )
}
•• 	
[
ßß 	

MethodImpl
ßß	 
(
ßß 
MethodImplOptions
ßß %
.
ßß% & 
AggressiveInlining
ßß& 8
)
ßß8 9
]
ßß9 :
static
®® 
int
®® 
Align
®® 
(
®® 
int
®® 
s
®® 
,
®® 
int
®®  #
	alignment
®®$ -
)
®®- .
{
©© 	
return
™™ 
(
™™ 
(
™™ 
s
™™ 
+
™™ 
	alignment
™™ "
-
™™# $
$num
™™% &
)
™™& '
/
™™( )
	alignment
™™* 3
)
™™3 4
*
™™5 6
	alignment
™™7 @
;
™™@ A
}
´´ 	
}
¨¨ 
}≠≠ √‚
®D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\UniversalRenderPipelineCore.cs
	namespace

 	
UnityEngine


 
.

 
	Rendering

 
.

  
	Universal

  )
{ 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
enum5 9
MixedLightingSetup: L
{ 
None 
, 

ShadowMask 
, 
Subtractive 
, 
} 
; 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
struct5 ;
RenderingData< I
{ 
public 
CullingResults 
cullResults )
;) *
public 

CameraData 

cameraData $
;$ %
public 
	LightData 
	lightData "
;" #
public 

ShadowData 

shadowData $
;$ %
public 
PostProcessingData !
postProcessingData" 4
;4 5
public 
bool #
supportsDynamicBatching +
;+ ,
public 
PerObjectData 
perObjectData *
;* +
public   
bool   !
postProcessingEnabled   )
;  ) *
}!! 
[## 
	MovedFrom## 
(## 
$str## +
)##+ ,
]##, -
public##. 4
struct##5 ;
	LightData##< E
{$$ 
public%% 
int%% 
mainLightIndex%% !
;%%! "
public&& 
int&& !
additionalLightsCount&& (
;&&( )
public'' 
int'' -
!maxPerObjectAdditionalLightsCount'' 4
;''4 5
public(( 
NativeArray(( 
<(( 
VisibleLight(( '
>((' (
visibleLights(() 6
;((6 7
public)) 
bool)) *
shadeAdditionalLightsPerVertex)) 2
;))2 3
public** 
bool** !
supportsMixedLighting** )
;**) *
}++ 
[-- 
	MovedFrom-- 
(-- 
$str-- +
)--+ ,
]--, -
public--. 4
struct--5 ;

CameraData--< F
{.. 
	Matrix4x411 
m_ViewMatrix11 
;11 
	Matrix4x422 
m_ProjectionMatrix22 $
;22$ %
internal44 
void44 &
SetViewAndProjectionMatrix44 0
(440 1
	Matrix4x4441 :

viewMatrix44; E
,44E F
	Matrix4x444G P
projectionMatrix44Q a
)44a b
{55 	
m_ViewMatrix66 
=66 

viewMatrix66 %
;66% &
m_ProjectionMatrix77 
=77  
projectionMatrix77! 1
;771 2
}88 	
public>> 
	Matrix4x4>> 
GetViewMatrix>> &
(>>& '
int>>' *
	viewIndex>>+ 4
=>>5 6
$num>>7 8
)>>8 9
{?? 	
ifAA 
(AA 
xrAA 
.AA 
enabledAA 
)AA 
returnBB 
xrBB 
.BB 
GetViewMatrixBB '
(BB' (
	viewIndexBB( 1
)BB1 2
;BB2 3
returnDD 
m_ViewMatrixDD 
;DD  
}EE 	
publicKK 
	Matrix4x4KK 
GetProjectionMatrixKK ,
(KK, -
intKK- 0
	viewIndexKK1 :
=KK; <
$numKK= >
)KK> ?
{LL 	
ifNN 
(NN 
xrNN 
.NN 
enabledNN 
)NN 
returnOO 
xrOO 
.OO 
GetProjMatrixOO '
(OO' (
	viewIndexOO( 1
)OO1 2
;OO2 3
returnQQ 
m_ProjectionMatrixQQ %
;QQ% &
}RR 	
public[[ 
	Matrix4x4[[ "
GetGPUProjectionMatrix[[ /
([[/ 0
int[[0 3
	viewIndex[[4 =
=[[> ?
$num[[@ A
)[[A B
{\\ 	
return]] 
GL]] 
.]] "
GetGPUProjectionMatrix]] ,
(]], -
GetProjectionMatrix]]- @
(]]@ A
	viewIndex]]A J
)]]J K
,]]K L+
IsCameraProjectionMatrixFlipped]]M l
(]]l m
)]]m n
)]]n o
;]]o p
}^^ 	
public`` 
Camera`` 
camera`` 
;`` 
publicaa 
CameraRenderTypeaa 

renderTypeaa  *
;aa* +
publicbb 
RenderTexturebb 
targetTexturebb *
;bb* +
publiccc #
RenderTextureDescriptorcc &"
cameraTargetDescriptorcc' =
;cc= >
internaldd 
Rectdd 
	pixelRectdd 
;dd  
internalee 
intee 

pixelWidthee 
;ee  
internalff 
intff 
pixelHeightff  
;ff  !
internalgg 
floatgg 
aspectRatiogg "
;gg" #
publichh 
floathh 
renderScalehh  
;hh  !
publicii 
boolii 

clearDepthii 
;ii 
publicjj 

CameraTypejj 

cameraTypejj $
;jj$ %
publickk 
boolkk 
isDefaultViewportkk %
;kk% &
publicll 
boolll 
isHdrEnabledll  
;ll  !
publicmm 
boolmm  
requiresDepthTexturemm (
;mm( )
publicnn 
boolnn !
requiresOpaqueTexturenn )
;nn) *
publicpp 
boolpp 
xrRenderingpp 
;pp  
internalrr 
boolrr !
requireSrgbConversionrr +
{ss 	
gettt 
{uu 
ifww 
(ww 
xrww 
.ww 
enabledww 
)ww 
returnxx 
!xx 
xrxx 
.xx 
renderTargetDescxx /
.xx/ 0
sRGBxx0 4
&&xx5 7
(xx8 9
QualitySettingsxx9 H
.xxH I
activeColorSpacexxI Y
==xxZ \

ColorSpacexx] g
.xxg h
Linearxxh n
)xxn o
;xxo p
return{{ 
Display{{ 
.{{ 
main{{ #
.{{# $(
requiresSrgbBlitToBackbuffer{{$ @
;{{@ A
}|| 
}}} 	
public
ÇÇ 
bool
ÇÇ 
isSceneViewCamera
ÇÇ %
=>
ÇÇ& (

cameraType
ÇÇ) 3
==
ÇÇ4 6

CameraType
ÇÇ7 A
.
ÇÇA B
	SceneView
ÇÇB K
;
ÇÇK L
public
áá 
bool
áá 
isPreviewCamera
áá #
=>
áá$ &

cameraType
áá' 1
==
áá2 4

CameraType
áá5 ?
.
áá? @
Preview
áá@ G
;
ááG H
public
èè 
bool
èè -
IsCameraProjectionMatrixFlipped
èè 3
(
èè3 4
)
èè4 5
{
êê 	
var
íí 
renderer
íí 
=
íí  
ScriptableRenderer
íí -
.
íí- .
current
íí. 5
;
íí5 6
Debug
ìì 
.
ìì 
Assert
ìì 
(
ìì 
renderer
ìì !
!=
ìì" $
null
ìì% )
,
ìì) *
$str
ìì+ |
)
ìì| }
;
ìì} ~
if
ïï 
(
ïï 
renderer
ïï 
!=
ïï 
null
ïï  
)
ïï  !
{
ññ 
bool
óó )
renderingToBackBufferTarget
óó 0
=
óó1 2
renderer
óó3 ;
.
óó; <
cameraColorTarget
óó< M
==
óóN P&
BuiltinRenderTextureType
óóQ i
.
óói j
CameraTarget
óój v
;
óóv w
if
ôô 
(
ôô 
xr
ôô 
.
ôô 
enabled
ôô 
)
ôô )
renderingToBackBufferTarget
öö /
|=
öö0 2
renderer
öö3 ;
.
öö; <
cameraColorTarget
öö< M
==
ööN P
xr
ööQ S
.
ööS T
renderTarget
ööT `
&&
ööa c
!
ööd e
xr
ööe g
.
öög h*
renderTargetIsRenderTextureööh É
;ööÉ Ñ
bool
úú  
renderingToTexture
úú '
=
úú( )
!
úú* +)
renderingToBackBufferTarget
úú+ F
||
úúG I
targetTexture
úúJ W
!=
úúX Z
null
úú[ _
;
úú_ `
return
ùù 

SystemInfo
ùù !
.
ùù! "#
graphicsUVStartsAtTop
ùù" 7
&&
ùù8 : 
renderingToTexture
ùù; M
;
ùùM N
}
ûû 
return
†† 
true
†† 
;
†† 
}
°° 	
public
££ 
SortingCriteria
££ $
defaultOpaqueSortFlags
££ 5
;
££5 6
internal
•• 
XRPass
•• 
xr
•• 
;
•• 
[
ßß 	
Obsolete
ßß	 
(
ßß 
$str
ßß 2
)
ßß2 3
]
ßß3 4
public
®® 
bool
®® 
isStereoEnabled
®® #
;
®®# $
public
™™ 
float
™™ 
maxShadowDistance
™™ &
;
™™& '
public
´´ 
bool
´´  
postProcessEnabled
´´ &
;
´´& '
public
≠≠ 
IEnumerator
≠≠ 
<
≠≠ 
Action
≠≠ !
<
≠≠! "$
RenderTargetIdentifier
≠≠" 8
,
≠≠8 9
CommandBuffer
≠≠: G
>
≠≠G H
>
≠≠H I
captureActions
≠≠J X
;
≠≠X Y
public
ØØ 
	LayerMask
ØØ 
volumeLayerMask
ØØ (
;
ØØ( )
public
∞∞ 
	Transform
∞∞ 
volumeTrigger
∞∞ &
;
∞∞& '
public
≤≤ 
bool
≤≤ 
isStopNaNEnabled
≤≤ $
;
≤≤$ %
public
≥≥ 
bool
≥≥  
isDitheringEnabled
≥≥ &
;
≥≥& '
public
¥¥ 
AntialiasingMode
¥¥ 
antialiasing
¥¥  ,
;
¥¥, -
public
µµ !
AntialiasingQuality
µµ "!
antialiasingQuality
µµ# 6
;
µµ6 7
public
ªª  
ScriptableRenderer
ªª !
renderer
ªª" *
;
ªª* +
public
¡¡ 
bool
¡¡  
resolveFinalTarget
¡¡ &
;
¡¡& '
}
¬¬ 
[
ƒƒ 
	MovedFrom
ƒƒ 
(
ƒƒ 
$str
ƒƒ +
)
ƒƒ+ ,
]
ƒƒ, -
public
ƒƒ. 4
struct
ƒƒ5 ;

ShadowData
ƒƒ< F
{
≈≈ 
public
∆∆ 
bool
∆∆ &
supportsMainLightShadows
∆∆ ,
;
∆∆, -
public
«« 
bool
«« .
 requiresScreenSpaceShadowResolve
«« 4
;
««4 5
public
»» 
int
»» %
mainLightShadowmapWidth
»» *
;
»»* +
public
…… 
int
…… &
mainLightShadowmapHeight
…… +
;
……+ ,
public
   
int
   *
mainLightShadowCascadesCount
   /
;
  / 0
public
ÀÀ 
Vector3
ÀÀ *
mainLightShadowCascadesSplit
ÀÀ 3
;
ÀÀ3 4
public
ÃÃ 
bool
ÃÃ ,
supportsAdditionalLightShadows
ÃÃ 2
;
ÃÃ2 3
public
ÕÕ 
int
ÕÕ ,
additionalLightsShadowmapWidth
ÕÕ 1
;
ÕÕ1 2
public
ŒŒ 
int
ŒŒ -
additionalLightsShadowmapHeight
ŒŒ 2
;
ŒŒ2 3
public
œœ 
bool
œœ !
supportsSoftShadows
œœ '
;
œœ' (
public
–– 
int
–– &
shadowmapDepthBufferBits
–– +
;
––+ ,
public
—— 
List
—— 
<
—— 
Vector4
—— 
>
—— 
bias
—— !
;
——! "
}
““ 
public
’’ 

struct
’’ 
PreTile
’’ 
{
÷÷ 
public
ŸŸ 
Unity
ŸŸ 
.
ŸŸ 
Mathematics
ŸŸ  
.
ŸŸ  !
float4
ŸŸ! '
	planeLeft
ŸŸ( 1
;
ŸŸ1 2
public
⁄⁄ 
Unity
⁄⁄ 
.
⁄⁄ 
Mathematics
⁄⁄  
.
⁄⁄  !
float4
⁄⁄! '

planeRight
⁄⁄( 2
;
⁄⁄2 3
public
€€ 
Unity
€€ 
.
€€ 
Mathematics
€€  
.
€€  !
float4
€€! '
planeBottom
€€( 3
;
€€3 4
public
‹‹ 
Unity
‹‹ 
.
‹‹ 
Mathematics
‹‹  
.
‹‹  !
float4
‹‹! '
planeTop
‹‹( 0
;
‹‹0 1
}
›› 
public
‡‡ 

struct
‡‡ 
TileData
‡‡ 
{
·· 
public
‚‚ 
uint
‚‚ 
tileID
‚‚ 
;
‚‚ 
public
„„ 
uint
„„ 
listBitMask
„„ 
;
„„  
public
‰‰ 
uint
‰‰ 
relLightOffset
‰‰ "
;
‰‰" #
public
ÂÂ 
uint
ÂÂ 
unused
ÂÂ 
;
ÂÂ 
}
ÊÊ 
public
ÈÈ 

struct
ÈÈ 
PunctualLightData
ÈÈ #
{
ÍÍ 
public
ÎÎ 
Vector3
ÎÎ 
wsPos
ÎÎ 
;
ÎÎ 
public
ÏÏ 
float
ÏÏ 
radius
ÏÏ 
;
ÏÏ 
public
ÌÌ 
Vector4
ÌÌ 
color
ÌÌ 
;
ÌÌ 
public
ÓÓ 
Vector4
ÓÓ 
attenuation
ÓÓ "
;
ÓÓ" #
public
ÔÔ 
Vector3
ÔÔ 
spotDirection
ÔÔ $
;
ÔÔ$ %
public
 
int
 

lightIndex
 
;
 
public
ÒÒ 
Vector4
ÒÒ  
occlusionProbeInfo
ÒÒ )
;
ÒÒ) *
}
ÚÚ 
internal
ÙÙ 
static
ÙÙ 
class
ÙÙ 
ShaderPropertyId
ÙÙ *
{
ıı 
public
ˆˆ 
static
ˆˆ 
readonly
ˆˆ 
int
ˆˆ "$
glossyEnvironmentColor
ˆˆ# 9
=
ˆˆ: ;
Shader
ˆˆ< B
.
ˆˆB C
PropertyToID
ˆˆC O
(
ˆˆO P
$str
ˆˆP i
)
ˆˆi j
;
ˆˆj k
public
˜˜ 
static
˜˜ 
readonly
˜˜ 
int
˜˜ "$
subtractiveShadowColor
˜˜# 9
=
˜˜: ;
Shader
˜˜< B
.
˜˜B C
PropertyToID
˜˜C O
(
˜˜O P
$str
˜˜P i
)
˜˜i j
;
˜˜j k
public
˘˘ 
static
˘˘ 
readonly
˘˘ 
int
˘˘ "
ambientSkyColor
˘˘# 2
=
˘˘3 4
Shader
˘˘5 ;
.
˘˘; <
PropertyToID
˘˘< H
(
˘˘H I
$str
˘˘I [
)
˘˘[ \
;
˘˘\ ]
public
˙˙ 
static
˙˙ 
readonly
˙˙ 
int
˙˙ "!
ambientEquatorColor
˙˙# 6
=
˙˙7 8
Shader
˙˙9 ?
.
˙˙? @
PropertyToID
˙˙@ L
(
˙˙L M
$str
˙˙M c
)
˙˙c d
;
˙˙d e
public
˚˚ 
static
˚˚ 
readonly
˚˚ 
int
˚˚ " 
ambientGroundColor
˚˚# 5
=
˚˚6 7
Shader
˚˚8 >
.
˚˚> ?
PropertyToID
˚˚? K
(
˚˚K L
$str
˚˚L a
)
˚˚a b
;
˚˚b c
public
˝˝ 
static
˝˝ 
readonly
˝˝ 
int
˝˝ "
time
˝˝# '
=
˝˝( )
Shader
˝˝* 0
.
˝˝0 1
PropertyToID
˝˝1 =
(
˝˝= >
$str
˝˝> E
)
˝˝E F
;
˝˝F G
public
˛˛ 
static
˛˛ 
readonly
˛˛ 
int
˛˛ "
sinTime
˛˛# *
=
˛˛+ ,
Shader
˛˛- 3
.
˛˛3 4
PropertyToID
˛˛4 @
(
˛˛@ A
$str
˛˛A K
)
˛˛K L
;
˛˛L M
public
ˇˇ 
static
ˇˇ 
readonly
ˇˇ 
int
ˇˇ "
cosTime
ˇˇ# *
=
ˇˇ+ ,
Shader
ˇˇ- 3
.
ˇˇ3 4
PropertyToID
ˇˇ4 @
(
ˇˇ@ A
$str
ˇˇA K
)
ˇˇK L
;
ˇˇL M
public
ÄÄ 
static
ÄÄ 
readonly
ÄÄ 
int
ÄÄ "
	deltaTime
ÄÄ# ,
=
ÄÄ- .
Shader
ÄÄ/ 5
.
ÄÄ5 6
PropertyToID
ÄÄ6 B
(
ÄÄB C
$str
ÄÄC T
)
ÄÄT U
;
ÄÄU V
public
ÅÅ 
static
ÅÅ 
readonly
ÅÅ 
int
ÅÅ "
timeParameters
ÅÅ# 1
=
ÅÅ2 3
Shader
ÅÅ4 :
.
ÅÅ: ;
PropertyToID
ÅÅ; G
(
ÅÅG H
$str
ÅÅH Y
)
ÅÅY Z
;
ÅÅZ [
public
ÉÉ 
static
ÉÉ 
readonly
ÉÉ 
int
ÉÉ " 
scaledScreenParams
ÉÉ# 5
=
ÉÉ6 7
Shader
ÉÉ8 >
.
ÉÉ> ?
PropertyToID
ÉÉ? K
(
ÉÉK L
$str
ÉÉL a
)
ÉÉa b
;
ÉÉb c
public
ÑÑ 
static
ÑÑ 
readonly
ÑÑ 
int
ÑÑ "!
worldSpaceCameraPos
ÑÑ# 6
=
ÑÑ7 8
Shader
ÑÑ9 ?
.
ÑÑ? @
PropertyToID
ÑÑ@ L
(
ÑÑL M
$str
ÑÑM c
)
ÑÑc d
;
ÑÑd e
public
ÖÖ 
static
ÖÖ 
readonly
ÖÖ 
int
ÖÖ "
screenParams
ÖÖ# /
=
ÖÖ0 1
Shader
ÖÖ2 8
.
ÖÖ8 9
PropertyToID
ÖÖ9 E
(
ÖÖE F
$str
ÖÖF U
)
ÖÖU V
;
ÖÖV W
public
ÜÜ 
static
ÜÜ 
readonly
ÜÜ 
int
ÜÜ "
projectionParams
ÜÜ# 3
=
ÜÜ4 5
Shader
ÜÜ6 <
.
ÜÜ< =
PropertyToID
ÜÜ= I
(
ÜÜI J
$str
ÜÜJ ]
)
ÜÜ] ^
;
ÜÜ^ _
public
áá 
static
áá 
readonly
áá 
int
áá "
zBufferParams
áá# 0
=
áá1 2
Shader
áá3 9
.
áá9 :
PropertyToID
áá: F
(
ááF G
$str
ááG W
)
ááW X
;
ááX Y
public
àà 
static
àà 
readonly
àà 
int
àà "
orthoParams
àà# .
=
àà/ 0
Shader
àà1 7
.
àà7 8
PropertyToID
àà8 D
(
ààD E
$str
ààE X
)
ààX Y
;
ààY Z
public
ää 
static
ää 
readonly
ää 
int
ää "

viewMatrix
ää# -
=
ää. /
Shader
ää0 6
.
ää6 7
PropertyToID
ää7 C
(
ääC D
$str
ääD S
)
ääS T
;
ääT U
public
ãã 
static
ãã 
readonly
ãã 
int
ãã "
projectionMatrix
ãã# 3
=
ãã4 5
Shader
ãã6 <
.
ãã< =
PropertyToID
ãã= I
(
ããI J
$str
ããJ e
)
ããe f
;
ããf g
public
åå 
static
åå 
readonly
åå 
int
åå "%
viewAndProjectionMatrix
åå# :
=
åå; <
Shader
åå= C
.
ååC D
PropertyToID
ååD P
(
ååP Q
$str
ååQ a
)
ååa b
;
ååb c
public
éé 
static
éé 
readonly
éé 
int
éé "
inverseViewMatrix
éé# 4
=
éé5 6
Shader
éé7 =
.
éé= >
PropertyToID
éé> J
(
ééJ K
$str
ééK ]
)
éé] ^
;
éé^ _
public
èè 
static
èè 
readonly
èè 
int
èè "%
inverseProjectionMatrix
èè# :
=
èè; <
Shader
èè= C
.
èèC D
PropertyToID
èèD P
(
èèP Q
$str
èèQ c
)
èèc d
;
èèd e
public
êê 
static
êê 
readonly
êê 
int
êê ",
inverseViewAndProjectionMatrix
êê# A
=
êêB C
Shader
êêD J
.
êêJ K
PropertyToID
êêK W
(
êêW X
$str
êêX k
)
êêk l
;
êêl m
public
íí 
static
íí 
readonly
íí 
int
íí "$
cameraProjectionMatrix
íí# 9
=
íí: ;
Shader
íí< B
.
ííB C
PropertyToID
ííC O
(
ííO P
$str
ííP h
)
ííh i
;
ííi j
public
ìì 
static
ìì 
readonly
ìì 
int
ìì "+
inverseCameraProjectionMatrix
ìì# @
=
ììA B
Shader
ììC I
.
ììI J
PropertyToID
ììJ V
(
ììV W
$str
ììW r
)
ììr s
;
ììs t
public
îî 
static
îî 
readonly
îî 
int
îî "!
worldToCameraMatrix
îî# 6
=
îî7 8
Shader
îî9 ?
.
îî? @
PropertyToID
îî@ L
(
îîL M
$str
îîM b
)
îîb c
;
îîc d
public
ïï 
static
ïï 
readonly
ïï 
int
ïï "!
cameraToWorldMatrix
ïï# 6
=
ïï7 8
Shader
ïï9 ?
.
ïï? @
PropertyToID
ïï@ L
(
ïïL M
$str
ïïM b
)
ïïb c
;
ïïc d
public
óó 
static
óó 
readonly
óó 
int
óó "
	sourceTex
óó# ,
=
óó- .
Shader
óó/ 5
.
óó5 6
PropertyToID
óó6 B
(
óóB C
$str
óóC O
)
óóO P
;
óóP Q
public
òò 
static
òò 
readonly
òò 
int
òò "
	scaleBias
òò# ,
=
òò- .
Shader
òò/ 5
.
òò5 6
PropertyToID
òò6 B
(
òòB C
$str
òòC O
)
òòO P
;
òòP Q
public
ôô 
static
ôô 
readonly
ôô 
int
ôô "
scaleBiasRt
ôô# .
=
ôô/ 0
Shader
ôô1 7
.
ôô7 8
PropertyToID
ôô8 D
(
ôôD E
$str
ôôE S
)
ôôS T
;
ôôT U
}
öö 
public
úú 

struct
úú  
PostProcessingData
úú $
{
ùù 
public
ûû 
ColorGradingMode
ûû 
gradingMode
ûû  +
;
ûû+ ,
public
üü 
int
üü 
lutSize
üü 
;
üü 
}
†† 
public
¢¢ 

static
¢¢ 
class
¢¢ "
ShaderKeywordStrings
¢¢ ,
{
££ 
public
§§ 
static
§§ 
readonly
§§ 
string
§§ %
MainLightShadows
§§& 6
=
§§7 8
$str
§§9 N
;
§§N O
public
•• 
static
•• 
readonly
•• 
string
•• %%
MainLightShadowCascades
••& =
=
••> ?
$str
••@ ]
;
••] ^
public
¶¶ 
static
¶¶ 
readonly
¶¶ 
string
¶¶ %$
AdditionalLightsVertex
¶¶& <
=
¶¶= >
$str
¶¶? Z
;
¶¶Z [
public
ßß 
static
ßß 
readonly
ßß 
string
ßß %#
AdditionalLightsPixel
ßß& ;
=
ßß< =
$str
ßß> R
;
ßßR S
public
®® 
static
®® 
readonly
®® 
string
®® %$
AdditionalLightShadows
®®& <
=
®®= >
$str
®®? Z
;
®®Z [
public
©© 
static
©© 
readonly
©© 
string
©© %
SoftShadows
©©& 1
=
©©2 3
$str
©©4 C
;
©©C D
public
™™ 
static
™™ 
readonly
™™ 
string
™™ %&
MixedLightingSubtractive
™™& >
=
™™? @
$str
™™A ^
;
™™^ _
public
´´ 
static
´´ 
readonly
´´ 
string
´´ %"
LightmapShadowMixing
´´& :
=
´´; <
$str
´´= U
;
´´U V
public
¨¨ 
static
¨¨ 
readonly
¨¨ 
string
¨¨ %
ShadowsShadowMask
¨¨& 7
=
¨¨8 9
$str
¨¨: N
;
¨¨N O
public
ÆÆ 
static
ÆÆ 
readonly
ÆÆ 
string
ÆÆ %
DepthNoMsaa
ÆÆ& 1
=
ÆÆ2 3
$str
ÆÆ4 D
;
ÆÆD E
public
ØØ 
static
ØØ 
readonly
ØØ 
string
ØØ %

DepthMsaa2
ØØ& 0
=
ØØ1 2
$str
ØØ3 B
;
ØØB C
public
∞∞ 
static
∞∞ 
readonly
∞∞ 
string
∞∞ %

DepthMsaa4
∞∞& 0
=
∞∞1 2
$str
∞∞3 B
;
∞∞B C
public
±± 
static
±± 
readonly
±± 
string
±± %

DepthMsaa8
±±& 0
=
±±1 2
$str
±±3 B
;
±±B C
public
≥≥ 
static
≥≥ 
readonly
≥≥ 
string
≥≥ %$
LinearToSRGBConversion
≥≥& <
=
≥≥= >
$str
≥≥? [
;
≥≥[ \
public
µµ 
static
µµ 
readonly
µµ 
string
µµ %
SmaaLow
µµ& -
=
µµ. /
$str
µµ0 B
;
µµB C
public
∂∂ 
static
∂∂ 
readonly
∂∂ 
string
∂∂ %

SmaaMedium
∂∂& 0
=
∂∂1 2
$str
∂∂3 H
;
∂∂H I
public
∑∑ 
static
∑∑ 
readonly
∑∑ 
string
∑∑ %
SmaaHigh
∑∑& .
=
∑∑/ 0
$str
∑∑1 D
;
∑∑D E
public
∏∏ 
static
∏∏ 
readonly
∏∏ 
string
∏∏ %
PaniniGeneric
∏∏& 3
=
∏∏4 5
$str
∏∏6 @
;
∏∏@ A
public
ππ 
static
ππ 
readonly
ππ 
string
ππ % 
PaniniUnitDistance
ππ& 8
=
ππ9 :
$str
ππ; K
;
ππK L
public
∫∫ 
static
∫∫ 
readonly
∫∫ 
string
∫∫ %
BloomLQ
∫∫& -
=
∫∫. /
$str
∫∫0 ;
;
∫∫; <
public
ªª 
static
ªª 
readonly
ªª 
string
ªª %
BloomHQ
ªª& -
=
ªª. /
$str
ªª0 ;
;
ªª; <
public
ºº 
static
ºº 
readonly
ºº 
string
ºº %
BloomLQDirt
ºº& 1
=
ºº2 3
$str
ºº4 D
;
ººD E
public
ΩΩ 
static
ΩΩ 
readonly
ΩΩ 
string
ΩΩ %
BloomHQDirt
ΩΩ& 1
=
ΩΩ2 3
$str
ΩΩ4 D
;
ΩΩD E
public
ææ 
static
ææ 
readonly
ææ 
string
ææ %
UseRGBM
ææ& -
=
ææ. /
$str
ææ0 ;
;
ææ; <
public
øø 
static
øø 
readonly
øø 
string
øø %

Distortion
øø& 0
=
øø1 2
$str
øø3 @
;
øø@ A
public
¿¿ 
static
¿¿ 
readonly
¿¿ 
string
¿¿ %!
ChromaticAberration
¿¿& 9
=
¿¿: ;
$str
¿¿< S
;
¿¿S T
public
¡¡ 
static
¡¡ 
readonly
¡¡ 
string
¡¡ %

HDRGrading
¡¡& 0
=
¡¡1 2
$str
¡¡3 A
;
¡¡A B
public
¬¬ 
static
¬¬ 
readonly
¬¬ 
string
¬¬ %
TonemapACES
¬¬& 1
=
¬¬2 3
$str
¬¬4 C
;
¬¬C D
public
√√ 
static
√√ 
readonly
√√ 
string
√√ %
TonemapNeutral
√√& 4
=
√√5 6
$str
√√7 I
;
√√I J
public
ƒƒ 
static
ƒƒ 
readonly
ƒƒ 
string
ƒƒ %
	FilmGrain
ƒƒ& /
=
ƒƒ0 1
$str
ƒƒ2 ?
;
ƒƒ? @
public
≈≈ 
static
≈≈ 
readonly
≈≈ 
string
≈≈ %
Fxaa
≈≈& *
=
≈≈+ ,
$str
≈≈- 4
;
≈≈4 5
public
∆∆ 
static
∆∆ 
readonly
∆∆ 
string
∆∆ %
	Dithering
∆∆& /
=
∆∆0 1
$str
∆∆2 >
;
∆∆> ?
public
«« 
static
«« 
readonly
«« 
string
«« %"
ScreenSpaceOcclusion
««& :
=
««; <
$str
««= V
;
««V W
public
…… 
static
…… 
readonly
…… 
string
…… %!
HighQualitySampling
……& 9
=
……: ;
$str
……< T
;
……T U
public
ÀÀ 
static
ÀÀ 
readonly
ÀÀ 
string
ÀÀ %!
DOWNSAMPLING_SIZE_2
ÀÀ& 9
=
ÀÀ: ;
$str
ÀÀ< Q
;
ÀÀQ R
public
ÃÃ 
static
ÃÃ 
readonly
ÃÃ 
string
ÃÃ %!
DOWNSAMPLING_SIZE_4
ÃÃ& 9
=
ÃÃ: ;
$str
ÃÃ< Q
;
ÃÃQ R
public
ÕÕ 
static
ÕÕ 
readonly
ÕÕ 
string
ÕÕ %!
DOWNSAMPLING_SIZE_8
ÕÕ& 9
=
ÕÕ: ;
$str
ÕÕ< Q
;
ÕÕQ R
public
ŒŒ 
static
ŒŒ 
readonly
ŒŒ 
string
ŒŒ %"
DOWNSAMPLING_SIZE_16
ŒŒ& :
=
ŒŒ; <
$str
ŒŒ= S
;
ŒŒS T
public
œœ 
static
œœ 
readonly
œœ 
string
œœ %
_SPOT
œœ& +
=
œœ, -
$str
œœ. 5
;
œœ5 6
public
–– 
static
–– 
readonly
–– 
string
–– %
_DIRECTIONAL
––& 2
=
––3 4
$str
––5 C
;
––C D
public
—— 
static
—— 
readonly
—— 
string
—— %
_POINT
——& ,
=
——- .
$str
——/ 7
;
——7 8
public
““ 
static
““ 
readonly
““ 
string
““ %0
"_DEFERRED_ADDITIONAL_LIGHT_SHADOWS
““& H
=
““I J
$str
““K o
;
““o p
public
”” 
static
”” 
readonly
”” 
string
”” %"
_GBUFFER_NORMALS_OCT
””& :
=
””; <
$str
””= S
;
””S T
public
‘‘ 
static
‘‘ 
readonly
‘‘ 
string
‘‘ %,
_DEFERRED_SUBTRACTIVE_LIGHTING
‘‘& D
=
‘‘E F
$str
‘‘G g
;
‘‘g h
public
’’ 
static
’’ 
readonly
’’ 
string
’’ %
LIGHTMAP_ON
’’& 1
=
’’2 3
$str
’’4 A
;
’’A B
public
÷÷ 
static
÷÷ 
readonly
÷÷ 
string
÷÷ %
_ALPHATEST_ON
÷÷& 3
=
÷÷4 5
$str
÷÷6 E
;
÷÷E F
public
◊◊ 
static
◊◊ 
readonly
◊◊ 
string
◊◊ %"
DIRLIGHTMAP_COMBINED
◊◊& :
=
◊◊; <
$str
◊◊= S
;
◊◊S T
public
ÿÿ 
static
ÿÿ 
readonly
ÿÿ 
string
ÿÿ %
_DETAIL_MULX2
ÿÿ& 3
=
ÿÿ4 5
$str
ÿÿ6 E
;
ÿÿE F
public
ŸŸ 
static
ŸŸ 
readonly
ŸŸ 
string
ŸŸ %
_DETAIL_SCALED
ŸŸ& 4
=
ŸŸ5 6
$str
ŸŸ7 G
;
ŸŸG H
public
⁄⁄ 
static
⁄⁄ 
readonly
⁄⁄ 
string
⁄⁄ %

_CLEARCOAT
⁄⁄& 0
=
⁄⁄1 2
$str
⁄⁄3 ?
;
⁄⁄? @
public
€€ 
static
€€ 
readonly
€€ 
string
€€ %
_CLEARCOATMAP
€€& 3
=
€€4 5
$str
€€6 E
;
€€E F
public
ﬁﬁ 
static
ﬁﬁ 
readonly
ﬁﬁ 
string
ﬁﬁ %
UseDrawProcedural
ﬁﬁ& 7
=
ﬁﬁ8 9
$str
ﬁﬁ: P
;
ﬁﬁP Q
}
ﬂﬂ 
public
·· 

sealed
·· 
partial
·· 
class
·· %
UniversalRenderPipeline
··  7
{
‚‚ 
static
ÂÂ 
Vector4
ÂÂ $
k_DefaultLightPosition
ÂÂ -
=
ÂÂ. /
new
ÂÂ0 3
Vector4
ÂÂ4 ;
(
ÂÂ; <
$num
ÂÂ< @
,
ÂÂ@ A
$num
ÂÂB F
,
ÂÂF G
$num
ÂÂH L
,
ÂÂL M
$num
ÂÂN R
)
ÂÂR S
;
ÂÂS T
static
ÊÊ 
Vector4
ÊÊ !
k_DefaultLightColor
ÊÊ *
=
ÊÊ+ ,
Color
ÊÊ- 2
.
ÊÊ2 3
black
ÊÊ3 8
;
ÊÊ8 9
static
ÍÍ 
Vector4
ÍÍ '
k_DefaultLightAttenuation
ÍÍ 0
=
ÍÍ1 2
new
ÍÍ3 6
Vector4
ÍÍ7 >
(
ÍÍ> ?
$num
ÍÍ? C
,
ÍÍC D
$num
ÍÍE I
,
ÍÍI J
$num
ÍÍK O
,
ÍÍO P
$num
ÍÍQ U
)
ÍÍU V
;
ÍÍV W
static
ÎÎ 
Vector4
ÎÎ )
k_DefaultLightSpotDirection
ÎÎ 2
=
ÎÎ3 4
new
ÎÎ5 8
Vector4
ÎÎ9 @
(
ÎÎ@ A
$num
ÎÎA E
,
ÎÎE F
$num
ÎÎG K
,
ÎÎK L
$num
ÎÎM Q
,
ÎÎQ R
$num
ÎÎS W
)
ÎÎW X
;
ÎÎX Y
static
ÏÏ 
Vector4
ÏÏ )
k_DefaultLightsProbeChannel
ÏÏ 2
=
ÏÏ3 4
new
ÏÏ5 8
Vector4
ÏÏ9 @
(
ÏÏ@ A
$num
ÏÏA E
,
ÏÏE F
$num
ÏÏG K
,
ÏÏK L
$num
ÏÏM Q
,
ÏÏQ R
$num
ÏÏS W
)
ÏÏW X
;
ÏÏX Y
static
ÓÓ 
List
ÓÓ 
<
ÓÓ 
Vector4
ÓÓ 
>
ÓÓ 
m_ShadowBiasData
ÓÓ -
=
ÓÓ. /
new
ÓÓ0 3
List
ÓÓ4 8
<
ÓÓ8 9
Vector4
ÓÓ9 @
>
ÓÓ@ A
(
ÓÓA B
)
ÓÓB C
;
ÓÓC D
public
ıı 
static
ıı 
bool
ıı 
IsGameCamera
ıı '
(
ıı' (
Camera
ıı( .
camera
ıı/ 5
)
ıı5 6
{
ˆˆ 	
if
˜˜ 
(
˜˜ 
camera
˜˜ 
==
˜˜ 
null
˜˜ 
)
˜˜ 
throw
¯¯ 
new
¯¯ #
ArgumentNullException
¯¯ /
(
¯¯/ 0
$str
¯¯0 8
)
¯¯8 9
;
¯¯9 :
return
˙˙ 
camera
˙˙ 
.
˙˙ 

cameraType
˙˙ $
==
˙˙% '

CameraType
˙˙( 2
.
˙˙2 3
Game
˙˙3 7
||
˙˙8 :
camera
˙˙; A
.
˙˙A B

cameraType
˙˙B L
==
˙˙M O

CameraType
˙˙P Z
.
˙˙Z [
VR
˙˙[ ]
;
˙˙] ^
}
˚˚ 	
[
ÇÇ 	
Obsolete
ÇÇ	 
(
ÇÇ 
$str
ÇÇ =
)
ÇÇ= >
]
ÇÇ> ?
public
ÉÉ 
static
ÉÉ 
bool
ÉÉ 
IsStereoEnabled
ÉÉ *
(
ÉÉ* +
Camera
ÉÉ+ 1
camera
ÉÉ2 8
)
ÉÉ8 9
{
ÑÑ 	
if
ÖÖ 
(
ÖÖ 
camera
ÖÖ 
==
ÖÖ 
null
ÖÖ 
)
ÖÖ 
throw
ÜÜ 
new
ÜÜ #
ArgumentNullException
ÜÜ /
(
ÜÜ/ 0
$str
ÜÜ0 8
)
ÜÜ8 9
;
ÜÜ9 :
return
àà 
IsGameCamera
àà 
(
àà  
camera
àà  &
)
àà& '
&&
àà( *
(
àà+ ,
camera
àà, 2
.
àà2 3
stereoTargetEye
àà3 B
==
ààC E!
StereoTargetEyeMask
ààF Y
.
ààY Z
Both
ààZ ^
)
àà^ _
;
àà_ `
}
ââ 	
public
èè 
static
èè *
UniversalRenderPipelineAsset
èè 2
asset
èè3 8
{
êê 	
get
ëë 
=>
ëë 
GraphicsSettings
ëë #
.
ëë# $#
currentRenderPipeline
ëë$ 9
as
ëë: <*
UniversalRenderPipelineAsset
ëë= Y
;
ëëY Z
}
íí 	
[
ôô 	
Obsolete
ôô	 
(
ôô 
$str
ôô G
)
ôôG H
]
ôôH I
static
öö 
bool
öö &
IsMultiPassStereoEnabled
öö ,
(
öö, -
Camera
öö- 3
camera
öö4 :
)
öö: ;
{
õõ 	
if
úú 
(
úú 
camera
úú 
==
úú 
null
úú 
)
úú 
throw
ùù 
new
ùù #
ArgumentNullException
ùù /
(
ùù/ 0
$str
ùù0 8
)
ùù8 9
;
ùù9 :
return
üü 
false
üü 
;
üü 
}
†† 	

Comparison
¢¢ 
<
¢¢ 
Camera
¢¢ 
>
¢¢ 
cameraComparison
¢¢ +
=
¢¢, -
(
¢¢. /
camera1
¢¢/ 6
,
¢¢6 7
camera2
¢¢8 ?
)
¢¢? @
=>
¢¢A C
{
¢¢D E
return
¢¢F L
(
¢¢M N
int
¢¢N Q
)
¢¢Q R
camera1
¢¢S Z
.
¢¢Z [
depth
¢¢[ `
-
¢¢a b
(
¢¢c d
int
¢¢d g
)
¢¢g h
camera2
¢¢i p
.
¢¢p q
depth
¢¢q v
;
¢¢v w
}
¢¢x y
;
¢¢y z
void
™™ 
SortCameras
™™ 
(
™™ 
Camera
™™ 
[
™™  
]
™™  !
cameras
™™" )
)
™™) *
{
´´ 	
if
¨¨ 
(
¨¨ 
cameras
¨¨ 
.
¨¨ 
Length
¨¨ 
>
¨¨  
$num
¨¨! "
)
¨¨" #
Array
≠≠ 
.
≠≠ 
Sort
≠≠ 
(
≠≠ 
cameras
≠≠ "
,
≠≠" #
cameraComparison
≠≠$ 4
)
≠≠4 5
;
≠≠5 6
}
ÆÆ 	
static
±± %
RenderTextureDescriptor
±± &+
CreateRenderTextureDescriptor
±±' D
(
±±D E
Camera
±±E K
camera
±±L R
,
±±R S
float
±±T Y
renderScale
±±Z e
,
±±e f
bool
≤≤ 
isHdrEnabled
≤≤ 
,
≤≤ 
int
≤≤ "
msaaSamples
≤≤# .
,
≤≤. /
bool
≤≤0 4

needsAlpha
≤≤5 ?
)
≤≤? @
{
≥≥ 	%
RenderTextureDescriptor
¥¥ #
desc
¥¥$ (
;
¥¥( )
GraphicsFormat
µµ (
renderTextureFormatDefault
µµ 5
=
µµ6 7

SystemInfo
µµ8 B
.
µµB C
GetGraphicsFormat
µµC T
(
µµT U
DefaultFormat
µµU b
.
µµb c
LDR
µµc f
)
µµf g
;
µµg h
if
∑∑ 
(
∑∑ 
camera
∑∑ 
.
∑∑ 
targetTexture
∑∑ $
==
∑∑% '
null
∑∑( ,
)
∑∑, -
{
∏∏ 
desc
ππ 
=
ππ 
new
ππ %
RenderTextureDescriptor
ππ 2
(
ππ2 3
camera
ππ3 9
.
ππ9 :

pixelWidth
ππ: D
,
ππD E
camera
ππF L
.
ππL M
pixelHeight
ππM X
)
ππX Y
;
ππY Z
desc
∫∫ 
.
∫∫ 
width
∫∫ 
=
∫∫ 
(
∫∫ 
int
∫∫ !
)
∫∫! "
(
∫∫" #
(
∫∫# $
float
∫∫$ )
)
∫∫) *
desc
∫∫* .
.
∫∫. /
width
∫∫/ 4
*
∫∫5 6
renderScale
∫∫7 B
)
∫∫B C
;
∫∫C D
desc
ªª 
.
ªª 
height
ªª 
=
ªª 
(
ªª 
int
ªª "
)
ªª" #
(
ªª# $
(
ªª$ %
float
ªª% *
)
ªª* +
desc
ªª+ /
.
ªª/ 0
height
ªª0 6
*
ªª7 8
renderScale
ªª9 D
)
ªªD E
;
ªªE F
GraphicsFormat
ææ 
	hdrFormat
ææ (
;
ææ( )
if
øø 
(
øø 
!
øø 

needsAlpha
øø 
&&
øø  "
RenderingUtils
øø# 1
.
øø1 2$
SupportsGraphicsFormat
øø2 H
(
øøH I
GraphicsFormat
øøI W
.
øøW X$
B10G11R11_UFloatPack32
øøX n
,
øøn o
FormatUsage
øøp {
.
øø{ |
Linearøø| Ç
|øøÉ Ñ
FormatUsageøøÖ ê
.øøê ë
Renderøøë ó
)øøó ò
)øøò ô
	hdrFormat
¿¿ 
=
¿¿ 
GraphicsFormat
¿¿  .
.
¿¿. /$
B10G11R11_UFloatPack32
¿¿/ E
;
¿¿E F
else
¡¡ 
if
¡¡ 
(
¡¡ 
RenderingUtils
¡¡ '
.
¡¡' ($
SupportsGraphicsFormat
¡¡( >
(
¡¡> ?
GraphicsFormat
¡¡? M
.
¡¡M N!
R16G16B16A16_SFloat
¡¡N a
,
¡¡a b
FormatUsage
¡¡c n
.
¡¡n o
Linear
¡¡o u
|
¡¡v w
FormatUsage¡¡x É
.¡¡É Ñ
Render¡¡Ñ ä
)¡¡ä ã
)¡¡ã å
	hdrFormat
¬¬ 
=
¬¬ 
GraphicsFormat
¬¬  .
.
¬¬. /!
R16G16B16A16_SFloat
¬¬/ B
;
¬¬B C
else
√√ 
	hdrFormat
ƒƒ 
=
ƒƒ 

SystemInfo
ƒƒ  *
.
ƒƒ* +
GetGraphicsFormat
ƒƒ+ <
(
ƒƒ< =
DefaultFormat
ƒƒ= J
.
ƒƒJ K
HDR
ƒƒK N
)
ƒƒN O
;
ƒƒO P
desc
∆∆ 
.
∆∆ 
graphicsFormat
∆∆ #
=
∆∆$ %
isHdrEnabled
∆∆& 2
?
∆∆3 4
	hdrFormat
∆∆5 >
:
∆∆? @(
renderTextureFormatDefault
∆∆A [
;
∆∆[ \
desc
«« 
.
«« 
depthBufferBits
«« $
=
««% &
$num
««' )
;
««) *
desc
»» 
.
»» 
msaaSamples
»»  
=
»»! "
msaaSamples
»»# .
;
»». /
desc
…… 
.
…… 
sRGB
…… 
=
…… 
(
…… 
QualitySettings
…… ,
.
……, -
activeColorSpace
……- =
==
……> @

ColorSpace
……A K
.
……K L
Linear
……L R
)
……R S
;
……S T
}
   
else
ÀÀ 
{
ÃÃ 
desc
ÕÕ 
=
ÕÕ 
camera
ÕÕ 
.
ÕÕ 
targetTexture
ÕÕ +
.
ÕÕ+ ,

descriptor
ÕÕ, 6
;
ÕÕ6 7
desc
ŒŒ 
.
ŒŒ 
width
ŒŒ 
=
ŒŒ 
camera
ŒŒ #
.
ŒŒ# $

pixelWidth
ŒŒ$ .
;
ŒŒ. /
desc
œœ 
.
œœ 
height
œœ 
=
œœ 
camera
œœ $
.
œœ$ %
pixelHeight
œœ% 0
;
œœ0 1
desc
–– 
.
–– 
graphicsFormat
–– #
=
––$ %
isHdrEnabled
––& 2
?
––3 4
desc
––5 9
.
––9 :
graphicsFormat
––: H
:
––I J(
renderTextureFormatDefault
––K e
;
––e f
}
÷÷ 
desc
ÿÿ 
.
ÿÿ 
enableRandomWrite
ÿÿ "
=
ÿÿ# $
false
ÿÿ% *
;
ÿÿ* +
desc
ŸŸ 
.
ŸŸ 
bindMS
ŸŸ 
=
ŸŸ 
false
ŸŸ 
;
ŸŸ  
desc
⁄⁄ 
.
⁄⁄ 
useDynamicScale
⁄⁄  
=
⁄⁄! "
camera
⁄⁄# )
.
⁄⁄) *$
allowDynamicResolution
⁄⁄* @
;
⁄⁄@ A
desc
ﬁﬁ 
.
ﬁﬁ 
msaaSamples
ﬁﬁ 
=
ﬁﬁ 

SystemInfo
ﬁﬁ )
.
ﬁﬁ) *6
(GetRenderTextureSupportedMSAASampleCount
ﬁﬁ* R
(
ﬁﬁR S
desc
ﬁﬁS W
)
ﬁﬁW X
;
ﬁﬁX Y
return
‡‡ 
desc
‡‡ 
;
‡‡ 
}
·· 	
static
„„ 
Lightmapping
„„ 
.
„„ #
RequestLightsDelegate
„„ 1
lightsDelegate
„„2 @
=
„„A B
(
„„C D
Light
„„D I
[
„„I J
]
„„J K
requests
„„L T
,
„„T U
NativeArray
„„V a
<
„„a b
LightDataGI
„„b m
>
„„m n
lightsOutput
„„o {
)
„„{ |
=>
„„} 
{
‰‰ 	
LightDataGI
ÁÁ 
	lightData
ÁÁ !
=
ÁÁ" #
new
ÁÁ$ '
LightDataGI
ÁÁ( 3
(
ÁÁ3 4
)
ÁÁ4 5
;
ÁÁ5 6
for
ÈÈ 
(
ÈÈ 
int
ÈÈ 
i
ÈÈ 
=
ÈÈ 
$num
ÈÈ 
;
ÈÈ 
i
ÈÈ 
<
ÈÈ 
requests
ÈÈ  (
.
ÈÈ( )
Length
ÈÈ) /
;
ÈÈ/ 0
i
ÈÈ1 2
++
ÈÈ2 4
)
ÈÈ4 5
{
ÍÍ 
Light
ÎÎ 
light
ÎÎ 
=
ÎÎ 
requests
ÎÎ &
[
ÎÎ& '
i
ÎÎ' (
]
ÎÎ( )
;
ÎÎ) *
switch
ÏÏ 
(
ÏÏ 
light
ÏÏ 
.
ÏÏ 
type
ÏÏ "
)
ÏÏ" #
{
ÌÌ 
case
ÓÓ 
	LightType
ÓÓ "
.
ÓÓ" #
Directional
ÓÓ# .
:
ÓÓ. /
DirectionalLight
ÔÔ (
directionalLight
ÔÔ) 9
=
ÔÔ: ;
new
ÔÔ< ?
DirectionalLight
ÔÔ@ P
(
ÔÔP Q
)
ÔÔQ R
;
ÔÔR S
LightmapperUtils
 (
.
( )
Extract
) 0
(
0 1
light
1 6
,
6 7
ref
8 ;
directionalLight
< L
)
L M
;
M N
	lightData
ÒÒ !
.
ÒÒ! "
Init
ÒÒ" &
(
ÒÒ& '
ref
ÒÒ' *
directionalLight
ÒÒ+ ;
)
ÒÒ; <
;
ÒÒ< =
break
ÚÚ 
;
ÚÚ 
case
ÛÛ 
	LightType
ÛÛ "
.
ÛÛ" #
Point
ÛÛ# (
:
ÛÛ( )

PointLight
ÙÙ "

pointLight
ÙÙ# -
=
ÙÙ. /
new
ÙÙ0 3

PointLight
ÙÙ4 >
(
ÙÙ> ?
)
ÙÙ? @
;
ÙÙ@ A
LightmapperUtils
ıı (
.
ıı( )
Extract
ıı) 0
(
ıı0 1
light
ıı1 6
,
ıı6 7
ref
ıı8 ;

pointLight
ıı< F
)
ııF G
;
ııG H
	lightData
ˆˆ !
.
ˆˆ! "
Init
ˆˆ" &
(
ˆˆ& '
ref
ˆˆ' *

pointLight
ˆˆ+ 5
)
ˆˆ5 6
;
ˆˆ6 7
break
˜˜ 
;
˜˜ 
case
¯¯ 
	LightType
¯¯ "
.
¯¯" #
Spot
¯¯# '
:
¯¯' (
	SpotLight
˘˘ !
	spotLight
˘˘" +
=
˘˘, -
new
˘˘. 1
	SpotLight
˘˘2 ;
(
˘˘; <
)
˘˘< =
;
˘˘= >
LightmapperUtils
˙˙ (
.
˙˙( )
Extract
˙˙) 0
(
˙˙0 1
light
˙˙1 6
,
˙˙6 7
ref
˙˙8 ;
	spotLight
˙˙< E
)
˙˙E F
;
˙˙F G
	spotLight
˚˚ !
.
˚˚! "
innerConeAngle
˚˚" 0
=
˚˚1 2
light
˚˚3 8
.
˚˚8 9
innerSpotAngle
˚˚9 G
*
˚˚H I
Mathf
˚˚J O
.
˚˚O P
Deg2Rad
˚˚P W
;
˚˚W X
	spotLight
¸¸ !
.
¸¸! "
angularFalloff
¸¸" 0
=
¸¸1 2 
AngularFalloffType
¸¸3 E
.
¸¸E F#
AnalyticAndInnerAngle
¸¸F [
;
¸¸[ \
	lightData
˝˝ !
.
˝˝! "
Init
˝˝" &
(
˝˝& '
ref
˝˝' *
	spotLight
˝˝+ 4
)
˝˝4 5
;
˝˝5 6
break
˛˛ 
;
˛˛ 
case
ˇˇ 
	LightType
ˇˇ "
.
ˇˇ" #
Area
ˇˇ# '
:
ˇˇ' (
RectangleLight
ÄÄ &
rectangleLight
ÄÄ' 5
=
ÄÄ6 7
new
ÄÄ8 ;
RectangleLight
ÄÄ< J
(
ÄÄJ K
)
ÄÄK L
;
ÄÄL M
LightmapperUtils
ÅÅ (
.
ÅÅ( )
Extract
ÅÅ) 0
(
ÅÅ0 1
light
ÅÅ1 6
,
ÅÅ6 7
ref
ÅÅ8 ;
rectangleLight
ÅÅ< J
)
ÅÅJ K
;
ÅÅK L
rectangleLight
ÇÇ &
.
ÇÇ& '
mode
ÇÇ' +
=
ÇÇ, -
	LightMode
ÇÇ. 7
.
ÇÇ7 8
Baked
ÇÇ8 =
;
ÇÇ= >
	lightData
ÉÉ !
.
ÉÉ! "
Init
ÉÉ" &
(
ÉÉ& '
ref
ÉÉ' *
rectangleLight
ÉÉ+ 9
)
ÉÉ9 :
;
ÉÉ: ;
break
ÑÑ 
;
ÑÑ 
case
ÖÖ 
	LightType
ÖÖ "
.
ÖÖ" #
Disc
ÖÖ# '
:
ÖÖ' (
	DiscLight
ÜÜ !
	discLight
ÜÜ" +
=
ÜÜ, -
new
ÜÜ. 1
	DiscLight
ÜÜ2 ;
(
ÜÜ; <
)
ÜÜ< =
;
ÜÜ= >
LightmapperUtils
áá (
.
áá( )
Extract
áá) 0
(
áá0 1
light
áá1 6
,
áá6 7
ref
áá8 ;
	discLight
áá< E
)
ááE F
;
ááF G
	discLight
àà !
.
àà! "
mode
àà" &
=
àà' (
	LightMode
àà) 2
.
àà2 3
Baked
àà3 8
;
àà8 9
	lightData
ââ !
.
ââ! "
Init
ââ" &
(
ââ& '
ref
ââ' *
	discLight
ââ+ 4
)
ââ4 5
;
ââ5 6
break
ää 
;
ää 
default
ãã 
:
ãã 
	lightData
åå !
.
åå! "

InitNoBake
åå" ,
(
åå, -
light
åå- 2
.
åå2 3
GetInstanceID
åå3 @
(
åå@ A
)
ååA B
)
ååB C
;
ååC D
break
çç 
;
çç 
}
éé 
	lightData
êê 
.
êê 
falloff
êê !
=
êê" #
FalloffType
êê$ /
.
êê/ 0
InverseSquared
êê0 >
;
êê> ?
lightsOutput
ëë 
[
ëë 
i
ëë 
]
ëë 
=
ëë  !
	lightData
ëë" +
;
ëë+ ,
}
íí 
}
ùù 	
;
ùù	 

public
†† 
static
†† 
void
†† 1
#GetLightAttenuationAndSpotDirection
†† >
(
††> ?
	LightType
°° 
	lightType
°° 
,
°°  
float
°°! &

lightRange
°°' 1
,
°°1 2
	Matrix4x4
°°3 <%
lightLocalToWorldMatrix
°°= T
,
°°T U
float
¢¢ 
	spotAngle
¢¢ 
,
¢¢ 
float
¢¢ "
?
¢¢" #
innerSpotAngle
¢¢$ 2
,
¢¢2 3
out
££ 
Vector4
££ 
lightAttenuation
££ (
,
££( )
out
££* -
Vector4
££. 5
lightSpotDir
££6 B
)
££B C
{
§§ 	
lightAttenuation
•• 
=
•• '
k_DefaultLightAttenuation
•• 8
;
••8 9
lightSpotDir
¶¶ 
=
¶¶ )
k_DefaultLightSpotDirection
¶¶ 6
;
¶¶6 7
if
©© 
(
©© 
	lightType
©© 
!=
©© 
	LightType
©© &
.
©©& '
Directional
©©' 2
)
©©2 3
{
™™ 
float
∏∏ 
lightRangeSqr
∏∏ #
=
∏∏$ %

lightRange
∏∏& 0
*
∏∏1 2

lightRange
∏∏3 =
;
∏∏= >
float
ππ "
fadeStartDistanceSqr
ππ *
=
ππ+ ,
$num
ππ- 1
*
ππ2 3
$num
ππ4 8
*
ππ9 :
lightRangeSqr
ππ; H
;
ππH I
float
∫∫ 
fadeRangeSqr
∫∫ "
=
∫∫# $
(
∫∫% &"
fadeStartDistanceSqr
∫∫& :
-
∫∫; <
lightRangeSqr
∫∫= J
)
∫∫J K
;
∫∫K L
float
ªª !
oneOverFadeRangeSqr
ªª )
=
ªª* +
$num
ªª, 0
/
ªª1 2
fadeRangeSqr
ªª3 ?
;
ªª? @
float
ºº +
lightRangeSqrOverFadeRangeSqr
ºº 3
=
ºº4 5
-
ºº6 7
lightRangeSqr
ºº7 D
/
ººE F
fadeRangeSqr
ººG S
;
ººS T
float
ΩΩ "
oneOverLightRangeSqr
ΩΩ *
=
ΩΩ+ ,
$num
ΩΩ- 1
/
ΩΩ2 3
Mathf
ΩΩ4 9
.
ΩΩ9 :
Max
ΩΩ: =
(
ΩΩ= >
$num
ΩΩ> E
,
ΩΩE F

lightRange
ΩΩG Q
*
ΩΩR S

lightRange
ΩΩT ^
)
ΩΩ^ _
;
ΩΩ_ `
lightAttenuation
¡¡  
.
¡¡  !
x
¡¡! "
=
¡¡# $
Application
¡¡% 0
.
¡¡0 1
isMobilePlatform
¡¡1 A
||
¡¡B D

SystemInfo
¡¡E O
.
¡¡O P 
graphicsDeviceType
¡¡P b
==
¡¡c e 
GraphicsDeviceType
¡¡f x
.
¡¡x y
Switch
¡¡y 
?¡¡Ä Å#
oneOverFadeRangeSqr¡¡Ç ï
:¡¡ñ ó$
oneOverLightRangeSqr¡¡ò ¨
;¡¡¨ ≠
lightAttenuation
¬¬  
.
¬¬  !
y
¬¬! "
=
¬¬# $+
lightRangeSqrOverFadeRangeSqr
¬¬% B
;
¬¬B C
}
√√ 
if
≈≈ 
(
≈≈ 
	lightType
≈≈ 
==
≈≈ 
	LightType
≈≈ &
.
≈≈& '
Spot
≈≈' +
)
≈≈+ ,
{
∆∆ 
Vector4
«« 
dir
«« 
=
«« %
lightLocalToWorldMatrix
«« 5
.
««5 6
	GetColumn
««6 ?
(
««? @
$num
««@ A
)
««A B
;
««B C
lightSpotDir
»» 
=
»» 
new
»» "
Vector4
»»# *
(
»»* +
-
»»+ ,
dir
»», /
.
»»/ 0
x
»»0 1
,
»»1 2
-
»»3 4
dir
»»4 7
.
»»7 8
y
»»8 9
,
»»9 :
-
»»; <
dir
»»< ?
.
»»? @
z
»»@ A
,
»»A B
$num
»»C G
)
»»G H
;
»»H I
float
–– 
cosOuterAngle
–– #
=
––$ %
Mathf
––& +
.
––+ ,
Cos
––, /
(
––/ 0
Mathf
––0 5
.
––5 6
Deg2Rad
––6 =
*
––> ?
	spotAngle
––@ I
*
––J K
$num
––L P
)
––P Q
;
––Q R
float
‘‘ 
cosInnerAngle
‘‘ #
;
‘‘# $
if
’’ 
(
’’ 
innerSpotAngle
’’ "
.
’’" #
HasValue
’’# +
)
’’+ ,
cosInnerAngle
÷÷ !
=
÷÷" #
Mathf
÷÷$ )
.
÷÷) *
Cos
÷÷* -
(
÷÷- .
innerSpotAngle
÷÷. <
.
÷÷< =
Value
÷÷= B
*
÷÷C D
Mathf
÷÷E J
.
÷÷J K
Deg2Rad
÷÷K R
*
÷÷S T
$num
÷÷U Y
)
÷÷Y Z
;
÷÷Z [
else
◊◊ 
cosInnerAngle
ÿÿ !
=
ÿÿ" #
Mathf
ÿÿ$ )
.
ÿÿ) *
Cos
ÿÿ* -
(
ÿÿ- .
(
ÿÿ. /
$num
ÿÿ/ 3
*
ÿÿ4 5
Mathf
ÿÿ6 ;
.
ÿÿ; <
Atan
ÿÿ< @
(
ÿÿ@ A
Mathf
ÿÿA F
.
ÿÿF G
Tan
ÿÿG J
(
ÿÿJ K
	spotAngle
ÿÿK T
*
ÿÿU V
$num
ÿÿW [
*
ÿÿ\ ]
Mathf
ÿÿ^ c
.
ÿÿc d
Deg2Rad
ÿÿd k
)
ÿÿk l
*
ÿÿm n
(
ÿÿo p
$num
ÿÿp u
-
ÿÿv w
$num
ÿÿx }
)
ÿÿ} ~
/ÿÿ Ä
$numÿÿÅ Ü
)ÿÿÜ á
)ÿÿá à
*ÿÿâ ä
$numÿÿã è
)ÿÿè ê
;ÿÿê ë
float
ŸŸ 
smoothAngleRange
ŸŸ &
=
ŸŸ' (
Mathf
ŸŸ) .
.
ŸŸ. /
Max
ŸŸ/ 2
(
ŸŸ2 3
$num
ŸŸ3 9
,
ŸŸ9 :
cosInnerAngle
ŸŸ; H
-
ŸŸI J
cosOuterAngle
ŸŸK X
)
ŸŸX Y
;
ŸŸY Z
float
⁄⁄ 
invAngleRange
⁄⁄ #
=
⁄⁄$ %
$num
⁄⁄& *
/
⁄⁄+ ,
smoothAngleRange
⁄⁄- =
;
⁄⁄= >
float
€€ 
add
€€ 
=
€€ 
-
€€ 
cosOuterAngle
€€ *
*
€€+ ,
invAngleRange
€€- :
;
€€: ;
lightAttenuation
‹‹  
.
‹‹  !
z
‹‹! "
=
‹‹# $
invAngleRange
‹‹% 2
;
‹‹2 3
lightAttenuation
››  
.
››  !
w
››! "
=
››# $
add
››% (
;
››( )
}
ﬁﬁ 
}
ﬂﬂ 	
public
·· 
static
·· 
void
·· -
InitializeLightConstants_Common
·· :
(
··: ;
NativeArray
··; F
<
··F G
VisibleLight
··G S
>
··S T
lights
··U [
,
··[ \
int
··] `

lightIndex
··a k
,
··k l
out
··m p
Vector4
··q x
lightPos··y Å
,··Å Ç
out··É Ü
Vector4··á é

lightColor··è ô
,··ô ö
out··õ û
Vector4··ü ¶ 
lightAttenuation··ß ∑
,··∑ ∏
out··π º
Vector4··Ω ƒ
lightSpotDir··≈ —
,··— “
out··” ÷
Vector4··◊ ﬁ*
lightOcclusionProbeChannel··ﬂ ˘
)··˘ ˙
{
‚‚ 	
lightPos
„„ 
=
„„ $
k_DefaultLightPosition
„„ -
;
„„- .

lightColor
‰‰ 
=
‰‰ !
k_DefaultLightColor
‰‰ ,
;
‰‰, -(
lightOcclusionProbeChannel
ÂÂ &
=
ÂÂ' ()
k_DefaultLightsProbeChannel
ÂÂ) D
;
ÂÂD E
lightAttenuation
ÊÊ 
=
ÊÊ '
k_DefaultLightAttenuation
ÊÊ 8
;
ÊÊ8 9
lightSpotDir
ÁÁ 
=
ÁÁ )
k_DefaultLightSpotDirection
ÁÁ 6
;
ÁÁ6 7
if
ÎÎ 
(
ÎÎ 

lightIndex
ÎÎ 
<
ÎÎ 
$num
ÎÎ 
)
ÎÎ 
return
ÏÏ 
;
ÏÏ 
VisibleLight
ÓÓ 
	lightData
ÓÓ "
=
ÓÓ# $
lights
ÓÓ% +
[
ÓÓ+ ,

lightIndex
ÓÓ, 6
]
ÓÓ6 7
;
ÓÓ7 8
if
ÔÔ 
(
ÔÔ 
	lightData
ÔÔ 
.
ÔÔ 
	lightType
ÔÔ #
==
ÔÔ$ &
	LightType
ÔÔ' 0
.
ÔÔ0 1
Directional
ÔÔ1 <
)
ÔÔ< =
{
 
Vector4
ÒÒ 
dir
ÒÒ 
=
ÒÒ 
-
ÒÒ 
	lightData
ÒÒ (
.
ÒÒ( ) 
localToWorldMatrix
ÒÒ) ;
.
ÒÒ; <
	GetColumn
ÒÒ< E
(
ÒÒE F
$num
ÒÒF G
)
ÒÒG H
;
ÒÒH I
lightPos
ÚÚ 
=
ÚÚ 
new
ÚÚ 
Vector4
ÚÚ &
(
ÚÚ& '
dir
ÚÚ' *
.
ÚÚ* +
x
ÚÚ+ ,
,
ÚÚ, -
dir
ÚÚ. 1
.
ÚÚ1 2
y
ÚÚ2 3
,
ÚÚ3 4
dir
ÚÚ5 8
.
ÚÚ8 9
z
ÚÚ9 :
,
ÚÚ: ;
$num
ÚÚ< @
)
ÚÚ@ A
;
ÚÚA B
}
ÛÛ 
else
ÙÙ 
{
ıı 
Vector4
ˆˆ 
pos
ˆˆ 
=
ˆˆ 
	lightData
ˆˆ '
.
ˆˆ' ( 
localToWorldMatrix
ˆˆ( :
.
ˆˆ: ;
	GetColumn
ˆˆ; D
(
ˆˆD E
$num
ˆˆE F
)
ˆˆF G
;
ˆˆG H
lightPos
˜˜ 
=
˜˜ 
new
˜˜ 
Vector4
˜˜ &
(
˜˜& '
pos
˜˜' *
.
˜˜* +
x
˜˜+ ,
,
˜˜, -
pos
˜˜. 1
.
˜˜1 2
y
˜˜2 3
,
˜˜3 4
pos
˜˜5 8
.
˜˜8 9
z
˜˜9 :
,
˜˜: ;
$num
˜˜< @
)
˜˜@ A
;
˜˜A B
}
¯¯ 

lightColor
˚˚ 
=
˚˚ 
	lightData
˚˚ "
.
˚˚" #

finalColor
˚˚# -
;
˚˚- .1
#GetLightAttenuationAndSpotDirection
˝˝ /
(
˝˝/ 0
	lightData
˛˛ 
.
˛˛ 
	lightType
˛˛ #
,
˛˛# $
	lightData
˛˛% .
.
˛˛. /
range
˛˛/ 4
,
˛˛4 5
	lightData
˛˛6 ?
.
˛˛? @ 
localToWorldMatrix
˛˛@ R
,
˛˛R S
	lightData
ˇˇ 
.
ˇˇ 
	spotAngle
ˇˇ #
,
ˇˇ# $
	lightData
ˇˇ% .
.
ˇˇ. /
light
ˇˇ/ 4
?
ˇˇ4 5
.
ˇˇ5 6
innerSpotAngle
ˇˇ6 D
,
ˇˇD E
out
ÄÄ 
lightAttenuation
ÄÄ $
,
ÄÄ$ %
out
ÄÄ& )
lightSpotDir
ÄÄ* 6
)
ÄÄ6 7
;
ÄÄ7 8
Light
ÇÇ 
light
ÇÇ 
=
ÇÇ 
	lightData
ÇÇ #
.
ÇÇ# $
light
ÇÇ$ )
;
ÇÇ) *
if
ÑÑ 
(
ÑÑ 
light
ÑÑ 
!=
ÑÑ 
null
ÑÑ 
&&
ÑÑ  
light
ÑÑ! &
.
ÑÑ& '
bakingOutput
ÑÑ' 3
.
ÑÑ3 4
lightmapBakeType
ÑÑ4 D
==
ÑÑE G
LightmapBakeType
ÑÑH X
.
ÑÑX Y
Mixed
ÑÑY ^
&&
ÑÑ_ a
$num
ÖÖ 
<=
ÖÖ 
light
ÖÖ 
.
ÖÖ 
bakingOutput
ÖÖ '
.
ÖÖ' ("
occlusionMaskChannel
ÖÖ( <
&&
ÖÖ= ?
light
ÜÜ 
.
ÜÜ 
bakingOutput
ÜÜ "
.
ÜÜ" #"
occlusionMaskChannel
ÜÜ# 7
<
ÜÜ8 9
$num
ÜÜ: ;
)
ÜÜ; <
{
áá (
lightOcclusionProbeChannel
àà *
[
àà* +
light
àà+ 0
.
àà0 1
bakingOutput
àà1 =
.
àà= >"
occlusionMaskChannel
àà> R
]
ààR S
=
ààT U
$num
ààV Z
;
ààZ [
}
ââ 
}
ää 	
}
ãã 
internal
çç 
enum
çç 
URPProfileId
çç 
{
éé "
UniversalRenderTotal
êê 
,
êê #
UpdateVolumeFramework
ëë 
,
ëë 
RenderCameraStack
íí 
,
íí $
AdditionalLightsShadow
ïï 
,
ïï 
ColorGradingLUT
ññ 
,
ññ 
	CopyColor
óó 
,
óó 
	CopyDepth
òò 
,
òò  
DepthNormalPrepass
ôô 
,
ôô 
DepthPrepass
öö 
,
öö 
DrawOpaqueObjects
ùù 
,
ùù $
DrawTransparentObjects
ûû 
,
ûû 
MainLightShadow
££ 
,
££ 
ResolveShadows
§§ 
,
§§ 
SSAO
•• 
,
•• 
StopNaNs
®® 
,
®® 
SMAA
©© 
,
©© "
GaussianDepthOfField
™™ 
,
™™ 
BokehDepthOfField
´´ 
,
´´ 

MotionBlur
¨¨ 
,
¨¨ 
PaniniProjection
≠≠ 
,
≠≠ 
UberPostProcess
ÆÆ 
,
ÆÆ 
Bloom
ØØ 
,
ØØ 
	FinalBlit
±± 
}
≤≤ 
}≥≥ *
£D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\ChannelMixer.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' F
)F G
]G H
public 

sealed 
class 
ChannelMixer $
:% &
VolumeComponent' 6
,6 7!
IPostProcessComponent8 M
{ 
[ 	
Tooltip	 
( 
$str J
)J K
]K L
public		 !
ClampedFloatParameter		 $
redOutRedIn		% 0
=		1 2
new		3 6!
ClampedFloatParameter		7 L
(		L M
$num		M Q
,		Q R
-		S T
$num		T X
,		X Y
$num		Z ^
)		^ _
;		_ `
[ 	
Tooltip	 
( 
$str L
)L M
]M N
public !
ClampedFloatParameter $
redOutGreenIn% 2
=3 4
new5 8!
ClampedFloatParameter9 N
(N O
$numO Q
,Q R
-S T
$numT X
,X Y
$numZ ^
)^ _
;_ `
[ 	
Tooltip	 
( 
$str K
)K L
]L M
public !
ClampedFloatParameter $
redOutBlueIn% 1
=2 3
new4 7!
ClampedFloatParameter8 M
(M N
$numN P
,P Q
-R S
$numS W
,W X
$numY ]
)] ^
;^ _
[ 	
Tooltip	 
( 
$str J
)J K
]K L
public !
ClampedFloatParameter $
greenOutRedIn% 2
=3 4
new5 8!
ClampedFloatParameter9 N
(N O
$numO Q
,Q R
-S T
$numT X
,X Y
$numZ ^
)^ _
;_ `
[ 	
Tooltip	 
( 
$str L
)L M
]M N
public !
ClampedFloatParameter $
greenOutGreenIn% 4
=5 6
new7 :!
ClampedFloatParameter; P
(P Q
$numQ U
,U V
-W X
$numX \
,\ ]
$num^ b
)b c
;c d
[ 	
Tooltip	 
( 
$str K
)K L
]L M
public !
ClampedFloatParameter $
greenOutBlueIn% 3
=4 5
new6 9!
ClampedFloatParameter: O
(O P
$numP R
,R S
-T U
$numU Y
,Y Z
$num[ _
)_ `
;` a
[ 	
Tooltip	 
( 
$str J
)J K
]K L
public !
ClampedFloatParameter $
blueOutRedIn% 1
=2 3
new4 7!
ClampedFloatParameter8 M
(M N
$numN P
,P Q
-R S
$numS W
,W X
$numY ]
)] ^
;^ _
[ 	
Tooltip	 
( 
$str L
)L M
]M N
public !
ClampedFloatParameter $
blueOutGreenIn% 3
=4 5
new6 9!
ClampedFloatParameter: O
(O P
$numP R
,R S
-T U
$numU Y
,Y Z
$num[ _
)_ `
;` a
[   	
Tooltip  	 
(   
$str   K
)  K L
]  L M
public!! !
ClampedFloatParameter!! $
blueOutBlueIn!!% 2
=!!3 4
new!!5 8!
ClampedFloatParameter!!9 N
(!!N O
$num!!O S
,!!S T
-!!U V
$num!!V Z
,!!Z [
$num!!\ `
)!!` a
;!!a b
public## 
bool## 
IsActive## 
(## 
)## 
{$$ 	
return%% 
redOutRedIn%% 
.%% 
value%% $
!=%%% '
$num%%( ,
||&& 
redOutGreenIn&&  
.&&  !
value&&! &
!=&&' )
$num&&* ,
||'' 
redOutBlueIn'' 
.''  
value''  %
!=''& (
$num'') +
||(( 
greenOutRedIn((  
.((  !
value((! &
!=((' )
$num((* ,
||)) 
greenOutGreenIn)) "
.))" #
value))# (
!=))) +
$num)), 0
||** 
greenOutBlueIn** !
.**! "
value**" '
!=**( *
$num**+ -
||++ 
blueOutRedIn++ 
.++  
value++  %
!=++& (
$num++) +
||,, 
blueOutGreenIn,, !
.,,! "
value,," '
!=,,( *
$num,,+ -
||-- 
blueOutBlueIn--  
.--  !
value--! &
!=--' )
$num--* .
;--. /
}.. 	
public00 
bool00 
IsTileCompatible00 $
(00$ %
)00% &
=>00' )
true00* .
;00. /
}11 
}22 ¢ı
ßD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\ColorGradingLutPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
public

 

class

 
ColorGradingLutPass

 $
:

% & 
ScriptableRenderPass

' ;
{ 
readonly 
Material 
m_LutBuilderLdr )
;) *
readonly 
Material 
m_LutBuilderHdr )
;) *
readonly 
GraphicsFormat 
m_HdrLutFormat  .
;. /
readonly 
GraphicsFormat 
m_LdrLutFormat  .
;. /
RenderTargetHandle 
m_InternalLut (
;( )
public 
ColorGradingLutPass "
(" #
RenderPassEvent# 2
evt3 6
,6 7
PostProcessData8 G
dataH L
)L M
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @
ColorGradingLutPass@ S
)S T
)T U
;U V
renderPassEvent 
= 
evt !
;! " 
overrideCameraTarget  
=! "
true# '
;' (
Material 
Load 
( 
Shader  
shader! '
)' (
{ 
if 
( 
shader 
== 
null "
)" #
{ 
Debug 
. 
LogError "
(" #
$"# %
Missing shader. % 5
{5 6
GetType6 =
(= >
)> ?
.? @
DeclaringType@ M
.M N
NameN R
}R Sb
U render pass will not execute. Check for missing reference in the renderer resources.	S ®
"
® ©
)
© ™
;
™ ´
return 
null 
;  
} 
return!! 
	CoreUtils!!  
.!!  ! 
CreateEngineMaterial!!! 5
(!!5 6
shader!!6 <
)!!< =
;!!= >
}"" 
m_LutBuilderLdr$$ 
=$$ 
Load$$ "
($$" #
data$$# '
.$$' (
shaders$$( /
.$$/ 0
lutBuilderLdrPS$$0 ?
)$$? @
;$$@ A
m_LutBuilderHdr%% 
=%% 
Load%% "
(%%" #
data%%# '
.%%' (
shaders%%( /
.%%/ 0
lutBuilderHdrPS%%0 ?
)%%? @
;%%@ A
const(( 
FormatUsage(( 
kFlags(( $
=((% &
FormatUsage((' 2
.((2 3
Linear((3 9
|((: ;
FormatUsage((< G
.((G H
Render((H N
;((N O
if)) 
()) 

SystemInfo)) 
.)) 
IsFormatSupported)) ,
()), -
GraphicsFormat))- ;
.)); <
R16G16B16A16_SFloat))< O
,))O P
kFlags))Q W
)))W X
)))X Y
m_HdrLutFormat** 
=**  
GraphicsFormat**! /
.**/ 0
R16G16B16A16_SFloat**0 C
;**C D
else++ 
if++ 
(++ 

SystemInfo++ 
.++  
IsFormatSupported++  1
(++1 2
GraphicsFormat++2 @
.++@ A"
B10G11R11_UFloatPack32++A W
,++W X
kFlags++Y _
)++_ `
)++` a
m_HdrLutFormat,, 
=,,  
GraphicsFormat,,! /
.,,/ 0"
B10G11R11_UFloatPack32,,0 F
;,,F G
else-- 
m_HdrLutFormat22 
=22  
GraphicsFormat22! /
.22/ 0
R8G8B8A8_UNorm220 >
;22> ?
m_LdrLutFormat44 
=44 
GraphicsFormat44 +
.44+ ,
R8G8B8A8_UNorm44, :
;44: ;
}55 	
public77 
void77 
Setup77 
(77 
in77 
RenderTargetHandle77 /
internalLut770 ;
)77; <
{88 	
m_InternalLut99 
=99 
internalLut99 '
;99' (
}:: 	
public== 
override== 
void== 
Execute== $
(==$ %#
ScriptableRenderContext==% <
context=== D
,==D E
ref==F I
RenderingData==J W
renderingData==X e
)==e f
{>> 	
var?? 
cmd?? 
=?? 
CommandBufferPool?? '
.??' (
Get??( +
(??+ ,
)??, -
;??- .
using@@ 
(@@ 
new@@ 
ProfilingScope@@ %
(@@% &
cmd@@& )
,@@) *
ProfilingSampler@@+ ;
.@@; <
Get@@< ?
(@@? @
URPProfileId@@@ L
.@@L M
ColorGradingLUT@@M \
)@@\ ]
)@@] ^
)@@^ _
{AA 
varCC 
stackCC 
=CC 
VolumeManagerCC )
.CC) *
instanceCC* 2
.CC2 3
stackCC3 8
;CC8 9
varDD 
channelMixerDD  
=DD! "
stackDD# (
.DD( )
GetComponentDD) 5
<DD5 6
ChannelMixerDD6 B
>DDB C
(DDC D
)DDD E
;DDE F
varEE 
colorAdjustmentsEE $
=EE% &
stackEE' ,
.EE, -
GetComponentEE- 9
<EE9 :
ColorAdjustmentsEE: J
>EEJ K
(EEK L
)EEL M
;EEM N
varFF 
curvesFF 
=FF 
stackFF "
.FF" #
GetComponentFF# /
<FF/ 0
ColorCurvesFF0 ;
>FF; <
(FF< =
)FF= >
;FF> ?
varGG 
liftGammaGainGG !
=GG" #
stackGG$ )
.GG) *
GetComponentGG* 6
<GG6 7
LiftGammaGainGG7 D
>GGD E
(GGE F
)GGF G
;GGG H
varHH %
shadowsMidtonesHighlightsHH -
=HH. /
stackHH0 5
.HH5 6
GetComponentHH6 B
<HHB C%
ShadowsMidtonesHighlightsHHC \
>HH\ ]
(HH] ^
)HH^ _
;HH_ `
varII 
splitToningII 
=II  !
stackII" '
.II' (
GetComponentII( 4
<II4 5
SplitToningII5 @
>II@ A
(IIA B
)IIB C
;IIC D
varJJ 
tonemappingJJ 
=JJ  !
stackJJ" '
.JJ' (
GetComponentJJ( 4
<JJ4 5
TonemappingJJ5 @
>JJ@ A
(JJA B
)JJB C
;JJC D
varKK 
whiteBalanceKK  
=KK! "
stackKK# (
.KK( )
GetComponentKK) 5
<KK5 6
WhiteBalanceKK6 B
>KKB C
(KKC D
)KKD E
;KKE F
refMM 
varMM 
postProcessingDataMM *
=MM+ ,
refMM- 0
renderingDataMM1 >
.MM> ?
postProcessingDataMM? Q
;MMQ R
boolNN 
hdrNN 
=NN 
postProcessingDataNN -
.NN- .
gradingModeNN. 9
==NN: <
ColorGradingModeNN= M
.NNM N
HighDynamicRangeNNN ^
;NN^ _
intQQ 
	lutHeightQQ 
=QQ 
postProcessingDataQQ  2
.QQ2 3
lutSizeQQ3 :
;QQ: ;
intRR 
lutWidthRR 
=RR 
	lutHeightRR (
*RR) *
	lutHeightRR+ 4
;RR4 5
varSS 
formatSS 
=SS 
hdrSS  
?SS! "
m_HdrLutFormatSS# 1
:SS2 3
m_LdrLutFormatSS4 B
;SSB C
varTT 
materialTT 
=TT 
hdrTT "
?TT# $
m_LutBuilderHdrTT% 4
:TT5 6
m_LutBuilderLdrTT7 F
;TTF G
varUU 
descUU 
=UU 
newUU #
RenderTextureDescriptorUU 6
(UU6 7
lutWidthUU7 ?
,UU? @
	lutHeightUUA J
,UUJ K
formatUUL R
,UUR S
$numUUT U
)UUU V
;UUV W
descVV 
.VV 
vrUsageVV 
=VV 
VRTextureUsageVV -
.VV- .
NoneVV. 2
;VV2 3
cmdWW 
.WW 
GetTemporaryRTWW "
(WW" #
m_InternalLutWW# 0
.WW0 1
idWW1 3
,WW3 4
descWW5 9
,WW9 :

FilterModeWW; E
.WWE F
BilinearWWF N
)WWN O
;WWO P
varZZ 
lmsColorBalanceZZ #
=ZZ$ %

ColorUtilsZZ& 0
.ZZ0 1#
ColorBalanceToLMSCoeffsZZ1 H
(ZZH I
whiteBalanceZZI U
.ZZU V
temperatureZZV a
.ZZa b
valueZZb g
,ZZg h
whiteBalanceZZi u
.ZZu v
tintZZv z
.ZZz {
value	ZZ{ Ä
)
ZZÄ Å
;
ZZÅ Ç
var[[ 
	hueSatCon[[ 
=[[ 
new[[  #
Vector4[[$ +
([[+ ,
colorAdjustments[[, <
.[[< =
hueShift[[= E
.[[E F
value[[F K
/[[L M
$num[[N R
,[[R S
colorAdjustments[[T d
.[[d e

saturation[[e o
.[[o p
value[[p u
/[[v w
$num[[x |
+[[} ~
$num	[[ Å
,
[[Å Ç
colorAdjustments
[[É ì
.
[[ì î
contrast
[[î ú
.
[[ú ù
value
[[ù ¢
/
[[£ §
$num
[[• ©
+
[[™ ´
$num
[[¨ Æ
,
[[Æ Ø
$num
[[∞ ≤
)
[[≤ ≥
;
[[≥ ¥
var\\ 
channelMixerR\\ !
=\\" #
new\\$ '
Vector4\\( /
(\\/ 0
channelMixer\\0 <
.\\< =
redOutRedIn\\= H
.\\H I
value\\I N
/\\O P
$num\\Q U
,\\U V
channelMixer\\W c
.\\c d
redOutGreenIn\\d q
.\\q r
value\\r w
/\\x y
$num\\z ~
,\\~ 
channelMixer
\\Ä å
.
\\å ç
redOutBlueIn
\\ç ô
.
\\ô ö
value
\\ö ü
/
\\† °
$num
\\¢ ¶
,
\\¶ ß
$num
\\® ™
)
\\™ ´
;
\\´ ¨
var]] 
channelMixerG]] !
=]]" #
new]]$ '
Vector4]]( /
(]]/ 0
channelMixer]]0 <
.]]< =
greenOutRedIn]]= J
.]]J K
value]]K P
/]]Q R
$num]]S W
,]]W X
channelMixer]]Y e
.]]e f
greenOutGreenIn]]f u
.]]u v
value]]v {
/]]| }
$num	]]~ Ç
,
]]Ç É
channelMixer
]]Ñ ê
.
]]ê ë
greenOutBlueIn
]]ë ü
.
]]ü †
value
]]† •
/
]]¶ ß
$num
]]® ¨
,
]]¨ ≠
$num
]]Æ ∞
)
]]∞ ±
;
]]± ≤
var^^ 
channelMixerB^^ !
=^^" #
new^^$ '
Vector4^^( /
(^^/ 0
channelMixer^^0 <
.^^< =
blueOutRedIn^^= I
.^^I J
value^^J O
/^^P Q
$num^^R V
,^^V W
channelMixer^^X d
.^^d e
blueOutGreenIn^^e s
.^^s t
value^^t y
/^^z {
$num	^^| Ä
,
^^Ä Å
channelMixer
^^Ç é
.
^^é è
blueOutBlueIn
^^è ú
.
^^ú ù
value
^^ù ¢
/
^^£ §
$num
^^• ©
,
^^© ™
$num
^^´ ≠
)
^^≠ Æ
;
^^Æ Ø
var`` #
shadowsHighlightsLimits`` +
=``, -
new``. 1
Vector4``2 9
(``9 :%
shadowsMidtonesHighlightsaa -
.aa- .
shadowsStartaa. :
.aa: ;
valueaa; @
,aa@ A%
shadowsMidtonesHighlightsbb -
.bb- .

shadowsEndbb. 8
.bb8 9
valuebb9 >
,bb> ?%
shadowsMidtonesHighlightscc -
.cc- .
highlightsStartcc. =
.cc= >
valuecc> C
,ccC D%
shadowsMidtonesHighlightsdd -
.dd- .
highlightsEnddd. ;
.dd; <
valuedd< A
)ee 
;ee 
vargg 
(gg 
shadowsgg 
,gg 
midtonesgg &
,gg& '

highlightsgg( 2
)gg2 3
=gg4 5

ColorUtilsgg6 @
.gg@ A,
 PrepareShadowsMidtonesHighlightsggA a
(gga b%
shadowsMidtonesHighlightshh -
.hh- .
shadowshh. 5
.hh5 6
valuehh6 ;
,hh; <%
shadowsMidtonesHighlightsii -
.ii- .
midtonesii. 6
.ii6 7
valueii7 <
,ii< =%
shadowsMidtonesHighlightsjj -
.jj- .

highlightsjj. 8
.jj8 9
valuejj9 >
)kk 
;kk 
varmm 
(mm 
liftmm 
,mm 
gammamm  
,mm  !
gainmm" &
)mm& '
=mm( )

ColorUtilsmm* 4
.mm4 5 
PrepareLiftGammaGainmm5 I
(mmI J
liftGammaGainnn !
.nn! "
liftnn" &
.nn& '
valuenn' ,
,nn, -
liftGammaGainoo !
.oo! "
gammaoo" '
.oo' (
valueoo( -
,oo- .
liftGammaGainpp !
.pp! "
gainpp" &
.pp& '
valuepp' ,
)qq 
;qq 
varss 
(ss 
splitShadowsss !
,ss! "
splitHighlightsss# 2
)ss2 3
=ss4 5

ColorUtilsss6 @
.ss@ A
PrepareSplitToningssA S
(ssS T
splitToningtt 
.tt  
shadowstt  '
.tt' (
valuett( -
,tt- .
splitToninguu 
.uu  

highlightsuu  *
.uu* +
valueuu+ 0
,uu0 1
splitToningvv 
.vv  
balancevv  '
.vv' (
valuevv( -
)ww 
;ww 
varyy 
lutParametersyy !
=yy" #
newyy$ '
Vector4yy( /
(yy/ 0
	lutHeightyy0 9
,yy9 :
$numyy; ?
/yy@ A
lutWidthyyB J
,yyJ K
$numyyL P
/yyQ R
	lutHeightyyS \
,yy\ ]
	lutHeightzz 
/zz 
(zz  !
	lutHeightzz! *
-zz+ ,
$numzz- /
)zz/ 0
)zz0 1
;zz1 2
material}} 
.}} 
	SetVector}} "
(}}" #
ShaderConstants}}# 2
.}}2 3
_Lut_Params}}3 >
,}}> ?
lutParameters}}@ M
)}}M N
;}}N O
material~~ 
.~~ 
	SetVector~~ "
(~~" #
ShaderConstants~~# 2
.~~2 3
_ColorBalance~~3 @
,~~@ A
lmsColorBalance~~B Q
)~~Q R
;~~R S
material 
. 
	SetVector "
(" #
ShaderConstants# 2
.2 3
_ColorFilter3 ?
,? @
colorAdjustmentsA Q
.Q R
colorFilterR ]
.] ^
value^ c
.c d
lineard j
)j k
;k l
material
ÄÄ 
.
ÄÄ 
	SetVector
ÄÄ "
(
ÄÄ" #
ShaderConstants
ÄÄ# 2
.
ÄÄ2 3
_ChannelMixerRed
ÄÄ3 C
,
ÄÄC D
channelMixerR
ÄÄE R
)
ÄÄR S
;
ÄÄS T
material
ÅÅ 
.
ÅÅ 
	SetVector
ÅÅ "
(
ÅÅ" #
ShaderConstants
ÅÅ# 2
.
ÅÅ2 3 
_ChannelMixerGreen
ÅÅ3 E
,
ÅÅE F
channelMixerG
ÅÅG T
)
ÅÅT U
;
ÅÅU V
material
ÇÇ 
.
ÇÇ 
	SetVector
ÇÇ "
(
ÇÇ" #
ShaderConstants
ÇÇ# 2
.
ÇÇ2 3
_ChannelMixerBlue
ÇÇ3 D
,
ÇÇD E
channelMixerB
ÇÇF S
)
ÇÇS T
;
ÇÇT U
material
ÉÉ 
.
ÉÉ 
	SetVector
ÉÉ "
(
ÉÉ" #
ShaderConstants
ÉÉ# 2
.
ÉÉ2 3

_HueSatCon
ÉÉ3 =
,
ÉÉ= >
	hueSatCon
ÉÉ? H
)
ÉÉH I
;
ÉÉI J
material
ÑÑ 
.
ÑÑ 
	SetVector
ÑÑ "
(
ÑÑ" #
ShaderConstants
ÑÑ# 2
.
ÑÑ2 3
_Lift
ÑÑ3 8
,
ÑÑ8 9
lift
ÑÑ: >
)
ÑÑ> ?
;
ÑÑ? @
material
ÖÖ 
.
ÖÖ 
	SetVector
ÖÖ "
(
ÖÖ" #
ShaderConstants
ÖÖ# 2
.
ÖÖ2 3
_Gamma
ÖÖ3 9
,
ÖÖ9 :
gamma
ÖÖ; @
)
ÖÖ@ A
;
ÖÖA B
material
ÜÜ 
.
ÜÜ 
	SetVector
ÜÜ "
(
ÜÜ" #
ShaderConstants
ÜÜ# 2
.
ÜÜ2 3
_Gain
ÜÜ3 8
,
ÜÜ8 9
gain
ÜÜ: >
)
ÜÜ> ?
;
ÜÜ? @
material
áá 
.
áá 
	SetVector
áá "
(
áá" #
ShaderConstants
áá# 2
.
áá2 3
_Shadows
áá3 ;
,
áá; <
shadows
áá= D
)
ááD E
;
ááE F
material
àà 
.
àà 
	SetVector
àà "
(
àà" #
ShaderConstants
àà# 2
.
àà2 3
	_Midtones
àà3 <
,
àà< =
midtones
àà> F
)
ààF G
;
ààG H
material
ââ 
.
ââ 
	SetVector
ââ "
(
ââ" #
ShaderConstants
ââ# 2
.
ââ2 3
_Highlights
ââ3 >
,
ââ> ?

highlights
ââ@ J
)
ââJ K
;
ââK L
material
ää 
.
ää 
	SetVector
ää "
(
ää" #
ShaderConstants
ää# 2
.
ää2 3
_ShaHiLimits
ää3 ?
,
ää? @%
shadowsHighlightsLimits
ääA X
)
ääX Y
;
ääY Z
material
ãã 
.
ãã 
	SetVector
ãã "
(
ãã" #
ShaderConstants
ãã# 2
.
ãã2 3
_SplitShadows
ãã3 @
,
ãã@ A
splitShadows
ããB N
)
ããN O
;
ããO P
material
åå 
.
åå 
	SetVector
åå "
(
åå" #
ShaderConstants
åå# 2
.
åå2 3
_SplitHighlights
åå3 C
,
ååC D
splitHighlights
ååE T
)
ååT U
;
ååU V
material
èè 
.
èè 

SetTexture
èè #
(
èè# $
ShaderConstants
èè$ 3
.
èè3 4
_CurveMaster
èè4 @
,
èè@ A
curves
èèB H
.
èèH I
master
èèI O
.
èèO P
value
èèP U
.
èèU V

GetTexture
èèV `
(
èè` a
)
èèa b
)
èèb c
;
èèc d
material
êê 
.
êê 

SetTexture
êê #
(
êê# $
ShaderConstants
êê$ 3
.
êê3 4
	_CurveRed
êê4 =
,
êê= >
curves
êê? E
.
êêE F
red
êêF I
.
êêI J
value
êêJ O
.
êêO P

GetTexture
êêP Z
(
êêZ [
)
êê[ \
)
êê\ ]
;
êê] ^
material
ëë 
.
ëë 

SetTexture
ëë #
(
ëë# $
ShaderConstants
ëë$ 3
.
ëë3 4
_CurveGreen
ëë4 ?
,
ëë? @
curves
ëëA G
.
ëëG H
green
ëëH M
.
ëëM N
value
ëëN S
.
ëëS T

GetTexture
ëëT ^
(
ëë^ _
)
ëë_ `
)
ëë` a
;
ëëa b
material
íí 
.
íí 

SetTexture
íí #
(
íí# $
ShaderConstants
íí$ 3
.
íí3 4

_CurveBlue
íí4 >
,
íí> ?
curves
íí@ F
.
ííF G
blue
ííG K
.
ííK L
value
ííL Q
.
ííQ R

GetTexture
ííR \
(
íí\ ]
)
íí] ^
)
íí^ _
;
íí_ `
material
ïï 
.
ïï 

SetTexture
ïï #
(
ïï# $
ShaderConstants
ïï$ 3
.
ïï3 4
_CurveHueVsHue
ïï4 B
,
ïïB C
curves
ïïD J
.
ïïJ K
hueVsHue
ïïK S
.
ïïS T
value
ïïT Y
.
ïïY Z

GetTexture
ïïZ d
(
ïïd e
)
ïïe f
)
ïïf g
;
ïïg h
material
ññ 
.
ññ 

SetTexture
ññ #
(
ññ# $
ShaderConstants
ññ$ 3
.
ññ3 4
_CurveHueVsSat
ññ4 B
,
ññB C
curves
ññD J
.
ññJ K
hueVsSat
ññK S
.
ññS T
value
ññT Y
.
ññY Z

GetTexture
ññZ d
(
ññd e
)
ññe f
)
ññf g
;
ññg h
material
óó 
.
óó 

SetTexture
óó #
(
óó# $
ShaderConstants
óó$ 3
.
óó3 4
_CurveLumVsSat
óó4 B
,
óóB C
curves
óóD J
.
óóJ K
lumVsSat
óóK S
.
óóS T
value
óóT Y
.
óóY Z

GetTexture
óóZ d
(
óód e
)
óóe f
)
óóf g
;
óóg h
material
òò 
.
òò 

SetTexture
òò #
(
òò# $
ShaderConstants
òò$ 3
.
òò3 4
_CurveSatVsSat
òò4 B
,
òòB C
curves
òòD J
.
òòJ K
satVsSat
òòK S
.
òòS T
value
òòT Y
.
òòY Z

GetTexture
òòZ d
(
òòd e
)
òòe f
)
òòf g
;
òòg h
if
õõ 
(
õõ 
hdr
õõ 
)
õõ 
{
úú 
material
ùù 
.
ùù 
shaderKeywords
ùù +
=
ùù, -
null
ùù. 2
;
ùù2 3
switch
üü 
(
üü 
tonemapping
üü '
.
üü' (
mode
üü( ,
.
üü, -
value
üü- 2
)
üü2 3
{
†† 
case
°° 
TonemappingMode
°° ,
.
°°, -
Neutral
°°- 4
:
°°4 5
material
°°6 >
.
°°> ?
EnableKeyword
°°? L
(
°°L M"
ShaderKeywordStrings
°°M a
.
°°a b
TonemapNeutral
°°b p
)
°°p q
;
°°q r
break
°°s x
;
°°x y
case
¢¢ 
TonemappingMode
¢¢ ,
.
¢¢, -
ACES
¢¢- 1
:
¢¢1 2
material
¢¢3 ;
.
¢¢; <
EnableKeyword
¢¢< I
(
¢¢I J"
ShaderKeywordStrings
¢¢J ^
.
¢¢^ _
TonemapACES
¢¢_ j
)
¢¢j k
;
¢¢k l
break
¢¢m r
;
¢¢r s
default
££ 
:
££  
break
££! &
;
££& '
}
§§ 
}
•• 
renderingData
ßß 
.
ßß 

cameraData
ßß (
.
ßß( )
xr
ßß) +
.
ßß+ ,
StopSinglePass
ßß, :
(
ßß: ;
cmd
ßß; >
)
ßß> ?
;
ßß? @
Blit
™™ 
(
™™ 
cmd
™™ 
,
™™ 
m_InternalLut
™™ '
.
™™' (
id
™™( *
,
™™* +
m_InternalLut
™™, 9
.
™™9 :
id
™™: <
,
™™< =
material
™™> F
)
™™F G
;
™™G H
renderingData
¨¨ 
.
¨¨ 

cameraData
¨¨ (
.
¨¨( )
xr
¨¨) +
.
¨¨+ ,
StartSinglePass
¨¨, ;
(
¨¨; <
cmd
¨¨< ?
)
¨¨? @
;
¨¨@ A
}
≠≠ 
context
ØØ 
.
ØØ "
ExecuteCommandBuffer
ØØ (
(
ØØ( )
cmd
ØØ) ,
)
ØØ, -
;
ØØ- .
CommandBufferPool
∞∞ 
.
∞∞ 
Release
∞∞ %
(
∞∞% &
cmd
∞∞& )
)
∞∞) *
;
∞∞* +
}
±± 	
public
¥¥ 
override
¥¥ 
void
¥¥ *
OnFinishCameraStackRendering
¥¥ 9
(
¥¥9 :
CommandBuffer
¥¥: G
cmd
¥¥H K
)
¥¥K L
{
µµ 	
cmd
∂∂ 
.
∂∂  
ReleaseTemporaryRT
∂∂ "
(
∂∂" #
m_InternalLut
∂∂# 0
.
∂∂0 1
id
∂∂1 3
)
∂∂3 4
;
∂∂4 5
}
∑∑ 	
public
ππ 
void
ππ 
Cleanup
ππ 
(
ππ 
)
ππ 
{
∫∫ 	
	CoreUtils
ªª 
.
ªª 
Destroy
ªª 
(
ªª 
m_LutBuilderLdr
ªª -
)
ªª- .
;
ªª. /
	CoreUtils
ºº 
.
ºº 
Destroy
ºº 
(
ºº 
m_LutBuilderHdr
ºº -
)
ºº- .
;
ºº. /
}
ΩΩ 	
static
¿¿ 
class
¿¿ 
ShaderConstants
¿¿ $
{
¡¡ 	
public
¬¬ 
static
¬¬ 
readonly
¬¬ "
int
¬¬# &
_Lut_Params
¬¬' 2
=
¬¬: ;
Shader
¬¬< B
.
¬¬B C
PropertyToID
¬¬C O
(
¬¬O P
$str
¬¬P ]
)
¬¬] ^
;
¬¬^ _
public
√√ 
static
√√ 
readonly
√√ "
int
√√# &
_ColorBalance
√√' 4
=
√√: ;
Shader
√√< B
.
√√B C
PropertyToID
√√C O
(
√√O P
$str
√√P _
)
√√_ `
;
√√` a
public
ƒƒ 
static
ƒƒ 
readonly
ƒƒ "
int
ƒƒ# &
_ColorFilter
ƒƒ' 3
=
ƒƒ: ;
Shader
ƒƒ< B
.
ƒƒB C
PropertyToID
ƒƒC O
(
ƒƒO P
$str
ƒƒP ^
)
ƒƒ^ _
;
ƒƒ_ `
public
≈≈ 
static
≈≈ 
readonly
≈≈ "
int
≈≈# &
_ChannelMixerRed
≈≈' 7
=
≈≈: ;
Shader
≈≈< B
.
≈≈B C
PropertyToID
≈≈C O
(
≈≈O P
$str
≈≈P b
)
≈≈b c
;
≈≈c d
public
∆∆ 
static
∆∆ 
readonly
∆∆ "
int
∆∆# & 
_ChannelMixerGreen
∆∆' 9
=
∆∆: ;
Shader
∆∆< B
.
∆∆B C
PropertyToID
∆∆C O
(
∆∆O P
$str
∆∆P d
)
∆∆d e
;
∆∆e f
public
«« 
static
«« 
readonly
«« "
int
««# &
_ChannelMixerBlue
««' 8
=
««: ;
Shader
««< B
.
««B C
PropertyToID
««C O
(
««O P
$str
««P c
)
««c d
;
««d e
public
»» 
static
»» 
readonly
»» "
int
»»# &

_HueSatCon
»»' 1
=
»»: ;
Shader
»»< B
.
»»B C
PropertyToID
»»C O
(
»»O P
$str
»»P \
)
»»\ ]
;
»»] ^
public
…… 
static
…… 
readonly
…… "
int
……# &
_Lift
……' ,
=
……: ;
Shader
……< B
.
……B C
PropertyToID
……C O
(
……O P
$str
……P W
)
……W X
;
……X Y
public
   
static
   
readonly
   "
int
  # &
_Gamma
  ' -
=
  : ;
Shader
  < B
.
  B C
PropertyToID
  C O
(
  O P
$str
  P X
)
  X Y
;
  Y Z
public
ÀÀ 
static
ÀÀ 
readonly
ÀÀ "
int
ÀÀ# &
_Gain
ÀÀ' ,
=
ÀÀ: ;
Shader
ÀÀ< B
.
ÀÀB C
PropertyToID
ÀÀC O
(
ÀÀO P
$str
ÀÀP W
)
ÀÀW X
;
ÀÀX Y
public
ÃÃ 
static
ÃÃ 
readonly
ÃÃ "
int
ÃÃ# &
_Shadows
ÃÃ' /
=
ÃÃ: ;
Shader
ÃÃ< B
.
ÃÃB C
PropertyToID
ÃÃC O
(
ÃÃO P
$str
ÃÃP Z
)
ÃÃZ [
;
ÃÃ[ \
public
ÕÕ 
static
ÕÕ 
readonly
ÕÕ "
int
ÕÕ# &
	_Midtones
ÕÕ' 0
=
ÕÕ: ;
Shader
ÕÕ< B
.
ÕÕB C
PropertyToID
ÕÕC O
(
ÕÕO P
$str
ÕÕP [
)
ÕÕ[ \
;
ÕÕ\ ]
public
ŒŒ 
static
ŒŒ 
readonly
ŒŒ "
int
ŒŒ# &
_Highlights
ŒŒ' 2
=
ŒŒ: ;
Shader
ŒŒ< B
.
ŒŒB C
PropertyToID
ŒŒC O
(
ŒŒO P
$str
ŒŒP ]
)
ŒŒ] ^
;
ŒŒ^ _
public
œœ 
static
œœ 
readonly
œœ "
int
œœ# &
_ShaHiLimits
œœ' 3
=
œœ: ;
Shader
œœ< B
.
œœB C
PropertyToID
œœC O
(
œœO P
$str
œœP ^
)
œœ^ _
;
œœ_ `
public
–– 
static
–– 
readonly
–– "
int
––# &
_SplitShadows
––' 4
=
––: ;
Shader
––< B
.
––B C
PropertyToID
––C O
(
––O P
$str
––P _
)
––_ `
;
––` a
public
—— 
static
—— 
readonly
—— "
int
——# &
_SplitHighlights
——' 7
=
——: ;
Shader
——< B
.
——B C
PropertyToID
——C O
(
——O P
$str
——P b
)
——b c
;
——c d
public
““ 
static
““ 
readonly
““ "
int
““# &
_CurveMaster
““' 3
=
““: ;
Shader
““< B
.
““B C
PropertyToID
““C O
(
““O P
$str
““P ^
)
““^ _
;
““_ `
public
”” 
static
”” 
readonly
”” "
int
””# &
	_CurveRed
””' 0
=
””: ;
Shader
””< B
.
””B C
PropertyToID
””C O
(
””O P
$str
””P [
)
””[ \
;
””\ ]
public
‘‘ 
static
‘‘ 
readonly
‘‘ "
int
‘‘# &
_CurveGreen
‘‘' 2
=
‘‘: ;
Shader
‘‘< B
.
‘‘B C
PropertyToID
‘‘C O
(
‘‘O P
$str
‘‘P ]
)
‘‘] ^
;
‘‘^ _
public
’’ 
static
’’ 
readonly
’’ "
int
’’# &

_CurveBlue
’’' 1
=
’’: ;
Shader
’’< B
.
’’B C
PropertyToID
’’C O
(
’’O P
$str
’’P \
)
’’\ ]
;
’’] ^
public
÷÷ 
static
÷÷ 
readonly
÷÷ "
int
÷÷# &
_CurveHueVsHue
÷÷' 5
=
÷÷: ;
Shader
÷÷< B
.
÷÷B C
PropertyToID
÷÷C O
(
÷÷O P
$str
÷÷P `
)
÷÷` a
;
÷÷a b
public
◊◊ 
static
◊◊ 
readonly
◊◊ "
int
◊◊# &
_CurveHueVsSat
◊◊' 5
=
◊◊: ;
Shader
◊◊< B
.
◊◊B C
PropertyToID
◊◊C O
(
◊◊O P
$str
◊◊P `
)
◊◊` a
;
◊◊a b
public
ÿÿ 
static
ÿÿ 
readonly
ÿÿ "
int
ÿÿ# &
_CurveLumVsSat
ÿÿ' 5
=
ÿÿ: ;
Shader
ÿÿ< B
.
ÿÿB C
PropertyToID
ÿÿC O
(
ÿÿO P
$str
ÿÿP `
)
ÿÿ` a
;
ÿÿa b
public
ŸŸ 
static
ŸŸ 
readonly
ŸŸ "
int
ŸŸ# &
_CurveSatVsSat
ŸŸ' 5
=
ŸŸ: ;
Shader
ŸŸ< B
.
ŸŸB C
PropertyToID
ŸŸC O
(
ŸŸO P
$str
ŸŸP `
)
ŸŸ` a
;
ŸŸa b
}
⁄⁄ 	
}
€€ 
}‹‹ ∫
ßD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\XROcclusionMeshPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
public 

class 
XROcclusionMeshPass $
:% & 
ScriptableRenderPass' ;
{		 
public

 
XROcclusionMeshPass

 "
(

" #
RenderPassEvent

# 2
evt

3 6
)

6 7
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @
XROcclusionMeshPass@ S
)S T
)T U
;U V
renderPassEvent 
= 
evt !
;! "
} 	
public 
override 
void 
Execute $
($ %#
ScriptableRenderContext% <
context= D
,D E
refF I
RenderingDataJ W
renderingDataX e
)e f
{ 	
if 
( 
! 
renderingData 
. 

cameraData )
.) *
xr* ,
., -
enabled- 4
)4 5
return 
; 
CommandBuffer 
cmd 
= 
CommandBufferPool  1
.1 2
Get2 5
(5 6
)6 7
;7 8
renderingData 
. 

cameraData $
.$ %
xr% '
.' (
RenderOcclusionMesh( ;
(; <
cmd< ?
)? @
;@ A
context 
.  
ExecuteCommandBuffer (
(( )
cmd) ,
), -
;- .
CommandBufferPool 
. 
Release %
(% &
cmd& )
)) *
;* +
} 	
} 
} å8
¢D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\ColorCurves.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' E
)E F
]F G
public 

sealed 
class 
ColorCurves #
:$ %
VolumeComponent& 5
,5 6!
IPostProcessComponent7 L
{ 
public !
TextureCurveParameter $
master% +
=, -
new. 1!
TextureCurveParameter2 G
(G H
newH K
TextureCurveL X
(X Y
newY \
[\ ]
]] ^
{_ `
newa d
Keyframee m
(m n
$numn p
,p q
$numr t
,t u
$numv x
,x y
$numz |
)| }
,} ~
new	 Ç
Keyframe
É ã
(
ã å
$num
å é
,
é è
$num
ê í
,
í ì
$num
î ñ
,
ñ ó
$num
ò ö
)
ö õ
}
ú ù
,
ù û
$num
ü °
,
° ¢
false
£ ®
,
® ©
new
™ ≠
Vector2
Æ µ
(
µ ∂
$num
∂ ∏
,
∏ π
$num
∫ º
)
º Ω
)
Ω æ
)
æ ø
;
ø ¿
public		 !
TextureCurveParameter		 $
red		% (
=		) *
new		+ .!
TextureCurveParameter		/ D
(		D E
new		E H
TextureCurve		I U
(		U V
new		V Y
[		Y Z
]		Z [
{		\ ]
new		^ a
Keyframe		b j
(		j k
$num		k m
,		m n
$num		o q
,		q r
$num		s u
,		u v
$num		w y
)		y z
,		z {
new		| 
Keyframe
		Ä à
(
		à â
$num
		â ã
,
		ã å
$num
		ç è
,
		è ê
$num
		ë ì
,
		ì î
$num
		ï ó
)
		ó ò
}
		ô ö
,
		ö õ
$num
		ú û
,
		û ü
false
		† •
,
		• ¶
new
		ß ™
Vector2
		´ ≤
(
		≤ ≥
$num
		≥ µ
,
		µ ∂
$num
		∑ π
)
		π ∫
)
		∫ ª
)
		ª º
;
		º Ω
public

 !
TextureCurveParameter

 $
green

% *
=

+ ,
new

- 0!
TextureCurveParameter

1 F
(

F G
new

G J
TextureCurve

K W
(

W X
new

X [
[

[ \
]

\ ]
{

^ _
new

` c
Keyframe

d l
(

l m
$num

m o
,

o p
$num

q s
,

s t
$num

u w
,

w x
$num

y {
)

{ |
,

| }
new	

~ Å
Keyframe


Ç ä
(


ä ã
$num


ã ç
,


ç é
$num


è ë
,


ë í
$num


ì ï
,


ï ñ
$num


ó ô
)


ô ö
}


õ ú
,


ú ù
$num


û †
,


† °
false


¢ ß
,


ß ®
new


© ¨
Vector2


≠ ¥
(


¥ µ
$num


µ ∑
,


∑ ∏
$num


π ª
)


ª º
)


º Ω
)


Ω æ
;


æ ø
public !
TextureCurveParameter $
blue% )
=* +
new, /!
TextureCurveParameter0 E
(E F
newF I
TextureCurveJ V
(V W
newW Z
[Z [
][ \
{] ^
new_ b
Keyframec k
(k l
$numl n
,n o
$nump r
,r s
$numt v
,v w
$numx z
)z {
,{ |
new	} Ä
Keyframe
Å â
(
â ä
$num
ä å
,
å ç
$num
é ê
,
ê ë
$num
í î
,
î ï
$num
ñ ò
)
ò ô
}
ö õ
,
õ ú
$num
ù ü
,
ü †
false
° ¶
,
¶ ß
new
® ´
Vector2
¨ ≥
(
≥ ¥
$num
¥ ∂
,
∂ ∑
$num
∏ ∫
)
∫ ª
)
ª º
)
º Ω
;
Ω æ
public !
TextureCurveParameter $
hueVsHue% -
=. /
new0 3!
TextureCurveParameter4 I
(I J
newJ M
TextureCurveN Z
(Z [
new[ ^
Keyframe_ g
[g h
]h i
{j k
}l m
,m n
$numo s
,s t
trueu y
,y z
new{ ~
Vector2	 Ü
(
Ü á
$num
á â
,
â ä
$num
ã ç
)
ç é
)
é è
)
è ê
;
ê ë
public !
TextureCurveParameter $
hueVsSat% -
=. /
new0 3!
TextureCurveParameter4 I
(I J
newJ M
TextureCurveN Z
(Z [
new[ ^
Keyframe_ g
[g h
]h i
{j k
}l m
,m n
$numo s
,s t
trueu y
,y z
new{ ~
Vector2	 Ü
(
Ü á
$num
á â
,
â ä
$num
ã ç
)
ç é
)
é è
)
è ê
;
ê ë
public !
TextureCurveParameter $
satVsSat% -
=. /
new0 3!
TextureCurveParameter4 I
(I J
newJ M
TextureCurveN Z
(Z [
new[ ^
Keyframe_ g
[g h
]h i
{j k
}l m
,m n
$numo s
,s t
falseu z
,z {
new| 
Vector2
Ä á
(
á à
$num
à ä
,
ä ã
$num
å é
)
é è
)
è ê
)
ê ë
;
ë í
public !
TextureCurveParameter $
lumVsSat% -
=. /
new0 3!
TextureCurveParameter4 I
(I J
newJ M
TextureCurveN Z
(Z [
new[ ^
Keyframe_ g
[g h
]h i
{j k
}l m
,m n
$numo s
,s t
falseu z
,z {
new| 
Vector2
Ä á
(
á à
$num
à ä
,
ä ã
$num
å é
)
é è
)
è ê
)
ê ë
;
ë í
public 
bool 
IsActive 
( 
) 
=> !
true" &
;& '
public 
bool 
IsTileCompatible $
($ %
)% &
=>' )
true* .
;. /
} 
} ñç
±D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\External\LibTessDotNet\PriorityQueue.cs
	namespace&& 	
UnityEngine&&
 
.&& 
Experimental&& "
.&&" #
	Rendering&&# ,
.&&, -
	Universal&&- 6
{'' 
	namespace)) 	
LibTessDotNet))
 
{** 
internal++ 
class++ 
PriorityQueue++  
<++  !
TValue++! '
>++' (
where++) .
TValue++/ 5
:++6 7
class++8 =
{,, 
private-- 
PriorityHeap-- 
<-- 
TValue-- #
>--# $
.--$ %
LessOrEqual--% 0
_leq--1 5
;--5 6
private.. 
PriorityHeap.. 
<.. 
TValue.. #
>..# $
_heap..% *
;..* +
private// 
TValue// 
[// 
]// 
_keys// 
;// 
private00 
int00 
[00 
]00 
_order00 
;00 
private22 
int22 
_size22 
,22 
_max22 
;22  
private33 
bool33 
_initialized33 !
;33! "
public55 
bool55 
Empty55 
{55 
get55 
{55  !
return55" (
_size55) .
==55/ 1
$num552 3
&&554 6
_heap557 <
.55< =
Empty55= B
;55B C
}55D E
}55F G
public77 
PriorityQueue77 
(77 
int77  
initialSize77! ,
,77, -
PriorityHeap77. :
<77: ;
TValue77; A
>77A B
.77B C
LessOrEqual77C N
leq77O R
)77R S
{88 	
_leq99 
=99 
leq99 
;99 
_heap:: 
=:: 
new:: 
PriorityHeap:: $
<::$ %
TValue::% +
>::+ ,
(::, -
initialSize::- 8
,::8 9
leq::: =
)::= >
;::> ?
_keys<< 
=<< 
new<< 
TValue<< 
[<< 
initialSize<< *
]<<* +
;<<+ ,
_size>> 
=>> 
$num>> 
;>> 
_max?? 
=?? 
initialSize?? 
;?? 
_initialized@@ 
=@@ 
false@@  
;@@  !
}AA 	
classCC 
	StackItemCC 
{DD 	
internalEE 
intEE 
pEE 
,EE 
rEE 
;EE 
}FF 	
;FF	 

staticHH 
voidHH 
SwapHH 
(HH 
refHH 
intHH  
aHH! "
,HH" #
refHH$ '
intHH( +
bHH, -
)HH- .
{II 	
intJJ 
tmpJJ 
=JJ 
aJJ 
;JJ 
aKK 
=KK 
bKK 
;KK 
bLL 
=LL 
tmpLL 
;LL 
}MM 	
publicOO 
voidOO 
InitOO 
(OO 
)OO 
{PP 	
varQQ 
stackQQ 
=QQ 
newQQ 
StackQQ !
<QQ! "
	StackItemQQ" +
>QQ+ ,
(QQ, -
)QQ- .
;QQ. /
intRR 
pRR 
,RR 
rRR 
,RR 
iRR 
,RR 
jRR 
,RR 
pivRR 
;RR  
uintSS 
seedSS 
=SS 
$numSS "
;SS" #
pUU 
=UU 
$numUU 
;UU 
rVV 
=VV 
_sizeVV 
-VV 
$numVV 
;VV 
_orderWW 
=WW 
newWW 
intWW 
[WW 
_sizeWW "
+WW# $
$numWW% &
]WW& '
;WW' (
forXX 
(XX 
pivXX 
=XX 
$numXX 
,XX 
iXX 
=XX 
pXX 
;XX  
iXX! "
<=XX# %
rXX& '
;XX' (
++XX) +
pivXX+ .
,XX. /
++XX0 2
iXX2 3
)XX3 4
{YY 
_orderZZ 
[ZZ 
iZZ 
]ZZ 
=ZZ 
pivZZ 
;ZZ  
}[[ 
stack]] 
.]] 
Push]] 
(]] 
new]] 
	StackItem]] $
{]]% &
p]]' (
=]]) *
p]]+ ,
,]], -
r]]. /
=]]0 1
r]]2 3
}]]4 5
)]]5 6
;]]6 7
while^^ 
(^^ 
stack^^ 
.^^ 
Count^^ 
>^^  
$num^^! "
)^^" #
{__ 
var`` 
top`` 
=`` 
stack`` 
.``  
Pop``  #
(``# $
)``$ %
;``% &
paa 
=aa 
topaa 
.aa 
paa 
;aa 
rbb 
=bb 
topbb 
.bb 
rbb 
;bb 
whiledd 
(dd 
rdd 
>dd 
pdd 
+dd 
$numdd !
)dd! "
{ee 
seedff 
=ff 
seedff 
*ff  !
$numff" ,
+ff- .
$numff/ 0
;ff0 1
igg 
=gg 
pgg 
+gg 
(gg 
intgg  
)gg  !
(gg! "
seedgg" &
%gg' (
(gg) *
rgg* +
-gg, -
pgg. /
+gg0 1
$numgg2 3
)gg3 4
)gg4 5
;gg5 6
pivhh 
=hh 
_orderhh  
[hh  !
ihh! "
]hh" #
;hh# $
_orderii 
[ii 
iii 
]ii 
=ii 
_orderii  &
[ii& '
pii' (
]ii( )
;ii) *
_orderjj 
[jj 
pjj 
]jj 
=jj 
pivjj  #
;jj# $
ikk 
=kk 
pkk 
-kk 
$numkk 
;kk 
jll 
=ll 
rll 
+ll 
$numll 
;ll 
domm 
{mm 
donn 
{nn 
++nn 
inn  
;nn  !
}nn" #
whilenn$ )
(nn* +
!nn+ ,
_leqnn, 0
(nn0 1
_keysnn1 6
[nn6 7
_ordernn7 =
[nn= >
inn> ?
]nn? @
]nn@ A
,nnA B
_keysnnC H
[nnH I
pivnnI L
]nnL M
)nnM N
)nnN O
;nnO P
dooo 
{oo 
--oo 
joo  
;oo  !
}oo" #
whileoo$ )
(oo* +
!oo+ ,
_leqoo, 0
(oo0 1
_keysoo1 6
[oo6 7
pivoo7 :
]oo: ;
,oo; <
_keysoo= B
[ooB C
_orderooC I
[ooI J
jooJ K
]ooK L
]ooL M
)ooM N
)ooN O
;ooO P
Swappp 
(pp 
refpp  
_orderpp! '
[pp' (
ipp( )
]pp) *
,pp* +
refpp, /
_orderpp0 6
[pp6 7
jpp7 8
]pp8 9
)pp9 :
;pp: ;
}qq 
whileqq 
(qq 
iqq 
<qq  
jqq! "
)qq" #
;qq# $
Swaprr 
(rr 
refrr 
_orderrr #
[rr# $
irr$ %
]rr% &
,rr& '
refrr( +
_orderrr, 2
[rr2 3
jrr3 4
]rr4 5
)rr5 6
;rr6 7
ifss 
(ss 
iss 
-ss 
pss 
<ss 
rss  !
-ss" #
jss$ %
)ss% &
{tt 
stackuu 
.uu 
Pushuu "
(uu" #
newuu# &
	StackItemuu' 0
{uu1 2
puu3 4
=uu5 6
juu7 8
+uu9 :
$numuu; <
,uu< =
ruu> ?
=uu@ A
ruuB C
}uuD E
)uuE F
;uuF G
rvv 
=vv 
ivv 
-vv 
$numvv  !
;vv! "
}ww 
elsexx 
{yy 
stackzz 
.zz 
Pushzz "
(zz" #
newzz# &
	StackItemzz' 0
{zz1 2
pzz3 4
=zz5 6
pzz7 8
,zz8 9
rzz: ;
=zz< =
izz> ?
-zz@ A
$numzzB C
}zzD E
)zzE F
;zzF G
p{{ 
={{ 
j{{ 
+{{ 
$num{{  !
;{{! "
}|| 
}}} 
for~~ 
(~~ 
i~~ 
=~~ 
p~~ 
+~~ 
$num~~ 
;~~ 
i~~  !
<=~~" $
r~~% &
;~~& '
++~~( *
i~~* +
)~~+ ,
{ 
piv
ÄÄ 
=
ÄÄ 
_order
ÄÄ  
[
ÄÄ  !
i
ÄÄ! "
]
ÄÄ" #
;
ÄÄ# $
for
ÅÅ 
(
ÅÅ 
j
ÅÅ 
=
ÅÅ 
i
ÅÅ 
;
ÅÅ 
j
ÅÅ  !
>
ÅÅ" #
p
ÅÅ$ %
&&
ÅÅ& (
!
ÅÅ) *
_leq
ÅÅ* .
(
ÅÅ. /
_keys
ÅÅ/ 4
[
ÅÅ4 5
piv
ÅÅ5 8
]
ÅÅ8 9
,
ÅÅ9 :
_keys
ÅÅ; @
[
ÅÅ@ A
_order
ÅÅA G
[
ÅÅG H
j
ÅÅH I
-
ÅÅJ K
$num
ÅÅL M
]
ÅÅM N
]
ÅÅN O
)
ÅÅO P
;
ÅÅP Q
--
ÅÅR T
j
ÅÅT U
)
ÅÅU V
{
ÇÇ 
_order
ÉÉ 
[
ÉÉ 
j
ÉÉ  
]
ÉÉ  !
=
ÉÉ" #
_order
ÉÉ$ *
[
ÉÉ* +
j
ÉÉ+ ,
-
ÉÉ- .
$num
ÉÉ/ 0
]
ÉÉ0 1
;
ÉÉ1 2
}
ÑÑ 
_order
ÖÖ 
[
ÖÖ 
j
ÖÖ 
]
ÖÖ 
=
ÖÖ 
piv
ÖÖ  #
;
ÖÖ# $
}
ÜÜ 
}
áá 
p
ää 
=
ää 
$num
ää 
;
ää 
r
ãã 
=
ãã 
_size
ãã 
-
ãã 
$num
ãã 
;
ãã 
for
åå 
(
åå 
i
åå 
=
åå 
p
åå 
;
åå 
i
åå 
<
åå 
r
åå 
;
åå 
++
åå !
i
åå! "
)
åå" #
{
çç 
Debug
éé 
.
éé 
Assert
éé 
(
éé 
_leq
éé !
(
éé! "
_keys
éé" '
[
éé' (
_order
éé( .
[
éé. /
i
éé/ 0
+
éé1 2
$num
éé3 4
]
éé4 5
]
éé5 6
,
éé6 7
_keys
éé8 =
[
éé= >
_order
éé> D
[
ééD E
i
ééE F
]
ééF G
]
ééG H
)
ééH I
,
ééI J
$str
ééK W
)
ééW X
;
ééX Y
}
èè 
_max
íí 
=
íí 
_size
íí 
;
íí 
_initialized
ìì 
=
ìì 
true
ìì 
;
ìì  
_heap
îî 
.
îî 
Init
îî 
(
îî 
)
îî 
;
îî 
}
ïï 	
public
óó 
PQHandle
óó 
Insert
óó 
(
óó 
TValue
óó %
value
óó& +
)
óó+ ,
{
òò 	
if
ôô 
(
ôô 
_initialized
ôô 
)
ôô 
{
öö 
return
õõ 
_heap
õõ 
.
õõ 
Insert
õõ #
(
õõ# $
value
õõ$ )
)
õõ) *
;
õõ* +
}
úú 
int
ûû 
curr
ûû 
=
ûû 
_size
ûû 
;
ûû 
if
üü 
(
üü 
++
üü 
_size
üü 
>=
üü 
_max
üü 
)
üü  
{
†† 
_max
°° 
<<=
°° 
$num
°° 
;
°° 
Array
¢¢ 
.
¢¢ 
Resize
¢¢ 
(
¢¢ 
ref
¢¢  
_keys
¢¢! &
,
¢¢& '
_max
¢¢( ,
)
¢¢, -
;
¢¢- .
}
££ 
_keys
•• 
[
•• 
curr
•• 
]
•• 
=
•• 
value
•• 
;
••  
return
¶¶ 
new
¶¶ 
PQHandle
¶¶ 
{
¶¶  !
_handle
¶¶" )
=
¶¶* +
-
¶¶, -
(
¶¶- .
curr
¶¶. 2
+
¶¶3 4
$num
¶¶5 6
)
¶¶6 7
}
¶¶8 9
;
¶¶9 :
}
ßß 	
public
©© 
TValue
©© 

ExtractMin
©©  
(
©©  !
)
©©! "
{
™™ 	
Debug
´´ 
.
´´ 
Assert
´´ 
(
´´ 
_initialized
´´ %
)
´´% &
;
´´& '
if
≠≠ 
(
≠≠ 
_size
≠≠ 
==
≠≠ 
$num
≠≠ 
)
≠≠ 
{
ÆÆ 
return
ØØ 
_heap
ØØ 
.
ØØ 

ExtractMin
ØØ '
(
ØØ' (
)
ØØ( )
;
ØØ) *
}
∞∞ 
TValue
±± 
sortMin
±± 
=
±± 
_keys
±± "
[
±±" #
_order
±±# )
[
±±) *
_size
±±* /
-
±±0 1
$num
±±2 3
]
±±3 4
]
±±4 5
;
±±5 6
if
≤≤ 
(
≤≤ 
!
≤≤ 
_heap
≤≤ 
.
≤≤ 
Empty
≤≤ 
)
≤≤ 
{
≥≥ 
TValue
¥¥ 
heapMin
¥¥ 
=
¥¥  
_heap
¥¥! &
.
¥¥& '
Minimum
¥¥' .
(
¥¥. /
)
¥¥/ 0
;
¥¥0 1
if
µµ 
(
µµ 
_leq
µµ 
(
µµ 
heapMin
µµ  
,
µµ  !
sortMin
µµ" )
)
µµ) *
)
µµ* +
return
∂∂ 
_heap
∂∂  
.
∂∂  !

ExtractMin
∂∂! +
(
∂∂+ ,
)
∂∂, -
;
∂∂- .
}
∑∑ 
do
∏∏ 
{
∏∏ 
--
ππ 
_size
ππ 
;
ππ 
}
∫∫ 
while
∫∫ 
(
∫∫ 
_size
∫∫ 
>
∫∫ 
$num
∫∫ 
&&
∫∫ !
_keys
∫∫" '
[
∫∫' (
_order
∫∫( .
[
∫∫. /
_size
∫∫/ 4
-
∫∫5 6
$num
∫∫7 8
]
∫∫8 9
]
∫∫9 :
==
∫∫; =
null
∫∫> B
)
∫∫B C
;
∫∫C D
return
ºº 
sortMin
ºº 
;
ºº 
}
ΩΩ 	
public
øø 
TValue
øø 
Minimum
øø 
(
øø 
)
øø 
{
¿¿ 	
Debug
¡¡ 
.
¡¡ 
Assert
¡¡ 
(
¡¡ 
_initialized
¡¡ %
)
¡¡% &
;
¡¡& '
if
√√ 
(
√√ 
_size
√√ 
==
√√ 
$num
√√ 
)
√√ 
{
ƒƒ 
return
≈≈ 
_heap
≈≈ 
.
≈≈ 
Minimum
≈≈ $
(
≈≈$ %
)
≈≈% &
;
≈≈& '
}
∆∆ 
TValue
«« 
sortMin
«« 
=
«« 
_keys
«« "
[
««" #
_order
««# )
[
««) *
_size
««* /
-
««0 1
$num
««2 3
]
««3 4
]
««4 5
;
««5 6
if
»» 
(
»» 
!
»» 
_heap
»» 
.
»» 
Empty
»» 
)
»» 
{
…… 
TValue
   
heapMin
   
=
    
_heap
  ! &
.
  & '
Minimum
  ' .
(
  . /
)
  / 0
;
  0 1
if
ÀÀ 
(
ÀÀ 
_leq
ÀÀ 
(
ÀÀ 
heapMin
ÀÀ  
,
ÀÀ  !
sortMin
ÀÀ" )
)
ÀÀ) *
)
ÀÀ* +
return
ÃÃ 
heapMin
ÃÃ "
;
ÃÃ" #
}
ÕÕ 
return
ŒŒ 
sortMin
ŒŒ 
;
ŒŒ 
}
œœ 	
public
—— 
void
—— 
Remove
—— 
(
—— 
PQHandle
—— #
handle
——$ *
)
——* +
{
““ 	
Debug
”” 
.
”” 
Assert
”” 
(
”” 
_initialized
”” %
)
””% &
;
””& '
int
’’ 
curr
’’ 
=
’’ 
handle
’’ 
.
’’ 
_handle
’’ %
;
’’% &
if
÷÷ 
(
÷÷ 
curr
÷÷ 
>=
÷÷ 
$num
÷÷ 
)
÷÷ 
{
◊◊ 
_heap
ÿÿ 
.
ÿÿ 
Remove
ÿÿ 
(
ÿÿ 
handle
ÿÿ #
)
ÿÿ# $
;
ÿÿ$ %
return
ŸŸ 
;
ŸŸ 
}
⁄⁄ 
curr
€€ 
=
€€ 
-
€€ 
(
€€ 
curr
€€ 
+
€€ 
$num
€€ 
)
€€ 
;
€€ 
Debug
‹‹ 
.
‹‹ 
Assert
‹‹ 
(
‹‹ 
curr
‹‹ 
<
‹‹ 
_max
‹‹  $
&&
‹‹% '
_keys
‹‹( -
[
‹‹- .
curr
‹‹. 2
]
‹‹2 3
!=
‹‹4 6
null
‹‹7 ;
)
‹‹; <
;
‹‹< =
_keys
ﬁﬁ 
[
ﬁﬁ 
curr
ﬁﬁ 
]
ﬁﬁ 
=
ﬁﬁ 
null
ﬁﬁ 
;
ﬁﬁ 
while
ﬂﬂ 
(
ﬂﬂ 
_size
ﬂﬂ 
>
ﬂﬂ 
$num
ﬂﬂ 
&&
ﬂﬂ 
_keys
ﬂﬂ  %
[
ﬂﬂ% &
_order
ﬂﬂ& ,
[
ﬂﬂ, -
_size
ﬂﬂ- 2
-
ﬂﬂ3 4
$num
ﬂﬂ5 6
]
ﬂﬂ6 7
]
ﬂﬂ7 8
==
ﬂﬂ9 ;
null
ﬂﬂ< @
)
ﬂﬂ@ A
{
‡‡ 
--
·· 
_size
·· 
;
·· 
}
‚‚ 
}
„„ 	
}
‰‰ 
}ÂÂ 
}ÁÁ Ã
üD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\CapturePass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
internal		 
class		 
CapturePass		 
:		   
ScriptableRenderPass		! 5
{

 
RenderTargetHandle 
m_CameraColorHandle .
;. /
const 
string 
m_ProfilerTag "
=# $
$str% 3
;3 4
private 
static 
readonly 
ProfilingSampler  0
m_ProfilingSampler1 C
=D E
newF I
ProfilingSamplerJ Z
(Z [
m_ProfilerTag[ h
)h i
;i j
public 
CapturePass 
( 
RenderPassEvent *
evt+ .
). /
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @
CapturePass@ K
)K L
)L M
;M N
renderPassEvent 
= 
evt !
;! "
} 	
public 
void 
Setup 
( 
RenderTargetHandle ,
colorHandle- 8
)8 9
{ 	
m_CameraColorHandle 
=  !
colorHandle" -
;- .
} 	
public 
override 
void 
Execute $
($ %#
ScriptableRenderContext% <
context= D
,D E
refF I
RenderingDataJ W
renderingDataX e
)e f
{ 	
CommandBuffer   
cmdBuf    
=  ! "
CommandBufferPool  # 4
.  4 5
Get  5 8
(  8 9
)  9 :
;  : ;
using!! 
(!! 
new!! 
ProfilingScope!! %
(!!% &
cmdBuf!!& ,
,!!, -
m_ProfilingSampler!!. @
)!!@ A
)!!A B
{"" 
var## %
colorAttachmentIdentifier## -
=##. /
m_CameraColorHandle##0 C
.##C D

Identifier##D N
(##N O
)##O P
;##P Q
var$$ 
captureActions$$ "
=$$# $
renderingData$$% 2
.$$2 3

cameraData$$3 =
.$$= >
captureActions$$> L
;$$L M
for%% 
(%% 
captureActions%% #
.%%# $
Reset%%$ )
(%%) *
)%%* +
;%%+ ,
captureActions%%- ;
.%%; <
MoveNext%%< D
(%%D E
)%%E F
;%%F G
)%%G H
captureActions&& "
.&&" #
Current&&# *
(&&* +%
colorAttachmentIdentifier&&+ D
,&&D E
cmdBuf&&F L
)&&L M
;&&M N
}'' 
context)) 
.))  
ExecuteCommandBuffer)) (
())( )
cmdBuf))) /
)))/ 0
;))0 1
CommandBufferPool** 
.** 
Release** %
(**% &
cmdBuf**& ,
)**, -
;**- .
}++ 	
},, 
}-- ïõ
ØD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Passes\Utility\RendererLighting.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
internal 
static 
class 
RendererLighting *
{ 
private		 
static		 
readonly		 
ProfilingSampler		  0
m_ProfilingSampler		1 C
=		D E
new		F I
ProfilingSampler		J Z
(		Z [
$str		[ j
)		j k
;		k l
private

 
static

 
readonly

 
ShaderTagId

  +&
k_NormalsRenderingPassName

, F
=

G H
new

I L
ShaderTagId

M X
(

X Y
$str

Y k
)

k l
;

l m
private 
static 
readonly 
Color  %
k_NormalClearColor& 8
=9 :
new; >
Color? D
(D E
$numE I
,I J
$numK O
,O P
$numQ U
,U V
$numW [
)[ \
;\ ]
private 
static 
readonly 
string  & 
k_SpriteLightKeyword' ;
=< =
$str> L
;L M
private 
static 
readonly 
string  &)
k_UsePointLightCookiesKeyword' D
=E F
$strG `
;` a
private 
static 
readonly 
string  &%
k_LightQualityFastKeyword' @
=A B
$strC W
;W X
private 
static 
readonly 
string  &
k_UseNormalMap' 5
=6 7
$str8 H
;H I
private 
static 
readonly 
string  &(
k_UseAdditiveBlendingKeyword' C
=D E
$strF ]
;] ^
private 
static 
readonly 
string  &
[& '
]' (#
k_UseBlendStyleKeywords) @
=A B
{ 	
$str $
,$ %
$str& >
,> ?
$str@ X
,X Y
$strZ r
} 	
;	 

private 
static 
readonly 
int  #
[# $
]$ %!
k_BlendFactorsPropIDs& ;
=< =
{ 	
Shader 
. 
PropertyToID 
(  
$str  :
): ;
,; <
Shader 
. 
PropertyToID 
(  
$str  :
): ;
,; <
Shader 
. 
PropertyToID 
(  
$str  :
): ;
,; <
Shader 
. 
PropertyToID 
(  
$str  :
): ;
} 	
;	 

private 
static 
readonly 
int  #
[# $
]$ %
k_MaskFilterPropIDs& 9
=: ;
{   	
Shader!! 
.!! 
PropertyToID!! 
(!!  
$str!!  8
)!!8 9
,!!9 :
Shader"" 
."" 
PropertyToID"" 
(""  
$str""  8
)""8 9
,""9 :
Shader## 
.## 
PropertyToID## 
(##  
$str##  8
)##8 9
,##9 :
Shader$$ 
.$$ 
PropertyToID$$ 
($$  
$str$$  8
)$$8 9
}%% 	
;%%	 

private'' 
static'' 
readonly'' 
int''  #
[''# $
]''$ %#
k_InvertedFilterPropIDs''& =
=''> ?
{(( 	
Shader)) 
.)) 
PropertyToID)) 
())  
$str))  <
)))< =
,))= >
Shader** 
.** 
PropertyToID** 
(**  
$str**  <
)**< =
,**= >
Shader++ 
.++ 
PropertyToID++ 
(++  
$str++  <
)++< =
,++= >
Shader,, 
.,, 
PropertyToID,, 
(,,  
$str,,  <
),,< =
}-- 	
;--	 

private// 
static// 
GraphicsFormat// %&
s_RenderTextureFormatToUse//& @
=//A B
GraphicsFormat//C Q
.//Q R
R8G8B8A8_UNorm//R `
;//` a
private00 
static00 
bool00 .
"s_HasSetupRenderTextureFormatToUse00 >
;00> ?
private22 
static22 
readonly22 
int22  #
k_SrcBlendID22$ 0
=221 2
Shader223 9
.229 :
PropertyToID22: F
(22F G
$str22G R
)22R S
;22S T
private33 
static33 
readonly33 
int33  #
k_DstBlendID33$ 0
=331 2
Shader333 9
.339 :
PropertyToID33: F
(33F G
$str33G R
)33R S
;33S T
private44 
static44 
readonly44 
int44  # 
k_FalloffIntensityID44$ 8
=449 :
Shader44; A
.44A B
PropertyToID44B N
(44N O
$str44O b
)44b c
;44c d
private55 
static55 
readonly55 
int55  #
k_FalloffDistanceID55$ 7
=558 9
Shader55: @
.55@ A
PropertyToID55A M
(55M N
$str55N `
)55` a
;55a b
private66 
static66 
readonly66 
int66  #
k_FalloffOffsetID66$ 5
=666 7
Shader668 >
.66> ?
PropertyToID66? K
(66K L
$str66L \
)66\ ]
;66] ^
private77 
static77 
readonly77 
int77  #
k_LightColorID77$ 2
=773 4
Shader775 ;
.77; <
PropertyToID77< H
(77H I
$str77I V
)77V W
;77W X
private88 
static88 
readonly88 
int88  #
k_VolumeOpacityID88$ 5
=886 7
Shader888 >
.88> ?
PropertyToID88? K
(88K L
$str88L \
)88\ ]
;88] ^
private99 
static99 
readonly99 
int99  #
k_CookieTexID99$ 1
=992 3
Shader994 :
.99: ;
PropertyToID99; G
(99G H
$str99H T
)99T U
;99U V
private:: 
static:: 
readonly:: 
int::  #
k_FalloffLookupID::$ 5
=::6 7
Shader::8 >
.::> ?
PropertyToID::? K
(::K L
$str::L \
)::\ ]
;::] ^
private;; 
static;; 
readonly;; 
int;;  #
k_LightPositionID;;$ 5
=;;6 7
Shader;;8 >
.;;> ?
PropertyToID;;? K
(;;K L
$str;;L \
);;\ ]
;;;] ^
private<< 
static<< 
readonly<< 
int<<  #
k_LightInvMatrixID<<$ 6
=<<7 8
Shader<<9 ?
.<<? @
PropertyToID<<@ L
(<<L M
$str<<M ^
)<<^ _
;<<_ `
private== 
static== 
readonly== 
int==  ##
k_LightNoRotInvMatrixID==$ ;
===< =
Shader==> D
.==D E
PropertyToID==E Q
(==Q R
$str==R h
)==h i
;==i j
private>> 
static>> 
readonly>> 
int>>  #
k_InnerRadiusMultID>>$ 7
=>>8 9
Shader>>: @
.>>@ A
PropertyToID>>A M
(>>M N
$str>>N `
)>>` a
;>>a b
private?? 
static?? 
readonly?? 
int??  #
k_OuterAngleID??$ 2
=??3 4
Shader??5 ;
.??; <
PropertyToID??< H
(??H I
$str??I V
)??V W
;??W X
private@@ 
static@@ 
readonly@@ 
int@@  #
k_InnerAngleMultID@@$ 6
=@@7 8
Shader@@9 ?
.@@? @
PropertyToID@@@ L
(@@L M
$str@@M ^
)@@^ _
;@@_ `
privateAA 
staticAA 
readonlyAA 
intAA  #
k_LightLookupIDAA$ 3
=AA4 5
ShaderAA6 <
.AA< =
PropertyToIDAA= I
(AAI J
$strAAJ X
)AAX Y
;AAY Z
privateBB 
staticBB 
readonlyBB 
intBB  #
k_IsFullSpotlightIDBB$ 7
=BB8 9
ShaderBB: @
.BB@ A
PropertyToIDBBA M
(BBM N
$strBBN `
)BB` a
;BBa b
privateCC 
staticCC 
readonlyCC 
intCC  #
k_LightZDistanceIDCC$ 6
=CC7 8
ShaderCC9 ?
.CC? @
PropertyToIDCC@ L
(CCL M
$strCCM ^
)CC^ _
;CC_ `
privateDD 
staticDD 
readonlyDD 
intDD  ##
k_PointLightCookieTexIDDD$ ;
=DD< =
ShaderDD> D
.DDD E
PropertyToIDDDE Q
(DDQ R
$strDDR h
)DDh i
;DDi j
privateFF 
staticFF 
GraphicsFormatFF %"
GetRenderTextureFormatFF& <
(FF< =
)FF= >
{GG 	
ifHH 
(HH 
!HH .
"s_HasSetupRenderTextureFormatToUseHH 3
)HH3 4
{II 
ifJJ 
(JJ 

SystemInfoJJ 
.JJ 
IsFormatSupportedJJ 0
(JJ0 1
GraphicsFormatJJ1 ?
.JJ? @"
B10G11R11_UFloatPack32JJ@ V
,JJV W
FormatUsageJJX c
.JJc d
LinearJJd j
|JJk l
FormatUsageJJm x
.JJx y
RenderJJy 
)	JJ Ä
)
JJÄ Å&
s_RenderTextureFormatToUseKK .
=KK/ 0
GraphicsFormatKK1 ?
.KK? @"
B10G11R11_UFloatPack32KK@ V
;KKV W
elseLL 
ifLL 
(LL 

SystemInfoLL #
.LL# $
IsFormatSupportedLL$ 5
(LL5 6
GraphicsFormatLL6 D
.LLD E
R16G16B16A16_SFloatLLE X
,LLX Y
FormatUsageLLZ e
.LLe f
LinearLLf l
|LLm n
FormatUsageLLo z
.LLz {
Render	LL{ Å
)
LLÅ Ç
)
LLÇ É&
s_RenderTextureFormatToUseMM .
=MM/ 0
GraphicsFormatMM1 ?
.MM? @
R16G16B16A16_SFloatMM@ S
;MMS T.
"s_HasSetupRenderTextureFormatToUseOO 2
=OO3 4
trueOO5 9
;OO9 :
}PP 
returnRR &
s_RenderTextureFormatToUseRR -
;RR- .
}SS 	
publicUU 
staticUU 
voidUU (
CreateNormalMapRenderTextureUU 7
(UU7 8
thisUU8 <
IRenderPass2DUU= J
passUUK O
,UUO P
RenderingDataUUQ ^
renderingDataUU_ l
,UUl m
CommandBufferUUn {
cmdUU| 
)	UU Ä
{VV 	
varWW 

descriptorWW 
=WW 
newWW  #
RenderTextureDescriptorWW! 8
(WW8 9
renderingDataWW9 F
.WWF G

cameraDataWWG Q
.WWQ R"
cameraTargetDescriptorWWR h
.WWh i
widthWWi n
,WWn o
renderingDataWWp }
.WW} ~

cameraData	WW~ à
.
WWà â$
cameraTargetDescriptor
WWâ ü
.
WWü †
height
WW† ¶
)
WW¶ ß
;
WWß ®

descriptorXX 
.XX 
graphicsFormatXX %
=XX& '"
GetRenderTextureFormatXX( >
(XX> ?
)XX? @
;XX@ A

descriptorYY 
.YY 
	useMipMapYY  
=YY! "
falseYY# (
;YY( )

descriptorZZ 
.ZZ 
autoGenerateMipsZZ '
=ZZ( )
falseZZ* /
;ZZ/ 0

descriptor[[ 
.[[ 
depthBufferBits[[ &
=[[' (
$num[[) *
;[[* +

descriptor\\ 
.\\ 
msaaSamples\\ "
=\\# $
renderingData\\% 2
.\\2 3

cameraData\\3 =
.\\= >"
cameraTargetDescriptor\\> T
.\\T U
msaaSamples\\U `
;\\` a

descriptor]] 
.]] 
	dimension]]  
=]]! "
TextureDimension]]# 3
.]]3 4
Tex2D]]4 9
;]]9 :
cmd__ 
.__ 
GetTemporaryRT__ 
(__ 
pass__ #
.__# $
rendererData__$ 0
.__0 1
normalsRenderTarget__1 D
.__D E
id__E G
,__G H

descriptor__I S
,__S T

FilterMode__U _
.___ `
Bilinear__` h
)__h i
;__i j
}`` 	
publicbb 
staticbb 
voidbb )
CreateBlendStyleRenderTexturebb 8
(bb8 9
thisbb9 =
IRenderPass2Dbb> K
passbbL P
,bbP Q
RenderingDatabbR _
renderingDatabb` m
,bbm n
CommandBufferbbo |
cmd	bb} Ä
,
bbÄ Å
int
bbÇ Ö
blendStyleIndex
bbÜ ï
)
bbï ñ
{cc 	
vardd 
renderTextureScaledd "
=dd# $
Mathfdd% *
.dd* +
Clampdd+ 0
(dd0 1
passdd1 5
.dd5 6
rendererDatadd6 B
.ddB C
lightBlendStylesddC S
[ddS T
blendStyleIndexddT c
]ddc d
.ddd e
renderTextureScaledde w
,ddw x
$numddy ~
,dd~ 
$num
ddÄ Ñ
)
ddÑ Ö
;
ddÖ Ü
varee 
widthee 
=ee 
(ee 
intee 
)ee 
(ee 
renderingDataee +
.ee+ ,

cameraDataee, 6
.ee6 7"
cameraTargetDescriptoree7 M
.eeM N
widtheeN S
*eeT U
renderTextureScaleeeV h
)eeh i
;eei j
varff 
heightff 
=ff 
(ff 
intff 
)ff 
(ff 
renderingDataff ,
.ff, -

cameraDataff- 7
.ff7 8"
cameraTargetDescriptorff8 N
.ffN O
heightffO U
*ffV W
renderTextureScaleffX j
)ffj k
;ffk l
varhh 

descriptorhh 
=hh 
newhh  #
RenderTextureDescriptorhh! 8
(hh8 9
widthhh9 >
,hh> ?
heighthh@ F
)hhF G
;hhG H

descriptorii 
.ii 
graphicsFormatii %
=ii& '"
GetRenderTextureFormatii( >
(ii> ?
)ii? @
;ii@ A

descriptorjj 
.jj 
	useMipMapjj  
=jj! "
falsejj# (
;jj( )

descriptorkk 
.kk 
autoGenerateMipskk '
=kk( )
falsekk* /
;kk/ 0

descriptorll 
.ll 
depthBufferBitsll &
=ll' (
$numll) *
;ll* +

descriptormm 
.mm 
msaaSamplesmm "
=mm# $
$nummm% &
;mm& '

descriptornn 
.nn 
	dimensionnn  
=nn! "
TextureDimensionnn# 3
.nn3 4
Tex2Dnn4 9
;nn9 :
refpp 
varpp 

blendStylepp 
=pp  
refpp! $
passpp% )
.pp) *
rendererDatapp* 6
.pp6 7
lightBlendStylespp7 G
[ppG H
blendStyleIndexppH W
]ppW X
;ppX Y
cmdqq 
.qq 
GetTemporaryRTqq 
(qq 

blendStyleqq )
.qq) *
renderTargetHandleqq* <
.qq< =
idqq= ?
,qq? @

descriptorqqA K
,qqK L

FilterModeqqM W
.qqW X
BilinearqqX `
)qq` a
;qqa b

blendStylerr 
.rr 
hasRenderTargetrr &
=rr' (
truerr) -
;rr- .

blendStyless 
.ss 
isDirtyss 
=ss  
truess! %
;ss% &
}tt 	
publicvv 
staticvv 
voidvv 
EnableBlendStylevv +
(vv+ ,
CommandBuffervv, 9
cmdvv: =
,vv= >
intvv? B
blendStyleIndexvvC R
,vvR S
boolvvT X
enabledvvY `
)vv` a
{ww 	
varxx 
keywordxx 
=xx #
k_UseBlendStyleKeywordsxx 1
[xx1 2
blendStyleIndexxx2 A
]xxA B
;xxB C
ifzz 
(zz 
enabledzz 
)zz 
cmd{{ 
.{{ 
EnableShaderKeyword{{ '
({{' (
keyword{{( /
){{/ 0
;{{0 1
else|| 
cmd}} 
.}}  
DisableShaderKeyword}} (
(}}( )
keyword}}) 0
)}}0 1
;}}1 2
}~~ 	
public
ÄÄ 
static
ÄÄ 
void
ÄÄ #
ReleaseRenderTextures
ÄÄ 0
(
ÄÄ0 1
this
ÄÄ1 5
IRenderPass2D
ÄÄ6 C
pass
ÄÄD H
,
ÄÄH I
CommandBuffer
ÄÄJ W
cmd
ÄÄX [
)
ÄÄ[ \
{
ÅÅ 	
for
ÇÇ 
(
ÇÇ 
var
ÇÇ 
i
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
;
ÇÇ 
i
ÇÇ 
<
ÇÇ 
pass
ÇÇ  $
.
ÇÇ$ %
rendererData
ÇÇ% 1
.
ÇÇ1 2
lightBlendStyles
ÇÇ2 B
.
ÇÇB C
Length
ÇÇC I
;
ÇÇI J
i
ÇÇK L
++
ÇÇL N
)
ÇÇN O
{
ÉÉ 
if
ÑÑ 
(
ÑÑ 
!
ÑÑ 
pass
ÑÑ 
.
ÑÑ 
rendererData
ÑÑ &
.
ÑÑ& '
lightBlendStyles
ÑÑ' 7
[
ÑÑ7 8
i
ÑÑ8 9
]
ÑÑ9 :
.
ÑÑ: ;
hasRenderTarget
ÑÑ; J
)
ÑÑJ K
continue
ÖÖ 
;
ÖÖ 
pass
áá 
.
áá 
rendererData
áá !
.
áá! "
lightBlendStyles
áá" 2
[
áá2 3
i
áá3 4
]
áá4 5
.
áá5 6
hasRenderTarget
áá6 E
=
ááF G
false
ááH M
;
ááM N
cmd
àà 
.
àà  
ReleaseTemporaryRT
àà &
(
àà& '
pass
àà' +
.
àà+ ,
rendererData
àà, 8
.
àà8 9
lightBlendStyles
àà9 I
[
ààI J
i
ààJ K
]
ààK L
.
ààL M 
renderTargetHandle
ààM _
.
àà_ `
id
àà` b
)
ààb c
;
ààc d
}
ââ 
cmd
ãã 
.
ãã  
ReleaseTemporaryRT
ãã "
(
ãã" #
pass
ãã# '
.
ãã' (
rendererData
ãã( 4
.
ãã4 5!
normalsRenderTarget
ãã5 H
.
ããH I
id
ããI K
)
ããK L
;
ããL M
cmd
åå 
.
åå  
ReleaseTemporaryRT
åå "
(
åå" #
pass
åå# '
.
åå' (
rendererData
åå( 4
.
åå4 5!
shadowsRenderTarget
åå5 H
.
ååH I
id
ååI K
)
ååK L
;
ååL M
}
çç 	
private
êê 
static
êê 
bool
êê 
RenderLightSet
êê *
(
êê* +
IRenderPass2D
êê+ 8
pass
êê9 =
,
êê= >
RenderingData
êê? L
renderingData
êêM Z
,
êêZ [
int
êê\ _
blendStyleIndex
êê` o
,
êêo p
CommandBuffer
êêq ~
cmdêê Ç
,êêÇ É
intêêÑ á
layerToRenderêêà ï
,êêï ñ&
RenderTargetIdentifierêêó ≠
renderTextureêêÆ ª
,êêª º
boolêêΩ ¡
rtNeedsClearêê¬ Œ
,êêŒ œ
Colorêê– ’

clearColorêê÷ ‡
,êê‡ ·
Listêê‚ Ê
<êêÊ Á
Light2DêêÁ Ó
>êêÓ Ô
lightsêê ˆ
)êêˆ ˜
{
ëë 	
var
íí 
renderedAnyLight
íí  
=
íí! "
false
íí# (
;
íí( )
foreach
îî 
(
îî 
var
îî 
light
îî 
in
îî !
lights
îî" (
)
îî( )
{
ïï 
if
ññ 
(
ññ 
light
ññ 
!=
ññ 
null
ññ !
&&
ññ" $
light
óó 
.
óó 
	lightType
óó #
!=
óó$ &
Light2D
óó' .
.
óó. /
	LightType
óó/ 8
.
óó8 9
Global
óó9 ?
&&
óó@ B
light
òò 
.
òò 
blendStyleIndex
òò )
==
òò* ,
blendStyleIndex
òò- <
&&
òò= ?
light
ôô 
.
ôô 

IsLitLayer
ôô $
(
ôô$ %
layerToRender
ôô% 2
)
ôô2 3
)
ôô3 4
{
öö 
var
úú 
lightMaterial
úú %
=
úú& '
pass
úú( ,
.
úú, -
rendererData
úú- 9
.
úú9 :
GetLightMaterial
úú: J
(
úúJ K
light
úúK P
,
úúP Q
false
úúR W
)
úúW X
;
úúX Y
if
ùù 
(
ùù 
lightMaterial
ùù %
==
ùù& (
null
ùù) -
)
ùù- .
continue
ûû  
;
ûû  !
var
†† 
	lightMesh
†† !
=
††" #
light
††$ )
.
††) *
	lightMesh
††* 3
;
††3 4
if
°° 
(
°° 
	lightMesh
°° !
==
°°" $
null
°°% )
)
°°) *
continue
¢¢  
;
¢¢  !
ShadowRendering
§§ #
.
§§# $
RenderShadows
§§$ 1
(
§§1 2
pass
§§2 6
,
§§6 7
renderingData
§§8 E
,
§§E F
cmd
§§G J
,
§§J K
layerToRender
§§L Y
,
§§Y Z
light
§§[ `
,
§§` a
light
§§b g
.
§§g h
shadowIntensity
§§h w
,
§§w x
renderTexture§§y Ü
,§§Ü á
renderTexture§§à ï
)§§ï ñ
;§§ñ ó
if
¶¶ 
(
¶¶ 
!
¶¶ 
renderedAnyLight
¶¶ )
&&
¶¶* ,
rtNeedsClear
¶¶- 9
)
¶¶9 :
{
ßß 
cmd
®® 
.
®® 
ClearRenderTarget
®® -
(
®®- .
false
®®. 3
,
®®3 4
true
®®5 9
,
®®9 :

clearColor
®®; E
)
®®E F
;
®®F G
}
©© 
renderedAnyLight
´´ $
=
´´% &
true
´´' +
;
´´+ ,
if
≠≠ 
(
≠≠ 
light
≠≠ 
.
≠≠ 
	lightType
≠≠ '
==
≠≠( *
Light2D
≠≠+ 2
.
≠≠2 3
	LightType
≠≠3 <
.
≠≠< =
Sprite
≠≠= C
&&
≠≠D F
light
≠≠G L
.
≠≠L M
lightCookieSprite
≠≠M ^
!=
≠≠_ a
null
≠≠b f
&&
≠≠g i
light
≠≠j o
.
≠≠o p 
lightCookieSprite≠≠p Å
.≠≠Å Ç
texture≠≠Ç â
!=≠≠ä å
null≠≠ç ë
)≠≠ë í
cmd
ÆÆ 
.
ÆÆ 
SetGlobalTexture
ÆÆ ,
(
ÆÆ, -
k_CookieTexID
ÆÆ- :
,
ÆÆ: ;
light
ÆÆ< A
.
ÆÆA B
lightCookieSprite
ÆÆB S
.
ÆÆS T
texture
ÆÆT [
)
ÆÆ[ \
;
ÆÆ\ ]
cmd
∞∞ 
.
∞∞ 
SetGlobalFloat
∞∞ &
(
∞∞& '"
k_FalloffIntensityID
∞∞' ;
,
∞∞; <
light
∞∞= B
.
∞∞B C
falloffIntensity
∞∞C S
)
∞∞S T
;
∞∞T U
cmd
±± 
.
±± 
SetGlobalFloat
±± &
(
±±& '!
k_FalloffDistanceID
±±' :
,
±±: ;
light
±±< A
.
±±A B#
shapeLightFalloffSize
±±B W
)
±±W X
;
±±X Y
cmd
≤≤ 
.
≤≤ 
SetGlobalVector
≤≤ '
(
≤≤' (
k_FalloffOffsetID
≤≤( 9
,
≤≤9 :
light
≤≤; @
.
≤≤@ A%
shapeLightFalloffOffset
≤≤A X
)
≤≤X Y
;
≤≤Y Z
cmd
≥≥ 
.
≥≥ 
SetGlobalColor
≥≥ &
(
≥≥& '
k_LightColorID
≥≥' 5
,
≥≥5 6
light
≥≥7 <
.
≥≥< =
	intensity
≥≥= F
*
≥≥G H
light
≥≥I N
.
≥≥N O
color
≥≥O T
)
≥≥T U
;
≥≥U V
cmd
¥¥ 
.
¥¥ 
SetGlobalFloat
¥¥ &
(
¥¥& '
k_VolumeOpacityID
¥¥' 8
,
¥¥8 9
light
¥¥: ?
.
¥¥? @
volumeOpacity
¥¥@ M
)
¥¥M N
;
¥¥N O
if
∂∂ 
(
∂∂ 
light
∂∂ 
.
∂∂ 
useNormalMap
∂∂ *
||
∂∂+ -
light
∂∂. 3
.
∂∂3 4
	lightType
∂∂4 =
==
∂∂> @
Light2D
∂∂A H
.
∂∂H I
	LightType
∂∂I R
.
∂∂R S
Point
∂∂S X
)
∂∂X Y(
SetPointLightShaderGlobals
∑∑ 2
(
∑∑2 3
cmd
∑∑3 6
,
∑∑6 7
light
∑∑8 =
)
∑∑= >
;
∑∑> ?
if
∫∫ 
(
∫∫ 
light
∫∫ 
.
∫∫ 
	lightType
∫∫ '
==
∫∫( *
Light2D
∫∫+ 2
.
∫∫2 3
	LightType
∫∫3 <
.
∫∫< =

Parametric
∫∫= G
||
∫∫H J
light
∫∫K P
.
∫∫P Q
	lightType
∫∫Q Z
==
∫∫[ ]
Light2D
∫∫^ e
.
∫∫e f
	LightType
∫∫f o
.
∫∫o p
Freeform
∫∫p x
||
∫∫y {
light∫∫| Å
.∫∫Å Ç
	lightType∫∫Ç ã
==∫∫å é
Light2D∫∫è ñ
.∫∫ñ ó
	LightType∫∫ó †
.∫∫† °
Sprite∫∫° ß
)∫∫ß ®
{
ªª 
cmd
ºº 
.
ºº 
DrawMesh
ºº $
(
ºº$ %
	lightMesh
ºº% .
,
ºº. /
light
ºº0 5
.
ºº5 6
	transform
ºº6 ?
.
ºº? @ 
localToWorldMatrix
ºº@ R
,
ººR S
lightMaterial
ººT a
)
ººa b
;
ººb c
}
ΩΩ 
else
ææ 
if
ææ 
(
ææ 
light
ææ "
.
ææ" #
	lightType
ææ# ,
==
ææ- /
Light2D
ææ0 7
.
ææ7 8
	LightType
ææ8 A
.
ææA B
Point
ææB G
)
ææG H
{
øø 
var
¿¿ 
scale
¿¿ !
=
¿¿" #
new
¿¿$ '
Vector3
¿¿( /
(
¿¿/ 0
light
¿¿0 5
.
¿¿5 6#
pointLightOuterRadius
¿¿6 K
,
¿¿K L
light
¿¿M R
.
¿¿R S#
pointLightOuterRadius
¿¿S h
,
¿¿h i
light
¿¿j o
.
¿¿o p$
pointLightOuterRadius¿¿p Ö
)¿¿Ö Ü
;¿¿Ü á
var
¡¡ 
matrix
¡¡ "
=
¡¡# $
	Matrix4x4
¡¡% .
.
¡¡. /
TRS
¡¡/ 2
(
¡¡2 3
light
¡¡3 8
.
¡¡8 9
	transform
¡¡9 B
.
¡¡B C
position
¡¡C K
,
¡¡K L

Quaternion
¡¡M W
.
¡¡W X
identity
¡¡X `
,
¡¡` a
scale
¡¡b g
)
¡¡g h
;
¡¡h i
cmd
¬¬ 
.
¬¬ 
DrawMesh
¬¬ $
(
¬¬$ %
	lightMesh
¬¬% .
,
¬¬. /
matrix
¬¬0 6
,
¬¬6 7
lightMaterial
¬¬8 E
)
¬¬E F
;
¬¬F G
}
√√ 
}
ƒƒ 
}
≈≈ 
if
»» 
(
»» 
!
»» 
renderedAnyLight
»» !
&&
»»" $
rtNeedsClear
»»% 1
)
»»1 2
{
…… 
cmd
   
.
   
ClearRenderTarget
   %
(
  % &
false
  & +
,
  + ,
true
  - 1
,
  1 2

clearColor
  3 =
)
  = >
;
  > ?
}
ÀÀ 
return
ÕÕ 
renderedAnyLight
ÕÕ #
;
ÕÕ# $
}
ŒŒ 	
private
–– 
static
–– 
void
–– "
RenderLightVolumeSet
–– 0
(
––0 1
IRenderPass2D
––1 >
pass
––? C
,
––C D
RenderingData
––E R
renderingData
––S `
,
––` a
int
––b e
blendStyleIndex
––f u
,
––u v
CommandBuffer––w Ñ
cmd––Ö à
,––à â
int––ä ç
layerToRender––é õ
,––õ ú&
RenderTargetIdentifier––ù ≥
renderTexture––¥ ¡
,––¡ ¬&
RenderTargetIdentifier––√ Ÿ
depthTexture––⁄ Ê
,––Ê Á
List––Ë Ï
<––Ï Ì
Light2D––Ì Ù
>––Ù ı
lights––ˆ ¸
)––¸ ˝
{
—— 	
if
““ 
(
““ 
lights
““ 
.
““ 
Count
““ 
>
““ 
$num
““  
)
““  !
{
”” 
for
‘‘ 
(
‘‘ 
var
‘‘ 
i
‘‘ 
=
‘‘ 
$num
‘‘ 
;
‘‘ 
i
‘‘  !
<
‘‘" #
lights
‘‘$ *
.
‘‘* +
Count
‘‘+ 0
;
‘‘0 1
i
‘‘2 3
++
‘‘3 5
)
‘‘5 6
{
’’ 
var
÷÷ 
light
÷÷ 
=
÷÷ 
lights
÷÷  &
[
÷÷& '
i
÷÷' (
]
÷÷( )
;
÷÷) *
var
ÿÿ 
topMostLayer
ÿÿ $
=
ÿÿ% &
light
ÿÿ' ,
.
ÿÿ, - 
GetTopMostLitLayer
ÿÿ- ?
(
ÿÿ? @
)
ÿÿ@ A
;
ÿÿA B
if
ŸŸ 
(
ŸŸ 
layerToRender
ŸŸ %
==
ŸŸ& (
topMostLayer
ŸŸ) 5
)
ŸŸ5 6
{
⁄⁄ 
if
€€ 
(
€€ 
light
€€ !
!=
€€" $
null
€€% )
&&
€€* ,
light
€€- 2
.
€€2 3
	lightType
€€3 <
!=
€€= ?
Light2D
€€@ G
.
€€G H
	LightType
€€H Q
.
€€Q R
Global
€€R X
&&
€€Y [
light
€€\ a
.
€€a b
volumeOpacity
€€b o
>
€€p q
$num
€€r v
&&
€€w y
light
€€z 
.€€ Ä
blendStyleIndex€€Ä è
==€€ê í
blendStyleIndex€€ì ¢
&&€€£ •
light€€¶ ´
.€€´ ¨

IsLitLayer€€¨ ∂
(€€∂ ∑
layerToRender€€∑ ƒ
)€€ƒ ≈
)€€≈ ∆
{
‹‹ 
var
›› !
lightVolumeMaterial
››  3
=
››4 5
pass
››6 :
.
››: ;
rendererData
››; G
.
››G H
GetLightMaterial
››H X
(
››X Y
light
››Y ^
,
››^ _
true
››` d
)
››d e
;
››e f
if
ﬁﬁ 
(
ﬁﬁ  !
lightVolumeMaterial
ﬁﬁ  3
!=
ﬁﬁ4 6
null
ﬁﬁ7 ;
)
ﬁﬁ; <
{
ﬂﬂ 
var
‡‡  #
	lightMesh
‡‡$ -
=
‡‡. /
light
‡‡0 5
.
‡‡5 6
	lightMesh
‡‡6 ?
;
‡‡? @
if
··  "
(
··# $
	lightMesh
··$ -
!=
··. 0
null
··1 5
)
··5 6
{
‚‚  !
ShadowRendering
„„$ 3
.
„„3 4
RenderShadows
„„4 A
(
„„A B
pass
„„B F
,
„„F G
renderingData
„„H U
,
„„U V
cmd
„„W Z
,
„„Z [
layerToRender
„„\ i
,
„„i j
light
„„k p
,
„„p q
light
„„r w
.
„„w x$
shadowVolumeIntensity„„x ç
,„„ç é
renderTexture„„è ú
,„„ú ù
depthTexture„„û ™
)„„™ ´
;„„´ ¨
if
ÂÂ$ &
(
ÂÂ' (
light
ÂÂ( -
.
ÂÂ- .
	lightType
ÂÂ. 7
==
ÂÂ8 :
Light2D
ÂÂ; B
.
ÂÂB C
	LightType
ÂÂC L
.
ÂÂL M
Sprite
ÂÂM S
&&
ÂÂT V
light
ÂÂW \
.
ÂÂ\ ]
lightCookieSprite
ÂÂ] n
!=
ÂÂo q
null
ÂÂr v
&&
ÂÂw y
light
ÂÂz 
.ÂÂ Ä!
lightCookieSpriteÂÂÄ ë
.ÂÂë í
textureÂÂí ô
!=ÂÂö ú
nullÂÂù °
)ÂÂ° ¢
cmd
ÊÊ( +
.
ÊÊ+ ,
SetGlobalTexture
ÊÊ, <
(
ÊÊ< =
k_CookieTexID
ÊÊ= J
,
ÊÊJ K
light
ÊÊL Q
.
ÊÊQ R
lightCookieSprite
ÊÊR c
.
ÊÊc d
texture
ÊÊd k
)
ÊÊk l
;
ÊÊl m
cmd
ËË$ '
.
ËË' (
SetGlobalFloat
ËË( 6
(
ËË6 7"
k_FalloffIntensityID
ËË7 K
,
ËËK L
light
ËËM R
.
ËËR S
falloffIntensity
ËËS c
)
ËËc d
;
ËËd e
cmd
ÈÈ$ '
.
ÈÈ' (
SetGlobalFloat
ÈÈ( 6
(
ÈÈ6 7!
k_FalloffDistanceID
ÈÈ7 J
,
ÈÈJ K
light
ÈÈL Q
.
ÈÈQ R#
shapeLightFalloffSize
ÈÈR g
)
ÈÈg h
;
ÈÈh i
cmd
ÍÍ$ '
.
ÍÍ' (
SetGlobalVector
ÍÍ( 7
(
ÍÍ7 8
k_FalloffOffsetID
ÍÍ8 I
,
ÍÍI J
light
ÍÍK P
.
ÍÍP Q%
shapeLightFalloffOffset
ÍÍQ h
)
ÍÍh i
;
ÍÍi j
cmd
ÎÎ$ '
.
ÎÎ' (
SetGlobalColor
ÎÎ( 6
(
ÎÎ6 7
k_LightColorID
ÎÎ7 E
,
ÎÎE F
light
ÎÎG L
.
ÎÎL M
	intensity
ÎÎM V
*
ÎÎW X
light
ÎÎY ^
.
ÎÎ^ _
color
ÎÎ_ d
)
ÎÎd e
;
ÎÎe f
cmd
ÏÏ$ '
.
ÏÏ' (
SetGlobalFloat
ÏÏ( 6
(
ÏÏ6 7
k_VolumeOpacityID
ÏÏ7 H
,
ÏÏH I
light
ÏÏJ O
.
ÏÏO P
volumeOpacity
ÏÏP ]
)
ÏÏ] ^
;
ÏÏ^ _
if
ÔÔ$ &
(
ÔÔ' (
light
ÔÔ( -
.
ÔÔ- .
useNormalMap
ÔÔ. :
||
ÔÔ; =
light
ÔÔ> C
.
ÔÔC D
	lightType
ÔÔD M
==
ÔÔN P
Light2D
ÔÔQ X
.
ÔÔX Y
	LightType
ÔÔY b
.
ÔÔb c
Point
ÔÔc h
)
ÔÔh i(
SetPointLightShaderGlobals
( B
(
B C
cmd
C F
,
F G
light
H M
)
M N
;
N O
if
ÛÛ$ &
(
ÛÛ' (
light
ÛÛ( -
.
ÛÛ- .
	lightType
ÛÛ. 7
==
ÛÛ8 :
Light2D
ÛÛ; B
.
ÛÛB C
	LightType
ÛÛC L
.
ÛÛL M

Parametric
ÛÛM W
||
ÛÛX Z
light
ÛÛ[ `
.
ÛÛ` a
	lightType
ÛÛa j
==
ÛÛk m
Light2D
ÛÛn u
.
ÛÛu v
	LightType
ÛÛv 
.ÛÛ Ä
FreeformÛÛÄ à
||ÛÛâ ã
lightÛÛå ë
.ÛÛë í
	lightTypeÛÛí õ
==ÛÛú û
Light2DÛÛü ¶
.ÛÛ¶ ß
	LightTypeÛÛß ∞
.ÛÛ∞ ±
SpriteÛÛ± ∑
)ÛÛ∑ ∏
{
ÙÙ$ %
cmd
ıı( +
.
ıı+ ,
DrawMesh
ıı, 4
(
ıı4 5
	lightMesh
ıı5 >
,
ıı> ?
light
ıı@ E
.
ııE F
	transform
ııF O
.
ııO P 
localToWorldMatrix
ııP b
,
ııb c!
lightVolumeMaterial
ııd w
)
ııw x
;
ııx y
}
ˆˆ$ %
else
˜˜$ (
if
˜˜) +
(
˜˜, -
light
˜˜- 2
.
˜˜2 3
	lightType
˜˜3 <
==
˜˜= ?
Light2D
˜˜@ G
.
˜˜G H
	LightType
˜˜H Q
.
˜˜Q R
Point
˜˜R W
)
˜˜W X
{
¯¯$ %
var
˘˘( +
scale
˘˘, 1
=
˘˘2 3
new
˘˘4 7
Vector3
˘˘8 ?
(
˘˘? @
light
˘˘@ E
.
˘˘E F#
pointLightOuterRadius
˘˘F [
,
˘˘[ \
light
˘˘] b
.
˘˘b c#
pointLightOuterRadius
˘˘c x
,
˘˘x y
light
˘˘z 
.˘˘ Ä%
pointLightOuterRadius˘˘Ä ï
)˘˘ï ñ
;˘˘ñ ó
var
˙˙( +
matrix
˙˙, 2
=
˙˙3 4
	Matrix4x4
˙˙5 >
.
˙˙> ?
TRS
˙˙? B
(
˙˙B C
light
˙˙C H
.
˙˙H I
	transform
˙˙I R
.
˙˙R S
position
˙˙S [
,
˙˙[ \

Quaternion
˙˙] g
.
˙˙g h
identity
˙˙h p
,
˙˙p q
scale
˙˙r w
)
˙˙w x
;
˙˙x y
cmd
˚˚( +
.
˚˚+ ,
DrawMesh
˚˚, 4
(
˚˚4 5
	lightMesh
˚˚5 >
,
˚˚> ?
matrix
˚˚@ F
,
˚˚F G!
lightVolumeMaterial
˚˚H [
)
˚˚[ \
;
˚˚\ ]
}
¸¸$ %
}
˝˝  !
}
˛˛ 
}
ˇˇ 
}
ÄÄ 
}
ÅÅ 
}
ÇÇ 
}
ÉÉ 	
public
ÖÖ 
static
ÖÖ 
void
ÖÖ (
SetShapeLightShaderGlobals
ÖÖ 5
(
ÖÖ5 6
this
ÖÖ6 :
IRenderPass2D
ÖÖ; H
pass
ÖÖI M
,
ÖÖM N
CommandBuffer
ÖÖO \
cmd
ÖÖ] `
)
ÖÖ` a
{
ÜÜ 	
for
áá 
(
áá 
var
áá 
i
áá 
=
áá 
$num
áá 
;
áá 
i
áá 
<
áá 
pass
áá  $
.
áá$ %
rendererData
áá% 1
.
áá1 2
lightBlendStyles
áá2 B
.
ááB C
Length
ááC I
;
ááI J
i
ááK L
++
ááL N
)
ááN O
{
àà 
var
ââ 

blendStyle
ââ 
=
ââ  
pass
ââ! %
.
ââ% &
rendererData
ââ& 2
.
ââ2 3
lightBlendStyles
ââ3 C
[
ââC D
i
ââD E
]
ââE F
;
ââF G
if
ää 
(
ää 
i
ää 
>=
ää #
k_BlendFactorsPropIDs
ää .
.
ää. /
Length
ää/ 5
)
ää5 6
break
ãã 
;
ãã 
cmd
çç 
.
çç 
SetGlobalVector
çç #
(
çç# $#
k_BlendFactorsPropIDs
çç$ 9
[
çç9 :
i
çç: ;
]
çç; <
,
çç< =

blendStyle
çç> H
.
ççH I
blendFactors
ççI U
)
ççU V
;
ççV W
cmd
éé 
.
éé 
SetGlobalVector
éé #
(
éé# $!
k_MaskFilterPropIDs
éé$ 7
[
éé7 8
i
éé8 9
]
éé9 :
,
éé: ;

blendStyle
éé< F
.
ééF G&
maskTextureChannelFilter
ééG _
.
éé_ `
mask
éé` d
)
ééd e
;
éée f
cmd
èè 
.
èè 
SetGlobalVector
èè #
(
èè# $%
k_InvertedFilterPropIDs
èè$ ;
[
èè; <
i
èè< =
]
èè= >
,
èè> ?

blendStyle
èè@ J
.
èèJ K&
maskTextureChannelFilter
èèK c
.
èèc d
inverted
èèd l
)
èèl m
;
èèm n
}
êê 
cmd
íí 
.
íí 
SetGlobalTexture
íí  
(
íí  !
k_FalloffLookupID
íí! 2
,
íí2 3"
Light2DLookupTexture
íí4 H
.
ííH I%
GetFalloffLookupTexture
ííI `
(
íí` a
)
íía b
)
ííb c
;
ííc d
}
ìì 	
private
ïï 
static
ïï 
float
ïï &
GetNormalizedInnerRadius
ïï 5
(
ïï5 6
Light2D
ïï6 =
light
ïï> C
)
ïïC D
{
ññ 	
return
óó 
light
óó 
.
óó #
pointLightInnerRadius
óó .
/
óó/ 0
light
óó1 6
.
óó6 7#
pointLightOuterRadius
óó7 L
;
óóL M
}
òò 	
private
öö 
static
öö 
float
öö  
GetNormalizedAngle
öö /
(
öö/ 0
float
öö0 5
angle
öö6 ;
)
öö; <
{
õõ 	
return
úú 
(
úú 
angle
úú 
/
úú 
$num
úú "
)
úú" #
;
úú# $
}
ùù 	
private
üü 
static
üü 
void
üü %
GetScaledLightInvMatrix
üü 3
(
üü3 4
Light2D
üü4 ;
light
üü< A
,
üüA B
out
üüC F
	Matrix4x4
üüG P
	retMatrix
üüQ Z
,
üüZ [
bool
üü\ `
includeRotation
üüa p
)
üüp q
{
†† 	
var
°° 
outerRadius
°° 
=
°° 
light
°° #
.
°°# $#
pointLightOuterRadius
°°$ 9
;
°°9 :
var
¢¢ 

lightScale
¢¢ 
=
¢¢ 
Vector3
¢¢ $
.
¢¢$ %
one
¢¢% (
;
¢¢( )
var
££ 
outerRadiusScale
££  
=
££! "
new
££# &
Vector3
££' .
(
££. /

lightScale
££/ 9
.
££9 :
x
££: ;
*
££< =
outerRadius
££> I
,
££I J

lightScale
££K U
.
££U V
y
££V W
*
££X Y
outerRadius
££Z e
,
££e f

lightScale
££g q
.
££q r
z
££r s
*
££t u
outerRadius££v Å
)££Å Ç
;££Ç É
var
•• 
	transform
•• 
=
•• 
light
•• !
.
••! "
	transform
••" +
;
••+ ,
var
¶¶ 
rotation
¶¶ 
=
¶¶ 
includeRotation
¶¶ *
?
¶¶+ ,
	transform
¶¶- 6
.
¶¶6 7
rotation
¶¶7 ?
:
¶¶@ A

Quaternion
¶¶B L
.
¶¶L M
identity
¶¶M U
;
¶¶U V
var
®® 
scaledLightMat
®® 
=
®®  
	Matrix4x4
®®! *
.
®®* +
TRS
®®+ .
(
®®. /
	transform
®®/ 8
.
®®8 9
position
®®9 A
,
®®A B
rotation
®®C K
,
®®K L
outerRadiusScale
®®M ]
)
®®] ^
;
®®^ _
	retMatrix
©© 
=
©© 
	Matrix4x4
©© !
.
©©! "
Inverse
©©" )
(
©©) *
scaledLightMat
©©* 8
)
©©8 9
;
©©9 :
}
™™ 	
private
¨¨ 
static
¨¨ 
void
¨¨ (
SetPointLightShaderGlobals
¨¨ 6
(
¨¨6 7
CommandBuffer
¨¨7 D
cmd
¨¨E H
,
¨¨H I
Light2D
¨¨J Q
light
¨¨R W
)
¨¨W X
{
≠≠ 	%
GetScaledLightInvMatrix
ØØ #
(
ØØ# $
light
ØØ$ )
,
ØØ) *
out
ØØ+ .
var
ØØ/ 2 
lightInverseMatrix
ØØ3 E
,
ØØE F
true
ØØG K
)
ØØK L
;
ØØL M%
GetScaledLightInvMatrix
∞∞ #
(
∞∞# $
light
∞∞$ )
,
∞∞) *
out
∞∞+ .
var
∞∞/ 2%
lightNoRotInverseMatrix
∞∞3 J
,
∞∞J K
false
∞∞L Q
)
∞∞Q R
;
∞∞R S
var
≤≤ 
innerRadius
≤≤ 
=
≤≤ &
GetNormalizedInnerRadius
≤≤ 6
(
≤≤6 7
light
≤≤7 <
)
≤≤< =
;
≤≤= >
var
≥≥ 

innerAngle
≥≥ 
=
≥≥  
GetNormalizedAngle
≥≥ /
(
≥≥/ 0
light
≥≥0 5
.
≥≥5 6"
pointLightInnerAngle
≥≥6 J
)
≥≥J K
;
≥≥K L
var
¥¥ 

outerAngle
¥¥ 
=
¥¥  
GetNormalizedAngle
¥¥ /
(
¥¥/ 0
light
¥¥0 5
.
¥¥5 6"
pointLightOuterAngle
¥¥6 J
)
¥¥J K
;
¥¥K L
var
µµ 
innerRadiusMult
µµ 
=
µµ  !
$num
µµ" #
/
µµ$ %
(
µµ& '
$num
µµ' (
-
µµ) *
innerRadius
µµ+ 6
)
µµ6 7
;
µµ7 8
cmd
∑∑ 
.
∑∑ 
SetGlobalVector
∑∑ 
(
∑∑  
k_LightPositionID
∑∑  1
,
∑∑1 2
light
∑∑3 8
.
∑∑8 9
	transform
∑∑9 B
.
∑∑B C
position
∑∑C K
)
∑∑K L
;
∑∑L M
cmd
∏∏ 
.
∏∏ 
SetGlobalMatrix
∏∏ 
(
∏∏   
k_LightInvMatrixID
∏∏  2
,
∏∏2 3 
lightInverseMatrix
∏∏4 F
)
∏∏F G
;
∏∏G H
cmd
ππ 
.
ππ 
SetGlobalMatrix
ππ 
(
ππ  %
k_LightNoRotInvMatrixID
ππ  7
,
ππ7 8%
lightNoRotInverseMatrix
ππ9 P
)
ππP Q
;
ππQ R
cmd
∫∫ 
.
∫∫ 
SetGlobalFloat
∫∫ 
(
∫∫ !
k_InnerRadiusMultID
∫∫ 2
,
∫∫2 3
innerRadiusMult
∫∫4 C
)
∫∫C D
;
∫∫D E
cmd
ªª 
.
ªª 
SetGlobalFloat
ªª 
(
ªª 
k_OuterAngleID
ªª -
,
ªª- .

outerAngle
ªª/ 9
)
ªª9 :
;
ªª: ;
cmd
ºº 
.
ºº 
SetGlobalFloat
ºº 
(
ºº  
k_InnerAngleMultID
ºº 1
,
ºº1 2
$num
ºº3 4
/
ºº5 6
(
ºº7 8

outerAngle
ºº8 B
-
ººC D

innerAngle
ººE O
)
ººO P
)
ººP Q
;
ººQ R
cmd
ΩΩ 
.
ΩΩ 
SetGlobalTexture
ΩΩ  
(
ΩΩ  !
k_LightLookupID
ΩΩ! 0
,
ΩΩ0 1"
Light2DLookupTexture
ΩΩ2 F
.
ΩΩF G#
GetLightLookupTexture
ΩΩG \
(
ΩΩ\ ]
)
ΩΩ] ^
)
ΩΩ^ _
;
ΩΩ_ `
cmd
ææ 
.
ææ 
SetGlobalTexture
ææ  
(
ææ  !
k_FalloffLookupID
ææ! 2
,
ææ2 3"
Light2DLookupTexture
ææ4 H
.
ææH I%
GetFalloffLookupTexture
ææI `
(
ææ` a
)
ææa b
)
ææb c
;
ææc d
cmd
øø 
.
øø 
SetGlobalFloat
øø 
(
øø "
k_FalloffIntensityID
øø 3
,
øø3 4
light
øø5 :
.
øø: ;
falloffIntensity
øø; K
)
øøK L
;
øøL M
cmd
¿¿ 
.
¿¿ 
SetGlobalFloat
¿¿ 
(
¿¿ !
k_IsFullSpotlightID
¿¿ 2
,
¿¿2 3

innerAngle
¿¿4 >
==
¿¿? A
$num
¿¿B C
?
¿¿D E
$num
¿¿F J
:
¿¿K L
$num
¿¿M Q
)
¿¿Q R
;
¿¿R S
cmd
¬¬ 
.
¬¬ 
SetGlobalFloat
¬¬ 
(
¬¬  
k_LightZDistanceID
¬¬ 1
,
¬¬1 2
light
¬¬3 8
.
¬¬8 9 
pointLightDistance
¬¬9 K
)
¬¬K L
;
¬¬L M
if
ƒƒ 
(
ƒƒ 
light
ƒƒ 
.
ƒƒ 
lightCookieSprite
ƒƒ '
!=
ƒƒ( *
null
ƒƒ+ /
&&
ƒƒ0 2
light
ƒƒ3 8
.
ƒƒ8 9
lightCookieSprite
ƒƒ9 J
.
ƒƒJ K
texture
ƒƒK R
!=
ƒƒS U
null
ƒƒV Z
)
ƒƒZ [
cmd
≈≈ 
.
≈≈ 
SetGlobalTexture
≈≈ $
(
≈≈$ %%
k_PointLightCookieTexID
≈≈% <
,
≈≈< =
light
≈≈> C
.
≈≈C D
lightCookieSprite
≈≈D U
.
≈≈U V
texture
≈≈V ]
)
≈≈] ^
;
≈≈^ _
}
∆∆ 	
public
»» 
static
»» 
void
»»  
ClearDirtyLighting
»» -
(
»»- .
this
»». 2
IRenderPass2D
»»3 @
pass
»»A E
,
»»E F
CommandBuffer
»»G T
cmd
»»U X
,
»»X Y
uint
»»Z ^
blendStylesUsed
»»_ n
)
»»n o
{
…… 	
for
   
(
   
var
   
i
   
=
   
$num
   
;
   
i
   
<
   
pass
    $
.
  $ %
rendererData
  % 1
.
  1 2
lightBlendStyles
  2 B
.
  B C
Length
  C I
;
  I J
++
  K M
i
  M N
)
  N O
{
ÀÀ 
if
ÃÃ 
(
ÃÃ 
(
ÃÃ 
blendStylesUsed
ÃÃ $
&
ÃÃ% &
(
ÃÃ' (
uint
ÃÃ( ,
)
ÃÃ, -
(
ÃÃ- .
$num
ÃÃ. /
<<
ÃÃ0 2
i
ÃÃ3 4
)
ÃÃ4 5
)
ÃÃ5 6
==
ÃÃ7 9
$num
ÃÃ: ;
)
ÃÃ; <
continue
ÕÕ 
;
ÕÕ 
if
œœ 
(
œœ 
!
œœ 
pass
œœ 
.
œœ 
rendererData
œœ &
.
œœ& '
lightBlendStyles
œœ' 7
[
œœ7 8
i
œœ8 9
]
œœ9 :
.
œœ: ;
isDirty
œœ; B
)
œœB C
continue
–– 
;
–– 
cmd
““ 
.
““ 
SetRenderTarget
““ #
(
““# $
pass
““$ (
.
““( )
rendererData
““) 5
.
““5 6
lightBlendStyles
““6 F
[
““F G
i
““G H
]
““H I
.
““I J 
renderTargetHandle
““J \
.
““\ ]

Identifier
““] g
(
““g h
)
““h i
)
““i j
;
““j k
cmd
”” 
.
”” 
ClearRenderTarget
”” %
(
””% &
false
””& +
,
””+ ,
true
””- 1
,
””1 2
Color
””3 8
.
””8 9
black
””9 >
)
””> ?
;
””? @
pass
‘‘ 
.
‘‘ 
rendererData
‘‘ !
.
‘‘! "
lightBlendStyles
‘‘" 2
[
‘‘2 3
i
‘‘3 4
]
‘‘4 5
.
‘‘5 6
isDirty
‘‘6 =
=
‘‘> ?
false
‘‘@ E
;
‘‘E F
}
’’ 
}
÷÷ 	
public
ÿÿ 
static
ÿÿ 
void
ÿÿ 
RenderNormals
ÿÿ (
(
ÿÿ( )
this
ÿÿ) -
IRenderPass2D
ÿÿ. ;
pass
ÿÿ< @
,
ÿÿ@ A%
ScriptableRenderContext
ÿÿB Y
context
ÿÿZ a
,
ÿÿa b
CullingResults
ÿÿc q
cullResults
ÿÿr }
,
ÿÿ} ~
DrawingSettingsÿÿ é
drawSettingsÿÿè õ
,ÿÿõ ú!
FilteringSettingsÿÿù Æ
filterSettingsÿÿØ Ω
,ÿÿΩ æ&
RenderTargetIdentifierÿÿø ’
depthTargetÿÿ÷ ·
)ÿÿ· ‚
{
ŸŸ 	
var
⁄⁄ 
cmd
⁄⁄ 
=
⁄⁄ 
CommandBufferPool
⁄⁄ '
.
⁄⁄' (
Get
⁄⁄( +
(
⁄⁄+ ,
)
⁄⁄, -
;
⁄⁄- .
using
€€ 
(
€€ 
new
€€ 
ProfilingScope
€€ %
(
€€% &
cmd
€€& )
,
€€) * 
m_ProfilingSampler
€€+ =
)
€€= >
)
€€> ?
{
‹‹ 
cmd
›› 
.
›› 
SetRenderTarget
›› #
(
››# $
pass
››$ (
.
››( )
rendererData
››) 5
.
››5 6!
normalsRenderTarget
››6 I
.
››I J

Identifier
››J T
(
››T U
)
››U V
,
››V W
depthTarget
››X c
)
››c d
;
››d e
cmd
ﬁﬁ 
.
ﬁﬁ 
ClearRenderTarget
ﬁﬁ %
(
ﬁﬁ% &
true
ﬁﬁ& *
,
ﬁﬁ* +
true
ﬁﬁ, 0
,
ﬁﬁ0 1 
k_NormalClearColor
ﬁﬁ2 D
)
ﬁﬁD E
;
ﬁﬁE F
}
ﬂﬂ 
context
‡‡ 
.
‡‡ "
ExecuteCommandBuffer
‡‡ (
(
‡‡( )
cmd
‡‡) ,
)
‡‡, -
;
‡‡- .
CommandBufferPool
·· 
.
·· 
Release
·· %
(
··% &
cmd
··& )
)
··) *
;
··* +
drawSettings
„„ 
.
„„ 
SetShaderPassName
„„ *
(
„„* +
$num
„„+ ,
,
„„, -(
k_NormalsRenderingPassName
„„. H
)
„„H I
;
„„I J
context
‰‰ 
.
‰‰ 
DrawRenderers
‰‰ !
(
‰‰! "
cullResults
‰‰" -
,
‰‰- .
ref
‰‰/ 2
drawSettings
‰‰3 ?
,
‰‰? @
ref
‰‰A D
filterSettings
‰‰E S
)
‰‰S T
;
‰‰T U
}
ÂÂ 	
public
ÁÁ 
static
ÁÁ 
void
ÁÁ 
RenderLights
ÁÁ '
(
ÁÁ' (
this
ÁÁ( ,
IRenderPass2D
ÁÁ- :
pass
ÁÁ; ?
,
ÁÁ? @
RenderingData
ÁÁA N
renderingData
ÁÁO \
,
ÁÁ\ ]
CommandBuffer
ÁÁ^ k
cmd
ÁÁl o
,
ÁÁo p
int
ÁÁq t
layerToRenderÁÁu Ç
,ÁÁÇ É
uintÁÁÑ à
blendStylesUsedÁÁâ ò
)ÁÁò ô
{
ËË 	
var
ÈÈ 
blendStyles
ÈÈ 
=
ÈÈ 
pass
ÈÈ "
.
ÈÈ" #
rendererData
ÈÈ# /
.
ÈÈ/ 0
lightBlendStyles
ÈÈ0 @
;
ÈÈ@ A
for
ÎÎ 
(
ÎÎ 
var
ÎÎ 
i
ÎÎ 
=
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
i
ÎÎ 
<
ÎÎ 
blendStyles
ÎÎ  +
.
ÎÎ+ ,
Length
ÎÎ, 2
;
ÎÎ2 3
++
ÎÎ4 6
i
ÎÎ6 7
)
ÎÎ7 8
{
ÏÏ 
if
ÌÌ 
(
ÌÌ 
(
ÌÌ 
blendStylesUsed
ÌÌ $
&
ÌÌ% &
(
ÌÌ' (
uint
ÌÌ( ,
)
ÌÌ, -
(
ÌÌ- .
$num
ÌÌ. /
<<
ÌÌ0 2
i
ÌÌ3 4
)
ÌÌ4 5
)
ÌÌ5 6
==
ÌÌ7 9
$num
ÌÌ: ;
)
ÌÌ; <
continue
ÓÓ 
;
ÓÓ 
var
 

sampleName
 
=
  
blendStyles
! ,
[
, -
i
- .
]
. /
.
/ 0
name
0 4
;
4 5
cmd
ÒÒ 
.
ÒÒ 
BeginSample
ÒÒ 
(
ÒÒ  

sampleName
ÒÒ  *
)
ÒÒ* +
;
ÒÒ+ ,
var
ÛÛ 
rtID
ÛÛ 
=
ÛÛ 
pass
ÛÛ 
.
ÛÛ  
rendererData
ÛÛ  ,
.
ÛÛ, -
lightBlendStyles
ÛÛ- =
[
ÛÛ= >
i
ÛÛ> ?
]
ÛÛ? @
.
ÛÛ@ A 
renderTargetHandle
ÛÛA S
.
ÛÛS T

Identifier
ÛÛT ^
(
ÛÛ^ _
)
ÛÛ_ `
;
ÛÛ` a
cmd
ÙÙ 
.
ÙÙ 
SetRenderTarget
ÙÙ #
(
ÙÙ# $
rtID
ÙÙ$ (
)
ÙÙ( )
;
ÙÙ) *
var
ˆˆ 
rtDirty
ˆˆ 
=
ˆˆ 
false
ˆˆ #
;
ˆˆ# $
if
˜˜ 
(
˜˜ 
!
˜˜ 
Light2DManager
˜˜ #
.
˜˜# $
GetGlobalColor
˜˜$ 2
(
˜˜2 3
layerToRender
˜˜3 @
,
˜˜@ A
i
˜˜B C
,
˜˜C D
out
˜˜E H
var
˜˜I L

clearColor
˜˜M W
)
˜˜W X
)
˜˜X Y

clearColor
¯¯ 
=
¯¯  
Color
¯¯! &
.
¯¯& '
black
¯¯' ,
;
¯¯, -
else
˘˘ 
rtDirty
˙˙ 
=
˙˙ 
true
˙˙ "
;
˙˙" #
rtDirty
¸¸ 
|=
¸¸ 
RenderLightSet
¸¸ )
(
¸¸) *
pass
˝˝ 
,
˝˝ 
renderingData
˝˝ '
,
˝˝' (
i
˛˛ 
,
˛˛ 
cmd
ˇˇ 
,
ˇˇ 
layerToRender
ÄÄ !
,
ÄÄ! "
rtID
ÅÅ 
,
ÅÅ 
(
ÇÇ 
pass
ÇÇ 
.
ÇÇ 
rendererData
ÇÇ &
.
ÇÇ& '
lightBlendStyles
ÇÇ' 7
[
ÇÇ7 8
i
ÇÇ8 9
]
ÇÇ9 :
.
ÇÇ: ;
isDirty
ÇÇ; B
||
ÇÇC E
rtDirty
ÇÇF M
)
ÇÇM N
,
ÇÇN O

clearColor
ÉÉ 
,
ÉÉ 
pass
ÑÑ 
.
ÑÑ 
rendererData
ÑÑ %
.
ÑÑ% &
lightCullResult
ÑÑ& 5
.
ÑÑ5 6
visibleLights
ÑÑ6 C
)
ÖÖ 
;
ÖÖ 
pass
áá 
.
áá 
rendererData
áá !
.
áá! "
lightBlendStyles
áá" 2
[
áá2 3
i
áá3 4
]
áá4 5
.
áá5 6
isDirty
áá6 =
=
áá> ?
rtDirty
áá@ G
;
ááG H
cmd
ââ 
.
ââ 
	EndSample
ââ 
(
ââ 

sampleName
ââ (
)
ââ( )
;
ââ) *
}
ää 
}
ãã 	
public
çç 
static
çç 
void
çç  
RenderLightVolumes
çç -
(
çç- .
this
çç. 2
IRenderPass2D
çç3 @
pass
ççA E
,
ççE F
RenderingData
ççG T
renderingData
ççU b
,
ççb c
CommandBuffer
ççd q
cmd
ççr u
,
ççu v
int
ççw z
layerToRenderçç{ à
,ççà â&
RenderTargetIdentifierççä †
renderTargetçç° ≠
,çç≠ Æ&
RenderTargetIdentifierççØ ≈
depthTargetçç∆ —
,çç— “
uintçç” ◊
blendStylesUsedççÿ Á
)ççÁ Ë
{
éé 	
var
èè 
blendStyles
èè 
=
èè 
pass
èè "
.
èè" #
rendererData
èè# /
.
èè/ 0
lightBlendStyles
èè0 @
;
èè@ A
for
ëë 
(
ëë 
var
ëë 
i
ëë 
=
ëë 
$num
ëë 
;
ëë 
i
ëë 
<
ëë 
blendStyles
ëë  +
.
ëë+ ,
Length
ëë, 2
;
ëë2 3
++
ëë4 6
i
ëë6 7
)
ëë7 8
{
íí 
if
ìì 
(
ìì 
(
ìì 
blendStylesUsed
ìì $
&
ìì% &
(
ìì' (
uint
ìì( ,
)
ìì, -
(
ìì- .
$num
ìì. /
<<
ìì0 2
i
ìì3 4
)
ìì4 5
)
ìì5 6
==
ìì7 9
$num
ìì: ;
)
ìì; <
continue
îî 
;
îî 
string
ññ 

sampleName
ññ !
=
ññ" #
blendStyles
ññ$ /
[
ññ/ 0
i
ññ0 1
]
ññ1 2
.
ññ2 3
name
ññ3 7
;
ññ7 8
cmd
óó 
.
óó 
BeginSample
óó 
(
óó  

sampleName
óó  *
)
óó* +
;
óó+ ,"
RenderLightVolumeSet
ôô $
(
ôô$ %
pass
öö 
,
öö 
renderingData
öö '
,
öö' (
i
õõ 
,
õõ 
cmd
úú 
,
úú 
layerToRender
ùù !
,
ùù! "
renderTarget
ûû  
,
ûû  !
depthTarget
üü 
,
üü  
pass
†† 
.
†† 
rendererData
†† %
.
††% &
lightCullResult
††& 5
.
††5 6
visibleLights
††6 C
)
°° 
;
°° 
cmd
££ 
.
££ 
	EndSample
££ 
(
££ 

sampleName
££ (
)
££( )
;
££) *
}
§§ 
}
•• 	
private
ßß 
static
ßß 
void
ßß 
SetBlendModes
ßß )
(
ßß) *
Material
ßß* 2
material
ßß3 ;
,
ßß; <
	BlendMode
ßß= F
src
ßßG J
,
ßßJ K
	BlendMode
ßßL U
dst
ßßV Y
)
ßßY Z
{
®® 	
material
©© 
.
©© 
SetFloat
©© 
(
©© 
k_SrcBlendID
©© *
,
©©* +
(
©©, -
float
©©- 2
)
©©2 3
src
©©3 6
)
©©6 7
;
©©7 8
material
™™ 
.
™™ 
SetFloat
™™ 
(
™™ 
k_DstBlendID
™™ *
,
™™* +
(
™™, -
float
™™- 2
)
™™2 3
dst
™™3 6
)
™™6 7
;
™™7 8
}
´´ 	
private
≠≠ 
static
≠≠ 
uint
≠≠ #
GetLightMaterialIndex
≠≠ 1
(
≠≠1 2
Light2D
≠≠2 9
light
≠≠: ?
,
≠≠? @
bool
≠≠A E
isVolume
≠≠F N
)
≠≠N O
{
ÆÆ 	
var
ØØ 
isPoint
ØØ 
=
ØØ 
light
ØØ 
.
ØØ  
isPointLight
ØØ  ,
;
ØØ, -
var
∞∞ 
bitIndex
∞∞ 
=
∞∞ 
$num
∞∞ 
;
∞∞ 
var
±± 
	volumeBit
±± 
=
±± 
isVolume
±± $
?
±±% &
$num
±±' )
<<
±±* ,
bitIndex
±±- 5
:
±±6 7
$num
±±8 :
;
±±: ;
bitIndex
≤≤ 
++
≤≤ 
;
≤≤ 
var
≥≥ 
shapeBit
≥≥ 
=
≥≥ 
!
≥≥ 
isPoint
≥≥ #
?
≥≥$ %
$num
≥≥& (
<<
≥≥) +
bitIndex
≥≥, 4
:
≥≥5 6
$num
≥≥7 9
;
≥≥9 :
bitIndex
¥¥ 
++
¥¥ 
;
¥¥ 
var
µµ 
additiveBit
µµ 
=
µµ 
light
µµ #
.
µµ# $!
alphaBlendOnOverlap
µµ$ 7
?
µµ8 9
$num
µµ: <
:
µµ= >
$num
µµ? A
<<
µµB D
bitIndex
µµE M
;
µµM N
bitIndex
∂∂ 
++
∂∂ 
;
∂∂ 
var
∑∑ 
	spriteBit
∑∑ 
=
∑∑ 
light
∑∑ !
.
∑∑! "
	lightType
∑∑" +
==
∑∑, .
Light2D
∑∑/ 6
.
∑∑6 7
	LightType
∑∑7 @
.
∑∑@ A
Sprite
∑∑A G
?
∑∑H I
$num
∑∑J L
<<
∑∑M O
bitIndex
∑∑P X
:
∑∑Y Z
$num
∑∑[ ]
;
∑∑] ^
bitIndex
∏∏ 
++
∏∏ 
;
∏∏ 
var
ππ 
pointCookieBit
ππ 
=
ππ  
(
ππ! "
isPoint
ππ" )
&&
ππ* ,
light
ππ- 2
.
ππ2 3
lightCookieSprite
ππ3 D
!=
ππE G
null
ππH L
&&
ππM O
light
ππP U
.
ππU V
lightCookieSprite
ππV g
.
ππg h
texture
ππh o
!=
ππp r
null
ππs w
)
ππw x
?
ππy z
$num
ππ{ }
<<ππ~ Ä
bitIndexππÅ â
:ππä ã
$numππå é
;ππé è
bitIndex
∫∫ 
++
∫∫ 
;
∫∫ 
var
ªª !
pointFastQualityBit
ªª #
=
ªª$ %
(
ªª& '
isPoint
ªª' .
&&
ªª/ 1
light
ªª2 7
.
ªª7 8
pointLightQuality
ªª8 I
==
ªªJ L
Light2D
ªªM T
.
ªªT U
PointLightQuality
ªªU f
.
ªªf g
Fast
ªªg k
)
ªªk l
?
ªªm n
$num
ªªo q
<<
ªªr t
bitIndex
ªªu }
:
ªª~ 
$numªªÄ Ç
;ªªÇ É
bitIndex
ºº 
++
ºº 
;
ºº 
var
ΩΩ 
useNormalMap
ΩΩ 
=
ΩΩ 
light
ΩΩ $
.
ΩΩ$ %
useNormalMap
ΩΩ% 1
?
ΩΩ2 3
$num
ΩΩ4 6
<<
ΩΩ7 9
bitIndex
ΩΩ: B
:
ΩΩC D
$num
ΩΩE G
;
ΩΩG H
return
øø !
pointFastQualityBit
øø &
|
øø' (
pointCookieBit
øø) 7
|
øø8 9
	spriteBit
øø: C
|
øøD E
additiveBit
øøF Q
|
øøR S
shapeBit
øøT \
|
øø] ^
	volumeBit
øø_ h
|
øøi j
useNormalMap
øøk w
;
øøw x
}
¿¿ 	
private
¬¬ 
static
¬¬ 
Material
¬¬ !
CreateLightMaterial
¬¬  3
(
¬¬3 4
Renderer2DData
¬¬4 B
rendererData
¬¬C O
,
¬¬O P
Light2D
¬¬Q X
light
¬¬Y ^
,
¬¬^ _
bool
¬¬` d
isVolume
¬¬e m
)
¬¬m n
{
√√ 	
var
ƒƒ 
isPoint
ƒƒ 
=
ƒƒ 
light
ƒƒ 
.
ƒƒ  
isPointLight
ƒƒ  ,
;
ƒƒ, -
Material
≈≈ 
material
≈≈ 
;
≈≈ 
if
«« 
(
«« 
isVolume
«« 
)
«« 
material
»» 
=
»» 
	CoreUtils
»» $
.
»»$ %"
CreateEngineMaterial
»»% 9
(
»»9 :
isPoint
»»: A
?
»»B C
rendererData
»»D P
.
»»P Q$
pointLightVolumeShader
»»Q g
:
»»h i
rendererData
»»j v
.
»»v w%
shapeLightVolumeShader»»w ç
)»»ç é
;»»é è
else
…… 
{
   
material
ÀÀ 
=
ÀÀ 
	CoreUtils
ÀÀ $
.
ÀÀ$ %"
CreateEngineMaterial
ÀÀ% 9
(
ÀÀ9 :
isPoint
ÀÀ: A
?
ÀÀB C
rendererData
ÀÀD P
.
ÀÀP Q
pointLightShader
ÀÀQ a
:
ÀÀb c
rendererData
ÀÀd p
.
ÀÀp q
shapeLightShaderÀÀq Å
)ÀÀÅ Ç
;ÀÀÇ É
if
ÕÕ 
(
ÕÕ 
!
ÕÕ 
light
ÕÕ 
.
ÕÕ !
alphaBlendOnOverlap
ÕÕ .
)
ÕÕ. /
{
ŒŒ 
SetBlendModes
œœ !
(
œœ! "
material
œœ" *
,
œœ* +
	BlendMode
œœ, 5
.
œœ5 6
One
œœ6 9
,
œœ9 :
	BlendMode
œœ; D
.
œœD E
One
œœE H
)
œœH I
;
œœI J
material
–– 
.
–– 
EnableKeyword
–– *
(
––* +*
k_UseAdditiveBlendingKeyword
––+ G
)
––G H
;
––H I
}
—— 
else
““ 
SetBlendModes
”” !
(
””! "
material
””" *
,
””* +
	BlendMode
””, 5
.
””5 6
SrcAlpha
””6 >
,
””> ?
	BlendMode
””@ I
.
””I J
OneMinusSrcAlpha
””J Z
)
””Z [
;
””[ \
}
‘‘ 
if
÷÷ 
(
÷÷ 
light
÷÷ 
.
÷÷ 
	lightType
÷÷ 
==
÷÷  "
Light2D
÷÷# *
.
÷÷* +
	LightType
÷÷+ 4
.
÷÷4 5
Sprite
÷÷5 ;
)
÷÷; <
material
◊◊ 
.
◊◊ 
EnableKeyword
◊◊ &
(
◊◊& '"
k_SpriteLightKeyword
◊◊' ;
)
◊◊; <
;
◊◊< =
if
ŸŸ 
(
ŸŸ 
isPoint
ŸŸ 
&&
ŸŸ 
light
ŸŸ  
.
ŸŸ  !
lightCookieSprite
ŸŸ! 2
!=
ŸŸ3 5
null
ŸŸ6 :
&&
ŸŸ; =
light
ŸŸ> C
.
ŸŸC D
lightCookieSprite
ŸŸD U
.
ŸŸU V
texture
ŸŸV ]
!=
ŸŸ^ `
null
ŸŸa e
)
ŸŸe f
material
⁄⁄ 
.
⁄⁄ 
EnableKeyword
⁄⁄ &
(
⁄⁄& '+
k_UsePointLightCookiesKeyword
⁄⁄' D
)
⁄⁄D E
;
⁄⁄E F
if
‹‹ 
(
‹‹ 
isPoint
‹‹ 
&&
‹‹ 
light
‹‹  
.
‹‹  !
pointLightQuality
‹‹! 2
==
‹‹3 5
Light2D
‹‹6 =
.
‹‹= >
PointLightQuality
‹‹> O
.
‹‹O P
Fast
‹‹P T
)
‹‹T U
material
›› 
.
›› 
EnableKeyword
›› &
(
››& ''
k_LightQualityFastKeyword
››' @
)
››@ A
;
››A B
if
ﬂﬂ 
(
ﬂﬂ 
light
ﬂﬂ 
.
ﬂﬂ 
useNormalMap
ﬂﬂ "
)
ﬂﬂ" #
material
‡‡ 
.
‡‡ 
EnableKeyword
‡‡ &
(
‡‡& '
k_UseNormalMap
‡‡' 5
)
‡‡5 6
;
‡‡6 7
return
‚‚ 
material
‚‚ 
;
‚‚ 
}
„„ 	
private
ÂÂ 
static
ÂÂ 
Material
ÂÂ 
GetLightMaterial
ÂÂ  0
(
ÂÂ0 1
this
ÂÂ1 5
Renderer2DData
ÂÂ6 D
rendererData
ÂÂE Q
,
ÂÂQ R
Light2D
ÂÂS Z
light
ÂÂ[ `
,
ÂÂ` a
bool
ÂÂb f
isVolume
ÂÂg o
)
ÂÂo p
{
ÊÊ 	
var
ÁÁ 
materialIndex
ÁÁ 
=
ÁÁ #
GetLightMaterialIndex
ÁÁ  5
(
ÁÁ5 6
light
ÁÁ6 ;
,
ÁÁ; <
isVolume
ÁÁ= E
)
ÁÁE F
;
ÁÁF G
if
ÈÈ 
(
ÈÈ 
!
ÈÈ 
rendererData
ÈÈ 
.
ÈÈ 
lightMaterials
ÈÈ ,
.
ÈÈ, -
TryGetValue
ÈÈ- 8
(
ÈÈ8 9
materialIndex
ÈÈ9 F
,
ÈÈF G
out
ÈÈH K
var
ÈÈL O
material
ÈÈP X
)
ÈÈX Y
)
ÈÈY Z
{
ÍÍ 
material
ÎÎ 
=
ÎÎ !
CreateLightMaterial
ÎÎ .
(
ÎÎ. /
rendererData
ÎÎ/ ;
,
ÎÎ; <
light
ÎÎ= B
,
ÎÎB C
isVolume
ÎÎD L
)
ÎÎL M
;
ÎÎM N
rendererData
ÏÏ 
.
ÏÏ 
lightMaterials
ÏÏ +
[
ÏÏ+ ,
materialIndex
ÏÏ, 9
]
ÏÏ9 :
=
ÏÏ; <
material
ÏÏ= E
;
ÏÏE F
}
ÌÌ 
return
ÔÔ 
material
ÔÔ 
;
ÔÔ 
}
 	
}
ÒÒ 
}ÚÚ ¥Ø
¢D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\PixelPerfectCamera.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
[		 %
DisallowMultipleComponent		 
]		 
[

 
AddComponentMenu

 
(

 
$str

 H
)

H I
]

I J
[ 
RequireComponent 
( 
typeof 
( 
Camera #
)# $
)$ %
]% &
[ 
	MovedFrom 
( 
$str 8
)8 9
]9 :
[ 
HelpURL 
( 
$str	 õ
)
õ ú
]
ú ù
public 

class 
PixelPerfectCamera #
:$ %
MonoBehaviour& 3
,3 4
IPixelPerfectCamera5 H
{ 
public 
int 
	assetsPPU 
{ 
get "
{# $
return% +
m_AssetsPPU, 7
;7 8
}9 :
set; >
{? @
m_AssetsPPUA L
=M N
valueO T
>U V
$numW X
?Y Z
value[ `
:a b
$numc d
;d e
}f g
}h i
public 
int 
refResolutionX !
{" #
get$ '
{( )
return* 0
m_RefResolutionX1 A
;A B
}C D
setE H
{I J
m_RefResolutionXK [
=\ ]
value^ c
>d e
$numf g
?h i
valuej o
:p q
$numr s
;s t
}u v
}w x
public 
int 
refResolutionY !
{" #
get$ '
{( )
return* 0
m_RefResolutionY1 A
;A B
}C D
setE H
{I J
m_RefResolutionYK [
=\ ]
value^ c
>d e
$numf g
?h i
valuej o
:p q
$numr s
;s t
}u v
}w x
public## 
bool## 
	upscaleRT## 
{## 
get##  #
{##$ %
return##& ,
m_UpscaleRT##- 8
;##8 9
}##: ;
set##< ?
{##@ A
m_UpscaleRT##B M
=##N O
value##P U
;##U V
}##W X
}##Y Z
public)) 
bool)) 
pixelSnapping)) !
{))" #
get))$ '
{))( )
return))* 0
m_PixelSnapping))1 @
;))@ A
}))B C
set))D G
{))H I
m_PixelSnapping))J Y
=))Z [
value))\ a
;))a b
}))c d
}))e f
public.. 
bool.. 

cropFrameX.. 
{..  
get..! $
{..% &
return..' -
m_CropFrameX... :
;..: ;
}..< =
set..> A
{..B C
m_CropFrameX..D P
=..Q R
value..S X
;..X Y
}..Z [
}..\ ]
public33 
bool33 

cropFrameY33 
{33  
get33! $
{33% &
return33' -
m_CropFrameY33. :
;33: ;
}33< =
set33> A
{33B C
m_CropFrameY33D P
=33Q R
value33S X
;33X Y
}33Z [
}33\ ]
public99 
bool99 
stretchFill99 
{99  !
get99" %
{99& '
return99( .
m_StretchFill99/ <
;99< =
}99> ?
set99@ C
{99D E
m_StretchFill99F S
=99T U
value99V [
;99[ \
}99] ^
}99_ `
public>> 
int>> 

pixelRatio>> 
{?? 	
get@@ 
{AA 
ifBB 
(BB *
m_CinemachineCompatibilityModeBB 2
)BB2 3
{CC 
ifDD 
(DD 
m_UpscaleRTDD #
)DD# $
returnEE 

m_InternalEE )
.EE) *
zoomEE* .
*EE/ 0

m_InternalEE1 ;
.EE; <
cinemachineVCamZoomEE< O
;EEO P
elseFF 
returnGG 

m_InternalGG )
.GG) *
cinemachineVCamZoomGG* =
;GG= >
}HH 
elseII 
{JJ 
returnKK 

m_InternalKK %
.KK% &
zoomKK& *
;KK* +
}LL 
}MM 
}NN 	
publicXX 
Vector3XX 
RoundToPixelXX #
(XX# $
Vector3XX$ +
positionXX, 4
)XX4 5
{YY 	
floatZZ 
unitsPerPixelZZ 
=ZZ  !

m_InternalZZ" ,
.ZZ, -
unitsPerPixelZZ- :
;ZZ: ;
if[[ 
([[ 
unitsPerPixel[[ 
==[[  
$num[[! %
)[[% &
return\\ 
position\\ 
;\\  
Vector3^^ 
result^^ 
;^^ 
result__ 
.__ 
x__ 
=__ 
Mathf__ 
.__ 
Round__ "
(__" #
position__# +
.__+ ,
x__, -
/__. /
unitsPerPixel__0 =
)__= >
*__? @
unitsPerPixel__A N
;__N O
result`` 
.`` 
y`` 
=`` 
Mathf`` 
.`` 
Round`` "
(``" #
position``# +
.``+ ,
y``, -
/``. /
unitsPerPixel``0 =
)``= >
*``? @
unitsPerPixel``A N
;``N O
resultaa 
.aa 
zaa 
=aa 
Mathfaa 
.aa 
Roundaa "
(aa" #
positionaa# +
.aa+ ,
zaa, -
/aa. /
unitsPerPixelaa0 =
)aa= >
*aa? @
unitsPerPixelaaA N
;aaN O
returncc 
resultcc 
;cc 
}dd 	
publickk 
floatkk '
CorrectCinemachineOrthoSizekk 0
(kk0 1
floatkk1 6
targetOrthoSizekk7 F
)kkF G
{ll 	*
m_CinemachineCompatibilityModemm *
=mm+ ,
truemm- 1
;mm1 2
ifoo 
(oo 

m_Internaloo 
==oo 
nulloo "
)oo" #
returnpp 
targetOrthoSizepp &
;pp& '
elseqq 
returnrr 

m_Internalrr !
.rr! "'
CorrectCinemachineOrthoSizerr" =
(rr= >
targetOrthoSizerr> M
)rrM N
;rrN O
}ss 	
[uu 	
SerializeFielduu	 
]uu 
intuu 
m_AssetsPPUuu  +
=uu4 5
$numuu6 9
;uu9 :
[vv 	
SerializeFieldvv	 
]vv 
intvv 
m_RefResolutionXvv  0
=vv4 5
$numvv6 9
;vv9 :
[ww 	
SerializeFieldww	 
]ww 
intww 
m_RefResolutionYww  0
=ww4 5
$numww6 9
;ww9 :
[xx 	
SerializeFieldxx	 
]xx 
boolxx 
m_UpscaleRTxx  +
;xx+ ,
[yy 	
SerializeFieldyy	 
]yy 
boolyy 
m_PixelSnappingyy  /
;yy/ 0
[zz 	
SerializeFieldzz	 
]zz 
boolzz 
m_CropFrameXzz  ,
;zz, -
[{{ 	
SerializeField{{	 
]{{ 
bool{{ 
m_CropFrameY{{  ,
;{{, -
[|| 	
SerializeField||	 
]|| 
bool|| 
m_StretchFill||  -
;||- .
Camera~~ 
m_Camera~~ 
;~~ &
PixelPerfectCameraInternal "

m_Internal# -
;- .
bool
ÄÄ ,
m_CinemachineCompatibilityMode
ÄÄ +
;
ÄÄ+ ,
internal
ÇÇ 
bool
ÇÇ 
	isRunning
ÇÇ 
{
ÉÉ 	
get
ÑÑ 
{
ÖÖ 
return
áá 
(
áá 
Application
áá #
.
áá# $
	isPlaying
áá$ -
||
áá. 0
runInEditMode
áá1 >
)
áá> ?
&&
áá@ B
enabled
ááC J
;
ááJ K
}
ãã 
}
åå 	
internal
éé 

FilterMode
éé !
finalBlitFilterMode
éé /
{
èè 	
get
êê 
{
ëë 
if
íí 
(
íí 
!
íí 
	isRunning
íí 
)
íí 
return
ìì 

FilterMode
ìì %
.
ìì% &
Bilinear
ìì& .
;
ìì. /
else
îî 
return
ïï 

m_Internal
ïï %
.
ïï% &
useStretchFill
ïï& 4
?
ïï5 6

FilterMode
ïï7 A
.
ïïA B
Bilinear
ïïB J
:
ïïK L

FilterMode
ïïM W
.
ïïW X
Point
ïïX ]
;
ïï] ^
}
ññ 
}
óó 	
internal
ôô 

Vector2Int
ôô 
offscreenRTSize
ôô +
{
öö 	
get
õõ 
{
úú 
if
ùù 
(
ùù 
!
ùù 
	isRunning
ùù 
)
ùù 
return
ûû 

Vector2Int
ûû %
.
ûû% &
zero
ûû& *
;
ûû* +
else
üü 
return
†† 
new
†† 

Vector2Int
†† )
(
††) *

m_Internal
††* 4
.
††4 5
offscreenRTWidth
††5 E
,
††E F

m_Internal
††G Q
.
††Q R
offscreenRTHeight
††R c
)
††c d
;
††d e
}
°° 
}
¢¢ 	
void
•• 
	PixelSnap
•• 
(
•• 
)
•• 
{
¶¶ 	
Vector3
ßß 
cameraPosition
ßß "
=
ßß# $
m_Camera
ßß% -
.
ßß- .
	transform
ßß. 7
.
ßß7 8
position
ßß8 @
;
ßß@ A
Vector3
®® #
roundedCameraPosition
®® )
=
®®* +
RoundToPixel
®®, 8
(
®®8 9
cameraPosition
®®9 G
)
®®G H
;
®®H I
Vector3
©© 
offset
©© 
=
©© #
roundedCameraPosition
©© 2
-
©©3 4
cameraPosition
©©5 C
;
©©C D
offset
™™ 
.
™™ 
z
™™ 
=
™™ 
-
™™ 
offset
™™ 
.
™™ 
z
™™  
;
™™  !
	Matrix4x4
´´ 
offsetMatrix
´´ "
=
´´# $
	Matrix4x4
´´% .
.
´´. /
TRS
´´/ 2
(
´´2 3
-
´´3 4
offset
´´4 :
,
´´: ;

Quaternion
´´< F
.
´´F G
identity
´´G O
,
´´O P
new
´´Q T
Vector3
´´U \
(
´´\ ]
$num
´´] a
,
´´a b
$num
´´c g
,
´´g h
-
´´i j
$num
´´j n
)
´´n o
)
´´o p
;
´´p q
m_Camera
≠≠ 
.
≠≠ !
worldToCameraMatrix
≠≠ (
=
≠≠) *
offsetMatrix
≠≠+ 7
*
≠≠8 9
m_Camera
≠≠: B
.
≠≠B C
	transform
≠≠C L
.
≠≠L M 
worldToLocalMatrix
≠≠M _
;
≠≠_ `
}
ÆÆ 	
void
∞∞ 
Awake
∞∞ 
(
∞∞ 
)
∞∞ 
{
±± 	
m_Camera
≤≤ 
=
≤≤ 
GetComponent
≤≤ #
<
≤≤# $
Camera
≤≤$ *
>
≤≤* +
(
≤≤+ ,
)
≤≤, -
;
≤≤- .

m_Internal
≥≥ 
=
≥≥ 
new
≥≥ (
PixelPerfectCameraInternal
≥≥ 7
(
≥≥7 8
this
≥≥8 <
)
≥≥< =
;
≥≥= >

m_Internal
µµ 
.
µµ 
originalOrthoSize
µµ (
=
µµ) *
m_Camera
µµ+ 3
.
µµ3 4
orthographicSize
µµ4 D
;
µµD E
}
∂∂ 	
void
∏∏ $
OnBeginCameraRendering
∏∏ #
(
∏∏# $%
ScriptableRenderContext
∏∏$ ;
context
∏∏< C
,
∏∏C D
Camera
∏∏E K
camera
∏∏L R
)
∏∏R S
{
ππ 	
if
∫∫ 
(
∫∫ 
camera
∫∫ 
!=
∫∫ 
m_Camera
∫∫ "
)
∫∫" #
return
ªª 
;
ªª 
var
ΩΩ 
targetTexture
ΩΩ 
=
ΩΩ 
m_Camera
ΩΩ  (
.
ΩΩ( )
targetTexture
ΩΩ) 6
;
ΩΩ6 7

Vector2Int
ææ 
rtSize
ææ 
=
ææ 
targetTexture
ææ  -
==
ææ. 0
null
ææ1 5
?
ææ6 7
new
ææ8 ;

Vector2Int
ææ< F
(
ææF G
Screen
ææG M
.
ææM N
width
ææN S
,
ææS T
Screen
ææU [
.
ææ[ \
height
ææ\ b
)
ææb c
:
ææd e
new
ææf i

Vector2Int
ææj t
(
ææt u
targetTextureææu Ç
.ææÇ É
widthææÉ à
,ææà â
targetTextureææä ó
.ææó ò
heightææò û
)ææû ü
;ææü †

m_Internal
¿¿ 
.
¿¿ '
CalculateCameraProperties
¿¿ 0
(
¿¿0 1
rtSize
¿¿1 7
.
¿¿7 8
x
¿¿8 9
,
¿¿9 :
rtSize
¿¿; A
.
¿¿A B
y
¿¿B C
)
¿¿C D
;
¿¿D E
	PixelSnap
¬¬ 
(
¬¬ 
)
¬¬ 
;
¬¬ 
if
ƒƒ 
(
ƒƒ 

m_Internal
ƒƒ 
.
ƒƒ 
useOffscreenRT
ƒƒ )
)
ƒƒ) *
m_Camera
≈≈ 
.
≈≈ 
	pixelRect
≈≈ "
=
≈≈# $

m_Internal
≈≈% /
.
≈≈/ 0)
CalculateFinalBlitPixelRect
≈≈0 K
(
≈≈K L
rtSize
≈≈L R
.
≈≈R S
x
≈≈S T
,
≈≈T U
rtSize
≈≈V \
.
≈≈\ ]
y
≈≈] ^
)
≈≈^ _
;
≈≈_ `
else
∆∆ 
m_Camera
«« 
.
«« 
rect
«« 
=
«« 
new
««  #
Rect
««$ (
(
««( )
$num
««) -
,
««- .
$num
««/ 3
,
««3 4
$num
««5 9
,
««9 :
$num
««; ?
)
««? @
;
««@ A
if
ÕÕ 
(
ÕÕ 
!
ÕÕ ,
m_CinemachineCompatibilityMode
ÕÕ /
)
ÕÕ/ 0
{
ŒŒ 
m_Camera
œœ 
.
œœ 
orthographicSize
œœ )
=
œœ* +

m_Internal
œœ, 6
.
œœ6 7
	orthoSize
œœ7 @
;
œœ@ A
}
–– 
UnityEngine
““ 
.
““ 
U2D
““ 
.
““ #
PixelPerfectRendering
““ 1
.
““1 2
pixelSnapSpacing
““2 B
=
““C D

m_Internal
““E O
.
““O P
unitsPerPixel
““P ]
;
““] ^
}
”” 	
void
’’ "
OnEndCameraRendering
’’ !
(
’’! "%
ScriptableRenderContext
’’" 9
context
’’: A
,
’’A B
Camera
’’C I
camera
’’J P
)
’’P Q
{
÷÷ 	
if
◊◊ 
(
◊◊ 
camera
◊◊ 
==
◊◊ 
m_Camera
◊◊ "
)
◊◊" #
UnityEngine
ÿÿ 
.
ÿÿ 
U2D
ÿÿ 
.
ÿÿ  #
PixelPerfectRendering
ÿÿ  5
.
ÿÿ5 6
pixelSnapSpacing
ÿÿ6 F
=
ÿÿG H
$num
ÿÿI M
;
ÿÿM N
}
ŸŸ 	
void
€€ 
OnEnable
€€ 
(
€€ 
)
€€ 
{
‹‹ 	,
m_CinemachineCompatibilityMode
›› *
=
››+ ,
false
››- 2
;
››2 3#
RenderPipelineManager
ﬂﬂ !
.
ﬂﬂ! ""
beginCameraRendering
ﬂﬂ" 6
+=
ﬂﬂ7 9$
OnBeginCameraRendering
ﬂﬂ: P
;
ﬂﬂP Q#
RenderPipelineManager
‡‡ !
.
‡‡! " 
endCameraRendering
‡‡" 4
+=
‡‡5 7"
OnEndCameraRendering
‡‡8 L
;
‡‡L M
if
„„ 
(
„„ 
!
„„ 
UnityEditor
„„ 
.
„„ 
EditorApplication
„„ .
.
„„. /
	isPlaying
„„/ 8
)
„„8 9
UnityEditor
‰‰ 
.
‰‰ 
EditorApplication
‰‰ -
.
‰‰- ."
playModeStateChanged
‰‰. B
+=
‰‰C E
OnPlayModeChanged
‰‰F W
;
‰‰W X
}
ÊÊ 	
internal
ËË 
void
ËË 
	OnDisable
ËË 
(
ËË  
)
ËË  !
{
ÈÈ 	#
RenderPipelineManager
ÍÍ !
.
ÍÍ! ""
beginCameraRendering
ÍÍ" 6
-=
ÍÍ7 9$
OnBeginCameraRendering
ÍÍ: P
;
ÍÍP Q#
RenderPipelineManager
ÎÎ !
.
ÎÎ! " 
endCameraRendering
ÎÎ" 4
-=
ÎÎ5 7"
OnEndCameraRendering
ÎÎ8 L
;
ÎÎL M
m_Camera
ÌÌ 
.
ÌÌ 
rect
ÌÌ 
=
ÌÌ 
new
ÌÌ 
Rect
ÌÌ  $
(
ÌÌ$ %
$num
ÌÌ% )
,
ÌÌ) *
$num
ÌÌ+ /
,
ÌÌ/ 0
$num
ÌÌ1 5
,
ÌÌ5 6
$num
ÌÌ7 ;
)
ÌÌ; <
;
ÌÌ< =
m_Camera
ÓÓ 
.
ÓÓ 
orthographicSize
ÓÓ %
=
ÓÓ& '

m_Internal
ÓÓ( 2
.
ÓÓ2 3
originalOrthoSize
ÓÓ3 D
;
ÓÓD E
m_Camera
ÔÔ 
.
ÔÔ &
ResetWorldToCameraMatrix
ÔÔ -
(
ÔÔ- .
)
ÔÔ. /
;
ÔÔ/ 0
if
ÚÚ 
(
ÚÚ 
!
ÚÚ 
UnityEditor
ÚÚ 
.
ÚÚ 
EditorApplication
ÚÚ .
.
ÚÚ. /
	isPlaying
ÚÚ/ 8
)
ÚÚ8 9
UnityEditor
ÛÛ 
.
ÛÛ 
EditorApplication
ÛÛ -
.
ÛÛ- ."
playModeStateChanged
ÛÛ. B
-=
ÛÛC E
OnPlayModeChanged
ÛÛF W
;
ÛÛW X
}
ıı 	
void
˘˘ 
OnGUI
˘˘ 
(
˘˘ 
)
˘˘ 
{
˙˙ 	
if
¸¸ 
(
¸¸ 
!
¸¸ 
UnityEditor
¸¸ 
.
¸¸ 
EditorApplication
¸¸ .
.
¸¸. /
	isPlaying
¸¸/ 8
&&
¸¸9 ;
!
¸¸< =
runInEditMode
¸¸= J
)
¸¸J K
return
˝˝ 
;
˝˝ 
Color
ÄÄ 
oldColor
ÄÄ 
=
ÄÄ 
GUI
ÄÄ  
.
ÄÄ  !
color
ÄÄ! &
;
ÄÄ& '
GUI
ÅÅ 
.
ÅÅ 
color
ÅÅ 
=
ÅÅ 
Color
ÅÅ 
.
ÅÅ 
red
ÅÅ !
;
ÅÅ! "

Vector2Int
ÉÉ 
renderResolution
ÉÉ '
=
ÉÉ( )

Vector2Int
ÉÉ* 4
.
ÉÉ4 5
zero
ÉÉ5 9
;
ÉÉ9 :
renderResolution
ÑÑ 
.
ÑÑ 
x
ÑÑ 
=
ÑÑ  

m_Internal
ÑÑ! +
.
ÑÑ+ ,
useOffscreenRT
ÑÑ, :
?
ÑÑ; <

m_Internal
ÑÑ= G
.
ÑÑG H
offscreenRTWidth
ÑÑH X
:
ÑÑY Z
m_Camera
ÑÑ[ c
.
ÑÑc d

pixelWidth
ÑÑd n
;
ÑÑn o
renderResolution
ÖÖ 
.
ÖÖ 
y
ÖÖ 
=
ÖÖ  

m_Internal
ÖÖ! +
.
ÖÖ+ ,
useOffscreenRT
ÖÖ, :
?
ÖÖ; <

m_Internal
ÖÖ= G
.
ÖÖG H
offscreenRTHeight
ÖÖH Y
:
ÖÖZ [
m_Camera
ÖÖ\ d
.
ÖÖd e
pixelHeight
ÖÖe p
;
ÖÖp q
if
áá 
(
áá 
renderResolution
áá  
.
áá  !
x
áá! "
%
áá# $
$num
áá% &
!=
áá' )
$num
áá* +
||
áá, .
renderResolution
áá/ ?
.
áá? @
y
áá@ A
%
ááB C
$num
ááD E
!=
ááF H
$num
ááI J
)
ááJ K
{
àà 
string
ââ 
warning
ââ 
=
ââ  
string
ââ! '
.
ââ' (
Format
ââ( .
(
ââ. /
$strââ/ £
,ââ£ § 
renderResolutionââ• µ
.ââµ ∂
xââ∂ ∑
,ââ∑ ∏ 
renderResolutionââπ …
.ââ…  
yââ  À
)ââÀ Ã
;ââÃ Õ
	GUILayout
ää 
.
ää 
Box
ää 
(
ää 
warning
ää %
)
ää% &
;
ää& '
}
ãã 
var
çç 
targetTexture
çç 
=
çç 
m_Camera
çç  (
.
çç( )
targetTexture
çç) 6
;
çç6 7

Vector2Int
éé 
rtSize
éé 
=
éé 
targetTexture
éé  -
==
éé. 0
null
éé1 5
?
éé6 7
new
éé8 ;

Vector2Int
éé< F
(
ééF G
Screen
ééG M
.
ééM N
width
ééN S
,
ééS T
Screen
ééU [
.
éé[ \
height
éé\ b
)
ééb c
:
ééd e
new
ééf i

Vector2Int
ééj t
(
éét u
targetTextureééu Ç
.ééÇ É
widthééÉ à
,ééà â
targetTextureééä ó
.ééó ò
heightééò û
)ééû ü
;ééü †
if
êê 
(
êê 
rtSize
êê 
.
êê 
x
êê 
<
êê 
refResolutionX
êê )
||
êê* ,
rtSize
êê- 3
.
êê3 4
y
êê4 5
<
êê6 7
refResolutionY
êê8 F
)
êêF G
{
ëë 
	GUILayout
íí 
.
íí 
Box
íí 
(
íí 
$stríí Ç
)ííÇ É
;ííÉ Ñ
}
ìì 
GUI
ïï 
.
ïï 
color
ïï 
=
ïï 
oldColor
ïï  
;
ïï  !
}
ññ 	
void
öö 
OnPlayModeChanged
öö 
(
öö 
UnityEditor
öö *
.
öö* +!
PlayModeStateChange
öö+ >
state
öö? D
)
ööD E
{
õõ 	
if
ùù 
(
ùù 
state
ùù 
==
ùù 
UnityEditor
ùù $
.
ùù$ %!
PlayModeStateChange
ùù% 8
.
ùù8 9
ExitingEditMode
ùù9 H
)
ùùH I
{
ûû 
runInEditMode
üü 
=
üü 
false
üü  %
;
üü% &
	OnDisable
†† 
(
†† 
)
†† 
;
†† 
}
°° 
}
¢¢ 	
}
§§ 
}•• ﬁ.
üD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\RenderTargetHandle.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
struct5 ;
RenderTargetHandle< N
{ 
public 
int 
id 
{ 
set 
; 
get  
;  !
}" #
private		 "
RenderTargetIdentifier		 &
rtid		' +
{		, -
set		. 1
;		1 2
get		3 6
;		6 7
}		8 9
public 
static 
readonly 
RenderTargetHandle 1
CameraTarget2 >
=? @
newA D
RenderTargetHandleE W
{X Y
idY [
=\ ]
-^ _
$num_ `
}a b
;b c
public 
RenderTargetHandle !
(! ""
RenderTargetIdentifier" 8"
renderTargetIdentifier9 O
)O P
{ 	
id 
= 
- 
$num 
; 
rtid 
= "
renderTargetIdentifier )
;) *
} 	
internal 
static 
RenderTargetHandle *
GetCameraTarget+ :
(: ;
XRPass; A
xrB D
)D E
{ 	
if 
( 
xr 
. 
enabled 
) 
return 
new 
RenderTargetHandle -
(- .
xr. 0
.0 1
renderTarget1 =
)= >
;> ?
return 
CameraTarget 
;  
} 	
public 
void 
Init 
( 
string 
shaderProperty  .
). /
{ 	
id!! 
=!! 
Shader!! 
.!! 
PropertyToID!! $
(!!$ %
shaderProperty!!% 3
)!!3 4
;!!4 5
}"" 	
public$$ 
void$$ 
Init$$ 
($$ "
RenderTargetIdentifier$$ /"
renderTargetIdentifier$$0 F
)$$F G
{%% 	
id&& 
=&& 
-&& 
$num&& 
;&& 
rtid'' 
='' "
renderTargetIdentifier'' )
;'') *
}(( 	
public** "
RenderTargetIdentifier** %

Identifier**& 0
(**0 1
)**1 2
{++ 	
if,, 
(,, 
id,, 
==,, 
-,, 
$num,, 
),, 
{-- 
return.. $
BuiltinRenderTextureType.. /
.../ 0
CameraTarget..0 <
;..< =
}// 
if00 
(00 
id00 
==00 
-00 
$num00 
)00 
{11 
return22 
rtid22 
;22 
}33 
return44 
new44 "
RenderTargetIdentifier44 -
(44- .
id44. 0
)440 1
;441 2
}55 	
public77 
bool77 %
HasInternalRenderTargetId77 -
(77- .
)77. /
{88 	
return99 
id99 
==99 
-99 
$num99 
;99 
}:: 	
public<< 
bool<< 
Equals<< 
(<< 
RenderTargetHandle<< -
other<<. 3
)<<3 4
{== 	
if>> 
(>> 
id>> 
==>> 
->> 
$num>> 
||>> 
other>> !
.>>! "
id>>" $
==>>% '
->>( )
$num>>) *
)>>* +
return?? 

Identifier?? !
(??! "
)??" #
==??$ &
other??' ,
.??, -

Identifier??- 7
(??7 8
)??8 9
;??9 :
return@@ 
id@@ 
==@@ 
other@@ 
.@@ 
id@@ !
;@@! "
}AA 	
publicCC 
overrideCC 
boolCC 
EqualsCC #
(CC# $
objectCC$ *
objCC+ .
)CC. /
{DD 	
ifEE 
(EE 
ReferenceEqualsEE 
(EE  
nullEE  $
,EE$ %
objEE& )
)EE) *
)EE* +
returnEE, 2
falseEE3 8
;EE8 9
returnFF 
objFF 
isFF 
RenderTargetHandleFF ,
&&FF- /
EqualsFF0 6
(FF6 7
(FF7 8
RenderTargetHandleFF8 J
)FFJ K
objFFK N
)FFN O
;FFO P
}GG 	
publicII 
overrideII 
intII 
GetHashCodeII '
(II' (
)II( )
{JJ 	
returnKK 
idKK 
;KK 
}LL 	
publicNN 
staticNN 
boolNN 
operatorNN #
==NN# %
(NN% &
RenderTargetHandleNN& 8
c1NN9 ;
,NN; <
RenderTargetHandleNN= O
c2NNP R
)NNR S
{OO 	
returnPP 
c1PP 
.PP 
EqualsPP 
(PP 
c2PP 
)PP  
;PP  !
}QQ 	
publicSS 
staticSS 
boolSS 
operatorSS #
!=SS# %
(SS% &
RenderTargetHandleSS& 8
c1SS9 ;
,SS; <
RenderTargetHandleSS= O
c2SSP R
)SSR S
{TT 	
returnUU 
!UU 
c1UU 
.UU 
EqualsUU 
(UU 
c2UU  
)UU  !
;UU! "
}VV 	
}WW 
}XX ”A
°D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Light2DCullResult.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
internal		 
struct		 

LightStats		 
{

 
public 
int 
totalLights 
; 
public 
int 
totalNormalMapUsage &
;& '
public 
int  
totalVolumetricUsage '
;' (
public 
uint 
blendStylesUsed #
;# $
} 
internal 
	interface 
ILight2DCullResult )
{ 
List 
< 
Light2D 
> 
visibleLights #
{$ %
get& )
;) *
}+ ,

LightStats  
GetLightStatsByLayer '
(' (
int( +
layer, 1
)1 2
;2 3
bool 

IsSceneLit 
( 
) 
; 
} 
internal 
class 
Light2DCullResult $
:% &
ILight2DCullResult' 9
{ 
private 
List 
< 
Light2D 
> 
m_VisibleLights -
=. /
new0 3
List4 8
<8 9
Light2D9 @
>@ A
(A B
)B C
;C D
public 
List 
< 
Light2D 
> 
visibleLights *
=>+ -
m_VisibleLights. =
;= >
public 
bool 

IsSceneLit 
( 
)  
{ 	
if 
( 
visibleLights 
. 
Count #
>$ %
$num& '
)' (
return   
true   
;   
foreach"" 
("" 
var"" 
light"" 
in"" !
Light2DManager""" 0
.""0 1
lights""1 7
)""7 8
{## 
if$$ 
($$ 
light$$ 
.$$ 
	lightType$$ #
==$$$ &
Light2D$$' .
.$$. /
	LightType$$/ 8
.$$8 9
Global$$9 ?
)$$? @
return%% 
true%% 
;%%  
}&& 
return(( 
false(( 
;(( 
})) 	
public** 

LightStats**  
GetLightStatsByLayer** .
(**. /
int**/ 2
layer**3 8
)**8 9
{++ 	
var,, 
returnStats,, 
=,, 
new,, !

LightStats,," ,
(,,, -
),,- .
;,,. /
foreach-- 
(-- 
var-- 
light-- 
in-- !
visibleLights--" /
)--/ 0
{.. 
if// 
(// 
!// 
light// 
.// 

IsLitLayer// %
(//% &
layer//& +
)//+ ,
)//, -
continue00 
;00 
returnStats22 
.22 
totalLights22 '
++22' )
;22) *
if33 
(33 
light33 
.33 
useNormalMap33 &
)33& '
returnStats44 
.44  
totalNormalMapUsage44  3
++443 5
;445 6
if55 
(55 
light55 
.55 
volumeOpacity55 '
>55( )
$num55* +
)55+ ,
returnStats66 
.66   
totalVolumetricUsage66  4
++664 6
;666 7
returnStats88 
.88 
blendStylesUsed88 +
|=88, .
(88/ 0
uint880 4
)884 5
(885 6
$num886 7
<<888 :
light88; @
.88@ A
blendStyleIndex88A P
)88P Q
;88Q R
}99 
return;; 
returnStats;; 
;;; 
}<< 	
public>> 
void>> 
SetupCulling>>  
(>>  !
ref>>! $'
ScriptableCullingParameters>>% @
cullingParameters>>A R
,>>R S
Camera>>T Z
camera>>[ a
)>>a b
{?? 	
Profiler@@ 
.@@ 
BeginSample@@  
(@@  !
$str@@! 1
)@@1 2
;@@2 3
m_VisibleLightsAA 
.AA 
ClearAA !
(AA! "
)AA" #
;AA# $
foreachBB 
(BB 
varBB 
lightBB 
inBB !
Light2DManagerBB" 0
.BB0 1
lightsBB1 7
)BB7 8
{CC 
ifDD 
(DD 
(DD 
cameraDD 
.DD 
cullingMaskDD '
&DD( )
(DD* +
$numDD+ ,
<<DD- /
lightDD0 5
.DD5 6

gameObjectDD6 @
.DD@ A
layerDDA F
)DDF G
)DDG H
==DDI K
$numDDL M
)DDM N
continueEE 
;EE 
ifHH 
(HH 
!HH 
UnityEditorHH  
.HH  !
SceneManagementHH! 0
.HH0 1
StageUtilityHH1 =
.HH= >(
IsGameObjectRenderedByCameraHH> Z
(HHZ [
lightHH[ `
.HH` a

gameObjectHHa k
,HHk l
cameraHHm s
)HHs t
)HHt u
continueII 
;II 
ifLL 
(LL 
lightLL 
.LL 
	lightTypeLL #
==LL$ &
Light2DLL' .
.LL. /
	LightTypeLL/ 8
.LL8 9
GlobalLL9 ?
)LL? @
{MM 
m_VisibleLightsNN #
.NN# $
AddNN$ '
(NN' (
lightNN( -
)NN- .
;NN. /
continueOO 
;OO 
}PP 
ProfilerRR 
.RR 
BeginSampleRR $
(RR$ %
$strRR% 2
)RR2 3
;RR3 4
varSS 
positionSS 
=SS 
lightSS $
.SS$ %
boundingSphereSS% 3
.SS3 4
positionSS4 <
;SS< =
varTT 
culledTT 
=TT 
falseTT "
;TT" #
forUU 
(UU 
varUU 
iUU 
=UU 
$numUU 
;UU 
iUU  !
<UU" #
cullingParametersUU$ 5
.UU5 6
cullingPlaneCountUU6 G
;UUG H
++UUI K
iUUK L
)UUL M
{VV 
varWW 
planeWW 
=WW 
cullingParametersWW  1
.WW1 2
GetCullingPlaneWW2 A
(WWA B
iWWB C
)WWC D
;WWD E
varYY 
distanceYY  
=YY! "
mathYY# '
.YY' (
dotYY( +
(YY+ ,
positionYY, 4
,YY4 5
planeYY6 ;
.YY; <
normalYY< B
)YYB C
+YYD E
planeYYF K
.YYK L
distanceYYL T
;YYT U
ifZZ 
(ZZ 
distanceZZ  
<ZZ! "
-ZZ# $
lightZZ$ )
.ZZ) *
boundingSphereZZ* 8
.ZZ8 9
radiusZZ9 ?
)ZZ? @
{[[ 
culled\\ 
=\\  
true\\! %
;\\% &
break]] 
;]] 
}^^ 
}__ 
Profiler`` 
.`` 
	EndSample`` "
(``" #
)``# $
;``$ %
ifaa 
(aa 
culledaa 
)aa 
continuebb 
;bb 
m_VisibleLightsdd 
.dd  
Adddd  #
(dd# $
lightdd$ )
)dd) *
;dd* +
}ee 
m_VisibleLightshh 
.hh 
Sorthh  
(hh  !
(hh! "
l1hh" $
,hh$ %
l2hh& (
)hh( )
=>hh* ,
l1hh- /
.hh/ 0

lightOrderhh0 :
-hh; <
l2hh= ?
.hh? @

lightOrderhh@ J
)hhJ K
;hhK L
Profilerii 
.ii 
	EndSampleii 
(ii 
)ii  
;ii  !
}jj 	
}kk 
}ll ûÆ
úD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\LightUtility.cs
	namespace		 	
UnityEngine		
 
.		 
Experimental		 "
.		" #
	Rendering		# ,
.		, -
	Universal		- 6
{

 
internal 
static 
class 
LightUtility &
{ 
public 
static 
bool 
CheckForChange )
() *
int* -
a. /
,/ 0
ref1 4
int5 8
b9 :
): ;
{ 	
var 
changed 
= 
a 
!= 
b  
;  !
b 
= 
a 
; 
return 
changed 
; 
} 	
public 
static 
bool 
CheckForChange )
() *
float* /
a0 1
,1 2
ref3 6
float7 <
b= >
)> ?
{ 	
var 
changed 
= 
a 
!= 
b  
;  !
b 
= 
a 
; 
return 
changed 
; 
} 	
public 
static 
bool 
CheckForChange )
() *
bool* .
a/ 0
,0 1
ref2 5
bool6 :
b; <
)< =
{ 	
var 
changed 
= 
a 
!= 
b  
;  !
b 
= 
a 
; 
return 
changed 
; 
}   	
private"" 
struct"" %
ParametricLightMeshVertex"" 0
{## 	
public$$ 
float3$$ 
position$$ "
;$$" #
public%% 
Color%% 
color%% 
;%% 
public'' 
static'' 
readonly'' "%
VertexAttributeDescriptor''# <
[''< =
]''= >
VertexLayout''? K
=''L M
new''N Q
[''Q R
]''R S
{(( 
new)) %
VertexAttributeDescriptor)) -
())- .
VertexAttribute)). =
.))= >
Position))> F
,))F G!
VertexAttributeFormat))H ]
.))] ^
Float32))^ e
,))e f
$num))g h
)))h i
,))i j
new** %
VertexAttributeDescriptor** -
(**- .
VertexAttribute**. =
.**= >
Color**> C
,**C D!
VertexAttributeFormat**E Z
.**Z [
Float32**[ b
,**b c
$num**d e
)**e f
,**f g
}++ 
;++ 
},, 	
private.. 
struct.. !
SpriteLightMeshVertex.. ,
{// 	
public00 
Vector300 
position00 #
;00# $
public11 
Color11 
color11 
;11 
public22 
Vector222 
uv22 
;22 
public44 
static44 
readonly44 "%
VertexAttributeDescriptor44# <
[44< =
]44= >
VertexLayout44? K
=44L M
new44N Q
[44Q R
]44R S
{55 
new66 %
VertexAttributeDescriptor66 -
(66- .
VertexAttribute66. =
.66= >
Position66> F
,66F G!
VertexAttributeFormat66H ]
.66] ^
Float3266^ e
,66e f
$num66g h
)66h i
,66i j
new77 %
VertexAttributeDescriptor77 -
(77- .
VertexAttribute77. =
.77= >
Color77> C
,77C D!
VertexAttributeFormat77E Z
.77Z [
Float3277[ b
,77b c
$num77d e
)77e f
,77f g
new88 %
VertexAttributeDescriptor88 -
(88- .
VertexAttribute88. =
.88= >
	TexCoord088> G
,88G H!
VertexAttributeFormat88I ^
.88^ _
Float3288_ f
,88f g
$num88h i
)88i j
,88j k
}99 
;99 
}:: 	
public<< 
static<< 
Bounds<< "
GenerateParametricMesh<< 3
(<<3 4
Mesh<<4 8
mesh<<9 =
,<<= >
float<<? D
radius<<E K
,<<K L
float<<M R
falloffDistance<<S b
,<<b c
float<<d i
angle<<j o
,<<o p
int<<q t
sides<<u z
)<<z {
{== 	
var>> 
angleOffset>> 
=>> 
Mathf>> #
.>># $
PI>>$ &
/>>' (
$num>>) -
+>>. /
Mathf>>0 5
.>>5 6
Deg2Rad>>6 =
*>>> ?
angle>>@ E
;>>E F
if?? 
(?? 
sides?? 
<?? 
$num?? 
)?? 
{@@ 
radiusAA 
=AA 
$numAA <
*AA= >
radiusAA? E
;AAE F
sidesBB 
=BB 
$numBB 
;BB 
}CC 
ifEE 
(EE 
sidesEE 
==EE 
$numEE 
)EE 
{FF 
angleOffsetGG 
=GG 
MathfGG #
.GG# $
PIGG$ &
/GG' (
$numGG) -
+GG. /
MathfGG0 5
.GG5 6
Deg2RadGG6 =
*GG> ?
angleGG@ E
;GGE F
}HH 
varJJ 
vertexCountJJ 
=JJ 
$numJJ 
+JJ  !
$numJJ" #
*JJ$ %
sidesJJ& +
;JJ+ ,
varKK 

indexCountKK 
=KK 
$numKK 
*KK  
$numKK! "
*KK# $
sidesKK% *
;KK* +
varLL 
verticesLL 
=LL 
newLL 
NativeArrayLL *
<LL* +%
ParametricLightMeshVertexLL+ D
>LLD E
(LLE F
vertexCountLLF Q
,LLQ R
	AllocatorLLS \
.LL\ ]
TempLL] a
)LLa b
;LLb c
varMM 
	trianglesMM 
=MM 
newMM 
NativeArrayMM  +
<MM+ ,
ushortMM, 2
>MM2 3
(MM3 4

indexCountMM4 >
,MM> ?
	AllocatorMM@ I
.MMI J
TempMMJ N
)MMN O
;MMO P
varNN 
centerIndexNN 
=NN 
(NN 
ushortNN %
)NN% &
(NN& '
$numNN' (
*NN) *
sidesNN+ 0
)NN0 1
;NN1 2
varQQ 
colorQQ 
=QQ 
newQQ 
ColorQQ !
(QQ! "
$numQQ" #
,QQ# $
$numQQ% &
,QQ& '
$numQQ( )
,QQ) *
$numQQ+ ,
)QQ, -
;QQ- .
verticesRR 
[RR 
centerIndexRR  
]RR  !
=RR" #
newRR$ '%
ParametricLightMeshVertexRR( A
{SS 
positionTT 
=TT 
float3TT !
.TT! "
zeroTT" &
,TT& '
colorUU 
=UU 
colorUU 
}VV 
;VV 
varXX 
radiansPerSideXX 
=XX  
$numXX! "
*XX# $
MathfXX% *
.XX* +
PIXX+ -
/XX. /
sidesXX0 5
;XX5 6
varYY 
minYY 
=YY 
newYY 
float3YY  
(YY  !
floatYY! &
.YY& '
MaxValueYY' /
,YY/ 0
floatYY1 6
.YY6 7
MaxValueYY7 ?
,YY? @
$numYYA B
)YYB C
;YYC D
varZZ 
maxZZ 
=ZZ 
newZZ 
float3ZZ  
(ZZ  !
floatZZ! &
.ZZ& '
MinValueZZ' /
,ZZ/ 0
floatZZ1 6
.ZZ6 7
MinValueZZ7 ?
,ZZ? @
$numZZA B
)ZZB C
;ZZC D
for\\ 
(\\ 
var\\ 
i\\ 
=\\ 
$num\\ 
;\\ 
i\\ 
<\\ 
sides\\  %
;\\% &
i\\' (
++\\( *
)\\* +
{]] 
var^^ 
endAngle^^ 
=^^ 
(^^  
i^^  !
+^^" #
$num^^$ %
)^^% &
*^^' (
radiansPerSide^^) 7
;^^7 8
var__ 

extrudeDir__ 
=__  
new__! $
float3__% +
(__+ ,
math__, 0
.__0 1
cos__1 4
(__4 5
endAngle__5 =
+__> ?
angleOffset__@ K
)__K L
,__L M
math__N R
.__R S
sin__S V
(__V W
endAngle__W _
+__` a
angleOffset__b m
)__m n
,__n o
$num__p q
)__q r
;__r s
var`` 
endPoint`` 
=`` 
radius`` %
*``& '

extrudeDir``( 2
;``2 3
varbb 
vertexIndexbb 
=bb  !
(bb" #
$numbb# $
*bb% &
ibb' (
+bb) *
$numbb+ ,
)bb, -
%bb. /
(bb0 1
$numbb1 2
*bb3 4
sidesbb5 :
)bb: ;
;bb; <
verticescc 
[cc 
vertexIndexcc $
]cc$ %
=cc& '
newcc( +%
ParametricLightMeshVertexcc, E
{dd 
positionee 
=ee 
endPointee '
,ee' (
colorff 
=ff 
newff 
Colorff  %
(ff% &

extrudeDirff& 0
.ff0 1
xff1 2
,ff2 3

extrudeDirff4 >
.ff> ?
yff? @
,ff@ A
$numffB C
,ffC D
$numffE F
)ffF G
}gg 
;gg 
verticeshh 
[hh 
vertexIndexhh $
+hh% &
$numhh' (
]hh( )
=hh* +
newhh, /%
ParametricLightMeshVertexhh0 I
{ii 
positionjj 
=jj 
endPointjj '
,jj' (
colorkk 
=kk 
colorkk !
}ll 
;ll 
varoo 
triangleIndexoo !
=oo" #
$numoo$ %
*oo& '
ioo( )
;oo) *
	trianglespp 
[pp 
triangleIndexpp '
]pp' (
=pp) *
(pp+ ,
ushortpp, 2
)pp2 3
(pp3 4
vertexIndexpp4 ?
+pp@ A
$numppB C
)ppC D
;ppD E
	trianglesqq 
[qq 
triangleIndexqq '
+qq( )
$numqq* +
]qq+ ,
=qq- .
(qq/ 0
ushortqq0 6
)qq6 7
(qq7 8
$numqq8 9
*qq: ;
iqq< =
+qq> ?
$numqq@ A
)qqA B
;qqB C
	trianglesrr 
[rr 
triangleIndexrr '
+rr( )
$numrr* +
]rr+ ,
=rr- .
centerIndexrr/ :
;rr: ;
	trianglesuu 
[uu 
triangleIndexuu '
+uu( )
$numuu* +
]uu+ ,
=uu- .
(uu/ 0
ushortuu0 6
)uu6 7
(uu7 8
vertexIndexuu8 C
)uuC D
;uuD E
	trianglesvv 
[vv 
triangleIndexvv '
+vv( )
$numvv* +
]vv+ ,
=vv- .
(vv/ 0
ushortvv0 6
)vv6 7
(vv7 8
$numvv8 9
*vv: ;
ivv< =
)vv= >
;vv> ?
	trianglesww 
[ww 
triangleIndexww '
+ww( )
$numww* +
]ww+ ,
=ww- .
(ww/ 0
ushortww0 6
)ww6 7
(ww7 8
$numww8 9
*ww: ;
iww< =
+ww> ?
$numww@ A
)wwA B
;wwB C
	triangleszz 
[zz 
triangleIndexzz '
+zz( )
$numzz* +
]zz+ ,
=zz- .
(zz/ 0
ushortzz0 6
)zz6 7
(zz7 8
vertexIndexzz8 C
+zzD E
$numzzF G
)zzG H
;zzH I
	triangles{{ 
[{{ 
triangleIndex{{ '
+{{( )
$num{{* +
]{{+ ,
={{- .
({{/ 0
ushort{{0 6
){{6 7
({{7 8
vertexIndex{{8 C
){{C D
;{{D E
	triangles|| 
[|| 
triangleIndex|| '
+||( )
$num||* +
]||+ ,
=||- .
(||/ 0
ushort||0 6
)||6 7
(||7 8
$num||8 9
*||: ;
i||< =
+||> ?
$num||@ A
)||A B
;||B C
min~~ 
=~~ 
math~~ 
.~~ 
min~~ 
(~~ 
min~~ "
,~~" #
endPoint~~$ ,
+~~- .

extrudeDir~~/ 9
*~~: ;
falloffDistance~~< K
)~~K L
;~~L M
max 
= 
math 
. 
max 
( 
max "
," #
endPoint$ ,
+- .

extrudeDir/ 9
*: ;
falloffDistance< K
)K L
;L M
}
ÄÄ 
mesh
ÇÇ 
.
ÇÇ #
SetVertexBufferParams
ÇÇ &
(
ÇÇ& '
vertexCount
ÇÇ' 2
,
ÇÇ2 3'
ParametricLightMeshVertex
ÇÇ4 M
.
ÇÇM N
VertexLayout
ÇÇN Z
)
ÇÇZ [
;
ÇÇ[ \
mesh
ÉÉ 
.
ÉÉ !
SetVertexBufferData
ÉÉ $
(
ÉÉ$ %
vertices
ÉÉ% -
,
ÉÉ- .
$num
ÉÉ/ 0
,
ÉÉ0 1
$num
ÉÉ2 3
,
ÉÉ3 4
vertexCount
ÉÉ5 @
)
ÉÉ@ A
;
ÉÉA B
mesh
ÑÑ 
.
ÑÑ 

SetIndices
ÑÑ 
(
ÑÑ 
	triangles
ÑÑ %
,
ÑÑ% &
MeshTopology
ÑÑ' 3
.
ÑÑ3 4
	Triangles
ÑÑ4 =
,
ÑÑ= >
$num
ÑÑ? @
,
ÑÑ@ A
false
ÑÑB G
)
ÑÑG H
;
ÑÑH I
return
ÜÜ 
new
ÜÜ 
Bounds
ÜÜ 
{
áá 
min
àà 
=
àà 
min
àà 
,
àà 
max
ââ 
=
ââ 
max
ââ 
}
ää 
;
ää 
}
ãã 	
public
çç 
static
çç 
Bounds
çç  
GenerateSpriteMesh
çç /
(
çç/ 0
Mesh
çç0 4
mesh
çç5 9
,
çç9 :
Sprite
çç; A
sprite
ççB H
)
ççH I
{
éé 	
if
èè 
(
èè 
sprite
èè 
==
èè 
null
èè 
)
èè 
{
êê 
mesh
ëë 
.
ëë 
Clear
ëë 
(
ëë 
)
ëë 
;
ëë 
return
íí 
new
íí 
Bounds
íí !
(
íí! "
Vector3
íí" )
.
íí) *
zero
íí* .
,
íí. /
Vector3
íí0 7
.
íí7 8
zero
íí8 <
)
íí< =
;
íí= >
}
ìì 
var
óó 
uvs
óó 
=
óó 
sprite
óó 
.
óó 
uv
óó 
;
óó  
var
ôô 
srcVertices
ôô 
=
ôô 
sprite
ôô $
.
ôô$ % 
GetVertexAttribute
ôô% 7
<
ôô7 8
Vector3
ôô8 ?
>
ôô? @
(
ôô@ A
VertexAttribute
ôôA P
.
ôôP Q
Position
ôôQ Y
)
ôôY Z
;
ôôZ [
var
öö 
srcUVs
öö 
=
öö 
sprite
öö 
.
öö   
GetVertexAttribute
öö  2
<
öö2 3
Vector2
öö3 :
>
öö: ;
(
öö; <
VertexAttribute
öö< K
.
ööK L
	TexCoord0
ööL U
)
ööU V
;
ööV W
var
õõ 

srcIndices
õõ 
=
õõ 
sprite
õõ #
.
õõ# $

GetIndices
õõ$ .
(
õõ. /
)
õõ/ 0
;
õõ0 1
var
ùù 
center
ùù 
=
ùù 
$num
ùù 
*
ùù 
(
ùù  !
sprite
ùù! '
.
ùù' (
bounds
ùù( .
.
ùù. /
min
ùù/ 2
+
ùù3 4
sprite
ùù5 ;
.
ùù; <
bounds
ùù< B
.
ùùB C
max
ùùC F
)
ùùF G
;
ùùG H
var
ûû 
vertices
ûû 
=
ûû 
new
ûû 
NativeArray
ûû *
<
ûû* +#
SpriteLightMeshVertex
ûû+ @
>
ûû@ A
(
ûûA B

srcIndices
ûûB L
.
ûûL M
Length
ûûM S
,
ûûS T
	Allocator
ûûU ^
.
ûû^ _
Temp
ûû_ c
)
ûûc d
;
ûûd e
var
üü 
color
üü 
=
üü 
new
üü 
Color
üü !
(
üü! "
$num
üü" #
,
üü# $
$num
üü$ %
,
üü% &
$num
üü& '
,
üü' (
$num
üü) *
)
üü* +
;
üü+ ,
for
°° 
(
°° 
var
°° 
i
°° 
=
°° 
$num
°° 
;
°° 
i
°° 
<
°° 
srcVertices
°°  +
.
°°+ ,
Length
°°, 2
;
°°2 3
i
°°4 5
++
°°5 7
)
°°7 8
{
¢¢ 
vertices
££ 
[
££ 
i
££ 
]
££ 
=
££ 
new
££ !#
SpriteLightMeshVertex
££" 7
{
§§ 
position
•• 
=
•• 
new
•• "
Vector3
••# *
(
••* +
srcVertices
••+ 6
[
••6 7
i
••7 8
]
••8 9
.
••9 :
x
••: ;
,
••; <
srcVertices
••= H
[
••H I
i
••I J
]
••J K
.
••K L
y
••L M
,
••M N
$num
••O P
)
••P Q
-
••R S
center
••T Z
,
••Z [
color
¶¶ 
=
¶¶ 
color
¶¶ !
,
¶¶! "
uv
ßß 
=
ßß 
srcUVs
ßß 
[
ßß  
i
ßß  !
]
ßß! "
}
®® 
;
®® 
}
©© 
mesh
™™ 
.
™™ #
SetVertexBufferParams
™™ &
(
™™& '
vertices
™™' /
.
™™/ 0
Length
™™0 6
,
™™6 7#
SpriteLightMeshVertex
™™8 M
.
™™M N
VertexLayout
™™N Z
)
™™Z [
;
™™[ \
mesh
´´ 
.
´´ !
SetVertexBufferData
´´ $
(
´´$ %
vertices
´´% -
,
´´- .
$num
´´/ 0
,
´´0 1
$num
´´2 3
,
´´3 4
vertices
´´5 =
.
´´= >
Length
´´> D
)
´´D E
;
´´E F
mesh
¨¨ 
.
¨¨ 

SetIndices
¨¨ 
(
¨¨ 

srcIndices
¨¨ &
,
¨¨& '
MeshTopology
¨¨( 4
.
¨¨4 5
	Triangles
¨¨5 >
,
¨¨> ?
$num
¨¨@ A
,
¨¨A B
true
¨¨C G
)
¨¨G H
;
¨¨H I
return
≠≠ 
mesh
≠≠ 
.
≠≠ 

GetSubMesh
≠≠ "
(
≠≠" #
$num
≠≠# $
)
≠≠$ %
.
≠≠% &
bounds
≠≠& ,
;
≠≠, -
}
ÆÆ 	
public
∞∞ 
static
∞∞ 
List
∞∞ 
<
∞∞ 
Vector2
∞∞ "
>
∞∞" #
GetFalloffShape
∞∞$ 3
(
∞∞3 4
Vector3
∞∞4 ;
[
∞∞; <
]
∞∞< =
	shapePath
∞∞> G
)
∞∞G H
{
±± 	
var
≤≤ 
extrusionDir
≤≤ 
=
≤≤ 
new
≤≤ "
List
≤≤# '
<
≤≤' (
Vector2
≤≤( /
>
≤≤/ 0
(
≤≤0 1
)
≤≤1 2
;
≤≤2 3
for
≥≥ 
(
≥≥ 
var
≥≥ 
i
≥≥ 
=
≥≥ 
$num
≥≥ 
;
≥≥ 
i
≥≥ 
<
≥≥ 
	shapePath
≥≥  )
.
≥≥) *
Length
≥≥* 0
;
≥≥0 1
++
≥≥2 4
i
≥≥4 5
)
≥≥5 6
{
¥¥ 
var
µµ 
h
µµ 
=
µµ 
(
µµ 
i
µµ 
==
µµ 
$num
µµ 
)
µµ  
?
µµ! "
(
µµ# $
	shapePath
µµ$ -
.
µµ- .
Length
µµ. 4
-
µµ5 6
$num
µµ7 8
)
µµ8 9
:
µµ: ;
(
µµ< =
i
µµ= >
-
µµ? @
$num
µµA B
)
µµB C
;
µµC D
var
∂∂ 
j
∂∂ 
=
∂∂ 
(
∂∂ 
i
∂∂ 
+
∂∂ 
$num
∂∂ 
)
∂∂ 
%
∂∂  !
	shapePath
∂∂" +
.
∂∂+ ,
Length
∂∂, 2
;
∂∂2 3
var
∏∏ 
pp
∏∏ 
=
∏∏ 
	shapePath
∏∏ "
[
∏∏" #
h
∏∏# $
]
∏∏$ %
;
∏∏% &
var
ππ 
cp
ππ 
=
ππ 
	shapePath
ππ "
[
ππ" #
i
ππ# $
]
ππ$ %
;
ππ% &
var
∫∫ 
np
∫∫ 
=
∫∫ 
	shapePath
∫∫ "
[
∫∫" #
j
∫∫# $
]
∫∫$ %
;
∫∫% &
var
ºº 
cpd
ºº 
=
ºº 
cp
ºº 
-
ºº 
pp
ºº !
;
ºº! "
var
ΩΩ 
npd
ΩΩ 
=
ΩΩ 
np
ΩΩ 
-
ΩΩ 
cp
ΩΩ !
;
ΩΩ! "
if
ææ 
(
ææ 
cpd
ææ 
.
ææ 
	magnitude
ææ !
<
ææ" #
$num
ææ$ *
||
ææ+ -
npd
ææ. 1
.
ææ1 2
	magnitude
ææ2 ;
<
ææ< =
$num
ææ> D
)
ææD E
continue
øø 
;
øø 
var
¡¡ 
vl
¡¡ 
=
¡¡ 
cpd
¡¡ 
.
¡¡ 

normalized
¡¡ '
;
¡¡' (
var
¬¬ 
vr
¬¬ 
=
¬¬ 
npd
¬¬ 
.
¬¬ 

normalized
¬¬ '
;
¬¬' (
vl
ƒƒ 
=
ƒƒ 
new
ƒƒ 
Vector2
ƒƒ  
(
ƒƒ  !
-
ƒƒ! "
vl
ƒƒ" $
.
ƒƒ$ %
y
ƒƒ% &
,
ƒƒ& '
vl
ƒƒ( *
.
ƒƒ* +
x
ƒƒ+ ,
)
ƒƒ, -
;
ƒƒ- .
vr
≈≈ 
=
≈≈ 
new
≈≈ 
Vector2
≈≈  
(
≈≈  !
-
≈≈! "
vr
≈≈" $
.
≈≈$ %
y
≈≈% &
,
≈≈& '
vr
≈≈( *
.
≈≈* +
x
≈≈+ ,
)
≈≈, -
;
≈≈- .
var
«« 
va
«« 
=
«« 
vl
«« 
.
«« 

normalized
«« &
+
««' (
vr
««) +
.
««+ ,

normalized
««, 6
;
««6 7
var
»» 
vn
»» 
=
»» 
-
»» 
va
»» 
.
»» 

normalized
»» '
;
»»' (
if
   
(
   
va
   
.
   
	magnitude
    
>
  ! "
$num
  # $
&&
  % '
vn
  ( *
.
  * +
	magnitude
  + 4
>
  5 6
$num
  7 8
)
  8 9
{
ÀÀ 
var
ÃÃ 
dir
ÃÃ 
=
ÃÃ 
new
ÃÃ !
Vector2
ÃÃ" )
(
ÃÃ) *
vn
ÃÃ* ,
.
ÃÃ, -
x
ÃÃ- .
,
ÃÃ. /
vn
ÃÃ0 2
.
ÃÃ2 3
y
ÃÃ3 4
)
ÃÃ4 5
;
ÃÃ5 6
extrusionDir
ÕÕ  
.
ÕÕ  !
Add
ÕÕ! $
(
ÕÕ$ %
dir
ÕÕ% (
)
ÕÕ( )
;
ÕÕ) *
}
ŒŒ 
}
œœ 
return
–– 
extrusionDir
–– 
;
––  
}
—— 	
public
”” 
static
”” 
Bounds
”” 
GenerateShapeMesh
”” .
(
””. /
Mesh
””/ 3
mesh
””4 8
,
””8 9
Vector3
””: A
[
””A B
]
””B C
	shapePath
””D M
,
””M N
float
””O T
falloffDistance
””U d
)
””d e
{
‘‘ 	
var
’’ 
meshInteriorColor
’’ !
=
’’" #
new
’’$ '
Color
’’( -
(
’’- .
$num
’’. /
,
’’/ 0
$num
’’0 1
,
’’1 2
$num
’’2 3
,
’’3 4
$num
’’4 5
)
’’5 6
;
’’6 7
var
÷÷ 
min
÷÷ 
=
÷÷ 
new
÷÷ 
float3
÷÷  
(
÷÷  !
float
÷÷! &
.
÷÷& '
MaxValue
÷÷' /
,
÷÷/ 0
float
÷÷1 6
.
÷÷6 7
MaxValue
÷÷7 ?
,
÷÷? @
$num
÷÷A B
)
÷÷B C
;
÷÷C D
var
◊◊ 
max
◊◊ 
=
◊◊ 
new
◊◊ 
float3
◊◊  
(
◊◊  !
float
◊◊! &
.
◊◊& '
MinValue
◊◊' /
,
◊◊/ 0
float
◊◊1 6
.
◊◊6 7
MinValue
◊◊7 ?
,
◊◊? @
$num
◊◊A B
)
◊◊B C
;
◊◊C D
var
⁄⁄ 

pointCount
⁄⁄ 
=
⁄⁄ 
	shapePath
⁄⁄ &
.
⁄⁄& '
Length
⁄⁄' -
;
⁄⁄- .
var
€€ 
inputs
€€ 
=
€€ 
new
€€ 
ContourVertex
€€ *
[
€€* +

pointCount
€€+ 5
]
€€5 6
;
€€6 7
for
‹‹ 
(
‹‹ 
var
‹‹ 
i
‹‹ 
=
‹‹ 
$num
‹‹ 
;
‹‹ 
i
‹‹ 
<
‹‹ 

pointCount
‹‹  *
;
‹‹* +
++
‹‹, .
i
‹‹. /
)
‹‹/ 0
inputs
›› 
[
›› 
i
›› 
]
›› 
=
›› 
new
›› 
ContourVertex
››  -
(
››- .
)
››. /
{
››0 1
Position
››2 :
=
››; <
new
››= @
Vec3
››A E
(
››E F
)
››F G
{
››H I
X
››J K
=
››L M
	shapePath
››N W
[
››W X
i
››X Y
]
››Y Z
.
››Z [
x
››[ \
,
››\ ]
Y
››^ _
=
››` a
	shapePath
››b k
[
››k l
i
››l m
]
››m n
.
››n o
y
››o p
}
››q r
}
››r s
;
››s t
var
ﬂﬂ 
tessI
ﬂﬂ 
=
ﬂﬂ 
new
ﬂﬂ 
Tess
ﬂﬂ  
(
ﬂﬂ  !
)
ﬂﬂ! "
;
ﬂﬂ" #
tessI
‡‡ 
.
‡‡ 

AddContour
‡‡ 
(
‡‡ 
inputs
‡‡ #
,
‡‡# $ 
ContourOrientation
‡‡% 7
.
‡‡7 8
Original
‡‡8 @
)
‡‡@ A
;
‡‡A B
tessI
·· 
.
·· 

Tessellate
·· 
(
·· 
WindingRule
·· (
.
··( )
EvenOdd
··) 0
,
··0 1
ElementType
··2 =
.
··= >
Polygons
··> F
,
··F G
$num
··H I
)
··I J
;
··J K
var
„„ 
indicesI
„„ 
=
„„ 
tessI
„„  
.
„„  !
Elements
„„! )
.
„„) *
Select
„„* 0
(
„„0 1
i
„„1 2
=>
„„3 5
i
„„6 7
)
„„7 8
;
„„8 9
var
‰‰ 
	verticesI
‰‰ 
=
‰‰ 
tessI
‰‰ !
.
‰‰! "
Vertices
‰‰" *
.
‰‰* +
Select
‰‰+ 1
(
‰‰1 2
v
‰‰2 3
=>
‰‰4 6
new
‰‰7 :
float3
‰‰; A
(
‰‰A B
v
‰‰B C
.
‰‰C D
Position
‰‰D L
.
‰‰L M
X
‰‰M N
,
‰‰N O
v
‰‰P Q
.
‰‰Q R
Position
‰‰R Z
.
‰‰Z [
Y
‰‰[ \
,
‰‰\ ]
$num
‰‰^ _
)
‰‰_ `
)
‰‰` a
;
‰‰a b
var
ÊÊ 
finalVertices
ÊÊ 
=
ÊÊ 
new
ÊÊ  #
NativeArray
ÊÊ$ /
<
ÊÊ/ 0'
ParametricLightMeshVertex
ÊÊ0 I
>
ÊÊI J
(
ÊÊJ K
	verticesI
ÊÊK T
.
ÊÊT U
Count
ÊÊU Z
(
ÊÊZ [
)
ÊÊ[ \
+
ÊÊ] ^
$num
ÊÊ_ `
*
ÊÊa b
	shapePath
ÊÊc l
.
ÊÊl m
Length
ÊÊm s
,
ÊÊs t
	Allocator
ÊÊu ~
.
ÊÊ~ 
TempÊÊ É
)ÊÊÉ Ñ
;ÊÊÑ Ö
var
ÁÁ 
finalIndices
ÁÁ 
=
ÁÁ 
new
ÁÁ "
NativeArray
ÁÁ# .
<
ÁÁ. /
ushort
ÁÁ/ 5
>
ÁÁ5 6
(
ÁÁ6 7
indicesI
ÁÁ7 ?
.
ÁÁ? @
Count
ÁÁ@ E
(
ÁÁE F
)
ÁÁF G
+
ÁÁH I
$num
ÁÁJ K
*
ÁÁL M
	shapePath
ÁÁN W
.
ÁÁW X
Length
ÁÁX ^
,
ÁÁ^ _
	Allocator
ÁÁ` i
.
ÁÁi j
Temp
ÁÁj n
)
ÁÁn o
;
ÁÁo p
var
ÈÈ 
vertexOffset
ÈÈ 
=
ÈÈ 
$num
ÈÈ  
;
ÈÈ  !
foreach
ÍÍ 
(
ÍÍ 
var
ÍÍ 
v
ÍÍ 
in
ÍÍ 
	verticesI
ÍÍ &
)
ÍÍ& '
{
ÎÎ 
finalVertices
ÏÏ 
[
ÏÏ 
vertexOffset
ÏÏ *
++
ÏÏ* ,
]
ÏÏ, -
=
ÏÏ. /
new
ÏÏ0 3'
ParametricLightMeshVertex
ÏÏ4 M
{
ÌÌ 
position
ÓÓ 
=
ÓÓ 
v
ÓÓ  
,
ÓÓ  !
color
ÔÔ 
=
ÔÔ 
meshInteriorColor
ÔÔ -
}
 
;
 
}
ÒÒ 
var
ÛÛ 
indexOffset
ÛÛ 
=
ÛÛ 
$num
ÛÛ 
;
ÛÛ  
foreach
ÙÙ 
(
ÙÙ 
var
ÙÙ 
v
ÙÙ 
in
ÙÙ 
indicesI
ÙÙ &
)
ÙÙ& '
{
ıı 
finalIndices
ˆˆ 
[
ˆˆ 
indexOffset
ˆˆ (
++
ˆˆ( *
]
ˆˆ* +
=
ˆˆ, -
(
ˆˆ. /
ushort
ˆˆ/ 5
)
ˆˆ5 6
v
ˆˆ6 7
;
ˆˆ7 8
}
˜˜ 
var
˙˙ 
extrusionDirs
˙˙ 
=
˙˙ 
GetFalloffShape
˙˙  /
(
˙˙/ 0
	shapePath
˙˙0 9
)
˙˙9 :
;
˙˙: ;
var
˚˚ 
falloffPointCount
˚˚ !
=
˚˚" #
$num
˚˚$ %
*
˚˚& '
	shapePath
˚˚( 1
.
˚˚1 2
Length
˚˚2 8
;
˚˚8 9
for
¸¸ 
(
¸¸ 
var
¸¸ 
i
¸¸ 
=
¸¸ 
$num
¸¸ 
;
¸¸ 
i
¸¸ 
<
¸¸ 
	shapePath
¸¸  )
.
¸¸) *
Length
¸¸* 0
;
¸¸0 1
i
¸¸2 3
++
¸¸3 5
)
¸¸5 6
{
˝˝ 
var
ˇˇ 
triangleIndex
ˇˇ !
=
ˇˇ" #
$num
ˇˇ$ %
*
ˇˇ& '
i
ˇˇ( )
;
ˇˇ) *
var
ÄÄ 
aIndex
ÄÄ 
=
ÄÄ 
vertexOffset
ÄÄ )
+
ÄÄ* +
triangleIndex
ÄÄ, 9
;
ÄÄ9 :
var
ÅÅ 
bIndex
ÅÅ 
=
ÅÅ 
vertexOffset
ÅÅ )
+
ÅÅ* +
triangleIndex
ÅÅ, 9
+
ÅÅ: ;
$num
ÅÅ< =
;
ÅÅ= >
var
ÇÇ 
cIndex
ÇÇ 
=
ÇÇ 
vertexOffset
ÇÇ )
+
ÇÇ* +
(
ÇÇ, -
triangleIndex
ÇÇ- :
+
ÇÇ; <
$num
ÇÇ= >
)
ÇÇ> ?
%
ÇÇ@ A
falloffPointCount
ÇÇB S
;
ÇÇS T
var
ÉÉ 
dIndex
ÉÉ 
=
ÉÉ 
vertexOffset
ÉÉ )
+
ÉÉ* +
(
ÉÉ, -
triangleIndex
ÉÉ- :
+
ÉÉ; <
$num
ÉÉ= >
)
ÉÉ> ?
%
ÉÉ@ A
falloffPointCount
ÉÉB S
;
ÉÉS T
var
ÜÜ 
point
ÜÜ 
=
ÜÜ 
new
ÜÜ '
ParametricLightMeshVertex
ÜÜ  9
{
áá 
position
àà 
=
àà 
	shapePath
àà (
[
àà( )
i
àà) *
]
àà* +
,
àà+ ,
color
ââ 
=
ââ 
new
ââ 
Color
ââ  %
(
ââ% &
$num
ââ& '
,
ââ' (
$num
ââ) *
,
ââ* +
$num
ââ, -
,
ââ- .
$num
ââ/ 0
)
ââ0 1
}
ää 
;
ää 
finalVertices
ãã 
[
ãã 
vertexOffset
ãã *
+
ãã+ ,
i
ãã- .
*
ãã/ 0
$num
ãã1 2
]
ãã2 3
=
ãã4 5
point
ãã6 ;
;
ãã; <
point
çç 
.
çç 
color
çç 
=
çç 
new
çç !
Color
çç" '
(
çç' (
extrusionDirs
çç( 5
[
çç5 6
i
çç6 7
]
çç7 8
.
çç8 9
x
çç9 :
,
çç: ;
extrusionDirs
çç< I
[
ççI J
i
ççJ K
]
ççK L
.
ççL M
y
ççM N
,
ççN O
$num
ççP Q
,
ççQ R
$num
ççS T
)
ççT U
;
ççU V
finalVertices
éé 
[
éé 
vertexOffset
éé *
+
éé+ ,
i
éé- .
*
éé/ 0
$num
éé1 2
+
éé3 4
$num
éé5 6
]
éé6 7
=
éé8 9
point
éé; @
;
éé@ A
finalIndices
êê 
[
êê 
indexOffset
êê (
+
êê) *
i
êê+ ,
*
êê, -
$num
êê- .
+
êê/ 0
$num
êê1 2
]
êê2 3
=
êê4 5
(
êê6 7
ushort
êê7 =
)
êê= >
aIndex
êê> D
;
êêD E
finalIndices
ëë 
[
ëë 
indexOffset
ëë (
+
ëë) *
i
ëë+ ,
*
ëë, -
$num
ëë- .
+
ëë/ 0
$num
ëë1 2
]
ëë2 3
=
ëë4 5
(
ëë6 7
ushort
ëë7 =
)
ëë= >
bIndex
ëë> D
;
ëëD E
finalIndices
íí 
[
íí 
indexOffset
íí (
+
íí) *
i
íí+ ,
*
íí, -
$num
íí- .
+
íí/ 0
$num
íí1 2
]
íí2 3
=
íí4 5
(
íí6 7
ushort
íí7 =
)
íí= >
dIndex
íí> D
;
ííD E
finalIndices
îî 
[
îî 
indexOffset
îî (
+
îî) *
i
îî+ ,
*
îî, -
$num
îî- .
+
îî/ 0
$num
îî1 2
]
îî2 3
=
îî4 5
(
îî6 7
ushort
îî7 =
)
îî= >
dIndex
îî> D
;
îîD E
finalIndices
ïï 
[
ïï 
indexOffset
ïï (
+
ïï) *
i
ïï+ ,
*
ïï, -
$num
ïï- .
+
ïï/ 0
$num
ïï1 2
]
ïï2 3
=
ïï4 5
(
ïï6 7
ushort
ïï7 =
)
ïï= >
cIndex
ïï> D
;
ïïD E
finalIndices
ññ 
[
ññ 
indexOffset
ññ (
+
ññ) *
i
ññ+ ,
*
ññ, -
$num
ññ- .
+
ññ/ 0
$num
ññ1 2
]
ññ2 3
=
ññ4 5
(
ññ6 7
ushort
ññ7 =
)
ññ= >
aIndex
ññ> D
;
ññD E
var
òò 

extrudeDir
òò 
=
òò  
new
òò! $
float3
òò% +
(
òò+ ,
extrusionDirs
òò, 9
[
òò9 :
i
òò: ;
]
òò; <
.
òò< =
x
òò= >
,
òò> ?
extrusionDirs
òò@ M
[
òòM N
i
òòN O
]
òòO P
.
òòP Q
y
òòQ R
,
òòR S
$num
òòT U
)
òòU V
;
òòV W
min
ôô 
=
ôô 
math
ôô 
.
ôô 
min
ôô 
(
ôô 
min
ôô "
,
ôô" #
point
ôô$ )
.
ôô) *
position
ôô* 2
+
ôô3 4

extrudeDir
ôô5 ?
*
ôô@ A
falloffDistance
ôôB Q
)
ôôQ R
;
ôôR S
max
öö 
=
öö 
math
öö 
.
öö 
max
öö 
(
öö 
max
öö "
,
öö" #
point
öö$ )
.
öö) *
position
öö* 2
+
öö3 4

extrudeDir
öö5 ?
*
öö@ A
falloffDistance
ööB Q
)
ööQ R
;
ööR S
}
õõ 
mesh
ùù 
.
ùù #
SetVertexBufferParams
ùù &
(
ùù& '
finalVertices
ùù' 4
.
ùù4 5
Length
ùù5 ;
,
ùù; <'
ParametricLightMeshVertex
ùù= V
.
ùùV W
VertexLayout
ùùW c
)
ùùc d
;
ùùd e
mesh
ûû 
.
ûû !
SetVertexBufferData
ûû $
(
ûû$ %
finalVertices
ûû% 2
,
ûû2 3
$num
ûû4 5
,
ûû5 6
$num
ûû7 8
,
ûû8 9
finalVertices
ûû: G
.
ûûG H
Length
ûûH N
)
ûûN O
;
ûûO P
mesh
üü 
.
üü 

SetIndices
üü 
(
üü 
finalIndices
üü (
,
üü( )
MeshTopology
üü* 6
.
üü6 7
	Triangles
üü7 @
,
üü@ A
$num
üüB C
,
üüC D
false
üüE J
)
üüJ K
;
üüK L
return
°° 
new
°° 
Bounds
°° 
{
¢¢ 
min
££ 
=
££ 
min
££ 
,
££ 
max
§§ 
=
§§ 
max
§§ 
}
•• 
;
•• 
}
¶¶ 	
public
©© 
static
©© 
int
©© 
GetShapePathHash
©© *
(
©©* +
Vector3
©©+ 2
[
©©2 3
]
©©3 4
path
©©5 9
)
©©9 :
{
™™ 	
	unchecked
´´ 
{
¨¨ 
int
≠≠ 
hashCode
≠≠ 
=
≠≠ 
(
≠≠  
int
≠≠  #
)
≠≠# $
$num
≠≠$ .
;
≠≠. /
if
ØØ 
(
ØØ 
path
ØØ 
!=
ØØ 
null
ØØ  
)
ØØ  !
{
∞∞ 
foreach
±± 
(
±± 
var
±±  
point
±±! &
in
±±' )
path
±±* .
)
±±. /
hashCode
≤≤  
=
≤≤! "
hashCode
≤≤# +
*
≤≤, -
$num
≤≤. 6
^
≤≤7 8
point
≤≤9 >
.
≤≤> ?
GetHashCode
≤≤? J
(
≤≤J K
)
≤≤K L
;
≤≤L M
}
≥≥ 
else
¥¥ 
{
µµ 
hashCode
∂∂ 
=
∂∂ 
$num
∂∂  
;
∂∂  !
}
∑∑ 
return
ππ 
hashCode
ππ 
;
ππ  
}
∫∫ 
}
ªª 	
}
ææ 
}øø ª
¶D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\ScriptableRendererFeature.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
ExcludeFromPreset 
] 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
abstract5 =
class> C%
ScriptableRendererFeatureD ]
:^ _
ScriptableObject` p
,p q
IDisposabler }
{ 
[ 	
SerializeField	 
, 
HideInInspector (
]( )
private* 1
bool2 6
m_Active7 ?
=@ A
trueB F
;F G
public 
bool 
isActive 
=> 
m_Active  (
;( )
public 
abstract 
void 
Create #
(# $
)$ %
;% &
public 
abstract 
void 
AddRenderPasses ,
(, -
ScriptableRenderer- ?
renderer@ H
,H I
refJ M
RenderingDataN [
renderingData\ i
)i j
;j k
void   
OnEnable   
(   
)   
{!! 	
Create"" 
("" 
)"" 
;"" 
}## 	
void%% 

OnValidate%% 
(%% 
)%% 
{&& 	
Create'' 
('' 
)'' 
;'' 
}(( 	
public// 
void// 
	SetActive// 
(// 
bool// "
active//# )
)//) *
{00 	
m_Active11 
=11 
active11 
;11 
}22 	
public77 
void77 
Dispose77 
(77 
)77 
{88 	
Dispose99 
(99 
true99 
)99 
;99 
GC:: 
.:: 
SuppressFinalize:: 
(::  
this::  $
)::$ %
;::% &
};; 	
	protected== 
virtual== 
void== 
Dispose== &
(==& '
bool==' +
	disposing==, 5
)==5 6
{>> 	
}?? 	
}@@ 
}AA µÛ	
£D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\PostProcessPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
public 

	interface !
IPostProcessComponent *
{ 
bool		 
IsActive		 
(		 
)		 
;		 
bool

 
IsTileCompatible

 
(

 
)

 
;

  
} 
} 
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
public 

class 
PostProcessPass  
:! " 
ScriptableRenderPass# 7
{ #
RenderTextureDescriptor 
m_Descriptor  ,
;, -
RenderTargetHandle 
m_Source #
;# $
RenderTargetHandle 
m_Destination (
;( )
RenderTargetHandle 
m_Depth "
;" #
RenderTargetHandle 
m_InternalLut (
;( )
const 
string %
k_RenderPostProcessingTag .
=/ 0
$str1 P
;P Q
const 
string *
k_RenderFinalPostProcessingTag 3
=4 5
$str6 X
;X Y
private 
static 
readonly 
ProfilingSampler  0+
m_ProfilingRenderPostProcessing1 P
=Q R
newS V
ProfilingSamplerW g
(g h&
k_RenderPostProcessingTag	h Å
)
Å Ç
;
Ç É
private   
static   
readonly   
ProfilingSampler    00
$m_ProfilingRenderFinalPostProcessing  1 U
=  V W
new  X [
ProfilingSampler  \ l
(  l m+
k_RenderFinalPostProcessingTag	  m ã
)
  ã å
;
  å ç
MaterialLibrary"" 
m_Materials"" #
;""# $
PostProcessData## 
m_Data## 
;## 
DepthOfField&& 
m_DepthOfField&& #
;&&# $

MotionBlur'' 
m_MotionBlur'' 
;''  
PaniniProjection(( 
m_PaniniProjection(( +
;((+ ,
Bloom)) 
m_Bloom)) 
;)) 
LensDistortion** 
m_LensDistortion** '
;**' (
ChromaticAberration++ !
m_ChromaticAberration++ 1
;++1 2
Vignette,, 

m_Vignette,, 
;,, 
ColorLookup-- 
m_ColorLookup-- !
;--! "
ColorAdjustments.. 
m_ColorAdjustments.. +
;..+ ,
Tonemapping// 
m_Tonemapping// !
;//! "
	FilmGrain00 
m_FilmGrain00 
;00 
const33 
int33 
k_MaxPyramidSize33 "
=33# $
$num33% '
;33' (
readonly44 
GraphicsFormat44 
m_DefaultHDRFormat44  2
;442 3
bool55 
	m_UseRGBM55 
;55 
readonly66 
GraphicsFormat66 
m_SMAAEdgeFormat66  0
;660 1
readonly77 
GraphicsFormat77 
m_GaussianCoCFormat77  3
;773 4
	Matrix4x488 
[88 
]88 
m_PrevViewProjM88 #
=88$ %
new88& )
	Matrix4x488* 3
[883 4
$num884 5
]885 6
;886 7
bool99 
m_ResetHistory99 
;99 
int:: #
m_DitheringTextureIndex:: #
;::# $"
RenderTargetIdentifier;; 
[;; 
];;  
m_MRT2;;! '
;;;' (
Vector4<< 
[<< 
]<< 
m_BokehKernel<< 
;<<  
int== 
m_BokehHash== 
;== 
bool@@ 
m_IsFinalPass@@ 
;@@ 
boolDD 
m_HasFinalPassDD 
;DD 
boolHH *
m_EnableSRGBConversionIfNeededHH +
;HH+ ,
boolKK 
m_UseDrawProceduralKK  
;KK  !
MaterialMM 
m_BlitMaterialMM 
;MM  
publicOO 
PostProcessPassOO 
(OO 
RenderPassEventOO .
evtOO/ 2
,OO2 3
PostProcessDataOO4 C
dataOOD H
,OOH I
MaterialOOJ R
blitMaterialOOS _
)OO_ `
{PP 	
baseQQ 
.QQ 
profilingSamplerQQ !
=QQ" #
newQQ$ '
ProfilingSamplerQQ( 8
(QQ8 9
nameofQQ9 ?
(QQ? @
PostProcessPassQQ@ O
)QQO P
)QQP Q
;QQQ R
renderPassEventRR 
=RR 
evtRR !
;RR! "
m_DataSS 
=SS 
dataSS 
;SS 
m_MaterialsTT 
=TT 
newTT 
MaterialLibraryTT -
(TT- .
dataTT. 2
)TT2 3
;TT3 4
m_BlitMaterialUU 
=UU 
blitMaterialUU )
;UU) *
ifXX 
(XX 

SystemInfoXX 
.XX 
IsFormatSupportedXX ,
(XX, -
GraphicsFormatXX- ;
.XX; <"
B10G11R11_UFloatPack32XX< R
,XXR S
FormatUsageXXT _
.XX_ `
LinearXX` f
|XXg h
FormatUsageXXi t
.XXt u
RenderXXu {
)XX{ |
)XX| }
{YY 
m_DefaultHDRFormatZZ "
=ZZ# $
GraphicsFormatZZ% 3
.ZZ3 4"
B10G11R11_UFloatPack32ZZ4 J
;ZZJ K
	m_UseRGBM[[ 
=[[ 
false[[ !
;[[! "
}\\ 
else]] 
{^^ 
m_DefaultHDRFormat__ "
=__# $
QualitySettings__% 4
.__4 5
activeColorSpace__5 E
==__F H

ColorSpace__I S
.__S T
Linear__T Z
?`` 
GraphicsFormat`` $
.``$ %
R8G8B8A8_SRGB``% 2
:aa 
GraphicsFormataa $
.aa$ %
R8G8B8A8_UNormaa% 3
;aa3 4
	m_UseRGBMbb 
=bb 
truebb  
;bb  !
}cc 
ifff 
(ff 

SystemInfoff 
.ff 
IsFormatSupportedff ,
(ff, -
GraphicsFormatff- ;
.ff; <

R8G8_UNormff< F
,ffF G
FormatUsageffH S
.ffS T
RenderffT Z
)ffZ [
&&ff\ ^

SystemInfoff_ i
.ffi j 
graphicsDeviceVendorffj ~
.ff~ 
ToLowerInvariant	ff è
(
ffè ê
)
ffê ë
.
ffë í
Contains
ffí ö
(
ffö õ
$str
ffõ †
)
ff† °
)
ff° ¢
m_SMAAEdgeFormatgg  
=gg! "
GraphicsFormatgg# 1
.gg1 2

R8G8_UNormgg2 <
;gg< =
elsehh 
m_SMAAEdgeFormatii  
=ii! "
GraphicsFormatii# 1
.ii1 2
R8G8B8A8_UNormii2 @
;ii@ A
ifkk 
(kk 

SystemInfokk 
.kk 
IsFormatSupportedkk ,
(kk, -
GraphicsFormatkk- ;
.kk; <
	R16_UNormkk< E
,kkE F
FormatUsagekkG R
.kkR S
LinearkkS Y
|kkZ [
FormatUsagekk\ g
.kkg h
Renderkkh n
)kkn o
)kko p
m_GaussianCoCFormatll #
=ll$ %
GraphicsFormatll& 4
.ll4 5
	R16_UNormll5 >
;ll> ?
elsemm 
ifmm 
(mm 

SystemInfomm 
.mm  
IsFormatSupportedmm  1
(mm1 2
GraphicsFormatmm2 @
.mm@ A

R16_SFloatmmA K
,mmK L
FormatUsagemmM X
.mmX Y
LinearmmY _
|mm` a
FormatUsagemmb m
.mmm n
Rendermmn t
)mmt u
)mmu v
m_GaussianCoCFormatnn #
=nn$ %
GraphicsFormatnn& 4
.nn4 5

R16_SFloatnn5 ?
;nn? @
elseoo 
m_GaussianCoCFormatpp #
=pp$ %
GraphicsFormatpp& 4
.pp4 5
R8_UNormpp5 =
;pp= >
ShaderConstantstt 
.tt 
_BloomMipUptt '
=tt( )
newtt* -
inttt. 1
[tt1 2
k_MaxPyramidSizett2 B
]ttB C
;ttC D
ShaderConstantsuu 
.uu 
_BloomMipDownuu )
=uu* +
newuu, /
intuu0 3
[uu3 4
k_MaxPyramidSizeuu4 D
]uuD E
;uuE F
forww 
(ww 
intww 
iww 
=ww 
$numww 
;ww 
iww 
<ww 
k_MaxPyramidSizeww  0
;ww0 1
iww2 3
++ww3 5
)ww5 6
{xx 
ShaderConstantsyy 
.yy  
_BloomMipUpyy  +
[yy+ ,
iyy, -
]yy- .
=yy/ 0
Shaderyy1 7
.yy7 8
PropertyToIDyy8 D
(yyD E
$stryyE R
+yyS T
iyyU V
)yyV W
;yyW X
ShaderConstantszz 
.zz  
_BloomMipDownzz  -
[zz- .
izz. /
]zz/ 0
=zz1 2
Shaderzz3 9
.zz9 :
PropertyToIDzz: F
(zzF G
$strzzG V
+zzW X
izzY Z
)zzZ [
;zz[ \
}{{ 
m_MRT2}} 
=}} 
new}} "
RenderTargetIdentifier}} /
[}}/ 0
$num}}0 1
]}}1 2
;}}2 3
m_ResetHistory~~ 
=~~ 
true~~ !
;~~! "
} 	
public
ÅÅ 
void
ÅÅ 
Cleanup
ÅÅ 
(
ÅÅ 
)
ÅÅ 
=>
ÅÅ  
m_Materials
ÅÅ! ,
.
ÅÅ, -
Cleanup
ÅÅ- 4
(
ÅÅ4 5
)
ÅÅ5 6
;
ÅÅ6 7
public
ÉÉ 
void
ÉÉ 
Setup
ÉÉ 
(
ÉÉ 
in
ÉÉ %
RenderTextureDescriptor
ÉÉ 4
baseDescriptor
ÉÉ5 C
,
ÉÉC D
in
ÉÉE G 
RenderTargetHandle
ÉÉH Z
source
ÉÉ[ a
,
ÉÉa b
in
ÉÉc e 
RenderTargetHandle
ÉÉf x
destinationÉÉy Ñ
,ÉÉÑ Ö
inÉÉÜ à"
RenderTargetHandleÉÉâ õ
depthÉÉú °
,ÉÉ° ¢
inÉÉ£ •"
RenderTargetHandleÉÉ¶ ∏
internalLutÉÉπ ƒ
,ÉÉƒ ≈
boolÉÉ∆  
hasFinalPassÉÉÀ ◊
,ÉÉ◊ ÿ
boolÉÉŸ ›$
enableSRGBConversionÉÉﬁ Ú
)ÉÉÚ Û
{
ÑÑ 	
m_Descriptor
ÖÖ 
=
ÖÖ 
baseDescriptor
ÖÖ )
;
ÖÖ) *
m_Source
ÜÜ 
=
ÜÜ 
source
ÜÜ 
;
ÜÜ 
m_Destination
áá 
=
áá 
destination
áá '
;
áá' (
m_Depth
àà 
=
àà 
depth
àà 
;
àà 
m_InternalLut
ââ 
=
ââ 
internalLut
ââ '
;
ââ' (
m_IsFinalPass
ää 
=
ää 
false
ää !
;
ää! "
m_HasFinalPass
ãã 
=
ãã 
hasFinalPass
ãã )
;
ãã) *,
m_EnableSRGBConversionIfNeeded
åå *
=
åå+ ,"
enableSRGBConversion
åå- A
;
ååA B
}
çç 	
public
èè 
void
èè 
SetupFinalPass
èè "
(
èè" #
in
èè# % 
RenderTargetHandle
èè& 8
source
èè9 ?
)
èè? @
{
êê 	
m_Source
ëë 
=
ëë 
source
ëë 
;
ëë 
m_Destination
íí 
=
íí  
RenderTargetHandle
íí .
.
íí. /
CameraTarget
íí/ ;
;
íí; <
m_IsFinalPass
ìì 
=
ìì 
true
ìì  
;
ìì  !
m_HasFinalPass
îî 
=
îî 
false
îî "
;
îî" #,
m_EnableSRGBConversionIfNeeded
ïï *
=
ïï+ ,
true
ïï- 1
;
ïï1 2
}
ññ 	
public
ôô 
override
ôô 
void
ôô 
OnCameraSetup
ôô *
(
ôô* +
CommandBuffer
ôô+ 8
cmd
ôô9 <
,
ôô< =
ref
ôô> A
RenderingData
ôôB O
renderingData
ôôP ]
)
ôô] ^
{
öö 	
if
õõ 
(
õõ 
m_Destination
õõ 
==
õõ   
RenderTargetHandle
õõ! 3
.
õõ3 4
CameraTarget
õõ4 @
)
õõ@ A
return
úú 
;
úú 
if
üü 
(
üü 
m_Destination
üü 
.
üü '
HasInternalRenderTargetId
üü 7
(
üü7 8
)
üü8 9
)
üü9 :
return
†† 
;
†† 
var
¢¢ 
desc
¢¢ 
=
¢¢ %
GetCompatibleDescriptor
¢¢ .
(
¢¢. /
)
¢¢/ 0
;
¢¢0 1
desc
££ 
.
££ 
depthBufferBits
££  
=
££! "
$num
££# $
;
££$ %
cmd
§§ 
.
§§ 
GetTemporaryRT
§§ 
(
§§ 
m_Destination
§§ ,
.
§§, -
id
§§- /
,
§§/ 0
desc
§§1 5
,
§§5 6

FilterMode
§§7 A
.
§§A B
Point
§§B G
)
§§G H
;
§§H I
}
•• 	
public
®® 
override
®® 
void
®® 
OnCameraCleanup
®® ,
(
®®, -
CommandBuffer
®®- :
cmd
®®; >
)
®®> ?
{
©© 	
if
™™ 
(
™™ 
m_Destination
™™ 
==
™™   
RenderTargetHandle
™™! 3
.
™™3 4
CameraTarget
™™4 @
)
™™@ A
return
´´ 
;
´´ 
if
ÆÆ 
(
ÆÆ 
m_Destination
ÆÆ 
.
ÆÆ '
HasInternalRenderTargetId
ÆÆ 7
(
ÆÆ7 8
)
ÆÆ8 9
)
ÆÆ9 :
return
ØØ 
;
ØØ 
cmd
±± 
.
±±  
ReleaseTemporaryRT
±± "
(
±±" #
m_Destination
±±# 0
.
±±0 1
id
±±1 3
)
±±3 4
;
±±4 5
}
≤≤ 	
public
¥¥ 
void
¥¥ 
ResetHistory
¥¥  
(
¥¥  !
)
¥¥! "
{
µµ 	
m_ResetHistory
∂∂ 
=
∂∂ 
true
∂∂ !
;
∂∂! "
}
∑∑ 	
public
ππ 
bool
ππ 
CanRunOnTile
ππ  
(
ππ  !
)
ππ! "
{
∫∫ 	
return
ºº 
false
ºº 
;
ºº 
}
ΩΩ 	
public
¿¿ 
override
¿¿ 
void
¿¿ 
Execute
¿¿ $
(
¿¿$ %%
ScriptableRenderContext
¿¿% <
context
¿¿= D
,
¿¿D E
ref
¿¿F I
RenderingData
¿¿J W
renderingData
¿¿X e
)
¿¿e f
{
¡¡ 	
var
ƒƒ 
stack
ƒƒ 
=
ƒƒ 
VolumeManager
ƒƒ %
.
ƒƒ% &
instance
ƒƒ& .
.
ƒƒ. /
stack
ƒƒ/ 4
;
ƒƒ4 5
m_DepthOfField
≈≈ 
=
≈≈" #
stack
≈≈$ )
.
≈≈) *
GetComponent
≈≈* 6
<
≈≈6 7
DepthOfField
≈≈7 C
>
≈≈C D
(
≈≈D E
)
≈≈E F
;
≈≈F G
m_MotionBlur
∆∆ 
=
∆∆" #
stack
∆∆$ )
.
∆∆) *
GetComponent
∆∆* 6
<
∆∆6 7

MotionBlur
∆∆7 A
>
∆∆A B
(
∆∆B C
)
∆∆C D
;
∆∆D E 
m_PaniniProjection
«« 
=
««" #
stack
««$ )
.
««) *
GetComponent
««* 6
<
««6 7
PaniniProjection
««7 G
>
««G H
(
««H I
)
««I J
;
««J K
m_Bloom
»» 
=
»»" #
stack
»»$ )
.
»») *
GetComponent
»»* 6
<
»»6 7
Bloom
»»7 <
>
»»< =
(
»»= >
)
»»> ?
;
»»? @
m_LensDistortion
…… 
=
……" #
stack
……$ )
.
……) *
GetComponent
……* 6
<
……6 7
LensDistortion
……7 E
>
……E F
(
……F G
)
……G H
;
……H I#
m_ChromaticAberration
   !
=
  " #
stack
  $ )
.
  ) *
GetComponent
  * 6
<
  6 7!
ChromaticAberration
  7 J
>
  J K
(
  K L
)
  L M
;
  M N

m_Vignette
ÀÀ 
=
ÀÀ" #
stack
ÀÀ$ )
.
ÀÀ) *
GetComponent
ÀÀ* 6
<
ÀÀ6 7
Vignette
ÀÀ7 ?
>
ÀÀ? @
(
ÀÀ@ A
)
ÀÀA B
;
ÀÀB C
m_ColorLookup
ÃÃ 
=
ÃÃ" #
stack
ÃÃ$ )
.
ÃÃ) *
GetComponent
ÃÃ* 6
<
ÃÃ6 7
ColorLookup
ÃÃ7 B
>
ÃÃB C
(
ÃÃC D
)
ÃÃD E
;
ÃÃE F 
m_ColorAdjustments
ÕÕ 
=
ÕÕ" #
stack
ÕÕ$ )
.
ÕÕ) *
GetComponent
ÕÕ* 6
<
ÕÕ6 7
ColorAdjustments
ÕÕ7 G
>
ÕÕG H
(
ÕÕH I
)
ÕÕI J
;
ÕÕJ K
m_Tonemapping
ŒŒ 
=
ŒŒ" #
stack
ŒŒ$ )
.
ŒŒ) *
GetComponent
ŒŒ* 6
<
ŒŒ6 7
Tonemapping
ŒŒ7 B
>
ŒŒB C
(
ŒŒC D
)
ŒŒD E
;
ŒŒE F
m_FilmGrain
œœ 
=
œœ" #
stack
œœ$ )
.
œœ) *
GetComponent
œœ* 6
<
œœ6 7
	FilmGrain
œœ7 @
>
œœ@ A
(
œœA B
)
œœB C
;
œœC D!
m_UseDrawProcedural
–– 
=
––" #
renderingData
––$ 1
.
––1 2

cameraData
––2 <
.
––< =
xr
––= ?
.
––? @
enabled
––@ G
;
––G H
if
““ 
(
““ 
m_IsFinalPass
““ 
)
““ 
{
”” 
var
‘‘ 
cmd
‘‘ 
=
‘‘ 
CommandBufferPool
‘‘ +
.
‘‘+ ,
Get
‘‘, /
(
‘‘/ 0
)
‘‘0 1
;
‘‘1 2
using
’’ 
(
’’ 
new
’’ 
ProfilingScope
’’ )
(
’’) *
cmd
’’* -
,
’’- .2
$m_ProfilingRenderFinalPostProcessing
’’/ S
)
’’S T
)
’’T U
{
÷÷ 
RenderFinalPass
◊◊ #
(
◊◊# $
cmd
◊◊$ '
,
◊◊' (
ref
◊◊) ,
renderingData
◊◊- :
)
◊◊: ;
;
◊◊; <
}
ÿÿ 
context
⁄⁄ 
.
⁄⁄ "
ExecuteCommandBuffer
⁄⁄ ,
(
⁄⁄, -
cmd
⁄⁄- 0
)
⁄⁄0 1
;
⁄⁄1 2
CommandBufferPool
€€ !
.
€€! "
Release
€€" )
(
€€) *
cmd
€€* -
)
€€- .
;
€€. /
}
‹‹ 
else
›› 
if
›› 
(
›› 
CanRunOnTile
›› !
(
››! "
)
››" #
)
››# $
{
ﬁﬁ 
}
·· 
else
‚‚ 
{
„„ 
var
ÊÊ 
cmd
ÊÊ 
=
ÊÊ 
CommandBufferPool
ÊÊ +
.
ÊÊ+ ,
Get
ÊÊ, /
(
ÊÊ/ 0
)
ÊÊ0 1
;
ÊÊ1 2
using
ÁÁ 
(
ÁÁ 
new
ÁÁ 
ProfilingScope
ÁÁ )
(
ÁÁ) *
cmd
ÁÁ* -
,
ÁÁ- .-
m_ProfilingRenderPostProcessing
ÁÁ/ N
)
ÁÁN O
)
ÁÁO P
{
ËË 
Render
ÈÈ 
(
ÈÈ 
cmd
ÈÈ 
,
ÈÈ 
ref
ÈÈ  #
renderingData
ÈÈ$ 1
)
ÈÈ1 2
;
ÈÈ2 3
}
ÍÍ 
context
ÏÏ 
.
ÏÏ "
ExecuteCommandBuffer
ÏÏ ,
(
ÏÏ, -
cmd
ÏÏ- 0
)
ÏÏ0 1
;
ÏÏ1 2
CommandBufferPool
ÌÌ !
.
ÌÌ! "
Release
ÌÌ" )
(
ÌÌ) *
cmd
ÌÌ* -
)
ÌÌ- .
;
ÌÌ. /
}
ÓÓ 
m_ResetHistory
 
=
 
false
 "
;
" #
}
ÒÒ 	%
RenderTextureDescriptor
ÛÛ %
GetCompatibleDescriptor
ÛÛ  7
(
ÛÛ7 8
)
ÛÛ8 9
=>
ÙÙ %
GetCompatibleDescriptor
ÙÙ &
(
ÙÙ& '
m_Descriptor
ÙÙ' 3
.
ÙÙ3 4
width
ÙÙ4 9
,
ÙÙ9 :
m_Descriptor
ÙÙ; G
.
ÙÙG H
height
ÙÙH N
,
ÙÙN O
m_Descriptor
ÙÙP \
.
ÙÙ\ ]
graphicsFormat
ÙÙ] k
,
ÙÙk l
m_Descriptor
ÙÙm y
.
ÙÙy z
depthBufferBitsÙÙz â
)ÙÙâ ä
;ÙÙä ã%
RenderTextureDescriptor
ˆˆ %
GetCompatibleDescriptor
ˆˆ  7
(
ˆˆ7 8
int
ˆˆ8 ;
width
ˆˆ< A
,
ˆˆA B
int
ˆˆC F
height
ˆˆG M
,
ˆˆM N
GraphicsFormat
ˆˆO ]
format
ˆˆ^ d
,
ˆˆd e
int
ˆˆf i
depthBufferBits
ˆˆj y
=
ˆˆz {
$num
ˆˆ| }
)
ˆˆ} ~
{
˜˜ 	
var
¯¯ 
desc
¯¯ 
=
¯¯ 
m_Descriptor
¯¯ #
;
¯¯# $
desc
˘˘ 
.
˘˘ 
depthBufferBits
˘˘  
=
˘˘! "
depthBufferBits
˘˘# 2
;
˘˘2 3
desc
˙˙ 
.
˙˙ 
msaaSamples
˙˙ 
=
˙˙ 
$num
˙˙  
;
˙˙  !
desc
˚˚ 
.
˚˚ 
width
˚˚ 
=
˚˚ 
width
˚˚ 
;
˚˚ 
desc
¸¸ 
.
¸¸ 
height
¸¸ 
=
¸¸ 
height
¸¸  
;
¸¸  !
desc
˝˝ 
.
˝˝ 
graphicsFormat
˝˝ 
=
˝˝  !
format
˝˝" (
;
˝˝( )
return
˛˛ 
desc
˛˛ 
;
˛˛ 
}
ˇˇ 	
bool
ÅÅ 3
%RequireSRGBConversionBlitToBackBuffer
ÅÅ 2
(
ÅÅ2 3

CameraData
ÅÅ3 =

cameraData
ÅÅ> H
)
ÅÅH I
{
ÇÇ 	
return
ÉÉ 

cameraData
ÉÉ 
.
ÉÉ #
requireSrgbConversion
ÉÉ 3
&&
ÉÉ4 6,
m_EnableSRGBConversionIfNeeded
ÉÉ7 U
;
ÉÉU V
}
ÑÑ 	
private
ÜÜ 
new
ÜÜ 
void
ÜÜ 
Blit
ÜÜ 
(
ÜÜ 
CommandBuffer
ÜÜ +
cmd
ÜÜ, /
,
ÜÜ/ 0$
RenderTargetIdentifier
ÜÜ1 G
source
ÜÜH N
,
ÜÜN O$
RenderTargetIdentifier
ÜÜP f
destination
ÜÜg r
,
ÜÜr s
Material
ÜÜt |
materialÜÜ} Ö
,ÜÜÖ Ü
intÜÜá ä
	passIndexÜÜã î
=ÜÜï ñ
$numÜÜó ò
)ÜÜò ô
{
áá 	
cmd
àà 
.
àà 
SetGlobalTexture
àà  
(
àà  !
ShaderPropertyId
àà! 1
.
àà1 2
	sourceTex
àà2 ;
,
àà; <
source
àà= C
)
ààC D
;
ààD E
if
ââ 
(
ââ !
m_UseDrawProcedural
ââ #
)
ââ# $
{
ää 
Vector4
ãã 
	scaleBias
ãã !
=
ãã" #
new
ãã$ '
Vector4
ãã( /
(
ãã/ 0
$num
ãã0 1
,
ãã1 2
$num
ãã3 4
,
ãã4 5
$num
ãã6 7
,
ãã7 8
$num
ãã9 :
)
ãã: ;
;
ãã; <
cmd
åå 
.
åå 
SetGlobalVector
åå #
(
åå# $
ShaderPropertyId
åå$ 4
.
åå4 5
	scaleBias
åå5 >
,
åå> ?
	scaleBias
åå@ I
)
ååI J
;
ååJ K
cmd
éé 
.
éé 
SetRenderTarget
éé #
(
éé# $
new
éé$ '$
RenderTargetIdentifier
éé( >
(
éé> ?
destination
éé? J
,
ééJ K
$num
ééL M
,
ééM N
CubemapFace
ééO Z
.
ééZ [
Unknown
éé[ b
,
ééb c
-
ééd e
$num
éée f
)
ééf g
,
éég h$
RenderBufferLoadAction
èè *
.
èè* +
Load
èè+ /
,
èè/ 0%
RenderBufferStoreAction
èè1 H
.
èèH I
Store
èèI N
,
èèN O$
RenderBufferLoadAction
èèP f
.
èèf g
Load
èèg k
,
èèk l&
RenderBufferStoreActionèèm Ñ
.èèÑ Ö
StoreèèÖ ä
)èèä ã
;èèã å
cmd
êê 
.
êê 
DrawProcedural
êê "
(
êê" #
	Matrix4x4
êê# ,
.
êê, -
identity
êê- 5
,
êê5 6
material
êê7 ?
,
êê? @
	passIndex
êêA J
,
êêJ K
MeshTopology
êêL X
.
êêX Y
Quads
êêY ^
,
êê^ _
$num
êê` a
,
êêa b
$num
êêc d
,
êêd e
null
êêf j
)
êêj k
;
êêk l
}
ëë 
else
íí 
{
ìì 
cmd
îî 
.
îî 
Blit
îî 
(
îî 
source
îî 
,
îî  
destination
îî! ,
,
îî, -
material
îî. 6
,
îî6 7
	passIndex
îî8 A
)
îîA B
;
îîB C
}
ïï 
}
ññ 	
private
òò 
void
òò  
DrawFullscreenMesh
òò '
(
òò' (
CommandBuffer
òò( 5
cmd
òò6 9
,
òò9 :
Material
òò; C
material
òòD L
,
òòL M
int
òòN Q
	passIndex
òòR [
)
òò[ \
{
ôô 	
if
öö 
(
öö !
m_UseDrawProcedural
öö #
)
öö# $
{
õõ 
Vector4
úú 
	scaleBias
úú !
=
úú" #
new
úú$ '
Vector4
úú( /
(
úú/ 0
$num
úú0 1
,
úú1 2
$num
úú3 4
,
úú4 5
$num
úú6 7
,
úú7 8
$num
úú9 :
)
úú: ;
;
úú; <
cmd
ùù 
.
ùù 
SetGlobalVector
ùù #
(
ùù# $
ShaderPropertyId
ùù$ 4
.
ùù4 5
	scaleBias
ùù5 >
,
ùù> ?
	scaleBias
ùù@ I
)
ùùI J
;
ùùJ K
cmd
ûû 
.
ûû 
DrawProcedural
ûû "
(
ûû" #
	Matrix4x4
ûû# ,
.
ûû, -
identity
ûû- 5
,
ûû5 6
material
ûû7 ?
,
ûû? @
	passIndex
ûûA J
,
ûûJ K
MeshTopology
ûûL X
.
ûûX Y
Quads
ûûY ^
,
ûû^ _
$num
ûû` a
,
ûûa b
$num
ûûc d
,
ûûd e
null
ûûf j
)
ûûj k
;
ûûk l
}
üü 
else
†† 
{
°° 
cmd
¢¢ 
.
¢¢ 
DrawMesh
¢¢ 
(
¢¢ 
RenderingUtils
¢¢ +
.
¢¢+ ,
fullscreenMesh
¢¢, :
,
¢¢: ;
	Matrix4x4
¢¢< E
.
¢¢E F
identity
¢¢F N
,
¢¢N O
material
¢¢P X
,
¢¢X Y
$num
¢¢Z [
,
¢¢[ \
	passIndex
¢¢] f
)
¢¢f g
;
¢¢g h
}
££ 
}
§§ 	
void
¶¶ 
Render
¶¶ 
(
¶¶ 
CommandBuffer
¶¶ !
cmd
¶¶" %
,
¶¶% &
ref
¶¶' *
RenderingData
¶¶+ 8
renderingData
¶¶9 F
)
¶¶F G
{
ßß 	
ref
®® 
var
®® 

cameraData
®® 
=
®®  
ref
®®! $
renderingData
®®% 2
.
®®2 3

cameraData
®®3 =
;
®®= >
bool
¨¨ 
tempTargetUsed
¨¨ 
=
¨¨  !
false
¨¨" '
;
¨¨' (
bool
≠≠ 
tempTarget2Used
≠≠  
=
≠≠! "
false
≠≠# (
;
≠≠( )
int
ÆÆ 
source
ÆÆ 
=
ÆÆ 
m_Source
ÆÆ !
.
ÆÆ! "
id
ÆÆ" $
;
ÆÆ$ %
int
ØØ 
destination
ØØ 
=
ØØ 
-
ØØ 
$num
ØØ  
;
ØØ  !
bool
∞∞ 
isSceneViewCamera
∞∞ "
=
∞∞# $

cameraData
∞∞% /
.
∞∞/ 0
isSceneViewCamera
∞∞0 A
;
∞∞A B
int
≥≥ 
	GetSource
≥≥ 
(
≥≥ 
)
≥≥ 
=>
≥≥ 
source
≥≥ %
;
≥≥% &
int
µµ 
GetDestination
µµ 
(
µµ 
)
µµ  
{
∂∂ 
if
∑∑ 
(
∑∑ 
destination
∑∑ 
==
∑∑  "
-
∑∑# $
$num
∑∑$ %
)
∑∑% &
{
∏∏ 
cmd
ππ 
.
ππ 
GetTemporaryRT
ππ &
(
ππ& '
ShaderConstants
ππ' 6
.
ππ6 7
_TempTarget
ππ7 B
,
ππB C%
GetCompatibleDescriptor
ππD [
(
ππ[ \
)
ππ\ ]
,
ππ] ^

FilterMode
ππ_ i
.
ππi j
Bilinear
ππj r
)
ππr s
;
ππs t
destination
∫∫ 
=
∫∫  !
ShaderConstants
∫∫" 1
.
∫∫1 2
_TempTarget
∫∫2 =
;
∫∫= >
tempTargetUsed
ªª "
=
ªª# $
true
ªª% )
;
ªª) *
}
ºº 
else
ΩΩ 
if
ΩΩ 
(
ΩΩ 
destination
ΩΩ $
==
ΩΩ% '
m_Source
ΩΩ( 0
.
ΩΩ0 1
id
ΩΩ1 3
&&
ΩΩ4 6
m_Descriptor
ΩΩ7 C
.
ΩΩC D
msaaSamples
ΩΩD O
>
ΩΩP Q
$num
ΩΩR S
)
ΩΩS T
{
ææ 
cmd
¿¿ 
.
¿¿ 
GetTemporaryRT
¿¿ &
(
¿¿& '
ShaderConstants
¿¿' 6
.
¿¿6 7
_TempTarget2
¿¿7 C
,
¿¿C D%
GetCompatibleDescriptor
¿¿E \
(
¿¿\ ]
)
¿¿] ^
,
¿¿^ _

FilterMode
¿¿` j
.
¿¿j k
Bilinear
¿¿k s
)
¿¿s t
;
¿¿t u
destination
¡¡ 
=
¡¡  !
ShaderConstants
¡¡" 1
.
¡¡1 2
_TempTarget2
¡¡2 >
;
¡¡> ?
tempTarget2Used
¬¬ #
=
¬¬$ %
true
¬¬& *
;
¬¬* +
}
√√ 
return
≈≈ 
destination
≈≈ "
;
≈≈" #
}
∆∆ 
void
»» 
Swap
»» 
(
»» 
)
»» 
=>
»» 
	CoreUtils
»» $
.
»»$ %
Swap
»»% )
(
»») *
ref
»»* -
source
»». 4
,
»»4 5
ref
»»6 9
destination
»»: E
)
»»E F
;
»»F G
cmd
ÀÀ 
.
ÀÀ 
SetGlobalMatrix
ÀÀ 
(
ÀÀ  
ShaderConstants
ÀÀ  /
.
ÀÀ/ 0 
_FullscreenProjMat
ÀÀ0 B
,
ÀÀB C
GL
ÀÀD F
.
ÀÀF G$
GetGPUProjectionMatrix
ÀÀG ]
(
ÀÀ] ^
	Matrix4x4
ÀÀ^ g
.
ÀÀg h
identity
ÀÀh p
,
ÀÀp q
true
ÀÀr v
)
ÀÀv w
)
ÀÀw x
;
ÀÀx y
if
œœ 
(
œœ 

cameraData
œœ 
.
œœ 
isStopNaNEnabled
œœ +
&&
œœ, .
m_Materials
œœ/ :
.
œœ: ;
stopNaN
œœ; B
!=
œœC E
null
œœF J
)
œœJ K
{
–– 
using
—— 
(
—— 
new
—— 
ProfilingScope
—— )
(
——) *
cmd
——* -
,
——- .
ProfilingSampler
——/ ?
.
——? @
Get
——@ C
(
——C D
URPProfileId
——D P
.
——P Q
StopNaNs
——Q Y
)
——Y Z
)
——Z [
)
——[ \
{
““ 
RenderingUtils
”” "
.
””" #
Blit
””# '
(
””' (
cmd
‘‘ 
,
‘‘ 
	GetSource
‘‘ &
(
‘‘& '
)
‘‘' (
,
‘‘( )
GetDestination
‘‘* 8
(
‘‘8 9
)
‘‘9 :
,
‘‘: ;
m_Materials
‘‘< G
.
‘‘G H
stopNaN
‘‘H O
,
‘‘O P
$num
‘‘Q R
,
‘‘R S!
m_UseDrawProcedural
‘‘T g
,
‘‘g h$
RenderBufferLoadAction
’’ .
.
’’. /
DontCare
’’/ 7
,
’’7 8%
RenderBufferStoreAction
’’9 P
.
’’P Q
Store
’’Q V
,
’’V W$
RenderBufferLoadAction
÷÷ .
.
÷÷. /
DontCare
÷÷/ 7
,
÷÷7 8%
RenderBufferStoreAction
÷÷9 P
.
÷÷P Q
DontCare
÷÷Q Y
)
÷÷Y Z
;
÷÷Z [
Swap
ÿÿ 
(
ÿÿ 
)
ÿÿ 
;
ÿÿ 
}
ŸŸ 
}
⁄⁄ 
if
›› 
(
›› 

cameraData
›› 
.
›› 
antialiasing
›› '
==
››( *
AntialiasingMode
››+ ;
.
››; </
!SubpixelMorphologicalAntiAliasing
››< ]
&&
››^ `

SystemInfo
››a k
.
››k l 
graphicsDeviceType
››l ~
!=›› Å"
GraphicsDeviceType››Ç î
.››î ï
	OpenGLES2››ï û
)››û ü
{
ﬁﬁ 
using
‡‡ 
(
‡‡ 
new
‡‡ 
ProfilingScope
‡‡ )
(
‡‡) *
cmd
‡‡* -
,
‡‡- .
ProfilingSampler
‡‡/ ?
.
‡‡? @
Get
‡‡@ C
(
‡‡C D
URPProfileId
‡‡D P
.
‡‡P Q
SMAA
‡‡Q U
)
‡‡U V
)
‡‡V W
)
‡‡W X
{
·· 1
#DoSubpixelMorphologicalAntialiasing
‚‚ 7
(
‚‚7 8
ref
‚‚8 ;

cameraData
‚‚< F
,
‚‚F G
cmd
‚‚H K
,
‚‚K L
	GetSource
‚‚M V
(
‚‚V W
)
‚‚W X
,
‚‚X Y
GetDestination
‚‚Z h
(
‚‚h i
)
‚‚i j
)
‚‚j k
;
‚‚k l
Swap
„„ 
(
„„ 
)
„„ 
;
„„ 
}
‰‰ 
}
ÂÂ 
if
ËË 
(
ËË 
m_DepthOfField
ËË 
.
ËË 
IsActive
ËË '
(
ËË' (
)
ËË( )
&&
ËË* ,
!
ËË- .
isSceneViewCamera
ËË. ?
)
ËË? @
{
ÈÈ 
var
ÍÍ 

markerName
ÍÍ 
=
ÍÍ  
m_DepthOfField
ÍÍ! /
.
ÍÍ/ 0
mode
ÍÍ0 4
.
ÍÍ4 5
value
ÍÍ5 :
==
ÍÍ; =
DepthOfFieldMode
ÍÍ> N
.
ÍÍN O
Gaussian
ÍÍO W
?
ÎÎ 
URPProfileId
ÎÎ "
.
ÎÎ" #"
GaussianDepthOfField
ÎÎ# 7
:
ÏÏ 
URPProfileId
ÏÏ "
.
ÏÏ" #
BokehDepthOfField
ÏÏ# 4
;
ÏÏ4 5
using
ÓÓ 
(
ÓÓ 
new
ÓÓ 
ProfilingScope
ÓÓ )
(
ÓÓ) *
cmd
ÓÓ* -
,
ÓÓ- .
ProfilingSampler
ÓÓ/ ?
.
ÓÓ? @
Get
ÓÓ@ C
(
ÓÓC D

markerName
ÓÓD N
)
ÓÓN O
)
ÓÓO P
)
ÓÓP Q
{
ÔÔ 
DoDepthOfField
 "
(
" #

cameraData
# -
.
- .
camera
. 4
,
4 5
cmd
6 9
,
9 :
	GetSource
; D
(
D E
)
E F
,
F G
GetDestination
H V
(
V W
)
W X
,
X Y

cameraData
Z d
.
d e
	pixelRect
e n
)
n o
;
o p
Swap
ÒÒ 
(
ÒÒ 
)
ÒÒ 
;
ÒÒ 
}
ÚÚ 
}
ÛÛ 
if
ˆˆ 
(
ˆˆ 
m_MotionBlur
ˆˆ 
.
ˆˆ 
IsActive
ˆˆ %
(
ˆˆ% &
)
ˆˆ& '
&&
ˆˆ( *
!
ˆˆ+ ,
isSceneViewCamera
ˆˆ, =
)
ˆˆ= >
{
˜˜ 
using
¯¯ 
(
¯¯ 
new
¯¯ 
ProfilingScope
¯¯ )
(
¯¯) *
cmd
¯¯* -
,
¯¯- .
ProfilingSampler
¯¯/ ?
.
¯¯? @
Get
¯¯@ C
(
¯¯C D
URPProfileId
¯¯D P
.
¯¯P Q

MotionBlur
¯¯Q [
)
¯¯[ \
)
¯¯\ ]
)
¯¯] ^
{
˘˘ 
DoMotionBlur
˙˙  
(
˙˙  !

cameraData
˙˙! +
,
˙˙+ ,
cmd
˙˙- 0
,
˙˙0 1
	GetSource
˙˙2 ;
(
˙˙; <
)
˙˙< =
,
˙˙= >
GetDestination
˙˙? M
(
˙˙M N
)
˙˙N O
)
˙˙O P
;
˙˙P Q
Swap
˚˚ 
(
˚˚ 
)
˚˚ 
;
˚˚ 
}
¸¸ 
}
˝˝ 
if
ÅÅ 
(
ÅÅ  
m_PaniniProjection
ÅÅ "
.
ÅÅ" #
IsActive
ÅÅ# +
(
ÅÅ+ ,
)
ÅÅ, -
&&
ÅÅ. 0
!
ÅÅ1 2
isSceneViewCamera
ÅÅ2 C
)
ÅÅC D
{
ÇÇ 
using
ÉÉ 
(
ÉÉ 
new
ÉÉ 
ProfilingScope
ÉÉ )
(
ÉÉ) *
cmd
ÉÉ* -
,
ÉÉ- .
ProfilingSampler
ÉÉ/ ?
.
ÉÉ? @
Get
ÉÉ@ C
(
ÉÉC D
URPProfileId
ÉÉD P
.
ÉÉP Q
PaniniProjection
ÉÉQ a
)
ÉÉa b
)
ÉÉb c
)
ÉÉc d
{
ÑÑ  
DoPaniniProjection
ÖÖ &
(
ÖÖ& '

cameraData
ÖÖ' 1
.
ÖÖ1 2
camera
ÖÖ2 8
,
ÖÖ8 9
cmd
ÖÖ: =
,
ÖÖ= >
	GetSource
ÖÖ? H
(
ÖÖH I
)
ÖÖI J
,
ÖÖJ K
GetDestination
ÖÖL Z
(
ÖÖZ [
)
ÖÖ[ \
)
ÖÖ\ ]
;
ÖÖ] ^
Swap
ÜÜ 
(
ÜÜ 
)
ÜÜ 
;
ÜÜ 
}
áá 
}
àà 
using
ãã 
(
ãã 
new
ãã 
ProfilingScope
ãã %
(
ãã% &
cmd
ãã& )
,
ãã) *
ProfilingSampler
ãã+ ;
.
ãã; <
Get
ãã< ?
(
ãã? @
URPProfileId
ãã@ L
.
ããL M
UberPostProcess
ããM \
)
ãã\ ]
)
ãã] ^
)
ãã^ _
{
åå 
m_Materials
éé 
.
éé 
uber
éé  
.
éé  !
shaderKeywords
éé! /
=
éé0 1
null
éé2 6
;
éé6 7
bool
ëë 
bloomActive
ëë  
=
ëë! "
m_Bloom
ëë# *
.
ëë* +
IsActive
ëë+ 3
(
ëë3 4
)
ëë4 5
;
ëë5 6
if
íí 
(
íí 
bloomActive
íí 
)
íí  
{
ìì 
using
îî 
(
îî 
new
îî 
ProfilingScope
îî -
(
îî- .
cmd
îî. 1
,
îî1 2
ProfilingSampler
îî3 C
.
îîC D
Get
îîD G
(
îîG H
URPProfileId
îîH T
.
îîT U
Bloom
îîU Z
)
îîZ [
)
îî[ \
)
îî\ ]

SetupBloom
ïï "
(
ïï" #
cmd
ïï# &
,
ïï& '
	GetSource
ïï( 1
(
ïï1 2
)
ïï2 3
,
ïï3 4
m_Materials
ïï5 @
.
ïï@ A
uber
ïïA E
)
ïïE F
;
ïïF G
}
ññ !
SetupLensDistortion
ôô #
(
ôô# $
m_Materials
ôô$ /
.
ôô/ 0
uber
ôô0 4
,
ôô4 5
isSceneViewCamera
ôô6 G
)
ôôG H
;
ôôH I&
SetupChromaticAberration
öö (
(
öö( )
m_Materials
öö) 4
.
öö4 5
uber
öö5 9
)
öö9 :
;
öö: ;
SetupVignette
õõ 
(
õõ 
m_Materials
õõ )
.
õõ) *
uber
õõ* .
)
õõ. /
;
õõ/ 0
SetupColorGrading
úú !
(
úú! "
cmd
úú" %
,
úú% &
ref
úú' *
renderingData
úú+ 8
,
úú8 9
m_Materials
úú: E
.
úúE F
uber
úúF J
)
úúJ K
;
úúK L

SetupGrain
üü 
(
üü 

cameraData
üü %
,
üü% &
m_Materials
üü' 2
.
üü2 3
uber
üü3 7
)
üü7 8
;
üü8 9
SetupDithering
†† 
(
†† 

cameraData
†† )
,
††) *
m_Materials
††+ 6
.
††6 7
uber
††7 ;
)
††; <
;
††< =
if
¢¢ 
(
¢¢ 3
%RequireSRGBConversionBlitToBackBuffer
¢¢ 9
(
¢¢9 :

cameraData
¢¢: D
)
¢¢D E
)
¢¢E F
m_Materials
££ 
.
££  
uber
££  $
.
££$ %
EnableKeyword
££% 2
(
££2 3"
ShaderKeywordStrings
££3 G
.
££G H$
LinearToSRGBConversion
££H ^
)
££^ _
;
££_ `
cmd
¶¶ 
.
¶¶ 
SetGlobalTexture
¶¶ $
(
¶¶$ %
ShaderPropertyId
¶¶% 5
.
¶¶5 6
	sourceTex
¶¶6 ?
,
¶¶? @
	GetSource
¶¶A J
(
¶¶J K
)
¶¶K L
)
¶¶L M
;
¶¶M N
var
®® 
colorLoadAction
®® #
=
®®$ %$
RenderBufferLoadAction
®®& <
.
®®< =
DontCare
®®= E
;
®®E F
if
©© 
(
©© 
m_Destination
©© !
==
©©" $ 
RenderTargetHandle
©©% 7
.
©©7 8
CameraTarget
©©8 D
&&
©©E G
!
©©H I

cameraData
©©I S
.
©©S T
isDefaultViewport
©©T e
)
©©e f
colorLoadAction
™™ #
=
™™$ %$
RenderBufferLoadAction
™™& <
.
™™< =
Load
™™= A
;
™™A B 
RenderTargetHandle
ÆÆ " 
cameraTargetHandle
ÆÆ# 5
=
ÆÆ6 7 
RenderTargetHandle
ÆÆ8 J
.
ÆÆJ K
GetCameraTarget
ÆÆK Z
(
ÆÆZ [

cameraData
ÆÆ[ e
.
ÆÆe f
xr
ÆÆf h
)
ÆÆh i
;
ÆÆi j$
RenderTargetIdentifier
ØØ &
cameraTarget
ØØ' 3
=
ØØ4 5
(
ØØ6 7

cameraData
ØØ7 A
.
ØØA B
targetTexture
ØØB O
!=
ØØP R
null
ØØS W
&&
ØØX Z
!
ØØ[ \

cameraData
ØØ\ f
.
ØØf g
xr
ØØg i
.
ØØi j
enabled
ØØj q
)
ØØq r
?
ØØs t
new
ØØu x%
RenderTargetIdentifierØØy è
(ØØè ê

cameraDataØØê ö
.ØØö õ
targetTextureØØõ ®
)ØØ® ©
:ØØ™ ´"
cameraTargetHandleØØ¨ æ
.ØØæ ø

IdentifierØØø …
(ØØ…  
)ØØ  À
;ØØÀ Ã
cameraTarget
∞∞ 
=
∞∞ 
(
∞∞  
m_Destination
∞∞  -
==
∞∞. 0 
RenderTargetHandle
∞∞1 C
.
∞∞C D
CameraTarget
∞∞D P
)
∞∞P Q
?
∞∞R S
cameraTarget
∞∞T `
:
∞∞a b
m_Destination
∞∞c p
.
∞∞p q

Identifier
∞∞q {
(
∞∞{ |
)
∞∞| }
;
∞∞} ~
bool
≥≥ '
finishPostProcessOnScreen
≥≥ .
=
≥≥/ 0

cameraData
≥≥1 ;
.
≥≥; < 
resolveFinalTarget
≥≥< N
||
≥≥O Q
(
≥≥R S
m_Destination
≥≥S `
==
≥≥a c 
cameraTargetHandle
≥≥d v
||
≥≥w y
m_HasFinalPass≥≥z à
==≥≥â ã
true≥≥å ê
)≥≥ê ë
;≥≥ë í
if
∂∂ 
(
∂∂ 

cameraData
∂∂ 
.
∂∂ 
xr
∂∂ !
.
∂∂! "
enabled
∂∂" )
)
∂∂) *
{
∑∑ 
cmd
∏∏ 
.
∏∏ 
SetRenderTarget
∏∏ '
(
∏∏' (
new
∏∏( +$
RenderTargetIdentifier
∏∏, B
(
∏∏B C
cameraTarget
∏∏C O
,
∏∏O P
$num
∏∏Q R
,
∏∏R S
CubemapFace
∏∏T _
.
∏∏_ `
Unknown
∏∏` g
,
∏∏g h
-
∏∏i j
$num
∏∏j k
)
∏∏k l
,
∏∏l m
colorLoadAction
ππ (
,
ππ( )%
RenderBufferStoreAction
ππ* A
.
ππA B
Store
ππB G
,
ππG H$
RenderBufferLoadAction
ππI _
.
ππ_ `
DontCare
ππ` h
,
ππh i&
RenderBufferStoreActionππj Å
.ππÅ Ç
DontCareππÇ ä
)ππä ã
;ππã å
bool
ªª (
isRenderToBackBufferTarget
ªª 3
=
ªª4 5
cameraTarget
ªª6 B
==
ªªC E

cameraData
ªªF P
.
ªªP Q
xr
ªªQ S
.
ªªS T
renderTarget
ªªT `
&&
ªªa c
!
ªªd e

cameraData
ªªe o
.
ªªo p
xr
ªªp r
.
ªªr s*
renderTargetIsRenderTextureªªs é
;ªªé è
if
ºº 
(
ºº (
isRenderToBackBufferTarget
ºº 2
)
ºº2 3
cmd
ΩΩ 
.
ΩΩ 
SetViewport
ΩΩ '
(
ΩΩ' (

cameraData
ΩΩ( 2
.
ΩΩ2 3
	pixelRect
ΩΩ3 <
)
ΩΩ< =
;
ΩΩ= >
bool
¡¡ 
yflip
¡¡ 
=
¡¡  (
isRenderToBackBufferTarget
¡¡! ;
&&
¡¡< >

SystemInfo
¡¡? I
.
¡¡I J#
graphicsUVStartsAtTop
¡¡J _
;
¡¡_ `
Vector4
¬¬ 
	scaleBias
¬¬ %
=
¬¬& '
yflip
¬¬( -
?
¬¬. /
new
¬¬0 3
Vector4
¬¬4 ;
(
¬¬; <
$num
¬¬< =
,
¬¬= >
-
¬¬? @
$num
¬¬@ A
,
¬¬A B
$num
¬¬C D
,
¬¬D E
$num
¬¬F G
)
¬¬G H
:
¬¬I J
new
¬¬K N
Vector4
¬¬O V
(
¬¬V W
$num
¬¬W X
,
¬¬X Y
$num
¬¬Z [
,
¬¬[ \
$num
¬¬] ^
,
¬¬^ _
$num
¬¬` a
)
¬¬a b
;
¬¬b c
cmd
√√ 
.
√√ 
SetGlobalVector
√√ '
(
√√' (
ShaderPropertyId
√√( 8
.
√√8 9
	scaleBias
√√9 B
,
√√B C
	scaleBias
√√D M
)
√√M N
;
√√N O
cmd
ƒƒ 
.
ƒƒ 
DrawProcedural
ƒƒ &
(
ƒƒ& '
	Matrix4x4
ƒƒ' 0
.
ƒƒ0 1
identity
ƒƒ1 9
,
ƒƒ9 :
m_Materials
ƒƒ; F
.
ƒƒF G
uber
ƒƒG K
,
ƒƒK L
$num
ƒƒM N
,
ƒƒN O
MeshTopology
ƒƒP \
.
ƒƒ\ ]
Quads
ƒƒ] b
,
ƒƒb c
$num
ƒƒd e
,
ƒƒe f
$num
ƒƒg h
,
ƒƒh i
null
ƒƒj n
)
ƒƒn o
;
ƒƒo p
if
   
(
   
!
   '
finishPostProcessOnScreen
   2
)
  2 3
{
ÀÀ 
cmd
ÃÃ 
.
ÃÃ 
SetGlobalTexture
ÃÃ ,
(
ÃÃ, -
ShaderPropertyId
ÃÃ- =
.
ÃÃ= >
	sourceTex
ÃÃ> G
,
ÃÃG H
cameraTarget
ÃÃI U
)
ÃÃU V
;
ÃÃV W
cmd
ÕÕ 
.
ÕÕ 
SetRenderTarget
ÕÕ +
(
ÕÕ+ ,
new
ÕÕ, /$
RenderTargetIdentifier
ÕÕ0 F
(
ÕÕF G
m_Source
ÕÕG O
.
ÕÕO P
id
ÕÕP R
,
ÕÕR S
$num
ÕÕT U
,
ÕÕU V
CubemapFace
ÕÕW b
.
ÕÕb c
Unknown
ÕÕc j
,
ÕÕj k
-
ÕÕl m
$num
ÕÕm n
)
ÕÕn o
,
ÕÕo p
colorLoadAction
ŒŒ +
,
ŒŒ+ ,%
RenderBufferStoreAction
ŒŒ- D
.
ŒŒD E
Store
ŒŒE J
,
ŒŒJ K$
RenderBufferLoadAction
ŒŒL b
.
ŒŒb c
DontCare
ŒŒc k
,
ŒŒk l&
RenderBufferStoreActionŒŒm Ñ
.ŒŒÑ Ö
DontCareŒŒÖ ç
)ŒŒç é
;ŒŒé è
	scaleBias
–– !
=
––" #
new
––$ '
Vector4
––( /
(
––/ 0
$num
––0 1
,
––1 2
$num
––3 4
,
––4 5
$num
––6 7
,
––7 8
$num
––9 :
)
––: ;
;
––; <
;
––= >
cmd
—— 
.
—— 
SetGlobalVector
—— +
(
——+ ,
ShaderPropertyId
——, <
.
——< =
	scaleBias
——= F
,
——F G
	scaleBias
——H Q
)
——Q R
;
——R S
cmd
““ 
.
““ 
DrawProcedural
““ *
(
““* +
	Matrix4x4
““+ 4
.
““4 5
identity
““5 =
,
““= >
m_BlitMaterial
““? M
,
““M N
$num
““O P
,
““P Q
MeshTopology
““R ^
.
““^ _
Quads
““_ d
,
““d e
$num
““f g
,
““g h
$num
““i j
,
““j k
null
““l p
)
““p q
;
““q r
}
”” 
}
‘‘ 
else
’’ 
{
◊◊ 
cmd
ÿÿ 
.
ÿÿ 
SetRenderTarget
ÿÿ '
(
ÿÿ' (
cameraTarget
ÿÿ( 4
,
ÿÿ4 5
colorLoadAction
ÿÿ6 E
,
ÿÿE F%
RenderBufferStoreAction
ÿÿG ^
.
ÿÿ^ _
Store
ÿÿ_ d
,
ÿÿd e$
RenderBufferLoadAction
ÿÿf |
.
ÿÿ| }
DontCareÿÿ} Ö
,ÿÿÖ Ü'
RenderBufferStoreActionÿÿá û
.ÿÿû ü
DontCareÿÿü ß
)ÿÿß ®
;ÿÿ® ©
cmd
ŸŸ 
.
ŸŸ '
SetViewProjectionMatrices
ŸŸ 1
(
ŸŸ1 2
	Matrix4x4
ŸŸ2 ;
.
ŸŸ; <
identity
ŸŸ< D
,
ŸŸD E
	Matrix4x4
ŸŸF O
.
ŸŸO P
identity
ŸŸP X
)
ŸŸX Y
;
ŸŸY Z
if
€€ 
(
€€ 
m_Destination
€€ %
==
€€& ( 
RenderTargetHandle
€€) ;
.
€€; <
CameraTarget
€€< H
)
€€H I
cmd
‹‹ 
.
‹‹ 
SetViewport
‹‹ '
(
‹‹' (

cameraData
‹‹( 2
.
‹‹2 3
	pixelRect
‹‹3 <
)
‹‹< =
;
‹‹= >
cmd
ﬁﬁ 
.
ﬁﬁ 
DrawMesh
ﬁﬁ  
(
ﬁﬁ  !
RenderingUtils
ﬁﬁ! /
.
ﬁﬁ/ 0
fullscreenMesh
ﬁﬁ0 >
,
ﬁﬁ> ?
	Matrix4x4
ﬁﬁ@ I
.
ﬁﬁI J
identity
ﬁﬁJ R
,
ﬁﬁR S
m_Materials
ﬁﬁT _
.
ﬁﬁ_ `
uber
ﬁﬁ` d
)
ﬁﬁd e
;
ﬁﬁe f
if
‰‰ 
(
‰‰ 
!
‰‰ '
finishPostProcessOnScreen
‰‰ 2
)
‰‰2 3
{
ÂÂ 
cmd
ÊÊ 
.
ÊÊ 
SetGlobalTexture
ÊÊ ,
(
ÊÊ, -
ShaderPropertyId
ÊÊ- =
.
ÊÊ= >
	sourceTex
ÊÊ> G
,
ÊÊG H
cameraTarget
ÊÊI U
)
ÊÊU V
;
ÊÊV W
cmd
ÁÁ 
.
ÁÁ 
SetRenderTarget
ÁÁ +
(
ÁÁ+ ,
m_Source
ÁÁ, 4
.
ÁÁ4 5
id
ÁÁ5 7
,
ÁÁ7 8$
RenderBufferLoadAction
ÁÁ9 O
.
ÁÁO P
DontCare
ÁÁP X
,
ÁÁX Y%
RenderBufferStoreAction
ÁÁZ q
.
ÁÁq r
Store
ÁÁr w
,
ÁÁw x%
RenderBufferLoadActionÁÁy è
.ÁÁè ê
DontCareÁÁê ò
,ÁÁò ô'
RenderBufferStoreActionÁÁö ±
.ÁÁ± ≤
DontCareÁÁ≤ ∫
)ÁÁ∫ ª
;ÁÁª º
cmd
ËË 
.
ËË 
DrawMesh
ËË $
(
ËË$ %
RenderingUtils
ËË% 3
.
ËË3 4
fullscreenMesh
ËË4 B
,
ËËB C
	Matrix4x4
ËËD M
.
ËËM N
identity
ËËN V
,
ËËV W
m_BlitMaterial
ËËX f
)
ËËf g
;
ËËg h
}
ÈÈ 
cmd
ÎÎ 
.
ÎÎ '
SetViewProjectionMatrices
ÎÎ 1
(
ÎÎ1 2

cameraData
ÎÎ2 <
.
ÎÎ< =
camera
ÎÎ= C
.
ÎÎC D!
worldToCameraMatrix
ÎÎD W
,
ÎÎW X

cameraData
ÎÎY c
.
ÎÎc d
camera
ÎÎd j
.
ÎÎj k
projectionMatrix
ÎÎk {
)
ÎÎ{ |
;
ÎÎ| }
}
ÏÏ 
if
ÔÔ 
(
ÔÔ 
bloomActive
ÔÔ 
)
ÔÔ  
cmd
 
.
  
ReleaseTemporaryRT
 *
(
* +
ShaderConstants
+ :
.
: ;
_BloomMipUp
; F
[
F G
$num
G H
]
H I
)
I J
;
J K
if
ÚÚ 
(
ÚÚ 
tempTargetUsed
ÚÚ "
)
ÚÚ" #
cmd
ÛÛ 
.
ÛÛ  
ReleaseTemporaryRT
ÛÛ *
(
ÛÛ* +
ShaderConstants
ÛÛ+ :
.
ÛÛ: ;
_TempTarget
ÛÛ; F
)
ÛÛF G
;
ÛÛG H
if
ıı 
(
ıı 
tempTarget2Used
ıı #
)
ıı# $
cmd
ˆˆ 
.
ˆˆ  
ReleaseTemporaryRT
ˆˆ *
(
ˆˆ* +
ShaderConstants
ˆˆ+ :
.
ˆˆ: ;
_TempTarget2
ˆˆ; G
)
ˆˆG H
;
ˆˆH I
}
˜˜ 
}
¯¯ 	
private
˙˙ &
BuiltinRenderTextureType
˙˙ (#
BlitDstDiscardContent
˙˙) >
(
˙˙> ?
CommandBuffer
˙˙? L
cmd
˙˙M P
,
˙˙P Q$
RenderTargetIdentifier
˙˙R h
rt
˙˙i k
)
˙˙k l
{
˚˚ 	
cmd
˛˛ 
.
˛˛ 
SetRenderTarget
˛˛ 
(
˛˛  
new
˛˛  #$
RenderTargetIdentifier
˛˛$ :
(
˛˛: ;
rt
˛˛; =
,
˛˛= >
$num
˛˛? @
,
˛˛@ A
CubemapFace
˛˛B M
.
˛˛M N
Unknown
˛˛N U
,
˛˛U V
-
˛˛W X
$num
˛˛X Y
)
˛˛Y Z
,
˛˛Z [$
RenderBufferLoadAction
ˇˇ &
.
ˇˇ& '
DontCare
ˇˇ' /
,
ˇˇ/ 0%
RenderBufferStoreAction
ˇˇ1 H
.
ˇˇH I
Store
ˇˇI N
,
ˇˇN O$
RenderBufferLoadAction
ÄÄ &
.
ÄÄ& '
DontCare
ÄÄ' /
,
ÄÄ/ 0%
RenderBufferStoreAction
ÄÄ1 H
.
ÄÄH I
DontCare
ÄÄI Q
)
ÄÄQ R
;
ÄÄR S
return
ÅÅ &
BuiltinRenderTextureType
ÅÅ +
.
ÅÅ+ ,
CurrentActive
ÅÅ, 9
;
ÅÅ9 :
}
ÇÇ 	
void
ÜÜ 1
#DoSubpixelMorphologicalAntialiasing
ÜÜ 0
(
ÜÜ0 1
ref
ÜÜ1 4

CameraData
ÜÜ5 ?

cameraData
ÜÜ@ J
,
ÜÜJ K
CommandBuffer
ÜÜL Y
cmd
ÜÜZ ]
,
ÜÜ] ^
int
ÜÜ_ b
source
ÜÜc i
,
ÜÜi j
int
ÜÜk n
destination
ÜÜo z
)
ÜÜz {
{
áá 	
var
àà 
camera
àà 
=
àà 

cameraData
àà #
.
àà# $
camera
àà$ *
;
àà* +
var
ââ 
	pixelRect
ââ 
=
ââ 

cameraData
ââ &
.
ââ& '
	pixelRect
ââ' 0
;
ââ0 1
var
ää 
material
ää 
=
ää 
m_Materials
ää &
.
ää& '/
!subpixelMorphologicalAntialiasing
ää' H
;
ääH I
const
ãã 
int
ãã 
kStencilBit
ãã !
=
ãã" #
$num
ãã$ &
;
ãã& '
material
éé 
.
éé 
	SetVector
éé 
(
éé 
ShaderConstants
éé .
.
éé. /
_Metrics
éé/ 7
,
éé7 8
new
éé9 <
Vector4
éé= D
(
ééD E
$num
ééE G
/
ééH I
m_Descriptor
ééJ V
.
ééV W
width
ééW \
,
éé\ ]
$num
éé^ `
/
ééa b
m_Descriptor
ééc o
.
ééo p
height
éép v
,
éév w
m_Descriptorééx Ñ
.ééÑ Ö
widthééÖ ä
,ééä ã
m_Descriptorééå ò
.ééò ô
heightééô ü
)ééü †
)éé† °
;éé° ¢
material
èè 
.
èè 

SetTexture
èè 
(
èè  
ShaderConstants
èè  /
.
èè/ 0
_AreaTexture
èè0 <
,
èè< =
m_Data
èè> D
.
èèD E
textures
èèE M
.
èèM N
smaaAreaTex
èèN Y
)
èèY Z
;
èèZ [
material
êê 
.
êê 

SetTexture
êê 
(
êê  
ShaderConstants
êê  /
.
êê/ 0
_SearchTexture
êê0 >
,
êê> ?
m_Data
êê@ F
.
êêF G
textures
êêG O
.
êêO P
smaaSearchTex
êêP ]
)
êê] ^
;
êê^ _
material
ëë 
.
ëë 
SetInt
ëë 
(
ëë 
ShaderConstants
ëë +
.
ëë+ ,
_StencilRef
ëë, 7
,
ëë7 8
kStencilBit
ëë9 D
)
ëëD E
;
ëëE F
material
íí 
.
íí 
SetInt
íí 
(
íí 
ShaderConstants
íí +
.
íí+ ,
_StencilMask
íí, 8
,
íí8 9
kStencilBit
íí: E
)
ííE F
;
ííF G
material
ïï 
.
ïï 
shaderKeywords
ïï #
=
ïï$ %
null
ïï& *
;
ïï* +
switch
óó 
(
óó 

cameraData
óó 
.
óó !
antialiasingQuality
óó 2
)
óó2 3
{
òò 
case
ôô !
AntialiasingQuality
ôô (
.
ôô( )
Low
ôô) ,
:
ôô, -
material
ôô. 6
.
ôô6 7
EnableKeyword
ôô7 D
(
ôôD E"
ShaderKeywordStrings
ôôE Y
.
ôôY Z
SmaaLow
ôôZ a
)
ôôa b
;
ôôb c
break
öö 
;
öö 
case
õõ !
AntialiasingQuality
õõ (
.
õõ( )
Medium
õõ) /
:
õõ/ 0
material
õõ1 9
.
õõ9 :
EnableKeyword
õõ: G
(
õõG H"
ShaderKeywordStrings
õõH \
.
õõ\ ]

SmaaMedium
õõ] g
)
õõg h
;
õõh i
break
úú 
;
úú 
case
ùù !
AntialiasingQuality
ùù (
.
ùù( )
High
ùù) -
:
ùù- .
material
ùù/ 7
.
ùù7 8
EnableKeyword
ùù8 E
(
ùùE F"
ShaderKeywordStrings
ùùF Z
.
ùùZ [
SmaaHigh
ùù[ c
)
ùùc d
;
ùùd e
break
ûû 
;
ûû 
}
üü $
RenderTargetIdentifier
¢¢ "
stencil
¢¢# *
;
¢¢* +
int
££ 
tempDepthBits
££ 
;
££ 
if
§§ 
(
§§ 
m_Depth
§§ 
==
§§  
RenderTargetHandle
§§ -
.
§§- .
CameraTarget
§§. :
||
§§; =
m_Descriptor
§§> J
.
§§J K
msaaSamples
§§K V
>
§§W X
$num
§§Y Z
)
§§Z [
{
•• 
stencil
ßß 
=
ßß 
ShaderConstants
ßß )
.
ßß) *
_EdgeTexture
ßß* 6
;
ßß6 7
tempDepthBits
®® 
=
®® 
$num
®®  "
;
®®" #
}
©© 
else
™™ 
{
´´ 
stencil
¨¨ 
=
¨¨ 
m_Depth
¨¨ !
.
¨¨! "

Identifier
¨¨" ,
(
¨¨, -
)
¨¨- .
;
¨¨. /
tempDepthBits
≠≠ 
=
≠≠ 
$num
≠≠  !
;
≠≠! "
}
ÆÆ 
cmd
ØØ 
.
ØØ 
GetTemporaryRT
ØØ 
(
ØØ 
ShaderConstants
ØØ .
.
ØØ. /
_EdgeTexture
ØØ/ ;
,
ØØ; <%
GetCompatibleDescriptor
ØØ= T
(
ØØT U
m_Descriptor
ØØU a
.
ØØa b
width
ØØb g
,
ØØg h
m_Descriptor
ØØi u
.
ØØu v
height
ØØv |
,
ØØ| }
m_SMAAEdgeFormatØØ~ é
,ØØé è
tempDepthBitsØØê ù
)ØØù û
,ØØû ü

FilterModeØØ† ™
.ØØ™ ´
PointØØ´ ∞
)ØØ∞ ±
;ØØ± ≤
cmd
∞∞ 
.
∞∞ 
GetTemporaryRT
∞∞ 
(
∞∞ 
ShaderConstants
∞∞ .
.
∞∞. /
_BlendTexture
∞∞/ <
,
∞∞< =%
GetCompatibleDescriptor
∞∞> U
(
∞∞U V
m_Descriptor
∞∞V b
.
∞∞b c
width
∞∞c h
,
∞∞h i
m_Descriptor
∞∞j v
.
∞∞v w
height
∞∞w }
,
∞∞} ~
GraphicsFormat∞∞ ç
.∞∞ç é
R8G8B8A8_UNorm∞∞é ú
)∞∞ú ù
,∞∞ù û

FilterMode∞∞ü ©
.∞∞© ™
Point∞∞™ Ø
)∞∞Ø ∞
;∞∞∞ ±
cmd
≥≥ 
.
≥≥ '
SetViewProjectionMatrices
≥≥ )
(
≥≥) *
	Matrix4x4
≥≥* 3
.
≥≥3 4
identity
≥≥4 <
,
≥≥< =
	Matrix4x4
≥≥> G
.
≥≥G H
identity
≥≥H P
)
≥≥P Q
;
≥≥Q R
cmd
¥¥ 
.
¥¥ 
SetViewport
¥¥ 
(
¥¥ 
	pixelRect
¥¥ %
)
¥¥% &
;
¥¥& '
cmd
∑∑ 
.
∑∑ 
SetRenderTarget
∑∑ 
(
∑∑  
new
∑∑  #$
RenderTargetIdentifier
∑∑$ :
(
∑∑: ;
ShaderConstants
∑∑; J
.
∑∑J K
_EdgeTexture
∑∑K W
,
∑∑W X
$num
∑∑Y Z
,
∑∑Z [
CubemapFace
∑∑\ g
.
∑∑g h
Unknown
∑∑h o
,
∑∑o p
-
∑∑q r
$num
∑∑r s
)
∑∑s t
,
∑∑t u$
RenderBufferLoadAction
∏∏ &
.
∏∏& '
DontCare
∏∏' /
,
∏∏/ 0%
RenderBufferStoreAction
∏∏1 H
.
∏∏H I
Store
∏∏I N
,
∏∏N O
stencil
∏∏P W
,
∏∏W X$
RenderBufferLoadAction
ππ &
.
ππ& '
DontCare
ππ' /
,
ππ/ 0%
RenderBufferStoreAction
ππ1 H
.
ππH I
Store
ππI N
)
ππN O
;
ππO P
cmd
∫∫ 
.
∫∫ 
ClearRenderTarget
∫∫ !
(
∫∫! "
true
∫∫" &
,
∫∫& '
true
∫∫( ,
,
∫∫, -
Color
∫∫. 3
.
∫∫3 4
clear
∫∫4 9
)
∫∫9 :
;
∫∫: ;
cmd
ªª 
.
ªª 
SetGlobalTexture
ªª  
(
ªª  !
ShaderConstants
ªª! 0
.
ªª0 1
_ColorTexture
ªª1 >
,
ªª> ?
source
ªª@ F
)
ªªF G
;
ªªG H 
DrawFullscreenMesh
ºº 
(
ºº 
cmd
ºº "
,
ºº" #
material
ºº$ ,
,
ºº, -
$num
ºº. /
)
ºº/ 0
;
ºº0 1
cmd
øø 
.
øø 
SetRenderTarget
øø 
(
øø  
new
øø  #$
RenderTargetIdentifier
øø$ :
(
øø: ;
ShaderConstants
øø; J
.
øøJ K
_BlendTexture
øøK X
,
øøX Y
$num
øøZ [
,
øø[ \
CubemapFace
øø] h
.
øøh i
Unknown
øøi p
,
øøp q
-
øør s
$num
øøs t
)
øøt u
,
øøu v$
RenderBufferLoadAction
¿¿ &
.
¿¿& '
DontCare
¿¿' /
,
¿¿/ 0%
RenderBufferStoreAction
¿¿1 H
.
¿¿H I
Store
¿¿I N
,
¿¿N O
stencil
¿¿P W
,
¿¿W X$
RenderBufferLoadAction
¡¡ &
.
¡¡& '
Load
¡¡' +
,
¡¡+ ,%
RenderBufferStoreAction
¡¡- D
.
¡¡D E
DontCare
¡¡E M
)
¡¡M N
;
¡¡N O
cmd
¬¬ 
.
¬¬ 
ClearRenderTarget
¬¬ !
(
¬¬! "
false
¬¬" '
,
¬¬' (
true
¬¬) -
,
¬¬- .
Color
¬¬/ 4
.
¬¬4 5
clear
¬¬5 :
)
¬¬: ;
;
¬¬; <
cmd
√√ 
.
√√ 
SetGlobalTexture
√√  
(
√√  !
ShaderConstants
√√! 0
.
√√0 1
_ColorTexture
√√1 >
,
√√> ?
ShaderConstants
√√@ O
.
√√O P
_EdgeTexture
√√P \
)
√√\ ]
;
√√] ^ 
DrawFullscreenMesh
ƒƒ 
(
ƒƒ 
cmd
ƒƒ "
,
ƒƒ" #
material
ƒƒ$ ,
,
ƒƒ, -
$num
ƒƒ. /
)
ƒƒ/ 0
;
ƒƒ0 1
cmd
«« 
.
«« 
SetRenderTarget
«« 
(
««  
new
««  #$
RenderTargetIdentifier
««$ :
(
««: ;
destination
««; F
,
««F G
$num
««H I
,
««I J
CubemapFace
««K V
.
««V W
Unknown
««W ^
,
««^ _
-
««` a
$num
««a b
)
««b c
,
««c d$
RenderBufferLoadAction
»» &
.
»»& '
DontCare
»»' /
,
»»/ 0%
RenderBufferStoreAction
»»1 H
.
»»H I
Store
»»I N
,
»»N O$
RenderBufferLoadAction
…… &
.
……& '
DontCare
……' /
,
……/ 0%
RenderBufferStoreAction
……1 H
.
……H I
DontCare
……I Q
)
……Q R
;
……R S
cmd
   
.
   
SetGlobalTexture
    
(
    !
ShaderConstants
  ! 0
.
  0 1
_ColorTexture
  1 >
,
  > ?
source
  @ F
)
  F G
;
  G H
cmd
ÀÀ 
.
ÀÀ 
SetGlobalTexture
ÀÀ  
(
ÀÀ  !
ShaderConstants
ÀÀ! 0
.
ÀÀ0 1
_BlendTexture
ÀÀ1 >
,
ÀÀ> ?
ShaderConstants
ÀÀ@ O
.
ÀÀO P
_BlendTexture
ÀÀP ]
)
ÀÀ] ^
;
ÀÀ^ _ 
DrawFullscreenMesh
ÃÃ 
(
ÃÃ 
cmd
ÃÃ "
,
ÃÃ" #
material
ÃÃ$ ,
,
ÃÃ, -
$num
ÃÃ. /
)
ÃÃ/ 0
;
ÃÃ0 1
cmd
œœ 
.
œœ  
ReleaseTemporaryRT
œœ "
(
œœ" #
ShaderConstants
œœ# 2
.
œœ2 3
_EdgeTexture
œœ3 ?
)
œœ? @
;
œœ@ A
cmd
–– 
.
––  
ReleaseTemporaryRT
–– "
(
––" #
ShaderConstants
––# 2
.
––2 3
_BlendTexture
––3 @
)
––@ A
;
––A B
cmd
—— 
.
—— '
SetViewProjectionMatrices
—— )
(
——) *
camera
——* 0
.
——0 1!
worldToCameraMatrix
——1 D
,
——D E
camera
——F L
.
——L M
projectionMatrix
——M ]
)
——] ^
;
——^ _
}
““ 	
void
⁄⁄ 
DoDepthOfField
⁄⁄ 
(
⁄⁄ 
Camera
⁄⁄ "
camera
⁄⁄# )
,
⁄⁄) *
CommandBuffer
⁄⁄+ 8
cmd
⁄⁄9 <
,
⁄⁄< =
int
⁄⁄> A
source
⁄⁄B H
,
⁄⁄H I
int
⁄⁄J M
destination
⁄⁄N Y
,
⁄⁄Y Z
Rect
⁄⁄[ _
	pixelRect
⁄⁄` i
)
⁄⁄i j
{
€€ 	
if
‹‹ 
(
‹‹ 
m_DepthOfField
‹‹ 
.
‹‹ 
mode
‹‹ #
.
‹‹# $
value
‹‹$ )
==
‹‹* ,
DepthOfFieldMode
‹‹- =
.
‹‹= >
Gaussian
‹‹> F
)
‹‹F G$
DoGaussianDepthOfField
›› &
(
››& '
camera
››' -
,
››- .
cmd
››/ 2
,
››2 3
source
››4 :
,
››: ;
destination
››< G
,
››G H
	pixelRect
››I R
)
››R S
;
››S T
else
ﬁﬁ 
if
ﬁﬁ 
(
ﬁﬁ 
m_DepthOfField
ﬁﬁ #
.
ﬁﬁ# $
mode
ﬁﬁ$ (
.
ﬁﬁ( )
value
ﬁﬁ) .
==
ﬁﬁ/ 1
DepthOfFieldMode
ﬁﬁ2 B
.
ﬁﬁB C
Bokeh
ﬁﬁC H
)
ﬁﬁH I!
DoBokehDepthOfField
ﬂﬂ #
(
ﬂﬂ# $
cmd
ﬂﬂ$ '
,
ﬂﬂ' (
source
ﬂﬂ) /
,
ﬂﬂ/ 0
destination
ﬂﬂ1 <
,
ﬂﬂ< =
	pixelRect
ﬂﬂ> G
)
ﬂﬂG H
;
ﬂﬂH I
}
‡‡ 	
void
‚‚ $
DoGaussianDepthOfField
‚‚ #
(
‚‚# $
Camera
‚‚$ *
camera
‚‚+ 1
,
‚‚1 2
CommandBuffer
‚‚3 @
cmd
‚‚A D
,
‚‚D E
int
‚‚F I
source
‚‚J P
,
‚‚P Q
int
‚‚R U
destination
‚‚V a
,
‚‚a b
Rect
‚‚c g
	pixelRect
‚‚h q
)
‚‚q r
{
„„ 	
int
‰‰ 

downSample
‰‰ 
=
‰‰ 
$num
‰‰ 
;
‰‰ 
var
ÂÂ 
material
ÂÂ 
=
ÂÂ 
m_Materials
ÂÂ &
.
ÂÂ& '"
gaussianDepthOfField
ÂÂ' ;
;
ÂÂ; <
int
ÊÊ 
wh
ÊÊ 
=
ÊÊ 
m_Descriptor
ÊÊ !
.
ÊÊ! "
width
ÊÊ" '
/
ÊÊ( )

downSample
ÊÊ* 4
;
ÊÊ4 5
int
ÁÁ 
hh
ÁÁ 
=
ÁÁ 
m_Descriptor
ÁÁ !
.
ÁÁ! "
height
ÁÁ" (
/
ÁÁ) *

downSample
ÁÁ+ 5
;
ÁÁ5 6
float
ËË 
farStart
ËË 
=
ËË 
m_DepthOfField
ËË +
.
ËË+ ,
gaussianStart
ËË, 9
.
ËË9 :
value
ËË: ?
;
ËË? @
float
ÈÈ 
farEnd
ÈÈ 
=
ÈÈ 
Mathf
ÈÈ  
.
ÈÈ  !
Max
ÈÈ! $
(
ÈÈ$ %
farStart
ÈÈ% -
,
ÈÈ- .
m_DepthOfField
ÈÈ/ =
.
ÈÈ= >
gaussianEnd
ÈÈ> I
.
ÈÈI J
value
ÈÈJ O
)
ÈÈO P
;
ÈÈP Q
float
ÓÓ 
	maxRadius
ÓÓ 
=
ÓÓ 
m_DepthOfField
ÓÓ ,
.
ÓÓ, -
gaussianMaxRadius
ÓÓ- >
.
ÓÓ> ?
value
ÓÓ? D
*
ÓÓE F
(
ÓÓG H
wh
ÓÓH J
/
ÓÓK L
$num
ÓÓM R
)
ÓÓR S
;
ÓÓS T
	maxRadius
ÔÔ 
=
ÔÔ 
Mathf
ÔÔ 
.
ÔÔ 
Min
ÔÔ !
(
ÔÔ! "
	maxRadius
ÔÔ" +
,
ÔÔ+ ,
$num
ÔÔ- /
)
ÔÔ/ 0
;
ÔÔ0 1
	CoreUtils
ÒÒ 
.
ÒÒ 

SetKeyword
ÒÒ  
(
ÒÒ  !
material
ÒÒ! )
,
ÒÒ) *"
ShaderKeywordStrings
ÒÒ+ ?
.
ÒÒ? @!
HighQualitySampling
ÒÒ@ S
,
ÒÒS T
m_DepthOfField
ÒÒU c
.
ÒÒc d!
highQualitySampling
ÒÒd w
.
ÒÒw x
value
ÒÒx }
)
ÒÒ} ~
;
ÒÒ~ 
material
ÚÚ 
.
ÚÚ 
	SetVector
ÚÚ 
(
ÚÚ 
ShaderConstants
ÚÚ .
.
ÚÚ. /

_CoCParams
ÚÚ/ 9
,
ÚÚ9 :
new
ÚÚ; >
Vector3
ÚÚ? F
(
ÚÚF G
farStart
ÚÚG O
,
ÚÚO P
farEnd
ÚÚQ W
,
ÚÚW X
	maxRadius
ÚÚY b
)
ÚÚb c
)
ÚÚc d
;
ÚÚd e
cmd
ıı 
.
ıı 
GetTemporaryRT
ıı 
(
ıı 
ShaderConstants
ıı .
.
ıı. /
_FullCoCTexture
ıı/ >
,
ıı> ?%
GetCompatibleDescriptor
ıı@ W
(
ııW X
m_Descriptor
ııX d
.
ııd e
width
ııe j
,
ııj k
m_Descriptor
ııl x
.
ııx y
height
ııy 
,ıı Ä#
m_GaussianCoCFormatııÅ î
)ııî ï
,ııï ñ

FilterModeııó °
.ıı° ¢
Bilinearıı¢ ™
)ıı™ ´
;ıı´ ¨
cmd
ˆˆ 
.
ˆˆ 
GetTemporaryRT
ˆˆ 
(
ˆˆ 
ShaderConstants
ˆˆ .
.
ˆˆ. /
_HalfCoCTexture
ˆˆ/ >
,
ˆˆ> ?%
GetCompatibleDescriptor
ˆˆ@ W
(
ˆˆW X
wh
ˆˆX Z
,
ˆˆZ [
hh
ˆˆ\ ^
,
ˆˆ^ _!
m_GaussianCoCFormat
ˆˆ` s
)
ˆˆs t
,
ˆˆt u

FilterModeˆˆv Ä
.ˆˆÄ Å
BilinearˆˆÅ â
)ˆˆâ ä
;ˆˆä ã
cmd
˜˜ 
.
˜˜ 
GetTemporaryRT
˜˜ 
(
˜˜ 
ShaderConstants
˜˜ .
.
˜˜. /
_PingTexture
˜˜/ ;
,
˜˜; <%
GetCompatibleDescriptor
˜˜= T
(
˜˜T U
wh
˜˜U W
,
˜˜W X
hh
˜˜Y [
,
˜˜[ \ 
m_DefaultHDRFormat
˜˜] o
)
˜˜o p
,
˜˜p q

FilterMode
˜˜r |
.
˜˜| }
Bilinear˜˜} Ö
)˜˜Ö Ü
;˜˜Ü á
cmd
¯¯ 
.
¯¯ 
GetTemporaryRT
¯¯ 
(
¯¯ 
ShaderConstants
¯¯ .
.
¯¯. /
_PongTexture
¯¯/ ;
,
¯¯; <%
GetCompatibleDescriptor
¯¯= T
(
¯¯T U
wh
¯¯U W
,
¯¯W X
hh
¯¯Y [
,
¯¯[ \ 
m_DefaultHDRFormat
¯¯] o
)
¯¯o p
,
¯¯p q

FilterMode
¯¯r |
.
¯¯| }
Bilinear¯¯} Ö
)¯¯Ö Ü
;¯¯Ü á
PostProcessUtils
˚˚ 
.
˚˚ 
SetSourceSize
˚˚ *
(
˚˚* +
cmd
˚˚+ .
,
˚˚. /
m_Descriptor
˚˚0 <
)
˚˚< =
;
˚˚= >
cmd
¸¸ 
.
¸¸ 
SetGlobalVector
¸¸ 
(
¸¸  
ShaderConstants
¸¸  /
.
¸¸/ 0$
_DownSampleScaleFactor
¸¸0 F
,
¸¸F G
new
¸¸H K
Vector4
¸¸L S
(
¸¸S T
$num
¸¸T X
/
¸¸Y Z

downSample
¸¸[ e
,
¸¸e f
$num
¸¸g k
/
¸¸l m

downSample
¸¸n x
,
¸¸x y

downSample¸¸z Ñ
,¸¸Ñ Ö

downSample¸¸Ü ê
)¸¸ê ë
)¸¸ë í
;¸¸í ì
Blit
ˇˇ 
(
ˇˇ 
cmd
ˇˇ 
,
ˇˇ 
source
ˇˇ 
,
ˇˇ 
ShaderConstants
ˇˇ -
.
ˇˇ- .
_FullCoCTexture
ˇˇ. =
,
ˇˇ= >
material
ˇˇ? G
,
ˇˇG H
$num
ˇˇI J
)
ˇˇJ K
;
ˇˇK L
m_MRT2
ÇÇ 
[
ÇÇ 
$num
ÇÇ 
]
ÇÇ 
=
ÇÇ 
ShaderConstants
ÇÇ '
.
ÇÇ' (
_HalfCoCTexture
ÇÇ( 7
;
ÇÇ7 8
m_MRT2
ÉÉ 
[
ÉÉ 
$num
ÉÉ 
]
ÉÉ 
=
ÉÉ 
ShaderConstants
ÉÉ '
.
ÉÉ' (
_PingTexture
ÉÉ( 4
;
ÉÉ4 5
cmd
ÖÖ 
.
ÖÖ '
SetViewProjectionMatrices
ÖÖ )
(
ÖÖ) *
	Matrix4x4
ÖÖ* 3
.
ÖÖ3 4
identity
ÖÖ4 <
,
ÖÖ< =
	Matrix4x4
ÖÖ> G
.
ÖÖG H
identity
ÖÖH P
)
ÖÖP Q
;
ÖÖQ R
cmd
ÜÜ 
.
ÜÜ 
SetViewport
ÜÜ 
(
ÜÜ 
	pixelRect
ÜÜ %
)
ÜÜ% &
;
ÜÜ& '
cmd
áá 
.
áá 
SetGlobalTexture
áá  
(
áá  !
ShaderConstants
áá! 0
.
áá0 1
_ColorTexture
áá1 >
,
áá> ?
source
áá@ F
)
ááF G
;
ááG H
cmd
àà 
.
àà 
SetGlobalTexture
àà  
(
àà  !
ShaderConstants
àà! 0
.
àà0 1
_FullCoCTexture
àà1 @
,
àà@ A
ShaderConstants
ààB Q
.
ààQ R
_FullCoCTexture
ààR a
)
ààa b
;
ààb c
cmd
ââ 
.
ââ 
SetRenderTarget
ââ 
(
ââ  
m_MRT2
ââ  &
,
ââ& '
ShaderConstants
ââ( 7
.
ââ7 8
_HalfCoCTexture
ââ8 G
,
ââG H
$num
ââI J
,
ââJ K
CubemapFace
ââL W
.
ââW X
Unknown
ââX _
,
ââ_ `
-
ââa b
$num
ââb c
)
ââc d
;
ââd e 
DrawFullscreenMesh
ää 
(
ää 
cmd
ää "
,
ää" #
material
ää$ ,
,
ää, -
$num
ää. /
)
ää/ 0
;
ää0 1
cmd
åå 
.
åå '
SetViewProjectionMatrices
åå )
(
åå) *
camera
åå* 0
.
åå0 1!
worldToCameraMatrix
åå1 D
,
ååD E
camera
ååF L
.
ååL M
projectionMatrix
ååM ]
)
åå] ^
;
åå^ _
cmd
èè 
.
èè 
SetGlobalTexture
èè  
(
èè  !
ShaderConstants
èè! 0
.
èè0 1
_HalfCoCTexture
èè1 @
,
èè@ A
ShaderConstants
èèB Q
.
èèQ R
_HalfCoCTexture
èèR a
)
èèa b
;
èèb c
Blit
êê 
(
êê 
cmd
êê 
,
êê 
ShaderConstants
êê %
.
êê% &
_PingTexture
êê& 2
,
êê2 3
ShaderConstants
êê4 C
.
êêC D
_PongTexture
êêD P
,
êêP Q
material
êêR Z
,
êêZ [
$num
êê\ ]
)
êê] ^
;
êê^ _
Blit
ëë 
(
ëë 
cmd
ëë 
,
ëë 
ShaderConstants
ëë %
.
ëë% &
_PongTexture
ëë& 2
,
ëë2 3#
BlitDstDiscardContent
ëë4 I
(
ëëI J
cmd
ëëJ M
,
ëëM N
ShaderConstants
ëëO ^
.
ëë^ _
_PingTexture
ëë_ k
)
ëëk l
,
ëël m
material
ëën v
,
ëëv w
$num
ëëx y
)
ëëy z
;
ëëz {
cmd
îî 
.
îî 
SetGlobalTexture
îî  
(
îî  !
ShaderConstants
îî! 0
.
îî0 1
_ColorTexture
îî1 >
,
îî> ?
ShaderConstants
îî@ O
.
îîO P
_PingTexture
îîP \
)
îî\ ]
;
îî] ^
cmd
ïï 
.
ïï 
SetGlobalTexture
ïï  
(
ïï  !
ShaderConstants
ïï! 0
.
ïï0 1
_FullCoCTexture
ïï1 @
,
ïï@ A
ShaderConstants
ïïB Q
.
ïïQ R
_FullCoCTexture
ïïR a
)
ïïa b
;
ïïb c
Blit
ññ 
(
ññ 
cmd
ññ 
,
ññ 
source
ññ 
,
ññ #
BlitDstDiscardContent
ññ 3
(
ññ3 4
cmd
ññ4 7
,
ññ7 8
destination
ññ9 D
)
ññD E
,
ññE F
material
ññG O
,
ññO P
$num
ññQ R
)
ññR S
;
ññS T
cmd
ôô 
.
ôô  
ReleaseTemporaryRT
ôô "
(
ôô" #
ShaderConstants
ôô# 2
.
ôô2 3
_FullCoCTexture
ôô3 B
)
ôôB C
;
ôôC D
cmd
öö 
.
öö  
ReleaseTemporaryRT
öö "
(
öö" #
ShaderConstants
öö# 2
.
öö2 3
_HalfCoCTexture
öö3 B
)
ööB C
;
ööC D
cmd
õõ 
.
õõ  
ReleaseTemporaryRT
õõ "
(
õõ" #
ShaderConstants
õõ# 2
.
õõ2 3
_PingTexture
õõ3 ?
)
õõ? @
;
õõ@ A
cmd
úú 
.
úú  
ReleaseTemporaryRT
úú "
(
úú" #
ShaderConstants
úú# 2
.
úú2 3
_PongTexture
úú3 ?
)
úú? @
;
úú@ A
}
ùù 	
void
üü  
PrepareBokehKernel
üü 
(
üü  
)
üü  !
{
†† 	
const
°° 
int
°° 
kRings
°° 
=
°° 
$num
°°  
;
°°  !
const
¢¢ 
int
¢¢ 
kPointsPerRing
¢¢ $
=
¢¢% &
$num
¢¢' (
;
¢¢( )
if
•• 
(
•• 
m_BokehKernel
•• 
==
••  
null
••! %
)
••% &
m_BokehKernel
¶¶ 
=
¶¶ 
new
¶¶  #
Vector4
¶¶$ +
[
¶¶+ ,
$num
¶¶, .
]
¶¶. /
;
¶¶/ 0
int
©© 
idx
©© 
=
©© 
$num
©© 
;
©© 
float
™™ 

bladeCount
™™ 
=
™™ 
m_DepthOfField
™™ -
.
™™- .

bladeCount
™™. 8
.
™™8 9
value
™™9 >
;
™™> ?
float
´´ 
	curvature
´´ 
=
´´ 
$num
´´  
-
´´! "
m_DepthOfField
´´# 1
.
´´1 2
bladeCurvature
´´2 @
.
´´@ A
value
´´A F
;
´´F G
float
¨¨ 
rotation
¨¨ 
=
¨¨ 
m_DepthOfField
¨¨ +
.
¨¨+ ,
bladeRotation
¨¨, 9
.
¨¨9 :
value
¨¨: ?
*
¨¨@ A
Mathf
¨¨B G
.
¨¨G H
Deg2Rad
¨¨H O
;
¨¨O P
const
≠≠ 
float
≠≠ 
PI
≠≠ 
=
≠≠ 
Mathf
≠≠ "
.
≠≠" #
PI
≠≠# %
;
≠≠% &
const
ÆÆ 
float
ÆÆ 
TWO_PI
ÆÆ 
=
ÆÆ  
Mathf
ÆÆ! &
.
ÆÆ& '
PI
ÆÆ' )
*
ÆÆ* +
$num
ÆÆ, .
;
ÆÆ. /
for
∞∞ 
(
∞∞ 
int
∞∞ 
ring
∞∞ 
=
∞∞ 
$num
∞∞ 
;
∞∞ 
ring
∞∞ #
<
∞∞$ %
kRings
∞∞& ,
;
∞∞, -
ring
∞∞. 2
++
∞∞2 4
)
∞∞4 5
{
±± 
float
≤≤ 
bias
≤≤ 
=
≤≤ 
$num
≤≤ 
/
≤≤  !
kPointsPerRing
≤≤" 0
;
≤≤0 1
float
≥≥ 
radius
≥≥ 
=
≥≥ 
(
≥≥  
ring
≥≥  $
+
≥≥% &
bias
≥≥' +
)
≥≥+ ,
/
≥≥- .
(
≥≥/ 0
kRings
≥≥0 6
-
≥≥7 8
$num
≥≥9 ;
+
≥≥< =
bias
≥≥> B
)
≥≥B C
;
≥≥C D
int
¥¥ 
points
¥¥ 
=
¥¥ 
ring
¥¥ !
*
¥¥" #
kPointsPerRing
¥¥$ 2
;
¥¥2 3
for
∂∂ 
(
∂∂ 
int
∂∂ 
point
∂∂ 
=
∂∂  
$num
∂∂! "
;
∂∂" #
point
∂∂$ )
<
∂∂* +
points
∂∂, 2
;
∂∂2 3
point
∂∂4 9
++
∂∂9 ;
)
∂∂; <
{
∑∑ 
float
ππ 
phi
ππ 
=
ππ 
$num
ππ  "
*
ππ# $
PI
ππ% '
*
ππ( )
point
ππ* /
/
ππ0 1
points
ππ2 8
;
ππ8 9
float
ΩΩ 
nt
ΩΩ 
=
ΩΩ 
Mathf
ΩΩ $
.
ΩΩ$ %
Cos
ΩΩ% (
(
ΩΩ( )
PI
ΩΩ) +
/
ΩΩ, -

bladeCount
ΩΩ. 8
)
ΩΩ8 9
;
ΩΩ9 :
float
ææ 
dt
ææ 
=
ææ 
Mathf
ææ $
.
ææ$ %
Cos
ææ% (
(
ææ( )
phi
ææ) ,
-
ææ- .
(
ææ/ 0
TWO_PI
ææ0 6
/
ææ7 8

bladeCount
ææ9 C
)
ææC D
*
ææE F
Mathf
ææG L
.
ææL M
Floor
ææM R
(
ææR S
(
ææS T

bladeCount
ææT ^
*
ææ_ `
phi
ææa d
+
ææe f
Mathf
ææg l
.
ææl m
PI
ææm o
)
ææo p
/
ææq r
TWO_PI
ææs y
)
ææy z
)
ææz {
;
ææ{ |
float
øø 
r
øø 
=
øø 
radius
øø $
*
øø% &
Mathf
øø' ,
.
øø, -
Pow
øø- 0
(
øø0 1
nt
øø1 3
/
øø4 5
dt
øø6 8
,
øø8 9
	curvature
øø: C
)
øøC D
;
øøD E
float
¿¿ 
u
¿¿ 
=
¿¿ 
r
¿¿ 
*
¿¿  !
Mathf
¿¿" '
.
¿¿' (
Cos
¿¿( +
(
¿¿+ ,
phi
¿¿, /
-
¿¿0 1
rotation
¿¿2 :
)
¿¿: ;
;
¿¿; <
float
¡¡ 
v
¡¡ 
=
¡¡ 
r
¡¡ 
*
¡¡  !
Mathf
¡¡" '
.
¡¡' (
Sin
¡¡( +
(
¡¡+ ,
phi
¡¡, /
-
¡¡0 1
rotation
¡¡2 :
)
¡¡: ;
;
¡¡; <
m_BokehKernel
√√ !
[
√√! "
idx
√√" %
]
√√% &
=
√√' (
new
√√) ,
Vector4
√√- 4
(
√√4 5
u
√√5 6
,
√√6 7
v
√√8 9
)
√√9 :
;
√√: ;
idx
ƒƒ 
++
ƒƒ 
;
ƒƒ 
}
≈≈ 
}
∆∆ 
}
«« 	
[
…… 	

MethodImpl
……	 
(
…… 
MethodImplOptions
…… %
.
……% & 
AggressiveInlining
……& 8
)
……8 9
]
……9 :
static
   
float
   '
GetMaxBokehRadiusInPixels
   .
(
  . /
float
  / 4
viewportHeight
  5 C
)
  C D
{
ÀÀ 	
const
ÕÕ 
float
ÕÕ 
kRadiusInPixels
ÕÕ '
=
ÕÕ( )
$num
ÕÕ* -
;
ÕÕ- .
return
ŒŒ 
Mathf
ŒŒ 
.
ŒŒ 
Min
ŒŒ 
(
ŒŒ 
$num
ŒŒ "
,
ŒŒ" #
kRadiusInPixels
ŒŒ$ 3
/
ŒŒ4 5
viewportHeight
ŒŒ6 D
)
ŒŒD E
;
ŒŒE F
}
œœ 	
void
—— !
DoBokehDepthOfField
——  
(
——  !
CommandBuffer
——! .
cmd
——/ 2
,
——2 3
int
——4 7
source
——8 >
,
——> ?
int
——@ C
destination
——D O
,
——O P
Rect
——Q U
	pixelRect
——V _
)
——_ `
{
““ 	
int
”” 

downSample
”” 
=
”” 
$num
”” 
;
”” 
var
‘‘ 
material
‘‘ 
=
‘‘ 
m_Materials
‘‘ &
.
‘‘& '
bokehDepthOfField
‘‘' 8
;
‘‘8 9
int
’’ 
wh
’’ 
=
’’ 
m_Descriptor
’’ !
.
’’! "
width
’’" '
/
’’( )

downSample
’’* 4
;
’’4 5
int
÷÷ 
hh
÷÷ 
=
÷÷ 
m_Descriptor
÷÷ !
.
÷÷! "
height
÷÷" (
/
÷÷) *

downSample
÷÷+ 5
;
÷÷5 6
float
ŸŸ 
F
ŸŸ 
=
ŸŸ 
m_DepthOfField
ŸŸ $
.
ŸŸ$ %
focalLength
ŸŸ% 0
.
ŸŸ0 1
value
ŸŸ1 6
/
ŸŸ7 8
$num
ŸŸ9 >
;
ŸŸ> ?
float
⁄⁄ 
A
⁄⁄ 
=
⁄⁄ 
m_DepthOfField
⁄⁄ $
.
⁄⁄$ %
focalLength
⁄⁄% 0
.
⁄⁄0 1
value
⁄⁄1 6
/
⁄⁄7 8
m_DepthOfField
⁄⁄9 G
.
⁄⁄G H
aperture
⁄⁄H P
.
⁄⁄P Q
value
⁄⁄Q V
;
⁄⁄V W
float
€€ 
P
€€ 
=
€€ 
m_DepthOfField
€€ $
.
€€$ %
focusDistance
€€% 2
.
€€2 3
value
€€3 8
;
€€8 9
float
‹‹ 
maxCoC
‹‹ 
=
‹‹ 
(
‹‹ 
A
‹‹ 
*
‹‹ 
F
‹‹  !
)
‹‹! "
/
‹‹# $
(
‹‹% &
P
‹‹& '
-
‹‹( )
F
‹‹* +
)
‹‹+ ,
;
‹‹, -
float
›› 
	maxRadius
›› 
=
›› '
GetMaxBokehRadiusInPixels
›› 7
(
››7 8
m_Descriptor
››8 D
.
››D E
height
››E K
)
››K L
;
››L M
float
ﬁﬁ 
	rcpAspect
ﬁﬁ 
=
ﬁﬁ 
$num
ﬁﬁ  
/
ﬁﬁ! "
(
ﬁﬁ# $
wh
ﬁﬁ$ &
/
ﬁﬁ' (
(
ﬁﬁ) *
float
ﬁﬁ* /
)
ﬁﬁ/ 0
hh
ﬁﬁ0 2
)
ﬁﬁ2 3
;
ﬁﬁ3 4
cmd
‡‡ 
.
‡‡ 
SetGlobalVector
‡‡ 
(
‡‡  
ShaderConstants
‡‡  /
.
‡‡/ 0

_CoCParams
‡‡0 :
,
‡‡: ;
new
‡‡< ?
Vector4
‡‡@ G
(
‡‡G H
P
‡‡H I
,
‡‡I J
maxCoC
‡‡K Q
,
‡‡Q R
	maxRadius
‡‡S \
,
‡‡\ ]
	rcpAspect
‡‡^ g
)
‡‡g h
)
‡‡h i
;
‡‡i j
int
„„ 
hash
„„ 
=
„„ 
m_DepthOfField
„„ %
.
„„% &
GetHashCode
„„& 1
(
„„1 2
)
„„2 3
;
„„3 4
if
‰‰ 
(
‰‰ 
hash
‰‰ 
!=
‰‰ 
m_BokehHash
‰‰ #
)
‰‰# $
{
ÂÂ 
m_BokehHash
ÊÊ 
=
ÊÊ 
hash
ÊÊ "
;
ÊÊ" # 
PrepareBokehKernel
ÁÁ "
(
ÁÁ" #
)
ÁÁ# $
;
ÁÁ$ %
}
ËË 
cmd
ÍÍ 
.
ÍÍ "
SetGlobalVectorArray
ÍÍ $
(
ÍÍ$ %
ShaderConstants
ÍÍ% 4
.
ÍÍ4 5
_BokehKernel
ÍÍ5 A
,
ÍÍA B
m_BokehKernel
ÍÍC P
)
ÍÍP Q
;
ÍÍQ R
cmd
ÌÌ 
.
ÌÌ 
GetTemporaryRT
ÌÌ 
(
ÌÌ 
ShaderConstants
ÌÌ .
.
ÌÌ. /
_FullCoCTexture
ÌÌ/ >
,
ÌÌ> ?%
GetCompatibleDescriptor
ÌÌ@ W
(
ÌÌW X
m_Descriptor
ÌÌX d
.
ÌÌd e
width
ÌÌe j
,
ÌÌj k
m_Descriptor
ÌÌl x
.
ÌÌx y
height
ÌÌy 
,ÌÌ Ä
GraphicsFormatÌÌÅ è
.ÌÌè ê
R8_UNormÌÌê ò
)ÌÌò ô
,ÌÌô ö

FilterModeÌÌõ •
.ÌÌ• ¶
BilinearÌÌ¶ Æ
)ÌÌÆ Ø
;ÌÌØ ∞
cmd
ÓÓ 
.
ÓÓ 
GetTemporaryRT
ÓÓ 
(
ÓÓ 
ShaderConstants
ÓÓ .
.
ÓÓ. /
_PingTexture
ÓÓ/ ;
,
ÓÓ; <%
GetCompatibleDescriptor
ÓÓ= T
(
ÓÓT U
wh
ÓÓU W
,
ÓÓW X
hh
ÓÓY [
,
ÓÓ[ \
GraphicsFormat
ÓÓ] k
.
ÓÓk l!
R16G16B16A16_SFloat
ÓÓl 
)ÓÓ Ä
,ÓÓÄ Å

FilterModeÓÓÇ å
.ÓÓå ç
BilinearÓÓç ï
)ÓÓï ñ
;ÓÓñ ó
cmd
ÔÔ 
.
ÔÔ 
GetTemporaryRT
ÔÔ 
(
ÔÔ 
ShaderConstants
ÔÔ .
.
ÔÔ. /
_PongTexture
ÔÔ/ ;
,
ÔÔ; <%
GetCompatibleDescriptor
ÔÔ= T
(
ÔÔT U
wh
ÔÔU W
,
ÔÔW X
hh
ÔÔY [
,
ÔÔ[ \
GraphicsFormat
ÔÔ] k
.
ÔÔk l!
R16G16B16A16_SFloat
ÔÔl 
)ÔÔ Ä
,ÔÔÄ Å

FilterModeÔÔÇ å
.ÔÔå ç
BilinearÔÔç ï
)ÔÔï ñ
;ÔÔñ ó
PostProcessUtils
ÒÒ 
.
ÒÒ 
SetSourceSize
ÒÒ *
(
ÒÒ* +
cmd
ÒÒ+ .
,
ÒÒ. /
m_Descriptor
ÒÒ0 <
)
ÒÒ< =
;
ÒÒ= >
cmd
ÚÚ 
.
ÚÚ 
SetGlobalVector
ÚÚ 
(
ÚÚ  
ShaderConstants
ÚÚ  /
.
ÚÚ/ 0$
_DownSampleScaleFactor
ÚÚ0 F
,
ÚÚF G
new
ÚÚH K
Vector4
ÚÚL S
(
ÚÚS T
$num
ÚÚT X
/
ÚÚY Z

downSample
ÚÚ[ e
,
ÚÚe f
$num
ÚÚg k
/
ÚÚl m

downSample
ÚÚn x
,
ÚÚx y

downSampleÚÚz Ñ
,ÚÚÑ Ö

downSampleÚÚÜ ê
)ÚÚê ë
)ÚÚë í
;ÚÚí ì
Blit
ıı 
(
ıı 
cmd
ıı 
,
ıı 
source
ıı 
,
ıı 
ShaderConstants
ıı -
.
ıı- .
_FullCoCTexture
ıı. =
,
ıı= >
material
ıı? G
,
ııG H
$num
ııI J
)
ııJ K
;
ııK L
cmd
ˆˆ 
.
ˆˆ 
SetGlobalTexture
ˆˆ  
(
ˆˆ  !
ShaderConstants
ˆˆ! 0
.
ˆˆ0 1
_FullCoCTexture
ˆˆ1 @
,
ˆˆ@ A
ShaderConstants
ˆˆB Q
.
ˆˆQ R
_FullCoCTexture
ˆˆR a
)
ˆˆa b
;
ˆˆb c
Blit
˘˘ 
(
˘˘ 
cmd
˘˘ 
,
˘˘ 
source
˘˘ 
,
˘˘ 
ShaderConstants
˘˘ -
.
˘˘- .
_PingTexture
˘˘. :
,
˘˘: ;
material
˘˘< D
,
˘˘D E
$num
˘˘F G
)
˘˘G H
;
˘˘H I
Blit
¸¸ 
(
¸¸ 
cmd
¸¸ 
,
¸¸ 
ShaderConstants
¸¸ %
.
¸¸% &
_PingTexture
¸¸& 2
,
¸¸2 3
ShaderConstants
¸¸4 C
.
¸¸C D
_PongTexture
¸¸D P
,
¸¸P Q
material
¸¸R Z
,
¸¸Z [
$num
¸¸\ ]
)
¸¸] ^
;
¸¸^ _
Blit
ˇˇ 
(
ˇˇ 
cmd
ˇˇ 
,
ˇˇ 
ShaderConstants
ˇˇ %
.
ˇˇ% &
_PongTexture
ˇˇ& 2
,
ˇˇ2 3#
BlitDstDiscardContent
ˇˇ4 I
(
ˇˇI J
cmd
ˇˇJ M
,
ˇˇM N
ShaderConstants
ˇˇO ^
.
ˇˇ^ _
_PingTexture
ˇˇ_ k
)
ˇˇk l
,
ˇˇl m
material
ˇˇn v
,
ˇˇv w
$num
ˇˇx y
)
ˇˇy z
;
ˇˇz {
cmd
ÇÇ 
.
ÇÇ 
SetGlobalTexture
ÇÇ  
(
ÇÇ  !
ShaderConstants
ÇÇ! 0
.
ÇÇ0 1
_DofTexture
ÇÇ1 <
,
ÇÇ< =
ShaderConstants
ÇÇ> M
.
ÇÇM N
_PingTexture
ÇÇN Z
)
ÇÇZ [
;
ÇÇ[ \
Blit
ÉÉ 
(
ÉÉ 
cmd
ÉÉ 
,
ÉÉ 
source
ÉÉ 
,
ÉÉ #
BlitDstDiscardContent
ÉÉ 3
(
ÉÉ3 4
cmd
ÉÉ4 7
,
ÉÉ7 8
destination
ÉÉ9 D
)
ÉÉD E
,
ÉÉE F
material
ÉÉG O
,
ÉÉO P
$num
ÉÉQ R
)
ÉÉR S
;
ÉÉS T
cmd
ÜÜ 
.
ÜÜ  
ReleaseTemporaryRT
ÜÜ "
(
ÜÜ" #
ShaderConstants
ÜÜ# 2
.
ÜÜ2 3
_FullCoCTexture
ÜÜ3 B
)
ÜÜB C
;
ÜÜC D
cmd
áá 
.
áá  
ReleaseTemporaryRT
áá "
(
áá" #
ShaderConstants
áá# 2
.
áá2 3
_PingTexture
áá3 ?
)
áá? @
;
áá@ A
cmd
àà 
.
àà  
ReleaseTemporaryRT
àà "
(
àà" #
ShaderConstants
àà# 2
.
àà2 3
_PongTexture
àà3 ?
)
àà? @
;
àà@ A
}
ââ 	
internal
êê 
static
êê 
readonly
êê  
	Matrix4x4
êê! *
[
êê* +
]
êê+ ,"
viewProjMatrixStereo
êê- A
=
êêB C
new
êêD G
	Matrix4x4
êêH Q
[
êêQ R
$num
êêR S
]
êêS T
;
êêT U
void
íí 
DoMotionBlur
íí 
(
íí 

CameraData
íí $

cameraData
íí% /
,
íí/ 0
CommandBuffer
íí1 >
cmd
íí? B
,
ííB C
int
ííD G
source
ííH N
,
ííN O
int
ííP S
destination
ííT _
)
íí_ `
{
ìì 	
var
îî 
material
îî 
=
îî 
m_Materials
îî &
.
îî& '
cameraMotionBlur
îî' 7
;
îî7 8
if
óó 
(
óó 

cameraData
óó 
.
óó 
xr
óó 
.
óó 
enabled
óó %
&&
óó& (

cameraData
óó) 3
.
óó3 4
xr
óó4 6
.
óó6 7
singlePassEnabled
óó7 H
)
óóH I
{
òò 
var
ôô 
	viewProj0
ôô 
=
ôô 
GL
ôô  "
.
ôô" #$
GetGPUProjectionMatrix
ôô# 9
(
ôô9 :

cameraData
ôô: D
.
ôôD E!
GetProjectionMatrix
ôôE X
(
ôôX Y
$num
ôôY Z
)
ôôZ [
,
ôô[ \
true
ôô] a
)
ôôa b
*
ôôc d

cameraData
ôôe o
.
ôôo p
GetViewMatrix
ôôp }
(
ôô} ~
$num
ôô~ 
)ôô Ä
;ôôÄ Å
var
öö 
	viewProj1
öö 
=
öö 
GL
öö  "
.
öö" #$
GetGPUProjectionMatrix
öö# 9
(
öö9 :

cameraData
öö: D
.
ööD E!
GetProjectionMatrix
ööE X
(
ööX Y
$num
ööY Z
)
ööZ [
,
öö[ \
true
öö] a
)
ööa b
*
ööc d

cameraData
ööe o
.
ööo p
GetViewMatrix
ööp }
(
öö} ~
$num
öö~ 
)öö Ä
;ööÄ Å
if
õõ 
(
õõ 
m_ResetHistory
õõ "
)
õõ" #
{
úú "
viewProjMatrixStereo
ùù (
[
ùù( )
$num
ùù) *
]
ùù* +
=
ùù, -
	viewProj0
ùù. 7
;
ùù7 8"
viewProjMatrixStereo
ûû (
[
ûû( )
$num
ûû) *
]
ûû* +
=
ûû, -
	viewProj1
ûû. 7
;
ûû7 8
material
üü 
.
üü 
SetMatrixArray
üü +
(
üü+ ,
$str
üü, B
,
üüB C"
viewProjMatrixStereo
üüD X
)
üüX Y
;
üüY Z
}
†† 
else
°° 
material
¢¢ 
.
¢¢ 
SetMatrixArray
¢¢ +
(
¢¢+ ,
$str
¢¢, B
,
¢¢B C
m_PrevViewProjM
¢¢D S
)
¢¢S T
;
¢¢T U
m_PrevViewProjM
§§ 
[
§§  
$num
§§  !
]
§§! "
=
§§# $
	viewProj0
§§% .
;
§§. /
m_PrevViewProjM
•• 
[
••  
$num
••  !
]
••! "
=
••# $
	viewProj1
••% .
;
••. /
}
¶¶ 
else
ßß 
{
©© 
int
™™ 
prevViewProjMIdx
™™ $
=
™™% &
$num
™™' (
;
™™( )
if
¨¨ 
(
¨¨ 

cameraData
¨¨ 
.
¨¨ 
xr
¨¨ !
.
¨¨! "
enabled
¨¨" )
)
¨¨) *
prevViewProjMIdx
≠≠ $
=
≠≠% &

cameraData
≠≠' 1
.
≠≠1 2
xr
≠≠2 4
.
≠≠4 5
multipassId
≠≠5 @
;
≠≠@ A
var
≤≤ 
proj
≤≤ 
=
≤≤ 

cameraData
≤≤ %
.
≤≤% &!
GetProjectionMatrix
≤≤& 9
(
≤≤9 :
)
≤≤: ;
;
≤≤; <
var
≥≥ 
view
≥≥ 
=
≥≥ 

cameraData
≥≥ %
.
≥≥% &
GetViewMatrix
≥≥& 3
(
≥≥3 4
)
≥≥4 5
;
≥≥5 6
var
¥¥ 
viewProj
¥¥ 
=
¥¥ 
proj
¥¥ #
*
¥¥$ %
view
¥¥& *
;
¥¥* +
material
∂∂ 
.
∂∂ 
	SetMatrix
∂∂ "
(
∂∂" #
$str
∂∂# /
,
∂∂/ 0
viewProj
∂∂1 9
)
∂∂9 :
;
∂∂: ;
if
∏∏ 
(
∏∏ 
m_ResetHistory
∏∏ "
)
∏∏" #
material
ππ 
.
ππ 
	SetMatrix
ππ &
(
ππ& '
$str
ππ' 7
,
ππ7 8
viewProj
ππ9 A
)
ππA B
;
ππB C
else
∫∫ 
material
ªª 
.
ªª 
	SetMatrix
ªª &
(
ªª& '
$str
ªª' 7
,
ªª7 8
m_PrevViewProjM
ªª9 H
[
ªªH I
prevViewProjMIdx
ªªI Y
]
ªªY Z
)
ªªZ [
;
ªª[ \
m_PrevViewProjM
ΩΩ 
[
ΩΩ  
prevViewProjMIdx
ΩΩ  0
]
ΩΩ0 1
=
ΩΩ2 3
viewProj
ΩΩ4 <
;
ΩΩ< =
}
ææ 
material
¿¿ 
.
¿¿ 
SetFloat
¿¿ 
(
¿¿ 
$str
¿¿ *
,
¿¿* +
m_MotionBlur
¿¿, 8
.
¿¿8 9
	intensity
¿¿9 B
.
¿¿B C
value
¿¿C H
)
¿¿H I
;
¿¿I J
material
¡¡ 
.
¡¡ 
SetFloat
¡¡ 
(
¡¡ 
$str
¡¡ &
,
¡¡& '
m_MotionBlur
¡¡( 4
.
¡¡4 5
clamp
¡¡5 :
.
¡¡: ;
value
¡¡; @
)
¡¡@ A
;
¡¡A B
PostProcessUtils
√√ 
.
√√ 
SetSourceSize
√√ *
(
√√* +
cmd
√√+ .
,
√√. /
m_Descriptor
√√0 <
)
√√< =
;
√√= >
Blit
≈≈ 
(
≈≈ 
cmd
≈≈ 
,
≈≈ 
source
≈≈ 
,
≈≈ #
BlitDstDiscardContent
≈≈ 3
(
≈≈3 4
cmd
≈≈4 7
,
≈≈7 8
destination
≈≈9 D
)
≈≈D E
,
≈≈E F
material
≈≈G O
,
≈≈O P
(
≈≈Q R
int
≈≈R U
)
≈≈U V
m_MotionBlur
≈≈V b
.
≈≈b c
quality
≈≈c j
.
≈≈j k
value
≈≈k p
)
≈≈p q
;
≈≈q r
}
∆∆ 	
void
ÕÕ  
DoPaniniProjection
ÕÕ 
(
ÕÕ  
Camera
ÕÕ  &
camera
ÕÕ' -
,
ÕÕ- .
CommandBuffer
ÕÕ/ <
cmd
ÕÕ= @
,
ÕÕ@ A
int
ÕÕB E
source
ÕÕF L
,
ÕÕL M
int
ÕÕN Q
destination
ÕÕR ]
)
ÕÕ] ^
{
ŒŒ 	
float
œœ 
distance
œœ 
=
œœ  
m_PaniniProjection
œœ /
.
œœ/ 0
distance
œœ0 8
.
œœ8 9
value
œœ9 >
;
œœ> ?
var
–– 
viewExtents
–– 
=
–– 
CalcViewExtents
–– -
(
––- .
camera
––. 4
)
––4 5
;
––5 6
var
—— 
cropExtents
—— 
=
—— 
CalcCropExtents
—— -
(
——- .
camera
——. 4
,
——4 5
distance
——6 >
)
——> ?
;
——? @
float
”” 
scaleX
”” 
=
”” 
cropExtents
”” &
.
””& '
x
””' (
/
””) *
viewExtents
””+ 6
.
””6 7
x
””7 8
;
””8 9
float
‘‘ 
scaleY
‘‘ 
=
‘‘ 
cropExtents
‘‘ &
.
‘‘& '
y
‘‘' (
/
‘‘) *
viewExtents
‘‘+ 6
.
‘‘6 7
y
‘‘7 8
;
‘‘8 9
float
’’ 
scaleF
’’ 
=
’’ 
Mathf
’’  
.
’’  !
Min
’’! $
(
’’$ %
scaleX
’’% +
,
’’+ ,
scaleY
’’- 3
)
’’3 4
;
’’4 5
float
◊◊ 
paniniD
◊◊ 
=
◊◊ 
distance
◊◊ $
;
◊◊$ %
float
ÿÿ 
paniniS
ÿÿ 
=
ÿÿ 
Mathf
ÿÿ !
.
ÿÿ! "
Lerp
ÿÿ" &
(
ÿÿ& '
$num
ÿÿ' )
,
ÿÿ) *
Mathf
ÿÿ+ 0
.
ÿÿ0 1
Clamp01
ÿÿ1 8
(
ÿÿ8 9
scaleF
ÿÿ9 ?
)
ÿÿ? @
,
ÿÿ@ A 
m_PaniniProjection
ÿÿB T
.
ÿÿT U
	cropToFit
ÿÿU ^
.
ÿÿ^ _
value
ÿÿ_ d
)
ÿÿd e
;
ÿÿe f
var
⁄⁄ 
material
⁄⁄ 
=
⁄⁄ 
m_Materials
⁄⁄ &
.
⁄⁄& '
paniniProjection
⁄⁄' 7
;
⁄⁄7 8
material
€€ 
.
€€ 
	SetVector
€€ 
(
€€ 
ShaderConstants
€€ .
.
€€. /
_Params
€€/ 6
,
€€6 7
new
€€8 ;
Vector4
€€< C
(
€€C D
viewExtents
€€D O
.
€€O P
x
€€P Q
,
€€Q R
viewExtents
€€S ^
.
€€^ _
y
€€_ `
,
€€` a
paniniD
€€b i
,
€€i j
paniniS
€€k r
)
€€r s
)
€€s t
;
€€t u
material
‹‹ 
.
‹‹ 
EnableKeyword
‹‹ "
(
‹‹" #
$num
›› 
-
›› 
Mathf
›› 
.
›› 
Abs
›› 
(
›› 
paniniD
›› &
)
››& '
>
››( )
float
››* /
.
››/ 0
Epsilon
››0 7
?
ﬁﬁ "
ShaderKeywordStrings
ﬁﬁ &
.
ﬁﬁ& '
PaniniGeneric
ﬁﬁ' 4
:
ﬁﬁ5 6"
ShaderKeywordStrings
ﬁﬁ7 K
.
ﬁﬁK L 
PaniniUnitDistance
ﬁﬁL ^
)
ﬂﬂ 
;
ﬂﬂ 
Blit
·· 
(
·· 
cmd
·· 
,
·· 
source
·· 
,
·· #
BlitDstDiscardContent
·· 3
(
··3 4
cmd
··4 7
,
··7 8
destination
··9 D
)
··D E
,
··E F
material
··G O
)
··O P
;
··P Q
}
‚‚ 	
Vector2
‰‰ 
CalcViewExtents
‰‰ 
(
‰‰  
Camera
‰‰  &
camera
‰‰' -
)
‰‰- .
{
ÂÂ 	
float
ÊÊ 
fovY
ÊÊ 
=
ÊÊ 
camera
ÊÊ 
.
ÊÊ  
fieldOfView
ÊÊ  +
*
ÊÊ, -
Mathf
ÊÊ. 3
.
ÊÊ3 4
Deg2Rad
ÊÊ4 ;
;
ÊÊ; <
float
ÁÁ 
aspect
ÁÁ 
=
ÁÁ 
m_Descriptor
ÁÁ '
.
ÁÁ' (
width
ÁÁ( -
/
ÁÁ. /
(
ÁÁ0 1
float
ÁÁ1 6
)
ÁÁ6 7
m_Descriptor
ÁÁ7 C
.
ÁÁC D
height
ÁÁD J
;
ÁÁJ K
float
ÈÈ 
viewExtY
ÈÈ 
=
ÈÈ 
Mathf
ÈÈ "
.
ÈÈ" #
Tan
ÈÈ# &
(
ÈÈ& '
$num
ÈÈ' +
*
ÈÈ, -
fovY
ÈÈ. 2
)
ÈÈ2 3
;
ÈÈ3 4
float
ÍÍ 
viewExtX
ÍÍ 
=
ÍÍ 
aspect
ÍÍ #
*
ÍÍ$ %
viewExtY
ÍÍ& .
;
ÍÍ. /
return
ÏÏ 
new
ÏÏ 
Vector2
ÏÏ 
(
ÏÏ 
viewExtX
ÏÏ '
,
ÏÏ' (
viewExtY
ÏÏ) 1
)
ÏÏ1 2
;
ÏÏ2 3
}
ÌÌ 	
Vector2
ÔÔ 
CalcCropExtents
ÔÔ 
(
ÔÔ  
Camera
ÔÔ  &
camera
ÔÔ' -
,
ÔÔ- .
float
ÔÔ/ 4
d
ÔÔ5 6
)
ÔÔ6 7
{
 	
float
áá 
viewDist
áá 
=
áá 
$num
áá 
+
áá  !
d
áá" #
;
áá# $
var
ââ 
projPos
ââ 
=
ââ 
CalcViewExtents
ââ )
(
ââ) *
camera
ââ* 0
)
ââ0 1
;
ââ1 2
var
ää 
projHyp
ää 
=
ää 
Mathf
ää 
.
ää  
Sqrt
ää  $
(
ää$ %
projPos
ää% ,
.
ää, -
x
ää- .
*
ää/ 0
projPos
ää1 8
.
ää8 9
x
ää9 :
+
ää; <
$num
ää= ?
)
ää? @
;
ää@ A
float
åå 
cylDistMinusD
åå 
=
åå  !
$num
åå" $
/
åå% &
projHyp
åå' .
;
åå. /
float
çç 
cylDist
çç 
=
çç 
cylDistMinusD
çç )
+
çç* +
d
çç, -
;
çç- .
var
éé 
cylPos
éé 
=
éé 
projPos
éé  
*
éé! "
cylDistMinusD
éé# 0
;
éé0 1
return
êê 
cylPos
êê 
*
êê 
(
êê 
viewDist
êê %
/
êê& '
cylDist
êê( /
)
êê/ 0
;
êê0 1
}
ëë 	
void
óó 

SetupBloom
óó 
(
óó 
CommandBuffer
óó %
cmd
óó& )
,
óó) *
int
óó+ .
source
óó/ 5
,
óó5 6
Material
óó7 ?
uberMaterial
óó@ L
)
óóL M
{
òò 	
int
öö 
tw
öö 
=
öö 
m_Descriptor
öö !
.
öö! "
width
öö" '
>>
öö( *
$num
öö+ ,
;
öö, -
int
õõ 
th
õõ 
=
õõ 
m_Descriptor
õõ !
.
õõ! "
height
õõ" (
>>
õõ) +
$num
õõ, -
;
õõ- .
int
ûû 
maxSize
ûû 
=
ûû 
Mathf
ûû 
.
ûû  
Max
ûû  #
(
ûû# $
tw
ûû$ &
,
ûû& '
th
ûû( *
)
ûû* +
;
ûû+ ,
int
üü 

iterations
üü 
=
üü 
Mathf
üü "
.
üü" #

FloorToInt
üü# -
(
üü- .
Mathf
üü. 3
.
üü3 4
Log
üü4 7
(
üü7 8
maxSize
üü8 ?
,
üü? @
$num
üüA C
)
üüC D
-
üüE F
$num
üüG H
)
üüH I
;
üüI J

iterations
†† 
-=
†† 
m_Bloom
†† !
.
††! "
skipIterations
††" 0
.
††0 1
value
††1 6
;
††6 7
int
°° 
mipCount
°° 
=
°° 
Mathf
°°  
.
°°  !
Clamp
°°! &
(
°°& '

iterations
°°' 1
,
°°1 2
$num
°°3 4
,
°°4 5
k_MaxPyramidSize
°°6 F
)
°°F G
;
°°G H
float
§§ 
clamp
§§ 
=
§§ 
m_Bloom
§§ !
.
§§! "
clamp
§§" '
.
§§' (
value
§§( -
;
§§- .
float
•• 
	threshold
•• 
=
•• 
Mathf
•• #
.
••# $ 
GammaToLinearSpace
••$ 6
(
••6 7
m_Bloom
••7 >
.
••> ?
	threshold
••? H
.
••H I
value
••I N
)
••N O
;
••O P
float
¶¶ 
thresholdKnee
¶¶ 
=
¶¶  !
	threshold
¶¶" +
*
¶¶, -
$num
¶¶. 2
;
¶¶2 3
float
©© 
scatter
©© 
=
©© 
Mathf
©© !
.
©©! "
Lerp
©©" &
(
©©& '
$num
©©' ,
,
©©, -
$num
©©. 3
,
©©3 4
m_Bloom
©©5 <
.
©©< =
scatter
©©= D
.
©©D E
value
©©E J
)
©©J K
;
©©K L
var
™™ 
bloomMaterial
™™ 
=
™™ 
m_Materials
™™  +
.
™™+ ,
bloom
™™, 1
;
™™1 2
bloomMaterial
´´ 
.
´´ 
	SetVector
´´ #
(
´´# $
ShaderConstants
´´$ 3
.
´´3 4
_Params
´´4 ;
,
´´; <
new
´´= @
Vector4
´´A H
(
´´H I
scatter
´´I P
,
´´P Q
clamp
´´R W
,
´´W X
	threshold
´´Y b
,
´´b c
thresholdKnee
´´d q
)
´´q r
)
´´r s
;
´´s t
	CoreUtils
¨¨ 
.
¨¨ 

SetKeyword
¨¨  
(
¨¨  !
bloomMaterial
¨¨! .
,
¨¨. /"
ShaderKeywordStrings
¨¨0 D
.
¨¨D E
BloomHQ
¨¨E L
,
¨¨L M
m_Bloom
¨¨N U
.
¨¨U V"
highQualityFiltering
¨¨V j
.
¨¨j k
value
¨¨k p
)
¨¨p q
;
¨¨q r
	CoreUtils
≠≠ 
.
≠≠ 

SetKeyword
≠≠  
(
≠≠  !
bloomMaterial
≠≠! .
,
≠≠. /"
ShaderKeywordStrings
≠≠0 D
.
≠≠D E
UseRGBM
≠≠E L
,
≠≠L M
	m_UseRGBM
≠≠N W
)
≠≠W X
;
≠≠X Y
var
∞∞ 
desc
∞∞ 
=
∞∞ %
GetCompatibleDescriptor
∞∞ .
(
∞∞. /
tw
∞∞/ 1
,
∞∞1 2
th
∞∞3 5
,
∞∞5 6 
m_DefaultHDRFormat
∞∞7 I
)
∞∞I J
;
∞∞J K
cmd
±± 
.
±± 
GetTemporaryRT
±± 
(
±± 
ShaderConstants
±± .
.
±±. /
_BloomMipDown
±±/ <
[
±±< =
$num
±±= >
]
±±> ?
,
±±? @
desc
±±A E
,
±±E F

FilterMode
±±G Q
.
±±Q R
Bilinear
±±R Z
)
±±Z [
;
±±[ \
cmd
≤≤ 
.
≤≤ 
GetTemporaryRT
≤≤ 
(
≤≤ 
ShaderConstants
≤≤ .
.
≤≤. /
_BloomMipUp
≤≤/ :
[
≤≤: ;
$num
≤≤; <
]
≤≤< =
,
≤≤= >
desc
≤≤? C
,
≤≤C D

FilterMode
≤≤E O
.
≤≤O P
Bilinear
≤≤P X
)
≤≤X Y
;
≤≤Y Z
Blit
≥≥ 
(
≥≥ 
cmd
≥≥ 
,
≥≥ 
source
≥≥ 
,
≥≥ 
ShaderConstants
≥≥ -
.
≥≥- .
_BloomMipDown
≥≥. ;
[
≥≥; <
$num
≥≥< =
]
≥≥= >
,
≥≥> ?
bloomMaterial
≥≥@ M
,
≥≥M N
$num
≥≥O P
)
≥≥P Q
;
≥≥Q R
int
∂∂ 
lastDown
∂∂ 
=
∂∂ 
ShaderConstants
∂∂ *
.
∂∂* +
_BloomMipDown
∂∂+ 8
[
∂∂8 9
$num
∂∂9 :
]
∂∂: ;
;
∂∂; <
for
∑∑ 
(
∑∑ 
int
∑∑ 
i
∑∑ 
=
∑∑ 
$num
∑∑ 
;
∑∑ 
i
∑∑ 
<
∑∑ 
mipCount
∑∑  (
;
∑∑( )
i
∑∑* +
++
∑∑+ -
)
∑∑- .
{
∏∏ 
tw
ππ 
=
ππ 
Mathf
ππ 
.
ππ 
Max
ππ 
(
ππ 
$num
ππ  
,
ππ  !
tw
ππ" $
>>
ππ% '
$num
ππ( )
)
ππ) *
;
ππ* +
th
∫∫ 
=
∫∫ 
Mathf
∫∫ 
.
∫∫ 
Max
∫∫ 
(
∫∫ 
$num
∫∫  
,
∫∫  !
th
∫∫" $
>>
∫∫% '
$num
∫∫( )
)
∫∫) *
;
∫∫* +
int
ªª 
mipDown
ªª 
=
ªª 
ShaderConstants
ªª -
.
ªª- .
_BloomMipDown
ªª. ;
[
ªª; <
i
ªª< =
]
ªª= >
;
ªª> ?
int
ºº 
mipUp
ºº 
=
ºº 
ShaderConstants
ºº +
.
ºº+ ,
_BloomMipUp
ºº, 7
[
ºº7 8
i
ºº8 9
]
ºº9 :
;
ºº: ;
desc
ææ 
.
ææ 
width
ææ 
=
ææ 
tw
ææ 
;
ææ  
desc
øø 
.
øø 
height
øø 
=
øø 
th
øø  
;
øø  !
cmd
¡¡ 
.
¡¡ 
GetTemporaryRT
¡¡ "
(
¡¡" #
mipDown
¡¡# *
,
¡¡* +
desc
¡¡, 0
,
¡¡0 1

FilterMode
¡¡2 <
.
¡¡< =
Bilinear
¡¡= E
)
¡¡E F
;
¡¡F G
cmd
¬¬ 
.
¬¬ 
GetTemporaryRT
¬¬ "
(
¬¬" #
mipUp
¬¬# (
,
¬¬( )
desc
¬¬* .
,
¬¬. /

FilterMode
¬¬0 :
.
¬¬: ;
Bilinear
¬¬; C
)
¬¬C D
;
¬¬D E
Blit
«« 
(
«« 
cmd
«« 
,
«« 
lastDown
«« "
,
««" #
mipUp
««$ )
,
««) *
bloomMaterial
««+ 8
,
««8 9
$num
««: ;
)
««; <
;
««< =
Blit
»» 
(
»» 
cmd
»» 
,
»» 
mipUp
»» 
,
»»  
mipDown
»»! (
,
»»( )
bloomMaterial
»»* 7
,
»»7 8
$num
»»9 :
)
»»: ;
;
»»; <
lastDown
   
=
   
mipDown
   "
;
  " #
}
ÀÀ 
for
ŒŒ 
(
ŒŒ 
int
ŒŒ 
i
ŒŒ 
=
ŒŒ 
mipCount
ŒŒ !
-
ŒŒ" #
$num
ŒŒ$ %
;
ŒŒ% &
i
ŒŒ' (
>=
ŒŒ) +
$num
ŒŒ, -
;
ŒŒ- .
i
ŒŒ/ 0
--
ŒŒ0 2
)
ŒŒ2 3
{
œœ 
int
–– 
lowMip
–– 
=
–– 
(
–– 
i
–– 
==
––  "
mipCount
––# +
-
––, -
$num
––. /
)
––/ 0
?
––1 2
ShaderConstants
––3 B
.
––B C
_BloomMipDown
––C P
[
––P Q
i
––Q R
+
––S T
$num
––U V
]
––V W
:
––X Y
ShaderConstants
––Z i
.
––i j
_BloomMipUp
––j u
[
––u v
i
––v w
+
––x y
$num
––z {
]
––{ |
;
––| }
int
—— 
highMip
—— 
=
—— 
ShaderConstants
—— -
.
——- .
_BloomMipDown
——. ;
[
——; <
i
——< =
]
——= >
;
——> ?
int
““ 
dst
““ 
=
““ 
ShaderConstants
““ )
.
““) *
_BloomMipUp
““* 5
[
““5 6
i
““6 7
]
““7 8
;
““8 9
cmd
‘‘ 
.
‘‘ 
SetGlobalTexture
‘‘ $
(
‘‘$ %
ShaderConstants
‘‘% 4
.
‘‘4 5
_SourceTexLowMip
‘‘5 E
,
‘‘E F
lowMip
‘‘G M
)
‘‘M N
;
‘‘N O
Blit
’’ 
(
’’ 
cmd
’’ 
,
’’ 
highMip
’’ !
,
’’! "#
BlitDstDiscardContent
’’# 8
(
’’8 9
cmd
’’9 <
,
’’< =
dst
’’> A
)
’’A B
,
’’B C
bloomMaterial
’’D Q
,
’’Q R
$num
’’S T
)
’’T U
;
’’U V
}
÷÷ 
for
ŸŸ 
(
ŸŸ 
int
ŸŸ 
i
ŸŸ 
=
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
i
ŸŸ 
<
ŸŸ 
mipCount
ŸŸ  (
;
ŸŸ( )
i
ŸŸ* +
++
ŸŸ+ -
)
ŸŸ- .
{
⁄⁄ 
cmd
€€ 
.
€€  
ReleaseTemporaryRT
€€ &
(
€€& '
ShaderConstants
€€' 6
.
€€6 7
_BloomMipDown
€€7 D
[
€€D E
i
€€E F
]
€€F G
)
€€G H
;
€€H I
if
‹‹ 
(
‹‹ 
i
‹‹ 
>
‹‹ 
$num
‹‹ 
)
‹‹ 
cmd
‹‹ 
.
‹‹  
ReleaseTemporaryRT
‹‹ 1
(
‹‹1 2
ShaderConstants
‹‹2 A
.
‹‹A B
_BloomMipUp
‹‹B M
[
‹‹M N
i
‹‹N O
]
‹‹O P
)
‹‹P Q
;
‹‹Q R
}
›› 
var
‡‡ 
tint
‡‡ 
=
‡‡ 
m_Bloom
‡‡ 
.
‡‡ 
tint
‡‡ #
.
‡‡# $
value
‡‡$ )
.
‡‡) *
linear
‡‡* 0
;
‡‡0 1
var
·· 
luma
·· 
=
·· 

ColorUtils
·· !
.
··! "
	Luminance
··" +
(
··+ ,
tint
··, 0
)
··0 1
;
··1 2
tint
‚‚ 
=
‚‚ 
luma
‚‚ 
>
‚‚ 
$num
‚‚ 
?
‚‚ 
tint
‚‚ #
*
‚‚$ %
(
‚‚& '
$num
‚‚' )
/
‚‚* +
luma
‚‚, 0
)
‚‚0 1
:
‚‚2 3
Color
‚‚4 9
.
‚‚9 :
white
‚‚: ?
;
‚‚? @
var
‰‰ 
bloomParams
‰‰ 
=
‰‰ 
new
‰‰ !
Vector4
‰‰" )
(
‰‰) *
m_Bloom
‰‰* 1
.
‰‰1 2
	intensity
‰‰2 ;
.
‰‰; <
value
‰‰< A
,
‰‰A B
tint
‰‰C G
.
‰‰G H
r
‰‰H I
,
‰‰I J
tint
‰‰K O
.
‰‰O P
g
‰‰P Q
,
‰‰Q R
tint
‰‰S W
.
‰‰W X
b
‰‰X Y
)
‰‰Y Z
;
‰‰Z [
uberMaterial
ÂÂ 
.
ÂÂ 
	SetVector
ÂÂ "
(
ÂÂ" #
ShaderConstants
ÂÂ# 2
.
ÂÂ2 3
_Bloom_Params
ÂÂ3 @
,
ÂÂ@ A
bloomParams
ÂÂB M
)
ÂÂM N
;
ÂÂN O
uberMaterial
ÊÊ 
.
ÊÊ 
SetFloat
ÊÊ !
(
ÊÊ! "
ShaderConstants
ÊÊ" 1
.
ÊÊ1 2
_Bloom_RGBM
ÊÊ2 =
,
ÊÊ= >
	m_UseRGBM
ÊÊ? H
?
ÊÊI J
$num
ÊÊK M
:
ÊÊN O
$num
ÊÊP R
)
ÊÊR S
;
ÊÊS T
cmd
ËË 
.
ËË 
SetGlobalTexture
ËË  
(
ËË  !
ShaderConstants
ËË! 0
.
ËË0 1
_Bloom_Texture
ËË1 ?
,
ËË? @
ShaderConstants
ËËA P
.
ËËP Q
_BloomMipUp
ËËQ \
[
ËË\ ]
$num
ËË] ^
]
ËË^ _
)
ËË_ `
;
ËË` a
var
ÌÌ 
dirtTexture
ÌÌ 
=
ÌÌ 
m_Bloom
ÌÌ %
.
ÌÌ% &
dirtTexture
ÌÌ& 1
.
ÌÌ1 2
value
ÌÌ2 7
==
ÌÌ8 :
null
ÌÌ; ?
?
ÌÌ@ A
	Texture2D
ÌÌB K
.
ÌÌK L
blackTexture
ÌÌL X
:
ÌÌY Z
m_Bloom
ÌÌ[ b
.
ÌÌb c
dirtTexture
ÌÌc n
.
ÌÌn o
value
ÌÌo t
;
ÌÌt u
float
ÓÓ 
	dirtRatio
ÓÓ 
=
ÓÓ 
dirtTexture
ÓÓ )
.
ÓÓ) *
width
ÓÓ* /
/
ÓÓ0 1
(
ÓÓ2 3
float
ÓÓ3 8
)
ÓÓ8 9
dirtTexture
ÓÓ9 D
.
ÓÓD E
height
ÓÓE K
;
ÓÓK L
float
ÔÔ 
screenRatio
ÔÔ 
=
ÔÔ 
m_Descriptor
ÔÔ  ,
.
ÔÔ, -
width
ÔÔ- 2
/
ÔÔ3 4
(
ÔÔ5 6
float
ÔÔ6 ;
)
ÔÔ; <
m_Descriptor
ÔÔ< H
.
ÔÔH I
height
ÔÔI O
;
ÔÔO P
var
 
dirtScaleOffset
 
=
  !
new
" %
Vector4
& -
(
- .
$num
. 0
,
0 1
$num
2 4
,
4 5
$num
6 8
,
8 9
$num
: <
)
< =
;
= >
float
ÒÒ 
dirtIntensity
ÒÒ 
=
ÒÒ  !
m_Bloom
ÒÒ" )
.
ÒÒ) *
dirtIntensity
ÒÒ* 7
.
ÒÒ7 8
value
ÒÒ8 =
;
ÒÒ= >
if
ÛÛ 
(
ÛÛ 
	dirtRatio
ÛÛ 
>
ÛÛ 
screenRatio
ÛÛ '
)
ÛÛ' (
{
ÙÙ 
dirtScaleOffset
ıı 
.
ıı  
x
ıı  !
=
ıı" #
screenRatio
ıı$ /
/
ıı0 1
	dirtRatio
ıı2 ;
;
ıı; <
dirtScaleOffset
ˆˆ 
.
ˆˆ  
z
ˆˆ  !
=
ˆˆ" #
(
ˆˆ$ %
$num
ˆˆ% '
-
ˆˆ( )
dirtScaleOffset
ˆˆ* 9
.
ˆˆ9 :
x
ˆˆ: ;
)
ˆˆ; <
*
ˆˆ= >
$num
ˆˆ? C
;
ˆˆC D
}
˜˜ 
else
¯¯ 
if
¯¯ 
(
¯¯ 
screenRatio
¯¯  
>
¯¯! "
	dirtRatio
¯¯# ,
)
¯¯, -
{
˘˘ 
dirtScaleOffset
˙˙ 
.
˙˙  
y
˙˙  !
=
˙˙" #
	dirtRatio
˙˙$ -
/
˙˙. /
screenRatio
˙˙0 ;
;
˙˙; <
dirtScaleOffset
˚˚ 
.
˚˚  
w
˚˚  !
=
˚˚" #
(
˚˚$ %
$num
˚˚% '
-
˚˚( )
dirtScaleOffset
˚˚* 9
.
˚˚9 :
y
˚˚: ;
)
˚˚; <
*
˚˚= >
$num
˚˚? C
;
˚˚C D
}
¸¸ 
uberMaterial
˛˛ 
.
˛˛ 
	SetVector
˛˛ "
(
˛˛" #
ShaderConstants
˛˛# 2
.
˛˛2 3
_LensDirt_Params
˛˛3 C
,
˛˛C D
dirtScaleOffset
˛˛E T
)
˛˛T U
;
˛˛U V
uberMaterial
ˇˇ 
.
ˇˇ 
SetFloat
ˇˇ !
(
ˇˇ! "
ShaderConstants
ˇˇ" 1
.
ˇˇ1 2!
_LensDirt_Intensity
ˇˇ2 E
,
ˇˇE F
dirtIntensity
ˇˇG T
)
ˇˇT U
;
ˇˇU V
uberMaterial
ÄÄ 
.
ÄÄ 

SetTexture
ÄÄ #
(
ÄÄ# $
ShaderConstants
ÄÄ$ 3
.
ÄÄ3 4
_LensDirt_Texture
ÄÄ4 E
,
ÄÄE F
dirtTexture
ÄÄG R
)
ÄÄR S
;
ÄÄS T
if
ÉÉ 
(
ÉÉ 
m_Bloom
ÉÉ 
.
ÉÉ "
highQualityFiltering
ÉÉ ,
.
ÉÉ, -
value
ÉÉ- 2
)
ÉÉ2 3
uberMaterial
ÑÑ 
.
ÑÑ 
EnableKeyword
ÑÑ *
(
ÑÑ* +
dirtIntensity
ÑÑ+ 8
>
ÑÑ9 :
$num
ÑÑ; =
?
ÑÑ> ?"
ShaderKeywordStrings
ÑÑ@ T
.
ÑÑT U
BloomHQDirt
ÑÑU `
:
ÑÑa b"
ShaderKeywordStrings
ÑÑc w
.
ÑÑw x
BloomHQ
ÑÑx 
)ÑÑ Ä
;ÑÑÄ Å
else
ÖÖ 
uberMaterial
ÜÜ 
.
ÜÜ 
EnableKeyword
ÜÜ *
(
ÜÜ* +
dirtIntensity
ÜÜ+ 8
>
ÜÜ9 :
$num
ÜÜ; =
?
ÜÜ> ?"
ShaderKeywordStrings
ÜÜ@ T
.
ÜÜT U
BloomLQDirt
ÜÜU `
:
ÜÜa b"
ShaderKeywordStrings
ÜÜc w
.
ÜÜw x
BloomLQ
ÜÜx 
)ÜÜ Ä
;ÜÜÄ Å
}
áá 	
void
çç !
SetupLensDistortion
çç  
(
çç  !
Material
çç! )
material
çç* 2
,
çç2 3
bool
çç4 8
isSceneView
çç9 D
)
ççD E
{
éé 	
float
èè 
amount
èè 
=
èè 
$num
èè 
*
èè  !
Mathf
èè" '
.
èè' (
Max
èè( +
(
èè+ ,
Mathf
èè, 1
.
èè1 2
Abs
èè2 5
(
èè5 6
m_LensDistortion
èè6 F
.
èèF G
	intensity
èèG P
.
èèP Q
value
èèQ V
*
èèW X
$num
èèY ]
)
èè] ^
,
èè^ _
$num
èè` b
)
èèb c
;
èèc d
float
êê 
theta
êê 
=
êê 
Mathf
êê 
.
êê  
Deg2Rad
êê  '
*
êê( )
Mathf
êê* /
.
êê/ 0
Min
êê0 3
(
êê3 4
$num
êê4 8
,
êê8 9
amount
êê: @
)
êê@ A
;
êêA B
float
ëë 
sigma
ëë 
=
ëë 
$num
ëë 
*
ëë 
Mathf
ëë $
.
ëë$ %
Tan
ëë% (
(
ëë( )
theta
ëë) .
*
ëë/ 0
$num
ëë1 5
)
ëë5 6
;
ëë6 7
var
íí 
center
íí 
=
íí 
m_LensDistortion
íí )
.
íí) *
center
íí* 0
.
íí0 1
value
íí1 6
*
íí7 8
$num
íí9 ;
-
íí< =
Vector2
íí> E
.
ííE F
one
ííF I
;
ííI J
var
ìì 
p1
ìì 
=
ìì 
new
ìì 
Vector4
ìì  
(
ìì  !
center
îî 
.
îî 
x
îî 
,
îî 
center
ïï 
.
ïï 
y
ïï 
,
ïï 
Mathf
ññ 
.
ññ 
Max
ññ 
(
ññ 
m_LensDistortion
ññ *
.
ññ* +
xMultiplier
ññ+ 6
.
ññ6 7
value
ññ7 <
,
ññ< =
$num
ññ> C
)
ññC D
,
ññD E
Mathf
óó 
.
óó 
Max
óó 
(
óó 
m_LensDistortion
óó *
.
óó* +
yMultiplier
óó+ 6
.
óó6 7
value
óó7 <
,
óó< =
$num
óó> C
)
óóC D
)
òò 
;
òò 
var
ôô 
p2
ôô 
=
ôô 
new
ôô 
Vector4
ôô  
(
ôô  !
m_LensDistortion
öö  
.
öö  !
	intensity
öö! *
.
öö* +
value
öö+ 0
>=
öö1 3
$num
öö4 6
?
öö7 8
theta
öö9 >
:
öö? @
$num
ööA C
/
ööD E
theta
ööF K
,
ööK L
sigma
õõ 
,
õõ 
$num
úú 
/
úú 
m_LensDistortion
úú %
.
úú% &
scale
úú& +
.
úú+ ,
value
úú, 1
,
úú1 2
m_LensDistortion
ùù  
.
ùù  !
	intensity
ùù! *
.
ùù* +
value
ùù+ 0
*
ùù1 2
$num
ùù3 7
)
ûû 
;
ûû 
material
†† 
.
†† 
	SetVector
†† 
(
†† 
ShaderConstants
†† .
.
††. /!
_Distortion_Params1
††/ B
,
††B C
p1
††D F
)
††F G
;
††G H
material
°° 
.
°° 
	SetVector
°° 
(
°° 
ShaderConstants
°° .
.
°°. /!
_Distortion_Params2
°°/ B
,
°°B C
p2
°°D F
)
°°F G
;
°°G H
if
££ 
(
££ 
m_LensDistortion
££  
.
££  !
IsActive
££! )
(
££) *
)
££* +
&&
££, .
!
££/ 0
isSceneView
££0 ;
)
££; <
material
§§ 
.
§§ 
EnableKeyword
§§ &
(
§§& '"
ShaderKeywordStrings
§§' ;
.
§§; <

Distortion
§§< F
)
§§F G
;
§§G H
}
•• 	
void
´´ &
SetupChromaticAberration
´´ %
(
´´% &
Material
´´& .
material
´´/ 7
)
´´7 8
{
¨¨ 	
material
≠≠ 
.
≠≠ 
SetFloat
≠≠ 
(
≠≠ 
ShaderConstants
≠≠ -
.
≠≠- .
_Chroma_Params
≠≠. <
,
≠≠< =#
m_ChromaticAberration
≠≠> S
.
≠≠S T
	intensity
≠≠T ]
.
≠≠] ^
value
≠≠^ c
*
≠≠d e
$num
≠≠f k
)
≠≠k l
;
≠≠l m
if
ØØ 
(
ØØ #
m_ChromaticAberration
ØØ %
.
ØØ% &
IsActive
ØØ& .
(
ØØ. /
)
ØØ/ 0
)
ØØ0 1
material
∞∞ 
.
∞∞ 
EnableKeyword
∞∞ &
(
∞∞& '"
ShaderKeywordStrings
∞∞' ;
.
∞∞; <!
ChromaticAberration
∞∞< O
)
∞∞O P
;
∞∞P Q
}
±± 	
void
∑∑ 
SetupVignette
∑∑ 
(
∑∑ 
Material
∑∑ #
material
∑∑$ ,
)
∑∑, -
{
∏∏ 	
var
ππ 
color
ππ 
=
ππ 

m_Vignette
ππ "
.
ππ" #
color
ππ# (
.
ππ( )
value
ππ) .
;
ππ. /
var
∫∫ 
center
∫∫ 
=
∫∫ 

m_Vignette
∫∫ #
.
∫∫# $
center
∫∫$ *
.
∫∫* +
value
∫∫+ 0
;
∫∫0 1
var
ªª 
aspectRatio
ªª 
=
ªª 
m_Descriptor
ªª *
.
ªª* +
width
ªª+ 0
/
ªª1 2
(
ªª3 4
float
ªª4 9
)
ªª9 :
m_Descriptor
ªª: F
.
ªªF G
height
ªªG M
;
ªªM N
var
ΩΩ 
v1
ΩΩ 
=
ΩΩ 
new
ΩΩ 
Vector4
ΩΩ  
(
ΩΩ  !
color
ææ 
.
ææ 
r
ææ 
,
ææ 
color
ææ 
.
ææ 
g
ææ  
,
ææ  !
color
ææ" '
.
ææ' (
b
ææ( )
,
ææ) *

m_Vignette
øø 
.
øø 
rounded
øø "
.
øø" #
value
øø# (
?
øø) *
aspectRatio
øø+ 6
:
øø7 8
$num
øø9 ;
)
¿¿ 
;
¿¿ 
var
¡¡ 
v2
¡¡ 
=
¡¡ 
new
¡¡ 
Vector4
¡¡  
(
¡¡  !
center
¬¬ 
.
¬¬ 
x
¬¬ 
,
¬¬ 
center
¬¬  
.
¬¬  !
y
¬¬! "
,
¬¬" #

m_Vignette
√√ 
.
√√ 
	intensity
√√ $
.
√√$ %
value
√√% *
*
√√+ ,
$num
√√- /
,
√√/ 0

m_Vignette
ƒƒ 
.
ƒƒ 

smoothness
ƒƒ %
.
ƒƒ% &
value
ƒƒ& +
*
ƒƒ, -
$num
ƒƒ. 0
)
≈≈ 
;
≈≈ 
material
«« 
.
«« 
	SetVector
«« 
(
«« 
ShaderConstants
«« .
.
««. /
_Vignette_Params1
««/ @
,
««@ A
v1
««B D
)
««D E
;
««E F
material
»» 
.
»» 
	SetVector
»» 
(
»» 
ShaderConstants
»» .
.
»». /
_Vignette_Params2
»»/ @
,
»»@ A
v2
»»B D
)
»»D E
;
»»E F
}
…… 	
void
œœ 
SetupColorGrading
œœ 
(
œœ 
CommandBuffer
œœ ,
cmd
œœ- 0
,
œœ0 1
ref
œœ2 5
RenderingData
œœ6 C
renderingData
œœD Q
,
œœQ R
Material
œœS [
material
œœ\ d
)
œœd e
{
–– 	
ref
—— 
var
——  
postProcessingData
—— &
=
——' (
ref
——) ,
renderingData
——- :
.
——: ; 
postProcessingData
——; M
;
——M N
bool
““ 
hdr
““ 
=
““  
postProcessingData
““ )
.
““) *
gradingMode
““* 5
==
““6 8
ColorGradingMode
““9 I
.
““I J
HighDynamicRange
““J Z
;
““Z [
int
”” 
	lutHeight
”” 
=
””  
postProcessingData
”” .
.
””. /
lutSize
””/ 6
;
””6 7
int
‘‘ 
lutWidth
‘‘ 
=
‘‘ 
	lutHeight
‘‘ $
*
‘‘% &
	lutHeight
‘‘' 0
;
‘‘0 1
float
◊◊  
postExposureLinear
◊◊ $
=
◊◊% &
Mathf
◊◊' ,
.
◊◊, -
Pow
◊◊- 0
(
◊◊0 1
$num
◊◊1 3
,
◊◊3 4 
m_ColorAdjustments
◊◊5 G
.
◊◊G H
postExposure
◊◊H T
.
◊◊T U
value
◊◊U Z
)
◊◊Z [
;
◊◊[ \
cmd
ÿÿ 
.
ÿÿ 
SetGlobalTexture
ÿÿ  
(
ÿÿ  !
ShaderConstants
ÿÿ! 0
.
ÿÿ0 1
_InternalLut
ÿÿ1 =
,
ÿÿ= >
m_InternalLut
ÿÿ? L
.
ÿÿL M

Identifier
ÿÿM W
(
ÿÿW X
)
ÿÿX Y
)
ÿÿY Z
;
ÿÿZ [
material
ŸŸ 
.
ŸŸ 
	SetVector
ŸŸ 
(
ŸŸ 
ShaderConstants
ŸŸ .
.
ŸŸ. /
_Lut_Params
ŸŸ/ :
,
ŸŸ: ;
new
ŸŸ< ?
Vector4
ŸŸ@ G
(
ŸŸG H
$num
ŸŸH J
/
ŸŸK L
lutWidth
ŸŸM U
,
ŸŸU V
$num
ŸŸW Y
/
ŸŸZ [
	lutHeight
ŸŸ\ e
,
ŸŸe f
	lutHeight
ŸŸg p
-
ŸŸq r
$num
ŸŸs u
,
ŸŸu v!
postExposureLinearŸŸw â
)ŸŸâ ä
)ŸŸä ã
;ŸŸã å
material
⁄⁄ 
.
⁄⁄ 

SetTexture
⁄⁄ 
(
⁄⁄  
ShaderConstants
⁄⁄  /
.
⁄⁄/ 0
_UserLut
⁄⁄0 8
,
⁄⁄8 9
m_ColorLookup
⁄⁄: G
.
⁄⁄G H
texture
⁄⁄H O
.
⁄⁄O P
value
⁄⁄P U
)
⁄⁄U V
;
⁄⁄V W
material
€€ 
.
€€ 
	SetVector
€€ 
(
€€ 
ShaderConstants
€€ .
.
€€. /
_UserLut_Params
€€/ >
,
€€> ?
!
€€@ A
m_ColorLookup
€€A N
.
€€N O
IsActive
€€O W
(
€€W X
)
€€X Y
?
‹‹ 
Vector4
‹‹ 
.
‹‹ 
zero
‹‹ 
:
›› 
new
›› 
Vector4
›› 
(
›› 
$num
››  
/
››! "
m_ColorLookup
››# 0
.
››0 1
texture
››1 8
.
››8 9
value
››9 >
.
››> ?
width
››? D
,
››D E
$num
ﬁﬁ  
/
ﬁﬁ! "
m_ColorLookup
ﬁﬁ# 0
.
ﬁﬁ0 1
texture
ﬁﬁ1 8
.
ﬁﬁ8 9
value
ﬁﬁ9 >
.
ﬁﬁ> ?
height
ﬁﬁ? E
,
ﬁﬁE F
m_ColorLookup
ﬂﬂ +
.
ﬂﬂ+ ,
texture
ﬂﬂ, 3
.
ﬂﬂ3 4
value
ﬂﬂ4 9
.
ﬂﬂ9 :
height
ﬂﬂ: @
-
ﬂﬂA B
$num
ﬂﬂC E
,
ﬂﬂE F
m_ColorLookup
‡‡ +
.
‡‡+ ,
contribution
‡‡, 8
.
‡‡8 9
value
‡‡9 >
)
‡‡> ?
)
·· 
;
·· 
if
„„ 
(
„„ 
hdr
„„ 
)
„„ 
{
‰‰ 
material
ÂÂ 
.
ÂÂ 
EnableKeyword
ÂÂ &
(
ÂÂ& '"
ShaderKeywordStrings
ÂÂ' ;
.
ÂÂ; <

HDRGrading
ÂÂ< F
)
ÂÂF G
;
ÂÂG H
}
ÊÊ 
else
ÁÁ 
{
ËË 
switch
ÈÈ 
(
ÈÈ 
m_Tonemapping
ÈÈ %
.
ÈÈ% &
mode
ÈÈ& *
.
ÈÈ* +
value
ÈÈ+ 0
)
ÈÈ0 1
{
ÍÍ 
case
ÎÎ 
TonemappingMode
ÎÎ (
.
ÎÎ( )
Neutral
ÎÎ) 0
:
ÎÎ0 1
material
ÎÎ2 :
.
ÎÎ: ;
EnableKeyword
ÎÎ; H
(
ÎÎH I"
ShaderKeywordStrings
ÎÎI ]
.
ÎÎ] ^
TonemapNeutral
ÎÎ^ l
)
ÎÎl m
;
ÎÎm n
break
ÎÎo t
;
ÎÎt u
case
ÏÏ 
TonemappingMode
ÏÏ (
.
ÏÏ( )
ACES
ÏÏ) -
:
ÏÏ- .
material
ÏÏ/ 7
.
ÏÏ7 8
EnableKeyword
ÏÏ8 E
(
ÏÏE F"
ShaderKeywordStrings
ÏÏF Z
.
ÏÏZ [
TonemapACES
ÏÏ[ f
)
ÏÏf g
;
ÏÏg h
break
ÏÏi n
;
ÏÏn o
default
ÌÌ 
:
ÌÌ 
break
ÌÌ "
;
ÌÌ" #
}
ÓÓ 
}
ÔÔ 
}
 	
void
ˆˆ 

SetupGrain
ˆˆ 
(
ˆˆ 
in
ˆˆ 

CameraData
ˆˆ %

cameraData
ˆˆ& 0
,
ˆˆ0 1
Material
ˆˆ2 :
material
ˆˆ; C
)
ˆˆC D
{
˜˜ 	
if
¯¯ 
(
¯¯ 
!
¯¯ 
m_HasFinalPass
¯¯ 
&&
¯¯  "
m_FilmGrain
¯¯# .
.
¯¯. /
IsActive
¯¯/ 7
(
¯¯7 8
)
¯¯8 9
)
¯¯9 :
{
˘˘ 
material
˙˙ 
.
˙˙ 
EnableKeyword
˙˙ &
(
˙˙& '"
ShaderKeywordStrings
˙˙' ;
.
˙˙; <
	FilmGrain
˙˙< E
)
˙˙E F
;
˙˙F G
PostProcessUtils
˚˚  
.
˚˚  ! 
ConfigureFilmGrain
˚˚! 3
(
˚˚3 4
m_Data
¸¸ 
,
¸¸ 
m_FilmGrain
˝˝ 
,
˝˝  

cameraData
˛˛ 
.
˛˛ 

pixelWidth
˛˛ )
,
˛˛) *

cameraData
˛˛+ 5
.
˛˛5 6
pixelHeight
˛˛6 A
,
˛˛A B
material
ˇˇ 
)
Ä	Ä	 
;
Ä	Ä	 
}
Å	Å	 
}
Ç	Ç	 	
void
à	à	 
SetupDithering
à	à	 
(
à	à	 
in
à	à	 

CameraData
à	à	 )

cameraData
à	à	* 4
,
à	à	4 5
Material
à	à	6 >
material
à	à	? G
)
à	à	G H
{
â	â	 	
if
ä	ä	 
(
ä	ä	 
!
ä	ä	 
m_HasFinalPass
ä	ä	 
&&
ä	ä	  "

cameraData
ä	ä	# -
.
ä	ä	- . 
isDitheringEnabled
ä	ä	. @
)
ä	ä	@ A
{
ã	ã	 
material
å	å	 
.
å	å	 
EnableKeyword
å	å	 &
(
å	å	& '"
ShaderKeywordStrings
å	å	' ;
.
å	å	; <
	Dithering
å	å	< E
)
å	å	E F
;
å	å	F G%
m_DitheringTextureIndex
ç	ç	 '
=
ç	ç	( )
PostProcessUtils
ç	ç	* :
.
ç	ç	: ; 
ConfigureDithering
ç	ç	; M
(
ç	ç	M N
m_Data
é	é	 
,
é	é	 %
m_DitheringTextureIndex
è	è	 +
,
è	è	+ ,

cameraData
ê	ê	 
.
ê	ê	 

pixelWidth
ê	ê	 )
,
ê	ê	) *

cameraData
ê	ê	+ 5
.
ê	ê	5 6
pixelHeight
ê	ê	6 A
,
ê	ê	A B
material
ë	ë	 
)
í	í	 
;
í	í	 
}
ì	ì	 
}
î	î	 	
void
ö	ö	 
RenderFinalPass
ö	ö	 
(
ö	ö	 
CommandBuffer
ö	ö	 *
cmd
ö	ö	+ .
,
ö	ö	. /
ref
ö	ö	0 3
RenderingData
ö	ö	4 A
renderingData
ö	ö	B O
)
ö	ö	O P
{
õ	õ	 	
ref
ú	ú	 
var
ú	ú	 

cameraData
ú	ú	 
=
ú	ú	  
ref
ú	ú	! $
renderingData
ú	ú	% 2
.
ú	ú	2 3

cameraData
ú	ú	3 =
;
ú	ú	= >
var
ù	ù	 
material
ù	ù	 
=
ù	ù	 
m_Materials
ù	ù	 &
.
ù	ù	& '
	finalPass
ù	ù	' 0
;
ù	ù	0 1
material
û	û	 
.
û	û	 
shaderKeywords
û	û	 #
=
û	û	$ %
null
û	û	& *
;
û	û	* +
if
°	°	 
(
°	°	 

cameraData
°	°	 
.
°	°	 
antialiasing
°	°	 '
==
°	°	( *
AntialiasingMode
°	°	+ ;
.
°	°	; <)
FastApproximateAntialiasing
°	°	< W
)
°	°	W X
material
¢	¢	 
.
¢	¢	 
EnableKeyword
¢	¢	 &
(
¢	¢	& '"
ShaderKeywordStrings
¢	¢	' ;
.
¢	¢	; <
Fxaa
¢	¢	< @
)
¢	¢	@ A
;
¢	¢	A B
PostProcessUtils
§	§	 
.
§	§	 
SetSourceSize
§	§	 *
(
§	§	* +
cmd
§	§	+ .
,
§	§	. /

cameraData
§	§	0 :
.
§	§	: ;$
cameraTargetDescriptor
§	§	; Q
)
§	§	Q R
;
§	§	R S

SetupGrain
¶	¶	 
(
¶	¶	 

cameraData
¶	¶	 !
,
¶	¶	! "
material
¶	¶	# +
)
¶	¶	+ ,
;
¶	¶	, -
SetupDithering
ß	ß	 
(
ß	ß	 

cameraData
ß	ß	 %
,
ß	ß	% &
material
ß	ß	' /
)
ß	ß	/ 0
;
ß	ß	0 1
if
©	©	 
(
©	©	 3
%RequireSRGBConversionBlitToBackBuffer
©	©	 5
(
©	©	5 6

cameraData
©	©	6 @
)
©	©	@ A
)
©	©	A B
material
™	™	 
.
™	™	 
EnableKeyword
™	™	 &
(
™	™	& '"
ShaderKeywordStrings
™	™	' ;
.
™	™	; <$
LinearToSRGBConversion
™	™	< R
)
™	™	R S
;
™	™	S T
cmd
¨	¨	 
.
¨	¨	 
SetGlobalTexture
¨	¨	  
(
¨	¨	  !
ShaderPropertyId
¨	¨	! 1
.
¨	¨	1 2
	sourceTex
¨	¨	2 ;
,
¨	¨	; <
m_Source
¨	¨	= E
.
¨	¨	E F

Identifier
¨	¨	F P
(
¨	¨	P Q
)
¨	¨	Q R
)
¨	¨	R S
;
¨	¨	S T
var
Æ	Æ	 
colorLoadAction
Æ	Æ	 
=
Æ	Æ	  !

cameraData
Æ	Æ	" ,
.
Æ	Æ	, -
isDefaultViewport
Æ	Æ	- >
?
Æ	Æ	? @$
RenderBufferLoadAction
Æ	Æ	A W
.
Æ	Æ	W X
DontCare
Æ	Æ	X `
:
Æ	Æ	a b$
RenderBufferLoadAction
Æ	Æ	c y
.
Æ	Æ	y z
Load
Æ	Æ	z ~
;
Æ	Æ	~  
RenderTargetHandle
∞	∞	  
cameraTargetHandle
∞	∞	 1
=
∞	∞	2 3 
RenderTargetHandle
∞	∞	4 F
.
∞	∞	F G
GetCameraTarget
∞	∞	G V
(
∞	∞	V W

cameraData
∞	∞	W a
.
∞	∞	a b
xr
∞	∞	b d
)
∞	∞	d e
;
∞	∞	e f
if
≥	≥	 
(
≥	≥	 

cameraData
≥	≥	 
.
≥	≥	 
xr
≥	≥	 
.
≥	≥	 
enabled
≥	≥	 %
)
≥	≥	% &
{
¥	¥	 $
RenderTargetIdentifier
µ	µ	 &
cameraTarget
µ	µ	' 3
=
µ	µ	4 5 
cameraTargetHandle
µ	µ	6 H
.
µ	µ	H I

Identifier
µ	µ	I S
(
µ	µ	S T
)
µ	µ	T U
;
µ	µ	U V
bool
∏	∏	 (
isRenderToBackBufferTarget
∏	∏	 /
=
∏	∏	0 1
cameraTarget
∏	∏	2 >
==
∏	∏	? A

cameraData
∏	∏	B L
.
∏	∏	L M
xr
∏	∏	M O
.
∏	∏	O P
renderTarget
∏	∏	P \
&&
∏	∏	] _
!
∏	∏	` a

cameraData
∏	∏	a k
.
∏	∏	k l
xr
∏	∏	l n
.
∏	∏	n o*
renderTargetIsRenderTexture∏	∏	o ä
;∏	∏	ä ã
bool
º	º	 
yflip
º	º	 
=
º	º	 (
isRenderToBackBufferTarget
º	º	 7
&&
º	º	8 :

SystemInfo
º	º	; E
.
º	º	E F#
graphicsUVStartsAtTop
º	º	F [
;
º	º	[ \
Vector4
æ	æ	 
	scaleBias
æ	æ	 !
=
æ	æ	" #
yflip
æ	æ	$ )
?
æ	æ	* +
new
æ	æ	, /
Vector4
æ	æ	0 7
(
æ	æ	7 8
$num
æ	æ	8 9
,
æ	æ	9 :
-
æ	æ	; <
$num
æ	æ	< =
,
æ	æ	= >
$num
æ	æ	? @
,
æ	æ	@ A
$num
æ	æ	B C
)
æ	æ	C D
:
æ	æ	E F
new
æ	æ	G J
Vector4
æ	æ	K R
(
æ	æ	R S
$num
æ	æ	S T
,
æ	æ	T U
$num
æ	æ	V W
,
æ	æ	W X
$num
æ	æ	Y Z
,
æ	æ	Z [
$num
æ	æ	\ ]
)
æ	æ	] ^
;
æ	æ	^ _
cmd
¿	¿	 
.
¿	¿	 
SetRenderTarget
¿	¿	 #
(
¿	¿	# $
new
¿	¿	$ '$
RenderTargetIdentifier
¿	¿	( >
(
¿	¿	> ?
cameraTarget
¿	¿	? K
,
¿	¿	K L
$num
¿	¿	M N
,
¿	¿	N O
CubemapFace
¿	¿	P [
.
¿	¿	[ \
Unknown
¿	¿	\ c
,
¿	¿	c d
-
¿	¿	e f
$num
¿	¿	f g
)
¿	¿	g h
,
¿	¿	h i
colorLoadAction
¡	¡	 #
,
¡	¡	# $%
RenderBufferStoreAction
¡	¡	% <
.
¡	¡	< =
Store
¡	¡	= B
,
¡	¡	B C$
RenderBufferLoadAction
¡	¡	D Z
.
¡	¡	Z [
DontCare
¡	¡	[ c
,
¡	¡	c d%
RenderBufferStoreAction
¡	¡	e |
.
¡	¡	| }
DontCare¡	¡	} Ö
)¡	¡	Ö Ü
;¡	¡	Ü á
cmd
¬	¬	 
.
¬	¬	 
SetViewport
¬	¬	 
(
¬	¬	  

cameraData
¬	¬	  *
.
¬	¬	* +
	pixelRect
¬	¬	+ 4
)
¬	¬	4 5
;
¬	¬	5 6
cmd
√	√	 
.
√	√	 
SetGlobalVector
√	√	 #
(
√	√	# $
ShaderPropertyId
√	√	$ 4
.
√	√	4 5
	scaleBias
√	√	5 >
,
√	√	> ?
	scaleBias
√	√	@ I
)
√	√	I J
;
√	√	J K
cmd
ƒ	ƒ	 
.
ƒ	ƒ	 
DrawProcedural
ƒ	ƒ	 "
(
ƒ	ƒ	" #
	Matrix4x4
ƒ	ƒ	# ,
.
ƒ	ƒ	, -
identity
ƒ	ƒ	- 5
,
ƒ	ƒ	5 6
material
ƒ	ƒ	7 ?
,
ƒ	ƒ	? @
$num
ƒ	ƒ	A B
,
ƒ	ƒ	B C
MeshTopology
ƒ	ƒ	D P
.
ƒ	ƒ	P Q
Quads
ƒ	ƒ	Q V
,
ƒ	ƒ	V W
$num
ƒ	ƒ	X Y
,
ƒ	ƒ	Y Z
$num
ƒ	ƒ	[ \
,
ƒ	ƒ	\ ]
null
ƒ	ƒ	^ b
)
ƒ	ƒ	b c
;
ƒ	ƒ	c d
}
≈	≈	 
else
∆	∆	 
{
»	»	 $
RenderTargetIdentifier
À	À	 &
cameraTarget
À	À	' 3
=
À	À	4 5
(
À	À	6 7

cameraData
À	À	7 A
.
À	À	A B
targetTexture
À	À	B O
!=
À	À	P R
null
À	À	S W
)
À	À	W X
?
À	À	Y Z
new
À	À	[ ^$
RenderTargetIdentifier
À	À	_ u
(
À	À	u v

cameraDataÀ	À	v Ä
.À	À	Ä Å
targetTextureÀ	À	Å é
)À	À	é è
:À	À	ê ë"
cameraTargetHandleÀ	À	í §
.À	À	§ •

IdentifierÀ	À	• Ø
(À	À	Ø ∞
)À	À	∞ ±
;À	À	± ≤
cmd
Õ	Õ	 
.
Õ	Õ	 
SetRenderTarget
Õ	Õ	 #
(
Õ	Õ	# $
cameraTarget
Õ	Õ	$ 0
,
Õ	Õ	0 1
colorLoadAction
Õ	Õ	2 A
,
Õ	Õ	A B%
RenderBufferStoreAction
Õ	Õ	C Z
.
Õ	Õ	Z [
Store
Õ	Õ	[ `
,
Õ	Õ	` a$
RenderBufferLoadAction
Õ	Õ	b x
.
Õ	Õ	x y
DontCareÕ	Õ	y Å
,Õ	Õ	Å Ç'
RenderBufferStoreActionÕ	Õ	É ö
.Õ	Õ	ö õ
DontCareÕ	Õ	õ £
)Õ	Õ	£ §
;Õ	Õ	§ •
cmd
Œ	Œ	 
.
Œ	Œ	 '
SetViewProjectionMatrices
Œ	Œ	 -
(
Œ	Œ	- .
	Matrix4x4
Œ	Œ	. 7
.
Œ	Œ	7 8
identity
Œ	Œ	8 @
,
Œ	Œ	@ A
	Matrix4x4
Œ	Œ	B K
.
Œ	Œ	K L
identity
Œ	Œ	L T
)
Œ	Œ	T U
;
Œ	Œ	U V
cmd
œ	œ	 
.
œ	œ	 
SetViewport
œ	œ	 
(
œ	œ	  

cameraData
œ	œ	  *
.
œ	œ	* +
	pixelRect
œ	œ	+ 4
)
œ	œ	4 5
;
œ	œ	5 6
cmd
–	–	 
.
–	–	 
DrawMesh
–	–	 
(
–	–	 
RenderingUtils
–	–	 +
.
–	–	+ ,
fullscreenMesh
–	–	, :
,
–	–	: ;
	Matrix4x4
–	–	< E
.
–	–	E F
identity
–	–	F N
,
–	–	N O
material
–	–	P X
)
–	–	X Y
;
–	–	Y Z
cmd
—	—	 
.
—	—	 '
SetViewProjectionMatrices
—	—	 -
(
—	—	- .

cameraData
—	—	. 8
.
—	—	8 9
camera
—	—	9 ?
.
—	—	? @!
worldToCameraMatrix
—	—	@ S
,
—	—	S T

cameraData
—	—	U _
.
—	—	_ `
camera
—	—	` f
.
—	—	f g
projectionMatrix
—	—	g w
)
—	—	w x
;
—	—	x y
}
“	“	 
}
”	”	 	
class
Ÿ	Ÿ	 
MaterialLibrary
Ÿ	Ÿ	 
{
⁄	⁄	 	
public
€	€	 
readonly
€	€	 
Material
€	€	 $
stopNaN
€	€	% ,
;
€	€	, -
public
‹	‹	 
readonly
‹	‹	 
Material
‹	‹	 $/
!subpixelMorphologicalAntialiasing
‹	‹	% F
;
‹	‹	F G
public
›	›	 
readonly
›	›	 
Material
›	›	 $"
gaussianDepthOfField
›	›	% 9
;
›	›	9 :
public
ﬁ	ﬁ	 
readonly
ﬁ	ﬁ	 
Material
ﬁ	ﬁ	 $
bokehDepthOfField
ﬁ	ﬁ	% 6
;
ﬁ	ﬁ	6 7
public
ﬂ	ﬂ	 
readonly
ﬂ	ﬂ	 
Material
ﬂ	ﬂ	 $
cameraMotionBlur
ﬂ	ﬂ	% 5
;
ﬂ	ﬂ	5 6
public
‡	‡	 
readonly
‡	‡	 
Material
‡	‡	 $
paniniProjection
‡	‡	% 5
;
‡	‡	5 6
public
·	·	 
readonly
·	·	 
Material
·	·	 $
bloom
·	·	% *
;
·	·	* +
public
‚	‚	 
readonly
‚	‚	 
Material
‚	‚	 $
uber
‚	‚	% )
;
‚	‚	) *
public
„	„	 
readonly
„	„	 
Material
„	„	 $
	finalPass
„	„	% .
;
„	„	. /
public
Â	Â	 
MaterialLibrary
Â	Â	 "
(
Â	Â	" #
PostProcessData
Â	Â	# 2
data
Â	Â	3 7
)
Â	Â	7 8
{
Ê	Ê	 
stopNaN
Á	Á	 
=
Á	Á	 
Load
Á	Á	 
(
Á	Á	 
data
Á	Á	 #
.
Á	Á	# $
shaders
Á	Á	$ +
.
Á	Á	+ ,
	stopNanPS
Á	Á	, 5
)
Á	Á	5 6
;
Á	Á	6 7/
!subpixelMorphologicalAntialiasing
Ë	Ë	 1
=
Ë	Ë	2 3
Load
Ë	Ë	4 8
(
Ë	Ë	8 9
data
Ë	Ë	9 =
.
Ë	Ë	= >
shaders
Ë	Ë	> E
.
Ë	Ë	E F1
#subpixelMorphologicalAntialiasingPS
Ë	Ë	F i
)
Ë	Ë	i j
;
Ë	Ë	j k"
gaussianDepthOfField
È	È	 $
=
È	È	% &
Load
È	È	' +
(
È	È	+ ,
data
È	È	, 0
.
È	È	0 1
shaders
È	È	1 8
.
È	È	8 9$
gaussianDepthOfFieldPS
È	È	9 O
)
È	È	O P
;
È	È	P Q
bokehDepthOfField
Í	Í	 !
=
Í	Í	" #
Load
Í	Í	$ (
(
Í	Í	( )
data
Í	Í	) -
.
Í	Í	- .
shaders
Í	Í	. 5
.
Í	Í	5 6!
bokehDepthOfFieldPS
Í	Í	6 I
)
Í	Í	I J
;
Í	Í	J K
cameraMotionBlur
Î	Î	  
=
Î	Î	! "
Load
Î	Î	# '
(
Î	Î	' (
data
Î	Î	( ,
.
Î	Î	, -
shaders
Î	Î	- 4
.
Î	Î	4 5 
cameraMotionBlurPS
Î	Î	5 G
)
Î	Î	G H
;
Î	Î	H I
paniniProjection
Ï	Ï	  
=
Ï	Ï	! "
Load
Ï	Ï	# '
(
Ï	Ï	' (
data
Ï	Ï	( ,
.
Ï	Ï	, -
shaders
Ï	Ï	- 4
.
Ï	Ï	4 5 
paniniProjectionPS
Ï	Ï	5 G
)
Ï	Ï	G H
;
Ï	Ï	H I
bloom
Ì	Ì	 
=
Ì	Ì	 
Load
Ì	Ì	 
(
Ì	Ì	 
data
Ì	Ì	 !
.
Ì	Ì	! "
shaders
Ì	Ì	" )
.
Ì	Ì	) *
bloomPS
Ì	Ì	* 1
)
Ì	Ì	1 2
;
Ì	Ì	2 3
uber
Ó	Ó	 
=
Ó	Ó	 
Load
Ó	Ó	 
(
Ó	Ó	 
data
Ó	Ó	  
.
Ó	Ó	  !
shaders
Ó	Ó	! (
.
Ó	Ó	( )

uberPostPS
Ó	Ó	) 3
)
Ó	Ó	3 4
;
Ó	Ó	4 5
	finalPass
Ô	Ô	 
=
Ô	Ô	 
Load
Ô	Ô	  
(
Ô	Ô	  !
data
Ô	Ô	! %
.
Ô	Ô	% &
shaders
Ô	Ô	& -
.
Ô	Ô	- .
finalPostPassPS
Ô	Ô	. =
)
Ô	Ô	= >
;
Ô	Ô	> ?
}
		 
Material
Ú	Ú	 
Load
Ú	Ú	 
(
Ú	Ú	 
Shader
Ú	Ú	  
shader
Ú	Ú	! '
)
Ú	Ú	' (
{
Û	Û	 
if
Ù	Ù	 
(
Ù	Ù	 
shader
Ù	Ù	 
==
Ù	Ù	 
null
Ù	Ù	 "
)
Ù	Ù	" #
{
ı	ı	 
Debug
ˆ	ˆ	 
.
ˆ	ˆ	 
LogErrorFormat
ˆ	ˆ	 (
(
ˆ	ˆ	( )
$"
ˆ	ˆ	) +
Missing shader. 
ˆ	ˆ	+ ;
{
ˆ	ˆ	; <
GetType
ˆ	ˆ	< C
(
ˆ	ˆ	C D
)
ˆ	ˆ	D E
.
ˆ	ˆ	E F
DeclaringType
ˆ	ˆ	F S
.
ˆ	ˆ	S T
Name
ˆ	ˆ	T X
}
ˆ	ˆ	X Yd
U render pass will not execute. Check for missing reference in the renderer resources.ˆ	ˆ	Y Æ
"ˆ	ˆ	Æ Ø
)ˆ	ˆ	Ø ∞
;ˆ	ˆ	∞ ±
return
˜	˜	 
null
˜	˜	 
;
˜	˜	  
}
¯	¯	 
else
˘	˘	 
if
˘	˘	 
(
˘	˘	 
!
˘	˘	 
shader
˘	˘	  
.
˘	˘	  !
isSupported
˘	˘	! ,
)
˘	˘	, -
{
˙	˙	 
return
˚	˚	 
null
˚	˚	 
;
˚	˚	  
}
¸	¸	 
return
˛	˛	 
	CoreUtils
˛	˛	  
.
˛	˛	  !"
CreateEngineMaterial
˛	˛	! 5
(
˛	˛	5 6
shader
˛	˛	6 <
)
˛	˛	< =
;
˛	˛	= >
}
ˇ	ˇ	 
internal
Å
Å
 
void
Å
Å
 
Cleanup
Å
Å
 !
(
Å
Å
! "
)
Å
Å
" #
{
Ç
Ç
 
	CoreUtils
É
É
 
.
É
É
 
Destroy
É
É
 !
(
É
É
! "
stopNaN
É
É
" )
)
É
É
) *
;
É
É
* +
	CoreUtils
Ñ
Ñ
 
.
Ñ
Ñ
 
Destroy
Ñ
Ñ
 !
(
Ñ
Ñ
! "/
!subpixelMorphologicalAntialiasing
Ñ
Ñ
" C
)
Ñ
Ñ
C D
;
Ñ
Ñ
D E
	CoreUtils
Ö
Ö
 
.
Ö
Ö
 
Destroy
Ö
Ö
 !
(
Ö
Ö
! ""
gaussianDepthOfField
Ö
Ö
" 6
)
Ö
Ö
6 7
;
Ö
Ö
7 8
	CoreUtils
Ü
Ü
 
.
Ü
Ü
 
Destroy
Ü
Ü
 !
(
Ü
Ü
! "
bokehDepthOfField
Ü
Ü
" 3
)
Ü
Ü
3 4
;
Ü
Ü
4 5
	CoreUtils
á
á
 
.
á
á
 
Destroy
á
á
 !
(
á
á
! "
cameraMotionBlur
á
á
" 2
)
á
á
2 3
;
á
á
3 4
	CoreUtils
à
à
 
.
à
à
 
Destroy
à
à
 !
(
à
à
! "
paniniProjection
à
à
" 2
)
à
à
2 3
;
à
à
3 4
	CoreUtils
â
â
 
.
â
â
 
Destroy
â
â
 !
(
â
â
! "
bloom
â
â
" '
)
â
â
' (
;
â
â
( )
	CoreUtils
ä
ä
 
.
ä
ä
 
Destroy
ä
ä
 !
(
ä
ä
! "
uber
ä
ä
" &
)
ä
ä
& '
;
ä
ä
' (
	CoreUtils
ã
ã
 
.
ã
ã
 
Destroy
ã
ã
 !
(
ã
ã
! "
	finalPass
ã
ã
" +
)
ã
ã
+ ,
;
ã
ã
, -
}
å
å
 
}
ç
ç
 	
static
ê
ê
 
class
ê
ê
 
ShaderConstants
ê
ê
 $
{
ë
ë
 	
public
í
í
 
static
í
í
 
readonly
í
í
 "
int
í
í
# &
_TempTarget
í
í
' 2
=
í
í
; <
Shader
í
í
= C
.
í
í
C D
PropertyToID
í
í
D P
(
í
í
P Q
$str
í
í
Q ^
)
í
í
^ _
;
í
í
_ `
public
ì
ì
 
static
ì
ì
 
readonly
ì
ì
 "
int
ì
ì
# &
_TempTarget2
ì
ì
' 3
=
ì
ì
; <
Shader
ì
ì
= C
.
ì
ì
C D
PropertyToID
ì
ì
D P
(
ì
ì
P Q
$str
ì
ì
Q _
)
ì
ì
_ `
;
ì
ì
` a
public
ï
ï
 
static
ï
ï
 
readonly
ï
ï
 "
int
ï
ï
# &
_StencilRef
ï
ï
' 2
=
ï
ï
; <
Shader
ï
ï
= C
.
ï
ï
C D
PropertyToID
ï
ï
D P
(
ï
ï
P Q
$str
ï
ï
Q ^
)
ï
ï
^ _
;
ï
ï
_ `
public
ñ
ñ
 
static
ñ
ñ
 
readonly
ñ
ñ
 "
int
ñ
ñ
# &
_StencilMask
ñ
ñ
' 3
=
ñ
ñ
; <
Shader
ñ
ñ
= C
.
ñ
ñ
C D
PropertyToID
ñ
ñ
D P
(
ñ
ñ
P Q
$str
ñ
ñ
Q _
)
ñ
ñ
_ `
;
ñ
ñ
` a
public
ò
ò
 
static
ò
ò
 
readonly
ò
ò
 "
int
ò
ò
# &
_FullCoCTexture
ò
ò
' 6
=
ò
ò
; <
Shader
ò
ò
= C
.
ò
ò
C D
PropertyToID
ò
ò
D P
(
ò
ò
P Q
$str
ò
ò
Q b
)
ò
ò
b c
;
ò
ò
c d
public
ô
ô
 
static
ô
ô
 
readonly
ô
ô
 "
int
ô
ô
# &
_HalfCoCTexture
ô
ô
' 6
=
ô
ô
; <
Shader
ô
ô
= C
.
ô
ô
C D
PropertyToID
ô
ô
D P
(
ô
ô
P Q
$str
ô
ô
Q b
)
ô
ô
b c
;
ô
ô
c d
public
ö
ö
 
static
ö
ö
 
readonly
ö
ö
 "
int
ö
ö
# &
_DofTexture
ö
ö
' 2
=
ö
ö
; <
Shader
ö
ö
= C
.
ö
ö
C D
PropertyToID
ö
ö
D P
(
ö
ö
P Q
$str
ö
ö
Q ^
)
ö
ö
^ _
;
ö
ö
_ `
public
õ
õ
 
static
õ
õ
 
readonly
õ
õ
 "
int
õ
õ
# &

_CoCParams
õ
õ
' 1
=
õ
õ
; <
Shader
õ
õ
= C
.
õ
õ
C D
PropertyToID
õ
õ
D P
(
õ
õ
P Q
$str
õ
õ
Q ]
)
õ
õ
] ^
;
õ
õ
^ _
public
ú
ú
 
static
ú
ú
 
readonly
ú
ú
 "
int
ú
ú
# &
_BokehKernel
ú
ú
' 3
=
ú
ú
; <
Shader
ú
ú
= C
.
ú
ú
C D
PropertyToID
ú
ú
D P
(
ú
ú
P Q
$str
ú
ú
Q _
)
ú
ú
_ `
;
ú
ú
` a
public
ù
ù
 
static
ù
ù
 
readonly
ù
ù
 "
int
ù
ù
# &
_PongTexture
ù
ù
' 3
=
ù
ù
; <
Shader
ù
ù
= C
.
ù
ù
C D
PropertyToID
ù
ù
D P
(
ù
ù
P Q
$str
ù
ù
Q _
)
ù
ù
_ `
;
ù
ù
` a
public
û
û
 
static
û
û
 
readonly
û
û
 "
int
û
û
# &
_PingTexture
û
û
' 3
=
û
û
; <
Shader
û
û
= C
.
û
û
C D
PropertyToID
û
û
D P
(
û
û
P Q
$str
û
û
Q _
)
û
û
_ `
;
û
û
` a
public
†
†
 
static
†
†
 
readonly
†
†
 "
int
†
†
# &
_Metrics
†
†
' /
=
†
†
; <
Shader
†
†
= C
.
†
†
C D
PropertyToID
†
†
D P
(
†
†
P Q
$str
†
†
Q [
)
†
†
[ \
;
†
†
\ ]
public
°
°
 
static
°
°
 
readonly
°
°
 "
int
°
°
# &
_AreaTexture
°
°
' 3
=
°
°
; <
Shader
°
°
= C
.
°
°
C D
PropertyToID
°
°
D P
(
°
°
P Q
$str
°
°
Q _
)
°
°
_ `
;
°
°
` a
public
¢
¢
 
static
¢
¢
 
readonly
¢
¢
 "
int
¢
¢
# &
_SearchTexture
¢
¢
' 5
=
¢
¢
; <
Shader
¢
¢
= C
.
¢
¢
C D
PropertyToID
¢
¢
D P
(
¢
¢
P Q
$str
¢
¢
Q a
)
¢
¢
a b
;
¢
¢
b c
public
£
£
 
static
£
£
 
readonly
£
£
 "
int
£
£
# &
_EdgeTexture
£
£
' 3
=
£
£
; <
Shader
£
£
= C
.
£
£
C D
PropertyToID
£
£
D P
(
£
£
P Q
$str
£
£
Q _
)
£
£
_ `
;
£
£
` a
public
§
§
 
static
§
§
 
readonly
§
§
 "
int
§
§
# &
_BlendTexture
§
§
' 4
=
§
§
; <
Shader
§
§
= C
.
§
§
C D
PropertyToID
§
§
D P
(
§
§
P Q
$str
§
§
Q `
)
§
§
` a
;
§
§
a b
public
¶
¶
 
static
¶
¶
 
readonly
¶
¶
 "
int
¶
¶
# &
_ColorTexture
¶
¶
' 4
=
¶
¶
; <
Shader
¶
¶
= C
.
¶
¶
C D
PropertyToID
¶
¶
D P
(
¶
¶
P Q
$str
¶
¶
Q `
)
¶
¶
` a
;
¶
¶
a b
public
ß
ß
 
static
ß
ß
 
readonly
ß
ß
 "
int
ß
ß
# &
_Params
ß
ß
' .
=
ß
ß
; <
Shader
ß
ß
= C
.
ß
ß
C D
PropertyToID
ß
ß
D P
(
ß
ß
P Q
$str
ß
ß
Q Z
)
ß
ß
Z [
;
ß
ß
[ \
public
®
®
 
static
®
®
 
readonly
®
®
 "
int
®
®
# &
_SourceTexLowMip
®
®
' 7
=
®
®
; <
Shader
®
®
= C
.
®
®
C D
PropertyToID
®
®
D P
(
®
®
P Q
$str
®
®
Q c
)
®
®
c d
;
®
®
d e
public
©
©
 
static
©
©
 
readonly
©
©
 "
int
©
©
# &
_Bloom_Params
©
©
' 4
=
©
©
; <
Shader
©
©
= C
.
©
©
C D
PropertyToID
©
©
D P
(
©
©
P Q
$str
©
©
Q `
)
©
©
` a
;
©
©
a b
public
™
™
 
static
™
™
 
readonly
™
™
 "
int
™
™
# &
_Bloom_RGBM
™
™
' 2
=
™
™
; <
Shader
™
™
= C
.
™
™
C D
PropertyToID
™
™
D P
(
™
™
P Q
$str
™
™
Q ^
)
™
™
^ _
;
™
™
_ `
public
´
´
 
static
´
´
 
readonly
´
´
 "
int
´
´
# &
_Bloom_Texture
´
´
' 5
=
´
´
; <
Shader
´
´
= C
.
´
´
C D
PropertyToID
´
´
D P
(
´
´
P Q
$str
´
´
Q a
)
´
´
a b
;
´
´
b c
public
¨
¨
 
static
¨
¨
 
readonly
¨
¨
 "
int
¨
¨
# &
_LensDirt_Texture
¨
¨
' 8
=
¨
¨
; <
Shader
¨
¨
= C
.
¨
¨
C D
PropertyToID
¨
¨
D P
(
¨
¨
P Q
$str
¨
¨
Q d
)
¨
¨
d e
;
¨
¨
e f
public
≠
≠
 
static
≠
≠
 
readonly
≠
≠
 "
int
≠
≠
# &
_LensDirt_Params
≠
≠
' 7
=
≠
≠
; <
Shader
≠
≠
= C
.
≠
≠
C D
PropertyToID
≠
≠
D P
(
≠
≠
P Q
$str
≠
≠
Q c
)
≠
≠
c d
;
≠
≠
d e
public
Æ
Æ
 
static
Æ
Æ
 
readonly
Æ
Æ
 "
int
Æ
Æ
# &!
_LensDirt_Intensity
Æ
Æ
' :
=
Æ
Æ
; <
Shader
Æ
Æ
= C
.
Æ
Æ
C D
PropertyToID
Æ
Æ
D P
(
Æ
Æ
P Q
$str
Æ
Æ
Q f
)
Æ
Æ
f g
;
Æ
Æ
g h
public
Ø
Ø
 
static
Ø
Ø
 
readonly
Ø
Ø
 "
int
Ø
Ø
# &!
_Distortion_Params1
Ø
Ø
' :
=
Ø
Ø
; <
Shader
Ø
Ø
= C
.
Ø
Ø
C D
PropertyToID
Ø
Ø
D P
(
Ø
Ø
P Q
$str
Ø
Ø
Q f
)
Ø
Ø
f g
;
Ø
Ø
g h
public
∞
∞
 
static
∞
∞
 
readonly
∞
∞
 "
int
∞
∞
# &!
_Distortion_Params2
∞
∞
' :
=
∞
∞
; <
Shader
∞
∞
= C
.
∞
∞
C D
PropertyToID
∞
∞
D P
(
∞
∞
P Q
$str
∞
∞
Q f
)
∞
∞
f g
;
∞
∞
g h
public
±
±
 
static
±
±
 
readonly
±
±
 "
int
±
±
# &
_Chroma_Params
±
±
' 5
=
±
±
; <
Shader
±
±
= C
.
±
±
C D
PropertyToID
±
±
D P
(
±
±
P Q
$str
±
±
Q a
)
±
±
a b
;
±
±
b c
public
≤
≤
 
static
≤
≤
 
readonly
≤
≤
 "
int
≤
≤
# &
_Vignette_Params1
≤
≤
' 8
=
≤
≤
; <
Shader
≤
≤
= C
.
≤
≤
C D
PropertyToID
≤
≤
D P
(
≤
≤
P Q
$str
≤
≤
Q d
)
≤
≤
d e
;
≤
≤
e f
public
≥
≥
 
static
≥
≥
 
readonly
≥
≥
 "
int
≥
≥
# &
_Vignette_Params2
≥
≥
' 8
=
≥
≥
; <
Shader
≥
≥
= C
.
≥
≥
C D
PropertyToID
≥
≥
D P
(
≥
≥
P Q
$str
≥
≥
Q d
)
≥
≥
d e
;
≥
≥
e f
public
¥
¥
 
static
¥
¥
 
readonly
¥
¥
 "
int
¥
¥
# &
_Lut_Params
¥
¥
' 2
=
¥
¥
; <
Shader
¥
¥
= C
.
¥
¥
C D
PropertyToID
¥
¥
D P
(
¥
¥
P Q
$str
¥
¥
Q ^
)
¥
¥
^ _
;
¥
¥
_ `
public
µ
µ
 
static
µ
µ
 
readonly
µ
µ
 "
int
µ
µ
# &
_UserLut_Params
µ
µ
' 6
=
µ
µ
; <
Shader
µ
µ
= C
.
µ
µ
C D
PropertyToID
µ
µ
D P
(
µ
µ
P Q
$str
µ
µ
Q b
)
µ
µ
b c
;
µ
µ
c d
public
∂
∂
 
static
∂
∂
 
readonly
∂
∂
 "
int
∂
∂
# &
_InternalLut
∂
∂
' 3
=
∂
∂
; <
Shader
∂
∂
= C
.
∂
∂
C D
PropertyToID
∂
∂
D P
(
∂
∂
P Q
$str
∂
∂
Q _
)
∂
∂
_ `
;
∂
∂
` a
public
∑
∑
 
static
∑
∑
 
readonly
∑
∑
 "
int
∑
∑
# &
_UserLut
∑
∑
' /
=
∑
∑
; <
Shader
∑
∑
= C
.
∑
∑
C D
PropertyToID
∑
∑
D P
(
∑
∑
P Q
$str
∑
∑
Q [
)
∑
∑
[ \
;
∑
∑
\ ]
public
∏
∏
 
static
∏
∏
 
readonly
∏
∏
 "
int
∏
∏
# &$
_DownSampleScaleFactor
∏
∏
' =
=
∏
∏
> ?
Shader
∏
∏
@ F
.
∏
∏
F G
PropertyToID
∏
∏
G S
(
∏
∏
S T
$str
∏
∏
T l
)
∏
∏
l m
;
∏
∏
m n
public
∫
∫
 
static
∫
∫
 
readonly
∫
∫
 "
int
∫
∫
# & 
_FullscreenProjMat
∫
∫
' 9
=
∫
∫
; <
Shader
∫
∫
= C
.
∫
∫
C D
PropertyToID
∫
∫
D P
(
∫
∫
P Q
$str
∫
∫
Q e
)
∫
∫
e f
;
∫
∫
f g
public
º
º
 
static
º
º
 
int
º
º
 
[
º
º
 
]
º
º
 
_BloomMipUp
º
º
  +
;
º
º
+ ,
public
Ω
Ω
 
static
Ω
Ω
 
int
Ω
Ω
 
[
Ω
Ω
 
]
Ω
Ω
 
_BloomMipDown
Ω
Ω
  -
;
Ω
Ω
- .
}
æ
æ
 	
}
¡
¡
 
}¬
¬
 õY
°D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Light2DBlendStyle.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
[ 
Serializable 
] 
[		 
	MovedFrom		 
(		 
$str		 8
)		8 9
]		9 :
public		; A
struct		B H
Light2DBlendStyle		I Z
{

 
internal 
enum 
TextureChannel $
{ 	
None 
= 
$num 
, 
R 
= 
$num 
, 
G 
= 
$num 
, 
B 
= 
$num 
, 
A 
= 
$num 
, 
	OneMinusR 
= 
$num 
, 
	OneMinusG 
= 
$num 
, 
	OneMinusB 
= 
$num 
, 
	OneMinusA 
= 
$num 
} 	
internal 
struct 
MaskChannelFilter )
{ 	
public 
Vector4 
mask 
{  !
get" %
;% &
private' .
set/ 2
;2 3
}4 5
public 
Vector4 
inverted #
{$ %
get& )
;) *
private+ 2
set3 6
;6 7
}8 9
public 
MaskChannelFilter $
($ %
Vector4% ,
m- .
,. /
Vector40 7
i8 9
)9 :
{ 
mask 
= 
m 
; 
inverted   
=   
i   
;   
}!! 
}"" 	
internal$$ 
enum$$ 
	BlendMode$$ 
{%% 	
Additive&& 
=&& 
$num&& 
,&& 
Multiply'' 
='' 
$num'' 
,'' 
Subtractive(( 
=(( 
$num(( 
,(( 
Custom)) 
=)) 
$num)) 
}** 	
[,, 	
Serializable,,	 
],, 
internal-- 
struct-- 
BlendFactors-- $
{.. 	
public// 
float// 
multiplicative// '
;//' (
public00 
float00 
additive00 !
;00! "
}11 	
public33 
string33 
name33 
;33 
[55 	
SerializeField55	 
]55 
internal66 
TextureChannel66 
maskTextureChannel66  2
;662 3
[88 	
SerializeField88	 
,88 
Range88 
(88 
$num88 $
,88$ %
$num88& *
)88* +
]88+ ,
internal99 
float99 
renderTextureScale99 )
;99) *
[;; 	
SerializeField;;	 
];; 
internal<< 
	BlendMode<< 
	blendMode<< $
;<<$ %
[>> 	
SerializeField>>	 
]>> 
internal?? 
BlendFactors?? 
customBlendFactors?? 0
;??0 1
internalAA 
Vector2AA 
blendFactorsAA %
{BB 	
getCC 
{DD 
varEE 
resultEE 
=EE 
newEE  
Vector2EE! (
(EE( )
)EE) *
;EE* +
switchGG 
(GG 
	blendModeGG !
)GG! "
{HH 
caseII 
	BlendModeII "
.II" #
AdditiveII# +
:II+ ,
resultJJ 
.JJ 
xJJ  
=JJ! "
$numJJ# '
;JJ' (
resultKK 
.KK 
yKK  
=KK! "
$numKK# '
;KK' (
breakLL 
;LL 
caseMM 
	BlendModeMM "
.MM" #
MultiplyMM# +
:MM+ ,
resultNN 
.NN 
xNN  
=NN! "
$numNN# '
;NN' (
resultOO 
.OO 
yOO  
=OO! "
$numOO# '
;OO' (
breakPP 
;PP 
caseQQ 
	BlendModeQQ "
.QQ" #
SubtractiveQQ# .
:QQ. /
resultRR 
.RR 
xRR  
=RR! "
$numRR# '
;RR' (
resultSS 
.SS 
ySS  
=SS! "
-SS# $
$numSS$ (
;SS( )
breakTT 
;TT 
caseUU 
	BlendModeUU "
.UU" #
CustomUU# )
:UU) *
resultVV 
.VV 
xVV  
=VV! "
customBlendFactorsVV# 5
.VV5 6
multiplicativeVV6 D
;VVD E
resultWW 
.WW 
yWW  
=WW! "
customBlendFactorsWW# 5
.WW5 6
additiveWW6 >
;WW> ?
breakXX 
;XX 
defaultYY 
:YY 
resultZZ 
=ZZ  
Vector2ZZ! (
.ZZ( )
zeroZZ) -
;ZZ- .
break[[ 
;[[ 
}\\ 
return^^ 
result^^ 
;^^ 
}__ 
}`` 	
internalbb 
MaskChannelFilterbb "$
maskTextureChannelFilterbb# ;
{cc 	
getdd 
{ee 
switchff 
(ff 
maskTextureChannelff *
)ff* +
{gg 
casehh 
TextureChannelhh '
.hh' (
Rhh( )
:hh) *
returnii 
newii "
MaskChannelFilterii# 4
(ii4 5
newii5 8
Vector4ii9 @
(ii@ A
$numiiA B
,iiB C
$numiiD E
,iiE F
$numiiG H
,iiH I
$numiiJ K
)iiK L
,iiL M
newiiN Q
Vector4iiR Y
(iiY Z
$numiiZ [
,ii[ \
$numii] ^
,ii^ _
$numii` a
,iia b
$numiic d
)iid e
)iie f
;iif g
casejj 
TextureChanneljj '
.jj' (
	OneMinusRjj( 1
:jj1 2
returnkk 
newkk "
MaskChannelFilterkk# 4
(kk4 5
newkk5 8
Vector4kk9 @
(kk@ A
$numkkA B
,kkB C
$numkkD E
,kkE F
$numkkG H
,kkH I
$numkkJ K
)kkK L
,kkL M
newkkN Q
Vector4kkR Y
(kkY Z
$numkkZ [
,kk[ \
$numkk] ^
,kk^ _
$numkk` a
,kka b
$numkkc d
)kkd e
)kke f
;kkf g
casell 
TextureChannelll '
.ll' (
Gll( )
:ll) *
returnmm 
newmm "
MaskChannelFiltermm# 4
(mm4 5
newmm5 8
Vector4mm9 @
(mm@ A
$nummmA B
,mmB C
$nummmD E
,mmE F
$nummmG H
,mmH I
$nummmJ K
)mmK L
,mmL M
newmmN Q
Vector4mmR Y
(mmY Z
$nummmZ [
,mm[ \
$nummm] ^
,mm^ _
$nummm` a
,mma b
$nummmc d
)mmd e
)mme f
;mmf g
casenn 
TextureChannelnn '
.nn' (
	OneMinusGnn( 1
:nn1 2
returnoo 
newoo "
MaskChannelFilteroo# 4
(oo4 5
newoo5 8
Vector4oo9 @
(oo@ A
$numooA B
,ooB C
$numooD E
,ooE F
$numooG H
,ooH I
$numooJ K
)ooK L
,ooL M
newooN Q
Vector4ooR Y
(ooY Z
$numooZ [
,oo[ \
$numoo] ^
,oo^ _
$numoo` a
,ooa b
$numooc d
)ood e
)ooe f
;oof g
casepp 
TextureChannelpp '
.pp' (
Bpp( )
:pp) *
returnqq 
newqq "
MaskChannelFilterqq# 4
(qq4 5
newqq5 8
Vector4qq9 @
(qq@ A
$numqqA B
,qqB C
$numqqD E
,qqE F
$numqqG H
,qqH I
$numqqJ K
)qqK L
,qqL M
newqqN Q
Vector4qqR Y
(qqY Z
$numqqZ [
,qq[ \
$numqq] ^
,qq^ _
$numqq` a
,qqa b
$numqqc d
)qqd e
)qqe f
;qqf g
caserr 
TextureChannelrr '
.rr' (
	OneMinusBrr( 1
:rr1 2
returnss 
newss "
MaskChannelFilterss# 4
(ss4 5
newss5 8
Vector4ss9 @
(ss@ A
$numssA B
,ssB C
$numssD E
,ssE F
$numssG H
,ssH I
$numssJ K
)ssK L
,ssL M
newssN Q
Vector4ssR Y
(ssY Z
$numssZ [
,ss[ \
$numss] ^
,ss^ _
$numss` a
,ssa b
$numssc d
)ssd e
)sse f
;ssf g
casett 
TextureChanneltt '
.tt' (
Att( )
:tt) *
returnuu 
newuu "
MaskChannelFilteruu# 4
(uu4 5
newuu5 8
Vector4uu9 @
(uu@ A
$numuuA B
,uuB C
$numuuD E
,uuE F
$numuuG H
,uuH I
$numuuJ K
)uuK L
,uuL M
newuuN Q
Vector4uuR Y
(uuY Z
$numuuZ [
,uu[ \
$numuu] ^
,uu^ _
$numuu` a
,uua b
$numuuc d
)uud e
)uue f
;uuf g
casevv 
TextureChannelvv '
.vv' (
	OneMinusAvv( 1
:vv1 2
returnww 
newww "
MaskChannelFilterww# 4
(ww4 5
newww5 8
Vector4ww9 @
(ww@ A
$numwwA B
,wwB C
$numwwD E
,wwE F
$numwwG H
,wwH I
$numwwJ K
)wwK L
,wwL M
newwwN Q
Vector4wwR Y
(wwY Z
$numwwZ [
,ww[ \
$numww] ^
,ww^ _
$numww` a
,wwa b
$numwwc d
)wwd e
)wwe f
;wwf g
casexx 
TextureChannelxx '
.xx' (
Nonexx( ,
:xx, -
defaultyy 
:yy 
returnzz 
newzz "
MaskChannelFilterzz# 4
(zz4 5
Vector4zz5 <
.zz< =
zerozz= A
,zzA B
Vector4zzC J
.zzJ K
zerozzK O
)zzO P
;zzP Q
}{{ 
}|| 
}}} 	
internal
ÄÄ 
bool
ÄÄ 
isDirty
ÄÄ 
{
ÄÄ 
get
ÄÄ  #
;
ÄÄ# $
set
ÄÄ% (
;
ÄÄ( )
}
ÄÄ* +
internal
ÅÅ 
bool
ÅÅ 
hasRenderTarget
ÅÅ %
{
ÅÅ& '
get
ÅÅ( +
;
ÅÅ+ ,
set
ÅÅ- 0
;
ÅÅ0 1
}
ÅÅ2 3
internal
ÇÇ  
RenderTargetHandle
ÇÇ # 
renderTargetHandle
ÇÇ$ 6
;
ÇÇ6 7
}
ÑÑ 
}ÖÖ å
§D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\LiftGammaGain.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' J
)J K
]K L
public 

sealed 
class 
LiftGammaGain %
:& '
VolumeComponent( 7
,7 8!
IPostProcessComponent9 N
{ 
[ 	
Tooltip	 
( 
$str ?
)? @
]@ A
public		 
Vector4Parameter		 
lift		  $
=		% &
new		' *
Vector4Parameter		+ ;
(		; <
new		< ?
Vector4		@ G
(		G H
$num		H J
,		J K
$num		L N
,		N O
$num		P R
,		R S
$num		T V
)		V W
)		W X
;		X Y
[ 	
Tooltip	 
( 
$str @
)@ A
]A B
public 
Vector4Parameter 
gamma  %
=& '
new( +
Vector4Parameter, <
(< =
new= @
Vector4A H
(H I
$numI K
,K L
$numM O
,O P
$numQ S
,S T
$numU W
)W X
)X Y
;Y Z
[ 	
Tooltip	 
( 
$str @
)@ A
]A B
public 
Vector4Parameter 
gain  $
=% &
new' *
Vector4Parameter+ ;
(; <
new< ?
Vector4@ G
(G H
$numH J
,J K
$numL N
,N O
$numP R
,R S
$numT V
)V W
)W X
;X Y
public 
bool 
IsActive 
( 
) 
{ 	
var 
defaultState 
= 
new "
Vector4# *
(* +
$num+ -
,- .
$num/ 1
,1 2
$num3 5
,5 6
$num7 9
)9 :
;: ;
return 
lift 
!= 
defaultState '
|| 
gamma 
!= 
defaultState (
|| 
gain 
!= 
defaultState '
;' (
} 	
public 
bool 
IsTileCompatible $
($ %
)% &
=>' )
true* .
;. /
} 
} É®
õD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\RenderingUtils.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
static5 ;
class< A
RenderingUtilsB P
{ 
static 
List 
< 
ShaderTagId 
>  #
m_LegacyShaderPassNames! 8
=9 :
new; >
List? C
<C D
ShaderTagIdD O
>O P
(P Q
)Q R
{ 	
new 
ShaderTagId 
( 
$str $
)$ %
,% &
new 
ShaderTagId 
( 
$str )
)) *
,* +
new 
ShaderTagId 
( 
$str )
)) *
,* +
new 
ShaderTagId 
( 
$str $
)$ %
,% &
new 
ShaderTagId 
( 
$str *
)* +
,+ ,
new 
ShaderTagId 
( 
$str &
)& '
,' (
} 	
;	 

static 
Mesh 
s_FullscreenMesh $
=% &
null' +
;+ ,
public 
static 
Mesh 
fullscreenMesh )
{ 	
get 
{   
if!! 
(!! 
s_FullscreenMesh!! $
!=!!% '
null!!( ,
)!!, -
return"" 
s_FullscreenMesh"" +
;""+ ,
float$$ 
topV$$ 
=$$ 
$num$$ !
;$$! "
float%% 
bottomV%% 
=%% 
$num%%  $
;%%$ %
s_FullscreenMesh''  
=''! "
new''# &
Mesh''' +
{'', -
name''. 2
=''3 4
$str''5 F
}''G H
;''H I
s_FullscreenMesh((  
.((  !
SetVertices((! ,
(((, -
new((- 0
List((1 5
<((5 6
Vector3((6 =
>((= >
{)) 
new** 
Vector3** 
(**  
-**  !
$num**! %
,**% &
-**' (
$num**( ,
,**, -
$num**. 2
)**2 3
,**3 4
new++ 
Vector3++ 
(++  
-++  !
$num++! %
,++% &
$num++( ,
,++, -
$num++. 2
)++2 3
,++3 4
new,, 
Vector3,, 
(,,  
$num,,  $
,,,$ %
-,,& '
$num,,' +
,,,+ ,
$num,,- 1
),,1 2
,,,2 3
new-- 
Vector3-- 
(--  
$num--  $
,--$ %
$num--' +
,--+ ,
$num--- 1
)--1 2
}.. 
).. 
;.. 
s_FullscreenMesh00  
.00  !
SetUVs00! '
(00' (
$num00( )
,00) *
new00+ .
List00/ 3
<003 4
Vector2004 ;
>00; <
{11 
new22 
Vector222 
(22  
$num22  $
,22$ %
bottomV22& -
)22- .
,22. /
new33 
Vector233 
(33  
$num33  $
,33$ %
topV33& *
)33* +
,33+ ,
new44 
Vector244 
(44  
$num44  $
,44$ %
bottomV44& -
)44- .
,44. /
new55 
Vector255 
(55  
$num55  $
,55$ %
topV55& *
)55* +
}66 
)66 
;66 
s_FullscreenMesh88  
.88  !

SetIndices88! +
(88+ ,
new88, /
[88/ 0
]880 1
{882 3
$num884 5
,885 6
$num887 8
,888 9
$num88: ;
,88; <
$num88= >
,88> ?
$num88@ A
,88A B
$num88C D
}88E F
,88F G
MeshTopology88H T
.88T U
	Triangles88U ^
,88^ _
$num88` a
,88a b
false88c h
)88h i
;88i j
s_FullscreenMesh99  
.99  !
UploadMeshData99! /
(99/ 0
true990 4
)994 5
;995 6
return:: 
s_FullscreenMesh:: '
;::' (
};; 
}<< 	
internal>> 
static>> 
bool>> 
useStructuredBuffer>> 0
{?? 	
getBB 
{CC 
returnFF 
falseFF 
;FF 
}MM 
}NN 	
staticPP 
MaterialPP 
s_ErrorMaterialPP '
;PP' (
staticQQ 
MaterialQQ 
errorMaterialQQ %
{RR 	
getSS 
{TT 
ifUU 
(UU 
s_ErrorMaterialUU #
==UU$ &
nullUU' +
)UU+ ,
{VV 
tryZZ 
{[[ 
s_ErrorMaterial\\ '
=\\( )
new\\* -
Material\\. 6
(\\6 7
Shader\\7 =
.\\= >
Find\\> B
(\\B C
$str\\C s
)\\s t
)\\t u
;\\u v
}]] 
catch^^ 
{^^ 
}^^ 
}__ 
returnaa 
s_ErrorMaterialaa &
;aa& '
}bb 
}cc 	
publicnn 
staticnn 
voidnn (
SetViewAndProjectionMatricesnn 7
(nn7 8
CommandBuffernn8 E
cmdnnF I
,nnI J
	Matrix4x4nnK T

viewMatrixnnU _
,nn_ `
	Matrix4x4nna j
projectionMatrixnnk {
,nn{ |
bool	nn} Å 
setInverseMatrices
nnÇ î
)
nnî ï
{oo 	
	Matrix4x4pp #
viewAndProjectionMatrixpp -
=pp. /
projectionMatrixpp0 @
*ppA B

viewMatrixppC M
;ppM N
cmdqq 
.qq 
SetGlobalMatrixqq 
(qq  
ShaderPropertyIdqq  0
.qq0 1

viewMatrixqq1 ;
,qq; <

viewMatrixqq= G
)qqG H
;qqH I
cmdrr 
.rr 
SetGlobalMatrixrr 
(rr  
ShaderPropertyIdrr  0
.rr0 1
projectionMatrixrr1 A
,rrA B
projectionMatrixrrC S
)rrS T
;rrT U
cmdss 
.ss 
SetGlobalMatrixss 
(ss  
ShaderPropertyIdss  0
.ss0 1#
viewAndProjectionMatrixss1 H
,ssH I#
viewAndProjectionMatrixssJ a
)ssa b
;ssb c
ifuu 
(uu 
setInverseMatricesuu "
)uu" #
{vv 
	Matrix4x4ww 
inverseViewMatrixww +
=ww, -
	Matrix4x4ww. 7
.ww7 8
Inverseww8 ?
(ww? @

viewMatrixww@ J
)wwJ K
;wwK L
	Matrix4x4xx #
inverseProjectionMatrixxx 1
=xx2 3
	Matrix4x4xx4 =
.xx= >
Inversexx> E
(xxE F
projectionMatrixxxF V
)xxV W
;xxW X
	Matrix4x4yy !
inverseViewProjectionyy /
=yy0 1
inverseViewMatrixyy2 C
*yyD E#
inverseProjectionMatrixyyF ]
;yy] ^
cmdzz 
.zz 
SetGlobalMatrixzz #
(zz# $
ShaderPropertyIdzz$ 4
.zz4 5
inverseViewMatrixzz5 F
,zzF G
inverseViewMatrixzzH Y
)zzY Z
;zzZ [
cmd{{ 
.{{ 
SetGlobalMatrix{{ #
({{# $
ShaderPropertyId{{$ 4
.{{4 5#
inverseProjectionMatrix{{5 L
,{{L M#
inverseProjectionMatrix{{N e
){{e f
;{{f g
cmd|| 
.|| 
SetGlobalMatrix|| #
(||# $
ShaderPropertyId||$ 4
.||4 5*
inverseViewAndProjectionMatrix||5 S
,||S T!
inverseViewProjection||U j
)||j k
;||k l
}}} 
}~~ 	
internal
ÇÇ 
static
ÇÇ 
readonly
ÇÇ  
int
ÇÇ! $#
UNITY_STEREO_MATRIX_V
ÇÇ% :
=
ÇÇ; <
Shader
ÇÇ= C
.
ÇÇC D
PropertyToID
ÇÇD P
(
ÇÇP Q
$str
ÇÇQ f
)
ÇÇf g
;
ÇÇg h
internal
ÉÉ 
static
ÉÉ 
readonly
ÉÉ  
int
ÉÉ! $$
UNITY_STEREO_MATRIX_IV
ÉÉ% ;
=
ÉÉ< =
Shader
ÉÉ> D
.
ÉÉD E
PropertyToID
ÉÉE Q
(
ÉÉQ R
$str
ÉÉR j
)
ÉÉj k
;
ÉÉk l
internal
ÑÑ 
static
ÑÑ 
readonly
ÑÑ  
int
ÑÑ! $#
UNITY_STEREO_MATRIX_P
ÑÑ% :
=
ÑÑ; <
Shader
ÑÑ= C
.
ÑÑC D
PropertyToID
ÑÑD P
(
ÑÑP Q
$str
ÑÑQ f
)
ÑÑf g
;
ÑÑg h
internal
ÖÖ 
static
ÖÖ 
readonly
ÖÖ  
int
ÖÖ! $$
UNITY_STEREO_MATRIX_IP
ÖÖ% ;
=
ÖÖ< =
Shader
ÖÖ> D
.
ÖÖD E
PropertyToID
ÖÖE Q
(
ÖÖQ R
$str
ÖÖR j
)
ÖÖj k
;
ÖÖk l
internal
ÜÜ 
static
ÜÜ 
readonly
ÜÜ  
int
ÜÜ! $$
UNITY_STEREO_MATRIX_VP
ÜÜ% ;
=
ÜÜ< =
Shader
ÜÜ> D
.
ÜÜD E
PropertyToID
ÜÜE Q
(
ÜÜQ R
$str
ÜÜR h
)
ÜÜh i
;
ÜÜi j
internal
áá 
static
áá 
readonly
áá  
int
áá! $%
UNITY_STEREO_MATRIX_IVP
áá% <
=
áá= >
Shader
áá? E
.
ááE F
PropertyToID
ááF R
(
ááR S
$str
ááS l
)
áál m
;
áám n
internal
àà 
static
àà 
readonly
àà  
int
àà! $,
UNITY_STEREO_CAMERA_PROJECTION
àà% C
=
ààD E
Shader
ààF L
.
ààL M
PropertyToID
ààM Y
(
ààY Z
$str
ààZ x
)
ààx y
;
àày z
internal
ââ 
static
ââ 
readonly
ââ  
int
ââ! $0
"UNITY_STEREO_CAMERA_INV_PROJECTION
ââ% G
=
ââH I
Shader
ââJ P
.
ââP Q
PropertyToID
ââQ ]
(
ââ] ^
$str
ââ^ 
)ââ Ä
;ââÄ Å
internal
ää 
static
ää 
readonly
ää  
int
ää! $(
UNITY_STEREO_VECTOR_CAMPOS
ää% ?
=
ää@ A
Shader
ääB H
.
ääH I
PropertyToID
ääI U
(
ääU V
$str
ääV w
)
ääw x
;
ääx y
internal
çç 
class
çç 
StereoConstants
çç &
{
éé 	
public
èè 
	Matrix4x4
èè 
[
èè 
]
èè 
viewProjMatrix
èè -
=
èè. /
new
èè0 3
	Matrix4x4
èè4 =
[
èè= >
$num
èè> ?
]
èè? @
;
èè@ A
public
êê 
	Matrix4x4
êê 
[
êê 
]
êê 
invViewMatrix
êê ,
=
êê- .
new
êê/ 2
	Matrix4x4
êê3 <
[
êê< =
$num
êê= >
]
êê> ?
;
êê? @
public
ëë 
	Matrix4x4
ëë 
[
ëë 
]
ëë 
invProjMatrix
ëë ,
=
ëë- .
new
ëë/ 2
	Matrix4x4
ëë3 <
[
ëë< =
$num
ëë= >
]
ëë> ?
;
ëë? @
public
íí 
	Matrix4x4
íí 
[
íí 
]
íí 
invViewProjMatrix
íí 0
=
íí1 2
new
íí3 6
	Matrix4x4
íí7 @
[
íí@ A
$num
ííA B
]
ííB C
;
ííC D
public
ìì 
	Matrix4x4
ìì 
[
ìì 
]
ìì !
invCameraProjMatrix
ìì 2
=
ìì3 4
new
ìì5 8
	Matrix4x4
ìì9 B
[
ììB C
$num
ììC D
]
ììD E
;
ììE F
public
îî 
Vector4
îî 
[
îî 
]
îî !
worldSpaceCameraPos
îî 0
=
îî1 2
new
îî3 6
Vector4
îî7 >
[
îî> ?
$num
îî? @
]
îî@ A
;
îîA B
}
ïï 	
;
ïï	 

static
óó 
readonly
óó 
StereoConstants
óó '
stereoConstants
óó( 7
=
óó8 9
new
óó: =
StereoConstants
óó> M
(
óóM N
)
óóN O
;
óóO P
internal
§§ 
static
§§ 
void
§§ 0
"SetStereoViewAndProjectionMatrices
§§ ?
(
§§? @
CommandBuffer
§§@ M
cmd
§§N Q
,
§§Q R
	Matrix4x4
§§S \
[
§§\ ]
]
§§] ^

viewMatrix
§§_ i
,
§§i j
	Matrix4x4
§§k t
[
§§t u
]
§§u v

projMatrix§§w Å
,§§Å Ç
	Matrix4x4§§É å
[§§å ç
]§§ç é 
cameraProjMatrix§§è ü
,§§ü †
bool§§° •"
setInverseMatrices§§¶ ∏
)§§∏ π
{
•• 	
for
¶¶ 
(
¶¶ 
int
¶¶ 
i
¶¶ 
=
¶¶ 
$num
¶¶ 
;
¶¶ 
i
¶¶ 
<
¶¶ 
$num
¶¶  !
;
¶¶! "
i
¶¶# $
++
¶¶$ &
)
¶¶& '
{
ßß 
stereoConstants
®® 
.
®®  
viewProjMatrix
®®  .
[
®®. /
i
®®/ 0
]
®®0 1
=
®®2 3

projMatrix
®®4 >
[
®®> ?
i
®®? @
]
®®@ A
*
®®B C

viewMatrix
®®D N
[
®®N O
i
®®O P
]
®®P Q
;
®®Q R
stereoConstants
©© 
.
©©  
invViewMatrix
©©  -
[
©©- .
i
©©. /
]
©©/ 0
=
©©1 2
	Matrix4x4
©©3 <
.
©©< =
Inverse
©©= D
(
©©D E

viewMatrix
©©E O
[
©©O P
i
©©P Q
]
©©Q R
)
©©R S
;
©©S T
stereoConstants
™™ 
.
™™  
invProjMatrix
™™  -
[
™™- .
i
™™. /
]
™™/ 0
=
™™1 2
	Matrix4x4
™™3 <
.
™™< =
Inverse
™™= D
(
™™D E

projMatrix
™™E O
[
™™O P
i
™™P Q
]
™™Q R
)
™™R S
;
™™S T
stereoConstants
´´ 
.
´´  
invViewProjMatrix
´´  1
[
´´1 2
i
´´2 3
]
´´3 4
=
´´5 6
	Matrix4x4
´´7 @
.
´´@ A
Inverse
´´A H
(
´´H I
stereoConstants
´´I X
.
´´X Y
viewProjMatrix
´´Y g
[
´´g h
i
´´h i
]
´´i j
)
´´j k
;
´´k l
stereoConstants
¨¨ 
.
¨¨  !
invCameraProjMatrix
¨¨  3
[
¨¨3 4
i
¨¨4 5
]
¨¨5 6
=
¨¨7 8
	Matrix4x4
¨¨9 B
.
¨¨B C
Inverse
¨¨C J
(
¨¨J K
cameraProjMatrix
¨¨K [
[
¨¨[ \
i
¨¨\ ]
]
¨¨] ^
)
¨¨^ _
;
¨¨_ `
stereoConstants
≠≠ 
.
≠≠  !
worldSpaceCameraPos
≠≠  3
[
≠≠3 4
i
≠≠4 5
]
≠≠5 6
=
≠≠7 8
stereoConstants
≠≠9 H
.
≠≠H I
invViewMatrix
≠≠I V
[
≠≠V W
i
≠≠W X
]
≠≠X Y
.
≠≠Y Z
	GetColumn
≠≠Z c
(
≠≠c d
$num
≠≠d e
)
≠≠e f
;
≠≠f g
}
ÆÆ 
cmd
∞∞ 
.
∞∞ "
SetGlobalMatrixArray
∞∞ $
(
∞∞$ %#
UNITY_STEREO_MATRIX_V
∞∞% :
,
∞∞: ;

viewMatrix
∞∞< F
)
∞∞F G
;
∞∞G H
cmd
±± 
.
±± "
SetGlobalMatrixArray
±± $
(
±±$ %#
UNITY_STEREO_MATRIX_P
±±% :
,
±±: ;

projMatrix
±±< F
)
±±F G
;
±±G H
cmd
≤≤ 
.
≤≤ "
SetGlobalMatrixArray
≤≤ $
(
≤≤$ %$
UNITY_STEREO_MATRIX_VP
≤≤% ;
,
≤≤; <
stereoConstants
≤≤= L
.
≤≤L M
viewProjMatrix
≤≤M [
)
≤≤[ \
;
≤≤\ ]
cmd
¥¥ 
.
¥¥ "
SetGlobalMatrixArray
¥¥ $
(
¥¥$ %,
UNITY_STEREO_CAMERA_PROJECTION
¥¥% C
,
¥¥C D
cameraProjMatrix
¥¥E U
)
¥¥U V
;
¥¥V W
if
∂∂ 
(
∂∂  
setInverseMatrices
∂∂ "
)
∂∂" #
{
∑∑ 
cmd
∏∏ 
.
∏∏ "
SetGlobalMatrixArray
∏∏ (
(
∏∏( )$
UNITY_STEREO_MATRIX_IV
∏∏) ?
,
∏∏? @
stereoConstants
∏∏A P
.
∏∏P Q
invViewMatrix
∏∏Q ^
)
∏∏^ _
;
∏∏_ `
cmd
ππ 
.
ππ "
SetGlobalMatrixArray
ππ (
(
ππ( )$
UNITY_STEREO_MATRIX_IP
ππ) ?
,
ππ? @
stereoConstants
ππA P
.
ππP Q
invProjMatrix
ππQ ^
)
ππ^ _
;
ππ_ `
cmd
∫∫ 
.
∫∫ "
SetGlobalMatrixArray
∫∫ (
(
∫∫( )%
UNITY_STEREO_MATRIX_IVP
∫∫) @
,
∫∫@ A
stereoConstants
∫∫B Q
.
∫∫Q R
invViewProjMatrix
∫∫R c
)
∫∫c d
;
∫∫d e
cmd
ºº 
.
ºº "
SetGlobalMatrixArray
ºº (
(
ºº( )0
"UNITY_STEREO_CAMERA_INV_PROJECTION
ºº) K
,
ººK L
stereoConstants
ººM \
.
ºº\ ]!
invCameraProjMatrix
ºº] p
)
ººp q
;
ººq r
}
ΩΩ 
cmd
ææ 
.
ææ "
SetGlobalVectorArray
ææ $
(
ææ$ %(
UNITY_STEREO_VECTOR_CAMPOS
ææ% ?
,
ææ? @
stereoConstants
ææA P
.
ææP Q!
worldSpaceCameraPos
ææQ d
)
ææd e
;
ææe f
}
øø 	
internal
¬¬ 
static
¬¬ 
void
¬¬ 
Blit
¬¬ !
(
¬¬! "
CommandBuffer
¬¬" /
cmd
¬¬0 3
,
¬¬3 4$
RenderTargetIdentifier
√√ "
source
√√# )
,
√√) *$
RenderTargetIdentifier
ƒƒ "
destination
ƒƒ# .
,
ƒƒ. /
Material
≈≈ 
material
≈≈ 
,
≈≈ 
int
∆∆ 
	passIndex
∆∆ 
=
∆∆ 
$num
∆∆ 
,
∆∆ 
bool
«« 
useDrawProcedural
«« "
=
««# $
false
««% *
,
««* +$
RenderBufferLoadAction
»» "
colorLoadAction
»»# 2
=
»»3 4$
RenderBufferLoadAction
»»5 K
.
»»K L
Load
»»L P
,
»»P Q%
RenderBufferStoreAction
…… #
colorStoreAction
……$ 4
=
……5 6%
RenderBufferStoreAction
……7 N
.
……N O
Store
……O T
,
……T U$
RenderBufferLoadAction
   "
depthLoadAction
  # 2
=
  3 4$
RenderBufferLoadAction
  5 K
.
  K L
Load
  L P
,
  P Q%
RenderBufferStoreAction
ÀÀ #
depthStoreAction
ÀÀ$ 4
=
ÀÀ5 6%
RenderBufferStoreAction
ÀÀ7 N
.
ÀÀN O
Store
ÀÀO T
)
ÀÀT U
{
ÃÃ 	
cmd
ÕÕ 
.
ÕÕ 
SetGlobalTexture
ÕÕ  
(
ÕÕ  !
ShaderPropertyId
ÕÕ! 1
.
ÕÕ1 2
	sourceTex
ÕÕ2 ;
,
ÕÕ; <
source
ÕÕ= C
)
ÕÕC D
;
ÕÕD E
if
ŒŒ 
(
ŒŒ 
useDrawProcedural
ŒŒ !
)
ŒŒ! "
{
œœ 
Vector4
–– 
	scaleBias
–– !
=
––" #
new
––$ '
Vector4
––( /
(
––/ 0
$num
––0 1
,
––1 2
$num
––3 4
,
––4 5
$num
––6 7
,
––7 8
$num
––9 :
)
––: ;
;
––; <
Vector4
—— 
scaleBiasRt
—— #
=
——$ %
new
——& )
Vector4
——* 1
(
——1 2
$num
——2 3
,
——3 4
$num
——5 6
,
——6 7
$num
——8 9
,
——9 :
$num
——; <
)
——< =
;
——= >
cmd
““ 
.
““ 
SetGlobalVector
““ #
(
““# $
ShaderPropertyId
““$ 4
.
““4 5
	scaleBias
““5 >
,
““> ?
	scaleBias
““@ I
)
““I J
;
““J K
cmd
”” 
.
”” 
SetGlobalVector
”” #
(
””# $
ShaderPropertyId
””$ 4
.
””4 5
scaleBiasRt
””5 @
,
””@ A
scaleBiasRt
””B M
)
””M N
;
””N O
cmd
‘‘ 
.
‘‘ 
SetRenderTarget
‘‘ #
(
‘‘# $
new
‘‘$ '$
RenderTargetIdentifier
‘‘( >
(
‘‘> ?
destination
‘‘? J
,
‘‘J K
$num
‘‘L M
,
‘‘M N
CubemapFace
‘‘O Z
.
‘‘Z [
Unknown
‘‘[ b
,
‘‘b c
-
‘‘d e
$num
‘‘e f
)
‘‘f g
,
‘‘g h
colorLoadAction
’’ #
,
’’# $
colorStoreAction
’’% 5
,
’’5 6
depthLoadAction
’’7 F
,
’’F G
depthStoreAction
’’H X
)
’’X Y
;
’’Y Z
cmd
÷÷ 
.
÷÷ 
DrawProcedural
÷÷ "
(
÷÷" #
	Matrix4x4
÷÷# ,
.
÷÷, -
identity
÷÷- 5
,
÷÷5 6
material
÷÷7 ?
,
÷÷? @
	passIndex
÷÷A J
,
÷÷J K
MeshTopology
÷÷L X
.
÷÷X Y
Quads
÷÷Y ^
,
÷÷^ _
$num
÷÷` a
,
÷÷a b
$num
÷÷c d
,
÷÷d e
null
÷÷f j
)
÷÷j k
;
÷÷k l
}
◊◊ 
else
ÿÿ 
{
ŸŸ 
cmd
⁄⁄ 
.
⁄⁄ 
SetRenderTarget
⁄⁄ #
(
⁄⁄# $
destination
⁄⁄$ /
,
⁄⁄/ 0
colorLoadAction
⁄⁄1 @
,
⁄⁄@ A
colorStoreAction
⁄⁄B R
,
⁄⁄R S
depthLoadAction
⁄⁄T c
,
⁄⁄c d
depthStoreAction
⁄⁄e u
)
⁄⁄u v
;
⁄⁄v w
cmd
€€ 
.
€€ 
Blit
€€ 
(
€€ 
source
€€ 
,
€€  &
BuiltinRenderTextureType
€€! 9
.
€€9 :
CurrentActive
€€: G
,
€€G H
material
€€I Q
,
€€Q R
	passIndex
€€S \
)
€€\ ]
;
€€] ^
}
‹‹ 
}
›› 	
[
·· 	
Conditional
··	 
(
·· 
$str
·· (
)
··( )
,
··) *
Conditional
··+ 6
(
··6 7
$str
··7 E
)
··E F
]
··F G
internal
‚‚ 
static
‚‚ 
void
‚‚ $
RenderObjectsWithError
‚‚ 3
(
‚‚3 4%
ScriptableRenderContext
‚‚4 K
context
‚‚L S
,
‚‚S T
ref
‚‚U X
CullingResults
‚‚Y g
cullResults
‚‚h s
,
‚‚s t
Camera
‚‚u {
camera‚‚| Ç
,‚‚Ç É!
FilteringSettings‚‚Ñ ï
filterSettings‚‚ñ §
,‚‚§ •
SortingCriteria‚‚¶ µ
	sortFlags‚‚∂ ø
)‚‚ø ¿
{
„„ 	
if
ÁÁ 
(
ÁÁ 
errorMaterial
ÁÁ 
==
ÁÁ  
null
ÁÁ! %
)
ÁÁ% &
return
ËË 
;
ËË 
SortingSettings
ÍÍ 
sortingSettings
ÍÍ +
=
ÍÍ, -
new
ÍÍ. 1
SortingSettings
ÍÍ2 A
(
ÍÍA B
camera
ÍÍB H
)
ÍÍH I
{
ÍÍJ K
criteria
ÍÍL T
=
ÍÍU V
	sortFlags
ÍÍW `
}
ÍÍa b
;
ÍÍb c
DrawingSettings
ÎÎ 
errorSettings
ÎÎ )
=
ÎÎ* +
new
ÎÎ, /
DrawingSettings
ÎÎ0 ?
(
ÎÎ? @%
m_LegacyShaderPassNames
ÎÎ@ W
[
ÎÎW X
$num
ÎÎX Y
]
ÎÎY Z
,
ÎÎZ [
sortingSettings
ÎÎ\ k
)
ÎÎk l
{
ÏÏ 
perObjectData
ÌÌ 
=
ÌÌ 
PerObjectData
ÌÌ  -
.
ÌÌ- .
None
ÌÌ. 2
,
ÌÌ2 3
overrideMaterial
ÓÓ  
=
ÓÓ! "
errorMaterial
ÓÓ# 0
,
ÓÓ0 1'
overrideMaterialPassIndex
ÔÔ )
=
ÔÔ* +
$num
ÔÔ, -
}
 
;
 
for
ÒÒ 
(
ÒÒ 
int
ÒÒ 
i
ÒÒ 
=
ÒÒ 
$num
ÒÒ 
;
ÒÒ 
i
ÒÒ 
<
ÒÒ %
m_LegacyShaderPassNames
ÒÒ  7
.
ÒÒ7 8
Count
ÒÒ8 =
;
ÒÒ= >
++
ÒÒ? A
i
ÒÒA B
)
ÒÒB C
errorSettings
ÚÚ 
.
ÚÚ 
SetShaderPassName
ÚÚ /
(
ÚÚ/ 0
i
ÚÚ0 1
,
ÚÚ1 2%
m_LegacyShaderPassNames
ÚÚ3 J
[
ÚÚJ K
i
ÚÚK L
]
ÚÚL M
)
ÚÚM N
;
ÚÚN O
context
ÙÙ 
.
ÙÙ 
DrawRenderers
ÙÙ !
(
ÙÙ! "
cullResults
ÙÙ" -
,
ÙÙ- .
ref
ÙÙ/ 2
errorSettings
ÙÙ3 @
,
ÙÙ@ A
ref
ÙÙB E
filterSettings
ÙÙF T
)
ÙÙT U
;
ÙÙU V
}
ıı 	
static
¯¯ 

Dictionary
¯¯ 
<
¯¯ !
RenderTextureFormat
¯¯ -
,
¯¯- .
bool
¯¯/ 3
>
¯¯3 4*
m_RenderTextureFormatSupport
¯¯5 Q
=
¯¯R S
new
¯¯T W

Dictionary
¯¯X b
<
¯¯b c!
RenderTextureFormat
¯¯c v
,
¯¯v w
bool
¯¯x |
>
¯¯| }
(
¯¯} ~
)
¯¯~ 
;¯¯ Ä
static
˘˘ 

Dictionary
˘˘ 
<
˘˘ 
GraphicsFormat
˘˘ (
,
˘˘( )

Dictionary
˘˘* 4
<
˘˘4 5
FormatUsage
˘˘5 @
,
˘˘@ A
bool
˘˘B F
>
˘˘F G
>
˘˘H I%
m_GraphicsFormatSupport
˘˘J a
=
˘˘b c
new
˘˘d g

Dictionary
˘˘h r
<
˘˘r s
GraphicsFormat˘˘s Å
,˘˘Å Ç

Dictionary˘˘É ç
<˘˘ç é
FormatUsage˘˘é ô
,˘˘ô ö
bool˘˘õ ü
>˘˘ü †
>˘˘° ¢
(˘˘¢ £
)˘˘£ §
;˘˘§ •
internal
˚˚ 
static
˚˚ 
void
˚˚ "
ClearSystemInfoCache
˚˚ 1
(
˚˚1 2
)
˚˚2 3
{
¸¸ 	*
m_RenderTextureFormatSupport
˝˝ (
.
˝˝( )
Clear
˝˝) .
(
˝˝. /
)
˝˝/ 0
;
˝˝0 1%
m_GraphicsFormatSupport
˛˛ #
.
˛˛# $
Clear
˛˛$ )
(
˛˛) *
)
˛˛* +
;
˛˛+ ,
}
ˇˇ 	
public
áá 
static
áá 
bool
áá )
SupportsRenderTextureFormat
áá 6
(
áá6 7!
RenderTextureFormat
áá7 J
format
ááK Q
)
ááQ R
{
àà 	
if
ââ 
(
ââ 
!
ââ *
m_RenderTextureFormatSupport
ââ -
.
ââ- .
TryGetValue
ââ. 9
(
ââ9 :
format
ââ: @
,
ââ@ A
out
ââB E
var
ââF I
support
ââJ Q
)
ââQ R
)
ââR S
{
ää 
support
ãã 
=
ãã 

SystemInfo
ãã $
.
ãã$ %)
SupportsRenderTextureFormat
ãã% @
(
ãã@ A
format
ããA G
)
ããG H
;
ããH I*
m_RenderTextureFormatSupport
åå ,
.
åå, -
Add
åå- 0
(
åå0 1
format
åå1 7
,
åå7 8
support
åå9 @
)
åå@ A
;
ååA B
}
çç 
return
èè 
support
èè 
;
èè 
}
êê 	
public
ôô 
static
ôô 
bool
ôô $
SupportsGraphicsFormat
ôô 1
(
ôô1 2
GraphicsFormat
ôô2 @
format
ôôA G
,
ôôG H
FormatUsage
ôôI T
usage
ôôU Z
)
ôôZ [
{
öö 	
bool
õõ 
support
õõ 
=
õõ 
false
õõ  
;
õõ  !
if
úú 
(
úú 
!
úú %
m_GraphicsFormatSupport
úú (
.
úú( )
TryGetValue
úú) 4
(
úú4 5
format
úú5 ;
,
úú; <
out
úú= @
var
úúA D
uses
úúE I
)
úúI J
)
úúJ K
{
ùù 
uses
ûû 
=
ûû 
new
ûû 

Dictionary
ûû %
<
ûû% &
FormatUsage
ûû& 1
,
ûû1 2
bool
ûû3 7
>
ûû7 8
(
ûû8 9
)
ûû9 :
;
ûû: ;
support
üü 
=
üü 

SystemInfo
üü $
.
üü$ %
IsFormatSupported
üü% 6
(
üü6 7
format
üü7 =
,
üü= >
usage
üü? D
)
üüD E
;
üüE F
uses
†† 
.
†† 
Add
†† 
(
†† 
usage
†† 
,
†† 
support
††  '
)
††' (
;
††( )%
m_GraphicsFormatSupport
°° '
.
°°' (
Add
°°( +
(
°°+ ,
format
°°, 2
,
°°2 3
uses
°°4 8
)
°°8 9
;
°°9 :
}
¢¢ 
else
££ 
{
§§ 
if
•• 
(
•• 
!
•• 
uses
•• 
.
•• 
TryGetValue
•• %
(
••% &
usage
••& +
,
••+ ,
out
••- 0
support
••1 8
)
••8 9
)
••9 :
{
¶¶ 
support
ßß 
=
ßß 

SystemInfo
ßß (
.
ßß( )
IsFormatSupported
ßß) :
(
ßß: ;
format
ßß; A
,
ßßA B
usage
ßßC H
)
ßßH I
;
ßßI J
uses
®® 
.
®® 
Add
®® 
(
®® 
usage
®® "
,
®®" #
support
®®$ +
)
®®+ ,
;
®®, -
}
©© 
}
™™ 
return
¨¨ 
support
¨¨ 
;
¨¨ 
}
≠≠ 	
internal
¥¥ 
static
¥¥ 
int
¥¥ *
GetLastValidColorBufferIndex
¥¥ 8
(
¥¥8 9$
RenderTargetIdentifier
¥¥9 O
[
¥¥O P
]
¥¥P Q
colorBuffers
¥¥R ^
)
¥¥^ _
{
µµ 	
int
∂∂ 
i
∂∂ 
=
∂∂ 
colorBuffers
∂∂  
.
∂∂  !
Length
∂∂! '
-
∂∂( )
$num
∂∂* +
;
∂∂+ ,
for
∑∑ 
(
∑∑ 
;
∑∑ 
i
∑∑ 
>=
∑∑ 
$num
∑∑ 
;
∑∑ 
--
∑∑ 
i
∑∑ 
)
∑∑ 
{
∏∏ 
if
ππ 
(
ππ 
colorBuffers
ππ  
[
ππ  !
i
ππ! "
]
ππ" #
!=
ππ$ &
$num
ππ' (
)
ππ( )
break
∫∫ 
;
∫∫ 
}
ªª 
return
ºº 
i
ºº 
;
ºº 
}
ΩΩ 	
internal
ƒƒ 
static
ƒƒ 
uint
ƒƒ &
GetValidColorBufferCount
ƒƒ 5
(
ƒƒ5 6$
RenderTargetIdentifier
ƒƒ6 L
[
ƒƒL M
]
ƒƒM N
colorBuffers
ƒƒO [
)
ƒƒ[ \
{
≈≈ 	
uint
∆∆ !
nonNullColorBuffers
∆∆ $
=
∆∆% &
$num
∆∆' (
;
∆∆( )
if
«« 
(
«« 
colorBuffers
«« 
!=
«« 
null
««  $
)
««$ %
{
»» 
foreach
…… 
(
…… 
var
…… 

identifier
…… '
in
……( *
colorBuffers
……+ 7
)
……7 8
{
   
if
ÀÀ 
(
ÀÀ 

identifier
ÀÀ "
!=
ÀÀ# %
$num
ÀÀ& '
)
ÀÀ' (
++
ÃÃ !
nonNullColorBuffers
ÃÃ -
;
ÃÃ- .
}
ÕÕ 
}
ŒŒ 
return
œœ !
nonNullColorBuffers
œœ &
;
œœ& '
}
–– 	
internal
◊◊ 
static
◊◊ 
bool
◊◊ 
IsMRT
◊◊ "
(
◊◊" #$
RenderTargetIdentifier
◊◊# 9
[
◊◊9 :
]
◊◊: ;
colorBuffers
◊◊< H
)
◊◊H I
{
ÿÿ 	
return
ŸŸ &
GetValidColorBufferCount
ŸŸ +
(
ŸŸ+ ,
colorBuffers
ŸŸ, 8
)
ŸŸ8 9
>
ŸŸ: ;
$num
ŸŸ< =
;
ŸŸ= >
}
⁄⁄ 	
internal
‚‚ 
static
‚‚ 
bool
‚‚ 
Contains
‚‚ %
(
‚‚% &$
RenderTargetIdentifier
‚‚& <
[
‚‚< =
]
‚‚= >
source
‚‚? E
,
‚‚E F$
RenderTargetIdentifier
‚‚G ]
value
‚‚^ c
)
‚‚c d
{
„„ 	
foreach
‰‰ 
(
‰‰ 
var
‰‰ 

identifier
‰‰ #
in
‰‰$ &
source
‰‰' -
)
‰‰- .
{
ÂÂ 
if
ÊÊ 
(
ÊÊ 

identifier
ÊÊ 
==
ÊÊ !
value
ÊÊ" '
)
ÊÊ' (
return
ÁÁ 
true
ÁÁ 
;
ÁÁ  
}
ËË 
return
ÈÈ 
false
ÈÈ 
;
ÈÈ 
}
ÍÍ 	
internal
ÚÚ 
static
ÚÚ 
int
ÚÚ 
IndexOf
ÚÚ #
(
ÚÚ# $$
RenderTargetIdentifier
ÚÚ$ :
[
ÚÚ: ;
]
ÚÚ; <
source
ÚÚ= C
,
ÚÚC D$
RenderTargetIdentifier
ÚÚE [
value
ÚÚ\ a
)
ÚÚa b
{
ÛÛ 	
for
ÙÙ 
(
ÙÙ 
int
ÙÙ 
i
ÙÙ 
=
ÙÙ 
$num
ÙÙ 
;
ÙÙ 
i
ÙÙ 
<
ÙÙ 
source
ÙÙ  &
.
ÙÙ& '
Length
ÙÙ' -
;
ÙÙ- .
++
ÙÙ/ 1
i
ÙÙ1 2
)
ÙÙ2 3
{
ıı 
if
ˆˆ 
(
ˆˆ 
source
ˆˆ 
[
ˆˆ 
i
ˆˆ 
]
ˆˆ 
==
ˆˆ  
value
ˆˆ! &
)
ˆˆ& '
return
˜˜ 
i
˜˜ 
;
˜˜ 
}
¯¯ 
return
˘˘ 
-
˘˘ 
$num
˘˘ 
;
˘˘ 
}
˙˙ 	
internal
ÇÇ 
static
ÇÇ 
uint
ÇÇ 
CountDistinct
ÇÇ *
(
ÇÇ* +$
RenderTargetIdentifier
ÇÇ+ A
[
ÇÇA B
]
ÇÇB C
source
ÇÇD J
,
ÇÇJ K$
RenderTargetIdentifier
ÇÇL b
value
ÇÇc h
)
ÇÇh i
{
ÉÉ 	
uint
ÑÑ 
count
ÑÑ 
=
ÑÑ 
$num
ÑÑ 
;
ÑÑ 
for
ÖÖ 
(
ÖÖ 
int
ÖÖ 
i
ÖÖ 
=
ÖÖ 
$num
ÖÖ 
;
ÖÖ 
i
ÖÖ 
<
ÖÖ 
source
ÖÖ  &
.
ÖÖ& '
Length
ÖÖ' -
;
ÖÖ- .
++
ÖÖ/ 1
i
ÖÖ1 2
)
ÖÖ2 3
{
ÜÜ 
if
áá 
(
áá 
source
áá 
[
áá 
i
áá 
]
áá 
!=
áá  
value
áá! &
&&
áá' )
source
áá* 0
[
áá0 1
i
áá1 2
]
áá2 3
!=
áá4 6
$num
áá7 8
)
áá8 9
++
àà 
count
àà 
;
àà 
}
ââ 
return
ää 
count
ää 
;
ää 
}
ãã 	
internal
íí 
static
íí 
int
íí 
	LastValid
íí %
(
íí% &$
RenderTargetIdentifier
íí& <
[
íí< =
]
íí= >
source
íí? E
)
ííE F
{
ìì 	
for
îî 
(
îî 
int
îî 
i
îî 
=
îî 
source
îî 
.
îî  
Length
îî  &
-
îî& '
$num
îî' (
;
îî( )
i
îî* +
>=
îî, .
$num
îî/ 0
;
îî0 1
--
îî2 4
i
îî4 5
)
îî5 6
{
ïï 
if
ññ 
(
ññ 
source
ññ 
[
ññ 
i
ññ 
]
ññ 
!=
ññ  
$num
ññ! "
)
ññ" #
return
óó 
i
óó 
;
óó 
}
òò 
return
ôô 
-
ôô 
$num
ôô 
;
ôô 
}
öö 	
internal
¢¢ 
static
¢¢ 
bool
¢¢ 
Contains
¢¢ %
(
¢¢% &
	ClearFlag
¢¢& /
a
¢¢0 1
,
¢¢1 2
	ClearFlag
¢¢3 <
b
¢¢= >
)
¢¢> ?
{
££ 	
return
§§ 
(
§§ 
a
§§ 
&
§§ 
b
§§ 
)
§§ 
==
§§ 
b
§§ 
;
§§  
}
•• 	
internal
≠≠ 
static
≠≠ 
bool
≠≠ 
SequenceEqual
≠≠ *
(
≠≠* +$
RenderTargetIdentifier
≠≠+ A
[
≠≠A B
]
≠≠B C
left
≠≠D H
,
≠≠H I$
RenderTargetIdentifier
≠≠J `
[
≠≠` a
]
≠≠a b
right
≠≠c h
)
≠≠h i
{
ÆÆ 	
if
ØØ 
(
ØØ 
left
ØØ 
.
ØØ 
Length
ØØ 
!=
ØØ 
right
ØØ $
.
ØØ$ %
Length
ØØ% +
)
ØØ+ ,
return
∞∞ 
false
∞∞ 
;
∞∞ 
for
≤≤ 
(
≤≤ 
int
≤≤ 
i
≤≤ 
=
≤≤ 
$num
≤≤ 
;
≤≤ 
i
≤≤ 
<
≤≤ 
left
≤≤  $
.
≤≤$ %
Length
≤≤% +
;
≤≤+ ,
++
≤≤- /
i
≤≤/ 0
)
≤≤0 1
if
≥≥ 
(
≥≥ 
left
≥≥ 
[
≥≥ 
i
≥≥ 
]
≥≥ 
!=
≥≥ 
right
≥≥ $
[
≥≥$ %
i
≥≥% &
]
≥≥& '
)
≥≥' (
return
¥¥ 
false
¥¥  
;
¥¥  !
return
∂∂ 
true
∂∂ 
;
∂∂ 
}
∑∑ 	
}
∏∏ 
}ππ ∞â
≠D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\External\LibTessDotNet\MeshUtils.cs
	namespace'' 	
UnityEngine''
 
.'' 
Experimental'' "
.''" #
	Rendering''# ,
.'', -
	Universal''- 6
{(( 
	namespace++ 	
LibTessDotNet++
 
{,, 
internal-- 
struct-- 
Vec3-- 
{.. 
public// 
readonly// 
static// 
Vec3// #
Zero//$ (
=//) *
new//+ .
Vec3/// 3
(//3 4
)//4 5
;//5 6
public11 
Real11 
X11 
,11 
Y11 
,11 
Z11 
;11 
public33 
Real33 
this33 
[33 
int33 
index33 "
]33" #
{44 	
get55 
{66 
if77 
(77 
index77 
==77 
$num77 
)77 
return77  &
X77' (
;77( )
if88 
(88 
index88 
==88 
$num88 
)88 
return88  &
Y88' (
;88( )
if99 
(99 
index99 
==99 
$num99 
)99 
return99  &
Z99' (
;99( )
throw:: 
new:: $
IndexOutOfRangeException:: 2
(::2 3
)::3 4
;::4 5
};; 
set<< 
{== 
if>> 
(>> 
index>> 
==>> 
$num>> 
)>> 
X>>  !
=>>" #
value>>$ )
;>>) *
else?? 
if?? 
(?? 
index?? 
==?? !
$num??" #
)??# $
Y??% &
=??' (
value??) .
;??. /
else@@ 
if@@ 
(@@ 
index@@ 
==@@ !
$num@@" #
)@@# $
Z@@% &
=@@' (
value@@) .
;@@. /
elseAA 
throwAA 
newAA $
IndexOutOfRangeExceptionAA 7
(AA7 8
)AA8 9
;AA9 :
}BB 
}CC 	
publicEE 
staticEE 
voidEE 
SubEE 
(EE 
refEE "
Vec3EE# '
lhsEE( +
,EE+ ,
refEE- 0
Vec3EE1 5
rhsEE6 9
,EE9 :
outEE; >
Vec3EE? C
resultEED J
)EEJ K
{FF 	
resultGG 
.GG 
XGG 
=GG 
lhsGG 
.GG 
XGG 
-GG 
rhsGG "
.GG" #
XGG# $
;GG$ %
resultHH 
.HH 
YHH 
=HH 
lhsHH 
.HH 
YHH 
-HH 
rhsHH "
.HH" #
YHH# $
;HH$ %
resultII 
.II 
ZII 
=II 
lhsII 
.II 
ZII 
-II 
rhsII "
.II" #
ZII# $
;II$ %
}JJ 	
publicLL 
staticLL 
voidLL 
NegLL 
(LL 
refLL "
Vec3LL# '
vLL( )
)LL) *
{MM 	
vNN 
.NN 
XNN 
=NN 
-NN 
vNN 
.NN 
XNN 
;NN 
vOO 
.OO 
YOO 
=OO 
-OO 
vOO 
.OO 
YOO 
;OO 
vPP 
.PP 
ZPP 
=PP 
-PP 
vPP 
.PP 
ZPP 
;PP 
}QQ 	
publicSS 
staticSS 
voidSS 
DotSS 
(SS 
refSS "
Vec3SS# '
uSS( )
,SS) *
refSS+ .
Vec3SS/ 3
vSS4 5
,SS5 6
outSS7 :
RealSS; ?
dotSS@ C
)SSC D
{TT 	
dotUU 
=UU 
uUU 
.UU 
XUU 
*UU 
vUU 
.UU 
XUU 
+UU 
uUU 
.UU  
YUU  !
*UU" #
vUU$ %
.UU% &
YUU& '
+UU( )
uUU* +
.UU+ ,
ZUU, -
*UU. /
vUU0 1
.UU1 2
ZUU2 3
;UU3 4
}VV 	
publicXX 
staticXX 
voidXX 
	NormalizeXX $
(XX$ %
refXX% (
Vec3XX) -
vXX. /
)XX/ 0
{YY 	
varZZ 
lenZZ 
=ZZ 
vZZ 
.ZZ 
XZZ 
*ZZ 
vZZ 
.ZZ 
XZZ 
+ZZ  !
vZZ" #
.ZZ# $
YZZ$ %
*ZZ& '
vZZ( )
.ZZ) *
YZZ* +
+ZZ, -
vZZ. /
.ZZ/ 0
ZZZ0 1
*ZZ2 3
vZZ4 5
.ZZ5 6
ZZZ6 7
;ZZ7 8
Debug[[ 
.[[ 
Assert[[ 
([[ 
len[[ 
>=[[ 
$num[[  $
)[[$ %
;[[% &
len\\ 
=\\ 
$num\\ 
/\\ 
(\\ 
Real\\ 
)\\ 
Math\\ #
.\\# $
Sqrt\\$ (
(\\( )
len\\) ,
)\\, -
;\\- .
v]] 
.]] 
X]] 
*=]] 
len]] 
;]] 
v^^ 
.^^ 
Y^^ 
*=^^ 
len^^ 
;^^ 
v__ 
.__ 
Z__ 
*=__ 
len__ 
;__ 
}`` 	
publicbb 
staticbb 
intbb 
LongAxisbb "
(bb" #
refbb# &
Vec3bb' +
vbb, -
)bb- .
{cc 	
intdd 
idd 
=dd 
$numdd 
;dd 
ifee 
(ee 
Mathee 
.ee 
Absee 
(ee 
vee 
.ee 
Yee 
)ee 
>ee 
Mathee  $
.ee$ %
Absee% (
(ee( )
vee) *
.ee* +
Xee+ ,
)ee, -
)ee- .
iee/ 0
=ee1 2
$numee3 4
;ee4 5
ifff 
(ff 
Mathff 
.ff 
Absff 
(ff 
vff 
.ff 
Zff 
)ff 
>ff 
Mathff  $
.ff$ %
Absff% (
(ff( )
iff) *
==ff+ -
$numff. /
?ff0 1
vff2 3
.ff3 4
Xff4 5
:ff6 7
vff8 9
.ff9 :
Yff: ;
)ff; <
)ff< =
iff> ?
=ff@ A
$numffB C
;ffC D
returngg 
igg 
;gg 
}hh 	
publicjj 
overridejj 
stringjj 
ToStringjj '
(jj' (
)jj( )
{kk 	
returnll 
stringll 
.ll 
Formatll  
(ll  !
$strll! 0
,ll0 1
Xll2 3
,ll3 4
Yll5 6
,ll6 7
Zll8 9
)ll9 :
;ll: ;
}mm 	
}nn 
internalpp 
staticpp 
classpp 
	MeshUtilspp #
{qq 
publicrr 
constrr 
intrr 
Undefrr 
=rr  
~rr! "
$numrr" #
;rr# $
publictt 
abstracttt 
classtt !
Pooledtt" (
<tt( )
Ttt) *
>tt* +
wherett, 1
Ttt2 3
:tt4 5
Pooledtt6 <
<tt< =
Ttt= >
>tt> ?
,tt? @
newttA D
(ttD E
)ttE F
{uu 
privatevv 
staticvv 
Stackvv $
<vv$ %
Tvv% &
>vv& '
_stackvv( .
;vv. /
publicww 
abstractww 
voidww  $
Resetww% *
(ww* +
)ww+ ,
;ww, -
publicxx 
virtualxx 
voidxx #
OnFreexx$ *
(xx* +
)xx+ ,
{xx- .
}xx/ 0
publiczz 
staticzz 
Tzz 
Createzz  &
(zz& '
)zz' (
{{{ 
if|| 
(|| 
_stack|| 
!=|| !
null||" &
&&||' )
_stack||* 0
.||0 1
Count||1 6
>||7 8
$num||9 :
)||: ;
{}} 
return~~ 
_stack~~ %
.~~% &
Pop~~& )
(~~) *
)~~* +
;~~+ ,
} 
return
ÄÄ 
new
ÄÄ 
T
ÄÄ  
(
ÄÄ  !
)
ÄÄ! "
;
ÄÄ" #
}
ÅÅ 
public
ÉÉ 
void
ÉÉ 
Free
ÉÉ  
(
ÉÉ  !
)
ÉÉ! "
{
ÑÑ 
OnFree
ÖÖ 
(
ÖÖ 
)
ÖÖ 
;
ÖÖ 
Reset
ÜÜ 
(
ÜÜ 
)
ÜÜ 
;
ÜÜ 
if
áá 
(
áá 
_stack
áá 
==
áá !
null
áá" &
)
áá& '
{
àà 
_stack
ââ 
=
ââ  
new
ââ! $
Stack
ââ% *
<
ââ* +
T
ââ+ ,
>
ââ, -
(
ââ- .
)
ââ. /
;
ââ/ 0
}
ää 
_stack
ãã 
.
ãã 
Push
ãã 
(
ãã  
(
ãã  !
T
ãã! "
)
ãã" #
this
ãã# '
)
ãã' (
;
ãã( )
}
åå 
}
çç 
public
èè 
class
èè 
Vertex
èè 
:
èè  !
Pooled
èè" (
<
èè( )
Vertex
èè) /
>
èè/ 0
{
êê 	
internal
ëë 
Vertex
ëë 
_prev
ëë !
,
ëë! "
_next
ëë# (
;
ëë( )
internal
íí 
Edge
íí 
_anEdge
íí !
;
íí! "
internal
îî 
Vec3
îî 
_coords
îî !
;
îî! "
internal
ïï 
Real
ïï 
_s
ïï 
,
ïï 
_t
ïï  
;
ïï  !
internal
ññ 
PQHandle
ññ 
	_pqHandle
ññ '
;
ññ' (
internal
óó 
int
óó 
_n
óó 
;
óó 
internal
òò 
object
òò 
_data
òò !
;
òò! "
public
öö 
override
öö 
void
öö  
Reset
öö! &
(
öö& '
)
öö' (
{
õõ 
_prev
úú 
=
úú 
_next
úú 
=
úú 
null
úú  $
;
úú$ %
_anEdge
ùù 
=
ùù 
null
ùù 
;
ùù 
_coords
ûû 
=
ûû 
Vec3
ûû 
.
ûû 
Zero
ûû #
;
ûû# $
_s
üü 
=
üü 
$num
üü 
;
üü 
_t
†† 
=
†† 
$num
†† 
;
†† 
	_pqHandle
°° 
=
°° 
new
°° 
PQHandle
°°  (
(
°°( )
)
°°) *
;
°°* +
_n
¢¢ 
=
¢¢ 
$num
¢¢ 
;
¢¢ 
_data
££ 
=
££ 
null
££ 
;
££ 
}
§§ 
}
•• 	
public
ßß 
class
ßß 
Face
ßß 
:
ßß 
Pooled
ßß "
<
ßß" #
Face
ßß# '
>
ßß' (
{
®® 	
internal
©© 
Face
©© 
_prev
©© 
,
©©  
_next
©©! &
;
©©& '
internal
™™ 
Edge
™™ 
_anEdge
™™ !
;
™™! "
internal
¨¨ 
Face
¨¨ 
_trail
¨¨  
;
¨¨  !
internal
≠≠ 
int
≠≠ 
_n
≠≠ 
;
≠≠ 
internal
ÆÆ 
bool
ÆÆ 
_marked
ÆÆ !
,
ÆÆ! "
_inside
ÆÆ# *
;
ÆÆ* +
internal
∞∞ 
int
∞∞ 

VertsCount
∞∞ #
{
±± 
get
≤≤ 
{
≥≥ 
int
¥¥ 
n
¥¥ 
=
¥¥ 
$num
¥¥ 
;
¥¥ 
var
µµ 
eCur
µµ 
=
µµ 
_anEdge
µµ &
;
µµ& '
do
∂∂ 
{
∂∂ 
n
∑∑ 
++
∑∑ 
;
∑∑ 
eCur
∏∏ 
=
∏∏ 
eCur
∏∏ #
.
∏∏# $
_Lnext
∏∏$ *
;
∏∏* +
}
ππ 
while
ππ 
(
ππ 
eCur
ππ !
!=
ππ" $
_anEdge
ππ% ,
)
ππ, -
;
ππ- .
return
∫∫ 
n
∫∫ 
;
∫∫ 
}
ªª 
}
ºº 
public
ææ 
override
ææ 
void
ææ  
Reset
ææ! &
(
ææ& '
)
ææ' (
{
øø 
_prev
¿¿ 
=
¿¿ 
_next
¿¿ 
=
¿¿ 
null
¿¿  $
;
¿¿$ %
_anEdge
¡¡ 
=
¡¡ 
null
¡¡ 
;
¡¡ 
_trail
¬¬ 
=
¬¬ 
null
¬¬ 
;
¬¬ 
_n
√√ 
=
√√ 
$num
√√ 
;
√√ 
_marked
ƒƒ 
=
ƒƒ 
false
ƒƒ 
;
ƒƒ  
_inside
≈≈ 
=
≈≈ 
false
≈≈ 
;
≈≈  
}
∆∆ 
}
«« 	
public
…… 
struct
…… 
EdgePair
…… 
{
   	
internal
ÀÀ 
Edge
ÀÀ 
_e
ÀÀ 
,
ÀÀ 
_eSym
ÀÀ #
;
ÀÀ# $
public
ÕÕ 
static
ÕÕ 
EdgePair
ÕÕ "
Create
ÕÕ# )
(
ÕÕ) *
)
ÕÕ* +
{
ŒŒ 
var
œœ 
pair
œœ 
=
œœ 
new
œœ 
	MeshUtils
œœ (
.
œœ( )
EdgePair
œœ) 1
(
œœ1 2
)
œœ2 3
;
œœ3 4
pair
–– 
.
–– 
_e
–– 
=
–– 
	MeshUtils
–– #
.
––# $
Edge
––$ (
.
––( )
Create
––) /
(
––/ 0
)
––0 1
;
––1 2
pair
—— 
.
—— 
_e
—— 
.
—— 
_pair
—— 
=
—— 
pair
——  $
;
——$ %
pair
““ 
.
““ 
_eSym
““ 
=
““ 
	MeshUtils
““ &
.
““& '
Edge
““' +
.
““+ ,
Create
““, 2
(
““2 3
)
““3 4
;
““4 5
pair
”” 
.
”” 
_eSym
”” 
.
”” 
_pair
””  
=
””! "
pair
””# '
;
””' (
return
‘‘ 
pair
‘‘ 
;
‘‘ 
}
’’ 
public
◊◊ 
void
◊◊ 
Reset
◊◊ 
(
◊◊ 
)
◊◊ 
{
ÿÿ 
_e
ŸŸ 
=
ŸŸ 
_eSym
ŸŸ 
=
ŸŸ 
null
ŸŸ !
;
ŸŸ! "
}
⁄⁄ 
}
€€ 	
public
›› 
class
›› 
Edge
›› 
:
›› 
Pooled
›› "
<
››" #
Edge
››# '
>
››' (
{
ﬁﬁ 	
internal
ﬂﬂ 
EdgePair
ﬂﬂ 
_pair
ﬂﬂ #
;
ﬂﬂ# $
internal
‡‡ 
Edge
‡‡ 
_next
‡‡ 
,
‡‡  
_Sym
‡‡! %
,
‡‡% &
_Onext
‡‡' -
,
‡‡- .
_Lnext
‡‡/ 5
;
‡‡5 6
internal
·· 
Vertex
·· 
_Org
··  
;
··  !
internal
‚‚ 
Face
‚‚ 
_Lface
‚‚  
;
‚‚  !
internal
„„ 
Tess
„„ 
.
„„ 
ActiveRegion
„„ &
_activeRegion
„„' 4
;
„„4 5
internal
‰‰ 
int
‰‰ 
_winding
‰‰ !
;
‰‰! "
internal
ÊÊ 
Face
ÊÊ 
_Rface
ÊÊ  
{
ÊÊ! "
get
ÊÊ# &
{
ÊÊ' (
return
ÊÊ) /
_Sym
ÊÊ0 4
.
ÊÊ4 5
_Lface
ÊÊ5 ;
;
ÊÊ; <
}
ÊÊ= >
set
ÊÊ? B
{
ÊÊC D
_Sym
ÊÊE I
.
ÊÊI J
_Lface
ÊÊJ P
=
ÊÊQ R
value
ÊÊS X
;
ÊÊX Y
}
ÊÊZ [
}
ÊÊ\ ]
internal
ÁÁ 
Vertex
ÁÁ 
_Dst
ÁÁ  
{
ÁÁ! "
get
ÁÁ# &
{
ÁÁ' (
return
ÁÁ) /
_Sym
ÁÁ0 4
.
ÁÁ4 5
_Org
ÁÁ5 9
;
ÁÁ9 :
}
ÁÁ; <
set
ÁÁ> A
{
ÁÁB C
_Sym
ÁÁD H
.
ÁÁH I
_Org
ÁÁI M
=
ÁÁN O
value
ÁÁP U
;
ÁÁU V
}
ÁÁW X
}
ÁÁY Z
internal
ÈÈ 
Edge
ÈÈ 
_Oprev
ÈÈ  
{
ÈÈ! "
get
ÈÈ# &
{
ÈÈ' (
return
ÈÈ) /
_Sym
ÈÈ0 4
.
ÈÈ4 5
_Lnext
ÈÈ5 ;
;
ÈÈ; <
}
ÈÈ= >
set
ÈÈ? B
{
ÈÈC D
_Sym
ÈÈE I
.
ÈÈI J
_Lnext
ÈÈJ P
=
ÈÈQ R
value
ÈÈS X
;
ÈÈX Y
}
ÈÈZ [
}
ÈÈ\ ]
internal
ÍÍ 
Edge
ÍÍ 
_Lprev
ÍÍ  
{
ÍÍ! "
get
ÍÍ# &
{
ÍÍ' (
return
ÍÍ) /
_Onext
ÍÍ0 6
.
ÍÍ6 7
_Sym
ÍÍ7 ;
;
ÍÍ; <
}
ÍÍ= >
set
ÍÍ? B
{
ÍÍC D
_Onext
ÍÍE K
.
ÍÍK L
_Sym
ÍÍL P
=
ÍÍQ R
value
ÍÍS X
;
ÍÍX Y
}
ÍÍZ [
}
ÍÍ\ ]
internal
ÎÎ 
Edge
ÎÎ 
_Dprev
ÎÎ  
{
ÎÎ! "
get
ÎÎ# &
{
ÎÎ' (
return
ÎÎ) /
_Lnext
ÎÎ0 6
.
ÎÎ6 7
_Sym
ÎÎ7 ;
;
ÎÎ; <
}
ÎÎ= >
set
ÎÎ? B
{
ÎÎC D
_Lnext
ÎÎE K
.
ÎÎK L
_Sym
ÎÎL P
=
ÎÎQ R
value
ÎÎS X
;
ÎÎX Y
}
ÎÎZ [
}
ÎÎ\ ]
internal
ÏÏ 
Edge
ÏÏ 
_Rprev
ÏÏ  
{
ÏÏ! "
get
ÏÏ# &
{
ÏÏ' (
return
ÏÏ) /
_Sym
ÏÏ0 4
.
ÏÏ4 5
_Onext
ÏÏ5 ;
;
ÏÏ; <
}
ÏÏ= >
set
ÏÏ? B
{
ÏÏC D
_Sym
ÏÏE I
.
ÏÏI J
_Onext
ÏÏJ P
=
ÏÏQ R
value
ÏÏS X
;
ÏÏX Y
}
ÏÏZ [
}
ÏÏ\ ]
internal
ÌÌ 
Edge
ÌÌ 
_Dnext
ÌÌ  
{
ÌÌ! "
get
ÌÌ# &
{
ÌÌ' (
return
ÌÌ) /
_Rprev
ÌÌ0 6
.
ÌÌ6 7
_Sym
ÌÌ7 ;
;
ÌÌ; <
}
ÌÌ= >
set
ÌÌ? B
{
ÌÌC D
_Rprev
ÌÌE K
.
ÌÌK L
_Sym
ÌÌL P
=
ÌÌQ R
value
ÌÌS X
;
ÌÌX Y
}
ÌÌZ [
}
ÌÌ\ ]
internal
ÓÓ 
Edge
ÓÓ 
_Rnext
ÓÓ  
{
ÓÓ! "
get
ÓÓ# &
{
ÓÓ' (
return
ÓÓ) /
_Oprev
ÓÓ0 6
.
ÓÓ6 7
_Sym
ÓÓ7 ;
;
ÓÓ; <
}
ÓÓ= >
set
ÓÓ? B
{
ÓÓC D
_Oprev
ÓÓE K
.
ÓÓK L
_Sym
ÓÓL P
=
ÓÓQ R
value
ÓÓS X
;
ÓÓX Y
}
ÓÓZ [
}
ÓÓ\ ]
internal
 
static
 
void
  
EnsureFirst
! ,
(
, -
ref
- 0
Edge
1 5
e
6 7
)
7 8
{
ÒÒ 
if
ÚÚ 
(
ÚÚ 
e
ÚÚ 
==
ÚÚ 
e
ÚÚ 
.
ÚÚ 
_pair
ÚÚ  
.
ÚÚ  !
_eSym
ÚÚ! &
)
ÚÚ& '
{
ÛÛ 
e
ÙÙ 
=
ÙÙ 
e
ÙÙ 
.
ÙÙ 
_Sym
ÙÙ 
;
ÙÙ 
}
ıı 
}
ˆˆ 
public
¯¯ 
override
¯¯ 
void
¯¯  
Reset
¯¯! &
(
¯¯& '
)
¯¯' (
{
˘˘ 
_pair
˙˙ 
.
˙˙ 
Reset
˙˙ 
(
˙˙ 
)
˙˙ 
;
˙˙ 
_next
˚˚ 
=
˚˚ 
_Sym
˚˚ 
=
˚˚ 
_Onext
˚˚ %
=
˚˚& '
_Lnext
˚˚( .
=
˚˚/ 0
null
˚˚1 5
;
˚˚5 6
_Org
¸¸ 
=
¸¸ 
null
¸¸ 
;
¸¸ 
_Lface
˝˝ 
=
˝˝ 
null
˝˝ 
;
˝˝ 
_activeRegion
˛˛ 
=
˛˛ 
null
˛˛  $
;
˛˛$ %
_winding
ˇˇ 
=
ˇˇ 
$num
ˇˇ 
;
ˇˇ 
}
ÄÄ 
}
ÅÅ 	
public
àà 
static
àà 
Edge
àà 
MakeEdge
àà #
(
àà# $
Edge
àà$ (
eNext
àà) .
)
àà. /
{
ââ 	
Debug
ää 
.
ää 
Assert
ää 
(
ää 
eNext
ää 
!=
ää !
null
ää" &
)
ää& '
;
ää' (
var
åå 
pair
åå 
=
åå 
EdgePair
åå 
.
åå  
Create
åå  &
(
åå& '
)
åå' (
;
åå( )
var
çç 
e
çç 
=
çç 
pair
çç 
.
çç 
_e
çç 
;
çç 
var
éé 
eSym
éé 
=
éé 
pair
éé 
.
éé 
_eSym
éé !
;
éé! "
Edge
ëë 
.
ëë 
EnsureFirst
ëë 
(
ëë 
ref
ëë  
eNext
ëë! &
)
ëë& '
;
ëë' (
var
ïï 
ePrev
ïï 
=
ïï 
eNext
ïï 
.
ïï 
_Sym
ïï "
.
ïï" #
_next
ïï# (
;
ïï( )
eSym
ññ 
.
ññ 
_next
ññ 
=
ññ 
ePrev
ññ 
;
ññ 
ePrev
óó 
.
óó 
_Sym
óó 
.
óó 
_next
óó 
=
óó 
e
óó  
;
óó  !
e
òò 
.
òò 
_next
òò 
=
òò 
eNext
òò 
;
òò 
eNext
ôô 
.
ôô 
_Sym
ôô 
.
ôô 
_next
ôô 
=
ôô 
eSym
ôô #
;
ôô# $
e
õõ 
.
õõ 
_Sym
õõ 
=
õõ 
eSym
õõ 
;
õõ 
e
úú 
.
úú 
_Onext
úú 
=
úú 
e
úú 
;
úú 
e
ùù 
.
ùù 
_Lnext
ùù 
=
ùù 
eSym
ùù 
;
ùù 
e
ûû 
.
ûû 
_Org
ûû 
=
ûû 
null
ûû 
;
ûû 
e
üü 
.
üü 
_Lface
üü 
=
üü 
null
üü 
;
üü 
e
†† 
.
†† 
_winding
†† 
=
†† 
$num
†† 
;
†† 
e
°° 
.
°° 
_activeRegion
°° 
=
°° 
null
°° "
;
°°" #
eSym
££ 
.
££ 
_Sym
££ 
=
££ 
e
££ 
;
££ 
eSym
§§ 
.
§§ 
_Onext
§§ 
=
§§ 
eSym
§§ 
;
§§ 
eSym
•• 
.
•• 
_Lnext
•• 
=
•• 
e
•• 
;
•• 
eSym
¶¶ 
.
¶¶ 
_Org
¶¶ 
=
¶¶ 
null
¶¶ 
;
¶¶ 
eSym
ßß 
.
ßß 
_Lface
ßß 
=
ßß 
null
ßß 
;
ßß 
eSym
®® 
.
®® 
_winding
®® 
=
®® 
$num
®® 
;
®® 
eSym
©© 
.
©© 
_activeRegion
©© 
=
©©  
null
©©! %
;
©©% &
return
´´ 
e
´´ 
;
´´ 
}
¨¨ 	
public
µµ 
static
µµ 
void
µµ 
Splice
µµ !
(
µµ! "
Edge
µµ" &
a
µµ' (
,
µµ( )
Edge
µµ* .
b
µµ/ 0
)
µµ0 1
{
∂∂ 	
var
∑∑ 
aOnext
∑∑ 
=
∑∑ 
a
∑∑ 
.
∑∑ 
_Onext
∑∑ !
;
∑∑! "
var
∏∏ 
bOnext
∏∏ 
=
∏∏ 
b
∏∏ 
.
∏∏ 
_Onext
∏∏ !
;
∏∏! "
aOnext
∫∫ 
.
∫∫ 
_Sym
∫∫ 
.
∫∫ 
_Lnext
∫∫ 
=
∫∫  
b
∫∫! "
;
∫∫" #
bOnext
ªª 
.
ªª 
_Sym
ªª 
.
ªª 
_Lnext
ªª 
=
ªª  
a
ªª! "
;
ªª" #
a
ºº 
.
ºº 
_Onext
ºº 
=
ºº 
bOnext
ºº 
;
ºº 
b
ΩΩ 
.
ΩΩ 
_Onext
ΩΩ 
=
ΩΩ 
aOnext
ΩΩ 
;
ΩΩ 
}
ææ 	
public
«« 
static
«« 
void
«« 

MakeVertex
«« %
(
««% &
Edge
««& *
eOrig
««+ 0
,
««0 1
Vertex
««2 8
vNext
««9 >
)
««> ?
{
»» 	
var
…… 
vNew
…… 
=
…… 
	MeshUtils
……  
.
……  !
Vertex
……! '
.
……' (
Create
……( .
(
……. /
)
……/ 0
;
……0 1
var
ÃÃ 
vPrev
ÃÃ 
=
ÃÃ 
vNext
ÃÃ 
.
ÃÃ 
_prev
ÃÃ #
;
ÃÃ# $
vNew
ÕÕ 
.
ÕÕ 
_prev
ÕÕ 
=
ÕÕ 
vPrev
ÕÕ 
;
ÕÕ 
vPrev
ŒŒ 
.
ŒŒ 
_next
ŒŒ 
=
ŒŒ 
vNew
ŒŒ 
;
ŒŒ 
vNew
œœ 
.
œœ 
_next
œœ 
=
œœ 
vNext
œœ 
;
œœ 
vNext
–– 
.
–– 
_prev
–– 
=
–– 
vNew
–– 
;
–– 
vNew
““ 
.
““ 
_anEdge
““ 
=
““ 
eOrig
““  
;
““  !
var
÷÷ 
e
÷÷ 
=
÷÷ 
eOrig
÷÷ 
;
÷÷ 
do
◊◊ 
{
◊◊ 
e
ÿÿ 
.
ÿÿ 
_Org
ÿÿ 
=
ÿÿ 
vNew
ÿÿ 
;
ÿÿ 
e
ŸŸ 
=
ŸŸ 
e
ŸŸ 
.
ŸŸ 
_Onext
ŸŸ 
;
ŸŸ 
}
⁄⁄ 
while
⁄⁄ 
(
⁄⁄ 
e
⁄⁄ 
!=
⁄⁄ 
eOrig
⁄⁄ 
)
⁄⁄  
;
⁄⁄  !
}
€€ 	
public
‰‰ 
static
‰‰ 
void
‰‰ 
MakeFace
‰‰ #
(
‰‰# $
Edge
‰‰$ (
eOrig
‰‰) .
,
‰‰. /
Face
‰‰0 4
fNext
‰‰5 :
)
‰‰: ;
{
ÂÂ 	
var
ÊÊ 
fNew
ÊÊ 
=
ÊÊ 
	MeshUtils
ÊÊ  
.
ÊÊ  !
Face
ÊÊ! %
.
ÊÊ% &
Create
ÊÊ& ,
(
ÊÊ, -
)
ÊÊ- .
;
ÊÊ. /
var
ÈÈ 
fPrev
ÈÈ 
=
ÈÈ 
fNext
ÈÈ 
.
ÈÈ 
_prev
ÈÈ #
;
ÈÈ# $
fNew
ÍÍ 
.
ÍÍ 
_prev
ÍÍ 
=
ÍÍ 
fPrev
ÍÍ 
;
ÍÍ 
fPrev
ÎÎ 
.
ÎÎ 
_next
ÎÎ 
=
ÎÎ 
fNew
ÎÎ 
;
ÎÎ 
fNew
ÏÏ 
.
ÏÏ 
_next
ÏÏ 
=
ÏÏ 
fNext
ÏÏ 
;
ÏÏ 
fNext
ÌÌ 
.
ÌÌ 
_prev
ÌÌ 
=
ÌÌ 
fNew
ÌÌ 
;
ÌÌ 
fNew
ÔÔ 
.
ÔÔ 
_anEdge
ÔÔ 
=
ÔÔ 
eOrig
ÔÔ  
;
ÔÔ  !
fNew
 
.
 
_trail
 
=
 
null
 
;
 
fNew
ÒÒ 
.
ÒÒ 
_marked
ÒÒ 
=
ÒÒ 
false
ÒÒ  
;
ÒÒ  !
fNew
ıı 
.
ıı 
_inside
ıı 
=
ıı 
fNext
ıı  
.
ıı  !
_inside
ıı! (
;
ıı( )
var
¯¯ 
e
¯¯ 
=
¯¯ 
eOrig
¯¯ 
;
¯¯ 
do
˘˘ 
{
˘˘ 
e
˙˙ 
.
˙˙ 
_Lface
˙˙ 
=
˙˙ 
fNew
˙˙ 
;
˙˙  
e
˚˚ 
=
˚˚ 
e
˚˚ 
.
˚˚ 
_Lnext
˚˚ 
;
˚˚ 
}
¸¸ 
while
¸¸ 
(
¸¸ 
e
¸¸ 
!=
¸¸ 
eOrig
¸¸ 
)
¸¸  
;
¸¸  !
}
˝˝ 	
public
ÉÉ 
static
ÉÉ 
void
ÉÉ 
KillEdge
ÉÉ #
(
ÉÉ# $
Edge
ÉÉ$ (
eDel
ÉÉ) -
)
ÉÉ- .
{
ÑÑ 	
Edge
ÜÜ 
.
ÜÜ 
EnsureFirst
ÜÜ 
(
ÜÜ 
ref
ÜÜ  
eDel
ÜÜ! %
)
ÜÜ% &
;
ÜÜ& '
var
ââ 
eNext
ââ 
=
ââ 
eDel
ââ 
.
ââ 
_next
ââ "
;
ââ" #
var
ää 
ePrev
ää 
=
ää 
eDel
ää 
.
ää 
_Sym
ää !
.
ää! "
_next
ää" '
;
ää' (
eNext
ãã 
.
ãã 
_Sym
ãã 
.
ãã 
_next
ãã 
=
ãã 
ePrev
ãã $
;
ãã$ %
ePrev
åå 
.
åå 
_Sym
åå 
.
åå 
_next
åå 
=
åå 
eNext
åå $
;
åå$ %
eDel
éé 
.
éé 
Free
éé 
(
éé 
)
éé 
;
éé 
}
èè 	
public
ïï 
static
ïï 
void
ïï 

KillVertex
ïï %
(
ïï% &
Vertex
ïï& ,
vDel
ïï- 1
,
ïï1 2
Vertex
ïï3 9
newOrg
ïï: @
)
ïï@ A
{
ññ 	
var
óó 
eStart
óó 
=
óó 
vDel
óó 
.
óó 
_anEdge
óó %
;
óó% &
var
öö 
e
öö 
=
öö 
eStart
öö 
;
öö 
do
õõ 
{
õõ 
e
úú 
.
úú 
_Org
úú 
=
úú 
newOrg
úú 
;
úú  
e
ùù 
=
ùù 
e
ùù 
.
ùù 
_Onext
ùù 
;
ùù 
}
ûû 
while
ûû 
(
ûû 
e
ûû 
!=
ûû 
eStart
ûû  
)
ûû  !
;
ûû! "
var
°° 
vPrev
°° 
=
°° 
vDel
°° 
.
°° 
_prev
°° "
;
°°" #
var
¢¢ 
vNext
¢¢ 
=
¢¢ 
vDel
¢¢ 
.
¢¢ 
_next
¢¢ "
;
¢¢" #
vNext
££ 
.
££ 
_prev
££ 
=
££ 
vPrev
££ 
;
££  
vPrev
§§ 
.
§§ 
_next
§§ 
=
§§ 
vNext
§§ 
;
§§  
vDel
¶¶ 
.
¶¶ 
Free
¶¶ 
(
¶¶ 
)
¶¶ 
;
¶¶ 
}
ßß 	
public
≠≠ 
static
≠≠ 
void
≠≠ 
KillFace
≠≠ #
(
≠≠# $
Face
≠≠$ (
fDel
≠≠) -
,
≠≠- .
Face
≠≠/ 3
newLFace
≠≠4 <
)
≠≠< =
{
ÆÆ 	
var
ØØ 
eStart
ØØ 
=
ØØ 
fDel
ØØ 
.
ØØ 
_anEdge
ØØ %
;
ØØ% &
var
≤≤ 
e
≤≤ 
=
≤≤ 
eStart
≤≤ 
;
≤≤ 
do
≥≥ 
{
≥≥ 
e
¥¥ 
.
¥¥ 
_Lface
¥¥ 
=
¥¥ 
newLFace
¥¥ #
;
¥¥# $
e
µµ 
=
µµ 
e
µµ 
.
µµ 
_Lnext
µµ 
;
µµ 
}
∂∂ 
while
∂∂ 
(
∂∂ 
e
∂∂ 
!=
∂∂ 
eStart
∂∂  
)
∂∂  !
;
∂∂! "
var
ππ 
fPrev
ππ 
=
ππ 
fDel
ππ 
.
ππ 
_prev
ππ "
;
ππ" #
var
∫∫ 
fNext
∫∫ 
=
∫∫ 
fDel
∫∫ 
.
∫∫ 
_next
∫∫ "
;
∫∫" #
fNext
ªª 
.
ªª 
_prev
ªª 
=
ªª 
fPrev
ªª 
;
ªª  
fPrev
ºº 
.
ºº 
_next
ºº 
=
ºº 
fNext
ºº 
;
ºº  
fDel
ææ 
.
ææ 
Free
ææ 
(
ææ 
)
ææ 
;
ææ 
}
øø 	
public
ƒƒ 
static
ƒƒ 
Real
ƒƒ 
FaceArea
ƒƒ #
(
ƒƒ# $
Face
ƒƒ$ (
f
ƒƒ) *
)
ƒƒ* +
{
≈≈ 	
Real
∆∆ 
area
∆∆ 
=
∆∆ 
$num
∆∆ 
;
∆∆ 
var
«« 
e
«« 
=
«« 
f
«« 
.
«« 
_anEdge
«« 
;
«« 
do
»» 
{
…… 
area
   
+=
   
(
   
e
   
.
   
_Org
   
.
    
_s
    "
-
  # $
e
  % &
.
  & '
_Dst
  ' +
.
  + ,
_s
  , .
)
  . /
*
  0 1
(
  2 3
e
  3 4
.
  4 5
_Org
  5 9
.
  9 :
_t
  : <
+
  = >
e
  ? @
.
  @ A
_Dst
  A E
.
  E F
_t
  F H
)
  H I
;
  I J
e
ÀÀ 
=
ÀÀ 
e
ÀÀ 
.
ÀÀ 
_Lnext
ÀÀ 
;
ÀÀ 
}
ÃÃ 
while
ÃÃ 
(
ÃÃ 
e
ÃÃ 
!=
ÃÃ 
f
ÃÃ 
.
ÃÃ 
_anEdge
ÃÃ #
)
ÃÃ# $
;
ÃÃ$ %
return
ÕÕ 
area
ÕÕ 
;
ÕÕ 
}
ŒŒ 	
}
œœ 
}–– 
}““ µ
õD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Light2DStub.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
LWRP- 1
{ 
[ 
Obsolete 
( 
$str k
,k l
truem q
)q r
]r s
public 

class 
Light2D 
{ 
} 
} å£
®D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\External\LibTessDotNet\Mesh.cs
	namespace%% 	
UnityEngine%%
 
.%% 
Experimental%% "
.%%" #
	Rendering%%# ,
.%%, -
	Universal%%- 6
{&& 
	namespace(( 	
LibTessDotNet((
 
{)) 
internal** 
class** 
Mesh** 
:** 
	MeshUtils** #
.**# $
Pooled**$ *
<*** +
Mesh**+ /
>**/ 0
{++ 
internal,, 
	MeshUtils,, 
.,, 
Vertex,, !
_vHead,," (
;,,( )
internal-- 
	MeshUtils-- 
.-- 
Face-- 
_fHead--  &
;--& '
internal.. 
	MeshUtils.. 
... 
Edge.. 
_eHead..  &
,..& '
	_eHeadSym..( 1
;..1 2
public00 
Mesh00 
(00 
)00 
{11 	
var22 
v22 
=22 
_vHead22 
=22 
	MeshUtils22 &
.22& '
Vertex22' -
.22- .
Create22. 4
(224 5
)225 6
;226 7
var33 
f33 
=33 
_fHead33 
=33 
	MeshUtils33 &
.33& '
Face33' +
.33+ ,
Create33, 2
(332 3
)333 4
;334 5
var55 
pair55 
=55 
	MeshUtils55  
.55  !
EdgePair55! )
.55) *
Create55* 0
(550 1
)551 2
;552 3
var66 
e66 
=66 
_eHead66 
=66 
pair66 !
.66! "
_e66" $
;66$ %
var77 
eSym77 
=77 
	_eHeadSym77  
=77! "
pair77# '
.77' (
_eSym77( -
;77- .
v99 
.99 
_next99 
=99 
v99 
.99 
_prev99 
=99 
v99  !
;99! "
v:: 
.:: 
_anEdge:: 
=:: 
null:: 
;:: 
f<< 
.<< 
_next<< 
=<< 
f<< 
.<< 
_prev<< 
=<< 
f<<  !
;<<! "
f== 
.== 
_anEdge== 
=== 
null== 
;== 
f>> 
.>> 
_trail>> 
=>> 
null>> 
;>> 
f?? 
.?? 
_marked?? 
=?? 
false?? 
;?? 
f@@ 
.@@ 
_inside@@ 
=@@ 
false@@ 
;@@ 
eBB 
.BB 
_nextBB 
=BB 
eBB 
;BB 
eCC 
.CC 
_SymCC 
=CC 
eSymCC 
;CC 
eDD 
.DD 
_OnextDD 
=DD 
nullDD 
;DD 
eEE 
.EE 
_LnextEE 
=EE 
nullEE 
;EE 
eFF 
.FF 
_OrgFF 
=FF 
nullFF 
;FF 
eGG 
.GG 
_LfaceGG 
=GG 
nullGG 
;GG 
eHH 
.HH 
_windingHH 
=HH 
$numHH 
;HH 
eII 
.II 
_activeRegionII 
=II 
nullII "
;II" #
eSymKK 
.KK 
_nextKK 
=KK 
eSymKK 
;KK 
eSymLL 
.LL 
_SymLL 
=LL 
eLL 
;LL 
eSymMM 
.MM 
_OnextMM 
=MM 
nullMM 
;MM 
eSymNN 
.NN 
_LnextNN 
=NN 
nullNN 
;NN 
eSymOO 
.OO 
_OrgOO 
=OO 
nullOO 
;OO 
eSymPP 
.PP 
_LfacePP 
=PP 
nullPP 
;PP 
eSymQQ 
.QQ 
_windingQQ 
=QQ 
$numQQ 
;QQ 
eSymRR 
.RR 
_activeRegionRR 
=RR  
nullRR! %
;RR% &
}SS 	
publicUU 
overrideUU 
voidUU 
ResetUU "
(UU" #
)UU# $
{VV 	
_vHeadWW 
=WW 
nullWW 
;WW 
_fHeadXX 
=XX 
nullXX 
;XX 
_eHeadYY 
=YY 
	_eHeadSymYY 
=YY  
nullYY! %
;YY% &
}ZZ 	
public\\ 
override\\ 
void\\ 
OnFree\\ #
(\\# $
)\\$ %
{]] 	
for^^ 
(^^ 
	MeshUtils^^ 
.^^ 
Face^^ 
f^^  !
=^^" #
_fHead^^$ *
.^^* +
_next^^+ 0
,^^0 1
fNext^^2 7
=^^8 9
_fHead^^: @
;^^@ A
f^^B C
!=^^D F
_fHead^^G M
;^^M N
f^^O P
=^^Q R
fNext^^S X
)^^X Y
{__ 
fNext`` 
=`` 
f`` 
.`` 
_next`` 
;``  
faa 
.aa 
Freeaa 
(aa 
)aa 
;aa 
}bb 
forcc 
(cc 
	MeshUtilscc 
.cc 
Vertexcc !
vcc" #
=cc$ %
_vHeadcc& ,
.cc, -
_nextcc- 2
,cc2 3
vNextcc4 9
=cc: ;
_vHeadcc< B
;ccB C
vccD E
!=ccF H
_vHeadccI O
;ccO P
vccQ R
=ccS T
vNextccU Z
)ccZ [
{dd 
vNextee 
=ee 
vee 
.ee 
_nextee 
;ee  
vff 
.ff 
Freeff 
(ff 
)ff 
;ff 
}gg 
forhh 
(hh 
	MeshUtilshh 
.hh 
Edgehh 
ehh  !
=hh" #
_eHeadhh$ *
.hh* +
_nexthh+ 0
,hh0 1
eNexthh2 7
=hh8 9
_eHeadhh: @
;hh@ A
ehhB C
!=hhD F
_eHeadhhG M
;hhM N
ehhO P
=hhQ R
eNexthhS X
)hhX Y
{ii 
eNextjj 
=jj 
ejj 
.jj 
_nextjj 
;jj  
ekk 
.kk 
Freekk 
(kk 
)kk 
;kk 
}ll 
}mm 	
publicss 
	MeshUtilsss 
.ss 
Edgess 
MakeEdgess &
(ss& '
)ss' (
{tt 	
varuu 
euu 
=uu 
	MeshUtilsuu 
.uu 
MakeEdgeuu &
(uu& '
_eHeaduu' -
)uu- .
;uu. /
	MeshUtilsww 
.ww 

MakeVertexww  
(ww  !
eww! "
,ww" #
_vHeadww$ *
)ww* +
;ww+ ,
	MeshUtilsxx 
.xx 

MakeVertexxx  
(xx  !
exx! "
.xx" #
_Symxx# '
,xx' (
_vHeadxx) /
)xx/ 0
;xx0 1
	MeshUtilsyy 
.yy 
MakeFaceyy 
(yy 
eyy  
,yy  !
_fHeadyy" (
)yy( )
;yy) *
return{{ 
e{{ 
;{{ 
}|| 	
public
ññ 
void
ññ 
Splice
ññ 
(
ññ 
	MeshUtils
ññ $
.
ññ$ %
Edge
ññ% )
eOrg
ññ* .
,
ññ. /
	MeshUtils
ññ0 9
.
ññ9 :
Edge
ññ: >
eDst
ññ? C
)
ññC D
{
óó 	
if
òò 
(
òò 
eOrg
òò 
==
òò 
eDst
òò 
)
òò 
{
ôô 
return
öö 
;
öö 
}
õõ 
bool
ùù 
joiningVertices
ùù  
=
ùù! "
false
ùù# (
;
ùù( )
if
ûû 
(
ûû 
eDst
ûû 
.
ûû 
_Org
ûû 
!=
ûû 
eOrg
ûû !
.
ûû! "
_Org
ûû" &
)
ûû& '
{
üü 
joiningVertices
°° 
=
°°  !
true
°°" &
;
°°& '
	MeshUtils
¢¢ 
.
¢¢ 

KillVertex
¢¢ $
(
¢¢$ %
eDst
¢¢% )
.
¢¢) *
_Org
¢¢* .
,
¢¢. /
eOrg
¢¢0 4
.
¢¢4 5
_Org
¢¢5 9
)
¢¢9 :
;
¢¢: ;
}
££ 
bool
§§ 
joiningLoops
§§ 
=
§§ 
false
§§  %
;
§§% &
if
•• 
(
•• 
eDst
•• 
.
•• 
_Lface
•• 
!=
•• 
eOrg
•• #
.
••# $
_Lface
••$ *
)
••* +
{
¶¶ 
joiningLoops
®® 
=
®® 
true
®® #
;
®®# $
	MeshUtils
©© 
.
©© 
KillFace
©© "
(
©©" #
eDst
©©# '
.
©©' (
_Lface
©©( .
,
©©. /
eOrg
©©0 4
.
©©4 5
_Lface
©©5 ;
)
©©; <
;
©©< =
}
™™ 
	MeshUtils
≠≠ 
.
≠≠ 
Splice
≠≠ 
(
≠≠ 
eDst
≠≠ !
,
≠≠! "
eOrg
≠≠# '
)
≠≠' (
;
≠≠( )
if
ØØ 
(
ØØ 
!
ØØ 
joiningVertices
ØØ  
)
ØØ  !
{
∞∞ 
	MeshUtils
≥≥ 
.
≥≥ 

MakeVertex
≥≥ $
(
≥≥$ %
eDst
≥≥% )
,
≥≥) *
eOrg
≥≥+ /
.
≥≥/ 0
_Org
≥≥0 4
)
≥≥4 5
;
≥≥5 6
eOrg
¥¥ 
.
¥¥ 
_Org
¥¥ 
.
¥¥ 
_anEdge
¥¥ !
=
¥¥" #
eOrg
¥¥$ (
;
¥¥( )
}
µµ 
if
∂∂ 
(
∂∂ 
!
∂∂ 
joiningLoops
∂∂ 
)
∂∂ 
{
∑∑ 
	MeshUtils
∫∫ 
.
∫∫ 
MakeFace
∫∫ "
(
∫∫" #
eDst
∫∫# '
,
∫∫' (
eOrg
∫∫) -
.
∫∫- .
_Lface
∫∫. 4
)
∫∫4 5
;
∫∫5 6
eOrg
ªª 
.
ªª 
_Lface
ªª 
.
ªª 
_anEdge
ªª #
=
ªª$ %
eOrg
ªª& *
;
ªª* +
}
ºº 
}
ΩΩ 	
public
∆∆ 
void
∆∆ 
Delete
∆∆ 
(
∆∆ 
	MeshUtils
∆∆ $
.
∆∆$ %
Edge
∆∆% )
eDel
∆∆* .
)
∆∆. /
{
«« 	
var
»» 
eDelSym
»» 
=
»» 
eDel
»» 
.
»» 
_Sym
»» #
;
»»# $
bool
ÕÕ 
joiningLoops
ÕÕ 
=
ÕÕ 
false
ÕÕ  %
;
ÕÕ% &
if
ŒŒ 
(
ŒŒ 
eDel
ŒŒ 
.
ŒŒ 
_Lface
ŒŒ 
!=
ŒŒ 
eDel
ŒŒ #
.
ŒŒ# $
_Rface
ŒŒ$ *
)
ŒŒ* +
{
œœ 
joiningLoops
—— 
=
—— 
true
—— #
;
——# $
	MeshUtils
““ 
.
““ 
KillFace
““ "
(
““" #
eDel
““# '
.
““' (
_Lface
““( .
,
““. /
eDel
““0 4
.
““4 5
_Rface
““5 ;
)
““; <
;
““< =
}
”” 
if
’’ 
(
’’ 
eDel
’’ 
.
’’ 
_Onext
’’ 
==
’’ 
eDel
’’ #
)
’’# $
{
÷÷ 
	MeshUtils
◊◊ 
.
◊◊ 

KillVertex
◊◊ $
(
◊◊$ %
eDel
◊◊% )
.
◊◊) *
_Org
◊◊* .
,
◊◊. /
null
◊◊0 4
)
◊◊4 5
;
◊◊5 6
}
ÿÿ 
else
ŸŸ 
{
⁄⁄ 
eDel
‹‹ 
.
‹‹ 
_Rface
‹‹ 
.
‹‹ 
_anEdge
‹‹ #
=
‹‹$ %
eDel
‹‹& *
.
‹‹* +
_Oprev
‹‹+ 1
;
‹‹1 2
eDel
›› 
.
›› 
_Org
›› 
.
›› 
_anEdge
›› !
=
››" #
eDel
››$ (
.
››( )
_Onext
››) /
;
››/ 0
	MeshUtils
ﬂﬂ 
.
ﬂﬂ 
Splice
ﬂﬂ  
(
ﬂﬂ  !
eDel
ﬂﬂ! %
,
ﬂﬂ% &
eDel
ﬂﬂ' +
.
ﬂﬂ+ ,
_Oprev
ﬂﬂ, 2
)
ﬂﬂ2 3
;
ﬂﬂ3 4
if
·· 
(
·· 
!
·· 
joiningLoops
·· !
)
··! "
{
‚‚ 
	MeshUtils
‰‰ 
.
‰‰ 
MakeFace
‰‰ &
(
‰‰& '
eDel
‰‰' +
,
‰‰+ ,
eDel
‰‰- 1
.
‰‰1 2
_Lface
‰‰2 8
)
‰‰8 9
;
‰‰9 :
}
ÂÂ 
}
ÊÊ 
if
ÎÎ 
(
ÎÎ 
eDelSym
ÎÎ 
.
ÎÎ 
_Onext
ÎÎ 
==
ÎÎ !
eDelSym
ÎÎ" )
)
ÎÎ) *
{
ÏÏ 
	MeshUtils
ÌÌ 
.
ÌÌ 

KillVertex
ÌÌ $
(
ÌÌ$ %
eDelSym
ÌÌ% ,
.
ÌÌ, -
_Org
ÌÌ- 1
,
ÌÌ1 2
null
ÌÌ3 7
)
ÌÌ7 8
;
ÌÌ8 9
	MeshUtils
ÓÓ 
.
ÓÓ 
KillFace
ÓÓ "
(
ÓÓ" #
eDelSym
ÓÓ# *
.
ÓÓ* +
_Lface
ÓÓ+ 1
,
ÓÓ1 2
null
ÓÓ3 7
)
ÓÓ7 8
;
ÓÓ8 9
}
ÔÔ 
else
 
{
ÒÒ 
eDel
ÛÛ 
.
ÛÛ 
_Lface
ÛÛ 
.
ÛÛ 
_anEdge
ÛÛ #
=
ÛÛ$ %
eDelSym
ÛÛ& -
.
ÛÛ- .
_Oprev
ÛÛ. 4
;
ÛÛ4 5
eDelSym
ÙÙ 
.
ÙÙ 
_Org
ÙÙ 
.
ÙÙ 
_anEdge
ÙÙ $
=
ÙÙ% &
eDelSym
ÙÙ' .
.
ÙÙ. /
_Onext
ÙÙ/ 5
;
ÙÙ5 6
	MeshUtils
ıı 
.
ıı 
Splice
ıı  
(
ıı  !
eDelSym
ıı! (
,
ıı( )
eDelSym
ıı* 1
.
ıı1 2
_Oprev
ıı2 8
)
ıı8 9
;
ıı9 :
}
ˆˆ 
	MeshUtils
˘˘ 
.
˘˘ 
KillEdge
˘˘ 
(
˘˘ 
eDel
˘˘ #
)
˘˘# $
;
˘˘$ %
}
˙˙ 	
public
ÄÄ 
	MeshUtils
ÄÄ 
.
ÄÄ 
Edge
ÄÄ 
AddEdgeVertex
ÄÄ +
(
ÄÄ+ ,
	MeshUtils
ÄÄ, 5
.
ÄÄ5 6
Edge
ÄÄ6 :
eOrg
ÄÄ; ?
)
ÄÄ? @
{
ÅÅ 	
var
ÇÇ 
eNew
ÇÇ 
=
ÇÇ 
	MeshUtils
ÇÇ  
.
ÇÇ  !
MakeEdge
ÇÇ! )
(
ÇÇ) *
eOrg
ÇÇ* .
)
ÇÇ. /
;
ÇÇ/ 0
var
ÉÉ 
eNewSym
ÉÉ 
=
ÉÉ 
eNew
ÉÉ 
.
ÉÉ 
_Sym
ÉÉ #
;
ÉÉ# $
	MeshUtils
ÜÜ 
.
ÜÜ 
Splice
ÜÜ 
(
ÜÜ 
eNew
ÜÜ !
,
ÜÜ! "
eOrg
ÜÜ# '
.
ÜÜ' (
_Lnext
ÜÜ( .
)
ÜÜ. /
;
ÜÜ/ 0
eNew
ââ 
.
ââ 
_Org
ââ 
=
ââ 
eOrg
ââ 
.
ââ 
_Dst
ââ !
;
ââ! "
	MeshUtils
ää 
.
ää 

MakeVertex
ää  
(
ää  !
eNewSym
ää! (
,
ää( )
eNew
ää* .
.
ää. /
_Org
ää/ 3
)
ää3 4
;
ää4 5
eNew
ãã 
.
ãã 
_Lface
ãã 
=
ãã 
eNewSym
ãã !
.
ãã! "
_Lface
ãã" (
=
ãã) *
eOrg
ãã+ /
.
ãã/ 0
_Lface
ãã0 6
;
ãã6 7
return
çç 
eNew
çç 
;
çç 
}
éé 	
public
ïï 
	MeshUtils
ïï 
.
ïï 
Edge
ïï 
	SplitEdge
ïï '
(
ïï' (
	MeshUtils
ïï( 1
.
ïï1 2
Edge
ïï2 6
eOrg
ïï7 ;
)
ïï; <
{
ññ 	
var
óó 
eTmp
óó 
=
óó 
AddEdgeVertex
óó $
(
óó$ %
eOrg
óó% )
)
óó) *
;
óó* +
var
òò 
eNew
òò 
=
òò 
eTmp
òò 
.
òò 
_Sym
òò  
;
òò  !
	MeshUtils
õõ 
.
õõ 
Splice
õõ 
(
õõ 
eOrg
õõ !
.
õõ! "
_Sym
õõ" &
,
õõ& '
eOrg
õõ( ,
.
õõ, -
_Sym
õõ- 1
.
õõ1 2
_Oprev
õõ2 8
)
õõ8 9
;
õõ9 :
	MeshUtils
úú 
.
úú 
Splice
úú 
(
úú 
eOrg
úú !
.
úú! "
_Sym
úú" &
,
úú& '
eNew
úú( ,
)
úú, -
;
úú- .
eOrg
üü 
.
üü 
_Dst
üü 
=
üü 
eNew
üü 
.
üü 
_Org
üü !
;
üü! "
eNew
†† 
.
†† 
_Dst
†† 
.
†† 
_anEdge
†† 
=
†† 
eNew
††  $
.
††$ %
_Sym
††% )
;
††) *
eNew
°° 
.
°° 
_Rface
°° 
=
°° 
eOrg
°° 
.
°° 
_Rface
°° %
;
°°% &
eNew
¢¢ 
.
¢¢ 
_winding
¢¢ 
=
¢¢ 
eOrg
¢¢  
.
¢¢  !
_winding
¢¢! )
;
¢¢) *
eNew
££ 
.
££ 
_Sym
££ 
.
££ 
_winding
££ 
=
££  
eOrg
££! %
.
££% &
_Sym
££& *
.
££* +
_winding
££+ 3
;
££3 4
return
•• 
eNew
•• 
;
•• 
}
¶¶ 	
public
≤≤ 
	MeshUtils
≤≤ 
.
≤≤ 
Edge
≤≤ 
Connect
≤≤ %
(
≤≤% &
	MeshUtils
≤≤& /
.
≤≤/ 0
Edge
≤≤0 4
eOrg
≤≤5 9
,
≤≤9 :
	MeshUtils
≤≤; D
.
≤≤D E
Edge
≤≤E I
eDst
≤≤J N
)
≤≤N O
{
≥≥ 	
var
¥¥ 
eNew
¥¥ 
=
¥¥ 
	MeshUtils
¥¥  
.
¥¥  !
MakeEdge
¥¥! )
(
¥¥) *
eOrg
¥¥* .
)
¥¥. /
;
¥¥/ 0
var
µµ 
eNewSym
µµ 
=
µµ 
eNew
µµ 
.
µµ 
_Sym
µµ #
;
µµ# $
bool
∑∑ 
joiningLoops
∑∑ 
=
∑∑ 
false
∑∑  %
;
∑∑% &
if
∏∏ 
(
∏∏ 
eDst
∏∏ 
.
∏∏ 
_Lface
∏∏ 
!=
∏∏ 
eOrg
∏∏ #
.
∏∏# $
_Lface
∏∏$ *
)
∏∏* +
{
ππ 
joiningLoops
ªª 
=
ªª 
true
ªª #
;
ªª# $
	MeshUtils
ºº 
.
ºº 
KillFace
ºº "
(
ºº" #
eDst
ºº# '
.
ºº' (
_Lface
ºº( .
,
ºº. /
eOrg
ºº0 4
.
ºº4 5
_Lface
ºº5 ;
)
ºº; <
;
ºº< =
}
ΩΩ 
	MeshUtils
¿¿ 
.
¿¿ 
Splice
¿¿ 
(
¿¿ 
eNew
¿¿ !
,
¿¿! "
eOrg
¿¿# '
.
¿¿' (
_Lnext
¿¿( .
)
¿¿. /
;
¿¿/ 0
	MeshUtils
¡¡ 
.
¡¡ 
Splice
¡¡ 
(
¡¡ 
eNewSym
¡¡ $
,
¡¡$ %
eDst
¡¡& *
)
¡¡* +
;
¡¡+ ,
eNew
ƒƒ 
.
ƒƒ 
_Org
ƒƒ 
=
ƒƒ 
eOrg
ƒƒ 
.
ƒƒ 
_Dst
ƒƒ !
;
ƒƒ! "
eNewSym
≈≈ 
.
≈≈ 
_Org
≈≈ 
=
≈≈ 
eDst
≈≈ 
.
≈≈  
_Org
≈≈  $
;
≈≈$ %
eNew
∆∆ 
.
∆∆ 
_Lface
∆∆ 
=
∆∆ 
eNewSym
∆∆ !
.
∆∆! "
_Lface
∆∆" (
=
∆∆) *
eOrg
∆∆+ /
.
∆∆/ 0
_Lface
∆∆0 6
;
∆∆6 7
eOrg
…… 
.
…… 
_Lface
…… 
.
…… 
_anEdge
…… 
=
……  !
eNewSym
……" )
;
……) *
if
ÀÀ 
(
ÀÀ 
!
ÀÀ 
joiningLoops
ÀÀ 
)
ÀÀ 
{
ÃÃ 
	MeshUtils
ÕÕ 
.
ÕÕ 
MakeFace
ÕÕ "
(
ÕÕ" #
eNew
ÕÕ# '
,
ÕÕ' (
eOrg
ÕÕ) -
.
ÕÕ- .
_Lface
ÕÕ. 4
)
ÕÕ4 5
;
ÕÕ5 6
}
ŒŒ 
return
–– 
eNew
–– 
;
–– 
}
—— 	
public
€€ 
void
€€ 
ZapFace
€€ 
(
€€ 
	MeshUtils
€€ %
.
€€% &
Face
€€& *
fZap
€€+ /
)
€€/ 0
{
‹‹ 	
var
›› 
eStart
›› 
=
›› 
fZap
›› 
.
›› 
_anEdge
›› %
;
››% &
var
‡‡ 
eNext
‡‡ 
=
‡‡ 
eStart
‡‡ 
.
‡‡ 
_Lnext
‡‡ %
;
‡‡% &
	MeshUtils
·· 
.
·· 
Edge
·· 
e
·· 
,
·· 
eSym
·· "
;
··" #
do
‚‚ 
{
‚‚ 
e
„„ 
=
„„ 
eNext
„„ 
;
„„ 
eNext
‰‰ 
=
‰‰ 
e
‰‰ 
.
‰‰ 
_Lnext
‰‰  
;
‰‰  !
e
ÊÊ 
.
ÊÊ 
_Lface
ÊÊ 
=
ÊÊ 
null
ÊÊ 
;
ÊÊ  
if
ÁÁ 
(
ÁÁ 
e
ÁÁ 
.
ÁÁ 
_Rface
ÁÁ 
==
ÁÁ 
null
ÁÁ  $
)
ÁÁ$ %
{
ËË 
if
ÎÎ 
(
ÎÎ 
e
ÎÎ 
.
ÎÎ 
_Onext
ÎÎ  
==
ÎÎ! #
e
ÎÎ$ %
)
ÎÎ% &
{
ÏÏ 
	MeshUtils
ÌÌ !
.
ÌÌ! "

KillVertex
ÌÌ" ,
(
ÌÌ, -
e
ÌÌ- .
.
ÌÌ. /
_Org
ÌÌ/ 3
,
ÌÌ3 4
null
ÌÌ5 9
)
ÌÌ9 :
;
ÌÌ: ;
}
ÓÓ 
else
ÔÔ 
{
 
e
ÚÚ 
.
ÚÚ 
_Org
ÚÚ 
.
ÚÚ 
_anEdge
ÚÚ &
=
ÚÚ' (
e
ÚÚ) *
.
ÚÚ* +
_Onext
ÚÚ+ 1
;
ÚÚ1 2
	MeshUtils
ÛÛ !
.
ÛÛ! "
Splice
ÛÛ" (
(
ÛÛ( )
e
ÛÛ) *
,
ÛÛ* +
e
ÛÛ, -
.
ÛÛ- .
_Oprev
ÛÛ. 4
)
ÛÛ4 5
;
ÛÛ5 6
}
ÙÙ 
eSym
ıı 
=
ıı 
e
ıı 
.
ıı 
_Sym
ıı !
;
ıı! "
if
ˆˆ 
(
ˆˆ 
eSym
ˆˆ 
.
ˆˆ 
_Onext
ˆˆ #
==
ˆˆ$ &
eSym
ˆˆ' +
)
ˆˆ+ ,
{
˜˜ 
	MeshUtils
¯¯ !
.
¯¯! "

KillVertex
¯¯" ,
(
¯¯, -
eSym
¯¯- 1
.
¯¯1 2
_Org
¯¯2 6
,
¯¯6 7
null
¯¯8 <
)
¯¯< =
;
¯¯= >
}
˘˘ 
else
˙˙ 
{
˚˚ 
eSym
˝˝ 
.
˝˝ 
_Org
˝˝ !
.
˝˝! "
_anEdge
˝˝" )
=
˝˝* +
eSym
˝˝, 0
.
˝˝0 1
_Onext
˝˝1 7
;
˝˝7 8
	MeshUtils
˛˛ !
.
˛˛! "
Splice
˛˛" (
(
˛˛( )
eSym
˛˛) -
,
˛˛- .
eSym
˛˛/ 3
.
˛˛3 4
_Oprev
˛˛4 :
)
˛˛: ;
;
˛˛; <
}
ˇˇ 
	MeshUtils
ÄÄ 
.
ÄÄ 
KillEdge
ÄÄ &
(
ÄÄ& '
e
ÄÄ' (
)
ÄÄ( )
;
ÄÄ) *
}
ÅÅ 
}
ÇÇ 
while
ÇÇ 
(
ÇÇ 
e
ÇÇ 
!=
ÇÇ 
eStart
ÇÇ  
)
ÇÇ  !
;
ÇÇ! "
var
ÖÖ 
fPrev
ÖÖ 
=
ÖÖ 
fZap
ÖÖ 
.
ÖÖ 
_prev
ÖÖ "
;
ÖÖ" #
var
ÜÜ 
fNext
ÜÜ 
=
ÜÜ 
fZap
ÜÜ 
.
ÜÜ 
_next
ÜÜ "
;
ÜÜ" #
fNext
áá 
.
áá 
_prev
áá 
=
áá 
fPrev
áá 
;
áá  
fPrev
àà 
.
àà 
_next
àà 
=
àà 
fNext
àà 
;
àà  
fZap
ää 
.
ää 
Free
ää 
(
ää 
)
ää 
;
ää 
}
ãã 	
public
çç 
void
çç 
MergeConvexFaces
çç $
(
çç$ %
int
çç% (
maxVertsPerFace
çç) 8
)
çç8 9
{
éé 	
for
èè 
(
èè 
var
èè 
f
èè 
=
èè 
_fHead
èè 
.
èè  
_next
èè  %
;
èè% &
f
èè' (
!=
èè) +
_fHead
èè, 2
;
èè2 3
f
èè4 5
=
èè6 7
f
èè8 9
.
èè9 :
_next
èè: ?
)
èè? @
{
êê 
if
íí 
(
íí 
!
íí 
f
íí 
.
íí 
_inside
íí 
)
íí 
{
ìì 
continue
îî 
;
îî 
}
ïï 
var
óó 
eCur
óó 
=
óó 
f
óó 
.
óó 
_anEdge
óó $
;
óó$ %
var
òò 
vStart
òò 
=
òò 
eCur
òò !
.
òò! "
_Org
òò" &
;
òò& '
while
öö 
(
öö 
true
öö 
)
öö 
{
õõ 
var
úú 
eNext
úú 
=
úú 
eCur
úú  $
.
úú$ %
_Lnext
úú% +
;
úú+ ,
var
ùù 
eSym
ùù 
=
ùù 
eCur
ùù #
.
ùù# $
_Sym
ùù$ (
;
ùù( )
if
üü 
(
üü 
eSym
üü 
!=
üü 
null
üü  $
&&
üü% '
eSym
üü( ,
.
üü, -
_Lface
üü- 3
!=
üü4 6
null
üü7 ;
&&
üü< >
eSym
üü? C
.
üüC D
_Lface
üüD J
.
üüJ K
_inside
üüK R
)
üüR S
{
†† 
int
££ 
curNv
££ !
=
££" #
f
££$ %
.
££% &

VertsCount
££& 0
;
££0 1
int
§§ 
symNv
§§ !
=
§§" #
eSym
§§$ (
.
§§( )
_Lface
§§) /
.
§§/ 0

VertsCount
§§0 :
;
§§: ;
if
•• 
(
•• 
(
•• 
curNv
•• "
+
••# $
symNv
••% *
-
••+ ,
$num
••- .
)
••. /
<=
••0 2
maxVertsPerFace
••3 B
)
••B C
{
¶¶ 
if
®® 
(
®®  
Geom
®®  $
.
®®$ %
VertCCW
®®% ,
(
®®, -
eCur
®®- 1
.
®®1 2
_Lprev
®®2 8
.
®®8 9
_Org
®®9 =
,
®®= >
eCur
®®? C
.
®®C D
_Org
®®D H
,
®®H I
eSym
®®J N
.
®®N O
_Lnext
®®O U
.
®®U V
_Lnext
®®V \
.
®®\ ]
_Org
®®] a
)
®®a b
&&
®®c e
Geom
©©  $
.
©©$ %
VertCCW
©©% ,
(
©©, -
eSym
©©- 1
.
©©1 2
_Lprev
©©2 8
.
©©8 9
_Org
©©9 =
,
©©= >
eSym
©©? C
.
©©C D
_Org
©©D H
,
©©H I
eCur
©©J N
.
©©N O
_Lnext
©©O U
.
©©U V
_Lnext
©©V \
.
©©\ ]
_Org
©©] a
)
©©a b
)
©©b c
{
™™ 
eNext
´´  %
=
´´& '
eSym
´´( ,
.
´´, -
_Lnext
´´- 3
;
´´3 4
Delete
¨¨  &
(
¨¨& '
eSym
¨¨' +
)
¨¨+ ,
;
¨¨, -
eCur
≠≠  $
=
≠≠% &
null
≠≠' +
;
≠≠+ ,
}
ÆÆ 
}
ØØ 
}
∞∞ 
if
≤≤ 
(
≤≤ 
eCur
≤≤ 
!=
≤≤ 
null
≤≤  $
&&
≤≤% '
eCur
≤≤( ,
.
≤≤, -
_Lnext
≤≤- 3
.
≤≤3 4
_Org
≤≤4 8
==
≤≤9 ;
vStart
≤≤< B
)
≤≤B C
break
≥≥ 
;
≥≥ 
eCur
∂∂ 
=
∂∂ 
eNext
∂∂  
;
∂∂  !
}
∑∑ 
}
∏∏ 
}
ππ 	
[
ªª 	
Conditional
ªª	 
(
ªª 
$str
ªª 
)
ªª 
]
ªª 
public
ºº 
void
ºº 
Check
ºº 
(
ºº 
)
ºº 
{
ΩΩ 	
	MeshUtils
ææ 
.
ææ 
Edge
ææ 
e
ææ 
;
ææ 
	MeshUtils
¿¿ 
.
¿¿ 
Face
¿¿ 
fPrev
¿¿  
=
¿¿! "
_fHead
¿¿# )
,
¿¿) *
f
¿¿+ ,
;
¿¿, -
for
¡¡ 
(
¡¡ 
fPrev
¡¡ 
=
¡¡ 
_fHead
¡¡ 
;
¡¡  
(
¡¡! "
f
¡¡" #
=
¡¡$ %
fPrev
¡¡& +
.
¡¡+ ,
_next
¡¡, 1
)
¡¡1 2
!=
¡¡3 5
_fHead
¡¡6 <
;
¡¡< =
fPrev
¡¡> C
=
¡¡D E
f
¡¡F G
)
¡¡G H
{
¬¬ 
e
√√ 
=
√√ 
f
√√ 
.
√√ 
_anEdge
√√ 
;
√√ 
do
ƒƒ 
{
ƒƒ 
Debug
≈≈ 
.
≈≈ 
Assert
≈≈  
(
≈≈  !
e
≈≈! "
.
≈≈" #
_Sym
≈≈# '
!=
≈≈( *
e
≈≈+ ,
)
≈≈, -
;
≈≈- .
Debug
∆∆ 
.
∆∆ 
Assert
∆∆  
(
∆∆  !
e
∆∆! "
.
∆∆" #
_Sym
∆∆# '
.
∆∆' (
_Sym
∆∆( ,
==
∆∆- /
e
∆∆0 1
)
∆∆1 2
;
∆∆2 3
Debug
«« 
.
«« 
Assert
««  
(
««  !
e
««! "
.
««" #
_Lnext
««# )
.
««) *
_Onext
««* 0
.
««0 1
_Sym
««1 5
==
««6 8
e
««9 :
)
««: ;
;
««; <
Debug
»» 
.
»» 
Assert
»»  
(
»»  !
e
»»! "
.
»»" #
_Onext
»»# )
.
»») *
_Sym
»»* .
.
»». /
_Lnext
»»/ 5
==
»»6 8
e
»»9 :
)
»»: ;
;
»»; <
Debug
…… 
.
…… 
Assert
……  
(
……  !
e
……! "
.
……" #
_Lface
……# )
==
……* ,
f
……- .
)
……. /
;
……/ 0
e
   
=
   
e
   
.
   
_Lnext
    
;
    !
}
ÀÀ 
while
ÀÀ 
(
ÀÀ 
e
ÀÀ 
!=
ÀÀ 
f
ÀÀ 
.
ÀÀ  
_anEdge
ÀÀ  '
)
ÀÀ' (
;
ÀÀ( )
}
ÃÃ 
Debug
ÕÕ 
.
ÕÕ 
Assert
ÕÕ 
(
ÕÕ 
f
ÕÕ 
.
ÕÕ 
_prev
ÕÕ  
==
ÕÕ! #
fPrev
ÕÕ$ )
&&
ÕÕ* ,
f
ÕÕ- .
.
ÕÕ. /
_anEdge
ÕÕ/ 6
==
ÕÕ7 9
null
ÕÕ: >
)
ÕÕ> ?
;
ÕÕ? @
	MeshUtils
œœ 
.
œœ 
Vertex
œœ 
vPrev
œœ "
=
œœ# $
_vHead
œœ% +
,
œœ+ ,
v
œœ- .
;
œœ. /
for
–– 
(
–– 
vPrev
–– 
=
–– 
_vHead
–– 
;
––  
(
––! "
v
––" #
=
––$ %
vPrev
––& +
.
––+ ,
_next
––, 1
)
––1 2
!=
––3 5
_vHead
––6 <
;
––< =
vPrev
––> C
=
––D E
v
––F G
)
––G H
{
—— 
Debug
““ 
.
““ 
Assert
““ 
(
““ 
v
““ 
.
““ 
_prev
““ $
==
““% '
vPrev
““( -
)
““- .
;
““. /
e
”” 
=
”” 
v
”” 
.
”” 
_anEdge
”” 
;
”” 
do
‘‘ 
{
’’ 
Debug
÷÷ 
.
÷÷ 
Assert
÷÷  
(
÷÷  !
e
÷÷! "
.
÷÷" #
_Sym
÷÷# '
!=
÷÷( *
e
÷÷+ ,
)
÷÷, -
;
÷÷- .
Debug
◊◊ 
.
◊◊ 
Assert
◊◊  
(
◊◊  !
e
◊◊! "
.
◊◊" #
_Sym
◊◊# '
.
◊◊' (
_Sym
◊◊( ,
==
◊◊- /
e
◊◊0 1
)
◊◊1 2
;
◊◊2 3
Debug
ÿÿ 
.
ÿÿ 
Assert
ÿÿ  
(
ÿÿ  !
e
ÿÿ! "
.
ÿÿ" #
_Lnext
ÿÿ# )
.
ÿÿ) *
_Onext
ÿÿ* 0
.
ÿÿ0 1
_Sym
ÿÿ1 5
==
ÿÿ6 8
e
ÿÿ9 :
)
ÿÿ: ;
;
ÿÿ; <
Debug
ŸŸ 
.
ŸŸ 
Assert
ŸŸ  
(
ŸŸ  !
e
ŸŸ! "
.
ŸŸ" #
_Onext
ŸŸ# )
.
ŸŸ) *
_Sym
ŸŸ* .
.
ŸŸ. /
_Lnext
ŸŸ/ 5
==
ŸŸ6 8
e
ŸŸ9 :
)
ŸŸ: ;
;
ŸŸ; <
Debug
⁄⁄ 
.
⁄⁄ 
Assert
⁄⁄  
(
⁄⁄  !
e
⁄⁄! "
.
⁄⁄" #
_Org
⁄⁄# '
==
⁄⁄( *
v
⁄⁄+ ,
)
⁄⁄, -
;
⁄⁄- .
e
€€ 
=
€€ 
e
€€ 
.
€€ 
_Onext
€€  
;
€€  !
}
‹‹ 
while
‹‹ 
(
‹‹ 
e
‹‹ 
!=
‹‹ 
v
‹‹ 
.
‹‹  
_anEdge
‹‹  '
)
‹‹' (
;
‹‹( )
}
›› 
Debug
ﬁﬁ 
.
ﬁﬁ 
Assert
ﬁﬁ 
(
ﬁﬁ 
v
ﬁﬁ 
.
ﬁﬁ 
_prev
ﬁﬁ  
==
ﬁﬁ! #
vPrev
ﬁﬁ$ )
&&
ﬁﬁ* ,
v
ﬁﬁ- .
.
ﬁﬁ. /
_anEdge
ﬁﬁ/ 6
==
ﬁﬁ7 9
null
ﬁﬁ: >
)
ﬁﬁ> ?
;
ﬁﬁ? @
	MeshUtils
‡‡ 
.
‡‡ 
Edge
‡‡ 
ePrev
‡‡  
=
‡‡! "
_eHead
‡‡# )
;
‡‡) *
for
·· 
(
·· 
ePrev
·· 
=
·· 
_eHead
·· 
;
··  
(
··! "
e
··" #
=
··$ %
ePrev
··& +
.
··+ ,
_next
··, 1
)
··1 2
!=
··3 5
_eHead
··6 <
;
··< =
ePrev
··> C
=
··D E
e
··F G
)
··G H
{
‚‚ 
Debug
„„ 
.
„„ 
Assert
„„ 
(
„„ 
e
„„ 
.
„„ 
_Sym
„„ #
.
„„# $
_next
„„$ )
==
„„* ,
ePrev
„„- 2
.
„„2 3
_Sym
„„3 7
)
„„7 8
;
„„8 9
Debug
‰‰ 
.
‰‰ 
Assert
‰‰ 
(
‰‰ 
e
‰‰ 
.
‰‰ 
_Sym
‰‰ #
!=
‰‰$ &
e
‰‰' (
)
‰‰( )
;
‰‰) *
Debug
ÂÂ 
.
ÂÂ 
Assert
ÂÂ 
(
ÂÂ 
e
ÂÂ 
.
ÂÂ 
_Sym
ÂÂ #
.
ÂÂ# $
_Sym
ÂÂ$ (
==
ÂÂ) +
e
ÂÂ, -
)
ÂÂ- .
;
ÂÂ. /
Debug
ÊÊ 
.
ÊÊ 
Assert
ÊÊ 
(
ÊÊ 
e
ÊÊ 
.
ÊÊ 
_Org
ÊÊ #
!=
ÊÊ$ &
null
ÊÊ' +
)
ÊÊ+ ,
;
ÊÊ, -
Debug
ÁÁ 
.
ÁÁ 
Assert
ÁÁ 
(
ÁÁ 
e
ÁÁ 
.
ÁÁ 
_Dst
ÁÁ #
!=
ÁÁ$ &
null
ÁÁ' +
)
ÁÁ+ ,
;
ÁÁ, -
Debug
ËË 
.
ËË 
Assert
ËË 
(
ËË 
e
ËË 
.
ËË 
_Lnext
ËË %
.
ËË% &
_Onext
ËË& ,
.
ËË, -
_Sym
ËË- 1
==
ËË2 4
e
ËË5 6
)
ËË6 7
;
ËË7 8
Debug
ÈÈ 
.
ÈÈ 
Assert
ÈÈ 
(
ÈÈ 
e
ÈÈ 
.
ÈÈ 
_Onext
ÈÈ %
.
ÈÈ% &
_Sym
ÈÈ& *
.
ÈÈ* +
_Lnext
ÈÈ+ 1
==
ÈÈ2 4
e
ÈÈ5 6
)
ÈÈ6 7
;
ÈÈ7 8
}
ÍÍ 
Debug
ÎÎ 
.
ÎÎ 
Assert
ÎÎ 
(
ÎÎ 
e
ÎÎ 
.
ÎÎ 
_Sym
ÎÎ 
.
ÎÎ  
_next
ÎÎ  %
==
ÎÎ& (
ePrev
ÎÎ) .
.
ÎÎ. /
_Sym
ÎÎ/ 3
&&
ÏÏ 
e
ÏÏ 
.
ÏÏ 
_Sym
ÏÏ 
==
ÏÏ 
	_eHeadSym
ÏÏ &
&&
ÌÌ 
e
ÌÌ 
.
ÌÌ 
_Sym
ÌÌ 
.
ÌÌ 
_Sym
ÌÌ 
==
ÌÌ !
e
ÌÌ" #
&&
ÓÓ 
e
ÓÓ 
.
ÓÓ 
_Org
ÓÓ 
==
ÓÓ 
null
ÓÓ !
&&
ÓÓ" $
e
ÓÓ% &
.
ÓÓ& '
_Dst
ÓÓ' +
==
ÓÓ, .
null
ÓÓ/ 3
&&
ÔÔ 
e
ÔÔ 
.
ÔÔ 
_Lface
ÔÔ 
==
ÔÔ 
null
ÔÔ #
&&
ÔÔ$ &
e
ÔÔ' (
.
ÔÔ( )
_Rface
ÔÔ) /
==
ÔÔ0 2
null
ÔÔ3 7
)
ÔÔ7 8
;
ÔÔ8 9
}
 	
}
ÒÒ 
}ÚÚ 
}ÙÙ ã
¥D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\InvokeOnRenderObjectCallbackPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
internal 
class ,
 InvokeOnRenderObjectCallbackPass 3
:4 5 
ScriptableRenderPass6 J
{ 
public		 ,
 InvokeOnRenderObjectCallbackPass		 /
(		/ 0
RenderPassEvent		0 ?
evt		@ C
)		C D
{

 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @,
 InvokeOnRenderObjectCallbackPass@ `
)` a
)a b
;b c
renderPassEvent 
= 
evt !
;! "
} 	
public 
override 
void 
Execute $
($ %#
ScriptableRenderContext% <
context= D
,D E
refF I
RenderingDataJ W
renderingDataX e
)e f
{ 	
context 
. (
InvokeOnRenderObjectCallback 0
(0 1
)1 2
;2 3
} 	
} 
} ˝ã
≠D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\MainLightShadowCasterPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
public 

class %
MainLightShadowCasterPass *
:+ , 
ScriptableRenderPass- A
{		 
private

 
static

 
class

 )
MainLightShadowConstantBuffer

 :
{ 	
public 
static 
int 
_WorldToShadow ,
;, -
public 
static 
int 
_ShadowParams +
;+ ,
public 
static 
int '
_CascadeShadowSplitSpheres0 9
;9 :
public 
static 
int '
_CascadeShadowSplitSpheres1 9
;9 :
public 
static 
int '
_CascadeShadowSplitSpheres2 9
;9 :
public 
static 
int '
_CascadeShadowSplitSpheres3 9
;9 :
public 
static 
int *
_CascadeShadowSplitSphereRadii <
;< =
public 
static 
int 
_ShadowOffset0 ,
;, -
public 
static 
int 
_ShadowOffset1 ,
;, -
public 
static 
int 
_ShadowOffset2 ,
;, -
public 
static 
int 
_ShadowOffset3 ,
;, -
public 
static 
int 
_ShadowmapSize ,
;, -
} 	
const 
int 
k_MaxCascades 
=  !
$num" #
;# $
const 
int !
k_ShadowmapBufferBits '
=( )
$num* ,
;, -
float 
m_MaxShadowDistance !
;! "
int 
m_ShadowmapWidth 
; 
int 
m_ShadowmapHeight 
; 
int '
m_ShadowCasterCascadesCount '
;' (
bool   )
m_SupportsBoxFilterForShadows   *
;  * +
RenderTargetHandle""  
m_MainLightShadowmap"" /
;""/ 0
RenderTexture## '
m_MainLightShadowmapTexture## 1
;##1 2
	Matrix4x4%% 
[%% 
]%% %
m_MainLightShadowMatrices%% -
;%%- .
ShadowSliceData&& 
[&& 
]&& 
m_CascadeSlices&& )
;&&) *
Vector4'' 
['' 
]'' #
m_CascadeSplitDistances'' )
;'') *
ProfilingSampler)) #
m_ProfilingSetupSampler)) 0
=))1 2
new))3 6
ProfilingSampler))7 G
())G H
$str))H ^
)))^ _
;))_ `
public++ %
MainLightShadowCasterPass++ (
(++( )
RenderPassEvent++) 8
evt++9 <
)++< =
{,, 	
base-- 
.-- 
profilingSampler-- !
=--" #
new--$ '
ProfilingSampler--( 8
(--8 9
nameof--9 ?
(--? @%
MainLightShadowCasterPass--@ Y
)--Y Z
)--Z [
;--[ \
renderPassEvent.. 
=.. 
evt.. !
;..! "%
m_MainLightShadowMatrices00 %
=00& '
new00( +
	Matrix4x400, 5
[005 6
k_MaxCascades006 C
+00D E
$num00F G
]00G H
;00H I
m_CascadeSlices11 
=11 
new11 !
ShadowSliceData11" 1
[111 2
k_MaxCascades112 ?
]11? @
;11@ A#
m_CascadeSplitDistances22 #
=22$ %
new22& )
Vector422* 1
[221 2
k_MaxCascades222 ?
]22? @
;22@ A)
MainLightShadowConstantBuffer44 )
.44) *
_WorldToShadow44* 8
=449 :
Shader44; A
.44A B
PropertyToID44B N
(44N O
$str44O h
)44h i
;44i j)
MainLightShadowConstantBuffer55 )
.55) *
_ShadowParams55* 7
=558 9
Shader55: @
.55@ A
PropertyToID55A M
(55M N
$str55N f
)55f g
;55g h)
MainLightShadowConstantBuffer66 )
.66) *'
_CascadeShadowSplitSpheres066* E
=66F G
Shader66H N
.66N O
PropertyToID66O [
(66[ \
$str66\ y
)66y z
;66z {)
MainLightShadowConstantBuffer77 )
.77) *'
_CascadeShadowSplitSpheres177* E
=77F G
Shader77H N
.77N O
PropertyToID77O [
(77[ \
$str77\ y
)77y z
;77z {)
MainLightShadowConstantBuffer88 )
.88) *'
_CascadeShadowSplitSpheres288* E
=88F G
Shader88H N
.88N O
PropertyToID88O [
(88[ \
$str88\ y
)88y z
;88z {)
MainLightShadowConstantBuffer99 )
.99) *'
_CascadeShadowSplitSpheres399* E
=99F G
Shader99H N
.99N O
PropertyToID99O [
(99[ \
$str99\ y
)99y z
;99z {)
MainLightShadowConstantBuffer:: )
.::) **
_CascadeShadowSplitSphereRadii::* H
=::I J
Shader::K Q
.::Q R
PropertyToID::R ^
(::^ _
$str::_ 
)	:: Ä
;
::Ä Å)
MainLightShadowConstantBuffer;; )
.;;) *
_ShadowOffset0;;* 8
=;;9 :
Shader;;; A
.;;A B
PropertyToID;;B N
(;;N O
$str;;O h
);;h i
;;;i j)
MainLightShadowConstantBuffer<< )
.<<) *
_ShadowOffset1<<* 8
=<<9 :
Shader<<; A
.<<A B
PropertyToID<<B N
(<<N O
$str<<O h
)<<h i
;<<i j)
MainLightShadowConstantBuffer== )
.==) *
_ShadowOffset2==* 8
===9 :
Shader==; A
.==A B
PropertyToID==B N
(==N O
$str==O h
)==h i
;==i j)
MainLightShadowConstantBuffer>> )
.>>) *
_ShadowOffset3>>* 8
=>>9 :
Shader>>; A
.>>A B
PropertyToID>>B N
(>>N O
$str>>O h
)>>h i
;>>i j)
MainLightShadowConstantBuffer?? )
.??) *
_ShadowmapSize??* 8
=??9 :
Shader??; A
.??A B
PropertyToID??B N
(??N O
$str??O h
)??h i
;??i j 
m_MainLightShadowmapAA  
.AA  !
InitAA! %
(AA% &
$strAA& B
)AAB C
;AAC D)
m_SupportsBoxFilterForShadowsBB )
=BB* +
ApplicationBB, 7
.BB7 8
isMobilePlatformBB8 H
||BBI K

SystemInfoBBL V
.BBV W
graphicsDeviceTypeBBW i
==BBj l
GraphicsDeviceTypeBBm 
.	BB Ä
Switch
BBÄ Ü
;
BBÜ á
}CC 	
publicEE 
boolEE 
SetupEE 
(EE 
refEE 
RenderingDataEE +
renderingDataEE, 9
)EE9 :
{FF 	
usingGG 
varGG 
	profScopeGG 
=GG  !
newGG" %
ProfilingScopeGG& 4
(GG4 5
nullGG5 9
,GG9 :#
m_ProfilingSetupSamplerGG; R
)GGR S
;GGS T
ifII 
(II 
!II 
renderingDataII 
.II 

shadowDataII )
.II) *$
supportsMainLightShadowsII* B
)IIB C
returnJJ 
falseJJ 
;JJ 
ClearLL 
(LL 
)LL 
;LL 
intMM 
shadowLightIndexMM  
=MM! "
renderingDataMM# 0
.MM0 1
	lightDataMM1 :
.MM: ;
mainLightIndexMM; I
;MMI J
ifNN 
(NN 
shadowLightIndexNN  
==NN! #
-NN$ %
$numNN% &
)NN& '
returnOO 
falseOO 
;OO 
VisibleLightQQ 
shadowLightQQ $
=QQ% &
renderingDataQQ' 4
.QQ4 5
	lightDataQQ5 >
.QQ> ?
visibleLightsQQ? L
[QQL M
shadowLightIndexQQM ]
]QQ] ^
;QQ^ _
LightRR 
lightRR 
=RR 
shadowLightRR %
.RR% &
lightRR& +
;RR+ ,
ifSS 
(SS 
lightSS 
.SS 
shadowsSS 
==SS  
LightShadowsSS! -
.SS- .
NoneSS. 2
)SS2 3
returnTT 
falseTT 
;TT 
ifVV 
(VV 
shadowLightVV 
.VV 
	lightTypeVV %
!=VV& (
	LightTypeVV) 2
.VV2 3
DirectionalVV3 >
)VV> ?
{WW 
DebugXX 
.XX 

LogWarningXX  
(XX  !
$strXX! W
)XXW X
;XXX Y
}YY 
Bounds[[ 
bounds[[ 
;[[ 
if\\ 
(\\ 
!\\ 
renderingData\\ 
.\\ 
cullResults\\ *
.\\* +!
GetShadowCasterBounds\\+ @
(\\@ A
shadowLightIndex\\A Q
,\\Q R
out\\S V
bounds\\W ]
)\\] ^
)\\^ _
return]] 
false]] 
;]] '
m_ShadowCasterCascadesCount__ '
=__( )
renderingData__* 7
.__7 8

shadowData__8 B
.__B C(
mainLightShadowCascadesCount__C _
;___ `
intaa 
shadowResolutionaa  
=aa! "
ShadowUtilsaa# .
.aa. /'
GetMaxTileResolutionInAtlasaa/ J
(aaJ K
renderingDataaaK X
.aaX Y

shadowDataaaY c
.aac d#
mainLightShadowmapWidthaad {
,aa{ |
renderingDatabb 
.bb 

shadowDatabb (
.bb( )$
mainLightShadowmapHeightbb) A
,bbA B'
m_ShadowCasterCascadesCountbbC ^
)bb^ _
;bb_ `
m_ShadowmapWidthcc 
=cc 
renderingDatacc ,
.cc, -

shadowDatacc- 7
.cc7 8#
mainLightShadowmapWidthcc8 O
;ccO P
m_ShadowmapHeightdd 
=dd 
(dd  !'
m_ShadowCasterCascadesCountdd! <
==dd= ?
$numdd@ A
)ddA B
?ddC D
renderingDataee 
.ee 

shadowDataee (
.ee( )$
mainLightShadowmapHeightee) A
>>eeB D
$numeeE F
:eeG H
renderingDataff 
.ff 

shadowDataff (
.ff( )$
mainLightShadowmapHeightff) A
;ffA B
forhh 
(hh 
inthh 
cascadeIndexhh !
=hh" #
$numhh$ %
;hh% &
cascadeIndexhh' 3
<hh4 5'
m_ShadowCasterCascadesCounthh6 Q
;hhQ R
++hhS U
cascadeIndexhhU a
)hha b
{ii 
booljj 
successjj 
=jj 
ShadowUtilsjj *
.jj* +)
ExtractDirectionalLightMatrixjj+ H
(jjH I
refjjI L
renderingDatajjM Z
.jjZ [
cullResultsjj[ f
,jjf g
refjjh k
renderingDatajjl y
.jjy z

shadowData	jjz Ñ
,
jjÑ Ö
shadowLightIndexkk $
,kk$ %
cascadeIndexkk& 2
,kk2 3
m_ShadowmapWidthkk4 D
,kkD E
m_ShadowmapHeightkkF W
,kkW X
shadowResolutionkkY i
,kki j
lightkkk p
.kkp q
shadowNearPlane	kkq Ä
,
kkÄ Å
outll #
m_CascadeSplitDistancesll /
[ll/ 0
cascadeIndexll0 <
]ll< =
,ll= >
outll? B
m_CascadeSlicesllC R
[llR S
cascadeIndexllS _
]ll_ `
,ll` a
outllb e
m_CascadeSlicesllf u
[llu v
cascadeIndex	llv Ç
]
llÇ É
.
llÉ Ñ

viewMatrix
llÑ é
,
llé è
out
llê ì
m_CascadeSlices
llî £
[
ll£ §
cascadeIndex
ll§ ∞
]
ll∞ ±
.
ll± ≤
projectionMatrix
ll≤ ¬
)
ll¬ √
;
ll√ ƒ
ifnn 
(nn 
!nn 
successnn 
)nn 
returnoo 
falseoo  
;oo  !
}pp 
m_MaxShadowDistancerr 
=rr  !
renderingDatarr" /
.rr/ 0

cameraDatarr0 :
.rr: ;
maxShadowDistancerr; L
*rrM N
renderingDatarrO \
.rr\ ]

cameraDatarr] g
.rrg h
maxShadowDistancerrh y
;rry z
returntt 
truett 
;tt 
}uu 	
publicww 
overrideww 
voidww 
	Configureww &
(ww& '
CommandBufferww' 4
cmdww5 8
,ww8 9#
RenderTextureDescriptorww: Q#
cameraTextureDescriptorwwR i
)wwi j
{xx 	'
m_MainLightShadowmapTextureyy '
=yy( )
ShadowUtilsyy* 5
.yy5 6%
GetTemporaryShadowTextureyy6 O
(yyO P
m_ShadowmapWidthyyP `
,yy` a
m_ShadowmapHeightzz %
,zz% &!
k_ShadowmapBufferBitszz' <
)zz< =
;zz= >
ConfigureTarget{{ 
({{ 
new{{ "
RenderTargetIdentifier{{  6
({{6 7'
m_MainLightShadowmapTexture{{7 R
){{R S
){{S T
;{{T U
ConfigureClear|| 
(|| 
	ClearFlag|| $
.||$ %
All||% (
,||( )
Color||* /
.||/ 0
black||0 5
)||5 6
;||6 7
}}} 	
public
ÄÄ 
override
ÄÄ 
void
ÄÄ 
Execute
ÄÄ $
(
ÄÄ$ %%
ScriptableRenderContext
ÄÄ% <
context
ÄÄ= D
,
ÄÄD E
ref
ÄÄF I
RenderingData
ÄÄJ W
renderingData
ÄÄX e
)
ÄÄe f
{
ÅÅ 	-
RenderMainLightCascadeShadowmap
ÇÇ +
(
ÇÇ+ ,
ref
ÇÇ, /
context
ÇÇ0 7
,
ÇÇ7 8
ref
ÇÇ9 <
renderingData
ÇÇ= J
.
ÇÇJ K
cullResults
ÇÇK V
,
ÇÇV W
ref
ÇÇX [
renderingData
ÇÇ\ i
.
ÇÇi j
	lightData
ÇÇj s
,
ÇÇs t
ref
ÇÇu x
renderingDataÇÇy Ü
.ÇÇÜ á

shadowDataÇÇá ë
)ÇÇë í
;ÇÇí ì
}
ÉÉ 	
public
ÜÜ 
override
ÜÜ 
void
ÜÜ 
OnCameraCleanup
ÜÜ ,
(
ÜÜ, -
CommandBuffer
ÜÜ- :
cmd
ÜÜ; >
)
ÜÜ> ?
{
áá 	
if
àà 
(
àà 
cmd
àà 
==
àà 
null
àà 
)
àà 
throw
ââ 
new
ââ #
ArgumentNullException
ââ /
(
ââ/ 0
$str
ââ0 5
)
ââ5 6
;
ââ6 7
if
ãã 
(
ãã )
m_MainLightShadowmapTexture
ãã +
)
ãã+ ,
{
åå 
RenderTexture
çç 
.
çç 
ReleaseTemporary
çç .
(
çç. /)
m_MainLightShadowmapTexture
çç/ J
)
ççJ K
;
ççK L)
m_MainLightShadowmapTexture
éé +
=
éé, -
null
éé. 2
;
éé2 3
}
èè 
}
êê 	
void
íí 
Clear
íí 
(
íí 
)
íí 
{
ìì 	)
m_MainLightShadowmapTexture
îî '
=
îî( )
null
îî* .
;
îî. /
for
ññ 
(
ññ 
int
ññ 
i
ññ 
=
ññ 
$num
ññ 
;
ññ 
i
ññ 
<
ññ '
m_MainLightShadowMatrices
ññ  9
.
ññ9 :
Length
ññ: @
;
ññ@ A
++
ññB D
i
ññD E
)
ññE F'
m_MainLightShadowMatrices
óó )
[
óó) *
i
óó* +
]
óó+ ,
=
óó- .
	Matrix4x4
óó/ 8
.
óó8 9
identity
óó9 A
;
óóA B
for
ôô 
(
ôô 
int
ôô 
i
ôô 
=
ôô 
$num
ôô 
;
ôô 
i
ôô 
<
ôô %
m_CascadeSplitDistances
ôô  7
.
ôô7 8
Length
ôô8 >
;
ôô> ?
++
ôô@ B
i
ôôB C
)
ôôC D%
m_CascadeSplitDistances
öö '
[
öö' (
i
öö( )
]
öö) *
=
öö+ ,
new
öö- 0
Vector4
öö1 8
(
öö8 9
$num
öö9 =
,
öö= >
$num
öö? C
,
ööC D
$num
ööE I
,
ööI J
$num
ööK O
)
ööO P
;
ööP Q
for
úú 
(
úú 
int
úú 
i
úú 
=
úú 
$num
úú 
;
úú 
i
úú 
<
úú 
m_CascadeSlices
úú  /
.
úú/ 0
Length
úú0 6
;
úú6 7
++
úú8 :
i
úú: ;
)
úú; <
m_CascadeSlices
ùù 
[
ùù  
i
ùù  !
]
ùù! "
.
ùù" #
Clear
ùù# (
(
ùù( )
)
ùù) *
;
ùù* +
}
ûû 	
void
†† -
RenderMainLightCascadeShadowmap
†† ,
(
††, -
ref
††- 0%
ScriptableRenderContext
††1 H
context
††I P
,
††P Q
ref
††R U
CullingResults
††V d
cullResults
††e p
,
††p q
ref
††r u
	LightData
††v 
	lightData††Ä â
,††â ä
ref††ã é

ShadowData††è ô

shadowData††ö §
)††§ •
{
°° 	
int
¢¢ 
shadowLightIndex
¢¢  
=
¢¢! "
	lightData
¢¢# ,
.
¢¢, -
mainLightIndex
¢¢- ;
;
¢¢; <
if
££ 
(
££ 
shadowLightIndex
££  
==
££! #
-
££$ %
$num
££% &
)
££& '
return
§§ 
;
§§ 
VisibleLight
¶¶ 
shadowLight
¶¶ $
=
¶¶% &
	lightData
¶¶' 0
.
¶¶0 1
visibleLights
¶¶1 >
[
¶¶> ?
shadowLightIndex
¶¶? O
]
¶¶O P
;
¶¶P Q
CommandBuffer
™™ 
cmd
™™ 
=
™™ 
CommandBufferPool
™™  1
.
™™1 2
Get
™™2 5
(
™™5 6
)
™™6 7
;
™™7 8
using
´´ 
(
´´ 
new
´´ 
ProfilingScope
´´ %
(
´´% &
cmd
´´& )
,
´´) *
ProfilingSampler
´´+ ;
.
´´; <
Get
´´< ?
(
´´? @
URPProfileId
´´@ L
.
´´L M
MainLightShadow
´´M \
)
´´\ ]
)
´´] ^
)
´´^ _
{
¨¨ 
var
≠≠ 
settings
≠≠ 
=
≠≠ 
new
≠≠ "#
ShadowDrawingSettings
≠≠# 8
(
≠≠8 9
cullResults
≠≠9 D
,
≠≠D E
shadowLightIndex
≠≠F V
)
≠≠V W
;
≠≠W X
for
ØØ 
(
ØØ 
int
ØØ 
cascadeIndex
ØØ %
=
ØØ& '
$num
ØØ( )
;
ØØ) *
cascadeIndex
ØØ+ 7
<
ØØ8 9)
m_ShadowCasterCascadesCount
ØØ: U
;
ØØU V
++
ØØW Y
cascadeIndex
ØØY e
)
ØØe f
{
∞∞ 
var
±± 
	splitData
±± !
=
±±" #
settings
±±$ ,
.
±±, -
	splitData
±±- 6
;
±±6 7
	splitData
≤≤ 
.
≤≤ 
cullingSphere
≤≤ +
=
≤≤, -%
m_CascadeSplitDistances
≤≤. E
[
≤≤E F
cascadeIndex
≤≤F R
]
≤≤R S
;
≤≤S T
settings
≥≥ 
.
≥≥ 
	splitData
≥≥ &
=
≥≥' (
	splitData
≥≥) 2
;
≥≥2 3
Vector4
¥¥ 

shadowBias
¥¥ &
=
¥¥' (
ShadowUtils
¥¥) 4
.
¥¥4 5
GetShadowBias
¥¥5 B
(
¥¥B C
ref
¥¥C F
shadowLight
¥¥G R
,
¥¥R S
shadowLightIndex
¥¥T d
,
¥¥d e
ref
¥¥f i

shadowData
¥¥j t
,
¥¥t u
m_CascadeSlices¥¥v Ö
[¥¥Ö Ü
cascadeIndex¥¥Ü í
]¥¥í ì
.¥¥ì î 
projectionMatrix¥¥î §
,¥¥§ •
m_CascadeSlices¥¥¶ µ
[¥¥µ ∂
cascadeIndex¥¥∂ ¬
]¥¥¬ √
.¥¥√ ƒ

resolution¥¥ƒ Œ
)¥¥Œ œ
;¥¥œ –
ShadowUtils
µµ 
.
µµ  -
SetupShadowCasterConstantBuffer
µµ  ?
(
µµ? @
cmd
µµ@ C
,
µµC D
ref
µµE H
shadowLight
µµI T
,
µµT U

shadowBias
µµV `
)
µµ` a
;
µµa b
ShadowUtils
∂∂ 
.
∂∂  
RenderShadowSlice
∂∂  1
(
∂∂1 2
cmd
∂∂2 5
,
∂∂5 6
ref
∂∂7 :
context
∂∂; B
,
∂∂B C
ref
∂∂D G
m_CascadeSlices
∂∂H W
[
∂∂W X
cascadeIndex
∂∂X d
]
∂∂d e
,
∂∂e f
ref
∑∑ 
settings
∑∑ $
,
∑∑$ %
m_CascadeSlices
∑∑& 5
[
∑∑5 6
cascadeIndex
∑∑6 B
]
∑∑B C
.
∑∑C D
projectionMatrix
∑∑D T
,
∑∑T U
m_CascadeSlices
∑∑V e
[
∑∑e f
cascadeIndex
∑∑f r
]
∑∑r s
.
∑∑s t

viewMatrix
∑∑t ~
)
∑∑~ 
;∑∑ Ä
}
∏∏ 
bool
∫∫ 
softShadows
∫∫  
=
∫∫! "
shadowLight
∫∫# .
.
∫∫. /
light
∫∫/ 4
.
∫∫4 5
shadows
∫∫5 <
==
∫∫= ?
LightShadows
∫∫@ L
.
∫∫L M
Soft
∫∫M Q
&&
∫∫R T

shadowData
∫∫U _
.
∫∫_ `!
supportsSoftShadows
∫∫` s
;
∫∫s t
	CoreUtils
ªª 
.
ªª 

SetKeyword
ªª $
(
ªª$ %
cmd
ªª% (
,
ªª( )"
ShaderKeywordStrings
ªª* >
.
ªª> ?
MainLightShadows
ªª? O
,
ªªO P
true
ªªQ U
)
ªªU V
;
ªªV W
	CoreUtils
ºº 
.
ºº 

SetKeyword
ºº $
(
ºº$ %
cmd
ºº% (
,
ºº( )"
ShaderKeywordStrings
ºº* >
.
ºº> ?%
MainLightShadowCascades
ºº? V
,
ººV W

shadowData
ººX b
.
ººb c*
mainLightShadowCascadesCount
ººc 
>ººÄ Å
$numººÇ É
)ººÉ Ñ
;ººÑ Ö
	CoreUtils
ΩΩ 
.
ΩΩ 

SetKeyword
ΩΩ $
(
ΩΩ$ %
cmd
ΩΩ% (
,
ΩΩ( )"
ShaderKeywordStrings
ΩΩ* >
.
ΩΩ> ?
SoftShadows
ΩΩ? J
,
ΩΩJ K
softShadows
ΩΩL W
)
ΩΩW X
;
ΩΩX Y3
%SetupMainLightShadowReceiverConstants
øø 5
(
øø5 6
cmd
øø6 9
,
øø9 :
shadowLight
øø; F
,
øøF G

shadowData
øøH R
.
øøR S!
supportsSoftShadows
øøS f
)
øøf g
;
øøg h
}
¿¿ 
context
¬¬ 
.
¬¬ "
ExecuteCommandBuffer
¬¬ (
(
¬¬( )
cmd
¬¬) ,
)
¬¬, -
;
¬¬- .
CommandBufferPool
√√ 
.
√√ 
Release
√√ %
(
√√% &
cmd
√√& )
)
√√) *
;
√√* +
}
ƒƒ 	
void
∆∆ 3
%SetupMainLightShadowReceiverConstants
∆∆ 2
(
∆∆2 3
CommandBuffer
∆∆3 @
cmd
∆∆A D
,
∆∆D E
VisibleLight
∆∆F R
shadowLight
∆∆S ^
,
∆∆^ _
bool
∆∆` d!
supportsSoftShadows
∆∆e x
)
∆∆x y
{
«« 	
Light
»» 
light
»» 
=
»» 
shadowLight
»» %
.
»»% &
light
»»& +
;
»»+ ,
bool
…… 
softShadows
…… 
=
…… 
shadowLight
…… *
.
……* +
light
……+ 0
.
……0 1
shadows
……1 8
==
……9 ;
LightShadows
……< H
.
……H I
Soft
……I M
&&
……N P!
supportsSoftShadows
……Q d
;
……d e
int
ÀÀ 
cascadeCount
ÀÀ 
=
ÀÀ )
m_ShadowCasterCascadesCount
ÀÀ :
;
ÀÀ: ;
for
ÃÃ 
(
ÃÃ 
int
ÃÃ 
i
ÃÃ 
=
ÃÃ 
$num
ÃÃ 
;
ÃÃ 
i
ÃÃ 
<
ÃÃ 
cascadeCount
ÃÃ  ,
;
ÃÃ, -
++
ÃÃ. 0
i
ÃÃ0 1
)
ÃÃ1 2'
m_MainLightShadowMatrices
ÕÕ )
[
ÕÕ) *
i
ÕÕ* +
]
ÕÕ+ ,
=
ÕÕ- .
m_CascadeSlices
ÕÕ/ >
[
ÕÕ> ?
i
ÕÕ? @
]
ÕÕ@ A
.
ÕÕA B
shadowTransform
ÕÕB Q
;
ÕÕQ R
	Matrix4x4
““ 
noOpShadowMatrix
““ &
=
““' (
	Matrix4x4
““) 2
.
““2 3
zero
““3 7
;
““7 8
noOpShadowMatrix
”” 
.
”” 
m22
””  
=
””! "
(
””# $

SystemInfo
””$ .
.
””. /!
usesReversedZBuffer
””/ B
)
””B C
?
””D E
$num
””F J
:
””K L
$num
””M Q
;
””Q R
for
‘‘ 
(
‘‘ 
int
‘‘ 
i
‘‘ 
=
‘‘ 
cascadeCount
‘‘ %
;
‘‘% &
i
‘‘' (
<=
‘‘) +
k_MaxCascades
‘‘, 9
;
‘‘9 :
++
‘‘; =
i
‘‘= >
)
‘‘> ?'
m_MainLightShadowMatrices
’’ )
[
’’) *
i
’’* +
]
’’+ ,
=
’’- .
noOpShadowMatrix
’’/ ?
;
’’? @
float
◊◊ !
invShadowAtlasWidth
◊◊ %
=
◊◊& '
$num
◊◊( ,
/
◊◊- .
m_ShadowmapWidth
◊◊/ ?
;
◊◊? @
float
ÿÿ "
invShadowAtlasHeight
ÿÿ &
=
ÿÿ' (
$num
ÿÿ) -
/
ÿÿ. /
m_ShadowmapHeight
ÿÿ0 A
;
ÿÿA B
float
ŸŸ %
invHalfShadowAtlasWidth
ŸŸ )
=
ŸŸ* +
$num
ŸŸ, 0
*
ŸŸ1 2!
invShadowAtlasWidth
ŸŸ3 F
;
ŸŸF G
float
⁄⁄ &
invHalfShadowAtlasHeight
⁄⁄ *
=
⁄⁄+ ,
$num
⁄⁄- 1
*
⁄⁄2 3"
invShadowAtlasHeight
⁄⁄4 H
;
⁄⁄H I
float
€€ 
softShadowsProp
€€ !
=
€€" #
softShadows
€€$ /
?
€€0 1
$num
€€2 6
:
€€7 8
$num
€€9 =
;
€€= >
float
ﬂﬂ 
	startFade
ﬂﬂ 
=
ﬂﬂ !
m_MaxShadowDistance
ﬂﬂ 1
*
ﬂﬂ2 3
$num
ﬂﬂ4 8
;
ﬂﬂ8 9
float
‡‡ 
oneOverFadeDist
‡‡ !
=
‡‡" #
$num
‡‡$ %
/
‡‡% &
(
‡‡& '!
m_MaxShadowDistance
‡‡' :
-
‡‡; <
	startFade
‡‡= F
)
‡‡F G
;
‡‡G H
float
·· 
minusStartFade
··  
=
··! "
-
··# $
	startFade
··$ -
*
··. /
oneOverFadeDist
··0 ?
;
··? @
cmd
‰‰ 
.
‰‰ 
SetGlobalTexture
‰‰  
(
‰‰  !"
m_MainLightShadowmap
‰‰! 5
.
‰‰5 6
id
‰‰6 8
,
‰‰8 9)
m_MainLightShadowmapTexture
‰‰: U
)
‰‰U V
;
‰‰V W
cmd
ÂÂ 
.
ÂÂ "
SetGlobalMatrixArray
ÂÂ $
(
ÂÂ$ %+
MainLightShadowConstantBuffer
ÂÂ% B
.
ÂÂB C
_WorldToShadow
ÂÂC Q
,
ÂÂQ R'
m_MainLightShadowMatrices
ÂÂS l
)
ÂÂl m
;
ÂÂm n
cmd
ÊÊ 
.
ÊÊ 
SetGlobalVector
ÊÊ 
(
ÊÊ  +
MainLightShadowConstantBuffer
ÊÊ  =
.
ÊÊ= >
_ShadowParams
ÊÊ> K
,
ÊÊK L
new
ÊÊM P
Vector4
ÊÊQ X
(
ÊÊX Y
light
ÊÊY ^
.
ÊÊ^ _
shadowStrength
ÊÊ_ m
,
ÊÊm n
softShadowsProp
ÊÊo ~
,
ÊÊ~ 
oneOverFadeDistÊÊÄ è
,ÊÊè ê
minusStartFadeÊÊë ü
)ÊÊü †
)ÊÊ† °
;ÊÊ° ¢
if
ËË 
(
ËË )
m_ShadowCasterCascadesCount
ËË +
>
ËË, -
$num
ËË. /
)
ËË/ 0
{
ÈÈ 
cmd
ÍÍ 
.
ÍÍ 
SetGlobalVector
ÍÍ #
(
ÍÍ# $+
MainLightShadowConstantBuffer
ÍÍ$ A
.
ÍÍA B)
_CascadeShadowSplitSpheres0
ÍÍB ]
,
ÍÍ] ^%
m_CascadeSplitDistances
ÎÎ +
[
ÎÎ+ ,
$num
ÎÎ, -
]
ÎÎ- .
)
ÎÎ. /
;
ÎÎ/ 0
cmd
ÏÏ 
.
ÏÏ 
SetGlobalVector
ÏÏ #
(
ÏÏ# $+
MainLightShadowConstantBuffer
ÏÏ$ A
.
ÏÏA B)
_CascadeShadowSplitSpheres1
ÏÏB ]
,
ÏÏ] ^%
m_CascadeSplitDistances
ÌÌ +
[
ÌÌ+ ,
$num
ÌÌ, -
]
ÌÌ- .
)
ÌÌ. /
;
ÌÌ/ 0
cmd
ÓÓ 
.
ÓÓ 
SetGlobalVector
ÓÓ #
(
ÓÓ# $+
MainLightShadowConstantBuffer
ÓÓ$ A
.
ÓÓA B)
_CascadeShadowSplitSpheres2
ÓÓB ]
,
ÓÓ] ^%
m_CascadeSplitDistances
ÔÔ +
[
ÔÔ+ ,
$num
ÔÔ, -
]
ÔÔ- .
)
ÔÔ. /
;
ÔÔ/ 0
cmd
 
.
 
SetGlobalVector
 #
(
# $+
MainLightShadowConstantBuffer
$ A
.
A B)
_CascadeShadowSplitSpheres3
B ]
,
] ^%
m_CascadeSplitDistances
ÒÒ +
[
ÒÒ+ ,
$num
ÒÒ, -
]
ÒÒ- .
)
ÒÒ. /
;
ÒÒ/ 0
cmd
ÚÚ 
.
ÚÚ 
SetGlobalVector
ÚÚ #
(
ÚÚ# $+
MainLightShadowConstantBuffer
ÚÚ$ A
.
ÚÚA B,
_CascadeShadowSplitSphereRadii
ÚÚB `
,
ÚÚ` a
new
ÚÚb e
Vector4
ÚÚf m
(
ÚÚm n%
m_CascadeSplitDistances
ÛÛ +
[
ÛÛ+ ,
$num
ÛÛ, -
]
ÛÛ- .
.
ÛÛ. /
w
ÛÛ/ 0
*
ÛÛ1 2%
m_CascadeSplitDistances
ÛÛ3 J
[
ÛÛJ K
$num
ÛÛK L
]
ÛÛL M
.
ÛÛM N
w
ÛÛN O
,
ÛÛO P%
m_CascadeSplitDistances
ÙÙ +
[
ÙÙ+ ,
$num
ÙÙ, -
]
ÙÙ- .
.
ÙÙ. /
w
ÙÙ/ 0
*
ÙÙ1 2%
m_CascadeSplitDistances
ÙÙ3 J
[
ÙÙJ K
$num
ÙÙK L
]
ÙÙL M
.
ÙÙM N
w
ÙÙN O
,
ÙÙO P%
m_CascadeSplitDistances
ıı +
[
ıı+ ,
$num
ıı, -
]
ıı- .
.
ıı. /
w
ıı/ 0
*
ıı1 2%
m_CascadeSplitDistances
ıı3 J
[
ııJ K
$num
ııK L
]
ııL M
.
ııM N
w
ııN O
,
ııO P%
m_CascadeSplitDistances
ˆˆ +
[
ˆˆ+ ,
$num
ˆˆ, -
]
ˆˆ- .
.
ˆˆ. /
w
ˆˆ/ 0
*
ˆˆ1 2%
m_CascadeSplitDistances
ˆˆ3 J
[
ˆˆJ K
$num
ˆˆK L
]
ˆˆL M
.
ˆˆM N
w
ˆˆN O
)
ˆˆO P
)
ˆˆP Q
;
ˆˆQ R
}
˜˜ 
if
˝˝ 
(
˝˝ !
supportsSoftShadows
˝˝ #
)
˝˝# $
{
˛˛ 
if
ˇˇ 
(
ˇˇ +
m_SupportsBoxFilterForShadows
ˇˇ 1
)
ˇˇ1 2
{
ÄÄ 
cmd
ÅÅ 
.
ÅÅ 
SetGlobalVector
ÅÅ '
(
ÅÅ' (+
MainLightShadowConstantBuffer
ÅÅ( E
.
ÅÅE F
_ShadowOffset0
ÅÅF T
,
ÅÅT U
new
ÇÇ 
Vector4
ÇÇ #
(
ÇÇ# $
-
ÇÇ$ %%
invHalfShadowAtlasWidth
ÇÇ% <
,
ÇÇ< =
-
ÇÇ> ?&
invHalfShadowAtlasHeight
ÇÇ? W
,
ÇÇW X
$num
ÇÇY ]
,
ÇÇ] ^
$num
ÇÇ_ c
)
ÇÇc d
)
ÇÇd e
;
ÇÇe f
cmd
ÉÉ 
.
ÉÉ 
SetGlobalVector
ÉÉ '
(
ÉÉ' (+
MainLightShadowConstantBuffer
ÉÉ( E
.
ÉÉE F
_ShadowOffset1
ÉÉF T
,
ÉÉT U
new
ÑÑ 
Vector4
ÑÑ #
(
ÑÑ# $%
invHalfShadowAtlasWidth
ÑÑ$ ;
,
ÑÑ; <
-
ÑÑ= >&
invHalfShadowAtlasHeight
ÑÑ> V
,
ÑÑV W
$num
ÑÑX \
,
ÑÑ\ ]
$num
ÑÑ^ b
)
ÑÑb c
)
ÑÑc d
;
ÑÑd e
cmd
ÖÖ 
.
ÖÖ 
SetGlobalVector
ÖÖ '
(
ÖÖ' (+
MainLightShadowConstantBuffer
ÖÖ( E
.
ÖÖE F
_ShadowOffset2
ÖÖF T
,
ÖÖT U
new
ÜÜ 
Vector4
ÜÜ #
(
ÜÜ# $
-
ÜÜ$ %%
invHalfShadowAtlasWidth
ÜÜ% <
,
ÜÜ< =&
invHalfShadowAtlasHeight
ÜÜ> V
,
ÜÜV W
$num
ÜÜX \
,
ÜÜ\ ]
$num
ÜÜ^ b
)
ÜÜb c
)
ÜÜc d
;
ÜÜd e
cmd
áá 
.
áá 
SetGlobalVector
áá '
(
áá' (+
MainLightShadowConstantBuffer
áá( E
.
ááE F
_ShadowOffset3
ááF T
,
ááT U
new
àà 
Vector4
àà #
(
àà# $%
invHalfShadowAtlasWidth
àà$ ;
,
àà; <&
invHalfShadowAtlasHeight
àà= U
,
ààU V
$num
ààW [
,
àà[ \
$num
àà] a
)
ààa b
)
ààb c
;
ààc d
}
ââ 
cmd
çç 
.
çç 
SetGlobalVector
çç #
(
çç# $+
MainLightShadowConstantBuffer
çç$ A
.
ççA B
_ShadowmapSize
ççB P
,
ççP Q
new
ççR U
Vector4
ççV ]
(
çç] ^!
invShadowAtlasWidth
çç^ q
,
ççq r"
invShadowAtlasHeight
éé (
,
éé( )
m_ShadowmapWidth
èè $
,
èè$ %
m_ShadowmapHeight
èè& 7
)
èè7 8
)
èè8 9
;
èè9 :
}
êê 
}
ëë 	
}
íí 
;
íí 
}ìì æ
†D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\FilmGrain.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
public 

enum 
FilmGrainLookup 
{ 
Thin1 
, 
Thin2 
, 
Medium1		 
,		 
Medium2

 
,

 
Medium3 
, 
Medium4 
, 
Medium5 
, 
Medium6 
, 
Large01 
, 
Large02 
, 
Custom 
} 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' B
)B C
]C D
public 

sealed 
class 
	FilmGrain !
:" #
VolumeComponent$ 3
,3 4!
IPostProcessComponent5 J
{ 
[ 	
Tooltip	 
( 
$str u
)u v
]v w
public $
FilmGrainLookupParameter '
type( ,
=- .
new/ 2$
FilmGrainLookupParameter3 K
(K L
FilmGrainLookupL [
.[ \
Thin1\ a
)a b
;b c
[ 	
Tooltip	 
( 
$str 2
)2 3
]3 4
public !
ClampedFloatParameter $
	intensity% .
=/ 0
new1 4!
ClampedFloatParameter5 J
(J K
$numK M
,M N
$numO Q
,Q R
$numS U
)U V
;V W
[ 	
Tooltip	 
( 
$str	 Ä
)
Ä Å
]
Å Ç
public !
ClampedFloatParameter $
response% -
=. /
new0 3!
ClampedFloatParameter4 I
(I J
$numJ N
,N O
$numP R
,R S
$numT V
)V W
;W X
[   	
Tooltip  	 
(   
$str   o
)  o p
]  p q
public!! $
NoInterpTextureParameter!! '
texture!!( /
=!!0 1
new!!2 5$
NoInterpTextureParameter!!6 N
(!!N O
null!!O S
)!!S T
;!!T U
public## 
bool## 
IsActive## 
(## 
)## 
=>## !
	intensity##" +
.##+ ,
value##, 1
>##2 3
$num##4 6
&&##7 9
(##: ;
type##; ?
.##? @
value##@ E
!=##F H
FilmGrainLookup##I X
.##X Y
Custom##Y _
||##` b
texture##c j
.##j k
value##k p
!=##q s
null##t x
)##x y
;##y z
public%% 
bool%% 
IsTileCompatible%% $
(%%$ %
)%%% &
=>%%' )
true%%* .
;%%. /
}&& 
[(( 
Serializable(( 
](( 
public)) 

sealed)) 
class)) $
FilmGrainLookupParameter)) 0
:))1 2
VolumeParameter))3 B
<))B C
FilmGrainLookup))C R
>))R S
{))T U
public))V \$
FilmGrainLookupParameter))] u
())u v
FilmGrainLookup	))v Ö
value
))Ü ã
,
))ã å
bool
))ç ë
overrideState
))í ü
=
))† °
false
))¢ ß
)
))ß ®
:
))© ™
base
))´ Ø
(
))Ø ∞
value
))∞ µ
,
))µ ∂
overrideState
))∑ ƒ
)
))ƒ ≈
{
))∆ «
}
))» …
}
))  À
}** ˙J
ßD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\DepthNormalOnlyPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
public 

class 
DepthNormalOnlyPass $
:% & 
ScriptableRenderPass' ;
{ 
internal #
RenderTextureDescriptor (
normalDescriptor) 9
{: ;
get< ?
;? @
privateA H
setI L
;L M
}N O
internal #
RenderTextureDescriptor (
depthDescriptor) 8
{9 :
get; >
;> ?
private@ G
setH K
;K L
}M N
private

 
RenderTargetHandle

 "
depthHandle

# .
{

/ 0
get

1 4
;

4 5
set

6 9
;

9 :
}

; <
private 
RenderTargetHandle "
normalHandle# /
{0 1
get2 5
;5 6
set7 :
;: ;
}< =
private 
ShaderTagId 
m_ShaderTagId )
=* +
new, /
ShaderTagId0 ;
(; <
$str< J
)J K
;K L
private 
FilteringSettings !
m_FilteringSettings" 5
;5 6
private 
const 
int 
k_DepthBufferBits +
=, -
$num. 0
;0 1
public 
DepthNormalOnlyPass "
(" #
RenderPassEvent# 2
evt3 6
,6 7
RenderQueueRange8 H
renderQueueRangeI Y
,Y Z
	LayerMask[ d
	layerMaske n
)n o
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @
DepthNormalOnlyPass@ S
)S T
)T U
;U V
m_FilteringSettings 
=  !
new" %
FilteringSettings& 7
(7 8
renderQueueRange8 H
,H I
	layerMaskJ S
)S T
;T U
renderPassEvent 
= 
evt !
;! "
} 	
public 
void 
Setup 
( #
RenderTextureDescriptor 1
baseDescriptor2 @
,@ A
RenderTargetHandleB T
depthHandleU `
,` a
RenderTargetHandleb t
normalHandle	u Å
)
Å Ç
{   	
this!! 
.!! 
depthHandle!! 
=!! 
depthHandle!! *
;!!* +
baseDescriptor"" 
."" 
colorFormat"" &
=""' (
RenderTextureFormat"") <
.""< =
Depth""= B
;""B C
baseDescriptor## 
.## 
depthBufferBits## *
=##+ ,
k_DepthBufferBits##- >
;##> ?
baseDescriptor$$ 
.$$ 
msaaSamples$$ &
=$$' (
$num$$) *
;$$* +
depthDescriptor%% 
=%% 
baseDescriptor%% ,
;%%, -
this'' 
.'' 
normalHandle'' 
='' 
normalHandle''  ,
;'', -
baseDescriptor(( 
.(( 
colorFormat(( &
=((' (
RenderTextureFormat(() <
.((< =
RGHalf((= C
;((C D
baseDescriptor)) 
.)) 
depthBufferBits)) *
=))+ ,
$num))- .
;)). /
baseDescriptor** 
.** 
msaaSamples** &
=**' (
$num**) *
;*** +
normalDescriptor++ 
=++ 
baseDescriptor++ -
;++- .
},, 	
public// 
override// 
void// 
OnCameraSetup// *
(//* +
CommandBuffer//+ 8
cmd//9 <
,//< =
ref//> A
RenderingData//B O
renderingData//P ]
)//] ^
{00 	
cmd11 
.11 
GetTemporaryRT11 
(11 
normalHandle11 +
.11+ ,
id11, .
,11. /
normalDescriptor110 @
,11@ A

FilterMode11B L
.11L M
Point11M R
)11R S
;11S T
cmd22 
.22 
GetTemporaryRT22 
(22 
depthHandle22 *
.22* +
id22+ -
,22- .
depthDescriptor22/ >
,22> ?

FilterMode22@ J
.22J K
Point22K P
)22P Q
;22Q R
ConfigureTarget33 
(33 
new44 "
RenderTargetIdentifier44 *
(44* +
normalHandle44+ 7
.447 8

Identifier448 B
(44B C
)44C D
,44D E
$num44F G
,44G H
CubemapFace44I T
.44T U
Unknown44U \
,44\ ]
-44^ _
$num44_ `
)44` a
,44a b
new55 "
RenderTargetIdentifier55 *
(55* +
depthHandle55+ 6
.556 7

Identifier557 A
(55A B
)55B C
,55C D
$num55E F
,55F G
CubemapFace55H S
.55S T
Unknown55T [
,55[ \
-55] ^
$num55^ _
)55_ `
)66 
;66 
ConfigureClear77 
(77 
	ClearFlag77 $
.77$ %
All77% (
,77( )
Color77* /
.77/ 0
black770 5
)775 6
;776 7
}88 	
public;; 
override;; 
void;; 
Execute;; $
(;;$ %#
ScriptableRenderContext;;% <
context;;= D
,;;D E
ref;;F I
RenderingData;;J W
renderingData;;X e
);;e f
{<< 	
CommandBuffer?? 
cmd?? 
=?? 
CommandBufferPool??  1
.??1 2
Get??2 5
(??5 6
)??6 7
;??7 8
using@@ 
(@@ 
new@@ 
ProfilingScope@@ %
(@@% &
cmd@@& )
,@@) *
ProfilingSampler@@+ ;
.@@; <
Get@@< ?
(@@? @
URPProfileId@@@ L
.@@L M
DepthNormalPrepass@@M _
)@@_ `
)@@` a
)@@a b
{AA 
contextBB 
.BB  
ExecuteCommandBufferBB ,
(BB, -
cmdBB- 0
)BB0 1
;BB1 2
cmdCC 
.CC 
ClearCC 
(CC 
)CC 
;CC 
varEE 
	sortFlagsEE 
=EE 
renderingDataEE  -
.EE- .

cameraDataEE. 8
.EE8 9"
defaultOpaqueSortFlagsEE9 O
;EEO P
varFF 
drawSettingsFF  
=FF! "!
CreateDrawingSettingsFF# 8
(FF8 9
m_ShaderTagIdFF9 F
,FFF G
refFFH K
renderingDataFFL Y
,FFY Z
	sortFlagsFF[ d
)FFd e
;FFe f
drawSettingsGG 
.GG 
perObjectDataGG *
=GG+ ,
PerObjectDataGG- :
.GG: ;
NoneGG; ?
;GG? @
refII 

CameraDataII 

cameraDataII )
=II* +
refII, /
renderingDataII0 =
.II= >

cameraDataII> H
;IIH I
CameraJJ 
cameraJJ 
=JJ 

cameraDataJJ  *
.JJ* +
cameraJJ+ 1
;JJ1 2
contextLL 
.LL 
DrawRenderersLL %
(LL% &
renderingDataLL& 3
.LL3 4
cullResultsLL4 ?
,LL? @
refLLA D
drawSettingsLLE Q
,LLQ R
refLLS V
m_FilteringSettingsLLW j
)LLj k
;LLk l
}NN 
contextOO 
.OO  
ExecuteCommandBufferOO (
(OO( )
cmdOO) ,
)OO, -
;OO- .
CommandBufferPoolPP 
.PP 
ReleasePP %
(PP% &
cmdPP& )
)PP) *
;PP* +
}QQ 	
publicTT 
overrideTT 
voidTT 
OnCameraCleanupTT ,
(TT, -
CommandBufferTT- :
cmdTT; >
)TT> ?
{UU 	
ifVV 
(VV 
cmdVV 
==VV 
nullVV 
)VV 
{WW 
throwXX 
newXX !
ArgumentNullExceptionXX /
(XX/ 0
$strXX0 5
)XX5 6
;XX6 7
}YY 
if[[ 
([[ 
depthHandle[[ 
!=[[ 
RenderTargetHandle[[ 1
.[[1 2
CameraTarget[[2 >
)[[> ?
{\\ 
cmd]] 
.]] 
ReleaseTemporaryRT]] &
(]]& '
normalHandle]]' 3
.]]3 4
id]]4 6
)]]6 7
;]]7 8
cmd^^ 
.^^ 
ReleaseTemporaryRT^^ &
(^^& '
depthHandle^^' 2
.^^2 3
id^^3 5
)^^5 6
;^^6 7
normalHandle__ 
=__ 
RenderTargetHandle__ 1
.__1 2
CameraTarget__2 >
;__> ?
depthHandle`` 
=`` 
RenderTargetHandle`` 0
.``0 1
CameraTarget``1 =
;``= >
}aa 
}bb 	
}cc 
}dd ˚‡
úD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\ForwardRenderer.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
public		 

enum		 
RenderingMode		 
{

 
Forward 
, 
Deferred 
} 
; 
public 

sealed 
class 
ForwardRenderer '
:( )
ScriptableRenderer* <
{ 
const 
int $
k_DepthStencilBufferBits *
=+ ,
$num- /
;/ 0
private 
static 
class 
	Profiling &
{ 	
private 
const 
string  
k_Name! '
=( )
nameof* 0
(0 1
ForwardRenderer1 @
)@ A
;A B
public 
static 
readonly "
ProfilingSampler# 3$
createCameraRenderTarget4 L
=M N
newO R
ProfilingSamplerS c
(c d
$"d f
{f g
k_Nameg m
}m n
.n o
{o p
nameofp v
(v w%
CreateCameraRenderTarget	w è
)
è ê
}
ê ë
"
ë í
)
í ì
;
ì î
} 	
internal!! 
RenderingMode!! 
renderingMode!! ,
{!!- .
get!!/ 2
{!!3 4
return!!5 ;
RenderingMode!!< I
.!!I J
Forward!!J Q
;!!Q R
}!!T U
}!!V W
internal## 
RenderingMode## 
actualRenderingMode## 2
{##3 4
get##5 8
{##9 :
return##; A
GL##B D
.##D E
	wireframe##E N
||##O Q
m_DeferredLights##R b
==##c e
null##f j
||##k m
!##n o
m_DeferredLights##o 
.	## Ä)
IsRuntimeSupportedThisFrame
##Ä õ
(
##õ ú
)
##ú ù
?
##ü †
RenderingMode
##° Æ
.
##Æ Ø
Forward
##Ø ∂
:
##∑ ∏
this
##π Ω
.
##Ω æ
renderingMode
##æ À
;
##À Ã
}
##Õ Œ
}
##œ –
internal$$ 
bool$$ "
accurateGbufferNormals$$ ,
{$$- .
get$$/ 2
{$$3 4
return$$5 ;
m_DeferredLights$$< L
!=$$M O
null$$P T
?$$U V
m_DeferredLights$$W g
.$$g h"
AccurateGbufferNormals$$h ~
:	$$ Ä
false
$$Å Ü
;
$$Ü á
}
$$à â
}
$$ä ã
ColorGradingLutPass%% !
m_ColorGradingLutPass%% 1
;%%1 2
DepthOnlyPass&& 
m_DepthPrepass&& $
;&&$ %
DepthNormalOnlyPass''  
m_DepthNormalPrepass'' 0
;''0 1%
MainLightShadowCasterPass(( !'
m_MainLightShadowCasterPass((" =
;((= >,
 AdditionalLightsShadowCasterPass)) (.
"m_AdditionalLightsShadowCasterPass))) K
;))K L
GBufferPass** 
m_GBufferPass** !
;**! "
CopyDepthPass++ "
m_GBufferCopyDepthPass++ ,
;++, -
TileDepthRangePass,,  
m_TileDepthRangePass,, /
;,,/ 0
TileDepthRangePass-- %
m_TileDepthRangeExtraPass-- 4
;--4 5
DeferredPass.. 
m_DeferredPass.. #
;..# $
DrawObjectsPass// )
m_RenderOpaqueForwardOnlyPass// 5
;//5 6
DrawObjectsPass00 %
m_RenderOpaqueForwardPass00 1
;001 2
DrawSkyboxPass11 
m_DrawSkyboxPass11 '
;11' (
CopyDepthPass22 
m_CopyDepthPass22 %
;22% &
CopyColorPass33 
m_CopyColorPass33 %
;33% &#
TransparentSettingsPass44 %
m_TransparentSettingsPass44  9
;449 :
DrawObjectsPass55 *
m_RenderTransparentForwardPass55 6
;556 7,
 InvokeOnRenderObjectCallbackPass66 ((
m_OnRenderObjectCallbackPass66) E
;66E F
PostProcessPass77 
m_PostProcessPass77 )
;77) *
PostProcessPass88 "
m_FinalPostProcessPass88 .
;88. /
FinalBlitPass99 
m_FinalBlitPass99 %
;99% &
CapturePass:: 
m_CapturePass:: !
;::! "
XROcclusionMeshPass<< !
m_XROcclusionMeshPass<< 1
;<<1 2
CopyDepthPass== 
m_XRCopyDepthPass== '
;==' ("
SceneViewDepthCopyPass@@ $
m_SceneViewDepthCopyPass@@ 7
;@@7 8
RenderTargetHandleCC )
m_ActiveCameraColorAttachmentCC 8
;CC8 9
RenderTargetHandleDD )
m_ActiveCameraDepthAttachmentDD 8
;DD8 9
RenderTargetHandleEE #
m_CameraColorAttachmentEE 2
;EE2 3
RenderTargetHandleFF #
m_CameraDepthAttachmentFF 2
;FF2 3
RenderTargetHandleGG 
m_DepthTextureGG )
;GG) *
RenderTargetHandleHH 
m_NormalsTextureHH +
;HH+ ,
RenderTargetHandleII 
[II 
]II 
m_GBufferHandlesII -
;II- .
RenderTargetHandleJJ 
m_OpaqueColorJJ (
;JJ( )
RenderTargetHandleKK #
m_AfterPostProcessColorKK 2
;KK2 3
RenderTargetHandleLL 
m_ColorGradingLutLL ,
;LL, -
RenderTargetHandleNN 
m_DepthInfoTextureNN -
;NN- .
RenderTargetHandleOO "
m_TileDepthInfoTextureOO 1
;OO1 2
ForwardLightsQQ 
m_ForwardLightsQQ %
;QQ% &
DeferredLightsRR 
m_DeferredLightsRR '
;RR' (
RenderingModeTT 
m_RenderingModeTT %
;TT% &
StencilStateVV !
m_DefaultStencilStateVV *
;VV* +
MaterialXX 
m_BlitMaterialXX 
;XX  
MaterialYY 
m_CopyDepthMaterialYY $
;YY$ %
MaterialZZ 
m_SamplingMaterialZZ #
;ZZ# $
Material[[ (
m_ScreenspaceShadowsMaterial[[ -
;[[- .
Material\\ #
m_TileDepthInfoMaterial\\ (
;\\( )
Material]] "
m_TileDeferredMaterial]] '
;]]' (
Material^^ %
m_StencilDeferredMaterial^^ *
;^^* +
public`` 
ForwardRenderer`` 
(`` 
ForwardRendererData`` 2
data``3 7
)``7 8
:``9 :
base``; ?
(``? @
data``@ D
)``D E
{aa 	#
UniversalRenderPipelinecc #
.cc# $

m_XRSystemcc$ .
.cc. /"
InitializeXRSystemDatacc/ E
(ccE F
dataccF J
.ccJ K
xrSystemDataccK W
)ccW X
;ccX Y
m_BlitMaterialff 
=ff 
	CoreUtilsff &
.ff& ' 
CreateEngineMaterialff' ;
(ff; <
dataff< @
.ff@ A
shadersffA H
.ffH I
blitPSffI O
)ffO P
;ffP Q
m_CopyDepthMaterialgg 
=gg  !
	CoreUtilsgg" +
.gg+ , 
CreateEngineMaterialgg, @
(gg@ A
dataggA E
.ggE F
shadersggF M
.ggM N
copyDepthPSggN Y
)ggY Z
;ggZ [
m_SamplingMaterialhh 
=hh  
	CoreUtilshh! *
.hh* + 
CreateEngineMaterialhh+ ?
(hh? @
datahh@ D
.hhD E
shadershhE L
.hhL M

samplingPShhM W
)hhW X
;hhX Y(
m_ScreenspaceShadowsMaterialii (
=ii) *
	CoreUtilsii+ 4
.ii4 5 
CreateEngineMaterialii5 I
(iiI J
dataiiJ N
.iiN O
shadersiiO V
.iiV W
screenSpaceShadowPSiiW j
)iij k
;iik l%
m_StencilDeferredMaterialll %
=ll& '
	CoreUtilsll( 1
.ll1 2 
CreateEngineMaterialll2 F
(llF G
datallG K
.llK L
shadersllL S
.llS T
stencilDeferredPSllT e
)lle f
;llf g
StencilStateDatann 
stencilDatann (
=nn) *
datann+ /
.nn/ 0
defaultStencilStatenn0 C
;nnC D!
m_DefaultStencilStateoo !
=oo" #
StencilStateoo$ 0
.oo0 1
defaultValueoo1 =
;oo= >!
m_DefaultStencilStatepp !
.pp! "
enabledpp" )
=pp* +
stencilDatapp, 7
.pp7 8 
overrideStencilStatepp8 L
;ppL M!
m_DefaultStencilStateqq !
.qq! "
SetCompareFunctionqq" 4
(qq4 5
stencilDataqq5 @
.qq@ A"
stencilCompareFunctionqqA W
)qqW X
;qqX Y!
m_DefaultStencilStaterr !
.rr! "
SetPassOperationrr" 2
(rr2 3
stencilDatarr3 >
.rr> ?
passOperationrr? L
)rrL M
;rrM N!
m_DefaultStencilStatess !
.ss! "
SetFailOperationss" 2
(ss2 3
stencilDatass3 >
.ss> ?
failOperationss? L
)ssL M
;ssM N!
m_DefaultStencilStatett !
.tt! "
SetZFailOperationtt" 3
(tt3 4
stencilDatatt4 ?
.tt? @
zFailOperationtt@ N
)ttN O
;ttO P
m_ForwardLightsvv 
=vv 
newvv !
ForwardLightsvv" /
(vv/ 0
)vv0 1
;vv1 2
thisxx 
.xx 
m_RenderingModexx  
=xx! "
RenderingModexx# 0
.xx0 1
Forwardxx1 8
;xx8 9'
m_MainLightShadowCasterPass|| '
=||( )
new||* -%
MainLightShadowCasterPass||. G
(||G H
RenderPassEvent||H W
.||W X"
BeforeRenderingShadows||X n
)||n o
;||o p.
"m_AdditionalLightsShadowCasterPass}} .
=}}/ 0
new}}1 4,
 AdditionalLightsShadowCasterPass}}5 U
(}}U V
RenderPassEvent}}V e
.}}e f"
BeforeRenderingShadows}}f |
)}}| }
;}}} ~!
m_XROcclusionMeshPass !
=" #
new$ '
XROcclusionMeshPass( ;
(; <
RenderPassEvent< K
.K L"
BeforeRenderingOpaquesL b
)b c
;c d
m_XRCopyDepthPass
ÅÅ 
=
ÅÅ 
new
ÅÅ  #
CopyDepthPass
ÅÅ$ 1
(
ÅÅ1 2
RenderPassEvent
ÅÅ2 A
.
ÅÅA B
AfterRendering
ÅÅB P
+
ÅÅQ R
$num
ÅÅS T
,
ÅÅT U!
m_CopyDepthMaterial
ÅÅV i
)
ÅÅi j
;
ÅÅj k
m_DepthPrepass
ÉÉ 
=
ÉÉ 
new
ÉÉ  
DepthOnlyPass
ÉÉ! .
(
ÉÉ. /
RenderPassEvent
ÉÉ/ >
.
ÉÉ> ?&
BeforeRenderingPrepasses
ÉÉ? W
,
ÉÉW X
RenderQueueRange
ÉÉY i
.
ÉÉi j
opaque
ÉÉj p
,
ÉÉp q
data
ÉÉr v
.
ÉÉv w
opaqueLayerMaskÉÉw Ü
)ÉÉÜ á
;ÉÉá à"
m_DepthNormalPrepass
ÑÑ  
=
ÑÑ! "
new
ÑÑ# &!
DepthNormalOnlyPass
ÑÑ' :
(
ÑÑ: ;
RenderPassEvent
ÑÑ; J
.
ÑÑJ K&
BeforeRenderingPrepasses
ÑÑK c
,
ÑÑc d
RenderQueueRange
ÑÑe u
.
ÑÑu v
opaque
ÑÑv |
,
ÑÑ| }
dataÑÑ~ Ç
.ÑÑÇ É
opaqueLayerMaskÑÑÉ í
)ÑÑí ì
;ÑÑì î#
m_ColorGradingLutPass
ÖÖ !
=
ÖÖ" #
new
ÖÖ$ '!
ColorGradingLutPass
ÖÖ( ;
(
ÖÖ; <
RenderPassEvent
ÖÖ< K
.
ÖÖK L&
BeforeRenderingPrepasses
ÖÖL d
,
ÖÖd e
data
ÖÖf j
.
ÖÖj k
postProcessData
ÖÖk z
)
ÖÖz {
;
ÖÖ{ |
if
áá 
(
áá 
this
áá 
.
áá 
renderingMode
áá "
==
áá# %
RenderingMode
áá& 3
.
áá3 4
Deferred
áá4 <
)
áá< =
{
àà 
m_DeferredLights
ââ  
=
ââ! "
new
ââ# &
DeferredLights
ââ' 5
(
ââ5 6%
m_TileDepthInfoMaterial
ââ6 M
,
ââM N$
m_TileDeferredMaterial
ââO e
,
ââe f(
m_StencilDeferredMaterialââg Ä
)ââÄ Å
;ââÅ Ç
m_DeferredLights
ää  
.
ää  !$
AccurateGbufferNormals
ää! 7
=
ää8 9
data
ää: >
.
ää> ?$
accurateGbufferNormals
ää? U
;
ääU V
m_DeferredLights
åå  
.
åå  !"
TiledDeferredShading
åå! 5
=
åå6 7
false
åå8 =
;
åå= >*
UniversalRenderPipelineAsset
çç ,
urpAsset
çç- 5
=
çç6 7
GraphicsSettings
çç8 H
.
ççH I!
renderPipelineAsset
ççI \
as
çç] _*
UniversalRenderPipelineAsset
çç` |
;
çç| }
m_GBufferPass
èè 
=
èè 
new
èè  #
GBufferPass
èè$ /
(
èè/ 0
RenderPassEvent
èè0 ?
.
èè? @$
BeforeRenderingOpaques
èè@ V
,
èèV W
RenderQueueRange
èèX h
.
èèh i
opaque
èèi o
,
èèo p
data
èèq u
.
èèu v
opaqueLayerMaskèèv Ö
,èèÖ Ü%
m_DefaultStencilStateèèá ú
,èèú ù
stencilDataèèû ©
.èè© ™ 
stencilReferenceèè™ ∫
,èè∫ ª 
m_DeferredLightsèèº Ã
)èèÃ Õ
;èèÕ Œ
StencilState
òò %
forwardOnlyStencilState
òò 4
=
òò5 6
DeferredLights
òò7 E
.
òòE F
OverwriteStencil
òòF V
(
òòV W#
m_DefaultStencilState
òòW l
,
òòl m
(
òòn o
int
òòo r
)
òòr s
StencilUsage
òòs 
.òò Ä
MaterialMaskòòÄ å
)òòå ç
;òòç é
ShaderTagId
ôô 
[
ôô 
]
ôô %
forwardOnlyShaderTagIds
ôô 5
=
ôô6 7
new
ôô8 ;
ShaderTagId
ôô< G
[
ôôG H
]
ôôH I
{
ôôJ K
new
öö 
ShaderTagId
öö #
(
öö# $
$str
öö$ :
)
öö: ;
,
öö; <
new
õõ 
ShaderTagId
õõ #
(
õõ# $
$str
õõ$ 5
)
õõ5 6
,
õõ6 7
new
úú 
ShaderTagId
úú #
(
úú# $
$str
úú$ 8
)
úú8 9
}
ùù 
;
ùù 
int
ûû #
forwardOnlyStencilRef
ûû )
=
ûû* +
stencilData
ûû, 7
.
ûû7 8
stencilReference
ûû8 H
|
ûûI J
(
ûûK L
int
ûûL O
)
ûûO P
StencilUsage
ûûP \
.
ûû\ ]
MaterialUnlit
ûû] j
;
ûûj k+
m_RenderOpaqueForwardOnlyPass
üü -
=
üü. /
new
üü0 3
DrawObjectsPass
üü4 C
(
üüC D
$str
üüD a
,
üüa b%
forwardOnlyShaderTagIds
üüc z
,
üüz {
trueüü| Ä
,üüÄ Å
RenderPassEventüüÇ ë
.üüë í&
BeforeRenderingOpaquesüüí ®
+üü© ™
$numüü´ ¨
,üü¨ ≠ 
RenderQueueRangeüüÆ æ
.üüæ ø
opaqueüüø ≈
,üü≈ ∆
dataüü« À
.üüÀ Ã
opaqueLayerMasküüÃ €
,üü€ ‹'
forwardOnlyStencilStateüü› Ù
,üüÙ ı%
forwardOnlyStencilRefüüˆ ã
)üüã å
;üüå ç$
m_GBufferCopyDepthPass
†† &
=
††' (
new
††) ,
CopyDepthPass
††- :
(
††: ;
RenderPassEvent
††; J
.
††J K$
BeforeRenderingOpaques
††K a
+
††b c
$num
††d e
,
††e f!
m_CopyDepthMaterial
††g z
)
††z {
;
††{ |"
m_TileDepthRangePass
°° $
=
°°% &
new
°°' * 
TileDepthRangePass
°°+ =
(
°°= >
RenderPassEvent
°°> M
.
°°M N$
BeforeRenderingOpaques
°°N d
+
°°e f
$num
°°g h
,
°°h i
m_DeferredLights
°°j z
,
°°z {
$num
°°| }
)
°°} ~
;
°°~ '
m_TileDepthRangeExtraPass
¢¢ )
=
¢¢* +
new
¢¢, / 
TileDepthRangePass
¢¢0 B
(
¢¢B C
RenderPassEvent
¢¢C R
.
¢¢R S$
BeforeRenderingOpaques
¢¢S i
+
¢¢j k
$num
¢¢l m
,
¢¢m n
m_DeferredLights
¢¢o 
,¢¢ Ä
$num¢¢Å Ç
)¢¢Ç É
;¢¢É Ñ
m_DeferredPass
££ 
=
££  
new
££! $
DeferredPass
££% 1
(
££1 2
RenderPassEvent
££2 A
.
££A B$
BeforeRenderingOpaques
££B X
+
££Y Z
$num
££[ \
,
££\ ]
m_DeferredLights
££^ n
)
££n o
;
££o p
}
§§ '
m_RenderOpaqueForwardPass
ßß %
=
ßß& '
new
ßß( +
DrawObjectsPass
ßß, ;
(
ßß; <
URPProfileId
ßß< H
.
ßßH I
DrawOpaqueObjects
ßßI Z
,
ßßZ [
true
ßß\ `
,
ßß` a
RenderPassEvent
ßßb q
.
ßßq r%
BeforeRenderingOpaquesßßr à
,ßßà â 
RenderQueueRangeßßä ö
.ßßö õ
opaqueßßõ °
,ßß° ¢
dataßß£ ß
.ßßß ®
opaqueLayerMaskßß® ∑
,ßß∑ ∏%
m_DefaultStencilStateßßπ Œ
,ßßŒ œ
stencilDataßß– €
.ßß€ ‹ 
stencilReferenceßß‹ Ï
)ßßÏ Ì
;ßßÌ Ó
m_CopyDepthPass
©© 
=
©© 
new
©© !
CopyDepthPass
©©" /
(
©©/ 0
RenderPassEvent
©©0 ?
.
©©? @"
AfterRenderingSkybox
©©@ T
,
©©T U!
m_CopyDepthMaterial
©©V i
)
©©i j
;
©©j k
m_DrawSkyboxPass
™™ 
=
™™ 
new
™™ "
DrawSkyboxPass
™™# 1
(
™™1 2
RenderPassEvent
™™2 A
.
™™A B#
BeforeRenderingSkybox
™™B W
)
™™W X
;
™™X Y
m_CopyColorPass
´´ 
=
´´ 
new
´´ !
CopyColorPass
´´" /
(
´´/ 0
RenderPassEvent
´´0 ?
.
´´? @"
AfterRenderingSkybox
´´@ T
,
´´T U 
m_SamplingMaterial
´´V h
,
´´h i
m_BlitMaterial
´´j x
)
´´x y
;
´´y z
{
ØØ '
m_TransparentSettingsPass
∞∞ )
=
∞∞* +
new
∞∞, /%
TransparentSettingsPass
∞∞0 G
(
∞∞G H
RenderPassEvent
∞∞H W
.
∞∞W X)
BeforeRenderingTransparents
∞∞X s
,
∞∞s t
data
∞∞u y
.
∞∞y z'
shadowTransparentReceive∞∞z í
)∞∞í ì
;∞∞ì î,
m_RenderTransparentForwardPass
±± .
=
±±/ 0
new
±±1 4
DrawObjectsPass
±±5 D
(
±±D E
URPProfileId
±±E Q
.
±±Q R$
DrawTransparentObjects
±±R h
,
±±h i
false
±±j o
,
±±o p
RenderPassEvent±±q Ä
.±±Ä Å+
BeforeRenderingTransparents±±Å ú
,±±ú ù 
RenderQueueRange±±û Æ
.±±Æ Ø
transparent±±Ø ∫
,±±∫ ª
data±±º ¿
.±±¿ ¡$
transparentLayerMask±±¡ ’
,±±’ ÷%
m_DefaultStencilState±±◊ Ï
,±±Ï Ì
stencilData±±Ó ˘
.±±˘ ˙ 
stencilReference±±˙ ä
)±±ä ã
;±±ã å
}
≤≤ *
m_OnRenderObjectCallbackPass
≥≥ (
=
≥≥) *
new
≥≥+ ..
 InvokeOnRenderObjectCallbackPass
≥≥/ O
(
≥≥O P
RenderPassEvent
≥≥P _
.
≥≥_ `+
BeforeRenderingPostProcessing
≥≥` }
)
≥≥} ~
;
≥≥~ 
m_PostProcessPass
¥¥ 
=
¥¥ 
new
¥¥  #
PostProcessPass
¥¥$ 3
(
¥¥3 4
RenderPassEvent
¥¥4 C
.
¥¥C D+
BeforeRenderingPostProcessing
¥¥D a
,
¥¥a b
data
¥¥c g
.
¥¥g h
postProcessData
¥¥h w
,
¥¥w x
m_BlitMaterial¥¥y á
)¥¥á à
;¥¥à â$
m_FinalPostProcessPass
µµ "
=
µµ# $
new
µµ% (
PostProcessPass
µµ) 8
(
µµ8 9
RenderPassEvent
µµ9 H
.
µµH I
AfterRendering
µµI W
+
µµX Y
$num
µµZ [
,
µµ[ \
data
µµ] a
.
µµa b
postProcessData
µµb q
,
µµq r
m_BlitMaterialµµs Å
)µµÅ Ç
;µµÇ É
m_CapturePass
∂∂ 
=
∂∂ 
new
∂∂ 
CapturePass
∂∂  +
(
∂∂+ ,
RenderPassEvent
∂∂, ;
.
∂∂; <
AfterRendering
∂∂< J
)
∂∂J K
;
∂∂K L
m_FinalBlitPass
∑∑ 
=
∑∑ 
new
∑∑ !
FinalBlitPass
∑∑" /
(
∑∑/ 0
RenderPassEvent
∑∑0 ?
.
∑∑? @
AfterRendering
∑∑@ N
+
∑∑O P
$num
∑∑Q R
,
∑∑R S
m_BlitMaterial
∑∑T b
)
∑∑b c
;
∑∑c d&
m_SceneViewDepthCopyPass
∫∫ $
=
∫∫% &
new
∫∫' *$
SceneViewDepthCopyPass
∫∫+ A
(
∫∫A B
RenderPassEvent
∫∫B Q
.
∫∫Q R
AfterRendering
∫∫R `
+
∫∫a b
$num
∫∫c d
,
∫∫d e!
m_CopyDepthMaterial
∫∫f y
)
∫∫y z
;
∫∫z {%
m_CameraColorAttachment
øø #
.
øø# $
Init
øø$ (
(
øø( )
$str
øø) >
)
øø> ?
;
øø? @%
m_CameraDepthAttachment
¿¿ #
.
¿¿# $
Init
¿¿$ (
(
¿¿( )
$str
¿¿) A
)
¿¿A B
;
¿¿B C
m_DepthTexture
¡¡ 
.
¡¡ 
Init
¡¡ 
(
¡¡  
$str
¡¡  5
)
¡¡5 6
;
¡¡6 7
m_NormalsTexture
¬¬ 
.
¬¬ 
Init
¬¬ !
(
¬¬! "
$str
¬¬" 9
)
¬¬9 :
;
¬¬: ;
if
√√ 
(
√√ 
this
√√ 
.
√√ 
renderingMode
√√ "
==
√√# %
RenderingMode
√√& 3
.
√√3 4
Deferred
√√4 <
)
√√< =
{
ƒƒ 
m_GBufferHandles
≈≈  
=
≈≈! "
new
≈≈# & 
RenderTargetHandle
≈≈' 9
[
≈≈9 :
(
≈≈: ;
int
≈≈; >
)
≈≈> ?
DeferredLights
≈≈? M
.
≈≈M N
GBufferHandles
≈≈N \
.
≈≈\ ]
Count
≈≈] b
]
≈≈b c
;
≈≈c d
m_GBufferHandles
∆∆  
[
∆∆  !
(
∆∆! "
int
∆∆" %
)
∆∆% &
DeferredLights
∆∆& 4
.
∆∆4 5
GBufferHandles
∆∆5 C
.
∆∆C D
DepthAsColor
∆∆D P
]
∆∆P Q
.
∆∆Q R
Init
∆∆R V
(
∆∆V W
$str
∆∆W m
)
∆∆m n
;
∆∆n o
m_GBufferHandles
««  
[
««  !
(
««! "
int
««" %
)
««% &
DeferredLights
««& 4
.
««4 5
GBufferHandles
««5 C
.
««C D
Albedo
««D J
]
««J K
.
««K L
Init
««L P
(
««P Q
$str
««Q \
)
««\ ]
;
««] ^
m_GBufferHandles
»»  
[
»»  !
(
»»! "
int
»»" %
)
»»% &
DeferredLights
»»& 4
.
»»4 5
GBufferHandles
»»5 C
.
»»C D
SpecularMetallic
»»D T
]
»»T U
.
»»U V
Init
»»V Z
(
»»Z [
$str
»»[ f
)
»»f g
;
»»g h
m_GBufferHandles
……  
[
……  !
(
……! "
int
……" %
)
……% &
DeferredLights
……& 4
.
……4 5
GBufferHandles
……5 C
.
……C D
NormalSmoothness
……D T
]
……T U
.
……U V
Init
……V Z
(
……Z [
$str
……[ f
)
……f g
;
……g h
m_GBufferHandles
    
[
    !
(
  ! "
int
  " %
)
  % &
DeferredLights
  & 4
.
  4 5
GBufferHandles
  5 C
.
  C D
Lighting
  D L
]
  L M
=
  N O
new
  P S 
RenderTargetHandle
  T f
(
  f g
)
  g h
;
  h i
m_GBufferHandles
ÀÀ  
[
ÀÀ  !
(
ÀÀ! "
int
ÀÀ" %
)
ÀÀ% &
DeferredLights
ÀÀ& 4
.
ÀÀ4 5
GBufferHandles
ÀÀ5 C
.
ÀÀC D

ShadowMask
ÀÀD N
]
ÀÀN O
.
ÀÀO P
Init
ÀÀP T
(
ÀÀT U
$str
ÀÀU `
)
ÀÀ` a
;
ÀÀa b
}
ÃÃ 
m_OpaqueColor
ÕÕ 
.
ÕÕ 
Init
ÕÕ 
(
ÕÕ 
$str
ÕÕ 5
)
ÕÕ5 6
;
ÕÕ6 7%
m_AfterPostProcessColor
ŒŒ #
.
ŒŒ# $
Init
ŒŒ$ (
(
ŒŒ( )
$str
ŒŒ) C
)
ŒŒC D
;
ŒŒD E
m_ColorGradingLut
œœ 
.
œœ 
Init
œœ "
(
œœ" #
$str
œœ# 8
)
œœ8 9
;
œœ9 : 
m_DepthInfoTexture
–– 
.
–– 
Init
–– #
(
––# $
$str
––$ 7
)
––7 8
;
––8 9$
m_TileDepthInfoTexture
—— "
.
——" #
Init
——# '
(
——' (
$str
——( ?
)
——? @
;
——@ A(
supportedRenderingFeatures
”” &
=
””' (
new
””) ,
RenderingFeatures
””- >
(
””> ?
)
””? @
{
‘‘ 
cameraStacking
’’ 
=
’’  
true
’’! %
,
’’% &
}
÷÷ 
;
÷÷ 
if
ÿÿ 
(
ÿÿ 
this
ÿÿ 
.
ÿÿ 
renderingMode
ÿÿ "
==
ÿÿ# %
RenderingMode
ÿÿ& 3
.
ÿÿ3 4
Deferred
ÿÿ4 <
)
ÿÿ< =
{
ŸŸ ,
unsupportedGraphicsDeviceTypes
⁄⁄ .
=
⁄⁄/ 0
new
⁄⁄1 4 
GraphicsDeviceType
⁄⁄5 G
[
⁄⁄G H
]
⁄⁄H I
{
⁄⁄J K 
GraphicsDeviceType
€€ &
.
€€& '

OpenGLCore
€€' 1
,
€€1 2 
GraphicsDeviceType
‹‹ &
.
‹‹& '
	OpenGLES2
‹‹' 0
,
‹‹0 1 
GraphicsDeviceType
›› &
.
››& '
	OpenGLES3
››' 0
}
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 
}
‡‡ 	
	protected
„„ 
override
„„ 
void
„„ 
Dispose
„„  '
(
„„' (
bool
„„( ,
	disposing
„„- 6
)
„„6 7
{
‰‰ 	
m_PostProcessPass
ÊÊ 
.
ÊÊ 
Cleanup
ÊÊ %
(
ÊÊ% &
)
ÊÊ& '
;
ÊÊ' ($
m_FinalPostProcessPass
ÁÁ "
.
ÁÁ" #
Cleanup
ÁÁ# *
(
ÁÁ* +
)
ÁÁ+ ,
;
ÁÁ, -#
m_ColorGradingLutPass
ËË !
.
ËË! "
Cleanup
ËË" )
(
ËË) *
)
ËË* +
;
ËË+ ,
	CoreUtils
ÍÍ 
.
ÍÍ 
Destroy
ÍÍ 
(
ÍÍ 
m_BlitMaterial
ÍÍ ,
)
ÍÍ, -
;
ÍÍ- .
	CoreUtils
ÎÎ 
.
ÎÎ 
Destroy
ÎÎ 
(
ÎÎ !
m_CopyDepthMaterial
ÎÎ 1
)
ÎÎ1 2
;
ÎÎ2 3
	CoreUtils
ÏÏ 
.
ÏÏ 
Destroy
ÏÏ 
(
ÏÏ  
m_SamplingMaterial
ÏÏ 0
)
ÏÏ0 1
;
ÏÏ1 2
	CoreUtils
ÌÌ 
.
ÌÌ 
Destroy
ÌÌ 
(
ÌÌ *
m_ScreenspaceShadowsMaterial
ÌÌ :
)
ÌÌ: ;
;
ÌÌ; <
	CoreUtils
ÓÓ 
.
ÓÓ 
Destroy
ÓÓ 
(
ÓÓ %
m_TileDepthInfoMaterial
ÓÓ 5
)
ÓÓ5 6
;
ÓÓ6 7
	CoreUtils
ÔÔ 
.
ÔÔ 
Destroy
ÔÔ 
(
ÔÔ $
m_TileDeferredMaterial
ÔÔ 4
)
ÔÔ4 5
;
ÔÔ5 6
	CoreUtils
 
.
 
Destroy
 
(
 '
m_StencilDeferredMaterial
 7
)
7 8
;
8 9
}
ÒÒ 	
public
ÙÙ 
override
ÙÙ 
void
ÙÙ 
Setup
ÙÙ "
(
ÙÙ" #%
ScriptableRenderContext
ÙÙ# :
context
ÙÙ; B
,
ÙÙB C
ref
ÙÙD G
RenderingData
ÙÙH U
renderingData
ÙÙV c
)
ÙÙc d
{
ıı 	
Camera
˘˘ 
camera
˘˘ 
=
˘˘ 
renderingData
˘˘ )
.
˘˘) *

cameraData
˘˘* 4
.
˘˘4 5
camera
˘˘5 ;
;
˘˘; <
ref
˙˙ 

CameraData
˙˙ 

cameraData
˙˙ %
=
˙˙& '
ref
˙˙( +
renderingData
˙˙, 9
.
˙˙9 :

cameraData
˙˙: D
;
˙˙D E%
RenderTextureDescriptor
˚˚ #$
cameraTargetDescriptor
˚˚$ :
=
˚˚; <
renderingData
˚˚= J
.
˚˚J K

cameraData
˚˚K U
.
˚˚U V$
cameraTargetDescriptor
˚˚V l
;
˚˚l m
bool
˛˛ %
isOffscreenDepthTexture
˛˛ (
=
˛˛) *

cameraData
˛˛+ 5
.
˛˛5 6
targetTexture
˛˛6 C
!=
˛˛D F
null
˛˛G K
&&
˛˛L N

cameraData
˛˛O Y
.
˛˛Y Z
targetTexture
˛˛Z g
.
˛˛g h
format
˛˛h n
==
˛˛o q"
RenderTextureFormat˛˛r Ö
.˛˛Ö Ü
Depth˛˛Ü ã
;˛˛ã å
if
ˇˇ 
(
ˇˇ %
isOffscreenDepthTexture
ˇˇ '
)
ˇˇ' (
{
ÄÄ #
ConfigureCameraTarget
ÅÅ %
(
ÅÅ% &&
BuiltinRenderTextureType
ÅÅ& >
.
ÅÅ> ?
CameraTarget
ÅÅ? K
,
ÅÅK L&
BuiltinRenderTextureType
ÅÅM e
.
ÅÅe f
CameraTarget
ÅÅf r
)
ÅÅr s
;
ÅÅs t
AddRenderPasses
ÇÇ 
(
ÇÇ  
ref
ÇÇ  #
renderingData
ÇÇ$ 1
)
ÇÇ1 2
;
ÇÇ2 3
EnqueuePass
ÉÉ 
(
ÉÉ '
m_RenderOpaqueForwardPass
ÉÉ 5
)
ÉÉ5 6
;
ÉÉ6 7
EnqueuePass
ÜÜ 
(
ÜÜ 
m_DrawSkyboxPass
ÜÜ ,
)
ÜÜ, -
;
ÜÜ- .
EnqueuePass
ãã 
(
ãã ,
m_RenderTransparentForwardPass
ãã :
)
ãã: ;
;
ãã; <
return
åå 
;
åå 
}
çç 
if
èè 
(
èè 
m_DeferredLights
èè  
!=
èè! #
null
èè$ (
)
èè( )
m_DeferredLights
êê  
.
êê  !&
ResolveMixedLightingMode
êê! 9
(
êê9 :
ref
êê: =
renderingData
êê> K
)
êêK L
;
êêL M
bool
ìì 
isPreviewCamera
ìì  
=
ìì! "

cameraData
ìì# -
.
ìì- .
isPreviewCamera
ìì. =
;
ìì= >
var
îî  
createColorTexture
îî "
=
îî# $
rendererFeatures
îî% 5
.
îî5 6
Count
îî6 ;
!=
îî< >
$num
îî? @
&&
îîA C
!
îîD E
isPreviewCamera
îîE T
;
îîT U
if
ïï 
(
ïï  
createColorTexture
ïï "
)
ïï" #
{
ññ +
m_ActiveCameraColorAttachment
óó -
=
óó. /%
m_CameraColorAttachment
óó0 G
;
óóG H
var
òò '
activeColorRenderTargetId
òò -
=
òò. /+
m_ActiveCameraColorAttachment
òò0 M
.
òòM N

Identifier
òòN X
(
òòX Y
)
òòY Z
;
òòZ [
if
öö 
(
öö 

cameraData
öö 
.
öö 
xr
öö !
.
öö! "
enabled
öö" )
)
öö) *'
activeColorRenderTargetId
öö+ D
=
ööE F
new
ööG J$
RenderTargetIdentifier
ööK a
(
ööa b'
activeColorRenderTargetId
ööb {
,
öö{ |
$num
öö} ~
,
öö~ 
CubemapFaceööÄ ã
.ööã å
Unknownööå ì
,ööì î
-ööï ñ
$numööñ ó
)ööó ò
;ööò ô(
ConfigureCameraColorTarget
úú *
(
úú* +'
activeColorRenderTargetId
úú+ D
)
úúD E
;
úúE F
}
ùù &
isCameraColorTargetValid
†† $
=
††% &
true
††' +
;
††+ ,
AddRenderPasses
°° 
(
°° 
ref
°° 
renderingData
°°  -
)
°°- .
;
°°. /&
isCameraColorTargetValid
¢¢ $
=
¢¢% &
false
¢¢' ,
;
¢¢, -$
RenderPassInputSummary
££ "
renderPassInputs
££# 3
=
££4 5!
GetRenderPassInputs
££6 I
(
££I J
ref
££J M
renderingData
££N [
)
££[ \
;
££\ ]
bool
¶¶ !
applyPostProcessing
¶¶ $
=
¶¶% &

cameraData
¶¶' 1
.
¶¶1 2 
postProcessEnabled
¶¶2 D
;
¶¶D E
bool
©© 
anyPostProcessing
©© "
=
©©# $
renderingData
©©% 2
.
©©2 3#
postProcessingEnabled
©©3 H
;
©©H I
bool
¨¨ %
generateColorGradingLUT
¨¨ (
=
¨¨) *

cameraData
¨¨+ 5
.
¨¨5 6 
postProcessEnabled
¨¨6 H
;
¨¨H I
bool
≠≠ 
isSceneViewCamera
≠≠ "
=
≠≠# $

cameraData
≠≠% /
.
≠≠/ 0
isSceneViewCamera
≠≠0 A
;
≠≠A B
bool
ÆÆ "
requiresDepthTexture
ÆÆ %
=
ÆÆ& '

cameraData
ÆÆ( 2
.
ÆÆ2 3"
requiresDepthTexture
ÆÆ3 G
||
ÆÆH J
renderPassInputs
ÆÆK [
.
ÆÆ[ \"
requiresDepthTexture
ÆÆ\ p
||
ÆÆq s
this
ÆÆt x
.
ÆÆx y"
actualRenderingModeÆÆy å
==ÆÆç è
RenderingModeÆÆê ù
.ÆÆù û
DeferredÆÆû ¶
;ÆÆ¶ ß
bool
∞∞ 
mainLightShadows
∞∞ !
=
∞∞" #)
m_MainLightShadowCasterPass
∞∞$ ?
.
∞∞? @
Setup
∞∞@ E
(
∞∞E F
ref
∞∞F I
renderingData
∞∞J W
)
∞∞W X
;
∞∞X Y
bool
±± $
additionalLightShadows
±± '
=
±±( )0
"m_AdditionalLightsShadowCasterPass
±±* L
.
±±L M
Setup
±±M R
(
±±R S
ref
±±S V
renderingData
±±W d
)
±±d e
;
±±e f
bool
≤≤ *
transparentsNeedSettingsPass
≤≤ -
=
≤≤. /'
m_TransparentSettingsPass
≤≤0 I
.
≤≤I J
Setup
≤≤J O
(
≤≤O P
ref
≤≤P S
renderingData
≤≤T a
)
≤≤a b
;
≤≤b c
bool
∏∏ "
requiresDepthPrepass
∏∏ %
=
∏∏& '"
requiresDepthTexture
∏∏( <
&&
∏∏= ?
!
∏∏@ A
CanCopyDepth
∏∏A M
(
∏∏M N
ref
∏∏N Q
renderingData
∏∏R _
.
∏∏_ `

cameraData
∏∏` j
)
∏∏j k
;
∏∏k l"
requiresDepthPrepass
ππ  
|=
ππ! #
isSceneViewCamera
ππ$ 5
;
ππ5 6"
requiresDepthPrepass
∫∫  
|=
∫∫! #
isPreviewCamera
∫∫$ 3
;
∫∫3 4"
requiresDepthPrepass
ªª  
|=
ªª! #
renderPassInputs
ªª$ 4
.
ªª4 5"
requiresDepthPrepass
ªª5 I
;
ªªI J"
requiresDepthPrepass
ºº  
|=
ºº! #
renderPassInputs
ºº$ 4
.
ºº4 5$
requiresNormalsTexture
ºº5 K
;
ººK L
m_CopyDepthPass
¿¿ 
.
¿¿ 
renderPassEvent
¿¿ +
=
¿¿, -
(
¿¿. /
!
¿¿/ 0"
requiresDepthTexture
¿¿0 D
&&
¿¿E G
(
¿¿H I!
applyPostProcessing
¿¿I \
||
¿¿] _
isSceneViewCamera
¿¿` q
)
¿¿q r
)
¿¿r s
?
¿¿t u
RenderPassEvent¿¿v Ö
.¿¿Ö Ü*
AfterRenderingTransparents¿¿Ü †
:¿¿° ¢
RenderPassEvent¿¿£ ≤
.¿¿≤ ≥%
AfterRenderingOpaques¿¿≥ »
;¿¿» … 
createColorTexture
¡¡ 
|=
¡¡ !.
 RequiresIntermediateColorTexture
¡¡" B
(
¡¡B C
ref
¡¡C F

cameraData
¡¡G Q
)
¡¡Q R
;
¡¡R S 
createColorTexture
¬¬ 
|=
¬¬ !
renderPassInputs
¬¬" 2
.
¬¬2 3"
requiresColorTexture
¬¬3 G
;
¬¬G H 
createColorTexture
√√ 
&=
√√ !
!
√√" #
isPreviewCamera
√√# 2
;
√√2 3
bool
    
createDepthTexture
   #
=
  $ %

cameraData
  & 0
.
  0 1"
requiresDepthTexture
  1 E
&&
  F H
!
  I J"
requiresDepthPrepass
  J ^
;
  ^ _ 
createDepthTexture
ÀÀ 
|=
ÀÀ !
(
ÀÀ" #

cameraData
ÀÀ# -
.
ÀÀ- .

renderType
ÀÀ. 8
==
ÀÀ9 ;
CameraRenderType
ÀÀ< L
.
ÀÀL M
Base
ÀÀM Q
&&
ÀÀR T
!
ÀÀU V

cameraData
ÀÀV `
.
ÀÀ` a 
resolveFinalTarget
ÀÀa s
)
ÀÀs t
;
ÀÀt u 
createDepthTexture
ÕÕ 
|=
ÕÕ !
this
ÕÕ" &
.
ÕÕ& '!
actualRenderingMode
ÕÕ' :
==
ÕÕ; =
RenderingMode
ÕÕ> K
.
ÕÕK L
Deferred
ÕÕL T
;
ÕÕT U
if
œœ 
(
œœ 

cameraData
œœ 
.
œœ 
xr
œœ 
.
œœ 
enabled
œœ %
)
œœ% &
{
––  
createDepthTexture
““ "
|=
““# % 
createColorTexture
““& 8
;
““8 9 
createColorTexture
”” "
=
””# $ 
createDepthTexture
””% 7
;
””7 8
}
‘‘ 
if
·· 
(
·· 

cameraData
·· 
.
·· 

renderType
·· %
==
··& (
CameraRenderType
··) 9
.
··9 :
Base
··: >
)
··> ?
{
‚‚  
RenderTargetHandle
„„ " 
cameraTargetHandle
„„# 5
=
„„6 7 
RenderTargetHandle
„„8 J
.
„„J K
GetCameraTarget
„„K Z
(
„„Z [

cameraData
„„[ e
.
„„e f
xr
„„f h
)
„„h i
;
„„i j+
m_ActiveCameraColorAttachment
ÂÂ -
=
ÂÂ. /
(
ÂÂ0 1 
createColorTexture
ÂÂ1 C
)
ÂÂC D
?
ÂÂE F%
m_CameraColorAttachment
ÂÂG ^
:
ÂÂ_ ` 
cameraTargetHandle
ÂÂa s
;
ÂÂs t+
m_ActiveCameraDepthAttachment
ÊÊ -
=
ÊÊ. /
(
ÊÊ0 1 
createDepthTexture
ÊÊ1 C
)
ÊÊC D
?
ÊÊE F%
m_CameraDepthAttachment
ÊÊG ^
:
ÊÊ_ ` 
cameraTargetHandle
ÊÊa s
;
ÊÊs t
bool
ËË '
intermediateRenderTexture
ËË .
=
ËË/ 0 
createColorTexture
ËË1 C
||
ËËD F 
createDepthTexture
ËËG Y
;
ËËY Z
if
ÎÎ 
(
ÎÎ '
intermediateRenderTexture
ÎÎ -
)
ÎÎ- .&
CreateCameraRenderTarget
ÏÏ ,
(
ÏÏ, -
context
ÏÏ- 4
,
ÏÏ4 5
ref
ÏÏ6 9$
cameraTargetDescriptor
ÏÏ: P
,
ÏÏP Q 
createColorTexture
ÏÏR d
,
ÏÏd e 
createDepthTexture
ÏÏf x
)
ÏÏx y
;
ÏÏy z
}
ÌÌ 
else
ÓÓ 
{
ÔÔ +
m_ActiveCameraColorAttachment
 -
=
. /%
m_CameraColorAttachment
0 G
;
G H+
m_ActiveCameraDepthAttachment
ÒÒ -
=
ÒÒ. /%
m_CameraDepthAttachment
ÒÒ0 G
;
ÒÒG H
}
ÚÚ 
{
ıı 
var
ˆˆ '
activeColorRenderTargetId
ˆˆ -
=
ˆˆ. /+
m_ActiveCameraColorAttachment
ˆˆ0 M
.
ˆˆM N

Identifier
ˆˆN X
(
ˆˆX Y
)
ˆˆY Z
;
ˆˆZ [
var
˜˜ '
activeDepthRenderTargetId
˜˜ -
=
˜˜. /+
m_ActiveCameraDepthAttachment
˜˜0 M
.
˜˜M N

Identifier
˜˜N X
(
˜˜X Y
)
˜˜Y Z
;
˜˜Z [
if
˙˙ 
(
˙˙ 

cameraData
˙˙ 
.
˙˙ 
xr
˙˙ !
.
˙˙! "
enabled
˙˙" )
)
˙˙) *
{
˚˚ '
activeColorRenderTargetId
¸¸ -
=
¸¸. /
new
¸¸0 3$
RenderTargetIdentifier
¸¸4 J
(
¸¸J K'
activeColorRenderTargetId
¸¸K d
,
¸¸d e
$num
¸¸f g
,
¸¸g h
CubemapFace
¸¸i t
.
¸¸t u
Unknown
¸¸u |
,
¸¸| }
-
¸¸~ 
$num¸¸ Ä
)¸¸Ä Å
;¸¸Å Ç'
activeDepthRenderTargetId
˝˝ -
=
˝˝. /
new
˝˝0 3$
RenderTargetIdentifier
˝˝4 J
(
˝˝J K'
activeDepthRenderTargetId
˝˝K d
,
˝˝d e
$num
˝˝f g
,
˝˝g h
CubemapFace
˝˝i t
.
˝˝t u
Unknown
˝˝u |
,
˝˝| }
-
˝˝~ 
$num˝˝ Ä
)˝˝Ä Å
;˝˝Å Ç
}
˛˛ #
ConfigureCameraTarget
ÅÅ %
(
ÅÅ% &'
activeColorRenderTargetId
ÅÅ& ?
,
ÅÅ? @'
activeDepthRenderTargetId
ÅÅA Z
)
ÅÅZ [
;
ÅÅ[ \
}
ÇÇ 
bool
ÑÑ *
hasPassesAfterPostProcessing
ÑÑ -
=
ÑÑ. /#
activeRenderPassQueue
ÑÑ0 E
.
ÑÑE F
Find
ÑÑF J
(
ÑÑJ K
x
ÑÑK L
=>
ÑÑM O
x
ÑÑP Q
.
ÑÑQ R
renderPassEvent
ÑÑR a
==
ÑÑb d
RenderPassEvent
ÑÑe t
.
ÑÑt u
AfterRenderingÑÑu É
)ÑÑÉ Ñ
!=ÑÑÖ á
nullÑÑà å
;ÑÑå ç
if
ÜÜ 
(
ÜÜ 
mainLightShadows
ÜÜ  
)
ÜÜ  !
EnqueuePass
áá 
(
áá )
m_MainLightShadowCasterPass
áá 7
)
áá7 8
;
áá8 9
if
ââ 
(
ââ $
additionalLightShadows
ââ &
)
ââ& '
EnqueuePass
ää 
(
ää 0
"m_AdditionalLightsShadowCasterPass
ää >
)
ää> ?
;
ää? @
if
åå 
(
åå "
requiresDepthPrepass
åå $
)
åå$ %
{
çç 
if
éé 
(
éé 
renderPassInputs
éé $
.
éé$ %$
requiresNormalsTexture
éé% ;
)
éé; <
{
èè "
m_DepthNormalPrepass
êê (
.
êê( )
Setup
êê) .
(
êê. /$
cameraTargetDescriptor
êê/ E
,
êêE F
m_DepthTexture
êêG U
,
êêU V
m_NormalsTexture
êêW g
)
êêg h
;
êêh i
EnqueuePass
ëë 
(
ëë  "
m_DepthNormalPrepass
ëë  4
)
ëë4 5
;
ëë5 6
}
íí 
else
ìì 
{
îî 
m_DepthPrepass
ïï "
.
ïï" #
Setup
ïï# (
(
ïï( )$
cameraTargetDescriptor
ïï) ?
,
ïï? @
m_DepthTexture
ïïA O
)
ïïO P
;
ïïP Q
EnqueuePass
ññ 
(
ññ  
m_DepthPrepass
ññ  .
)
ññ. /
;
ññ/ 0
}
óó 
}
òò 
if
öö 
(
öö %
generateColorGradingLUT
öö '
)
öö' (
{
õõ #
m_ColorGradingLutPass
úú %
.
úú% &
Setup
úú& +
(
úú+ ,
m_ColorGradingLut
úú, =
)
úú= >
;
úú> ?
EnqueuePass
ùù 
(
ùù #
m_ColorGradingLutPass
ùù 1
)
ùù1 2
;
ùù2 3
}
ûû 
if
°° 
(
°° 

cameraData
°° 
.
°° 
xr
°° 
.
°° #
hasValidOcclusionMesh
°° 3
)
°°3 4
EnqueuePass
¢¢ 
(
¢¢ #
m_XROcclusionMeshPass
¢¢ 1
)
¢¢1 2
;
¢¢2 3
if
•• 
(
•• 
this
•• 
.
•• !
actualRenderingMode
•• (
==
••) +
RenderingMode
••, 9
.
••9 :
Deferred
••: B
)
••B C
EnqueueDeferred
¶¶ 
(
¶¶  
ref
¶¶  #
renderingData
¶¶$ 1
,
¶¶1 2"
requiresDepthPrepass
¶¶3 G
,
¶¶G H
mainLightShadows
¶¶I Y
,
¶¶Y Z$
additionalLightShadows
¶¶[ q
)
¶¶q r
;
¶¶r s
else
ßß 
EnqueuePass
®® 
(
®® '
m_RenderOpaqueForwardPass
®® 5
)
®®5 6
;
®®6 7
Skybox
™™ 
cameraSkybox
™™ 
;
™™  

cameraData
´´ 
.
´´ 
camera
´´ 
.
´´ 
TryGetComponent
´´ -
<
´´- .
Skybox
´´. 4
>
´´4 5
(
´´5 6
out
´´6 9
cameraSkybox
´´: F
)
´´F G
;
´´G H
bool
¨¨ 
isOverlayCamera
¨¨  
=
¨¨! "

cameraData
¨¨# -
.
¨¨- .

renderType
¨¨. 8
==
¨¨9 ;
CameraRenderType
¨¨< L
.
¨¨L M
Overlay
¨¨M T
;
¨¨T U
if
≠≠ 
(
≠≠ 
camera
≠≠ 
.
≠≠ 

clearFlags
≠≠ !
==
≠≠" $
CameraClearFlags
≠≠% 5
.
≠≠5 6
Skybox
≠≠6 <
&&
≠≠= ?
(
≠≠@ A
RenderSettings
≠≠A O
.
≠≠O P
skybox
≠≠P V
!=
≠≠W Y
null
≠≠Z ^
||
≠≠_ a
cameraSkybox
≠≠b n
?
≠≠n o
.
≠≠o p
material
≠≠p x
!=
≠≠y {
null≠≠| Ä
)≠≠Ä Å
&&≠≠Ç Ñ
!≠≠Ö Ü
isOverlayCamera≠≠Ü ï
)≠≠ï ñ
EnqueuePass
ÆÆ 
(
ÆÆ 
m_DrawSkyboxPass
ÆÆ ,
)
ÆÆ, -
;
ÆÆ- .
bool
≤≤ #
requiresDepthCopyPass
≤≤ &
=
≤≤' (
!
≤≤) *"
requiresDepthPrepass
≤≤* >
&&
≥≥) +
renderingData
≥≥, 9
.
≥≥9 :

cameraData
≥≥: D
.
≥≥D E"
requiresDepthTexture
≥≥E Y
&&
¥¥) + 
createDepthTexture
¥¥, >
&&
µµ) +
this
µµ, 0
.
µµ0 1!
actualRenderingMode
µµ1 D
!=
µµE G
RenderingMode
µµH U
.
µµU V
Deferred
µµV ^
;
µµ^ _
if
∂∂ 
(
∂∂ #
requiresDepthCopyPass
∂∂ %
)
∂∂% &
{
∑∑ 
m_CopyDepthPass
∏∏ 
.
∏∏  
Setup
∏∏  %
(
∏∏% &+
m_ActiveCameraDepthAttachment
∏∏& C
,
∏∏C D
m_DepthTexture
∏∏E S
)
∏∏S T
;
∏∏T U
EnqueuePass
ππ 
(
ππ 
m_CopyDepthPass
ππ +
)
ππ+ ,
;
ππ, -
}
∫∫ 
if
ΩΩ 
(
ΩΩ 

cameraData
ΩΩ 
.
ΩΩ 

renderType
ΩΩ %
==
ΩΩ& (
CameraRenderType
ΩΩ) 9
.
ΩΩ9 :
Base
ΩΩ: >
&&
ΩΩ? A
!
ΩΩB C"
requiresDepthPrepass
ΩΩC W
&&
ΩΩX Z
!
ΩΩ[ \#
requiresDepthCopyPass
ΩΩ\ q
)
ΩΩq r
{
ææ 
Shader
øø 
.
øø 
SetGlobalTexture
øø '
(
øø' (
m_DepthTexture
øø( 6
.
øø6 7
id
øø7 9
,
øø9 :

SystemInfo
øø; E
.
øøE F!
usesReversedZBuffer
øøF Y
?
øøZ [
	Texture2D
øø\ e
.
øøe f
blackTexture
øøf r
:
øøs t
	Texture2D
øøu ~
.
øø~ 
whiteTextureøø ã
)øøã å
;øøå ç
}
¿¿ 
if
¬¬ 
(
¬¬ 
renderingData
¬¬ 
.
¬¬ 

cameraData
¬¬ (
.
¬¬( )#
requiresOpaqueTexture
¬¬) >
||
¬¬? A
renderPassInputs
¬¬B R
.
¬¬R S"
requiresColorTexture
¬¬S g
)
¬¬g h
{
√√ 
Downsampling
∆∆  
downsamplingMethod
∆∆ /
=
∆∆0 1%
UniversalRenderPipeline
∆∆2 I
.
∆∆I J
asset
∆∆J O
.
∆∆O P 
opaqueDownsampling
∆∆P b
;
∆∆b c
m_CopyColorPass
«« 
.
««  
Setup
««  %
(
««% &+
m_ActiveCameraColorAttachment
««& C
.
««C D

Identifier
««D N
(
««N O
)
««O P
,
««P Q
m_OpaqueColor
««R _
,
««_ ` 
downsamplingMethod
««a s
)
««s t
;
««t u
EnqueuePass
»» 
(
»» 
m_CopyColorPass
»» +
)
»»+ ,
;
»», -
}
…… 
{
ÕÕ 
if
ŒŒ 
(
ŒŒ *
transparentsNeedSettingsPass
ŒŒ 0
)
ŒŒ0 1
{
œœ 
EnqueuePass
–– 
(
––  '
m_TransparentSettingsPass
––  9
)
––9 :
;
––: ;
}
—— 
EnqueuePass
”” 
(
”” ,
m_RenderTransparentForwardPass
”” :
)
””: ;
;
””; <
}
‘‘ 
EnqueuePass
’’ 
(
’’ *
m_OnRenderObjectCallbackPass
’’ 4
)
’’4 5
;
’’5 6
bool
◊◊ "
lastCameraInTheStack
◊◊ %
=
◊◊& '

cameraData
◊◊( 2
.
◊◊2 3 
resolveFinalTarget
◊◊3 E
;
◊◊E F
bool
ÿÿ 
hasCaptureActions
ÿÿ "
=
ÿÿ# $
renderingData
ÿÿ% 2
.
ÿÿ2 3

cameraData
ÿÿ3 =
.
ÿÿ= >
captureActions
ÿÿ> L
!=
ÿÿM O
null
ÿÿP T
&&
ÿÿU W"
lastCameraInTheStack
ÿÿX l
;
ÿÿl m
bool
ŸŸ &
applyFinalPostProcessing
ŸŸ )
=
ŸŸ* +
anyPostProcessing
ŸŸ, =
&&
ŸŸ> @"
lastCameraInTheStack
ŸŸA U
&&
ŸŸV X
renderingData
⁄⁄% 2
.
⁄⁄2 3

cameraData
⁄⁄3 =
.
⁄⁄= >
antialiasing
⁄⁄> J
==
⁄⁄K M
AntialiasingMode
⁄⁄N ^
.
⁄⁄^ _)
FastApproximateAntialiasing
⁄⁄_ z
;
⁄⁄z {
bool
ﬁﬁ 1
#resolvePostProcessingToCameraTarget
ﬁﬁ 4
=
ﬁﬁ5 6
!
ﬁﬁ7 8
hasCaptureActions
ﬁﬁ8 I
&&
ﬁﬁJ L
!
ﬁﬁM N*
hasPassesAfterPostProcessing
ﬁﬁN j
&&
ﬁﬁk m
!
ﬁﬁn o'
applyFinalPostProcessingﬁﬁo á
;ﬁﬁá à
if
‡‡ 
(
‡‡ "
lastCameraInTheStack
‡‡ $
)
‡‡$ %
{
·· 
if
„„ 
(
„„ !
applyPostProcessing
„„ '
)
„„' (
{
‰‰ 
var
ÂÂ 
destination
ÂÂ #
=
ÂÂ$ %1
#resolvePostProcessingToCameraTarget
ÂÂ& I
?
ÂÂJ K 
RenderTargetHandle
ÂÂL ^
.
ÂÂ^ _
CameraTarget
ÂÂ_ k
:
ÂÂl m&
m_AfterPostProcessColorÂÂn Ö
;ÂÂÖ Ü
bool
ËË 
doSRGBConvertion
ËË )
=
ËË* +1
#resolvePostProcessingToCameraTarget
ËË, O
;
ËËO P
m_PostProcessPass
ÈÈ %
.
ÈÈ% &
Setup
ÈÈ& +
(
ÈÈ+ ,$
cameraTargetDescriptor
ÈÈ, B
,
ÈÈB C+
m_ActiveCameraColorAttachment
ÈÈD a
,
ÈÈa b
destination
ÈÈc n
,
ÈÈn o,
m_ActiveCameraDepthAttachmentÈÈp ç
,ÈÈç é!
m_ColorGradingLutÈÈè †
,ÈÈ† °(
applyFinalPostProcessingÈÈ¢ ∫
,ÈÈ∫ ª 
doSRGBConvertionÈÈº Ã
)ÈÈÃ Õ
;ÈÈÕ Œ
EnqueuePass
ÍÍ 
(
ÍÍ  
m_PostProcessPass
ÍÍ  1
)
ÍÍ1 2
;
ÍÍ2 3
}
ÎÎ 
var
ÔÔ  
sourceForFinalPass
ÔÔ &
=
ÔÔ' (
(
ÔÔ) *!
applyPostProcessing
ÔÔ* =
)
ÔÔ= >
?
ÔÔ? @%
m_AfterPostProcessColor
ÔÔA X
:
ÔÔY Z+
m_ActiveCameraColorAttachment
ÔÔ[ x
;
ÔÔx y
if
ÚÚ 
(
ÚÚ &
applyFinalPostProcessing
ÚÚ ,
)
ÚÚ, -
{
ÛÛ $
m_FinalPostProcessPass
ÙÙ *
.
ÙÙ* +
SetupFinalPass
ÙÙ+ 9
(
ÙÙ9 : 
sourceForFinalPass
ÙÙ: L
)
ÙÙL M
;
ÙÙM N
EnqueuePass
ıı 
(
ıı  $
m_FinalPostProcessPass
ıı  6
)
ıı6 7
;
ıı7 8
}
ˆˆ 
if
¯¯ 
(
¯¯ 
renderingData
¯¯ !
.
¯¯! "

cameraData
¯¯" ,
.
¯¯, -
captureActions
¯¯- ;
!=
¯¯< >
null
¯¯? C
)
¯¯C D
{
˘˘ 
m_CapturePass
˙˙ !
.
˙˙! "
Setup
˙˙" '
(
˙˙' ( 
sourceForFinalPass
˙˙( :
)
˙˙: ;
;
˙˙; <
EnqueuePass
˚˚ 
(
˚˚  
m_CapturePass
˚˚  -
)
˚˚- .
;
˚˚. /
}
¸¸ 
bool
ÄÄ "
cameraTargetResolved
ÄÄ )
=
ÄÄ* +&
applyFinalPostProcessing
ÇÇ ,
||
ÇÇ- /
(
ÑÑ !
applyPostProcessing
ÑÑ (
&&
ÑÑ) +
!
ÑÑ, -*
hasPassesAfterPostProcessing
ÑÑ- I
)
ÑÑI J
||
ÑÑK M+
m_ActiveCameraColorAttachment
ÜÜ 1
==
ÜÜ2 4 
RenderTargetHandle
ÜÜ5 G
.
ÜÜG H
GetCameraTarget
ÜÜH W
(
ÜÜW X

cameraData
ÜÜX b
.
ÜÜb c
xr
ÜÜc e
)
ÜÜe f
;
ÜÜf g
if
ââ 
(
ââ 
!
ââ "
cameraTargetResolved
ââ )
)
ââ) *
{
ää 
m_FinalBlitPass
ãã #
.
ãã# $
Setup
ãã$ )
(
ãã) *$
cameraTargetDescriptor
ãã* @
,
ãã@ A 
sourceForFinalPass
ããB T
)
ããT U
;
ããU V
EnqueuePass
åå 
(
åå  
m_FinalBlitPass
åå  /
)
åå/ 0
;
åå0 1
}
çç 
bool
êê !
depthTargetResolved
êê (
=
êê) *+
m_ActiveCameraDepthAttachment
íí 1
==
íí2 4 
RenderTargetHandle
íí5 G
.
ííG H
GetCameraTarget
ííH W
(
ííW X

cameraData
ííX b
.
ííb c
xr
ííc e
)
ííe f
;
ííf g
if
îî 
(
îî 
!
îî !
depthTargetResolved
îî (
&&
îî) +

cameraData
îî, 6
.
îî6 7
xr
îî7 9
.
îî9 :
	copyDepth
îî: C
)
îîC D
{
ïï 
m_XRCopyDepthPass
ññ %
.
ññ% &
Setup
ññ& +
(
ññ+ ,+
m_ActiveCameraDepthAttachment
ññ, I
,
ññI J 
RenderTargetHandle
ññK ]
.
ññ] ^
GetCameraTarget
ññ^ m
(
ññm n

cameraData
ññn x
.
ññx y
xr
ññy {
)
ññ{ |
)
ññ| }
;
ññ} ~
EnqueuePass
óó 
(
óó  
m_XRCopyDepthPass
óó  1
)
óó1 2
;
óó2 3
}
òò 
}
öö 
else
ùù 
if
ùù 
(
ùù !
applyPostProcessing
ùù (
)
ùù( )
{
ûû 
m_PostProcessPass
üü !
.
üü! "
Setup
üü" '
(
üü' ($
cameraTargetDescriptor
üü( >
,
üü> ?+
m_ActiveCameraColorAttachment
üü@ ]
,
üü] ^%
m_AfterPostProcessColor
üü_ v
,
üüv w,
m_ActiveCameraDepthAttachmentüüx ï
,üüï ñ!
m_ColorGradingLutüüó ®
,üü® ©
falseüü™ Ø
,üüØ ∞
falseüü± ∂
)üü∂ ∑
;üü∑ ∏
EnqueuePass
†† 
(
†† 
m_PostProcessPass
†† -
)
††- .
;
††. /
}
°° 
if
§§ 
(
§§ 
isSceneViewCamera
§§ !
)
§§! "
{
•• 

Assertions
ßß 
.
ßß 
Assert
ßß !
.
ßß! "
IsTrue
ßß" (
(
ßß( )"
lastCameraInTheStack
ßß) =
,
ßß= >
$str
ßß? y
)
ßßy z
;
ßßz {&
m_SceneViewDepthCopyPass
®® (
.
®®( )
Setup
®®) .
(
®®. /
m_DepthTexture
®®/ =
)
®®= >
;
®®> ?
EnqueuePass
©© 
(
©© &
m_SceneViewDepthCopyPass
©© 4
)
©©4 5
;
©©5 6
}
™™ 
}
¨¨ 	
public
ØØ 
override
ØØ 
void
ØØ 
SetupLights
ØØ (
(
ØØ( )%
ScriptableRenderContext
ØØ) @
context
ØØA H
,
ØØH I
ref
ØØJ M
RenderingData
ØØN [
renderingData
ØØ\ i
)
ØØi j
{
∞∞ 	
m_ForwardLights
±± 
.
±± 
Setup
±± !
(
±±! "
context
±±" )
,
±±) *
ref
±±+ .
renderingData
±±/ <
)
±±< =
;
±±= >
if
¥¥ 
(
¥¥ 
this
¥¥ 
.
¥¥ !
actualRenderingMode
¥¥ (
==
¥¥) +
RenderingMode
¥¥, 9
.
¥¥9 :
Deferred
¥¥: B
)
¥¥B C
m_DeferredLights
µµ  
.
µµ  !
SetupLights
µµ! ,
(
µµ, -
context
µµ- 4
,
µµ4 5
ref
µµ6 9
renderingData
µµ: G
)
µµG H
;
µµH I
}
∂∂ 	
public
ππ 
override
ππ 
void
ππ $
SetupCullingParameters
ππ 3
(
ππ3 4
ref
ππ4 7)
ScriptableCullingParameters
ππ8 S
cullingParameters
ππT e
,
ππe f
ref
∫∫ 

CameraData
∫∫ 

cameraData
∫∫ %
)
∫∫% &
{
ªª 	
bool
≈≈ %
isShadowCastingDisabled
≈≈ (
=
≈≈) *
!
≈≈+ ,%
UniversalRenderPipeline
≈≈, C
.
≈≈C D
asset
≈≈D I
.
≈≈I J&
supportsMainLightShadows
≈≈J b
&&
≈≈c e
!
≈≈f g%
UniversalRenderPipeline
≈≈g ~
.
≈≈~ 
asset≈≈ Ñ
.≈≈Ñ Ö.
supportsAdditionalLightShadows≈≈Ö £
;≈≈£ §
bool
∆∆ "
isShadowDistanceZero
∆∆ %
=
∆∆& '
Mathf
∆∆( -
.
∆∆- .
Approximately
∆∆. ;
(
∆∆; <

cameraData
∆∆< F
.
∆∆F G
maxShadowDistance
∆∆G X
,
∆∆X Y
$num
∆∆Z ^
)
∆∆^ _
;
∆∆_ `
if
«« 
(
«« %
isShadowCastingDisabled
«« '
||
««( *"
isShadowDistanceZero
««+ ?
)
««? @
{
»» 
cullingParameters
…… !
.
……! "
cullingOptions
……" 0
&=
……1 3
~
……4 5
CullingOptions
……5 C
.
……C D
ShadowCasters
……D Q
;
……Q R
}
   
if
ÃÃ 
(
ÃÃ 
this
ÃÃ 
.
ÃÃ !
actualRenderingMode
ÃÃ (
==
ÃÃ) +
RenderingMode
ÃÃ, 9
.
ÃÃ9 :
Deferred
ÃÃ: B
)
ÃÃB C
cullingParameters
ÕÕ !
.
ÕÕ! ""
maximumVisibleLights
ÕÕ" 6
=
ÕÕ7 8
$num
ÕÕ9 ?
;
ÕÕ? @
else
ŒŒ 
{
œœ 
cullingParameters
—— !
.
——! ""
maximumVisibleLights
——" 6
=
——7 8%
UniversalRenderPipeline
——9 P
.
——P Q(
maxVisibleAdditionalLights
——Q k
+
——l m
$num
——n o
;
——o p
}
““ 
cullingParameters
”” 
.
”” 
shadowDistance
”” ,
=
””- .

cameraData
””/ 9
.
””9 :
maxShadowDistance
””: K
;
””K L
}
‘‘ 	
public
◊◊ 
override
◊◊ 
void
◊◊ 
FinishRendering
◊◊ ,
(
◊◊, -
CommandBuffer
◊◊- :
cmd
◊◊; >
)
◊◊> ?
{
ÿÿ 	
if
ŸŸ 
(
ŸŸ +
m_ActiveCameraColorAttachment
ŸŸ -
!=
ŸŸ. 0 
RenderTargetHandle
ŸŸ1 C
.
ŸŸC D
CameraTarget
ŸŸD P
)
ŸŸP Q
{
⁄⁄ 
cmd
€€ 
.
€€  
ReleaseTemporaryRT
€€ &
(
€€& '+
m_ActiveCameraColorAttachment
€€' D
.
€€D E
id
€€E G
)
€€G H
;
€€H I+
m_ActiveCameraColorAttachment
‹‹ -
=
‹‹. / 
RenderTargetHandle
‹‹0 B
.
‹‹B C
CameraTarget
‹‹C O
;
‹‹O P
}
›› 
if
ﬂﬂ 
(
ﬂﬂ +
m_ActiveCameraDepthAttachment
ﬂﬂ -
!=
ﬂﬂ. 0 
RenderTargetHandle
ﬂﬂ1 C
.
ﬂﬂC D
CameraTarget
ﬂﬂD P
)
ﬂﬂP Q
{
‡‡ 
cmd
·· 
.
··  
ReleaseTemporaryRT
·· &
(
··& '+
m_ActiveCameraDepthAttachment
··' D
.
··D E
id
··E G
)
··G H
;
··H I+
m_ActiveCameraDepthAttachment
‚‚ -
=
‚‚. / 
RenderTargetHandle
‚‚0 B
.
‚‚B C
CameraTarget
‚‚C O
;
‚‚O P
}
„„ 
}
‰‰ 	
void
ÊÊ 
EnqueueDeferred
ÊÊ 
(
ÊÊ 
ref
ÊÊ  
RenderingData
ÊÊ! .
renderingData
ÊÊ/ <
,
ÊÊ< =
bool
ÊÊ> B
hasDepthPrepass
ÊÊC R
,
ÊÊR S
bool
ÊÊT X
applyMainShadow
ÊÊY h
,
ÊÊh i
bool
ÊÊj n$
applyAdditionalShadowÊÊo Ñ
)ÊÊÑ Ö
{
ÁÁ 	
m_GBufferHandles
ÈÈ 
[
ÈÈ 
(
ÈÈ 
int
ÈÈ !
)
ÈÈ! "
DeferredLights
ÈÈ" 0
.
ÈÈ0 1
GBufferHandles
ÈÈ1 ?
.
ÈÈ? @
Lighting
ÈÈ@ H
]
ÈÈH I
=
ÈÈJ K+
m_ActiveCameraColorAttachment
ÈÈL i
;
ÈÈi j
m_DeferredLights
ÎÎ 
.
ÎÎ 
Setup
ÎÎ "
(
ÎÎ" #
ref
ÏÏ 
renderingData
ÏÏ !
,
ÏÏ! "#
applyAdditionalShadow
ÌÌ %
?
ÌÌ& '0
"m_AdditionalLightsShadowCasterPass
ÌÌ( J
:
ÌÌK L
null
ÌÌM Q
,
ÌÌQ R
hasDepthPrepass
ÓÓ 
,
ÓÓ  
renderingData
ÔÔ 
.
ÔÔ 

cameraData
ÔÔ (
.
ÔÔ( )

renderType
ÔÔ) 3
==
ÔÔ4 6
CameraRenderType
ÔÔ7 G
.
ÔÔG H
Overlay
ÔÔH O
,
ÔÔO P
m_DepthTexture
 
,
  
m_DepthInfoTexture
ÒÒ "
,
ÒÒ" #$
m_TileDepthInfoTexture
ÚÚ &
,
ÚÚ& '+
m_ActiveCameraDepthAttachment
ÛÛ -
,
ÛÛ- .
m_GBufferHandles
ÛÛ/ ?
)
ÙÙ 
;
ÙÙ 
EnqueuePass
ˆˆ 
(
ˆˆ 
m_GBufferPass
ˆˆ %
)
ˆˆ% &
;
ˆˆ& '
EnqueuePass
¯¯ 
(
¯¯ +
m_RenderOpaqueForwardOnlyPass
¯¯ 5
)
¯¯5 6
;
¯¯6 7
if
˚˚ 
(
˚˚ 
!
˚˚ 
hasDepthPrepass
˚˚  
)
˚˚  !
{
¸¸ $
m_GBufferCopyDepthPass
˝˝ &
.
˝˝& '
Setup
˝˝' ,
(
˝˝, -%
m_CameraDepthAttachment
˝˝- D
,
˝˝D E
m_DepthTexture
˝˝F T
)
˝˝T U
;
˝˝U V
EnqueuePass
˛˛ 
(
˛˛ $
m_GBufferCopyDepthPass
˛˛ 2
)
˛˛2 3
;
˛˛3 4
}
ˇˇ 
if
ÖÖ 
(
ÖÖ 
m_DeferredLights
ÖÖ  
.
ÖÖ  !
HasTileLights
ÖÖ! .
(
ÖÖ. /
)
ÖÖ/ 0
)
ÖÖ0 1
{
ÜÜ 
EnqueuePass
ââ 
(
ââ "
m_TileDepthRangePass
ââ 0
)
ââ0 1
;
ââ1 2
if
èè 
(
èè 
m_DeferredLights
èè $
.
èè$ %(
HasTileDepthRangeExtraPass
èè% ?
(
èè? @
)
èè@ A
)
èèA B
EnqueuePass
êê 
(
êê  '
m_TileDepthRangeExtraPass
êê  9
)
êê9 :
;
êê: ;
}
ëë 
EnqueuePass
ìì 
(
ìì 
m_DeferredPass
ìì &
)
ìì& '
;
ìì' (
}
îî 	
private
ññ 
struct
ññ $
RenderPassInputSummary
ññ -
{
óó 	
internal
òò 
bool
òò "
requiresDepthTexture
òò .
;
òò. /
internal
ôô 
bool
ôô "
requiresDepthPrepass
ôô .
;
ôô. /
internal
öö 
bool
öö $
requiresNormalsTexture
öö 0
;
öö0 1
internal
õõ 
bool
õõ "
requiresColorTexture
õõ .
;
õõ. /
}
úú 	
private
ûû $
RenderPassInputSummary
ûû &!
GetRenderPassInputs
ûû' :
(
ûû: ;
ref
ûû; >
RenderingData
ûû? L
renderingData
ûûM Z
)
ûûZ [
{
üü 	$
RenderPassInputSummary
†† "
inputSummary
††# /
=
††0 1
new
††2 5$
RenderPassInputSummary
††6 L
(
††L M
)
††M N
;
††N O
for
°° 
(
°° 
int
°° 
i
°° 
=
°° 
$num
°° 
;
°° 
i
°° 
<
°° #
activeRenderPassQueue
°°  5
.
°°5 6
Count
°°6 ;
;
°°; <
++
°°= ?
i
°°? @
)
°°@ A
{
¢¢ "
ScriptableRenderPass
££ $
pass
££% )
=
££* +#
activeRenderPassQueue
££, A
[
££A B
i
££B C
]
££C D
;
££D E
bool
§§ 

needsDepth
§§ 
=
§§" #
(
§§$ %
pass
§§% )
.
§§) *
input
§§* /
&
§§0 1'
ScriptableRenderPassInput
§§2 K
.
§§K L
Depth
§§L Q
)
§§Q R
!=
§§S U'
ScriptableRenderPassInput
§§V o
.
§§o p
None
§§p t
;
§§t u
bool
•• 
needsNormals
•• !
=
••" #
(
••$ %
pass
••% )
.
••) *
input
••* /
&
••0 1'
ScriptableRenderPassInput
••2 K
.
••K L
Normal
••L R
)
••R S
!=
••T V'
ScriptableRenderPassInput
••W p
.
••p q
None
••q u
;
••u v
bool
¶¶ 

needsColor
¶¶ 
=
¶¶" #
(
¶¶$ %
pass
¶¶% )
.
¶¶) *
input
¶¶* /
&
¶¶0 1'
ScriptableRenderPassInput
¶¶2 K
.
¶¶K L
Color
¶¶L Q
)
¶¶Q R
!=
¶¶S U'
ScriptableRenderPassInput
¶¶V o
.
¶¶o p
None
¶¶p t
;
¶¶t u
bool
ßß 
eventBeforeOpaque
ßß &
=
ßß' (
pass
ßß) -
.
ßß- .
renderPassEvent
ßß. =
<=
ßß> @
RenderPassEvent
ßßA P
.
ßßP Q$
BeforeRenderingOpaques
ßßQ g
;
ßßg h
inputSummary
©© 
.
©© "
requiresDepthTexture
©© 1
|=
©©4 6

needsDepth
©©7 A
;
©©A B
inputSummary
™™ 
.
™™ "
requiresDepthPrepass
™™ 1
|=
™™4 6
needsNormals
™™7 C
||
™™D F

needsDepth
™™G Q
&&
™™R T
eventBeforeOpaque
™™U f
;
™™f g
inputSummary
´´ 
.
´´ $
requiresNormalsTexture
´´ 3
|=
´´4 6
needsNormals
´´7 C
;
´´C D
inputSummary
¨¨ 
.
¨¨ "
requiresColorTexture
¨¨ 1
|=
¨¨4 6

needsColor
¨¨7 A
;
¨¨A B
}
≠≠ 
return
ØØ 
inputSummary
ØØ 
;
ØØ  
}
∞∞ 	
void
≤≤ &
CreateCameraRenderTarget
≤≤ %
(
≤≤% &%
ScriptableRenderContext
≤≤& =
context
≤≤> E
,
≤≤E F
ref
≤≤G J%
RenderTextureDescriptor
≤≤K b

descriptor
≤≤c m
,
≤≤m n
bool
≤≤o s
createColor
≤≤t 
,≤≤ Ä
bool≤≤Å Ö
createDepth≤≤Ü ë
)≤≤ë í
{
≥≥ 	
CommandBuffer
¥¥ 
cmd
¥¥ 
=
¥¥ 
CommandBufferPool
¥¥  1
.
¥¥1 2
Get
¥¥2 5
(
¥¥5 6
)
¥¥6 7
;
¥¥7 8
using
µµ 
(
µµ 
new
µµ 
ProfilingScope
µµ %
(
µµ% &
cmd
µµ& )
,
µµ) *
	Profiling
µµ+ 4
.
µµ4 5&
createCameraRenderTarget
µµ5 M
)
µµM N
)
µµN O
{
∂∂ 
if
∑∑ 
(
∑∑ 
createColor
∑∑ 
)
∑∑  
{
∏∏ 
bool
ππ "
useDepthRenderBuffer
ππ -
=
ππ. /+
m_ActiveCameraDepthAttachment
ππ0 M
==
ππN P 
RenderTargetHandle
ππQ c
.
ππc d
CameraTarget
ππd p
;
ππp q
var
∫∫ 
colorDescriptor
∫∫ '
=
∫∫( )

descriptor
∫∫* 4
;
∫∫4 5
colorDescriptor
ªª #
.
ªª# $
depthBufferBits
ªª$ 3
=
ªª4 5
(
ªª6 7"
useDepthRenderBuffer
ªª7 K
)
ªªK L
?
ªªM N&
k_DepthStencilBufferBits
ªªO g
:
ªªh i
$num
ªªj k
;
ªªk l
cmd
ºº 
.
ºº 
GetTemporaryRT
ºº &
(
ºº& '+
m_ActiveCameraColorAttachment
ºº' D
.
ººD E
id
ººE G
,
ººG H
colorDescriptor
ººI X
,
ººX Y

FilterMode
ººZ d
.
ººd e
Bilinear
ººe m
)
ººm n
;
ººn o
}
ΩΩ 
if
øø 
(
øø 
createDepth
øø 
)
øø  
{
¿¿ 
var
¡¡ 
depthDescriptor
¡¡ '
=
¡¡( )

descriptor
¡¡* 4
;
¡¡4 5
depthDescriptor
ƒƒ #
.
ƒƒ# $
bindMS
ƒƒ$ *
=
ƒƒ+ ,
depthDescriptor
ƒƒ- <
.
ƒƒ< =
msaaSamples
ƒƒ= H
>
ƒƒI J
$num
ƒƒK L
&&
ƒƒM O
!
ƒƒP Q

SystemInfo
ƒƒQ [
.
ƒƒ[ \,
supportsMultisampleAutoResolve
ƒƒ\ z
&&
ƒƒ{ }
(
ƒƒ~ 

SystemInfoƒƒ â
.ƒƒâ ä,
supportsMultisampledTexturesƒƒä ¶
!=ƒƒß ©
$numƒƒ™ ´
)ƒƒ´ ¨
;ƒƒ¨ ≠
depthDescriptor
∆∆ #
.
∆∆# $
colorFormat
∆∆$ /
=
∆∆0 1!
RenderTextureFormat
∆∆2 E
.
∆∆E F
Depth
∆∆F K
;
∆∆K L
depthDescriptor
«« #
.
««# $
depthBufferBits
««$ 3
=
««4 5&
k_DepthStencilBufferBits
««6 N
;
««N O
cmd
»» 
.
»» 
GetTemporaryRT
»» &
(
»»& '+
m_ActiveCameraDepthAttachment
»»' D
.
»»D E
id
»»E G
,
»»G H
depthDescriptor
»»I X
,
»»X Y

FilterMode
»»Z d
.
»»d e
Point
»»e j
)
»»j k
;
»»k l
}
…… 
}
   
context
ÃÃ 
.
ÃÃ "
ExecuteCommandBuffer
ÃÃ (
(
ÃÃ( )
cmd
ÃÃ) ,
)
ÃÃ, -
;
ÃÃ- .
CommandBufferPool
ÕÕ 
.
ÕÕ 
Release
ÕÕ %
(
ÕÕ% &
cmd
ÕÕ& )
)
ÕÕ) *
;
ÕÕ* +
}
ŒŒ 	
bool
–– 1
#PlatformRequiresExplicitMsaaResolve
–– 0
(
––0 1
)
––1 2
{
—— 	
return
’’ 
!
’’ 

SystemInfo
’’ 
.
’’ ,
supportsMultisampleAutoResolve
’’ =
&&
’’> @
!
÷÷ 
(
÷÷ 

SystemInfo
÷÷ 
.
÷÷   
graphicsDeviceType
÷÷  2
==
÷÷3 5 
GraphicsDeviceType
÷÷6 H
.
÷÷H I
Metal
÷÷I N
&&
÷÷O Q
Application
÷÷R ]
.
÷÷] ^
isMobilePlatform
÷÷^ n
)
÷÷n o
;
÷÷o p
}
◊◊ 	
bool
ﬂﬂ .
 RequiresIntermediateColorTexture
ﬂﬂ -
(
ﬂﬂ- .
ref
ﬂﬂ. 1

CameraData
ﬂﬂ2 <

cameraData
ﬂﬂ= G
)
ﬂﬂG H
{
‡‡ 	
if
„„ 
(
„„ 

cameraData
„„ 
.
„„ 

renderType
„„ %
==
„„& (
CameraRenderType
„„) 9
.
„„9 :
Base
„„: >
&&
„„? A
!
„„B C

cameraData
„„C M
.
„„M N 
resolveFinalTarget
„„N `
)
„„` a
return
‰‰ 
true
‰‰ 
;
‰‰ 
if
ÏÏ 
(
ÏÏ 
this
ÏÏ 
.
ÏÏ !
actualRenderingMode
ÏÏ (
==
ÏÏ) +
RenderingMode
ÏÏ, 9
.
ÏÏ9 :
Deferred
ÏÏ: B
)
ÏÏB C
return
ÌÌ 
true
ÌÌ 
;
ÌÌ 
bool
ÔÔ 
isSceneViewCamera
ÔÔ "
=
ÔÔ# $

cameraData
ÔÔ% /
.
ÔÔ/ 0
isSceneViewCamera
ÔÔ0 A
;
ÔÔA B
var
 $
cameraTargetDescriptor
 &
=
' (

cameraData
) 3
.
3 4$
cameraTargetDescriptor
4 J
;
J K
int
ÒÒ 
msaaSamples
ÒÒ 
=
ÒÒ $
cameraTargetDescriptor
ÒÒ 4
.
ÒÒ4 5
msaaSamples
ÒÒ5 @
;
ÒÒ@ A
bool
ÚÚ 
isScaledRender
ÚÚ 
=
ÚÚ  !
!
ÚÚ" #
Mathf
ÚÚ# (
.
ÚÚ( )
Approximately
ÚÚ) 6
(
ÚÚ6 7

cameraData
ÚÚ7 A
.
ÚÚA B
renderScale
ÚÚB M
,
ÚÚM N
$num
ÚÚO S
)
ÚÚS T
;
ÚÚT U
bool
ÛÛ 4
&isCompatibleBackbufferTextureDimension
ÛÛ 7
=
ÛÛ8 9$
cameraTargetDescriptor
ÛÛ: P
.
ÛÛP Q
	dimension
ÛÛQ Z
==
ÛÛ[ ]
TextureDimension
ÛÛ^ n
.
ÛÛn o
Tex2D
ÛÛo t
;
ÛÛt u
bool
ÙÙ )
requiresExplicitMsaaResolve
ÙÙ ,
=
ÙÙ- .
msaaSamples
ÙÙ/ :
>
ÙÙ; <
$num
ÙÙ= >
&&
ÙÙ? A1
#PlatformRequiresExplicitMsaaResolve
ÙÙB e
(
ÙÙe f
)
ÙÙf g
;
ÙÙg h
bool
ıı 
isOffscreenRender
ıı "
=
ıı# $

cameraData
ıı% /
.
ıı/ 0
targetTexture
ıı0 =
!=
ıı> @
null
ııA E
&&
ııF H
!
ııI J
isSceneViewCamera
ııJ [
;
ıı[ \
bool
ˆˆ 
isCapturing
ˆˆ 
=
ˆˆ 

cameraData
ˆˆ )
.
ˆˆ) *
captureActions
ˆˆ* 8
!=
ˆˆ9 ;
null
ˆˆ< @
;
ˆˆ@ A
if
˘˘ 
(
˘˘ 

cameraData
˘˘ 
.
˘˘ 
xr
˘˘ 
.
˘˘ 
enabled
˘˘ %
)
˘˘% &4
&isCompatibleBackbufferTextureDimension
˙˙ 6
=
˙˙7 8

cameraData
˙˙9 C
.
˙˙C D
xr
˙˙D F
.
˙˙F G
renderTargetDesc
˙˙G W
.
˙˙W X
	dimension
˙˙X a
==
˙˙b d$
cameraTargetDescriptor
˙˙e {
.
˙˙{ |
	dimension˙˙| Ö
;˙˙Ö Ü
bool
˝˝ ,
requiresBlitForOffscreenCamera
˝˝ /
=
˝˝0 1

cameraData
˝˝2 <
.
˝˝< = 
postProcessEnabled
˝˝= O
||
˝˝P R

cameraData
˝˝S ]
.
˝˝] ^#
requiresOpaqueTexture
˝˝^ s
||
˝˝t v*
requiresExplicitMsaaResolve˝˝w í
||˝˝ì ï
!˝˝ñ ó

cameraData˝˝ó °
.˝˝° ¢!
isDefaultViewport˝˝¢ ≥
;˝˝≥ ¥
if
˛˛ 
(
˛˛ 
isOffscreenRender
˛˛ !
)
˛˛! "
return
ˇˇ ,
requiresBlitForOffscreenCamera
ˇˇ 5
;
ˇˇ5 6
return
ÅÅ ,
requiresBlitForOffscreenCamera
ÅÅ 1
||
ÅÅ2 4
isSceneViewCamera
ÅÅ5 F
||
ÅÅG I
isScaledRender
ÅÅJ X
||
ÅÅY [

cameraData
ÅÅ\ f
.
ÅÅf g
isHdrEnabled
ÅÅg s
||
ÅÅt v
!
ÇÇ 4
&isCompatibleBackbufferTextureDimension
ÇÇ :
||
ÇÇ; =
isCapturing
ÇÇ> I
||
ÇÇJ L

cameraData
ÇÇM W
.
ÇÇW X#
requireSrgbConversion
ÇÇX m
;
ÇÇm n
}
ÉÉ 	
bool
ÖÖ 
CanCopyDepth
ÖÖ 
(
ÖÖ 
ref
ÖÖ 

CameraData
ÖÖ (

cameraData
ÖÖ) 3
)
ÖÖ3 4
{
ÜÜ 	
bool
áá "
msaaEnabledForCamera
áá %
=
áá& '

cameraData
áá( 2
.
áá2 3$
cameraTargetDescriptor
áá3 I
.
ááI J
msaaSamples
ááJ U
>
ááV W
$num
ááX Y
;
ááY Z
bool
àà !
supportsTextureCopy
àà $
=
àà% &

SystemInfo
àà' 1
.
àà1 2 
copyTextureSupport
àà2 D
!=
ààE G 
CopyTextureSupport
ààH Z
.
ààZ [
None
àà[ _
;
àà_ `
bool
ââ !
supportsDepthTarget
ââ $
=
ââ% &
RenderingUtils
ââ' 5
.
ââ5 6)
SupportsRenderTextureFormat
ââ6 Q
(
ââQ R!
RenderTextureFormat
ââR e
.
ââe f
Depth
ââf k
)
ââk l
;
ââl m
bool
ää 
supportsDepthCopy
ää "
=
ää# $
!
ää% &"
msaaEnabledForCamera
ää& :
&&
ää; =
(
ää> ?!
supportsDepthTarget
ää? R
||
ääS U!
supportsTextureCopy
ääV i
)
ääi j
;
ääj k
bool
èè 
msaaDepthResolve
èè !
=
èè" #
false
èè$ )
;
èè) *
return
êê 
supportsDepthCopy
êê $
||
êê% '
msaaDepthResolve
êê( 8
;
êê8 9
}
ëë 	
}
íí 
}ìì ©,
óD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\ShaderData.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
class 	

ShaderData
 
: 
IDisposable "
{ 
static 

ShaderData 

m_Instance $
=% &
null' +
;+ ,
ComputeBuffer		 
m_LightDataBuffer		 '
=		( )
null		* .
;		. /
ComputeBuffer

  
m_LightIndicesBuffer

 *
=

+ ,
null

- 1
;

1 2
ComputeBuffer 
m_ShadowDataBuffer (
=) *
null+ /
;/ 0
ComputeBuffer !
m_ShadowIndicesBuffer +
=, -
null. 2
;2 3

ShaderData 
( 
) 
{ 	
} 	
internal 
static 

ShaderData "
instance# +
{ 	
get 
{ 
if 
( 

m_Instance 
== !
null" &
)& '

m_Instance 
=  
new! $

ShaderData% /
(/ 0
)0 1
;1 2
return 

m_Instance !
;! "
} 
} 	
public 
void 
Dispose 
( 
) 
{ 	
DisposeBuffer   
(   
ref   
m_LightDataBuffer   /
)  / 0
;  0 1
DisposeBuffer!! 
(!! 
ref!!  
m_LightIndicesBuffer!! 2
)!!2 3
;!!3 4
DisposeBuffer"" 
("" 
ref"" 
m_ShadowDataBuffer"" 0
)""0 1
;""1 2
DisposeBuffer## 
(## 
ref## !
m_ShadowIndicesBuffer## 3
)##3 4
;##4 5
}$$ 	
internal&& 
ComputeBuffer&& 
GetLightDataBuffer&& 1
(&&1 2
int&&2 5
size&&6 :
)&&: ;
{'' 	
return(( 
GetOrUpdateBuffer(( $
<(($ %
ShaderInput((% 0
.((0 1
	LightData((1 :
>((: ;
(((; <
ref((< ?
m_LightDataBuffer((@ Q
,((Q R
size((S W
)((W X
;((X Y
})) 	
internal++ 
ComputeBuffer++ !
GetLightIndicesBuffer++ 4
(++4 5
int++5 8
size++9 =
)++= >
{,, 	
return-- 
GetOrUpdateBuffer-- $
<--$ %
int--% (
>--( )
(--) *
ref--* - 
m_LightIndicesBuffer--. B
,--B C
size--D H
)--H I
;--I J
}.. 	
internal00 
ComputeBuffer00 
GetShadowDataBuffer00 2
(002 3
int003 6
size007 ;
)00; <
{11 	
return22 
GetOrUpdateBuffer22 $
<22$ %
ShaderInput22% 0
.220 1

ShadowData221 ;
>22; <
(22< =
ref22= @
m_ShadowDataBuffer22A S
,22S T
size22U Y
)22Y Z
;22Z [
}33 	
internal55 
ComputeBuffer55 "
GetShadowIndicesBuffer55 5
(555 6
int556 9
size55: >
)55> ?
{66 	
return77 
GetOrUpdateBuffer77 $
<77$ %
int77% (
>77( )
(77) *
ref77* -!
m_ShadowIndicesBuffer77. C
,77C D
size77E I
)77I J
;77J K
}88 	
ComputeBuffer:: 
GetOrUpdateBuffer:: '
<::' (
T::( )
>::) *
(::* +
ref::+ .
ComputeBuffer::/ <
buffer::= C
,::C D
int::E H
size::I M
)::M N
where::O T
T::U V
:::W X
struct::Y _
{;; 	
if<< 
(<< 
buffer<< 
==<< 
null<< 
)<< 
{== 
buffer>> 
=>> 
new>> 
ComputeBuffer>> *
(>>* +
size>>+ /
,>>/ 0
Marshal>>1 8
.>>8 9
SizeOf>>9 ?
<>>? @
T>>@ A
>>>A B
(>>B C
)>>C D
)>>D E
;>>E F
}?? 
else@@ 
if@@ 
(@@ 
size@@ 
>@@ 
buffer@@ "
.@@" #
count@@# (
)@@( )
{AA 
bufferBB 
.BB 
DisposeBB 
(BB 
)BB  
;BB  !
bufferCC 
=CC 
newCC 
ComputeBufferCC *
(CC* +
sizeCC+ /
,CC/ 0
MarshalCC1 8
.CC8 9
SizeOfCC9 ?
<CC? @
TCC@ A
>CCA B
(CCB C
)CCC D
)CCD E
;CCE F
}DD 
returnFF 
bufferFF 
;FF 
}GG 	
voidII 
DisposeBufferII 
(II 
refII 
ComputeBufferII ,
bufferII- 3
)II3 4
{JJ 	
ifKK 
(KK 
bufferKK 
!=KK 
nullKK 
)KK 
{LL 
bufferMM 
.MM 
DisposeMM 
(MM 
)MM  
;MM  !
bufferNN 
=NN 
nullNN 
;NN 
}OO 
}PP 	
}QQ 
}RR ãX
£D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\DrawObjectsPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
public 

class 
DrawObjectsPass  
:! " 
ScriptableRenderPass# 7
{ 
FilteringSettings 
m_FilteringSettings -
;- .
RenderStateBlock 
m_RenderStateBlock +
;+ ,
List 
< 
ShaderTagId 
> 
m_ShaderTagIdList +
=, -
new. 1
List2 6
<6 7
ShaderTagId7 B
>B C
(C D
)D E
;E F
string 
m_ProfilerTag 
; 
ProfilingSampler 
m_ProfilingSampler +
;+ ,
bool 

m_IsOpaque 
; 
static 
readonly 
int &
s_DrawObjectPassDataPropID 6
=7 8
Shader9 ?
.? @
PropertyToID@ L
(L M
$strM b
)b c
;c d
public 
DrawObjectsPass 
( 
string %
profilerTag& 1
,1 2
ShaderTagId3 >
[> ?
]? @
shaderTagIdsA M
,M N
boolO S
opaqueT Z
,Z [
RenderPassEvent\ k
evtl o
,o p
RenderQueueRange	q Å
renderQueueRange
Ç í
,
í ì
	LayerMask
î ù
	layerMask
û ß
,
ß ®
StencilState
© µ
stencilState
∂ ¬
,
¬ √
int
ƒ «
stencilReference
» ÿ
)
ÿ Ÿ
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @
DrawObjectsPass@ O
)O P
)P Q
;Q R
m_ProfilerTag 
= 
profilerTag '
;' (
m_ProfilingSampler 
=  
new! $
ProfilingSampler% 5
(5 6
profilerTag6 A
)A B
;B C
foreach 
( 
ShaderTagId  
sid! $
in% '
shaderTagIds( 4
)4 5
m_ShaderTagIdList !
.! "
Add" %
(% &
sid& )
)) *
;* +
renderPassEvent   
=   
evt   !
;  ! "
m_FilteringSettings!! 
=!!  !
new!!" %
FilteringSettings!!& 7
(!!7 8
renderQueueRange!!8 H
,!!H I
	layerMask!!J S
)!!S T
;!!T U
m_RenderStateBlock"" 
=""  
new""! $
RenderStateBlock""% 5
(""5 6
RenderStateMask""6 E
.""E F
Nothing""F M
)""M N
;""N O

m_IsOpaque## 
=## 
opaque## 
;##  
if%% 
(%% 
stencilState%% 
.%% 
enabled%% $
)%%$ %
{&& 
m_RenderStateBlock'' "
.''" #
stencilReference''# 3
=''4 5
stencilReference''6 F
;''F G
m_RenderStateBlock(( "
.((" #
mask((# '
=((( )
RenderStateMask((* 9
.((9 :
Stencil((: A
;((A B
m_RenderStateBlock)) "
.))" #
stencilState))# /
=))0 1
stencilState))2 >
;))> ?
}** 
}++ 	
public-- 
DrawObjectsPass-- 
(-- 
string-- %
profilerTag--& 1
,--1 2
bool--3 7
opaque--8 >
,--> ?
RenderPassEvent--@ O
evt--P S
,--S T
RenderQueueRange--U e
renderQueueRange--f v
,--v w
	LayerMask	--x Å
	layerMask
--Ç ã
,
--ã å
StencilState
--ç ô
stencilState
--ö ¶
,
--¶ ß
int
--® ´
stencilReference
--¨ º
)
--º Ω
:.. 
this.. 
(.. 
profilerTag.. 
,.. 
new// 
ShaderTagId// 
[//  
]//  !
{//" #
new//$ '
ShaderTagId//( 3
(//3 4
$str//4 E
)//E F
,//F G
new//H K
ShaderTagId//L W
(//W X
$str//X j
)//j k
,//k l
new//m p
ShaderTagId//q |
(//| }
$str	//} ì
)
//ì î
,
//î ï
new
//ñ ô
ShaderTagId
//ö •
(
//• ¶
$str
//¶ ∫
)
//∫ ª
}
//ª º
,
//º Ω
opaque00 
,00 
evt00 
,00 
renderQueueRange00 -
,00- .
	layerMask00/ 8
,008 9
stencilState00: F
,00F G
stencilReference00H X
)00X Y
{11 	
}11	 

internal33 
DrawObjectsPass33  
(33  !
URPProfileId33! -
	profileId33. 7
,337 8
bool339 =
opaque33> D
,33D E
RenderPassEvent33F U
evt33V Y
,33Y Z
RenderQueueRange33[ k
renderQueueRange33l |
,33| }
	LayerMask	33~ á
	layerMask
33à ë
,
33ë í
StencilState
33ì ü
stencilState
33† ¨
,
33¨ ≠
int
33Æ ±
stencilReference
33≤ ¬
)
33¬ √
:44 
this44 
(44 
	profileId44 
.44 
GetType44 $
(44$ %
)44% &
.44& '
Name44' +
,44+ ,
opaque44- 3
,443 4
evt445 8
,448 9
renderQueueRange44: J
,44J K
	layerMask44L U
,44U V
stencilState44W c
,44c d
stencilReference44e u
)44u v
{55 	
m_ProfilingSampler66 
=66  
ProfilingSampler66! 1
.661 2
Get662 5
(665 6
	profileId666 ?
)66? @
;66@ A
}77 	
public:: 
override:: 
void:: 
Execute:: $
(::$ %#
ScriptableRenderContext::% <
context::= D
,::D E
ref::F I
RenderingData::J W
renderingData::X e
)::e f
{;; 	
CommandBuffer>> 
cmd>> 
=>> 
CommandBufferPool>>  1
.>>1 2
Get>>2 5
(>>5 6
)>>6 7
;>>7 8
using?? 
(?? 
new?? 
ProfilingScope?? %
(??% &
cmd??& )
,??) *
m_ProfilingSampler??+ =
)??= >
)??> ?
{@@ 
Vector4DD 
drawObjectPassDataDD *
=DD+ ,
newDD- 0
Vector4DD1 8
(DD8 9
$numDD9 =
,DD= >
$numDD? C
,DDC D
$numDDE I
,DDI J
(DDK L

m_IsOpaqueDDL V
)DDV W
?DDX Y
$numDDZ ^
:DD_ `
$numDDa e
)DDe f
;DDf g
cmdEE 
.EE 
SetGlobalVectorEE #
(EE# $&
s_DrawObjectPassDataPropIDEE$ >
,EE> ?
drawObjectPassDataEE@ R
)EER S
;EES T
floatKK 
flipSignKK 
=KK  
(KK! "
renderingDataKK" /
.KK/ 0

cameraDataKK0 :
.KK: ;+
IsCameraProjectionMatrixFlippedKK; Z
(KKZ [
)KK[ \
)KK\ ]
?KK^ _
-KK` a
$numKKa e
:KKf g
$numKKh l
;KKl m
Vector4LL 
	scaleBiasLL !
=LL" #
(LL$ %
flipSignLL% -
<LL. /
$numLL0 4
)LL4 5
?MM 
newMM 
Vector4MM !
(MM! "
flipSignMM" *
,MM* +
$numMM, 0
,MM0 1
-MM2 3
$numMM3 7
,MM7 8
$numMM9 =
)MM= >
:NN 
newNN 
Vector4NN !
(NN! "
flipSignNN" *
,NN* +
$numNN, 0
,NN0 1
$numNN2 6
,NN6 7
$numNN8 <
)NN< =
;NN= >
cmdOO 
.OO 
SetGlobalVectorOO #
(OO# $
ShaderPropertyIdOO$ 4
.OO4 5
scaleBiasRtOO5 @
,OO@ A
	scaleBiasOOB K
)OOK L
;OOL M
contextQQ 
.QQ  
ExecuteCommandBufferQQ ,
(QQ, -
cmdQQ- 0
)QQ0 1
;QQ1 2
cmdRR 
.RR 
ClearRR 
(RR 
)RR 
;RR 
CameraTT 
cameraTT 
=TT 
renderingDataTT  -
.TT- .

cameraDataTT. 8
.TT8 9
cameraTT9 ?
;TT? @
varUU 
	sortFlagsUU 
=UU 
(UU  !

m_IsOpaqueUU! +
)UU+ ,
?UU- .
renderingDataUU/ <
.UU< =

cameraDataUU= G
.UUG H"
defaultOpaqueSortFlagsUUH ^
:UU_ `
SortingCriteriaUUa p
.UUp q
CommonTransparent	UUq Ç
;
UUÇ É
varVV 
drawSettingsVV  
=VV! "!
CreateDrawingSettingsVV# 8
(VV8 9
m_ShaderTagIdListVV9 J
,VVJ K
refVVL O
renderingDataVVP ]
,VV] ^
	sortFlagsVV_ h
)VVh i
;VVi j
varWW 
filterSettingsWW "
=WW# $
m_FilteringSettingsWW% 8
;WW8 9
if[[ 
([[ 
renderingData[[ !
.[[! "

cameraData[[" ,
.[[, -
isPreviewCamera[[- <
)[[< =
{\\ 
filterSettings]] "
.]]" #
	layerMask]]# ,
=]]- .
-]]/ 0
$num]]0 1
;]]1 2
}^^ 
contextaa 
.aa 
DrawRenderersaa %
(aa% &
renderingDataaa& 3
.aa3 4
cullResultsaa4 ?
,aa? @
refaaA D
drawSettingsaaE Q
,aaQ R
refaaS V
filterSettingsaaW e
,aae f
refaag j
m_RenderStateBlockaak }
)aa} ~
;aa~ 
RenderingUtilsdd 
.dd "
RenderObjectsWithErrordd 5
(dd5 6
contextdd6 =
,dd= >
refdd? B
renderingDataddC P
.ddP Q
cullResultsddQ \
,dd\ ]
cameradd^ d
,ddd e
filterSettingsddf t
,ddt u
SortingCriteria	ddv Ö
.
ddÖ Ü
None
ddÜ ä
)
ddä ã
;
ddã å
}ee 
contextff 
.ff  
ExecuteCommandBufferff (
(ff( )
cmdff) ,
)ff, -
;ff- .
CommandBufferPoolgg 
.gg 
Releasegg %
(gg% &
cmdgg& )
)gg) *
;gg* +
}hh 	
}ii 
}jj á√
§D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\UniversalRenderPipeline.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
LWRP  $
{ 
[ 
Obsolete 
( 
$str n
,n o
truep t
)t u
]u v
public 

class %
LightweightRenderPipeline *
{ 
public %
LightweightRenderPipeline (
(( )*
LightweightRenderPipelineAsset) G
assetH M
)M N
{ 	
} 	
} 
} 
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
public 

sealed 
partial 
class #
UniversalRenderPipeline  7
:8 9
RenderPipeline: H
{ 
public 
const 
string 
k_ShaderTagName +
=, -
$str. A
;A B
private 
static 
class 
	Profiling &
{ 	
private   
static   

Dictionary   %
<  % &
int  & )
,  ) *
ProfilingSampler  + ;
>  ; <
s_HashSamplerCache  = O
=  P Q
new  R U

Dictionary  V `
<  ` a
int  a d
,  d e
ProfilingSampler  f v
>  v w
(  w x
)  x y
;  y z
public!! 
static!! 
readonly!! "
ProfilingSampler!!# 3
unknownSampler!!4 B
=!!C D
new!!E H
ProfilingSampler!!I Y
(!!Y Z
$str!!Z c
)!!c d
;!!d e
public$$ 
static$$ 
ProfilingSampler$$ *$
TryGetOrAddCameraSampler$$+ C
($$C D
Camera$$D J
camera$$K Q
)$$Q R
{%% 
ProfilingSampler)) $
ps))% '
=))( )
null))* .
;)). /
int** 
cameraId**  
=**! "
camera**# )
.**) *
GetHashCode*** 5
(**5 6
)**6 7
;**7 8
bool++ 
exists++ 
=++  !
s_HashSamplerCache++" 4
.++4 5
TryGetValue++5 @
(++@ A
cameraId++A I
,++I J
out++K N
ps++O Q
)++Q R
;++R S
if,, 
(,, 
!,, 
exists,, 
),,  
{-- 
ps// 
=// 
new//  
ProfilingSampler//! 1
(//1 2
$"//3 5
{//5 6
nameof//6 <
(//< =#
UniversalRenderPipeline//= T
)//T U
}//U V
.//V W
{//W X
nameof//X ^
(//^ _
RenderSingleCamera//_ q
)//q r
}//r s
: //s u
{//u v
camera//v |
.//| }
name	//} Å
}
//Å Ç
"
//Ç É
)
//É Ñ
;
//Ñ Ö
s_HashSamplerCache00 *
.00* +
Add00+ .
(00. /
cameraId00/ 7
,007 8
ps009 ;
)00; <
;00< =
}11 
return22 
ps22 
;22 
}44 
public66 
static66 
class66 
Pipeline66  (
{77 
public== 
static== 
readonly== &
ProfilingSampler==' 7
beginFrameRendering==8 K
===M N
new==O R
ProfilingSampler==S c
(==c d
$"==d f
{==f g
nameof==g m
(==m n
RenderPipeline==n |
)==| }
}==} ~
.==~ 
{	== Ä
nameof
==Ä Ü
(
==Ü á!
BeginFrameRendering
==á ö
)
==ö õ
}
==õ ú
"
==ú ù
)
==ù û
;
==û ü
public>> 
static>> 
readonly>> &
ProfilingSampler>>' 7
endFrameRendering>>8 I
=>>M N
new>>O R
ProfilingSampler>>S c
(>>c d
$">>d f
{>>f g
nameof>>g m
(>>m n
RenderPipeline>>n |
)>>| }
}>>} ~
.>>~ 
{	>> Ä
nameof
>>Ä Ü
(
>>Ü á
EndFrameRendering
>>á ò
)
>>ò ô
}
>>ô ö
"
>>ö õ
)
>>õ ú
;
>>ú ù
public@@ 
static@@ 
readonly@@ &
ProfilingSampler@@' 7 
beginCameraRendering@@8 L
=@@M N
new@@O R
ProfilingSampler@@S c
(@@c d
$"@@d f
{@@f g
nameof@@g m
(@@m n
RenderPipeline@@n |
)@@| }
}@@} ~
.@@~ 
{	@@ Ä
nameof
@@Ä Ü
(
@@Ü á"
BeginCameraRendering
@@á õ
)
@@õ ú
}
@@ú ù
"
@@ù û
)
@@û ü
;
@@ü †
publicAA 
staticAA 
readonlyAA &
ProfilingSamplerAA' 7
endCameraRenderingAA8 J
=AAM N
newAAO R
ProfilingSamplerAAS c
(AAc d
$"AAd f
{AAf g
nameofAAg m
(AAm n
RenderPipelineAAn |
)AA| }
}AA} ~
.AA~ 
{	AA Ä
nameof
AAÄ Ü
(
AAÜ á 
EndCameraRendering
AAá ô
)
AAô ö
}
AAö õ
"
AAõ ú
)
AAú ù
;
AAù û
constCC 
stringCC 
k_NameCC #
=CC$ %
nameofCC& ,
(CC, -#
UniversalRenderPipelineCC- D
)CCD E
;CCE F
publicDD 
staticDD 
readonlyDD &
ProfilingSamplerDD' 7 
initializeCameraDataDD8 L
=DDW X
newDDY \
ProfilingSamplerDD] m
(DDm n
$"DDn p
{DDp q
k_NameDDq w
}DDw x
.DDx y
{DDy z
nameof	DDz Ä
(
DDÄ Å"
InitializeCameraData
DDÅ ï
)
DDï ñ
}
DDñ ó
"
DDó ò
)
DDò ô
;
DDô ö
publicEE 
staticEE 
readonlyEE &
ProfilingSamplerEE' 7'
initializeStackedCameraDataEE8 S
=EEW X
newEEY \
ProfilingSamplerEE] m
(EEm n
$"EEn p
{EEp q
k_NameEEq w
}EEw x
.EEx y
{EEy z
nameof	EEz Ä
(
EEÄ Å)
InitializeStackedCameraData
EEÅ ú
)
EEú ù
}
EEù û
"
EEû ü
)
EEü †
;
EE† °
publicFF 
staticFF 
readonlyFF &
ProfilingSamplerFF' 7*
initializeAdditionalCameraDataFF8 V
=FFW X
newFFY \
ProfilingSamplerFF] m
(FFm n
$"FFn p
{FFp q
k_NameFFq w
}FFw x
.FFx y
{FFy z
nameof	FFz Ä
(
FFÄ Å,
InitializeAdditionalCameraData
FFÅ ü
)
FFü †
}
FF† °
"
FF° ¢
)
FF¢ £
;
FF£ §
publicGG 
staticGG 
readonlyGG &
ProfilingSamplerGG' 7#
initializeRenderingDataGG8 O
=GGW X
newGGY \
ProfilingSamplerGG] m
(GGm n
$"GGn p
{GGp q
k_NameGGq w
}GGw x
.GGx y
{GGy z
nameof	GGz Ä
(
GGÄ Å%
InitializeRenderingData
GGÅ ò
)
GGò ô
}
GGô ö
"
GGö õ
)
GGõ ú
;
GGú ù
publicHH 
staticHH 
readonlyHH &
ProfilingSamplerHH' 7 
initializeShadowDataHH8 L
=HHW X
newHHY \
ProfilingSamplerHH] m
(HHm n
$"HHn p
{HHp q
k_NameHHq w
}HHw x
.HHx y
{HHy z
nameof	HHz Ä
(
HHÄ Å"
InitializeShadowData
HHÅ ï
)
HHï ñ
}
HHñ ó
"
HHó ò
)
HHò ô
;
HHô ö
publicII 
staticII 
readonlyII &
ProfilingSamplerII' 7
initializeLightDataII8 K
=IIW X
newIIY \
ProfilingSamplerII] m
(IIm n
$"IIn p
{IIp q
k_NameIIq w
}IIw x
.IIx y
{IIy z
nameof	IIz Ä
(
IIÄ Å!
InitializeLightData
IIÅ î
)
IIî ï
}
IIï ñ
"
IIñ ó
)
IIó ò
;
IIò ô
publicJJ 
staticJJ 
readonlyJJ &
ProfilingSamplerJJ' 7"
getPerObjectLightFlagsJJ8 N
=JJW X
newJJY \
ProfilingSamplerJJ] m
(JJm n
$"JJn p
{JJp q
k_NameJJq w
}JJw x
.JJx y
{JJy z
nameof	JJz Ä
(
JJÄ Å$
GetPerObjectLightFlags
JJÅ ó
)
JJó ò
}
JJò ô
"
JJô ö
)
JJö õ
;
JJõ ú
publicKK 
staticKK 
readonlyKK &
ProfilingSamplerKK' 7
getMainLightIndexKK8 I
=KKW X
newKKY \
ProfilingSamplerKK] m
(KKm n
$"KKn p
{KKp q
k_NameKKq w
}KKw x
.KKx y
{KKy z
nameof	KKz Ä
(
KKÄ Å
GetMainLightIndex
KKÅ í
)
KKí ì
}
KKì î
"
KKî ï
)
KKï ñ
;
KKñ ó
publicLL 
staticLL 
readonlyLL &
ProfilingSamplerLL' 7(
setupPerFrameShaderConstantsLL8 T
=LLW X
newLLY \
ProfilingSamplerLL] m
(LLm n
$"LLn p
{LLp q
k_NameLLq w
}LLw x
.LLx y
{LLy z
nameof	LLz Ä
(
LLÄ Å*
SetupPerFrameShaderConstants
LLÅ ù
)
LLù û
}
LLû ü
"
LLü †
)
LL† °
;
LL° ¢
publicNN 
staticNN 
classNN #
RendererNN$ ,
{OO 
constPP 
stringPP  
k_NamePP! '
=PP( )
nameofPP* 0
(PP0 1
ScriptableRendererPP1 C
)PPC D
;PPD E
publicQQ 
staticQQ !
readonlyQQ" *
ProfilingSamplerQQ+ ;"
setupCullingParametersQQ< R
=QQS T
newQQU X
ProfilingSamplerQQY i
(QQi j
$"QQj l
{QQl m
k_NameQQm s
}QQs t
.QQt u
{QQu v
nameofQQv |
(QQ| }
ScriptableRenderer	QQ} è
.
QQè ê$
SetupCullingParameters
QQê ¶
)
QQ¶ ß
}
QQß ®
"
QQ® ©
)
QQ© ™
;
QQ™ ´
publicRR 
staticRR !
readonlyRR" *
ProfilingSamplerRR+ ;
setupRR< A
=RRS T
newRRU X
ProfilingSamplerRRY i
(RRi j
$"RRj l
{RRl m
k_NameRRm s
}RRs t
.RRt u
{RRu v
nameofRRv |
(RR| }
ScriptableRenderer	RR} è
.
RRè ê
Setup
RRê ï
)
RRï ñ
}
RRñ ó
"
RRó ò
)
RRò ô
;
RRô ö
}SS 
;SS 
publicUU 
staticUU 
classUU #
ContextUU$ +
{VV 
constWW 
stringWW  
k_NameWW! '
=WW( )
nameofWW* 0
(WW0 1
ContextWW1 8
)WW8 9
;WW9 :
publicXX 
staticXX !
readonlyXX" *
ProfilingSamplerXX+ ;
submitXX< B
=XXC D
newXXE H
ProfilingSamplerXXI Y
(XXY Z
$"XXZ \
{XX\ ]
k_NameXX] c
}XXc d
.XXd e
{XXe f
nameofXXf l
(XXl m$
ScriptableRenderContext	XXm Ñ
.
XXÑ Ö
Submit
XXÖ ã
)
XXã å
}
XXå ç
"
XXç é
)
XXé è
;
XXè ê
}YY 
;YY 
public[[ 
static[[ 
class[[ #
XR[[$ &
{\\ 
public]] 
static]] !
readonly]]" *
ProfilingSampler]]+ ;

mirrorView]]< F
=]]G H
new]]I L
ProfilingSampler]]M ]
(]]] ^
$str]]^ n
)]]n o
;]]o p
}^^ 
;^^ 
}__ 
;__ 
}`` 	
internalcc 
staticcc 
XRSystemcc  

m_XRSystemcc! +
=cc, -
newcc. 1
XRSystemcc2 :
(cc: ;
)cc; <
;cc< =
publicff 
staticff 
floatff 
maxShadowBiasff )
{gg 	
gethh 
=>hh 
$numhh 
;hh 
}ii 	
publickk 
statickk 
floatkk 
minRenderScalekk *
{ll 	
getmm 
=>mm 
$nummm 
;mm 
}nn 	
publicpp 
staticpp 
floatpp 
maxRenderScalepp *
{qq 	
getrr 
=>rr 
$numrr 
;rr 
}ss 	
publicvv 
staticvv 
intvv 
maxPerObjectLightsvv ,
{ww 	
getzz 
=>zz 
(zz 

SystemInfozz 
.zz 
graphicsDeviceTypezz 1
==zz2 4
GraphicsDeviceTypezz5 G
.zzG H
	OpenGLES2zzH Q
)zzQ R
?zzS T
$numzzU V
:zzW X
$numzzY Z
;zzZ [
}{{ 	
const~~ 
int~~ C
7k_MaxVisibleAdditionalLightsMobileShaderLevelLessThan45~~ I
=~~J K
$num~~L N
;~~N O
const 
int .
"k_MaxVisibleAdditionalLightsMobile 4
=8 9
$num: <
;< =
const
ÄÄ 
int
ÄÄ 3
%k_MaxVisibleAdditionalLightsNonMobile
ÄÄ 7
=
ÄÄ8 9
$num
ÄÄ: =
;
ÄÄ= >
public
ÅÅ 
static
ÅÅ 
int
ÅÅ (
maxVisibleAdditionalLights
ÅÅ 4
{
ÇÇ 	
get
ÉÉ 
{
ÑÑ 
bool
ÖÖ 
isMobile
ÖÖ 
=
ÖÖ 
Application
ÖÖ  +
.
ÖÖ+ ,
isMobilePlatform
ÖÖ, <
;
ÖÖ< =
if
ÜÜ 
(
ÜÜ 
isMobile
ÜÜ 
&&
ÜÜ 
(
ÜÜ  !

SystemInfo
ÜÜ! +
.
ÜÜ+ , 
graphicsDeviceType
ÜÜ, >
==
ÜÜ? A 
GraphicsDeviceType
ÜÜB T
.
ÜÜT U
	OpenGLES2
ÜÜU ^
||
ÜÜ_ a
(
ÜÜb c

SystemInfo
ÜÜc m
.
ÜÜm n!
graphicsDeviceTypeÜÜn Ä
==ÜÜÅ É"
GraphicsDeviceTypeÜÜÑ ñ
.ÜÜñ ó
	OpenGLES3ÜÜó †
&&ÜÜ° £
GraphicsÜÜ§ ¨
.ÜÜ¨ ≠"
minOpenGLESVersionÜÜ≠ ø
<=ÜÜ¿ ¬
OpenGLESVersionÜÜ√ “
.ÜÜ“ ”

OpenGLES30ÜÜ” ›
)ÜÜ› ﬁ
)ÜÜﬁ ﬂ
)ÜÜﬂ ‡
return
áá E
7k_MaxVisibleAdditionalLightsMobileShaderLevelLessThan45
áá R
;
ááR S
return
ää 
(
ää 
isMobile
ää  
||
ää! #

SystemInfo
ää$ .
.
ää. / 
graphicsDeviceType
ää/ A
==
ääB D 
GraphicsDeviceType
ääE W
.
ääW X

OpenGLCore
ääX b
||
ääc e

SystemInfo
ääf p
.
ääp q!
graphicsDeviceTypeääq É
==ääÑ Ü"
GraphicsDeviceTypeääá ô
.ääô ö
	OpenGLES2ääö £
||ää§ ¶

SystemInfoääß ±
.ää± ≤"
graphicsDeviceTypeää≤ ƒ
==ää≈ «"
GraphicsDeviceTypeää» ⁄
.ää⁄ €
	OpenGLES3ää€ ‰
)ää‰ Â
?
ãã 0
"k_MaxVisibleAdditionalLightsMobile
ãã <
:
ãã= >3
%k_MaxVisibleAdditionalLightsNonMobile
ãã? d
;
ããd e
}
åå 
}
çç 	
public
èè %
UniversalRenderPipeline
èè &
(
èè& '*
UniversalRenderPipelineAsset
èè' C
asset
èèD I
)
èèI J
{
êê 	+
SetSupportedRenderingFeatures
ëë )
(
ëë) *
)
ëë* +
;
ëë+ ,
if
îî 
(
îî 
QualitySettings
îî 
.
îî  
antiAliasing
îî  ,
!=
îî- /
asset
îî0 5
.
îî5 6
msaaSampleCount
îî6 E
)
îîE F
{
ïï 
QualitySettings
ññ 
.
ññ  
antiAliasing
ññ  ,
=
ññ- .
asset
ññ/ 4
.
ññ4 5
msaaSampleCount
ññ5 D
;
ññD E
XRSystem
òò 
.
òò 
UpdateMSAALevel
òò (
(
òò( )
asset
òò) .
.
òò. /
msaaSampleCount
òò/ >
)
òò> ?
;
òò? @
}
öö 
XRSystem
ùù 
.
ùù 
UpdateRenderScale
ùù &
(
ùù& '
asset
ùù' ,
.
ùù, -
renderScale
ùù- 8
)
ùù8 9
;
ùù9 :
Shader
†† 
.
†† "
globalRenderPipeline
†† '
=
††( )
$str
††* Q
;
††Q R
Lightmapping
¢¢ 
.
¢¢ 
SetDelegate
¢¢ $
(
¢¢$ %
lightsDelegate
¢¢% 3
)
¢¢3 4
;
¢¢4 5!
CameraCaptureBridge
§§ 
.
§§  
enabled
§§  '
=
§§( )
true
§§* .
;
§§. /
RenderingUtils
¶¶ 
.
¶¶ "
ClearSystemInfoCache
¶¶ /
(
¶¶/ 0
)
¶¶0 1
;
¶¶1 2
}
ßß 	
	protected
©© 
override
©© 
void
©© 
Dispose
©©  '
(
©©' (
bool
©©( ,
	disposing
©©- 6
)
©©6 7
{
™™ 	
base
´´ 
.
´´ 
Dispose
´´ 
(
´´ 
	disposing
´´ "
)
´´" #
;
´´# $
Shader
≠≠ 
.
≠≠ "
globalRenderPipeline
≠≠ '
=
≠≠( )
$str
≠≠* ,
;
≠≠, -(
SupportedRenderingFeatures
ÆÆ &
.
ÆÆ& '
active
ÆÆ' -
=
ÆÆ. /
new
ÆÆ0 3(
SupportedRenderingFeatures
ÆÆ4 N
(
ÆÆN O
)
ÆÆO P
;
ÆÆP Q

ShaderData
ØØ 
.
ØØ 
instance
ØØ 
.
ØØ  
Dispose
ØØ  '
(
ØØ' (
)
ØØ( )
;
ØØ) * 
DeferredShaderData
∞∞ 
.
∞∞ 
instance
∞∞ '
.
∞∞' (
Dispose
∞∞( /
(
∞∞/ 0
)
∞∞0 1
;
∞∞1 2

m_XRSystem
≥≥ 
?
≥≥ 
.
≥≥ 
Dispose
≥≥ 
(
≥≥  
)
≥≥  !
;
≥≥! "
SceneViewDrawMode
∑∑ 
.
∑∑ 
ResetDrawMode
∑∑ +
(
∑∑+ ,
)
∑∑, -
;
∑∑- .
Lightmapping
ππ 
.
ππ 
ResetDelegate
ππ &
(
ππ& '
)
ππ' (
;
ππ( )!
CameraCaptureBridge
∫∫ 
.
∫∫  
enabled
∫∫  '
=
∫∫( )
false
∫∫* /
;
∫∫/ 0
}
ªª 	
	protected
«« 
override
«« 
void
«« 
Render
««  &
(
««& '%
ScriptableRenderContext
««' >
renderContext
««? L
,
««L M
Camera
««N T
[
««T U
]
««U V
cameras
««W ^
)
««^ _
{
…… 	
using
ÃÃ 
var
ÃÃ 
	profScope
ÃÃ 
=
ÃÃ  !
new
ÃÃ" %
ProfilingScope
ÃÃ& 4
(
ÃÃ4 5
null
ÃÃ5 9
,
ÃÃ9 :
ProfilingSampler
ÃÃ; K
.
ÃÃK L
Get
ÃÃL O
(
ÃÃO P
URPProfileId
ÃÃP \
.
ÃÃ\ ]"
UniversalRenderTotal
ÃÃ] q
)
ÃÃq r
)
ÃÃr s
;
ÃÃs t
using
‘‘ 
(
‘‘ 
new
‘‘ 
ProfilingScope
‘‘ $
(
‘‘$ %
null
‘‘% )
,
‘‘) *
	Profiling
‘‘+ 4
.
‘‘4 5
Pipeline
‘‘5 =
.
‘‘= >!
beginFrameRendering
‘‘> Q
)
‘‘Q R
)
‘‘R S
{
’’ !
BeginFrameRendering
÷÷ #
(
÷÷# $
renderContext
÷÷$ 1
,
÷÷1 2
cameras
÷÷3 :
)
÷÷: ;
;
÷÷; <
}
◊◊ 
GraphicsSettings
⁄⁄ 
.
⁄⁄ &
lightsUseLinearIntensity
⁄⁄ 5
=
⁄⁄6 7
(
⁄⁄8 9
QualitySettings
⁄⁄9 H
.
⁄⁄H I
activeColorSpace
⁄⁄I Y
==
⁄⁄Z \

ColorSpace
⁄⁄] g
.
⁄⁄g h
Linear
⁄⁄h n
)
⁄⁄n o
;
⁄⁄o p
GraphicsSettings
€€ 
.
€€ 1
#useScriptableRenderPipelineBatching
€€ @
=
€€A B
asset
€€C H
.
€€H I
useSRPBatcher
€€I V
;
€€V W*
SetupPerFrameShaderConstants
‹‹ (
(
‹‹( )
)
‹‹) *
;
‹‹* +
XRSystem
ﬂﬂ 
.
ﬂﬂ 
UpdateMSAALevel
ﬂﬂ $
(
ﬂﬂ$ %
asset
ﬂﬂ% *
.
ﬂﬂ* +
msaaSampleCount
ﬂﬂ+ :
)
ﬂﬂ: ;
;
ﬂﬂ; <
SortCameras
„„ 
(
„„ 
cameras
„„ 
)
„„  
;
„„  !
for
ÁÁ 
(
ÁÁ 
int
ÁÁ 
i
ÁÁ 
=
ÁÁ 
$num
ÁÁ 
;
ÁÁ 
i
ÁÁ 
<
ÁÁ 
cameras
ÁÁ  '
.
ÁÁ' (
Length
ÁÁ( .
;
ÁÁ. /
++
ÁÁ0 2
i
ÁÁ2 3
)
ÁÁ3 4
{
ÈÈ 
var
ÍÍ 
camera
ÍÍ 
=
ÍÍ 
cameras
ÍÍ $
[
ÍÍ$ %
i
ÍÍ% &
]
ÍÍ& '
;
ÍÍ' (
if
ÎÎ 
(
ÎÎ 
IsGameCamera
ÎÎ  
(
ÎÎ  !
camera
ÎÎ! '
)
ÎÎ' (
)
ÎÎ( )
{
ÏÏ 
RenderCameraStack
ÌÌ %
(
ÌÌ% &
renderContext
ÌÌ& 3
,
ÌÌ3 4
camera
ÌÌ5 ;
)
ÌÌ; <
;
ÌÌ< =
}
ÓÓ 
else
ÔÔ 
{
 
using
ÒÒ 
(
ÒÒ 
new
ÒÒ 
ProfilingScope
ÒÒ -
(
ÒÒ- .
null
ÒÒ. 2
,
ÒÒ2 3
	Profiling
ÒÒ4 =
.
ÒÒ= >
Pipeline
ÒÒ> F
.
ÒÒF G"
beginCameraRendering
ÒÒG [
)
ÒÒ[ \
)
ÒÒ\ ]
{
ÚÚ "
BeginCameraRendering
ÛÛ ,
(
ÛÛ, -
renderContext
ÛÛ- :
,
ÛÛ: ;
camera
ÛÛ< B
)
ÛÛB C
;
ÛÛC D
}
ÙÙ #
UpdateVolumeFramework
˘˘ )
(
˘˘) *
camera
˘˘* 0
,
˘˘0 1
null
˘˘2 6
)
˘˘6 7
;
˘˘7 8 
RenderSingleCamera
˚˚ &
(
˚˚& '
renderContext
˚˚' 4
,
˚˚4 5
camera
˚˚6 <
)
˚˚< =
;
˚˚= >
using
˝˝ 
(
˝˝ 
new
˝˝ 
ProfilingScope
˝˝ -
(
˝˝- .
null
˝˝. 2
,
˝˝2 3
	Profiling
˝˝4 =
.
˝˝= >
Pipeline
˝˝> F
.
˝˝F G 
endCameraRendering
˝˝G Y
)
˝˝Y Z
)
˝˝Z [
{
˛˛  
EndCameraRendering
ˇˇ *
(
ˇˇ* +
renderContext
ˇˇ+ 8
,
ˇˇ8 9
camera
ˇˇ: @
)
ˇˇ@ A
;
ˇˇA B
}
ÄÄ 
}
ÅÅ 
}
ÇÇ 
using
ââ 
(
ââ 
new
ââ 
ProfilingScope
ââ $
(
ââ$ %
null
ââ% )
,
ââ) *
	Profiling
ââ+ 4
.
ââ4 5
Pipeline
ââ5 =
.
ââ= >
endFrameRendering
ââ> O
)
ââO P
)
ââP Q
{
ää 
EndFrameRendering
ãã !
(
ãã! "
renderContext
ãã" /
,
ãã/ 0
cameras
ãã1 8
)
ãã8 9
;
ãã9 :
}
åå 
}
éé 	
public
óó 
static
óó 
void
óó  
RenderSingleCamera
óó -
(
óó- .%
ScriptableRenderContext
óó. E
context
óóF M
,
óóM N
Camera
óóO U
camera
óóV \
)
óó\ ]
{
òò 	+
UniversalAdditionalCameraData
ôô )"
additionalCameraData
ôô* >
=
ôô? @
null
ôôA E
;
ôôE F
if
öö 
(
öö 
IsGameCamera
öö 
(
öö 
camera
öö #
)
öö# $
)
öö$ %
camera
õõ 
.
õõ 

gameObject
õõ !
.
õõ! "
TryGetComponent
õõ" 1
(
õõ1 2
out
õõ2 5"
additionalCameraData
õõ6 J
)
õõJ K
;
õõK L
if
ùù 
(
ùù "
additionalCameraData
ùù $
!=
ùù% '
null
ùù( ,
&&
ùù- /"
additionalCameraData
ùù0 D
.
ùùD E

renderType
ùùE O
!=
ùùP R
CameraRenderType
ùùS c
.
ùùc d
Base
ùùd h
)
ùùh i
{
ûû 
Debug
üü 
.
üü 

LogWarning
üü  
(
üü  !
$strüü! Ä
)üüÄ Å
;üüÅ Ç
return
†† 
;
†† 
}
°° "
InitializeCameraData
££  
(
££  !
camera
££! '
,
££' ("
additionalCameraData
££) =
,
££= >
true
££? C
,
££C D
out
££E H
var
££I L

cameraData
££M W
)
££W X
;
££X Y 
RenderSingleCamera
®® 
(
®® 
context
®® &
,
®®& '

cameraData
®®( 2
,
®®2 3

cameraData
®®4 >
.
®®> ? 
postProcessEnabled
®®? Q
)
®®Q R
;
®®R S
}
©© 	
static
´´ 
bool
´´ %
TryGetCullingParameters
´´ +
(
´´+ ,

CameraData
´´, 6

cameraData
´´7 A
,
´´A B
out
´´C F)
ScriptableCullingParameters
´´G b
cullingParams
´´c p
)
´´p q
{
¨¨ 	
if
ÆÆ 
(
ÆÆ 

cameraData
ÆÆ 
.
ÆÆ 
xr
ÆÆ 
.
ÆÆ 
enabled
ÆÆ %
)
ÆÆ% &
{
ØØ 
cullingParams
∞∞ 
=
∞∞ 

cameraData
∞∞  *
.
∞∞* +
xr
∞∞+ -
.
∞∞- .
cullingParams
∞∞. ;
;
∞∞; <
if
≥≥ 
(
≥≥ 
!
≥≥ 

cameraData
≥≥ 
.
≥≥  
camera
≥≥  &
.
≥≥& '#
usePhysicalProperties
≥≥' <
)
≥≥< =

cameraData
¥¥ 
.
¥¥ 
camera
¥¥ %
.
¥¥% &
fieldOfView
¥¥& 1
=
¥¥2 3
Mathf
¥¥4 9
.
¥¥9 :
Rad2Deg
¥¥: A
*
¥¥B C
Mathf
¥¥D I
.
¥¥I J
Atan
¥¥J N
(
¥¥N O
$num
¥¥O S
/
¥¥T U
cullingParams
¥¥V c
.
¥¥c d$
stereoProjectionMatrix
¥¥d z
.
¥¥z {
m11
¥¥{ ~
)
¥¥~ 
*¥¥Ä Å
$num¥¥Ç Ü
;¥¥Ü á
return
∂∂ 
true
∂∂ 
;
∂∂ 
}
∑∑ 
return
∫∫ 

cameraData
∫∫ 
.
∫∫ 
camera
∫∫ $
.
∫∫$ %%
TryGetCullingParameters
∫∫% <
(
∫∫< =
false
∫∫= B
,
∫∫B C
out
∫∫D G
cullingParams
∫∫H U
)
∫∫U V
;
∫∫V W
}
ªª 	
static
√√ 
void
√√  
RenderSingleCamera
√√ &
(
√√& '%
ScriptableRenderContext
√√' >
context
√√? F
,
√√F G

CameraData
√√H R

cameraData
√√S ]
,
√√] ^
bool
√√_ c&
anyPostProcessingEnabled
√√d |
)
√√| }
{
ƒƒ 	
Camera
≈≈ 
camera
≈≈ 
=
≈≈ 

cameraData
≈≈ &
.
≈≈& '
camera
≈≈' -
;
≈≈- .
var
∆∆ 
renderer
∆∆ 
=
∆∆ 

cameraData
∆∆ %
.
∆∆% &
renderer
∆∆& .
;
∆∆. /
if
«« 
(
«« 
renderer
«« 
==
«« 
null
««  
)
««  !
{
»» 
Debug
…… 
.
…… 

LogWarning
……  
(
……  !
string
……! '
.
……' (
Format
……( .
(
……. /
$str……/ Å
,……Å Ç
camera……É â
.……â ä
name……ä é
)……é è
)……è ê
;……ê ë
return
   
;
   
}
ÀÀ 
if
ÕÕ 
(
ÕÕ 
!
ÕÕ %
TryGetCullingParameters
ÕÕ (
(
ÕÕ( )

cameraData
ÕÕ) 3
,
ÕÕ3 4
out
ÕÕ5 8
var
ÕÕ9 <
cullingParameters
ÕÕ= N
)
ÕÕN O
)
ÕÕO P
return
ŒŒ 
;
ŒŒ  
ScriptableRenderer
–– 
.
–– 
current
–– &
=
––' (
renderer
––) 1
;
––1 2
bool
—— 
isSceneViewCamera
—— "
=
——# $

cameraData
——% /
.
——/ 0
isSceneViewCamera
——0 A
;
——A B
CommandBuffer
ŸŸ 
cmd
ŸŸ 
=
ŸŸ 
CommandBufferPool
ŸŸ  1
.
ŸŸ1 2
Get
ŸŸ2 5
(
ŸŸ5 6
)
ŸŸ6 7
;
ŸŸ7 8
ProfilingSampler
⁄⁄ 
sampler
⁄⁄ $
=
⁄⁄% &
	Profiling
⁄⁄' 0
.
⁄⁄0 1&
TryGetOrAddCameraSampler
⁄⁄1 I
(
⁄⁄I J
camera
⁄⁄J P
)
⁄⁄P Q
;
⁄⁄Q R
using
€€ 
(
€€ 
new
€€ 
ProfilingScope
€€ %
(
€€% &
cmd
€€& )
,
€€) *
sampler
€€+ 2
)
€€2 3
)
€€3 4
{
‹‹ 
renderer
›› 
.
›› 
Clear
›› 
(
›› 

cameraData
›› )
.
››) *

renderType
››* 4
)
››4 5
;
››5 6
using
ﬂﬂ 
(
ﬂﬂ 
new
ﬂﬂ 
ProfilingScope
ﬂﬂ )
(
ﬂﬂ) *
cmd
ﬂﬂ+ .
,
ﬂﬂ. /
	Profiling
ﬂﬂ0 9
.
ﬂﬂ9 :
Pipeline
ﬂﬂ: B
.
ﬂﬂB C
Renderer
ﬂﬂC K
.
ﬂﬂK L$
setupCullingParameters
ﬂﬂL b
)
ﬂﬂb c
)
ﬂﬂc d
{
‡‡ 
renderer
·· 
.
·· $
SetupCullingParameters
·· 3
(
··3 4
ref
··4 7
cullingParameters
··8 I
,
··I J
ref
··K N

cameraData
··O Y
)
··Y Z
;
··Z [
}
‚‚ 
context
‰‰ 
.
‰‰ "
ExecuteCommandBuffer
‰‰ ,
(
‰‰, -
cmd
‰‰- 0
)
‰‰0 1
;
‰‰1 2
cmd
ÂÂ 
.
ÂÂ 
Clear
ÂÂ 
(
ÂÂ 
)
ÂÂ 
;
ÂÂ 
if
ÈÈ 
(
ÈÈ 
isSceneViewCamera
ÈÈ %
)
ÈÈ% &
{
ÍÍ %
ScriptableRenderContext
ÎÎ +
.
ÎÎ+ ,+
EmitWorldGeometryForSceneView
ÎÎ, I
(
ÎÎI J
camera
ÎÎJ P
)
ÎÎP Q
;
ÎÎQ R
}
ÏÏ 
var
ÔÔ 
cullResults
ÔÔ 
=
ÔÔ  !
context
ÔÔ" )
.
ÔÔ) *
Cull
ÔÔ* .
(
ÔÔ. /
ref
ÔÔ/ 2
cullingParameters
ÔÔ3 D
)
ÔÔD E
;
ÔÔE F%
InitializeRenderingData
 '
(
' (
asset
( -
,
- .
ref
/ 2

cameraData
3 =
,
= >
ref
? B
cullResults
C N
,
N O&
anyPostProcessingEnabled
P h
,
h i
out
j m
var
n q
renderingData
r 
) Ä
;Ä Å
using
˜˜ 
(
˜˜ 
new
˜˜ 
ProfilingScope
˜˜ )
(
˜˜) *
cmd
˜˜* -
,
˜˜- .
	Profiling
˜˜/ 8
.
˜˜8 9
Pipeline
˜˜9 A
.
˜˜A B
Renderer
˜˜B J
.
˜˜J K
setup
˜˜K P
)
˜˜P Q
)
˜˜Q R
{
¯¯ 
renderer
˘˘ 
.
˘˘ 
Setup
˘˘ "
(
˘˘" #
context
˘˘# *
,
˘˘* +
ref
˘˘, /
renderingData
˘˘0 =
)
˘˘= >
;
˘˘> ?
}
˙˙ 
renderer
˝˝ 
.
˝˝ 
Execute
˝˝  
(
˝˝  !
context
˝˝! (
,
˝˝( )
ref
˝˝* -
renderingData
˝˝. ;
)
˝˝; <
;
˝˝< =
}
ˇˇ 

cameraData
ÅÅ 
.
ÅÅ 
xr
ÅÅ 
.
ÅÅ 
	EndCamera
ÅÅ #
(
ÅÅ# $
cmd
ÅÅ$ '
,
ÅÅ' (

cameraData
ÅÅ) 3
)
ÅÅ3 4
;
ÅÅ4 5
context
ÇÇ 
.
ÇÇ "
ExecuteCommandBuffer
ÇÇ (
(
ÇÇ( )
cmd
ÇÇ) ,
)
ÇÇ, -
;
ÇÇ- .
CommandBufferPool
ÉÉ 
.
ÉÉ 
Release
ÉÉ %
(
ÉÉ% &
cmd
ÉÉ& )
)
ÉÉ) *
;
ÉÉ* +
using
ÖÖ 
(
ÖÖ 
new
ÖÖ 
ProfilingScope
ÖÖ %
(
ÖÖ% &
cmd
ÖÖ& )
,
ÖÖ) *
	Profiling
ÖÖ+ 4
.
ÖÖ4 5
Pipeline
ÖÖ5 =
.
ÖÖ= >
Context
ÖÖ> E
.
ÖÖE F
submit
ÖÖF L
)
ÖÖL M
)
ÖÖM N
{
ÜÜ 
context
áá 
.
áá 
Submit
áá 
(
áá 
)
áá  
;
áá  !
}
àà  
ScriptableRenderer
ää 
.
ää 
current
ää &
=
ää' (
null
ää) -
;
ää- .
}
ãã 	
static
ìì 
void
ìì 
RenderCameraStack
ìì %
(
ìì% &%
ScriptableRenderContext
ìì& =
context
ìì> E
,
ììE F
Camera
ììG M

baseCamera
ììN X
)
ììX Y
{
îî 	
using
ïï 
var
ïï 
	profScope
ïï 
=
ïï  !
new
ïï" %
ProfilingScope
ïï& 4
(
ïï4 5
null
ïï5 9
,
ïï9 :
ProfilingSampler
ïï; K
.
ïïK L
Get
ïïL O
(
ïïO P
URPProfileId
ïïP \
.
ïï\ ]
RenderCameraStack
ïï] n
)
ïïn o
)
ïïo p
;
ïïp q

baseCamera
óó 
.
óó 
TryGetComponent
óó &
<
óó& '+
UniversalAdditionalCameraData
óó' D
>
óóD E
(
óóE F
out
óóF I
var
óóJ M&
baseCameraAdditionalData
óóN f
)
óóf g
;
óóg h
if
öö 
(
öö &
baseCameraAdditionalData
öö (
!=
öö) +
null
öö, 0
&&
öö1 3&
baseCameraAdditionalData
öö4 L
.
ööL M

renderType
ööM W
==
ööX Z
CameraRenderType
öö[ k
.
öök l
Overlay
ööl s
)
öös t
return
õõ 
;
õõ 
var
ûû 
renderer
ûû 
=
ûû &
baseCameraAdditionalData
ûû 3
?
ûû3 4
.
ûû4 5 
scriptableRenderer
ûû5 G
;
ûûG H
bool
üü $
supportsCameraStacking
üü '
=
üü( )
renderer
üü* 2
!=
üü3 5
null
üü6 :
&&
üü; =
renderer
üü> F
.
üüF G(
supportedRenderingFeatures
üüG a
.
üüa b
cameraStacking
üüb p
;
üüp q
List
†† 
<
†† 
Camera
†† 
>
†† 
cameraStack
†† $
=
††% &
(
††' ($
supportsCameraStacking
††( >
)
††> ?
?
††@ A&
baseCameraAdditionalData
††B Z
?
††Z [
.
††[ \
cameraStack
††\ g
:
††h i
null
††j n
;
††n o
bool
¢¢ &
anyPostProcessingEnabled
¢¢ )
=
¢¢* +&
baseCameraAdditionalData
¢¢, D
!=
¢¢E G
null
¢¢H L
&&
¢¢M O&
baseCameraAdditionalData
¢¢P h
.
¢¢h i"
renderPostProcessing
¢¢i }
;
¢¢} ~
int
ßß *
lastActiveOverlayCameraIndex
ßß ,
=
ßß- .
-
ßß/ 0
$num
ßß0 1
;
ßß1 2
if
®® 
(
®® 
cameraStack
®® 
!=
®® 
null
®® #
)
®®# $
{
©© 
var
™™ $
baseCameraRendererType
™™ *
=
™™+ ,&
baseCameraAdditionalData
™™- E
?
™™E F
.
™™F G 
scriptableRenderer
™™G Y
.
™™Y Z
GetType
™™Z a
(
™™a b
)
™™b c
;
™™c d
bool
´´ %
shouldUpdateCameraStack
´´ ,
=
´´- .
false
´´/ 4
;
´´4 5
for
≠≠ 
(
≠≠ 
int
≠≠ 
i
≠≠ 
=
≠≠ 
$num
≠≠ 
;
≠≠ 
i
≠≠  !
<
≠≠" #
cameraStack
≠≠$ /
.
≠≠/ 0
Count
≠≠0 5
;
≠≠5 6
++
≠≠7 9
i
≠≠9 :
)
≠≠: ;
{
ÆÆ 
Camera
ØØ 

currCamera
ØØ %
=
ØØ& '
cameraStack
ØØ( 3
[
ØØ3 4
i
ØØ4 5
]
ØØ5 6
;
ØØ6 7
if
∞∞ 
(
∞∞ 

currCamera
∞∞ "
==
∞∞# %
null
∞∞& *
)
∞∞* +
{
±± %
shouldUpdateCameraStack
≤≤ /
=
≤≤0 1
true
≤≤2 6
;
≤≤6 7
continue
≥≥  
;
≥≥  !
}
¥¥ 
if
∂∂ 
(
∂∂ 

currCamera
∂∂ "
.
∂∂" # 
isActiveAndEnabled
∂∂# 5
)
∂∂5 6
{
∑∑ 

currCamera
∏∏ "
.
∏∏" #
TryGetComponent
∏∏# 2
<
∏∏2 3+
UniversalAdditionalCameraData
∏∏3 P
>
∏∏P Q
(
∏∏Q R
out
∏∏R U
var
∏∏V Y
data
∏∏Z ^
)
∏∏^ _
;
∏∏_ `
if
∫∫ 
(
∫∫ 
data
∫∫  
==
∫∫! #
null
∫∫$ (
||
∫∫) +
data
∫∫, 0
.
∫∫0 1

renderType
∫∫1 ;
!=
∫∫< >
CameraRenderType
∫∫? O
.
∫∫O P
Overlay
∫∫P W
)
∫∫W X
{
ªª 
Debug
ºº !
.
ºº! "

LogWarning
ºº" ,
(
ºº, -
string
ºº- 3
.
ºº3 4
Format
ºº4 :
(
ºº: ;
$str
ºº; }
,
ºº} ~

currCameraºº â
.ººâ ä
nameººä é
)ººé è
)ººè ê
;ººê ë
continue
ΩΩ $
;
ΩΩ$ %
}
ææ 
var
¿¿ $
currCameraRendererType
¿¿ 2
=
¿¿3 4
data
¿¿5 9
?
¿¿9 :
.
¿¿: ; 
scriptableRenderer
¿¿; M
.
¿¿M N
GetType
¿¿N U
(
¿¿U V
)
¿¿V W
;
¿¿W X
if
¡¡ 
(
¡¡ $
currCameraRendererType
¡¡ 2
!=
¡¡3 5$
baseCameraRendererType
¡¡6 L
)
¡¡L M
{
¬¬ 
var
√√ 
renderer2DType
√√  .
=
√√/ 0
typeof
√√1 7
(
√√7 8
Experimental
√√8 D
.
√√D E
	Rendering
√√E N
.
√√N O
	Universal
√√O X
.
√√X Y

Renderer2D
√√Y c
)
√√c d
;
√√d e
if
ƒƒ 
(
ƒƒ  $
currCameraRendererType
ƒƒ  6
!=
ƒƒ7 9
renderer2DType
ƒƒ: H
&&
ƒƒI K$
baseCameraRendererType
ƒƒL b
!=
ƒƒc e
renderer2DType
ƒƒf t
)
ƒƒt u
{
≈≈ 
Debug
∆∆  %
.
∆∆% &

LogWarning
∆∆& 0
(
∆∆0 1
string
∆∆1 7
.
∆∆7 8
Format
∆∆8 >
(
∆∆> ?
$str∆∆? î
,∆∆î ï

currCamera∆∆ñ †
.∆∆† °
name∆∆° •
)∆∆• ¶
)∆∆¶ ß
;∆∆ß ®
continue
««  (
;
««( )
}
»» 
}
…… &
anyPostProcessingEnabled
ÀÀ 0
|=
ÀÀ1 3
data
ÀÀ4 8
.
ÀÀ8 9"
renderPostProcessing
ÀÀ9 M
;
ÀÀM N*
lastActiveOverlayCameraIndex
ÃÃ 4
=
ÃÃ5 6
i
ÃÃ7 8
;
ÃÃ8 9
}
ÕÕ 
}
ŒŒ 
if
œœ 
(
œœ %
shouldUpdateCameraStack
œœ *
)
œœ* +
{
–– &
baseCameraAdditionalData
—— ,
.
——, -
UpdateCameraStack
——- >
(
——> ?
)
——? @
;
——@ A
}
““ 
}
”” &
anyPostProcessingEnabled
÷÷ $
&=
÷÷% '

SystemInfo
÷÷( 2
.
÷÷2 3 
graphicsDeviceType
÷÷3 E
!=
÷÷F H 
GraphicsDeviceType
÷÷I [
.
÷÷[ \
	OpenGLES2
÷÷\ e
;
÷÷e f
bool
ÿÿ  
isStackedRendering
ÿÿ #
=
ÿÿ$ %*
lastActiveOverlayCameraIndex
ÿÿ& B
!=
ÿÿC E
-
ÿÿF G
$num
ÿÿG H
;
ÿÿH I"
InitializeCameraData
⁄⁄  
(
⁄⁄  !

baseCamera
⁄⁄! +
,
⁄⁄+ ,&
baseCameraAdditionalData
⁄⁄- E
,
⁄⁄E F
!
⁄⁄G H 
isStackedRendering
⁄⁄H Z
,
⁄⁄Z [
out
⁄⁄\ _
var
⁄⁄` c
baseCameraData
⁄⁄d r
)
⁄⁄r s
;
⁄⁄s t
var
››  
originalTargetDesc
›› "
=
››# $
baseCameraData
››% 3
.
››3 4$
cameraTargetDescriptor
››4 J
;
››J K
var
ﬁﬁ 
xrActive
ﬁﬁ 
=
ﬁﬁ 
false
ﬁﬁ  
;
ﬁﬁ  !
var
ﬂﬂ 
xrPasses
ﬂﬂ 
=
ﬂﬂ 

m_XRSystem
ﬂﬂ %
.
ﬂﬂ% &

SetupFrame
ﬂﬂ& 0
(
ﬂﬂ0 1
baseCameraData
ﬂﬂ1 ?
)
ﬂﬂ? @
;
ﬂﬂ@ A
foreach
‡‡ 
(
‡‡ 
XRPass
‡‡ 
xrPass
‡‡ "
in
‡‡# %
xrPasses
‡‡& .
)
‡‡. /
{
·· 
baseCameraData
‚‚ 
.
‚‚ 
xr
‚‚ !
=
‚‚" #
xrPass
‚‚$ *
;
‚‚* +
baseCameraData
ÊÊ 
.
ÊÊ 
isStereoEnabled
ÊÊ .
=
ÊÊ/ 0
xrPass
ÊÊ1 7
.
ÊÊ7 8
enabled
ÊÊ8 ?
;
ÊÊ? @
if
ÈÈ 
(
ÈÈ 
baseCameraData
ÈÈ "
.
ÈÈ" #
xr
ÈÈ# %
.
ÈÈ% &
enabled
ÈÈ& -
)
ÈÈ- .
{
ÍÍ 
xrActive
ÎÎ 
=
ÎÎ 
true
ÎÎ #
;
ÎÎ# $

m_XRSystem
ÌÌ 
.
ÌÌ 
UpdateCameraData
ÌÌ /
(
ÌÌ/ 0
ref
ÌÌ0 3
baseCameraData
ÌÌ4 B
,
ÌÌB C
baseCameraData
ÌÌD R
.
ÌÌR S
xr
ÌÌS U
)
ÌÌU V
;
ÌÌV W
}
ÓÓ 
using
 
(
 
new
 
ProfilingScope
 (
(
( )
null
) -
,
- .
	Profiling
/ 8
.
8 9
Pipeline
9 A
.
A B"
beginCameraRendering
B V
)
V W
)
W X
{
ÒÒ "
BeginCameraRendering
ÚÚ (
(
ÚÚ( )
context
ÚÚ) 0
,
ÚÚ0 1

baseCamera
ÚÚ2 <
)
ÚÚ< =
;
ÚÚ= >
}
ÛÛ #
UpdateVolumeFramework
¯¯ %
(
¯¯% &

baseCamera
¯¯& 0
,
¯¯0 1&
baseCameraAdditionalData
¯¯2 J
)
¯¯J K
;
¯¯K L 
RenderSingleCamera
˝˝ "
(
˝˝" #
context
˝˝# *
,
˝˝* +
baseCameraData
˝˝, :
,
˝˝: ;&
anyPostProcessingEnabled
˝˝< T
)
˝˝T U
;
˝˝U V
using
˛˛ 
(
˛˛ 
new
˛˛ 
ProfilingScope
˛˛ )
(
˛˛) *
null
˛˛* .
,
˛˛. /
	Profiling
˛˛0 9
.
˛˛9 :
Pipeline
˛˛: B
.
˛˛B C 
endCameraRendering
˛˛C U
)
˛˛U V
)
˛˛V W
{
ˇˇ  
EndCameraRendering
ÄÄ &
(
ÄÄ& '
context
ÄÄ' .
,
ÄÄ. /

baseCamera
ÄÄ0 :
)
ÄÄ: ;
;
ÄÄ; <
}
ÅÅ 
if
ÉÉ 
(
ÉÉ  
isStackedRendering
ÉÉ &
)
ÉÉ& '
{
ÑÑ 
for
ÖÖ 
(
ÖÖ 
int
ÖÖ 
i
ÖÖ 
=
ÖÖ  
$num
ÖÖ! "
;
ÖÖ" #
i
ÖÖ$ %
<
ÖÖ& '
cameraStack
ÖÖ( 3
.
ÖÖ3 4
Count
ÖÖ4 9
;
ÖÖ9 :
++
ÖÖ; =
i
ÖÖ= >
)
ÖÖ> ?
{
ÜÜ 
var
áá 

currCamera
áá &
=
áá' (
cameraStack
áá) 4
[
áá4 5
i
áá5 6
]
áá6 7
;
áá7 8
if
àà 
(
àà 
!
àà 

currCamera
àà '
.
àà' ( 
isActiveAndEnabled
àà( :
)
àà: ;
continue
ââ $
;
ââ$ %

currCamera
ãã "
.
ãã" #
TryGetComponent
ãã# 2
<
ãã2 3+
UniversalAdditionalCameraData
ãã3 P
>
ããP Q
(
ããQ R
out
ããR U
var
ããV Y
currCameraData
ããZ h
)
ããh i
;
ããi j
if
çç 
(
çç 
currCameraData
çç *
!=
çç+ -
null
çç. 2
)
çç2 3
{
éé 

CameraData
êê &
overlayCameraData
êê' 8
=
êê9 :
baseCameraData
êê; I
;
êêI J
bool
ëë  

lastCamera
ëë! +
=
ëë, -
i
ëë. /
==
ëë0 2*
lastActiveOverlayCameraIndex
ëë3 O
;
ëëO P
using
ìì !
(
ìì" #
new
ìì# &
ProfilingScope
ìì' 5
(
ìì5 6
null
ìì6 :
,
ìì: ;
	Profiling
ìì< E
.
ììE F
Pipeline
ììF N
.
ììN O"
beginCameraRendering
ììO c
)
ììc d
)
ììd e
{
îî "
BeginCameraRendering
ïï  4
(
ïï4 5
context
ïï5 <
,
ïï< =

currCamera
ïï> H
)
ïïH I
;
ïïI J
}
ññ #
UpdateVolumeFramework
õõ 1
(
õõ1 2

currCamera
õõ2 <
,
õõ< =
currCameraData
õõ> L
)
õõL M
;
õõM N,
InitializeAdditionalCameraData
úú :
(
úú: ;

currCamera
úú; E
,
úúE F
currCameraData
úúG U
,
úúU V

lastCamera
úúW a
,
úúa b
ref
úúc f
overlayCameraData
úúg x
)
úúx y
;
úúy z
if
ûû 
(
ûû  
baseCameraData
ûû  .
.
ûû. /
xr
ûû/ 1
.
ûû1 2
enabled
ûû2 9
)
ûû9 :

m_XRSystem
üü  *
.
üü* +
UpdateFromCamera
üü+ ;
(
üü; <
ref
üü< ?
overlayCameraData
üü@ Q
.
üüQ R
xr
üüR T
,
üüT U
overlayCameraData
üüV g
)
üüg h
;
üüh i 
RenderSingleCamera
°° .
(
°°. /
context
°°/ 6
,
°°6 7
overlayCameraData
°°8 I
,
°°I J&
anyPostProcessingEnabled
°°K c
)
°°c d
;
°°d e
using
££ !
(
££" #
new
££# &
ProfilingScope
££' 5
(
££5 6
null
££6 :
,
££: ;
	Profiling
££< E
.
££E F
Pipeline
££F N
.
££N O 
endCameraRendering
££O a
)
££a b
)
££b c
{
§§  
EndCameraRendering
••  2
(
••2 3
context
••3 :
,
••: ;

currCamera
••< F
)
••F G
;
••G H
}
¶¶ 
}
ßß 
}
®® 
}
©© 
if
¨¨ 
(
¨¨ 
baseCameraData
¨¨ "
.
¨¨" #
xr
¨¨# %
.
¨¨% &
enabled
¨¨& -
)
¨¨- .
baseCameraData
≠≠ "
.
≠≠" #$
cameraTargetDescriptor
≠≠# 9
=
≠≠: ; 
originalTargetDesc
≠≠< N
;
≠≠N O
}
ÆÆ 
if
∞∞ 
(
∞∞ 
xrActive
∞∞ 
)
∞∞ 
{
±± 
CommandBuffer
≤≤ 
cmd
≤≤ !
=
≤≤" #
CommandBufferPool
≤≤$ 5
.
≤≤5 6
Get
≤≤6 9
(
≤≤9 :
)
≤≤: ;
;
≤≤; <
using
≥≥ 
(
≥≥ 
new
≥≥ 
ProfilingScope
≥≥ )
(
≥≥) *
cmd
≥≥* -
,
≥≥- .
	Profiling
≥≥/ 8
.
≥≥8 9
Pipeline
≥≥9 A
.
≥≥A B
XR
≥≥B D
.
≥≥D E

mirrorView
≥≥E O
)
≥≥O P
)
≥≥P Q
{
¥¥ 

m_XRSystem
µµ 
.
µµ 
RenderMirrorView
µµ /
(
µµ/ 0
cmd
µµ0 3
,
µµ3 4

baseCamera
µµ5 ?
)
µµ? @
;
µµ@ A
}
∂∂ 
context
∏∏ 
.
∏∏ "
ExecuteCommandBuffer
∏∏ ,
(
∏∏, -
cmd
∏∏- 0
)
∏∏0 1
;
∏∏1 2
context
ππ 
.
ππ 
Submit
ππ 
(
ππ 
)
ππ  
;
ππ  !
CommandBufferPool
∫∫ !
.
∫∫! "
Release
∫∫" )
(
∫∫) *
cmd
∫∫* -
)
∫∫- .
;
∫∫. /
}
ªª 

m_XRSystem
ΩΩ 
.
ΩΩ 
ReleaseFrame
ΩΩ #
(
ΩΩ# $
)
ΩΩ$ %
;
ΩΩ% &
}
øø 	
static
¡¡ 
void
¡¡ #
UpdateVolumeFramework
¡¡ )
(
¡¡) *
Camera
¡¡* 0
camera
¡¡1 7
,
¡¡7 8+
UniversalAdditionalCameraData
¡¡9 V"
additionalCameraData
¡¡W k
)
¡¡k l
{
¬¬ 	
using
√√ 
var
√√ 
	profScope
√√ 
=
√√  !
new
√√" %
ProfilingScope
√√& 4
(
√√4 5
null
√√5 9
,
√√9 :
ProfilingSampler
√√; K
.
√√K L
Get
√√L O
(
√√O P
URPProfileId
√√P \
.
√√\ ]#
UpdateVolumeFramework
√√] r
)
√√r s
)
√√s t
;
√√t u
	LayerMask
∆∆ 
	layerMask
∆∆ 
=
∆∆  !
$num
∆∆" #
;
∆∆# $
	Transform
«« 
trigger
«« 
=
«« 
camera
««  &
.
««& '
	transform
««' 0
;
««0 1
if
…… 
(
…… "
additionalCameraData
…… $
!=
……% '
null
……( ,
)
……, -
{
   
	layerMask
ÀÀ 
=
ÀÀ "
additionalCameraData
ÀÀ 0
.
ÀÀ0 1
volumeLayerMask
ÀÀ1 @
;
ÀÀ@ A
trigger
ÃÃ 
=
ÃÃ "
additionalCameraData
ÃÃ .
.
ÃÃ. /
volumeTrigger
ÃÃ/ <
!=
ÃÃ= ?
null
ÃÃ@ D
?
ÕÕ "
additionalCameraData
ÕÕ *
.
ÕÕ* +
volumeTrigger
ÕÕ+ 8
:
ŒŒ 
trigger
ŒŒ 
;
ŒŒ 
}
œœ 
else
–– 
if
–– 
(
–– 
camera
–– 
.
–– 

cameraType
–– &
==
––' )

CameraType
––* 4
.
––4 5
	SceneView
––5 >
)
––> ?
{
—— 
var
”” 

mainCamera
”” 
=
””  
Camera
””! '
.
””' (
main
””( ,
;
””, -+
UniversalAdditionalCameraData
‘‘ -&
mainAdditionalCameraData
‘‘. F
=
‘‘G H
null
‘‘I M
;
‘‘M N
if
÷÷ 
(
÷÷ 

mainCamera
÷÷ 
!=
÷÷ !
null
÷÷" &
&&
÷÷' )

mainCamera
÷÷* 4
.
÷÷4 5
TryGetComponent
÷÷5 D
(
÷÷D E
out
÷÷E H&
mainAdditionalCameraData
÷÷I a
)
÷÷a b
)
÷÷b c
	layerMask
◊◊ 
=
◊◊ &
mainAdditionalCameraData
◊◊  8
.
◊◊8 9
volumeLayerMask
◊◊9 H
;
◊◊H I
trigger
ŸŸ 
=
ŸŸ &
mainAdditionalCameraData
ŸŸ 2
!=
ŸŸ3 5
null
ŸŸ6 :
&&
ŸŸ; =&
mainAdditionalCameraData
ŸŸ> V
.
ŸŸV W
volumeTrigger
ŸŸW d
!=
ŸŸe g
null
ŸŸh l
?
ŸŸm n'
mainAdditionalCameraDataŸŸo á
.ŸŸá à
volumeTriggerŸŸà ï
:ŸŸñ ó
triggerŸŸò ü
;ŸŸü †
}
⁄⁄ 
VolumeManager
‹‹ 
.
‹‹ 
instance
‹‹ "
.
‹‹" #
Update
‹‹# )
(
‹‹) *
trigger
‹‹* 1
,
‹‹1 2
	layerMask
‹‹3 <
)
‹‹< =
;
‹‹= >
}
›› 	
static
ﬂﬂ 
bool
ﬂﬂ &
CheckPostProcessForDepth
ﬂﬂ ,
(
ﬂﬂ, -
in
ﬂﬂ- /

CameraData
ﬂﬂ0 :

cameraData
ﬂﬂ; E
)
ﬂﬂE F
{
‡‡ 	
if
·· 
(
·· 
!
·· 

cameraData
·· 
.
··  
postProcessEnabled
·· .
)
··. /
return
‚‚ 
false
‚‚ 
;
‚‚ 
if
‰‰ 
(
‰‰ 

cameraData
‰‰ 
.
‰‰ 
antialiasing
‰‰ '
==
‰‰( *
AntialiasingMode
‰‰+ ;
.
‰‰; </
!SubpixelMorphologicalAntiAliasing
‰‰< ]
)
‰‰] ^
return
ÂÂ 
true
ÂÂ 
;
ÂÂ 
var
ÁÁ 
stack
ÁÁ 
=
ÁÁ 
VolumeManager
ÁÁ %
.
ÁÁ% &
instance
ÁÁ& .
.
ÁÁ. /
stack
ÁÁ/ 4
;
ÁÁ4 5
if
ÈÈ 
(
ÈÈ 
stack
ÈÈ 
.
ÈÈ 
GetComponent
ÈÈ "
<
ÈÈ" #
DepthOfField
ÈÈ# /
>
ÈÈ/ 0
(
ÈÈ0 1
)
ÈÈ1 2
.
ÈÈ2 3
IsActive
ÈÈ3 ;
(
ÈÈ; <
)
ÈÈ< =
)
ÈÈ= >
return
ÍÍ 
true
ÍÍ 
;
ÍÍ 
if
ÏÏ 
(
ÏÏ 
stack
ÏÏ 
.
ÏÏ 
GetComponent
ÏÏ "
<
ÏÏ" #

MotionBlur
ÏÏ# -
>
ÏÏ- .
(
ÏÏ. /
)
ÏÏ/ 0
.
ÏÏ0 1
IsActive
ÏÏ1 9
(
ÏÏ9 :
)
ÏÏ: ;
)
ÏÏ; <
return
ÌÌ 
true
ÌÌ 
;
ÌÌ 
return
ÔÔ 
false
ÔÔ 
;
ÔÔ 
}
 	
static
ÚÚ 
void
ÚÚ +
SetSupportedRenderingFeatures
ÚÚ 1
(
ÚÚ1 2
)
ÚÚ2 3
{
ÛÛ 	(
SupportedRenderingFeatures
ıı &
.
ıı& '
active
ıı' -
=
ıı. /
new
ıı0 3(
SupportedRenderingFeatures
ıı4 N
(
ııN O
)
ııO P
{
ˆˆ "
reflectionProbeModes
˜˜ $
=
˜˜% &(
SupportedRenderingFeatures
˜˜' A
.
˜˜A B"
ReflectionProbeModes
˜˜B V
.
˜˜V W
None
˜˜W [
,
˜˜[ \'
defaultMixedLightingModes
¯¯ )
=
¯¯* +(
SupportedRenderingFeatures
¯¯, F
.
¯¯F G$
LightmapMixedBakeModes
¯¯G ]
.
¯¯] ^
Subtractive
¯¯^ i
,
¯¯i j 
mixedLightingModes
˘˘ "
=
˘˘# $(
SupportedRenderingFeatures
˘˘% ?
.
˘˘? @$
LightmapMixedBakeModes
˘˘@ V
.
˘˘V W
Subtractive
˘˘W b
|
˘˘c d(
SupportedRenderingFeatures
˘˘e 
.˘˘ Ä&
LightmapMixedBakeModes˘˘Ä ñ
.˘˘ñ ó
IndirectOnly˘˘ó £
|˘˘§ •*
SupportedRenderingFeatures˘˘¶ ¿
.˘˘¿ ¡&
LightmapMixedBakeModes˘˘¡ ◊
.˘˘◊ ÿ

Shadowmask˘˘ÿ ‚
,˘˘‚ „
lightmapBakeTypes
˙˙ !
=
˙˙" #
LightmapBakeType
˙˙$ 4
.
˙˙4 5
Baked
˙˙5 :
|
˙˙; <
LightmapBakeType
˙˙= M
.
˙˙M N
Mixed
˙˙N S
,
˙˙S T
lightmapsModes
˚˚ 
=
˚˚  
LightmapsMode
˚˚! .
.
˚˚. /!
CombinedDirectional
˚˚/ B
|
˚˚C D
LightmapsMode
˚˚E R
.
˚˚R S
NonDirectional
˚˚S a
,
˚˚a b$
lightProbeProxyVolumes
¸¸ &
=
¸¸' (
false
¸¸) .
,
¸¸. /
motionVectors
˝˝ 
=
˝˝ 
false
˝˝  %
,
˝˝% &
receiveShadows
˛˛ 
=
˛˛  
false
˛˛! &
,
˛˛& '
reflectionProbes
ˇˇ  
=
ˇˇ! "
true
ˇˇ# '
,
ˇˇ' (&
particleSystemInstancing
ÄÄ (
=
ÄÄ) *
true
ÄÄ+ /
}
ÅÅ 
;
ÅÅ 
SceneViewDrawMode
ÇÇ 
.
ÇÇ 
SetupDrawMode
ÇÇ +
(
ÇÇ+ ,
)
ÇÇ, -
;
ÇÇ- .
}
ÑÑ 	
static
ÜÜ 
void
ÜÜ "
InitializeCameraData
ÜÜ (
(
ÜÜ( )
Camera
ÜÜ) /
camera
ÜÜ0 6
,
ÜÜ6 7+
UniversalAdditionalCameraData
ÜÜ8 U"
additionalCameraData
ÜÜV j
,
ÜÜj k
bool
ÜÜl p!
resolveFinalTargetÜÜq É
,ÜÜÉ Ñ
outÜÜÖ à

CameraDataÜÜâ ì

cameraDataÜÜî û
)ÜÜû ü
{
áá 	
using
àà 
var
àà 
	profScope
àà 
=
àà  !
new
àà" %
ProfilingScope
àà& 4
(
àà4 5
null
àà5 9
,
àà9 :
	Profiling
àà; D
.
ààD E
Pipeline
ààE M
.
ààM N"
initializeCameraData
ààN b
)
ààb c
;
ààc d

cameraData
ää 
=
ää 
new
ää 

CameraData
ää '
(
ää' (
)
ää( )
;
ää) *)
InitializeStackedCameraData
ãã '
(
ãã' (
camera
ãã( .
,
ãã. /"
additionalCameraData
ãã0 D
,
ããD E
ref
ããF I

cameraData
ããJ T
)
ããT U
;
ããU V,
InitializeAdditionalCameraData
åå *
(
åå* +
camera
åå+ 1
,
åå1 2"
additionalCameraData
åå3 G
,
ååG H 
resolveFinalTarget
ååI [
,
åå[ \
ref
åå] `

cameraData
ååa k
)
ååk l
;
åål m
}
çç 	
static
ññ 
void
ññ )
InitializeStackedCameraData
ññ /
(
ññ/ 0
Camera
ññ0 6

baseCamera
ññ7 A
,
ññA B+
UniversalAdditionalCameraData
ññC `&
baseAdditionalCameraData
ñña y
,
ññy z
ref
ññ{ ~

CameraDataññ â

cameraDataññä î
)ññî ï
{
óó 	
using
òò 
var
òò 
	profScope
òò 
=
òò  !
new
òò" %
ProfilingScope
òò& 4
(
òò4 5
null
òò5 9
,
òò9 :
	Profiling
òò; D
.
òòD E
Pipeline
òòE M
.
òòM N)
initializeStackedCameraData
òòN i
)
òòi j
;
òòj k
var
öö 
settings
öö 
=
öö 
asset
öö  
;
öö  !

cameraData
õõ 
.
õõ 
targetTexture
õõ $
=
õõ% &

baseCamera
õõ' 1
.
õõ1 2
targetTexture
õõ2 ?
;
õõ? @

cameraData
úú 
.
úú 

cameraType
úú !
=
úú" #

baseCamera
úú$ .
.
úú. /

cameraType
úú/ 9
;
úú9 :
bool
ùù 
isSceneViewCamera
ùù "
=
ùù# $

cameraData
ùù% /
.
ùù/ 0
isSceneViewCamera
ùù0 A
;
ùùA B
if
¢¢ 
(
¢¢ 
isSceneViewCamera
¢¢ !
)
¢¢! "
{
££ 

cameraData
§§ 
.
§§ 
volumeLayerMask
§§ *
=
§§+ ,
$num
§§- .
;
§§. /

cameraData
•• 
.
•• 
volumeTrigger
•• (
=
••) *
null
••+ /
;
••/ 0

cameraData
¶¶ 
.
¶¶ 
isStopNaNEnabled
¶¶ +
=
¶¶, -
false
¶¶. 3
;
¶¶3 4

cameraData
ßß 
.
ßß  
isDitheringEnabled
ßß -
=
ßß. /
false
ßß0 5
;
ßß5 6

cameraData
®® 
.
®® 
antialiasing
®® '
=
®®( )
AntialiasingMode
®®* :
.
®®: ;
None
®®; ?
;
®®? @

cameraData
©© 
.
©© !
antialiasingQuality
©© .
=
©©/ 0!
AntialiasingQuality
©©1 D
.
©©D E
High
©©E I
;
©©I J

cameraData
´´ 
.
´´ 
xrRendering
´´ &
=
´´' (
false
´´) .
;
´´. /
}
≠≠ 
else
ÆÆ 
if
ÆÆ 
(
ÆÆ &
baseAdditionalCameraData
ÆÆ -
!=
ÆÆ. 0
null
ÆÆ1 5
)
ÆÆ5 6
{
ØØ 

cameraData
∞∞ 
.
∞∞ 
volumeLayerMask
∞∞ *
=
∞∞+ ,&
baseAdditionalCameraData
∞∞- E
.
∞∞E F
volumeLayerMask
∞∞F U
;
∞∞U V

cameraData
±± 
.
±± 
volumeTrigger
±± (
=
±±) *&
baseAdditionalCameraData
±±+ C
.
±±C D
volumeTrigger
±±D Q
==
±±R T
null
±±U Y
?
±±Z [

baseCamera
±±\ f
.
±±f g
	transform
±±g p
:
±±q r'
baseAdditionalCameraData±±s ã
.±±ã å
volumeTrigger±±å ô
;±±ô ö

cameraData
≤≤ 
.
≤≤ 
isStopNaNEnabled
≤≤ +
=
≤≤, -&
baseAdditionalCameraData
≤≤. F
.
≤≤F G
stopNaN
≤≤G N
&&
≤≤O Q

SystemInfo
≤≤R \
.
≤≤\ ]!
graphicsShaderLevel
≤≤] p
>=
≤≤q s
$num
≤≤t v
;
≤≤v w

cameraData
≥≥ 
.
≥≥  
isDitheringEnabled
≥≥ -
=
≥≥. /&
baseAdditionalCameraData
≥≥0 H
.
≥≥H I
	dithering
≥≥I R
;
≥≥R S

cameraData
¥¥ 
.
¥¥ 
antialiasing
¥¥ '
=
¥¥( )&
baseAdditionalCameraData
¥¥* B
.
¥¥B C
antialiasing
¥¥C O
;
¥¥O P

cameraData
µµ 
.
µµ !
antialiasingQuality
µµ .
=
µµ/ 0&
baseAdditionalCameraData
µµ1 I
.
µµI J!
antialiasingQuality
µµJ ]
;
µµ] ^

cameraData
∑∑ 
.
∑∑ 
xrRendering
∑∑ &
=
∑∑' (&
baseAdditionalCameraData
∑∑) A
.
∑∑A B
allowXRRendering
∑∑B R
&&
∑∑S U

m_XRSystem
∑∑V `
.
∑∑` a
RefreshXrSdk
∑∑a m
(
∑∑m n
)
∑∑n o
;
∑∑o p
}
ππ 
else
∫∫ 
{
ªª 

cameraData
ºº 
.
ºº 
volumeLayerMask
ºº *
=
ºº+ ,
$num
ºº- .
;
ºº. /

cameraData
ΩΩ 
.
ΩΩ 
volumeTrigger
ΩΩ (
=
ΩΩ) *
null
ΩΩ+ /
;
ΩΩ/ 0

cameraData
ææ 
.
ææ 
isStopNaNEnabled
ææ +
=
ææ, -
false
ææ. 3
;
ææ3 4

cameraData
øø 
.
øø  
isDitheringEnabled
øø -
=
øø. /
false
øø0 5
;
øø5 6

cameraData
¿¿ 
.
¿¿ 
antialiasing
¿¿ '
=
¿¿( )
AntialiasingMode
¿¿* :
.
¿¿: ;
None
¿¿; ?
;
¿¿? @

cameraData
¡¡ 
.
¡¡ !
antialiasingQuality
¡¡ .
=
¡¡/ 0!
AntialiasingQuality
¡¡1 D
.
¡¡D E
High
¡¡E I
;
¡¡I J

cameraData
√√ 
.
√√ 
xrRendering
√√ &
=
√√' (

m_XRSystem
√√) 3
.
√√3 4
RefreshXrSdk
√√4 @
(
√√@ A
)
√√A B
;
√√B C
}
≈≈ 
var
ÀÀ 
renderer
ÀÀ 
=
ÀÀ &
baseAdditionalCameraData
ÀÀ 3
?
ÀÀ3 4
.
ÀÀ4 5 
scriptableRenderer
ÀÀ5 G
;
ÀÀG H
bool
ÃÃ "
rendererSupportsMSAA
ÃÃ %
=
ÃÃ& '
renderer
ÃÃ( 0
!=
ÃÃ1 3
null
ÃÃ4 8
&&
ÃÃ9 ;
renderer
ÃÃ< D
.
ÃÃD E(
supportedRenderingFeatures
ÃÃE _
.
ÃÃ_ `
msaa
ÃÃ` d
;
ÃÃd e
int
ŒŒ 
msaaSamples
ŒŒ 
=
ŒŒ 
$num
ŒŒ 
;
ŒŒ  
if
œœ 
(
œœ 

baseCamera
œœ 
.
œœ 
	allowMSAA
œœ $
&&
œœ% '
settings
œœ( 0
.
œœ0 1
msaaSampleCount
œœ1 @
>
œœA B
$num
œœC D
&&
œœE G"
rendererSupportsMSAA
œœH \
)
œœ\ ]
msaaSamples
–– 
=
–– 
(
–– 

baseCamera
–– )
.
––) *
targetTexture
––* 7
!=
––8 :
null
––; ?
)
––? @
?
––A B

baseCamera
––C M
.
––M N
targetTexture
––N [
.
––[ \
antiAliasing
––\ h
:
––i j
settings
––k s
.
––s t
msaaSampleCount––t É
;––É Ñ
if
‘‘ 
(
‘‘ 

cameraData
‘‘ 
.
‘‘ 
xrRendering
‘‘ &
)
‘‘& '
msaaSamples
’’ 
=
’’ 
XRSystem
’’ &
.
’’& '
GetMSAALevel
’’' 3
(
’’3 4
)
’’4 5
;
’’5 6

cameraData
ÿÿ 
.
ÿÿ 
isHdrEnabled
ÿÿ #
=
ÿÿ$ %

baseCamera
ÿÿ& 0
.
ÿÿ0 1
allowHDR
ÿÿ1 9
&&
ÿÿ: <
settings
ÿÿ= E
.
ÿÿE F
supportsHDR
ÿÿF Q
;
ÿÿQ R
Rect
⁄⁄ 

cameraRect
⁄⁄ 
=
⁄⁄ 

baseCamera
⁄⁄ (
.
⁄⁄( )
rect
⁄⁄) -
;
⁄⁄- .

cameraData
€€ 
.
€€ 
	pixelRect
€€  
=
€€! "

baseCamera
€€# -
.
€€- .
	pixelRect
€€. 7
;
€€7 8

cameraData
‹‹ 
.
‹‹ 

pixelWidth
‹‹ !
=
‹‹" #

baseCamera
‹‹$ .
.
‹‹. /

pixelWidth
‹‹/ 9
;
‹‹9 :

cameraData
›› 
.
›› 
pixelHeight
›› "
=
››# $

baseCamera
››% /
.
››/ 0
pixelHeight
››0 ;
;
››; <

cameraData
ﬁﬁ 
.
ﬁﬁ 
aspectRatio
ﬁﬁ "
=
ﬁﬁ# $
(
ﬁﬁ% &
float
ﬁﬁ& +
)
ﬁﬁ+ ,

cameraData
ﬁﬁ, 6
.
ﬁﬁ6 7

pixelWidth
ﬁﬁ7 A
/
ﬁﬁB C
(
ﬁﬁD E
float
ﬁﬁE J
)
ﬁﬁJ K

cameraData
ﬁﬁK U
.
ﬁﬁU V
pixelHeight
ﬁﬁV a
;
ﬁﬁa b

cameraData
ﬂﬂ 
.
ﬂﬂ 
isDefaultViewport
ﬂﬂ (
=
ﬂﬂ) *
(
ﬂﬂ+ ,
!
ﬂﬂ, -
(
ﬂﬂ- .
Math
ﬂﬂ. 2
.
ﬂﬂ2 3
Abs
ﬂﬂ3 6
(
ﬂﬂ6 7

cameraRect
ﬂﬂ7 A
.
ﬂﬂA B
x
ﬂﬂB C
)
ﬂﬂC D
>
ﬂﬂE F
$num
ﬂﬂG K
||
ﬂﬂL N
Math
ﬂﬂO S
.
ﬂﬂS T
Abs
ﬂﬂT W
(
ﬂﬂW X

cameraRect
ﬂﬂX b
.
ﬂﬂb c
y
ﬂﬂc d
)
ﬂﬂd e
>
ﬂﬂf g
$num
ﬂﬂh l
||
ﬂﬂm o
Math
‡‡ 
.
‡‡ 
Abs
‡‡ 
(
‡‡ 

cameraRect
‡‡ #
.
‡‡# $
width
‡‡$ )
)
‡‡) *
<
‡‡+ ,
$num
‡‡- 1
||
‡‡2 4
Math
‡‡5 9
.
‡‡9 :
Abs
‡‡: =
(
‡‡= >

cameraRect
‡‡> H
.
‡‡H I
height
‡‡I O
)
‡‡O P
<
‡‡Q R
$num
‡‡S W
)
‡‡W X
)
‡‡X Y
;
‡‡Y Z
const
‰‰ 
float
‰‰ #
kRenderScaleThreshold
‰‰ -
=
‰‰. /
$num
‰‰0 5
;
‰‰5 6

cameraData
ÂÂ 
.
ÂÂ 
renderScale
ÂÂ "
=
ÂÂ# $
(
ÂÂ% &
Mathf
ÂÂ& +
.
ÂÂ+ ,
Abs
ÂÂ, /
(
ÂÂ/ 0
$num
ÂÂ0 4
-
ÂÂ5 6
settings
ÂÂ7 ?
.
ÂÂ? @
renderScale
ÂÂ@ K
)
ÂÂK L
<
ÂÂM N#
kRenderScaleThreshold
ÂÂO d
)
ÂÂd e
?
ÂÂf g
$num
ÂÂh l
:
ÂÂm n
settings
ÂÂo w
.
ÂÂw x
renderScaleÂÂx É
;ÂÂÉ Ñ

cameraData
ËË 
.
ËË 
xr
ËË 
=
ËË 

m_XRSystem
ËË &
.
ËË& '
	emptyPass
ËË' 0
;
ËË0 1
XRSystem
ÈÈ 
.
ÈÈ 
UpdateRenderScale
ÈÈ &
(
ÈÈ& '

cameraData
ÈÈ' 1
.
ÈÈ1 2
renderScale
ÈÈ2 =
)
ÈÈ= >
;
ÈÈ> ?
var
ÓÓ 
commonOpaqueFlags
ÓÓ !
=
ÓÓ" #
SortingCriteria
ÓÓ$ 3
.
ÓÓ3 4
CommonOpaque
ÓÓ4 @
;
ÓÓ@ A
var
ÔÔ &
noFrontToBackOpaqueFlags
ÔÔ (
=
ÔÔ) *
SortingCriteria
ÔÔ+ :
.
ÔÔ: ;
SortingLayer
ÔÔ; G
|
ÔÔH I
SortingCriteria
ÔÔJ Y
.
ÔÔY Z
RenderQueue
ÔÔZ e
|
ÔÔf g
SortingCriteria
ÔÔh w
.
ÔÔw x#
OptimizeStateChangesÔÔx å
|ÔÔç é
SortingCriteriaÔÔè û
.ÔÔû ü
CanvasOrderÔÔü ™
;ÔÔ™ ´
bool
 
	hasHSRGPU
 
=
 

SystemInfo
 '
.
' (*
hasHiddenSurfaceRemovalOnGPU
( D
;
D E
bool
ÒÒ '
canSkipFrontToBackSorting
ÒÒ *
=
ÒÒ+ ,
(
ÒÒ- .

baseCamera
ÒÒ. 8
.
ÒÒ8 9
opaqueSortMode
ÒÒ9 G
==
ÒÒH J
OpaqueSortMode
ÒÒK Y
.
ÒÒY Z
Default
ÒÒZ a
&&
ÒÒb d
	hasHSRGPU
ÒÒe n
)
ÒÒn o
||
ÒÒp r

baseCamera
ÒÒs }
.
ÒÒ} ~
opaqueSortModeÒÒ~ å
==ÒÒç è
OpaqueSortModeÒÒê û
.ÒÒû ü
NoDistanceSortÒÒü ≠
;ÒÒ≠ Æ

cameraData
ÛÛ 
.
ÛÛ $
defaultOpaqueSortFlags
ÛÛ -
=
ÛÛ. /'
canSkipFrontToBackSorting
ÛÛ0 I
?
ÛÛJ K&
noFrontToBackOpaqueFlags
ÛÛL d
:
ÛÛe f
commonOpaqueFlags
ÛÛg x
;
ÛÛx y

cameraData
ÙÙ 
.
ÙÙ 
captureActions
ÙÙ %
=
ÙÙ& '!
CameraCaptureBridge
ÙÙ( ;
.
ÙÙ; <
GetCaptureActions
ÙÙ< M
(
ÙÙM N

baseCamera
ÙÙN X
)
ÙÙX Y
;
ÙÙY Z
bool
ˆˆ 
needsAlphaChannel
ˆˆ "
=
ˆˆ# $
Graphics
ˆˆ% -
.
ˆˆ- .&
preserveFramebufferAlpha
ˆˆ. F
;
ˆˆF G

cameraData
˜˜ 
.
˜˜ $
cameraTargetDescriptor
˜˜ -
=
˜˜. /+
CreateRenderTextureDescriptor
˜˜0 M
(
˜˜M N

baseCamera
˜˜N X
,
˜˜X Y

cameraData
˜˜Z d
.
˜˜d e
renderScale
˜˜e p
,
˜˜p q

cameraData
¯¯ 
.
¯¯ 
isHdrEnabled
¯¯ '
,
¯¯' (
msaaSamples
¯¯) 4
,
¯¯4 5
needsAlphaChannel
¯¯6 G
)
¯¯G H
;
¯¯H I
}
˘˘ 	
static
ÇÇ 
void
ÇÇ ,
InitializeAdditionalCameraData
ÇÇ 2
(
ÇÇ2 3
Camera
ÇÇ3 9
camera
ÇÇ: @
,
ÇÇ@ A+
UniversalAdditionalCameraData
ÇÇB _"
additionalCameraData
ÇÇ` t
,
ÇÇt u
bool
ÇÇv z!
resolveFinalTargetÇÇ{ ç
,ÇÇç é
refÇÇè í

CameraDataÇÇì ù

cameraDataÇÇû ®
)ÇÇ® ©
{
ÉÉ 	
using
ÑÑ 
var
ÑÑ 
	profScope
ÑÑ 
=
ÑÑ  !
new
ÑÑ" %
ProfilingScope
ÑÑ& 4
(
ÑÑ4 5
null
ÑÑ5 9
,
ÑÑ9 :
	Profiling
ÑÑ; D
.
ÑÑD E
Pipeline
ÑÑE M
.
ÑÑM N,
initializeAdditionalCameraData
ÑÑN l
)
ÑÑl m
;
ÑÑm n
var
ÜÜ 
settings
ÜÜ 
=
ÜÜ 
asset
ÜÜ  
;
ÜÜ  !

cameraData
áá 
.
áá 
camera
áá 
=
áá 
camera
áá  &
;
áá& '
bool
ââ 
anyShadowsEnabled
ââ "
=
ââ# $
settings
ââ% -
.
ââ- .&
supportsMainLightShadows
ââ. F
||
ââG I
settings
ââJ R
.
ââR S,
supportsAdditionalLightShadows
ââS q
;
ââq r

cameraData
ää 
.
ää 
maxShadowDistance
ää (
=
ää) *
Mathf
ää+ 0
.
ää0 1
Min
ää1 4
(
ää4 5
settings
ää5 =
.
ää= >
shadowDistance
ää> L
,
ääL M
camera
ääN T
.
ääT U
farClipPlane
ääU a
)
ääa b
;
ääb c

cameraData
ãã 
.
ãã 
maxShadowDistance
ãã (
=
ãã) *
(
ãã+ ,
anyShadowsEnabled
ãã, =
&&
ãã> @

cameraData
ããA K
.
ããK L
maxShadowDistance
ããL ]
>=
ãã^ `
camera
ããa g
.
ããg h
nearClipPlane
ããh u
)
ããu v
?
ããw x

cameraDataããy É
.ããÉ Ñ!
maxShadowDistanceããÑ ï
:ããñ ó
$numããò ú
;ããú ù
bool
çç 
isSceneViewCamera
çç "
=
çç# $

cameraData
çç% /
.
çç/ 0
isSceneViewCamera
çç0 A
;
ççA B
if
éé 
(
éé 
isSceneViewCamera
éé !
)
éé! "
{
èè 

cameraData
êê 
.
êê 

renderType
êê %
=
êê& '
CameraRenderType
êê( 8
.
êê8 9
Base
êê9 =
;
êê= >

cameraData
ëë 
.
ëë 

clearDepth
ëë %
=
ëë& '
true
ëë( ,
;
ëë, -

cameraData
íí 
.
íí  
postProcessEnabled
íí -
=
íí. /
	CoreUtils
íí0 9
.
íí9 :%
ArePostProcessesEnabled
íí: Q
(
ííQ R
camera
ííR X
)
ííX Y
;
ííY Z

cameraData
ìì 
.
ìì "
requiresDepthTexture
ìì /
=
ìì0 1
settings
ìì2 :
.
ìì: ;(
supportsCameraDepthTexture
ìì; U
;
ììU V

cameraData
îî 
.
îî #
requiresOpaqueTexture
îî 0
=
îî1 2
settings
îî3 ;
.
îî; <)
supportsCameraOpaqueTexture
îî< W
;
îîW X

cameraData
ïï 
.
ïï 
renderer
ïï #
=
ïï$ %
asset
ïï& +
.
ïï+ , 
scriptableRenderer
ïï, >
;
ïï> ?
}
ññ 
else
óó 
if
óó 
(
óó "
additionalCameraData
óó )
!=
óó* ,
null
óó- 1
)
óó1 2
{
òò 

cameraData
ôô 
.
ôô 

renderType
ôô %
=
ôô& '"
additionalCameraData
ôô( <
.
ôô< =

renderType
ôô= G
;
ôôG H

cameraData
öö 
.
öö 

clearDepth
öö %
=
öö& '
(
öö( )"
additionalCameraData
öö) =
.
öö= >

renderType
öö> H
!=
ööI K
CameraRenderType
ööL \
.
öö\ ]
Base
öö] a
)
ööa b
?
ööc d"
additionalCameraData
ööe y
.
ööy z

clearDepthööz Ñ
:ööÖ Ü
trueööá ã
;ööã å

cameraData
õõ 
.
õõ  
postProcessEnabled
õõ -
=
õõ. /"
additionalCameraData
õõ0 D
.
õõD E"
renderPostProcessing
õõE Y
;
õõY Z

cameraData
úú 
.
úú 
maxShadowDistance
úú ,
=
úú- .
(
úú/ 0"
additionalCameraData
úú0 D
.
úúD E
renderShadows
úúE R
)
úúR S
?
úúT U

cameraData
úúV `
.
úú` a
maxShadowDistance
úúa r
:
úús t
$num
úúu y
;
úúy z

cameraData
ùù 
.
ùù "
requiresDepthTexture
ùù /
=
ùù0 1"
additionalCameraData
ùù2 F
.
ùùF G"
requiresDepthTexture
ùùG [
;
ùù[ \

cameraData
ûû 
.
ûû #
requiresOpaqueTexture
ûû 0
=
ûû1 2"
additionalCameraData
ûû3 G
.
ûûG H"
requiresColorTexture
ûûH \
;
ûû\ ]

cameraData
üü 
.
üü 
renderer
üü #
=
üü$ %"
additionalCameraData
üü& :
.
üü: ; 
scriptableRenderer
üü; M
;
üüM N
}
†† 
else
°° 
{
¢¢ 

cameraData
££ 
.
££ 

renderType
££ %
=
££& '
CameraRenderType
££( 8
.
££8 9
Base
££9 =
;
££= >

cameraData
§§ 
.
§§ 

clearDepth
§§ %
=
§§& '
true
§§( ,
;
§§, -

cameraData
•• 
.
••  
postProcessEnabled
•• -
=
••. /
false
••0 5
;
••5 6

cameraData
¶¶ 
.
¶¶ "
requiresDepthTexture
¶¶ /
=
¶¶0 1
settings
¶¶2 :
.
¶¶: ;(
supportsCameraDepthTexture
¶¶; U
;
¶¶U V

cameraData
ßß 
.
ßß #
requiresOpaqueTexture
ßß 0
=
ßß1 2
settings
ßß3 ;
.
ßß; <)
supportsCameraOpaqueTexture
ßß< W
;
ßßW X

cameraData
®® 
.
®® 
renderer
®® #
=
®®$ %
asset
®®& +
.
®®+ , 
scriptableRenderer
®®, >
;
®®> ?
}
©© 

cameraData
¨¨ 
.
¨¨  
postProcessEnabled
¨¨ )
&=
¨¨* ,

SystemInfo
¨¨- 7
.
¨¨7 8 
graphicsDeviceType
¨¨8 J
!=
¨¨K M 
GraphicsDeviceType
¨¨N `
.
¨¨` a
	OpenGLES2
¨¨a j
;
¨¨j k

cameraData
ÆÆ 
.
ÆÆ "
requiresDepthTexture
ÆÆ +
|=
ÆÆ, .
isSceneViewCamera
ÆÆ/ @
||
ÆÆA C&
CheckPostProcessForDepth
ÆÆD \
(
ÆÆ\ ]

cameraData
ÆÆ] g
)
ÆÆg h
;
ÆÆh i

cameraData
ØØ 
.
ØØ  
resolveFinalTarget
ØØ )
=
ØØ* + 
resolveFinalTarget
ØØ, >
;
ØØ> ?
bool
≥≥ 
isOverlayCamera
≥≥  
=
≥≥! "
(
≥≥# $

cameraData
≥≥$ .
.
≥≥. /

renderType
≥≥/ 9
==
≥≥: <
CameraRenderType
≥≥= M
.
≥≥M N
Overlay
≥≥N U
)
≥≥U V
;
≥≥V W
if
¥¥ 
(
¥¥ 
isOverlayCamera
¥¥ 
)
¥¥  
{
µµ 

cameraData
∂∂ 
.
∂∂ "
requiresDepthTexture
∂∂ /
=
∂∂0 1
false
∂∂2 7
;
∂∂7 8

cameraData
∑∑ 
.
∑∑ #
requiresOpaqueTexture
∑∑ 0
=
∑∑1 2
false
∑∑3 8
;
∑∑8 9
}
∏∏ 
	Matrix4x4
∫∫ 
projectionMatrix
∫∫ &
=
∫∫' (
camera
∫∫) /
.
∫∫/ 0
projectionMatrix
∫∫0 @
;
∫∫@ A
if
øø 
(
øø 
isOverlayCamera
øø 
&&
øø  "
!
øø# $
camera
øø$ *
.
øø* +
orthographic
øø+ 7
&&
øø8 :

cameraData
øø; E
.
øøE F
	pixelRect
øøF O
!=
øøP R
camera
øøS Y
.
øøY Z
	pixelRect
øøZ c
)
øøc d
{
¿¿ 
float
¬¬ 
	cotangent
¬¬ 
=
¬¬  !
camera
¬¬" (
.
¬¬( )
projectionMatrix
¬¬) 9
.
¬¬9 :
m00
¬¬: =
*
¬¬> ?
camera
¬¬@ F
.
¬¬F G
aspect
¬¬G M
;
¬¬M N
float
≈≈ 
newCotangent
≈≈ "
=
≈≈# $
	cotangent
≈≈% .
/
≈≈/ 0

cameraData
≈≈1 ;
.
≈≈; <
aspectRatio
≈≈< G
;
≈≈G H
projectionMatrix
∆∆  
.
∆∆  !
m00
∆∆! $
=
∆∆% &
newCotangent
∆∆' 3
;
∆∆3 4
}
«« 

cameraData
…… 
.
…… (
SetViewAndProjectionMatrix
…… 1
(
……1 2
camera
……2 8
.
……8 9!
worldToCameraMatrix
……9 L
,
……L M
projectionMatrix
……N ^
)
……^ _
;
……_ `
}
   	
static
ÃÃ 
void
ÃÃ %
InitializeRenderingData
ÃÃ +
(
ÃÃ+ ,*
UniversalRenderPipelineAsset
ÃÃ, H
settings
ÃÃI Q
,
ÃÃQ R
ref
ÃÃS V

CameraData
ÃÃW a

cameraData
ÃÃb l
,
ÃÃl m
ref
ÃÃn q
CullingResultsÃÃr Ä
cullResultsÃÃÅ å
,ÃÃå ç
bool
ÕÕ &
anyPostProcessingEnabled
ÕÕ )
,
ÕÕ) *
out
ÕÕ+ .
RenderingData
ÕÕ/ <
renderingData
ÕÕ= J
)
ÕÕJ K
{
ŒŒ 	
using
œœ 
var
œœ 
	profScope
œœ 
=
œœ  !
new
œœ" %
ProfilingScope
œœ& 4
(
œœ4 5
null
œœ5 9
,
œœ9 :
	Profiling
œœ; D
.
œœD E
Pipeline
œœE M
.
œœM N%
initializeRenderingData
œœN e
)
œœe f
;
œœf g
var
—— 
visibleLights
—— 
=
—— 
cullResults
——  +
.
——+ ,
visibleLights
——, 9
;
——9 :
int
”” 
mainLightIndex
”” 
=
””  
GetMainLightIndex
””! 2
(
””2 3
settings
””3 ;
,
””; <
visibleLights
””= J
)
””J K
;
””K L
bool
‘‘ "
mainLightCastShadows
‘‘ %
=
‘‘& '
false
‘‘( -
;
‘‘- .
bool
’’ )
additionalLightsCastShadows
’’ ,
=
’’- .
false
’’/ 4
;
’’4 5
if
◊◊ 
(
◊◊ 

cameraData
◊◊ 
.
◊◊ 
maxShadowDistance
◊◊ ,
>
◊◊- .
$num
◊◊/ 3
)
◊◊3 4
{
ÿÿ "
mainLightCastShadows
ŸŸ $
=
ŸŸ% &
(
ŸŸ' (
mainLightIndex
ŸŸ( 6
!=
ŸŸ7 9
-
ŸŸ: ;
$num
ŸŸ; <
&&
ŸŸ= ?
visibleLights
ŸŸ@ M
[
ŸŸM N
mainLightIndex
ŸŸN \
]
ŸŸ\ ]
.
ŸŸ] ^
light
ŸŸ^ c
!=
ŸŸd f
null
ŸŸg k
&&
ŸŸl n
visibleLights
⁄⁄( 5
[
⁄⁄5 6
mainLightIndex
⁄⁄6 D
]
⁄⁄D E
.
⁄⁄E F
light
⁄⁄F K
.
⁄⁄K L
shadows
⁄⁄L S
!=
⁄⁄T V
LightShadows
⁄⁄W c
.
⁄⁄c d
None
⁄⁄d h
)
⁄⁄h i
;
⁄⁄i j
if
›› 
(
›› 
settings
›› 
.
›› +
additionalLightsRenderingMode
›› :
==
››; = 
LightRenderingMode
››> P
.
››P Q
PerPixel
››Q Y
)
››Y Z
{
ﬁﬁ 
for
ﬂﬂ 
(
ﬂﬂ 
int
ﬂﬂ 
i
ﬂﬂ 
=
ﬂﬂ  
$num
ﬂﬂ! "
;
ﬂﬂ" #
i
ﬂﬂ$ %
<
ﬂﬂ& '
visibleLights
ﬂﬂ( 5
.
ﬂﬂ5 6
Length
ﬂﬂ6 <
;
ﬂﬂ< =
++
ﬂﬂ> @
i
ﬂﬂ@ A
)
ﬂﬂA B
{
‡‡ 
if
·· 
(
·· 
i
·· 
==
··  
mainLightIndex
··! /
)
··/ 0
continue
‚‚ $
;
‚‚$ %
Light
‰‰ 
light
‰‰ #
=
‰‰$ %
visibleLights
‰‰& 3
[
‰‰3 4
i
‰‰4 5
]
‰‰5 6
.
‰‰6 7
light
‰‰7 <
;
‰‰< =
if
ÁÁ 
(
ÁÁ 
visibleLights
ÁÁ )
[
ÁÁ) *
i
ÁÁ* +
]
ÁÁ+ ,
.
ÁÁ, -
	lightType
ÁÁ- 6
==
ÁÁ7 9
	LightType
ÁÁ: C
.
ÁÁC D
Spot
ÁÁD H
&&
ÁÁI K
light
ÁÁL Q
!=
ÁÁR T
null
ÁÁU Y
&&
ÁÁZ \
light
ÁÁ] b
.
ÁÁb c
shadows
ÁÁc j
!=
ÁÁk m
LightShadows
ÁÁn z
.
ÁÁz {
None
ÁÁ{ 
)ÁÁ Ä
{
ËË )
additionalLightsCastShadows
ÈÈ 7
=
ÈÈ8 9
true
ÈÈ: >
;
ÈÈ> ?
break
ÍÍ !
;
ÍÍ! "
}
ÎÎ 
}
ÏÏ 
}
ÌÌ 
}
ÓÓ 
renderingData
 
.
 
cullResults
 %
=
& '
cullResults
( 3
;
3 4
renderingData
ÒÒ 
.
ÒÒ 

cameraData
ÒÒ $
=
ÒÒ% &

cameraData
ÒÒ' 1
;
ÒÒ1 2!
InitializeLightData
ÚÚ 
(
ÚÚ  
settings
ÚÚ  (
,
ÚÚ( )
visibleLights
ÚÚ* 7
,
ÚÚ7 8
mainLightIndex
ÚÚ9 G
,
ÚÚG H
out
ÚÚI L
renderingData
ÚÚM Z
.
ÚÚZ [
	lightData
ÚÚ[ d
)
ÚÚd e
;
ÚÚe f"
InitializeShadowData
ÛÛ  
(
ÛÛ  !
settings
ÛÛ! )
,
ÛÛ) *
visibleLights
ÛÛ+ 8
,
ÛÛ8 9"
mainLightCastShadows
ÛÛ: N
,
ÛÛN O)
additionalLightsCastShadows
ÛÛP k
&&
ÛÛl n
!
ÛÛo p
renderingData
ÛÛp }
.
ÛÛ} ~
	lightDataÛÛ~ á
.ÛÛá à.
shadeAdditionalLightsPerVertexÛÛà ¶
,ÛÛ¶ ß
outÛÛ® ´
renderingDataÛÛ¨ π
.ÛÛπ ∫

shadowDataÛÛ∫ ƒ
)ÛÛƒ ≈
;ÛÛ≈ ∆*
InitializePostProcessingData
ÙÙ (
(
ÙÙ( )
settings
ÙÙ) 1
,
ÙÙ1 2
out
ÙÙ3 6
renderingData
ÙÙ7 D
.
ÙÙD E 
postProcessingData
ÙÙE W
)
ÙÙW X
;
ÙÙX Y
renderingData
ıı 
.
ıı %
supportsDynamicBatching
ıı 1
=
ıı2 3
settings
ıı4 <
.
ıı< =%
supportsDynamicBatching
ıı= T
;
ııT U
renderingData
ˆˆ 
.
ˆˆ 
perObjectData
ˆˆ '
=
ˆˆ( )$
GetPerObjectLightFlags
ˆˆ* @
(
ˆˆ@ A
renderingData
ˆˆA N
.
ˆˆN O
	lightData
ˆˆO X
.
ˆˆX Y#
additionalLightsCount
ˆˆY n
)
ˆˆn o
;
ˆˆo p
renderingData
˜˜ 
.
˜˜ #
postProcessingEnabled
˜˜ /
=
˜˜0 1&
anyPostProcessingEnabled
˜˜2 J
;
˜˜J K
}
¯¯ 	
static
˙˙ 
void
˙˙ "
InitializeShadowData
˙˙ (
(
˙˙( )*
UniversalRenderPipelineAsset
˙˙) E
settings
˙˙F N
,
˙˙N O
NativeArray
˙˙P [
<
˙˙[ \
VisibleLight
˙˙\ h
>
˙˙h i
visibleLights
˙˙j w
,
˙˙w x
bool
˙˙y }#
mainLightCastShadows˙˙~ í
,˙˙í ì
bool˙˙î ò+
additionalLightsCastShadows˙˙ô ¥
,˙˙¥ µ
out˙˙∂ π

ShadowData˙˙∫ ƒ

shadowData˙˙≈ œ
)˙˙œ –
{
˚˚ 	
using
¸¸ 
var
¸¸ 
	profScope
¸¸ 
=
¸¸  !
new
¸¸" %
ProfilingScope
¸¸& 4
(
¸¸4 5
null
¸¸5 9
,
¸¸9 :
	Profiling
¸¸; D
.
¸¸D E
Pipeline
¸¸E M
.
¸¸M N"
initializeShadowData
¸¸N b
)
¸¸b c
;
¸¸c d
m_ShadowBiasData
˛˛ 
.
˛˛ 
Clear
˛˛ "
(
˛˛" #
)
˛˛# $
;
˛˛$ %
for
ÄÄ 
(
ÄÄ 
int
ÄÄ 
i
ÄÄ 
=
ÄÄ 
$num
ÄÄ 
;
ÄÄ 
i
ÄÄ 
<
ÄÄ 
visibleLights
ÄÄ  -
.
ÄÄ- .
Length
ÄÄ. 4
;
ÄÄ4 5
++
ÄÄ6 8
i
ÄÄ8 9
)
ÄÄ9 :
{
ÅÅ 
Light
ÇÇ 
light
ÇÇ 
=
ÇÇ 
visibleLights
ÇÇ +
[
ÇÇ+ ,
i
ÇÇ, -
]
ÇÇ- .
.
ÇÇ. /
light
ÇÇ/ 4
;
ÇÇ4 5*
UniversalAdditionalLightData
ÉÉ ,
data
ÉÉ- 1
=
ÉÉ2 3
null
ÉÉ4 8
;
ÉÉ8 9
if
ÑÑ 
(
ÑÑ 
light
ÑÑ 
!=
ÑÑ 
null
ÑÑ !
)
ÑÑ! "
{
ÖÖ 
light
ÜÜ 
.
ÜÜ 

gameObject
ÜÜ $
.
ÜÜ$ %
TryGetComponent
ÜÜ% 4
(
ÜÜ4 5
out
ÜÜ5 8
data
ÜÜ9 =
)
ÜÜ= >
;
ÜÜ> ?
}
áá 
if
ââ 
(
ââ 
data
ââ 
&&
ââ 
!
ââ 
data
ââ !
.
ââ! "!
usePipelineSettings
ââ" 5
)
ââ5 6
m_ShadowBiasData
ää $
.
ää$ %
Add
ää% (
(
ää( )
new
ää) ,
Vector4
ää- 4
(
ää4 5
light
ää5 :
.
ää: ;

shadowBias
ää; E
,
ääE F
light
ääG L
.
ääL M
shadowNormalBias
ääM ]
,
ää] ^
$num
ää_ c
,
ääc d
$num
ääe i
)
ääi j
)
ääj k
;
ääk l
else
ãã 
m_ShadowBiasData
åå $
.
åå$ %
Add
åå% (
(
åå( )
new
åå) ,
Vector4
åå- 4
(
åå4 5
settings
åå5 =
.
åå= >
shadowDepthBias
åå> M
,
ååM N
settings
ååO W
.
ååW X
shadowNormalBias
ååX h
,
ååh i
$num
ååj n
,
åån o
$num
ååp t
)
ååt u
)
ååu v
;
ååv w
}
çç 

shadowData
èè 
.
èè 
bias
èè 
=
èè 
m_ShadowBiasData
èè .
;
èè. /

shadowData
êê 
.
êê &
supportsMainLightShadows
êê /
=
êê0 1

SystemInfo
êê2 <
.
êê< =
supportsShadows
êê= L
&&
êêM O
settings
êêP X
.
êêX Y&
supportsMainLightShadows
êêY q
&&
êêr t#
mainLightCastShadowsêêu â
;êêâ ä

shadowData
îî 
.
îî .
 requiresScreenSpaceShadowResolve
îî 7
=
îî8 9
false
îî: ?
;
îî? @

shadowData
ññ 
.
ññ *
mainLightShadowCascadesCount
ññ 3
=
ññ4 5
settings
ññ6 >
.
ññ> ? 
shadowCascadeCount
ññ? Q
;
ññQ R

shadowData
óó 
.
óó %
mainLightShadowmapWidth
óó .
=
óó/ 0
settings
óó1 9
.
óó9 :*
mainLightShadowmapResolution
óó: V
;
óóV W

shadowData
òò 
.
òò &
mainLightShadowmapHeight
òò /
=
òò0 1
settings
òò2 :
.
òò: ;*
mainLightShadowmapResolution
òò; W
;
òòW X
switch
öö 
(
öö 

shadowData
öö 
.
öö *
mainLightShadowCascadesCount
öö ;
)
öö; <
{
õõ 
case
úú 
$num
úú 
:
úú 

shadowData
ùù 
.
ùù *
mainLightShadowCascadesSplit
ùù ;
=
ùù< =
new
ùù> A
Vector3
ùùB I
(
ùùI J
$num
ùùJ N
,
ùùN O
$num
ùùP T
,
ùùT U
$num
ùùV Z
)
ùùZ [
;
ùù[ \
break
ûû 
;
ûû 
case
†† 
$num
†† 
:
†† 

shadowData
°° 
.
°° *
mainLightShadowCascadesSplit
°° ;
=
°°< =
new
°°> A
Vector3
°°B I
(
°°I J
settings
°°J R
.
°°R S
cascade2Split
°°S `
,
°°` a
$num
°°b f
,
°°f g
$num
°°h l
)
°°l m
;
°°m n
break
¢¢ 
;
¢¢ 
case
§§ 
$num
§§ 
:
§§ 

shadowData
•• 
.
•• *
mainLightShadowCascadesSplit
•• ;
=
••< =
new
••> A
Vector3
••B I
(
••I J
settings
••J R
.
••R S
cascade3Split
••S `
.
••` a
x
••a b
,
••b c
settings
••d l
.
••l m
cascade3Split
••m z
.
••z {
y
••{ |
,
••| }
$num••~ Ç
)••Ç É
;••É Ñ
break
¶¶ 
;
¶¶ 
default
®® 
:
®® 

shadowData
©© 
.
©© *
mainLightShadowCascadesSplit
©© ;
=
©©< =
settings
©©> F
.
©©F G
cascade4Split
©©G T
;
©©T U
break
™™ 
;
™™ 
}
´´ 

shadowData
≠≠ 
.
≠≠ ,
supportsAdditionalLightShadows
≠≠ 5
=
≠≠6 7

SystemInfo
≠≠8 B
.
≠≠B C
supportsShadows
≠≠C R
&&
≠≠S U
settings
≠≠V ^
.
≠≠^ _,
supportsAdditionalLightShadows
≠≠_ }
&&≠≠~ Ä+
additionalLightsCastShadows≠≠Å ú
;≠≠ú ù

shadowData
ÆÆ 
.
ÆÆ ,
additionalLightsShadowmapWidth
ÆÆ 5
=
ÆÆ6 7

shadowData
ÆÆ8 B
.
ÆÆB C-
additionalLightsShadowmapHeight
ÆÆC b
=
ÆÆc d
settings
ÆÆe m
.
ÆÆm n2
#additionalLightsShadowmapResolutionÆÆn ë
;ÆÆë í

shadowData
ØØ 
.
ØØ !
supportsSoftShadows
ØØ *
=
ØØ+ ,
settings
ØØ- 5
.
ØØ5 6!
supportsSoftShadows
ØØ6 I
&&
ØØJ L
(
ØØM N

shadowData
ØØN X
.
ØØX Y&
supportsMainLightShadows
ØØY q
||
ØØr t

shadowData
ØØu 
.ØØ Ä.
supportsAdditionalLightShadowsØØÄ û
)ØØû ü
;ØØü †

shadowData
∞∞ 
.
∞∞ &
shadowmapDepthBufferBits
∞∞ /
=
∞∞0 1
$num
∞∞2 4
;
∞∞4 5
}
±± 	
static
≥≥ 
void
≥≥ *
InitializePostProcessingData
≥≥ 0
(
≥≥0 1*
UniversalRenderPipelineAsset
≥≥1 M
settings
≥≥N V
,
≥≥V W
out
≥≥X [ 
PostProcessingData
≥≥\ n!
postProcessingData≥≥o Å
)≥≥Å Ç
{
¥¥ 	 
postProcessingData
µµ 
.
µµ 
gradingMode
µµ *
=
µµ+ ,
settings
µµ- 5
.
µµ5 6
supportsHDR
µµ6 A
?
∂∂ 
settings
∂∂ 
.
∂∂ 
colorGradingMode
∂∂ +
:
∑∑ 
ColorGradingMode
∑∑ "
.
∑∑" #
LowDynamicRange
∑∑# 2
;
∑∑2 3 
postProcessingData
ππ 
.
ππ 
lutSize
ππ &
=
ππ' (
settings
ππ) 1
.
ππ1 2!
colorGradingLutSize
ππ2 E
;
ππE F
}
∫∫ 	
static
ºº 
void
ºº !
InitializeLightData
ºº '
(
ºº' (*
UniversalRenderPipelineAsset
ºº( D
settings
ººE M
,
ººM N
NativeArray
ººO Z
<
ººZ [
VisibleLight
ºº[ g
>
ººg h
visibleLights
ººi v
,
ººv w
int
ººx {
mainLightIndexºº| ä
,ººä ã
outººå è
	LightDataººê ô
	lightDataººö £
)ºº£ §
{
ΩΩ 	
using
ææ 
var
ææ 
	profScope
ææ 
=
ææ  !
new
ææ" %
ProfilingScope
ææ& 4
(
ææ4 5
null
ææ5 9
,
ææ9 :
	Profiling
ææ; D
.
ææD E
Pipeline
ææE M
.
ææM N!
initializeLightData
ææN a
)
ææa b
;
ææb c
int
¿¿ *
maxPerObjectAdditionalLights
¿¿ ,
=
¿¿- .%
UniversalRenderPipeline
¿¿/ F
.
¿¿F G 
maxPerObjectLights
¿¿G Y
;
¿¿Y Z
int
¡¡ (
maxVisibleAdditionalLights
¡¡ *
=
¡¡+ ,%
UniversalRenderPipeline
¡¡- D
.
¡¡D E(
maxVisibleAdditionalLights
¡¡E _
;
¡¡_ `
	lightData
√√ 
.
√√ 
mainLightIndex
√√ $
=
√√% &
mainLightIndex
√√' 5
;
√√5 6
if
≈≈ 
(
≈≈ 
settings
≈≈ 
.
≈≈ +
additionalLightsRenderingMode
≈≈ 6
!=
≈≈7 9 
LightRenderingMode
≈≈: L
.
≈≈L M
Disabled
≈≈M U
)
≈≈U V
{
∆∆ 
	lightData
«« 
.
«« #
additionalLightsCount
«« /
=
««0 1
Math
»» 
.
»» 
Min
»» 
(
»» 
(
»» 
mainLightIndex
»» ,
!=
»»- /
-
»»0 1
$num
»»1 2
)
»»2 3
?
»»4 5
visibleLights
»»6 C
.
»»C D
Length
»»D J
-
»»K L
$num
»»M N
:
»»O P
visibleLights
»»Q ^
.
»»^ _
Length
»»_ e
,
»»e f(
maxVisibleAdditionalLights
…… 2
)
……2 3
;
……3 4
	lightData
   
.
   /
!maxPerObjectAdditionalLightsCount
   ;
=
  < =
Math
  > B
.
  B C
Min
  C F
(
  F G
settings
  G O
.
  O P&
maxAdditionalLightsCount
  P h
,
  h i+
maxPerObjectAdditionalLights  j Ü
)  Ü á
;  á à
}
ÀÀ 
else
ÃÃ 
{
ÕÕ 
	lightData
ŒŒ 
.
ŒŒ #
additionalLightsCount
ŒŒ /
=
ŒŒ0 1
$num
ŒŒ2 3
;
ŒŒ3 4
	lightData
œœ 
.
œœ /
!maxPerObjectAdditionalLightsCount
œœ ;
=
œœ< =
$num
œœ> ?
;
œœ? @
}
–– 
	lightData
““ 
.
““ ,
shadeAdditionalLightsPerVertex
““ 4
=
““5 6
settings
““7 ?
.
““? @+
additionalLightsRenderingMode
““@ ]
==
““^ ` 
LightRenderingMode
““a s
.
““s t
	PerVertex
““t }
;
““} ~
	lightData
”” 
.
”” 
visibleLights
”” #
=
””$ %
visibleLights
””& 3
;
””3 4
	lightData
‘‘ 
.
‘‘ #
supportsMixedLighting
‘‘ +
=
‘‘, -
settings
‘‘. 6
.
‘‘6 7#
supportsMixedLighting
‘‘7 L
;
‘‘L M
}
’’ 	
static
◊◊ 
PerObjectData
◊◊ $
GetPerObjectLightFlags
◊◊ 3
(
◊◊3 4
int
◊◊4 7#
additionalLightsCount
◊◊8 M
)
◊◊M N
{
ÿÿ 	
using
ŸŸ 
var
ŸŸ 
	profScope
ŸŸ 
=
ŸŸ  !
new
ŸŸ" %
ProfilingScope
ŸŸ& 4
(
ŸŸ4 5
null
ŸŸ5 9
,
ŸŸ9 :
	Profiling
ŸŸ; D
.
ŸŸD E
Pipeline
ŸŸE M
.
ŸŸM N$
getPerObjectLightFlags
ŸŸN d
)
ŸŸd e
;
ŸŸe f
var
€€ 
configuration
€€ 
=
€€ 
PerObjectData
€€  -
.
€€- .
ReflectionProbes
€€. >
|
€€? @
PerObjectData
€€A N
.
€€N O
	Lightmaps
€€O X
|
€€Y Z
PerObjectData
€€[ h
.
€€h i

LightProbe
€€i s
|
€€t u
PerObjectData€€v É
.€€É Ñ
	LightData€€Ñ ç
|€€é è
PerObjectData€€ê ù
.€€ù û
OcclusionProbe€€û ¨
|€€≠ Æ
PerObjectData€€Ø º
.€€º Ω

ShadowMask€€Ω «
;€€« »
if
›› 
(
›› #
additionalLightsCount
›› %
>
››& '
$num
››( )
)
››) *
{
ﬁﬁ 
configuration
ﬂﬂ 
|=
ﬂﬂ  
PerObjectData
ﬂﬂ! .
.
ﬂﬂ. /
	LightData
ﬂﬂ/ 8
;
ﬂﬂ8 9
if
‚‚ 
(
‚‚ 
!
‚‚ 
RenderingUtils
‚‚ #
.
‚‚# $!
useStructuredBuffer
‚‚$ 7
)
‚‚7 8
configuration
„„ !
|=
„„" $
PerObjectData
„„% 2
.
„„2 3
LightIndices
„„3 ?
;
„„? @
}
‰‰ 
return
ÊÊ 
configuration
ÊÊ  
;
ÊÊ  !
}
ÁÁ 	
static
ÍÍ 
int
ÍÍ 
GetMainLightIndex
ÍÍ $
(
ÍÍ$ %*
UniversalRenderPipelineAsset
ÍÍ% A
settings
ÍÍB J
,
ÍÍJ K
NativeArray
ÍÍL W
<
ÍÍW X
VisibleLight
ÍÍX d
>
ÍÍd e
visibleLights
ÍÍf s
)
ÍÍs t
{
ÎÎ 	
using
ÏÏ 
var
ÏÏ 
	profScope
ÏÏ 
=
ÏÏ  !
new
ÏÏ" %
ProfilingScope
ÏÏ& 4
(
ÏÏ4 5
null
ÏÏ5 9
,
ÏÏ9 :
	Profiling
ÏÏ; D
.
ÏÏD E
Pipeline
ÏÏE M
.
ÏÏM N
getMainLightIndex
ÏÏN _
)
ÏÏ_ `
;
ÏÏ` a
int
ÓÓ  
totalVisibleLights
ÓÓ "
=
ÓÓ# $
visibleLights
ÓÓ% 2
.
ÓÓ2 3
Length
ÓÓ3 9
;
ÓÓ9 :
if
 
(
  
totalVisibleLights
 "
==
# %
$num
& '
||
( *
settings
+ 3
.
3 4$
mainLightRenderingMode
4 J
!=
K M 
LightRenderingMode
N `
.
` a
PerPixel
a i
)
i j
return
ÒÒ 
-
ÒÒ 
$num
ÒÒ 
;
ÒÒ 
Light
ÛÛ 
sunLight
ÛÛ 
=
ÛÛ 
RenderSettings
ÛÛ +
.
ÛÛ+ ,
sun
ÛÛ, /
;
ÛÛ/ 0
int
ÙÙ ,
brightestDirectionalLightIndex
ÙÙ .
=
ÙÙ/ 0
-
ÙÙ1 2
$num
ÙÙ2 3
;
ÙÙ3 4
float
ıı %
brightestLightIntensity
ıı )
=
ıı* +
$num
ıı, 0
;
ıı0 1
for
ˆˆ 
(
ˆˆ 
int
ˆˆ 
i
ˆˆ 
=
ˆˆ 
$num
ˆˆ 
;
ˆˆ 
i
ˆˆ 
<
ˆˆ  
totalVisibleLights
ˆˆ  2
;
ˆˆ2 3
++
ˆˆ4 6
i
ˆˆ6 7
)
ˆˆ7 8
{
˜˜ 
VisibleLight
¯¯ 
currVisibleLight
¯¯ -
=
¯¯. /
visibleLights
¯¯0 =
[
¯¯= >
i
¯¯> ?
]
¯¯? @
;
¯¯@ A
Light
˘˘ 
	currLight
˘˘ 
=
˘˘  !
currVisibleLight
˘˘" 2
.
˘˘2 3
light
˘˘3 8
;
˘˘8 9
if
˛˛ 
(
˛˛ 
	currLight
˛˛ 
==
˛˛  
null
˛˛! %
)
˛˛% &
break
ˇˇ 
;
ˇˇ 
if
ÅÅ 
(
ÅÅ 
currVisibleLight
ÅÅ $
.
ÅÅ$ %
	lightType
ÅÅ% .
==
ÅÅ/ 1
	LightType
ÅÅ2 ;
.
ÅÅ; <
Directional
ÅÅ< G
)
ÅÅG H
{
ÇÇ 
if
ÑÑ 
(
ÑÑ 
	currLight
ÑÑ !
==
ÑÑ" $
sunLight
ÑÑ% -
)
ÑÑ- .
return
ÖÖ 
i
ÖÖ  
;
ÖÖ  !
if
àà 
(
àà 
	currLight
àà !
.
àà! "
	intensity
àà" +
>
àà, -%
brightestLightIntensity
àà. E
)
ààE F
{
ââ %
brightestLightIntensity
ää /
=
ää0 1
	currLight
ää2 ;
.
ää; <
	intensity
ää< E
;
ääE F,
brightestDirectionalLightIndex
ãã 6
=
ãã7 8
i
ãã9 :
;
ãã: ;
}
åå 
}
çç 
}
éé 
return
êê ,
brightestDirectionalLightIndex
êê 1
;
êê1 2
}
ëë 	
static
ìì 
void
ìì *
SetupPerFrameShaderConstants
ìì 0
(
ìì0 1
)
ìì1 2
{
îî 	
using
ïï 
var
ïï 
	profScope
ïï 
=
ïï  !
new
ïï" %
ProfilingScope
ïï& 4
(
ïï4 5
null
ïï5 9
,
ïï9 :
	Profiling
ïï; D
.
ïïD E
Pipeline
ïïE M
.
ïïM N*
setupPerFrameShaderConstants
ïïN j
)
ïïj k
;
ïïk l"
SphericalHarmonicsL2
òò  
	ambientSH
òò! *
=
òò+ ,
RenderSettings
òò- ;
.
òò; <
ambientProbe
òò< H
;
òòH I
Color
ôô "
linearGlossyEnvColor
ôô &
=
ôô' (
new
ôô) ,
Color
ôô- 2
(
ôô2 3
	ambientSH
ôô3 <
[
ôô< =
$num
ôô= >
,
ôô> ?
$num
ôô@ A
]
ôôA B
,
ôôB C
	ambientSH
ôôD M
[
ôôM N
$num
ôôN O
,
ôôO P
$num
ôôQ R
]
ôôR S
,
ôôS T
	ambientSH
ôôU ^
[
ôô^ _
$num
ôô_ `
,
ôô` a
$num
ôôb c
]
ôôc d
)
ôôd e
*
ôôf g
RenderSettings
ôôh v
.
ôôv w"
reflectionIntensityôôw ä
;ôôä ã
Color
öö 
glossyEnvColor
öö  
=
öö! "
	CoreUtils
öö# ,
.
öö, --
ConvertLinearToActiveColorSpace
öö- L
(
ööL M"
linearGlossyEnvColor
ööM a
)
ööa b
;
ööb c
Shader
õõ 
.
õõ 
SetGlobalVector
õõ "
(
õõ" #
ShaderPropertyId
õõ# 3
.
õõ3 4$
glossyEnvironmentColor
õõ4 J
,
õõJ K
glossyEnvColor
õõL Z
)
õõZ [
;
õõ[ \
Shader
ûû 
.
ûû 
SetGlobalVector
ûû "
(
ûû" #
ShaderPropertyId
ûû# 3
.
ûû3 4
ambientSkyColor
ûû4 C
,
ûûC D
	CoreUtils
ûûE N
.
ûûN O+
ConvertSRGBToActiveColorSpace
ûûO l
(
ûûl m
RenderSettings
ûûm {
.
ûû{ |
ambientSkyColorûû| ã
)ûûã å
)ûûå ç
;ûûç é
Shader
üü 
.
üü 
SetGlobalVector
üü "
(
üü" #
ShaderPropertyId
üü# 3
.
üü3 4!
ambientEquatorColor
üü4 G
,
üüG H
	CoreUtils
üüI R
.
üüR S+
ConvertSRGBToActiveColorSpace
üüS p
(
üüp q
RenderSettings
üüq 
.üü Ä#
ambientEquatorColorüüÄ ì
)üüì î
)üüî ï
;üüï ñ
Shader
†† 
.
†† 
SetGlobalVector
†† "
(
††" #
ShaderPropertyId
††# 3
.
††3 4 
ambientGroundColor
††4 F
,
††F G
	CoreUtils
††H Q
.
††Q R+
ConvertSRGBToActiveColorSpace
††R o
(
††o p
RenderSettings
††p ~
.
††~ !
ambientGroundColor†† ë
)††ë í
)††í ì
;††ì î
Shader
££ 
.
££ 
SetGlobalVector
££ "
(
££" #
ShaderPropertyId
££# 3
.
££3 4$
subtractiveShadowColor
££4 J
,
££J K
	CoreUtils
££L U
.
££U V+
ConvertSRGBToActiveColorSpace
££V s
(
££s t
RenderSettings££t Ç
.££Ç É&
subtractiveShadowColor££É ô
)££ô ö
)££ö õ
;££õ ú
}
§§ 	
}
ÁÁ 
}ËË î9
≤D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Shadows\ShadowCasterGroup2DManager.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
internal 
class &
ShadowCasterGroup2DManager -
{ 
static		 
List		 
<		 
ShadowCasterGroup2D		 '
>		' ( 
s_ShadowCasterGroups		) =
=		> ?
null		@ D
;		D E
public 
static 
List 
< 
ShadowCasterGroup2D .
>. /
shadowCasterGroups0 B
{C D
getE H
{I J
returnK Q 
s_ShadowCasterGroupsR f
;f g
}h i
}j k
public 
static 
void &
AddShadowCasterGroupToList 5
(5 6
ShadowCasterGroup2D6 I
shadowCasterJ V
,V W
ListX \
<\ ]
ShadowCasterGroup2D] p
>p q
listr v
)v w
{ 	
int 
positionToInsert  
=! "
$num# $
;$ %
for 
( 
positionToInsert !
=" #
$num$ %
;% &
positionToInsert' 7
<8 9
list: >
.> ?
Count? D
;D E
positionToInsertF V
++V X
)X Y
{ 
if 
( 
shadowCaster  
.  !
GetShadowGroup! /
(/ 0
)0 1
==2 4
list5 9
[9 :
positionToInsert: J
]J K
.K L
GetShadowGroupL Z
(Z [
)[ \
)\ ]
break 
; 
} 
list 
. 
Insert 
( 
positionToInsert (
,( )
shadowCaster* 6
)6 7
;7 8
} 	
public 
static 
void +
RemoveShadowCasterGroupFromList :
(: ;
ShadowCasterGroup2D; N
shadowCasterO [
,[ \
List] a
<a b
ShadowCasterGroup2Db u
>u v
listw {
){ |
{ 	
list 
. 
Remove 
( 
shadowCaster $
)$ %
;% &
} 	
static #
CompositeShadowCaster2D &,
 FindTopMostCompositeShadowCaster' G
(G H
ShadowCaster2DH V
shadowCasterW c
)c d
{   	#
CompositeShadowCaster2D!! #
retGroup!!$ ,
=!!- .
null!!/ 3
;!!3 4
	Transform## 
transformToCheck## &
=##' (
shadowCaster##) 5
.##5 6
	transform##6 ?
.##? @
parent##@ F
;##F G
while$$ 
($$ 
transformToCheck$$ #
!=$$$ &
null$$' +
)$$+ ,
{%% #
CompositeShadowCaster2D&& '
currentGroup&&( 4
=&&5 6
transformToCheck&&7 G
.&&G H
GetComponent&&H T
<&&T U#
CompositeShadowCaster2D&&U l
>&&l m
(&&m n
)&&n o
;&&o p
if'' 
('' 
currentGroup''  
!=''! #
null''$ (
)''( )
retGroup(( 
=(( 
currentGroup(( +
;((+ ,
transformToCheck**  
=**! "
transformToCheck**# 3
.**3 4
parent**4 :
;**: ;
}++ 
return-- 
retGroup-- 
;-- 
}.. 	
public00 
static00 
bool00 "
AddToShadowCasterGroup00 1
(001 2
ShadowCaster2D002 @
shadowCaster00A M
,00M N
ref00O R
ShadowCasterGroup2D00S f
shadowCasterGroup00g x
)00x y
{11 	
ShadowCasterGroup2D22  
newShadowCasterGroup22  4
=225 6,
 FindTopMostCompositeShadowCaster227 W
(22W X
shadowCaster22X d
)22d e
as22f h
ShadowCasterGroup2D22i |
;22| }
if44 
(44  
newShadowCasterGroup44 $
==44% '
null44( ,
)44, - 
newShadowCasterGroup55 $
=55% &
shadowCaster55' 3
.553 4
GetComponent554 @
<55@ A
ShadowCaster2D55A O
>55O P
(55P Q
)55Q R
;55R S
if77 
(77  
newShadowCasterGroup77 $
!=77% '
null77( ,
&&77- /
shadowCasterGroup770 A
!=77B D 
newShadowCasterGroup77E Y
)77Y Z
{88  
newShadowCasterGroup99 $
.99$ %"
RegisterShadowCaster2D99% ;
(99; <
shadowCaster99< H
)99H I
;99I J
shadowCasterGroup:: !
=::" # 
newShadowCasterGroup::$ 8
;::8 9
return;; 
true;; 
;;; 
}<< 
return>> 
false>> 
;>> 
}?? 	
publicAA 
staticAA 
voidAA '
RemoveFromShadowCasterGroupAA 6
(AA6 7
ShadowCaster2DAA7 E
shadowCasterAAF R
,AAR S
ShadowCasterGroup2DAAT g
shadowCasterGroupAAh y
)AAy z
{BB 	
ifCC 
(CC 
shadowCasterGroupCC !
!=CC" $
nullCC% )
)CC) *
shadowCasterGroupDD !
.DD! "$
UnregisterShadowCaster2DDD" :
(DD: ;
shadowCasterDD; G
)DDG H
;DDH I
}EE 	
publicGG 
staticGG 
voidGG 
AddGroupGG #
(GG# $
ShadowCasterGroup2DGG$ 7
groupGG8 =
)GG= >
{HH 	
ifII 
(II 
groupII 
==II 
nullII 
)II 
returnJJ 
;JJ 
ifLL 
(LL  
s_ShadowCasterGroupsLL $
==LL% '
nullLL( ,
)LL, - 
s_ShadowCasterGroupsMM $
=MM% &
newMM' *
ListMM+ /
<MM/ 0
ShadowCasterGroup2DMM0 C
>MMC D
(MMD E
)MME F
;MMF G&
AddShadowCasterGroupToListOO &
(OO& '
groupOO' ,
,OO, - 
s_ShadowCasterGroupsOO. B
)OOB C
;OOC D
}PP 	
publicQQ 
staticQQ 
voidQQ 
RemoveGroupQQ &
(QQ& '
ShadowCasterGroup2DQQ' :
groupQQ; @
)QQ@ A
{RR 	
ifSS 
(SS 
groupSS 
!=SS 
nullSS 
&&SS   
s_ShadowCasterGroupsSS! 5
!=SS6 8
nullSS9 =
)SS= >+
RemoveShadowCasterGroupFromListTT /
(TT/ 0
groupTT0 5
,TT5 6 
s_ShadowCasterGroupsTT7 K
)TTK L
;TTL M
}UU 	
}VV 
}WW ˘Â
´D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Passes\Render2DLightingPass.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
internal 
class  
Render2DLightingPass '
:( ) 
ScriptableRenderPass* >
,> ?
IRenderPass2D@ M
{		 
private

 
static

 
readonly

 
int

  #!
k_HDREmulationScaleID

$ 9
=

: ;
Shader

< B
.

B C
PropertyToID

C O
(

O P
$str

P d
)

d e
;

e f
private 
static 
readonly 
int  #(
k_InverseHDREmulationScaleID$ @
=A B
ShaderC I
.I J
PropertyToIDJ V
(V W
$strW r
)r s
;s t
private 
static 
readonly 
int  # 
k_UseSceneLightingID$ 8
=9 :
Shader; A
.A B
PropertyToIDB N
(N O
$strO b
)b c
;c d
private 
static 
readonly 
int  #
k_RendererColorID$ 5
=6 7
Shader8 >
.> ?
PropertyToID? K
(K L
$strL \
)\ ]
;] ^
private 
static 
readonly 
int  #"
k_ShapeLightTexture0ID$ :
=; <
Shader= C
.C D
PropertyToIDD P
(P Q
$strQ f
)f g
;g h
private 
static 
readonly 
int  #"
k_ShapeLightTexture1ID$ :
=; <
Shader= C
.C D
PropertyToIDD P
(P Q
$strQ f
)f g
;g h
private 
static 
readonly 
int  #"
k_ShapeLightTexture2ID$ :
=; <
Shader= C
.C D
PropertyToIDD P
(P Q
$strQ f
)f g
;g h
private 
static 
readonly 
int  #"
k_ShapeLightTexture3ID$ :
=; <
Shader= C
.C D
PropertyToIDD P
(P Q
$strQ f
)f g
;g h
private 
static 
readonly 
ShaderTagId  +*
k_CombinedRenderingPassNameOld, J
=K L
newM P
ShaderTagIdQ \
(\ ]
$str] l
)l m
;m n
private 
static 
readonly 
ShaderTagId  +'
k_CombinedRenderingPassName, G
=H I
newJ M
ShaderTagIdN Y
(Y Z
$strZ g
)g h
;h i
private 
static 
readonly 
ShaderTagId  +&
k_NormalsRenderingPassName, F
=G H
newI L
ShaderTagIdM X
(X Y
$strY k
)k l
;l m
private 
static 
readonly 
ShaderTagId  +
k_LegacyPassName, <
== >
new? B
ShaderTagIdC N
(N O
$strO `
)` a
;a b
private 
static 
readonly 
List  $
<$ %
ShaderTagId% 0
>0 1
k_ShaderTags2 >
=? @
newA D
ListE I
<I J
ShaderTagIdJ U
>U V
(V W
)W X
{Y Z
k_LegacyPassName[ k
,k l(
k_CombinedRenderingPassName	m à
,
à â,
k_CombinedRenderingPassNameOld
ä ®
}
© ™
;
™ ´
private 
static 
readonly 
ProfilingSampler  0
m_ProfilingSampler1 C
=D E
newF I
ProfilingSamplerJ Z
(Z [
$str[ o
)o p
;p q
private 
static 
readonly 
ProfilingSampler  0#
m_ProfilingSamplerUnlit1 H
=I J
newK N
ProfilingSamplerO _
(_ `
$str` n
)n o
;o p
private 
readonly 
Renderer2DData '
m_Renderer2DData( 8
;8 9
public  
Render2DLightingPass #
(# $
Renderer2DData$ 2
rendererData3 ?
)? @
{ 	
m_Renderer2DData   
=   
rendererData   +
;  + ,
}!! 	
private## 
void## &
GetTransparencySortingMode## /
(##/ 0
Camera##0 6
camera##7 =
,##= >
ref##? B
SortingSettings##C R
sortingSettings##S b
)##b c
{$$ 	
var%% 
mode%% 
=%% 
camera%% 
.%%  
transparencySortMode%% 2
;%%2 3
if'' 
('' 
mode'' 
==''  
TransparencySortMode'' ,
.'', -
Default''- 4
)''4 5
{(( 
mode)) 
=)) 
m_Renderer2DData)) '
.))' ( 
transparencySortMode))( <
;))< =
if** 
(** 
mode** 
==**  
TransparencySortMode** 0
.**0 1
Default**1 8
)**8 9
mode++ 
=++ 
camera++ !
.++! "
orthographic++" .
?++/ 0 
TransparencySortMode++1 E
.++E F
Orthographic++F R
:++S T 
TransparencySortMode++U i
.++i j
Perspective++j u
;++u v
},, 
if.. 
(.. 
mode.. 
==..  
TransparencySortMode.. ,
..., -
Perspective..- 8
)..8 9
{// 
sortingSettings00 
.00  
distanceMetric00  .
=00/ 0
DistanceMetric001 ?
.00? @
Perspective00@ K
;00K L
}11 
else22 
if22 
(22 
mode22 
==22  
TransparencySortMode22 1
.221 2
Orthographic222 >
)22> ?
{33 
sortingSettings44 
.44  
distanceMetric44  .
=44/ 0
DistanceMetric441 ?
.44? @
Orthographic44@ L
;44L M
}55 
else66 
{77 
sortingSettings88 
.88  
distanceMetric88  .
=88/ 0
DistanceMetric881 ?
.88? @

CustomAxis88@ J
;88J K
sortingSettings99 
.99  

customAxis99  *
=99+ ,
m_Renderer2DData99- =
.99= > 
transparencySortAxis99> R
;99R S
}:: 
};; 	
private== 
bool==  
CompareLightsInLayer== )
(==) *
int==* -
layerIndex1==. 9
,==9 :
int==; >
layerIndex2==? J
,==J K
SortingLayer==L X
[==X Y
]==Y Z
sortingLayers==[ h
)==h i
{>> 	
var?? 
layerId1?? 
=?? 
sortingLayers?? (
[??( )
layerIndex1??) 4
]??4 5
.??5 6
id??6 8
;??8 9
var@@ 
layerId2@@ 
=@@ 
sortingLayers@@ (
[@@( )
layerIndex2@@) 4
]@@4 5
.@@5 6
id@@6 8
;@@8 9
foreachAA 
(AA 
varAA 
lightAA 
inAA !
m_Renderer2DDataAA" 2
.AA2 3
lightCullResultAA3 B
.AAB C
visibleLightsAAC P
)AAP Q
{BB 
ifCC 
(CC 
lightCC 
.CC 

IsLitLayerCC $
(CC$ %
layerId1CC% -
)CC- .
!=CC/ 1
lightCC2 7
.CC7 8

IsLitLayerCC8 B
(CCB C
layerId2CCC K
)CCK L
)CCL M
returnDD 
falseDD  
;DD  !
}EE 
returnFF 
trueFF 
;FF 
}GG 	
privateII 
intII !
FindUpperBoundInBatchII )
(II) *
intII* -
startLayerIndexII. =
,II= >
SortingLayerII? K
[IIK L
]IIL M
sortingLayersIIN [
)II[ \
{JJ 	
forLL 
(LL 
varLL 
iLL 
=LL 
startLayerIndexLL (
+LL( )
$numLL) *
;LL* +
iLL, -
<LL. /
sortingLayersLL0 =
.LL= >
LengthLL> D
;LLD E
iLLF G
++LLG I
)LLI J
{MM 
ifNN 
(NN 
!NN  
CompareLightsInLayerNN (
(NN( )
startLayerIndexNN) 8
,NN8 9
iNN: ;
,NN; <
sortingLayersNN= J
)NNJ K
)NNK L
returnOO 
iOO 
-OO 
$numOO 
;OO 
}PP 
returnQQ 
sortingLayersQQ  
.QQ  !
LengthQQ! '
-QQ' (
$numQQ( )
;QQ) *
}RR 	
publicTT 
overrideTT 
voidTT 
ExecuteTT $
(TT$ %#
ScriptableRenderContextTT% <
contextTT= D
,TTD E
refTTF I
RenderingDataTTJ W
renderingDataTTX e
)TTe f
{UU 	
varVV 
	isLitViewVV 
=VV 
trueVV  
;VV  !
ifYY 
(YY 
renderingDataYY 
.YY 

cameraDataYY (
.YY( )
isSceneViewCameraYY) :
)YY: ;
	isLitViewZZ 
=ZZ 
UnityEditorZZ '
.ZZ' (
	SceneViewZZ( 1
.ZZ1 2#
currentDrawingSceneViewZZ2 I
.ZZI J
sceneLightingZZJ W
;ZZW X
if\\ 
(\\ 
renderingData\\ 
.\\ 

cameraData\\ (
.\\( )
camera\\) /
.\\/ 0

cameraType\\0 :
==\\; =

CameraType\\> H
.\\H I
Preview\\I P
)\\P Q
	isLitView]] 
=]] 
false]] !
;]]! "
var__ 
cachedSortingLayers__ #
=__$ %
Light2DManager__& 4
.__4 5!
GetCachedSortingLayer__5 J
(__J K
)__K L
;__L M
var`` 
camera`` 
=`` 
renderingData`` &
.``& '

cameraData``' 1
.``1 2
camera``2 8
;``8 9
varbb 
filterSettingsbb 
=bb  
newbb! $
FilteringSettingsbb% 6
(bb6 7
)bb7 8
;bb8 9
filterSettingscc 
.cc 
renderQueueRangecc +
=cc, -
RenderQueueRangecc. >
.cc> ?
allcc? B
;ccB C
filterSettingsdd 
.dd 
	layerMaskdd $
=dd% &
-dd' (
$numdd( )
;dd) *
filterSettingsee 
.ee 
renderingLayerMaskee -
=ee. /
$numee0 :
;ee: ;
filterSettingsff 
.ff 
sortingLayerRangeff ,
=ff- .
SortingLayerRangeff/ @
.ff@ A
allffA D
;ffD E
varhh 

isSceneLithh 
=hh 
m_Renderer2DDatahh -
.hh- .
lightCullResulthh. =
.hh= >

IsSceneLithh> H
(hhH I
)hhI J
;hhJ K
ifii 
(ii 

isSceneLitii 
)ii 
{jj 
varkk 
cmdkk 
=kk 
CommandBufferPoolkk +
.kk+ ,
Getkk, /
(kk/ 0
)kk0 1
;kk1 2
cmdll 
.ll 
Clearll 
(ll 
)ll 
;ll 
usingnn 
(nn 
newnn 
ProfilingScopenn )
(nn) *
cmdnn* -
,nn- .
m_ProfilingSamplernn/ A
)nnA B
)nnB C
{oo 
thispp 
.pp (
CreateNormalMapRenderTexturepp 5
(pp5 6
renderingDatapp6 C
,ppC D
cmdppE H
)ppH I
;ppI J
cmdrr 
.rr 
SetGlobalFloatrr &
(rr& '!
k_HDREmulationScaleIDrr' <
,rr< =
m_Renderer2DDatarr> N
.rrN O
hdrEmulationScalerrO `
)rr` a
;rra b
cmdss 
.ss 
SetGlobalFloatss &
(ss& '(
k_InverseHDREmulationScaleIDss' C
,ssC D
$numssE I
/ssJ K
m_Renderer2DDatassL \
.ss\ ]
hdrEmulationScaless] n
)ssn o
;sso p
cmdtt 
.tt 
SetGlobalFloattt &
(tt& ' 
k_UseSceneLightingIDtt' ;
,tt; <
	isLitViewtt= F
?ttG H
$numttI M
:ttN O
$numttP T
)ttT U
;ttU V
cmduu 
.uu 
SetGlobalColoruu &
(uu& '
k_RendererColorIDuu' 8
,uu8 9
Coloruu: ?
.uu? @
whiteuu@ E
)uuE F
;uuF G
thisvv 
.vv &
SetShapeLightShaderGlobalsvv 3
(vv3 4
cmdvv4 7
)vv7 8
;vv8 9
contextxx 
.xx  
ExecuteCommandBufferxx 0
(xx0 1
cmdxx1 4
)xx4 5
;xx5 6
varzz  
combinedDrawSettingszz ,
=zz- .!
CreateDrawingSettingszz/ D
(zzD E
k_ShaderTagszzE Q
,zzQ R
refzzS V
renderingDatazzW d
,zzd e
SortingCriteriazzf u
.zzu v
CommonTransparent	zzv á
)
zzá à
;
zzà â
var{{ 
normalsDrawSettings{{ +
={{, -!
CreateDrawingSettings{{. C
({{C D&
k_NormalsRenderingPassName{{D ^
,{{^ _
ref{{` c
renderingData{{d q
,{{q r
SortingCriteria	{{s Ç
.
{{Ç É
CommonTransparent
{{É î
)
{{î ï
;
{{ï ñ
var}} 
sortSettings}} $
=}}% & 
combinedDrawSettings}}' ;
.}}; <
sortingSettings}}< K
;}}K L&
GetTransparencySortingMode~~ .
(~~. /
camera~~/ 5
,~~5 6
ref~~7 :
sortSettings~~; G
)~~G H
;~~H I 
combinedDrawSettings (
.( )
sortingSettings) 8
=9 :
sortSettings; G
;G H!
normalsDrawSettings
ÄÄ '
.
ÄÄ' (
sortingSettings
ÄÄ( 7
=
ÄÄ8 9
sortSettings
ÄÄ: F
;
ÄÄF G
var
ÇÇ 
blendStylesCount
ÇÇ (
=
ÇÇ) *
m_Renderer2DData
ÇÇ+ ;
.
ÇÇ; <
lightBlendStyles
ÇÇ< L
.
ÇÇL M
Length
ÇÇM S
;
ÇÇS T
for
ÉÉ 
(
ÉÉ 
var
ÉÉ 
i
ÉÉ 
=
ÉÉ  
$num
ÉÉ! "
;
ÉÉ" #
i
ÉÉ$ %
<
ÉÉ& '!
cachedSortingLayers
ÉÉ( ;
.
ÉÉ; <
Length
ÉÉ< B
;
ÉÉB C
)
ÉÉC D
{
ÑÑ 
var
ÖÖ 
layerToRender
ÖÖ )
=
ÖÖ* +!
cachedSortingLayers
ÖÖ, ?
[
ÖÖ? @
i
ÖÖ@ A
]
ÖÖA B
.
ÖÖB C
id
ÖÖC E
;
ÖÖE F
var
ÜÜ 

lightStats
ÜÜ &
=
ÜÜ' (
m_Renderer2DData
ÜÜ) 9
.
ÜÜ9 :
lightCullResult
ÜÜ: I
.
ÜÜI J"
GetLightStatsByLayer
ÜÜJ ^
(
ÜÜ^ _
layerToRender
ÜÜ_ l
)
ÜÜl m
;
ÜÜm n
cmd
àà 
.
àà 
Clear
àà !
(
àà! "
)
àà" #
;
àà# $
for
ââ 
(
ââ 
var
ââ  
blendStyleIndex
ââ! 0
=
ââ1 2
$num
ââ3 4
;
ââ4 5
blendStyleIndex
ââ6 E
<
ââF G
blendStylesCount
ââH X
;
ââX Y
blendStyleIndex
ââZ i
++
ââi k
)
ââk l
{
ää 
var
ãã 
blendStyleMask
ãã  .
=
ãã/ 0
(
ãã1 2
uint
ãã2 6
)
ãã6 7
(
ãã8 9
$num
ãã9 :
<<
ãã; =
blendStyleIndex
ãã> M
)
ããM N
;
ããN O
var
åå 
blendStyleUsed
åå  .
=
åå/ 0
(
åå1 2

lightStats
åå2 <
.
åå< =
blendStylesUsed
åå= L
&
ååM N
blendStyleMask
ååO ]
)
åå] ^
>
åå_ `
$num
ååa b
;
ååb c
if
éé 
(
éé  
blendStyleUsed
éé  .
&&
éé/ 1
!
éé2 3
m_Renderer2DData
éé3 C
.
ééC D
lightBlendStyles
ééD T
[
ééT U
blendStyleIndex
ééU d
]
ééd e
.
éée f
hasRenderTarget
ééf u
)
ééu v
{
èè 
this
êê  $
.
êê$ %+
CreateBlendStyleRenderTexture
êê% B
(
êêB C
renderingData
êêC P
,
êêP Q
cmd
êêR U
,
êêU V
blendStyleIndex
êêW f
)
êêf g
;
êêg h
}
ëë 
RendererLighting
ìì ,
.
ìì, -
EnableBlendStyle
ìì- =
(
ìì= >
cmd
ìì> A
,
ììA B
blendStyleIndex
ììC R
,
ììR S
blendStyleUsed
ììT b
)
ììb c
;
ììc d
}
îî 
context
ññ 
.
ññ  "
ExecuteCommandBuffer
ññ  4
(
ññ4 5
cmd
ññ5 8
)
ññ8 9
;
ññ9 :
var
ôô 
upperLayerInBatch
ôô -
=
ôô. /#
FindUpperBoundInBatch
ôô0 E
(
ôôE F
i
ôôF G
,
ôôG H!
cachedSortingLayers
ôôI \
)
ôô\ ]
;
ôô] ^
var
ùù 
startLayerValue
ùù +
=
ùù, -
(
ùù. /
short
ùù/ 4
)
ùù4 5!
cachedSortingLayers
ùù6 I
[
ùùI J
i
ùùJ K
]
ùùK L
.
ùùL M
value
ùùM R
;
ùùR S
var
ûû 

lowerBound
ûû &
=
ûû' (
(
ûû) *
i
ûû* +
==
ûû, .
$num
ûû/ 0
)
ûû0 1
?
ûû2 3
short
ûû4 9
.
ûû9 :
MinValue
ûû: B
:
ûûC D
startLayerValue
ûûE T
;
ûûT U
var
üü 
endLayerValue
üü )
=
üü* +
(
üü, -
short
üü- 2
)
üü2 3!
cachedSortingLayers
üü4 G
[
üüG H
upperLayerInBatch
üüH Y
]
üüY Z
.
üüZ [
value
üü[ `
;
üü` a
var
†† 

upperBound
†† &
=
††' (
(
††) *
upperLayerInBatch
††* ;
==
††< >!
cachedSortingLayers
††? R
.
††R S
Length
††S Y
-
††Z [
$num
††\ ]
)
††] ^
?
††_ `
short
††a f
.
††f g
MaxValue
††g o
:
††p q
endLayerValue
††r 
;†† Ä
filterSettings
¢¢ &
.
¢¢& '
sortingLayerRange
¢¢' 8
=
¢¢9 :
new
¢¢; >
SortingLayerRange
¢¢? P
(
¢¢P Q

lowerBound
¢¢Q [
,
¢¢[ \

upperBound
¢¢] g
)
¢¢g h
;
¢¢h i
if
•• 
(
•• 

lightStats
•• &
.
••& '!
totalNormalMapUsage
••' :
>
••; <
$num
••= >
)
••> ?
this
¶¶  
.
¶¶  !
RenderNormals
¶¶! .
(
¶¶. /
context
¶¶/ 6
,
¶¶6 7
renderingData
¶¶8 E
.
¶¶E F
cullResults
¶¶F Q
,
¶¶Q R!
normalsDrawSettings
¶¶S f
,
¶¶f g
filterSettings
¶¶h v
,
¶¶v w
depthAttachment¶¶x á
)¶¶á à
;¶¶à â
cmd
®® 
.
®® 
Clear
®® !
(
®®! "
)
®®" #
;
®®# $
if
©© 
(
©© 

lightStats
©© &
.
©©& '
totalLights
©©' 2
>
©©3 4
$num
©©5 6
)
©©6 7
{
™™ 
this
´´  
.
´´  !
RenderLights
´´! -
(
´´- .
renderingData
´´. ;
,
´´; <
cmd
´´= @
,
´´@ A
layerToRender
´´B O
,
´´O P

lightStats
´´Q [
.
´´[ \
blendStylesUsed
´´\ k
)
´´k l
;
´´l m
}
¨¨ 
else
≠≠ 
{
ÆÆ 
this
ØØ  
.
ØØ  ! 
ClearDirtyLighting
ØØ! 3
(
ØØ3 4
cmd
ØØ4 7
,
ØØ7 8

lightStats
ØØ9 C
.
ØØC D
blendStylesUsed
ØØD S
)
ØØS T
;
ØØT U
}
∞∞ 
	CoreUtils
≤≤ !
.
≤≤! "
SetRenderTarget
≤≤" 1
(
≤≤1 2
cmd
≤≤2 5
,
≤≤5 6
colorAttachment
≤≤7 F
,
≤≤F G
depthAttachment
≤≤H W
,
≤≤W X
	ClearFlag
≤≤Y b
.
≤≤b c
None
≤≤c g
,
≤≤g h
Color
≤≤i n
.
≤≤n o
white
≤≤o t
)
≤≤t u
;
≤≤u v
context
≥≥ 
.
≥≥  "
ExecuteCommandBuffer
≥≥  4
(
≥≥4 5
cmd
≥≥5 8
)
≥≥8 9
;
≥≥9 :
Profiler
µµ  
.
µµ  !
BeginSample
µµ! ,
(
µµ, -
$str
µµ- e
)
µµe f
;
µµf g
context
∂∂ 
.
∂∂  
DrawRenderers
∂∂  -
(
∂∂- .
renderingData
∂∂. ;
.
∂∂; <
cullResults
∂∂< G
,
∂∂G H
ref
∂∂I L"
combinedDrawSettings
∂∂M a
,
∂∂a b
ref
∂∂c f
filterSettings
∂∂g u
)
∂∂u v
;
∂∂v w
Profiler
∑∑  
.
∑∑  !
	EndSample
∑∑! *
(
∑∑* +
)
∑∑+ ,
;
∑∑, -
if
ππ 
(
ππ 

lightStats
ππ &
.
ππ& '"
totalVolumetricUsage
ππ' ;
>
ππ< =
$num
ππ> ?
)
ππ? @
{
∫∫ 
cmd
ªª 
.
ªª  
Clear
ªª  %
(
ªª% &
)
ªª& '
;
ªª' (
this
ºº  
.
ºº  ! 
RenderLightVolumes
ºº! 3
(
ºº3 4
renderingData
ºº4 A
,
ººA B
cmd
ººC F
,
ººF G
layerToRender
ººH U
,
ººU V
colorAttachment
ººW f
,
ººf g
depthAttachment
ººh w
,
ººw x

lightStatsººy É
.ººÉ Ñ
blendStylesUsedººÑ ì
)ººì î
;ººî ï
context
ΩΩ #
.
ΩΩ# $"
ExecuteCommandBuffer
ΩΩ$ 8
(
ΩΩ8 9
cmd
ΩΩ9 <
)
ΩΩ< =
;
ΩΩ= >
cmd
ææ 
.
ææ  
Clear
ææ  %
(
ææ% &
)
ææ& '
;
ææ' (
}
øø 
i
¬¬ 
=
¬¬ 
upperLayerInBatch
¬¬ -
+
¬¬. /
$num
¬¬0 1
;
¬¬1 2
}
√√ 
cmd
≈≈ 
.
≈≈ 
Clear
≈≈ 
(
≈≈ 
)
≈≈ 
;
≈≈  
Profiler
∆∆ 
.
∆∆ 
BeginSample
∆∆ (
(
∆∆( )
$str
∆∆) ]
)
∆∆] ^
;
∆∆^ _
this
«« 
.
«« #
ReleaseRenderTextures
«« .
(
««. /
cmd
««/ 2
)
««2 3
;
««3 4
Profiler
»» 
.
»» 
	EndSample
»» &
(
»»& '
)
»»' (
;
»»( )
}
…… 
context
ÀÀ 
.
ÀÀ "
ExecuteCommandBuffer
ÀÀ ,
(
ÀÀ, -
cmd
ÀÀ- 0
)
ÀÀ0 1
;
ÀÀ1 2
CommandBufferPool
ÃÃ !
.
ÃÃ! "
Release
ÃÃ" )
(
ÃÃ) *
cmd
ÃÃ* -
)
ÃÃ- .
;
ÃÃ. /
filterSettings
ŒŒ 
.
ŒŒ 
sortingLayerRange
ŒŒ 0
=
ŒŒ1 2
SortingLayerRange
ŒŒ3 D
.
ŒŒD E
all
ŒŒE H
;
ŒŒH I
RenderingUtils
œœ 
.
œœ $
RenderObjectsWithError
œœ 5
(
œœ5 6
context
œœ6 =
,
œœ= >
ref
œœ? B
renderingData
œœC P
.
œœP Q
cullResults
œœQ \
,
œœ\ ]
camera
œœ^ d
,
œœd e
filterSettings
œœf t
,
œœt u
SortingCriteriaœœv Ö
.œœÖ Ü
NoneœœÜ ä
)œœä ã
;œœã å
}
–– 
else
—— 
{
““ 
var
”” 
unlitDrawSettings
”” %
=
””& '#
CreateDrawingSettings
””( =
(
””= >
k_ShaderTags
””> J
,
””J K
ref
””L O
renderingData
””P ]
,
””] ^
SortingCriteria
””_ n
.
””n o 
CommonTransparent””o Ä
)””Ä Å
;””Å Ç
var
’’ 
cmd
’’ 
=
’’ 
CommandBufferPool
’’ +
.
’’+ ,
Get
’’, /
(
’’/ 0
)
’’0 1
;
’’1 2
using
÷÷ 
(
÷÷ 
new
÷÷ 
ProfilingScope
÷÷ )
(
÷÷) *
cmd
÷÷* -
,
÷÷- .%
m_ProfilingSamplerUnlit
÷÷/ F
)
÷÷F G
)
÷÷G H
{
◊◊ 
	CoreUtils
ÿÿ 
.
ÿÿ 
SetRenderTarget
ÿÿ -
(
ÿÿ- .
cmd
ÿÿ. 1
,
ÿÿ1 2
colorAttachment
ÿÿ3 B
,
ÿÿB C
depthAttachment
ÿÿD S
,
ÿÿS T
	ClearFlag
ÿÿU ^
.
ÿÿ^ _
None
ÿÿ_ c
,
ÿÿc d
Color
ÿÿe j
.
ÿÿj k
white
ÿÿk p
)
ÿÿp q
;
ÿÿq r
cmd
ŸŸ 
.
ŸŸ 
SetGlobalTexture
ŸŸ (
(
ŸŸ( )$
k_ShapeLightTexture0ID
ŸŸ) ?
,
ŸŸ? @
	Texture2D
ŸŸA J
.
ŸŸJ K
blackTexture
ŸŸK W
)
ŸŸW X
;
ŸŸX Y
cmd
⁄⁄ 
.
⁄⁄ 
SetGlobalTexture
⁄⁄ (
(
⁄⁄( )$
k_ShapeLightTexture1ID
⁄⁄) ?
,
⁄⁄? @
	Texture2D
⁄⁄A J
.
⁄⁄J K
blackTexture
⁄⁄K W
)
⁄⁄W X
;
⁄⁄X Y
cmd
€€ 
.
€€ 
SetGlobalTexture
€€ (
(
€€( )$
k_ShapeLightTexture2ID
€€) ?
,
€€? @
	Texture2D
€€A J
.
€€J K
blackTexture
€€K W
)
€€W X
;
€€X Y
cmd
‹‹ 
.
‹‹ 
SetGlobalTexture
‹‹ (
(
‹‹( )$
k_ShapeLightTexture3ID
‹‹) ?
,
‹‹? @
	Texture2D
‹‹A J
.
‹‹J K
blackTexture
‹‹K W
)
‹‹W X
;
‹‹X Y
cmd
›› 
.
›› 
SetGlobalFloat
›› &
(
››& '"
k_UseSceneLightingID
››' ;
,
››; <
	isLitView
››= F
?
››G H
$num
››I M
:
››N O
$num
››P T
)
››T U
;
››U V
cmd
ﬁﬁ 
.
ﬁﬁ 
SetGlobalColor
ﬁﬁ &
(
ﬁﬁ& '
k_RendererColorID
ﬁﬁ' 8
,
ﬁﬁ8 9
Color
ﬁﬁ: ?
.
ﬁﬁ? @
white
ﬁﬁ@ E
)
ﬁﬁE F
;
ﬁﬁF G
cmd
ﬂﬂ 
.
ﬂﬂ !
EnableShaderKeyword
ﬂﬂ +
(
ﬂﬂ+ ,
$str
ﬂﬂ, D
)
ﬂﬂD E
;
ﬂﬂE F
}
‡‡ 
context
‚‚ 
.
‚‚ "
ExecuteCommandBuffer
‚‚ ,
(
‚‚, -
cmd
‚‚- 0
)
‚‚0 1
;
‚‚1 2
CommandBufferPool
„„ !
.
„„! "
Release
„„" )
(
„„) *
cmd
„„* -
)
„„- .
;
„„. /
Profiler
ÂÂ 
.
ÂÂ 
BeginSample
ÂÂ $
(
ÂÂ$ %
$str
ÂÂ% ;
)
ÂÂ; <
;
ÂÂ< =
context
ÊÊ 
.
ÊÊ 
DrawRenderers
ÊÊ )
(
ÊÊ) *
renderingData
ÊÊ* 7
.
ÊÊ7 8
cullResults
ÊÊ8 C
,
ÊÊC D
ref
ÊÊE H
unlitDrawSettings
ÊÊI Z
,
ÊÊZ [
ref
ÊÊ\ _
filterSettings
ÊÊ` n
)
ÊÊn o
;
ÊÊo p
Profiler
ÁÁ 
.
ÁÁ 
	EndSample
ÁÁ "
(
ÁÁ" #
)
ÁÁ# $
;
ÁÁ$ %
RenderingUtils
ÈÈ 
.
ÈÈ $
RenderObjectsWithError
ÈÈ 5
(
ÈÈ5 6
context
ÈÈ6 =
,
ÈÈ= >
ref
ÈÈ? B
renderingData
ÈÈC P
.
ÈÈP Q
cullResults
ÈÈQ \
,
ÈÈ\ ]
camera
ÈÈ^ d
,
ÈÈd e
filterSettings
ÈÈf t
,
ÈÈt u
SortingCriteriaÈÈv Ö
.ÈÈÖ Ü
NoneÈÈÜ ä
)ÈÈä ã
;ÈÈã å
}
ÍÍ 
}
ÎÎ 	
Renderer2DData
ÌÌ 
IRenderPass2D
ÌÌ $
.
ÌÌ$ %
rendererData
ÌÌ% 1
{
ÓÓ 	
get
ÔÔ 
{
ÔÔ 
return
ÔÔ 
m_Renderer2DData
ÔÔ )
;
ÔÔ) *
}
ÔÔ+ ,
}
 	
}
ÒÒ 
}ÚÚ µﬂ
¥D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\AdditionalLightsShadowCasterPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
public

 

class

 ,
 AdditionalLightsShadowCasterPass

 1
:

2 3 
ScriptableRenderPass

4 H
{ 
private 
static 
class +
AdditionalShadowsConstantBuffer <
{ 	
public 
static 
int *
_AdditionalLightsWorldToShadow <
;< =
public 
static 
int #
_AdditionalShadowParams 5
;5 6
public 
static 
int $
_AdditionalShadowOffset0 6
;6 7
public 
static 
int $
_AdditionalShadowOffset1 6
;6 7
public 
static 
int $
_AdditionalShadowOffset2 6
;6 7
public 
static 
int $
_AdditionalShadowOffset3 6
;6 7
public 
static 
int $
_AdditionalShadowmapSize 6
;6 7
} 	
public 
static 
int '
m_AdditionalShadowsBufferId 5
;5 6
public 
static 
int (
m_AdditionalShadowsIndicesId 6
;6 7
bool !
m_UseStructuredBuffer "
;" #
const 
int !
k_ShadowmapBufferBits '
=( )
$num* ,
;, -
private 
RenderTargetHandle "'
m_AdditionalLightsShadowmap# >
;> ?
RenderTexture .
"m_AdditionalLightsShadowmapTexture 8
;8 9
int 
m_ShadowmapWidth 
; 
int   
m_ShadowmapHeight   
;   
ShadowSliceData"" 
["" 
]"" #
m_AdditionalLightSlices"" 1
=""2 3
null""4 8
;""8 9
	Matrix4x4%% 
[%% 
]%% +
m_AdditionalLightsWorldToShadow%% 3
=%%4 5
null%%6 :
;%%: ;
Vector4&& 
[&& 
]&& *
m_AdditionalLightsShadowParams&& 0
=&&1 2
null&&3 7
;&&7 8
ShaderInput)) 
.)) 

ShadowData)) 
[)) 
]))  (
m_AdditionalLightsShadowData))! =
=))> ?
null))@ D
;))D E
List++ 
<++ 
int++ 
>++ 1
%m_AdditionalShadowCastingLightIndices++ 7
=++8 9
new++: =
List++> B
<++B C
int++C F
>++F G
(++G H
)++H I
;++I J
List,, 
<,, 
int,, 
>,, 4
(m_AdditionalShadowCastingLightIndicesMap,, :
=,,; <
new,,= @
List,,A E
<,,E F
int,,F I
>,,I J
(,,J K
),,K L
;,,L M
List.. 
<.. 
int.. 
>.. *
m_ShadowCastingLightIndicesMap.. 0
=..1 2
new..3 6
List..7 ;
<..; <
int..< ?
>..? @
(..@ A
)..A B
;..B C
bool00 )
m_SupportsBoxFilterForShadows00 *
;00* +
ProfilingSampler11 #
m_ProfilingSetupSampler11 0
=111 2
new113 6
ProfilingSampler117 G
(11G H
$str11H b
)11b c
;11c d
public33 ,
 AdditionalLightsShadowCasterPass33 /
(33/ 0
RenderPassEvent330 ?
evt33@ C
)33C D
{44 	
base55 
.55 
profilingSampler55 !
=55" #
new55$ '
ProfilingSampler55( 8
(558 9
nameof559 ?
(55? @,
 AdditionalLightsShadowCasterPass55@ `
)55` a
)55a b
;55b c
renderPassEvent66 
=66 
evt66 !
;66! "+
AdditionalShadowsConstantBuffer88 +
.88+ ,*
_AdditionalLightsWorldToShadow88, J
=88K L
Shader88M S
.88S T
PropertyToID88T `
(88` a
$str	88a Å
)
88Å Ç
;
88Ç É+
AdditionalShadowsConstantBuffer99 +
.99+ ,#
_AdditionalShadowParams99, C
=99D E
Shader99F L
.99L M
PropertyToID99M Y
(99Y Z
$str99Z s
)99s t
;99t u+
AdditionalShadowsConstantBuffer:: +
.::+ ,$
_AdditionalShadowOffset0::, D
=::E F
Shader::G M
.::M N
PropertyToID::N Z
(::Z [
$str::[ u
)::u v
;::v w+
AdditionalShadowsConstantBuffer;; +
.;;+ ,$
_AdditionalShadowOffset1;;, D
=;;E F
Shader;;G M
.;;M N
PropertyToID;;N Z
(;;Z [
$str;;[ u
);;u v
;;;v w+
AdditionalShadowsConstantBuffer<< +
.<<+ ,$
_AdditionalShadowOffset2<<, D
=<<E F
Shader<<G M
.<<M N
PropertyToID<<N Z
(<<Z [
$str<<[ u
)<<u v
;<<v w+
AdditionalShadowsConstantBuffer== +
.==+ ,$
_AdditionalShadowOffset3==, D
===E F
Shader==G M
.==M N
PropertyToID==N Z
(==Z [
$str==[ u
)==u v
;==v w+
AdditionalShadowsConstantBuffer>> +
.>>+ ,$
_AdditionalShadowmapSize>>, D
=>>E F
Shader>>G M
.>>M N
PropertyToID>>N Z
(>>Z [
$str>>[ u
)>>u v
;>>v w'
m_AdditionalLightsShadowmap?? '
.??' (
Init??( ,
(??, -
$str??- P
)??P Q
;??Q R'
m_AdditionalShadowsBufferIdAA '
=AA( )
ShaderAA* 0
.AA0 1
PropertyToIDAA1 =
(AA= >
$strAA> X
)AAX Y
;AAY Z(
m_AdditionalShadowsIndicesIdBB (
=BB) *
ShaderBB+ 1
.BB1 2
PropertyToIDBB2 >
(BB> ?
$strBB? Z
)BBZ [
;BB[ \!
m_UseStructuredBufferCC !
=CC" #
RenderingUtilsCC$ 2
.CC2 3
useStructuredBufferCC3 F
;CCF G)
m_SupportsBoxFilterForShadowsDD )
=DD* +
ApplicationDD, 7
.DD7 8
isMobilePlatformDD8 H
||DDI K

SystemInfoDDL V
.DDV W
graphicsDeviceTypeDDW i
==DDj l
GraphicsDeviceTypeDDm 
.	DD Ä
Switch
DDÄ Ü
;
DDÜ á
ifFF 
(FF 
!FF !
m_UseStructuredBufferFF &
)FF& '
{GG 
intII 
	maxLightsII 
=II #
UniversalRenderPipelineII  7
.II7 8&
maxVisibleAdditionalLightsII8 R
;IIR S+
m_AdditionalLightsWorldToShadowJJ /
=JJ0 1
newJJ2 5
	Matrix4x4JJ6 ?
[JJ? @
	maxLightsJJ@ I
]JJI J
;JJJ K*
m_AdditionalLightsShadowParamsKK .
=KK/ 0
newKK1 4
Vector4KK5 <
[KK< =
	maxLightsKK= F
]KKF G
;KKG H
}LL 
}MM 	
publicOO 
boolOO 
SetupOO 
(OO 
refOO 
RenderingDataOO +
renderingDataOO, 9
)OO9 :
{PP 	
usingQQ 
varQQ 
	profScopeQQ 
=QQ  !
newQQ" %
ProfilingScopeQQ& 4
(QQ4 5
nullQQ5 9
,QQ9 :#
m_ProfilingSetupSamplerQQ; R
)QQR S
;QQS T
ClearSS 
(SS 
)SS 
;SS 
m_ShadowmapWidthUU 
=UU 
renderingDataUU ,
.UU, -

shadowDataUU- 7
.UU7 8*
additionalLightsShadowmapWidthUU8 V
;UUV W
m_ShadowmapHeightVV 
=VV 
renderingDataVV  -
.VV- .

shadowDataVV. 8
.VV8 9+
additionalLightsShadowmapHeightVV9 X
;VVX Y
varXX 
visibleLightsXX 
=XX 
renderingDataXX  -
.XX- .
	lightDataXX. 7
.XX7 8
visibleLightsXX8 E
;XXE F
intYY !
additionalLightsCountYY %
=YY& '
renderingDataYY( 5
.YY5 6
	lightDataYY6 ?
.YY? @!
additionalLightsCountYY@ U
;YYU V
if[[ 
([[ #
m_AdditionalLightSlices[[ '
==[[( *
null[[+ /
||[[0 2#
m_AdditionalLightSlices[[3 J
.[[J K
Length[[K Q
<[[R S!
additionalLightsCount[[T i
)[[i j#
m_AdditionalLightSlices\\ '
=\\( )
new\\* -
ShadowSliceData\\. =
[\\= >!
additionalLightsCount\\> S
]\\S T
;\\T U
if^^ 
(^^ (
m_AdditionalLightsShadowData^^ ,
==^^- /
null^^0 4
||^^5 7(
m_AdditionalLightsShadowData^^8 T
.^^T U
Length^^U [
<^^\ ]!
additionalLightsCount^^^ s
)^^s t(
m_AdditionalLightsShadowData__ ,
=__- .
new__/ 2
ShaderInput__3 >
.__> ?

ShadowData__? I
[__I J!
additionalLightsCount__J _
]___ `
;__` a
forbb 
(bb 
intbb 
ibb 
=bb 
$numbb 
;bb 
ibb 
<bb 
visibleLightsbb  -
.bb- .
Lengthbb. 4
;bb4 5
++bb6 8
ibb8 9
)bb9 :*
m_ShadowCastingLightIndicesMapcc .
.cc. /
Addcc/ 2
(cc2 3
-cc3 4
$numcc4 5
)cc5 6
;cc6 7
intee $
validShadowCastingLightsee (
=ee) *
$numee+ ,
;ee, -
boolff 
supportsSoftShadowsff $
=ff% &
renderingDataff' 4
.ff4 5

shadowDataff5 ?
.ff? @
supportsSoftShadowsff@ S
;ffS T
forgg 
(gg 
intgg 
igg 
=gg 
$numgg 
;gg 
igg 
<gg 
visibleLightsgg  -
.gg- .
Lengthgg. 4
&&gg5 71
%m_AdditionalShadowCastingLightIndicesgg8 ]
.gg] ^
Countgg^ c
<ggd e!
additionalLightsCountggf {
;gg{ |
++gg} 
i	gg Ä
)
ggÄ Å
{hh 
VisibleLightii 
shadowLightii (
=ii) *
visibleLightsii+ 8
[ii8 9
iii9 :
]ii: ;
;ii; <
ifll 
(ll 
ill 
==ll 
renderingDatall &
.ll& '
	lightDatall' 0
.ll0 1
mainLightIndexll1 ?
)ll? @
continuemm 
;mm 
intoo #
shadowCastingLightIndexoo +
=oo, -1
%m_AdditionalShadowCastingLightIndicesoo. S
.ooS T
CountooT Y
;ooY Z
boolpp 
isValidShadowSlicepp '
=pp( )
falsepp* /
;pp/ 0
ifqq 
(qq 
renderingDataqq !
.qq! "
cullResultsqq" -
.qq- .!
GetShadowCasterBoundsqq. C
(qqC D
iqqD E
,qqE F
outqqG J
varqqK N
boundsqqO U
)qqU V
)qqV W
{rr 
ifuu 
(uu 
!uu 
renderingDatauu &
.uu& '

shadowDatauu' 1
.uu1 2*
supportsAdditionalLightShadowsuu2 P
)uuP Q
continuevv  
;vv  !
ifxx 
(xx %
IsValidShadowCastingLightxx 1
(xx1 2
refxx2 5
renderingDataxx6 C
.xxC D
	lightDataxxD M
,xxM N
ixxO P
)xxP Q
)xxQ R
{yy 
boolzz 
successzz $
=zz% &
ShadowUtilszz' 2
.zz2 3"
ExtractSpotLightMatrixzz3 I
(zzI J
refzzJ M
renderingDatazzN [
.zz[ \
cullResultszz\ g
,zzg h
ref{{ 
renderingData{{  -
.{{- .

shadowData{{. 8
,{{8 9
i|| 
,|| 
out}} 
var}}  #
shadowTransform}}$ 3
,}}3 4
out~~ #
m_AdditionalLightSlices~~  7
[~~7 8#
shadowCastingLightIndex~~8 O
]~~O P
.~~P Q

viewMatrix~~Q [
,~~[ \
out #
m_AdditionalLightSlices  7
[7 8#
shadowCastingLightIndex8 O
]O P
.P Q
projectionMatrixQ a
)a b
;b c
if
ÅÅ 
(
ÅÅ 
success
ÅÅ #
)
ÅÅ# $
{
ÇÇ 3
%m_AdditionalShadowCastingLightIndices
ÉÉ A
.
ÉÉA B
Add
ÉÉB E
(
ÉÉE F
i
ÉÉF G
)
ÉÉG H
;
ÉÉH I
var
ÑÑ 
light
ÑÑ  %
=
ÑÑ& '
shadowLight
ÑÑ( 3
.
ÑÑ3 4
light
ÑÑ4 9
;
ÑÑ9 :
float
ÖÖ !
shadowStrength
ÖÖ" 0
=
ÖÖ1 2
light
ÖÖ3 8
.
ÖÖ8 9
shadowStrength
ÖÖ9 G
;
ÖÖG H
float
ÜÜ !
softShadows
ÜÜ" -
=
ÜÜ. /
(
ÜÜ0 1!
supportsSoftShadows
ÜÜ1 D
&&
ÜÜE G
light
ÜÜH M
.
ÜÜM N
shadows
ÜÜN U
==
ÜÜV X
LightShadows
ÜÜY e
.
ÜÜe f
Soft
ÜÜf j
)
ÜÜj k
?
ÜÜl m
$num
ÜÜn r
:
ÜÜs t
$num
ÜÜu y
;
ÜÜy z
Vector4
áá #
shadowParams
áá$ 0
=
áá1 2
new
áá3 6
Vector4
áá7 >
(
áá> ?
shadowStrength
áá? M
,
ááM N
softShadows
ááO Z
,
ááZ [
$num
áá\ `
,
áá` a
$num
ááb f
)
ááf g
;
áág h
if
àà 
(
àà  #
m_UseStructuredBuffer
àà  5
)
àà5 6
{
ââ *
m_AdditionalLightsShadowData
ää  <
[
ää< =%
shadowCastingLightIndex
ää= T
]
ääT U
.
ääU V!
worldToShadowMatrix
ääV i
=
ääj k
shadowTransform
ääl {
;
ää{ |*
m_AdditionalLightsShadowData
ãã  <
[
ãã< =%
shadowCastingLightIndex
ãã= T
]
ããT U
.
ããU V
shadowParams
ããV b
=
ããc d
shadowParams
ããe q
;
ããq r
}
åå 
else
çç  
{
éé -
m_AdditionalLightsWorldToShadow
èè  ?
[
èè? @%
shadowCastingLightIndex
èè@ W
]
èèW X
=
èèY Z
shadowTransform
èè[ j
;
èèj k,
m_AdditionalLightsShadowParams
êê  >
[
êê> ?%
shadowCastingLightIndex
êê? V
]
êêV W
=
êêX Y
shadowParams
êêZ f
;
êêf g
}
ëë  
isValidShadowSlice
íí .
=
íí/ 0
true
íí1 5
;
íí5 6&
validShadowCastingLights
ìì 4
++
ìì4 6
;
ìì6 7
}
îî 
}
ïï 
}
ññ 
if
òò 
(
òò #
m_UseStructuredBuffer
òò )
)
òò) *
{
ôô 
int
üü 
indexMap
üü  
=
üü! "
(
üü# $ 
isValidShadowSlice
üü$ 6
)
üü6 7
?
üü8 9%
shadowCastingLightIndex
üü: Q
:
üüR S
-
üüT U
$num
üüU V
;
üüV W6
(m_AdditionalShadowCastingLightIndicesMap
†† <
.
††< =
Add
††= @
(
††@ A
indexMap
††A I
)
††I J
;
††J K
}
°° 
else
¢¢ 
if
¢¢ 
(
¢¢ 
!
¢¢  
isValidShadowSlice
¢¢ ,
)
¢¢, -
{
££ 
	Matrix4x4
≠≠ 
identity
≠≠ &
=
≠≠' (
	Matrix4x4
≠≠) 2
.
≠≠2 3
identity
≠≠3 ;
;
≠≠; <3
%m_AdditionalShadowCastingLightIndices
ÆÆ 9
.
ÆÆ9 :
Add
ÆÆ: =
(
ÆÆ= >
i
ÆÆ> ?
)
ÆÆ? @
;
ÆÆ@ A-
m_AdditionalLightsWorldToShadow
ØØ 3
[
ØØ3 4%
shadowCastingLightIndex
ØØ4 K
]
ØØK L
=
ØØM N
identity
ØØO W
;
ØØW X,
m_AdditionalLightsShadowParams
∞∞ 2
[
∞∞2 3%
shadowCastingLightIndex
∞∞3 J
]
∞∞J K
=
∞∞L M
Vector4
∞∞N U
.
∞∞U V
zero
∞∞V Z
;
∞∞Z [%
m_AdditionalLightSlices
±± +
[
±±+ ,%
shadowCastingLightIndex
±±, C
]
±±C D
.
±±D E

viewMatrix
±±E O
=
±±P Q
identity
±±R Z
;
±±Z [%
m_AdditionalLightSlices
≤≤ +
[
≤≤+ ,%
shadowCastingLightIndex
≤≤, C
]
≤≤C D
.
≤≤D E
projectionMatrix
≤≤E U
=
≤≤V W
identity
≤≤X `
;
≤≤` a
}
≥≥ ,
m_ShadowCastingLightIndicesMap
µµ .
[
µµ. /
i
µµ/ 0
]
µµ0 1
=
µµ2 3 
isValidShadowSlice
µµ4 F
?
µµG H%
shadowCastingLightIndex
µµI `
:
µµa b
-
µµc d
$num
µµd e
;
µµe f
}
∂∂ 
if
ππ 
(
ππ &
validShadowCastingLights
ππ (
==
ππ) +
$num
ππ, -
)
ππ- .
return
∫∫ 
false
∫∫ 
;
∫∫ 
int
ºº 

atlasWidth
ºº 
=
ºº 
renderingData
ºº *
.
ºº* +

shadowData
ºº+ 5
.
ºº5 6,
additionalLightsShadowmapWidth
ºº6 T
;
ººT U
int
ΩΩ 
atlasHeight
ΩΩ 
=
ΩΩ 
renderingData
ΩΩ +
.
ΩΩ+ ,

shadowData
ΩΩ, 6
.
ΩΩ6 7-
additionalLightsShadowmapHeight
ΩΩ7 V
;
ΩΩV W
int
ææ 
sliceResolution
ææ 
=
ææ  !
ShadowUtils
ææ" -
.
ææ- .)
GetMaxTileResolutionInAtlas
ææ. I
(
ææI J

atlasWidth
ææJ T
,
ææT U
atlasHeight
ææV a
,
ææa b&
validShadowCastingLights
ææc {
)
ææ{ |
;
ææ| }
int
¬¬ 
maximumSlices
¬¬ 
=
¬¬ 
(
¬¬  !
m_ShadowmapWidth
¬¬! 1
/
¬¬2 3
sliceResolution
¬¬4 C
)
¬¬C D
*
¬¬E F
(
¬¬G H
m_ShadowmapHeight
¬¬H Y
/
¬¬Z [
sliceResolution
¬¬\ k
)
¬¬k l
;
¬¬l m
if
√√ 
(
√√ &
validShadowCastingLights
√√ (
<=
√√) +
(
√√, -
maximumSlices
√√- :
/
√√; <
$num
√√= >
)
√√> ?
)
√√? @
m_ShadowmapHeight
ƒƒ !
/=
ƒƒ" $
$num
ƒƒ% &
;
ƒƒ& '
int
∆∆  
shadowSlicesPerRow
∆∆ "
=
∆∆# $
(
∆∆% &

atlasWidth
∆∆& 0
/
∆∆1 2
sliceResolution
∆∆3 B
)
∆∆B C
;
∆∆C D
float
«« 
oneOverAtlasWidth
«« #
=
««$ %
$num
««& *
/
««+ ,
m_ShadowmapWidth
««- =
;
««= >
float
»»  
oneOverAtlasHeight
»» $
=
»»% &
$num
»»' +
/
»», -
m_ShadowmapHeight
»». ?
;
»»? @
int
   

sliceIndex
   
=
   
$num
   
;
   
int
ÀÀ ,
shadowCastingLightsBufferCount
ÀÀ .
=
ÀÀ/ 03
%m_AdditionalShadowCastingLightIndices
ÀÀ1 V
.
ÀÀV W
Count
ÀÀW \
;
ÀÀ\ ]
	Matrix4x4
ÃÃ 
sliceTransform
ÃÃ $
=
ÃÃ% &
	Matrix4x4
ÃÃ' 0
.
ÃÃ0 1
identity
ÃÃ1 9
;
ÃÃ9 :
sliceTransform
ÕÕ 
.
ÕÕ 
m00
ÕÕ 
=
ÕÕ  
sliceResolution
ÕÕ! 0
*
ÕÕ1 2
oneOverAtlasWidth
ÕÕ3 D
;
ÕÕD E
sliceTransform
ŒŒ 
.
ŒŒ 
m11
ŒŒ 
=
ŒŒ  
sliceResolution
ŒŒ! 0
*
ŒŒ1 2 
oneOverAtlasHeight
ŒŒ3 E
;
ŒŒE F
for
–– 
(
–– 
int
–– 
i
–– 
=
–– 
$num
–– 
;
–– 
i
–– 
<
–– ,
shadowCastingLightsBufferCount
––  >
;
––> ?
++
––@ B
i
––B C
)
––C D
{
—— 
if
‘‘ 
(
‘‘ 
!
‘‘ #
m_UseStructuredBuffer
‘‘ *
&&
‘‘+ -
Mathf
‘‘. 3
.
‘‘3 4
Approximately
‘‘4 A
(
‘‘A B,
m_AdditionalLightsShadowParams
‘‘B `
[
‘‘` a
i
‘‘a b
]
‘‘b c
.
‘‘c d
x
‘‘d e
,
‘‘e f
$num
‘‘g k
)
‘‘k l
)
‘‘l m
continue
’’ 
;
’’ %
m_AdditionalLightSlices
◊◊ '
[
◊◊' (
i
◊◊( )
]
◊◊) *
.
◊◊* +
offsetX
◊◊+ 2
=
◊◊3 4
(
◊◊5 6

sliceIndex
◊◊6 @
%
◊◊A B 
shadowSlicesPerRow
◊◊C U
)
◊◊U V
*
◊◊W X
sliceResolution
◊◊Y h
;
◊◊h i%
m_AdditionalLightSlices
ÿÿ '
[
ÿÿ' (
i
ÿÿ( )
]
ÿÿ) *
.
ÿÿ* +
offsetY
ÿÿ+ 2
=
ÿÿ3 4
(
ÿÿ5 6

sliceIndex
ÿÿ6 @
/
ÿÿA B 
shadowSlicesPerRow
ÿÿC U
)
ÿÿU V
*
ÿÿW X
sliceResolution
ÿÿY h
;
ÿÿh i%
m_AdditionalLightSlices
ŸŸ '
[
ŸŸ' (
i
ŸŸ( )
]
ŸŸ) *
.
ŸŸ* +

resolution
ŸŸ+ 5
=
ŸŸ6 7
sliceResolution
ŸŸ8 G
;
ŸŸG H
sliceTransform
€€ 
.
€€ 
m03
€€ "
=
€€# $%
m_AdditionalLightSlices
€€% <
[
€€< =
i
€€= >
]
€€> ?
.
€€? @
offsetX
€€@ G
*
€€H I
oneOverAtlasWidth
€€J [
;
€€[ \
sliceTransform
‹‹ 
.
‹‹ 
m13
‹‹ "
=
‹‹# $%
m_AdditionalLightSlices
‹‹% <
[
‹‹< =
i
‹‹= >
]
‹‹> ?
.
‹‹? @
offsetY
‹‹@ G
*
‹‹H I 
oneOverAtlasHeight
‹‹J \
;
‹‹\ ]
if
‡‡ 
(
‡‡ #
m_UseStructuredBuffer
‡‡ )
)
‡‡) **
m_AdditionalLightsShadowData
·· 0
[
··0 1
i
··1 2
]
··2 3
.
··3 4!
worldToShadowMatrix
··4 G
=
··H I
sliceTransform
··J X
*
··Y Z*
m_AdditionalLightsShadowData
··[ w
[
··w x
i
··x y
]
··y z
.
··z {"
worldToShadowMatrix··{ é
;··é è
else
‚‚ -
m_AdditionalLightsWorldToShadow
„„ 3
[
„„3 4
i
„„4 5
]
„„5 6
=
„„7 8
sliceTransform
„„9 G
*
„„H I-
m_AdditionalLightsWorldToShadow
„„J i
[
„„i j
i
„„j k
]
„„k l
;
„„l m

sliceIndex
‰‰ 
++
‰‰ 
;
‰‰ 
}
ÂÂ 
return
ÁÁ 
true
ÁÁ 
;
ÁÁ 
}
ËË 	
public
ÍÍ 
override
ÍÍ 
void
ÍÍ 
	Configure
ÍÍ &
(
ÍÍ& '
CommandBuffer
ÍÍ' 4
cmd
ÍÍ5 8
,
ÍÍ8 9%
RenderTextureDescriptor
ÍÍ: Q%
cameraTextureDescriptor
ÍÍR i
)
ÍÍi j
{
ÎÎ 	0
"m_AdditionalLightsShadowmapTexture
ÏÏ .
=
ÏÏ/ 0
ShadowUtils
ÏÏ1 <
.
ÏÏ< ='
GetTemporaryShadowTexture
ÏÏ= V
(
ÏÏV W
m_ShadowmapWidth
ÏÏW g
,
ÏÏg h
m_ShadowmapHeight
ÏÏi z
,
ÏÏz {$
k_ShadowmapBufferBitsÏÏ| ë
)ÏÏë í
;ÏÏí ì
ConfigureTarget
ÌÌ 
(
ÌÌ 
new
ÌÌ $
RenderTargetIdentifier
ÌÌ  6
(
ÌÌ6 70
"m_AdditionalLightsShadowmapTexture
ÌÌ7 Y
)
ÌÌY Z
)
ÌÌZ [
;
ÌÌ[ \
ConfigureClear
ÓÓ 
(
ÓÓ 
	ClearFlag
ÓÓ $
.
ÓÓ$ %
All
ÓÓ% (
,
ÓÓ( )
Color
ÓÓ* /
.
ÓÓ/ 0
black
ÓÓ0 5
)
ÓÓ5 6
;
ÓÓ6 7
}
ÔÔ 	
public
ÚÚ 
override
ÚÚ 
void
ÚÚ 
Execute
ÚÚ $
(
ÚÚ$ %%
ScriptableRenderContext
ÚÚ% <
context
ÚÚ= D
,
ÚÚD E
ref
ÚÚF I
RenderingData
ÚÚJ W
renderingData
ÚÚX e
)
ÚÚe f
{
ÛÛ 	
if
ÙÙ 
(
ÙÙ 
renderingData
ÙÙ 
.
ÙÙ 

shadowData
ÙÙ (
.
ÙÙ( ),
supportsAdditionalLightShadows
ÙÙ) G
)
ÙÙG H,
RenderAdditionalShadowmapAtlas
ıı .
(
ıı. /
ref
ıı/ 2
context
ıı3 :
,
ıı: ;
ref
ıı< ?
renderingData
ıı@ M
.
ııM N
cullResults
ııN Y
,
ııY Z
ref
ıı[ ^
renderingData
ıı_ l
.
ııl m
	lightData
ıım v
,
ııv w
ref
ııx {
renderingDataıı| â
.ııâ ä

shadowDataııä î
)ııî ï
;ııï ñ
}
ˆˆ 	
public
¯¯ 
override
¯¯ 
void
¯¯ 
OnCameraCleanup
¯¯ ,
(
¯¯, -
CommandBuffer
¯¯- :
cmd
¯¯; >
)
¯¯> ?
{
˘˘ 	
if
˙˙ 
(
˙˙ 
cmd
˙˙ 
==
˙˙ 
null
˙˙ 
)
˙˙ 
throw
˚˚ 
new
˚˚ #
ArgumentNullException
˚˚ /
(
˚˚/ 0
$str
˚˚0 5
)
˚˚5 6
;
˚˚6 7
if
˝˝ 
(
˝˝ 0
"m_AdditionalLightsShadowmapTexture
˝˝ 2
)
˝˝2 3
{
˛˛ 
RenderTexture
ˇˇ 
.
ˇˇ 
ReleaseTemporary
ˇˇ .
(
ˇˇ. /0
"m_AdditionalLightsShadowmapTexture
ˇˇ/ Q
)
ˇˇQ R
;
ˇˇR S0
"m_AdditionalLightsShadowmapTexture
ÄÄ 2
=
ÄÄ3 4
null
ÄÄ5 9
;
ÄÄ9 :
}
ÅÅ 
}
ÇÇ 	
public
ÑÑ 
int
ÑÑ /
!GetShadowLightIndexFromLightIndex
ÑÑ 4
(
ÑÑ4 5
int
ÑÑ5 8
visibleLightIndex
ÑÑ9 J
)
ÑÑJ K
{
ÖÖ 	
if
ÜÜ 
(
ÜÜ 
visibleLightIndex
ÜÜ !
<
ÜÜ" #
$num
ÜÜ$ %
||
ÜÜ& (
visibleLightIndex
ÜÜ) :
>=
ÜÜ; =,
m_ShadowCastingLightIndicesMap
ÜÜ> \
.
ÜÜ\ ]
Count
ÜÜ] b
)
ÜÜb c
return
áá 
-
áá 
$num
áá 
;
áá 
return
àà ,
m_ShadowCastingLightIndicesMap
àà 1
[
àà1 2
visibleLightIndex
àà2 C
]
ààC D
;
ààD E
}
ââ 	
void
ãã 
Clear
ãã 
(
ãã 
)
ãã 
{
åå 	3
%m_AdditionalShadowCastingLightIndices
çç 1
.
çç1 2
Clear
çç2 7
(
çç7 8
)
çç8 9
;
çç9 :6
(m_AdditionalShadowCastingLightIndicesMap
éé 4
.
éé4 5
Clear
éé5 :
(
éé: ;
)
éé; <
;
éé< =0
"m_AdditionalLightsShadowmapTexture
èè .
=
èè/ 0
null
èè1 5
;
èè5 6,
m_ShadowCastingLightIndicesMap
êê *
.
êê* +
Clear
êê+ 0
(
êê0 1
)
êê1 2
;
êê2 3
}
ëë 	
void
ìì ,
RenderAdditionalShadowmapAtlas
ìì +
(
ìì+ ,
ref
ìì, /%
ScriptableRenderContext
ìì0 G
context
ììH O
,
ììO P
ref
ììQ T
CullingResults
ììU c
cullResults
ììd o
,
ììo p
ref
ììq t
	LightData
ììu ~
	lightDataìì à
,ììà â
refììä ç

ShadowDataììé ò

shadowDataììô £
)ìì£ §
{
îî 	
NativeArray
ïï 
<
ïï 
VisibleLight
ïï $
>
ïï$ %
visibleLights
ïï& 3
=
ïï4 5
	lightData
ïï6 ?
.
ïï? @
visibleLights
ïï@ M
;
ïïM N
bool
óó +
additionalLightHasSoftShadows
óó .
=
óó/ 0
false
óó1 6
;
óó6 7
CommandBuffer
öö 
cmd
öö 
=
öö 
CommandBufferPool
öö  1
.
öö1 2
Get
öö2 5
(
öö5 6
)
öö6 7
;
öö7 8
using
õõ 
(
õõ 
new
õõ 
ProfilingScope
õõ %
(
õõ% &
cmd
õõ& )
,
õõ) *
ProfilingSampler
õõ+ ;
.
õõ; <
Get
õõ< ?
(
õõ? @
URPProfileId
õõ@ L
.
õõL M$
AdditionalLightsShadow
õõM c
)
õõc d
)
õõd e
)
õõe f
{
úú 
bool
ùù $
anyShadowSliceRenderer
ùù +
=
ùù, -
false
ùù. 3
;
ùù3 4
int
ûû 
shadowSlicesCount
ûû %
=
ûû& '3
%m_AdditionalShadowCastingLightIndices
ûû( M
.
ûûM N
Count
ûûN S
;
ûûS T
for
üü 
(
üü 
int
üü 
i
üü 
=
üü 
$num
üü 
;
üü 
i
üü  !
<
üü" #
shadowSlicesCount
üü$ 5
;
üü5 6
++
üü7 9
i
üü9 :
)
üü: ;
{
†† 
if
•• 
(
•• 
!
•• #
m_UseStructuredBuffer
•• .
&&
••/ 1
Mathf
••2 7
.
••7 8
Approximately
••8 E
(
••E F,
m_AdditionalLightsShadowParams
••F d
[
••d e
i
••e f
]
••f g
.
••g h
x
••h i
,
••i j
$num
••k o
)
••o p
)
••p q
continue
¶¶  
;
¶¶  !
int
©© 
shadowLightIndex
©© (
=
©©) *3
%m_AdditionalShadowCastingLightIndices
©©+ P
[
©©P Q
i
©©Q R
]
©©R S
;
©©S T
VisibleLight
™™  
shadowLight
™™! ,
=
™™- .
visibleLights
™™/ <
[
™™< =
shadowLightIndex
™™= M
]
™™M N
;
™™N O
ShadowSliceData
¨¨ #
shadowSliceData
¨¨$ 3
=
¨¨4 5%
m_AdditionalLightSlices
¨¨6 M
[
¨¨M N
i
¨¨N O
]
¨¨O P
;
¨¨P Q
var
ÆÆ 
settings
ÆÆ  
=
ÆÆ! "
new
ÆÆ# &#
ShadowDrawingSettings
ÆÆ' <
(
ÆÆ< =
cullResults
ÆÆ= H
,
ÆÆH I
shadowLightIndex
ÆÆJ Z
)
ÆÆZ [
;
ÆÆ[ \
Vector4
ØØ 

shadowBias
ØØ &
=
ØØ' (
ShadowUtils
ØØ) 4
.
ØØ4 5
GetShadowBias
ØØ5 B
(
ØØB C
ref
ØØC F
shadowLight
ØØG R
,
ØØR S
shadowLightIndex
ØØT d
,
ØØd e
ref
∞∞ 

shadowData
∞∞ &
,
∞∞& '
shadowSliceData
∞∞( 7
.
∞∞7 8
projectionMatrix
∞∞8 H
,
∞∞H I
shadowSliceData
∞∞J Y
.
∞∞Y Z

resolution
∞∞Z d
)
∞∞d e
;
∞∞e f
ShadowUtils
±± 
.
±±  -
SetupShadowCasterConstantBuffer
±±  ?
(
±±? @
cmd
±±@ C
,
±±C D
ref
±±E H
shadowLight
±±I T
,
±±T U

shadowBias
±±V `
)
±±` a
;
±±a b
ShadowUtils
≤≤ 
.
≤≤  
RenderShadowSlice
≤≤  1
(
≤≤1 2
cmd
≤≤2 5
,
≤≤5 6
ref
≤≤7 :
context
≤≤; B
,
≤≤B C
ref
≤≤D G
shadowSliceData
≤≤H W
,
≤≤W X
ref
≤≤Y \
settings
≤≤] e
)
≤≤e f
;
≤≤f g+
additionalLightHasSoftShadows
≥≥ 1
|=
≥≥2 4
shadowLight
≥≥5 @
.
≥≥@ A
light
≥≥A F
.
≥≥F G
shadows
≥≥G N
==
≥≥O Q
LightShadows
≥≥R ^
.
≥≥^ _
Soft
≥≥_ c
;
≥≥c d$
anyShadowSliceRenderer
¥¥ *
=
¥¥+ ,
true
¥¥- 1
;
¥¥1 2
}
µµ 
bool
ªª %
mainLightHasSoftShadows
ªª ,
=
ªª- .

shadowData
ªª/ 9
.
ªª9 :&
supportsMainLightShadows
ªª: R
&&
ªªS U
	lightData
ºº/ 8
.
ºº8 9
mainLightIndex
ºº9 G
!=
ººH J
-
ººK L
$num
ººL M
&&
ººN P
visibleLights
ΩΩ/ <
[
ΩΩ< =
	lightData
ΩΩ= F
.
ΩΩF G
mainLightIndex
ΩΩG U
]
ΩΩU V
.
ΩΩV W
light
ΩΩW \
.
ΩΩ\ ]
shadows
ΩΩ] d
==
ΩΩe g
LightShadows
ææ/ ;
.
ææ; <
Soft
ææ< @
;
ææ@ A
bool
¿¿ 
softShadows
¿¿  
=
¿¿! "

shadowData
¿¿# -
.
¿¿- .!
supportsSoftShadows
¿¿. A
&&
¿¿B D
(
¡¡# $%
mainLightHasSoftShadows
¡¡$ ;
||
¡¡< >+
additionalLightHasSoftShadows
¡¡? \
)
¡¡\ ]
;
¡¡] ^
	CoreUtils
√√ 
.
√√ 

SetKeyword
√√ $
(
√√$ %
cmd
√√% (
,
√√( )"
ShaderKeywordStrings
√√* >
.
√√> ?$
AdditionalLightShadows
√√? U
,
√√U V$
anyShadowSliceRenderer
√√W m
)
√√m n
;
√√n o
	CoreUtils
ƒƒ 
.
ƒƒ 

SetKeyword
ƒƒ $
(
ƒƒ$ %
cmd
ƒƒ% (
,
ƒƒ( )"
ShaderKeywordStrings
ƒƒ* >
.
ƒƒ> ?
SoftShadows
ƒƒ? J
,
ƒƒJ K
softShadows
ƒƒL W
)
ƒƒW X
;
ƒƒX Y
if
∆∆ 
(
∆∆ $
anyShadowSliceRenderer
∆∆ *
)
∆∆* +:
,SetupAdditionalLightsShadowReceiverConstants
«« @
(
««@ A
cmd
««A D
,
««D E
ref
««F I

shadowData
««J T
,
««T U
softShadows
««V a
)
««a b
;
««b c
}
»» 
context
   
.
   "
ExecuteCommandBuffer
   (
(
  ( )
cmd
  ) ,
)
  , -
;
  - .
CommandBufferPool
ÀÀ 
.
ÀÀ 
Release
ÀÀ %
(
ÀÀ% &
cmd
ÀÀ& )
)
ÀÀ) *
;
ÀÀ* +
}
ÃÃ 	
void
ŒŒ :
,SetupAdditionalLightsShadowReceiverConstants
ŒŒ 9
(
ŒŒ9 :
CommandBuffer
ŒŒ: G
cmd
ŒŒH K
,
ŒŒK L
ref
ŒŒM P

ShadowData
ŒŒQ [

shadowData
ŒŒ\ f
,
ŒŒf g
bool
ŒŒh l
softShadows
ŒŒm x
)
ŒŒx y
{
œœ 	
int
–– 
shadowLightsCount
–– !
=
––" #3
%m_AdditionalShadowCastingLightIndices
––$ I
.
––I J
Count
––J O
;
––O P
float
““ !
invShadowAtlasWidth
““ %
=
““& '
$num
““( ,
/
““- .

shadowData
““/ 9
.
““9 :,
additionalLightsShadowmapWidth
““: X
;
““X Y
float
”” "
invShadowAtlasHeight
”” &
=
””' (
$num
””) -
/
””. /

shadowData
””0 :
.
””: ;-
additionalLightsShadowmapHeight
””; Z
;
””Z [
float
‘‘ %
invHalfShadowAtlasWidth
‘‘ )
=
‘‘* +
$num
‘‘, 0
*
‘‘1 2!
invShadowAtlasWidth
‘‘3 F
;
‘‘F G
float
’’ &
invHalfShadowAtlasHeight
’’ *
=
’’+ ,
$num
’’- 1
*
’’2 3"
invShadowAtlasHeight
’’4 H
;
’’H I
cmd
◊◊ 
.
◊◊ 
SetGlobalTexture
◊◊  
(
◊◊  !)
m_AdditionalLightsShadowmap
◊◊! <
.
◊◊< =
id
◊◊= ?
,
◊◊? @0
"m_AdditionalLightsShadowmapTexture
◊◊A c
)
◊◊c d
;
◊◊d e
if
ŸŸ 
(
ŸŸ #
m_UseStructuredBuffer
ŸŸ %
)
ŸŸ% &
{
⁄⁄ 
NativeArray
€€ 
<
€€ 
ShaderInput
€€ '
.
€€' (

ShadowData
€€( 2
>
€€2 3
shadowBufferData
€€4 D
=
€€E F
new
€€G J
NativeArray
€€K V
<
€€V W
ShaderInput
€€W b
.
€€b c

ShadowData
€€c m
>
€€m n
(
€€n o 
shadowLightsCount€€o Ä
,€€Ä Å
	Allocator€€Ç ã
.€€ã å
Temp€€å ê
)€€ê ë
;€€ë í
for
‹‹ 
(
‹‹ 
int
‹‹ 
i
‹‹ 
=
‹‹ 
$num
‹‹ 
;
‹‹ 
i
‹‹  !
<
‹‹" #
shadowLightsCount
‹‹$ 5
;
‹‹5 6
++
‹‹7 9
i
‹‹9 :
)
‹‹: ;
{
›› 
ShaderInput
ﬁﬁ 
.
ﬁﬁ  

ShadowData
ﬁﬁ  *
data
ﬁﬁ+ /
;
ﬁﬁ/ 0
data
ﬂﬂ 
.
ﬂﬂ !
worldToShadowMatrix
ﬂﬂ ,
=
ﬂﬂ- .*
m_AdditionalLightsShadowData
ﬂﬂ/ K
[
ﬂﬂK L
i
ﬂﬂL M
]
ﬂﬂM N
.
ﬂﬂN O!
worldToShadowMatrix
ﬂﬂO b
;
ﬂﬂb c
data
‡‡ 
.
‡‡ 
shadowParams
‡‡ %
=
‡‡& '*
m_AdditionalLightsShadowData
‡‡( D
[
‡‡D E
i
‡‡E F
]
‡‡F G
.
‡‡G H
shadowParams
‡‡H T
;
‡‡T U
shadowBufferData
·· $
[
··$ %
i
··% &
]
··& '
=
··( )
data
··* .
;
··. /
}
‚‚ 
var
‰‰ 
shadowBuffer
‰‰  
=
‰‰! "

ShaderData
‰‰# -
.
‰‰- .
instance
‰‰. 6
.
‰‰6 7!
GetShadowDataBuffer
‰‰7 J
(
‰‰J K
shadowLightsCount
‰‰K \
)
‰‰\ ]
;
‰‰] ^
shadowBuffer
ÂÂ 
.
ÂÂ 
SetData
ÂÂ $
(
ÂÂ$ %
shadowBufferData
ÂÂ% 5
)
ÂÂ5 6
;
ÂÂ6 7
var
ÁÁ $
shadowIndicesMapBuffer
ÁÁ *
=
ÁÁ+ ,

ShaderData
ÁÁ- 7
.
ÁÁ7 8
instance
ÁÁ8 @
.
ÁÁ@ A$
GetShadowIndicesBuffer
ÁÁA W
(
ÁÁW X7
(m_AdditionalShadowCastingLightIndicesMapÁÁX Ä
.ÁÁÄ Å
CountÁÁÅ Ü
)ÁÁÜ á
;ÁÁá à$
shadowIndicesMapBuffer
ËË &
.
ËË& '
SetData
ËË' .
(
ËË. /6
(m_AdditionalShadowCastingLightIndicesMap
ËË/ W
,
ËËW X
$num
ËËY Z
,
ËËZ [
$num
ËË\ ]
,
ËË] ^6
(m_AdditionalShadowCastingLightIndicesMap
ÈÈ <
.
ÈÈ< =
Count
ÈÈ= B
)
ÈÈB C
;
ÈÈC D
cmd
ÎÎ 
.
ÎÎ 
SetGlobalBuffer
ÎÎ #
(
ÎÎ# $)
m_AdditionalShadowsBufferId
ÎÎ$ ?
,
ÎÎ? @
shadowBuffer
ÎÎA M
)
ÎÎM N
;
ÎÎN O
cmd
ÏÏ 
.
ÏÏ 
SetGlobalBuffer
ÏÏ #
(
ÏÏ# $*
m_AdditionalShadowsIndicesId
ÏÏ$ @
,
ÏÏ@ A$
shadowIndicesMapBuffer
ÏÏB X
)
ÏÏX Y
;
ÏÏY Z
shadowBufferData
ÌÌ  
.
ÌÌ  !
Dispose
ÌÌ! (
(
ÌÌ( )
)
ÌÌ) *
;
ÌÌ* +
}
ÓÓ 
else
ÔÔ 
{
 
cmd
ÒÒ 
.
ÒÒ "
SetGlobalMatrixArray
ÒÒ (
(
ÒÒ( )-
AdditionalShadowsConstantBuffer
ÒÒ) H
.
ÒÒH I,
_AdditionalLightsWorldToShadow
ÒÒI g
,
ÒÒg h.
m_AdditionalLightsWorldToShadowÒÒi à
)ÒÒà â
;ÒÒâ ä
cmd
ÚÚ 
.
ÚÚ "
SetGlobalVectorArray
ÚÚ (
(
ÚÚ( )-
AdditionalShadowsConstantBuffer
ÚÚ) H
.
ÚÚH I%
_AdditionalShadowParams
ÚÚI `
,
ÚÚ` a-
m_AdditionalLightsShadowParamsÚÚb Ä
)ÚÚÄ Å
;ÚÚÅ Ç
}
ÛÛ 
if
ıı 
(
ıı 
softShadows
ıı 
)
ıı 
{
ˆˆ 
if
˜˜ 
(
˜˜ +
m_SupportsBoxFilterForShadows
˜˜ 1
)
˜˜1 2
{
¯¯ 
cmd
˘˘ 
.
˘˘ 
SetGlobalVector
˘˘ '
(
˘˘' (-
AdditionalShadowsConstantBuffer
˘˘( G
.
˘˘G H&
_AdditionalShadowOffset0
˘˘H `
,
˘˘` a
new
˙˙ 
Vector4
˙˙ #
(
˙˙# $
-
˙˙$ %%
invHalfShadowAtlasWidth
˙˙% <
,
˙˙< =
-
˙˙> ?&
invHalfShadowAtlasHeight
˙˙? W
,
˙˙W X
$num
˙˙Y ]
,
˙˙] ^
$num
˙˙_ c
)
˙˙c d
)
˙˙d e
;
˙˙e f
cmd
˚˚ 
.
˚˚ 
SetGlobalVector
˚˚ '
(
˚˚' (-
AdditionalShadowsConstantBuffer
˚˚( G
.
˚˚G H&
_AdditionalShadowOffset1
˚˚H `
,
˚˚` a
new
¸¸ 
Vector4
¸¸ #
(
¸¸# $%
invHalfShadowAtlasWidth
¸¸$ ;
,
¸¸; <
-
¸¸= >&
invHalfShadowAtlasHeight
¸¸> V
,
¸¸V W
$num
¸¸X \
,
¸¸\ ]
$num
¸¸^ b
)
¸¸b c
)
¸¸c d
;
¸¸d e
cmd
˝˝ 
.
˝˝ 
SetGlobalVector
˝˝ '
(
˝˝' (-
AdditionalShadowsConstantBuffer
˝˝( G
.
˝˝G H&
_AdditionalShadowOffset2
˝˝H `
,
˝˝` a
new
˛˛ 
Vector4
˛˛ #
(
˛˛# $
-
˛˛$ %%
invHalfShadowAtlasWidth
˛˛% <
,
˛˛< =&
invHalfShadowAtlasHeight
˛˛> V
,
˛˛V W
$num
˛˛X \
,
˛˛\ ]
$num
˛˛^ b
)
˛˛b c
)
˛˛c d
;
˛˛d e
cmd
ˇˇ 
.
ˇˇ 
SetGlobalVector
ˇˇ '
(
ˇˇ' (-
AdditionalShadowsConstantBuffer
ˇˇ( G
.
ˇˇG H&
_AdditionalShadowOffset3
ˇˇH `
,
ˇˇ` a
new
ÄÄ 
Vector4
ÄÄ #
(
ÄÄ# $%
invHalfShadowAtlasWidth
ÄÄ$ ;
,
ÄÄ; <&
invHalfShadowAtlasHeight
ÄÄ= U
,
ÄÄU V
$num
ÄÄW [
,
ÄÄ[ \
$num
ÄÄ] a
)
ÄÄa b
)
ÄÄb c
;
ÄÄc d
}
ÅÅ 
cmd
ÖÖ 
.
ÖÖ 
SetGlobalVector
ÖÖ #
(
ÖÖ# $-
AdditionalShadowsConstantBuffer
ÖÖ$ C
.
ÖÖC D&
_AdditionalShadowmapSize
ÖÖD \
,
ÖÖ\ ]
new
ÖÖ^ a
Vector4
ÖÖb i
(
ÖÖi j!
invShadowAtlasWidth
ÖÖj }
,
ÖÖ} ~#
invShadowAtlasHeightÖÖ ì
,ÖÖì î

shadowData
ÜÜ 
.
ÜÜ ,
additionalLightsShadowmapWidth
ÜÜ =
,
ÜÜ= >

shadowData
ÜÜ? I
.
ÜÜI J-
additionalLightsShadowmapHeight
ÜÜJ i
)
ÜÜi j
)
ÜÜj k
;
ÜÜk l
}
áá 
}
àà 	
bool
ää '
IsValidShadowCastingLight
ää &
(
ää& '
ref
ää' *
	LightData
ää+ 4
	lightData
ää5 >
,
ää> ?
int
ää@ C
i
ääD E
)
ääE F
{
ãã 	
if
åå 
(
åå 
i
åå 
==
åå 
	lightData
åå 
.
åå 
mainLightIndex
åå -
)
åå- .
return
çç 
false
çç 
;
çç 
VisibleLight
èè 
shadowLight
èè $
=
èè% &
	lightData
èè' 0
.
èè0 1
visibleLights
èè1 >
[
èè> ?
i
èè? @
]
èè@ A
;
èèA B
if
íí 
(
íí 
shadowLight
íí 
.
íí 
	lightType
íí %
==
íí& (
	LightType
íí) 2
.
íí2 3
Point
íí3 8
||
íí9 ;
shadowLight
íí< G
.
ííG H
	lightType
ííH Q
==
ííR T
	LightType
ííU ^
.
íí^ _
Directional
íí_ j
)
ííj k
return
ìì 
false
ìì 
;
ìì 
Light
ïï 
light
ïï 
=
ïï 
shadowLight
ïï %
.
ïï% &
light
ïï& +
;
ïï+ ,
return
ññ 
light
ññ 
!=
ññ 
null
ññ  
&&
ññ! #
light
ññ$ )
.
ññ) *
shadows
ññ* 1
!=
ññ2 4
LightShadows
ññ5 A
.
ññA B
None
ññB F
&&
ññG I
!
ññJ K
Mathf
ññK P
.
ññP Q
Approximately
ññQ ^
(
ññ^ _
light
ññ_ d
.
ññd e
shadowStrength
ññe s
,
ññs t
$num
ññu y
)
ññy z
;
ññz {
}
óó 	
}
òò 
}ôô ÖÖ
∞D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\External\LibTessDotNet\PriorityHeap.cs
	namespace%% 	
UnityEngine%%
 
.%% 
Experimental%% "
.%%" #
	Rendering%%# ,
.%%, -
	Universal%%- 6
{&& 
	namespace(( 	
LibTessDotNet((
 
{)) 
internal** 
struct** 
PQHandle** 
{++ 
public,, 
static,, 
readonly,, 
int,, "
Invalid,,# *
=,,+ ,
$num,,- 7
;,,7 8
internal-- 
int-- 
_handle-- 
;-- 
}.. 
internal00 
class00 
PriorityHeap00 
<00  
TValue00  &
>00& '
where00( -
TValue00. 4
:005 6
class007 <
{11 
public22 
delegate22 
bool22 
LessOrEqual22 (
(22( )
TValue22) /
lhs220 3
,223 4
TValue225 ;
rhs22< ?
)22? @
;22@ A
	protected44 
class44 

HandleElem44 "
{55 	
internal66 
TValue66 
_key66  
;66  !
internal77 
int77 
_node77 
;77 
}88 	
private:: 
LessOrEqual:: 
_leq::  
;::  !
private;; 
int;; 
[;; 
];; 
_nodes;; 
;;; 
private<< 

HandleElem<< 
[<< 
]<< 
_handles<< %
;<<% &
private== 
int== 
_size== 
,== 
_max== 
;==  
private>> 
int>> 
	_freeList>> 
;>> 
private?? 
bool?? 
_initialized?? !
;??! "
publicAA 
boolAA 
EmptyAA 
{AA 
getAA 
{AA  !
returnAA" (
_sizeAA) .
==AA/ 1
$numAA2 3
;AA3 4
}AA5 6
}AA7 8
publicCC 
PriorityHeapCC 
(CC 
intCC 
initialSizeCC  +
,CC+ ,
LessOrEqualCC- 8
leqCC9 <
)CC< =
{DD 	
_leqEE 
=EE 
leqEE 
;EE 
_nodesGG 
=GG 
newGG 
intGG 
[GG 
initialSizeGG (
+GG) *
$numGG+ ,
]GG, -
;GG- .
_handlesHH 
=HH 
newHH 

HandleElemHH %
[HH% &
initialSizeHH& 1
+HH2 3
$numHH4 5
]HH5 6
;HH6 7
_sizeJJ 
=JJ 
$numJJ 
;JJ 
_maxKK 
=KK 
initialSizeKK 
;KK 
	_freeListLL 
=LL 
$numLL 
;LL 
_initializedMM 
=MM 
falseMM  
;MM  !
_nodesOO 
[OO 
$numOO 
]OO 
=OO 
$numOO 
;OO 
_handlesPP 
[PP 
$numPP 
]PP 
=PP 
newPP 

HandleElemPP (
{PP) *
_keyPP+ /
=PP0 1
nullPP2 6
}PP7 8
;PP8 9
}QQ 	
privateSS 
voidSS 
	FloatDownSS 
(SS 
intSS "
currSS# '
)SS' (
{TT 	
intUU 
childUU 
;UU 
intVV 
hCurrVV 
,VV 
hChildVV 
;VV 
hCurrXX 
=XX 
_nodesXX 
[XX 
currXX 
]XX  
;XX  !
whileYY 
(YY 
trueYY 
)YY 
{ZZ 
child[[ 
=[[ 
curr[[ 
<<[[ 
$num[[  !
;[[! "
if\\ 
(\\ 
child\\ 
<\\ 
_size\\ !
&&\\" $
_leq\\% )
(\\) *
_handles\\* 2
[\\2 3
_nodes\\3 9
[\\9 :
child\\: ?
+\\@ A
$num\\B C
]\\C D
]\\D E
.\\E F
_key\\F J
,\\J K
_handles\\L T
[\\T U
_nodes\\U [
[\\[ \
child\\\ a
]\\a b
]\\b c
.\\c d
_key\\d h
)\\h i
)\\i j
{]] 
++^^ 
child^^ 
;^^ 
}__ 
Debugaa 
.aa 
Assertaa 
(aa 
childaa "
<=aa# %
_maxaa& *
)aa* +
;aa+ ,
hChildcc 
=cc 
_nodescc 
[cc  
childcc  %
]cc% &
;cc& '
ifdd 
(dd 
childdd 
>dd 
_sizedd !
||dd" $
_leqdd% )
(dd) *
_handlesdd* 2
[dd2 3
hCurrdd3 8
]dd8 9
.dd9 :
_keydd: >
,dd> ?
_handlesdd@ H
[ddH I
hChildddI O
]ddO P
.ddP Q
_keyddQ U
)ddU V
)ddV W
{ee 
_nodesff 
[ff 
currff 
]ff  
=ff! "
hCurrff# (
;ff( )
_handlesgg 
[gg 
hCurrgg "
]gg" #
.gg# $
_nodegg$ )
=gg* +
currgg, 0
;gg0 1
breakhh 
;hh 
}ii 
_nodeskk 
[kk 
currkk 
]kk 
=kk 
hChildkk %
;kk% &
_handlesll 
[ll 
hChildll 
]ll  
.ll  !
_nodell! &
=ll' (
currll) -
;ll- .
currmm 
=mm 
childmm 
;mm 
}nn 
}oo 	
privateqq 
voidqq 
FloatUpqq 
(qq 
intqq  
currqq! %
)qq% &
{rr 	
intss 
parentss 
;ss 
inttt 
hCurrtt 
,tt 
hParenttt 
;tt 
hCurrvv 
=vv 
_nodesvv 
[vv 
currvv 
]vv  
;vv  !
whileww 
(ww 
trueww 
)ww 
{xx 
parentyy 
=yy 
curryy 
>>yy  
$numyy! "
;yy" #
hParentzz 
=zz 
_nodeszz  
[zz  !
parentzz! '
]zz' (
;zz( )
if{{ 
({{ 
parent{{ 
=={{ 
$num{{ 
||{{  "
_leq{{# '
({{' (
_handles{{( 0
[{{0 1
hParent{{1 8
]{{8 9
.{{9 :
_key{{: >
,{{> ?
_handles{{@ H
[{{H I
hCurr{{I N
]{{N O
.{{O P
_key{{P T
){{T U
){{U V
{|| 
_nodes}} 
[}} 
curr}} 
]}}  
=}}! "
hCurr}}# (
;}}( )
_handles~~ 
[~~ 
hCurr~~ "
]~~" #
.~~# $
_node~~$ )
=~~* +
curr~~, 0
;~~0 1
break 
; 
}
ÄÄ 
_nodes
ÅÅ 
[
ÅÅ 
curr
ÅÅ 
]
ÅÅ 
=
ÅÅ 
hParent
ÅÅ &
;
ÅÅ& '
_handles
ÇÇ 
[
ÇÇ 
hParent
ÇÇ  
]
ÇÇ  !
.
ÇÇ! "
_node
ÇÇ" '
=
ÇÇ( )
curr
ÇÇ* .
;
ÇÇ. /
curr
ÉÉ 
=
ÉÉ 
parent
ÉÉ 
;
ÉÉ 
}
ÑÑ 
}
ÖÖ 	
public
áá 
void
áá 
Init
áá 
(
áá 
)
áá 
{
àà 	
for
ââ 
(
ââ 
int
ââ 
i
ââ 
=
ââ 
_size
ââ 
;
ââ 
i
ââ  !
>=
ââ" $
$num
ââ% &
;
ââ& '
--
ââ( *
i
ââ* +
)
ââ+ ,
{
ää 
	FloatDown
ãã 
(
ãã 
i
ãã 
)
ãã 
;
ãã 
}
åå 
_initialized
çç 
=
çç 
true
çç 
;
çç  
}
éé 	
public
êê 
PQHandle
êê 
Insert
êê 
(
êê 
TValue
êê %
value
êê& +
)
êê+ ,
{
ëë 	
int
íí 
curr
íí 
=
íí 
++
íí 
_size
íí 
;
íí 
if
ìì 
(
ìì 
(
ìì 
curr
ìì 
*
ìì 
$num
ìì 
)
ìì 
>
ìì 
_max
ìì !
)
ìì! "
{
îî 
_max
ïï 
<<=
ïï 
$num
ïï 
;
ïï 
Array
ññ 
.
ññ 
Resize
ññ 
(
ññ 
ref
ññ  
_nodes
ññ! '
,
ññ' (
_max
ññ) -
+
ññ. /
$num
ññ0 1
)
ññ1 2
;
ññ2 3
Array
óó 
.
óó 
Resize
óó 
(
óó 
ref
óó  
_handles
óó! )
,
óó) *
_max
óó+ /
+
óó0 1
$num
óó2 3
)
óó3 4
;
óó4 5
}
òò 
int
öö 
free
öö 
;
öö 
if
õõ 
(
õõ 
	_freeList
õõ 
==
õõ 
$num
õõ 
)
õõ 
{
úú 
free
ùù 
=
ùù 
curr
ùù 
;
ùù 
}
ûû 
else
üü 
{
†† 
free
°° 
=
°° 
	_freeList
°°  
;
°°  !
	_freeList
¢¢ 
=
¢¢ 
_handles
¢¢ $
[
¢¢$ %
free
¢¢% )
]
¢¢) *
.
¢¢* +
_node
¢¢+ 0
;
¢¢0 1
}
££ 
_nodes
•• 
[
•• 
curr
•• 
]
•• 
=
•• 
free
•• 
;
••  
if
¶¶ 
(
¶¶ 
_handles
¶¶ 
[
¶¶ 
free
¶¶ 
]
¶¶ 
==
¶¶ !
null
¶¶" &
)
¶¶& '
{
ßß 
_handles
®® 
[
®® 
free
®® 
]
®® 
=
®®  
new
®®! $

HandleElem
®®% /
{
®®0 1
_key
®®2 6
=
®®7 8
value
®®9 >
,
®®> ?
_node
®®@ E
=
®®F G
curr
®®H L
}
®®M N
;
®®N O
}
©© 
else
™™ 
{
´´ 
_handles
¨¨ 
[
¨¨ 
free
¨¨ 
]
¨¨ 
.
¨¨ 
_node
¨¨ $
=
¨¨% &
curr
¨¨' +
;
¨¨+ ,
_handles
≠≠ 
[
≠≠ 
free
≠≠ 
]
≠≠ 
.
≠≠ 
_key
≠≠ #
=
≠≠$ %
value
≠≠& +
;
≠≠+ ,
}
ÆÆ 
if
∞∞ 
(
∞∞ 
_initialized
∞∞ 
)
∞∞ 
{
±± 
FloatUp
≤≤ 
(
≤≤ 
curr
≤≤ 
)
≤≤ 
;
≤≤ 
}
≥≥ 
Debug
µµ 
.
µµ 
Assert
µµ 
(
µµ 
free
µµ 
!=
µµ  
PQHandle
µµ! )
.
µµ) *
Invalid
µµ* 1
)
µµ1 2
;
µµ2 3
return
∂∂ 
new
∂∂ 
PQHandle
∂∂ 
{
∂∂  !
_handle
∂∂" )
=
∂∂* +
free
∂∂, 0
}
∂∂1 2
;
∂∂2 3
}
∑∑ 	
public
ππ 
TValue
ππ 

ExtractMin
ππ  
(
ππ  !
)
ππ! "
{
∫∫ 	
Debug
ªª 
.
ªª 
Assert
ªª 
(
ªª 
_initialized
ªª %
)
ªª% &
;
ªª& '
int
ΩΩ 
hMin
ΩΩ 
=
ΩΩ 
_nodes
ΩΩ 
[
ΩΩ 
$num
ΩΩ 
]
ΩΩ  
;
ΩΩ  !
TValue
ææ 
min
ææ 
=
ææ 
_handles
ææ !
[
ææ! "
hMin
ææ" &
]
ææ& '
.
ææ' (
_key
ææ( ,
;
ææ, -
if
¿¿ 
(
¿¿ 
_size
¿¿ 
>
¿¿ 
$num
¿¿ 
)
¿¿ 
{
¡¡ 
_nodes
¬¬ 
[
¬¬ 
$num
¬¬ 
]
¬¬ 
=
¬¬ 
_nodes
¬¬ "
[
¬¬" #
_size
¬¬# (
]
¬¬( )
;
¬¬) *
_handles
√√ 
[
√√ 
_nodes
√√ 
[
√√  
$num
√√  !
]
√√! "
]
√√" #
.
√√# $
_node
√√$ )
=
√√* +
$num
√√, -
;
√√- .
_handles
≈≈ 
[
≈≈ 
hMin
≈≈ 
]
≈≈ 
.
≈≈ 
_key
≈≈ #
=
≈≈$ %
null
≈≈& *
;
≈≈* +
_handles
∆∆ 
[
∆∆ 
hMin
∆∆ 
]
∆∆ 
.
∆∆ 
_node
∆∆ $
=
∆∆% &
	_freeList
∆∆' 0
;
∆∆0 1
	_freeList
«« 
=
«« 
hMin
««  
;
««  !
if
…… 
(
…… 
--
…… 
_size
…… 
>
…… 
$num
…… 
)
……  
{
   
	FloatDown
ÀÀ 
(
ÀÀ 
$num
ÀÀ 
)
ÀÀ  
;
ÀÀ  !
}
ÃÃ 
}
ÕÕ 
return
œœ 
min
œœ 
;
œœ 
}
–– 	
public
““ 
TValue
““ 
Minimum
““ 
(
““ 
)
““ 
{
”” 	
Debug
‘‘ 
.
‘‘ 
Assert
‘‘ 
(
‘‘ 
_initialized
‘‘ %
)
‘‘% &
;
‘‘& '
return
’’ 
_handles
’’ 
[
’’ 
_nodes
’’ "
[
’’" #
$num
’’# $
]
’’$ %
]
’’% &
.
’’& '
_key
’’' +
;
’’+ ,
}
÷÷ 	
public
ÿÿ 
void
ÿÿ 
Remove
ÿÿ 
(
ÿÿ 
PQHandle
ÿÿ #
handle
ÿÿ$ *
)
ÿÿ* +
{
ŸŸ 	
Debug
⁄⁄ 
.
⁄⁄ 
Assert
⁄⁄ 
(
⁄⁄ 
_initialized
⁄⁄ %
)
⁄⁄% &
;
⁄⁄& '
int
‹‹ 
hCurr
‹‹ 
=
‹‹ 
handle
‹‹ 
.
‹‹ 
_handle
‹‹ &
;
‹‹& '
Debug
›› 
.
›› 
Assert
›› 
(
›› 
hCurr
›› 
>=
›› !
$num
››" #
&&
››$ &
hCurr
››' ,
<=
››- /
_max
››0 4
&&
››5 7
_handles
››8 @
[
››@ A
hCurr
››A F
]
››F G
.
››G H
_key
››H L
!=
››M O
null
››P T
)
››T U
;
››U V
int
ﬂﬂ 
curr
ﬂﬂ 
=
ﬂﬂ 
_handles
ﬂﬂ 
[
ﬂﬂ  
hCurr
ﬂﬂ  %
]
ﬂﬂ% &
.
ﬂﬂ& '
_node
ﬂﬂ' ,
;
ﬂﬂ, -
_nodes
‡‡ 
[
‡‡ 
curr
‡‡ 
]
‡‡ 
=
‡‡ 
_nodes
‡‡ !
[
‡‡! "
_size
‡‡" '
]
‡‡' (
;
‡‡( )
_handles
·· 
[
·· 
_nodes
·· 
[
·· 
curr
··  
]
··  !
]
··! "
.
··" #
_node
··# (
=
··) *
curr
··+ /
;
··/ 0
if
„„ 
(
„„ 
curr
„„ 
<=
„„ 
--
„„ 
_size
„„ 
)
„„  
{
‰‰ 
if
ÂÂ 
(
ÂÂ 
curr
ÂÂ 
<=
ÂÂ 
$num
ÂÂ 
||
ÂÂ  
_leq
ÂÂ! %
(
ÂÂ% &
_handles
ÂÂ& .
[
ÂÂ. /
_nodes
ÂÂ/ 5
[
ÂÂ5 6
curr
ÂÂ6 :
>>
ÂÂ; =
$num
ÂÂ> ?
]
ÂÂ? @
]
ÂÂ@ A
.
ÂÂA B
_key
ÂÂB F
,
ÂÂF G
_handles
ÂÂH P
[
ÂÂP Q
_nodes
ÂÂQ W
[
ÂÂW X
curr
ÂÂX \
]
ÂÂ\ ]
]
ÂÂ] ^
.
ÂÂ^ _
_key
ÂÂ_ c
)
ÂÂc d
)
ÂÂd e
{
ÊÊ 
	FloatDown
ÁÁ 
(
ÁÁ 
curr
ÁÁ "
)
ÁÁ" #
;
ÁÁ# $
}
ËË 
else
ÈÈ 
{
ÍÍ 
FloatUp
ÎÎ 
(
ÎÎ 
curr
ÎÎ  
)
ÎÎ  !
;
ÎÎ! "
}
ÏÏ 
}
ÌÌ 
_handles
ÔÔ 
[
ÔÔ 
hCurr
ÔÔ 
]
ÔÔ 
.
ÔÔ 
_key
ÔÔ  
=
ÔÔ! "
null
ÔÔ# '
;
ÔÔ' (
_handles
 
[
 
hCurr
 
]
 
.
 
_node
 !
=
" #
	_freeList
$ -
;
- .
	_freeList
ÒÒ 
=
ÒÒ 
hCurr
ÒÒ 
;
ÒÒ 
}
ÚÚ 	
}
ÛÛ 
}ÙÙ 
}ˆˆ ∞ô
™D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\PixelPerfectCameraInternal.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
internal 
	interface 
IPixelPerfectCamera *
{ 
int 
	assetsPPU 
{ 
get 
; 
set  
;  !
}" #
int 
refResolutionX 
{ 
get  
;  !
set" %
;% &
}' (
int		 
refResolutionY		 
{		 
get		  
;		  !
set		" %
;		% &
}		' (
bool

 
	upscaleRT

 
{

 
get

 
;

 
set

 !
;

! "
}

# $
bool 
pixelSnapping 
{ 
get  
;  !
set" %
;% &
}' (
bool 

cropFrameX 
{ 
get 
; 
set "
;" #
}$ %
bool 

cropFrameY 
{ 
get 
; 
set "
;" #
}$ %
bool 
stretchFill 
{ 
get 
; 
set  #
;# $
}% &
} 
[ 
Serializable 
] 
internal 
class &
PixelPerfectCameraInternal -
:. /*
ISerializationCallbackReceiver0 N
{ 
[ 	
NonSerialized	 
] 
IPixelPerfectCamera 
m_Component '
;' (
PixelPerfectCamera #
m_SerializableComponent 2
;2 3
internal 
float 
originalOrthoSize )
;) *
internal 
bool 
hasPostProcessLayer +
;+ ,
internal 
bool 
cropFrameXAndY &
=, -
false. 3
;3 4
internal   
bool   
cropFrameXOrY   %
=  , -
false  . 3
;  3 4
internal!! 
bool!! 
useStretchFill!! &
=!!, -
false!!. 3
;!!3 4
internal"" 
int"" 
zoom"" 
="", -
$num"". /
;""/ 0
internal## 
bool## 
useOffscreenRT## &
=##, -
false##. 3
;##3 4
internal$$ 
int$$ 
offscreenRTWidth$$ (
=$$, -
$num$$. /
;$$/ 0
internal%% 
int%% 
offscreenRTHeight%% )
=%%, -
$num%%. /
;%%/ 0
internal&& 
Rect&& 
	pixelRect&& !
=&&, -
Rect&&. 2
.&&2 3
zero&&3 7
;&&7 8
internal'' 
float'' 
	orthoSize'' !
='', -
$num''. 2
;''2 3
internal(( 
float(( 
unitsPerPixel(( %
=((, -
$num((. 2
;((2 3
internal)) 
int)) 
cinemachineVCamZoom)) +
=)), -
$num)). /
;))/ 0
internal++ &
PixelPerfectCameraInternal++ +
(+++ ,
IPixelPerfectCamera++, ?
	component++@ I
)++I J
{,, 	
m_Component-- 
=-- 
	component-- #
;--# $
}.. 	
public00 
void00 
OnBeforeSerialize00 %
(00% &
)00& '
{11 	#
m_SerializableComponent22 #
=22$ %
m_Component22& 1
as222 4
PixelPerfectCamera225 G
;22G H
}33 	
public55 
void55 
OnAfterDeserialize55 &
(55& '
)55' (
{66 	
if77 
(77 #
m_SerializableComponent77 '
!=77( *
null77+ /
)77/ 0
m_Component88 
=88 #
m_SerializableComponent88 5
;885 6
}99 	
internal;; 
void;; %
CalculateCameraProperties;; /
(;;/ 0
int;;0 3
screenWidth;;4 ?
,;;? @
int;;A D
screenHeight;;E Q
);;Q R
{<< 	
int== 
	assetsPPU== 
=== 
m_Component== '
.==' (
	assetsPPU==( 1
;==1 2
int>> 
refResolutionX>> 
=>>  
m_Component>>! ,
.>>, -
refResolutionX>>- ;
;>>; <
int?? 
refResolutionY?? 
=??  
m_Component??! ,
.??, -
refResolutionY??- ;
;??; <
bool@@ 
	upscaleRT@@ 
=@@ 
m_Component@@ (
.@@( )
	upscaleRT@@) 2
;@@2 3
boolAA 
pixelSnappingAA 
=AA  
m_ComponentAA! ,
.AA, -
pixelSnappingAA- :
;AA: ;
boolBB 

cropFrameXBB 
=BB 
m_ComponentBB )
.BB) *

cropFrameXBB* 4
;BB4 5
boolCC 

cropFrameYCC 
=CC 
m_ComponentCC )
.CC) *

cropFrameYCC* 4
;CC4 5
boolDD 
stretchFillDD 
=DD 
m_ComponentDD *
.DD* +
stretchFillDD+ 6
;DD6 7
cropFrameXAndYFF 
=FF 

cropFrameYFF '
&&FF( *

cropFrameXFF+ 5
;FF5 6
cropFrameXOrYGG 
=GG 

cropFrameYGG &
||GG' )

cropFrameXGG* 4
;GG4 5
useStretchFillHH 
=HH 
cropFrameXAndYHH +
&&HH, .
stretchFillHH/ :
;HH: ;
intKK 
verticalZoomKK 
=KK 
screenHeightKK +
/KK, -
refResolutionYKK. <
;KK< =
intLL 
horizontalZoomLL 
=LL  
screenWidthLL! ,
/LL- .
refResolutionXLL/ =
;LL= >
zoomMM 
=MM 
MathMM 
.MM 
MaxMM 
(MM 
$numMM 
,MM 
MathMM #
.MM# $
MinMM$ '
(MM' (
verticalZoomMM( 4
,MM4 5
horizontalZoomMM6 D
)MMD E
)MME F
;MMF G
useOffscreenRTPP 
=PP 
falsePP "
;PP" #
offscreenRTWidthQQ 
=QQ 
$numQQ  
;QQ  !
offscreenRTHeightRR 
=RR 
$numRR  !
;RR! "
ifTT 
(TT 
cropFrameXOrYTT 
)TT 
{UU 
useOffscreenRTVV 
=VV  
trueVV! %
;VV% &
ifXX 
(XX 
!XX 
	upscaleRTXX 
)XX 
{YY 
ifZZ 
(ZZ 
cropFrameXAndYZZ &
)ZZ& '
{[[ 
offscreenRTWidth\\ (
=\\) *
zoom\\+ /
*\\0 1
refResolutionX\\2 @
;\\@ A
offscreenRTHeight]] )
=]]* +
zoom]], 0
*]]1 2
refResolutionY]]3 A
;]]A B
}^^ 
else__ 
if__ 
(__ 

cropFrameY__ '
)__' (
{`` 
offscreenRTWidthaa (
=aa) *
screenWidthaa+ 6
;aa6 7
offscreenRTHeightbb )
=bb* +
zoombb, 0
*bb1 2
refResolutionYbb3 A
;bbA B
}cc 
elsedd 
{ee 
offscreenRTWidthff (
=ff) *
zoomff+ /
*ff0 1
refResolutionXff2 @
;ff@ A
offscreenRTHeightgg )
=gg* +
screenHeightgg, 8
;gg8 9
}hh 
}ii 
elsejj 
{kk 
ifll 
(ll 
cropFrameXAndYll &
)ll& '
{mm 
offscreenRTWidthnn (
=nn) *
refResolutionXnn+ 9
;nn9 :
offscreenRTHeightoo )
=oo* +
refResolutionYoo, :
;oo: ;
}pp 
elseqq 
ifqq 
(qq 

cropFrameYqq '
)qq' (
{rr 
offscreenRTWidthss (
=ss) *
screenWidthss+ 6
/ss7 8
zoomss9 =
/ss> ?
$numss@ A
*ssB C
$numssD E
;ssE F
offscreenRTHeighttt )
=tt* +
refResolutionYtt, :
;tt: ;
}uu 
elsevv 
{ww 
offscreenRTWidthxx (
=xx) *
refResolutionXxx+ 9
;xx9 :
offscreenRTHeightyy )
=yy* +
screenHeightyy, 8
/yy9 :
zoomyy; ?
/yy@ A
$numyyB C
*yyD E
$numyyF G
;yyG H
}zz 
}{{ 
}|| 
else}} 
if}} 
(}} 
	upscaleRT}} 
&&}} !
zoom}}" &
>}}' (
$num}}) *
)}}* +
{~~ 
useOffscreenRT 
=  
true! %
;% &
offscreenRTWidth
ÄÄ  
=
ÄÄ! "
screenWidth
ÄÄ# .
/
ÄÄ/ 0
zoom
ÄÄ1 5
/
ÄÄ6 7
$num
ÄÄ8 9
*
ÄÄ: ;
$num
ÄÄ< =
;
ÄÄ= >
offscreenRTHeight
ÅÅ !
=
ÅÅ" #
screenHeight
ÅÅ$ 0
/
ÅÅ1 2
zoom
ÅÅ3 7
/
ÅÅ8 9
$num
ÅÅ: ;
*
ÅÅ< =
$num
ÅÅ> ?
;
ÅÅ? @
}
ÇÇ 
if
ÖÖ 
(
ÖÖ 
useOffscreenRT
ÖÖ 
)
ÖÖ 
{
ÜÜ 
	pixelRect
ââ 
=
ââ 
new
ââ 
Rect
ââ  $
(
ââ$ %
$num
ââ% )
,
ââ) *
$num
ââ+ /
,
ââ/ 0
offscreenRTWidth
ââ1 A
,
ââA B
offscreenRTHeight
ââC T
)
ââT U
;
ââU V
}
ää 
else
ãã 
	pixelRect
åå 
=
åå 
Rect
åå  
.
åå  !
zero
åå! %
;
åå% &
if
èè 
(
èè 

cropFrameY
èè 
)
èè 
	orthoSize
êê 
=
êê 
(
êê 
refResolutionY
êê +
*
êê, -
$num
êê. 2
)
êê2 3
/
êê4 5
	assetsPPU
êê6 ?
;
êê? @
else
ëë 
if
ëë 
(
ëë 

cropFrameX
ëë 
)
ëë  
{
íí 
float
ìì 
aspect
ìì 
=
ìì 
(
ìì  
	pixelRect
ìì  )
==
ìì* ,
Rect
ìì- 1
.
ìì1 2
zero
ìì2 6
)
ìì6 7
?
ìì8 9
(
ìì: ;
float
ìì; @
)
ìì@ A
screenWidth
ììA L
/
ììM N
screenHeight
ììO [
:
ìì\ ]
	pixelRect
ìì^ g
.
ììg h
width
ììh m
/
ììn o
	pixelRect
ììp y
.
ììy z
heightììz Ä
;ììÄ Å
	orthoSize
îî 
=
îî 
(
îî 
(
îî 
refResolutionX
îî ,
/
îî- .
aspect
îî/ 5
)
îî5 6
*
îî7 8
$num
îî9 =
)
îî= >
/
îî? @
	assetsPPU
îîA J
;
îîJ K
}
ïï 
else
ññ 
if
ññ 
(
ññ 
	upscaleRT
ññ 
&&
ññ !
zoom
ññ" &
>
ññ' (
$num
ññ) *
)
ññ* +
	orthoSize
óó 
=
óó 
(
óó 
offscreenRTHeight
óó .
*
óó/ 0
$num
óó1 5
)
óó5 6
/
óó7 8
	assetsPPU
óó9 B
;
óóB C
else
òò 
{
ôô 
float
öö 
pixelHeight
öö !
=
öö" #
(
öö$ %
	pixelRect
öö% .
==
öö/ 1
Rect
öö2 6
.
öö6 7
zero
öö7 ;
)
öö; <
?
öö= >
screenHeight
öö? K
:
ööL M
	pixelRect
ööN W
.
ööW X
height
ööX ^
;
öö^ _
	orthoSize
õõ 
=
õõ 
(
õõ 
pixelHeight
õõ (
*
õõ) *
$num
õõ+ /
)
õõ/ 0
/
õõ1 2
(
õõ3 4
zoom
õõ4 8
*
õõ9 :
	assetsPPU
õõ; D
)
õõD E
;
õõE F
}
úú 
if
üü 
(
üü 
	upscaleRT
üü 
||
üü 
(
üü 
!
üü 
	upscaleRT
üü (
&&
üü) +
pixelSnapping
üü, 9
)
üü9 :
)
üü: ;
unitsPerPixel
†† 
=
†† 
$num
††  $
/
††% &
	assetsPPU
††' 0
;
††0 1
else
°° 
unitsPerPixel
¢¢ 
=
¢¢ 
$num
¢¢  $
/
¢¢% &
(
¢¢' (
zoom
¢¢( ,
*
¢¢- .
	assetsPPU
¢¢/ 8
)
¢¢8 9
;
¢¢9 :
}
££ 	
internal
•• 
Rect
•• )
CalculateFinalBlitPixelRect
•• 1
(
••1 2
int
••2 5
screenWidth
••6 A
,
••A B
int
••C F
screenHeight
••G S
)
••S T
{
¶¶ 	
Rect
®® 
	pixelRect
®® 
=
®® 
new
®®  
Rect
®®! %
(
®®% &
)
®®& '
;
®®' (
if
™™ 
(
™™ 
useStretchFill
™™ 
)
™™ 
{
´´ 
float
≠≠ 
screenAspect
≠≠ "
=
≠≠# $
(
≠≠% &
float
≠≠& +
)
≠≠+ ,
screenWidth
≠≠, 7
/
≠≠8 9
screenHeight
≠≠: F
;
≠≠F G
float
ÆÆ 
cameraAspect
ÆÆ "
=
ÆÆ# $
(
ÆÆ% &
float
ÆÆ& +
)
ÆÆ+ ,
m_Component
ÆÆ, 7
.
ÆÆ7 8
refResolutionX
ÆÆ8 F
/
ÆÆG H
m_Component
ÆÆI T
.
ÆÆT U
refResolutionY
ÆÆU c
;
ÆÆc d
if
∞∞ 
(
∞∞ 
screenAspect
∞∞  
>
∞∞! "
cameraAspect
∞∞# /
)
∞∞/ 0
{
±± 
	pixelRect
≤≤ 
.
≤≤ 
height
≤≤ $
=
≤≤% &
screenHeight
≤≤' 3
;
≤≤3 4
	pixelRect
≥≥ 
.
≥≥ 
width
≥≥ #
=
≥≥$ %
screenHeight
≥≥& 2
*
≥≥3 4
cameraAspect
≥≥5 A
;
≥≥A B
	pixelRect
¥¥ 
.
¥¥ 
x
¥¥ 
=
¥¥  !
(
¥¥" #
screenWidth
¥¥# .
-
¥¥/ 0
(
¥¥1 2
int
¥¥2 5
)
¥¥5 6
	pixelRect
¥¥6 ?
.
¥¥? @
width
¥¥@ E
)
¥¥E F
/
¥¥G H
$num
¥¥I J
;
¥¥J K
	pixelRect
µµ 
.
µµ 
y
µµ 
=
µµ  !
$num
µµ" #
;
µµ# $
}
∂∂ 
else
∑∑ 
{
∏∏ 
	pixelRect
ππ 
.
ππ 
width
ππ #
=
ππ$ %
screenWidth
ππ& 1
;
ππ1 2
	pixelRect
∫∫ 
.
∫∫ 
height
∫∫ $
=
∫∫% &
screenWidth
∫∫' 2
/
∫∫3 4
cameraAspect
∫∫5 A
;
∫∫A B
	pixelRect
ªª 
.
ªª 
y
ªª 
=
ªª  !
(
ªª" #
screenHeight
ªª# /
-
ªª0 1
(
ªª2 3
int
ªª3 6
)
ªª6 7
	pixelRect
ªª7 @
.
ªª@ A
height
ªªA G
)
ªªG H
/
ªªI J
$num
ªªK L
;
ªªL M
	pixelRect
ºº 
.
ºº 
x
ºº 
=
ºº  !
$num
ºº" #
;
ºº# $
}
ΩΩ 
}
ææ 
else
øø 
{
¿¿ 
if
¬¬ 
(
¬¬ 
m_Component
¬¬ 
.
¬¬  
	upscaleRT
¬¬  )
)
¬¬) *
{
√√ 
	pixelRect
ƒƒ 
.
ƒƒ 
height
ƒƒ $
=
ƒƒ% &
zoom
ƒƒ' +
*
ƒƒ, -
offscreenRTHeight
ƒƒ. ?
;
ƒƒ? @
	pixelRect
≈≈ 
.
≈≈ 
width
≈≈ #
=
≈≈$ %
zoom
≈≈& *
*
≈≈+ ,
offscreenRTWidth
≈≈- =
;
≈≈= >
}
∆∆ 
else
«« 
{
»» 
	pixelRect
…… 
.
…… 
height
…… $
=
……% &
offscreenRTHeight
……' 8
;
……8 9
	pixelRect
   
.
   
width
   #
=
  $ %
offscreenRTWidth
  & 6
;
  6 7
}
ÀÀ 
	pixelRect
ÕÕ 
.
ÕÕ 
x
ÕÕ 
=
ÕÕ 
(
ÕÕ 
screenWidth
ÕÕ *
-
ÕÕ+ ,
(
ÕÕ- .
int
ÕÕ. 1
)
ÕÕ1 2
	pixelRect
ÕÕ2 ;
.
ÕÕ; <
width
ÕÕ< A
)
ÕÕA B
/
ÕÕC D
$num
ÕÕE F
;
ÕÕF G
	pixelRect
ŒŒ 
.
ŒŒ 
y
ŒŒ 
=
ŒŒ 
(
ŒŒ 
screenHeight
ŒŒ +
-
ŒŒ, -
(
ŒŒ. /
int
ŒŒ/ 2
)
ŒŒ2 3
	pixelRect
ŒŒ3 <
.
ŒŒ< =
height
ŒŒ= C
)
ŒŒC D
/
ŒŒE F
$num
ŒŒG H
;
ŒŒH I
}
œœ 
return
—— 
	pixelRect
—— 
;
—— 
}
““ 	
internal
’’ 
float
’’ )
CorrectCinemachineOrthoSize
’’ 2
(
’’2 3
float
’’3 8
targetOrthoSize
’’9 H
)
’’H I
{
÷÷ 	
float
◊◊  
correctedOrthoSize
◊◊ $
;
◊◊$ %
if
ŸŸ 
(
ŸŸ 
m_Component
ŸŸ 
.
ŸŸ 
	upscaleRT
ŸŸ %
)
ŸŸ% &
{
⁄⁄ !
cinemachineVCamZoom
€€ #
=
€€$ %
Math
€€& *
.
€€* +
Max
€€+ .
(
€€. /
$num
€€/ 0
,
€€0 1
Mathf
€€2 7
.
€€7 8

RoundToInt
€€8 B
(
€€B C
	orthoSize
€€C L
/
€€M N
targetOrthoSize
€€O ^
)
€€^ _
)
€€_ `
;
€€` a 
correctedOrthoSize
‹‹ "
=
‹‹# $
	orthoSize
‹‹% .
/
‹‹/ 0!
cinemachineVCamZoom
‹‹1 D
;
‹‹D E
}
›› 
else
ﬁﬁ 
{
ﬂﬂ !
cinemachineVCamZoom
‡‡ #
=
‡‡$ %
Math
‡‡& *
.
‡‡* +
Max
‡‡+ .
(
‡‡. /
$num
‡‡/ 0
,
‡‡0 1
Mathf
‡‡2 7
.
‡‡7 8

RoundToInt
‡‡8 B
(
‡‡B C
zoom
‡‡C G
*
‡‡H I
	orthoSize
‡‡J S
/
‡‡T U
targetOrthoSize
‡‡V e
)
‡‡e f
)
‡‡f g
;
‡‡g h 
correctedOrthoSize
·· "
=
··# $
zoom
··% )
*
··* +
	orthoSize
··, 5
/
··6 7!
cinemachineVCamZoom
··8 K
;
··K L
}
‚‚ 
if
ÂÂ 
(
ÂÂ 
!
ÂÂ 
m_Component
ÂÂ 
.
ÂÂ 
	upscaleRT
ÂÂ &
&&
ÂÂ' )
!
ÂÂ* +
m_Component
ÂÂ+ 6
.
ÂÂ6 7
pixelSnapping
ÂÂ7 D
)
ÂÂD E
unitsPerPixel
ÊÊ 
=
ÊÊ 
$num
ÊÊ  $
/
ÊÊ% &
(
ÊÊ' (!
cinemachineVCamZoom
ÊÊ( ;
*
ÊÊ< =
m_Component
ÊÊ> I
.
ÊÊI J
	assetsPPU
ÊÊJ S
)
ÊÊS T
;
ÊÊT U
return
ËË  
correctedOrthoSize
ËË %
;
ËË% &
}
ÈÈ 	
}
ÍÍ 
}ÎÎ ß3
°D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Data\PostProcessData.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[		 
Serializable		 
]		 
public

 

class

 
PostProcessData

  
:

! "
ScriptableObject

# 3
{ 
[ 	
System	 
. 
Diagnostics 
. 
CodeAnalysis (
.( )
SuppressMessage) 8
(8 9
$str9 P
,P Q
$strR Z
)Z [
][ \
internal 
class &
CreatePostProcessDataAsset 1
:2 3
EndNameEditAction4 E
{ 	
public 
override 
void  
Action! '
(' (
int( +

instanceId, 6
,6 7
string8 >
pathName? G
,G H
stringI O
resourceFileP \
)\ ]
{ 
var 
instance 
= 
CreateInstance -
<- .
PostProcessData. =
>= >
(> ?
)? @
;@ A
AssetDatabase 
. 
CreateAsset )
() *
instance* 2
,2 3
pathName4 <
)< =
;= >
ResourceReloader  
.  !
ReloadAllNullIn! 0
(0 1
instance1 9
,9 :(
UniversalRenderPipelineAsset; W
.W X
packagePathX c
)c d
;d e
	Selection 
. 
activeObject &
=' (
instance) 1
;1 2
} 
} 	
[ 	
MenuItem	 
( 
$str W
,W X
priorityY a
=b c
	CoreUtilsd m
.m n%
assetCreateMenuPriority3	n Ü
)
Ü á
]
á à
static 
void !
CreatePostProcessData )
() *
)* +
{ 	
ProjectWindowUtil 
. 1
%StartNameEditingIfProjectWindowExists C
(C D
$numD E
,E F
CreateInstanceG U
<U V&
CreatePostProcessDataAssetV p
>p q
(q r
)r s
,s t
$str	u í
,
í ì
null
î ò
,
ò ô
null
ö û
)
û ü
;
ü †
} 	
[   	
Serializable  	 
,   
ReloadGroup   "
]  " #
public!! 
sealed!! 
class!! 
ShaderResources!! +
{"" 	
[## 
Reload## 
(## 
$str## ;
)##; <
]##< =
public$$ 
Shader$$ 
	stopNanPS$$ #
;$$# $
[&& 
Reload&& 
(&& 
$str&& U
)&&U V
]&&V W
public'' 
Shader'' /
#subpixelMorphologicalAntialiasingPS'' =
;''= >
[)) 
Reload)) 
()) 
$str)) H
)))H I
]))I J
public** 
Shader** "
gaussianDepthOfFieldPS** 0
;**0 1
[,, 
Reload,, 
(,, 
$str,, E
),,E F
],,F G
public-- 
Shader-- 
bokehDepthOfFieldPS-- -
;--- .
[// 
Reload// 
(// 
$str// D
)//D E
]//E F
public00 
Shader00 
cameraMotionBlurPS00 ,
;00, -
[22 
Reload22 
(22 
$str22 D
)22D E
]22E F
public33 
Shader33 
paniniProjectionPS33 ,
;33, -
[55 
Reload55 
(55 
$str55 A
)55A B
]55B C
public66 
Shader66 
lutBuilderLdrPS66 )
;66) *
[88 
Reload88 
(88 
$str88 A
)88A B
]88B C
public99 
Shader99 
lutBuilderHdrPS99 )
;99) *
[;; 
Reload;; 
(;; 
$str;; 9
);;9 :
];;: ;
public<< 
Shader<< 
bloomPS<< !
;<<! "
[>> 
Reload>> 
(>> 
$str>> <
)>>< =
]>>= >
public?? 
Shader?? 

uberPostPS?? $
;??$ %
[AA 
ReloadAA 
(AA 
$strAA =
)AA= >
]AA> ?
publicBB 
ShaderBB 
finalPostPassPSBB )
;BB) *
}CC 	
[EE 	
SerializableEE	 
,EE 
ReloadGroupEE "
]EE" #
publicFF 
sealedFF 
classFF 
TextureResourcesFF ,
{GG 	
[II 
ReloadII 
(II 
$strII =
,II= >
$numII? @
,II@ A
$numIIB D
)IID E
]IIE F
publicJJ 
	Texture2DJJ 
[JJ 
]JJ 
blueNoise16LTexJJ .
;JJ. /
[MM 
ReloadMM 
(MM 
newMM 
[MM 
]MM 
{NN 
$strOO /
,OO/ 0
$strPP /
,PP/ 0
$strQQ 1
,QQ1 2
$strRR 1
,RR1 2
$strSS 1
,SS1 2
$strTT 1
,TT1 2
$strUU 1
,UU1 2
$strVV 1
,VV1 2
$strWW 0
,WW0 1
$strXX 0
}YY 
)YY 
]YY 
publicZZ 
	Texture2DZZ 
[ZZ 
]ZZ 
filmGrainTexZZ +
;ZZ+ ,
[\\ 
Reload\\ 
(\\ 
$str\\ /
)\\/ 0
]\\0 1
public]] 
	Texture2D]] 
smaaAreaTex]] (
;]]( )
[__ 
Reload__ 
(__ 
$str__ 1
)__1 2
]__2 3
public`` 
	Texture2D`` 
smaaSearchTex`` *
;``* +
}aa 	
publiccc 
ShaderResourcescc 
shaderscc &
;cc& '
publicdd 
TextureResourcesdd 
texturesdd  (
;dd( )
}ee 
}ff ã
úD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\Light2DShape.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
public 

sealed 
partial 
class 
Light2D  '
{ 
[ 	
SerializeField	 
] 
int '
m_ShapeLightParametricSides, G
=P Q
$numR S
;S T
[ 	
SerializeField	 
] 
float -
!m_ShapeLightParametricAngleOffset, M
=P Q
$numR V
;V W
[ 	
SerializeField	 
] 
float (
m_ShapeLightParametricRadius, H
=P Q
$numR V
;V W
[ 	
SerializeField	 
] 
float #
m_ShapeLightFalloffSize, C
=P Q
$numR W
;W X
[		 	
SerializeField			 
]		 
Vector2		  %
m_ShapeLightFalloffOffset		, E
=		P Q
Vector2		R Y
.		Y Z
zero		Z ^
;		^ _
[

 	
SerializeField

	 
]

 
Vector3

  
[

  !
]

! "
m_ShapePath

, 7
=

P Q
null

R V
;

V W
float +
m_PreviousShapeLightFalloffSize /
=< =
-> ?
$num? @
;@ A
int /
#m_PreviousShapeLightParametricSides 3
=< =
-> ?
$num? @
;@ A
float 5
)m_PreviousShapeLightParametricAngleOffset 9
=< =
-> ?
$num? @
;@ A
float 0
$m_PreviousShapeLightParametricRadius 4
=< =
-> ?
$num? @
;@ A
public 
int %
shapeLightParametricSides  9
=>@ B'
m_ShapeLightParametricSidesC ^
;^ _
public 
float +
shapeLightParametricAngleOffset  ?
=>@ B-
!m_ShapeLightParametricAngleOffsetC d
;d e
public 
float &
shapeLightParametricRadius  :
=>@ B(
m_ShapeLightParametricRadiusC _
;_ `
public 
float !
shapeLightFalloffSize  5
=>@ B#
m_ShapeLightFalloffSizeC Z
;Z [
public 
Vector2 #
shapeLightFalloffOffset  7
=>@ B%
m_ShapeLightFalloffOffsetC \
;\ ]
public 
Vector3 
[ 
] 
	shapePath  )
=>@ B
m_ShapePathC N
;N O
} 
} ù
´D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\TransparentSettingsPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
internal 
class #
TransparentSettingsPass *
:+ , 
ScriptableRenderPass- A
{ 
bool		 "
m_shouldReceiveShadows		 #
;		# $
const 
string 
m_ProfilerTag "
=# $
$str% @
;@ A
private 
static 
readonly 
ProfilingSampler  0
m_ProfilingSampler1 C
=D E
newF I
ProfilingSamplerJ Z
(Z [
m_ProfilerTag[ h
)h i
;i j
public #
TransparentSettingsPass &
(& '
RenderPassEvent' 6
evt7 :
,: ;
bool< @"
shadowReceiveSupportedA W
)W X
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @#
TransparentSettingsPass@ W
)W X
)X Y
;Y Z
renderPassEvent 
= 
evt !
;! ""
m_shouldReceiveShadows "
=# $"
shadowReceiveSupported% ;
;; <
} 	
public 
bool 
Setup 
( 
ref 
RenderingData +
renderingData, 9
)9 :
{ 	
return 
! "
m_shouldReceiveShadows *
;* +
} 	
public 
override 
void 
Execute $
($ %#
ScriptableRenderContext% <
context= D
,D E
refF I
RenderingDataJ W
renderingDataX e
)e f
{ 	
CommandBuffer   
cmd   
=   
CommandBufferPool    1
.  1 2
Get  2 5
(  5 6
)  6 7
;  7 8
using!! 
(!! 
new!! 
ProfilingScope!! %
(!!% &
cmd!!& )
,!!) *
m_ProfilingSampler!!+ =
)!!= >
)!!> ?
{"" 
	CoreUtils%% 
.%% 

SetKeyword%% $
(%%$ %
cmd%%% (
,%%( ) 
ShaderKeywordStrings%%* >
.%%> ?
MainLightShadows%%? O
,%%O P"
m_shouldReceiveShadows%%Q g
)%%g h
;%%h i
	CoreUtils&& 
.&& 

SetKeyword&& $
(&&$ %
cmd&&% (
,&&( ) 
ShaderKeywordStrings&&* >
.&&> ?#
MainLightShadowCascades&&? V
,&&V W"
m_shouldReceiveShadows&&X n
)&&n o
;&&o p
	CoreUtils'' 
.'' 

SetKeyword'' $
(''$ %
cmd''% (
,''( ) 
ShaderKeywordStrings''* >
.''> ?"
AdditionalLightShadows''? U
,''U V"
m_shouldReceiveShadows''W m
)''m n
;''n o
})) 
context,, 
.,,  
ExecuteCommandBuffer,, (
(,,( )
cmd,,) ,
),,, -
;,,- .
CommandBufferPool-- 
.-- 
Release-- %
(--% &
cmd--& )
)--) *
;--* +
}.. 	
}// 
}00 ö
©D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\UniversalAdditionalLightData.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
LWRP  $
{ 
[ 
Obsolete 
( 
$str s
,s t
trueu y
)y z
]z {
public 

class #
LWRPAdditionalLightData (
{ 
}		 
}

 
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ %
DisallowMultipleComponent 
] 
[ 
RequireComponent 
( 
typeof 
( 
Light "
)" #
)# $
]$ %
public 

class (
UniversalAdditionalLightData -
:. /
MonoBehaviour0 =
{ 
[ 	
Tooltip	 
( 
$str ;
); <
]< =
[ 	
SerializeField	 
] 
bool !
m_UsePipelineSettings 3
=4 5
true6 :
;: ;
public 
bool 
usePipelineSettings '
{ 	
get 
{ 
return !
m_UsePipelineSettings .
;. /
}0 1
set 
{ !
m_UsePipelineSettings '
=( )
value* /
;/ 0
}1 2
} 	
} 
} û*
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\ShaderUtils.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
enum5 9
ShaderPathID: F
{ 
Lit		 
,		 
	SimpleLit

 
,

 
Unlit 
, 

TerrainLit 
, 
ParticlesLit 
, 
ParticlesSimpleLit 
, 
ParticlesUnlit 
, 
BakedLit 
, 

SpeedTree7 
, 
SpeedTree7Billboard 
, 

SpeedTree8 
, 
} 
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public. 4
static5 ;
class< A
ShaderUtilsB M
{ 
static 
readonly 
string 
[ 
]  
s_ShaderPaths! .
=0 1
{ 	
$str +
,+ ,
$str 2
,2 3
$str -
,- .
$str 3
,3 4
$str 5
,5 6
$str <
,< =
$str   7
,  7 8
$str!! 1
,!!1 2
$str"" 9
,""9 :
$str## C
,##C D
$str$$ 9
,$$9 :
}%% 	
;%%	 

public'' 
static'' 
string'' 
GetShaderPath'' *
(''* +
ShaderPathID''+ 7
id''8 :
)'': ;
{(( 	
int)) 
index)) 
=)) 
()) 
int)) 
))) 
id)) 
;))  
int** 
arrayLength** 
=** 
s_ShaderPaths** +
.**+ ,
Length**, 2
;**2 3
if++ 
(++ 
arrayLength++ 
>++ 
$num++ 
&&++  "
index++# (
>=++) +
$num++, -
&&++. 0
index++1 6
<++7 8
arrayLength++9 D
)++D E
return,, 
s_ShaderPaths,, $
[,,$ %
index,,% *
],,* +
;,,+ ,
Debug.. 
... 
LogError.. 
(.. 
$str.. T
+..U V
id..W Y
+..Z [
$str..\ `
+..a b
index..c h
+..i j
$str..k n
)..n o
;..o p
return// 
$str// 
;// 
}00 	
public22 
static22 
ShaderPathID22 "
GetEnumFromPath22# 2
(222 3
string223 9
path22: >
)22> ?
{33 	
var44 
index44 
=44 
Array44 
.44 
	FindIndex44 '
(44' (
s_ShaderPaths44( 5
,445 6
m447 8
=>449 ;
m44< =
==44> @
path44A E
)44E F
;44F G
return55 
(55 
ShaderPathID55  
)55  !
index55! &
;55& '
}66 	
public88 
static88 
bool88 

IsLWShader88 %
(88% &
Shader88& ,
shader88- 3
)883 4
{99 	
return:: 
s_ShaderPaths::  
.::  !
Contains::! )
(::) *
shader::* 0
.::0 1
name::1 5
)::5 6
;::6 7
};; 	
static>> 
readonly>> 
string>> 
[>> 
]>>  
s_ShaderGUIDs>>! .
=>>/ 0
{?? 	
$str@@ .
,@@. /
$strAA .
,AA. /
$strBB .
,BB. /
$strCC .
,CC. /
$strDD .
,DD. /
$strEE .
,EE. /
$strFF .
,FF. /
$strGG .
,GG. /
$strHH .
,HH. /
$strII .
,II. /
$strJJ .
,JJ. /
}KK 	
;KK	 

internalMM 
staticMM 
stringMM 
GetShaderGUIDMM ,
(MM, -
ShaderPathIDMM- 9
idMM: <
)MM< =
{NN 	
intOO 
indexOO 
=OO 
(OO 
intOO 
)OO 
idOO 
;OO  
intPP 
arrayLengthPP 
=PP 
s_ShaderGUIDsPP +
.PP+ ,
LengthPP, 2
;PP2 3
ifQQ 
(QQ 
arrayLengthQQ 
>QQ 
$numQQ 
&&QQ  "
indexQQ# (
>=QQ) +
$numQQ, -
&&QQ. 0
indexQQ1 6
<QQ7 8
arrayLengthQQ9 D
)QQD E
returnRR 
s_ShaderGUIDsRR $
[RR$ %
indexRR% *
]RR* +
;RR+ ,
DebugTT 
.TT 
LogErrorTT 
(TT 
$strTT T
+TTU V
idTTW Y
+TTZ [
$strTT\ `
+TTa b
indexTTc h
+TTi j
$strTTk n
)TTn o
;TTo p
returnUU 
$strUU 
;UU 
}VV 	
}XX 
}YY ˙
ßD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Overrides\PaniniProjection.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
Serializable 
, 
VolumeComponentMenu &
(& '
$str' J
)J K
]K L
public 

sealed 
class 
PaniniProjection (
:) *
VolumeComponent+ :
,: ;!
IPostProcessComponent< Q
{ 
[ 	
Tooltip	 
( 
$str .
). /
]/ 0
public		 !
ClampedFloatParameter		 $
distance		% -
=		. /
new		0 3!
ClampedFloatParameter		4 I
(		I J
$num		J L
,		L M
$num		N P
,		P Q
$num		R T
)		T U
;		U V
[ 	
Tooltip	 
( 
$str 1
)1 2
]2 3
public !
ClampedFloatParameter $
	cropToFit% .
=/ 0
new1 4!
ClampedFloatParameter5 J
(J K
$numK M
,M N
$numO Q
,Q R
$numS U
)U V
;V W
public 
bool 
IsActive 
( 
) 
=> !
distance" *
.* +
value+ 0
>1 2
$num3 5
;5 6
public 
bool 
IsTileCompatible $
($ %
)% &
=>' )
false* /
;/ 0
} 
} û‹
®D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\External\LibTessDotNet\Geom.cs
	namespace%% 	
UnityEngine%%
 
.%% 
Experimental%% "
.%%" #
	Rendering%%# ,
.%%, -
	Universal%%- 6
{&& 
	namespace)) 	
LibTessDotNet))
 
{** 
internal++ 
static++ 
class++ 
Geom++ 
{,, 
public-- 
static-- 
bool-- 
IsWindingInside-- *
(--* +
WindingRule--+ 6
rule--7 ;
,--; <
int--= @
n--A B
)--B C
{.. 	
switch// 
(// 
rule// 
)// 
{00 
case11 
WindingRule11  
.11  !
EvenOdd11! (
:11( )
return22 
(22 
n22 
&22 
$num22  !
)22! "
==22# %
$num22& '
;22' (
case33 
WindingRule33  
.33  !
NonZero33! (
:33( )
return44 
n44 
!=44 
$num44  !
;44! "
case55 
WindingRule55  
.55  !
Positive55! )
:55) *
return66 
n66 
>66 
$num66  
;66  !
case77 
WindingRule77  
.77  !
Negative77! )
:77) *
return88 
n88 
<88 
$num88  
;88  !
case99 
WindingRule99  
.99  !
	AbsGeqTwo99! *
:99* +
return:: 
n:: 
>=:: 
$num::  !
||::" $
n::% &
<=::' )
-::* +
$num::+ ,
;::, -
};; 
throw<< 
new<< 
	Exception<< 
(<<  
$str<<  4
)<<4 5
;<<5 6
}== 	
public?? 
static?? 
bool?? 
VertCCW?? "
(??" #
	MeshUtils??# ,
.??, -
Vertex??- 3
u??4 5
,??5 6
	MeshUtils??7 @
.??@ A
Vertex??A G
v??H I
,??I J
	MeshUtils??K T
.??T U
Vertex??U [
w??\ ]
)??] ^
{@@ 	
returnAA 
(AA 
uAA 
.AA 
_sAA 
*AA 
(AA 
vAA 
.AA 
_tAA  
-AA! "
wAA# $
.AA$ %
_tAA% '
)AA' (
+AA) *
vAA+ ,
.AA, -
_sAA- /
*AA0 1
(AA2 3
wAA3 4
.AA4 5
_tAA5 7
-AA8 9
uAA: ;
.AA; <
_tAA< >
)AA> ?
+AA@ A
wAAB C
.AAC D
_sAAD F
*AAG H
(AAI J
uAAJ K
.AAK L
_tAAL N
-AAO P
vAAQ R
.AAR S
_tAAS U
)AAU V
)AAV W
>=AAX Z
$numAA[ _
;AA_ `
}BB 	
publicCC 
staticCC 
boolCC 
VertEqCC !
(CC! "
	MeshUtilsCC" +
.CC+ ,
VertexCC, 2
lhsCC3 6
,CC6 7
	MeshUtilsCC8 A
.CCA B
VertexCCB H
rhsCCI L
)CCL M
{DD 	
returnEE 
lhsEE 
.EE 
_sEE 
==EE 
rhsEE  
.EE  !
_sEE! #
&&EE$ &
lhsEE' *
.EE* +
_tEE+ -
==EE. 0
rhsEE1 4
.EE4 5
_tEE5 7
;EE7 8
}FF 	
publicGG 
staticGG 
boolGG 
VertLeqGG "
(GG" #
	MeshUtilsGG# ,
.GG, -
VertexGG- 3
lhsGG4 7
,GG7 8
	MeshUtilsGG9 B
.GGB C
VertexGGC I
rhsGGJ M
)GGM N
{HH 	
returnII 
(II 
lhsII 
.II 
_sII 
<II 
rhsII  
.II  !
_sII! #
)II# $
||II% '
(II( )
lhsII) ,
.II, -
_sII- /
==II0 2
rhsII3 6
.II6 7
_sII7 9
&&II: <
lhsII= @
.II@ A
_tIIA C
<=IID F
rhsIIG J
.IIJ K
_tIIK M
)IIM N
;IIN O
}JJ 	
publicWW 
staticWW 
RealWW 
EdgeEvalWW #
(WW# $
	MeshUtilsWW$ -
.WW- .
VertexWW. 4
uWW5 6
,WW6 7
	MeshUtilsWW8 A
.WWA B
VertexWWB H
vWWI J
,WWJ K
	MeshUtilsWWL U
.WWU V
VertexWWV \
wWW] ^
)WW^ _
{XX 	
DebugYY 
.YY 
AssertYY 
(YY 
VertLeqYY  
(YY  !
uYY! "
,YY" #
vYY$ %
)YY% &
&&YY' )
VertLeqYY* 1
(YY1 2
vYY2 3
,YY3 4
wYY5 6
)YY6 7
)YY7 8
;YY8 9
var[[ 
gapL[[ 
=[[ 
v[[ 
.[[ 
_s[[ 
-[[ 
u[[ 
.[[  
_s[[  "
;[[" #
var\\ 
gapR\\ 
=\\ 
w\\ 
.\\ 
_s\\ 
-\\ 
v\\ 
.\\  
_s\\  "
;\\" #
if^^ 
(^^ 
gapL^^ 
+^^ 
gapR^^ 
>^^ 
$num^^ "
)^^" #
{__ 
if`` 
(`` 
gapL`` 
<`` 
gapR`` 
)``  
{aa 
returnbb 
(bb 
vbb 
.bb 
_tbb  
-bb! "
ubb# $
.bb$ %
_tbb% '
)bb' (
+bb) *
(bb+ ,
ubb, -
.bb- .
_tbb. 0
-bb1 2
wbb3 4
.bb4 5
_tbb5 7
)bb7 8
*bb9 :
(bb; <
gapLbb< @
/bbA B
(bbC D
gapLbbD H
+bbI J
gapRbbK O
)bbO P
)bbP Q
;bbQ R
}cc 
elsedd 
{ee 
returnff 
(ff 
vff 
.ff 
_tff  
-ff! "
wff# $
.ff$ %
_tff% '
)ff' (
+ff) *
(ff+ ,
wff, -
.ff- .
_tff. 0
-ff1 2
uff3 4
.ff4 5
_tff5 7
)ff7 8
*ff9 :
(ff; <
gapRff< @
/ffA B
(ffC D
gapLffD H
+ffI J
gapRffK O
)ffO P
)ffP Q
;ffQ R
}gg 
}hh 
returnjj 
$numjj 
;jj 
}kk 	
publicrr 
staticrr 
Realrr 
EdgeSignrr #
(rr# $
	MeshUtilsrr$ -
.rr- .
Vertexrr. 4
urr5 6
,rr6 7
	MeshUtilsrr8 A
.rrA B
VertexrrB H
vrrI J
,rrJ K
	MeshUtilsrrL U
.rrU V
VertexrrV \
wrr] ^
)rr^ _
{ss 	
Debugtt 
.tt 
Asserttt 
(tt 
VertLeqtt  
(tt  !
utt! "
,tt" #
vtt$ %
)tt% &
&&tt' )
VertLeqtt* 1
(tt1 2
vtt2 3
,tt3 4
wtt5 6
)tt6 7
)tt7 8
;tt8 9
varvv 
gapLvv 
=vv 
vvv 
.vv 
_svv 
-vv 
uvv 
.vv  
_svv  "
;vv" #
varww 
gapRww 
=ww 
www 
.ww 
_sww 
-ww 
vww 
.ww  
_sww  "
;ww" #
ifyy 
(yy 
gapLyy 
+yy 
gapRyy 
>yy 
$numyy "
)yy" #
{zz 
return{{ 
({{ 
v{{ 
.{{ 
_t{{ 
-{{ 
w{{  
.{{  !
_t{{! #
){{# $
*{{% &
gapL{{' +
+{{, -
({{. /
v{{/ 0
.{{0 1
_t{{1 3
-{{4 5
u{{6 7
.{{7 8
_t{{8 :
){{: ;
*{{< =
gapR{{> B
;{{B C
}|| 
return~~ 
$num~~ 
;~~ 
} 	
public
ÅÅ 
static
ÅÅ 
bool
ÅÅ 
TransLeq
ÅÅ #
(
ÅÅ# $
	MeshUtils
ÅÅ$ -
.
ÅÅ- .
Vertex
ÅÅ. 4
lhs
ÅÅ5 8
,
ÅÅ8 9
	MeshUtils
ÅÅ: C
.
ÅÅC D
Vertex
ÅÅD J
rhs
ÅÅK N
)
ÅÅN O
{
ÇÇ 	
return
ÉÉ 
(
ÉÉ 
lhs
ÉÉ 
.
ÉÉ 
_t
ÉÉ 
<
ÉÉ 
rhs
ÉÉ  
.
ÉÉ  !
_t
ÉÉ! #
)
ÉÉ# $
||
ÉÉ% '
(
ÉÉ( )
lhs
ÉÉ) ,
.
ÉÉ, -
_t
ÉÉ- /
==
ÉÉ0 2
rhs
ÉÉ3 6
.
ÉÉ6 7
_t
ÉÉ7 9
&&
ÉÉ: <
lhs
ÉÉ= @
.
ÉÉ@ A
_s
ÉÉA C
<=
ÉÉD F
rhs
ÉÉG J
.
ÉÉJ K
_s
ÉÉK M
)
ÉÉM N
;
ÉÉN O
}
ÑÑ 	
public
ÜÜ 
static
ÜÜ 
Real
ÜÜ 
	TransEval
ÜÜ $
(
ÜÜ$ %
	MeshUtils
ÜÜ% .
.
ÜÜ. /
Vertex
ÜÜ/ 5
u
ÜÜ6 7
,
ÜÜ7 8
	MeshUtils
ÜÜ9 B
.
ÜÜB C
Vertex
ÜÜC I
v
ÜÜJ K
,
ÜÜK L
	MeshUtils
ÜÜM V
.
ÜÜV W
Vertex
ÜÜW ]
w
ÜÜ^ _
)
ÜÜ_ `
{
áá 	
Debug
àà 
.
àà 
Assert
àà 
(
àà 
TransLeq
àà !
(
àà! "
u
àà" #
,
àà# $
v
àà% &
)
àà& '
&&
àà( *
TransLeq
àà+ 3
(
àà3 4
v
àà4 5
,
àà5 6
w
àà7 8
)
àà8 9
)
àà9 :
;
àà: ;
var
ää 
gapL
ää 
=
ää 
v
ää 
.
ää 
_t
ää 
-
ää 
u
ää 
.
ää  
_t
ää  "
;
ää" #
var
ãã 
gapR
ãã 
=
ãã 
w
ãã 
.
ãã 
_t
ãã 
-
ãã 
v
ãã 
.
ãã  
_t
ãã  "
;
ãã" #
if
çç 
(
çç 
gapL
çç 
+
çç 
gapR
çç 
>
çç 
$num
çç "
)
çç" #
{
éé 
if
èè 
(
èè 
gapL
èè 
<
èè 
gapR
èè 
)
èè  
{
êê 
return
ëë 
(
ëë 
v
ëë 
.
ëë 
_s
ëë  
-
ëë! "
u
ëë# $
.
ëë$ %
_s
ëë% '
)
ëë' (
+
ëë) *
(
ëë+ ,
u
ëë, -
.
ëë- .
_s
ëë. 0
-
ëë1 2
w
ëë3 4
.
ëë4 5
_s
ëë5 7
)
ëë7 8
*
ëë9 :
(
ëë; <
gapL
ëë< @
/
ëëA B
(
ëëC D
gapL
ëëD H
+
ëëI J
gapR
ëëK O
)
ëëO P
)
ëëP Q
;
ëëQ R
}
íí 
else
ìì 
{
îî 
return
ïï 
(
ïï 
v
ïï 
.
ïï 
_s
ïï  
-
ïï! "
w
ïï# $
.
ïï$ %
_s
ïï% '
)
ïï' (
+
ïï) *
(
ïï+ ,
w
ïï, -
.
ïï- .
_s
ïï. 0
-
ïï1 2
u
ïï3 4
.
ïï4 5
_s
ïï5 7
)
ïï7 8
*
ïï9 :
(
ïï; <
gapR
ïï< @
/
ïïA B
(
ïïC D
gapL
ïïD H
+
ïïI J
gapR
ïïK O
)
ïïO P
)
ïïP Q
;
ïïQ R
}
ññ 
}
óó 
return
ôô 
$num
ôô 
;
ôô 
}
öö 	
public
úú 
static
úú 
Real
úú 
	TransSign
úú $
(
úú$ %
	MeshUtils
úú% .
.
úú. /
Vertex
úú/ 5
u
úú6 7
,
úú7 8
	MeshUtils
úú9 B
.
úúB C
Vertex
úúC I
v
úúJ K
,
úúK L
	MeshUtils
úúM V
.
úúV W
Vertex
úúW ]
w
úú^ _
)
úú_ `
{
ùù 	
Debug
ûû 
.
ûû 
Assert
ûû 
(
ûû 
TransLeq
ûû !
(
ûû! "
u
ûû" #
,
ûû# $
v
ûû% &
)
ûû& '
&&
ûû( *
TransLeq
ûû+ 3
(
ûû3 4
v
ûû4 5
,
ûû5 6
w
ûû7 8
)
ûû8 9
)
ûû9 :
;
ûû: ;
var
†† 
gapL
†† 
=
†† 
v
†† 
.
†† 
_t
†† 
-
†† 
u
†† 
.
††  
_t
††  "
;
††" #
var
°° 
gapR
°° 
=
°° 
w
°° 
.
°° 
_t
°° 
-
°° 
v
°° 
.
°°  
_t
°°  "
;
°°" #
if
££ 
(
££ 
gapL
££ 
+
££ 
gapR
££ 
>
££ 
$num
££ "
)
££" #
{
§§ 
return
•• 
(
•• 
v
•• 
.
•• 
_s
•• 
-
•• 
w
••  
.
••  !
_s
••! #
)
••# $
*
••% &
gapL
••' +
+
••, -
(
••. /
v
••/ 0
.
••0 1
_s
••1 3
-
••4 5
u
••6 7
.
••7 8
_s
••8 :
)
••: ;
*
••< =
gapR
••> B
;
••B C
}
¶¶ 
return
®® 
$num
®® 
;
®® 
}
©© 	
public
´´ 
static
´´ 
bool
´´ 
EdgeGoesLeft
´´ '
(
´´' (
	MeshUtils
´´( 1
.
´´1 2
Edge
´´2 6
e
´´7 8
)
´´8 9
{
¨¨ 	
return
≠≠ 
VertLeq
≠≠ 
(
≠≠ 
e
≠≠ 
.
≠≠ 
_Dst
≠≠ !
,
≠≠! "
e
≠≠# $
.
≠≠$ %
_Org
≠≠% )
)
≠≠) *
;
≠≠* +
}
ÆÆ 	
public
∞∞ 
static
∞∞ 
bool
∞∞ 
EdgeGoesRight
∞∞ (
(
∞∞( )
	MeshUtils
∞∞) 2
.
∞∞2 3
Edge
∞∞3 7
e
∞∞8 9
)
∞∞9 :
{
±± 	
return
≤≤ 
VertLeq
≤≤ 
(
≤≤ 
e
≤≤ 
.
≤≤ 
_Org
≤≤ !
,
≤≤! "
e
≤≤# $
.
≤≤$ %
_Dst
≤≤% )
)
≤≤) *
;
≤≤* +
}
≥≥ 	
public
µµ 
static
µµ 
Real
µµ 

VertL1dist
µµ %
(
µµ% &
	MeshUtils
µµ& /
.
µµ/ 0
Vertex
µµ0 6
u
µµ7 8
,
µµ8 9
	MeshUtils
µµ: C
.
µµC D
Vertex
µµD J
v
µµK L
)
µµL M
{
∂∂ 	
return
∑∑ 
Math
∑∑ 
.
∑∑ 
Abs
∑∑ 
(
∑∑ 
u
∑∑ 
.
∑∑ 
_s
∑∑  
-
∑∑! "
v
∑∑# $
.
∑∑$ %
_s
∑∑% '
)
∑∑' (
+
∑∑) *
Math
∑∑+ /
.
∑∑/ 0
Abs
∑∑0 3
(
∑∑3 4
u
∑∑4 5
.
∑∑5 6
_t
∑∑6 8
-
∑∑9 :
v
∑∑; <
.
∑∑< =
_t
∑∑= ?
)
∑∑? @
;
∑∑@ A
}
∏∏ 	
public
∫∫ 
static
∫∫ 
void
∫∫ 

AddWinding
∫∫ %
(
∫∫% &
	MeshUtils
∫∫& /
.
∫∫/ 0
Edge
∫∫0 4
eDst
∫∫5 9
,
∫∫9 :
	MeshUtils
∫∫; D
.
∫∫D E
Edge
∫∫E I
eSrc
∫∫J N
)
∫∫N O
{
ªª 	
eDst
ºº 
.
ºº 
_winding
ºº 
+=
ºº 
eSrc
ºº !
.
ºº! "
_winding
ºº" *
;
ºº* +
eDst
ΩΩ 
.
ΩΩ 
_Sym
ΩΩ 
.
ΩΩ 
_winding
ΩΩ 
+=
ΩΩ !
eSrc
ΩΩ" &
.
ΩΩ& '
_Sym
ΩΩ' +
.
ΩΩ+ ,
_winding
ΩΩ, 4
;
ΩΩ4 5
}
ææ 	
public
¿¿ 
static
¿¿ 
Real
¿¿ 
Interpolate
¿¿ &
(
¿¿& '
Real
¿¿' +
a
¿¿, -
,
¿¿- .
Real
¿¿/ 3
x
¿¿4 5
,
¿¿5 6
Real
¿¿7 ;
b
¿¿< =
,
¿¿= >
Real
¿¿? C
y
¿¿D E
)
¿¿E F
{
¡¡ 	
if
¬¬ 
(
¬¬ 
a
¬¬ 
<
¬¬ 
$num
¬¬ 
)
¬¬ 
{
√√ 
a
ƒƒ 
=
ƒƒ 
$num
ƒƒ 
;
ƒƒ 
}
≈≈ 
if
∆∆ 
(
∆∆ 
b
∆∆ 
<
∆∆ 
$num
∆∆ 
)
∆∆ 
{
«« 
b
»» 
=
»» 
$num
»» 
;
»» 
}
…… 
return
   
(
   
(
   
a
   
<=
   
b
   
)
   
?
   
(
    
(
    !
b
  ! "
==
  # %
$num
  & *
)
  * +
?
  , -
(
  . /
(
  / 0
x
  0 1
+
  1 2
y
  2 3
)
  3 4
/
  5 6
$num
  7 ;
)
  ; <
:
ÀÀ 
(
ÀÀ 
x
ÀÀ 
+
ÀÀ 
(
ÀÀ 
y
ÀÀ 
-
ÀÀ 
x
ÀÀ 
)
ÀÀ  
*
ÀÀ! "
(
ÀÀ# $
a
ÀÀ$ %
/
ÀÀ% &
(
ÀÀ& '
a
ÀÀ' (
+
ÀÀ( )
b
ÀÀ) *
)
ÀÀ* +
)
ÀÀ+ ,
)
ÀÀ, -
)
ÀÀ- .
:
ÃÃ 
(
ÃÃ 
y
ÃÃ 
+
ÃÃ 
(
ÃÃ 
x
ÃÃ 
-
ÃÃ 
y
ÃÃ 
)
ÃÃ  
*
ÃÃ! "
(
ÃÃ# $
b
ÃÃ$ %
/
ÃÃ% &
(
ÃÃ& '
a
ÃÃ' (
+
ÃÃ( )
b
ÃÃ) *
)
ÃÃ* +
)
ÃÃ+ ,
)
ÃÃ, -
)
ÃÃ- .
;
ÃÃ. /
}
ÕÕ 	
static
œœ 
void
œœ 
Swap
œœ 
(
œœ 
ref
œœ 
	MeshUtils
œœ &
.
œœ& '
Vertex
œœ' -
a
œœ. /
,
œœ/ 0
ref
œœ1 4
	MeshUtils
œœ5 >
.
œœ> ?
Vertex
œœ? E
b
œœF G
)
œœG H
{
–– 	
var
—— 
tmp
—— 
=
—— 
a
—— 
;
—— 
a
““ 
=
““ 
b
““ 
;
““ 
b
”” 
=
”” 
tmp
”” 
;
”” 
}
‘‘ 	
public
€€ 
static
€€ 
void
€€ 
EdgeIntersect
€€ (
(
€€( )
	MeshUtils
€€) 2
.
€€2 3
Vertex
€€3 9
o1
€€: <
,
€€< =
	MeshUtils
€€> G
.
€€G H
Vertex
€€H N
d1
€€O Q
,
€€Q R
	MeshUtils
€€S \
.
€€\ ]
Vertex
€€] c
o2
€€d f
,
€€f g
	MeshUtils
€€h q
.
€€q r
Vertex
€€r x
d2
€€y {
,
€€{ |
	MeshUtils€€} Ü
.€€Ü á
Vertex€€á ç
v€€é è
)€€è ê
{
‹‹ 	
if
‰‰ 
(
‰‰ 
!
‰‰ 
VertLeq
‰‰ 
(
‰‰ 
o1
‰‰ 
,
‰‰ 
d1
‰‰ 
)
‰‰  
)
‰‰  !
{
‰‰" #
Swap
‰‰$ (
(
‰‰( )
ref
‰‰) ,
o1
‰‰- /
,
‰‰/ 0
ref
‰‰1 4
d1
‰‰5 7
)
‰‰7 8
;
‰‰8 9
}
‰‰: ;
if
ÂÂ 
(
ÂÂ 
!
ÂÂ 
VertLeq
ÂÂ 
(
ÂÂ 
o2
ÂÂ 
,
ÂÂ 
d2
ÂÂ 
)
ÂÂ  
)
ÂÂ  !
{
ÂÂ" #
Swap
ÂÂ$ (
(
ÂÂ( )
ref
ÂÂ) ,
o2
ÂÂ- /
,
ÂÂ/ 0
ref
ÂÂ1 4
d2
ÂÂ5 7
)
ÂÂ7 8
;
ÂÂ8 9
}
ÂÂ: ;
if
ÊÊ 
(
ÊÊ 
!
ÊÊ 
VertLeq
ÊÊ 
(
ÊÊ 
o1
ÊÊ 
,
ÊÊ 
o2
ÊÊ 
)
ÊÊ  
)
ÊÊ  !
{
ÊÊ" #
Swap
ÊÊ$ (
(
ÊÊ( )
ref
ÊÊ) ,
o1
ÊÊ- /
,
ÊÊ/ 0
ref
ÊÊ1 4
o2
ÊÊ5 7
)
ÊÊ7 8
;
ÊÊ8 9
Swap
ÊÊ: >
(
ÊÊ> ?
ref
ÊÊ? B
d1
ÊÊC E
,
ÊÊE F
ref
ÊÊG J
d2
ÊÊK M
)
ÊÊM N
;
ÊÊN O
}
ÊÊP Q
if
ËË 
(
ËË 
!
ËË 
VertLeq
ËË 
(
ËË 
o2
ËË 
,
ËË 
d1
ËË 
)
ËË  
)
ËË  !
{
ÈÈ 
v
ÎÎ 
.
ÎÎ 
_s
ÎÎ 
=
ÎÎ 
(
ÎÎ 
o2
ÎÎ 
.
ÎÎ 
_s
ÎÎ 
+
ÎÎ 
d1
ÎÎ  "
.
ÎÎ" #
_s
ÎÎ# %
)
ÎÎ% &
/
ÎÎ' (
$num
ÎÎ) -
;
ÎÎ- .
}
ÏÏ 
else
ÌÌ 
if
ÌÌ 
(
ÌÌ 
VertLeq
ÌÌ 
(
ÌÌ 
d1
ÌÌ 
,
ÌÌ  
d2
ÌÌ! #
)
ÌÌ# $
)
ÌÌ$ %
{
ÓÓ 
var
 
z1
 
=
 
EdgeEval
 !
(
! "
o1
" $
,
$ %
o2
& (
,
( )
d1
* ,
)
, -
;
- .
var
ÒÒ 
z2
ÒÒ 
=
ÒÒ 
EdgeEval
ÒÒ !
(
ÒÒ! "
o2
ÒÒ" $
,
ÒÒ$ %
d1
ÒÒ& (
,
ÒÒ( )
d2
ÒÒ* ,
)
ÒÒ, -
;
ÒÒ- .
if
ÚÚ 
(
ÚÚ 
z1
ÚÚ 
+
ÚÚ 
z2
ÚÚ 
<
ÚÚ 
$num
ÚÚ "
)
ÚÚ" #
{
ÛÛ 
z1
ÙÙ 
=
ÙÙ 
-
ÙÙ 
z1
ÙÙ 
;
ÙÙ 
z2
ıı 
=
ıı 
-
ıı 
z2
ıı 
;
ıı 
}
ˆˆ 
v
˜˜ 
.
˜˜ 
_s
˜˜ 
=
˜˜ 
Interpolate
˜˜ "
(
˜˜" #
z1
˜˜# %
,
˜˜% &
o2
˜˜' )
.
˜˜) *
_s
˜˜* ,
,
˜˜, -
z2
˜˜. 0
,
˜˜0 1
d1
˜˜2 4
.
˜˜4 5
_s
˜˜5 7
)
˜˜7 8
;
˜˜8 9
}
¯¯ 
else
˘˘ 
{
˙˙ 
var
¸¸ 
z1
¸¸ 
=
¸¸ 
EdgeSign
¸¸ !
(
¸¸! "
o1
¸¸" $
,
¸¸$ %
o2
¸¸& (
,
¸¸( )
d1
¸¸* ,
)
¸¸, -
;
¸¸- .
var
˝˝ 
z2
˝˝ 
=
˝˝ 
-
˝˝ 
EdgeSign
˝˝ "
(
˝˝" #
o1
˝˝# %
,
˝˝% &
d2
˝˝' )
,
˝˝) *
d1
˝˝+ -
)
˝˝- .
;
˝˝. /
if
˛˛ 
(
˛˛ 
z1
˛˛ 
+
˛˛ 
z2
˛˛ 
<
˛˛ 
$num
˛˛ "
)
˛˛" #
{
ˇˇ 
z1
ÄÄ 
=
ÄÄ 
-
ÄÄ 
z1
ÄÄ 
;
ÄÄ 
z2
ÅÅ 
=
ÅÅ 
-
ÅÅ 
z2
ÅÅ 
;
ÅÅ 
}
ÇÇ 
v
ÉÉ 
.
ÉÉ 
_s
ÉÉ 
=
ÉÉ 
Interpolate
ÉÉ "
(
ÉÉ" #
z1
ÉÉ# %
,
ÉÉ% &
o2
ÉÉ' )
.
ÉÉ) *
_s
ÉÉ* ,
,
ÉÉ, -
z2
ÉÉ. 0
,
ÉÉ0 1
d2
ÉÉ2 4
.
ÉÉ4 5
_s
ÉÉ5 7
)
ÉÉ7 8
;
ÉÉ8 9
}
ÑÑ 
if
àà 
(
àà 
!
àà 
TransLeq
àà 
(
àà 
o1
àà 
,
àà 
d1
àà  
)
àà  !
)
àà! "
{
àà# $
Swap
àà% )
(
àà) *
ref
àà* -
o1
àà. 0
,
àà0 1
ref
àà2 5
d1
àà6 8
)
àà8 9
;
àà9 :
}
àà; <
if
ââ 
(
ââ 
!
ââ 
TransLeq
ââ 
(
ââ 
o2
ââ 
,
ââ 
d2
ââ  
)
ââ  !
)
ââ! "
{
ââ# $
Swap
ââ% )
(
ââ) *
ref
ââ* -
o2
ââ. 0
,
ââ0 1
ref
ââ2 5
d2
ââ6 8
)
ââ8 9
;
ââ9 :
}
ââ; <
if
ää 
(
ää 
!
ää 
TransLeq
ää 
(
ää 
o1
ää 
,
ää 
o2
ää  
)
ää  !
)
ää! "
{
ää# $
Swap
ää% )
(
ää) *
ref
ää* -
o1
ää. 0
,
ää0 1
ref
ää2 5
o2
ää6 8
)
ää8 9
;
ää9 :
Swap
ää; ?
(
ää? @
ref
ää@ C
d1
ääD F
,
ääF G
ref
ääH K
d2
ääL N
)
ääN O
;
ääO P
}
ääQ R
if
åå 
(
åå 
!
åå 
TransLeq
åå 
(
åå 
o2
åå 
,
åå 
d1
åå  
)
åå  !
)
åå! "
{
çç 
v
èè 
.
èè 
_t
èè 
=
èè 
(
èè 
o2
èè 
.
èè 
_t
èè 
+
èè 
d1
èè  "
.
èè" #
_t
èè# %
)
èè% &
/
èè' (
$num
èè) -
;
èè- .
}
êê 
else
ëë 
if
ëë 
(
ëë 
TransLeq
ëë 
(
ëë 
d1
ëë  
,
ëë  !
d2
ëë" $
)
ëë$ %
)
ëë% &
{
íí 
var
îî 
z1
îî 
=
îî 
	TransEval
îî "
(
îî" #
o1
îî# %
,
îî% &
o2
îî' )
,
îî) *
d1
îî+ -
)
îî- .
;
îî. /
var
ïï 
z2
ïï 
=
ïï 
	TransEval
ïï "
(
ïï" #
o2
ïï# %
,
ïï% &
d1
ïï' )
,
ïï) *
d2
ïï+ -
)
ïï- .
;
ïï. /
if
ññ 
(
ññ 
z1
ññ 
+
ññ 
z2
ññ 
<
ññ 
$num
ññ "
)
ññ" #
{
óó 
z1
òò 
=
òò 
-
òò 
z1
òò 
;
òò 
z2
ôô 
=
ôô 
-
ôô 
z2
ôô 
;
ôô 
}
öö 
v
õõ 
.
õõ 
_t
õõ 
=
õõ 
Interpolate
õõ "
(
õõ" #
z1
õõ# %
,
õõ% &
o2
õõ' )
.
õõ) *
_t
õõ* ,
,
õõ, -
z2
õõ. 0
,
õõ0 1
d1
õõ2 4
.
õõ4 5
_t
õõ5 7
)
õõ7 8
;
õõ8 9
}
úú 
else
ùù 
{
ûû 
var
†† 
z1
†† 
=
†† 
	TransSign
†† "
(
††" #
o1
††# %
,
††% &
o2
††' )
,
††) *
d1
††+ -
)
††- .
;
††. /
var
°° 
z2
°° 
=
°° 
-
°° 
	TransSign
°° #
(
°°# $
o1
°°$ &
,
°°& '
d2
°°( *
,
°°* +
d1
°°, .
)
°°. /
;
°°/ 0
if
¢¢ 
(
¢¢ 
z1
¢¢ 
+
¢¢ 
z2
¢¢ 
<
¢¢ 
$num
¢¢ "
)
¢¢" #
{
££ 
z1
§§ 
=
§§ 
-
§§ 
z1
§§ 
;
§§ 
z2
•• 
=
•• 
-
•• 
z2
•• 
;
•• 
}
¶¶ 
v
ßß 
.
ßß 
_t
ßß 
=
ßß 
Interpolate
ßß "
(
ßß" #
z1
ßß# %
,
ßß% &
o2
ßß' )
.
ßß) *
_t
ßß* ,
,
ßß, -
z2
ßß. 0
,
ßß0 1
d2
ßß2 4
.
ßß4 5
_t
ßß5 7
)
ßß7 8
;
ßß8 9
}
®® 
}
©© 	
}
™™ 
}´´ 
}≠≠ ü>
∞D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\ScreenSpaceShadowResolvePass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
public		 

class		 (
ScreenSpaceShadowResolvePass		 -
:		. / 
ScriptableRenderPass		0 D
{

 
Material (
m_ScreenSpaceShadowsMaterial -
;- .
RenderTargetHandle "
m_ScreenSpaceShadowmap 1
;1 2#
RenderTextureDescriptor %
m_RenderTextureDescriptor  9
;9 :
public (
ScreenSpaceShadowResolvePass +
(+ ,
RenderPassEvent, ;
evt< ?
,? @
MaterialA I&
screenspaceShadowsMaterialJ d
)d e
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @(
ScreenSpaceShadowResolvePass@ \
)\ ]
)] ^
;^ _(
m_ScreenSpaceShadowsMaterial (
=) *&
screenspaceShadowsMaterial+ E
;E F"
m_ScreenSpaceShadowmap "
." #
Init# '
(' (
$str( F
)F G
;G H
renderPassEvent 
= 
evt !
;! "
} 	
public 
void 
Setup 
( #
RenderTextureDescriptor 1
baseDescriptor2 @
)@ A
{ 	%
m_RenderTextureDescriptor %
=& '
baseDescriptor( 6
;6 7%
m_RenderTextureDescriptor %
.% &
depthBufferBits& 5
=6 7
$num8 9
;9 :%
m_RenderTextureDescriptor %
.% &
msaaSamples& 1
=2 3
$num4 5
;5 6%
m_RenderTextureDescriptor %
.% &
graphicsFormat& 4
=5 6
RenderingUtils7 E
.E F"
SupportsGraphicsFormatF \
(\ ]
GraphicsFormat] k
.k l
R8_UNorml t
,t u
FormatUsage	v Å
.
Å Ç
Linear
Ç à
|
â ä
FormatUsage
ã ñ
.
ñ ó
Render
ó ù
)
ù û
? 
GraphicsFormat  
.  !
R8_UNorm! )
: 
GraphicsFormat  
.  !
B8G8R8A8_UNorm! /
;/ 0
}   	
public"" 
override"" 
void"" 
	Configure"" &
(""& '
CommandBuffer""' 4
cmd""5 8
,""8 9#
RenderTextureDescriptor"": Q#
cameraTextureDescriptor""R i
)""i j
{## 	
cmd$$ 
.$$ 
GetTemporaryRT$$ 
($$ "
m_ScreenSpaceShadowmap$$ 5
.$$5 6
id$$6 8
,$$8 9%
m_RenderTextureDescriptor$$: S
,$$S T

FilterMode$$U _
.$$_ `
Bilinear$$` h
)$$h i
;$$i j"
RenderTargetIdentifier&& "'
screenSpaceOcclusionTexture&&# >
=&&? @"
m_ScreenSpaceShadowmap&&A W
.&&W X

Identifier&&X b
(&&b c
)&&c d
;&&d e
ConfigureTarget'' 
('' '
screenSpaceOcclusionTexture'' 7
)''7 8
;''8 9
ConfigureClear(( 
((( 
	ClearFlag(( $
.(($ %
All((% (
,((( )
Color((* /
.((/ 0
white((0 5
)((5 6
;((6 7
})) 	
public,, 
override,, 
void,, 
Execute,, $
(,,$ %#
ScriptableRenderContext,,% <
context,,= D
,,,D E
ref,,F I
RenderingData,,J W
renderingData,,X e
),,e f
{-- 	
if.. 
(.. (
m_ScreenSpaceShadowsMaterial.. ,
==..- /
null..0 4
)..4 5
{// 
Debug00 
.00 
LogErrorFormat00 $
(00$ %
$str	00% å
,
00å ç*
m_ScreenSpaceShadowsMaterial
00é ™
,
00™ ´
GetType
00¨ ≥
(
00≥ ¥
)
00¥ µ
.
00µ ∂
Name
00∂ ∫
)
00∫ ª
;
00ª º
return11 
;11 
}22 
if44 
(44 
renderingData44 
.44 
	lightData44 '
.44' (
mainLightIndex44( 6
==447 9
-44: ;
$num44; <
)44< =
return55 
;55 
Camera77 
camera77 
=77 
renderingData77 )
.77) *

cameraData77* 4
.774 5
camera775 ;
;77; <
CommandBuffer99 
cmd99 
=99 
CommandBufferPool99  1
.991 2
Get992 5
(995 6
)996 7
;997 8
using:: 
(:: 
new:: 
ProfilingScope:: %
(::% &
cmd::& )
,::) *
ProfilingSampler::+ ;
.::; <
Get::< ?
(::? @
URPProfileId::@ L
.::L M
ResolveShadows::M [
)::[ \
)::\ ]
)::] ^
{;; 
if<< 
(<< 
!<< 
renderingData<< "
.<<" #

cameraData<<# -
.<<- .
xr<<. 0
.<<0 1
enabled<<1 8
)<<8 9
{== 
cmd>> 
.>> %
SetViewProjectionMatrices>> 1
(>>1 2
	Matrix4x4>>2 ;
.>>; <
identity>>< D
,>>D E
	Matrix4x4>>F O
.>>O P
identity>>P X
)>>X Y
;>>Y Z
cmd?? 
.?? 
DrawMesh??  
(??  !
RenderingUtils??! /
.??/ 0
fullscreenMesh??0 >
,??> ?
	Matrix4x4??@ I
.??I J
identity??J R
,??R S(
m_ScreenSpaceShadowsMaterial??T p
)??p q
;??q r
cmd@@ 
.@@ %
SetViewProjectionMatrices@@ 1
(@@1 2
camera@@2 8
.@@8 9
worldToCameraMatrix@@9 L
,@@L M
camera@@N T
.@@T U
projectionMatrix@@U e
)@@e f
;@@f g
}AA 
elseBB 
{CC "
RenderTargetIdentifierEE *'
screenSpaceOcclusionTextureEE+ F
=EEG H"
m_ScreenSpaceShadowmapEEI _
.EE_ `

IdentifierEE` j
(EEj k
)EEk l
;EEl m
BlitFF 
(FF 
cmdFF 
,FF '
screenSpaceOcclusionTextureFF 9
,FF9 :'
screenSpaceOcclusionTextureFF; V
,FFV W(
m_ScreenSpaceShadowsMaterialFFX t
)FFt u
;FFu v
}GG 
}HH 
contextJJ 
.JJ  
ExecuteCommandBufferJJ (
(JJ( )
cmdJJ) ,
)JJ, -
;JJ- .
CommandBufferPoolKK 
.KK 
ReleaseKK %
(KK% &
cmdKK& )
)KK) *
;KK* +
}LL 	
publicOO 
overrideOO 
voidOO 
OnCameraCleanupOO ,
(OO, -
CommandBufferOO- :
cmdOO; >
)OO> ?
{PP 	
ifQQ 
(QQ 
cmdQQ 
==QQ 
nullQQ 
)QQ 
throwRR 
newRR !
ArgumentNullExceptionRR /
(RR/ 0
$strRR0 5
)RR5 6
;RR6 7
cmdTT 
.TT 
ReleaseTemporaryRTTT "
(TT" #"
m_ScreenSpaceShadowmapTT# 9
.TT9 :
idTT: <
)TT< =
;TT= >
}UU 	
}VV 
}WW ®•
©D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\External\LibTessDotNet\Sweep.cs
	namespace%% 	
UnityEngine%%
 
.%% 
Experimental%% "
.%%" #
	Rendering%%# ,
.%%, -
	Universal%%- 6
{&& 
	namespace)) 	
LibTessDotNet))
 
{** 
internal++ 
partial++ 
class++ 
Tess++ 
{,, 
internal-- 
class-- 
ActiveRegion-- #
{.. 	
internal// 
	MeshUtils// 
.// 
Edge// #
_eUp//$ (
;//( )
internal00 
Dict00 
<00 
ActiveRegion00 &
>00& '
.00' (
Node00( ,
_nodeUp00- 4
;004 5
internal11 
int11 
_windingNumber11 '
;11' (
internal22 
bool22 
_inside22 !
,22! "
	_sentinel22# ,
,22, -
_dirty22. 4
,224 5
_fixUpperEdge226 C
;22C D
}33 	
private55 
ActiveRegion55 
RegionBelow55 (
(55( )
ActiveRegion55) 5
reg556 9
)559 :
{66 	
return77 
reg77 
.77 
_nodeUp77 
.77 
_prev77 $
.77$ %
_key77% )
;77) *
}88 	
private:: 
ActiveRegion:: 
RegionAbove:: (
(::( )
ActiveRegion::) 5
reg::6 9
)::9 :
{;; 	
return<< 
reg<< 
.<< 
_nodeUp<< 
.<< 
_next<< $
.<<$ %
_key<<% )
;<<) *
}== 	
privateJJ 
boolJJ 
EdgeLeqJJ 
(JJ 
ActiveRegionJJ )
reg1JJ* .
,JJ. /
ActiveRegionJJ0 <
reg2JJ= A
)JJA B
{KK 	
varLL 
e1LL 
=LL 
reg1LL 
.LL 
_eUpLL 
;LL 
varMM 
e2MM 
=MM 
reg2MM 
.MM 
_eUpMM 
;MM 
ifOO 
(OO 
e1OO 
.OO 
_DstOO 
==OO 
_eventOO !
)OO! "
{PP 
ifQQ 
(QQ 
e2QQ 
.QQ 
_DstQQ 
==QQ 
_eventQQ %
)QQ% &
{RR 
ifUU 
(UU 
GeomUU 
.UU 
VertLeqUU $
(UU$ %
e1UU% '
.UU' (
_OrgUU( ,
,UU, -
e2UU. 0
.UU0 1
_OrgUU1 5
)UU5 6
)UU6 7
{VV 
returnWW 
GeomWW #
.WW# $
EdgeSignWW$ ,
(WW, -
e2WW- /
.WW/ 0
_DstWW0 4
,WW4 5
e1WW6 8
.WW8 9
_OrgWW9 =
,WW= >
e2WW? A
.WWA B
_OrgWWB F
)WWF G
<=WWH J
$numWWK O
;WWO P
}XX 
returnYY 
GeomYY 
.YY  
EdgeSignYY  (
(YY( )
e1YY) +
.YY+ ,
_DstYY, 0
,YY0 1
e2YY2 4
.YY4 5
_OrgYY5 9
,YY9 :
e1YY; =
.YY= >
_OrgYY> B
)YYB C
>=YYD F
$numYYG K
;YYK L
}ZZ 
return[[ 
Geom[[ 
.[[ 
EdgeSign[[ $
([[$ %
e2[[% '
.[[' (
_Dst[[( ,
,[[, -
_event[[. 4
,[[4 5
e2[[6 8
.[[8 9
_Org[[9 =
)[[= >
<=[[? A
$num[[B F
;[[F G
}\\ 
if]] 
(]] 
e2]] 
.]] 
_Dst]] 
==]] 
_event]] !
)]]! "
{^^ 
return__ 
Geom__ 
.__ 
EdgeSign__ $
(__$ %
e1__% '
.__' (
_Dst__( ,
,__, -
_event__. 4
,__4 5
e1__6 8
.__8 9
_Org__9 =
)__= >
>=__? A
$num__B F
;__F G
}`` 
varcc 
t1cc 
=cc 
Geomcc 
.cc 
EdgeEvalcc "
(cc" #
e1cc# %
.cc% &
_Dstcc& *
,cc* +
_eventcc, 2
,cc2 3
e1cc4 6
.cc6 7
_Orgcc7 ;
)cc; <
;cc< =
vardd 
t2dd 
=dd 
Geomdd 
.dd 
EdgeEvaldd "
(dd" #
e2dd# %
.dd% &
_Dstdd& *
,dd* +
_eventdd, 2
,dd2 3
e2dd4 6
.dd6 7
_Orgdd7 ;
)dd; <
;dd< =
returnee 
(ee 
t1ee 
>=ee 
t2ee 
)ee 
;ee 
}ff 	
privatehh 
voidhh 
DeleteRegionhh !
(hh! "
ActiveRegionhh" .
reghh/ 2
)hh2 3
{ii 	
ifjj 
(jj 
regjj 
.jj 
_fixUpperEdgejj !
)jj! "
{kk 
Debugoo 
.oo 
Assertoo 
(oo 
regoo  
.oo  !
_eUpoo! %
.oo% &
_windingoo& .
==oo/ 1
$numoo2 3
)oo3 4
;oo4 5
}pp 
regqq 
.qq 
_eUpqq 
.qq 
_activeRegionqq "
=qq# $
nullqq% )
;qq) *
_dictrr 
.rr 
Removerr 
(rr 
regrr 
.rr 
_nodeUprr $
)rr$ %
;rr% &
}ss 	
privatexx 
voidxx 
FixUpperEdgexx !
(xx! "
ActiveRegionxx" .
regxx/ 2
,xx2 3
	MeshUtilsxx4 =
.xx= >
Edgexx> B
newEdgexxC J
)xxJ K
{yy 	
Debugzz 
.zz 
Assertzz 
(zz 
regzz 
.zz 
_fixUpperEdgezz *
)zz* +
;zz+ ,
_mesh{{ 
.{{ 
Delete{{ 
({{ 
reg{{ 
.{{ 
_eUp{{ !
){{! "
;{{" #
reg|| 
.|| 
_fixUpperEdge|| 
=|| 
false||  %
;||% &
reg}} 
.}} 
_eUp}} 
=}} 
newEdge}} 
;}} 
newEdge~~ 
.~~ 
_activeRegion~~ !
=~~" #
reg~~$ '
;~~' (
} 	
private
ÅÅ 
ActiveRegion
ÅÅ 
TopLeftRegion
ÅÅ *
(
ÅÅ* +
ActiveRegion
ÅÅ+ 7
reg
ÅÅ8 ;
)
ÅÅ; <
{
ÇÇ 	
var
ÉÉ 
org
ÉÉ 
=
ÉÉ 
reg
ÉÉ 
.
ÉÉ 
_eUp
ÉÉ 
.
ÉÉ 
_Org
ÉÉ #
;
ÉÉ# $
do
ÜÜ 
{
ÜÜ 
reg
áá 
=
áá 
RegionAbove
áá !
(
áá! "
reg
áá" %
)
áá% &
;
áá& '
}
àà 
while
àà 
(
àà 
reg
àà 
.
àà 
_eUp
àà 
.
àà 
_Org
àà "
==
àà# %
org
àà& )
)
àà) *
;
àà* +
if
åå 
(
åå 
reg
åå 
.
åå 
_fixUpperEdge
åå !
)
åå! "
{
çç 
var
éé 
e
éé 
=
éé 
_mesh
éé 
.
éé 
Connect
éé %
(
éé% &
RegionBelow
éé& 1
(
éé1 2
reg
éé2 5
)
éé5 6
.
éé6 7
_eUp
éé7 ;
.
éé; <
_Sym
éé< @
,
éé@ A
reg
ééB E
.
ééE F
_eUp
ééF J
.
ééJ K
_Lnext
ééK Q
)
ééQ R
;
ééR S
FixUpperEdge
èè 
(
èè 
reg
èè  
,
èè  !
e
èè" #
)
èè# $
;
èè$ %
reg
êê 
=
êê 
RegionAbove
êê !
(
êê! "
reg
êê" %
)
êê% &
;
êê& '
}
ëë 
return
ìì 
reg
ìì 
;
ìì 
}
îî 	
private
ññ 
ActiveRegion
ññ 
TopRightRegion
ññ +
(
ññ+ ,
ActiveRegion
ññ, 8
reg
ññ9 <
)
ññ< =
{
óó 	
var
òò 
dst
òò 
=
òò 
reg
òò 
.
òò 
_eUp
òò 
.
òò 
_Dst
òò #
;
òò# $
do
õõ 
{
õõ 
reg
úú 
=
úú 
RegionAbove
úú !
(
úú! "
reg
úú" %
)
úú% &
;
úú& '
}
ùù 
while
ùù 
(
ùù 
reg
ùù 
.
ùù 
_eUp
ùù 
.
ùù 
_Dst
ùù "
==
ùù# %
dst
ùù& )
)
ùù) *
;
ùù* +
return
üü 
reg
üü 
;
üü 
}
†† 	
private
®® 
ActiveRegion
®® 
AddRegionBelow
®® +
(
®®+ ,
ActiveRegion
®®, 8
regAbove
®®9 A
,
®®A B
	MeshUtils
®®C L
.
®®L M
Edge
®®M Q
eNewUp
®®R X
)
®®X Y
{
©© 	
var
™™ 
regNew
™™ 
=
™™ 
new
™™ 
ActiveRegion
™™ )
(
™™) *
)
™™* +
;
™™+ ,
regNew
¨¨ 
.
¨¨ 
_eUp
¨¨ 
=
¨¨ 
eNewUp
¨¨  
;
¨¨  !
regNew
≠≠ 
.
≠≠ 
_nodeUp
≠≠ 
=
≠≠ 
_dict
≠≠ "
.
≠≠" #
InsertBefore
≠≠# /
(
≠≠/ 0
regAbove
≠≠0 8
.
≠≠8 9
_nodeUp
≠≠9 @
,
≠≠@ A
regNew
≠≠B H
)
≠≠H I
;
≠≠I J
regNew
ÆÆ 
.
ÆÆ 
_fixUpperEdge
ÆÆ  
=
ÆÆ! "
false
ÆÆ# (
;
ÆÆ( )
regNew
ØØ 
.
ØØ 
	_sentinel
ØØ 
=
ØØ 
false
ØØ $
;
ØØ$ %
regNew
∞∞ 
.
∞∞ 
_dirty
∞∞ 
=
∞∞ 
false
∞∞ !
;
∞∞! "
eNewUp
≤≤ 
.
≤≤ 
_activeRegion
≤≤  
=
≤≤! "
regNew
≤≤# )
;
≤≤) *
return
¥¥ 
regNew
¥¥ 
;
¥¥ 
}
µµ 	
private
∑∑ 
void
∑∑ 
ComputeWinding
∑∑ #
(
∑∑# $
ActiveRegion
∑∑$ 0
reg
∑∑1 4
)
∑∑4 5
{
∏∏ 	
reg
ππ 
.
ππ 
_windingNumber
ππ 
=
ππ  
RegionAbove
ππ! ,
(
ππ, -
reg
ππ- 0
)
ππ0 1
.
ππ1 2
_windingNumber
ππ2 @
+
ππA B
reg
ππC F
.
ππF G
_eUp
ππG K
.
ππK L
_winding
ππL T
;
ππT U
reg
∫∫ 
.
∫∫ 
_inside
∫∫ 
=
∫∫ 
Geom
∫∫ 
.
∫∫ 
IsWindingInside
∫∫ .
(
∫∫. /
_windingRule
∫∫/ ;
,
∫∫; <
reg
∫∫= @
.
∫∫@ A
_windingNumber
∫∫A O
)
∫∫O P
;
∫∫P Q
}
ªª 	
private
ƒƒ 
void
ƒƒ 
FinishRegion
ƒƒ !
(
ƒƒ! "
ActiveRegion
ƒƒ" .
reg
ƒƒ/ 2
)
ƒƒ2 3
{
≈≈ 	
var
∆∆ 
e
∆∆ 
=
∆∆ 
reg
∆∆ 
.
∆∆ 
_eUp
∆∆ 
;
∆∆ 
var
«« 
f
«« 
=
«« 
e
«« 
.
«« 
_Lface
«« 
;
«« 
f
…… 
.
…… 
_inside
…… 
=
…… 
reg
…… 
.
…… 
_inside
…… #
;
……# $
f
   
.
   
_anEdge
   
=
   
e
   
;
   
DeleteRegion
ÀÀ 
(
ÀÀ 
reg
ÀÀ 
)
ÀÀ 
;
ÀÀ 
}
ÃÃ 	
private
⁄⁄ 
	MeshUtils
⁄⁄ 
.
⁄⁄ 
Edge
⁄⁄ 
FinishLeftRegions
⁄⁄ 0
(
⁄⁄0 1
ActiveRegion
⁄⁄1 =
regFirst
⁄⁄> F
,
⁄⁄F G
ActiveRegion
⁄⁄H T
regLast
⁄⁄U \
)
⁄⁄\ ]
{
€€ 	
var
‹‹ 
regPrev
‹‹ 
=
‹‹ 
regFirst
‹‹ "
;
‹‹" #
var
›› 
ePrev
›› 
=
›› 
regFirst
››  
.
››  !
_eUp
››! %
;
››% &
while
ﬂﬂ 
(
ﬂﬂ 
regPrev
ﬂﬂ 
!=
ﬂﬂ 
regLast
ﬂﬂ %
)
ﬂﬂ% &
{
‡‡ 
regPrev
·· 
.
·· 
_fixUpperEdge
·· %
=
··& '
false
··( -
;
··- .
var
‚‚ 
reg
‚‚ 
=
‚‚ 
RegionBelow
‚‚ %
(
‚‚% &
regPrev
‚‚& -
)
‚‚- .
;
‚‚. /
var
„„ 
e
„„ 
=
„„ 
reg
„„ 
.
„„ 
_eUp
„„  
;
„„  !
if
‰‰ 
(
‰‰ 
e
‰‰ 
.
‰‰ 
_Org
‰‰ 
!=
‰‰ 
ePrev
‰‰ #
.
‰‰# $
_Org
‰‰$ (
)
‰‰( )
{
ÂÂ 
if
ÊÊ 
(
ÊÊ 
!
ÊÊ 
reg
ÊÊ 
.
ÊÊ 
_fixUpperEdge
ÊÊ *
)
ÊÊ* +
{
ÁÁ 
FinishRegion
ÌÌ $
(
ÌÌ$ %
regPrev
ÌÌ% ,
)
ÌÌ, -
;
ÌÌ- .
break
ÓÓ 
;
ÓÓ 
}
ÔÔ 
e
ÚÚ 
=
ÚÚ 
_mesh
ÚÚ 
.
ÚÚ 
Connect
ÚÚ %
(
ÚÚ% &
ePrev
ÚÚ& +
.
ÚÚ+ ,
_Lprev
ÚÚ, 2
,
ÚÚ2 3
e
ÚÚ4 5
.
ÚÚ5 6
_Sym
ÚÚ6 :
)
ÚÚ: ;
;
ÚÚ; <
FixUpperEdge
ÛÛ  
(
ÛÛ  !
reg
ÛÛ! $
,
ÛÛ$ %
e
ÛÛ& '
)
ÛÛ' (
;
ÛÛ( )
}
ÙÙ 
if
˜˜ 
(
˜˜ 
ePrev
˜˜ 
.
˜˜ 
_Onext
˜˜  
!=
˜˜! #
e
˜˜$ %
)
˜˜% &
{
¯¯ 
_mesh
˘˘ 
.
˘˘ 
Splice
˘˘  
(
˘˘  !
e
˘˘! "
.
˘˘" #
_Oprev
˘˘# )
,
˘˘) *
e
˘˘+ ,
)
˘˘, -
;
˘˘- .
_mesh
˙˙ 
.
˙˙ 
Splice
˙˙  
(
˙˙  !
ePrev
˙˙! &
,
˙˙& '
e
˙˙( )
)
˙˙) *
;
˙˙* +
}
˚˚ 
FinishRegion
¸¸ 
(
¸¸ 
regPrev
¸¸ $
)
¸¸$ %
;
¸¸% &
ePrev
˝˝ 
=
˝˝ 
reg
˝˝ 
.
˝˝ 
_eUp
˝˝  
;
˝˝  !
regPrev
˛˛ 
=
˛˛ 
reg
˛˛ 
;
˛˛ 
}
ˇˇ 
return
ÅÅ 
ePrev
ÅÅ 
;
ÅÅ 
}
ÇÇ 	
private
éé 
void
éé 
AddRightEdges
éé "
(
éé" #
ActiveRegion
éé# /
regUp
éé0 5
,
éé5 6
	MeshUtils
éé7 @
.
éé@ A
Edge
ééA E
eFirst
ééF L
,
ééL M
	MeshUtils
ééN W
.
ééW X
Edge
ééX \
eLast
éé] b
,
ééb c
	MeshUtils
ééd m
.
éém n
Edge
één r
eTopLeft
éés {
,
éé{ |
booléé} Å
cleanUpééÇ â
)ééâ ä
{
èè 	
bool
êê 
	firstTime
êê 
=
êê 
true
êê !
;
êê! "
var
íí 
e
íí 
=
íí 
eFirst
íí 
;
íí 
do
íí 
{
ìì 
Debug
îî 
.
îî 
Assert
îî 
(
îî 
Geom
îî !
.
îî! "
VertLeq
îî" )
(
îî) *
e
îî* +
.
îî+ ,
_Org
îî, 0
,
îî0 1
e
îî2 3
.
îî3 4
_Dst
îî4 8
)
îî8 9
)
îî9 :
;
îî: ;
AddRegionBelow
ïï 
(
ïï 
regUp
ïï $
,
ïï$ %
e
ïï& '
.
ïï' (
_Sym
ïï( ,
)
ïï, -
;
ïï- .
e
ññ 
=
ññ 
e
ññ 
.
ññ 
_Onext
ññ 
;
ññ 
}
óó 
while
óó 
(
óó 
e
óó 
!=
óó 
eLast
óó 
)
óó  
;
óó  !
if
úú 
(
úú 
eTopLeft
úú 
==
úú 
null
úú  
)
úú  !
{
ùù 
eTopLeft
ûû 
=
ûû 
RegionBelow
ûû &
(
ûû& '
regUp
ûû' ,
)
ûû, -
.
ûû- .
_eUp
ûû. 2
.
ûû2 3
_Rprev
ûû3 9
;
ûû9 :
}
üü 
ActiveRegion
°° 
regPrev
°°  
=
°°! "
regUp
°°# (
,
°°( )
reg
°°* -
;
°°- .
var
¢¢ 
ePrev
¢¢ 
=
¢¢ 
eTopLeft
¢¢  
;
¢¢  !
while
££ 
(
££ 
true
££ 
)
££ 
{
§§ 
reg
•• 
=
•• 
RegionBelow
•• !
(
••! "
regPrev
••" )
)
••) *
;
••* +
e
¶¶ 
=
¶¶ 
reg
¶¶ 
.
¶¶ 
_eUp
¶¶ 
.
¶¶ 
_Sym
¶¶ !
;
¶¶! "
if
ßß 
(
ßß 
e
ßß 
.
ßß 
_Org
ßß 
!=
ßß 
ePrev
ßß #
.
ßß# $
_Org
ßß$ (
)
ßß( )
break
ßß* /
;
ßß/ 0
if
©© 
(
©© 
e
©© 
.
©© 
_Onext
©© 
!=
©© 
ePrev
©©  %
)
©©% &
{
™™ 
_mesh
¨¨ 
.
¨¨ 
Splice
¨¨  
(
¨¨  !
e
¨¨! "
.
¨¨" #
_Oprev
¨¨# )
,
¨¨) *
e
¨¨+ ,
)
¨¨, -
;
¨¨- .
_mesh
≠≠ 
.
≠≠ 
Splice
≠≠  
(
≠≠  !
ePrev
≠≠! &
.
≠≠& '
_Oprev
≠≠' -
,
≠≠- .
e
≠≠/ 0
)
≠≠0 1
;
≠≠1 2
}
ÆÆ 
reg
∞∞ 
.
∞∞ 
_windingNumber
∞∞ "
=
∞∞# $
regPrev
∞∞% ,
.
∞∞, -
_windingNumber
∞∞- ;
-
∞∞< =
e
∞∞> ?
.
∞∞? @
_winding
∞∞@ H
;
∞∞H I
reg
±± 
.
±± 
_inside
±± 
=
±± 
Geom
±± "
.
±±" #
IsWindingInside
±±# 2
(
±±2 3
_windingRule
±±3 ?
,
±±? @
reg
±±A D
.
±±D E
_windingNumber
±±E S
)
±±S T
;
±±T U
regPrev
µµ 
.
µµ 
_dirty
µµ 
=
µµ  
true
µµ! %
;
µµ% &
if
∂∂ 
(
∂∂ 
!
∂∂ 
	firstTime
∂∂ 
&&
∂∂ !!
CheckForRightSplice
∂∂" 5
(
∂∂5 6
regPrev
∂∂6 =
)
∂∂= >
)
∂∂> ?
{
∑∑ 
Geom
∏∏ 
.
∏∏ 

AddWinding
∏∏ #
(
∏∏# $
e
∏∏$ %
,
∏∏% &
ePrev
∏∏' ,
)
∏∏, -
;
∏∏- .
DeleteRegion
ππ  
(
ππ  !
regPrev
ππ! (
)
ππ( )
;
ππ) *
_mesh
∫∫ 
.
∫∫ 
Delete
∫∫  
(
∫∫  !
ePrev
∫∫! &
)
∫∫& '
;
∫∫' (
}
ªª 
	firstTime
ºº 
=
ºº 
false
ºº !
;
ºº! "
regPrev
ΩΩ 
=
ΩΩ 
reg
ΩΩ 
;
ΩΩ 
ePrev
ææ 
=
ææ 
e
ææ 
;
ææ 
}
øø 
regPrev
¿¿ 
.
¿¿ 
_dirty
¿¿ 
=
¿¿ 
true
¿¿ !
;
¿¿! "
Debug
¡¡ 
.
¡¡ 
Assert
¡¡ 
(
¡¡ 
regPrev
¡¡  
.
¡¡  !
_windingNumber
¡¡! /
-
¡¡0 1
e
¡¡2 3
.
¡¡3 4
_winding
¡¡4 <
==
¡¡= ?
reg
¡¡@ C
.
¡¡C D
_windingNumber
¡¡D R
)
¡¡R S
;
¡¡S T
if
√√ 
(
√√ 
cleanUp
√√ 
)
√√ 
{
ƒƒ 
WalkDirtyRegions
∆∆  
(
∆∆  !
regPrev
∆∆! (
)
∆∆( )
;
∆∆) *
}
«« 
}
»» 	
private
ŒŒ 
void
ŒŒ !
SpliceMergeVertices
ŒŒ (
(
ŒŒ( )
	MeshUtils
ŒŒ) 2
.
ŒŒ2 3
Edge
ŒŒ3 7
e1
ŒŒ8 :
,
ŒŒ: ;
	MeshUtils
ŒŒ< E
.
ŒŒE F
Edge
ŒŒF J
e2
ŒŒK M
)
ŒŒM N
{
œœ 	
_mesh
–– 
.
–– 
Splice
–– 
(
–– 
e1
–– 
,
–– 
e2
–– 
)
––  
;
––  !
}
—— 	
private
⁄⁄ 
void
⁄⁄ 
VertexWeights
⁄⁄ "
(
⁄⁄" #
	MeshUtils
⁄⁄# ,
.
⁄⁄, -
Vertex
⁄⁄- 3
isect
⁄⁄4 9
,
⁄⁄9 :
	MeshUtils
⁄⁄; D
.
⁄⁄D E
Vertex
⁄⁄E K
org
⁄⁄L O
,
⁄⁄O P
	MeshUtils
⁄⁄Q Z
.
⁄⁄Z [
Vertex
⁄⁄[ a
dst
⁄⁄b e
,
⁄⁄e f
out
⁄⁄g j
Real
⁄⁄k o
w0
⁄⁄p r
,
⁄⁄r s
out
⁄⁄t w
Real
⁄⁄x |
w1
⁄⁄} 
)⁄⁄ Ä
{
€€ 	
var
‹‹ 
t1
‹‹ 
=
‹‹ 
Geom
‹‹ 
.
‹‹ 

VertL1dist
‹‹ $
(
‹‹$ %
org
‹‹% (
,
‹‹( )
isect
‹‹* /
)
‹‹/ 0
;
‹‹0 1
var
›› 
t2
›› 
=
›› 
Geom
›› 
.
›› 

VertL1dist
›› $
(
››$ %
dst
››% (
,
››( )
isect
››* /
)
››/ 0
;
››0 1
w0
ﬂﬂ 
=
ﬂﬂ 
(
ﬂﬂ 
t2
ﬂﬂ 
/
ﬂﬂ 
(
ﬂﬂ 
t1
ﬂﬂ 
+
ﬂﬂ 
t2
ﬂﬂ 
)
ﬂﬂ  
)
ﬂﬂ  !
/
ﬂﬂ" #
$num
ﬂﬂ$ (
;
ﬂﬂ( )
w1
‡‡ 
=
‡‡ 
(
‡‡ 
t1
‡‡ 
/
‡‡ 
(
‡‡ 
t1
‡‡ 
+
‡‡ 
t2
‡‡ 
)
‡‡  
)
‡‡  !
/
‡‡" #
$num
‡‡$ (
;
‡‡( )
isect
‚‚ 
.
‚‚ 
_coords
‚‚ 
.
‚‚ 
X
‚‚ 
+=
‚‚ 
w0
‚‚ !
*
‚‚" #
org
‚‚$ '
.
‚‚' (
_coords
‚‚( /
.
‚‚/ 0
X
‚‚0 1
+
‚‚2 3
w1
‚‚4 6
*
‚‚7 8
dst
‚‚9 <
.
‚‚< =
_coords
‚‚= D
.
‚‚D E
X
‚‚E F
;
‚‚F G
isect
„„ 
.
„„ 
_coords
„„ 
.
„„ 
Y
„„ 
+=
„„ 
w0
„„ !
*
„„" #
org
„„$ '
.
„„' (
_coords
„„( /
.
„„/ 0
Y
„„0 1
+
„„2 3
w1
„„4 6
*
„„7 8
dst
„„9 <
.
„„< =
_coords
„„= D
.
„„D E
Y
„„E F
;
„„F G
isect
‰‰ 
.
‰‰ 
_coords
‰‰ 
.
‰‰ 
Z
‰‰ 
+=
‰‰ 
w0
‰‰ !
*
‰‰" #
org
‰‰$ '
.
‰‰' (
_coords
‰‰( /
.
‰‰/ 0
Z
‰‰0 1
+
‰‰2 3
w1
‰‰4 6
*
‰‰7 8
dst
‰‰9 <
.
‰‰< =
_coords
‰‰= D
.
‰‰D E
Z
‰‰E F
;
‰‰F G
}
ÂÂ 	
private
ÏÏ 
void
ÏÏ 
GetIntersectData
ÏÏ %
(
ÏÏ% &
	MeshUtils
ÏÏ& /
.
ÏÏ/ 0
Vertex
ÏÏ0 6
isect
ÏÏ7 <
,
ÏÏ< =
	MeshUtils
ÏÏ> G
.
ÏÏG H
Vertex
ÏÏH N
orgUp
ÏÏO T
,
ÏÏT U
	MeshUtils
ÏÏV _
.
ÏÏ_ `
Vertex
ÏÏ` f
dstUp
ÏÏg l
,
ÏÏl m
	MeshUtils
ÏÏn w
.
ÏÏw x
Vertex
ÏÏx ~
orgLoÏÏ Ñ
,ÏÏÑ Ö
	MeshUtilsÏÏÜ è
.ÏÏè ê
VertexÏÏê ñ
dstLoÏÏó ú
)ÏÏú ù
{
ÌÌ 	
isect
ÓÓ 
.
ÓÓ 
_coords
ÓÓ 
=
ÓÓ 
Vec3
ÓÓ  
.
ÓÓ  !
Zero
ÓÓ! %
;
ÓÓ% &
Real
ÔÔ 
w0
ÔÔ 
,
ÔÔ 
w1
ÔÔ 
,
ÔÔ 
w2
ÔÔ 
,
ÔÔ 
w3
ÔÔ 
;
ÔÔ  
VertexWeights
 
(
 
isect
 
,
  
orgUp
! &
,
& '
dstUp
( -
,
- .
out
/ 2
w0
3 5
,
5 6
out
7 :
w1
; =
)
= >
;
> ?
VertexWeights
ÒÒ 
(
ÒÒ 
isect
ÒÒ 
,
ÒÒ  
orgLo
ÒÒ! &
,
ÒÒ& '
dstLo
ÒÒ( -
,
ÒÒ- .
out
ÒÒ/ 2
w2
ÒÒ3 5
,
ÒÒ5 6
out
ÒÒ7 :
w3
ÒÒ; =
)
ÒÒ= >
;
ÒÒ> ?
if
ÛÛ 
(
ÛÛ 
_combineCallback
ÛÛ  
!=
ÛÛ! #
null
ÛÛ$ (
)
ÛÛ( )
{
ÙÙ 
isect
ıı 
.
ıı 
_data
ıı 
=
ıı 
_combineCallback
ıı .
(
ıı. /
isect
ˆˆ 
.
ˆˆ 
_coords
ˆˆ !
,
ˆˆ! "
new
˜˜ 
object
˜˜ 
[
˜˜ 
]
˜˜  
{
˜˜! "
orgUp
˜˜# (
.
˜˜( )
_data
˜˜) .
,
˜˜. /
dstUp
˜˜0 5
.
˜˜5 6
_data
˜˜6 ;
,
˜˜; <
orgLo
˜˜= B
.
˜˜B C
_data
˜˜C H
,
˜˜H I
dstLo
˜˜J O
.
˜˜O P
_data
˜˜P U
}
˜˜V W
,
˜˜W X
new
¯¯ 
Real
¯¯ 
[
¯¯ 
]
¯¯ 
{
¯¯  
w0
¯¯! #
,
¯¯# $
w1
¯¯% '
,
¯¯' (
w2
¯¯) +
,
¯¯+ ,
w3
¯¯- /
}
¯¯0 1
)
˘˘ 
;
˘˘ 
}
˙˙ 
}
˚˚ 	
private
ññ 
bool
ññ !
CheckForRightSplice
ññ (
(
ññ( )
ActiveRegion
ññ) 5
regUp
ññ6 ;
)
ññ; <
{
óó 	
var
òò 
regLo
òò 
=
òò 
RegionBelow
òò #
(
òò# $
regUp
òò$ )
)
òò) *
;
òò* +
var
ôô 
eUp
ôô 
=
ôô 
regUp
ôô 
.
ôô 
_eUp
ôô  
;
ôô  !
var
öö 
eLo
öö 
=
öö 
regLo
öö 
.
öö 
_eUp
öö  
;
öö  !
if
úú 
(
úú 
Geom
úú 
.
úú 
VertLeq
úú 
(
úú 
eUp
úú  
.
úú  !
_Org
úú! %
,
úú% &
eLo
úú' *
.
úú* +
_Org
úú+ /
)
úú/ 0
)
úú0 1
{
ùù 
if
ûû 
(
ûû 
Geom
ûû 
.
ûû 
EdgeSign
ûû !
(
ûû! "
eLo
ûû" %
.
ûû% &
_Dst
ûû& *
,
ûû* +
eUp
ûû, /
.
ûû/ 0
_Org
ûû0 4
,
ûû4 5
eLo
ûû6 9
.
ûû9 :
_Org
ûû: >
)
ûû> ?
>
ûû@ A
$num
ûûB F
)
ûûF G
{
üü 
return
†† 
false
††  
;
††  !
}
°° 
if
§§ 
(
§§ 
!
§§ 
Geom
§§ 
.
§§ 
VertEq
§§  
(
§§  !
eUp
§§! $
.
§§$ %
_Org
§§% )
,
§§) *
eLo
§§+ .
.
§§. /
_Org
§§/ 3
)
§§3 4
)
§§4 5
{
•• 
_mesh
ßß 
.
ßß 
	SplitEdge
ßß #
(
ßß# $
eLo
ßß$ '
.
ßß' (
_Sym
ßß( ,
)
ßß, -
;
ßß- .
_mesh
®® 
.
®® 
Splice
®®  
(
®®  !
eUp
®®! $
,
®®$ %
eLo
®®& )
.
®®) *
_Oprev
®®* 0
)
®®0 1
;
®®1 2
regUp
©© 
.
©© 
_dirty
©©  
=
©©! "
regLo
©©# (
.
©©( )
_dirty
©©) /
=
©©0 1
true
©©2 6
;
©©6 7
}
™™ 
else
´´ 
if
´´ 
(
´´ 
eUp
´´ 
.
´´ 
_Org
´´ !
!=
´´" $
eLo
´´% (
.
´´( )
_Org
´´) -
)
´´- .
{
¨¨ 
_pq
ÆÆ 
.
ÆÆ 
Remove
ÆÆ 
(
ÆÆ 
eUp
ÆÆ "
.
ÆÆ" #
_Org
ÆÆ# '
.
ÆÆ' (
	_pqHandle
ÆÆ( 1
)
ÆÆ1 2
;
ÆÆ2 3!
SpliceMergeVertices
ØØ '
(
ØØ' (
eLo
ØØ( +
.
ØØ+ ,
_Oprev
ØØ, 2
,
ØØ2 3
eUp
ØØ4 7
)
ØØ7 8
;
ØØ8 9
}
∞∞ 
}
±± 
else
≤≤ 
{
≥≥ 
if
¥¥ 
(
¥¥ 
Geom
¥¥ 
.
¥¥ 
EdgeSign
¥¥ !
(
¥¥! "
eUp
¥¥" %
.
¥¥% &
_Dst
¥¥& *
,
¥¥* +
eLo
¥¥, /
.
¥¥/ 0
_Org
¥¥0 4
,
¥¥4 5
eUp
¥¥6 9
.
¥¥9 :
_Org
¥¥: >
)
¥¥> ?
<
¥¥@ A
$num
¥¥B F
)
¥¥F G
{
µµ 
return
∂∂ 
false
∂∂  
;
∂∂  !
}
∑∑ 
RegionAbove
∫∫ 
(
∫∫ 
regUp
∫∫ !
)
∫∫! "
.
∫∫" #
_dirty
∫∫# )
=
∫∫* +
regUp
∫∫, 1
.
∫∫1 2
_dirty
∫∫2 8
=
∫∫9 :
true
∫∫; ?
;
∫∫? @
_mesh
ªª 
.
ªª 
	SplitEdge
ªª 
(
ªª  
eUp
ªª  #
.
ªª# $
_Sym
ªª$ (
)
ªª( )
;
ªª) *
_mesh
ºº 
.
ºº 
Splice
ºº 
(
ºº 
eLo
ºº  
.
ºº  !
_Oprev
ºº! '
,
ºº' (
eUp
ºº) ,
)
ºº, -
;
ºº- .
}
ΩΩ 
return
ææ 
true
ææ 
;
ææ 
}
øø 	
private
”” 
bool
””  
CheckForLeftSplice
”” '
(
””' (
ActiveRegion
””( 4
regUp
””5 :
)
””: ;
{
‘‘ 	
var
’’ 
regLo
’’ 
=
’’ 
RegionBelow
’’ #
(
’’# $
regUp
’’$ )
)
’’) *
;
’’* +
var
÷÷ 
eUp
÷÷ 
=
÷÷ 
regUp
÷÷ 
.
÷÷ 
_eUp
÷÷  
;
÷÷  !
var
◊◊ 
eLo
◊◊ 
=
◊◊ 
regLo
◊◊ 
.
◊◊ 
_eUp
◊◊  
;
◊◊  !
Debug
ŸŸ 
.
ŸŸ 
Assert
ŸŸ 
(
ŸŸ 
!
ŸŸ 
Geom
ŸŸ 
.
ŸŸ 
VertEq
ŸŸ %
(
ŸŸ% &
eUp
ŸŸ& )
.
ŸŸ) *
_Dst
ŸŸ* .
,
ŸŸ. /
eLo
ŸŸ0 3
.
ŸŸ3 4
_Dst
ŸŸ4 8
)
ŸŸ8 9
)
ŸŸ9 :
;
ŸŸ: ;
if
€€ 
(
€€ 
Geom
€€ 
.
€€ 
VertLeq
€€ 
(
€€ 
eUp
€€  
.
€€  !
_Dst
€€! %
,
€€% &
eLo
€€' *
.
€€* +
_Dst
€€+ /
)
€€/ 0
)
€€0 1
{
‹‹ 
if
›› 
(
›› 
Geom
›› 
.
›› 
EdgeSign
›› !
(
››! "
eUp
››" %
.
››% &
_Dst
››& *
,
››* +
eLo
››, /
.
››/ 0
_Dst
››0 4
,
››4 5
eUp
››6 9
.
››9 :
_Org
››: >
)
››> ?
<
››@ A
$num
››B F
)
››F G
{
ﬁﬁ 
return
ﬂﬂ 
false
ﬂﬂ  
;
ﬂﬂ  !
}
‡‡ 
RegionAbove
„„ 
(
„„ 
regUp
„„ !
)
„„! "
.
„„" #
_dirty
„„# )
=
„„* +
regUp
„„, 1
.
„„1 2
_dirty
„„2 8
=
„„9 :
true
„„; ?
;
„„? @
var
‰‰ 
e
‰‰ 
=
‰‰ 
_mesh
‰‰ 
.
‰‰ 
	SplitEdge
‰‰ '
(
‰‰' (
eUp
‰‰( +
)
‰‰+ ,
;
‰‰, -
_mesh
ÂÂ 
.
ÂÂ 
Splice
ÂÂ 
(
ÂÂ 
eLo
ÂÂ  
.
ÂÂ  !
_Sym
ÂÂ! %
,
ÂÂ% &
e
ÂÂ' (
)
ÂÂ( )
;
ÂÂ) *
e
ÊÊ 
.
ÊÊ 
_Lface
ÊÊ 
.
ÊÊ 
_inside
ÊÊ  
=
ÊÊ! "
regUp
ÊÊ# (
.
ÊÊ( )
_inside
ÊÊ) 0
;
ÊÊ0 1
}
ÁÁ 
else
ËË 
{
ÈÈ 
if
ÍÍ 
(
ÍÍ 
Geom
ÍÍ 
.
ÍÍ 
EdgeSign
ÍÍ !
(
ÍÍ! "
eLo
ÍÍ" %
.
ÍÍ% &
_Dst
ÍÍ& *
,
ÍÍ* +
eUp
ÍÍ, /
.
ÍÍ/ 0
_Dst
ÍÍ0 4
,
ÍÍ4 5
eLo
ÍÍ6 9
.
ÍÍ9 :
_Org
ÍÍ: >
)
ÍÍ> ?
>
ÍÍ@ A
$num
ÍÍB F
)
ÍÍF G
{
ÎÎ 
return
ÏÏ 
false
ÏÏ  
;
ÏÏ  !
}
ÌÌ 
regUp
 
.
 
_dirty
 
=
 
regLo
 $
.
$ %
_dirty
% +
=
, -
true
. 2
;
2 3
var
ÒÒ 
e
ÒÒ 
=
ÒÒ 
_mesh
ÒÒ 
.
ÒÒ 
	SplitEdge
ÒÒ '
(
ÒÒ' (
eLo
ÒÒ( +
)
ÒÒ+ ,
;
ÒÒ, -
_mesh
ÚÚ 
.
ÚÚ 
Splice
ÚÚ 
(
ÚÚ 
eUp
ÚÚ  
.
ÚÚ  !
_Lnext
ÚÚ! '
,
ÚÚ' (
eLo
ÚÚ) ,
.
ÚÚ, -
_Sym
ÚÚ- 1
)
ÚÚ1 2
;
ÚÚ2 3
e
ÛÛ 
.
ÛÛ 
_Rface
ÛÛ 
.
ÛÛ 
_inside
ÛÛ  
=
ÛÛ! "
regUp
ÛÛ# (
.
ÛÛ( )
_inside
ÛÛ) 0
;
ÛÛ0 1
}
ÙÙ 
return
ıı 
true
ıı 
;
ıı 
}
ˆˆ 	
private
ÅÅ 
bool
ÅÅ 
CheckForIntersect
ÅÅ &
(
ÅÅ& '
ActiveRegion
ÅÅ' 3
regUp
ÅÅ4 9
)
ÅÅ9 :
{
ÇÇ 	
var
ÉÉ 
regLo
ÉÉ 
=
ÉÉ 
RegionBelow
ÉÉ #
(
ÉÉ# $
regUp
ÉÉ$ )
)
ÉÉ) *
;
ÉÉ* +
var
ÑÑ 
eUp
ÑÑ 
=
ÑÑ 
regUp
ÑÑ 
.
ÑÑ 
_eUp
ÑÑ  
;
ÑÑ  !
var
ÖÖ 
eLo
ÖÖ 
=
ÖÖ 
regLo
ÖÖ 
.
ÖÖ 
_eUp
ÖÖ  
;
ÖÖ  !
var
ÜÜ 
orgUp
ÜÜ 
=
ÜÜ 
eUp
ÜÜ 
.
ÜÜ 
_Org
ÜÜ  
;
ÜÜ  !
var
áá 
orgLo
áá 
=
áá 
eLo
áá 
.
áá 
_Org
áá  
;
áá  !
var
àà 
dstUp
àà 
=
àà 
eUp
àà 
.
àà 
_Dst
àà  
;
àà  !
var
ââ 
dstLo
ââ 
=
ââ 
eLo
ââ 
.
ââ 
_Dst
ââ  
;
ââ  !
Debug
ãã 
.
ãã 
Assert
ãã 
(
ãã 
!
ãã 
Geom
ãã 
.
ãã 
VertEq
ãã %
(
ãã% &
dstLo
ãã& +
,
ãã+ ,
dstUp
ãã- 2
)
ãã2 3
)
ãã3 4
;
ãã4 5
Debug
åå 
.
åå 
Assert
åå 
(
åå 
Geom
åå 
.
åå 
EdgeSign
åå &
(
åå& '
dstUp
åå' ,
,
åå, -
_event
åå. 4
,
åå4 5
orgUp
åå6 ;
)
åå; <
<=
åå= ?
$num
åå@ D
)
ååD E
;
ååE F
Debug
çç 
.
çç 
Assert
çç 
(
çç 
Geom
çç 
.
çç 
EdgeSign
çç &
(
çç& '
dstLo
çç' ,
,
çç, -
_event
çç. 4
,
çç4 5
orgLo
çç6 ;
)
çç; <
>=
çç= ?
$num
çç@ D
)
ççD E
;
ççE F
Debug
éé 
.
éé 
Assert
éé 
(
éé 
orgUp
éé 
!=
éé !
_event
éé" (
&&
éé) +
orgLo
éé, 1
!=
éé2 4
_event
éé5 ;
)
éé; <
;
éé< =
Debug
èè 
.
èè 
Assert
èè 
(
èè 
!
èè 
regUp
èè 
.
èè  
_fixUpperEdge
èè  -
&&
èè. 0
!
èè1 2
regLo
èè2 7
.
èè7 8
_fixUpperEdge
èè8 E
)
èèE F
;
èèF G
if
ëë 
(
ëë 
orgUp
ëë 
==
ëë 
orgLo
ëë 
)
ëë  
{
íí 
return
îî 
false
îî 
;
îî 
}
ïï 
var
óó 
tMinUp
óó 
=
óó 
Math
óó 
.
óó 
Min
óó !
(
óó! "
orgUp
óó" '
.
óó' (
_t
óó( *
,
óó* +
dstUp
óó, 1
.
óó1 2
_t
óó2 4
)
óó4 5
;
óó5 6
var
òò 
tMaxLo
òò 
=
òò 
Math
òò 
.
òò 
Max
òò !
(
òò! "
orgLo
òò" '
.
òò' (
_t
òò( *
,
òò* +
dstLo
òò, 1
.
òò1 2
_t
òò2 4
)
òò4 5
;
òò5 6
if
ôô 
(
ôô 
tMinUp
ôô 
>
ôô 
tMaxLo
ôô 
)
ôô  !
{
öö 
return
úú 
false
úú 
;
úú 
}
ùù 
if
üü 
(
üü 
Geom
üü 
.
üü 
VertLeq
üü 
(
üü 
orgUp
üü "
,
üü" #
orgLo
üü$ )
)
üü) *
)
üü* +
{
†† 
if
°° 
(
°° 
Geom
°° 
.
°° 
EdgeSign
°° !
(
°°! "
dstLo
°°# (
,
°°( )
orgUp
°°* /
,
°°/ 0
orgLo
°°1 6
)
°°7 8
>
°°9 :
$num
°°; ?
)
°°? @
{
¢¢ 
return
££ 
false
££  
;
££  !
}
§§ 
}
•• 
else
¶¶ 
{
ßß 
if
®® 
(
®® 
Geom
®® 
.
®® 
EdgeSign
®® !
(
®®! "
dstUp
®®# (
,
®®( )
orgLo
®®* /
,
®®/ 0
orgUp
®®1 6
)
®®7 8
<
®®9 :
$num
®®; ?
)
®®? @
{
©© 
return
™™ 
false
™™  
;
™™  !
}
´´ 
}
¨¨ 
var
∞∞ 
isect
∞∞ 
=
∞∞ 
	MeshUtils
∞∞ !
.
∞∞! "
Vertex
∞∞" (
.
∞∞( )
Create
∞∞) /
(
∞∞/ 0
)
∞∞0 1
;
∞∞1 2
Geom
±± 
.
±± 
EdgeIntersect
±± 
(
±± 
dstUp
±± $
,
±±$ %
orgUp
±±& +
,
±±+ ,
dstLo
±±- 2
,
±±2 3
orgLo
±±4 9
,
±±9 :
isect
±±; @
)
±±@ A
;
±±A B
Debug
≥≥ 
.
≥≥ 
Assert
≥≥ 
(
≥≥ 
Math
≥≥ 
.
≥≥ 
Min
≥≥ !
(
≥≥! "
orgUp
≥≥" '
.
≥≥' (
_t
≥≥( *
,
≥≥* +
dstUp
≥≥, 1
.
≥≥1 2
_t
≥≥2 4
)
≥≥4 5
<=
≥≥6 8
isect
≥≥9 >
.
≥≥> ?
_t
≥≥? A
)
≥≥A B
;
≥≥B C
Debug
¥¥ 
.
¥¥ 
Assert
¥¥ 
(
¥¥ 
isect
¥¥ 
.
¥¥ 
_t
¥¥ !
<=
¥¥" $
Math
¥¥% )
.
¥¥) *
Max
¥¥* -
(
¥¥- .
orgLo
¥¥. 3
.
¥¥3 4
_t
¥¥4 6
,
¥¥6 7
dstLo
¥¥8 =
.
¥¥= >
_t
¥¥> @
)
¥¥@ A
)
¥¥A B
;
¥¥B C
Debug
µµ 
.
µµ 
Assert
µµ 
(
µµ 
Math
µµ 
.
µµ 
Min
µµ !
(
µµ! "
dstLo
µµ" '
.
µµ' (
_s
µµ( *
,
µµ* +
dstUp
µµ, 1
.
µµ1 2
_s
µµ2 4
)
µµ4 5
<=
µµ6 8
isect
µµ9 >
.
µµ> ?
_s
µµ? A
)
µµA B
;
µµB C
Debug
∂∂ 
.
∂∂ 
Assert
∂∂ 
(
∂∂ 
isect
∂∂ 
.
∂∂ 
_s
∂∂ !
<=
∂∂" $
Math
∂∂% )
.
∂∂) *
Max
∂∂* -
(
∂∂- .
orgLo
∂∂. 3
.
∂∂3 4
_s
∂∂4 6
,
∂∂6 7
orgUp
∂∂8 =
.
∂∂= >
_s
∂∂> @
)
∂∂@ A
)
∂∂A B
;
∂∂B C
if
∏∏ 
(
∏∏ 
Geom
∏∏ 
.
∏∏ 
VertLeq
∏∏ 
(
∏∏ 
isect
∏∏ "
,
∏∏" #
_event
∏∏$ *
)
∏∏* +
)
∏∏+ ,
{
ππ 
isect
øø 
.
øø 
_s
øø 
=
øø 
_event
øø !
.
øø! "
_s
øø" $
;
øø$ %
isect
¿¿ 
.
¿¿ 
_t
¿¿ 
=
¿¿ 
_event
¿¿ !
.
¿¿! "
_t
¿¿" $
;
¿¿$ %
}
¡¡ 
var
«« 
orgMin
«« 
=
«« 
Geom
«« 
.
«« 
VertLeq
«« %
(
««% &
orgUp
««& +
,
««+ ,
orgLo
««- 2
)
««2 3
?
««4 5
orgUp
««6 ;
:
««< =
orgLo
««> C
;
««C D
if
»» 
(
»» 
Geom
»» 
.
»» 
VertLeq
»» 
(
»» 
orgMin
»» #
,
»»# $
isect
»»% *
)
»»* +
)
»»+ ,
{
…… 
isect
   
.
   
_s
   
=
   
orgMin
   !
.
  ! "
_s
  " $
;
  $ %
isect
ÀÀ 
.
ÀÀ 
_t
ÀÀ 
=
ÀÀ 
orgMin
ÀÀ !
.
ÀÀ! "
_t
ÀÀ" $
;
ÀÀ$ %
}
ÃÃ 
if
ŒŒ 
(
ŒŒ 
Geom
ŒŒ 
.
ŒŒ 
VertEq
ŒŒ 
(
ŒŒ 
isect
ŒŒ !
,
ŒŒ! "
orgUp
ŒŒ# (
)
ŒŒ( )
||
ŒŒ* ,
Geom
ŒŒ- 1
.
ŒŒ1 2
VertEq
ŒŒ2 8
(
ŒŒ8 9
isect
ŒŒ9 >
,
ŒŒ> ?
orgLo
ŒŒ@ E
)
ŒŒE F
)
ŒŒF G
{
œœ !
CheckForRightSplice
—— #
(
——# $
regUp
——$ )
)
——) *
;
——* +
return
““ 
false
““ 
;
““ 
}
”” 
if
’’ 
(
’’ 
(
’’ 
!
’’ 
Geom
’’ 
.
’’ 
VertEq
’’ !
(
’’! "
dstUp
’’" '
,
’’' (
_event
’’) /
)
’’/ 0
&&
÷÷ 
Geom
÷÷ 
.
÷÷ 
EdgeSign
÷÷  
(
÷÷  !
dstUp
÷÷! &
,
÷÷& '
_event
÷÷( .
,
÷÷. /
isect
÷÷0 5
)
÷÷5 6
>=
÷÷7 9
$num
÷÷: >
)
÷÷> ?
||
◊◊ 
(
◊◊ 
!
◊◊ 
Geom
◊◊ 
.
◊◊ 
VertEq
◊◊ !
(
◊◊! "
dstLo
◊◊" '
,
◊◊' (
_event
◊◊) /
)
◊◊/ 0
&&
ÿÿ 
Geom
ÿÿ 
.
ÿÿ 
EdgeSign
ÿÿ  
(
ÿÿ  !
dstLo
ÿÿ! &
,
ÿÿ& '
_event
ÿÿ( .
,
ÿÿ. /
isect
ÿÿ0 5
)
ÿÿ5 6
<=
ÿÿ7 9
$num
ÿÿ: >
)
ÿÿ> ?
)
ÿÿ? @
{
ŸŸ 
if
›› 
(
›› 
dstLo
›› 
==
›› 
_event
›› #
)
››# $
{
ﬁﬁ 
_mesh
‡‡ 
.
‡‡ 
	SplitEdge
‡‡ #
(
‡‡# $
eUp
‡‡$ '
.
‡‡' (
_Sym
‡‡( ,
)
‡‡, -
;
‡‡- .
_mesh
·· 
.
·· 
Splice
··  
(
··  !
eLo
··! $
.
··$ %
_Sym
··% )
,
··) *
eUp
··+ .
)
··. /
;
··/ 0
regUp
‚‚ 
=
‚‚ 
TopLeftRegion
‚‚ )
(
‚‚) *
regUp
‚‚* /
)
‚‚/ 0
;
‚‚0 1
eUp
„„ 
=
„„ 
RegionBelow
„„ %
(
„„% &
regUp
„„& +
)
„„+ ,
.
„„, -
_eUp
„„- 1
;
„„1 2
FinishLeftRegions
‰‰ %
(
‰‰% &
RegionBelow
‰‰& 1
(
‰‰1 2
regUp
‰‰2 7
)
‰‰7 8
,
‰‰8 9
regLo
‰‰: ?
)
‰‰? @
;
‰‰@ A
AddRightEdges
ÂÂ !
(
ÂÂ! "
regUp
ÂÂ" '
,
ÂÂ' (
eUp
ÂÂ) ,
.
ÂÂ, -
_Oprev
ÂÂ- 3
,
ÂÂ3 4
eUp
ÂÂ5 8
,
ÂÂ8 9
eUp
ÂÂ: =
,
ÂÂ= >
true
ÂÂ? C
)
ÂÂC D
;
ÂÂD E
return
ÊÊ 
true
ÊÊ 
;
ÊÊ  
}
ÁÁ 
if
ËË 
(
ËË 
dstUp
ËË 
==
ËË 
_event
ËË #
)
ËË$ %
{
ËË& '
_mesh
ÍÍ 
.
ÍÍ 
	SplitEdge
ÍÍ #
(
ÍÍ# $
eLo
ÍÍ$ '
.
ÍÍ' (
_Sym
ÍÍ( ,
)
ÍÍ, -
;
ÍÍ- .
_mesh
ÎÎ 
.
ÎÎ 
Splice
ÎÎ  
(
ÎÎ  !
eUp
ÎÎ! $
.
ÎÎ$ %
_Lnext
ÎÎ% +
,
ÎÎ+ ,
eLo
ÎÎ- 0
.
ÎÎ0 1
_Oprev
ÎÎ1 7
)
ÎÎ7 8
;
ÎÎ8 9
regLo
ÏÏ 
=
ÏÏ 
regUp
ÏÏ !
;
ÏÏ! "
regUp
ÌÌ 
=
ÌÌ 
TopRightRegion
ÌÌ *
(
ÌÌ* +
regUp
ÌÌ+ 0
)
ÌÌ0 1
;
ÌÌ1 2
var
ÓÓ 
e
ÓÓ 
=
ÓÓ 
RegionBelow
ÓÓ '
(
ÓÓ' (
regUp
ÓÓ( -
)
ÓÓ- .
.
ÓÓ. /
_eUp
ÓÓ/ 3
.
ÓÓ3 4
_Rprev
ÓÓ4 :
;
ÓÓ: ;
regLo
ÔÔ 
.
ÔÔ 
_eUp
ÔÔ 
=
ÔÔ  
eLo
ÔÔ! $
.
ÔÔ$ %
_Oprev
ÔÔ% +
;
ÔÔ+ ,
eLo
 
=
 
FinishLeftRegions
 +
(
+ ,
regLo
, 1
,
1 2
null
3 7
)
7 8
;
8 9
AddRightEdges
ÒÒ !
(
ÒÒ! "
regUp
ÒÒ" '
,
ÒÒ' (
eLo
ÒÒ) ,
.
ÒÒ, -
_Onext
ÒÒ- 3
,
ÒÒ3 4
eUp
ÒÒ5 8
.
ÒÒ8 9
_Rprev
ÒÒ9 ?
,
ÒÒ? @
e
ÒÒA B
,
ÒÒB C
true
ÒÒD H
)
ÒÒH I
;
ÒÒI J
return
ÚÚ 
true
ÚÚ 
;
ÚÚ  
}
ÛÛ 
if
˜˜ 
(
˜˜ 
Geom
˜˜ 
.
˜˜ 
EdgeSign
˜˜ !
(
˜˜! "
dstUp
˜˜# (
,
˜˜( )
_event
˜˜* 0
,
˜˜0 1
isect
˜˜2 7
)
˜˜8 9
>=
˜˜: <
$num
˜˜= A
)
˜˜A B
{
¯¯ 
RegionAbove
˘˘ 
(
˘˘  
regUp
˘˘  %
)
˘˘% &
.
˘˘& '
_dirty
˘˘' -
=
˘˘. /
regUp
˘˘0 5
.
˘˘5 6
_dirty
˘˘6 <
=
˘˘= >
true
˘˘? C
;
˘˘C D
_mesh
˙˙ 
.
˙˙ 
	SplitEdge
˙˙ #
(
˙˙# $
eUp
˙˙$ '
.
˙˙' (
_Sym
˙˙( ,
)
˙˙, -
;
˙˙- .
eUp
˚˚ 
.
˚˚ 
_Org
˚˚ 
.
˚˚ 
_s
˚˚ 
=
˚˚  !
_event
˚˚" (
.
˚˚( )
_s
˚˚) +
;
˚˚+ ,
eUp
¸¸ 
.
¸¸ 
_Org
¸¸ 
.
¸¸ 
_t
¸¸ 
=
¸¸  !
_event
¸¸" (
.
¸¸( )
_t
¸¸) +
;
¸¸+ ,
}
˝˝ 
if
˛˛ 
(
˛˛ 
Geom
˛˛ 
.
˛˛ 
EdgeSign
˛˛ !
(
˛˛! "
dstLo
˛˛" '
,
˛˛' (
_event
˛˛) /
,
˛˛/ 0
isect
˛˛1 6
)
˛˛6 7
<=
˛˛8 :
$num
˛˛; ?
)
˛˛? @
{
ˇˇ 
regUp
ÄÄ 
.
ÄÄ 
_dirty
ÄÄ  
=
ÄÄ! "
regLo
ÄÄ# (
.
ÄÄ( )
_dirty
ÄÄ) /
=
ÄÄ0 1
true
ÄÄ2 6
;
ÄÄ6 7
_mesh
ÅÅ 
.
ÅÅ 
	SplitEdge
ÅÅ #
(
ÅÅ# $
eLo
ÅÅ$ '
.
ÅÅ' (
_Sym
ÅÅ( ,
)
ÅÅ, -
;
ÅÅ- .
eLo
ÇÇ 
.
ÇÇ 
_Org
ÇÇ 
.
ÇÇ 
_s
ÇÇ 
=
ÇÇ  !
_event
ÇÇ" (
.
ÇÇ( )
_s
ÇÇ) +
;
ÇÇ+ ,
eLo
ÉÉ 
.
ÉÉ 
_Org
ÉÉ 
.
ÉÉ 
_t
ÉÉ 
=
ÉÉ  !
_event
ÉÉ" (
.
ÉÉ( )
_t
ÉÉ) +
;
ÉÉ+ ,
}
ÑÑ 
return
ÜÜ 
false
ÜÜ 
;
ÜÜ 
}
áá 
_mesh
êê 
.
êê 
	SplitEdge
êê 
(
êê 
eUp
êê 
.
êê  
_Sym
êê  $
)
êê$ %
;
êê% &
_mesh
ëë 
.
ëë 
	SplitEdge
ëë 
(
ëë 
eLo
ëë 
.
ëë  
_Sym
ëë  $
)
ëë$ %
;
ëë% &
_mesh
íí 
.
íí 
Splice
íí 
(
íí 
eLo
íí 
.
íí 
_Oprev
íí #
,
íí# $
eUp
íí% (
)
íí( )
;
íí) *
eUp
ìì 
.
ìì 
_Org
ìì 
.
ìì 
_s
ìì 
=
ìì 
isect
ìì 
.
ìì  
_s
ìì  "
;
ìì" #
eUp
îî 
.
îî 
_Org
îî 
.
îî 
_t
îî 
=
îî 
isect
îî 
.
îî  
_t
îî  "
;
îî" #
eUp
ïï 
.
ïï 
_Org
ïï 
.
ïï 
	_pqHandle
ïï 
=
ïï  
_pq
ïï! $
.
ïï$ %
Insert
ïï% +
(
ïï+ ,
eUp
ïï, /
.
ïï/ 0
_Org
ïï0 4
)
ïï4 5
;
ïï5 6
if
ññ 
(
ññ 
eUp
ññ 
.
ññ 
_Org
ññ 
.
ññ 
	_pqHandle
ññ "
.
ññ" #
_handle
ññ# *
==
ññ+ -
PQHandle
ññ. 6
.
ññ6 7
Invalid
ññ7 >
)
ññ> ?
{
óó 
throw
òò 
new
òò '
InvalidOperationException
òò 3
(
òò3 4
$str
òò4 T
)
òòT U
;
òòU V
}
ôô 
GetIntersectData
öö 
(
öö 
eUp
öö  
.
öö  !
_Org
öö! %
,
öö% &
orgUp
öö' ,
,
öö, -
dstUp
öö. 3
,
öö3 4
orgLo
öö5 :
,
öö: ;
dstLo
öö< A
)
ööA B
;
ööB C
RegionAbove
õõ 
(
õõ 
regUp
õõ 
)
õõ 
.
õõ 
_dirty
õõ %
=
õõ& '
regUp
õõ( -
.
õõ- .
_dirty
õõ. 4
=
õõ5 6
regLo
õõ7 <
.
õõ< =
_dirty
õõ= C
=
õõD E
true
õõF J
;
õõJ K
return
úú 
false
úú 
;
úú 
}
ùù 	
private
ßß 
void
ßß 
WalkDirtyRegions
ßß %
(
ßß% &
ActiveRegion
ßß& 2
regUp
ßß3 8
)
ßß8 9
{
®® 	
var
©© 
regLo
©© 
=
©© 
RegionBelow
©© #
(
©©# $
regUp
©©$ )
)
©©) *
;
©©* +
	MeshUtils
™™ 
.
™™ 
Edge
™™ 
eUp
™™ 
,
™™ 
eLo
™™  #
;
™™# $
while
¨¨ 
(
¨¨ 
true
¨¨ 
)
¨¨ 
{
≠≠ 
while
ØØ 
(
ØØ 
regLo
ØØ 
.
ØØ 
_dirty
ØØ #
)
ØØ# $
{
∞∞ 
regUp
±± 
=
±± 
regLo
±± !
;
±±! "
regLo
≤≤ 
=
≤≤ 
RegionBelow
≤≤ '
(
≤≤' (
regLo
≤≤( -
)
≤≤- .
;
≤≤. /
}
≥≥ 
if
¥¥ 
(
¥¥ 
!
¥¥ 
regUp
¥¥ 
.
¥¥ 
_dirty
¥¥ !
)
¥¥! "
{
µµ 
regLo
∂∂ 
=
∂∂ 
regUp
∂∂ !
;
∂∂! "
regUp
∑∑ 
=
∑∑ 
RegionAbove
∑∑ '
(
∑∑' (
regUp
∑∑) .
)
∑∑/ 0
;
∑∑0 1
if
∏∏ 
(
∏∏ 
regUp
∏∏ 
==
∏∏ 
null
∏∏  $
||
∏∏% '
!
∏∏( )
regUp
∏∏) .
.
∏∏. /
_dirty
∏∏/ 5
)
∏∏5 6
{
ππ 
return
ªª 
;
ªª 
}
ºº 
}
ΩΩ 
regUp
ææ 
.
ææ 
_dirty
ææ 
=
ææ 
false
ææ $
;
ææ$ %
eUp
øø 
=
øø 
regUp
øø 
.
øø 
_eUp
øø  
;
øø  !
eLo
¿¿ 
=
¿¿ 
regLo
¿¿ 
.
¿¿ 
_eUp
¿¿  
;
¿¿  !
if
¬¬ 
(
¬¬ 
eUp
¬¬ 
.
¬¬ 
_Dst
¬¬ 
!=
¬¬ 
eLo
¬¬  #
.
¬¬# $
_Dst
¬¬$ (
)
¬¬( )
{
√√ 
if
≈≈ 
(
≈≈  
CheckForLeftSplice
≈≈ *
(
≈≈* +
regUp
≈≈+ 0
)
≈≈0 1
)
≈≈1 2
{
∆∆ 
if
ÀÀ 
(
ÀÀ 
regLo
ÀÀ !
.
ÀÀ! "
_fixUpperEdge
ÀÀ" /
)
ÀÀ/ 0
{
ÃÃ 
DeleteRegion
ÕÕ (
(
ÕÕ( )
regLo
ÕÕ) .
)
ÕÕ. /
;
ÕÕ/ 0
_mesh
ŒŒ !
.
ŒŒ! "
Delete
ŒŒ" (
(
ŒŒ( )
eLo
ŒŒ) ,
)
ŒŒ, -
;
ŒŒ- .
regLo
œœ !
=
œœ" #
RegionBelow
œœ$ /
(
œœ/ 0
regUp
œœ0 5
)
œœ5 6
;
œœ6 7
eLo
–– 
=
––  !
regLo
––" '
.
––' (
_eUp
––( ,
;
––, -
}
—— 
else
““ 
if
““ 
(
““  
regUp
““! &
.
““& '
_fixUpperEdge
““' 4
)
““5 6
{
”” 
DeleteRegion
‘‘ (
(
‘‘( )
regUp
‘‘) .
)
‘‘. /
;
‘‘/ 0
_mesh
’’ !
.
’’! "
Delete
’’" (
(
’’( )
eUp
’’) ,
)
’’, -
;
’’- .
regUp
÷÷ !
=
÷÷" #
RegionAbove
÷÷$ /
(
÷÷/ 0
regLo
÷÷0 5
)
÷÷5 6
;
÷÷6 7
eUp
◊◊ 
=
◊◊  !
regUp
◊◊" '
.
◊◊' (
_eUp
◊◊( ,
;
◊◊, -
}
ÿÿ 
}
ŸŸ 
}
⁄⁄ 
if
€€ 
(
€€ 
eUp
€€ 
.
€€ 
_Org
€€ 
!=
€€ 
eLo
€€  #
.
€€# $
_Org
€€$ (
)
€€( )
{
‹‹ 
if
›› 
(
›› 
eUp
›› 
.
›› 
_Dst
›› #
!=
››$ &
eLo
››' *
.
››* +
_Dst
››+ /
&&
ﬁﬁ 
!
ﬁﬁ 
regUp
ﬁﬁ "
.
ﬁﬁ" #
_fixUpperEdge
ﬁﬁ# 0
&&
ﬁﬁ1 3
!
ﬁﬁ4 5
regLo
ﬁﬁ6 ;
.
ﬁﬁ; <
_fixUpperEdge
ﬁﬁ< I
&&
ﬂﬂ 
(
ﬂﬂ 
eUp
ﬂﬂ 
.
ﬂﬂ  
_Dst
ﬂﬂ  $
==
ﬂﬂ% '
_event
ﬂﬂ( .
||
ﬂﬂ/ 1
eLo
ﬂﬂ2 5
.
ﬂﬂ5 6
_Dst
ﬂﬂ6 :
==
ﬂﬂ; =
_event
ﬂﬂ> D
)
ﬂﬂD E
)
ﬂﬂF G
{
‡‡ 
if
ËË 
(
ËË 
CheckForIntersect
ËË -
(
ËË- .
regUp
ËË. 3
)
ËË3 4
)
ËË4 5
{
ÈÈ 
return
ÎÎ "
;
ÎÎ" #
}
ÏÏ 
}
ÌÌ 
else
ÓÓ 
{
ÔÔ !
CheckForRightSplice
ÚÚ +
(
ÚÚ+ ,
regUp
ÚÚ, 1
)
ÚÚ1 2
;
ÚÚ2 3
}
ÛÛ 
}
ÙÙ 
if
ıı 
(
ıı 
eUp
ıı 
.
ıı 
_Org
ıı 
==
ıı 
eLo
ıı  #
.
ıı# $
_Org
ıı$ (
&&
ıı) +
eUp
ıı, /
.
ıı/ 0
_Dst
ıı0 4
==
ıı5 7
eLo
ıı8 ;
.
ıı; <
_Dst
ıı< @
)
ıı@ A
{
ˆˆ 
Geom
¯¯ 
.
¯¯ 

AddWinding
¯¯ #
(
¯¯# $
eLo
¯¯$ '
,
¯¯' (
eUp
¯¯) ,
)
¯¯, -
;
¯¯- .
DeleteRegion
˘˘  
(
˘˘  !
regUp
˘˘! &
)
˘˘& '
;
˘˘' (
_mesh
˙˙ 
.
˙˙ 
Delete
˙˙  
(
˙˙  !
eUp
˙˙! $
)
˙˙$ %
;
˙˙% &
regUp
˚˚ 
=
˚˚ 
RegionAbove
˚˚ '
(
˚˚' (
regLo
˚˚( -
)
˚˚- .
;
˚˚. /
}
¸¸ 
}
˝˝ 
}
˛˛ 	
private
üü 
void
üü  
ConnectRightVertex
üü '
(
üü' (
ActiveRegion
üü( 4
regUp
üü5 :
,
üü: ;
	MeshUtils
üü< E
.
üüE F
Edge
üüF J
eBottomLeft
üüK V
)
üüV W
{
†† 	
var
°° 
eTopLeft
°° 
=
°° 
eBottomLeft
°° &
.
°°& '
_Onext
°°' -
;
°°- .
var
¢¢ 
regLo
¢¢ 
=
¢¢ 
RegionBelow
¢¢ #
(
¢¢# $
regUp
¢¢$ )
)
¢¢) *
;
¢¢* +
var
££ 
eUp
££ 
=
££ 
regUp
££ 
.
££ 
_eUp
££  
;
££  !
var
§§ 
eLo
§§ 
=
§§ 
regLo
§§ 
.
§§ 
_eUp
§§  
;
§§  !
bool
•• 

degenerate
•• 
=
•• 
false
•• #
;
••# $
if
ßß 
(
ßß 
eUp
ßß 
.
ßß 
_Dst
ßß 
!=
ßß 
eLo
ßß 
.
ßß  
_Dst
ßß  $
)
ßß$ %
{
®® 
CheckForIntersect
©© !
(
©©! "
regUp
©©" '
)
©©' (
;
©©( )
}
™™ 
if
ÆÆ 
(
ÆÆ 
Geom
ÆÆ 
.
ÆÆ 
VertEq
ÆÆ 
(
ÆÆ 
eUp
ÆÆ 
.
ÆÆ  
_Org
ÆÆ  $
,
ÆÆ$ %
_event
ÆÆ& ,
)
ÆÆ, -
)
ÆÆ- .
{
ØØ 
_mesh
∞∞ 
.
∞∞ 
Splice
∞∞ 
(
∞∞ 
eTopLeft
∞∞ %
.
∞∞% &
_Oprev
∞∞& ,
,
∞∞, -
eUp
∞∞. 1
)
∞∞1 2
;
∞∞2 3
regUp
±± 
=
±± 
TopLeftRegion
±± %
(
±±% &
regUp
±±& +
)
±±+ ,
;
±±, -
eTopLeft
≤≤ 
=
≤≤ 
RegionBelow
≤≤ &
(
≤≤& '
regUp
≤≤' ,
)
≤≤, -
.
≤≤- .
_eUp
≤≤. 2
;
≤≤2 3
FinishLeftRegions
≥≥ !
(
≥≥! "
RegionBelow
≥≥" -
(
≥≥- .
regUp
≥≥. 3
)
≥≥3 4
,
≥≥4 5
regLo
≥≥6 ;
)
≥≥; <
;
≥≥< =

degenerate
¥¥ 
=
¥¥ 
true
¥¥ !
;
¥¥! "
}
µµ 
if
∂∂ 
(
∂∂ 
Geom
∂∂ 
.
∂∂ 
VertEq
∂∂ 
(
∂∂ 
eLo
∂∂ 
.
∂∂  
_Org
∂∂  $
,
∂∂$ %
_event
∂∂& ,
)
∂∂, -
)
∂∂- .
{
∑∑ 
_mesh
∏∏ 
.
∏∏ 
Splice
∏∏ 
(
∏∏ 
eBottomLeft
∏∏ (
,
∏∏( )
eLo
∏∏* -
.
∏∏- .
_Oprev
∏∏. 4
)
∏∏4 5
;
∏∏5 6
eBottomLeft
ππ 
=
ππ 
FinishLeftRegions
ππ /
(
ππ/ 0
regLo
ππ0 5
,
ππ5 6
null
ππ7 ;
)
ππ; <
;
ππ< =

degenerate
∫∫ 
=
∫∫ 
true
∫∫ !
;
∫∫! "
}
ªª 
if
ºº 
(
ºº 

degenerate
ºº 
)
ºº 
{
ΩΩ 
AddRightEdges
ææ 
(
ææ 
regUp
ææ #
,
ææ# $
eBottomLeft
ææ% 0
.
ææ0 1
_Onext
ææ1 7
,
ææ7 8
eTopLeft
ææ9 A
,
ææA B
eTopLeft
ææC K
,
ææK L
true
ææM Q
)
ææQ R
;
ææR S
return
øø 
;
øø 
}
¿¿ 
	MeshUtils
ƒƒ 
.
ƒƒ 
Edge
ƒƒ 
eNew
ƒƒ 
;
ƒƒ  
if
≈≈ 
(
≈≈ 
Geom
≈≈ 
.
≈≈ 
VertLeq
≈≈ 
(
≈≈ 
eLo
≈≈  
.
≈≈  !
_Org
≈≈! %
,
≈≈% &
eUp
≈≈' *
.
≈≈* +
_Org
≈≈+ /
)
≈≈/ 0
)
≈≈0 1
{
∆∆ 
eNew
«« 
=
«« 
eLo
«« 
.
«« 
_Oprev
«« !
;
««! "
}
»» 
else
…… 
{
   
eNew
ÀÀ 
=
ÀÀ 
eUp
ÀÀ 
;
ÀÀ 
}
ÃÃ 
eNew
ÕÕ 
=
ÕÕ 
_mesh
ÕÕ 
.
ÕÕ 
Connect
ÕÕ  
(
ÕÕ  !
eBottomLeft
ÕÕ! ,
.
ÕÕ, -
_Lprev
ÕÕ- 3
,
ÕÕ3 4
eNew
ÕÕ5 9
)
ÕÕ9 :
;
ÕÕ: ;
AddRightEdges
—— 
(
—— 
regUp
—— 
,
——  
eNew
——! %
,
——% &
eNew
——' +
.
——+ ,
_Onext
——, 2
,
——2 3
eNew
——4 8
.
——8 9
_Onext
——9 ?
,
——? @
false
——A F
)
——F G
;
——G H
eNew
““ 
.
““ 
_Sym
““ 
.
““ 
_activeRegion
““ #
.
““# $
_fixUpperEdge
““$ 1
=
““2 3
true
““4 8
;
““8 9
WalkDirtyRegions
”” 
(
”” 
regUp
”” "
)
””" #
;
””# $
}
‘‘ 	
private
€€ 
void
€€ #
ConnectLeftDegenerate
€€ *
(
€€* +
ActiveRegion
€€+ 7
regUp
€€8 =
,
€€= >
	MeshUtils
€€? H
.
€€H I
Vertex
€€I O
vEvent
€€P V
)
€€V W
{
‹‹ 	
var
›› 
e
›› 
=
›› 
regUp
›› 
.
›› 
_eUp
›› 
;
›› 
if
ﬁﬁ 
(
ﬁﬁ 
Geom
ﬁﬁ 
.
ﬁﬁ 
VertEq
ﬁﬁ 
(
ﬁﬁ 
e
ﬁﬁ 
.
ﬁﬁ 
_Org
ﬁﬁ "
,
ﬁﬁ" #
vEvent
ﬁﬁ$ *
)
ﬁﬁ* +
)
ﬁﬁ+ ,
{
ﬂﬂ 
throw
‰‰ 
new
‰‰ '
InvalidOperationException
‰‰ 3
(
‰‰3 4
$str
‰‰4 ]
)
‰‰] ^
;
‰‰^ _
}
ÂÂ 
if
ÁÁ 
(
ÁÁ 
!
ÁÁ 
Geom
ÁÁ 
.
ÁÁ 
VertEq
ÁÁ 
(
ÁÁ 
e
ÁÁ 
.
ÁÁ 
_Dst
ÁÁ #
,
ÁÁ# $
vEvent
ÁÁ% +
)
ÁÁ+ ,
)
ÁÁ, -
{
ËË 
_mesh
ÍÍ 
.
ÍÍ 
	SplitEdge
ÍÍ 
(
ÍÍ  
e
ÍÍ  !
.
ÍÍ! "
_Sym
ÍÍ" &
)
ÍÍ& '
;
ÍÍ' (
if
ÎÎ 
(
ÎÎ 
regUp
ÎÎ 
.
ÎÎ 
_fixUpperEdge
ÎÎ '
)
ÎÎ' (
{
ÏÏ 
_mesh
ÓÓ 
.
ÓÓ 
Delete
ÓÓ  
(
ÓÓ  !
e
ÓÓ! "
.
ÓÓ" #
_Onext
ÓÓ# )
)
ÓÓ) *
;
ÓÓ* +
regUp
ÔÔ 
.
ÔÔ 
_fixUpperEdge
ÔÔ '
=
ÔÔ( )
false
ÔÔ* /
;
ÔÔ/ 0
}
 
_mesh
ÒÒ 
.
ÒÒ 
Splice
ÒÒ 
(
ÒÒ 
vEvent
ÒÒ #
.
ÒÒ# $
_anEdge
ÒÒ$ +
,
ÒÒ+ ,
e
ÒÒ- .
)
ÒÒ. /
;
ÒÒ/ 0

SweepEvent
ÚÚ 
(
ÚÚ 
vEvent
ÚÚ !
)
ÚÚ! "
;
ÚÚ" #
return
ÛÛ 
;
ÛÛ 
}
ÙÙ 
throw
˜˜ 
new
˜˜ '
InvalidOperationException
˜˜ /
(
˜˜/ 0
$str
˜˜0 Y
)
˜˜Y Z
;
˜˜Z [
}
¯¯ 	
private
ââ 
void
ââ 
ConnectLeftVertex
ââ &
(
ââ& '
	MeshUtils
ââ' 0
.
ââ0 1
Vertex
ââ1 7
vEvent
ââ8 >
)
ââ> ?
{
ää 	
var
ãã 
tmp
ãã 
=
ãã 
new
ãã 
ActiveRegion
ãã &
(
ãã& '
)
ãã' (
;
ãã( )
tmp
éé 
.
éé 
_eUp
éé 
=
éé 
vEvent
éé 
.
éé 
_anEdge
éé %
.
éé% &
_Sym
éé& *
;
éé* +
var
èè 
regUp
èè 
=
èè 
_dict
èè 
.
èè 
Find
èè "
(
èè" #
tmp
èè# &
)
èè& '
.
èè' (
Key
èè( +
;
èè+ ,
var
êê 
regLo
êê 
=
êê 
RegionBelow
êê #
(
êê# $
regUp
êê$ )
)
êê) *
;
êê* +
if
ëë 
(
ëë 
regLo
ëë 
==
ëë 
null
ëë 
)
ëë 
{
íí 
return
îî 
;
îî 
}
ïï 
var
ññ 
eUp
ññ 
=
ññ 
regUp
ññ 
.
ññ 
_eUp
ññ  
;
ññ  !
var
óó 
eLo
óó 
=
óó 
regLo
óó 
.
óó 
_eUp
óó  
;
óó  !
if
öö 
(
öö 
Geom
öö 
.
öö 
EdgeSign
öö 
(
öö 
eUp
öö !
.
öö! "
_Dst
öö" &
,
öö& '
vEvent
öö( .
,
öö. /
eUp
öö0 3
.
öö3 4
_Org
öö4 8
)
öö8 9
==
öö: <
$num
öö= A
)
ööA B
{
õõ #
ConnectLeftDegenerate
úú %
(
úú% &
regUp
úú& +
,
úú+ ,
vEvent
úú- 3
)
úú3 4
;
úú4 5
return
ùù 
;
ùù 
}
ûû 
var
¢¢ 
reg
¢¢ 
=
¢¢ 
Geom
¢¢ 
.
¢¢ 
VertLeq
¢¢ "
(
¢¢" #
eLo
¢¢# &
.
¢¢& '
_Dst
¢¢' +
,
¢¢+ ,
eUp
¢¢- 0
.
¢¢0 1
_Dst
¢¢1 5
)
¢¢5 6
?
¢¢7 8
regUp
¢¢9 >
:
¢¢? @
regLo
¢¢A F
;
¢¢F G
if
§§ 
(
§§ 
regUp
§§ 
.
§§ 
_inside
§§ 
||
§§  
reg
§§! $
.
§§$ %
_fixUpperEdge
§§% 2
)
§§2 3
{
•• 
	MeshUtils
¶¶ 
.
¶¶ 
Edge
¶¶ 
eNew
¶¶ #
;
¶¶# $
if
ßß 
(
ßß 
reg
ßß 
==
ßß 
regUp
ßß  
)
ßß  !
{
®® 
eNew
©© 
=
©© 
_mesh
©©  
.
©©  !
Connect
©©! (
(
©©( )
vEvent
©©) /
.
©©/ 0
_anEdge
©©0 7
.
©©7 8
_Sym
©©8 <
,
©©< =
eUp
©©> A
.
©©A B
_Lnext
©©B H
)
©©H I
;
©©I J
}
™™ 
else
´´ 
{
¨¨ 
eNew
≠≠ 
=
≠≠ 
_mesh
≠≠  
.
≠≠  !
Connect
≠≠! (
(
≠≠( )
eLo
≠≠) ,
.
≠≠, -
_Dnext
≠≠- 3
,
≠≠3 4
vEvent
≠≠5 ;
.
≠≠; <
_anEdge
≠≠< C
)
≠≠C D
.
≠≠D E
_Sym
≠≠E I
;
≠≠I J
}
ÆÆ 
if
ØØ 
(
ØØ 
reg
ØØ 
.
ØØ 
_fixUpperEdge
ØØ %
)
ØØ% &
{
∞∞ 
FixUpperEdge
±±  
(
±±  !
reg
±±! $
,
±±$ %
eNew
±±& *
)
±±* +
;
±±+ ,
}
≤≤ 
else
≥≥ 
{
¥¥ 
ComputeWinding
µµ "
(
µµ" #
AddRegionBelow
µµ# 1
(
µµ1 2
regUp
µµ2 7
,
µµ7 8
eNew
µµ9 =
)
µµ= >
)
µµ> ?
;
µµ? @
}
∂∂ 

SweepEvent
∑∑ 
(
∑∑ 
vEvent
∑∑ !
)
∑∑! "
;
∑∑" #
}
∏∏ 
else
ππ 
{
∫∫ 
AddRightEdges
ΩΩ 
(
ΩΩ 
regUp
ΩΩ #
,
ΩΩ# $
vEvent
ΩΩ% +
.
ΩΩ+ ,
_anEdge
ΩΩ, 3
,
ΩΩ3 4
vEvent
ΩΩ5 ;
.
ΩΩ; <
_anEdge
ΩΩ< C
,
ΩΩC D
null
ΩΩE I
,
ΩΩI J
true
ΩΩK O
)
ΩΩO P
;
ΩΩP Q
}
ææ 
}
øø 	
private
≈≈ 
void
≈≈ 

SweepEvent
≈≈ 
(
≈≈  
	MeshUtils
≈≈  )
.
≈≈) *
Vertex
≈≈* 0
vEvent
≈≈1 7
)
≈≈7 8
{
∆∆ 	
_event
«« 
=
«« 
vEvent
«« 
;
«« 
var
ÃÃ 
e
ÃÃ 
=
ÃÃ 
vEvent
ÃÃ 
.
ÃÃ 
_anEdge
ÃÃ "
;
ÃÃ" #
while
ÕÕ 
(
ÕÕ 
e
ÕÕ 
.
ÕÕ 
_activeRegion
ÕÕ "
==
ÕÕ# %
null
ÕÕ& *
)
ÕÕ* +
{
ŒŒ 
e
œœ 
=
œœ 
e
œœ 
.
œœ 
_Onext
œœ 
;
œœ 
if
–– 
(
–– 
e
–– 
==
–– 
vEvent
–– 
.
––  
_anEdge
––  '
)
––' (
{
—— 
ConnectLeftVertex
”” %
(
””% &
vEvent
””& ,
)
””, -
;
””- .
return
‘‘ 
;
‘‘ 
}
’’ 
}
÷÷ 
var
ﬁﬁ 
regUp
ﬁﬁ 
=
ﬁﬁ 
TopLeftRegion
ﬁﬁ %
(
ﬁﬁ% &
e
ﬁﬁ& '
.
ﬁﬁ' (
_activeRegion
ﬁﬁ( 5
)
ﬁﬁ5 6
;
ﬁﬁ6 7
var
ﬂﬂ 
reg
ﬂﬂ 
=
ﬂﬂ 
RegionBelow
ﬂﬂ !
(
ﬂﬂ! "
regUp
ﬂﬂ" '
)
ﬂﬂ' (
;
ﬂﬂ( )
var
‡‡ 
eTopLeft
‡‡ 
=
‡‡ 
reg
‡‡ 
.
‡‡ 
_eUp
‡‡ #
;
‡‡# $
var
·· 
eBottomLeft
·· 
=
·· 
FinishLeftRegions
·· /
(
··/ 0
reg
··0 3
,
··3 4
null
··5 9
)
··9 :
;
··: ;
if
ÁÁ 
(
ÁÁ 
eBottomLeft
ÁÁ 
.
ÁÁ 
_Onext
ÁÁ "
==
ÁÁ# %
eTopLeft
ÁÁ& .
)
ÁÁ. /
{
ËË  
ConnectRightVertex
ÍÍ "
(
ÍÍ" #
regUp
ÍÍ# (
,
ÍÍ( )
eBottomLeft
ÍÍ* 5
)
ÍÍ5 6
;
ÍÍ6 7
}
ÎÎ 
else
ÏÏ 
{
ÌÌ 
AddRightEdges
ÓÓ 
(
ÓÓ 
regUp
ÓÓ #
,
ÓÓ# $
eBottomLeft
ÓÓ% 0
.
ÓÓ0 1
_Onext
ÓÓ1 7
,
ÓÓ7 8
eTopLeft
ÓÓ9 A
,
ÓÓA B
eTopLeft
ÓÓC K
,
ÓÓK L
true
ÓÓM Q
)
ÓÓQ R
;
ÓÓR S
}
ÔÔ 
}
 	
private
˘˘ 
void
˘˘ 
AddSentinel
˘˘  
(
˘˘  !
Real
˘˘! %
smin
˘˘& *
,
˘˘* +
Real
˘˘, 0
smax
˘˘1 5
,
˘˘5 6
Real
˘˘7 ;
t
˘˘< =
)
˘˘= >
{
˙˙ 	
var
˚˚ 
e
˚˚ 
=
˚˚ 
_mesh
˚˚ 
.
˚˚ 
MakeEdge
˚˚ "
(
˚˚" #
)
˚˚# $
;
˚˚$ %
e
¸¸ 
.
¸¸ 
_Org
¸¸ 
.
¸¸ 
_s
¸¸ 
=
¸¸ 
smax
¸¸ 
;
¸¸ 
e
˝˝ 
.
˝˝ 
_Org
˝˝ 
.
˝˝ 
_t
˝˝ 
=
˝˝ 
t
˝˝ 
;
˝˝ 
e
˛˛ 
.
˛˛ 
_Dst
˛˛ 
.
˛˛ 
_s
˛˛ 
=
˛˛ 
smin
˛˛ 
;
˛˛ 
e
ˇˇ 
.
ˇˇ 
_Dst
ˇˇ 
.
ˇˇ 
_t
ˇˇ 
=
ˇˇ 
t
ˇˇ 
;
ˇˇ 
_event
ÄÄ 
=
ÄÄ 
e
ÄÄ 
.
ÄÄ 
_Dst
ÄÄ 
;
ÄÄ 
var
ÇÇ 
reg
ÇÇ 
=
ÇÇ 
new
ÇÇ 
ActiveRegion
ÇÇ &
(
ÇÇ& '
)
ÇÇ' (
;
ÇÇ( )
reg
ÉÉ 
.
ÉÉ 
_eUp
ÉÉ 
=
ÉÉ 
e
ÉÉ 
;
ÉÉ 
reg
ÑÑ 
.
ÑÑ 
_windingNumber
ÑÑ 
=
ÑÑ  
$num
ÑÑ! "
;
ÑÑ" #
reg
ÖÖ 
.
ÖÖ 
_inside
ÖÖ 
=
ÖÖ 
false
ÖÖ 
;
ÖÖ  
reg
ÜÜ 
.
ÜÜ 
_fixUpperEdge
ÜÜ 
=
ÜÜ 
false
ÜÜ  %
;
ÜÜ% &
reg
áá 
.
áá 
	_sentinel
áá 
=
áá 
true
áá  
;
áá  !
reg
àà 
.
àà 
_dirty
àà 
=
àà 
false
àà 
;
àà 
reg
ââ 
.
ââ 
_nodeUp
ââ 
=
ââ 
_dict
ââ 
.
ââ  
Insert
ââ  &
(
ââ& '
reg
ââ' *
)
ââ* +
;
ââ+ ,
}
ää 	
private
êê 
void
êê 
InitEdgeDict
êê !
(
êê! "
)
êê" #
{
ëë 	
_dict
íí 
=
íí 
new
íí 
Dict
íí 
<
íí 
ActiveRegion
íí )
>
íí) *
(
íí* +
EdgeLeq
íí+ 2
)
íí2 3
;
íí3 4
AddSentinel
îî 
(
îî 
-
îî 
SentinelCoord
îî &
,
îî& '
SentinelCoord
îî( 5
,
îî5 6
-
îî7 8
SentinelCoord
îî8 E
)
îîE F
;
îîF G
AddSentinel
ïï 
(
ïï 
-
ïï 
SentinelCoord
ïï &
,
ïï& '
SentinelCoord
ïï( 5
,
ïï5 6
+
ïï7 8
SentinelCoord
ïï8 E
)
ïïE F
;
ïïF G
}
ññ 	
private
òò 
void
òò 
DoneEdgeDict
òò !
(
òò! "
)
òò" #
{
ôô 	
int
öö 

fixedEdges
öö 
=
öö 
$num
öö 
;
öö 
ActiveRegion
úú 
reg
úú 
;
úú 
while
ùù 
(
ùù 
(
ùù 
reg
ùù 
=
ùù 
_dict
ùù 
.
ùù  
Min
ùù  #
(
ùù# $
)
ùù$ %
.
ùù% &
Key
ùù& )
)
ùù) *
!=
ùù+ -
null
ùù. 2
)
ùù2 3
{
ûû 
if
¢¢ 
(
¢¢ 
!
¢¢ 
reg
¢¢ 
.
¢¢ 
	_sentinel
¢¢ "
)
¢¢" #
{
££ 
Debug
§§ 
.
§§ 
Assert
§§  
(
§§  !
reg
§§! $
.
§§$ %
_fixUpperEdge
§§% 2
)
§§2 3
;
§§3 4
Debug
•• 
.
•• 
Assert
••  
(
••  !
++
••! #

fixedEdges
••# -
==
••. 0
$num
••1 2
)
••2 3
;
••3 4
}
¶¶ 
Debug
ßß 
.
ßß 
Assert
ßß 
(
ßß 
reg
ßß  
.
ßß  !
_windingNumber
ßß! /
==
ßß0 2
$num
ßß3 4
)
ßß4 5
;
ßß5 6
DeleteRegion
®® 
(
®® 
reg
®®  
)
®®  !
;
®®! "
}
©© 
_dict
´´ 
=
´´ 
null
´´ 
;
´´ 
}
¨¨ 	
private
±± 
void
±± #
RemoveDegenerateEdges
±± *
(
±±* +
)
±±+ ,
{
≤≤ 	
	MeshUtils
≥≥ 
.
≥≥ 
Edge
≥≥ 
eHead
≥≥  
=
≥≥! "
_mesh
≥≥# (
.
≥≥( )
_eHead
≥≥) /
,
≥≥/ 0
e
≥≥1 2
,
≥≥2 3
eNext
≥≥4 9
,
≥≥9 :
eLnext
≥≥; A
;
≥≥A B
for
µµ 
(
µµ 
e
µµ 
=
µµ 
eHead
µµ 
.
µµ 
_next
µµ  
;
µµ  !
e
µµ" #
!=
µµ$ &
eHead
µµ' ,
;
µµ, -
e
µµ. /
=
µµ0 1
eNext
µµ2 7
)
µµ7 8
{
∂∂ 
eNext
∑∑ 
=
∑∑ 
e
∑∑ 
.
∑∑ 
_next
∑∑ 
;
∑∑  
eLnext
∏∏ 
=
∏∏ 
e
∏∏ 
.
∏∏ 
_Lnext
∏∏ !
;
∏∏! "
if
∫∫ 
(
∫∫ 
Geom
∫∫ 
.
∫∫ 
VertEq
∫∫ 
(
∫∫  
e
∫∫  !
.
∫∫! "
_Org
∫∫" &
,
∫∫& '
e
∫∫( )
.
∫∫) *
_Dst
∫∫* .
)
∫∫. /
&&
∫∫0 2
e
∫∫3 4
.
∫∫4 5
_Lnext
∫∫5 ;
.
∫∫; <
_Lnext
∫∫< B
!=
∫∫C E
e
∫∫F G
)
∫∫G H
{
ªª !
SpliceMergeVertices
ææ '
(
ææ' (
eLnext
ææ( .
,
ææ. /
e
ææ0 1
)
ææ1 2
;
ææ2 3
_mesh
øø 
.
øø 
Delete
øø  
(
øø  !
e
øø! "
)
øø" #
;
øø# $
e
¿¿ 
=
¿¿ 
eLnext
¿¿ 
;
¿¿ 
eLnext
¡¡ 
=
¡¡ 
e
¡¡ 
.
¡¡ 
_Lnext
¡¡ %
;
¡¡% &
}
¬¬ 
if
√√ 
(
√√ 
eLnext
√√ 
.
√√ 
_Lnext
√√ !
==
√√" $
e
√√% &
)
√√& '
{
ƒƒ 
if
«« 
(
«« 
eLnext
«« 
!=
«« !
e
««" #
)
««# $
{
»» 
if
…… 
(
…… 
eLnext
…… "
==
……# %
eNext
……& +
||
……, .
eLnext
……/ 5
==
……6 8
eNext
……9 >
.
……> ?
_Sym
……? C
)
……C D
{
   
eNext
ÀÀ !
=
ÀÀ" #
eNext
ÀÀ$ )
.
ÀÀ) *
_next
ÀÀ* /
;
ÀÀ/ 0
}
ÃÃ 
_mesh
ÕÕ 
.
ÕÕ 
Delete
ÕÕ $
(
ÕÕ$ %
eLnext
ÕÕ% +
)
ÕÕ+ ,
;
ÕÕ, -
}
ŒŒ 
if
œœ 
(
œœ 
e
œœ 
==
œœ 
eNext
œœ "
||
œœ# %
e
œœ& '
==
œœ( *
eNext
œœ+ 0
.
œœ0 1
_Sym
œœ1 5
)
œœ5 6
{
–– 
eNext
—— 
=
—— 
eNext
——  %
.
——% &
_next
——& +
;
——+ ,
}
““ 
_mesh
”” 
.
”” 
Delete
””  
(
””  !
e
””! "
)
””" #
;
””# $
}
‘‘ 
}
’’ 
}
÷÷ 	
private
‹‹ 
void
‹‹ 
InitPriorityQ
‹‹ "
(
‹‹" #
)
‹‹# $
{
›› 	
	MeshUtils
ﬁﬁ 
.
ﬁﬁ 
Vertex
ﬁﬁ 
vHead
ﬁﬁ "
=
ﬁﬁ# $
_mesh
ﬁﬁ% *
.
ﬁﬁ* +
_vHead
ﬁﬁ+ 1
,
ﬁﬁ1 2
v
ﬁﬁ3 4
;
ﬁﬁ4 5
int
ﬂﬂ 
vertexCount
ﬂﬂ 
=
ﬂﬂ 
$num
ﬂﬂ 
;
ﬂﬂ  
for
·· 
(
·· 
v
·· 
=
·· 
vHead
·· 
.
·· 
_next
··  
;
··  !
v
··" #
!=
··$ &
vHead
··' ,
;
··, -
v
··. /
=
··0 1
v
··2 3
.
··3 4
_next
··4 9
)
··9 :
{
‚‚ 
vertexCount
„„ 
++
„„ 
;
„„ 
}
‰‰ 
vertexCount
ÊÊ 
+=
ÊÊ 
$num
ÊÊ 
;
ÊÊ 
_pq
ËË 
=
ËË 
new
ËË 
PriorityQueue
ËË #
<
ËË# $
	MeshUtils
ËË$ -
.
ËË- .
Vertex
ËË. 4
>
ËË4 5
(
ËË5 6
vertexCount
ËË6 A
,
ËËA B
Geom
ËËC G
.
ËËG H
VertLeq
ËËH O
)
ËËO P
;
ËËP Q
vHead
ÍÍ 
=
ÍÍ 
_mesh
ÍÍ 
.
ÍÍ 
_vHead
ÍÍ  
;
ÍÍ  !
for
ÎÎ 
(
ÎÎ 
v
ÎÎ 
=
ÎÎ 
vHead
ÎÎ 
.
ÎÎ 
_next
ÎÎ  
;
ÎÎ  !
v
ÎÎ" #
!=
ÎÎ$ &
vHead
ÎÎ' ,
;
ÎÎ, -
v
ÎÎ. /
=
ÎÎ0 1
v
ÎÎ2 3
.
ÎÎ3 4
_next
ÎÎ4 9
)
ÎÎ: ;
{
ÎÎ< =
v
ÏÏ 
.
ÏÏ 
	_pqHandle
ÏÏ 
=
ÏÏ 
_pq
ÏÏ !
.
ÏÏ! "
Insert
ÏÏ" (
(
ÏÏ( )
v
ÏÏ) *
)
ÏÏ* +
;
ÏÏ+ ,
if
ÌÌ 
(
ÌÌ 
v
ÌÌ 
.
ÌÌ 
	_pqHandle
ÌÌ 
.
ÌÌ  
_handle
ÌÌ  '
==
ÌÌ( *
PQHandle
ÌÌ+ 3
.
ÌÌ3 4
Invalid
ÌÌ4 ;
)
ÌÌ; <
{
ÓÓ 
throw
ÔÔ 
new
ÔÔ '
InvalidOperationException
ÔÔ 7
(
ÔÔ7 8
$str
ÔÔ8 X
)
ÔÔX Y
;
ÔÔY Z
}
 
}
ÒÒ 
_pq
ÚÚ 
.
ÚÚ 
Init
ÚÚ 
(
ÚÚ 
)
ÚÚ 
;
ÚÚ 
}
ÛÛ 	
private
ıı 
void
ıı 
DonePriorityQ
ıı "
(
ıı" #
)
ıı# $
{
ˆˆ 	
_pq
˜˜ 
=
˜˜ 
null
˜˜ 
;
˜˜ 
}
¯¯ 	
private
à	à	 
void
à	à	 #
RemoveDegenerateFaces
à	à	 *
(
à	à	* +
)
à	à	+ ,
{
â	â	 	
	MeshUtils
ä	ä	 
.
ä	ä	 
Face
ä	ä	 
f
ä	ä	 
,
ä	ä	 
fNext
ä	ä	 #
;
ä	ä	# $
	MeshUtils
ã	ã	 
.
ã	ã	 
Edge
ã	ã	 
e
ã	ã	 
;
ã	ã	 
for
ç	ç	 
(
ç	ç	 
f
ç	ç	 
=
ç	ç	 
_mesh
ç	ç	 
.
ç	ç	 
_fHead
ç	ç	 !
.
ç	ç	! "
_next
ç	ç	" '
;
ç	ç	' (
f
ç	ç	) *
!=
ç	ç	+ -
_mesh
ç	ç	. 3
.
ç	ç	3 4
_fHead
ç	ç	4 :
;
ç	ç	: ;
f
ç	ç	< =
=
ç	ç	> ?
fNext
ç	ç	@ E
)
ç	ç	E F
{
é	é	 
fNext
è	è	 
=
è	è	 
f
è	è	 
.
è	è	 
_next
è	è	 
;
è	è	  
e
ê	ê	 
=
ê	ê	 
f
ê	ê	 
.
ê	ê	 
_anEdge
ê	ê	 
;
ê	ê	 
Debug
ë	ë	 
.
ë	ë	 
Assert
ë	ë	 
(
ë	ë	 
e
ë	ë	 
.
ë	ë	 
_Lnext
ë	ë	 %
!=
ë	ë	& (
e
ë	ë	) *
)
ë	ë	* +
;
ë	ë	+ ,
if
ì	ì	 
(
ì	ì	 
e
ì	ì	 
.
ì	ì	 
_Lnext
ì	ì	 
.
ì	ì	 
_Lnext
ì	ì	 #
==
ì	ì	$ &
e
ì	ì	' (
)
ì	ì	( )
{
î	î	 
Geom
ñ	ñ	 
.
ñ	ñ	 

AddWinding
ñ	ñ	 #
(
ñ	ñ	# $
e
ñ	ñ	$ %
.
ñ	ñ	% &
_Onext
ñ	ñ	& ,
,
ñ	ñ	, -
e
ñ	ñ	. /
)
ñ	ñ	/ 0
;
ñ	ñ	0 1
_mesh
ó	ó	 
.
ó	ó	 
Delete
ó	ó	  
(
ó	ó	  !
e
ó	ó	! "
)
ó	ó	" #
;
ó	ó	# $
}
ò	ò	 
}
ô	ô	 
}
ö	ö	 	
	protected
£	£	 
void
£	£	 
ComputeInterior
£	£	 &
(
£	£	& '
)
£	£	' (
{
§	§	 	#
RemoveDegenerateEdges
™	™	 !
(
™	™	! "
)
™	™	" #
;
™	™	# $
InitPriorityQ
´	´	 
(
´	´	 
)
´	´	 
;
´	´	 #
RemoveDegenerateFaces
¨	¨	 !
(
¨	¨	! "
)
¨	¨	" #
;
¨	¨	# $
InitEdgeDict
≠	≠	 
(
≠	≠	 
)
≠	≠	 
;
≠	≠	 
	MeshUtils
Ø	Ø	 
.
Ø	Ø	 
Vertex
Ø	Ø	 
v
Ø	Ø	 
,
Ø	Ø	 
vNext
Ø	Ø	  %
;
Ø	Ø	% &
while
∞	∞	 
(
∞	∞	 
(
∞	∞	 
v
∞	∞	 
=
∞	∞	 
_pq
∞	∞	 
.
∞	∞	 

ExtractMin
∞	∞	 &
(
∞	∞	& '
)
∞	∞	' (
)
∞	∞	( )
!=
∞	∞	* ,
null
∞	∞	- 1
)
∞	∞	1 2
{
±	±	 
while
≤	≤	 
(
≤	≤	 
true
≤	≤	 
)
≤	≤	 
{
≥	≥	 
vNext
¥	¥	 
=
¥	¥	 
_pq
¥	¥	 
.
¥	¥	  
Minimum
¥	¥	  '
(
¥	¥	' (
)
¥	¥	( )
;
¥	¥	) *
if
µ	µ	 
(
µ	µ	 
vNext
µ	µ	 
==
µ	µ	  
null
µ	µ	! %
||
µ	µ	& (
!
µ	µ	) *
Geom
µ	µ	* .
.
µ	µ	. /
VertEq
µ	µ	/ 5
(
µ	µ	5 6
vNext
µ	µ	6 ;
,
µ	µ	; <
v
µ	µ	= >
)
µ	µ	> ?
)
µ	µ	? @
{
∂	∂	 
break
∑	∑	 
;
∑	∑	 
}
∏	∏	 
vNext
«	«	 
=
«	«	 
_pq
«	«	 
.
«	«	  

ExtractMin
«	«	  *
(
«	«	* +
)
«	«	+ ,
;
«	«	, -!
SpliceMergeVertices
»	»	 '
(
»	»	' (
v
»	»	( )
.
»	»	) *
_anEdge
»	»	* 1
,
»	»	1 2
vNext
»	»	3 8
.
»	»	8 9
_anEdge
»	»	9 @
)
»	»	@ A
;
»	»	A B
}
…	…	 

SweepEvent
 	 	 
(
 	 	 
v
 	 	 
)
 	 	 
;
 	 	 
}
À	À	 
DoneEdgeDict
Õ	Õ	 
(
Õ	Õ	 
)
Õ	Õ	 
;
Õ	Õ	 
DonePriorityQ
Œ	Œ	 
(
Œ	Œ	 
)
Œ	Œ	 
;
Œ	Œ	 #
RemoveDegenerateFaces
–	–	 !
(
–	–	! "
)
–	–	" #
;
–	–	# $
_mesh
—	—	 
.
—	—	 
Check
—	—	 
(
—	—	 
)
—	—	 
;
—	—	 
}
“	“	 	
}
”	”	 
}‘	‘	 
}÷	÷	 Ÿ
∞D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\2D\CinemachineUniversalPixelPerfect.cs
	namespace 	
UnityEngine
 
. 
Experimental "
." #
	Rendering# ,
., -
	Universal- 6
{ 
[		 
AddComponentMenu		 
(		 
$str		 
)		 
]		 
public

 

class

 ,
 CinemachineUniversalPixelPerfect

 1
:

2 3
MonoBehaviour

4 A
{ 
void 
OnEnable 
( 
) 
{ 	
Debug 
. 
LogError 
( 
$str	 •
)
• ¶
;
¶ ß
} 	
} 
} ÔP
°D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\CopyColorPass.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
.) *
Internal* 2
{ 
public 

class 
CopyColorPass 
:   
ScriptableRenderPass! 5
{ 
int &
m_SampleOffsetShaderHandle &
;& '
Material 
m_SamplingMaterial #
;# $
Downsampling  
m_DownsamplingMethod )
;) *
Material 
m_CopyColorMaterial $
;$ %
private "
RenderTargetIdentifier &
source' -
{. /
get0 3
;3 4
set5 8
;8 9
}: ;
private 
RenderTargetHandle "
destination# .
{/ 0
get1 4
;4 5
set6 9
;9 :
}; <
public 
CopyColorPass 
( 
RenderPassEvent ,
evt- 0
,0 1
Material2 :
samplingMaterial; K
,K L
MaterialM U
copyColorMaterialV g
=h i
nullj n
)n o
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @
CopyColorPass@ M
)M N
)N O
;O P
m_SamplingMaterial 
=  
samplingMaterial! 1
;1 2
m_CopyColorMaterial 
=  !
copyColorMaterial" 3
;3 4&
m_SampleOffsetShaderHandle &
=' (
Shader) /
./ 0
PropertyToID0 <
(< =
$str= L
)L M
;M N
renderPassEvent   
=   
evt   !
;  ! " 
m_DownsamplingMethod!!  
=!!! "
Downsampling!!# /
.!!/ 0
None!!0 4
;!!4 5
}"" 	
public)) 
void)) 
Setup)) 
()) "
RenderTargetIdentifier)) 0
source))1 7
,))7 8
RenderTargetHandle))9 K
destination))L W
,))W X
Downsampling))Y e
downsampling))f r
)))r s
{** 	
this++ 
.++ 
source++ 
=++ 
source++  
;++  !
this,, 
.,, 
destination,, 
=,, 
destination,, *
;,,* + 
m_DownsamplingMethod--  
=--! "
downsampling--# /
;--/ 0
}.. 	
public00 
override00 
void00 
OnCameraSetup00 *
(00* +
CommandBuffer00+ 8
cmd009 <
,00< =
ref00> A
RenderingData00B O
renderingData00P ]
)00] ^
{11 	#
RenderTextureDescriptor22 #

descriptor22$ .
=22/ 0
renderingData221 >
.22> ?

cameraData22? I
.22I J"
cameraTargetDescriptor22J `
;22` a

descriptor33 
.33 
msaaSamples33 "
=33# $
$num33% &
;33& '

descriptor44 
.44 
depthBufferBits44 &
=44' (
$num44) *
;44* +
if55 
(55  
m_DownsamplingMethod55 $
==55% '
Downsampling55( 4
.554 5
_2xBilinear555 @
)55@ A
{66 

descriptor77 
.77 
width77  
/=77! #
$num77$ %
;77% &

descriptor88 
.88 
height88 !
/=88" $
$num88% &
;88& '
}99 
else:: 
if:: 
(::  
m_DownsamplingMethod:: )
==::* ,
Downsampling::- 9
.::9 :
_4xBox::: @
||::A C 
m_DownsamplingMethod::D X
==::Y [
Downsampling::\ h
.::h i
_4xBilinear::i t
)::t u
{;; 

descriptor<< 
.<< 
width<<  
/=<<! #
$num<<$ %
;<<% &

descriptor== 
.== 
height== !
/===" $
$num==% &
;==& '
}>> 
cmd@@ 
.@@ 
GetTemporaryRT@@ 
(@@ 
destination@@ *
.@@* +
id@@+ -
,@@- .

descriptor@@/ 9
,@@9 : 
m_DownsamplingMethod@@; O
==@@P R
Downsampling@@S _
.@@_ `
None@@` d
?@@e f

FilterMode@@g q
.@@q r
Point@@r w
:@@x y

FilterMode	@@z Ñ
.
@@Ñ Ö
Bilinear
@@Ö ç
)
@@ç é
;
@@é è
}AA 	
publicDD 
overrideDD 
voidDD 
ExecuteDD $
(DD$ %#
ScriptableRenderContextDD% <
contextDD= D
,DDD E
refDDF I
RenderingDataDDJ W
renderingDataDDX e
)DDe f
{EE 	
ifFF 
(FF 
m_SamplingMaterialFF "
==FF# %
nullFF& *
)FF* +
{GG 
DebugHH 
.HH 
LogErrorFormatHH $
(HH$ %
$str	HH% å
,
HHå ç 
m_SamplingMaterial
HHé †
,
HH† °
GetType
HH¢ ©
(
HH© ™
)
HH™ ´
.
HH´ ¨
Name
HH¨ ∞
)
HH∞ ±
;
HH± ≤
returnII 
;II 
}JJ 
CommandBufferLL 
cmdLL 
=LL 
CommandBufferPoolLL  1
.LL1 2
GetLL2 5
(LL5 6
)LL6 7
;LL7 8
usingMM 
(MM 
newMM 
ProfilingScopeMM %
(MM% &
cmdMM& )
,MM) *
ProfilingSamplerMM+ ;
.MM; <
GetMM< ?
(MM? @
URPProfileIdMM@ L
.MML M
	CopyColorMMM V
)MMV W
)MMW X
)MMX Y
{NN "
RenderTargetIdentifierOO &
opaqueColorRTOO' 4
=OO5 6
destinationOO7 B
.OOB C

IdentifierOOC M
(OOM N
)OON O
;OOO P
ScriptableRendererQQ "
.QQ" #
SetRenderTargetQQ# 2
(QQ2 3
cmdQQ3 6
,QQ6 7
opaqueColorRTQQ8 E
,QQE F$
BuiltinRenderTextureTypeQQG _
.QQ_ `
CameraTargetQQ` l
,QQl m
	clearFlagQQn w
,QQw x

clearColorRR 
)RR 
;RR  
boolTT  
useDrawProceduleBlitTT )
=TT* +
renderingDataTT, 9
.TT9 :

cameraDataTT: D
.TTD E
xrTTE G
.TTG H
enabledTTH O
;TTO P
switchUU 
(UU  
m_DownsamplingMethodUU ,
)UU, -
{VV 
caseWW 
DownsamplingWW %
.WW% &
NoneWW& *
:WW* +
RenderingUtilsXX &
.XX& '
BlitXX' +
(XX+ ,
cmdXX, /
,XX/ 0
sourceXX1 7
,XX7 8
opaqueColorRTXX9 F
,XXF G
m_CopyColorMaterialXXH [
,XX[ \
$numXX] ^
,XX^ _ 
useDrawProceduleBlitXX` t
)XXt u
;XXu v
breakYY 
;YY 
caseZZ 
DownsamplingZZ %
.ZZ% &
_2xBilinearZZ& 1
:ZZ1 2
RenderingUtils[[ &
.[[& '
Blit[[' +
([[+ ,
cmd[[, /
,[[/ 0
source[[1 7
,[[7 8
opaqueColorRT[[9 F
,[[F G
m_CopyColorMaterial[[H [
,[[[ \
$num[[] ^
,[[^ _ 
useDrawProceduleBlit[[` t
)[[t u
;[[u v
break\\ 
;\\ 
case]] 
Downsampling]] %
.]]% &
_4xBox]]& ,
:]], -
m_SamplingMaterial^^ *
.^^* +
SetFloat^^+ 3
(^^3 4&
m_SampleOffsetShaderHandle^^4 N
,^^N O
$num^^P Q
)^^Q R
;^^R S
RenderingUtils__ &
.__& '
Blit__' +
(__+ ,
cmd__, /
,__/ 0
source__1 7
,__7 8
opaqueColorRT__9 F
,__F G
m_SamplingMaterial__H Z
,__Z [
$num__\ ]
,__] ^ 
useDrawProceduleBlit___ s
)__s t
;__t u
break`` 
;`` 
caseaa 
Downsamplingaa %
.aa% &
_4xBilinearaa& 1
:aa1 2
RenderingUtilsbb &
.bb& '
Blitbb' +
(bb+ ,
cmdbb, /
,bb/ 0
sourcebb1 7
,bb7 8
opaqueColorRTbb9 F
,bbF G
m_CopyColorMaterialbbH [
,bb[ \
$numbb] ^
,bb^ _ 
useDrawProceduleBlitbb` t
)bbt u
;bbu v
breakcc 
;cc 
}dd 
}ee 
contextgg 
.gg  
ExecuteCommandBuffergg (
(gg( )
cmdgg) ,
)gg, -
;gg- .
CommandBufferPoolhh 
.hh 
Releasehh %
(hh% &
cmdhh& )
)hh) *
;hh* +
}ii 	
publicll 
overridell 
voidll 
OnCameraCleanupll ,
(ll, -
CommandBufferll- :
cmdll; >
)ll> ?
{mm 	
ifnn 
(nn 
cmdnn 
==nn 
nullnn 
)nn 
throwoo 
newoo !
ArgumentNullExceptionoo /
(oo/ 0
$stroo0 5
)oo5 6
;oo6 7
ifqq 
(qq 
destinationqq 
!=qq 
RenderTargetHandleqq 1
.qq1 2
CameraTargetqq2 >
)qq> ?
{rr 
cmdss 
.ss 
ReleaseTemporaryRTss &
(ss& '
destinationss' 2
.ss2 3
idss3 5
)ss5 6
;ss6 7
destinationtt 
=tt 
RenderTargetHandlett 0
.tt0 1
CameraTargettt1 =
;tt= >
}uu 
}vv 	
}ww 
}xx £Z
†D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\ForwardRendererData.cs
	namespace		 	
UnityEngine		
 
.		 
	Rendering		 
.		  
	Universal		  )
{

 
[ 
Serializable 
, 
ReloadGroup 
, 
ExcludeFromPreset  1
]1 2
[ 
	MovedFrom 
( 
$str +
)+ ,
], -
public 

class 
ForwardRendererData $
:% &"
ScriptableRendererData' =
{ 
[ 	
System	 
. 
Diagnostics 
. 
CodeAnalysis (
.( )
SuppressMessage) 8
(8 9
$str9 P
,P Q
$strR Z
)Z [
][ \
internal 
class &
CreateForwardRendererAsset 1
:2 3
EndNameEditAction4 E
{ 	
public 
override 
void  
Action! '
(' (
int( +

instanceId, 6
,6 7
string8 >
pathName? G
,G H
stringI O
resourceFileP \
)\ ]
{ 
var 
instance 
= 
CreateInstance -
<- .
ForwardRendererData. A
>A B
(B C
)C D
;D E
AssetDatabase 
. 
CreateAsset )
() *
instance* 2
,2 3
pathName4 <
)< =
;= >
ResourceReloader  
.  !
ReloadAllNullIn! 0
(0 1
instance1 9
,9 :(
UniversalRenderPipelineAsset; W
.W X
packagePathX c
)c d
;d e
	Selection 
. 
activeObject &
=' (
instance) 1
;1 2
} 
} 	
[ 	
MenuItem	 
( 
$str V
,V W
priorityX `
=a b
	CoreUtilsc l
.l m%
assetCreateMenuPriority2	m Ö
)
Ö Ü
]
Ü á
static 
void %
CreateForwardRendererData -
(- .
). /
{ 	
ProjectWindowUtil 
. 1
%StartNameEditingIfProjectWindowExists C
(C D
$numD E
,E F
CreateInstanceG U
<U V&
CreateForwardRendererAssetV p
>p q
(q r
)r s
,s t
$str	u ñ
,
ñ ó
null
ò ú
,
ú ù
null
û ¢
)
¢ £
;
£ §
}   	
[## 	
Serializable##	 
,## 
ReloadGroup## "
]##" #
public$$ 
sealed$$ 
class$$ 
ShaderResources$$ +
{%% 	
[&& 
Reload&& 
(&& 
$str&& /
)&&/ 0
]&&0 1
public'' 
Shader'' 
blitPS''  
;''  !
[)) 
Reload)) 
()) 
$str)) 4
)))4 5
]))5 6
public** 
Shader** 
copyDepthPS** %
;**% &
[,, 
Reload,, 
(,, 
$str,, =
),,= >
],,> ?
public-- 
Shader-- 
screenSpaceShadowPS-- -
;--- .
[// 
Reload// 
(// 
$str// 3
)//3 4
]//4 5
public00 
Shader00 

samplingPS00 $
;00$ %
[22 
EditorBrowsable22 
(22  
EditorBrowsableState22 1
.221 2
Never222 7
)227 8
]228 9
public44 
Shader44 
tileDepthInfoPS44 )
;44) *
[66 
EditorBrowsable66 
(66  
EditorBrowsableState66 1
.661 2
Never662 7
)667 8
]668 9
public88 
Shader88 
tileDeferredPS88 (
;88( )
[:: 
Reload:: 
(:: 
$str:: :
)::: ;
]::; <
public;; 
Shader;; 
stencilDeferredPS;; +
;;;+ ,
[== 
Reload== 
(== 
$str== 8
)==8 9
]==9 :
public>> 
Shader>> 
fallbackErrorPS>> )
;>>) *
[@@ 
Reload@@ 
(@@ 
$str@@ 8
)@@8 9
]@@9 :
publicAA 
ShaderAA 
materialErrorPSAA )
;AA) *
}BB 	
[DD 	
ReloadDD	 
(DD 
$strDD 4
)DD4 5
]DD5 6
publicEE 
PostProcessDataEE 
postProcessDataEE .
=EE/ 0
nullEE1 5
;EE5 6
[HH 	
ReloadHH	 
(HH 
$strHH 1
)HH1 2
]HH2 3
publicII 
XRSystemDataII 
xrSystemDataII (
=II) *
nullII+ /
;II/ 0
publicLL 
ShaderResourcesLL 
shadersLL &
=LL' (
nullLL) -
;LL- .
[NN 	
SerializeFieldNN	 
]NN 
	LayerMaskNN "
m_OpaqueLayerMaskNN# 4
=NN5 6
-NN7 8
$numNN8 9
;NN9 :
[OO 	
SerializeFieldOO	 
]OO 
	LayerMaskOO ""
m_TransparentLayerMaskOO# 9
=OO: ;
-OO< =
$numOO= >
;OO> ?
[PP 	
SerializeFieldPP	 
]PP 
StencilStateDataPP )!
m_DefaultStencilStatePP* ?
=PP@ A
newPPB E
StencilStateDataPPF V
(PPV W
)PPW X
{PPY Z
passOperationPP[ h
=PPi j
	StencilOpPPk t
.PPt u
ReplacePPu |
}PP} ~
;PP~ 
[QQ 	
SerializeFieldQQ	 
]QQ 
boolQQ &
m_ShadowTransparentReceiveQQ 8
=QQ9 :
trueQQ; ?
;QQ? @
[RR 	
SerializeFieldRR	 
]RR 
RenderingModeRR &
m_RenderingModeRR' 6
=RR7 8
RenderingModeRR9 F
.RRF G
ForwardRRG N
;RRN O
[SS 	
SerializeFieldSS	 
]SS 
boolSS $
m_AccurateGbufferNormalsSS 6
=SS7 8
falseSS9 >
;SS> ?
	protectedVV 
overrideVV 
ScriptableRendererVV -
CreateVV. 4
(VV4 5
)VV5 6
{WW 	
ifYY 
(YY 
!YY 
ApplicationYY 
.YY 
	isPlayingYY &
)YY& '
{ZZ 
ResourceReloader[[  
.[[  !
TryReloadAllNullIn[[! 3
([[3 4
this[[4 8
,[[8 9(
UniversalRenderPipelineAsset[[: V
.[[V W
packagePath[[W b
)[[b c
;[[c d
ResourceReloader\\  
.\\  !
TryReloadAllNullIn\\! 3
(\\3 4
postProcessData\\4 C
,\\C D(
UniversalRenderPipelineAsset\\E a
.\\a b
packagePath\\b m
)\\m n
;\\n o
ResourceReloader^^  
.^^  !
TryReloadAllNullIn^^! 3
(^^3 4
xrSystemData^^4 @
,^^@ A(
UniversalRenderPipelineAsset^^B ^
.^^^ _
packagePath^^_ j
)^^j k
;^^k l
}`` 
returnbb 
newbb 
ForwardRendererbb &
(bb& '
thisbb' +
)bb+ ,
;bb, -
}cc 	
publichh 
	LayerMaskhh 
opaqueLayerMaskhh (
{ii 	
getjj 
=>jj 
m_OpaqueLayerMaskjj $
;jj$ %
setkk 
{ll 
SetDirtymm 
(mm 
)mm 
;mm 
m_OpaqueLayerMasknn !
=nn" #
valuenn$ )
;nn) *
}oo 
}pp 	
publicuu 
	LayerMaskuu  
transparentLayerMaskuu -
{vv 	
getww 
=>ww "
m_TransparentLayerMaskww )
;ww) *
setxx 
{yy 
SetDirtyzz 
(zz 
)zz 
;zz "
m_TransparentLayerMask{{ &
={{' (
value{{) .
;{{. /
}|| 
}}} 	
public 
StencilStateData 
defaultStencilState  3
{
ÄÄ 	
get
ÅÅ 
=>
ÅÅ #
m_DefaultStencilState
ÅÅ (
;
ÅÅ( )
set
ÇÇ 
{
ÉÉ 
SetDirty
ÑÑ 
(
ÑÑ 
)
ÑÑ 
;
ÑÑ #
m_DefaultStencilState
ÖÖ %
=
ÖÖ& '
value
ÖÖ( -
;
ÖÖ- .
}
ÜÜ 
}
áá 	
public
åå 
bool
åå &
shadowTransparentReceive
åå ,
{
çç 	
get
éé 
=>
éé (
m_ShadowTransparentReceive
éé -
;
éé- .
set
èè 
{
êê 
SetDirty
ëë 
(
ëë 
)
ëë 
;
ëë (
m_ShadowTransparentReceive
íí *
=
íí+ ,
value
íí- 2
;
íí2 3
}
ìì 
}
îî 	
public
ôô 
RenderingMode
ôô 
renderingMode
ôô *
{
öö 	
get
õõ 
=>
õõ 
m_RenderingMode
õõ "
;
õõ" #
set
úú 
{
ùù 
SetDirty
ûû 
(
ûû 
)
ûû 
;
ûû 
m_RenderingMode
üü 
=
üü  !
value
üü" '
;
üü' (
}
†† 
}
°° 	
public
ßß 
bool
ßß $
accurateGbufferNormals
ßß *
{
®® 	
get
©© 
=>
©© &
m_AccurateGbufferNormals
©© +
;
©©+ ,
set
™™ 
{
´´ 
SetDirty
¨¨ 
(
¨¨ 
)
¨¨ 
;
¨¨ &
m_AccurateGbufferNormals
≠≠ (
=
≠≠) *
value
≠≠+ 0
;
≠≠0 1
}
ÆÆ 
}
ØØ 	
	protected
ΩΩ 
override
ΩΩ 
void
ΩΩ 
OnEnable
ΩΩ  (
(
ΩΩ( )
)
ΩΩ) *
{
ææ 	
base
øø 
.
øø 
OnEnable
øø 
(
øø 
)
øø 
;
øø 
if
≈≈ 
(
≈≈ 
shaders
≈≈ 
==
≈≈ 
null
≈≈ 
)
≈≈  
return
∆∆ 
;
∆∆ 
ResourceReloader
…… 
.
……  
TryReloadAllNullIn
…… /
(
……/ 0
this
……0 4
,
……4 5*
UniversalRenderPipelineAsset
……6 R
.
……R S
packagePath
……S ^
)
……^ _
;
……_ `
ResourceReloader
   
.
    
TryReloadAllNullIn
   /
(
  / 0
postProcessData
  0 ?
,
  ? @*
UniversalRenderPipelineAsset
  A ]
.
  ] ^
packagePath
  ^ i
)
  i j
;
  j k
ResourceReloader
ÃÃ 
.
ÃÃ  
TryReloadAllNullIn
ÃÃ /
(
ÃÃ/ 0
xrSystemData
ÃÃ0 <
,
ÃÃ< =*
UniversalRenderPipelineAsset
ÃÃ> Z
.
ÃÃZ [
packagePath
ÃÃ[ f
)
ÃÃf g
;
ÃÃg h
}
œœ 	
}
–– 
}—— Ü
ΩD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\RendererFeatures\DisallowMultipleRendererFeature.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
[ 
AttributeUsage 
( 
AttributeTargets $
.$ %
Class% *
)* +
]+ ,
internal		 
class		 +
DisallowMultipleRendererFeature		 2
:		3 4
	Attribute		5 >
{

 
} 
} ò0
¶D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\Passes\SceneViewDepthCopy.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
internal 
class "
SceneViewDepthCopyPass )
:* + 
ScriptableRenderPass, @
{ 
private 
RenderTargetHandle "
source# )
{* +
get, /
;/ 0
set1 4
;4 5
}6 7
Material 
m_CopyDepthMaterial $
;$ %
const 
string 
m_ProfilerTag "
=# $
$str% @
;@ A
private		 
static		 
readonly		 
ProfilingSampler		  0
m_ProfilingSampler		1 C
=		D E
new		F I
ProfilingSampler		J Z
(		Z [
m_ProfilerTag		[ h
)		h i
;		i j
public "
SceneViewDepthCopyPass %
(% &
RenderPassEvent& 5
evt6 9
,9 :
Material; C
copyDepthMaterialD U
)U V
{ 	
base 
. 
profilingSampler !
=" #
new$ '
ProfilingSampler( 8
(8 9
nameof9 ?
(? @"
SceneViewDepthCopyPass@ V
)V W
)W X
;X Y
m_CopyDepthMaterial 
=  !
copyDepthMaterial" 3
;3 4
renderPassEvent 
= 
evt !
;! "
} 	
public 
void 
Setup 
( 
RenderTargetHandle ,
source- 3
)3 4
{ 	
this 
. 
source 
= 
source  
;  !
} 	
public 
override 
void 
Execute $
($ %#
ScriptableRenderContext% <
context= D
,D E
refF I
RenderingDataJ W
renderingDataX e
)e f
{ 	
if 
( 
m_CopyDepthMaterial #
==$ &
null' +
)+ ,
{ 
Debug 
. 
LogErrorFormat $
($ %
$str	% å
,
å ç!
m_CopyDepthMaterial
é °
,
° ¢
GetType
£ ™
(
™ ´
)
´ ¨
.
¨ ≠
Name
≠ ±
)
± ≤
;
≤ ≥
return 
; 
} 
CommandBuffer"" 
cmd"" 
="" 
CommandBufferPool""  1
.""1 2
Get""2 5
(""5 6
)""6 7
;""7 8
using## 
(## 
new## 
ProfilingScope## %
(##% &
cmd##& )
,##) *
m_ProfilingSampler##+ =
)##= >
)##> ?
{$$ 
	CoreUtils%% 
.%% 
SetRenderTarget%% )
(%%) *
cmd%%* -
,%%- .$
BuiltinRenderTextureType%%/ G
.%%G H
CameraTarget%%H T
)%%T U
;%%U V
cmd&& 
.&& 
SetGlobalTexture&& $
(&&$ %
$str&&% =
,&&= >
source&&? E
.&&E F

Identifier&&F P
(&&P Q
)&&Q R
)&&R S
;&&S T
cmd'' 
.'' 
EnableShaderKeyword'' '
(''' ( 
ShaderKeywordStrings''( <
.''< =
DepthNoMsaa''= H
)''H I
;''I J
cmd(( 
.((  
DisableShaderKeyword(( (
(((( ) 
ShaderKeywordStrings(() =
.((= >

DepthMsaa2((> H
)((H I
;((I J
cmd)) 
.))  
DisableShaderKeyword)) (
())( ) 
ShaderKeywordStrings))) =
.))= >

DepthMsaa4))> H
)))H I
;))I J
cmd** 
.**  
DisableShaderKeyword** (
(**( ) 
ShaderKeywordStrings**) =
.**= >

DepthMsaa8**> H
)**H I
;**I J
ref33 

CameraData33 

cameraData33 )
=33* +
ref33, /
renderingData330 =
.33= >

cameraData33> H
;33H I
float44 
flipSign44 
=44  
(44! "

cameraData44" ,
.44, -+
IsCameraProjectionMatrixFlipped44- L
(44L M
)44M N
)44N O
?44P Q
-44R S
$num44S W
:44X Y
$num44Z ^
;44^ _
Vector455 
scaleBiasRt55 #
=55$ %
(55& '
flipSign55' /
<550 1
$num552 6
)556 7
?66 
new66 
Vector466 !
(66! "
flipSign66" *
,66* +
$num66, 0
,660 1
-662 3
$num663 7
,667 8
$num669 =
)66= >
:77 
new77 
Vector477 !
(77! "
flipSign77" *
,77* +
$num77, 0
,770 1
$num772 6
,776 7
$num778 <
)77< =
;77= >
cmd88 
.88 
SetGlobalVector88 #
(88# $
ShaderPropertyId88$ 4
.884 5
scaleBiasRt885 @
,88@ A
scaleBiasRt88B M
)88M N
;88N O
cmd:: 
.:: 
DrawMesh:: 
(:: 
RenderingUtils:: +
.::+ ,
fullscreenMesh::, :
,::: ;
	Matrix4x4::< E
.::E F
identity::F N
,::N O
m_CopyDepthMaterial::P c
)::c d
;::d e
};; 
context== 
.==  
ExecuteCommandBuffer== (
(==( )
cmd==) ,
)==, -
;==- .
CommandBufferPool>> 
.>> 
Release>> %
(>>% &
cmd>>& )
)>>) *
;>>* +
}?? 	
}@@ 
}AA ≈Q
ùD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.render-pipelines.universal@10.2.2\Runtime\PostProcessUtils.cs
	namespace 	
UnityEngine
 
. 
	Rendering 
.  
	Universal  )
{ 
public 

static 
class 
PostProcessUtils (
{ 
[ 	
System	 
. 
Obsolete 
( 
$str	 Ö
)
Ö Ü
]
Ü á
public 
static 
int 
ConfigureDithering ,
(, -
PostProcessData- <
data= A
,A B
intC F
indexG L
,L M
CameraN T
cameraU [
,[ \
Material] e
materialf n
)n o
{ 	
return 
ConfigureDithering %
(% &
data& *
,* +
index, 1
,1 2
camera3 9
.9 :

pixelWidth: D
,D E
cameraF L
.L M
pixelHeightM X
,X Y
materialZ b
)b c
;c d
}		 	
public 
static 
int 
ConfigureDithering ,
(, -
PostProcessData- <
data= A
,A B
intC F
indexG L
,L M
intN Q
cameraPixelWidthR b
,b c
intd g
cameraPixelHeighth y
,y z
Material	{ É
material
Ñ å
)
å ç
{ 	
var 
	blueNoise 
= 
data  
.  !
textures! )
.) *
blueNoise16LTex* 9
;9 :
if 
( 
	blueNoise 
== 
null !
||" $
	blueNoise% .
.. /
Length/ 5
==6 8
$num9 :
): ;
return 
$num 
; 
if 
( 
++ 
index 
>= 
	blueNoise $
.$ %
Length% +
)+ ,
index 
= 
$num 
; 
float 

rndOffsetX 
= 
Random %
.% &
value& +
;+ ,
float 

rndOffsetY 
= 
Random %
.% &
value& +
;+ ,
var!! 
noiseTex!! 
=!! 
	blueNoise!! $
[!!$ %
index!!% *
]!!* +
;!!+ ,
material## 
.## 

SetTexture## 
(##  
ShaderConstants##  /
.##/ 0
_BlueNoise_Texture##0 B
,##B C
noiseTex##D L
)##L M
;##M N
material$$ 
.$$ 
	SetVector$$ 
($$ 
ShaderConstants$$ .
.$$. /
_Dithering_Params$$/ @
,$$@ A
new$$B E
Vector4$$F M
($$M N
cameraPixelWidth%%  
/%%! "
(%%# $
float%%$ )
)%%) *
noiseTex%%* 2
.%%2 3
width%%3 8
,%%8 9
cameraPixelHeight&& !
/&&" #
(&&$ %
float&&% *
)&&* +
noiseTex&&+ 3
.&&3 4
height&&4 :
,&&: ;

rndOffsetX'' 
,'' 

rndOffsetY(( 
))) 
))) 
;)) 
return++ 
index++ 
;++ 
},, 	
[.. 	
System..	 
... 
Obsolete.. 
(.. 
$str	.. Ö
)
..Ö Ü
]
..Ü á
public// 
static// 
void// 
ConfigureFilmGrain// -
(//- .
PostProcessData//. =
data//> B
,//B C
	FilmGrain//D M
settings//N V
,//V W
Camera//X ^
camera//_ e
,//e f
Material//g o
material//p x
)//x y
{00 	
ConfigureFilmGrain11 
(11 
data11 #
,11# $
settings11% -
,11- .
camera11/ 5
.115 6

pixelWidth116 @
,11@ A
camera11B H
.11H I
pixelHeight11I T
,11T U
material11V ^
)11^ _
;11_ `
}22 	
public55 
static55 
void55 
ConfigureFilmGrain55 -
(55- .
PostProcessData55. =
data55> B
,55B C
	FilmGrain55D M
settings55N V
,55V W
int55X [
cameraPixelWidth55\ l
,55l m
int55n q
cameraPixelHeight	55r É
,
55É Ñ
Material
55Ö ç
material
55é ñ
)
55ñ ó
{66 	
var77 
texture77 
=77 
settings77 "
.77" #
texture77# *
.77* +
value77+ 0
;770 1
if99 
(99 
settings99 
.99 
type99 
.99 
value99 #
!=99$ &
FilmGrainLookup99' 6
.996 7
Custom997 =
)99= >
texture:: 
=:: 
data:: 
.:: 
textures:: '
.::' (
filmGrainTex::( 4
[::4 5
(::5 6
int::6 9
)::9 :
settings::: B
.::B C
type::C G
.::G H
value::H M
]::M N
;::N O
float@@ 
offsetX@@ 
=@@ 
Random@@ "
.@@" #
value@@# (
;@@( )
floatAA 
offsetYAA 
=AA 
RandomAA "
.AA" #
valueAA# (
;AA( )
varDD 
tilingParamsDD 
=DD 
textureDD &
==DD' )
nullDD* .
?EE 
Vector4EE 
.EE 
zeroEE 
:FF 
newFF 
Vector4FF 
(FF 
cameraPixelWidthFF .
/FF/ 0
(FF1 2
floatFF2 7
)FF7 8
textureFF8 ?
.FF? @
widthFF@ E
,FFE F
cameraPixelHeightFFG X
/FFY Z
(FF[ \
floatFF\ a
)FFa b
textureFFb i
.FFi j
heightFFj p
,FFp q
offsetXFFr y
,FFy z
offsetY	FF{ Ç
)
FFÇ É
;
FFÉ Ñ
materialHH 
.HH 

SetTextureHH 
(HH  
ShaderConstantsHH  /
.HH/ 0
_Grain_TextureHH0 >
,HH> ?
textureHH@ G
)HHG H
;HHH I
materialII 
.II 
	SetVectorII 
(II 
ShaderConstantsII .
.II. /
_Grain_ParamsII/ <
,II< =
newII> A
Vector2IIB I
(III J
settingsIIJ R
.IIR S
	intensityIIS \
.II\ ]
valueII] b
*IIc d
$numIIe g
,IIg h
settingsIIi q
.IIq r
responseIIr z
.IIz {
value	II{ Ä
)
IIÄ Å
)
IIÅ Ç
;
IIÇ É
materialJJ 
.JJ 
	SetVectorJJ 
(JJ 
ShaderConstantsJJ .
.JJ. /
_Grain_TilingParamsJJ/ B
,JJB C
tilingParamsJJD P
)JJP Q
;JJQ R
}KK 	
internalMM 
staticMM 
voidMM 
SetSourceSizeMM *
(MM* +
CommandBufferMM+ 8
cmdMM9 <
,MM< =#
RenderTextureDescriptorMM> U
descMMV Z
)MMZ [
{NN 	
floatOO 
widthOO 
=OO 
descOO 
.OO 
widthOO $
;OO$ %
floatPP 
heightPP 
=PP 
descPP 
.PP  
heightPP  &
;PP& '
ifQQ 
(QQ 
descQQ 
.QQ 
useDynamicScaleQQ $
)QQ$ %
{RR 
widthSS 
*=SS !
ScalableBufferManagerSS .
.SS. /
widthScaleFactorSS/ ?
;SS? @
heightTT 
*=TT !
ScalableBufferManagerTT /
.TT/ 0
heightScaleFactorTT0 A
;TTA B
}UU 
cmdVV 
.VV 
SetGlobalVectorVV 
(VV  
ShaderConstantsVV  /
.VV/ 0
_SourceSizeVV0 ;
,VV; <
newVV= @
Vector4VVA H
(VVH I
widthVVI N
,VVN O
heightVVP V
,VVV W
$numVVX \
/VV] ^
widthVV_ d
,VVd e
$numVVf j
/VVk l
heightVVm s
)VVs t
)VVt u
;VVu v
}WW 	
staticZZ 
classZZ 
ShaderConstantsZZ $
{[[ 	
public\\ 
static\\ 
readonly\\ "
int\\# &
_Grain_Texture\\' 5
=\\6 7
Shader\\8 >
.\\> ?
PropertyToID\\? K
(\\K L
$str\\L \
)\\\ ]
;\\] ^
public]] 
static]] 
readonly]] "
int]]# &
_Grain_Params]]' 4
=]]5 6
Shader]]7 =
.]]= >
PropertyToID]]> J
(]]J K
$str]]K Z
)]]Z [
;]][ \
public^^ 
static^^ 
readonly^^ "
int^^# &
_Grain_TilingParams^^' :
=^^; <
Shader^^= C
.^^C D
PropertyToID^^D P
(^^P Q
$str^^Q f
)^^f g
;^^g h
public`` 
static`` 
readonly`` "
int``# &
_BlueNoise_Texture``' 9
=``: ;
Shader``< B
.``B C
PropertyToID``C O
(``O P
$str``P d
)``d e
;``e f
publicaa 
staticaa 
readonlyaa "
intaa# &
_Dithering_Paramsaa' 8
=aa: ;
Shaderaa< B
.aaB C
PropertyToIDaaC O
(aaO P
$straaP c
)aac d
;aad e
publiccc 
staticcc 
readonlycc "
intcc# &
_SourceSizecc' 2
=cc3 4
Shadercc5 ;
.cc; <
PropertyToIDcc< H
(ccH I
$strccI V
)ccV W
;ccW X
}dd 	
}ee 
}ff 