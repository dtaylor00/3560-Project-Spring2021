ù¡
óD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ProBuilderMeshFunction.cs
	namespace		 	
UnityEngine		
 
.		 

ProBuilder		  
{

 
public 

sealed 
partial 
class 
ProBuilderMesh  .
:/ 0*
ISerializationCallbackReceiver1 O
{ 
static 
HashSet 
< 
int 
> 
s_CachedHashSet +
=, -
new. 1
HashSet2 9
<9 :
int: =
>= >
(> ?
)? @
;@ A
public 
void 
OnBeforeSerialize %
(% &
)& '
{( )
}) *
public 
void 
OnAfterDeserialize &
(& '
)' (
{ 	
InvalidateCaches 
( 
) 
; 
} 	
void:: 
Awake:: 
(:: 
):: 
{;; 	&
EnsureMeshFilterIsAssigned<< &
(<<& '
)<<' (
;<<( )(
EnsureMeshColliderIsAssigned== (
(==( )
)==) *
;==* +
if?? 
(?? 
vertexCount?? 
>?? 
$num?? 
&&@@ 
	faceCount@@ 
>@@ 
$num@@  
&&AA 
meshSyncStateAA  
==AA! #
MeshSyncStateAA$ 1
.AA1 2
NullAA2 6
)AA6 7
RebuildBB 
(BB 
)BB 
;BB 
}CC 	
voidEE 
ResetEE 
(EE 
)EE 
{FF 	
ifGG 
(GG 
meshSyncStateGG 
!=GG  
MeshSyncStateGG! .
.GG. /
NullGG/ 3
&&GG4 6
meshSyncStateGG7 D
!=GGE G
MeshSyncStateGGH U
.GGU V
InstanceIDMismatchGGV h
)GGh i
{HH 
RebuildII 
(II 
)II 
;II 
ifJJ 
(JJ !
componentHasBeenResetJJ )
!=JJ* ,
nullJJ- 1
)JJ1 2!
componentHasBeenResetKK )
(KK) *
thisKK* .
)KK. /
;KK/ 0
}LL 
}MM 	
voidOO 
	OnDestroyOO 
(OO 
)OO 
{PP 	
ifRR 
(RR 
m_MeshFilterRR 
!=RR 
nullRR  $
||RR% '
thisRR( ,
.RR, -
TryGetComponentRR- <
(RR< =
outRR= @
m_MeshFilterRRA M
)RRM N
)RRN O
m_MeshFilterSS 
.SS 
	hideFlagsSS &
=SS' (
	HideFlagsSS) 2
.SS2 3
NoneSS3 7
;SS7 8
ifUU 
(UU $
componentWillBeDestroyedUU (
!=UU) +
nullUU, 0
)UU0 1$
componentWillBeDestroyedVV (
(VV( )
thisVV) -
)VV- .
;VV. /
ifZZ 
(ZZ 
!ZZ &
preserveMeshAssetOnDestroyZZ +
&&ZZ, .
Application[[ 
.[[ 
isEditor[[ $
&&[[% '
!\\ 
Application\\ 
.\\ 
	isPlaying\\ &
&&\\' )
Time]] 
.]] 

frameCount]] 
>]]  !
$num]]" #
)]]# $
{^^ 
if__ 
(__ 
meshWillBeDestroyed__ '
!=__( *
null__+ /
)__/ 0
meshWillBeDestroyed`` '
(``' (
this``( ,
)``, -
;``- .
elseaa 
DestroyImmediatebb $
(bb$ %

gameObjectbb% /
.bb/ 0
GetComponentbb0 <
<bb< =

MeshFilterbb= G
>bbG H
(bbH I
)bbI J
.bbJ K

sharedMeshbbK U
,bbU V
truebbW [
)bb[ \
;bb\ ]
}cc 
}dd 	
publicii 
voidii 
Clearii 
(ii 
)ii 
{jj 	
m_Facesmm 
=mm 
newmm 
Facemm 
[mm 
$nummm  
]mm  !
;mm! "
m_Positionsnn 
=nn 
newnn 
Vector3nn %
[nn% &
$numnn& '
]nn' (
;nn( )
m_Textures0oo 
=oo 
newoo 
Vector2oo %
[oo% &
$numoo& '
]oo' (
;oo( )
m_Textures2pp 
=pp 
nullpp 
;pp 
m_Textures3qq 
=qq 
nullqq 
;qq 

m_Tangentsrr 
=rr 
nullrr 
;rr 
m_SharedVerticesss 
=ss 
newss "
SharedVertexss# /
[ss/ 0
$numss0 1
]ss1 2
;ss2 3
m_SharedTexturestt 
=tt 
newtt "
SharedVertextt# /
[tt/ 0
$numtt0 1
]tt1 2
;tt2 3(
InvalidateSharedVertexLookupuu (
(uu( )
)uu) *
;uu* +)
InvalidateSharedTextureLookupvv )
(vv) *
)vv* +
;vv+ ,
m_Colorsww 
=ww 
nullww 
;ww 
ClearSelectionxx 
(xx 
)xx 
;xx 
}yy 	
internal{{ 
void{{ &
EnsureMeshFilterIsAssigned{{ 0
({{0 1
){{1 2
{|| 	
if}} 
(}} 
filter}} 
==}} 
null}} 
)}} 
m_MeshFilter~~ 
=~~ 

gameObject~~ )
.~~) *
AddComponent~~* 6
<~~6 7

MeshFilter~~7 A
>~~A B
(~~B C
)~~C D
;~~D E
m_MeshFilter
ÅÅ 
.
ÅÅ 
	hideFlags
ÅÅ "
=
ÅÅ# $#
k_MeshFilterHideFlags
ÅÅ% :
;
ÅÅ: ;
if
ÑÑ 
(
ÑÑ 
!
ÑÑ 
renderer
ÑÑ 
.
ÑÑ !
isPartOfStaticBatch
ÑÑ -
&&
ÑÑ. 0
filter
ÑÑ1 7
.
ÑÑ7 8

sharedMesh
ÑÑ8 B
!=
ÑÑC E
m_Mesh
ÑÑF L
)
ÑÑL M
filter
ÖÖ 
.
ÖÖ 

sharedMesh
ÖÖ !
=
ÖÖ" #
m_Mesh
ÖÖ$ *
;
ÖÖ* +
}
ÜÜ 	
internal
àà 
static
àà 
ProBuilderMesh
àà &&
CreateInstanceWithPoints
àà' ?
(
àà? @
Vector3
àà@ G
[
ààG H
]
ààH I
	positions
ààJ S
)
ààS T
{
ââ 	
if
ää 
(
ää 
	positions
ää 
.
ää 
Length
ää  
%
ää! "
$num
ää# $
!=
ää% '
$num
ää( )
)
ää) *
{
ãã 
Log
åå 
.
åå 
Warning
åå 
(
åå 
$str
åå ]
)
åå] ^
;
åå^ _
return
çç 
null
çç 
;
çç 
}
éé 

GameObject
êê 
go
êê 
=
êê 
new
êê 

GameObject
êê  *
(
êê* +
)
êê+ ,
;
êê, -
go
ëë 
.
ëë 
name
ëë 
=
ëë 
$str
ëë '
;
ëë' (
ProBuilderMesh
íí 
pb
íí 
=
íí 
go
íí  "
.
íí" #
AddComponent
íí# /
<
íí/ 0
ProBuilderMesh
íí0 >
>
íí> ?
(
íí? @
)
íí@ A
;
ííA B
pb
ìì 
.
ìì !
m_MeshFormatVersion
ìì "
=
ìì# $!
k_MeshFormatVersion
ìì% 8
;
ìì8 9
pb
îî 
.
îî  
GeometryWithPoints
îî !
(
îî! "
	positions
îî" +
)
îî+ ,
;
îî, -
return
ññ 
pb
ññ 
;
ññ 
}
óó 	
public
ûû 
static
ûû 
ProBuilderMesh
ûû $
Create
ûû% +
(
ûû+ ,
)
ûû, -
{
üü 	
var
†† 
go
†† 
=
†† 
new
†† 

GameObject
†† #
(
††# $
)
††$ %
;
††% &
var
°° 
pb
°° 
=
°° 
go
°° 
.
°° 
AddComponent
°° $
<
°°$ %
ProBuilderMesh
°°% 3
>
°°3 4
(
°°4 5
)
°°5 6
;
°°6 7
pb
¢¢ 
.
¢¢ !
m_MeshFormatVersion
¢¢ "
=
¢¢# $!
k_MeshFormatVersion
¢¢% 8
;
¢¢8 9
pb
££ 
.
££ 
Clear
££ 
(
££ 
)
££ 
;
££ 
return
§§ 
pb
§§ 
;
§§ 
}
•• 	
public
≠≠ 
static
≠≠ 
ProBuilderMesh
≠≠ $
Create
≠≠% +
(
≠≠+ ,
IEnumerable
≠≠, 7
<
≠≠7 8
Vector3
≠≠8 ?
>
≠≠? @
	positions
≠≠A J
,
≠≠J K
IEnumerable
≠≠L W
<
≠≠W X
Face
≠≠X \
>
≠≠\ ]
faces
≠≠^ c
)
≠≠c d
{
ÆÆ 	

GameObject
ØØ 
go
ØØ 
=
ØØ 
new
ØØ 

GameObject
ØØ  *
(
ØØ* +
)
ØØ+ ,
;
ØØ, -
ProBuilderMesh
∞∞ 
pb
∞∞ 
=
∞∞ 
go
∞∞  "
.
∞∞" #
AddComponent
∞∞# /
<
∞∞/ 0
ProBuilderMesh
∞∞0 >
>
∞∞> ?
(
∞∞? @
)
∞∞@ A
;
∞∞A B
go
±± 
.
±± 
name
±± 
=
±± 
$str
±± '
;
±±' (
pb
≤≤ 
.
≤≤ !
m_MeshFormatVersion
≤≤ "
=
≤≤# $!
k_MeshFormatVersion
≤≤% 8
;
≤≤8 9
pb
≥≥ 
.
≥≥ *
RebuildWithPositionsAndFaces
≥≥ +
(
≥≥+ ,
	positions
≥≥, 5
,
≥≥5 6
faces
≥≥7 <
)
≥≥< =
;
≥≥= >
return
¥¥ 
pb
¥¥ 
;
¥¥ 
}
µµ 	
public
¿¿ 
static
¿¿ 
ProBuilderMesh
¿¿ $
Create
¿¿% +
(
¿¿+ ,
IList
¡¡ 
<
¡¡ 
Vertex
¡¡ 
>
¡¡ 
vertices
¡¡ "
,
¡¡" #
IList
¬¬ 
<
¬¬ 
Face
¬¬ 
>
¬¬ 
faces
¬¬ 
,
¬¬ 
IList
√√ 
<
√√ 
SharedVertex
√√ 
>
√√ 
sharedVertices
√√  .
=
√√/ 0
null
√√1 5
,
√√5 6
IList
ƒƒ 
<
ƒƒ 
SharedVertex
ƒƒ 
>
ƒƒ 
sharedTextures
ƒƒ  .
=
ƒƒ/ 0
null
ƒƒ1 5
,
ƒƒ5 6
IList
≈≈ 
<
≈≈ 
Material
≈≈ 
>
≈≈ 
	materials
≈≈ %
=
≈≈& '
null
≈≈( ,
)
≈≈, -
{
∆∆ 	
var
«« 
go
«« 
=
«« 
new
«« 

GameObject
«« #
(
««# $
)
««$ %
;
««% &
go
»» 
.
»» 
name
»» 
=
»» 
$str
»» '
;
»»' (
var
…… 
mesh
…… 
=
…… 
go
…… 
.
…… 
AddComponent
…… &
<
……& '
ProBuilderMesh
……' 5
>
……5 6
(
……6 7
)
……7 8
;
……8 9
if
   
(
   
	materials
   
!=
   
null
   !
)
  ! "
mesh
ÀÀ 
.
ÀÀ 
renderer
ÀÀ 
.
ÀÀ 
sharedMaterials
ÀÀ -
=
ÀÀ. /
	materials
ÀÀ0 9
.
ÀÀ9 :
ToArray
ÀÀ: A
(
ÀÀA B
)
ÀÀB C
;
ÀÀC D
mesh
ÃÃ 
.
ÃÃ !
m_MeshFormatVersion
ÃÃ $
=
ÃÃ% &!
k_MeshFormatVersion
ÃÃ' :
;
ÃÃ: ;
mesh
ÕÕ 
.
ÕÕ 
SetVertices
ÕÕ 
(
ÕÕ 
vertices
ÕÕ %
)
ÕÕ% &
;
ÕÕ& '
mesh
ŒŒ 
.
ŒŒ 
faces
ŒŒ 
=
ŒŒ 
faces
ŒŒ 
;
ŒŒ 
mesh
œœ 
.
œœ 
sharedVertices
œœ 
=
œœ  !
sharedVertices
œœ" 0
;
œœ0 1
mesh
–– 
.
–– 
sharedTextures
–– 
=
––  !
sharedTextures
––" 0
!=
––1 3
null
––4 8
?
––9 :
sharedTextures
––; I
.
––I J
ToArray
––J Q
(
––Q R
)
––R S
:
––T U
null
––V Z
;
––Z [
mesh
—— 
.
—— 
ToMesh
—— 
(
—— 
)
—— 
;
—— 
mesh
““ 
.
““ 
Refresh
““ 
(
““ 
)
““ 
;
““ 
return
”” 
mesh
”” 
;
”” 
}
‘‘ 	
void
÷÷  
GeometryWithPoints
÷÷ 
(
÷÷  
Vector3
÷÷  '
[
÷÷' (
]
÷÷( )
points
÷÷* 0
)
÷÷0 1
{
◊◊ 	
Face
ŸŸ 
[
ŸŸ 
]
ŸŸ 
f
ŸŸ 
=
ŸŸ 
new
ŸŸ 
Face
ŸŸ 
[
ŸŸ  
points
ŸŸ  &
.
ŸŸ& '
Length
ŸŸ' -
/
ŸŸ. /
$num
ŸŸ0 1
]
ŸŸ1 2
;
ŸŸ2 3
for
€€ 
(
€€ 
int
€€ 
i
€€ 
=
€€ 
$num
€€ 
;
€€ 
i
€€ 
<
€€ 
points
€€  &
.
€€& '
Length
€€' -
;
€€- .
i
€€/ 0
+=
€€1 3
$num
€€4 5
)
€€5 6
{
‹‹ 
f
›› 
[
›› 
i
›› 
/
›› 
$num
›› 
]
›› 
=
›› 
new
›› 
Face
›› #
(
››# $
new
››$ '
int
››( +
[
››+ ,
$num
››, -
]
››- .
{
ﬁﬁ 
i
ﬂﬂ 
+
ﬂﬂ 
$num
ﬂﬂ 
,
ﬂﬂ 
i
ﬂﬂ 
+
ﬂﬂ 
$num
ﬂﬂ  
,
ﬂﬂ  !
i
ﬂﬂ" #
+
ﬂﬂ$ %
$num
ﬂﬂ& '
,
ﬂﬂ' (
i
‡‡ 
+
‡‡ 
$num
‡‡ 
,
‡‡ 
i
‡‡ 
+
‡‡ 
$num
‡‡  
,
‡‡  !
i
‡‡" #
+
‡‡$ %
$num
‡‡& '
}
·· 
,
·· 
$num
‚‚ 
,
‚‚  
AutoUnwrapSettings
„„ *
.
„„* +
tile
„„+ /
,
„„/ 0
$num
‰‰ 
,
‰‰ 
-
ÂÂ 
$num
ÂÂ 
,
ÂÂ 
-
ÊÊ 
$num
ÊÊ 
,
ÊÊ 
false
ÁÁ 
)
ÁÁ 
;
ÁÁ 
}
ËË 
Clear
ÍÍ 
(
ÍÍ 
)
ÍÍ 
;
ÍÍ 
	positions
ÎÎ 
=
ÎÎ 
points
ÎÎ 
;
ÎÎ 
m_Faces
ÏÏ 
=
ÏÏ 
f
ÏÏ 
;
ÏÏ 
m_SharedVertices
ÌÌ 
=
ÌÌ 
SharedVertex
ÌÌ +
.
ÌÌ+ ,,
GetSharedVerticesWithPositions
ÌÌ, J
(
ÌÌJ K
points
ÌÌK Q
)
ÌÌQ R
;
ÌÌR S*
InvalidateSharedVertexLookup
ÓÓ (
(
ÓÓ( )
)
ÓÓ) *
;
ÓÓ* +
ToMesh
ÔÔ 
(
ÔÔ 
)
ÔÔ 
;
ÔÔ 
Refresh
 
(
 
)
 
;
 
}
ÒÒ 	
public
¯¯ 
void
¯¯ *
RebuildWithPositionsAndFaces
¯¯ 0
(
¯¯0 1
IEnumerable
¯¯1 <
<
¯¯< =
Vector3
¯¯= D
>
¯¯D E
vertices
¯¯F N
,
¯¯N O
IEnumerable
¯¯P [
<
¯¯[ \
Face
¯¯\ `
>
¯¯` a
faces
¯¯b g
)
¯¯g h
{
˘˘ 	
if
˙˙ 
(
˙˙ 
vertices
˙˙ 
==
˙˙ 
null
˙˙  
)
˙˙  !
throw
˚˚ 
new
˚˚ #
ArgumentNullException
˚˚ /
(
˚˚/ 0
$str
˚˚0 :
)
˚˚: ;
;
˚˚; <
Clear
˝˝ 
(
˝˝ 
)
˝˝ 
;
˝˝ 
m_Positions
˛˛ 
=
˛˛ 
vertices
˛˛ "
.
˛˛" #
ToArray
˛˛# *
(
˛˛* +
)
˛˛+ ,
;
˛˛, -
m_Faces
ˇˇ 
=
ˇˇ 
faces
ˇˇ 
.
ˇˇ 
ToArray
ˇˇ #
(
ˇˇ# $
)
ˇˇ$ %
;
ˇˇ% &
m_SharedVertices
ÄÄ 
=
ÄÄ 
SharedVertex
ÄÄ +
.
ÄÄ+ ,,
GetSharedVerticesWithPositions
ÄÄ, J
(
ÄÄJ K
m_Positions
ÄÄK V
)
ÄÄV W
;
ÄÄW X*
InvalidateSharedVertexLookup
ÅÅ (
(
ÅÅ( )
)
ÅÅ) *
;
ÅÅ* ++
InvalidateSharedTextureLookup
ÇÇ )
(
ÇÇ) *
)
ÇÇ* +
;
ÇÇ+ ,
ToMesh
ÉÉ 
(
ÉÉ 
)
ÉÉ 
;
ÉÉ 
Refresh
ÑÑ 
(
ÑÑ 
)
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
internal
ää 
void
ää 
Rebuild
ää 
(
ää 
)
ää 
{
ãã 	
ToMesh
åå 
(
åå 
)
åå 
;
åå 
Refresh
çç 
(
çç 
)
çç 
;
çç 
}
éé 	
public
îî 
void
îî 
ToMesh
îî 
(
îî 
MeshTopology
îî '
preferredTopology
îî( 9
=
îî: ;
MeshTopology
îî< H
.
îîH I
	Triangles
îîI R
)
îîR S
{
ïï 	
if
óó 
(
óó 
mesh
óó 
==
óó 
null
óó 
)
óó 
{
òò 
mesh
úú 
=
úú 
new
úú 
Mesh
úú 
(
úú  
)
úú  !
;
úú! "
}
ùù 
else
ûû 
if
ûû 
(
ûû 
mesh
ûû 
.
ûû 
vertexCount
ûû %
!=
ûû& (
vertexCount
ûû) 4
)
ûû4 5
{
üü 
mesh
†† 
.
†† 
Clear
†† 
(
†† 
)
†† 
;
†† 
}
°° 
mesh
££ 
.
££ 
indexFormat
££ 
=
££ 
vertexCount
££ *
>
££+ ,
ushort
££- 3
.
££3 4
MaxValue
££4 <
?
££= >
	Rendering
££? H
.
££H I
IndexFormat
££I T
.
££T U
UInt32
££U [
:
££\ ]
	Rendering
££^ g
.
££g h
IndexFormat
££h s
.
££s t
UInt16
££t z
;
££z {
mesh
§§ 
.
§§ 
vertices
§§ 
=
§§ 
m_Positions
§§ '
;
§§' (
mesh
•• 
.
•• 
uv2
•• 
=
•• 
null
•• 
;
•• 
if
ßß 
(
ßß !
m_MeshFormatVersion
ßß #
<
ßß$ %!
k_MeshFormatVersion
ßß& 9
)
ßß9 :
{
®® 
if
©© 
(
©© !
m_MeshFormatVersion
©© '
<
©©( )8
*k_MeshFormatVersionSubmeshMaterialRefactor
©©* T
)
©©T U
Submesh
™™ 
.
™™ ,
MapFaceMaterialsToSubmeshIndex
™™ :
(
™™: ;
this
™™; ?
)
™™? @
;
™™@ A!
m_MeshFormatVersion
¨¨ #
=
¨¨$ %!
k_MeshFormatVersion
¨¨& 9
;
¨¨9 :
}
≠≠ !
m_MeshFormatVersion
ØØ 
=
ØØ  !!
k_MeshFormatVersion
ØØ" 5
;
ØØ5 6
int
±± 
materialCount
±± 
=
±± 
MaterialUtility
±±  /
.
±±/ 0
GetMaterialCount
±±0 @
(
±±@ A
renderer
±±A I
)
±±I J
;
±±J K
Submesh
≥≥ 
[
≥≥ 
]
≥≥ 
	submeshes
≥≥ 
=
≥≥  !
Submesh
≥≥" )
.
≥≥) *
GetSubmeshes
≥≥* 6
(
≥≥6 7
facesInternal
≥≥7 D
,
≥≥D E
materialCount
≥≥F S
,
≥≥S T
preferredTopology
≥≥U f
)
≥≥f g
;
≥≥g h
mesh
µµ 
.
µµ 
subMeshCount
µµ 
=
µµ 
materialCount
µµ  -
;
µµ- .
for
∑∑ 
(
∑∑ 
int
∑∑ 
i
∑∑ 
=
∑∑ 
$num
∑∑ 
;
∑∑ 
i
∑∑ 
<
∑∑ 
mesh
∑∑  $
.
∑∑$ %
subMeshCount
∑∑% 1
;
∑∑1 2
i
∑∑3 4
++
∑∑4 6
)
∑∑6 7
{
∏∏ 
mesh
øø 
.
øø 

SetIndices
øø 
(
øø  
	submeshes
øø  )
[
øø) *
i
øø* +
]
øø+ ,
.
øø, -
	m_Indexes
øø- 6
,
øø6 7
	submeshes
øø8 A
[
øøA B
i
øøB C
]
øøC D
.
øøD E

m_Topology
øøE O
,
øøO P
i
øøQ R
,
øøR S
false
øøT Y
)
øøY Z
;
øøZ [
}
¿¿ 
mesh
¬¬ 
.
¬¬ 
name
¬¬ 
=
¬¬ 
string
¬¬ 
.
¬¬ 
Format
¬¬ %
(
¬¬% &
$str
¬¬& 2
,
¬¬2 3
id
¬¬4 6
)
¬¬6 7
;
¬¬7 8(
EnsureMeshFilterIsAssigned
ƒƒ &
(
ƒƒ& '
)
ƒƒ' (
;
ƒƒ( )
}
≈≈ 	
internal
   
void
   

MakeUnique
    
(
    !
)
  ! "
{
ÀÀ 	
mesh
ÕÕ 
=
ÕÕ 
new
ÕÕ 
Mesh
ÕÕ 
(
ÕÕ 
)
ÕÕ 
;
ÕÕ 
ToMesh
ŒŒ 
(
ŒŒ 
)
ŒŒ 
;
ŒŒ 
Refresh
œœ 
(
œœ 
)
œœ 
;
œœ 
}
–– 	
public
÷÷ 
void
÷÷ 
CopyFrom
÷÷ 
(
÷÷ 
ProBuilderMesh
÷÷ +
other
÷÷, 1
)
÷÷1 2
{
◊◊ 	
if
ÿÿ 
(
ÿÿ 
other
ÿÿ 
==
ÿÿ 
null
ÿÿ 
)
ÿÿ 
throw
ŸŸ 
new
ŸŸ #
ArgumentNullException
ŸŸ /
(
ŸŸ/ 0
$str
ŸŸ0 7
)
ŸŸ7 8
;
ŸŸ8 9
Clear
€€ 
(
€€ 
)
€€ 
;
€€ 
	positions
‹‹ 
=
‹‹ 
other
‹‹ 
.
‹‹ 
	positions
‹‹ '
;
‹‹' (
sharedVertices
›› 
=
›› 
other
›› "
.
››" #$
sharedVerticesInternal
››# 9
;
››9 :
SetSharedTextures
ﬁﬁ 
(
ﬁﬁ 
other
ﬁﬁ #
.
ﬁﬁ# $!
sharedTextureLookup
ﬁﬁ$ 7
)
ﬁﬁ7 8
;
ﬁﬁ8 9
facesInternal
ﬂﬂ 
=
ﬂﬂ 
other
ﬂﬂ !
.
ﬂﬂ! "
faces
ﬂﬂ" '
.
ﬂﬂ' (
Select
ﬂﬂ( .
(
ﬂﬂ. /
x
ﬂﬂ/ 0
=>
ﬂﬂ1 3
new
ﬂﬂ4 7
Face
ﬂﬂ8 <
(
ﬂﬂ< =
x
ﬂﬂ= >
)
ﬂﬂ> ?
)
ﬂﬂ? @
.
ﬂﬂ@ A
ToArray
ﬂﬂA H
(
ﬂﬂH I
)
ﬂﬂI J
;
ﬂﬂJ K
List
·· 
<
·· 
Vector4
·· 
>
·· 
uvs
·· 
=
·· 
new
··  #
List
··$ (
<
··( )
Vector4
··) 0
>
··0 1
(
··1 2
)
··2 3
;
··3 4
for
„„ 
(
„„ 
var
„„ 
i
„„ 
=
„„ 
$num
„„ 
;
„„ 
i
„„ 
<
„„ 
k_UVChannelCount
„„  0
;
„„0 1
i
„„2 3
++
„„3 5
)
„„5 6
{
‰‰ 
other
ÂÂ 
.
ÂÂ 
GetUVs
ÂÂ 
(
ÂÂ 
i
ÂÂ 
,
ÂÂ 
uvs
ÂÂ  #
)
ÂÂ# $
;
ÂÂ$ %
SetUVs
ÊÊ 
(
ÊÊ 
i
ÊÊ 
,
ÊÊ 
uvs
ÊÊ 
)
ÊÊ 
;
ÊÊ 
}
ÁÁ 
tangents
ÈÈ 
=
ÈÈ 
other
ÈÈ 
.
ÈÈ 
tangents
ÈÈ %
;
ÈÈ% &
colors
ÍÍ 
=
ÍÍ 
other
ÍÍ 
.
ÍÍ 
colors
ÍÍ !
;
ÍÍ! "
userCollisions
ÎÎ 
=
ÎÎ 
other
ÎÎ "
.
ÎÎ" #
userCollisions
ÎÎ# 1
;
ÎÎ1 2

selectable
ÏÏ 
=
ÏÏ 
other
ÏÏ 
.
ÏÏ 

selectable
ÏÏ )
;
ÏÏ) *
unwrapParameters
ÌÌ 
=
ÌÌ 
new
ÌÌ "
UnwrapParameters
ÌÌ# 3
(
ÌÌ3 4
other
ÌÌ4 9
.
ÌÌ9 :
unwrapParameters
ÌÌ: J
)
ÌÌJ K
;
ÌÌK L
}
ÓÓ 	
public
ˆˆ 
void
ˆˆ 
Refresh
ˆˆ 
(
ˆˆ 
RefreshMask
ˆˆ '
mask
ˆˆ( ,
=
ˆˆ- .
RefreshMask
ˆˆ/ :
.
ˆˆ: ;
All
ˆˆ; >
)
ˆˆ> ?
{
˜˜ 	
if
˘˘ 
(
˘˘ 
(
˘˘ 
mask
˘˘ 
&
˘˘ 
RefreshMask
˘˘ #
.
˘˘# $
UV
˘˘$ &
)
˘˘& '
>
˘˘( )
$num
˘˘* +
)
˘˘+ ,
	RefreshUV
˙˙ 
(
˙˙ 
facesInternal
˙˙ '
)
˙˙' (
;
˙˙( )
if
¸¸ 
(
¸¸ 
(
¸¸ 
mask
¸¸ 
&
¸¸ 
RefreshMask
¸¸ #
.
¸¸# $
Colors
¸¸$ *
)
¸¸* +
>
¸¸, -
$num
¸¸. /
)
¸¸/ 0
RefreshColors
˝˝ 
(
˝˝ 
)
˝˝ 
;
˝˝  
if
ˇˇ 
(
ˇˇ 
(
ˇˇ 
mask
ˇˇ 
&
ˇˇ 
RefreshMask
ˇˇ #
.
ˇˇ# $
Normals
ˇˇ$ +
)
ˇˇ+ ,
>
ˇˇ- .
$num
ˇˇ/ 0
)
ˇˇ0 1
RefreshNormals
ÄÄ 
(
ÄÄ 
)
ÄÄ  
;
ÄÄ  !
if
ÇÇ 
(
ÇÇ 
(
ÇÇ 
mask
ÇÇ 
&
ÇÇ 
RefreshMask
ÇÇ #
.
ÇÇ# $
Tangents
ÇÇ$ ,
)
ÇÇ, -
>
ÇÇ. /
$num
ÇÇ0 1
)
ÇÇ1 2
RefreshTangents
ÉÉ 
(
ÉÉ  
)
ÉÉ  !
;
ÉÉ! "
if
ÖÖ 
(
ÖÖ 
(
ÖÖ 
mask
ÖÖ 
&
ÖÖ 
RefreshMask
ÖÖ #
.
ÖÖ# $

Collisions
ÖÖ$ .
)
ÖÖ. /
>
ÖÖ0 1
$num
ÖÖ2 3
)
ÖÖ3 4*
EnsureMeshColliderIsAssigned
ÜÜ ,
(
ÜÜ, -
)
ÜÜ- .
;
ÜÜ. /
}
áá 	
internal
ââ 
void
ââ *
EnsureMeshColliderIsAssigned
ââ 2
(
ââ2 3
)
ââ3 4
{
ää 	
if
ãã 
(
ãã 

gameObject
ãã 
.
ãã 
TryGetComponent
ãã )
<
ãã) *
MeshCollider
ãã* 6
>
ãã6 7
(
ãã7 8
out
ãã8 ;
MeshCollider
ãã< H
collider
ããI Q
)
ããQ R
)
ããR S
{
åå 
if
êê 
(
êê 
collider
êê 
.
êê 

sharedMesh
êê '
!=
êê( *
mesh
êê+ /
)
êê/ 0
{
ëë 
collider
íí 
.
íí 

sharedMesh
íí '
=
íí( )
null
íí* .
;
íí. /
collider
ìì 
.
ìì 

sharedMesh
ìì '
=
ìì( )
mesh
ìì* .
;
ìì. /
}
îî 
}
ïï 
}
ññ 	
internal
ûû 
int
ûû #
GetUnusedTextureGroup
ûû *
(
ûû* +
int
ûû+ .
i
ûû/ 0
=
ûû1 2
$num
ûû3 4
)
ûû4 5
{
üü 	
while
†† 
(
†† 
Array
†† 
.
†† 
Exists
†† 
(
††  
facesInternal
††  -
,
††- .
element
††/ 6
=>
††7 9
element
††: A
.
††A B
textureGroup
††B N
==
††O Q
i
††R S
)
††S T
)
††T U
i
°° 
++
°° 
;
°° 
return
££ 
i
££ 
;
££ 
}
§§ 	
static
¶¶ 
bool
¶¶ !
IsValidTextureGroup
¶¶ '
(
¶¶' (
int
¶¶( +
group
¶¶, 1
)
¶¶1 2
{
ßß 	
return
®® 
group
®® 
>
®® 
$num
®® 
;
®® 
}
©© 	
internal
±± 
int
±±  
UnusedElementGroup
±± '
(
±±' (
int
±±( +
i
±±, -
=
±±. /
$num
±±0 1
)
±±1 2
{
≤≤ 	
while
≥≥ 
(
≥≥ 
Array
≥≥ 
.
≥≥ 
Exists
≥≥ 
(
≥≥  
facesInternal
≥≥  -
,
≥≥- .
element
≥≥/ 6
=>
≥≥7 9
element
≥≥: A
.
≥≥A B
elementGroup
≥≥B N
==
≥≥O Q
i
≥≥R S
)
≥≥S T
)
≥≥T U
i
¥¥ 
++
¥¥ 
;
¥¥ 
return
∂∂ 
i
∂∂ 
;
∂∂ 
}
∑∑ 	
public
ππ 
void
ππ 
	RefreshUV
ππ 
(
ππ 
IEnumerable
ππ )
<
ππ) *
Face
ππ* .
>
ππ. /
facesToRefresh
ππ0 >
)
ππ> ?
{
∫∫ 	
if
ΩΩ 
(
ΩΩ 
!
ΩΩ 
	HasArrays
ΩΩ 
(
ΩΩ 

MeshArrays
ΩΩ %
.
ΩΩ% &
Texture0
ΩΩ& .
)
ΩΩ. /
)
ΩΩ/ 0
{
ææ 
m_Textures0
øø 
=
øø 
new
øø !
Vector2
øø" )
[
øø) *
vertexCount
øø* 5
]
øø5 6
;
øø6 7
foreach
¿¿ 
(
¿¿ 
Face
¿¿ 
f
¿¿ 
in
¿¿  "
facesInternal
¿¿# 0
)
¿¿0 1
f
¡¡ 
.
¡¡ 
manualUV
¡¡ 
=
¡¡  
false
¡¡! &
;
¡¡& '
facesToRefresh
¬¬ 
=
¬¬  
facesInternal
¬¬! .
;
¬¬. /
}
√√ 
s_CachedHashSet
≈≈ 
.
≈≈ 
Clear
≈≈ !
(
≈≈! "
)
≈≈" #
;
≈≈# $
foreach
«« 
(
«« 
var
«« 
face
«« 
in
««  
facesToRefresh
««! /
)
««/ 0
{
»» 
if
…… 
(
…… 
face
…… 
.
…… 
manualUV
…… !
||
……" $
face
……% )
.
……) *
indexesInternal
……* 9
?
……9 :
.
……: ;
Length
……; A
<
……B C
$num
……D E
)
……E F
continue
   
;
   
int
ÃÃ 
textureGroup
ÃÃ  
=
ÃÃ! "
face
ÃÃ# '
.
ÃÃ' (
textureGroup
ÃÃ( 4
;
ÃÃ4 5
if
ŒŒ 
(
ŒŒ 
!
ŒŒ !
IsValidTextureGroup
ŒŒ (
(
ŒŒ( )
textureGroup
ŒŒ) 5
)
ŒŒ5 6
)
ŒŒ6 7
UvUnwrapping
œœ  
.
œœ  !
Unwrap
œœ! '
(
œœ' (
this
œœ( ,
,
œœ, -
face
œœ. 2
)
œœ2 3
;
œœ3 4
else
–– 
if
–– 
(
–– 
s_CachedHashSet
–– (
.
––( )
Add
––) ,
(
––, -
textureGroup
––- 9
)
––9 :
)
––: ;
UvUnwrapping
——  
.
——  !!
ProjectTextureGroup
——! 4
(
——4 5
this
——5 9
,
——9 :
textureGroup
——; G
,
——G H
face
——I M
.
——M N
uv
——N P
)
——P Q
;
——Q R
}
““ 
mesh
‘‘ 
.
‘‘ 
uv
‘‘ 
=
‘‘ 
m_Textures0
‘‘ !
;
‘‘! "
if
÷÷ 
(
÷÷ 
	HasArrays
÷÷ 
(
÷÷ 

MeshArrays
÷÷ $
.
÷÷$ %
Texture2
÷÷% -
)
÷÷- .
)
÷÷. /
mesh
◊◊ 
.
◊◊ 
SetUVs
◊◊ 
(
◊◊ 
$num
◊◊ 
,
◊◊ 
m_Textures2
◊◊ *
)
◊◊* +
;
◊◊+ ,
if
ÿÿ 
(
ÿÿ 
	HasArrays
ÿÿ 
(
ÿÿ 

MeshArrays
ÿÿ $
.
ÿÿ$ %
Texture3
ÿÿ% -
)
ÿÿ- .
)
ÿÿ. /
mesh
ŸŸ 
.
ŸŸ 
SetUVs
ŸŸ 
(
ŸŸ 
$num
ŸŸ 
,
ŸŸ 
m_Textures3
ŸŸ *
)
ŸŸ* +
;
ŸŸ+ ,
}
⁄⁄ 	
internal
‹‹ 
void
‹‹ 

SetGroupUV
‹‹  
(
‹‹  ! 
AutoUnwrapSettings
‹‹! 3
settings
‹‹4 <
,
‹‹< =
int
‹‹> A
group
‹‹B G
)
‹‹G H
{
›› 	
if
ﬁﬁ 
(
ﬁﬁ 
!
ﬁﬁ !
IsValidTextureGroup
ﬁﬁ $
(
ﬁﬁ$ %
group
ﬁﬁ% *
)
ﬁﬁ* +
)
ﬁﬁ+ ,
return
ﬂﬂ 
;
ﬂﬂ 
foreach
·· 
(
·· 
var
·· 
face
·· 
in
··  
facesInternal
··! .
)
··. /
{
‚‚ 
if
„„ 
(
„„ 
face
„„ 
.
„„ 
textureGroup
„„ %
!=
„„& (
group
„„) .
)
„„. /
continue
‰‰ 
;
‰‰ 
face
ÊÊ 
.
ÊÊ 
uv
ÊÊ 
=
ÊÊ 
settings
ÊÊ "
;
ÊÊ" #
}
ÁÁ 
}
ËË 	
void
ÍÍ 
RefreshColors
ÍÍ 
(
ÍÍ 
)
ÍÍ 
{
ÎÎ 	
Mesh
ÏÏ 
m
ÏÏ 
=
ÏÏ 
filter
ÏÏ 
.
ÏÏ 

sharedMesh
ÏÏ &
;
ÏÏ& '
m
ÌÌ 
.
ÌÌ 
colors
ÌÌ 
=
ÌÌ 
m_Colors
ÌÌ 
;
ÌÌ  
}
ÓÓ 	
public
ıı 
void
ıı 
SetFaceColor
ıı  
(
ıı  !
Face
ıı! %
face
ıı& *
,
ıı* +
Color
ıı, 1
color
ıı2 7
)
ıı7 8
{
ˆˆ 	
if
˜˜ 
(
˜˜ 
face
˜˜ 
==
˜˜ 
null
˜˜ 
)
˜˜ 
throw
¯¯ 
new
¯¯ #
ArgumentNullException
¯¯ /
(
¯¯/ 0
$str
¯¯0 6
)
¯¯6 7
;
¯¯7 8
if
˙˙ 
(
˙˙ 
!
˙˙ 
	HasArrays
˙˙ 
(
˙˙ 

MeshArrays
˙˙ %
.
˙˙% &
Color
˙˙& +
)
˙˙+ ,
)
˙˙, -
m_Colors
˚˚ 
=
˚˚ 
ArrayUtility
˚˚ '
.
˚˚' (
Fill
˚˚( ,
(
˚˚, -
Color
˚˚- 2
.
˚˚2 3
white
˚˚3 8
,
˚˚8 9
vertexCount
˚˚: E
)
˚˚E F
;
˚˚F G
foreach
˝˝ 
(
˝˝ 
int
˝˝ 
i
˝˝ 
in
˝˝ 
face
˝˝ "
.
˝˝" #
distinctIndexes
˝˝# 2
)
˝˝2 3
m_Colors
˛˛ 
[
˛˛ 
i
˛˛ 
]
˛˛ 
=
˛˛ 
color
˛˛ #
;
˛˛# $
}
ˇˇ 	
public
ââ 
void
ââ 
SetMaterial
ââ 
(
ââ  
IEnumerable
ââ  +
<
ââ+ ,
Face
ââ, 0
>
ââ0 1
faces
ââ2 7
,
ââ7 8
Material
ââ9 A
material
ââB J
)
ââJ K
{
ää 	
var
ãã 
	materials
ãã 
=
ãã 
renderer
ãã $
.
ãã$ %
sharedMaterials
ãã% 4
;
ãã4 5
var
åå 
submeshCount
åå 
=
åå 
	materials
åå (
.
åå( )
Length
åå) /
;
åå/ 0
var
çç 
index
çç 
=
çç 
-
çç 
$num
çç 
;
çç 
for
èè 
(
èè 
int
èè 
i
èè 
=
èè 
$num
èè 
;
èè 
i
èè 
<
èè 
submeshCount
èè  ,
&&
èè- /
index
èè0 5
<
èè6 7
$num
èè8 9
;
èè9 :
i
èè; <
++
èè< >
)
èè> ?
{
êê 
if
ëë 
(
ëë 
	materials
ëë 
[
ëë 
i
ëë 
]
ëë  
==
ëë! #
material
ëë$ ,
)
ëë, -
index
íí 
=
íí 
i
íí 
;
íí 
}
ìì 
if
ïï 
(
ïï 
index
ïï 
<
ïï 
$num
ïï 
)
ïï 
{
ññ 
var
ôô 
submeshIndexes
ôô "
=
ôô# $
new
ôô% (
bool
ôô) -
[
ôô- .
submeshCount
ôô. :
]
ôô: ;
;
ôô; <
foreach
õõ 
(
õõ 
var
õõ 
face
õõ !
in
õõ" $
m_Faces
õõ% ,
)
õõ, -
submeshIndexes
úú "
[
úú" #
Math
úú# '
.
úú' (
Clamp
úú( -
(
úú- .
face
úú. 2
.
úú2 3
submeshIndex
úú3 ?
,
úú? @
$num
úúA B
,
úúB C
submeshCount
úúD P
-
úúQ R
$num
úúS T
)
úúT U
]
úúU V
=
úúW X
true
úúY ]
;
úú] ^
index
ûû 
=
ûû 
Array
ûû 
.
ûû 
IndexOf
ûû %
(
ûû% &
submeshIndexes
ûû& 4
,
ûû4 5
false
ûû6 ;
)
ûû; <
;
ûû< =
if
°° 
(
°° 
index
°° 
>
°° 
-
°° 
$num
°° 
)
°° 
{
¢¢ 
	materials
££ 
[
££ 
index
££ #
]
££# $
=
££% &
material
££' /
;
££/ 0
renderer
§§ 
.
§§ 
sharedMaterials
§§ ,
=
§§- .
	materials
§§/ 8
;
§§8 9
}
•• 
else
¶¶ 
{
ßß 
index
©© 
=
©© 
	materials
©© %
.
©©% &
Length
©©& ,
;
©©, -
var
™™ 
copy
™™ 
=
™™ 
new
™™ "
Material
™™# +
[
™™+ ,
index
™™, 1
+
™™2 3
$num
™™4 5
]
™™5 6
;
™™6 7
Array
´´ 
.
´´ 
Copy
´´ 
(
´´ 
	materials
´´ (
,
´´( )
copy
´´* .
,
´´. /
index
´´0 5
)
´´5 6
;
´´6 7
copy
¨¨ 
[
¨¨ 
index
¨¨ 
]
¨¨ 
=
¨¨  !
material
¨¨" *
;
¨¨* +
renderer
≠≠ 
.
≠≠ 
sharedMaterials
≠≠ ,
=
≠≠- .
copy
≠≠/ 3
;
≠≠3 4
}
ÆÆ 
}
ØØ 
foreach
±± 
(
±± 
var
±± 
face
±± 
in
±±  
faces
±±! &
)
±±& '
face
≤≤ 
.
≤≤ 
submeshIndex
≤≤ !
=
≤≤" #
index
≤≤$ )
;
≤≤) *
}
≥≥ 	
void
µµ 
RefreshNormals
µµ 
(
µµ 
)
µµ 
{
∂∂ 	
Normals
∑∑ 
.
∑∑ 
CalculateNormals
∑∑ $
(
∑∑$ %
this
∑∑% )
)
∑∑) *
;
∑∑* +
mesh
∏∏ 
.
∏∏ 
normals
∏∏ 
=
∏∏ 
	m_Normals
∏∏ $
;
∏∏$ %
}
ππ 	
void
ªª 
RefreshTangents
ªª 
(
ªª 
)
ªª 
{
ºº 	
Normals
ΩΩ 
.
ΩΩ 
CalculateTangents
ΩΩ %
(
ΩΩ% &
this
ΩΩ& *
)
ΩΩ* +
;
ΩΩ+ ,
mesh
ææ 
.
ææ 
tangents
ææ 
=
ææ 

m_Tangents
ææ &
;
ææ& '
}
øø 	
internal
∆∆ 
int
∆∆ #
GetSharedVertexHandle
∆∆ *
(
∆∆* +
int
∆∆+ .
vertex
∆∆/ 5
)
∆∆5 6
{
«« 	
int
»» 
res
»» 
;
»» 
if
   
(
   "
m_SharedVertexLookup
   $
.
  $ %
TryGetValue
  % 0
(
  0 1
vertex
  1 7
,
  7 8
out
  9 <
res
  = @
)
  @ A
)
  A B
return
ÀÀ 
res
ÀÀ 
;
ÀÀ 
for
ÕÕ 
(
ÕÕ 
int
ÕÕ 
i
ÕÕ 
=
ÕÕ 
$num
ÕÕ 
;
ÕÕ 
i
ÕÕ 
<
ÕÕ 
m_SharedVertices
ÕÕ  0
.
ÕÕ0 1
Length
ÕÕ1 7
;
ÕÕ7 8
i
ÕÕ9 :
++
ÕÕ: <
)
ÕÕ< =
{
ŒŒ 
for
œœ 
(
œœ 
int
œœ 
n
œœ 
=
œœ 
$num
œœ 
,
œœ 
c
œœ  !
=
œœ" #
m_SharedVertices
œœ$ 4
[
œœ4 5
i
œœ5 6
]
œœ6 7
.
œœ7 8
Count
œœ8 =
;
œœ= >
n
œœ? @
<
œœA B
c
œœC D
;
œœD E
n
œœF G
++
œœG I
)
œœI J
if
–– 
(
–– 
m_SharedVertices
–– (
[
––( )
i
––) *
]
––* +
[
––+ ,
n
––, -
]
––- .
==
––/ 1
vertex
––2 8
)
––8 9
return
—— 
i
——  
;
——  !
}
““ 
throw
‘‘ 
new
‘‘ )
ArgumentOutOfRangeException
‘‘ 1
(
‘‘1 2
$str
‘‘2 :
)
‘‘: ;
;
‘‘; <
}
’’ 	
internal
◊◊ 
HashSet
◊◊ 
<
◊◊ 
int
◊◊ 
>
◊◊ $
GetSharedVertexHandles
◊◊ 4
(
◊◊4 5
IEnumerable
◊◊5 @
<
◊◊@ A
int
◊◊A D
>
◊◊D E
vertices
◊◊F N
)
◊◊N O
{
ÿÿ 	
var
ŸŸ 
lookup
ŸŸ 
=
ŸŸ  
sharedVertexLookup
ŸŸ +
;
ŸŸ+ ,
HashSet
⁄⁄ 
<
⁄⁄ 
int
⁄⁄ 
>
⁄⁄ 
common
⁄⁄ 
=
⁄⁄  !
new
⁄⁄" %
HashSet
⁄⁄& -
<
⁄⁄- .
int
⁄⁄. 1
>
⁄⁄1 2
(
⁄⁄2 3
)
⁄⁄3 4
;
⁄⁄4 5
foreach
€€ 
(
€€ 
var
€€ 
i
€€ 
in
€€ 
vertices
€€ &
)
€€& '
common
‹‹ 
.
‹‹ 
Add
‹‹ 
(
‹‹ 
lookup
‹‹ !
[
‹‹! "
i
‹‹" #
]
‹‹# $
)
‹‹$ %
;
‹‹% &
return
›› 
common
›› 
;
›› 
}
ﬁﬁ 	
public
ÊÊ 
List
ÊÊ 
<
ÊÊ 
int
ÊÊ 
>
ÊÊ #
GetCoincidentVertices
ÊÊ .
(
ÊÊ. /
IEnumerable
ÊÊ/ :
<
ÊÊ: ;
int
ÊÊ; >
>
ÊÊ> ?
vertices
ÊÊ@ H
)
ÊÊH I
{
ÁÁ 	
if
ËË 
(
ËË 
vertices
ËË 
==
ËË 
null
ËË  
)
ËË  !
throw
ÈÈ 
new
ÈÈ #
ArgumentNullException
ÈÈ /
(
ÈÈ/ 0
$str
ÈÈ0 :
)
ÈÈ: ;
;
ÈÈ; <
List
ÎÎ 
<
ÎÎ 
int
ÎÎ 
>
ÎÎ 
shared
ÎÎ 
=
ÎÎ 
new
ÎÎ "
List
ÎÎ# '
<
ÎÎ' (
int
ÎÎ( +
>
ÎÎ+ ,
(
ÎÎ, -
)
ÎÎ- .
;
ÎÎ. /#
GetCoincidentVertices
ÏÏ !
(
ÏÏ! "
vertices
ÏÏ" *
,
ÏÏ* +
shared
ÏÏ, 2
)
ÏÏ2 3
;
ÏÏ3 4
return
ÌÌ 
shared
ÌÌ 
;
ÌÌ 
}
ÓÓ 	
public
ˆˆ 
void
ˆˆ #
GetCoincidentVertices
ˆˆ )
(
ˆˆ) *
IEnumerable
ˆˆ* 5
<
ˆˆ5 6
Face
ˆˆ6 :
>
ˆˆ: ;
faces
ˆˆ< A
,
ˆˆA B
List
ˆˆC G
<
ˆˆG H
int
ˆˆH K
>
ˆˆK L

coincident
ˆˆM W
)
ˆˆW X
{
˜˜ 	
if
¯¯ 
(
¯¯ 
faces
¯¯ 
==
¯¯ 
null
¯¯ 
)
¯¯ 
throw
˘˘ 
new
˘˘ #
ArgumentNullException
˘˘ /
(
˘˘/ 0
$str
˘˘0 7
)
˘˘7 8
;
˘˘8 9
if
˚˚ 
(
˚˚ 

coincident
˚˚ 
==
˚˚ 
null
˚˚ "
)
˚˚" #
throw
¸¸ 
new
¸¸ #
ArgumentNullException
¸¸ /
(
¸¸/ 0
$str
¸¸0 <
)
¸¸< =
;
¸¸= >

coincident
˛˛ 
.
˛˛ 
Clear
˛˛ 
(
˛˛ 
)
˛˛ 
;
˛˛ 
s_CachedHashSet
ˇˇ 
.
ˇˇ 
Clear
ˇˇ !
(
ˇˇ! "
)
ˇˇ" #
;
ˇˇ# $
var
ÄÄ 
lookup
ÄÄ 
=
ÄÄ  
sharedVertexLookup
ÄÄ +
;
ÄÄ+ ,
foreach
ÇÇ 
(
ÇÇ 
var
ÇÇ 
face
ÇÇ 
in
ÇÇ  
faces
ÇÇ! &
)
ÇÇ& '
{
ÉÉ 
foreach
ÑÑ 
(
ÑÑ 
var
ÑÑ 
v
ÑÑ 
in
ÑÑ !
face
ÑÑ" &
.
ÑÑ& '%
distinctIndexesInternal
ÑÑ' >
)
ÑÑ> ?
{
ÖÖ 
var
ÜÜ 
common
ÜÜ 
=
ÜÜ  
lookup
ÜÜ! '
[
ÜÜ' (
v
ÜÜ( )
]
ÜÜ) *
;
ÜÜ* +
if
àà 
(
àà 
s_CachedHashSet
àà '
.
àà' (
Add
àà( +
(
àà+ ,
common
àà, 2
)
àà2 3
)
àà3 4
{
ââ 
var
ää 
indices
ää #
=
ää$ %
m_SharedVertices
ää& 6
[
ää6 7
common
ää7 =
]
ää= >
;
ää> ?
for
åå 
(
åå 
int
åå  
i
åå! "
=
åå# $
$num
åå% &
,
åå& '
c
åå( )
=
åå* +
indices
åå, 3
.
åå3 4
Count
åå4 9
;
åå9 :
i
åå; <
<
åå= >
c
åå? @
;
åå@ A
i
ååB C
++
ååC E
)
ååE F

coincident
çç &
.
çç& '
Add
çç' *
(
çç* +
indices
çç+ 2
[
çç2 3
i
çç3 4
]
çç4 5
)
çç5 6
;
çç6 7
}
éé 
}
èè 
}
êê 
}
ëë 	
public
ôô 
void
ôô #
GetCoincidentVertices
ôô )
(
ôô) *
IEnumerable
ôô* 5
<
ôô5 6
Edge
ôô6 :
>
ôô: ;
edges
ôô< A
,
ôôA B
List
ôôC G
<
ôôG H
int
ôôH K
>
ôôK L

coincident
ôôM W
)
ôôW X
{
öö 	
if
õõ 
(
õõ 
faces
õõ 
==
õõ 
null
õõ 
)
õõ 
throw
úú 
new
úú #
ArgumentNullException
úú /
(
úú/ 0
$str
úú0 7
)
úú7 8
;
úú8 9
if
ûû 
(
ûû 

coincident
ûû 
==
ûû 
null
ûû "
)
ûû" #
throw
üü 
new
üü #
ArgumentNullException
üü /
(
üü/ 0
$str
üü0 <
)
üü< =
;
üü= >

coincident
°° 
.
°° 
Clear
°° 
(
°° 
)
°° 
;
°° 
s_CachedHashSet
¢¢ 
.
¢¢ 
Clear
¢¢ !
(
¢¢! "
)
¢¢" #
;
¢¢# $
var
££ 
lookup
££ 
=
££  
sharedVertexLookup
££ +
;
££+ ,
foreach
•• 
(
•• 
var
•• 
edge
•• 
in
••  
edges
••! &
)
••& '
{
¶¶ 
var
ßß 
common
ßß 
=
ßß 
lookup
ßß #
[
ßß# $
edge
ßß$ (
.
ßß( )
a
ßß) *
]
ßß* +
;
ßß+ ,
if
©© 
(
©© 
s_CachedHashSet
©© #
.
©©# $
Add
©©$ '
(
©©' (
common
©©( .
)
©©. /
)
©©/ 0
{
™™ 
var
´´ 
indices
´´ 
=
´´  !
m_SharedVertices
´´" 2
[
´´2 3
common
´´3 9
]
´´9 :
;
´´: ;
for
≠≠ 
(
≠≠ 
int
≠≠ 
i
≠≠ 
=
≠≠  
$num
≠≠! "
,
≠≠" #
c
≠≠$ %
=
≠≠& '
indices
≠≠( /
.
≠≠/ 0
Count
≠≠0 5
;
≠≠5 6
i
≠≠7 8
<
≠≠9 :
c
≠≠; <
;
≠≠< =
i
≠≠> ?
++
≠≠? A
)
≠≠A B

coincident
ÆÆ "
.
ÆÆ" #
Add
ÆÆ# &
(
ÆÆ& '
indices
ÆÆ' .
[
ÆÆ. /
i
ÆÆ/ 0
]
ÆÆ0 1
)
ÆÆ1 2
;
ÆÆ2 3
}
ØØ 
common
±± 
=
±± 
lookup
±± 
[
±±  
edge
±±  $
.
±±$ %
b
±±% &
]
±±& '
;
±±' (
if
≥≥ 
(
≥≥ 
s_CachedHashSet
≥≥ #
.
≥≥# $
Add
≥≥$ '
(
≥≥' (
common
≥≥( .
)
≥≥. /
)
≥≥/ 0
{
¥¥ 
var
µµ 
indices
µµ 
=
µµ  !
m_SharedVertices
µµ" 2
[
µµ2 3
common
µµ3 9
]
µµ9 :
;
µµ: ;
for
∑∑ 
(
∑∑ 
int
∑∑ 
i
∑∑ 
=
∑∑  
$num
∑∑! "
,
∑∑" #
c
∑∑$ %
=
∑∑& '
indices
∑∑( /
.
∑∑/ 0
Count
∑∑0 5
;
∑∑5 6
i
∑∑7 8
<
∑∑9 :
c
∑∑; <
;
∑∑< =
i
∑∑> ?
++
∑∑? A
)
∑∑A B

coincident
∏∏ "
.
∏∏" #
Add
∏∏# &
(
∏∏& '
indices
∏∏' .
[
∏∏. /
i
∏∏/ 0
]
∏∏0 1
)
∏∏1 2
;
∏∏2 3
}
ππ 
}
∫∫ 
}
ªª 	
public
√√ 
void
√√ #
GetCoincidentVertices
√√ )
(
√√) *
IEnumerable
√√* 5
<
√√5 6
int
√√6 9
>
√√9 :
vertices
√√; C
,
√√C D
List
√√E I
<
√√I J
int
√√J M
>
√√M N

coincident
√√O Y
)
√√Y Z
{
ƒƒ 	
if
≈≈ 
(
≈≈ 
vertices
≈≈ 
==
≈≈ 
null
≈≈  
)
≈≈  !
throw
∆∆ 
new
∆∆ #
ArgumentNullException
∆∆ /
(
∆∆/ 0
$str
∆∆0 :
)
∆∆: ;
;
∆∆; <
if
»» 
(
»» 

coincident
»» 
==
»» 
null
»» "
)
»»" #
throw
…… 
new
…… #
ArgumentNullException
…… /
(
……/ 0
$str
……0 <
)
……< =
;
……= >

coincident
ÀÀ 
.
ÀÀ 
Clear
ÀÀ 
(
ÀÀ 
)
ÀÀ 
;
ÀÀ 
s_CachedHashSet
ÃÃ 
.
ÃÃ 
Clear
ÃÃ !
(
ÃÃ! "
)
ÃÃ" #
;
ÃÃ# $
var
ÕÕ 
lookup
ÕÕ 
=
ÕÕ  
sharedVertexLookup
ÕÕ +
;
ÕÕ+ ,
foreach
œœ 
(
œœ 
var
œœ 
v
œœ 
in
œœ 
vertices
œœ &
)
œœ& '
{
–– 
var
—— 
common
—— 
=
—— 
lookup
—— #
[
——# $
v
——$ %
]
——% &
;
——& '
if
”” 
(
”” 
s_CachedHashSet
”” #
.
””# $
Add
””$ '
(
””' (
common
””( .
)
””. /
)
””/ 0
{
‘‘ 
var
’’ 
indices
’’ 
=
’’  !
m_SharedVertices
’’" 2
[
’’2 3
common
’’3 9
]
’’9 :
;
’’: ;
for
◊◊ 
(
◊◊ 
int
◊◊ 
i
◊◊ 
=
◊◊  
$num
◊◊! "
,
◊◊" #
c
◊◊$ %
=
◊◊& '
indices
◊◊( /
.
◊◊/ 0
Count
◊◊0 5
;
◊◊5 6
i
◊◊7 8
<
◊◊9 :
c
◊◊; <
;
◊◊< =
i
◊◊> ?
++
◊◊? A
)
◊◊A B

coincident
ÿÿ "
.
ÿÿ" #
Add
ÿÿ# &
(
ÿÿ& '
indices
ÿÿ' .
[
ÿÿ. /
i
ÿÿ/ 0
]
ÿÿ0 1
)
ÿÿ1 2
;
ÿÿ2 3
}
ŸŸ 
}
⁄⁄ 
}
€€ 	
public
‰‰ 
void
‰‰ #
GetCoincidentVertices
‰‰ )
(
‰‰) *
int
‰‰* -
vertex
‰‰. 4
,
‰‰4 5
List
‰‰6 :
<
‰‰: ;
int
‰‰; >
>
‰‰> ?

coincident
‰‰@ J
)
‰‰J K
{
ÂÂ 	
if
ÊÊ 
(
ÊÊ 

coincident
ÊÊ 
==
ÊÊ 
null
ÊÊ "
)
ÊÊ" #
throw
ÁÁ 
new
ÁÁ #
ArgumentNullException
ÁÁ /
(
ÁÁ/ 0
$str
ÁÁ0 <
)
ÁÁ< =
;
ÁÁ= >
int
ÈÈ 
common
ÈÈ 
;
ÈÈ 
if
ÎÎ 
(
ÎÎ 
!
ÎÎ  
sharedVertexLookup
ÎÎ #
.
ÎÎ# $
TryGetValue
ÎÎ$ /
(
ÎÎ/ 0
vertex
ÎÎ0 6
,
ÎÎ6 7
out
ÎÎ8 ;
common
ÎÎ< B
)
ÎÎB C
)
ÎÎC D
throw
ÏÏ 
new
ÏÏ )
ArgumentOutOfRangeException
ÏÏ 5
(
ÏÏ5 6
$str
ÏÏ6 >
)
ÏÏ> ?
;
ÏÏ? @
var
ÓÓ 
indices
ÓÓ 
=
ÓÓ 
m_SharedVertices
ÓÓ *
[
ÓÓ* +
common
ÓÓ+ 1
]
ÓÓ1 2
;
ÓÓ2 3
for
 
(
 
int
 
i
 
=
 
$num
 
,
 
c
 
=
 
indices
  '
.
' (
Count
( -
;
- .
i
/ 0
<
1 2
c
3 4
;
4 5
i
6 7
++
7 9
)
9 :

coincident
ÒÒ 
.
ÒÒ 
Add
ÒÒ 
(
ÒÒ 
indices
ÒÒ &
[
ÒÒ& '
i
ÒÒ' (
]
ÒÒ( )
)
ÒÒ) *
;
ÒÒ* +
}
ÚÚ 	
public
˚˚ 
void
˚˚ #
SetVerticesCoincident
˚˚ )
(
˚˚) *
IEnumerable
˚˚* 5
<
˚˚5 6
int
˚˚6 9
>
˚˚9 :
vertices
˚˚; C
)
˚˚C D
{
¸¸ 	
var
˝˝ 
lookup
˝˝ 
=
˝˝  
sharedVertexLookup
˝˝ +
;
˝˝+ ,
List
˛˛ 
<
˛˛ 
int
˛˛ 
>
˛˛ 

coincident
˛˛  
=
˛˛! "
new
˛˛# &
List
˛˛' +
<
˛˛+ ,
int
˛˛, /
>
˛˛/ 0
(
˛˛0 1
)
˛˛1 2
;
˛˛2 3#
GetCoincidentVertices
ˇˇ !
(
ˇˇ! "
vertices
ˇˇ" *
,
ˇˇ* +

coincident
ˇˇ, 6
)
ˇˇ6 7
;
ˇˇ7 8
SharedVertex
ÄÄ 
.
ÄÄ 
SetCoincident
ÄÄ &
(
ÄÄ& '
ref
ÄÄ' *
lookup
ÄÄ+ 1
,
ÄÄ1 2

coincident
ÄÄ3 =
)
ÄÄ= >
;
ÄÄ> ?
SetSharedVertices
ÅÅ 
(
ÅÅ 
lookup
ÅÅ $
)
ÅÅ$ %
;
ÅÅ% &
}
ÇÇ 	
internal
ÑÑ 
void
ÑÑ #
SetTexturesCoincident
ÑÑ +
(
ÑÑ+ ,
IEnumerable
ÑÑ, 7
<
ÑÑ7 8
int
ÑÑ8 ;
>
ÑÑ; <
vertices
ÑÑ= E
)
ÑÑE F
{
ÖÖ 	
var
ÜÜ 
lookup
ÜÜ 
=
ÜÜ !
sharedTextureLookup
ÜÜ ,
;
ÜÜ, -
SharedVertex
áá 
.
áá 
SetCoincident
áá &
(
áá& '
ref
áá' *
lookup
áá+ 1
,
áá1 2
vertices
áá3 ;
)
áá; <
;
áá< =
SetSharedTextures
àà 
(
àà 
lookup
àà $
)
àà$ %
;
àà% &
}
ââ 	
internal
ãã 
void
ãã 
AddToSharedVertex
ãã '
(
ãã' (
int
ãã( + 
sharedVertexHandle
ãã, >
,
ãã> ?
int
ãã@ C
vertex
ããD J
)
ããJ K
{
åå 	
if
çç 
(
çç  
sharedVertexHandle
çç "
<
çç# $
$num
çç% &
||
çç' ) 
sharedVertexHandle
çç* <
>=
çç= ?
m_SharedVertices
çç@ P
.
ççP Q
Length
ççQ W
)
ççW X
throw
éé 
new
éé )
ArgumentOutOfRangeException
éé 5
(
éé5 6
$str
éé6 J
)
ééJ K
;
ééK L
m_SharedVertices
êê 
[
êê  
sharedVertexHandle
êê /
]
êê/ 0
.
êê0 1
Add
êê1 4
(
êê4 5
vertex
êê5 ;
)
êê; <
;
êê< =*
InvalidateSharedVertexLookup
ëë (
(
ëë( )
)
ëë) *
;
ëë* +
}
íí 	
internal
îî 
void
îî 
AddSharedVertex
îî %
(
îî% &
SharedVertex
îî& 2
vertex
îî3 9
)
îî9 :
{
ïï 	
if
ññ 
(
ññ 
vertex
ññ 
==
ññ 
null
ññ 
)
ññ 
throw
óó 
new
óó #
ArgumentNullException
óó /
(
óó/ 0
$str
óó0 8
)
óó8 9
;
óó9 :
m_SharedVertices
ôô 
=
ôô 
m_SharedVertices
ôô /
.
ôô/ 0
Add
ôô0 3
(
ôô3 4
vertex
ôô4 :
)
ôô: ;
;
ôô; <*
InvalidateSharedVertexLookup
öö (
(
öö( )
)
öö) *
;
öö* +
}
õõ 	
}
úú 
}ùù ·Y
ìD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ProBuilderSnapping.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static		 

class		 
ProBuilderSnapping		 #
{

 
const 
float  
k_MaxRaySnapDistance (
=) *
Mathf+ 0
.0 1
Infinity1 9
;9 :
public 
static 
Vector3 
	SnapValue '
(' (
Vector3( /
vertex0 6
,6 7
float8 =
snpVal> D
)D E
{ 	
return 
new 
Vector3 
( 
snpVal 
* 
Mathf 
. 
Round $
($ %
vertex% +
.+ ,
x, -
/. /
snpVal0 6
)6 7
,7 8
snpVal 
* 
Mathf 
. 
Round $
($ %
vertex% +
.+ ,
y, -
/. /
snpVal0 6
)6 7
,7 8
snpVal 
* 
Mathf 
. 
Round $
($ %
vertex% +
.+ ,
z, -
/. /
snpVal0 6
)6 7
)7 8
;8 9
} 	
public"" 
static"" 
float"" 
	SnapValue"" %
(""% &
float""& +
val"", /
,""/ 0
float""1 6
snpVal""7 =
)""= >
{## 	
if$$ 
($$ 
snpVal$$ 
<$$ 
Mathf$$ 
.$$ 
Epsilon$$ &
)$$& '
return%% 
val%% 
;%% 
return&& 
snpVal&& 
*&& 
Mathf&& !
.&&! "
Round&&" '
(&&' (
val&&( +
/&&, -
snpVal&&. 4
)&&4 5
;&&5 6
}'' 	
public00 
static00 
Vector300 
	SnapValue00 '
(00' (
Vector300( /
vertex000 6
,006 7
Vector3008 ?
snap00@ D
)00D E
{11 	
float22 
x22 
=22 
vertex22 
.22 
x22 
,22 
y22  !
=22" #
vertex22$ *
.22* +
y22+ ,
,22, -
z22. /
=220 1
vertex222 8
.228 9
z229 :
;22: ;
Vector333 
v33 
=33 
new33 
Vector333 #
(33# $
(44 
Mathf44 
.44 
Abs44 
(44 
snap44 #
.44# $
x44$ %
)44% &
<44' (
$num44) 0
?441 2
x443 4
:445 6
snap447 ;
.44; <
x44< =
*44> ?
Mathf44@ E
.44E F
Round44F K
(44K L
x44L M
/44N O
snap44P T
.44T U
x44U V
)44V W
)44W X
,44X Y
(55 
Mathf55 
.55 
Abs55 
(55 
snap55 #
.55# $
y55$ %
)55% &
<55' (
$num55) 0
?551 2
y553 4
:555 6
snap557 ;
.55; <
y55< =
*55> ?
Mathf55@ E
.55E F
Round55F K
(55K L
y55L M
/55N O
snap55P T
.55T U
y55U V
)55V W
)55W X
,55X Y
(66 
Mathf66 
.66 
Abs66 
(66 
snap66 #
.66# $
z66$ %
)66% &
<66' (
$num66) 0
?661 2
z663 4
:665 6
snap667 ;
.66; <
z66< =
*66> ?
Mathf66@ E
.66E F
Round66F K
(66K L
z66L M
/66N O
snap66P T
.66T U
z66U V
)66V W
)66W X
)77 
;77 
return88 
v88 
;88 
}99 	
publicAA 
staticAA 
voidAA 
SnapVerticesAA '
(AA' (
ProBuilderMeshAA( 6
meshAA7 ;
,AA; <
IEnumerableAA= H
<AAH I
intAAI L
>AAL M
indexesAAN U
,AAU V
Vector3AAW ^
snapAA_ c
)AAc d
{BB 	
Vector3CC 
[CC 
]CC 
vertsCC 
=CC 
meshCC "
.CC" #
positionsInternalCC# 4
;CC4 5
foreachEE 
(EE 
varEE 
vEE 
inEE 
indexesEE %
)EE% &
vertsFF 
[FF 
vFF 
]FF 
=FF 
meshFF 
.FF  
	transformFF  )
.FF) *!
InverseTransformPointFF* ?
(FF? @
	SnapValueFF@ I
(FFI J
meshFFJ N
.FFN O
	transformFFO X
.FFX Y
TransformPointFFY g
(FFg h
vertsFFh m
[FFm n
vFFn o
]FFo p
)FFp q
,FFq r
snapFFs w
)FFw x
)FFx y
;FFy z
}GG 	
internalII 
staticII 
Vector3II .
"GetSnappingMaskBasedOnNormalVectorII  B
(IIB C
Vector3IIC J
normalIIK Q
)IIQ R
{JJ 	
returnKK 
newKK 
Vector3KK 
(KK 
(LL 
MathfLL 
.LL 
ApproximatelyLL $
(LL$ %
MathfLL% *
.LL* +
AbsLL+ .
(LL. /
normalLL/ 5
.LL5 6
xLL6 7
)LL7 8
,LL8 9
$numLL: <
)LL< =
)LL= >
?LL? @
$numLLA C
:LLD E
$numLLF H
,LLH I
(MM 
MathfMM 
.MM 
ApproximatelyMM $
(MM$ %
MathfMM% *
.MM* +
AbsMM+ .
(MM. /
normalMM/ 5
.MM5 6
yMM6 7
)MM7 8
,MM8 9
$numMM: <
)MM< =
)MM= >
?MM? @
$numMMA C
:MMD E
$numMMF H
,MMH I
(NN 
MathfNN 
.NN 
ApproximatelyNN $
(NN$ %
MathfNN% *
.NN* +
AbsNN+ .
(NN. /
normalNN/ 5
.NN5 6
zNN6 7
)NN7 8
,NN8 9
$numNN: <
)NN< =
)NN= >
?NN? @
$numNNA C
:NND E
$numNNF H
)NNH I
;NNI J
}OO 	
internalQQ 
staticQQ 
Vector3QQ 
SnapValueOnRayQQ  .
(QQ. /
RayQQ/ 2
rayQQ3 6
,QQ6 7
floatQQ8 =
distanceQQ> F
,QQF G
floatQQH M
snapQQN R
,QQR S
Vector3MaskQQT _
maskQQ` d
)QQd e
{RR 	
varSS 
nearestSS 
=SS  
k_MaxRaySnapDistanceSS .
;SS. /
varUU 

forwardRayUU 
=UU 
newUU  
RayUU! $
(UU$ %
rayUU% (
.UU( )
originUU) /
,UU/ 0
rayUU1 4
.UU4 5
	directionUU5 >
)UU> ?
;UU? @
varVV 
backwardsRayVV 
=VV 
newVV "
RayVV# &
(VV& '
rayVV' *
.VV* +
originVV+ 1
,VV1 2
-VV3 4
rayVV4 7
.VV7 8
	directionVV8 A
)VVA B
;VVB C
forXX 
(XX 
intXX 
iXX 
=XX 
$numXX 
;XX 
iXX 
<XX 
$numXX  !
;XX! "
iXX# $
++XX$ &
)XX& '
{YY 
ifZZ 
(ZZ 
maskZZ 
[ZZ 
iZZ 
]ZZ 
>ZZ 
$numZZ  
)ZZ  !
{[[ 
var\\ 
dir\\ 
=\\ 
new\\ !
Vector3Mask\\" -
(\\- .
new\\. 1
Vector3Mask\\2 =
(\\= >
(\\> ?
byte\\? C
)\\C D
(\\E F
$num\\F G
<<\\H J
i\\K L
)\\L M
)\\M N
)\\N O
;\\O P
var^^ 
prj^^ 
=^^ 
Vector3^^ %
.^^% &
Project^^& -
(^^- .
ray__ 
.__ 
	direction__ %
*__& '
Math__( ,
.__, -
MakeNonZero__- 8
(__8 9
distance__9 A
)__A B
,__B C
dir`` 
*`` 
Mathf`` #
.``# $
Sign``$ (
(``( )
ray``) ,
.``, -
	direction``- 6
[``6 7
i``7 8
]``8 9
)``9 :
)``: ;
;``; <
varbb 
pntbb 
=bb 
raybb !
.bb! "
originbb" (
+bb) *
prjbb+ .
;bb. /
varcc 
planecc 
=cc 
newcc  #
Planecc$ )
(cc) *
dircc* -
,cc- .
	SnapValuecc/ 8
(cc8 9
pntcc9 <
,cc< =
dircc> A
*ccB C
snapccD H
)ccH I
)ccI J
;ccJ K
ifee 
(ee 
Mathfee 
.ee 
Absee  
(ee  !
planeee! &
.ee& '
GetDistanceToPointee' 9
(ee9 :
rayee: =
.ee= >
originee> D
)eeD E
)eeE F
<eeG H
$numeeI O
)eeO P
{ff 
nearestgg 
=gg  !
$numgg" $
;gg$ %
continuehh  
;hh  !
}ii 
floatkk 
dkk 
;kk 
ifmm 
(mm 
planemm 
.mm 
Raycastmm %
(mm% &

forwardRaymm& 0
,mm0 1
outmm2 5
dmm6 7
)mm7 8
&&mm9 ;
Mathfmm< A
.mmA B
AbsmmB E
(mmE F
dmmF G
)mmG H
<mmI J
MathfmmK P
.mmP Q
AbsmmQ T
(mmT U
nearestmmU \
)mm\ ]
)mm] ^
nearestnn 
=nn  !
dnn" #
;nn# $
ifoo 
(oo 
planeoo 
.oo 
Raycastoo %
(oo% &
backwardsRayoo& 2
,oo2 3
outoo4 7
doo8 9
)oo9 :
&&oo; =
Mathfoo> C
.ooC D
AbsooD G
(ooG H
dooH I
)ooI J
<ooK L
MathfooM R
.ooR S
AbsooS V
(ooV W
nearestooW ^
)oo^ _
)oo_ `
nearestpp 
=pp  !
-pp" #
dpp# $
;pp$ %
}qq 
}rr 
returntt 
raytt 
.tt 
origintt 
+tt 
raytt  #
.tt# $
	directiontt$ -
*tt. /
(tt0 1
Mathftt1 6
.tt6 7
Abstt7 :
(tt: ;
nearesttt; B
)ttB C
>=ttD F 
k_MaxRaySnapDistancettG [
?tt\ ]
distancett^ f
:ttg h
nearesttti p
)ttp q
;ttq r
}uu 	
}vv 
}ww €ó
åD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\MeshUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{		 
public 

static 
class 
MeshUtility #
{ 
internal 
static 
Vertex 
[ 
]  #
GeneratePerTriangleMesh! 8
(8 9
Mesh9 =
mesh> B
)B C
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new !
ArgumentNullException /
(/ 0
$str0 6
)6 7
;7 8
Vertex 
[ 
] 
vertices 
= 
mesh  $
.$ %
GetVertices% 0
(0 1
)1 2
;2 3
int 
smc 
= 
mesh 
. 
subMeshCount '
;' (
Vertex 
[ 
] 
tv 
= 
new 
Vertex $
[$ %
mesh% )
.) *
	triangles* 3
.3 4
Length4 :
]: ;
;; <
int 
[ 
] 
[ 
] 
	triangles 
= 
new  #
int$ '
[' (
smc( +
]+ ,
[, -
]- .
;. /
int 
triIndex 
= 
$num 
; 
for 
( 
int 
s 
= 
$num 
; 
s 
< 
smc  #
;# $
s% &
++& (
)( )
{   
	triangles!! 
[!! 
s!! 
]!! 
=!! 
mesh!! #
.!!# $
GetTriangles!!$ 0
(!!0 1
s!!1 2
)!!2 3
;!!3 4
int"" 
tl"" 
="" 
	triangles"" "
[""" #
s""# $
]""$ %
.""% &
Length""& ,
;"", -
for$$ 
($$ 
int$$ 
i$$ 
=$$ 
$num$$ 
;$$ 
i$$  !
<$$" #
tl$$$ &
;$$& '
i$$( )
++$$) +
)$$+ ,
{%% 
tv&& 
[&& 
triIndex&& 
++&& !
]&&! "
=&&# $
new&&% (
Vertex&&) /
(&&/ 0
vertices&&0 8
[&&8 9
	triangles&&9 B
[&&B C
s&&C D
]&&D E
[&&E F
i&&F G
]&&G H
]&&H I
)&&I J
;&&J K
	triangles'' 
['' 
s'' 
]''  
[''  !
i''! "
]''" #
=''$ %
triIndex''& .
-''/ 0
$num''1 2
;''2 3
}(( 
})) 
Vertex++ 
.++ 
SetMesh++ 
(++ 
mesh++ 
,++  
tv++! #
)++# $
;++$ %
mesh-- 
.-- 
subMeshCount-- 
=-- 
smc--  #
;--# $
for// 
(// 
int// 
s// 
=// 
$num// 
;// 
s// 
<// 
smc//  #
;//# $
s//% &
++//& (
)//( )
mesh00 
.00 
SetTriangles00 !
(00! "
	triangles00" +
[00+ ,
s00, -
]00- .
,00. /
s000 1
)001 2
;002 3
return22 
tv22 
;22 
}33 	
public99 
static99 
void99 
GenerateTangent99 *
(99* +
Mesh99+ /
mesh990 4
)994 5
{:: 	
if;; 
(;; 
mesh;; 
==;; 
null;; 
);; 
throw<< 
new<< 
System<<  
.<<  !!
ArgumentNullException<<! 6
(<<6 7
$str<<7 =
)<<= >
;<<> ?
intAA 
[AA 
]AA 
	trianglesAA 
=AA 
meshAA "
.AA" #
	trianglesAA# ,
;AA, -
Vector3BB 
[BB 
]BB 
verticesBB 
=BB  
meshBB! %
.BB% &
verticesBB& .
;BB. /
Vector2CC 
[CC 
]CC 
uvCC 
=CC 
meshCC 
.CC  
uvCC  "
;CC" #
Vector3DD 
[DD 
]DD 
normalsDD 
=DD 
meshDD  $
.DD$ %
normalsDD% ,
;DD, -
intGG 
triangleCountGG 
=GG 
	trianglesGG  )
.GG) *
LengthGG* 0
;GG0 1
intHH 
vertexCountHH 
=HH 
verticesHH &
.HH& '
LengthHH' -
;HH- .
Vector3JJ 
[JJ 
]JJ 
tan1JJ 
=JJ 
newJJ  
Vector3JJ! (
[JJ( )
vertexCountJJ) 4
]JJ4 5
;JJ5 6
Vector3KK 
[KK 
]KK 
tan2KK 
=KK 
newKK  
Vector3KK! (
[KK( )
vertexCountKK) 4
]KK4 5
;KK5 6
Vector4MM 
[MM 
]MM 
tangentsMM 
=MM  
newMM! $
Vector4MM% ,
[MM, -
vertexCountMM- 8
]MM8 9
;MM9 :
forOO 
(OO 
longOO 
aOO 
=OO 
$numOO 
;OO 
aOO 
<OO  
triangleCountOO! .
;OO. /
aOO0 1
+=OO2 4
$numOO5 6
)OO6 7
{PP 
longQQ 
i1QQ 
=QQ 
	trianglesQQ #
[QQ# $
aQQ$ %
+QQ& '
$numQQ( )
]QQ) *
;QQ* +
longRR 
i2RR 
=RR 
	trianglesRR #
[RR# $
aRR$ %
+RR& '
$numRR( )
]RR) *
;RR* +
longSS 
i3SS 
=SS 
	trianglesSS #
[SS# $
aSS$ %
+SS& '
$numSS( )
]SS) *
;SS* +
Vector3UU 
v1UU 
=UU 
verticesUU %
[UU% &
i1UU& (
]UU( )
;UU) *
Vector3VV 
v2VV 
=VV 
verticesVV %
[VV% &
i2VV& (
]VV( )
;VV) *
Vector3WW 
v3WW 
=WW 
verticesWW %
[WW% &
i3WW& (
]WW( )
;WW) *
Vector2YY 
w1YY 
=YY 
uvYY 
[YY  
i1YY  "
]YY" #
;YY# $
Vector2ZZ 
w2ZZ 
=ZZ 
uvZZ 
[ZZ  
i2ZZ  "
]ZZ" #
;ZZ# $
Vector2[[ 
w3[[ 
=[[ 
uv[[ 
[[[  
i3[[  "
][[" #
;[[# $
float]] 
x1]] 
=]] 
v2]] 
.]] 
x]] 
-]]  !
v1]]" $
.]]$ %
x]]% &
;]]& '
float^^ 
x2^^ 
=^^ 
v3^^ 
.^^ 
x^^ 
-^^  !
v1^^" $
.^^$ %
x^^% &
;^^& '
float__ 
y1__ 
=__ 
v2__ 
.__ 
y__ 
-__  !
v1__" $
.__$ %
y__% &
;__& '
float`` 
y2`` 
=`` 
v3`` 
.`` 
y`` 
-``  !
v1``" $
.``$ %
y``% &
;``& '
floataa 
z1aa 
=aa 
v2aa 
.aa 
zaa 
-aa  !
v1aa" $
.aa$ %
zaa% &
;aa& '
floatbb 
z2bb 
=bb 
v3bb 
.bb 
zbb 
-bb  !
v1bb" $
.bb$ %
zbb% &
;bb& '
floatdd 
s1dd 
=dd 
w2dd 
.dd 
xdd 
-dd  !
w1dd" $
.dd$ %
xdd% &
;dd& '
floatee 
s2ee 
=ee 
w3ee 
.ee 
xee 
-ee  !
w1ee" $
.ee$ %
xee% &
;ee& '
floatff 
t1ff 
=ff 
w2ff 
.ff 
yff 
-ff  !
w1ff" $
.ff$ %
yff% &
;ff& '
floatgg 
t2gg 
=gg 
w3gg 
.gg 
ygg 
-gg  !
w1gg" $
.gg$ %
ygg% &
;gg& '
floatii 
rii 
=ii 
$numii 
/ii  
(ii! "
s1ii" $
*ii% &
t2ii' )
-ii* +
s2ii, .
*ii/ 0
t1ii1 3
)ii3 4
;ii4 5
Vector3kk 
sdirkk 
=kk 
newkk "
Vector3kk# *
(kk* +
(kk+ ,
t2kk, .
*kk/ 0
x1kk1 3
-kk4 5
t1kk6 8
*kk9 :
x2kk; =
)kk= >
*kk? @
rkkA B
,kkB C
(kkD E
t2kkE G
*kkH I
y1kkJ L
-kkM N
t1kkO Q
*kkR S
y2kkT V
)kkV W
*kkX Y
rkkZ [
,kk[ \
(kk] ^
t2kk^ `
*kka b
z1kkc e
-kkf g
t1kkh j
*kkk l
z2kkm o
)kko p
*kkq r
rkks t
)kkt u
;kku v
Vector3ll 
tdirll 
=ll 
newll "
Vector3ll# *
(ll* +
(ll+ ,
s1ll, .
*ll/ 0
x2ll1 3
-ll4 5
s2ll6 8
*ll9 :
x1ll; =
)ll= >
*ll? @
rllA B
,llB C
(llD E
s1llE G
*llH I
y2llJ L
-llM N
s2llO Q
*llR S
y1llT V
)llV W
*llX Y
rllZ [
,ll[ \
(ll] ^
s1ll^ `
*lla b
z2llc e
-llf g
s2llh j
*llk l
z1llm o
)llo p
*llq r
rlls t
)llt u
;llu v
tan1nn 
[nn 
i1nn 
]nn 
+=nn 
sdirnn  
;nn  !
tan1oo 
[oo 
i2oo 
]oo 
+=oo 
sdiroo  
;oo  !
tan1pp 
[pp 
i3pp 
]pp 
+=pp 
sdirpp  
;pp  !
tan2rr 
[rr 
i1rr 
]rr 
+=rr 
tdirrr  
;rr  !
tan2ss 
[ss 
i2ss 
]ss 
+=ss 
tdirss  
;ss  !
tan2tt 
[tt 
i3tt 
]tt 
+=tt 
tdirtt  
;tt  !
}uu 
forxx 
(xx 
longxx 
axx 
=xx 
$numxx 
;xx 
axx 
<xx  
vertexCountxx! ,
;xx, -
++xx. 0
axx0 1
)xx1 2
{yy 
Vector3zz 
nzz 
=zz 
normalszz #
[zz# $
azz$ %
]zz% &
;zz& '
Vector3{{ 
t{{ 
={{ 
tan1{{  
[{{  !
a{{! "
]{{" #
;{{# $
Vector3}} 
.}} 
OrthoNormalize}} &
(}}& '
ref}}' *
n}}+ ,
,}}, -
ref}}. 1
t}}2 3
)}}3 4
;}}4 5
tangents~~ 
[~~ 
a~~ 
]~~ 
.~~ 
x~~ 
=~~ 
t~~  !
.~~! "
x~~" #
;~~# $
tangents 
[ 
a 
] 
. 
y 
= 
t  !
.! "
y" #
;# $
tangents
ÄÄ 
[
ÄÄ 
a
ÄÄ 
]
ÄÄ 
.
ÄÄ 
z
ÄÄ 
=
ÄÄ 
t
ÄÄ  !
.
ÄÄ! "
z
ÄÄ" #
;
ÄÄ# $
tangents
ÇÇ 
[
ÇÇ 
a
ÇÇ 
]
ÇÇ 
.
ÇÇ 
w
ÇÇ 
=
ÇÇ 
(
ÇÇ  !
Vector3
ÇÇ! (
.
ÇÇ( )
Dot
ÇÇ) ,
(
ÇÇ, -
Vector3
ÇÇ- 4
.
ÇÇ4 5
Cross
ÇÇ5 :
(
ÇÇ: ;
n
ÇÇ; <
,
ÇÇ< =
t
ÇÇ> ?
)
ÇÇ? @
,
ÇÇ@ A
tan2
ÇÇB F
[
ÇÇF G
a
ÇÇG H
]
ÇÇH I
)
ÇÇI J
<
ÇÇK L
$num
ÇÇM Q
)
ÇÇQ R
?
ÇÇS T
-
ÇÇU V
$num
ÇÇV Z
:
ÇÇ[ \
$num
ÇÇ] a
;
ÇÇa b
}
ÉÉ 
mesh
ÖÖ 
.
ÖÖ 
tangents
ÖÖ 
=
ÖÖ 
tangents
ÖÖ $
;
ÖÖ$ %
}
ÜÜ 	
public
çç 
static
çç 
Mesh
çç 
DeepCopy
çç #
(
çç# $
Mesh
çç$ (
source
çç) /
)
çç/ 0
{
éé 	
Mesh
èè 
m
èè 
=
èè 
new
èè 
Mesh
èè 
(
èè 
)
èè 
;
èè  
CopyTo
êê 
(
êê 
source
êê 
,
êê 
m
êê 
)
êê 
;
êê 
return
ëë 
m
ëë 
;
ëë 
}
íí 	
public
öö 
static
öö 
void
öö 
CopyTo
öö !
(
öö! "
Mesh
öö" &
source
öö' -
,
öö- .
Mesh
öö/ 3
destination
öö4 ?
)
öö? @
{
õõ 	
if
úú 
(
úú 
source
úú 
==
úú 
null
úú 
)
úú 
throw
ùù 
new
ùù 
System
ùù  
.
ùù  !#
ArgumentNullException
ùù! 6
(
ùù6 7
$str
ùù7 ?
)
ùù? @
;
ùù@ A
if
üü 
(
üü 
destination
üü 
==
üü 
null
üü #
)
üü# $
throw
†† 
new
†† 
System
††  
.
††  !#
ArgumentNullException
††! 6
(
††6 7
$str
††7 D
)
††D E
;
††E F
Vector3
¢¢ 
[
¢¢ 
]
¢¢ 
v
¢¢ 
=
¢¢ 
new
¢¢ 
Vector3
¢¢ %
[
¢¢% &
source
¢¢& ,
.
¢¢, -
vertices
¢¢- 5
.
¢¢5 6
Length
¢¢6 <
]
¢¢< =
;
¢¢= >
int
££ 
[
££ 
]
££ 
[
££ 
]
££ 
t
££ 
=
££ 
new
££ 
int
££ 
[
££  
source
££  &
.
££& '
subMeshCount
££' 3
]
££3 4
[
££4 5
]
££5 6
;
££6 7
Vector2
§§ 
[
§§ 
]
§§ 
u
§§ 
=
§§ 
new
§§ 
Vector2
§§ %
[
§§% &
source
§§& ,
.
§§, -
uv
§§- /
.
§§/ 0
Length
§§0 6
]
§§6 7
;
§§7 8
Vector2
•• 
[
•• 
]
•• 
u2
•• 
=
•• 
new
•• 
Vector2
•• &
[
••& '
source
••' -
.
••- .
uv2
••. 1
.
••1 2
Length
••2 8
]
••8 9
;
••9 :
Vector4
¶¶ 
[
¶¶ 
]
¶¶ 
tan
¶¶ 
=
¶¶ 
new
¶¶ 
Vector4
¶¶  '
[
¶¶' (
source
¶¶( .
.
¶¶. /
tangents
¶¶/ 7
.
¶¶7 8
Length
¶¶8 >
]
¶¶> ?
;
¶¶? @
Vector3
ßß 
[
ßß 
]
ßß 
n
ßß 
=
ßß 
new
ßß 
Vector3
ßß %
[
ßß% &
source
ßß& ,
.
ßß, -
normals
ßß- 4
.
ßß4 5
Length
ßß5 ;
]
ßß; <
;
ßß< =
Color32
®® 
[
®® 
]
®® 
c
®® 
=
®® 
new
®® 
Color32
®® %
[
®®% &
source
®®& ,
.
®®, -
colors32
®®- 5
.
®®5 6
Length
®®6 <
]
®®< =
;
®®= >
System
™™ 
.
™™ 
Array
™™ 
.
™™ 
Copy
™™ 
(
™™ 
source
™™ $
.
™™$ %
vertices
™™% -
,
™™- .
v
™™/ 0
,
™™0 1
v
™™2 3
.
™™3 4
Length
™™4 :
)
™™: ;
;
™™; <
for
¨¨ 
(
¨¨ 
int
¨¨ 
i
¨¨ 
=
¨¨ 
$num
¨¨ 
;
¨¨ 
i
¨¨ 
<
¨¨ 
t
¨¨  !
.
¨¨! "
Length
¨¨" (
;
¨¨( )
i
¨¨* +
++
¨¨+ -
)
¨¨- .
t
≠≠ 
[
≠≠ 
i
≠≠ 
]
≠≠ 
=
≠≠ 
source
≠≠ 
.
≠≠ 
GetTriangles
≠≠ *
(
≠≠* +
i
≠≠+ ,
)
≠≠, -
;
≠≠- .
System
ØØ 
.
ØØ 
Array
ØØ 
.
ØØ 
Copy
ØØ 
(
ØØ 
source
ØØ $
.
ØØ$ %
uv
ØØ% '
,
ØØ' (
u
ØØ) *
,
ØØ* +
u
ØØ, -
.
ØØ- .
Length
ØØ. 4
)
ØØ4 5
;
ØØ5 6
System
∞∞ 
.
∞∞ 
Array
∞∞ 
.
∞∞ 
Copy
∞∞ 
(
∞∞ 
source
∞∞ $
.
∞∞$ %
uv2
∞∞% (
,
∞∞( )
u2
∞∞* ,
,
∞∞, -
u2
∞∞. 0
.
∞∞0 1
Length
∞∞1 7
)
∞∞7 8
;
∞∞8 9
System
±± 
.
±± 
Array
±± 
.
±± 
Copy
±± 
(
±± 
source
±± $
.
±±$ %
normals
±±% ,
,
±±, -
n
±±. /
,
±±/ 0
n
±±1 2
.
±±2 3
Length
±±3 9
)
±±9 :
;
±±: ;
System
≤≤ 
.
≤≤ 
Array
≤≤ 
.
≤≤ 
Copy
≤≤ 
(
≤≤ 
source
≤≤ $
.
≤≤$ %
tangents
≤≤% -
,
≤≤- .
tan
≤≤/ 2
,
≤≤2 3
tan
≤≤4 7
.
≤≤7 8
Length
≤≤8 >
)
≤≤> ?
;
≤≤? @
System
≥≥ 
.
≥≥ 
Array
≥≥ 
.
≥≥ 
Copy
≥≥ 
(
≥≥ 
source
≥≥ $
.
≥≥$ %
colors32
≥≥% -
,
≥≥- .
c
≥≥/ 0
,
≥≥0 1
c
≥≥2 3
.
≥≥3 4
Length
≥≥4 :
)
≥≥: ;
;
≥≥; <
destination
µµ 
.
µµ 
Clear
µµ 
(
µµ 
)
µµ 
;
µµ  
destination
∂∂ 
.
∂∂ 
name
∂∂ 
=
∂∂ 
source
∂∂ %
.
∂∂% &
name
∂∂& *
;
∂∂* +
destination
∏∏ 
.
∏∏ 
vertices
∏∏  
=
∏∏! "
v
∏∏# $
;
∏∏$ %
destination
∫∫ 
.
∫∫ 
subMeshCount
∫∫ $
=
∫∫% &
t
∫∫' (
.
∫∫( )
Length
∫∫) /
;
∫∫/ 0
for
ºº 
(
ºº 
int
ºº 
i
ºº 
=
ºº 
$num
ºº 
;
ºº 
i
ºº 
<
ºº 
t
ºº  !
.
ºº! "
Length
ºº" (
;
ºº( )
i
ºº* +
++
ºº+ -
)
ºº- .
destination
ΩΩ 
.
ΩΩ 
SetTriangles
ΩΩ (
(
ΩΩ( )
t
ΩΩ) *
[
ΩΩ* +
i
ΩΩ+ ,
]
ΩΩ, -
,
ΩΩ- .
i
ΩΩ/ 0
)
ΩΩ0 1
;
ΩΩ1 2
destination
øø 
.
øø 
uv
øø 
=
øø 
u
øø 
;
øø 
destination
¿¿ 
.
¿¿ 
uv2
¿¿ 
=
¿¿ 
u2
¿¿  
;
¿¿  !
destination
¡¡ 
.
¡¡ 
tangents
¡¡  
=
¡¡! "
tan
¡¡# &
;
¡¡& '
destination
¬¬ 
.
¬¬ 
normals
¬¬ 
=
¬¬  !
n
¬¬" #
;
¬¬# $
destination
√√ 
.
√√ 
colors32
√√  
=
√√! "
c
√√# $
;
√√$ %
}
ƒƒ 	
internal
ÕÕ 
static
ÕÕ 
T
ÕÕ 
GetMeshChannel
ÕÕ (
<
ÕÕ( )
T
ÕÕ) *
>
ÕÕ* +
(
ÕÕ+ ,

GameObject
ÕÕ, 6

gameObject
ÕÕ7 A
,
ÕÕA B
Func
ÕÕC G
<
ÕÕG H
Mesh
ÕÕH L
,
ÕÕL M
T
ÕÕN O
>
ÕÕO P
attributeGetter
ÕÕQ `
)
ÕÕ` a
where
ÕÕb g
T
ÕÕh i
:
ÕÕj k
IList
ÕÕl q
{
ŒŒ 	
if
œœ 
(
œœ 

gameObject
œœ 
==
œœ 
null
œœ "
)
œœ" #
throw
–– 
new
–– 
System
––  
.
––  !#
ArgumentNullException
––! 6
(
––6 7
$str
––7 C
)
––C D
;
––D E
if
““ 
(
““ 
attributeGetter
““ 
==
““  "
null
““# '
)
““' (
throw
”” 
new
”” 
System
””  
.
””  !#
ArgumentNullException
””! 6
(
””6 7
$str
””7 H
)
””H I
;
””I J

MeshFilter
’’ 
mf
’’ 
=
’’ 

gameObject
’’ &
.
’’& '
GetComponent
’’' 3
<
’’3 4

MeshFilter
’’4 >
>
’’> ?
(
’’? @
)
’’@ A
;
’’A B
Mesh
÷÷ 
mesh
÷÷ 
=
÷÷ 
mf
÷÷ 
!=
÷÷ 
null
÷÷ "
?
÷÷# $
mf
÷÷% '
.
÷÷' (

sharedMesh
÷÷( 2
:
÷÷3 4
null
÷÷5 9
;
÷÷9 :
T
◊◊ 
res
◊◊ 
=
◊◊ 
default
◊◊ 
(
◊◊ 
T
◊◊ 
)
◊◊ 
;
◊◊ 
if
ŸŸ 
(
ŸŸ 
mesh
ŸŸ 
==
ŸŸ 
null
ŸŸ 
)
ŸŸ 
return
⁄⁄ 
res
⁄⁄ 
;
⁄⁄ 
int
‹‹ 
vertexCount
‹‹ 
=
‹‹ 
mesh
‹‹ "
.
‹‹" #
vertexCount
‹‹# .
;
‹‹. /
MeshRenderer
ﬂﬂ 
renderer
ﬂﬂ !
=
ﬂﬂ" #

gameObject
ﬂﬂ$ .
.
ﬂﬂ. /
GetComponent
ﬂﬂ/ ;
<
ﬂﬂ; <
MeshRenderer
ﬂﬂ< H
>
ﬂﬂH I
(
ﬂﬂI J
)
ﬂﬂJ K
;
ﬂﬂK L
Mesh
‡‡ 
vertexStream
‡‡ 
=
‡‡ 
renderer
‡‡  (
!=
‡‡) +
null
‡‡, 0
?
‡‡1 2
renderer
‡‡3 ;
.
‡‡; <%
additionalVertexStreams
‡‡< S
:
‡‡T U
null
‡‡V Z
;
‡‡Z [
if
‚‚ 
(
‚‚ 
vertexStream
‚‚ 
!=
‚‚ 
null
‚‚  $
)
‚‚$ %
{
„„ 
res
‰‰ 
=
‰‰ 
attributeGetter
‰‰ %
(
‰‰% &
vertexStream
‰‰& 2
)
‰‰2 3
;
‰‰3 4
if
ÊÊ 
(
ÊÊ 
res
ÊÊ 
!=
ÊÊ 
null
ÊÊ 
&&
ÊÊ  "
res
ÊÊ# &
.
ÊÊ& '
Count
ÊÊ' ,
==
ÊÊ- /
vertexCount
ÊÊ0 ;
)
ÊÊ; <
return
ÁÁ 
res
ÁÁ 
;
ÁÁ 
}
ËË 
res
ÍÍ 
=
ÍÍ 
attributeGetter
ÍÍ !
(
ÍÍ! "
mesh
ÍÍ" &
)
ÍÍ& '
;
ÍÍ' (
return
ÏÏ 
res
ÏÏ 
!=
ÏÏ 
null
ÏÏ 
&&
ÏÏ !
res
ÏÏ" %
.
ÏÏ% &
Count
ÏÏ& +
==
ÏÏ, .
vertexCount
ÏÏ/ :
?
ÏÏ; <
res
ÏÏ= @
:
ÏÏA B
default
ÏÏC J
(
ÏÏJ K
T
ÏÏK L
)
ÏÏL M
;
ÏÏM N
}
ÌÌ 	
public
ÙÙ 
static
ÙÙ 
string
ÙÙ 
Print
ÙÙ "
(
ÙÙ" #
Mesh
ÙÙ# '
mesh
ÙÙ( ,
)
ÙÙ, -
{
ıı 	
if
ˆˆ 
(
ˆˆ 
mesh
ˆˆ 
==
ˆˆ 
null
ˆˆ 
)
ˆˆ 
throw
˜˜ 
new
˜˜ #
ArgumentNullException
˜˜ /
(
˜˜/ 0
$str
˜˜0 6
)
˜˜6 7
;
˜˜7 8
System
˘˘ 
.
˘˘ 
Text
˘˘ 
.
˘˘ 
StringBuilder
˘˘ %
sb
˘˘& (
=
˘˘) *
new
˘˘+ .
System
˘˘/ 5
.
˘˘5 6
Text
˘˘6 :
.
˘˘: ;
StringBuilder
˘˘; H
(
˘˘H I
)
˘˘I J
;
˘˘J K
sb
˚˚ 
.
˚˚ 

AppendLine
˚˚ 
(
˚˚ 
string
˚˚  
.
˚˚  !
Format
˚˚! '
(
˚˚' (
$str
˚˚( W
,
˚˚W X
mesh
˚˚Y ]
.
˚˚] ^
vertexCount
˚˚^ i
,
˚˚i j
mesh
˚˚k o
.
˚˚o p
	triangles
˚˚p y
.
˚˚y z
Length˚˚z Ä
,˚˚Ä Å
mesh˚˚Ç Ü
.˚˚Ü á
subMeshCount˚˚á ì
)˚˚ì î
)˚˚î ï
;˚˚ï ñ
sb
˝˝ 
.
˝˝ 

AppendLine
˝˝ 
(
˝˝ 
string
˝˝  
.
˝˝  !
Format
˝˝! '
(
˝˝' (
$str
˝˝( g
,
˝˝g h
$str
˛˛ 
,
˛˛  
$str
ˇˇ 
,
ˇˇ 
$str
ÄÄ 
,
ÄÄ 
$str
ÅÅ 
,
ÅÅ 
$str
ÇÇ 
,
ÇÇ 
$str
ÉÉ 
,
ÉÉ 
$str
ÑÑ 
,
ÑÑ 
$str
ÖÖ 
)
ÖÖ 
)
ÖÖ 
;
ÖÖ 
Vector3
áá 
[
áá 
]
áá 
	positions
áá 
=
áá  !
mesh
áá" &
.
áá& '
vertices
áá' /
;
áá/ 0
Vector3
àà 
[
àà 
]
àà 
normals
àà 
=
àà 
mesh
àà  $
.
àà$ %
normals
àà% ,
;
àà, -
Color
ââ 
[
ââ 
]
ââ 
colors
ââ 
=
ââ 
mesh
ââ !
.
ââ! "
colors
ââ" (
;
ââ( )
Vector4
ää 
[
ää 
]
ää 
tangents
ää 
=
ää  
mesh
ää! %
.
ää% &
tangents
ää& .
;
ää. /
List
åå 
<
åå 
Vector4
åå 
>
åå 
uv0
åå 
=
åå 
new
åå  #
List
åå$ (
<
åå( )
Vector4
åå) 0
>
åå0 1
(
åå1 2
)
åå2 3
;
åå3 4
Vector2
çç 
[
çç 
]
çç 
uv2
çç 
=
çç 
mesh
çç  
.
çç  !
uv2
çç! $
;
çç$ %
List
éé 
<
éé 
Vector4
éé 
>
éé 
uv3
éé 
=
éé 
new
éé  #
List
éé$ (
<
éé( )
Vector4
éé) 0
>
éé0 1
(
éé1 2
)
éé2 3
;
éé3 4
List
èè 
<
èè 
Vector4
èè 
>
èè 
uv4
èè 
=
èè 
new
èè  #
List
èè$ (
<
èè( )
Vector4
èè) 0
>
èè0 1
(
èè1 2
)
èè2 3
;
èè3 4
mesh
ëë 
.
ëë 
GetUVs
ëë 
(
ëë 
$num
ëë 
,
ëë 
uv0
ëë 
)
ëë 
;
ëë  
mesh
íí 
.
íí 
GetUVs
íí 
(
íí 
$num
íí 
,
íí 
uv3
íí 
)
íí 
;
íí  
mesh
ìì 
.
ìì 
GetUVs
ìì 
(
ìì 
$num
ìì 
,
ìì 
uv4
ìì 
)
ìì 
;
ìì  
if
ïï 
(
ïï 
	positions
ïï 
!=
ïï 
null
ïï !
&&
ïï" $
	positions
ïï% .
.
ïï. /
Count
ïï/ 4
(
ïï4 5
)
ïï5 6
!=
ïï7 9
mesh
ïï: >
.
ïï> ?
vertexCount
ïï? J
)
ïïJ K
	positions
ññ 
=
ññ 
null
ññ  
;
ññ  !
if
óó 
(
óó 
normals
óó 
!=
óó 
null
óó 
&&
óó  "
normals
óó# *
.
óó* +
Count
óó+ 0
(
óó0 1
)
óó1 2
!=
óó3 5
mesh
óó6 :
.
óó: ;
vertexCount
óó; F
)
óóF G
normals
òò 
=
òò 
null
òò 
;
òò 
if
ôô 
(
ôô 
colors
ôô 
!=
ôô 
null
ôô 
&&
ôô !
colors
ôô" (
.
ôô( )
Count
ôô) .
(
ôô. /
)
ôô/ 0
!=
ôô1 3
mesh
ôô4 8
.
ôô8 9
vertexCount
ôô9 D
)
ôôD E
colors
öö 
=
öö 
null
öö 
;
öö 
if
õõ 
(
õõ 
tangents
õõ 
!=
õõ 
null
õõ  
&&
õõ! #
tangents
õõ$ ,
.
õõ, -
Count
õõ- 2
(
õõ2 3
)
õõ3 4
!=
õõ5 7
mesh
õõ8 <
.
õõ< =
vertexCount
õõ= H
)
õõH I
tangents
úú 
=
úú 
null
úú 
;
úú  
if
ùù 
(
ùù 
uv0
ùù 
.
ùù 
Count
ùù 
(
ùù 
)
ùù 
!=
ùù 
mesh
ùù #
.
ùù# $
vertexCount
ùù$ /
)
ùù/ 0
uv0
ûû 
=
ûû 
null
ûû 
;
ûû 
if
üü 
(
üü 
uv2
üü 
.
üü 
Count
üü 
(
üü 
)
üü 
!=
üü 
mesh
üü #
.
üü# $
vertexCount
üü$ /
)
üü/ 0
uv2
†† 
=
†† 
null
†† 
;
†† 
if
°° 
(
°° 
uv3
°° 
.
°° 
Count
°° 
(
°° 
)
°° 
!=
°° 
mesh
°° #
.
°°# $
vertexCount
°°$ /
)
°°/ 0
uv3
¢¢ 
=
¢¢ 
null
¢¢ 
;
¢¢ 
if
££ 
(
££ 
uv4
££ 
.
££ 
Count
££ 
(
££ 
)
££ 
!=
££ 
mesh
££ #
.
££# $
vertexCount
££$ /
)
££/ 0
uv4
§§ 
=
§§ 
null
§§ 
;
§§ 
sb
¶¶ 
.
¶¶ 

AppendLine
¶¶ 
(
¶¶ 
$str
¶¶ (
)
¶¶( )
;
¶¶) *
for
®® 
(
®® 
int
®® 
i
®® 
=
®® 
$num
®® 
,
®® 
c
®® 
=
®® 
mesh
®®  $
.
®®$ %
vertexCount
®®% 0
;
®®0 1
i
®®2 3
<
®®4 5
c
®®6 7
;
®®7 8
i
®®9 :
++
®®: <
)
®®< =
{
©© 
sb
™™ 
.
™™ 

AppendLine
™™ 
(
™™ 
string
™™ $
.
™™$ %
Format
™™% +
(
™™+ ,
$str
™™, n
,
™™n o
	positions
´´ !
==
´´" $
null
´´% )
?
´´, -
$str
´´. 4
:
´´5 6
string
´´7 =
.
´´= >
Format
´´> D
(
´´D E
$str
´´E ]
,
´´] ^
	positions
´´_ h
[
´´h i
i
´´i j
]
´´j k
.
´´k l
x
´´l m
,
´´m n
	positions
´´o x
[
´´x y
i
´´y z
]
´´z {
.
´´{ |
y
´´| }
,
´´} ~
	positions´´ à
[´´à â
i´´â ä
]´´ä ã
.´´ã å
z´´å ç
)´´ç é
,´´é è
normals
¨¨ 
==
¨¨  "
null
¨¨# '
?
¨¨, -
$str
¨¨. 4
:
¨¨5 6
string
¨¨7 =
.
¨¨= >
Format
¨¨> D
(
¨¨D E
$str
¨¨E ]
,
¨¨] ^
normals
¨¨_ f
[
¨¨f g
i
¨¨g h
]
¨¨h i
.
¨¨i j
x
¨¨j k
,
¨¨k l
normals
¨¨m t
[
¨¨t u
i
¨¨u v
]
¨¨v w
.
¨¨w x
y
¨¨x y
,
¨¨y z
normals¨¨{ Ç
[¨¨Ç É
i¨¨É Ñ
]¨¨Ñ Ö
.¨¨Ö Ü
z¨¨Ü á
)¨¨á à
,¨¨à â
colors
≠≠ 
==
≠≠ !
null
≠≠" &
?
≠≠, -
$str
≠≠. 4
:
≠≠5 6
string
≠≠7 =
.
≠≠= >
Format
≠≠> D
(
≠≠D E
$str
≠≠E e
,
≠≠e f
colors
≠≠g m
[
≠≠m n
i
≠≠n o
]
≠≠o p
.
≠≠p q
r
≠≠q r
,
≠≠r s
colors
≠≠t z
[
≠≠z {
i
≠≠{ |
]
≠≠| }
.
≠≠} ~
g
≠≠~ 
,≠≠ Ä
colors≠≠Å á
[≠≠á à
i≠≠à â
]≠≠â ä
.≠≠ä ã
b≠≠ã å
,≠≠å ç
colors≠≠é î
[≠≠î ï
i≠≠ï ñ
]≠≠ñ ó
.≠≠ó ò
a≠≠ò ô
)≠≠ô ö
,≠≠ö õ
tangents
ÆÆ  
==
ÆÆ! #
null
ÆÆ$ (
?
ÆÆ, -
$str
ÆÆ. 4
:
ÆÆ5 6
string
ÆÆ7 =
.
ÆÆ= >
Format
ÆÆ> D
(
ÆÆD E
$str
ÆÆE e
,
ÆÆe f
tangents
ÆÆg o
[
ÆÆo p
i
ÆÆp q
]
ÆÆq r
.
ÆÆr s
x
ÆÆs t
,
ÆÆt u
tangents
ÆÆv ~
[
ÆÆ~ 
iÆÆ Ä
]ÆÆÄ Å
.ÆÆÅ Ç
yÆÆÇ É
,ÆÆÉ Ñ
tangentsÆÆÖ ç
[ÆÆç é
iÆÆé è
]ÆÆè ê
.ÆÆê ë
zÆÆë í
,ÆÆí ì
tangentsÆÆî ú
[ÆÆú ù
iÆÆù û
]ÆÆû ü
.ÆÆü †
wÆÆ† °
)ÆÆ° ¢
,ÆÆ¢ £
uv0
ØØ 
==
ØØ 
null
ØØ #
?
ØØ, -
$str
ØØ. 4
:
ØØ5 6
string
ØØ7 =
.
ØØ= >
Format
ØØ> D
(
ØØD E
$str
ØØE e
,
ØØe f
uv0
ØØg j
[
ØØj k
i
ØØk l
]
ØØl m
.
ØØm n
x
ØØn o
,
ØØo p
uv0
ØØq t
[
ØØt u
i
ØØu v
]
ØØv w
.
ØØw x
y
ØØx y
,
ØØy z
uv0
ØØ{ ~
[
ØØ~ 
iØØ Ä
]ØØÄ Å
.ØØÅ Ç
zØØÇ É
,ØØÉ Ñ
uv0ØØÖ à
[ØØà â
iØØâ ä
]ØØä ã
.ØØã å
wØØå ç
)ØØç é
,ØØé è
uv2
∞∞ 
==
∞∞ 
null
∞∞ #
?
∞∞, -
$str
∞∞. 4
:
∞∞5 6
string
∞∞7 =
.
∞∞= >
Format
∞∞> D
(
∞∞D E
$str
∞∞E U
,
∞∞U V
uv2
∞∞W Z
[
∞∞Z [
i
∞∞[ \
]
∞∞\ ]
.
∞∞] ^
x
∞∞^ _
,
∞∞_ `
uv2
∞∞a d
[
∞∞d e
i
∞∞e f
]
∞∞f g
.
∞∞g h
y
∞∞h i
)
∞∞i j
,
∞∞j k
uv3
±± 
==
±± 
null
±± #
?
±±, -
$str
±±. 4
:
±±5 6
string
±±7 =
.
±±= >
Format
±±> D
(
±±D E
$str
±±E e
,
±±e f
uv3
±±g j
[
±±j k
i
±±k l
]
±±l m
.
±±m n
x
±±n o
,
±±o p
uv3
±±q t
[
±±t u
i
±±u v
]
±±v w
.
±±w x
y
±±x y
,
±±y z
uv3
±±{ ~
[
±±~ 
i±± Ä
]±±Ä Å
.±±Å Ç
z±±Ç É
,±±É Ñ
uv3±±Ö à
[±±à â
i±±â ä
]±±ä ã
.±±ã å
w±±å ç
)±±ç é
,±±é è
uv4
≤≤ 
==
≤≤ 
null
≤≤ #
?
≤≤, -
$str
≤≤. 4
:
≤≤5 6
string
≤≤7 =
.
≤≤= >
Format
≤≤> D
(
≤≤D E
$str
≤≤E e
,
≤≤e f
uv4
≤≤g j
[
≤≤j k
i
≤≤k l
]
≤≤l m
.
≤≤m n
x
≤≤n o
,
≤≤o p
uv4
≤≤q t
[
≤≤t u
i
≤≤u v
]
≤≤v w
.
≤≤w x
y
≤≤x y
,
≤≤y z
uv4
≤≤{ ~
[
≤≤~ 
i≤≤ Ä
]≤≤Ä Å
.≤≤Å Ç
z≤≤Ç É
,≤≤É Ñ
uv4≤≤Ö à
[≤≤à â
i≤≤â ä
]≤≤ä ã
.≤≤ã å
w≤≤å ç
)≤≤ç é
,≤≤é è
i
≥≥ 
)
≥≥ 
)
≥≥ 
;
≥≥ 
}
¥¥ 
sb
∂∂ 
.
∂∂ 

AppendLine
∂∂ 
(
∂∂ 
$str
∂∂ &
)
∂∂& '
;
∂∂' (
for
∏∏ 
(
∏∏ 
int
∏∏ 
i
∏∏ 
=
∏∏ 
$num
∏∏ 
;
∏∏ 
i
∏∏ 
<
∏∏ 
mesh
∏∏  $
.
∏∏$ %
subMeshCount
∏∏% 1
;
∏∏1 2
i
∏∏3 4
++
∏∏4 6
)
∏∏6 7
{
ππ 
var
∫∫ 
topo
∫∫ 
=
∫∫ 
mesh
∫∫ 
.
∫∫  
GetTopology
∫∫  +
(
∫∫+ ,
i
∫∫, -
)
∫∫- .
;
∫∫. /
var
ªª 
submesh
ªª 
=
ªª 
mesh
ªª "
.
ªª" #

GetIndices
ªª# -
(
ªª- .
i
ªª. /
)
ªª/ 0
;
ªª0 1
sb
ºº 
.
ºº 

AppendLine
ºº 
(
ºº 
$"
ºº  

  Submesh[
ºº  *
{
ºº* +
i
ºº+ ,
}
ºº, -
] (
ºº- 0
{
ºº0 1
topo
ºº1 5
}
ºº5 6
)
ºº6 7
"
ºº7 8
)
ºº8 9
;
ºº9 :
switch
ææ 
(
ææ 
topo
ææ 
)
ææ 
{
øø 
case
¿¿ 
MeshTopology
¿¿ %
.
¿¿% &
Points
¿¿& ,
:
¿¿, -
for
¡¡ 
(
¡¡ 
int
¡¡  
n
¡¡! "
=
¡¡# $
$num
¡¡% &
;
¡¡& '
n
¡¡( )
<
¡¡* +
submesh
¡¡, 3
.
¡¡3 4
Length
¡¡4 :
;
¡¡: ;
n
¡¡< =
+=
¡¡> @
$num
¡¡A B
)
¡¡B C
sb
¬¬ 
.
¬¬ 

AppendLine
¬¬ )
(
¬¬) *
string
¬¬* 0
.
¬¬0 1
Format
¬¬1 7
(
¬¬7 8
$str
¬¬8 ?
,
¬¬? @
submesh
¬¬A H
[
¬¬H I
n
¬¬I J
]
¬¬J K
)
¬¬K L
)
¬¬L M
;
¬¬M N
break
√√ 
;
√√ 
case
ƒƒ 
MeshTopology
ƒƒ %
.
ƒƒ% &
Lines
ƒƒ& +
:
ƒƒ+ ,
for
≈≈ 
(
≈≈ 
int
≈≈  
n
≈≈! "
=
≈≈# $
$num
≈≈% &
;
≈≈& '
n
≈≈( )
<
≈≈* +
submesh
≈≈, 3
.
≈≈3 4
Length
≈≈4 :
;
≈≈: ;
n
≈≈< =
+=
≈≈> @
$num
≈≈A B
)
≈≈B C
sb
∆∆ 
.
∆∆ 

AppendLine
∆∆ )
(
∆∆) *
string
∆∆* 0
.
∆∆0 1
Format
∆∆1 7
(
∆∆7 8
$str
∆∆8 D
,
∆∆D E
submesh
∆∆F M
[
∆∆M N
n
∆∆N O
]
∆∆O P
,
∆∆P Q
submesh
∆∆R Y
[
∆∆Y Z
n
∆∆Z [
+
∆∆\ ]
$num
∆∆^ _
]
∆∆_ `
)
∆∆` a
)
∆∆a b
;
∆∆b c
break
«« 
;
«« 
case
»» 
MeshTopology
»» %
.
»»% &
	Triangles
»»& /
:
»»/ 0
for
…… 
(
…… 
int
……  
n
……! "
=
……# $
$num
……% &
;
……& '
n
……( )
<
……* +
submesh
……, 3
.
……3 4
Length
……4 :
;
……: ;
n
……< =
+=
……> @
$num
……A B
)
……B C
sb
   
.
   

AppendLine
   )
(
  ) *
string
  * 0
.
  0 1
Format
  1 7
(
  7 8
$str
  8 I
,
  I J
submesh
  K R
[
  R S
n
  S T
]
  T U
,
  U V
submesh
  W ^
[
  ^ _
n
  _ `
+
  a b
$num
  c d
]
  d e
,
  e f
submesh
  g n
[
  n o
n
  o p
+
  q r
$num
  s t
]
  t u
)
  u v
)
  v w
;
  w x
break
ÀÀ 
;
ÀÀ 
case
ÃÃ 
MeshTopology
ÃÃ %
.
ÃÃ% &
Quads
ÃÃ& +
:
ÃÃ+ ,
for
ÕÕ 
(
ÕÕ 
int
ÕÕ  
n
ÕÕ! "
=
ÕÕ# $
$num
ÕÕ% &
;
ÕÕ& '
n
ÕÕ( )
<
ÕÕ* +
submesh
ÕÕ, 3
.
ÕÕ3 4
Length
ÕÕ4 :
;
ÕÕ: ;
n
ÕÕ< =
+=
ÕÕ> @
$num
ÕÕA B
)
ÕÕB C
sb
ŒŒ 
.
ŒŒ 

AppendLine
ŒŒ )
(
ŒŒ) *
string
ŒŒ* 0
.
ŒŒ0 1
Format
ŒŒ1 7
(
ŒŒ7 8
$str
ŒŒ8 N
,
ŒŒN O
submesh
ŒŒP W
[
ŒŒW X
n
ŒŒX Y
]
ŒŒY Z
,
ŒŒZ [
submesh
ŒŒ\ c
[
ŒŒc d
n
ŒŒd e
+
ŒŒf g
$num
ŒŒh i
]
ŒŒi j
,
ŒŒj k
submesh
ŒŒl s
[
ŒŒs t
n
ŒŒt u
+
ŒŒv w
$num
ŒŒx y
]
ŒŒy z
,
ŒŒz {
submeshŒŒ| É
[ŒŒÉ Ñ
nŒŒÑ Ö
+ŒŒÜ á
$numŒŒà â
]ŒŒâ ä
)ŒŒä ã
)ŒŒã å
;ŒŒå ç
break
œœ 
;
œœ 
}
–– 
}
—— 
return
”” 
sb
”” 
.
”” 
ToString
”” 
(
”” 
)
””  
;
””  !
}
‘‘ 	
public
€€ 
static
€€ 
uint
€€ 
GetIndexCount
€€ (
(
€€( )
Mesh
€€) -
mesh
€€. 2
)
€€2 3
{
‹‹ 	
uint
›› 
sum
›› 
=
›› 
$num
›› 
;
›› 
if
ﬂﬂ 
(
ﬂﬂ 
mesh
ﬂﬂ 
==
ﬂﬂ 
null
ﬂﬂ 
)
ﬂﬂ 
return
‡‡ 
sum
‡‡ 
;
‡‡ 
for
‚‚ 
(
‚‚ 
int
‚‚ 
i
‚‚ 
=
‚‚ 
$num
‚‚ 
,
‚‚ 
c
‚‚ 
=
‚‚ 
mesh
‚‚  $
.
‚‚$ %
subMeshCount
‚‚% 1
;
‚‚1 2
i
‚‚3 4
<
‚‚5 6
c
‚‚7 8
;
‚‚8 9
i
‚‚: ;
++
‚‚; =
)
‚‚= >
sum
„„ 
+=
„„ 
mesh
„„ 
.
„„ 
GetIndexCount
„„ )
(
„„) *
i
„„* +
)
„„+ ,
;
„„, -
return
ÂÂ 
sum
ÂÂ 
;
ÂÂ 
}
ÊÊ 	
public
ÌÌ 
static
ÌÌ 
uint
ÌÌ 
GetPrimitiveCount
ÌÌ ,
(
ÌÌ, -
Mesh
ÌÌ- 1
mesh
ÌÌ2 6
)
ÌÌ6 7
{
ÓÓ 	
uint
ÔÔ 
sum
ÔÔ 
=
ÔÔ 
$num
ÔÔ 
;
ÔÔ 
if
ÒÒ 
(
ÒÒ 
mesh
ÒÒ 
==
ÒÒ 
null
ÒÒ 
)
ÒÒ 
return
ÚÚ 
sum
ÚÚ 
;
ÚÚ 
for
ÙÙ 
(
ÙÙ 
int
ÙÙ 
i
ÙÙ 
=
ÙÙ 
$num
ÙÙ 
,
ÙÙ 
c
ÙÙ 
=
ÙÙ 
mesh
ÙÙ  $
.
ÙÙ$ %
subMeshCount
ÙÙ% 1
;
ÙÙ1 2
i
ÙÙ3 4
<
ÙÙ5 6
c
ÙÙ7 8
;
ÙÙ8 9
i
ÙÙ: ;
++
ÙÙ; =
)
ÙÙ= >
{
ıı 
if
ˆˆ 
(
ˆˆ 
mesh
ˆˆ 
.
ˆˆ 
GetTopology
ˆˆ $
(
ˆˆ$ %
i
ˆˆ% &
)
ˆˆ& '
==
ˆˆ( *
MeshTopology
ˆˆ+ 7
.
ˆˆ7 8
	Triangles
ˆˆ8 A
)
ˆˆA B
sum
˜˜ 
+=
˜˜ 
mesh
˜˜ 
.
˜˜  
GetIndexCount
˜˜  -
(
˜˜- .
i
˜˜. /
)
˜˜/ 0
/
˜˜1 2
$num
˜˜3 4
;
˜˜4 5
else
¯¯ 
if
¯¯ 
(
¯¯ 
mesh
¯¯ 
.
¯¯ 
GetTopology
¯¯ )
(
¯¯) *
i
¯¯* +
)
¯¯+ ,
==
¯¯- /
MeshTopology
¯¯0 <
.
¯¯< =
Quads
¯¯= B
)
¯¯B C
sum
˘˘ 
+=
˘˘ 
mesh
˘˘ 
.
˘˘  
GetIndexCount
˘˘  -
(
˘˘- .
i
˘˘. /
)
˘˘/ 0
/
˘˘1 2
$num
˘˘3 4
;
˘˘4 5
}
˙˙ 
return
¸¸ 
sum
¸¸ 
;
¸¸ 
}
˝˝ 	
public
ÜÜ 
static
ÜÜ 
void
ÜÜ 
Compile
ÜÜ "
(
ÜÜ" #
ProBuilderMesh
ÜÜ# 1
probuilderMesh
ÜÜ2 @
,
ÜÜ@ A
Mesh
ÜÜB F

targetMesh
ÜÜG Q
,
ÜÜQ R
MeshTopology
ÜÜS _
preferredTopology
ÜÜ` q
=
ÜÜr s
MeshTopologyÜÜt Ä
.ÜÜÄ Å
	TrianglesÜÜÅ ä
)ÜÜä ã
{
áá 	
if
àà 
(
àà 
probuilderMesh
àà 
==
àà !
null
àà" &
)
àà& '
throw
ââ 
new
ââ #
ArgumentNullException
ââ /
(
ââ/ 0
$str
ââ0 @
)
ââ@ A
;
ââA B
if
ãã 
(
ãã 

targetMesh
ãã 
==
ãã 
null
ãã "
)
ãã" #
throw
åå 
new
åå #
ArgumentNullException
åå /
(
åå/ 0
$str
åå0 <
)
åå< =
;
åå= >

targetMesh
éé 
.
éé 
Clear
éé 
(
éé 
)
éé 
;
éé 

targetMesh
êê 
.
êê 
vertices
êê 
=
êê  !
probuilderMesh
êê" 0
.
êê0 1
positionsInternal
êê1 B
;
êêB C

targetMesh
ëë 
.
ëë 
uv
ëë 
=
ëë 
probuilderMesh
ëë *
.
ëë* +
texturesInternal
ëë+ ;
;
ëë; <
if
ìì 
(
ìì 
probuilderMesh
ìì 
.
ìì 
	HasArrays
ìì (
(
ìì( )

MeshArrays
ìì) 3
.
ìì3 4
Texture2
ìì4 <
)
ìì< =
)
ìì= >
{
îî 
List
ïï 
<
ïï 
Vector4
ïï 
>
ïï 
	uvChannel
ïï '
=
ïï( )
new
ïï* -
List
ïï. 2
<
ïï2 3
Vector4
ïï3 :
>
ïï: ;
(
ïï; <
)
ïï< =
;
ïï= >
probuilderMesh
ññ 
.
ññ 
GetUVs
ññ %
(
ññ% &
$num
ññ& '
,
ññ' (
	uvChannel
ññ) 2
)
ññ2 3
;
ññ3 4

targetMesh
óó 
.
óó 
SetUVs
óó !
(
óó! "
$num
óó" #
,
óó# $
	uvChannel
óó% .
)
óó. /
;
óó/ 0
}
òò 
if
öö 
(
öö 
probuilderMesh
öö 
.
öö 
	HasArrays
öö (
(
öö( )

MeshArrays
öö) 3
.
öö3 4
Texture3
öö4 <
)
öö< =
)
öö= >
{
õõ 
List
úú 
<
úú 
Vector4
úú 
>
úú 
	uvChannel
úú '
=
úú( )
new
úú* -
List
úú. 2
<
úú2 3
Vector4
úú3 :
>
úú: ;
(
úú; <
)
úú< =
;
úú= >
probuilderMesh
ùù 
.
ùù 
GetUVs
ùù %
(
ùù% &
$num
ùù& '
,
ùù' (
	uvChannel
ùù) 2
)
ùù2 3
;
ùù3 4

targetMesh
ûû 
.
ûû 
SetUVs
ûû !
(
ûû! "
$num
ûû" #
,
ûû# $
	uvChannel
ûû% .
)
ûû. /
;
ûû/ 0
}
üü 

targetMesh
°° 
.
°° 
normals
°° 
=
°°  
probuilderMesh
°°! /
.
°°/ 0

GetNormals
°°0 :
(
°°: ;
)
°°; <
;
°°< =

targetMesh
¢¢ 
.
¢¢ 
tangents
¢¢ 
=
¢¢  !
probuilderMesh
¢¢" 0
.
¢¢0 1
GetTangents
¢¢1 <
(
¢¢< =
)
¢¢= >
;
¢¢> ?
if
§§ 
(
§§ 
probuilderMesh
§§ 
.
§§ 
	HasArrays
§§ (
(
§§( )

MeshArrays
§§) 3
.
§§3 4
Color
§§4 9
)
§§9 :
)
§§: ;

targetMesh
•• 
.
•• 
colors
•• !
=
••" #
probuilderMesh
••$ 2
.
••2 3
colorsInternal
••3 A
;
••A B
var
ßß 
materialCount
ßß 
=
ßß 
probuilderMesh
ßß  .
.
ßß. /
GetComponent
ßß/ ;
<
ßß; <
Renderer
ßß< D
>
ßßD E
(
ßßE F
)
ßßF G
.
ßßG H
sharedMaterials
ßßH W
.
ßßW X
Length
ßßX ^
;
ßß^ _
var
®® 
	submeshes
®® 
=
®® 
Submesh
®® #
.
®®# $
GetSubmeshes
®®$ 0
(
®®0 1
probuilderMesh
®®1 ?
.
®®? @
facesInternal
®®@ M
,
®®M N
materialCount
®®O \
,
®®\ ]
preferredTopology
®®^ o
)
®®o p
;
®®p q

targetMesh
©© 
.
©© 
subMeshCount
©© #
=
©©$ %
	submeshes
©©& /
.
©©/ 0
Length
©©0 6
;
©©6 7
for
´´ 
(
´´ 
int
´´ 
i
´´ 
=
´´ 
$num
´´ 
;
´´ 
i
´´ 
<
´´ 

targetMesh
´´  *
.
´´* +
subMeshCount
´´+ 7
;
´´7 8
i
´´9 :
++
´´: <
)
´´< =

targetMesh
¨¨ 
.
¨¨ 

SetIndices
¨¨ %
(
¨¨% &
	submeshes
¨¨& /
[
¨¨/ 0
i
¨¨0 1
]
¨¨1 2
.
¨¨2 3
	m_Indexes
¨¨3 <
,
¨¨< =
	submeshes
¨¨> G
[
¨¨G H
i
¨¨H I
]
¨¨I J
.
¨¨J K

m_Topology
¨¨K U
,
¨¨U V
i
¨¨W X
,
¨¨X Y
false
¨¨Z _
)
¨¨_ `
;
¨¨` a

targetMesh
ÆÆ 
.
ÆÆ 
name
ÆÆ 
=
ÆÆ 
string
ÆÆ $
.
ÆÆ$ %
Format
ÆÆ% +
(
ÆÆ+ ,
$str
ÆÆ, 8
,
ÆÆ8 9
probuilderMesh
ÆÆ: H
.
ÆÆH I
id
ÆÆI K
)
ÆÆK L
;
ÆÆL M
}
ØØ 	
public
∂∂ 
static
∂∂ 
Vertex
∂∂ 
[
∂∂ 
]
∂∂ 
GetVertices
∂∂ *
(
∂∂* +
this
∂∂+ /
Mesh
∂∂0 4
mesh
∂∂5 9
)
∂∂9 :
{
∑∑ 	
if
∏∏ 
(
∏∏ 
mesh
∏∏ 
==
∏∏ 
null
∏∏ 
)
∏∏ 
return
ππ 
null
ππ 
;
ππ 
int
ªª 
vertexCount
ªª 
=
ªª 
mesh
ªª "
.
ªª" #
vertexCount
ªª# .
;
ªª. /
Vertex
ºº 
[
ºº 
]
ºº 
v
ºº 
=
ºº 
new
ºº 
Vertex
ºº #
[
ºº# $
vertexCount
ºº$ /
]
ºº/ 0
;
ºº0 1
Vector3
ææ 
[
ææ 
]
ææ 
	positions
ææ 
=
ææ  !
mesh
ææ" &
.
ææ& '
vertices
ææ' /
;
ææ/ 0
Color
øø 
[
øø 
]
øø 
colors
øø 
=
øø 
mesh
øø !
.
øø! "
colors
øø" (
;
øø( )
Vector3
¿¿ 
[
¿¿ 
]
¿¿ 
normals
¿¿ 
=
¿¿ 
mesh
¿¿  $
.
¿¿$ %
normals
¿¿% ,
;
¿¿, -
Vector4
¡¡ 
[
¡¡ 
]
¡¡ 
tangents
¡¡ 
=
¡¡  
mesh
¡¡! %
.
¡¡% &
tangents
¡¡& .
;
¡¡. /
Vector2
¬¬ 
[
¬¬ 
]
¬¬ 
uv0s
¬¬ 
=
¬¬ 
mesh
¬¬ !
.
¬¬! "
uv
¬¬" $
;
¬¬$ %
Vector2
√√ 
[
√√ 
]
√√ 
uv2s
√√ 
=
√√ 
mesh
√√ !
.
√√! "
uv2
√√" %
;
√√% &
List
ƒƒ 
<
ƒƒ 
Vector4
ƒƒ 
>
ƒƒ 
uv3s
ƒƒ 
=
ƒƒ  
new
ƒƒ! $
List
ƒƒ% )
<
ƒƒ) *
Vector4
ƒƒ* 1
>
ƒƒ1 2
(
ƒƒ2 3
)
ƒƒ3 4
;
ƒƒ4 5
List
≈≈ 
<
≈≈ 
Vector4
≈≈ 
>
≈≈ 
uv4s
≈≈ 
=
≈≈  
new
≈≈! $
List
≈≈% )
<
≈≈) *
Vector4
≈≈* 1
>
≈≈1 2
(
≈≈2 3
)
≈≈3 4
;
≈≈4 5
mesh
∆∆ 
.
∆∆ 
GetUVs
∆∆ 
(
∆∆ 
$num
∆∆ 
,
∆∆ 
uv3s
∆∆ 
)
∆∆  
;
∆∆  !
mesh
«« 
.
«« 
GetUVs
«« 
(
«« 
$num
«« 
,
«« 
uv4s
«« 
)
««  
;
««  !
bool
…… 
_hasPositions
…… 
=
……  
	positions
……! *
!=
……+ -
null
……. 2
&&
……3 5
	positions
……6 ?
.
……? @
Count
……@ E
(
……E F
)
……F G
==
……H J
vertexCount
……K V
;
……V W
bool
   

_hasColors
   
=
   
colors
   $
!=
  % '
null
  ( ,
&&
  - /
colors
  0 6
.
  6 7
Count
  7 <
(
  < =
)
  = >
==
  ? A
vertexCount
  B M
;
  M N
bool
ÀÀ 
_hasNormals
ÀÀ 
=
ÀÀ 
normals
ÀÀ &
!=
ÀÀ' )
null
ÀÀ* .
&&
ÀÀ/ 1
normals
ÀÀ2 9
.
ÀÀ9 :
Count
ÀÀ: ?
(
ÀÀ? @
)
ÀÀ@ A
==
ÀÀB D
vertexCount
ÀÀE P
;
ÀÀP Q
bool
ÃÃ 
_hasTangents
ÃÃ 
=
ÃÃ 
tangents
ÃÃ  (
!=
ÃÃ) +
null
ÃÃ, 0
&&
ÃÃ1 3
tangents
ÃÃ4 <
.
ÃÃ< =
Count
ÃÃ= B
(
ÃÃB C
)
ÃÃC D
==
ÃÃE G
vertexCount
ÃÃH S
;
ÃÃS T
bool
ÕÕ 
_hasUv0
ÕÕ 
=
ÕÕ 
uv0s
ÕÕ 
!=
ÕÕ  "
null
ÕÕ# '
&&
ÕÕ( *
uv0s
ÕÕ+ /
.
ÕÕ/ 0
Count
ÕÕ0 5
(
ÕÕ5 6
)
ÕÕ6 7
==
ÕÕ8 :
vertexCount
ÕÕ; F
;
ÕÕF G
bool
ŒŒ 
_hasUv2
ŒŒ 
=
ŒŒ 
uv2s
ŒŒ 
!=
ŒŒ  "
null
ŒŒ# '
&&
ŒŒ( *
uv2s
ŒŒ+ /
.
ŒŒ/ 0
Count
ŒŒ0 5
(
ŒŒ5 6
)
ŒŒ6 7
==
ŒŒ8 :
vertexCount
ŒŒ; F
;
ŒŒF G
bool
œœ 
_hasUv3
œœ 
=
œœ 
uv3s
œœ 
.
œœ  
Count
œœ  %
(
œœ% &
)
œœ& '
==
œœ( *
vertexCount
œœ+ 6
;
œœ6 7
bool
–– 
_hasUv4
–– 
=
–– 
uv4s
–– 
.
––  
Count
––  %
(
––% &
)
––& '
==
––( *
vertexCount
––+ 6
;
––6 7
for
““ 
(
““ 
int
““ 
i
““ 
=
““ 
$num
““ 
;
““ 
i
““ 
<
““ 
vertexCount
““  +
;
““+ ,
i
““- .
++
““. 0
)
““0 1
{
”” 
v
‘‘ 
[
‘‘ 
i
‘‘ 
]
‘‘ 
=
‘‘ 
new
‘‘ 
Vertex
‘‘ !
(
‘‘! "
)
‘‘" #
;
‘‘# $
if
÷÷ 
(
÷÷ 
_hasPositions
÷÷ !
)
÷÷! "
v
◊◊ 
[
◊◊ 
i
◊◊ 
]
◊◊ 
.
◊◊ 
position
◊◊ !
=
◊◊" #
	positions
◊◊$ -
[
◊◊- .
i
◊◊. /
]
◊◊/ 0
;
◊◊0 1
if
ŸŸ 
(
ŸŸ 

_hasColors
ŸŸ 
)
ŸŸ 
v
⁄⁄ 
[
⁄⁄ 
i
⁄⁄ 
]
⁄⁄ 
.
⁄⁄ 
color
⁄⁄ 
=
⁄⁄  
colors
⁄⁄! '
[
⁄⁄' (
i
⁄⁄( )
]
⁄⁄) *
;
⁄⁄* +
if
‹‹ 
(
‹‹ 
_hasNormals
‹‹ 
)
‹‹  
v
›› 
[
›› 
i
›› 
]
›› 
.
›› 
normal
›› 
=
››  !
normals
››" )
[
››) *
i
››* +
]
››+ ,
;
››, -
if
ﬂﬂ 
(
ﬂﬂ 
_hasTangents
ﬂﬂ  
)
ﬂﬂ  !
v
‡‡ 
[
‡‡ 
i
‡‡ 
]
‡‡ 
.
‡‡ 
tangent
‡‡  
=
‡‡! "
tangents
‡‡# +
[
‡‡+ ,
i
‡‡, -
]
‡‡- .
;
‡‡. /
if
‚‚ 
(
‚‚ 
_hasUv0
‚‚ 
)
‚‚ 
v
„„ 
[
„„ 
i
„„ 
]
„„ 
.
„„ 
uv0
„„ 
=
„„ 
uv0s
„„ #
[
„„# $
i
„„$ %
]
„„% &
;
„„& '
if
ÂÂ 
(
ÂÂ 
_hasUv2
ÂÂ 
)
ÂÂ 
v
ÊÊ 
[
ÊÊ 
i
ÊÊ 
]
ÊÊ 
.
ÊÊ 
uv2
ÊÊ 
=
ÊÊ 
uv2s
ÊÊ #
[
ÊÊ# $
i
ÊÊ$ %
]
ÊÊ% &
;
ÊÊ& '
if
ËË 
(
ËË 
_hasUv3
ËË 
)
ËË 
v
ÈÈ 
[
ÈÈ 
i
ÈÈ 
]
ÈÈ 
.
ÈÈ 
uv3
ÈÈ 
=
ÈÈ 
uv3s
ÈÈ #
[
ÈÈ# $
i
ÈÈ$ %
]
ÈÈ% &
;
ÈÈ& '
if
ÎÎ 
(
ÎÎ 
_hasUv4
ÎÎ 
)
ÎÎ 
v
ÏÏ 
[
ÏÏ 
i
ÏÏ 
]
ÏÏ 
.
ÏÏ 
uv4
ÏÏ 
=
ÏÏ 
uv4s
ÏÏ #
[
ÏÏ# $
i
ÏÏ$ %
]
ÏÏ% &
;
ÏÏ& '
}
ÌÌ 
return
ÔÔ 
v
ÔÔ 
;
ÔÔ 
}
 	
public
¸¸ 
static
¸¸ 
void
¸¸ $
CollapseSharedVertices
¸¸ 1
(
¸¸1 2
Mesh
¸¸2 6
mesh
¸¸7 ;
,
¸¸; <
Vertex
¸¸= C
[
¸¸C D
]
¸¸D E
vertices
¸¸F N
=
¸¸O P
null
¸¸Q U
)
¸¸U V
{
˝˝ 	
if
˛˛ 
(
˛˛ 
mesh
˛˛ 
==
˛˛ 
null
˛˛ 
)
˛˛ 
throw
ˇˇ 
new
ˇˇ 
System
ˇˇ  
.
ˇˇ  !#
ArgumentNullException
ˇˇ! 6
(
ˇˇ6 7
$str
ˇˇ7 =
)
ˇˇ= >
;
ˇˇ> ?
if
ÅÅ 
(
ÅÅ 
vertices
ÅÅ 
==
ÅÅ 
null
ÅÅ  
)
ÅÅ  !
vertices
ÇÇ 
=
ÇÇ 
mesh
ÇÇ 
.
ÇÇ  
GetVertices
ÇÇ  +
(
ÇÇ+ ,
)
ÇÇ, -
;
ÇÇ- .
int
ÑÑ 
smc
ÑÑ 
=
ÑÑ 
mesh
ÑÑ 
.
ÑÑ 
subMeshCount
ÑÑ '
;
ÑÑ' (
List
ÖÖ 
<
ÖÖ 

Dictionary
ÖÖ 
<
ÖÖ 
Vertex
ÖÖ "
,
ÖÖ" #
int
ÖÖ$ '
>
ÖÖ' (
>
ÖÖ( )
subVertices
ÖÖ* 5
=
ÖÖ6 7
new
ÖÖ8 ;
List
ÖÖ< @
<
ÖÖ@ A

Dictionary
ÖÖA K
<
ÖÖK L
Vertex
ÖÖL R
,
ÖÖR S
int
ÖÖT W
>
ÖÖW X
>
ÖÖX Y
(
ÖÖY Z
)
ÖÖZ [
;
ÖÖ[ \
int
ÜÜ 
[
ÜÜ 
]
ÜÜ 
[
ÜÜ 
]
ÜÜ 
tris
ÜÜ 
=
ÜÜ 
new
ÜÜ 
int
ÜÜ "
[
ÜÜ" #
smc
ÜÜ# &
]
ÜÜ& '
[
ÜÜ' (
]
ÜÜ( )
;
ÜÜ) *
int
áá 
subIndex
áá 
=
áá 
$num
áá 
;
áá 
for
ââ 
(
ââ 
int
ââ 
i
ââ 
=
ââ 
$num
ââ 
;
ââ 
i
ââ 
<
ââ 
smc
ââ  #
;
ââ# $
++
ââ% '
i
ââ' (
)
ââ( )
{
ää 
tris
ãã 
[
ãã 
i
ãã 
]
ãã 
=
ãã 
mesh
ãã 
.
ãã 
GetTriangles
ãã +
(
ãã+ ,
i
ãã, -
)
ãã- .
;
ãã. /

Dictionary
åå 
<
åå 
Vertex
åå !
,
åå! "
int
åå# &
>
åå& '
newVertices
åå( 3
=
åå4 5
new
åå6 9

Dictionary
åå: D
<
ååD E
Vertex
ååE K
,
ååK L
int
ååM P
>
ååP Q
(
ååQ R
)
ååR S
;
ååS T
for
éé 
(
éé 
int
éé 
n
éé 
=
éé 
$num
éé 
;
éé 
n
éé  !
<
éé" #
tris
éé$ (
[
éé( )
i
éé) *
]
éé* +
.
éé+ ,
Length
éé, 2
;
éé2 3
n
éé4 5
++
éé5 7
)
éé7 8
{
èè 
Vertex
êê 
v
êê 
=
êê 
vertices
êê '
[
êê' (
tris
êê( ,
[
êê, -
i
êê- .
]
êê. /
[
êê/ 0
n
êê0 1
]
êê1 2
]
êê2 3
;
êê3 4
int
ëë 
index
ëë 
;
ëë 
if
ìì 
(
ìì 
newVertices
ìì #
.
ìì# $
TryGetValue
ìì$ /
(
ìì/ 0
v
ìì0 1
,
ìì1 2
out
ìì3 6
index
ìì7 <
)
ìì< =
)
ìì= >
{
îî 
tris
ïï 
[
ïï 
i
ïï 
]
ïï 
[
ïï  
n
ïï  !
]
ïï! "
=
ïï# $
index
ïï% *
;
ïï* +
}
ññ 
else
óó 
{
òò 
tris
ôô 
[
ôô 
i
ôô 
]
ôô 
[
ôô  
n
ôô  !
]
ôô! "
=
ôô# $
subIndex
ôô% -
;
ôô- .
newVertices
öö #
.
öö# $
Add
öö$ '
(
öö' (
v
öö( )
,
öö) *
subIndex
öö+ 3
)
öö3 4
;
öö4 5
subIndex
õõ  
++
õõ  "
;
õõ" #
}
úú 
}
ùù 
subVertices
üü 
.
üü 
Add
üü 
(
üü  
newVertices
üü  +
)
üü+ ,
;
üü, -
}
†† 
Vertex
¢¢ 
[
¢¢ 
]
¢¢ 
	collapsed
¢¢ 
=
¢¢  
subVertices
¢¢! ,
.
¢¢, -

SelectMany
¢¢- 7
(
¢¢7 8
x
¢¢8 9
=>
¢¢: <
x
¢¢= >
.
¢¢> ?
Keys
¢¢? C
)
¢¢C D
.
¢¢D E
ToArray
¢¢E L
(
¢¢L M
)
¢¢M N
;
¢¢N O
Vertex
££ 
.
££ 
SetMesh
££ 
(
££ 
mesh
££ 
,
££  
	collapsed
££! *
)
££* +
;
££+ ,
mesh
§§ 
.
§§ 
subMeshCount
§§ 
=
§§ 
smc
§§  #
;
§§# $
for
•• 
(
•• 
int
•• 
i
•• 
=
•• 
$num
•• 
;
•• 
i
•• 
<
•• 
smc
••  #
;
••# $
i
••% &
++
••& (
)
••( )
mesh
¶¶ 
.
¶¶ 
SetTriangles
¶¶ !
(
¶¶! "
tris
¶¶" &
[
¶¶& '
i
¶¶' (
]
¶¶( )
,
¶¶) *
i
¶¶+ ,
)
¶¶, -
;
¶¶- .
}
ßß 	
internal
©© 
static
©© 
string
©© 
SanityCheck
©© *
(
©©* +
ProBuilderMesh
©©+ 9
mesh
©©: >
)
©©> ?
{
™™ 	
return
´´ 
SanityCheck
´´ 
(
´´ 
mesh
´´ #
.
´´# $
GetVertices
´´$ /
(
´´/ 0
)
´´0 1
)
´´1 2
;
´´2 3
}
¨¨ 	
internal
≥≥ 
static
≥≥ 
string
≥≥ 
SanityCheck
≥≥ *
(
≥≥* +
Mesh
≥≥+ /
mesh
≥≥0 4
)
≥≥4 5
{
¥¥ 	
return
µµ 
SanityCheck
µµ 
(
µµ 
mesh
µµ #
.
µµ# $
GetVertices
µµ$ /
(
µµ/ 0
)
µµ0 1
)
µµ1 2
;
µµ2 3
}
∂∂ 	
internal
ºº 
static
ºº 
string
ºº 
SanityCheck
ºº *
(
ºº* +
IList
ºº+ 0
<
ºº0 1
Vertex
ºº1 7
>
ºº7 8
vertices
ºº9 A
)
ººA B
{
ΩΩ 	
var
ææ 
sb
ææ 
=
ææ 
new
ææ 
StringBuilder
ææ &
(
ææ& '
)
ææ' (
;
ææ( )
for
¿¿ 
(
¿¿ 
int
¿¿ 
i
¿¿ 
=
¿¿ 
$num
¿¿ 
,
¿¿ 
c
¿¿ 
=
¿¿ 
vertices
¿¿  (
.
¿¿( )
Count
¿¿) .
;
¿¿. /
i
¿¿0 1
<
¿¿2 3
c
¿¿4 5
;
¿¿5 6
i
¿¿7 8
++
¿¿8 :
)
¿¿: ;
{
¡¡ 
var
¬¬ 
vertex
¬¬ 
=
¬¬ 
vertices
¬¬ %
[
¬¬% &
i
¬¬& '
]
¬¬' (
;
¬¬( )
if
ƒƒ 
(
ƒƒ 
Math
ƒƒ 
.
ƒƒ 
IsNumber
ƒƒ !
(
ƒƒ! "
vertex
ƒƒ" (
.
ƒƒ( )
position
ƒƒ) 1
)
ƒƒ1 2
&&
≈≈ 
Math
≈≈ 
.
≈≈ 
IsNumber
≈≈ $
(
≈≈$ %
vertex
≈≈% +
.
≈≈+ ,
color
≈≈, 1
)
≈≈1 2
&&
∆∆ 
Math
∆∆ 
.
∆∆ 
IsNumber
∆∆ $
(
∆∆$ %
vertex
∆∆% +
.
∆∆+ ,
uv0
∆∆, /
)
∆∆/ 0
&&
«« 
Math
«« 
.
«« 
IsNumber
«« $
(
««$ %
vertex
««% +
.
««+ ,
normal
««, 2
)
««2 3
&&
»» 
Math
»» 
.
»» 
IsNumber
»» $
(
»»$ %
vertex
»»% +
.
»»+ ,
tangent
»», 3
)
»»3 4
&&
…… 
Math
…… 
.
…… 
IsNumber
…… $
(
……$ %
vertex
……% +
.
……+ ,
uv2
……, /
)
……/ 0
&&
   
Math
   
.
   
IsNumber
   $
(
  $ %
vertex
  % +
.
  + ,
uv3
  , /
)
  / 0
&&
ÀÀ 
Math
ÀÀ 
.
ÀÀ 
IsNumber
ÀÀ $
(
ÀÀ$ %
vertex
ÀÀ% +
.
ÀÀ+ ,
uv4
ÀÀ, /
)
ÀÀ/ 0
)
ÀÀ0 1
continue
ÃÃ 
;
ÃÃ 
sb
ŒŒ 
.
ŒŒ 
AppendFormat
ŒŒ 
(
ŒŒ  
$str
ŒŒ  N
,
ŒŒN O
i
ŒŒP Q
,
ŒŒQ R
vertex
ŒŒS Y
.
ŒŒY Z
ToString
ŒŒZ b
(
ŒŒb c
)
ŒŒc d
)
ŒŒd e
;
ŒŒe f
}
œœ 
return
—— 
sb
—— 
.
—— 
ToString
—— 
(
—— 
)
——  
;
——  !
}
““ 	
}
”” 
}‘‘ »à
àD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Submesh.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ 
Serializable 
] 
public 

sealed 
class 
Submesh 
{ 
[ 	
SerializeField	 
] 
internal 
int 
[ 
] 
	m_Indexes  
;  !
[ 	
SerializeField	 
] 
internal 
MeshTopology 

m_Topology (
;( )
[ 	
SerializeField	 
] 
internal 
int 
m_SubmeshIndex #
;# $
public 
IEnumerable 
< 
int 
> 
indexes  '
{ 	
get 
{ 
return 
new 
ReadOnlyCollection /
</ 0
int0 3
>3 4
(4 5
	m_Indexes5 >
)> ?
;? @
}A B
set 
{ 
	m_Indexes 
= 
value #
.# $
ToArray$ +
(+ ,
), -
;- .
}/ 0
} 	
public$$ 
MeshTopology$$ 
topology$$ $
{%% 	
get&& 
{&& 
return&& 

m_Topology&& #
;&&# $
}&&% &
set'' 
{'' 

m_Topology'' 
='' 
value'' $
;''$ %
}''& '
}(( 	
public-- 
int-- 
submeshIndex-- 
{.. 	
get// 
{// 
return// 
m_SubmeshIndex// '
;//' (
}//) *
set00 
{00 
m_SubmeshIndex00  
=00! "
value00# (
;00( )
}00* +
}11 	
public99 
Submesh99 
(99 
int99 
submeshIndex99 '
,99' (
MeshTopology99) 5
topology996 >
,99> ?
IEnumerable99@ K
<99K L
int99L O
>99O P
indexes99Q X
)99X Y
{:: 	
if;; 
(;; 
indexes;; 
==;; 
null;; 
);;  
throw<< 
new<< !
ArgumentNullException<< /
(<</ 0
$str<<0 9
)<<9 :
;<<: ;
	m_Indexes>> 
=>> 
indexes>> 
.>>  
ToArray>>  '
(>>' (
)>>( )
;>>) *

m_Topology?? 
=?? 
topology?? !
;??! "
m_SubmeshIndex@@ 
=@@ 
submeshIndex@@ )
;@@) *
}AA 	
publicHH 
SubmeshHH 
(HH 
MeshHH 
meshHH  
,HH  !
intHH" %
subMeshIndexHH& 2
)HH2 3
{II 	
ifJJ 
(JJ 
meshJJ 
==JJ 
nullJJ 
)JJ 
throwKK 
newKK !
ArgumentNullExceptionKK /
(KK/ 0
$strKK0 6
)KK6 7
;KK7 8
	m_IndexesMM 
=MM 
meshMM 
.MM 

GetIndicesMM '
(MM' (
subMeshIndexMM( 4
)MM4 5
;MM5 6

m_TopologyNN 
=NN 
meshNN 
.NN 
GetTopologyNN )
(NN) *
subMeshIndexNN* 6
)NN6 7
;NN7 8
m_SubmeshIndexOO 
=OO 
subMeshIndexOO )
;OO) *
}PP 	
publicRR 
overrideRR 
stringRR 
ToStringRR '
(RR' (
)RR( )
{SS 	
returnTT 
stringTT 
.TT 
FormatTT  
(TT  !
$strTT! 0
,TT0 1
m_SubmeshIndexTT2 @
,TT@ A

m_TopologyTTB L
.TTL M
ToStringTTM U
(TTU V
)TTV W
,TTW X
	m_IndexesTTY b
!=TTc e
nullTTf j
?TTk l
	m_IndexesTTm v
.TTv w
LengthTTw }
.TT} ~
ToString	TT~ Ü
(
TTÜ á
)
TTá à
:
TTâ ä
$str
TTã é
)
TTé è
;
TTè ê
}UU 	
internalWW 
staticWW 
intWW 
GetSubmeshCountWW +
(WW+ ,
ProBuilderMeshWW, :
meshWW; ?
)WW? @
{XX 	
intYY 
countYY 
=YY 
$numYY 
;YY 
foreachZZ 
(ZZ 
varZZ 
faceZZ 
inZZ  
meshZZ! %
.ZZ% &
facesInternalZZ& 3
)ZZ3 4
count[[ 
=[[ 
Math[[ 
.[[ 
Max[[  
([[  !
count[[! &
,[[& '
face[[( ,
.[[, -
submeshIndex[[- 9
)[[9 :
;[[: ;
return\\ 
count\\ 
+\\ 
$num\\ 
;\\ 
}]] 	
publicgg 
staticgg 
Submeshgg 
[gg 
]gg 
GetSubmeshesgg  ,
(gg, -
IEnumerablegg- 8
<gg8 9
Facegg9 =
>gg= >
facesgg? D
,ggD E
intggF I
submeshCountggJ V
,ggV W
MeshTopologyggX d
preferredTopologygge v
=ggw x
MeshTopology	ggy Ö
.
ggÖ Ü
	Triangles
ggÜ è
)
ggè ê
{hh 	
ifii 
(ii 
preferredTopologyii !
!=ii" $
MeshTopologyii% 1
.ii1 2
	Trianglesii2 ;
&&ii< >
preferredTopologyii? P
!=iiQ S
MeshTopologyiiT `
.ii` a
Quadsiia f
)iif g
throwjj 
newjj 
Systemjj  
.jj  !#
NotImplementedExceptionjj! 8
(jj8 9
$strjj9 l
)jjl m
;jjm n
ifll 
(ll 
facesll 
==ll 
nullll 
)ll 
throwmm 
newmm !
ArgumentNullExceptionmm /
(mm/ 0
$strmm0 7
)mm7 8
;mm8 9
booloo 

wantsQuadsoo 
=oo 
preferredTopologyoo /
==oo0 2
MeshTopologyoo3 ?
.oo? @
Quadsoo@ E
;ooE F
Listqq 
<qq 
intqq 
>qq 
[qq 
]qq 
quadsqq 
=qq 

wantsQuadsqq  *
?qq+ ,
newqq- 0
Listqq1 5
<qq5 6
intqq6 9
>qq9 :
[qq: ;
submeshCountqq; G
]qqG H
:qqI J
nullqqK O
;qqO P
Listrr 
<rr 
intrr 
>rr 
[rr 
]rr 
trisrr 
=rr 
newrr "
Listrr# '
<rr' (
intrr( +
>rr+ ,
[rr, -
submeshCountrr- 9
]rr9 :
;rr: ;
intss 
maxSubmeshIndexss 
=ss  !
submeshCountss" .
-ss/ 0
$numss1 2
;ss2 3
foruu 
(uu 
intuu 
iuu 
=uu 
$numuu 
;uu 
iuu 
<uu 
submeshCountuu  ,
;uu, -
iuu. /
++uu/ 1
)uu1 2
{vv 
ifww 
(ww 

wantsQuadsww 
)ww 
quadsxx 
[xx 
ixx 
]xx 
=xx 
newxx "
Listxx# '
<xx' (
intxx( +
>xx+ ,
(xx, -
)xx- .
;xx. /
triszz 
[zz 
izz 
]zz 
=zz 
newzz 
Listzz "
<zz" #
intzz# &
>zz& '
(zz' (
)zz( )
;zz) *
}{{ 
foreach}} 
(}} 
var}} 
face}} 
in}}  
faces}}! &
)}}& '
{~~ 
if 
( 
face 
. 
indexesInternal (
==) +
null, 0
||1 3
face4 8
.8 9
indexesInternal9 H
.H I
LengthI O
<P Q
$numR S
)S T
continue
ÄÄ 
;
ÄÄ 
int
ÇÇ 
submeshIndex
ÇÇ  
=
ÇÇ! "
Math
ÇÇ# '
.
ÇÇ' (
Clamp
ÇÇ( -
(
ÇÇ- .
face
ÇÇ. 2
.
ÇÇ2 3
submeshIndex
ÇÇ3 ?
,
ÇÇ? @
$num
ÇÇA B
,
ÇÇB C
maxSubmeshIndex
ÇÇD S
)
ÇÇS T
;
ÇÇT U
if
ÑÑ 
(
ÑÑ 

wantsQuads
ÑÑ 
&&
ÑÑ !
face
ÑÑ" &
.
ÑÑ& '
IsQuad
ÑÑ' -
(
ÑÑ- .
)
ÑÑ. /
)
ÑÑ/ 0
quads
ÖÖ 
[
ÖÖ 
submeshIndex
ÖÖ &
]
ÖÖ& '
.
ÖÖ' (
AddRange
ÖÖ( 0
(
ÖÖ0 1
face
ÖÖ1 5
.
ÖÖ5 6
ToQuad
ÖÖ6 <
(
ÖÖ< =
)
ÖÖ= >
)
ÖÖ> ?
;
ÖÖ? @
else
ÜÜ 
tris
áá 
[
áá 
submeshIndex
áá %
]
áá% &
.
áá& '
AddRange
áá' /
(
áá/ 0
face
áá0 4
.
áá4 5
indexesInternal
áá5 D
)
ááD E
;
ááE F
}
àà 
var
ää 
	submeshes
ää 
=
ää 
new
ää 
Submesh
ää  '
[
ää' (
submeshCount
ää( 4
]
ää4 5
;
ää5 6
switch
åå 
(
åå 
preferredTopology
åå %
)
åå% &
{
çç 
case
éé 
MeshTopology
éé !
.
éé! "
	Triangles
éé" +
:
éé+ ,
{
èè 
for
êê 
(
êê 
int
êê 
submeshIndex
êê )
=
êê* +
$num
êê, -
;
êê- .
submeshIndex
êê/ ;
<
êê< =
submeshCount
êê> J
;
êêJ K
submeshIndex
êêL X
++
êêX Z
)
êêZ [
	submeshes
ëë !
[
ëë! "
submeshIndex
ëë" .
]
ëë. /
=
ëë0 1
new
ëë2 5
Submesh
ëë6 =
(
ëë= >
submeshIndex
ëë> J
,
ëëJ K
MeshTopology
ëëL X
.
ëëX Y
	Triangles
ëëY b
,
ëëb c
tris
ëëd h
[
ëëh i
submeshIndex
ëëi u
]
ëëu v
)
ëëv w
;
ëëw x
break
íí 
;
íí 
}
ìì 
case
ïï 
MeshTopology
ïï !
.
ïï! "
Quads
ïï" '
:
ïï' (
{
ññ 
for
óó 
(
óó 
int
óó 
submeshIndex
óó )
=
óó* +
$num
óó, -
;
óó- .
submeshIndex
óó/ ;
<
óó< =
submeshCount
óó> J
;
óóJ K
submeshIndex
óóL X
++
óóX Z
)
óóZ [
{
òò 
if
öö 
(
öö 
tris
öö  
[
öö  !
submeshIndex
öö! -
]
öö- .
.
öö. /
Count
öö/ 4
>
öö5 6
$num
öö7 8
)
öö8 9
{
õõ 
var
úú 
tri
úú  #
=
úú$ %
tris
úú& *
[
úú* +
submeshIndex
úú+ 7
]
úú7 8
;
úú8 9
var
ùù 
quad
ùù  $
=
ùù% &
quads
ùù' ,
[
ùù, -
submeshIndex
ùù- 9
]
ùù9 :
;
ùù: ;
int
üü 
triCount
üü  (
=
üü) *
tri
üü+ .
.
üü. /
Count
üü/ 4
;
üü4 5
int
†† 
	quadCount
††  )
=
††* +
quad
††, 0
.
††0 1
Count
††1 6
;
††6 7
int
¢¢ 
[
¢¢  
]
¢¢  !
	triangles
¢¢" +
=
¢¢, -
new
¢¢. 1
int
¢¢2 5
[
¢¢5 6
triCount
¢¢6 >
+
¢¢? @
(
¢¢A B
(
¢¢B C
	quadCount
¢¢C L
/
¢¢M N
$num
¢¢O P
)
¢¢P Q
*
¢¢R S
$num
¢¢T U
)
¢¢U V
]
¢¢V W
;
¢¢W X
for
§§ 
(
§§  !
int
§§! $
i
§§% &
=
§§' (
$num
§§) *
;
§§* +
i
§§, -
<
§§. /
triCount
§§0 8
;
§§8 9
i
§§: ;
++
§§; =
)
§§= >
	triangles
••  )
[
••) *
i
••* +
]
••+ ,
=
••- .
tri
••/ 2
[
••2 3
i
••3 4
]
••4 5
;
••5 6
for
ßß 
(
ßß  !
int
ßß! $
i
ßß% &
=
ßß' (
$num
ßß) *
,
ßß* +
n
ßß, -
=
ßß. /
triCount
ßß0 8
;
ßß8 9
i
ßß: ;
<
ßß< =
	quadCount
ßß> G
;
ßßG H
i
ßßI J
+=
ßßK M
$num
ßßN O
,
ßßO P
n
ßßQ R
+=
ßßS U
$num
ßßV W
)
ßßW X
{
®® 
	triangles
©©  )
[
©©) *
n
©©* +
+
©©, -
$num
©©. /
]
©©/ 0
=
©©1 2
quad
©©3 7
[
©©7 8
i
©©8 9
+
©©: ;
$num
©©< =
]
©©= >
;
©©> ?
	triangles
™™  )
[
™™) *
n
™™* +
+
™™, -
$num
™™. /
]
™™/ 0
=
™™1 2
quad
™™3 7
[
™™7 8
i
™™8 9
+
™™: ;
$num
™™< =
]
™™= >
;
™™> ?
	triangles
´´  )
[
´´) *
n
´´* +
+
´´, -
$num
´´. /
]
´´/ 0
=
´´1 2
quad
´´3 7
[
´´7 8
i
´´8 9
+
´´: ;
$num
´´< =
]
´´= >
;
´´> ?
	triangles
≠≠  )
[
≠≠) *
n
≠≠* +
+
≠≠, -
$num
≠≠. /
]
≠≠/ 0
=
≠≠1 2
quad
≠≠3 7
[
≠≠7 8
i
≠≠8 9
+
≠≠: ;
$num
≠≠< =
]
≠≠= >
;
≠≠> ?
	triangles
ÆÆ  )
[
ÆÆ) *
n
ÆÆ* +
+
ÆÆ, -
$num
ÆÆ. /
]
ÆÆ/ 0
=
ÆÆ1 2
quad
ÆÆ3 7
[
ÆÆ7 8
i
ÆÆ8 9
+
ÆÆ: ;
$num
ÆÆ< =
]
ÆÆ= >
;
ÆÆ> ?
	triangles
ØØ  )
[
ØØ) *
n
ØØ* +
+
ØØ, -
$num
ØØ. /
]
ØØ/ 0
=
ØØ1 2
quad
ØØ3 7
[
ØØ7 8
i
ØØ8 9
+
ØØ: ;
$num
ØØ< =
]
ØØ= >
;
ØØ> ?
}
∞∞ 
	submeshes
≤≤ %
[
≤≤% &
submeshIndex
≤≤& 2
]
≤≤2 3
=
≤≤4 5
new
≤≤6 9
Submesh
≤≤: A
(
≤≤A B
submeshIndex
≤≤B N
,
≤≤N O
MeshTopology
≤≤P \
.
≤≤\ ]
	Triangles
≤≤] f
,
≤≤f g
	triangles
≤≤h q
)
≤≤q r
;
≤≤r s
}
≥≥ 
else
¥¥ 
{
µµ 
	submeshes
∂∂ %
[
∂∂% &
submeshIndex
∂∂& 2
]
∂∂2 3
=
∂∂4 5
new
∂∂6 9
Submesh
∂∂: A
(
∂∂A B
submeshIndex
∂∂B N
,
∂∂N O
MeshTopology
∂∂P \
.
∂∂\ ]
Quads
∂∂] b
,
∂∂b c
quads
∂∂d i
[
∂∂i j
submeshIndex
∂∂j v
]
∂∂v w
)
∂∂w x
;
∂∂x y
}
∑∑ 
}
∏∏ 
break
ππ 
;
ππ 
}
∫∫ 
}
ªª 
return
ΩΩ 
	submeshes
ΩΩ 
;
ΩΩ 
}
ææ 	
internal
¿¿ 
static
¿¿ 
void
¿¿ ,
MapFaceMaterialsToSubmeshIndex
¿¿ ;
(
¿¿; <
ProBuilderMesh
¿¿< J
mesh
¿¿K O
)
¿¿O P
{
¡¡ 	
var
¬¬ 
	materials
¬¬ 
=
¬¬ 
mesh
¬¬  
.
¬¬  !
renderer
¬¬! )
.
¬¬) *
sharedMaterials
¬¬* 9
;
¬¬9 :
var
√√ 
submeshCount
√√ 
=
√√ 
	materials
√√ (
.
√√( )
Length
√√) /
;
√√/ 0
foreach
≈≈ 
(
≈≈ 
var
≈≈ 
face
≈≈ 
in
≈≈  
mesh
≈≈! %
.
≈≈% &
facesInternal
≈≈& 3
)
≈≈3 4
{
∆∆ 
if
»» 
(
»» 
face
»» 
.
»» 
material
»» !
==
»»" $
null
»»% )
)
»») *
continue
…… 
;
…… 
var
   
index
   
=
   
Array
   !
.
  ! "
IndexOf
  " )
(
  ) *
	materials
  * 3
,
  3 4
face
  5 9
.
  9 :
material
  : B
)
  B C
;
  C D
face
ÀÀ 
.
ÀÀ 
submeshIndex
ÀÀ !
=
ÀÀ" #
Math
ÀÀ$ (
.
ÀÀ( )
Clamp
ÀÀ) .
(
ÀÀ. /
index
ÀÀ/ 4
,
ÀÀ4 5
$num
ÀÀ6 7
,
ÀÀ7 8
submeshCount
ÀÀ9 E
-
ÀÀF G
$num
ÀÀH I
)
ÀÀI J
;
ÀÀJ K
face
ÃÃ 
.
ÃÃ 
material
ÃÃ 
=
ÃÃ 
null
ÃÃ  $
;
ÃÃ$ %
}
ŒŒ 
}
œœ 	
}
–– 
}—— Í/
àD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\IntVec3.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
struct 

IntVec3 
: 
System 
. 

IEquatable &
<& '
IntVec3' .
>. /
{		 
public

 
Vector3

 
value

 
;

 
public 
float 
x 
{ 
get 
{ 
return %
value& +
.+ ,
x, -
;- .
}/ 0
}1 2
public 
float 
y 
{ 
get 
{ 
return %
value& +
.+ ,
y, -
;- .
}/ 0
}1 2
public 
float 
z 
{ 
get 
{ 
return %
value& +
.+ ,
z, -
;- .
}/ 0
}1 2
public 
IntVec3 
( 
Vector3 
vector %
)% &
{ 	
this 
. 
value 
= 
vector 
;  
} 	
public 
override 
string 
ToString '
(' (
)( )
{ 	
return 
string 
. 
Format  
(  !
$str! ;
,; <
x= >
,> ?
y@ A
,A B
zC D
)D E
;E F
} 	
public 
static 
bool 
operator #
==# %
(% &
IntVec3& -
a. /
,/ 0
IntVec31 8
b9 :
): ;
{ 	
return 
a 
. 
Equals 
( 
b 
) 
; 
} 	
public 
static 
bool 
operator #
!=# %
(% &
IntVec3& -
a. /
,/ 0
IntVec31 8
b9 :
): ;
{   	
return!! 
!!! 
(!! 
a!! 
==!! 
b!! 
)!! 
;!! 
}"" 	
public$$ 
bool$$ 
Equals$$ 
($$ 
IntVec3$$ "
p$$# $
)$$$ %
{%% 	
return&& 
round&& 
(&& 
x&& 
)&& 
==&& 
round&& $
(&&$ %
p&&% &
.&&& '
x&&' (
)&&( )
&&&&* ,
round'' 
('' 
y'' 
)'' 
=='' 
round'' !
(''! "
p''" #
.''# $
y''$ %
)''% &
&&''' )
round(( 
((( 
z(( 
)(( 
==(( 
round(( !
(((! "
p((" #
.((# $
z(($ %
)((% &
;((& '
})) 	
public++ 
bool++ 
Equals++ 
(++ 
Vector3++ "
p++# $
)++$ %
{,, 	
return-- 
round-- 
(-- 
x-- 
)-- 
==-- 
round-- $
(--$ %
p--% &
.--& '
x--' (
)--( )
&&--* ,
round.. 
(.. 
y.. 
).. 
==.. 
round.. !
(..! "
p.." #
...# $
y..$ %
)..% &
&&..' )
round// 
(// 
z// 
)// 
==// 
round// !
(//! "
p//" #
.//# $
z//$ %
)//% &
;//& '
}00 	
public22 
override22 
bool22 
Equals22 #
(22# $
System22$ *
.22* +
Object22+ 1
b222 3
)223 4
{33 	
return44 
(44 
b44 
is44 
IntVec344  
&&44! #
(44$ %
this44% )
.44) *
Equals44* 0
(440 1
(441 2
IntVec3442 9
)449 :
b44: ;
)44; <
)44< =
)44= >
||44? A
(55 
b55 
is55 
Vector355 
&&55  
this55! %
.55% &
Equals55& ,
(55, -
(55- .
Vector355. 5
)555 6
b556 7
)557 8
)558 9
;559 :
}66 	
public88 
override88 
int88 
GetHashCode88 '
(88' (
)88( )
{99 	
return:: 

VectorHash:: 
.:: 
GetHashCode:: )
(::) *
value::* /
)::/ 0
;::0 1
};; 	
private== 
static== 
int== 
round==  
(==  !
float==! &
v==' (
)==( )
{>> 	
return?? 
System?? 
.?? 
Convert?? !
.??! "
ToInt32??" )
(??) *
v??* +
*??, -

VectorHash??. 8
.??8 9 
FltCompareResolution??9 M
)??M N
;??N O
}@@ 	
publicBB 
staticBB 
implicitBB 
operatorBB '
Vector3BB( /
(BB/ 0
IntVec3BB0 7
pBB8 9
)BB9 :
{CC 	
returnDD 
pDD 
.DD 
valueDD 
;DD 
}EE 	
publicGG 
staticGG 
implicitGG 
operatorGG '
IntVec3GG( /
(GG/ 0
Vector3GG0 7
pGG8 9
)GG9 :
{HH 	
returnII 
newII 
IntVec3II 
(II 
pII  
)II  !
;II! "
}JJ 	
}KK 
}LL ıÈ
ÖD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Math.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public		 

static		 
class		 
Math		 
{

 
public 
const 
float 
phi 
=  
$num! 3
;3 4
const 
float 
k_FltEpsilon  
=! "
float# (
.( )
Epsilon) 0
;0 1
const 
float 
k_FltCompareEpsilon '
=( )
$num* 0
;0 1
internal 
const 
float 
handleEpsilon *
=+ ,
$num- 3
;3 4
internal&& 
static&& 
Vector2&&  
PointInCircumference&&  4
(&&4 5
float&&5 :
radius&&; A
,&&A B
float&&C H
angleInDegrees&&I W
,&&W X
Vector2&&Y `
origin&&a g
)&&g h
{'' 	
float)) 
x)) 
=)) 
()) 
float)) 
))) 
()) 
radius)) $
*))% &
Mathf))' ,
.)), -
Cos))- 0
())0 1
Mathf))1 6
.))6 7
Deg2Rad))7 >
*))? @
angleInDegrees))A O
)))O P
)))P Q
+))R S
origin))T Z
.))Z [
x))[ \
;))\ ]
float** 
y** 
=** 
(** 
float** 
)** 
(** 
radius** $
***% &
Mathf**' ,
.**, -
Sin**- 0
(**0 1
Mathf**1 6
.**6 7
Deg2Rad**7 >
***? @
angleInDegrees**A O
)**O P
)**P Q
+**R S
origin**T Z
.**Z [
y**[ \
;**\ ]
return,, 
new,, 
Vector2,, 
(,, 
x,,  
,,,  !
y,," #
),,# $
;,,$ %
}-- 	
internal66 
static66 
Vector366 
PointInSphere66  -
(66- .
float66. 3
radius664 :
,66: ;
float66< A
latitudeAngle66B O
,66O P
float66Q V
longitudeAngle66W e
)66e f
{77 	
float88 
x88 
=88 
(88 
radius88 
*88 
Mathf88  %
.88% &
Cos88& )
(88) *
Mathf88* /
.88/ 0
Deg2Rad880 7
*888 9
latitudeAngle88: G
)88G H
*88I J
Mathf88K P
.88P Q
Sin88Q T
(88T U
Mathf88U Z
.88Z [
Deg2Rad88[ b
*88c d
longitudeAngle88e s
)88s t
)88t u
;88u v
float99 
y99 
=99 
(99 
radius99 
*99 
Mathf99  %
.99% &
Sin99& )
(99) *
Mathf99* /
.99/ 0
Deg2Rad990 7
*998 9
latitudeAngle99: G
)99G H
*99I J
Mathf99K P
.99P Q
Sin99Q T
(99T U
Mathf99U Z
.99Z [
Deg2Rad99[ b
*99c d
longitudeAngle99e s
)99s t
)99t u
;99u v
float:: 
z:: 
=:: 
(:: 
radius:: 
*:: 
Mathf::  %
.::% &
Cos::& )
(::) *
Mathf::* /
.::/ 0
Deg2Rad::0 7
*::8 9
longitudeAngle::: H
)::H I
)::I J
;::J K
return<< 
new<< 
Vector3<< 
(<< 
x<<  
,<<  !
y<<" #
,<<# $
z<<% &
)<<& '
;<<' (
}== 	
internalEE 
staticEE 
floatEE 
SignedAngleEE )
(EE) *
Vector2EE* 1
aEE2 3
,EE3 4
Vector2EE5 <
bEE= >
)EE> ?
{FF 	
floatGG 
tGG 
=GG 
Vector2GG 
.GG 
AngleGG #
(GG# $
aGG$ %
,GG% &
bGG' (
)GG( )
;GG) *
ifHH 
(HH 
bHH 
.HH 
xHH 
-HH 
aHH 
.HH 
xHH 
<HH 
$numHH 
)HH 
tII 
=II 
$numII 
-II 
tII 
;II 
returnJJ 
tJJ 
;JJ 
}KK 	
publicSS 
staticSS 
floatSS 
SqrDistanceSS '
(SS' (
Vector3SS( /
aSS0 1
,SS1 2
Vector3SS3 :
bSS; <
)SS< =
{TT 	
floatUU 
dxUU 
=UU 
bUU 
.UU 
xUU 
-UU 
aUU 
.UU 
xUU  
,UU  !
dyVV 
=VV 
bVV 
.VV 
yVV 
-VV 
aVV 
.VV 
yVV  
,VV  !
dzWW 
=WW 
bWW 
.WW 
zWW 
-WW 
aWW 
.WW 
zWW  
;WW  !
returnXX 
dxXX 
*XX 
dxXX 
+XX 
dyXX 
*XX  !
dyXX" $
+XX% &
dzXX' )
*XX* +
dzXX, .
;XX. /
}YY 	
publiccc 
staticcc 
floatcc 
TriangleAreacc (
(cc( )
Vector3cc) 0
xcc1 2
,cc2 3
Vector3cc4 ;
ycc< =
,cc= >
Vector3cc? F
zccG H
)ccH I
{dd 	
floatee 
aee 
=ee 
SqrDistanceee #
(ee# $
xee$ %
,ee% &
yee' (
)ee( )
,ee) *
bff 
=ff 
SqrDistanceff #
(ff# $
yff$ %
,ff% &
zff' (
)ff( )
,ff) *
cgg 
=gg 
SqrDistancegg #
(gg# $
zgg$ %
,gg% &
xgg' (
)gg( )
;gg) *
returnii 
Mathfii 
.ii 
Sqrtii 
(ii 
(ii 
$numii !
*ii" #
aii$ %
*ii& '
bii( )
+ii* +
$numii, .
*ii/ 0
bii1 2
*ii3 4
cii5 6
+ii7 8
$numii9 ;
*ii< =
cii> ?
*ii@ A
aiiB C
-iiD E
aiiF G
*iiH I
aiiJ K
-iiL M
biiN O
*iiP Q
biiR S
-iiT U
ciiV W
*iiX Y
ciiZ [
)ii[ \
/ii] ^
$numii_ b
)iib c
;iic d
}jj 	
internalrr 
staticrr 
floatrr 
PolygonArearr )
(rr) *
Vector3rr* 1
[rr1 2
]rr2 3
verticesrr4 <
,rr< =
intrr> A
[rrA B
]rrB C
indexesrrD K
)rrK L
{ss 	
floattt 
areatt 
=tt 
$numtt 
;tt 
forvv 
(vv 
intvv 
ivv 
=vv 
$numvv 
;vv 
ivv 
<vv 
indexesvv  '
.vv' (
Lengthvv( .
;vv. /
ivv0 1
+=vv2 4
$numvv5 6
)vv6 7
areaww 
+=ww 
TriangleAreaww $
(ww$ %
verticesww% -
[ww- .
indexesww. 5
[ww5 6
iww6 7
]ww7 8
]ww8 9
,ww9 :
verticesww; C
[wwC D
indexeswwD K
[wwK L
iwwL M
+wwN O
$numwwP Q
]wwQ R
]wwR S
,wwS T
verticeswwU ]
[ww] ^
indexesww^ e
[wwe f
iwwf g
+wwh i
$numwwj k
]wwk l
]wwl m
)wwm n
;wwn o
returnyy 
areayy 
;yy 
}zz 	
internal
ÉÉ 
static
ÉÉ 
Vector2
ÉÉ 
RotateAroundPoint
ÉÉ  1
(
ÉÉ1 2
this
ÉÉ2 6
Vector2
ÉÉ7 >
v
ÉÉ? @
,
ÉÉ@ A
Vector2
ÉÉB I
origin
ÉÉJ P
,
ÉÉP Q
float
ÉÉR W
theta
ÉÉX ]
)
ÉÉ] ^
{
ÑÑ 	
float
ÖÖ 
cx
ÖÖ 
=
ÖÖ 
origin
ÖÖ 
.
ÖÖ 
x
ÖÖ 
,
ÖÖ  
cy
ÖÖ! #
=
ÖÖ$ %
origin
ÖÖ& ,
.
ÖÖ, -
y
ÖÖ- .
;
ÖÖ. /
float
ÜÜ 
px
ÜÜ 
=
ÜÜ 
v
ÜÜ 
.
ÜÜ 
x
ÜÜ 
,
ÜÜ 
py
ÜÜ 
=
ÜÜ  
v
ÜÜ! "
.
ÜÜ" #
y
ÜÜ# $
;
ÜÜ$ %
float
àà 
s
àà 
=
àà 
Mathf
àà 
.
àà 
Sin
àà 
(
àà  
theta
àà  %
*
àà& '
Mathf
àà( -
.
àà- .
Deg2Rad
àà. 5
)
àà5 6
;
àà6 7
float
ââ 
c
ââ 
=
ââ 
Mathf
ââ 
.
ââ 
Cos
ââ 
(
ââ  
theta
ââ  %
*
ââ& '
Mathf
ââ( -
.
ââ- .
Deg2Rad
ââ. 5
)
ââ5 6
;
ââ6 7
px
åå 
-=
åå 
cx
åå 
;
åå 
py
çç 
-=
çç 
cy
çç 
;
çç 
float
êê 
xnew
êê 
=
êê 
px
êê 
*
êê 
c
êê 
+
êê  !
py
êê" $
*
êê% &
s
êê' (
;
êê( )
float
ëë 
ynew
ëë 
=
ëë 
-
ëë 
px
ëë 
*
ëë 
s
ëë  
+
ëë! "
py
ëë# %
*
ëë& '
c
ëë( )
;
ëë) *
px
îî 
=
îî 
xnew
îî 
+
îî 
cx
îî 
;
îî 
py
ïï 
=
ïï 
ynew
ïï 
+
ïï 
cy
ïï 
;
ïï 
return
óó 
new
óó 
Vector2
óó 
(
óó 
px
óó !
,
óó! "
py
óó# %
)
óó% &
;
óó& '
}
òò 	
public
°° 
static
°° 
Vector2
°° 
ScaleAroundPoint
°° .
(
°°. /
this
°°/ 3
Vector2
°°4 ;
v
°°< =
,
°°= >
Vector2
°°? F
origin
°°G M
,
°°M N
Vector2
°°O V
scale
°°W \
)
°°\ ]
{
¢¢ 	
Vector2
££ 
tp
££ 
=
££ 
v
££ 
-
££ 
origin
££ #
;
££# $
tp
§§ 
=
§§ 
Vector2
§§ 
.
§§ 
Scale
§§ 
(
§§ 
tp
§§ !
,
§§! "
scale
§§# (
)
§§( )
;
§§) *
tp
•• 
+=
•• 
origin
•• 
;
•• 
return
ßß 
tp
ßß 
;
ßß 
}
®® 	
internal
™™ 
static
™™ 
Vector2
™™ 
Perpendicular
™™  -
(
™™- .
Vector2
™™. 5
value
™™6 ;
)
™™; <
{
´´ 	
return
¨¨ 
new
¨¨ 
Vector2
¨¨ 
(
¨¨ 
-
¨¨  
value
¨¨  %
.
¨¨% &
y
¨¨& '
,
¨¨' (
value
¨¨) .
.
¨¨. /
x
¨¨/ 0
)
¨¨0 1
;
¨¨1 2
}
≠≠ 	
public
∂∂ 
static
∂∂ 
Vector2
∂∂ 
ReflectPoint
∂∂ *
(
∂∂* +
Vector2
∂∂+ 2
point
∂∂3 8
,
∂∂8 9
Vector2
∂∂: A
	lineStart
∂∂B K
,
∂∂K L
Vector2
∂∂M T
lineEnd
∂∂U \
)
∂∂\ ]
{
∑∑ 	
Vector2
∏∏ 
line
∏∏ 
=
∏∏ 
lineEnd
∏∏ "
-
∏∏# $
	lineStart
∏∏% .
;
∏∏. /
Vector2
ππ 
perp
ππ 
=
ππ 
new
ππ 
Vector2
ππ &
(
ππ& '
-
ππ' (
line
ππ( ,
.
ππ, -
y
ππ- .
,
ππ. /
line
ππ0 4
.
ππ4 5
x
ππ5 6
)
ππ6 7
;
ππ7 8
float
ªª 
dist
ªª 
=
ªª 
Mathf
ªª 
.
ªª 
Sin
ªª "
(
ªª" #
Vector2
ªª# *
.
ªª* +
Angle
ªª+ 0
(
ªª0 1
line
ªª1 5
,
ªª5 6
point
ªª7 <
-
ªª= >
	lineStart
ªª? H
)
ªªH I
*
ªªJ K
Mathf
ªªL Q
.
ªªQ R
Deg2Rad
ªªR Y
)
ªªY Z
*
ªª[ \
Vector2
ªª] d
.
ªªd e
Distance
ªªe m
(
ªªm n
point
ªªn s
,
ªªs t
	lineStart
ªªu ~
)
ªª~ 
;ªª Ä
return
ΩΩ 
point
ΩΩ 
+
ΩΩ 
perp
ΩΩ 
*
ΩΩ  !
(
ΩΩ" #
dist
ΩΩ# '
*
ΩΩ( )
$num
ΩΩ* ,
)
ΩΩ, -
*
ΩΩ. /
(
ΩΩ0 1
Vector2
ΩΩ1 8
.
ΩΩ8 9
Dot
ΩΩ9 <
(
ΩΩ< =
point
ΩΩ= B
-
ΩΩC D
	lineStart
ΩΩE N
,
ΩΩN O
perp
ΩΩP T
)
ΩΩT U
>
ΩΩV W
$num
ΩΩX Y
?
ΩΩZ [
-
ΩΩ\ ]
$num
ΩΩ] _
:
ΩΩ` a
$num
ΩΩb d
)
ΩΩd e
;
ΩΩe f
}
ææ 	
internal
¿¿ 
static
¿¿ 
float
¿¿ !
SqrDistanceRayPoint
¿¿ 1
(
¿¿1 2
Ray
¿¿2 5
ray
¿¿6 9
,
¿¿9 :
Vector3
¿¿; B
point
¿¿C H
)
¿¿H I
{
¡¡ 	
return
¬¬ 
Vector3
¬¬ 
.
¬¬ 
Cross
¬¬  
(
¬¬  !
ray
¬¬! $
.
¬¬$ %
	direction
¬¬% .
,
¬¬. /
point
¬¬0 5
-
¬¬6 7
ray
¬¬8 ;
.
¬¬; <
origin
¬¬< B
)
¬¬B C
.
¬¬C D
sqrMagnitude
¬¬D P
;
¬¬P Q
}
√√ 	
public
ÕÕ 
static
ÕÕ 
float
ÕÕ &
DistancePointLineSegment
ÕÕ 4
(
ÕÕ4 5
Vector2
ÕÕ5 <
point
ÕÕ= B
,
ÕÕB C
Vector2
ÕÕD K
	lineStart
ÕÕL U
,
ÕÕU V
Vector2
ÕÕW ^
lineEnd
ÕÕ_ f
)
ÕÕf g
{
ŒŒ 	
float
–– 
l2
–– 
=
–– 
(
–– 
(
–– 
	lineStart
–– "
.
––" #
x
––# $
-
––% &
lineEnd
––' .
.
––. /
x
––/ 0
)
––0 1
*
––2 3
(
––4 5
	lineStart
––5 >
.
––> ?
x
––? @
-
––A B
lineEnd
––C J
.
––J K
x
––K L
)
––L M
)
––M N
+
––O P
(
––Q R
(
––R S
	lineStart
––S \
.
––\ ]
y
––] ^
-
––_ `
lineEnd
––a h
.
––h i
y
––i j
)
––j k
*
––l m
(
––n o
	lineStart
––o x
.
––x y
y
––y z
-
––{ |
lineEnd––} Ñ
.––Ñ Ö
y––Ö Ü
)––Ü á
)––á à
;––à â
if
““ 
(
““ 
l2
““ 
==
““ 
$num
““ 
)
““ 
return
““ "
Vector2
““# *
.
““* +
Distance
““+ 3
(
““3 4
point
““4 9
,
““9 :
	lineStart
““; D
)
““D E
;
““E F
float
◊◊ 
t
◊◊ 
=
◊◊ 
Vector2
◊◊ 
.
◊◊ 
Dot
◊◊ !
(
◊◊! "
point
◊◊" '
-
◊◊( )
	lineStart
◊◊* 3
,
◊◊3 4
lineEnd
◊◊5 <
-
◊◊= >
	lineStart
◊◊? H
)
◊◊H I
/
◊◊J K
l2
◊◊L N
;
◊◊N O
if
ŸŸ 
(
ŸŸ 
t
ŸŸ 
<
ŸŸ 
$num
ŸŸ 
)
ŸŸ 
return
⁄⁄ 
Vector2
⁄⁄ 
.
⁄⁄ 
Distance
⁄⁄ '
(
⁄⁄' (
point
⁄⁄( -
,
⁄⁄- .
	lineStart
⁄⁄/ 8
)
⁄⁄8 9
;
⁄⁄9 :
else
€€ 
if
€€ 
(
€€ 
t
€€ 
>
€€ 
$num
€€ 
)
€€ 
return
‹‹ 
Vector2
‹‹ 
.
‹‹ 
Distance
‹‹ '
(
‹‹' (
point
‹‹( -
,
‹‹- .
lineEnd
‹‹/ 6
)
‹‹6 7
;
‹‹7 8
Vector2
ﬁﬁ 

projection
ﬁﬁ 
=
ﬁﬁ  
	lineStart
ﬁﬁ! *
+
ﬁﬁ+ ,
t
ﬁﬁ- .
*
ﬁﬁ/ 0
(
ﬁﬁ1 2
lineEnd
ﬁﬁ2 9
-
ﬁﬁ: ;
	lineStart
ﬁﬁ< E
)
ﬁﬁE F
;
ﬁﬁF G
return
‡‡ 
Vector2
‡‡ 
.
‡‡ 
Distance
‡‡ #
(
‡‡# $
point
‡‡$ )
,
‡‡) *

projection
‡‡+ 5
)
‡‡5 6
;
‡‡6 7
}
·· 	
public
ÎÎ 
static
ÎÎ 
float
ÎÎ &
DistancePointLineSegment
ÎÎ 4
(
ÎÎ4 5
Vector3
ÎÎ5 <
point
ÎÎ= B
,
ÎÎB C
Vector3
ÎÎD K
	lineStart
ÎÎL U
,
ÎÎU V
Vector3
ÎÎW ^
lineEnd
ÎÎ_ f
)
ÎÎf g
{
ÏÏ 	
float
ÓÓ 
l2
ÓÓ 
=
ÓÓ 
(
ÓÓ 
(
ÓÓ 
	lineStart
ÓÓ "
.
ÓÓ" #
x
ÓÓ# $
-
ÓÓ% &
lineEnd
ÓÓ' .
.
ÓÓ. /
x
ÓÓ/ 0
)
ÓÓ0 1
*
ÓÓ2 3
(
ÓÓ4 5
	lineStart
ÓÓ5 >
.
ÓÓ> ?
x
ÓÓ? @
-
ÓÓA B
lineEnd
ÓÓC J
.
ÓÓJ K
x
ÓÓK L
)
ÓÓL M
)
ÓÓM N
+
ÓÓO P
(
ÓÓQ R
(
ÓÓR S
	lineStart
ÓÓS \
.
ÓÓ\ ]
y
ÓÓ] ^
-
ÓÓ_ `
lineEnd
ÓÓa h
.
ÓÓh i
y
ÓÓi j
)
ÓÓj k
*
ÓÓl m
(
ÓÓn o
	lineStart
ÓÓo x
.
ÓÓx y
y
ÓÓy z
-
ÓÓ{ |
lineEndÓÓ} Ñ
.ÓÓÑ Ö
yÓÓÖ Ü
)ÓÓÜ á
)ÓÓá à
+ÓÓâ ä
(ÓÓã å
(ÓÓå ç
	lineStartÓÓç ñ
.ÓÓñ ó
zÓÓó ò
-ÓÓô ö
lineEndÓÓõ ¢
.ÓÓ¢ £
zÓÓ£ §
)ÓÓ§ •
*ÓÓ¶ ß
(ÓÓ® ©
	lineStartÓÓ© ≤
.ÓÓ≤ ≥
zÓÓ≥ ¥
-ÓÓµ ∂
lineEndÓÓ∑ æ
.ÓÓæ ø
zÓÓø ¿
)ÓÓ¿ ¡
)ÓÓ¡ ¬
;ÓÓ¬ √
if
 
(
 
l2
 
==
 
$num
 
)
 
return
 "
Vector3
# *
.
* +
Distance
+ 3
(
3 4
point
4 9
,
9 :
	lineStart
; D
)
D E
;
E F
float
ıı 
t
ıı 
=
ıı 
Vector3
ıı 
.
ıı 
Dot
ıı !
(
ıı! "
point
ıı" '
-
ıı( )
	lineStart
ıı* 3
,
ıı3 4
lineEnd
ıı5 <
-
ıı= >
	lineStart
ıı? H
)
ııH I
/
ııJ K
l2
ııL N
;
ııN O
if
˜˜ 
(
˜˜ 
t
˜˜ 
<
˜˜ 
$num
˜˜ 
)
˜˜ 
return
¯¯ 
Vector3
¯¯ 
.
¯¯ 
Distance
¯¯ '
(
¯¯' (
point
¯¯( -
,
¯¯- .
	lineStart
¯¯/ 8
)
¯¯8 9
;
¯¯9 :
else
˘˘ 
if
˘˘ 
(
˘˘ 
t
˘˘ 
>
˘˘ 
$num
˘˘ 
)
˘˘ 
return
˙˙ 
Vector3
˙˙ 
.
˙˙ 
Distance
˙˙ '
(
˙˙' (
point
˙˙( -
,
˙˙- .
lineEnd
˙˙/ 6
)
˙˙6 7
;
˙˙7 8
Vector3
¸¸ 

projection
¸¸ 
=
¸¸  
	lineStart
¸¸! *
+
¸¸+ ,
t
¸¸- .
*
¸¸/ 0
(
¸¸1 2
lineEnd
¸¸2 9
-
¸¸: ;
	lineStart
¸¸< E
)
¸¸E F
;
¸¸F G
return
˛˛ 
Vector3
˛˛ 
.
˛˛ 
Distance
˛˛ #
(
˛˛# $
point
˛˛$ )
,
˛˛) *

projection
˛˛+ 5
)
˛˛5 6
;
˛˛6 7
}
ˇˇ 	
public
áá 
static
áá 
Vector3
áá #
GetNearestPointRayRay
áá 3
(
áá3 4
Ray
áá4 7
a
áá8 9
,
áá9 :
Ray
áá; >
b
áá? @
)
áá@ A
{
àà 	
return
ââ #
GetNearestPointRayRay
ââ (
(
ââ( )
a
ââ) *
.
ââ* +
origin
ââ+ 1
,
ââ1 2
a
ââ3 4
.
ââ4 5
	direction
ââ5 >
,
ââ> ?
b
ââ@ A
.
ââA B
origin
ââB H
,
ââH I
b
ââJ K
.
ââK L
	direction
ââL U
)
ââU V
;
ââV W
}
ää 	
internal
åå 
static
åå 
Vector3
åå #
GetNearestPointRayRay
åå  5
(
åå5 6
Vector3
åå6 =
ao
åå> @
,
åå@ A
Vector3
ååB I
ad
ååJ L
,
ååL M
Vector3
ååN U
bo
ååV X
,
ååX Y
Vector3
ååZ a
bd
ååb d
)
ååd e
{
çç 	
float
éé 
dot
éé 
=
éé 
Vector3
éé 
.
éé  
Dot
éé  #
(
éé# $
ad
éé$ &
,
éé& '
bd
éé( *
)
éé* +
;
éé+ ,
float
èè 
abs
èè 
=
èè 
Mathf
èè 
.
èè 
Abs
èè !
(
èè! "
dot
èè" %
)
èè% &
;
èè& '
if
íí 
(
íí 
(
íí 
abs
íí 
-
íí 
$num
íí 
)
íí 
>
íí 
Mathf
íí "
.
íí" #
Epsilon
íí# *
||
íí+ -
abs
íí. 1
<
íí2 3
Mathf
íí4 9
.
íí9 :
Epsilon
íí: A
)
ííA B
return
ìì 
ao
ìì 
;
ìì 
Vector3
ïï 
c
ïï 
=
ïï 
bo
ïï 
-
ïï 
ao
ïï 
;
ïï  
float
óó 
n
óó 
=
óó 
-
óó 
dot
óó 
*
óó 
Vector3
óó $
.
óó$ %
Dot
óó% (
(
óó( )
bd
óó) +
,
óó+ ,
c
óó- .
)
óó. /
+
óó0 1
Vector3
óó2 9
.
óó9 :
Dot
óó: =
(
óó= >
ad
óó> @
,
óó@ A
c
óóB C
)
óóC D
*
óóE F
Vector3
óóG N
.
óóN O
Dot
óóO R
(
óóR S
bd
óóS U
,
óóU V
bd
óóW Y
)
óóY Z
;
óóZ [
float
òò 
d
òò 
=
òò 
Vector3
òò 
.
òò 
Dot
òò !
(
òò! "
ad
òò" $
,
òò$ %
ad
òò& (
)
òò( )
*
òò* +
Vector3
òò, 3
.
òò3 4
Dot
òò4 7
(
òò7 8
bd
òò8 :
,
òò: ;
bd
òò< >
)
òò> ?
-
òò@ A
dot
òòB E
*
òòF G
dot
òòH K
;
òòK L
return
öö 
ao
öö 
+
öö 
ad
öö 
*
öö 
(
öö 
n
öö 
/
öö  !
d
öö" #
)
öö# $
;
öö$ %
}
õõ 	
internal
†† 
static
†† 
bool
†† %
GetLineSegmentIntersect
†† 4
(
††4 5
Vector2
††5 <
p0
††= ?
,
††? @
Vector2
††A H
p1
††I K
,
††K L
Vector2
††M T
p2
††U W
,
††W X
Vector2
††Y `
p3
††a c
,
††c d
ref
††e h
Vector2
††i p
	intersect
††q z
)
††z {
{
°° 	
	intersect
¢¢ 
=
¢¢ 
Vector2
¢¢ 
.
¢¢  
zero
¢¢  $
;
¢¢$ %
Vector2
££ 
s1
££ 
,
££ 
s2
££ 
;
££ 
s1
§§ 
.
§§ 
x
§§ 
=
§§ 
p1
§§ 
.
§§ 
x
§§ 
-
§§ 
p0
§§ 
.
§§ 
x
§§ 
;
§§ 
s1
§§$ &
.
§§& '
y
§§' (
=
§§) *
p1
§§+ -
.
§§- .
y
§§. /
-
§§0 1
p0
§§2 4
.
§§4 5
y
§§5 6
;
§§6 7
s2
•• 
.
•• 
x
•• 
=
•• 
p3
•• 
.
•• 
x
•• 
-
•• 
p2
•• 
.
•• 
x
•• 
;
•• 
s2
••$ &
.
••& '
y
••' (
=
••) *
p3
••+ -
.
••- .
y
••. /
-
••0 1
p2
••2 4
.
••4 5
y
••5 6
;
••6 7
float
ßß 
s
ßß 
,
ßß 
t
ßß 
;
ßß 
s
®® 
=
®® 
(
®® 
-
®® 
s1
®® 
.
®® 
y
®® 
*
®® 
(
®® 
p0
®® 
.
®® 
x
®® 
-
®®  
p2
®®! #
.
®®# $
x
®®$ %
)
®®% &
+
®®' (
s1
®®) +
.
®®+ ,
x
®®, -
*
®®. /
(
®®0 1
p0
®®1 3
.
®®3 4
y
®®4 5
-
®®6 7
p2
®®8 :
.
®®: ;
y
®®; <
)
®®< =
)
®®= >
/
®®? @
(
®®A B
-
®®B C
s2
®®C E
.
®®E F
x
®®F G
*
®®H I
s1
®®J L
.
®®L M
y
®®M N
+
®®O P
s1
®®Q S
.
®®S T
x
®®T U
*
®®V W
s2
®®X Z
.
®®Z [
y
®®[ \
)
®®\ ]
;
®®] ^
t
©© 
=
©© 
(
©© 
s2
©© 
.
©© 
x
©© 
*
©© 
(
©© 
p0
©© 
.
©© 
y
©© 
-
©© 
p2
©©  "
.
©©" #
y
©©# $
)
©©$ %
-
©©& '
s2
©©( *
.
©©* +
y
©©+ ,
*
©©- .
(
©©/ 0
p0
©©0 2
.
©©2 3
x
©©3 4
-
©©5 6
p2
©©7 9
.
©©9 :
x
©©: ;
)
©©; <
)
©©< =
/
©©> ?
(
©©@ A
-
©©A B
s2
©©B D
.
©©D E
x
©©E F
*
©©G H
s1
©©I K
.
©©K L
y
©©L M
+
©©N O
s1
©©P R
.
©©R S
x
©©S T
*
©©U V
s2
©©W Y
.
©©Y Z
y
©©Z [
)
©©[ \
;
©©\ ]
if
´´ 
(
´´ 
s
´´ 
>=
´´ 
$num
´´ 
&&
´´ 
s
´´ 
<=
´´ 
$num
´´  
&&
´´! #
t
´´$ %
>=
´´& (
$num
´´) *
&&
´´+ -
t
´´. /
<=
´´0 2
$num
´´3 4
)
´´4 5
{
¨¨ 
	intersect
ÆÆ 
.
ÆÆ 
x
ÆÆ 
=
ÆÆ 
p0
ÆÆ  
.
ÆÆ  !
x
ÆÆ! "
+
ÆÆ# $
(
ÆÆ% &
t
ÆÆ& '
*
ÆÆ( )
s1
ÆÆ* ,
.
ÆÆ, -
x
ÆÆ- .
)
ÆÆ. /
;
ÆÆ/ 0
	intersect
ØØ 
.
ØØ 
y
ØØ 
=
ØØ 
p0
ØØ  
.
ØØ  !
y
ØØ! "
+
ØØ# $
(
ØØ% &
t
ØØ& '
*
ØØ( )
s1
ØØ* ,
.
ØØ, -
y
ØØ- .
)
ØØ. /
;
ØØ/ 0
return
∞∞ 
true
∞∞ 
;
∞∞ 
}
±± 
return
≥≥ 
false
≥≥ 
;
≥≥ 
}
¥¥ 	
internal
ææ 
static
ææ 
bool
ææ %
GetLineSegmentIntersect
ææ 4
(
ææ4 5
Vector2
ææ5 <
p0
ææ= ?
,
ææ? @
Vector2
ææA H
p1
ææI K
,
ææK L
Vector2
ææM T
p2
ææU W
,
ææW X
Vector2
ææY `
p3
ææa c
)
ææc d
{
øø 	
Vector2
¿¿ 
s1
¿¿ 
,
¿¿ 
s2
¿¿ 
;
¿¿ 
s1
¡¡ 
.
¡¡ 
x
¡¡ 
=
¡¡ 
p1
¡¡ 
.
¡¡ 
x
¡¡ 
-
¡¡ 
p0
¡¡ 
.
¡¡ 
x
¡¡ 
;
¡¡ 
s1
¡¡$ &
.
¡¡& '
y
¡¡' (
=
¡¡) *
p1
¡¡+ -
.
¡¡- .
y
¡¡. /
-
¡¡0 1
p0
¡¡2 4
.
¡¡4 5
y
¡¡5 6
;
¡¡6 7
s2
¬¬ 
.
¬¬ 
x
¬¬ 
=
¬¬ 
p3
¬¬ 
.
¬¬ 
x
¬¬ 
-
¬¬ 
p2
¬¬ 
.
¬¬ 
x
¬¬ 
;
¬¬ 
s2
¬¬$ &
.
¬¬& '
y
¬¬' (
=
¬¬) *
p3
¬¬+ -
.
¬¬- .
y
¬¬. /
-
¬¬0 1
p2
¬¬2 4
.
¬¬4 5
y
¬¬5 6
;
¬¬6 7
float
ƒƒ 
s
ƒƒ 
,
ƒƒ 
t
ƒƒ 
;
ƒƒ 
s
≈≈ 
=
≈≈ 
(
≈≈ 
-
≈≈ 
s1
≈≈ 
.
≈≈ 
y
≈≈ 
*
≈≈ 
(
≈≈ 
p0
≈≈ 
.
≈≈ 
x
≈≈ 
-
≈≈  
p2
≈≈! #
.
≈≈# $
x
≈≈$ %
)
≈≈% &
+
≈≈' (
s1
≈≈) +
.
≈≈+ ,
x
≈≈, -
*
≈≈. /
(
≈≈0 1
p0
≈≈1 3
.
≈≈3 4
y
≈≈4 5
-
≈≈6 7
p2
≈≈8 :
.
≈≈: ;
y
≈≈; <
)
≈≈< =
)
≈≈= >
/
≈≈? @
(
≈≈A B
-
≈≈B C
s2
≈≈C E
.
≈≈E F
x
≈≈F G
*
≈≈H I
s1
≈≈J L
.
≈≈L M
y
≈≈M N
+
≈≈O P
s1
≈≈Q S
.
≈≈S T
x
≈≈T U
*
≈≈V W
s2
≈≈X Z
.
≈≈Z [
y
≈≈[ \
)
≈≈\ ]
;
≈≈] ^
t
∆∆ 
=
∆∆ 
(
∆∆ 
s2
∆∆ 
.
∆∆ 
x
∆∆ 
*
∆∆ 
(
∆∆ 
p0
∆∆ 
.
∆∆ 
y
∆∆ 
-
∆∆ 
p2
∆∆  "
.
∆∆" #
y
∆∆# $
)
∆∆$ %
-
∆∆& '
s2
∆∆( *
.
∆∆* +
y
∆∆+ ,
*
∆∆- .
(
∆∆/ 0
p0
∆∆0 2
.
∆∆2 3
x
∆∆3 4
-
∆∆5 6
p2
∆∆7 9
.
∆∆9 :
x
∆∆: ;
)
∆∆; <
)
∆∆< =
/
∆∆> ?
(
∆∆@ A
-
∆∆A B
s2
∆∆B D
.
∆∆D E
x
∆∆E F
*
∆∆G H
s1
∆∆I K
.
∆∆K L
y
∆∆L M
+
∆∆N O
s1
∆∆P R
.
∆∆R S
x
∆∆S T
*
∆∆U V
s2
∆∆W Y
.
∆∆Y Z
y
∆∆Z [
)
∆∆[ \
;
∆∆\ ]
return
»» 
(
»» 
s
»» 
>=
»» 
$num
»» 
&&
»» 
s
»» 
<=
»»  "
$num
»»# $
&&
»»% '
t
»»( )
>=
»»* ,
$num
»»- .
&&
»»/ 1
t
»»2 3
<=
»»4 6
$num
»»7 8
)
»»8 9
;
»»9 :
}
…… 	
internal
““ 
static
““ 
bool
““ 
PointInPolygon
““ +
(
““+ ,
Vector2
““, 3
[
““3 4
]
““4 5
polygon
““6 =
,
““= >
Vector2
““? F
point
““G L
,
““L M
int
““N Q
[
““Q R
]
““R S
indexes
““T [
=
““\ ]
null
““^ b
)
““b c
{
”” 	
int
‘‘ 
len
‘‘ 
=
‘‘ 
indexes
‘‘ 
!=
‘‘  
null
‘‘! %
?
‘‘& '
indexes
‘‘( /
.
‘‘/ 0
Length
‘‘0 6
:
‘‘7 8
polygon
‘‘9 @
.
‘‘@ A
Length
‘‘A G
;
‘‘G H
if
÷÷ 
(
÷÷ 
len
÷÷ 
%
÷÷ 
$num
÷÷ 
!=
÷÷ 
$num
÷÷ 
)
÷÷ 
{
◊◊ 
Debug
ÿÿ 
.
ÿÿ 
LogError
ÿÿ 
(
ÿÿ 
$str
ÿÿ [
)
ÿÿ[ \
;
ÿÿ\ ]
return
ŸŸ 
false
ŸŸ 
;
ŸŸ 
}
⁄⁄ 
Bounds2D
‹‹ 
bounds
‹‹ 
=
‹‹ 
new
‹‹ !
Bounds2D
‹‹" *
(
‹‹* +
polygon
‹‹+ 2
,
‹‹2 3
indexes
‹‹4 ;
)
‹‹; <
;
‹‹< =
if
ﬁﬁ 
(
ﬁﬁ 
bounds
ﬁﬁ 
.
ﬁﬁ 
ContainsPoint
ﬁﬁ $
(
ﬁﬁ$ %
point
ﬁﬁ% *
)
ﬁﬁ* +
)
ﬁﬁ+ ,
{
ﬂﬂ 
Vector2
·· 
p1
·· 
=
·· 
polygon
·· $
[
··$ %
indexes
··% ,
!=
··- /
null
··0 4
?
··5 6
indexes
··7 >
[
··> ?
$num
··? @
]
··@ A
:
··B C
$num
··D E
]
··E F
;
··F G
Vector2
‚‚ 
p2
‚‚ 
=
‚‚ 
polygon
‚‚ $
[
‚‚$ %
indexes
‚‚% ,
!=
‚‚- /
null
‚‚0 4
?
‚‚5 6
indexes
‚‚7 >
[
‚‚> ?
$num
‚‚? @
]
‚‚@ A
:
‚‚B C
$num
‚‚D E
]
‚‚E F
;
‚‚F G
Vector2
„„ 
center
„„ 
=
„„  
p1
„„! #
+
„„$ %
(
„„& '
p2
„„' )
-
„„* +
p1
„„, .
)
„„. /
*
„„0 1
$num
„„2 6
;
„„6 7
Vector2
‰‰ 
dir
‰‰ 
=
‰‰ 
center
‰‰ $
-
‰‰% &
bounds
‰‰' -
.
‰‰- .
center
‰‰. 4
;
‰‰4 5
Vector2
ÊÊ 
rayStart
ÊÊ  
=
ÊÊ! "
bounds
ÊÊ# )
.
ÊÊ) *
center
ÊÊ* 0
+
ÊÊ1 2
dir
ÊÊ3 6
*
ÊÊ7 8
(
ÊÊ9 :
bounds
ÊÊ: @
.
ÊÊ@ A
size
ÊÊA E
.
ÊÊE F
y
ÊÊF G
+
ÊÊH I
bounds
ÊÊJ P
.
ÊÊP Q
size
ÊÊQ U
.
ÊÊU V
x
ÊÊV W
+
ÊÊX Y
$num
ÊÊZ \
)
ÊÊ\ ]
;
ÊÊ] ^
int
ÁÁ 

collisions
ÁÁ 
=
ÁÁ  
$num
ÁÁ! "
;
ÁÁ" #
for
ÈÈ 
(
ÈÈ 
int
ÈÈ 
i
ÈÈ 
=
ÈÈ 
$num
ÈÈ 
;
ÈÈ 
i
ÈÈ  !
<
ÈÈ" #
len
ÈÈ$ '
;
ÈÈ' (
i
ÈÈ) *
+=
ÈÈ+ -
$num
ÈÈ. /
)
ÈÈ/ 0
{
ÍÍ 
int
ÎÎ 
a
ÎÎ 
=
ÎÎ 
indexes
ÎÎ #
!=
ÎÎ$ &
null
ÎÎ' +
?
ÎÎ, -
indexes
ÎÎ. 5
[
ÎÎ5 6
i
ÎÎ6 7
]
ÎÎ7 8
:
ÎÎ9 :
i
ÎÎ; <
;
ÎÎ< =
int
ÏÏ 
b
ÏÏ 
=
ÏÏ 
indexes
ÏÏ #
!=
ÏÏ$ &
null
ÏÏ' +
?
ÏÏ, -
indexes
ÏÏ. 5
[
ÏÏ5 6
i
ÏÏ6 7
+
ÏÏ8 9
$num
ÏÏ: ;
]
ÏÏ; <
:
ÏÏ= >
i
ÏÏ? @
+
ÏÏA B
$num
ÏÏC D
;
ÏÏD E
if
ÓÓ 
(
ÓÓ %
GetLineSegmentIntersect
ÓÓ /
(
ÓÓ/ 0
rayStart
ÓÓ0 8
,
ÓÓ8 9
point
ÓÓ: ?
,
ÓÓ? @
polygon
ÓÓA H
[
ÓÓH I
a
ÓÓI J
]
ÓÓJ K
,
ÓÓK L
polygon
ÓÓM T
[
ÓÓT U
b
ÓÓU V
]
ÓÓV W
)
ÓÓW X
)
ÓÓX Y

collisions
ÔÔ "
++
ÔÔ" $
;
ÔÔ$ %
}
 
return
ÚÚ 

collisions
ÚÚ !
%
ÚÚ" #
$num
ÚÚ$ %
!=
ÚÚ& (
$num
ÚÚ) *
;
ÚÚ* +
}
ÛÛ 
else
ÙÙ 
return
ıı 
false
ıı 
;
ıı 
}
ˆˆ 	
internal
ÉÉ 
static
ÉÉ 
bool
ÉÉ 
PointInPolygon
ÉÉ +
(
ÉÉ+ ,
Vector2
ÉÉ, 3
[
ÉÉ3 4
]
ÉÉ4 5
	positions
ÉÉ6 ?
,
ÉÉ? @
Bounds2D
ÉÉA I

polyBounds
ÉÉJ T
,
ÉÉT U
Edge
ÉÉV Z
[
ÉÉZ [
]
ÉÉ[ \
edges
ÉÉ] b
,
ÉÉb c
Vector2
ÉÉd k
point
ÉÉl q
)
ÉÉq r
{
ÑÑ 	
int
ÖÖ 
len
ÖÖ 
=
ÖÖ 
edges
ÖÖ 
.
ÖÖ 
Length
ÖÖ "
*
ÖÖ# $
$num
ÖÖ% &
;
ÖÖ& '
Vector2
áá 
rayStart
áá 
=
áá 

polyBounds
áá )
.
áá) *
center
áá* 0
+
áá1 2
Vector2
áá3 :
.
áá: ;
up
áá; =
*
áá> ?
(
áá@ A

polyBounds
ááA K
.
ááK L
size
ááL P
.
ááP Q
y
ááQ R
+
ááS T
$num
ááU W
)
ááW X
;
ááX Y
int
ââ 

collisions
ââ 
=
ââ 
$num
ââ 
;
ââ 
for
ãã 
(
ãã 
int
ãã 
i
ãã 
=
ãã 
$num
ãã 
;
ãã 
i
ãã 
<
ãã 
len
ãã  #
;
ãã# $
i
ãã% &
+=
ãã' )
$num
ãã* +
)
ãã+ ,
{
åå 
if
çç 
(
çç %
GetLineSegmentIntersect
çç +
(
çç+ ,
rayStart
çç, 4
,
çç4 5
point
çç6 ;
,
çç; <
	positions
çç= F
[
ççF G
i
ççG H
]
ççH I
,
ççI J
	positions
ççK T
[
ççT U
i
ççU V
+
ççW X
$num
ççY Z
]
ççZ [
)
çç[ \
)
çç\ ]

collisions
éé 
++
éé  
;
éé  !
}
èè 
return
ëë 

collisions
ëë 
%
ëë 
$num
ëë  !
!=
ëë" $
$num
ëë% &
;
ëë& '
}
íí 	
internal
üü 
static
üü 
bool
üü 
PointInPolygon
üü +
(
üü+ ,
Vector3
üü, 3
[
üü3 4
]
üü4 5
	positions
üü6 ?
,
üü? @
Bounds2D
üüA I

polyBounds
üüJ T
,
üüT U
Edge
üüV Z
[
üüZ [
]
üü[ \
edges
üü] b
,
üüb c
Vector2
üüd k
point
üül q
)
üüq r
{
†† 	
int
°° 
len
°° 
=
°° 
edges
°° 
.
°° 
Length
°° "
*
°°# $
$num
°°% &
;
°°& '
Vector2
££ 
rayStart
££ 
=
££ 

polyBounds
££ )
.
££) *
center
££* 0
+
££1 2
Vector2
££3 :
.
££: ;
up
££; =
*
££> ?
(
££@ A

polyBounds
££A K
.
££K L
size
££L P
.
££P Q
y
££Q R
+
££S T
$num
££U W
)
££W X
;
££X Y
int
•• 

collisions
•• 
=
•• 
$num
•• 
;
•• 
for
ßß 
(
ßß 
int
ßß 
i
ßß 
=
ßß 
$num
ßß 
;
ßß 
i
ßß 
<
ßß 
len
ßß  #
;
ßß# $
i
ßß% &
+=
ßß' )
$num
ßß* +
)
ßß+ ,
{
®® 
if
©© 
(
©© %
GetLineSegmentIntersect
©© +
(
©©+ ,
rayStart
©©, 4
,
©©4 5
point
©©6 ;
,
©©; <
	positions
©©= F
[
©©F G
i
©©G H
]
©©H I
,
©©I J
	positions
©©K T
[
©©T U
i
©©U V
+
©©W X
$num
©©Y Z
]
©©Z [
)
©©[ \
)
©©\ ]

collisions
™™ 
++
™™  
;
™™  !
}
´´ 
return
≠≠ 

collisions
≠≠ 
%
≠≠ 
$num
≠≠  !
!=
≠≠" $
$num
≠≠% &
;
≠≠& '
}
ÆÆ 	
internal
∞∞ 
static
∞∞ 
bool
∞∞ '
RectIntersectsLineSegment
∞∞ 6
(
∞∞6 7
Rect
∞∞7 ;
rect
∞∞< @
,
∞∞@ A
Vector2
∞∞B I
a
∞∞J K
,
∞∞K L
Vector2
∞∞M T
b
∞∞U V
)
∞∞V W
{
±± 	
return
≤≤ 
Clipping
≤≤ 
.
≤≤ %
RectContainsLineSegment
≤≤ 3
(
≤≤3 4
rect
≤≤4 8
,
≤≤8 9
a
≤≤: ;
.
≤≤; <
x
≤≤< =
,
≤≤= >
a
≤≤? @
.
≤≤@ A
y
≤≤A B
,
≤≤B C
b
≤≤D E
.
≤≤E F
x
≤≤F G
,
≤≤G H
b
≤≤I J
.
≤≤J K
y
≤≤K L
)
≤≤L M
;
≤≤M N
}
≥≥ 	
internal
µµ 
static
µµ 
bool
µµ '
RectIntersectsLineSegment
µµ 6
(
µµ6 7
Rect
µµ7 ;
rect
µµ< @
,
µµ@ A
Vector3
µµB I
a
µµJ K
,
µµK L
Vector3
µµM T
b
µµU V
)
µµV W
{
∂∂ 	
return
∑∑ 
Clipping
∑∑ 
.
∑∑ %
RectContainsLineSegment
∑∑ 3
(
∑∑3 4
rect
∑∑4 8
,
∑∑8 9
a
∑∑: ;
.
∑∑; <
x
∑∑< =
,
∑∑= >
a
∑∑? @
.
∑∑@ A
y
∑∑A B
,
∑∑B C
b
∑∑D E
.
∑∑E F
x
∑∑F G
,
∑∑G H
b
∑∑I J
.
∑∑J K
y
∑∑K L
)
∑∑L M
;
∑∑M N
}
∏∏ 	
public
»» 
static
»» 
bool
»» #
RayIntersectsTriangle
»» 0
(
»»0 1
Ray
»»1 4
InRay
»»5 :
,
»»: ;
Vector3
»»< C
InTriangleA
»»D O
,
»»O P
Vector3
»»Q X
InTriangleB
»»Y d
,
»»d e
Vector3
»»f m
InTriangleC
»»n y
,
»»y z
out
…… 
float
…… 
OutDistance
…… !
,
……! "
out
……# &
Vector3
……' .
OutPoint
……/ 7
)
……7 8
{
   	
OutDistance
ÀÀ 
=
ÀÀ 
$num
ÀÀ 
;
ÀÀ 
OutPoint
ÃÃ 
=
ÃÃ 
Vector3
ÃÃ 
.
ÃÃ 
zero
ÃÃ #
;
ÃÃ# $
Vector3
œœ 
e1
œœ 
=
œœ 
InTriangleB
œœ $
-
œœ% &
InTriangleA
œœ' 2
;
œœ2 3
Vector3
–– 
e2
–– 
=
–– 
InTriangleC
–– $
-
––% &
InTriangleA
––' 2
;
––2 3
Vector3
”” 
P
”” 
=
”” 
Vector3
”” 
.
””  
Cross
””  %
(
””% &
InRay
””& +
.
””+ ,
	direction
””, 5
,
””5 6
e2
””7 9
)
””9 :
;
””: ;
float
÷÷ 
det
÷÷ 
=
÷÷ 
Vector3
÷÷ 
.
÷÷  
Dot
÷÷  #
(
÷÷# $
e1
÷÷$ &
,
÷÷& '
P
÷÷( )
)
÷÷) *
;
÷÷* +
if
⁄⁄ 
(
⁄⁄ 
det
⁄⁄ 
>
⁄⁄ 
-
⁄⁄ 
Mathf
⁄⁄ 
.
⁄⁄ 
Epsilon
⁄⁄ $
&&
⁄⁄% '
det
⁄⁄( +
<
⁄⁄, -
Mathf
⁄⁄. 3
.
⁄⁄3 4
Epsilon
⁄⁄4 ;
)
⁄⁄; <
return
€€ 
false
€€ 
;
€€ 
float
›› 
inv_det
›› 
=
›› 
$num
›› 
/
››  
det
››! $
;
››$ %
Vector3
‡‡ 
T
‡‡ 
=
‡‡ 
InRay
‡‡ 
.
‡‡ 
origin
‡‡ $
-
‡‡% &
InTriangleA
‡‡' 2
;
‡‡2 3
float
„„ 
u
„„ 
=
„„ 
Vector3
„„ 
.
„„ 
Dot
„„ !
(
„„! "
T
„„" #
,
„„# $
P
„„% &
)
„„& '
*
„„( )
inv_det
„„* 1
;
„„1 2
if
ÊÊ 
(
ÊÊ 
u
ÊÊ 
<
ÊÊ 
$num
ÊÊ 
||
ÊÊ 
u
ÊÊ 
>
ÊÊ 
$num
ÊÊ  
)
ÊÊ  !
return
ÁÁ 
false
ÁÁ 
;
ÁÁ 
Vector3
ÍÍ 
Q
ÍÍ 
=
ÍÍ 
Vector3
ÍÍ 
.
ÍÍ  
Cross
ÍÍ  %
(
ÍÍ% &
T
ÍÍ& '
,
ÍÍ' (
e1
ÍÍ) +
)
ÍÍ+ ,
;
ÍÍ, -
float
ÌÌ 
v
ÌÌ 
=
ÌÌ 
Vector3
ÌÌ 
.
ÌÌ 
Dot
ÌÌ !
(
ÌÌ! "
InRay
ÌÌ" '
.
ÌÌ' (
	direction
ÌÌ( 1
,
ÌÌ1 2
Q
ÌÌ3 4
)
ÌÌ4 5
*
ÌÌ6 7
inv_det
ÌÌ8 ?
;
ÌÌ? @
if
 
(
 
v
 
<
 
$num
 
||
 
u
 
+
 
v
 
>
! "
$num
# %
)
% &
return
ÒÒ 
false
ÒÒ 
;
ÒÒ 
float
ÛÛ 
t
ÛÛ 
=
ÛÛ 
Vector3
ÛÛ 
.
ÛÛ 
Dot
ÛÛ !
(
ÛÛ! "
e2
ÛÛ" $
,
ÛÛ$ %
Q
ÛÛ& '
)
ÛÛ' (
*
ÛÛ) *
inv_det
ÛÛ+ 2
;
ÛÛ2 3
if
ˆˆ 
(
ˆˆ 
t
ˆˆ 
>
ˆˆ 
Mathf
ˆˆ 
.
ˆˆ 
Epsilon
ˆˆ !
)
ˆˆ! "
{
˜˜ 
OutDistance
˘˘ 
=
˘˘ 
t
˘˘ 
;
˘˘  
OutPoint
˚˚ 
.
˚˚ 
x
˚˚ 
=
˚˚ 
(
˚˚ 
u
˚˚ 
*
˚˚  !
InTriangleB
˚˚" -
.
˚˚- .
x
˚˚. /
+
˚˚0 1
v
˚˚2 3
*
˚˚4 5
InTriangleC
˚˚6 A
.
˚˚A B
x
˚˚B C
+
˚˚D E
(
˚˚F G
$num
˚˚G H
-
˚˚I J
(
˚˚K L
u
˚˚L M
+
˚˚N O
v
˚˚P Q
)
˚˚Q R
)
˚˚R S
*
˚˚T U
InTriangleA
˚˚V a
.
˚˚a b
x
˚˚b c
)
˚˚c d
;
˚˚d e
OutPoint
¸¸ 
.
¸¸ 
y
¸¸ 
=
¸¸ 
(
¸¸ 
u
¸¸ 
*
¸¸  !
InTriangleB
¸¸" -
.
¸¸- .
y
¸¸. /
+
¸¸0 1
v
¸¸2 3
*
¸¸4 5
InTriangleC
¸¸6 A
.
¸¸A B
y
¸¸B C
+
¸¸D E
(
¸¸F G
$num
¸¸G H
-
¸¸I J
(
¸¸K L
u
¸¸L M
+
¸¸N O
v
¸¸P Q
)
¸¸Q R
)
¸¸R S
*
¸¸T U
InTriangleA
¸¸V a
.
¸¸a b
y
¸¸b c
)
¸¸c d
;
¸¸d e
OutPoint
˝˝ 
.
˝˝ 
z
˝˝ 
=
˝˝ 
(
˝˝ 
u
˝˝ 
*
˝˝  !
InTriangleB
˝˝" -
.
˝˝- .
z
˝˝. /
+
˝˝0 1
v
˝˝2 3
*
˝˝4 5
InTriangleC
˝˝6 A
.
˝˝A B
z
˝˝B C
+
˝˝D E
(
˝˝F G
$num
˝˝G H
-
˝˝I J
(
˝˝K L
u
˝˝L M
+
˝˝N O
v
˝˝P Q
)
˝˝Q R
)
˝˝R S
*
˝˝T U
InTriangleA
˝˝V a
.
˝˝a b
z
˝˝b c
)
˝˝c d
;
˝˝d e
return
ˇˇ 
true
ˇˇ 
;
ˇˇ 
}
ÄÄ 
return
ÇÇ 
false
ÇÇ 
;
ÇÇ 
}
ÉÉ 	
static
ÜÜ 
Vector3
ÜÜ 
tv1
ÜÜ 
,
ÜÜ 
tv2
ÜÜ 
,
ÜÜ  
tv3
ÜÜ! $
,
ÜÜ$ %
tv4
ÜÜ& )
;
ÜÜ) *
internal
ìì 
static
ìì 
bool
ìì $
RayIntersectsTriangle2
ìì 3
(
ìì3 4
Vector3
ìì4 ;
origin
ìì< B
,
ììB C
Vector3
îî 
dir
îî 
,
îî 
Vector3
ïï 
vert0
ïï 
,
ïï 
Vector3
ññ 
vert1
ññ 
,
ññ 
Vector3
óó 
vert2
óó 
,
óó 
ref
òò 
float
òò 
distance
òò 
,
òò 
ref
ôô 
Vector3
ôô 
normal
ôô 
)
ôô 
{
öö 	
Math
õõ 
.
õõ 
Subtract
õõ 
(
õõ 
vert0
õõ 
,
õõ  
vert1
õõ! &
,
õõ& '
ref
õõ( +
tv1
õõ, /
)
õõ/ 0
;
õõ0 1
Math
úú 
.
úú 
Subtract
úú 
(
úú 
vert0
úú 
,
úú  
vert2
úú! &
,
úú& '
ref
úú( +
tv2
úú, /
)
úú/ 0
;
úú0 1
Math
ûû 
.
ûû 
Cross
ûû 
(
ûû 
dir
ûû 
,
ûû 
tv2
ûû 
,
ûû  
ref
ûû! $
tv4
ûû% (
)
ûû( )
;
ûû) *
float
üü 
det
üü 
=
üü 
Vector3
üü 
.
üü  
Dot
üü  #
(
üü# $
tv1
üü$ '
,
üü' (
tv4
üü) ,
)
üü, -
;
üü- .
if
°° 
(
°° 
det
°° 
<
°° 
Mathf
°° 
.
°° 
Epsilon
°° #
)
°°# $
return
¢¢ 
false
¢¢ 
;
¢¢ 
Math
§§ 
.
§§ 
Subtract
§§ 
(
§§ 
vert0
§§ 
,
§§  
origin
§§! '
,
§§' (
ref
§§) ,
tv3
§§- 0
)
§§0 1
;
§§1 2
float
¶¶ 
u
¶¶ 
=
¶¶ 
Vector3
¶¶ 
.
¶¶ 
Dot
¶¶ !
(
¶¶! "
tv3
¶¶" %
,
¶¶% &
tv4
¶¶' *
)
¶¶* +
;
¶¶+ ,
if
®® 
(
®® 
u
®® 
<
®® 
$num
®® 
||
®® 
u
®® 
>
®® 
det
®® !
)
®®! "
return
©© 
false
©© 
;
©© 
Math
´´ 
.
´´ 
Cross
´´ 
(
´´ 
tv3
´´ 
,
´´ 
tv1
´´ 
,
´´  
ref
´´! $
tv4
´´% (
)
´´( )
;
´´) *
float
≠≠ 
v
≠≠ 
=
≠≠ 
Vector3
≠≠ 
.
≠≠ 
Dot
≠≠ !
(
≠≠! "
dir
≠≠" %
,
≠≠% &
tv4
≠≠' *
)
≠≠* +
;
≠≠+ ,
if
ØØ 
(
ØØ 
v
ØØ 
<
ØØ 
$num
ØØ 
||
ØØ 
u
ØØ 
+
ØØ 
v
ØØ 
>
ØØ  !
det
ØØ" %
)
ØØ% &
return
∞∞ 
false
∞∞ 
;
∞∞ 
distance
≤≤ 
=
≤≤ 
Vector3
≤≤ 
.
≤≤ 
Dot
≤≤ "
(
≤≤" #
tv2
≤≤# &
,
≤≤& '
tv4
≤≤( +
)
≤≤+ ,
*
≤≤- .
(
≤≤/ 0
$num
≤≤0 2
/
≤≤3 4
det
≤≤5 8
)
≤≤8 9
;
≤≤9 :
Math
≥≥ 
.
≥≥ 
Cross
≥≥ 
(
≥≥ 
tv1
≥≥ 
,
≥≥ 
tv2
≥≥ 
,
≥≥  
ref
≥≥! $
normal
≥≥% +
)
≥≥+ ,
;
≥≥, -
return
µµ 
true
µµ 
;
µµ 
}
∂∂ 	
public
ææ 
static
ææ 
float
ææ 
Secant
ææ "
(
ææ" #
float
ææ# (
x
ææ) *
)
ææ* +
{
øø 	
return
¿¿ 
$num
¿¿ 
/
¿¿ 
Mathf
¿¿ 
.
¿¿ 
Cos
¿¿ !
(
¿¿! "
x
¿¿" #
)
¿¿# $
;
¿¿$ %
}
¡¡ 	
public
ÃÃ 
static
ÃÃ 
Vector3
ÃÃ 
Normal
ÃÃ $
(
ÃÃ$ %
Vector3
ÃÃ% ,
p0
ÃÃ- /
,
ÃÃ/ 0
Vector3
ÃÃ1 8
p1
ÃÃ9 ;
,
ÃÃ; <
Vector3
ÃÃ= D
p2
ÃÃE G
)
ÃÃG H
{
ÕÕ 	
float
ŒŒ 
ax
ŒŒ 
=
ŒŒ 
p1
ŒŒ 
.
ŒŒ 
x
ŒŒ 
-
ŒŒ 
p0
ŒŒ  "
.
ŒŒ" #
x
ŒŒ# $
,
ŒŒ$ %
ay
œœ 
=
œœ 
p1
œœ 
.
œœ 
y
œœ 
-
œœ 
p0
œœ  "
.
œœ" #
y
œœ# $
,
œœ$ %
az
–– 
=
–– 
p1
–– 
.
–– 
z
–– 
-
–– 
p0
––  "
.
––" #
z
––# $
,
––$ %
bx
—— 
=
—— 
p2
—— 
.
—— 
x
—— 
-
—— 
p0
——  "
.
——" #
x
——# $
,
——$ %
by
““ 
=
““ 
p2
““ 
.
““ 
y
““ 
-
““ 
p0
““  "
.
““" #
y
““# $
,
““$ %
bz
”” 
=
”” 
p2
”” 
.
”” 
z
”” 
-
”” 
p0
””  "
.
””" #
z
””# $
;
””$ %
Vector3
’’ 
cross
’’ 
=
’’ 
Vector3
’’ #
.
’’# $
zero
’’$ (
;
’’( )
Cross
◊◊ 
(
◊◊ 
ax
◊◊ 
,
◊◊ 
ay
◊◊ 
,
◊◊ 
az
◊◊ 
,
◊◊ 
bx
◊◊  
,
◊◊  !
by
◊◊" $
,
◊◊$ %
bz
◊◊& (
,
◊◊( )
ref
◊◊* -
cross
◊◊. 3
.
◊◊3 4
x
◊◊4 5
,
◊◊5 6
ref
◊◊7 :
cross
◊◊; @
.
◊◊@ A
y
◊◊A B
,
◊◊B C
ref
◊◊D G
cross
◊◊H M
.
◊◊M N
z
◊◊N O
)
◊◊O P
;
◊◊P Q
if
ŸŸ 
(
ŸŸ 
cross
ŸŸ 
.
ŸŸ 
	magnitude
ŸŸ 
<
ŸŸ  !
Mathf
ŸŸ" '
.
ŸŸ' (
Epsilon
ŸŸ( /
)
ŸŸ/ 0
{
⁄⁄ 
return
€€ 
new
€€ 
Vector3
€€ "
(
€€" #
$num
€€# %
,
€€% &
$num
€€' )
,
€€) *
$num
€€+ -
)
€€- .
;
€€. /
}
‹‹ 
else
›› 
{
ﬁﬁ 
cross
ﬂﬂ 
.
ﬂﬂ 
	Normalize
ﬂﬂ 
(
ﬂﬂ  
)
ﬂﬂ  !
;
ﬂﬂ! "
return
‡‡ 
cross
‡‡ 
;
‡‡ 
}
·· 
}
‚‚ 	
internal
ÍÍ 
static
ÍÍ 
Vector3
ÍÍ 
Normal
ÍÍ  &
(
ÍÍ& '
IList
ÍÍ' ,
<
ÍÍ, -
Vertex
ÍÍ- 3
>
ÍÍ3 4
vertices
ÍÍ5 =
,
ÍÍ= >
IList
ÍÍ? D
<
ÍÍD E
int
ÍÍE H
>
ÍÍH I
indexes
ÍÍJ Q
=
ÍÍR S
null
ÍÍT X
)
ÍÍX Y
{
ÎÎ 	
if
ÏÏ 
(
ÏÏ 
indexes
ÏÏ 
==
ÏÏ 
null
ÏÏ 
||
ÏÏ  "
indexes
ÏÏ# *
.
ÏÏ* +
Count
ÏÏ+ 0
%
ÏÏ1 2
$num
ÏÏ3 4
!=
ÏÏ5 7
$num
ÏÏ8 9
)
ÏÏ9 :
{
ÌÌ 
Vector3
ÓÓ 
cross
ÓÓ 
=
ÓÓ 
Vector3
ÓÓ  '
.
ÓÓ' (
Cross
ÓÓ( -
(
ÓÓ- .
vertices
ÓÓ. 6
[
ÓÓ6 7
$num
ÓÓ7 8
]
ÓÓ8 9
.
ÓÓ9 :
position
ÓÓ: B
-
ÓÓC D
vertices
ÓÓE M
[
ÓÓM N
$num
ÓÓN O
]
ÓÓO P
.
ÓÓP Q
position
ÓÓQ Y
,
ÓÓY Z
vertices
ÓÓ[ c
[
ÓÓc d
$num
ÓÓd e
]
ÓÓe f
.
ÓÓf g
position
ÓÓg o
-
ÓÓp q
vertices
ÓÓr z
[
ÓÓz {
$num
ÓÓ{ |
]
ÓÓ| }
.
ÓÓ} ~
positionÓÓ~ Ü
)ÓÓÜ á
;ÓÓá à
cross
ÔÔ 
.
ÔÔ 
	Normalize
ÔÔ 
(
ÔÔ  
)
ÔÔ  !
;
ÔÔ! "
return
 
cross
 
;
 
}
ÒÒ 
else
ÚÚ 
{
ÛÛ 
int
ÙÙ 
len
ÙÙ 
=
ÙÙ 
indexes
ÙÙ !
.
ÙÙ! "
Count
ÙÙ" '
;
ÙÙ' (
Vector3
ıı 
nrm
ıı 
=
ıı 
Vector3
ıı %
.
ıı% &
zero
ıı& *
;
ıı* +
for
˜˜ 
(
˜˜ 
int
˜˜ 
i
˜˜ 
=
˜˜ 
$num
˜˜ 
;
˜˜ 
i
˜˜  !
<
˜˜" #
len
˜˜$ '
;
˜˜' (
i
˜˜) *
+=
˜˜+ -
$num
˜˜. /
)
˜˜/ 0
nrm
¯¯ 
+=
¯¯ 
Normal
¯¯ !
(
¯¯! "
vertices
¯¯" *
[
¯¯* +
indexes
¯¯+ 2
[
¯¯2 3
i
¯¯3 4
]
¯¯4 5
]
¯¯5 6
.
¯¯6 7
position
¯¯7 ?
,
¯¯? @
vertices
¯¯A I
[
¯¯I J
indexes
¯¯J Q
[
¯¯Q R
i
¯¯R S
+
¯¯T U
$num
¯¯V W
]
¯¯W X
]
¯¯X Y
.
¯¯Y Z
position
¯¯Z b
,
¯¯b c
vertices
¯¯d l
[
¯¯l m
indexes
¯¯m t
[
¯¯t u
i
¯¯u v
+
¯¯w x
$num
¯¯y z
]
¯¯z {
]
¯¯{ |
.
¯¯| }
position¯¯} Ö
)¯¯Ö Ü
;¯¯Ü á
nrm
˙˙ 
/=
˙˙ 
(
˙˙ 
len
˙˙ 
/
˙˙ 
$num
˙˙  
)
˙˙  !
;
˙˙! "
nrm
˚˚ 
.
˚˚ 
	Normalize
˚˚ 
(
˚˚ 
)
˚˚ 
;
˚˚  
return
˝˝ 
nrm
˝˝ 
;
˝˝ 
}
˛˛ 
}
ˇˇ 	
public
áá 
static
áá 
Vector3
áá 
Normal
áá $
(
áá$ %
ProBuilderMesh
áá% 3
mesh
áá4 8
,
áá8 9
Face
áá: >
face
áá? C
)
ááC D
{
àà 	
if
ââ 
(
ââ 
mesh
ââ 
==
ââ 
null
ââ 
||
ââ 
face
ââ  $
==
ââ% '
null
ââ( ,
)
ââ, -
throw
ää 
new
ää #
ArgumentNullException
ää /
(
ää/ 0
$str
ää0 6
)
ää6 7
;
ää7 8
var
åå 
	positions
åå 
=
åå 
mesh
åå  
.
åå  !
positionsInternal
åå! 2
;
åå2 3
Vector3
íí 
nrm
íí 
=
íí 
Normal
íí  
(
íí  !
	positions
ìì 
[
ìì 
face
ìì "
.
ìì" #
indexesInternal
ìì# 2
[
ìì2 3
$num
ìì3 4
]
ìì4 5
]
ìì5 6
,
ìì6 7
	positions
îî 
[
îî 
face
îî "
.
îî" #
indexesInternal
îî# 2
[
îî2 3
$num
îî3 4
]
îî4 5
]
îî5 6
,
îî6 7
	positions
ïï 
[
ïï 
face
ïï "
.
ïï" #
indexesInternal
ïï# 2
[
ïï2 3
$num
ïï3 4
]
ïï4 5
]
ïï5 6
)
ïï6 7
;
ïï7 8
if
óó 
(
óó 
face
óó 
.
óó 
indexesInternal
óó $
.
óó$ %
Length
óó% +
>
óó, -
$num
óó. /
)
óó/ 0
{
òò 
Vector3
ôô 
prj
ôô 
=
ôô 

Projection
ôô (
.
ôô( )
FindBestPlane
ôô) 6
(
ôô6 7
	positions
ôô7 @
,
ôô@ A
face
ôôB F
.
ôôF G%
distinctIndexesInternal
ôôG ^
)
ôô^ _
.
ôô_ `
normal
ôô` f
;
ôôf g
if
õõ 
(
õõ 
Vector3
õõ 
.
õõ 
Dot
õõ 
(
õõ  
nrm
õõ  #
,
õõ# $
prj
õõ% (
)
õõ( )
<
õõ* +
$num
õõ, .
)
õõ. /
{
úú 
nrm
ùù 
.
ùù 
x
ùù 
=
ùù 
-
ùù 
prj
ùù  
.
ùù  !
x
ùù! "
;
ùù" #
nrm
ûû 
.
ûû 
y
ûû 
=
ûû 
-
ûû 
prj
ûû  
.
ûû  !
y
ûû! "
;
ûû" #
nrm
üü 
.
üü 
z
üü 
=
üü 
-
üü 
prj
üü  
.
üü  !
z
üü! "
;
üü" #
}
†† 
else
°° 
{
¢¢ 
nrm
££ 
.
££ 
x
££ 
=
££ 
prj
££ 
.
££  
x
££  !
;
££! "
nrm
§§ 
.
§§ 
y
§§ 
=
§§ 
prj
§§ 
.
§§  
y
§§  !
;
§§! "
nrm
•• 
.
•• 
z
•• 
=
•• 
prj
•• 
.
••  
z
••  !
;
••! "
}
¶¶ 
}
ßß 
return
©© 
nrm
©© 
;
©© 
}
™™ 	
internal
≤≤ 
static
≤≤ 
Vector3
≤≤ 
Normal
≤≤  &
(
≤≤& '
IList
≤≤' ,
<
≤≤, -
Vector3
≤≤- 4
>
≤≤4 5
p
≤≤6 7
)
≤≤7 8
{
≥≥ 	
if
¥¥ 
(
¥¥ 
p
¥¥ 
==
¥¥ 
null
¥¥ 
||
¥¥ 
p
¥¥ 
.
¥¥ 
Count
¥¥ $
<
¥¥% &
$num
¥¥' (
)
¥¥( )
return
µµ 
Vector3
µµ 
.
µµ 
zero
µµ #
;
µµ# $
int
∑∑ 
c
∑∑ 
=
∑∑ 
p
∑∑ 
.
∑∑ 
Count
∑∑ 
;
∑∑ 
if
ππ 
(
ππ 
c
ππ 
%
ππ 
$num
ππ 
==
ππ 
$num
ππ 
)
ππ 
{
∫∫ 
Vector3
ªª 
nrm
ªª 
=
ªª 
Vector3
ªª %
.
ªª% &
zero
ªª& *
;
ªª* +
for
ºº 
(
ºº 
int
ºº 
i
ºº 
=
ºº 
$num
ºº 
;
ºº 
i
ºº  !
<
ºº" #
c
ºº$ %
;
ºº% &
i
ºº' (
+=
ºº) +
$num
ºº, -
)
ºº- .
nrm
ΩΩ 
+=
ΩΩ 
Normal
ΩΩ !
(
ΩΩ! "
p
ΩΩ" #
[
ΩΩ# $
i
ΩΩ$ %
+
ΩΩ& '
$num
ΩΩ( )
]
ΩΩ) *
,
ΩΩ* +
p
ΩΩ, -
[
ΩΩ- .
i
ΩΩ. /
+
ΩΩ0 1
$num
ΩΩ2 3
]
ΩΩ3 4
,
ΩΩ4 5
p
ΩΩ6 7
[
ΩΩ7 8
i
ΩΩ8 9
+
ΩΩ: ;
$num
ΩΩ< =
]
ΩΩ= >
)
ΩΩ> ?
;
ΩΩ? @
nrm
ææ 
/=
ææ 
(
ææ 
c
ææ 
/
ææ 
$num
ææ 
)
ææ 
;
ææ  
nrm
øø 
.
øø 
	Normalize
øø 
(
øø 
)
øø 
;
øø  
return
¿¿ 
nrm
¿¿ 
;
¿¿ 
}
¡¡ 
Vector3
¬¬ 
cross
¬¬ 
=
¬¬ 
Vector3
¬¬ #
.
¬¬# $
Cross
¬¬$ )
(
¬¬) *
p
¬¬* +
[
¬¬+ ,
$num
¬¬, -
]
¬¬- .
-
¬¬/ 0
p
¬¬1 2
[
¬¬2 3
$num
¬¬3 4
]
¬¬4 5
,
¬¬5 6
p
¬¬7 8
[
¬¬8 9
$num
¬¬9 :
]
¬¬: ;
-
¬¬< =
p
¬¬> ?
[
¬¬? @
$num
¬¬@ A
]
¬¬A B
)
¬¬B C
;
¬¬C D
if
ƒƒ 
(
ƒƒ 
cross
ƒƒ 
.
ƒƒ 
	magnitude
ƒƒ 
<
ƒƒ  !
Mathf
ƒƒ" '
.
ƒƒ' (
Epsilon
ƒƒ( /
)
ƒƒ/ 0
return
≈≈ 
new
≈≈ 
Vector3
≈≈ "
(
≈≈" #
$num
≈≈# %
,
≈≈% &
$num
≈≈' )
,
≈≈) *
$num
≈≈+ -
)
≈≈- .
;
≈≈. /
return
«« 
cross
«« 
.
«« 

normalized
«« #
;
««# $
}
»» 	
public
–– 
static
–– 
Normal
–– $
NormalTangentBitangent
–– 3
(
––3 4
ProBuilderMesh
––4 B
mesh
––C G
,
––G H
Face
––I M
face
––N R
)
––R S
{
—— 	
if
““ 
(
““ 
mesh
““ 
==
““ 
null
““ 
||
““ 
face
““  $
==
““% '
null
““( ,
||
““- /
face
““0 4
.
““4 5
indexesInternal
““5 D
.
““D E
Length
““E K
<
““L M
$num
““N O
)
““O P
throw
”” 
new
”” 
System
””  
.
””  !#
ArgumentNullException
””! 6
(
””6 7
$str
””7 =
,
””= >
$str””? ó
)””ó ò
;””ò ô
if
’’ 
(
’’ 
mesh
’’ 
.
’’ 
texturesInternal
’’ %
==
’’& (
null
’’) -
||
’’. 0
mesh
’’1 5
.
’’5 6
texturesInternal
’’6 F
.
’’F G
Length
’’G M
!=
’’N P
mesh
’’Q U
.
’’U V
vertexCount
’’V a
)
’’a b
throw
÷÷ 
new
÷÷ 
ArgumentException
÷÷ +
(
÷÷+ ,
$str
÷÷, q
)
÷÷q r
;
÷÷r s
var
ÿÿ 
nrm
ÿÿ 
=
ÿÿ 
Math
ÿÿ 
.
ÿÿ 
Normal
ÿÿ !
(
ÿÿ! "
mesh
ÿÿ" &
,
ÿÿ& '
face
ÿÿ( ,
)
ÿÿ, -
;
ÿÿ- .
Vector3
⁄⁄ 
tan1
⁄⁄ 
=
⁄⁄ 
Vector3
⁄⁄ "
.
⁄⁄" #
zero
⁄⁄# '
;
⁄⁄' (
Vector3
€€ 
tan2
€€ 
=
€€ 
Vector3
€€ "
.
€€" #
zero
€€# '
;
€€' (
Vector4
‹‹ 
tan
‹‹ 
=
‹‹ 
new
‹‹ 
Vector4
‹‹ %
(
‹‹% &
$num
‹‹& (
,
‹‹( )
$num
‹‹* ,
,
‹‹, -
$num
‹‹. 0
,
‹‹0 1
$num
‹‹2 4
)
‹‹4 5
;
‹‹5 6
long
ﬁﬁ 
i1
ﬁﬁ 
=
ﬁﬁ 
face
ﬁﬁ 
.
ﬁﬁ 
indexesInternal
ﬁﬁ *
[
ﬁﬁ* +
$num
ﬁﬁ+ ,
]
ﬁﬁ, -
;
ﬁﬁ- .
long
ﬂﬂ 
i2
ﬂﬂ 
=
ﬂﬂ 
face
ﬂﬂ 
.
ﬂﬂ 
indexesInternal
ﬂﬂ *
[
ﬂﬂ* +
$num
ﬂﬂ+ ,
]
ﬂﬂ, -
;
ﬂﬂ- .
long
‡‡ 
i3
‡‡ 
=
‡‡ 
face
‡‡ 
.
‡‡ 
indexesInternal
‡‡ *
[
‡‡* +
$num
‡‡+ ,
]
‡‡, -
;
‡‡- .
Vector3
‚‚ 
v1
‚‚ 
=
‚‚ 
mesh
‚‚ 
.
‚‚ 
positionsInternal
‚‚ /
[
‚‚/ 0
i1
‚‚0 2
]
‚‚2 3
;
‚‚3 4
Vector3
„„ 
v2
„„ 
=
„„ 
mesh
„„ 
.
„„ 
positionsInternal
„„ /
[
„„/ 0
i2
„„0 2
]
„„2 3
;
„„3 4
Vector3
‰‰ 
v3
‰‰ 
=
‰‰ 
mesh
‰‰ 
.
‰‰ 
positionsInternal
‰‰ /
[
‰‰/ 0
i3
‰‰0 2
]
‰‰2 3
;
‰‰3 4
Vector2
ÊÊ 
w1
ÊÊ 
=
ÊÊ 
mesh
ÊÊ 
.
ÊÊ 
texturesInternal
ÊÊ .
[
ÊÊ. /
i1
ÊÊ/ 1
]
ÊÊ1 2
;
ÊÊ2 3
Vector2
ÁÁ 
w2
ÁÁ 
=
ÁÁ 
mesh
ÁÁ 
.
ÁÁ 
texturesInternal
ÁÁ .
[
ÁÁ. /
i2
ÁÁ/ 1
]
ÁÁ1 2
;
ÁÁ2 3
Vector2
ËË 
w3
ËË 
=
ËË 
mesh
ËË 
.
ËË 
texturesInternal
ËË .
[
ËË. /
i3
ËË/ 1
]
ËË1 2
;
ËË2 3
float
ÍÍ 
x1
ÍÍ 
=
ÍÍ 
v2
ÍÍ 
.
ÍÍ 
x
ÍÍ 
-
ÍÍ 
v1
ÍÍ  
.
ÍÍ  !
x
ÍÍ! "
;
ÍÍ" #
float
ÎÎ 
x2
ÎÎ 
=
ÎÎ 
v3
ÎÎ 
.
ÎÎ 
x
ÎÎ 
-
ÎÎ 
v1
ÎÎ  
.
ÎÎ  !
x
ÎÎ! "
;
ÎÎ" #
float
ÏÏ 
y1
ÏÏ 
=
ÏÏ 
v2
ÏÏ 
.
ÏÏ 
y
ÏÏ 
-
ÏÏ 
v1
ÏÏ  
.
ÏÏ  !
y
ÏÏ! "
;
ÏÏ" #
float
ÌÌ 
y2
ÌÌ 
=
ÌÌ 
v3
ÌÌ 
.
ÌÌ 
y
ÌÌ 
-
ÌÌ 
v1
ÌÌ  
.
ÌÌ  !
y
ÌÌ! "
;
ÌÌ" #
float
ÓÓ 
z1
ÓÓ 
=
ÓÓ 
v2
ÓÓ 
.
ÓÓ 
z
ÓÓ 
-
ÓÓ 
v1
ÓÓ  
.
ÓÓ  !
z
ÓÓ! "
;
ÓÓ" #
float
ÔÔ 
z2
ÔÔ 
=
ÔÔ 
v3
ÔÔ 
.
ÔÔ 
z
ÔÔ 
-
ÔÔ 
v1
ÔÔ  
.
ÔÔ  !
z
ÔÔ! "
;
ÔÔ" #
float
ÒÒ 
s1
ÒÒ 
=
ÒÒ 
w2
ÒÒ 
.
ÒÒ 
x
ÒÒ 
-
ÒÒ 
w1
ÒÒ  
.
ÒÒ  !
x
ÒÒ! "
;
ÒÒ" #
float
ÚÚ 
s2
ÚÚ 
=
ÚÚ 
w3
ÚÚ 
.
ÚÚ 
x
ÚÚ 
-
ÚÚ 
w1
ÚÚ  
.
ÚÚ  !
x
ÚÚ! "
;
ÚÚ" #
float
ÛÛ 
t1
ÛÛ 
=
ÛÛ 
w2
ÛÛ 
.
ÛÛ 
y
ÛÛ 
-
ÛÛ 
w1
ÛÛ  
.
ÛÛ  !
y
ÛÛ! "
;
ÛÛ" #
float
ÙÙ 
t2
ÙÙ 
=
ÙÙ 
w3
ÙÙ 
.
ÙÙ 
y
ÙÙ 
-
ÙÙ 
w1
ÙÙ  
.
ÙÙ  !
y
ÙÙ! "
;
ÙÙ" #
float
ˆˆ 
r
ˆˆ 
=
ˆˆ 
$num
ˆˆ 
/
ˆˆ 
(
ˆˆ 
s1
ˆˆ  
*
ˆˆ! "
t2
ˆˆ# %
-
ˆˆ& '
s2
ˆˆ( *
*
ˆˆ+ ,
t1
ˆˆ- /
)
ˆˆ/ 0
;
ˆˆ0 1
Vector3
¯¯ 
sdir
¯¯ 
=
¯¯ 
new
¯¯ 
Vector3
¯¯ &
(
¯¯& '
(
¯¯' (
t2
¯¯( *
*
¯¯+ ,
x1
¯¯- /
-
¯¯0 1
t1
¯¯2 4
*
¯¯5 6
x2
¯¯7 9
)
¯¯9 :
*
¯¯; <
r
¯¯= >
,
¯¯> ?
(
¯¯@ A
t2
¯¯A C
*
¯¯D E
y1
¯¯F H
-
¯¯I J
t1
¯¯K M
*
¯¯N O
y2
¯¯P R
)
¯¯R S
*
¯¯T U
r
¯¯V W
,
¯¯W X
(
¯¯Y Z
t2
¯¯Z \
*
¯¯] ^
z1
¯¯_ a
-
¯¯b c
t1
¯¯d f
*
¯¯g h
z2
¯¯i k
)
¯¯k l
*
¯¯m n
r
¯¯o p
)
¯¯p q
;
¯¯q r
Vector3
˘˘ 
tdir
˘˘ 
=
˘˘ 
new
˘˘ 
Vector3
˘˘ &
(
˘˘& '
(
˘˘' (
s1
˘˘( *
*
˘˘+ ,
x2
˘˘- /
-
˘˘0 1
s2
˘˘2 4
*
˘˘5 6
x1
˘˘7 9
)
˘˘9 :
*
˘˘; <
r
˘˘= >
,
˘˘> ?
(
˘˘@ A
s1
˘˘A C
*
˘˘D E
y2
˘˘F H
-
˘˘I J
s2
˘˘K M
*
˘˘N O
y1
˘˘P R
)
˘˘R S
*
˘˘T U
r
˘˘V W
,
˘˘W X
(
˘˘Y Z
s1
˘˘Z \
*
˘˘] ^
z2
˘˘_ a
-
˘˘b c
s2
˘˘d f
*
˘˘g h
z1
˘˘i k
)
˘˘k l
*
˘˘m n
r
˘˘o p
)
˘˘p q
;
˘˘q r
tan1
˚˚ 
+=
˚˚ 
sdir
˚˚ 
;
˚˚ 
tan2
¸¸ 
+=
¸¸ 
tdir
¸¸ 
;
¸¸ 
Vector3
˛˛ 
n
˛˛ 
=
˛˛ 
nrm
˛˛ 
;
˛˛ 
Vector3
ˇˇ 
.
ˇˇ 
OrthoNormalize
ˇˇ "
(
ˇˇ" #
ref
ˇˇ# &
n
ˇˇ' (
,
ˇˇ( )
ref
ˇˇ* -
tan1
ˇˇ. 2
)
ˇˇ2 3
;
ˇˇ3 4
tan
ÅÅ 
.
ÅÅ 
x
ÅÅ 
=
ÅÅ 
tan1
ÅÅ 
.
ÅÅ 
x
ÅÅ 
;
ÅÅ 
tan
ÇÇ 
.
ÇÇ 
y
ÇÇ 
=
ÇÇ 
tan1
ÇÇ 
.
ÇÇ 
y
ÇÇ 
;
ÇÇ 
tan
ÉÉ 
.
ÉÉ 
z
ÉÉ 
=
ÉÉ 
tan1
ÉÉ 
.
ÉÉ 
z
ÉÉ 
;
ÉÉ 
tan
ÖÖ 
.
ÖÖ 
w
ÖÖ 
=
ÖÖ 
(
ÖÖ 
Vector3
ÖÖ 
.
ÖÖ 
Dot
ÖÖ  
(
ÖÖ  !
Vector3
ÖÖ! (
.
ÖÖ( )
Cross
ÖÖ) .
(
ÖÖ. /
n
ÖÖ/ 0
,
ÖÖ0 1
tan1
ÖÖ2 6
)
ÖÖ6 7
,
ÖÖ7 8
tan2
ÖÖ9 =
)
ÖÖ= >
<
ÖÖ? @
$num
ÖÖA E
)
ÖÖE F
?
ÖÖG H
-
ÖÖI J
$num
ÖÖJ N
:
ÖÖO P
$num
ÖÖQ U
;
ÖÖU V
return
áá 
new
áá 
Normal
áá 
(
áá 
)
áá 
{
àà 
normal
ââ 
=
ââ 
nrm
ââ 
,
ââ 
tangent
ää 
=
ää 
tan
ää 
,
ää 
	bitangent
ãã 
=
ãã 
Vector3
ãã #
.
ãã# $
Cross
ãã$ )
(
ãã) *
nrm
ãã* -
,
ãã- .
(
ãã/ 0
(
ãã0 1
Vector3
ãã1 8
)
ãã8 9
tan
ãã9 <
)
ãã< =
*
ãã> ?
tan
ãã@ C
.
ããC D
w
ããD E
)
ããE F
}
åå 
;
åå 
}
çç 	
internal
ïï 
static
ïï 
bool
ïï 
IsCardinalAxis
ïï +
(
ïï+ ,
Vector3
ïï, 3
v
ïï4 5
,
ïï5 6
float
ïï7 <
epsilon
ïï= D
=
ïïE F
k_FltEpsilon
ïïG S
)
ïïS T
{
ññ 	
if
óó 
(
óó 
v
óó 
==
óó 
Vector3
óó 
.
óó 
zero
óó !
)
óó! "
return
òò 
false
òò 
;
òò 
v
öö 
.
öö 
	Normalize
öö 
(
öö 
)
öö 
;
öö 
return
úú 
(
úú 
$num
úú 
-
úú 
Mathf
úú 
.
úú 
Abs
úú "
(
úú" #
Vector3
úú# *
.
úú* +
Dot
úú+ .
(
úú. /
Vector3
úú/ 6
.
úú6 7
up
úú7 9
,
úú9 :
v
úú; <
)
úú< =
)
úú= >
)
úú> ?
<
úú@ A
epsilon
úúB I
||
úúJ L
(
ùù 
$num
ùù 
-
ùù 
Mathf
ùù 
.
ùù 
Abs
ùù 
(
ùù  
Vector3
ùù  '
.
ùù' (
Dot
ùù( +
(
ùù+ ,
Vector3
ùù, 3
.
ùù3 4
forward
ùù4 ;
,
ùù; <
v
ùù= >
)
ùù> ?
)
ùù? @
)
ùù@ A
<
ùùB C
epsilon
ùùD K
||
ùùL N
(
ûû 
$num
ûû 
-
ûû 
Mathf
ûû 
.
ûû 
Abs
ûû 
(
ûû  
Vector3
ûû  '
.
ûû' (
Dot
ûû( +
(
ûû+ ,
Vector3
ûû, 3
.
ûû3 4
right
ûû4 9
,
ûû9 :
v
ûû; <
)
ûû< =
)
ûû= >
)
ûû> ?
<
ûû@ A
epsilon
ûûB I
;
ûûI J
}
üü 	
internal
ßß 
static
ßß 
Vector2
ßß 
DivideBy
ßß  (
(
ßß( )
this
ßß) -
Vector2
ßß. 5
v
ßß6 7
,
ßß7 8
Vector2
ßß9 @
o
ßßA B
)
ßßB C
{
®® 	
return
©© 
new
©© 
Vector2
©© 
(
©© 
v
©©  
.
©©  !
x
©©! "
/
©©# $
o
©©% &
.
©©& '
x
©©' (
,
©©( )
v
©©* +
.
©©+ ,
y
©©, -
/
©©. /
o
©©0 1
.
©©1 2
y
©©2 3
)
©©3 4
;
©©4 5
}
™™ 	
internal
≤≤ 
static
≤≤ 
Vector3
≤≤ 
DivideBy
≤≤  (
(
≤≤( )
this
≤≤) -
Vector3
≤≤. 5
v
≤≤6 7
,
≤≤7 8
Vector3
≤≤9 @
o
≤≤A B
)
≤≤B C
{
≥≥ 	
return
¥¥ 
new
¥¥ 
Vector3
¥¥ 
(
¥¥ 
v
¥¥  
.
¥¥  !
x
¥¥! "
/
¥¥# $
o
¥¥% &
.
¥¥& '
x
¥¥' (
,
¥¥( )
v
¥¥* +
.
¥¥+ ,
y
¥¥, -
/
¥¥. /
o
¥¥0 1
.
¥¥1 2
y
¥¥2 3
,
¥¥3 4
v
¥¥5 6
.
¥¥6 7
z
¥¥7 8
/
¥¥9 :
o
¥¥; <
.
¥¥< =
z
¥¥= >
)
¥¥> ?
;
¥¥? @
}
µµ 	
internal
ΩΩ 
static
ΩΩ 
T
ΩΩ 
Max
ΩΩ 
<
ΩΩ 
T
ΩΩ 
>
ΩΩ  
(
ΩΩ  !
T
ΩΩ! "
[
ΩΩ" #
]
ΩΩ# $
array
ΩΩ% *
)
ΩΩ* +
where
ΩΩ, 1
T
ΩΩ2 3
:
ΩΩ4 5
System
ΩΩ6 <
.
ΩΩ< =
IComparable
ΩΩ= H
<
ΩΩH I
T
ΩΩI J
>
ΩΩJ K
{
ææ 	
if
øø 
(
øø 
array
øø 
==
øø 
null
øø 
||
øø  
array
øø! &
.
øø& '
Length
øø' -
<
øø. /
$num
øø0 1
)
øø1 2
return
¿¿ 
default
¿¿ 
(
¿¿ 
T
¿¿  
)
¿¿  !
;
¿¿! "
T
¬¬ 
max
¬¬ 
=
¬¬ 
array
¬¬ 
[
¬¬ 
$num
¬¬ 
]
¬¬ 
;
¬¬ 
for
√√ 
(
√√ 
int
√√ 
i
√√ 
=
√√ 
$num
√√ 
;
√√ 
i
√√ 
<
√√ 
array
√√  %
.
√√% &
Length
√√& ,
;
√√, -
i
√√. /
++
√√/ 1
)
√√1 2
if
ƒƒ 
(
ƒƒ 
array
ƒƒ 
[
ƒƒ 
i
ƒƒ 
]
ƒƒ 
.
ƒƒ 
	CompareTo
ƒƒ &
(
ƒƒ& '
max
ƒƒ' *
)
ƒƒ* +
>=
ƒƒ, .
$num
ƒƒ/ 0
)
ƒƒ0 1
max
≈≈ 
=
≈≈ 
array
≈≈ 
[
≈≈  
i
≈≈  !
]
≈≈! "
;
≈≈" #
return
∆∆ 
max
∆∆ 
;
∆∆ 
}
«« 	
internal
œœ 
static
œœ 
T
œœ 
Min
œœ 
<
œœ 
T
œœ 
>
œœ  
(
œœ  !
T
œœ! "
[
œœ" #
]
œœ# $
array
œœ% *
)
œœ* +
where
œœ, 1
T
œœ2 3
:
œœ4 5
System
œœ6 <
.
œœ< =
IComparable
œœ= H
<
œœH I
T
œœI J
>
œœJ K
{
–– 	
if
—— 
(
—— 
array
—— 
==
—— 
null
—— 
||
——  
array
——! &
.
——& '
Length
——' -
<
——. /
$num
——0 1
)
——1 2
return
““ 
default
““ 
(
““ 
T
““  
)
““  !
;
““! "
T
‘‘ 
min
‘‘ 
=
‘‘ 
array
‘‘ 
[
‘‘ 
$num
‘‘ 
]
‘‘ 
;
‘‘ 
for
’’ 
(
’’ 
int
’’ 
i
’’ 
=
’’ 
$num
’’ 
;
’’ 
i
’’ 
<
’’ 
array
’’  %
.
’’% &
Length
’’& ,
;
’’, -
i
’’. /
++
’’/ 1
)
’’1 2
if
÷÷ 
(
÷÷ 
array
÷÷ 
[
÷÷ 
i
÷÷ 
]
÷÷ 
.
÷÷ 
	CompareTo
÷÷ &
(
÷÷& '
min
÷÷' *
)
÷÷* +
<
÷÷, -
$num
÷÷. /
)
÷÷/ 0
min
◊◊ 
=
◊◊ 
array
◊◊ 
[
◊◊  
i
◊◊  !
]
◊◊! "
;
◊◊" #
return
ÿÿ 
min
ÿÿ 
;
ÿÿ 
}
ŸŸ 	
internal
‡‡ 
static
‡‡ 
float
‡‡ 
LargestValue
‡‡ *
(
‡‡* +
Vector3
‡‡+ 2
v
‡‡3 4
)
‡‡4 5
{
·· 	
if
‚‚ 
(
‚‚ 
v
‚‚ 
.
‚‚ 
x
‚‚ 
>
‚‚ 
v
‚‚ 
.
‚‚ 
y
‚‚ 
&&
‚‚ 
v
‚‚ 
.
‚‚ 
x
‚‚  
>
‚‚! "
v
‚‚# $
.
‚‚$ %
z
‚‚% &
)
‚‚& '
return
‚‚( .
v
‚‚/ 0
.
‚‚0 1
x
‚‚1 2
;
‚‚2 3
if
„„ 
(
„„ 
v
„„ 
.
„„ 
y
„„ 
>
„„ 
v
„„ 
.
„„ 
x
„„ 
&&
„„ 
v
„„ 
.
„„ 
y
„„  
>
„„! "
v
„„# $
.
„„$ %
z
„„% &
)
„„& '
return
„„( .
v
„„/ 0
.
„„0 1
y
„„1 2
;
„„2 3
return
‰‰ 
v
‰‰ 
.
‰‰ 
z
‰‰ 
;
‰‰ 
}
ÂÂ 	
internal
ÏÏ 
static
ÏÏ 
float
ÏÏ 
LargestValue
ÏÏ *
(
ÏÏ* +
Vector2
ÏÏ+ 2
v
ÏÏ3 4
)
ÏÏ4 5
{
ÌÌ 	
return
ÓÓ 
(
ÓÓ 
v
ÓÓ 
.
ÓÓ 
x
ÓÓ 
>
ÓÓ 
v
ÓÓ 
.
ÓÓ 
y
ÓÓ 
)
ÓÓ 
?
ÓÓ  
v
ÓÓ! "
.
ÓÓ" #
x
ÓÓ# $
:
ÓÓ% &
v
ÓÓ' (
.
ÓÓ( )
y
ÓÓ) *
;
ÓÓ* +
}
ÔÔ 	
internal
ˆˆ 
static
ˆˆ 
Vector2
ˆˆ 
SmallestVector2
ˆˆ  /
(
ˆˆ/ 0
Vector2
ˆˆ0 7
[
ˆˆ7 8
]
ˆˆ8 9
v
ˆˆ: ;
)
ˆˆ; <
{
˜˜ 	
int
¯¯ 
len
¯¯ 
=
¯¯ 
v
¯¯ 
.
¯¯ 
Length
¯¯ 
;
¯¯ 
Vector2
˘˘ 
l
˘˘ 
=
˘˘ 
v
˘˘ 
[
˘˘ 
$num
˘˘ 
]
˘˘ 
;
˘˘ 
for
˙˙ 
(
˙˙ 
int
˙˙ 
i
˙˙ 
=
˙˙ 
$num
˙˙ 
;
˙˙ 
i
˙˙ 
<
˙˙ 
len
˙˙  #
;
˙˙# $
i
˙˙% &
++
˙˙& (
)
˙˙( )
{
˚˚ 
if
¸¸ 
(
¸¸ 
v
¸¸ 
[
¸¸ 
i
¸¸ 
]
¸¸ 
.
¸¸ 
x
¸¸ 
<
¸¸ 
l
¸¸ 
.
¸¸ 
x
¸¸  
)
¸¸  !
l
¸¸" #
.
¸¸# $
x
¸¸$ %
=
¸¸& '
v
¸¸( )
[
¸¸) *
i
¸¸* +
]
¸¸+ ,
.
¸¸, -
x
¸¸- .
;
¸¸. /
if
˝˝ 
(
˝˝ 
v
˝˝ 
[
˝˝ 
i
˝˝ 
]
˝˝ 
.
˝˝ 
y
˝˝ 
<
˝˝ 
l
˝˝ 
.
˝˝ 
y
˝˝  
)
˝˝  !
l
˝˝" #
.
˝˝# $
y
˝˝$ %
=
˝˝& '
v
˝˝( )
[
˝˝) *
i
˝˝* +
]
˝˝+ ,
.
˝˝, -
y
˝˝- .
;
˝˝. /
}
˛˛ 
return
ˇˇ 
l
ˇˇ 
;
ˇˇ 
}
ÄÄ 	
internal
àà 
static
àà 
Vector2
àà 
SmallestVector2
àà  /
(
àà/ 0
Vector2
àà0 7
[
àà7 8
]
àà8 9
v
àà: ;
,
àà; <
int
àà= @
[
àà@ A
]
ààA B
indexes
ààC J
)
ààJ K
{
ââ 	
int
ää 
len
ää 
=
ää 
indexes
ää 
.
ää 
Length
ää $
;
ää$ %
Vector2
ãã 
l
ãã 
=
ãã 
v
ãã 
[
ãã 
indexes
ãã !
[
ãã! "
$num
ãã" #
]
ãã# $
]
ãã$ %
;
ãã% &
for
åå 
(
åå 
int
åå 
i
åå 
=
åå 
$num
åå 
;
åå 
i
åå 
<
åå 
len
åå  #
;
åå# $
i
åå% &
++
åå& (
)
åå( )
{
çç 
if
éé 
(
éé 
v
éé 
[
éé 
indexes
éé 
[
éé 
i
éé 
]
éé  
]
éé  !
.
éé! "
x
éé" #
<
éé$ %
l
éé& '
.
éé' (
x
éé( )
)
éé) *
l
éé+ ,
.
éé, -
x
éé- .
=
éé/ 0
v
éé1 2
[
éé2 3
indexes
éé3 :
[
éé: ;
i
éé; <
]
éé< =
]
éé= >
.
éé> ?
x
éé? @
;
éé@ A
if
èè 
(
èè 
v
èè 
[
èè 
indexes
èè 
[
èè 
i
èè 
]
èè  
]
èè  !
.
èè! "
y
èè" #
<
èè$ %
l
èè& '
.
èè' (
y
èè( )
)
èè) *
l
èè+ ,
.
èè, -
y
èè- .
=
èè/ 0
v
èè1 2
[
èè2 3
indexes
èè3 :
[
èè: ;
i
èè; <
]
èè< =
]
èè= >
.
èè> ?
y
èè? @
;
èè@ A
}
êê 
return
ëë 
l
ëë 
;
ëë 
}
íí 	
internal
îî 
static
îî 
Vector2
îî 
SmallestVector2
îî  /
(
îî/ 0
Vector2
îî0 7
[
îî7 8
]
îî8 9
v
îî: ;
,
îî; <
IList
îî= B
<
îîB C
int
îîC F
>
îîF G
indexes
îîH O
)
îîO P
{
ïï 	
int
ññ 
len
ññ 
=
ññ 
indexes
ññ 
.
ññ 
Count
ññ #
;
ññ# $
Vector2
óó 
l
óó 
=
óó 
v
óó 
[
óó 
indexes
óó !
[
óó! "
$num
óó" #
]
óó# $
]
óó$ %
;
óó% &
for
òò 
(
òò 
int
òò 
i
òò 
=
òò 
$num
òò 
;
òò 
i
òò 
<
òò 
len
òò  #
;
òò# $
i
òò% &
++
òò& (
)
òò( )
{
ôô 
if
öö 
(
öö 
v
öö 
[
öö 
indexes
öö 
[
öö 
i
öö 
]
öö  
]
öö  !
.
öö! "
x
öö" #
<
öö$ %
l
öö& '
.
öö' (
x
öö( )
)
öö) *
l
öö+ ,
.
öö, -
x
öö- .
=
öö/ 0
v
öö1 2
[
öö2 3
indexes
öö3 :
[
öö: ;
i
öö; <
]
öö< =
]
öö= >
.
öö> ?
x
öö? @
;
öö@ A
if
õõ 
(
õõ 
v
õõ 
[
õõ 
indexes
õõ 
[
õõ 
i
õõ 
]
õõ  
]
õõ  !
.
õõ! "
y
õõ" #
<
õõ$ %
l
õõ& '
.
õõ' (
y
õõ( )
)
õõ) *
l
õõ+ ,
.
õõ, -
y
õõ- .
=
õõ/ 0
v
õõ1 2
[
õõ2 3
indexes
õõ3 :
[
õõ: ;
i
õõ; <
]
õõ< =
]
õõ= >
.
õõ> ?
y
õõ? @
;
õõ@ A
}
úú 
return
ùù 
l
ùù 
;
ùù 
}
ûû 	
internal
•• 
static
•• 
Vector2
•• 
LargestVector2
••  .
(
••. /
Vector2
••/ 6
[
••6 7
]
••7 8
v
••9 :
)
••: ;
{
¶¶ 	
int
ßß 
len
ßß 
=
ßß 
v
ßß 
.
ßß 
Length
ßß 
;
ßß 
Vector2
®® 
l
®® 
=
®® 
v
®® 
[
®® 
$num
®® 
]
®® 
;
®® 
for
©© 
(
©© 
int
©© 
i
©© 
=
©© 
$num
©© 
;
©© 
i
©© 
<
©© 
len
©©  #
;
©©# $
i
©©% &
++
©©& (
)
©©( )
{
™™ 
if
´´ 
(
´´ 
v
´´ 
[
´´ 
i
´´ 
]
´´ 
.
´´ 
x
´´ 
>
´´ 
l
´´ 
.
´´ 
x
´´  
)
´´  !
l
´´" #
.
´´# $
x
´´$ %
=
´´& '
v
´´( )
[
´´) *
i
´´* +
]
´´+ ,
.
´´, -
x
´´- .
;
´´. /
if
¨¨ 
(
¨¨ 
v
¨¨ 
[
¨¨ 
i
¨¨ 
]
¨¨ 
.
¨¨ 
y
¨¨ 
>
¨¨ 
l
¨¨ 
.
¨¨ 
y
¨¨  
)
¨¨  !
l
¨¨" #
.
¨¨# $
y
¨¨$ %
=
¨¨& '
v
¨¨( )
[
¨¨) *
i
¨¨* +
]
¨¨+ ,
.
¨¨, -
y
¨¨- .
;
¨¨. /
}
≠≠ 
return
ÆÆ 
l
ÆÆ 
;
ÆÆ 
}
ØØ 	
internal
±± 
static
±± 
Vector2
±± 
LargestVector2
±±  .
(
±±. /
Vector2
±±/ 6
[
±±6 7
]
±±7 8
v
±±9 :
,
±±: ;
int
±±< ?
[
±±? @
]
±±@ A
indexes
±±B I
)
±±I J
{
≤≤ 	
int
≥≥ 
len
≥≥ 
=
≥≥ 
indexes
≥≥ 
.
≥≥ 
Length
≥≥ $
;
≥≥$ %
Vector2
¥¥ 
l
¥¥ 
=
¥¥ 
v
¥¥ 
[
¥¥ 
indexes
¥¥ !
[
¥¥! "
$num
¥¥" #
]
¥¥# $
]
¥¥$ %
;
¥¥% &
for
µµ 
(
µµ 
int
µµ 
i
µµ 
=
µµ 
$num
µµ 
;
µµ 
i
µµ 
<
µµ 
len
µµ  #
;
µµ# $
i
µµ% &
++
µµ& (
)
µµ( )
{
∂∂ 
if
∑∑ 
(
∑∑ 
v
∑∑ 
[
∑∑ 
indexes
∑∑ 
[
∑∑ 
i
∑∑ 
]
∑∑  
]
∑∑  !
.
∑∑! "
x
∑∑" #
>
∑∑$ %
l
∑∑& '
.
∑∑' (
x
∑∑( )
)
∑∑) *
l
∑∑+ ,
.
∑∑, -
x
∑∑- .
=
∑∑/ 0
v
∑∑1 2
[
∑∑2 3
indexes
∑∑3 :
[
∑∑: ;
i
∑∑; <
]
∑∑< =
]
∑∑= >
.
∑∑> ?
x
∑∑? @
;
∑∑@ A
if
∏∏ 
(
∏∏ 
v
∏∏ 
[
∏∏ 
indexes
∏∏ 
[
∏∏ 
i
∏∏ 
]
∏∏  
]
∏∏  !
.
∏∏! "
y
∏∏" #
>
∏∏$ %
l
∏∏& '
.
∏∏' (
y
∏∏( )
)
∏∏) *
l
∏∏+ ,
.
∏∏, -
y
∏∏- .
=
∏∏/ 0
v
∏∏1 2
[
∏∏2 3
indexes
∏∏3 :
[
∏∏: ;
i
∏∏; <
]
∏∏< =
]
∏∏= >
.
∏∏> ?
y
∏∏? @
;
∏∏@ A
}
ππ 
return
∫∫ 
l
∫∫ 
;
∫∫ 
}
ªª 	
internal
ΩΩ 
static
ΩΩ 
Vector2
ΩΩ 
LargestVector2
ΩΩ  .
(
ΩΩ. /
Vector2
ΩΩ/ 6
[
ΩΩ6 7
]
ΩΩ7 8
v
ΩΩ9 :
,
ΩΩ: ;
IList
ΩΩ< A
<
ΩΩA B
int
ΩΩB E
>
ΩΩE F
indexes
ΩΩG N
)
ΩΩN O
{
ææ 	
int
øø 
len
øø 
=
øø 
indexes
øø 
.
øø 
Count
øø #
;
øø# $
Vector2
¿¿ 
l
¿¿ 
=
¿¿ 
v
¿¿ 
[
¿¿ 
indexes
¿¿ !
[
¿¿! "
$num
¿¿" #
]
¿¿# $
]
¿¿$ %
;
¿¿% &
for
¡¡ 
(
¡¡ 
int
¡¡ 
i
¡¡ 
=
¡¡ 
$num
¡¡ 
;
¡¡ 
i
¡¡ 
<
¡¡ 
len
¡¡  #
;
¡¡# $
i
¡¡% &
++
¡¡& (
)
¡¡( )
{
¬¬ 
if
√√ 
(
√√ 
v
√√ 
[
√√ 
indexes
√√ 
[
√√ 
i
√√ 
]
√√  
]
√√  !
.
√√! "
x
√√" #
>
√√$ %
l
√√& '
.
√√' (
x
√√( )
)
√√) *
l
√√+ ,
.
√√, -
x
√√- .
=
√√/ 0
v
√√1 2
[
√√2 3
indexes
√√3 :
[
√√: ;
i
√√; <
]
√√< =
]
√√= >
.
√√> ?
x
√√? @
;
√√@ A
if
ƒƒ 
(
ƒƒ 
v
ƒƒ 
[
ƒƒ 
indexes
ƒƒ 
[
ƒƒ 
i
ƒƒ 
]
ƒƒ  
]
ƒƒ  !
.
ƒƒ! "
y
ƒƒ" #
>
ƒƒ$ %
l
ƒƒ& '
.
ƒƒ' (
y
ƒƒ( )
)
ƒƒ) *
l
ƒƒ+ ,
.
ƒƒ, -
y
ƒƒ- .
=
ƒƒ/ 0
v
ƒƒ1 2
[
ƒƒ2 3
indexes
ƒƒ3 :
[
ƒƒ: ;
i
ƒƒ; <
]
ƒƒ< =
]
ƒƒ= >
.
ƒƒ> ?
y
ƒƒ? @
;
ƒƒ@ A
}
≈≈ 
return
∆∆ 
l
∆∆ 
;
∆∆ 
}
«« 	
internal
ŒŒ 
static
ŒŒ 
Bounds
ŒŒ 
	GetBounds
ŒŒ (
(
ŒŒ( )
Vector3
ŒŒ) 0
[
ŒŒ0 1
]
ŒŒ1 2
	positions
ŒŒ3 <
,
ŒŒ< =
IList
ŒŒ> C
<
ŒŒC D
int
ŒŒD G
>
ŒŒG H
indices
ŒŒI P
=
ŒŒQ R
null
ŒŒS W
)
ŒŒW X
{
œœ 	
bool
–– 

hasIndices
–– 
=
–– 
indices
–– %
!=
––& (
null
––) -
;
––- .
if
““ 
(
““ 
(
““ 

hasIndices
““ 
&&
““ 
indices
““ &
.
““& '
Count
““' ,
<
““- .
$num
““/ 0
)
““0 1
||
““2 4
	positions
““5 >
.
““> ?
Length
““? E
<
““F G
$num
““H I
)
““I J
return
”” 
default
”” 
(
”” 
Bounds
”” %
)
””% &
;
””& '
Vector3
’’ 
min
’’ 
=
’’ 
	positions
’’ #
[
’’# $

hasIndices
’’$ .
?
’’/ 0
indices
’’1 8
[
’’8 9
$num
’’9 :
]
’’: ;
:
’’< =
$num
’’> ?
]
’’? @
;
’’@ A
Vector3
÷÷ 
max
÷÷ 
=
÷÷ 
min
÷÷ 
;
÷÷ 
if
ÿÿ 
(
ÿÿ 

hasIndices
ÿÿ 
)
ÿÿ 
{
ŸŸ 
for
⁄⁄ 
(
⁄⁄ 
int
⁄⁄ 
i
⁄⁄ 
=
⁄⁄ 
$num
⁄⁄ 
,
⁄⁄ 
c
⁄⁄  !
=
⁄⁄" #
indices
⁄⁄$ +
.
⁄⁄+ ,
Count
⁄⁄, 1
;
⁄⁄1 2
i
⁄⁄3 4
<
⁄⁄5 6
c
⁄⁄7 8
;
⁄⁄8 9
i
⁄⁄: ;
++
⁄⁄; =
)
⁄⁄= >
{
€€ 
min
‹‹ 
.
‹‹ 
x
‹‹ 
=
‹‹ 
Mathf
‹‹ !
.
‹‹! "
Min
‹‹" %
(
‹‹% &
	positions
‹‹& /
[
‹‹/ 0
indices
‹‹0 7
[
‹‹7 8
i
‹‹8 9
]
‹‹9 :
]
‹‹: ;
.
‹‹; <
x
‹‹< =
,
‹‹= >
min
‹‹? B
.
‹‹B C
x
‹‹C D
)
‹‹D E
;
‹‹E F
max
›› 
.
›› 
x
›› 
=
›› 
Mathf
›› !
.
››! "
Max
››" %
(
››% &
	positions
››& /
[
››/ 0
indices
››0 7
[
››7 8
i
››8 9
]
››9 :
]
››: ;
.
››; <
x
››< =
,
››= >
max
››? B
.
››B C
x
››C D
)
››D E
;
››E F
min
ﬂﬂ 
.
ﬂﬂ 
y
ﬂﬂ 
=
ﬂﬂ 
Mathf
ﬂﬂ !
.
ﬂﬂ! "
Min
ﬂﬂ" %
(
ﬂﬂ% &
	positions
ﬂﬂ& /
[
ﬂﬂ/ 0
indices
ﬂﬂ0 7
[
ﬂﬂ7 8
i
ﬂﬂ8 9
]
ﬂﬂ9 :
]
ﬂﬂ: ;
.
ﬂﬂ; <
y
ﬂﬂ< =
,
ﬂﬂ= >
min
ﬂﬂ? B
.
ﬂﬂB C
y
ﬂﬂC D
)
ﬂﬂD E
;
ﬂﬂE F
max
‡‡ 
.
‡‡ 
y
‡‡ 
=
‡‡ 
Mathf
‡‡ !
.
‡‡! "
Max
‡‡" %
(
‡‡% &
	positions
‡‡& /
[
‡‡/ 0
indices
‡‡0 7
[
‡‡7 8
i
‡‡8 9
]
‡‡9 :
]
‡‡: ;
.
‡‡; <
y
‡‡< =
,
‡‡= >
max
‡‡? B
.
‡‡B C
y
‡‡C D
)
‡‡D E
;
‡‡E F
min
‚‚ 
.
‚‚ 
z
‚‚ 
=
‚‚ 
Mathf
‚‚ !
.
‚‚! "
Min
‚‚" %
(
‚‚% &
	positions
‚‚& /
[
‚‚/ 0
indices
‚‚0 7
[
‚‚7 8
i
‚‚8 9
]
‚‚9 :
]
‚‚: ;
.
‚‚; <
z
‚‚< =
,
‚‚= >
min
‚‚? B
.
‚‚B C
z
‚‚C D
)
‚‚D E
;
‚‚E F
max
„„ 
.
„„ 
z
„„ 
=
„„ 
Mathf
„„ !
.
„„! "
Max
„„" %
(
„„% &
	positions
„„& /
[
„„/ 0
indices
„„0 7
[
„„7 8
i
„„8 9
]
„„9 :
]
„„: ;
.
„„; <
z
„„< =
,
„„= >
max
„„? B
.
„„B C
z
„„C D
)
„„D E
;
„„E F
}
‰‰ 
}
ÂÂ 
else
ÊÊ 
{
ÁÁ 
for
ËË 
(
ËË 
int
ËË 
i
ËË 
=
ËË 
$num
ËË 
,
ËË 
c
ËË  !
=
ËË" #
	positions
ËË$ -
.
ËË- .
Length
ËË. 4
;
ËË4 5
i
ËË6 7
<
ËË8 9
c
ËË: ;
;
ËË; <
i
ËË= >
++
ËË> @
)
ËË@ A
{
ÈÈ 
min
ÍÍ 
.
ÍÍ 
x
ÍÍ 
=
ÍÍ 
Mathf
ÍÍ !
.
ÍÍ! "
Min
ÍÍ" %
(
ÍÍ% &
	positions
ÍÍ& /
[
ÍÍ/ 0
i
ÍÍ0 1
]
ÍÍ1 2
.
ÍÍ2 3
x
ÍÍ3 4
,
ÍÍ4 5
min
ÍÍ6 9
.
ÍÍ9 :
x
ÍÍ: ;
)
ÍÍ; <
;
ÍÍ< =
max
ÎÎ 
.
ÎÎ 
x
ÎÎ 
=
ÎÎ 
Mathf
ÎÎ !
.
ÎÎ! "
Max
ÎÎ" %
(
ÎÎ% &
	positions
ÎÎ& /
[
ÎÎ/ 0
i
ÎÎ0 1
]
ÎÎ1 2
.
ÎÎ2 3
x
ÎÎ3 4
,
ÎÎ4 5
max
ÎÎ6 9
.
ÎÎ9 :
x
ÎÎ: ;
)
ÎÎ; <
;
ÎÎ< =
min
ÌÌ 
.
ÌÌ 
y
ÌÌ 
=
ÌÌ 
Mathf
ÌÌ !
.
ÌÌ! "
Min
ÌÌ" %
(
ÌÌ% &
	positions
ÌÌ& /
[
ÌÌ/ 0
i
ÌÌ0 1
]
ÌÌ1 2
.
ÌÌ2 3
y
ÌÌ3 4
,
ÌÌ4 5
min
ÌÌ6 9
.
ÌÌ9 :
y
ÌÌ: ;
)
ÌÌ; <
;
ÌÌ< =
max
ÓÓ 
.
ÓÓ 
y
ÓÓ 
=
ÓÓ 
Mathf
ÓÓ !
.
ÓÓ! "
Max
ÓÓ" %
(
ÓÓ% &
	positions
ÓÓ& /
[
ÓÓ/ 0
i
ÓÓ0 1
]
ÓÓ1 2
.
ÓÓ2 3
y
ÓÓ3 4
,
ÓÓ4 5
max
ÓÓ6 9
.
ÓÓ9 :
y
ÓÓ: ;
)
ÓÓ; <
;
ÓÓ< =
min
 
.
 
z
 
=
 
Mathf
 !
.
! "
Min
" %
(
% &
	positions
& /
[
/ 0
i
0 1
]
1 2
.
2 3
z
3 4
,
4 5
min
6 9
.
9 :
z
: ;
)
; <
;
< =
max
ÒÒ 
.
ÒÒ 
z
ÒÒ 
=
ÒÒ 
Mathf
ÒÒ !
.
ÒÒ! "
Max
ÒÒ" %
(
ÒÒ% &
	positions
ÒÒ& /
[
ÒÒ/ 0
i
ÒÒ0 1
]
ÒÒ1 2
.
ÒÒ2 3
z
ÒÒ3 4
,
ÒÒ4 5
max
ÒÒ6 9
.
ÒÒ9 :
z
ÒÒ: ;
)
ÒÒ; <
;
ÒÒ< =
}
ÚÚ 
}
ÛÛ 
return
ıı 
new
ıı 
Bounds
ıı 
(
ıı 
(
ıı 
min
ıı "
+
ıı# $
max
ıı% (
)
ıı( )
*
ıı* +
$num
ıı, /
,
ıı/ 0
max
ıı1 4
-
ıı5 6
min
ıı7 :
)
ıı: ;
;
ıı; <
}
ˆˆ 	
internal
˝˝ 
static
˝˝ 
Bounds
˝˝ 
	GetBounds
˝˝ (
(
˝˝( )
Vector3
˝˝) 0
[
˝˝0 1
]
˝˝1 2
	positions
˝˝3 <
,
˝˝< =
IEnumerable
˝˝> I
<
˝˝I J
Face
˝˝J N
>
˝˝N O
faces
˝˝P U
)
˝˝U V
{
˛˛ 	
bool
ˇˇ 
initialized
ˇˇ 
=
ˇˇ 
false
ˇˇ $
;
ˇˇ$ %
Vector3
ÅÅ 
min
ÅÅ 
=
ÅÅ 
Vector3
ÅÅ !
.
ÅÅ! "
zero
ÅÅ" &
;
ÅÅ& '
Vector3
ÇÇ 
max
ÇÇ 
=
ÇÇ 
min
ÇÇ 
;
ÇÇ 
foreach
ÑÑ 
(
ÑÑ 
var
ÑÑ 
face
ÑÑ 
in
ÑÑ  
faces
ÑÑ! &
)
ÑÑ& '
{
ÖÖ 
var
ÜÜ 
indices
ÜÜ 
=
ÜÜ 
face
ÜÜ "
.
ÜÜ" #%
distinctIndexesInternal
ÜÜ# :
;
ÜÜ: ;
if
àà 
(
àà 
!
àà 
initialized
àà  
)
àà  !
{
ââ 
initialized
ää 
=
ää  !
true
ää" &
;
ää& '
min
ãã 
=
ãã 
	positions
ãã #
[
ãã# $
indices
ãã$ +
[
ãã+ ,
$num
ãã, -
]
ãã- .
]
ãã. /
;
ãã/ 0
max
åå 
=
åå 
	positions
åå #
[
åå# $
indices
åå$ +
[
åå+ ,
$num
åå, -
]
åå- .
]
åå. /
;
åå/ 0
}
çç 
for
èè 
(
èè 
int
èè 
i
èè 
=
èè 
$num
èè 
,
èè 
c
èè  !
=
èè" #
indices
èè$ +
.
èè+ ,
Length
èè, 2
;
èè2 3
i
èè4 5
<
èè6 7
c
èè8 9
;
èè9 :
i
èè; <
++
èè< >
)
èè> ?
{
êê 
min
ëë 
.
ëë 
x
ëë 
=
ëë 
Mathf
ëë !
.
ëë! "
Min
ëë" %
(
ëë% &
	positions
ëë& /
[
ëë/ 0
indices
ëë0 7
[
ëë7 8
i
ëë8 9
]
ëë9 :
]
ëë: ;
.
ëë; <
x
ëë< =
,
ëë= >
min
ëë? B
.
ëëB C
x
ëëC D
)
ëëD E
;
ëëE F
max
íí 
.
íí 
x
íí 
=
íí 
Mathf
íí !
.
íí! "
Max
íí" %
(
íí% &
	positions
íí& /
[
íí/ 0
indices
íí0 7
[
íí7 8
i
íí8 9
]
íí9 :
]
íí: ;
.
íí; <
x
íí< =
,
íí= >
max
íí? B
.
ííB C
x
ííC D
)
ííD E
;
ííE F
min
îî 
.
îî 
y
îî 
=
îî 
Mathf
îî !
.
îî! "
Min
îî" %
(
îî% &
	positions
îî& /
[
îî/ 0
indices
îî0 7
[
îî7 8
i
îî8 9
]
îî9 :
]
îî: ;
.
îî; <
y
îî< =
,
îî= >
min
îî? B
.
îîB C
y
îîC D
)
îîD E
;
îîE F
max
ïï 
.
ïï 
y
ïï 
=
ïï 
Mathf
ïï !
.
ïï! "
Max
ïï" %
(
ïï% &
	positions
ïï& /
[
ïï/ 0
indices
ïï0 7
[
ïï7 8
i
ïï8 9
]
ïï9 :
]
ïï: ;
.
ïï; <
y
ïï< =
,
ïï= >
max
ïï? B
.
ïïB C
y
ïïC D
)
ïïD E
;
ïïE F
min
óó 
.
óó 
z
óó 
=
óó 
Mathf
óó !
.
óó! "
Min
óó" %
(
óó% &
	positions
óó& /
[
óó/ 0
indices
óó0 7
[
óó7 8
i
óó8 9
]
óó9 :
]
óó: ;
.
óó; <
z
óó< =
,
óó= >
min
óó? B
.
óóB C
z
óóC D
)
óóD E
;
óóE F
max
òò 
.
òò 
z
òò 
=
òò 
Mathf
òò !
.
òò! "
Max
òò" %
(
òò% &
	positions
òò& /
[
òò/ 0
indices
òò0 7
[
òò7 8
i
òò8 9
]
òò9 :
]
òò: ;
.
òò; <
z
òò< =
,
òò= >
max
òò? B
.
òòB C
z
òòC D
)
òòD E
;
òòE F
}
ôô 
}
öö 
return
úú 
new
úú 
Bounds
úú 
(
úú 
(
úú 
min
úú "
+
úú# $
max
úú% (
)
úú( )
*
úú* +
$num
úú, /
,
úú/ 0
max
úú1 4
-
úú5 6
min
úú7 :
)
úú: ;
;
úú; <
}
ùù 	
static
üü 
Vector3
üü 
ComponentMin
üü #
(
üü# $
Vector3
üü$ +
a
üü, -
,
üü- .
Vector3
üü/ 6
b
üü7 8
)
üü8 9
{
†† 	
return
°° 
new
°° 
Vector3
°° 
(
°° 
Mathf
°° $
.
°°$ %
Min
°°% (
(
°°( )
a
°°) *
.
°°* +
x
°°+ ,
,
°°, -
b
°°. /
.
°°/ 0
x
°°0 1
)
°°1 2
,
°°2 3
Mathf
°°4 9
.
°°9 :
Min
°°: =
(
°°= >
a
°°> ?
.
°°? @
y
°°@ A
,
°°A B
b
°°C D
.
°°D E
y
°°E F
)
°°F G
,
°°G H
Mathf
°°I N
.
°°N O
Min
°°O R
(
°°R S
a
°°S T
.
°°T U
z
°°U V
,
°°V W
b
°°X Y
.
°°Y Z
z
°°Z [
)
°°[ \
)
°°\ ]
;
°°] ^
}
¢¢ 	
static
§§ 
Vector3
§§ 
ComponentMax
§§ #
(
§§# $
Vector3
§§$ +
a
§§, -
,
§§- .
Vector3
§§/ 6
b
§§7 8
)
§§8 9
{
•• 	
return
¶¶ 
new
¶¶ 
Vector3
¶¶ 
(
¶¶ 
Mathf
¶¶ $
.
¶¶$ %
Max
¶¶% (
(
¶¶( )
a
¶¶) *
.
¶¶* +
x
¶¶+ ,
,
¶¶, -
b
¶¶. /
.
¶¶/ 0
x
¶¶0 1
)
¶¶1 2
,
¶¶2 3
Mathf
¶¶4 9
.
¶¶9 :
Max
¶¶: =
(
¶¶= >
a
¶¶> ?
.
¶¶? @
y
¶¶@ A
,
¶¶A B
b
¶¶C D
.
¶¶D E
y
¶¶E F
)
¶¶F G
,
¶¶G H
Mathf
¶¶I N
.
¶¶N O
Max
¶¶O R
(
¶¶R S
a
¶¶S T
.
¶¶T U
z
¶¶U V
,
¶¶V W
b
¶¶X Y
.
¶¶Y Z
z
¶¶Z [
)
¶¶[ \
)
¶¶\ ]
;
¶¶] ^
}
ßß 	
internal
ÆÆ 
static
ÆÆ 
Bounds
ÆÆ 
	GetBounds
ÆÆ (
(
ÆÆ( )
Vector3
ÆÆ) 0
[
ÆÆ0 1
]
ÆÆ1 2
	positions
ÆÆ3 <
,
ÆÆ< =
IEnumerable
ÆÆ> I
<
ÆÆI J
Edge
ÆÆJ N
>
ÆÆN O
edges
ÆÆP U
)
ÆÆU V
{
ØØ 	
bool
∞∞ 
initialized
∞∞ 
=
∞∞ 
false
∞∞ $
;
∞∞$ %
Vector3
≤≤ 
min
≤≤ 
=
≤≤ 
Vector3
≤≤ !
.
≤≤! "
zero
≤≤" &
;
≤≤& '
Vector3
≥≥ 
max
≥≥ 
=
≥≥ 
min
≥≥ 
;
≥≥ 
foreach
µµ 
(
µµ 
var
µµ 
edge
µµ 
in
µµ  
edges
µµ! &
)
µµ& '
{
∂∂ 
if
∑∑ 
(
∑∑ 
!
∑∑ 
initialized
∑∑  
)
∑∑  !
{
∏∏ 
initialized
ππ 
=
ππ  !
true
ππ" &
;
ππ& '
min
∫∫ 
=
∫∫ 
	positions
∫∫ #
[
∫∫# $
edge
∫∫$ (
.
∫∫( )
a
∫∫) *
]
∫∫* +
;
∫∫+ ,
max
ªª 
=
ªª 
	positions
ªª #
[
ªª# $
edge
ªª$ (
.
ªª( )
a
ªª) *
]
ªª* +
;
ªª+ ,
}
ºº 
min
ææ 
=
ææ 
ComponentMin
ææ "
(
ææ" #
	positions
ææ# ,
[
ææ, -
edge
ææ- 1
.
ææ1 2
a
ææ2 3
]
ææ3 4
,
ææ4 5
min
ææ6 9
)
ææ9 :
;
ææ: ;
max
øø 
=
øø 
ComponentMax
øø "
(
øø" #
	positions
øø# ,
[
øø, -
edge
øø- 1
.
øø1 2
a
øø2 3
]
øø3 4
,
øø4 5
max
øø6 9
)
øø9 :
;
øø: ;
min
¡¡ 
=
¡¡ 
ComponentMin
¡¡ "
(
¡¡" #
	positions
¡¡# ,
[
¡¡, -
edge
¡¡- 1
.
¡¡1 2
b
¡¡2 3
]
¡¡3 4
,
¡¡4 5
min
¡¡6 9
)
¡¡9 :
;
¡¡: ;
max
¬¬ 
=
¬¬ 
ComponentMax
¬¬ "
(
¬¬" #
	positions
¬¬# ,
[
¬¬, -
edge
¬¬- 1
.
¬¬1 2
b
¬¬2 3
]
¬¬3 4
,
¬¬4 5
max
¬¬6 9
)
¬¬9 :
;
¬¬: ;
}
√√ 
return
≈≈ 
new
≈≈ 
Bounds
≈≈ 
(
≈≈ 
(
≈≈ 
min
≈≈ "
+
≈≈# $
max
≈≈% (
)
≈≈( )
*
≈≈* +
$num
≈≈, /
,
≈≈/ 0
max
≈≈1 4
-
≈≈5 6
min
≈≈7 :
)
≈≈: ;
;
≈≈; <
}
∆∆ 	
public
ŒŒ 
static
ŒŒ 
Vector2
ŒŒ 
Average
ŒŒ %
(
ŒŒ% &
IList
ŒŒ& +
<
ŒŒ+ ,
Vector2
ŒŒ, 3
>
ŒŒ3 4
array
ŒŒ5 :
,
ŒŒ: ;
IList
ŒŒ< A
<
ŒŒA B
int
ŒŒB E
>
ŒŒE F
indexes
ŒŒG N
=
ŒŒO P
null
ŒŒQ U
)
ŒŒU V
{
œœ 	
if
–– 
(
–– 
array
–– 
==
–– 
null
–– 
)
–– 
throw
—— 
new
—— #
ArgumentNullException
—— /
(
——/ 0
$str
——0 7
)
——7 8
;
——8 9
Vector2
”” 
sum
”” 
=
”” 
Vector2
”” !
.
””! "
zero
””" &
;
””& '
float
‘‘ 
len
‘‘ 
=
‘‘ 
indexes
‘‘ 
==
‘‘  "
null
‘‘# '
?
‘‘( )
array
‘‘* /
.
‘‘/ 0
Count
‘‘0 5
:
‘‘6 7
indexes
‘‘8 ?
.
‘‘? @
Count
‘‘@ E
;
‘‘E F
if
÷÷ 
(
÷÷ 
indexes
÷÷ 
==
÷÷ 
null
÷÷ 
)
÷÷  
for
◊◊ 
(
◊◊ 
int
◊◊ 
i
◊◊ 
=
◊◊ 
$num
◊◊ 
;
◊◊ 
i
◊◊  !
<
◊◊" #
len
◊◊$ '
;
◊◊' (
i
◊◊) *
++
◊◊* ,
)
◊◊, -
sum
◊◊. 1
+=
◊◊2 4
array
◊◊5 :
[
◊◊: ;
i
◊◊; <
]
◊◊< =
;
◊◊= >
else
ÿÿ 
for
ŸŸ 
(
ŸŸ 
int
ŸŸ 
i
ŸŸ 
=
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
i
ŸŸ  !
<
ŸŸ" #
len
ŸŸ$ '
;
ŸŸ' (
i
ŸŸ) *
++
ŸŸ* ,
)
ŸŸ, -
sum
ŸŸ. 1
+=
ŸŸ2 4
array
ŸŸ5 :
[
ŸŸ: ;
indexes
ŸŸ; B
[
ŸŸB C
i
ŸŸC D
]
ŸŸD E
]
ŸŸE F
;
ŸŸF G
return
€€ 
sum
€€ 
/
€€ 
len
€€ 
;
€€ 
}
‹‹ 	
public
‰‰ 
static
‰‰ 
Vector3
‰‰ 
Average
‰‰ %
(
‰‰% &
IList
‰‰& +
<
‰‰+ ,
Vector3
‰‰, 3
>
‰‰3 4
array
‰‰5 :
,
‰‰: ;
IList
‰‰< A
<
‰‰A B
int
‰‰B E
>
‰‰E F
indexes
‰‰G N
=
‰‰O P
null
‰‰Q U
)
‰‰U V
{
ÂÂ 	
if
ÊÊ 
(
ÊÊ 
array
ÊÊ 
==
ÊÊ 
null
ÊÊ 
)
ÊÊ 
throw
ÁÁ 
new
ÁÁ #
ArgumentNullException
ÁÁ /
(
ÁÁ/ 0
$str
ÁÁ0 7
)
ÁÁ7 8
;
ÁÁ8 9
Vector3
ÈÈ 
sum
ÈÈ 
=
ÈÈ 
Vector3
ÈÈ !
.
ÈÈ! "
zero
ÈÈ" &
;
ÈÈ& '
float
ÎÎ 
len
ÎÎ 
=
ÎÎ 
indexes
ÎÎ 
==
ÎÎ  "
null
ÎÎ# '
?
ÎÎ( )
array
ÎÎ* /
.
ÎÎ/ 0
Count
ÎÎ0 5
:
ÎÎ6 7
indexes
ÎÎ8 ?
.
ÎÎ? @
Count
ÎÎ@ E
;
ÎÎE F
if
ÌÌ 
(
ÌÌ 
indexes
ÌÌ 
==
ÌÌ 
null
ÌÌ 
)
ÌÌ  
{
ÓÓ 
for
ÔÔ 
(
ÔÔ 
int
ÔÔ 
i
ÔÔ 
=
ÔÔ 
$num
ÔÔ 
;
ÔÔ 
i
ÔÔ  !
<
ÔÔ" #
len
ÔÔ$ '
;
ÔÔ' (
i
ÔÔ) *
++
ÔÔ* ,
)
ÔÔ, -
{
 
sum
ÒÒ 
.
ÒÒ 
x
ÒÒ 
+=
ÒÒ 
array
ÒÒ "
[
ÒÒ" #
i
ÒÒ# $
]
ÒÒ$ %
.
ÒÒ% &
x
ÒÒ& '
;
ÒÒ' (
sum
ÚÚ 
.
ÚÚ 
y
ÚÚ 
+=
ÚÚ 
array
ÚÚ "
[
ÚÚ" #
i
ÚÚ# $
]
ÚÚ$ %
.
ÚÚ% &
y
ÚÚ& '
;
ÚÚ' (
sum
ÛÛ 
.
ÛÛ 
z
ÛÛ 
+=
ÛÛ 
array
ÛÛ "
[
ÛÛ" #
i
ÛÛ# $
]
ÛÛ$ %
.
ÛÛ% &
z
ÛÛ& '
;
ÛÛ' (
}
ÙÙ 
}
ıı 
else
ˆˆ 
{
˜˜ 
for
¯¯ 
(
¯¯ 
int
¯¯ 
i
¯¯ 
=
¯¯ 
$num
¯¯ 
;
¯¯ 
i
¯¯  !
<
¯¯" #
len
¯¯$ '
;
¯¯' (
i
¯¯) *
++
¯¯* ,
)
¯¯, -
{
˘˘ 
sum
˙˙ 
.
˙˙ 
x
˙˙ 
+=
˙˙ 
array
˙˙ "
[
˙˙" #
indexes
˙˙# *
[
˙˙* +
i
˙˙+ ,
]
˙˙, -
]
˙˙- .
.
˙˙. /
x
˙˙/ 0
;
˙˙0 1
sum
˚˚ 
.
˚˚ 
y
˚˚ 
+=
˚˚ 
array
˚˚ "
[
˚˚" #
indexes
˚˚# *
[
˚˚* +
i
˚˚+ ,
]
˚˚, -
]
˚˚- .
.
˚˚. /
y
˚˚/ 0
;
˚˚0 1
sum
¸¸ 
.
¸¸ 
z
¸¸ 
+=
¸¸ 
array
¸¸ "
[
¸¸" #
indexes
¸¸# *
[
¸¸* +
i
¸¸+ ,
]
¸¸, -
]
¸¸- .
.
¸¸. /
z
¸¸/ 0
;
¸¸0 1
}
˝˝ 
}
˛˛ 
return
Ä	Ä	 
sum
Ä	Ä	 
/
Ä	Ä	 
len
Ä	Ä	 
;
Ä	Ä	 
}
Å	Å	 	
internal
ã	ã	 
static
ã	ã	 
Vector3
ã	ã	 
Average
ã	ã	  '
<
ã	ã	' (
T
ã	ã	( )
>
ã	ã	) *
(
ã	ã	* +
this
ã	ã	+ /
IList
ã	ã	0 5
<
ã	ã	5 6
T
ã	ã	6 7
>
ã	ã	7 8
list
ã	ã	9 =
,
ã	ã	= >
Func
ã	ã	? C
<
ã	ã	C D
T
ã	ã	D E
,
ã	ã	E F
Vector3
ã	ã	G N
>
ã	ã	N O
selector
ã	ã	P X
,
ã	ã	X Y
IList
ã	ã	Z _
<
ã	ã	_ `
int
ã	ã	` c
>
ã	ã	c d
indexes
ã	ã	e l
=
ã	ã	m n
null
ã	ã	o s
)
ã	ã	s t
{
å	å	 	
if
ç	ç	 
(
ç	ç	 
list
ç	ç	 
==
ç	ç	 
null
ç	ç	 
)
ç	ç	 
throw
é	é	 
new
é	é	 #
ArgumentNullException
é	é	 /
(
é	é	/ 0
$str
é	é	0 6
)
é	é	6 7
;
é	é	7 8
if
ê	ê	 
(
ê	ê	 
selector
ê	ê	 
==
ê	ê	 
null
ê	ê	  
)
ê	ê	  !
throw
ë	ë	 
new
ë	ë	 #
ArgumentNullException
ë	ë	 /
(
ë	ë	/ 0
$str
ë	ë	0 :
)
ë	ë	: ;
;
ë	ë	; <
Vector3
ì	ì	 
sum
ì	ì	 
=
ì	ì	 
Vector3
ì	ì	 !
.
ì	ì	! "
zero
ì	ì	" &
;
ì	ì	& '
float
î	î	 
len
î	î	 
=
î	î	 
indexes
î	î	 
==
î	î	  "
null
î	î	# '
?
î	î	( )
list
î	î	* .
.
î	î	. /
Count
î	î	/ 4
:
î	î	5 6
indexes
î	î	7 >
.
î	î	> ?
Count
î	î	? D
;
î	î	D E
if
ñ	ñ	 
(
ñ	ñ	 
indexes
ñ	ñ	 
==
ñ	ñ	 
null
ñ	ñ	 
)
ñ	ñ	  
{
ó	ó	 
for
ò	ò	 
(
ò	ò	 
int
ò	ò	 
i
ò	ò	 
=
ò	ò	 
$num
ò	ò	 
;
ò	ò	 
i
ò	ò	  !
<
ò	ò	" #
len
ò	ò	$ '
;
ò	ò	' (
i
ò	ò	) *
++
ò	ò	* ,
)
ò	ò	, -
sum
ô	ô	 
+=
ô	ô	 
selector
ô	ô	 #
(
ô	ô	# $
list
ô	ô	$ (
[
ô	ô	( )
i
ô	ô	) *
]
ô	ô	* +
)
ô	ô	+ ,
;
ô	ô	, -
}
ö	ö	 
else
õ	õ	 
{
ú	ú	 
for
ù	ù	 
(
ù	ù	 
int
ù	ù	 
i
ù	ù	 
=
ù	ù	 
$num
ù	ù	 
;
ù	ù	 
i
ù	ù	  !
<
ù	ù	" #
len
ù	ù	$ '
;
ù	ù	' (
i
ù	ù	) *
++
ù	ù	* ,
)
ù	ù	, -
sum
û	û	 
+=
û	û	 
selector
û	û	 #
(
û	û	# $
list
û	û	$ (
[
û	û	( )
indexes
û	û	) 0
[
û	û	0 1
i
û	û	1 2
]
û	û	2 3
]
û	û	3 4
)
û	û	4 5
;
û	û	5 6
}
ü	ü	 
return
°	°	 
sum
°	°	 
/
°	°	 
len
°	°	 
;
°	°	 
}
¢	¢	 	
public
§	§	 
static
§	§	 
Vector4
§	§	 
Average
§	§	 %
(
§	§	% &
IList
§	§	& +
<
§	§	+ ,
Vector4
§	§	, 3
>
§	§	3 4
v
§	§	5 6
,
§	§	6 7
IList
§	§	8 =
<
§	§	= >
int
§	§	> A
>
§	§	A B
indexes
§	§	C J
=
§	§	K L
null
§	§	M Q
)
§	§	Q R
{
•	•	 	
Vector4
¶	¶	 
sum
¶	¶	 
=
¶	¶	 
Vector4
¶	¶	 !
.
¶	¶	! "
zero
¶	¶	" &
;
¶	¶	& '
float
ß	ß	 
len
ß	ß	 
=
ß	ß	 
indexes
ß	ß	 
==
ß	ß	  "
null
ß	ß	# '
?
ß	ß	( )
v
ß	ß	* +
.
ß	ß	+ ,
Count
ß	ß	, 1
:
ß	ß	2 3
indexes
ß	ß	4 ;
.
ß	ß	; <
Count
ß	ß	< A
;
ß	ß	A B
if
®	®	 
(
®	®	 
indexes
®	®	 
==
®	®	 
null
®	®	 
)
®	®	  
for
©	©	 
(
©	©	 
int
©	©	 
i
©	©	 
=
©	©	 
$num
©	©	 
;
©	©	 
i
©	©	  !
<
©	©	" #
len
©	©	$ '
;
©	©	' (
i
©	©	) *
++
©	©	* ,
)
©	©	, -
sum
©	©	. 1
+=
©	©	2 4
v
©	©	5 6
[
©	©	6 7
i
©	©	7 8
]
©	©	8 9
;
©	©	9 :
else
™	™	 
for
´	´	 
(
´	´	 
int
´	´	 
i
´	´	 
=
´	´	 
$num
´	´	 
;
´	´	 
i
´	´	  !
<
´	´	" #
len
´	´	$ '
;
´	´	' (
i
´	´	) *
++
´	´	* ,
)
´	´	, -
sum
´	´	. 1
+=
´	´	2 4
v
´	´	5 6
[
´	´	6 7
indexes
´	´	7 >
[
´	´	> ?
i
´	´	? @
]
´	´	@ A
]
´	´	A B
;
´	´	B C
return
¨	¨	 
sum
¨	¨	 
/
¨	¨	 
len
¨	¨	 
;
¨	¨	 
}
≠	≠	 	
internal
Ø	Ø	 
static
Ø	Ø	 
Color
Ø	Ø	 
Average
Ø	Ø	 %
(
Ø	Ø	% &
IList
Ø	Ø	& +
<
Ø	Ø	+ ,
Color
Ø	Ø	, 1
>
Ø	Ø	1 2
c
Ø	Ø	3 4
,
Ø	Ø	4 5
IList
Ø	Ø	6 ;
<
Ø	Ø	; <
int
Ø	Ø	< ?
>
Ø	Ø	? @
indexes
Ø	Ø	A H
=
Ø	Ø	I J
null
Ø	Ø	K O
)
Ø	Ø	O P
{
∞	∞	 	
Color
±	±	 
sum
±	±	 
=
±	±	 
c
±	±	 
[
±	±	 
$num
±	±	 
]
±	±	 
;
±	±	 
float
≤	≤	 
len
≤	≤	 
=
≤	≤	 
indexes
≤	≤	 
==
≤	≤	  "
null
≤	≤	# '
?
≤	≤	( )
c
≤	≤	* +
.
≤	≤	+ ,
Count
≤	≤	, 1
:
≤	≤	2 3
indexes
≤	≤	4 ;
.
≤	≤	; <
Count
≤	≤	< A
;
≤	≤	A B
if
≥	≥	 
(
≥	≥	 
indexes
≥	≥	 
==
≥	≥	 
null
≥	≥	 
)
≥	≥	  
for
¥	¥	 
(
¥	¥	 
int
¥	¥	 
i
¥	¥	 
=
¥	¥	 
$num
¥	¥	 
;
¥	¥	 
i
¥	¥	  !
<
¥	¥	" #
len
¥	¥	$ '
;
¥	¥	' (
i
¥	¥	) *
++
¥	¥	* ,
)
¥	¥	, -
sum
¥	¥	. 1
+=
¥	¥	2 4
c
¥	¥	5 6
[
¥	¥	6 7
i
¥	¥	7 8
]
¥	¥	8 9
;
¥	¥	9 :
else
µ	µ	 
for
∂	∂	 
(
∂	∂	 
int
∂	∂	 
i
∂	∂	 
=
∂	∂	 
$num
∂	∂	 
;
∂	∂	 
i
∂	∂	  !
<
∂	∂	" #
len
∂	∂	$ '
;
∂	∂	' (
i
∂	∂	) *
++
∂	∂	* ,
)
∂	∂	, -
sum
∂	∂	. 1
+=
∂	∂	2 4
c
∂	∂	5 6
[
∂	∂	6 7
indexes
∂	∂	7 >
[
∂	∂	> ?
i
∂	∂	? @
]
∂	∂	@ A
]
∂	∂	A B
;
∂	∂	B C
return
∑	∑	 
sum
∑	∑	 
/
∑	∑	 
len
∑	∑	 
;
∑	∑	 
}
∏	∏	 	
internal
¡	¡	 
static
¡	¡	 
bool
¡	¡	 
Approx2
¡	¡	 $
(
¡	¡	$ %
this
¡	¡	% )
Vector2
¡	¡	* 1
a
¡	¡	2 3
,
¡	¡	3 4
Vector2
¡	¡	5 <
b
¡	¡	= >
,
¡	¡	> ?
float
¡	¡	@ E
delta
¡	¡	F K
=
¡	¡	L M!
k_FltCompareEpsilon
¡	¡	N a
)
¡	¡	a b
{
¬	¬	 	
return
√	√	 
Mathf
ƒ	ƒ	 
.
ƒ	ƒ	 
Abs
ƒ	ƒ	 
(
ƒ	ƒ	 
a
ƒ	ƒ	 
.
ƒ	ƒ	 
x
ƒ	ƒ	 
-
ƒ	ƒ	 
b
ƒ	ƒ	  !
.
ƒ	ƒ	! "
x
ƒ	ƒ	" #
)
ƒ	ƒ	# $
<
ƒ	ƒ	% &
delta
ƒ	ƒ	' ,
&&
ƒ	ƒ	- /
Mathf
≈	≈	 
.
≈	≈	 
Abs
≈	≈	 
(
≈	≈	 
a
≈	≈	 
.
≈	≈	 
y
≈	≈	 
-
≈	≈	 
b
≈	≈	  !
.
≈	≈	! "
y
≈	≈	" #
)
≈	≈	# $
<
≈	≈	% &
delta
≈	≈	' ,
;
≈	≈	, -
}
∆	∆	 	
internal
œ	œ	 
static
œ	œ	 
bool
œ	œ	 
Approx3
œ	œ	 $
(
œ	œ	$ %
this
œ	œ	% )
Vector3
œ	œ	* 1
a
œ	œ	2 3
,
œ	œ	3 4
Vector3
œ	œ	5 <
b
œ	œ	= >
,
œ	œ	> ?
float
œ	œ	@ E
delta
œ	œ	F K
=
œ	œ	L M!
k_FltCompareEpsilon
œ	œ	N a
)
œ	œ	a b
{
–	–	 	
return
—	—	 
Mathf
“	“	 
.
“	“	 
Abs
“	“	 
(
“	“	 
a
“	“	 
.
“	“	 
x
“	“	 
-
“	“	 
b
“	“	  !
.
“	“	! "
x
“	“	" #
)
“	“	# $
<
“	“	% &
delta
“	“	' ,
&&
“	“	- /
Mathf
”	”	 
.
”	”	 
Abs
”	”	 
(
”	”	 
a
”	”	 
.
”	”	 
y
”	”	 
-
”	”	 
b
”	”	  !
.
”	”	! "
y
”	”	" #
)
”	”	# $
<
”	”	% &
delta
”	”	' ,
&&
”	”	- /
Mathf
‘	‘	 
.
‘	‘	 
Abs
‘	‘	 
(
‘	‘	 
a
‘	‘	 
.
‘	‘	 
z
‘	‘	 
-
‘	‘	 
b
‘	‘	  !
.
‘	‘	! "
z
‘	‘	" #
)
‘	‘	# $
<
‘	‘	% &
delta
‘	‘	' ,
;
‘	‘	, -
}
’	’	 	
internal
ﬂ	ﬂ	 
static
ﬂ	ﬂ	 
bool
ﬂ	ﬂ	 
Approx4
ﬂ	ﬂ	 $
(
ﬂ	ﬂ	$ %
this
ﬂ	ﬂ	% )
Vector4
ﬂ	ﬂ	* 1
a
ﬂ	ﬂ	2 3
,
ﬂ	ﬂ	3 4
Vector4
ﬂ	ﬂ	5 <
b
ﬂ	ﬂ	= >
,
ﬂ	ﬂ	> ?
float
ﬂ	ﬂ	@ E
delta
ﬂ	ﬂ	F K
=
ﬂ	ﬂ	L M!
k_FltCompareEpsilon
ﬂ	ﬂ	N a
)
ﬂ	ﬂ	a b
{
‡	‡	 	
return
·	·	 
Mathf
‚	‚	 
.
‚	‚	 
Abs
‚	‚	 
(
‚	‚	 
a
‚	‚	 
.
‚	‚	 
x
‚	‚	 
-
‚	‚	 
b
‚	‚	  !
.
‚	‚	! "
x
‚	‚	" #
)
‚	‚	# $
<
‚	‚	% &
delta
‚	‚	' ,
&&
‚	‚	- /
Mathf
„	„	 
.
„	„	 
Abs
„	„	 
(
„	„	 
a
„	„	 
.
„	„	 
y
„	„	 
-
„	„	 
b
„	„	  !
.
„	„	! "
y
„	„	" #
)
„	„	# $
<
„	„	% &
delta
„	„	' ,
&&
„	„	- /
Mathf
‰	‰	 
.
‰	‰	 
Abs
‰	‰	 
(
‰	‰	 
a
‰	‰	 
.
‰	‰	 
z
‰	‰	 
-
‰	‰	 
b
‰	‰	  !
.
‰	‰	! "
z
‰	‰	" #
)
‰	‰	# $
<
‰	‰	% &
delta
‰	‰	' ,
&&
‰	‰	- /
Mathf
Â	Â	 
.
Â	Â	 
Abs
Â	Â	 
(
Â	Â	 
a
Â	Â	 
.
Â	Â	 
w
Â	Â	 
-
Â	Â	 
b
Â	Â	  !
.
Â	Â	! "
w
Â	Â	" #
)
Â	Â	# $
<
Â	Â	% &
delta
Â	Â	' ,
;
Â	Â	, -
}
Ê	Ê	 	
internal
Ô	Ô	 
static
Ô	Ô	 
bool
Ô	Ô	 
ApproxC
Ô	Ô	 $
(
Ô	Ô	$ %
this
Ô	Ô	% )
Color
Ô	Ô	* /
a
Ô	Ô	0 1
,
Ô	Ô	1 2
Color
Ô	Ô	3 8
b
Ô	Ô	9 :
,
Ô	Ô	: ;
float
Ô	Ô	< A
delta
Ô	Ô	B G
=
Ô	Ô	H I!
k_FltCompareEpsilon
Ô	Ô	J ]
)
Ô	Ô	] ^
{
		 	
return
Ò	Ò	 
Mathf
Ò	Ò	 
.
Ò	Ò	 
Abs
Ò	Ò	 
(
Ò	Ò	 
a
Ò	Ò	 
.
Ò	Ò	 
r
Ò	Ò	  
-
Ò	Ò	! "
b
Ò	Ò	# $
.
Ò	Ò	$ %
r
Ò	Ò	% &
)
Ò	Ò	& '
<
Ò	Ò	( )
delta
Ò	Ò	* /
&&
Ò	Ò	0 2
Mathf
Ú	Ú	 
.
Ú	Ú	 
Abs
Ú	Ú	 
(
Ú	Ú	 
a
Ú	Ú	 
.
Ú	Ú	 
g
Ú	Ú	 
-
Ú	Ú	 
b
Ú	Ú	  !
.
Ú	Ú	! "
g
Ú	Ú	" #
)
Ú	Ú	# $
<
Ú	Ú	% &
delta
Ú	Ú	' ,
&&
Ú	Ú	- /
Mathf
Û	Û	 
.
Û	Û	 
Abs
Û	Û	 
(
Û	Û	 
a
Û	Û	 
.
Û	Û	 
b
Û	Û	 
-
Û	Û	 
b
Û	Û	  !
.
Û	Û	! "
b
Û	Û	" #
)
Û	Û	# $
<
Û	Û	% &
delta
Û	Û	' ,
&&
Û	Û	- /
Mathf
Ù	Ù	 
.
Ù	Ù	 
Abs
Ù	Ù	 
(
Ù	Ù	 
a
Ù	Ù	 
.
Ù	Ù	 
a
Ù	Ù	 
-
Ù	Ù	 
b
Ù	Ù	  !
.
Ù	Ù	! "
a
Ù	Ù	" #
)
Ù	Ù	# $
<
Ù	Ù	% &
delta
Ù	Ù	' ,
;
Ù	Ù	, -
}
ı	ı	 	
internal
ˇ	ˇ	 
static
ˇ	ˇ	 
bool
ˇ	ˇ	 
Approx
ˇ	ˇ	 #
(
ˇ	ˇ	# $
this
ˇ	ˇ	$ (
float
ˇ	ˇ	) .
a
ˇ	ˇ	/ 0
,
ˇ	ˇ	0 1
float
ˇ	ˇ	2 7
b
ˇ	ˇ	8 9
,
ˇ	ˇ	9 :
float
ˇ	ˇ	; @
delta
ˇ	ˇ	A F
=
ˇ	ˇ	G H!
k_FltCompareEpsilon
ˇ	ˇ	I \
)
ˇ	ˇ	\ ]
{
Ä
Ä
 	
return
Å
Å
 
Mathf
Å
Å
 
.
Å
Å
 
Abs
Å
Å
 
(
Å
Å
 
b
Å
Å
 
-
Å
Å
  
a
Å
Å
! "
)
Å
Å
" #
<
Å
Å
$ %
Mathf
Å
Å
& +
.
Å
Å
+ ,
Abs
Å
Å
, /
(
Å
Å
/ 0
delta
Å
Å
0 5
)
Å
Å
5 6
;
Å
Å
6 7
}
Ç
Ç
 	
internal
é
é
 
static
é
é
 
int
é
é
 
Wrap
é
é
  
(
é
é
  !
int
é
é
! $
value
é
é
% *
,
é
é
* +
int
é
é
, /

lowerBound
é
é
0 :
,
é
é
: ;
int
é
é
< ?

upperBound
é
é
@ J
)
é
é
J K
{
è
è
 	
int
ê
ê
 

range_size
ê
ê
 
=
ê
ê
 

upperBound
ê
ê
 '
-
ê
ê
( )

lowerBound
ê
ê
* 4
+
ê
ê
5 6
$num
ê
ê
7 8
;
ê
ê
8 9
if
í
í
 
(
í
í
 
value
í
í
 
<
í
í
 

lowerBound
í
í
 "
)
í
í
" #
value
ì
ì
 
+=
ì
ì
 

range_size
ì
ì
 #
*
ì
ì
$ %
(
ì
ì
& '
(
ì
ì
' (

lowerBound
ì
ì
( 2
-
ì
ì
3 4
value
ì
ì
5 :
)
ì
ì
: ;
/
ì
ì
< =

range_size
ì
ì
> H
+
ì
ì
I J
$num
ì
ì
K L
)
ì
ì
L M
;
ì
ì
M N
return
ï
ï
 

lowerBound
ï
ï
 
+
ï
ï
 
(
ï
ï
  !
value
ï
ï
! &
-
ï
ï
' (

lowerBound
ï
ï
) 3
)
ï
ï
3 4
%
ï
ï
5 6

range_size
ï
ï
7 A
;
ï
ï
A B
}
ñ
ñ
 	
public
ü
ü
 
static
ü
ü
 
int
ü
ü
 
Clamp
ü
ü
 
(
ü
ü
  
int
ü
ü
  #
value
ü
ü
$ )
,
ü
ü
) *
int
ü
ü
+ .

lowerBound
ü
ü
/ 9
,
ü
ü
9 :
int
ü
ü
; >

upperBound
ü
ü
? I
)
ü
ü
I J
{
†
†
 	
return
°
°
 
value
°
°
 
<
°
°
 

lowerBound
°
°
 %
?
¢
¢
 

lowerBound
¢
¢
 
:
£
£
 
value
£
£
 
>
£
£
 

upperBound
£
£
 $
?
§
§
 

upperBound
§
§
  
:
•
•
 
value
•
•
 
;
•
•
 
}
¶
¶
 	
internal
®
®
 
static
®
®
 
Vector3
®
®
 
Clamp
®
®
  %
(
®
®
% &
Vector3
®
®
& -
value
®
®
. 3
,
®
®
3 4
Vector3
®
®
5 <

lowerBound
®
®
= G
,
®
®
G H
Vector3
®
®
I P

upperBound
®
®
Q [
)
®
®
[ \
{
©
©
 	
return
™
™
 
Vector3
™
™
 
.
™
™
 
Max
™
™
 
(
™
™
 
Vector3
™
™
 &
.
™
™
& '
Min
™
™
' *
(
™
™
* +
value
™
™
+ 0
,
™
™
0 1

upperBound
™
™
2 <
)
™
™
< =
,
™
™
= >

lowerBound
™
™
? I
)
™
™
I J
;
™
™
J K
}
´
´
 	
internal
≠
≠
 
static
≠
≠
 
Vector3
≠
≠
 
ToSignedMask
≠
≠
  ,
(
≠
≠
, -
this
≠
≠
- 1
Vector3
≠
≠
2 9
vec
≠
≠
: =
,
≠
≠
= >
float
≠
≠
? D
delta
≠
≠
E J
=
≠
≠
K L
k_FltEpsilon
≠
≠
M Y
)
≠
≠
Y Z
{
Æ
Æ
 	
return
Ø
Ø
 
new
Ø
Ø
 
Vector3
Ø
Ø
 
(
Ø
Ø
 
Mathf
∞
∞
 
.
∞
∞
 
Abs
∞
∞
 
(
∞
∞
 
vec
∞
∞
 
.
∞
∞
 
x
∞
∞
 
)
∞
∞
  
>
∞
∞
! "
delta
∞
∞
# (
?
∞
∞
) *
vec
∞
∞
+ .
.
∞
∞
. /
x
∞
∞
/ 0
/
∞
∞
1 2
Mathf
∞
∞
3 8
.
∞
∞
8 9
Abs
∞
∞
9 <
(
∞
∞
< =
vec
∞
∞
= @
.
∞
∞
@ A
x
∞
∞
A B
)
∞
∞
B C
:
∞
∞
D E
$num
∞
∞
F H
,
∞
∞
H I
Mathf
±
±
 
.
±
±
 
Abs
±
±
 
(
±
±
 
vec
±
±
 
.
±
±
 
y
±
±
 
)
±
±
  
>
±
±
! "
delta
±
±
# (
?
±
±
) *
vec
±
±
+ .
.
±
±
. /
y
±
±
/ 0
/
±
±
1 2
Mathf
±
±
3 8
.
±
±
8 9
Abs
±
±
9 <
(
±
±
< =
vec
±
±
= @
.
±
±
@ A
y
±
±
A B
)
±
±
B C
:
±
±
D E
$num
±
±
F H
,
±
±
H I
Mathf
≤
≤
 
.
≤
≤
 
Abs
≤
≤
 
(
≤
≤
 
vec
≤
≤
 
.
≤
≤
 
z
≤
≤
 
)
≤
≤
  
>
≤
≤
! "
delta
≤
≤
# (
?
≤
≤
) *
vec
≤
≤
+ .
.
≤
≤
. /
z
≤
≤
/ 0
/
≤
≤
1 2
Mathf
≤
≤
3 8
.
≤
≤
8 9
Abs
≤
≤
9 <
(
≤
≤
< =
vec
≤
≤
= @
.
≤
≤
@ A
z
≤
≤
A B
)
≤
≤
B C
:
≤
≤
D E
$num
≤
≤
F H
)
≥
≥
 
;
≥
≥
 
}
¥
¥
 	
internal
∂
∂
 
static
∂
∂
 
Vector3
∂
∂
 
Abs
∂
∂
  #
(
∂
∂
# $
this
∂
∂
$ (
Vector3
∂
∂
) 0
v
∂
∂
1 2
)
∂
∂
2 3
{
∑
∑
 	
return
∏
∏
 
new
∏
∏
 
Vector3
∏
∏
 
(
∏
∏
 
Mathf
∏
∏
 $
.
∏
∏
$ %
Abs
∏
∏
% (
(
∏
∏
( )
v
∏
∏
) *
.
∏
∏
* +
x
∏
∏
+ ,
)
∏
∏
, -
,
∏
∏
- .
Mathf
∏
∏
/ 4
.
∏
∏
4 5
Abs
∏
∏
5 8
(
∏
∏
8 9
v
∏
∏
9 :
.
∏
∏
: ;
y
∏
∏
; <
)
∏
∏
< =
,
∏
∏
= >
Mathf
∏
∏
? D
.
∏
∏
D E
Abs
∏
∏
E H
(
∏
∏
H I
v
∏
∏
I J
.
∏
∏
J K
z
∏
∏
K L
)
∏
∏
L M
)
∏
∏
M N
;
∏
∏
N O
}
π
π
 	
internal
ª
ª
 
static
ª
ª
 
int
ª
ª
 
IntSum
ª
ª
 "
(
ª
ª
" #
this
ª
ª
# '
Vector3
ª
ª
( /
mask
ª
ª
0 4
)
ª
ª
4 5
{
º
º
 	
return
Ω
Ω
 
(
Ω
Ω
 
int
Ω
Ω
 
)
Ω
Ω
 
Mathf
Ω
Ω
 
.
Ω
Ω
 
Abs
Ω
Ω
 !
(
Ω
Ω
! "
mask
Ω
Ω
" &
.
Ω
Ω
& '
x
Ω
Ω
' (
)
Ω
Ω
( )
+
Ω
Ω
* +
(
Ω
Ω
, -
int
Ω
Ω
- 0
)
Ω
Ω
0 1
Mathf
Ω
Ω
1 6
.
Ω
Ω
6 7
Abs
Ω
Ω
7 :
(
Ω
Ω
: ;
mask
Ω
Ω
; ?
.
Ω
Ω
? @
y
Ω
Ω
@ A
)
Ω
Ω
A B
+
Ω
Ω
C D
(
Ω
Ω
E F
int
Ω
Ω
F I
)
Ω
Ω
I J
Mathf
Ω
Ω
J O
.
Ω
Ω
O P
Abs
Ω
Ω
P S
(
Ω
Ω
S T
mask
Ω
Ω
T X
.
Ω
Ω
X Y
z
Ω
Ω
Y Z
)
Ω
Ω
Z [
;
Ω
Ω
[ \
}
æ
æ
 	
internal
¿
¿
 
static
¿
¿
 
float
¿
¿
 
Sum
¿
¿
 !
(
¿
¿
! "
this
¿
¿
" &
Vector3
¿
¿
' .
v
¿
¿
/ 0
)
¿
¿
0 1
{
¡
¡
 	
return
¬
¬
 
Mathf
¬
¬
 
.
¬
¬
 
Abs
¬
¬
 
(
¬
¬
 
v
¬
¬
 
.
¬
¬
 
x
¬
¬
  
)
¬
¬
  !
+
¬
¬
" #
Mathf
¬
¬
$ )
.
¬
¬
) *
Abs
¬
¬
* -
(
¬
¬
- .
v
¬
¬
. /
.
¬
¬
/ 0
y
¬
¬
0 1
)
¬
¬
1 2
+
¬
¬
3 4
Mathf
¬
¬
5 :
.
¬
¬
: ;
Abs
¬
¬
; >
(
¬
¬
> ?
v
¬
¬
? @
.
¬
¬
@ A
z
¬
¬
A B
)
¬
¬
B C
;
¬
¬
C D
}
√
√
 	
internal
–
–
 
static
–
–
 
void
–
–
 
Cross
–
–
 "
(
–
–
" #
Vector3
–
–
# *
a
–
–
+ ,
,
–
–
, -
Vector3
–
–
. 5
b
–
–
6 7
,
–
–
7 8
ref
–
–
9 <
float
–
–
= B
x
–
–
C D
,
–
–
D E
ref
–
–
F I
float
–
–
J O
y
–
–
P Q
,
–
–
Q R
ref
–
–
S V
float
–
–
W \
z
–
–
] ^
)
–
–
^ _
{
—
—
 	
x
“
“
 
=
“
“
 
a
“
“
 
.
“
“
 
y
“
“
 
*
“
“
 
b
“
“
 
.
“
“
 
z
“
“
 
-
“
“
 
a
“
“
 
.
“
“
 
z
“
“
 
*
“
“
  !
b
“
“
" #
.
“
“
# $
y
“
“
$ %
;
“
“
% &
y
”
”
 
=
”
”
 
a
”
”
 
.
”
”
 
z
”
”
 
*
”
”
 
b
”
”
 
.
”
”
 
x
”
”
 
-
”
”
 
a
”
”
 
.
”
”
 
x
”
”
 
*
”
”
  !
b
”
”
" #
.
”
”
# $
z
”
”
$ %
;
”
”
% &
z
‘
‘
 
=
‘
‘
 
a
‘
‘
 
.
‘
‘
 
x
‘
‘
 
*
‘
‘
 
b
‘
‘
 
.
‘
‘
 
y
‘
‘
 
-
‘
‘
 
a
‘
‘
 
.
‘
‘
 
y
‘
‘
 
*
‘
‘
  !
b
‘
‘
" #
.
‘
‘
# $
x
‘
‘
$ %
;
‘
‘
% &
}
’
’
 	
internal
›
›
 
static
›
›
 
void
›
›
 
Cross
›
›
 "
(
›
›
" #
Vector3
›
›
# *
a
›
›
+ ,
,
›
›
, -
Vector3
›
›
. 5
b
›
›
6 7
,
›
›
7 8
ref
›
›
9 <
Vector3
›
›
= D
res
›
›
E H
)
›
›
H I
{
ﬁ
ﬁ
 	
res
ﬂ
ﬂ
 
.
ﬂ
ﬂ
 
x
ﬂ
ﬂ
 
=
ﬂ
ﬂ
 
a
ﬂ
ﬂ
 
.
ﬂ
ﬂ
 
y
ﬂ
ﬂ
 
*
ﬂ
ﬂ
 
b
ﬂ
ﬂ
 
.
ﬂ
ﬂ
 
z
ﬂ
ﬂ
 
-
ﬂ
ﬂ
 
a
ﬂ
ﬂ
  !
.
ﬂ
ﬂ
! "
z
ﬂ
ﬂ
" #
*
ﬂ
ﬂ
$ %
b
ﬂ
ﬂ
& '
.
ﬂ
ﬂ
' (
y
ﬂ
ﬂ
( )
;
ﬂ
ﬂ
) *
res
‡
‡
 
.
‡
‡
 
y
‡
‡
 
=
‡
‡
 
a
‡
‡
 
.
‡
‡
 
z
‡
‡
 
*
‡
‡
 
b
‡
‡
 
.
‡
‡
 
x
‡
‡
 
-
‡
‡
 
a
‡
‡
  !
.
‡
‡
! "
x
‡
‡
" #
*
‡
‡
$ %
b
‡
‡
& '
.
‡
‡
' (
z
‡
‡
( )
;
‡
‡
) *
res
·
·
 
.
·
·
 
z
·
·
 
=
·
·
 
a
·
·
 
.
·
·
 
x
·
·
 
*
·
·
 
b
·
·
 
.
·
·
 
y
·
·
 
-
·
·
 
a
·
·
  !
.
·
·
! "
y
·
·
" #
*
·
·
$ %
b
·
·
& '
.
·
·
' (
x
·
·
( )
;
·
·
) *
}
‚
‚
 	
internal


 
static


 
void


 
Cross


 "
(


" #
float


# (
ax


) +
,


+ ,
float


- 2
ay


3 5
,


5 6
float


7 <
az


= ?
,


? @
float


A F
bx


G I
,


I J
float


K P
by


Q S
,


S T
float


U Z
bz


[ ]
,


] ^
ref


_ b
float


c h
x


i j
,


j k
ref


l o
float


p u
y


v w
,


w x
ref


y |
float

} Ç
z

É Ñ
)

Ñ Ö
{
Ò
Ò
 	
x
Ú
Ú
 
=
Ú
Ú
 
ay
Ú
Ú
 
*
Ú
Ú
 
bz
Ú
Ú
 
-
Ú
Ú
 
az
Ú
Ú
 
*
Ú
Ú
 
by
Ú
Ú
 !
;
Ú
Ú
! "
y
Û
Û
 
=
Û
Û
 
az
Û
Û
 
*
Û
Û
 
bx
Û
Û
 
-
Û
Û
 
ax
Û
Û
 
*
Û
Û
 
bz
Û
Û
 !
;
Û
Û
! "
z
Ù
Ù
 
=
Ù
Ù
 
ax
Ù
Ù
 
*
Ù
Ù
 
by
Ù
Ù
 
-
Ù
Ù
 
ay
Ù
Ù
 
*
Ù
Ù
 
bx
Ù
Ù
 !
;
Ù
Ù
! "
}
ı
ı
 	
internal
˝
˝
 
static
˝
˝
 
void
˝
˝
 
Subtract
˝
˝
 %
(
˝
˝
% &
Vector3
˝
˝
& -
a
˝
˝
. /
,
˝
˝
/ 0
Vector3
˝
˝
1 8
b
˝
˝
9 :
,
˝
˝
: ;
ref
˝
˝
< ?
Vector3
˝
˝
@ G
res
˝
˝
H K
)
˝
˝
K L
{
˛
˛
 	
res
ˇ
ˇ
 
.
ˇ
ˇ
 
x
ˇ
ˇ
 
=
ˇ
ˇ
 
b
ˇ
ˇ
 
.
ˇ
ˇ
 
x
ˇ
ˇ
 
-
ˇ
ˇ
 
a
ˇ
ˇ
 
.
ˇ
ˇ
 
x
ˇ
ˇ
 
;
ˇ
ˇ
 
res
ÄÄ 
.
ÄÄ 
y
ÄÄ 
=
ÄÄ 
b
ÄÄ 
.
ÄÄ 
y
ÄÄ 
-
ÄÄ 
a
ÄÄ 
.
ÄÄ 
y
ÄÄ 
;
ÄÄ 
res
ÅÅ 
.
ÅÅ 
z
ÅÅ 
=
ÅÅ 
b
ÅÅ 
.
ÅÅ 
z
ÅÅ 
-
ÅÅ 
a
ÅÅ 
.
ÅÅ 
z
ÅÅ 
;
ÅÅ 
}
ÇÇ 	
internal
ÑÑ 
static
ÑÑ 
int
ÑÑ 
Min
ÑÑ 
(
ÑÑ  
int
ÑÑ  #
a
ÑÑ$ %
,
ÑÑ% &
int
ÑÑ' *
b
ÑÑ+ ,
)
ÑÑ, -
{
ÖÖ 	
return
ÜÜ 
a
ÜÜ 
<
ÜÜ 
b
ÜÜ 
?
ÜÜ 
a
ÜÜ 
:
ÜÜ 
b
ÜÜ  
;
ÜÜ  !
}
áá 	
internal
ââ 
static
ââ 
int
ââ 
Max
ââ 
(
ââ  
int
ââ  #
a
ââ$ %
,
ââ% &
int
ââ' *
b
ââ+ ,
)
ââ, -
{
ää 	
return
ãã 
a
ãã 
>
ãã 
b
ãã 
?
ãã 
a
ãã 
:
ãã 
b
ãã  
;
ãã  !
}
åå 	
internal
éé 
static
éé 
bool
éé 
IsNumber
éé %
(
éé% &
float
éé& +
value
éé, 1
)
éé1 2
{
èè 	
return
êê 
!
êê 
(
êê 
float
êê 
.
êê 

IsInfinity
êê %
(
êê% &
value
êê& +
)
êê+ ,
||
êê- /
float
êê0 5
.
êê5 6
IsNaN
êê6 ;
(
êê; <
value
êê< A
)
êêA B
)
êêB C
;
êêC D
}
ëë 	
internal
ìì 
static
ìì 
bool
ìì 
IsNumber
ìì %
(
ìì% &
Vector2
ìì& -
value
ìì. 3
)
ìì3 4
{
îî 	
return
ïï 
IsNumber
ïï 
(
ïï 
value
ïï !
.
ïï! "
x
ïï" #
)
ïï# $
&&
ïï% '
IsNumber
ïï( 0
(
ïï0 1
value
ïï1 6
.
ïï6 7
y
ïï7 8
)
ïï8 9
;
ïï9 :
}
ññ 	
internal
òò 
static
òò 
bool
òò 
IsNumber
òò %
(
òò% &
Vector3
òò& -
value
òò. 3
)
òò3 4
{
ôô 	
return
öö 
IsNumber
öö 
(
öö 
value
öö !
.
öö! "
x
öö" #
)
öö# $
&&
öö% '
IsNumber
öö( 0
(
öö0 1
value
öö1 6
.
öö6 7
y
öö7 8
)
öö8 9
&&
öö: <
IsNumber
öö= E
(
ööE F
value
ööF K
.
ööK L
z
ööL M
)
ööM N
;
ööN O
}
õõ 	
internal
ùù 
static
ùù 
bool
ùù 
IsNumber
ùù %
(
ùù% &
Vector4
ùù& -
value
ùù. 3
)
ùù3 4
{
ûû 	
return
üü 
IsNumber
üü 
(
üü 
value
üü !
.
üü! "
x
üü" #
)
üü# $
&&
üü% '
IsNumber
üü( 0
(
üü0 1
value
üü1 6
.
üü6 7
y
üü7 8
)
üü8 9
&&
üü: <
IsNumber
üü= E
(
üüE F
value
üüF K
.
üüK L
z
üüL M
)
üüM N
&&
üüO Q
IsNumber
üüR Z
(
üüZ [
value
üü[ `
.
üü` a
w
üüa b
)
üüb c
;
üüc d
}
†† 	
internal
¢¢ 
static
¢¢ 
float
¢¢ 
MakeNonZero
¢¢ )
(
¢¢) *
float
¢¢* /
value
¢¢0 5
,
¢¢5 6
float
¢¢7 <
min
¢¢= @
=
¢¢A B
$num
¢¢C I
)
¢¢I J
{
££ 	
if
§§ 
(
§§ 
float
§§ 
.
§§ 
IsNaN
§§ 
(
§§ 
value
§§ !
)
§§! "
||
§§# %
float
§§& +
.
§§+ ,

IsInfinity
§§, 6
(
§§6 7
value
§§7 <
)
§§< =
||
§§> @
Mathf
§§A F
.
§§F G
Abs
§§G J
(
§§J K
value
§§K P
)
§§P Q
<
§§R S
min
§§T W
)
§§W X
return
•• 
min
•• 
*
•• 
Mathf
•• "
.
••" #
Sign
••# '
(
••' (
value
••( -
)
••- .
;
••. /
return
¶¶ 
value
¶¶ 
;
¶¶ 
}
ßß 	
}
®® 
}©© ˚ì
ÖD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Face.cs
	namespace		 	
UnityEngine		
 
.		 

ProBuilder		  
{

 
[ 
Serializable 
] 
public 

sealed 
class 
Face 
{ 
[ 	 
FormerlySerializedAs	 
( 
$str (
)( )
]) *
[ 	
SerializeField	 
] 
int 
[ 
] 
	m_Indexes 
; 
[ 	
SerializeField	 
] 
[ 	 
FormerlySerializedAs	 
( 
$str /
)/ 0
]0 1
int 
m_SmoothingGroup 
; 
[## 	
SerializeField##	 
]## 
[$$ 	 
FormerlySerializedAs$$	 
($$ 
$str$$ #
)$$# $
]$$$ %
AutoUnwrapSettings%% 
m_Uv%% 
;%%  
[** 	
SerializeField**	 
]** 
[++ 	 
FormerlySerializedAs++	 
(++ 
$str++ $
)++$ %
]++% &
Material,, 

m_Material,, 
;,, 
[.. 	
SerializeField..	 
].. 
int// 
m_SubmeshIndex// 
;// 
[22 	
SerializeField22	 
]22 
[33 	 
FormerlySerializedAs33	 
(33 
$str33 (
)33( )
]33) *
bool44 

m_ManualUV44 
;44 
public99 
bool99 
manualUV99 
{:: 	
get;; 
{;; 
return;; 

m_ManualUV;; #
;;;# $
};;% &
set<< 
{<< 

m_ManualUV<< 
=<< 
value<< $
;<<$ %
}<<& '
}== 	
[BB 	
SerializeFieldBB	 
]BB 
internalCC 
intCC 
elementGroupCC !
;CC! "
[FF 	
SerializeFieldFF	 
]FF 
intGG 
m_TextureGroupGG 
;GG 
publicLL 
intLL 
textureGroupLL 
{MM 	
getNN 
{NN 
returnNN 
m_TextureGroupNN '
;NN' (
}NN( )
setOO 
{OO 
m_TextureGroupOO  
=OO! "
valueOO# (
;OO( )
}OO* +
}PP 	
internalUU 
intUU 
[UU 
]UU 
indexesInternalUU &
{VV 	
getWW 
{WW 
returnWW 
	m_IndexesWW "
;WW" #
}WW$ %
setXX 
{YY 
ifZZ 
(ZZ 
	m_IndexesZZ 
==ZZ  
nullZZ! %
)ZZ% &
throw[[ 
new[[ !
ArgumentNullException[[ 3
([[3 4
$str[[4 ;
)[[; <
;[[< =
if\\ 
(\\ 
	m_Indexes\\ 
.\\ 
Length\\ $
%\\% &
$num\\' (
!=\\) +
$num\\, -
)\\- .
throw]] 
new]] 
ArgumentException]] /
(]]/ 0
$str]]0 W
)]]W X
;]]X Y
	m_Indexes^^ 
=^^ 
value^^ !
;^^! "
InvalidateCache__ 
(__  
)__  !
;__! "
}`` 
}aa 	
publicff 
ReadOnlyCollectionff !
<ff! "
intff" %
>ff% &
indexesff' .
{gg 	
gethh 
{hh 
returnhh 
newhh 
ReadOnlyCollectionhh /
<hh/ 0
inthh0 3
>hh3 4
(hh4 5
	m_Indexeshh5 >
)hh> ?
;hh? @
}hhA B
}ii 	
publicoo 
voidoo 

SetIndexesoo 
(oo 
IEnumerableoo *
<oo* +
intoo+ .
>oo. /
indicesoo0 7
)oo7 8
{pp 	
ifqq 
(qq 
indicesqq 
==qq 
nullqq 
)qq  
throwrr 
newrr !
ArgumentNullExceptionrr /
(rr/ 0
$strrr0 9
)rr9 :
;rr: ;
varss 
arrayss 
=ss 
indicesss 
.ss  
ToArrayss  '
(ss' (
)ss( )
;ss) *
inttt 
lentt 
=tt 
arraytt 
.tt 
Lengthtt "
;tt" #
ifuu 
(uu 
lenuu 
%uu 
$numuu 
!=uu 
$numuu 
)uu 
throwvv 
newvv 
ArgumentExceptionvv +
(vv+ ,
$strvv, S
)vvS T
;vvT U
	m_Indexesww 
=ww 
arrayww 
;ww 
InvalidateCachexx 
(xx 
)xx 
;xx 
}yy 	
[{{ 	
NonSerialized{{	 
]{{ 
int|| 
[|| 
]|| 
m_DistinctIndexes|| 
;||  
[~~ 	
NonSerialized~~	 
]~~ 
Edge 
[ 
] 
m_Edges 
; 
internal
ÑÑ 
int
ÑÑ 
[
ÑÑ 
]
ÑÑ %
distinctIndexesInternal
ÑÑ .
{
ÖÖ 	
get
ÜÜ 
{
ÜÜ 
return
ÜÜ 
m_DistinctIndexes
ÜÜ *
==
ÜÜ+ -
null
ÜÜ. 2
?
ÜÜ3 4"
CacheDistinctIndexes
ÜÜ5 I
(
ÜÜI J
)
ÜÜJ K
:
ÜÜL M
m_DistinctIndexes
ÜÜN _
;
ÜÜ_ `
}
ÜÜa b
}
áá 	
public
åå  
ReadOnlyCollection
åå !
<
åå! "
int
åå" %
>
åå% &
distinctIndexes
åå' 6
{
çç 	
get
éé 
{
éé 
return
éé 
new
éé  
ReadOnlyCollection
éé /
<
éé/ 0
int
éé0 3
>
éé3 4
(
éé4 5%
distinctIndexesInternal
éé5 L
)
ééL M
;
ééM N
}
ééO P
}
èè 	
internal
ëë 
Edge
ëë 
[
ëë 
]
ëë 
edgesInternal
ëë %
{
íí 	
get
ìì 
{
ìì 
return
ìì 
m_Edges
ìì  
==
ìì! #
null
ìì$ (
?
ìì) *

CacheEdges
ìì+ 5
(
ìì5 6
)
ìì6 7
:
ìì8 9
m_Edges
ìì: A
;
ììA B
}
ììC D
}
îî 	
public
ôô  
ReadOnlyCollection
ôô !
<
ôô! "
Edge
ôô" &
>
ôô& '
edges
ôô( -
{
öö 	
get
õõ 
{
õõ 
return
õõ 
new
õõ  
ReadOnlyCollection
õõ /
<
õõ/ 0
Edge
õõ0 4
>
õõ4 5
(
õõ5 6
edgesInternal
õõ6 C
)
õõC D
;
õõD E
}
õõF G
}
úú 	
public
°° 
int
°° 
smoothingGroup
°° !
{
¢¢ 	
get
££ 
{
££ 
return
££ 
m_SmoothingGroup
££ )
;
££) *
}
££+ ,
set
§§ 
{
§§ 
m_SmoothingGroup
§§ "
=
§§# $
value
§§% *
;
§§* +
}
§§, -
}
•• 	
[
™™ 	
Obsolete
™™	 
(
™™ 
$str
™™ Q
)
™™Q R
]
™™R S
public
´´ 
Material
´´ 
material
´´  
{
¨¨ 	
get
≠≠ 
{
≠≠ 
return
≠≠ 

m_Material
≠≠ #
;
≠≠# $
}
≠≠% &
set
ÆÆ 
{
ÆÆ 

m_Material
ÆÆ 
=
ÆÆ 
value
ÆÆ $
;
ÆÆ$ %
}
ÆÆ& '
}
ØØ 	
public
±± 
int
±± 
submeshIndex
±± 
{
≤≤ 	
get
≥≥ 
{
≥≥ 
return
≥≥ 
m_SubmeshIndex
≥≥ '
;
≥≥' (
}
≥≥) *
set
¥¥ 
{
¥¥ 
m_SubmeshIndex
¥¥  
=
¥¥! "
value
¥¥# (
;
¥¥( )
}
¥¥* +
}
µµ 	
public
∫∫  
AutoUnwrapSettings
∫∫ !
uv
∫∫" $
{
ªª 	
get
ºº 
{
ºº 
return
ºº 
m_Uv
ºº 
;
ºº 
}
ºº  
set
ΩΩ 
{
ΩΩ 
m_Uv
ΩΩ 
=
ΩΩ 
value
ΩΩ 
;
ΩΩ 
}
ΩΩ  !
}
ææ 	
public
ƒƒ 
int
ƒƒ 
this
ƒƒ 
[
ƒƒ 
int
ƒƒ 
i
ƒƒ 
]
ƒƒ 
{
≈≈ 	
get
∆∆ 
{
∆∆ 
return
∆∆ 
indexesInternal
∆∆ (
[
∆∆( )
i
∆∆) *
]
∆∆* +
;
∆∆+ ,
}
∆∆- .
}
«« 	
public
ÃÃ 
Face
ÃÃ 
(
ÃÃ 
)
ÃÃ 
{
ÕÕ 	
m_SubmeshIndex
ŒŒ 
=
ŒŒ 
$num
ŒŒ 
;
ŒŒ 
}
œœ 	
public
’’ 
Face
’’ 
(
’’ 
IEnumerable
’’ 
<
’’  
int
’’  #
>
’’# $
indices
’’% ,
)
’’, -
{
÷÷ 	

SetIndexes
◊◊ 
(
◊◊ 
indices
◊◊ 
)
◊◊ 
;
◊◊  
m_Uv
ÿÿ 
=
ÿÿ  
AutoUnwrapSettings
ÿÿ %
.
ÿÿ% &
tile
ÿÿ& *
;
ÿÿ* +

m_Material
ŸŸ 
=
ŸŸ 
BuiltinMaterials
ŸŸ )
.
ŸŸ) *
defaultMaterial
ŸŸ* 9
;
ŸŸ9 :
m_SmoothingGroup
⁄⁄ 
=
⁄⁄ 
	Smoothing
⁄⁄ (
.
⁄⁄( ) 
smoothingGroupNone
⁄⁄) ;
;
⁄⁄; <
m_SubmeshIndex
€€ 
=
€€ 
$num
€€ 
;
€€ 
textureGroup
‹‹ 
=
‹‹ 
-
‹‹ 
$num
‹‹ 
;
‹‹ 
elementGroup
›› 
=
›› 
$num
›› 
;
›› 
}
ﬁﬁ 	
[
‡‡ 	
Obsolete
‡‡	 
(
‡‡ 
$str
‡‡ U
)
‡‡U V
]
‡‡V W
internal
·· 
Face
·· 
(
·· 
int
·· 
[
·· 
]
·· 
	triangles
·· %
,
··% &
Material
··' /
m
··0 1
,
··1 2 
AutoUnwrapSettings
··3 E
u
··F G
,
··G H
int
··I L
	smoothing
··M V
,
··V W
int
··X [
texture
··\ c
,
··c d
int
··e h
element
··i p
,
··p q
bool
··r v
	manualUVs··w Ä
)··Ä Å
{
‚‚ 	

SetIndexes
„„ 
(
„„ 
	triangles
„„  
)
„„  !
;
„„! "
m_Uv
‰‰ 
=
‰‰ 
new
‰‰  
AutoUnwrapSettings
‰‰ )
(
‰‰) *
u
‰‰* +
)
‰‰+ ,
;
‰‰, -

m_Material
ÂÂ 
=
ÂÂ 
m
ÂÂ 
;
ÂÂ 
m_SmoothingGroup
ÊÊ 
=
ÊÊ 
	smoothing
ÊÊ (
;
ÊÊ( )
textureGroup
ÁÁ 
=
ÁÁ 
texture
ÁÁ "
;
ÁÁ" #
elementGroup
ËË 
=
ËË 
element
ËË "
;
ËË" #
manualUV
ÈÈ 
=
ÈÈ 
	manualUVs
ÈÈ  
;
ÈÈ  !
m_SubmeshIndex
ÍÍ 
=
ÍÍ 
$num
ÍÍ 
;
ÍÍ 
}
ÎÎ 	
internal
ÌÌ 
Face
ÌÌ 
(
ÌÌ 
IEnumerable
ÌÌ !
<
ÌÌ! "
int
ÌÌ" %
>
ÌÌ% &
	triangles
ÌÌ' 0
,
ÌÌ0 1
int
ÌÌ2 5
submeshIndex
ÌÌ6 B
,
ÌÌB C 
AutoUnwrapSettings
ÌÌD V
u
ÌÌW X
,
ÌÌX Y
int
ÌÌZ ]
	smoothing
ÌÌ^ g
,
ÌÌg h
int
ÌÌi l
texture
ÌÌm t
,
ÌÌt u
int
ÌÌv y
elementÌÌz Å
,ÌÌÅ Ç
boolÌÌÉ á
	manualUVsÌÌà ë
)ÌÌë í
{
ÓÓ 	

SetIndexes
ÔÔ 
(
ÔÔ 
	triangles
ÔÔ  
)
ÔÔ  !
;
ÔÔ! "
m_Uv
 
=
 
new
  
AutoUnwrapSettings
 )
(
) *
u
* +
)
+ ,
;
, -
m_SmoothingGroup
ÒÒ 
=
ÒÒ 
	smoothing
ÒÒ (
;
ÒÒ( )
textureGroup
ÚÚ 
=
ÚÚ 
texture
ÚÚ "
;
ÚÚ" #
elementGroup
ÛÛ 
=
ÛÛ 
element
ÛÛ "
;
ÛÛ" #
manualUV
ÙÙ 
=
ÙÙ 
	manualUVs
ÙÙ  
;
ÙÙ  !
m_SubmeshIndex
ıı 
=
ıı 
submeshIndex
ıı )
;
ıı) *
}
ˆˆ 	
public
¸¸ 
Face
¸¸ 
(
¸¸ 
Face
¸¸ 
other
¸¸ 
)
¸¸ 
{
˝˝ 	
CopyFrom
˛˛ 
(
˛˛ 
other
˛˛ 
)
˛˛ 
;
˛˛ 
}
ˇˇ 	
public
ÖÖ 
void
ÖÖ 
CopyFrom
ÖÖ 
(
ÖÖ 
Face
ÖÖ !
other
ÖÖ" '
)
ÖÖ' (
{
ÜÜ 	
if
áá 
(
áá 
other
áá 
==
áá 
null
áá 
)
áá 
throw
àà 
new
àà #
ArgumentNullException
àà /
(
àà/ 0
$str
àà0 7
)
àà7 8
;
àà8 9
int
ää 
len
ää 
=
ää 
other
ää 
.
ää 
indexesInternal
ää +
.
ää+ ,
Length
ää, 2
;
ää2 3
	m_Indexes
ãã 
=
ãã 
new
ãã 
int
ãã 
[
ãã  
len
ãã  #
]
ãã# $
;
ãã$ %
Array
åå 
.
åå 
Copy
åå 
(
åå 
other
åå 
.
åå 
indexesInternal
åå ,
,
åå, -
	m_Indexes
åå. 7
,
åå7 8
len
åå9 <
)
åå< =
;
åå= >
m_SmoothingGroup
éé 
=
éé 
other
éé $
.
éé$ %
smoothingGroup
éé% 3
;
éé3 4
m_Uv
èè 
=
èè 
new
èè  
AutoUnwrapSettings
èè )
(
èè) *
other
èè* /
.
èè/ 0
uv
èè0 2
)
èè2 3
;
èè3 4

m_Material
ëë 
=
ëë 
other
ëë 
.
ëë 
material
ëë '
;
ëë' (
manualUV
ìì 
=
ìì 
other
ìì 
.
ìì 
manualUV
ìì %
;
ìì% &
m_TextureGroup
îî 
=
îî 
other
îî "
.
îî" #
textureGroup
îî# /
;
îî/ 0
elementGroup
ïï 
=
ïï 
other
ïï  
.
ïï  !
elementGroup
ïï! -
;
ïï- .
m_SubmeshIndex
ññ 
=
ññ 
other
ññ "
.
ññ" #
m_SubmeshIndex
ññ# 1
;
ññ1 2
InvalidateCache
óó 
(
óó 
)
óó 
;
óó 
}
òò 	
internal
öö 
void
öö 
InvalidateCache
öö %
(
öö% &
)
öö& '
{
õõ 	
m_Edges
úú 
=
úú 
null
úú 
;
úú 
m_DistinctIndexes
ùù 
=
ùù 
null
ùù  $
;
ùù$ %
}
ûû 	
Edge
†† 
[
†† 
]
†† 

CacheEdges
†† 
(
†† 
)
†† 
{
°° 	
if
¢¢ 
(
¢¢ 
	m_Indexes
¢¢ 
==
¢¢ 
null
¢¢ !
)
¢¢! "
return
££ 
null
££ 
;
££ 
HashSet
•• 
<
•• 
Edge
•• 
>
•• 
dist
•• 
=
••  
new
••! $
HashSet
••% ,
<
••, -
Edge
••- 1
>
••1 2
(
••2 3
)
••3 4
;
••4 5
List
¶¶ 
<
¶¶ 
Edge
¶¶ 
>
¶¶ 
dup
¶¶ 
=
¶¶ 
new
¶¶  
List
¶¶! %
<
¶¶% &
Edge
¶¶& *
>
¶¶* +
(
¶¶+ ,
)
¶¶, -
;
¶¶- .
for
®® 
(
®® 
int
®® 
i
®® 
=
®® 
$num
®® 
;
®® 
i
®® 
<
®® 
indexesInternal
®®  /
.
®®/ 0
Length
®®0 6
;
®®6 7
i
®®8 9
+=
®®: <
$num
®®= >
)
®®> ?
{
©© 
Edge
™™ 
a
™™ 
=
™™ 
new
™™ 
Edge
™™ !
(
™™! "
indexesInternal
™™" 1
[
™™1 2
i
™™2 3
+
™™4 5
$num
™™6 7
]
™™7 8
,
™™8 9
indexesInternal
™™: I
[
™™I J
i
™™J K
+
™™L M
$num
™™N O
]
™™O P
)
™™P Q
;
™™Q R
Edge
´´ 
b
´´ 
=
´´ 
new
´´ 
Edge
´´ !
(
´´! "
indexesInternal
´´" 1
[
´´1 2
i
´´2 3
+
´´4 5
$num
´´6 7
]
´´7 8
,
´´8 9
indexesInternal
´´: I
[
´´I J
i
´´J K
+
´´L M
$num
´´N O
]
´´O P
)
´´P Q
;
´´Q R
Edge
¨¨ 
c
¨¨ 
=
¨¨ 
new
¨¨ 
Edge
¨¨ !
(
¨¨! "
indexesInternal
¨¨" 1
[
¨¨1 2
i
¨¨2 3
+
¨¨4 5
$num
¨¨6 7
]
¨¨7 8
,
¨¨8 9
indexesInternal
¨¨: I
[
¨¨I J
i
¨¨J K
+
¨¨L M
$num
¨¨N O
]
¨¨O P
)
¨¨P Q
;
¨¨Q R
if
ÆÆ 
(
ÆÆ 
!
ÆÆ 
dist
ÆÆ 
.
ÆÆ 
Add
ÆÆ 
(
ÆÆ 
a
ÆÆ 
)
ÆÆ  
)
ÆÆ  !
dup
ÆÆ" %
.
ÆÆ% &
Add
ÆÆ& )
(
ÆÆ) *
a
ÆÆ* +
)
ÆÆ+ ,
;
ÆÆ, -
if
ØØ 
(
ØØ 
!
ØØ 
dist
ØØ 
.
ØØ 
Add
ØØ 
(
ØØ 
b
ØØ 
)
ØØ  
)
ØØ  !
dup
ØØ" %
.
ØØ% &
Add
ØØ& )
(
ØØ) *
b
ØØ* +
)
ØØ+ ,
;
ØØ, -
if
∞∞ 
(
∞∞ 
!
∞∞ 
dist
∞∞ 
.
∞∞ 
Add
∞∞ 
(
∞∞ 
c
∞∞ 
)
∞∞  
)
∞∞  !
dup
∞∞" %
.
∞∞% &
Add
∞∞& )
(
∞∞) *
c
∞∞* +
)
∞∞+ ,
;
∞∞, -
}
±± 
dist
≥≥ 
.
≥≥ 

ExceptWith
≥≥ 
(
≥≥ 
dup
≥≥ 
)
≥≥  
;
≥≥  !
m_Edges
¥¥ 
=
¥¥ 
dist
¥¥ 
.
¥¥ 
ToArray
¥¥ "
(
¥¥" #
)
¥¥# $
;
¥¥$ %
return
µµ 
m_Edges
µµ 
;
µµ 
}
∂∂ 	
int
∏∏ 
[
∏∏ 
]
∏∏ "
CacheDistinctIndexes
∏∏ "
(
∏∏" #
)
∏∏# $
{
ππ 	
if
∫∫ 
(
∫∫ 
	m_Indexes
∫∫ 
==
∫∫ 
null
∫∫ !
)
∫∫! "
return
ªª 
null
ªª 
;
ªª 
m_DistinctIndexes
ºº 
=
ºº 
	m_Indexes
ºº  )
.
ºº) *
Distinct
ºº* 2
(
ºº2 3
)
ºº3 4
.
ºº4 5
ToArray
ºº5 <
(
ºº< =
)
ºº= >
;
ºº> ?
return
ΩΩ %
distinctIndexesInternal
ΩΩ *
;
ΩΩ* +
}
ææ 	
public
«« 
bool
«« 
Contains
«« 
(
«« 
int
««  
a
««! "
,
««" #
int
««$ '
b
««( )
,
««) *
int
««+ .
c
««/ 0
)
««0 1
{
»» 	
for
…… 
(
…… 
int
…… 
i
…… 
=
…… 
$num
…… 
,
…… 
cnt
…… 
=
……  !
indexesInternal
……" 1
.
……1 2
Length
……2 8
;
……8 9
i
……: ;
<
……< =
cnt
……> A
;
……A B
i
……C D
+=
……E G
$num
……H I
)
……I J
{
   
if
ÀÀ 
(
ÀÀ 
a
ÀÀ 
==
ÀÀ 
indexesInternal
ÀÀ (
[
ÀÀ( )
i
ÀÀ) *
+
ÀÀ+ ,
$num
ÀÀ- .
]
ÀÀ. /
&&
ÃÃ 
b
ÃÃ 
==
ÃÃ 
indexesInternal
ÃÃ +
[
ÃÃ+ ,
i
ÃÃ, -
+
ÃÃ. /
$num
ÃÃ0 1
]
ÃÃ1 2
&&
ÕÕ 
c
ÕÕ 
==
ÕÕ 
indexesInternal
ÕÕ +
[
ÕÕ+ ,
i
ÕÕ, -
+
ÕÕ. /
$num
ÕÕ0 1
]
ÕÕ1 2
)
ÕÕ2 3
return
ŒŒ 
true
ŒŒ 
;
ŒŒ  
}
œœ 
return
—— 
false
—— 
;
—— 
}
““ 	
public
ÿÿ 
bool
ÿÿ 
IsQuad
ÿÿ 
(
ÿÿ 
)
ÿÿ 
{
ŸŸ 	
return
⁄⁄ 
edgesInternal
⁄⁄  
!=
⁄⁄! #
null
⁄⁄$ (
&&
⁄⁄) +
edgesInternal
⁄⁄, 9
.
⁄⁄9 :
Length
⁄⁄: @
==
⁄⁄A C
$num
⁄⁄D E
;
⁄⁄E F
}
€€ 	
public
·· 
int
·· 
[
·· 
]
·· 
ToQuad
·· 
(
·· 
)
·· 
{
‚‚ 	
if
„„ 
(
„„ 
!
„„ 
IsQuad
„„ 
(
„„ 
)
„„ 
)
„„ 
throw
‰‰ 
new
‰‰ '
InvalidOperationException
‰‰ 3
(
‰‰3 4
$str‰‰4 Å
)‰‰Å Ç
;‰‰Ç É
int
ÊÊ 
[
ÊÊ 
]
ÊÊ 
quad
ÊÊ 
=
ÊÊ 
new
ÊÊ 
int
ÊÊ  
[
ÊÊ  !
$num
ÊÊ! "
]
ÊÊ" #
{
ÊÊ$ %
edgesInternal
ÊÊ& 3
[
ÊÊ3 4
$num
ÊÊ4 5
]
ÊÊ5 6
.
ÊÊ6 7
a
ÊÊ7 8
,
ÊÊ8 9
edgesInternal
ÊÊ: G
[
ÊÊG H
$num
ÊÊH I
]
ÊÊI J
.
ÊÊJ K
b
ÊÊK L
,
ÊÊL M
-
ÊÊN O
$num
ÊÊO P
,
ÊÊP Q
-
ÊÊR S
$num
ÊÊS T
}
ÊÊU V
;
ÊÊV W
if
ËË 
(
ËË 
edgesInternal
ËË 
[
ËË 
$num
ËË 
]
ËË  
.
ËË  !
a
ËË! "
==
ËË# %
quad
ËË& *
[
ËË* +
$num
ËË+ ,
]
ËË, -
)
ËË- .
quad
ÈÈ 
[
ÈÈ 
$num
ÈÈ 
]
ÈÈ 
=
ÈÈ 
edgesInternal
ÈÈ '
[
ÈÈ' (
$num
ÈÈ( )
]
ÈÈ) *
.
ÈÈ* +
b
ÈÈ+ ,
;
ÈÈ, -
else
ÍÍ 
if
ÍÍ 
(
ÍÍ 
edgesInternal
ÍÍ "
[
ÍÍ" #
$num
ÍÍ# $
]
ÍÍ$ %
.
ÍÍ% &
a
ÍÍ& '
==
ÍÍ( *
quad
ÍÍ+ /
[
ÍÍ/ 0
$num
ÍÍ0 1
]
ÍÍ1 2
)
ÍÍ2 3
quad
ÎÎ 
[
ÎÎ 
$num
ÎÎ 
]
ÎÎ 
=
ÎÎ 
edgesInternal
ÎÎ '
[
ÎÎ' (
$num
ÎÎ( )
]
ÎÎ) *
.
ÎÎ* +
b
ÎÎ+ ,
;
ÎÎ, -
else
ÏÏ 
if
ÏÏ 
(
ÏÏ 
edgesInternal
ÏÏ "
[
ÏÏ" #
$num
ÏÏ# $
]
ÏÏ$ %
.
ÏÏ% &
a
ÏÏ& '
==
ÏÏ( *
quad
ÏÏ+ /
[
ÏÏ/ 0
$num
ÏÏ0 1
]
ÏÏ1 2
)
ÏÏ2 3
quad
ÌÌ 
[
ÌÌ 
$num
ÌÌ 
]
ÌÌ 
=
ÌÌ 
edgesInternal
ÌÌ '
[
ÌÌ' (
$num
ÌÌ( )
]
ÌÌ) *
.
ÌÌ* +
b
ÌÌ+ ,
;
ÌÌ, -
if
ÔÔ 
(
ÔÔ 
edgesInternal
ÔÔ 
[
ÔÔ 
$num
ÔÔ 
]
ÔÔ  
.
ÔÔ  !
a
ÔÔ! "
==
ÔÔ# %
quad
ÔÔ& *
[
ÔÔ* +
$num
ÔÔ+ ,
]
ÔÔ, -
)
ÔÔ- .
quad
 
[
 
$num
 
]
 
=
 
edgesInternal
 '
[
' (
$num
( )
]
) *
.
* +
b
+ ,
;
, -
else
ÒÒ 
if
ÒÒ 
(
ÒÒ 
edgesInternal
ÒÒ "
[
ÒÒ" #
$num
ÒÒ# $
]
ÒÒ$ %
.
ÒÒ% &
a
ÒÒ& '
==
ÒÒ( *
quad
ÒÒ+ /
[
ÒÒ/ 0
$num
ÒÒ0 1
]
ÒÒ1 2
)
ÒÒ2 3
quad
ÚÚ 
[
ÚÚ 
$num
ÚÚ 
]
ÚÚ 
=
ÚÚ 
edgesInternal
ÚÚ '
[
ÚÚ' (
$num
ÚÚ( )
]
ÚÚ) *
.
ÚÚ* +
b
ÚÚ+ ,
;
ÚÚ, -
else
ÛÛ 
if
ÛÛ 
(
ÛÛ 
edgesInternal
ÛÛ "
[
ÛÛ" #
$num
ÛÛ# $
]
ÛÛ$ %
.
ÛÛ% &
a
ÛÛ& '
==
ÛÛ( *
quad
ÛÛ+ /
[
ÛÛ/ 0
$num
ÛÛ0 1
]
ÛÛ1 2
)
ÛÛ2 3
quad
ÙÙ 
[
ÙÙ 
$num
ÙÙ 
]
ÙÙ 
=
ÙÙ 
edgesInternal
ÙÙ '
[
ÙÙ' (
$num
ÙÙ( )
]
ÙÙ) *
.
ÙÙ* +
b
ÙÙ+ ,
;
ÙÙ, -
return
ˆˆ 
quad
ˆˆ 
;
ˆˆ 
}
˜˜ 	
public
˘˘ 
override
˘˘ 
string
˘˘ 
ToString
˘˘ '
(
˘˘' (
)
˘˘( )
{
˙˙ 	
System
˚˚ 
.
˚˚ 
Text
˚˚ 
.
˚˚ 
StringBuilder
˚˚ %
sb
˚˚& (
=
˚˚) *
new
˚˚+ .
System
˚˚/ 5
.
˚˚5 6
Text
˚˚6 :
.
˚˚: ;
StringBuilder
˚˚; H
(
˚˚H I
)
˚˚I J
;
˚˚J K
for
˝˝ 
(
˝˝ 
int
˝˝ 
i
˝˝ 
=
˝˝ 
$num
˝˝ 
;
˝˝ 
i
˝˝ 
<
˝˝ 
indexesInternal
˝˝  /
.
˝˝/ 0
Length
˝˝0 6
;
˝˝6 7
i
˝˝8 9
+=
˝˝: <
$num
˝˝= >
)
˝˝> ?
{
˛˛ 
sb
ˇˇ 
.
ˇˇ 
Append
ˇˇ 
(
ˇˇ 
$str
ˇˇ 
)
ˇˇ 
;
ˇˇ 
sb
ÄÄ 
.
ÄÄ 
Append
ÄÄ 
(
ÄÄ 
indexesInternal
ÄÄ )
[
ÄÄ) *
i
ÄÄ* +
]
ÄÄ+ ,
)
ÄÄ, -
;
ÄÄ- .
sb
ÅÅ 
.
ÅÅ 
Append
ÅÅ 
(
ÅÅ 
$str
ÅÅ 
)
ÅÅ 
;
ÅÅ  
sb
ÇÇ 
.
ÇÇ 
Append
ÇÇ 
(
ÇÇ 
indexesInternal
ÇÇ )
[
ÇÇ) *
i
ÇÇ* +
+
ÇÇ, -
$num
ÇÇ. /
]
ÇÇ/ 0
)
ÇÇ0 1
;
ÇÇ1 2
sb
ÉÉ 
.
ÉÉ 
Append
ÉÉ 
(
ÉÉ 
$str
ÉÉ 
)
ÉÉ 
;
ÉÉ  
sb
ÑÑ 
.
ÑÑ 
Append
ÑÑ 
(
ÑÑ 
indexesInternal
ÑÑ )
[
ÑÑ) *
i
ÑÑ* +
+
ÑÑ, -
$num
ÑÑ. /
]
ÑÑ/ 0
)
ÑÑ0 1
;
ÑÑ1 2
sb
ÖÖ 
.
ÖÖ 
Append
ÖÖ 
(
ÖÖ 
$str
ÖÖ 
)
ÖÖ 
;
ÖÖ 
if
áá 
(
áá 
i
áá 
<
áá 
indexesInternal
áá '
.
áá' (
Length
áá( .
-
áá/ 0
$num
áá1 2
)
áá2 3
sb
àà 
.
àà 
Append
àà 
(
àà 
$str
àà "
)
àà" #
;
àà# $
}
ââ 
return
ãã 
sb
ãã 
.
ãã 
ToString
ãã 
(
ãã 
)
ãã  
;
ãã  !
}
åå 	
public
íí 
void
íí 
ShiftIndexes
íí  
(
íí  !
int
íí! $
offset
íí% +
)
íí+ ,
{
ìì 	
for
îî 
(
îî 
int
îî 
i
îî 
=
îî 
$num
îî 
,
îî 
c
îî 
=
îî 
	m_Indexes
îî  )
.
îî) *
Length
îî* 0
;
îî0 1
i
îî2 3
<
îî4 5
c
îî6 7
;
îî7 8
i
îî9 :
++
îî: <
)
îî< =
	m_Indexes
ïï 
[
ïï 
i
ïï 
]
ïï 
+=
ïï 
offset
ïï  &
;
ïï& '
InvalidateCache
óó 
(
óó 
)
óó 
;
óó 
}
òò 	
int
ûû  
SmallestIndexValue
ûû 
(
ûû 
)
ûû  
{
üü 	
int
†† 
smallest
†† 
=
†† 
	m_Indexes
†† $
[
††$ %
$num
††% &
]
††& '
;
††' (
for
¢¢ 
(
¢¢ 
int
¢¢ 
i
¢¢ 
=
¢¢ 
$num
¢¢ 
;
¢¢ 
i
¢¢ 
<
¢¢ 
	m_Indexes
¢¢  )
.
¢¢) *
Length
¢¢* 0
;
¢¢0 1
i
¢¢2 3
++
¢¢3 5
)
¢¢5 6
{
££ 
if
§§ 
(
§§ 
	m_Indexes
§§ 
[
§§ 
i
§§ 
]
§§  
<
§§! "
smallest
§§# +
)
§§+ ,
smallest
•• 
=
•• 
	m_Indexes
•• (
[
••( )
i
••) *
]
••* +
;
••+ ,
}
¶¶ 
return
®® 
smallest
®® 
;
®® 
}
©© 	
public
¥¥ 
void
¥¥  
ShiftIndexesToZero
¥¥ &
(
¥¥& '
)
¥¥' (
{
µµ 	
int
∂∂ 
offset
∂∂ 
=
∂∂  
SmallestIndexValue
∂∂ +
(
∂∂+ ,
)
∂∂, -
;
∂∂- .
for
∏∏ 
(
∏∏ 
int
∏∏ 
i
∏∏ 
=
∏∏ 
$num
∏∏ 
;
∏∏ 
i
∏∏ 
<
∏∏ 
	m_Indexes
∏∏  )
.
∏∏) *
Length
∏∏* 0
;
∏∏0 1
i
∏∏2 3
++
∏∏3 5
)
∏∏5 6
	m_Indexes
ππ 
[
ππ 
i
ππ 
]
ππ 
-=
ππ 
offset
ππ  &
;
ππ& '
InvalidateCache
ªª 
(
ªª 
)
ªª 
;
ªª 
}
ºº 	
public
¡¡ 
void
¡¡ 
Reverse
¡¡ 
(
¡¡ 
)
¡¡ 
{
¬¬ 	
Array
√√ 
.
√√ 
Reverse
√√ 
(
√√ 
	m_Indexes
√√ #
)
√√# $
;
√√$ %
InvalidateCache
ƒƒ 
(
ƒƒ 
)
ƒƒ 
;
ƒƒ 
}
≈≈ 	
internal
«« 
static
«« 
void
«« 

GetIndices
«« '
(
««' (
IEnumerable
««( 3
<
««3 4
Face
««4 8
>
««8 9
faces
««: ?
,
««? @
List
««A E
<
««E F
int
««F I
>
««I J
indices
««K R
)
««R S
{
»» 	
indices
…… 
.
…… 
Clear
…… 
(
…… 
)
…… 
;
…… 
foreach
ÀÀ 
(
ÀÀ 
var
ÀÀ 
face
ÀÀ 
in
ÀÀ  
faces
ÀÀ! &
)
ÀÀ& '
{
ÃÃ 
for
ÕÕ 
(
ÕÕ 
int
ÕÕ 
i
ÕÕ 
=
ÕÕ 
$num
ÕÕ 
,
ÕÕ 
c
ÕÕ  !
=
ÕÕ" #
face
ÕÕ$ (
.
ÕÕ( )
indexesInternal
ÕÕ) 8
.
ÕÕ8 9
Length
ÕÕ9 ?
;
ÕÕ? @
i
ÕÕA B
<
ÕÕC D
c
ÕÕE F
;
ÕÕF G
++
ÕÕH J
i
ÕÕJ K
)
ÕÕK L
indices
ŒŒ 
.
ŒŒ 
Add
ŒŒ 
(
ŒŒ  
face
ŒŒ  $
.
ŒŒ$ %
indexesInternal
ŒŒ% 4
[
ŒŒ4 5
i
ŒŒ5 6
]
ŒŒ6 7
)
ŒŒ7 8
;
ŒŒ8 9
}
œœ 
}
–– 	
internal
““ 
static
““ 
void
““  
GetDistinctIndices
““ /
(
““/ 0
IEnumerable
““0 ;
<
““; <
Face
““< @
>
““@ A
faces
““B G
,
““G H
List
““I M
<
““M N
int
““N Q
>
““Q R
indices
““S Z
)
““Z [
{
”” 	
indices
‘‘ 
.
‘‘ 
Clear
‘‘ 
(
‘‘ 
)
‘‘ 
;
‘‘ 
foreach
÷÷ 
(
÷÷ 
var
÷÷ 
face
÷÷ 
in
÷÷  
faces
÷÷! &
)
÷÷& '
{
◊◊ 
for
ÿÿ 
(
ÿÿ 
int
ÿÿ 
i
ÿÿ 
=
ÿÿ 
$num
ÿÿ 
,
ÿÿ 
c
ÿÿ  !
=
ÿÿ" #
face
ÿÿ$ (
.
ÿÿ( )%
distinctIndexesInternal
ÿÿ) @
.
ÿÿ@ A
Length
ÿÿA G
;
ÿÿG H
i
ÿÿI J
<
ÿÿK L
c
ÿÿM N
;
ÿÿN O
++
ÿÿP R
i
ÿÿR S
)
ÿÿS T
indices
ŸŸ 
.
ŸŸ 
Add
ŸŸ 
(
ŸŸ  
face
ŸŸ  $
.
ŸŸ$ %%
distinctIndexesInternal
ŸŸ% <
[
ŸŸ< =
i
ŸŸ= >
]
ŸŸ> ?
)
ŸŸ? @
;
ŸŸ@ A
}
⁄⁄ 
}
€€ 	
internal
‡‡ 
bool
‡‡ 
TryGetNextEdge
‡‡ $
(
‡‡$ %
Edge
‡‡% )
source
‡‡* 0
,
‡‡0 1
int
‡‡2 5
index
‡‡6 ;
,
‡‡; <
ref
‡‡= @
Edge
‡‡A E
nextEdge
‡‡F N
,
‡‡N O
ref
‡‡P S
int
‡‡T W
	nextIndex
‡‡X a
)
‡‡a b
{
·· 	
for
‚‚ 
(
‚‚ 
int
‚‚ 
i
‚‚ 
=
‚‚ 
$num
‚‚ 
,
‚‚ 
c
‚‚ 
=
‚‚ 
edgesInternal
‚‚  -
.
‚‚- .
Length
‚‚. 4
;
‚‚4 5
i
‚‚6 7
<
‚‚8 9
c
‚‚: ;
;
‚‚; <
i
‚‚= >
++
‚‚> @
)
‚‚@ A
{
„„ 
if
‰‰ 
(
‰‰ 
edgesInternal
‰‰ !
[
‰‰! "
i
‰‰" #
]
‰‰# $
==
‰‰% '
source
‰‰( .
)
‰‰. /
continue
ÂÂ 
;
ÂÂ 
nextEdge
ÁÁ 
=
ÁÁ 
edgesInternal
ÁÁ (
[
ÁÁ( )
i
ÁÁ) *
]
ÁÁ* +
;
ÁÁ+ ,
if
ÈÈ 
(
ÈÈ 
nextEdge
ÈÈ 
.
ÈÈ 
Contains
ÈÈ %
(
ÈÈ% &
index
ÈÈ& +
)
ÈÈ+ ,
)
ÈÈ, -
{
ÍÍ 
	nextIndex
ÎÎ 
=
ÎÎ 
nextEdge
ÎÎ  (
.
ÎÎ( )
a
ÎÎ) *
==
ÎÎ+ -
index
ÎÎ. 3
?
ÎÎ4 5
nextEdge
ÎÎ6 >
.
ÎÎ> ?
b
ÎÎ? @
:
ÎÎA B
nextEdge
ÎÎC K
.
ÎÎK L
a
ÎÎL M
;
ÎÎM N
return
ÏÏ 
true
ÏÏ 
;
ÏÏ  
}
ÌÌ 
}
ÓÓ 
return
 
false
 
;
 
}
ÒÒ 	
}
ÚÚ 
}ÛÛ ˚¥
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\Triangulation.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{		 
static 

class 
Triangulation 
{ 
static  
TriangulationContext #"
s_TriangulationContext$ :
;: ;
static  
TriangulationContext # 
triangulationContext$ 8
{ 	
get 
{ 
if 
( "
s_TriangulationContext )
==* ,
null- 1
)1 2"
s_TriangulationContext *
=+ ,
new- 0
DTSweepContext1 ?
(? @
)@ A
;A B
return "
s_TriangulationContext -
;- .
} 
} 	
public## 
static## 
bool## 
SortAndTriangulate## -
(##- .
IList##. 3
<##3 4
Vector2##4 ;
>##; <
points##= C
,##C D
out##E H
List##I M
<##M N
int##N Q
>##Q R
indexes##S Z
,##Z [
bool##\ `
convex##a g
=##h i
false##j o
)##o p
{$$ 	
IList%% 
<%% 
Vector2%% 
>%% 
sorted%% !
=%%" #

Projection%%$ .
.%%. /
Sort%%/ 3
(%%3 4
points%%4 :
,%%: ;

SortMethod%%< F
.%%F G
CounterClockwise%%G W
)%%W X
;%%X Y

Dictionary'' 
<'' 
int'' 
,'' 
int'' 
>''  
map''! $
=''% &
new''' *

Dictionary''+ 5
<''5 6
int''6 9
,''9 :
int''; >
>''> ?
(''? @
)''@ A
;''A B
for)) 
()) 
int)) 
i)) 
=)) 
$num)) 
;)) 
i)) 
<)) 
sorted))  &
.))& '
Count))' ,
;)), -
i)). /
++))/ 1
)))1 2
map** 
.** 
Add** 
(** 
i** 
,** 
points** !
.**! "
IndexOf**" )
(**) *
sorted*** 0
[**0 1
i**1 2
]**2 3
)**3 4
)**4 5
;**5 6
if,, 
(,, 
!,, 
Triangulate,, 
(,, 
sorted,, #
,,,# $
out,,% (
indexes,,) 0
,,,0 1
convex,,2 8
),,8 9
),,9 :
return-- 
false-- 
;-- 
for// 
(// 
int// 
i// 
=// 
$num// 
;// 
i// 
<// 
indexes//  '
.//' (
Count//( -
;//- .
i/// 0
++//0 2
)//2 3
indexes00 
[00 
i00 
]00 
=00 
map00  
[00  !
indexes00! (
[00( )
i00) *
]00* +
]00+ ,
;00, -
return22 
true22 
;22 
}33 	
public== 
static== 
bool== 
TriangulateVertices== .
(==. /
IList==/ 4
<==4 5
Vertex==5 ;
>==; <
vertices=== E
,==E F
out==G J
List==K O
<==O P
int==P S
>==S T
	triangles==U ^
,==^ _
bool==` d
	unordered==e n
===o p
true==q u
,==u v
bool==w {
convex	==| Ç
=
==É Ñ
false
==Ö ä
)
==ä ã
{>> 	
Vector3?? 
[?? 
]?? 

facePoints??  
=??! "
new??# &
Vector3??' .
[??. /
vertices??/ 7
.??7 8
Count??8 =
]??= >
;??> ?
forAA 
(AA 
intAA 
iAA 
=AA 
$numAA 
;AA 
iAA 
<AA 
verticesAA  (
.AA( )
CountAA) .
;AA. /
++AA0 2
iAA2 3
)AA3 4

facePointsBB 
[BB 
iBB 
]BB 
=BB 
verticesBB  (
[BB( )
iBB) *
]BB* +
.BB+ ,
positionBB, 4
;BB4 5
returnDD 
TriangulateVerticesDD &
(DD& '

facePointsDD' 1
,DD1 2
outDD3 6
	trianglesDD7 @
,DD@ A
	unorderedDDB K
,DDK L
convexDDM S
)DDS T
;DDT U
}EE 	
publicPP 
staticPP 
boolPP 
TriangulateVerticesPP .
(PP. /
Vector3PP/ 6
[PP6 7
]PP7 8
verticesPP9 A
,PPA B
outPPC F
ListPPG K
<PPK L
intPPL O
>PPO P
	trianglesPPQ Z
,PPZ [
Vector3PP\ c
[PPc d
]PPd e
[PPe f
]PPf g
holesPPh m
=PPn o
nullPPp t
)PPt u
{QQ 	
	trianglesRR 
=RR 
nullRR 
;RR 
intSS 
vertexCountSS 
=SS 
verticesSS &
==SS' )
nullSS* .
?SS/ 0
$numSS1 2
:SS3 4
verticesSS5 =
.SS= >
LengthSS> D
;SSD E
ifUU 
(UU 
vertexCountUU 
<UU 
$numUU 
)UU  
returnVV 
falseVV 
;VV 
varXX 
normalXX 
=XX 

ProjectionXX #
.XX# $
FindBestPlaneXX$ 1
(XX1 2
verticesXX2 :
)XX: ;
.XX; <
normalXX< B
;XXB C
Vector2YY 
[YY 
]YY 
points2dYY 
=YY  

ProjectionYY! +
.YY+ ,
PlanarProjectYY, 9
(YY9 :
verticesYY: B
,YYB C
nullYYD H
,YYH I
normalYYJ P
)YYP Q
;YYQ R
Vector2ZZ 
[ZZ 
]ZZ 
[ZZ 
]ZZ 
holes2dZZ 
=ZZ  !
nullZZ" &
;ZZ& '
if[[ 
([[ 
holes[[ 
!=[[ 
null[[ 
)[[ 
{\\ 
holes2d]] 
=]] 
new]] 
Vector2]] %
[]]% &
holes]]& +
.]]+ ,
Length]], 2
]]]2 3
[]]3 4
]]]4 5
;]]5 6
for^^ 
(^^ 
int^^ 
i^^ 
=^^ 
$num^^ 
;^^ 
i^^  !
<^^" #
holes^^$ )
.^^) *
Length^^* 0
;^^0 1
i^^2 3
++^^3 5
)^^5 6
{__ 
if`` 
(`` 
holes`` 
[`` 
i`` 
]`` 
.``  
Length``  &
<``' (
$num``) *
)``* +
returnaa 
falseaa $
;aa$ %
holes2dcc 
[cc 
icc 
]cc 
=cc  

Projectioncc! +
.cc+ ,
PlanarProjectcc, 9
(cc9 :
holescc: ?
[cc? @
icc@ A
]ccA B
,ccB C
nullccD H
,ccH I
normalccJ P
)ccP Q
;ccQ R
}dd 
}ee 
returngg 
Triangulategg 
(gg 
points2dgg '
,gg' (
holes2dgg) 0
,gg0 1
outgg2 5
	trianglesgg6 ?
)gg? @
;gg@ A
}hh 	
publicjj 
staticjj 
booljj 
TriangulateVerticesjj .
(jj. /
Vector3jj/ 6
[jj6 7
]jj7 8
verticesjj9 A
,jjA B
outjjC F
ListjjG K
<jjK L
intjjL O
>jjO P
	trianglesjjQ Z
,jjZ [
booljj\ `
	unorderedjja j
=jjk l
truejjm q
,jjq r
booljjs w
convexjjx ~
=	jj Ä
false
jjÅ Ü
)
jjÜ á
{kk 	
	trianglesll 
=ll 
nullll 
;ll 
intmm 
vertexCountmm 
=mm 
verticesmm &
==mm' )
nullmm* .
?mm/ 0
$nummm1 2
:mm3 4
verticesmm5 =
.mm= >
Lengthmm> D
;mmD E
ifoo 
(oo 
vertexCountoo 
<oo 
$numoo 
)oo  
returnpp 
falsepp 
;pp 
ifrr 
(rr 
vertexCountrr 
==rr 
$numrr  
)rr  !
{ss 
	trianglestt 
=tt 
newtt 
Listtt  $
<tt$ %
inttt% (
>tt( )
(tt) *
)tt* +
{tt, -
$numtt. /
,tt/ 0
$numtt1 2
,tt2 3
$numtt4 5
}tt6 7
;tt7 8
returnuu 
trueuu 
;uu 
}vv 
Vector2xx 
[xx 
]xx 
points2dxx 
=xx  

Projectionxx! +
.xx+ ,
PlanarProjectxx, 9
(xx9 :
verticesxx: B
)xxB C
;xxC D
ifzz 
(zz 
	unorderedzz 
)zz 
return{{ 
SortAndTriangulate{{ )
({{) *
points2d{{* 2
,{{2 3
out{{4 7
	triangles{{8 A
,{{A B
convex{{C I
){{I J
;{{J K
return}} 
Triangulate}} 
(}} 
points2d}} '
,}}' (
out}}) ,
	triangles}}- 6
,}}6 7
convex}}8 >
)}}> ?
;}}? @
}~~ 	
public
áá 
static
áá 
bool
áá 
Triangulate
áá &
(
áá& '
IList
áá' ,
<
áá, -
Vector2
áá- 4
>
áá4 5
points
áá6 <
,
áá< =
out
áá> A
List
ááB F
<
ááF G
int
ááG J
>
ááJ K
indexes
ááL S
,
ááS T
bool
ááU Y
convex
ááZ `
=
ááa b
false
áác h
)
ááh i
{
àà 	
indexes
ââ 
=
ââ 
new
ââ 
List
ââ 
<
ââ 
int
ââ "
>
ââ" #
(
ââ# $
)
ââ$ %
;
ââ% &
int
ãã 
index
ãã 
=
ãã 
$num
ãã 
;
ãã 
Triangulatable
çç 
soup
çç 
=
çç  !
convex
çç" (
?
éé 
new
éé 
PointSet
éé 
(
éé 
points
éé %
.
éé% &
Select
éé& ,
(
éé, -
x
éé- .
=>
éé/ 1
new
éé2 5 
TriangulationPoint
éé6 H
(
ééH I
x
ééI J
.
ééJ K
x
ééK L
,
ééL M
x
ééN O
.
ééO P
y
ééP Q
,
ééQ R
index
ééS X
++
ééX Z
)
ééZ [
)
éé[ \
.
éé\ ]
ToList
éé] c
(
ééc d
)
ééd e
)
éée f
:
èè 
(
èè 
Triangulatable
èè !
)
èè! "
new
èè# &
Polygon
èè' .
(
èè. /
points
èè/ 5
.
èè5 6
Select
èè6 <
(
èè< =
x
èè= >
=>
èè? A
new
èèB E
PolygonPoint
èèF R
(
èèR S
x
èèS T
.
èèT U
x
èèU V
,
èèV W
x
èèX Y
.
èèY Z
y
èèZ [
,
èè[ \
index
èè] b
++
èèb d
)
èèd e
)
èèe f
)
èèf g
;
èèg h
try
ëë 
{
íí "
triangulationContext
ìì $
.
ìì$ %
Clear
ìì% *
(
ìì* +
)
ìì+ ,
;
ìì, -"
triangulationContext
îî $
.
îî$ %"
PrepareTriangulation
îî% 9
(
îî9 :
soup
îî: >
)
îî> ?
;
îî? @
DTSweep
ïï 
.
ïï 
Triangulate
ïï #
(
ïï# $
(
ïï$ %
DTSweepContext
ïï% 3
)
ïï3 4"
triangulationContext
ïï4 H
)
ïïH I
;
ïïI J
}
ññ 
catch
óó 
(
óó 
System
óó 
.
óó 
	Exception
óó #
e
óó$ %
)
óó% &
{
òò 
Log
ôô 
.
ôô 
Info
ôô 
(
ôô 
$str
ôô 1
+
ôô2 3
e
ôô4 5
.
ôô5 6
ToString
ôô6 >
(
ôô> ?
)
ôô? @
)
ôô@ A
;
ôôA B
return
öö 
false
öö 
;
öö 
}
õõ 
foreach
ùù 
(
ùù 
DelaunayTriangle
ùù %
d
ùù& '
in
ùù( *
soup
ùù+ /
.
ùù/ 0
	Triangles
ùù0 9
)
ùù9 :
{
ûû 
if
üü 
(
üü 
d
üü 
.
üü 
Points
üü 
[
üü 
$num
üü 
]
üü 
.
üü  
Index
üü  %
<
üü& '
$num
üü( )
||
üü* ,
d
üü- .
.
üü. /
Points
üü/ 5
[
üü5 6
$num
üü6 7
]
üü7 8
.
üü8 9
Index
üü9 >
<
üü? @
$num
üüA B
||
üüC E
d
üüF G
.
üüG H
Points
üüH N
[
üüN O
$num
üüO P
]
üüP Q
.
üüQ R
Index
üüR W
<
üüX Y
$num
üüZ [
)
üü[ \
{
†† 
Log
°° 
.
°° 
Info
°° 
(
°° 
$str
°° W
)
°°W X
;
°°X Y
return
¢¢ 
false
¢¢  
;
¢¢  !
}
££ 
indexes
•• 
.
•• 
Add
•• 
(
•• 
d
•• 
.
•• 
Points
•• $
[
••$ %
$num
••% &
]
••& '
.
••' (
Index
••( -
)
••- .
;
••. /
indexes
¶¶ 
.
¶¶ 
Add
¶¶ 
(
¶¶ 
d
¶¶ 
.
¶¶ 
Points
¶¶ $
[
¶¶$ %
$num
¶¶% &
]
¶¶& '
.
¶¶' (
Index
¶¶( -
)
¶¶- .
;
¶¶. /
indexes
ßß 
.
ßß 
Add
ßß 
(
ßß 
d
ßß 
.
ßß 
Points
ßß $
[
ßß$ %
$num
ßß% &
]
ßß& '
.
ßß' (
Index
ßß( -
)
ßß- .
;
ßß. /
}
®® 
WindingOrder
™™ 
originalWinding
™™ (
=
™™) *
SurfaceTopology
™™+ :
.
™™: ;
GetWindingOrder
™™; J
(
™™J K
points
™™K Q
)
™™Q R
;
™™R S
if
ØØ 
(
ØØ 
SurfaceTopology
ØØ 
.
ØØ  
GetWindingOrder
ØØ  /
(
ØØ/ 0
new
ØØ0 3
Vector2
ØØ4 ;
[
ØØ; <
$num
ØØ< =
]
ØØ= >
{
∞∞ 
points
±± 
[
±± 
indexes
±± 
[
±± 
$num
±±  
]
±±  !
]
±±! "
,
±±" #
points
≤≤ 
[
≤≤ 
indexes
≤≤ 
[
≤≤ 
$num
≤≤  
]
≤≤  !
]
≤≤! "
,
≤≤" #
points
≥≥ 
[
≥≥ 
indexes
≥≥ 
[
≥≥ 
$num
≥≥  
]
≥≥  !
]
≥≥! "
,
≥≥" #
}
µµ 
)
µµ 
!=
µµ 
originalWinding
µµ !
)
µµ! "
indexes
∂∂ 
.
∂∂ 
Reverse
∂∂ 
(
∂∂  
)
∂∂  !
;
∂∂! "
return
∏∏ 
true
∏∏ 
;
∏∏ 
}
ππ 	
public
√√ 
static
√√ 
bool
√√ 
Triangulate
√√ &
(
√√& '
IList
√√' ,
<
√√, -
Vector2
√√- 4
>
√√4 5
points
√√6 <
,
√√< =
IList
√√> C
<
√√C D
IList
√√D I
<
√√I J
Vector2
√√J Q
>
√√Q R
>
√√R S
holes
√√T Y
,
√√Y Z
out
√√[ ^
List
√√_ c
<
√√c d
int
√√d g
>
√√g h
indexes
√√i p
)
√√p q
{
ƒƒ 	
indexes
≈≈ 
=
≈≈ 
new
≈≈ 
List
≈≈ 
<
≈≈ 
int
≈≈ "
>
≈≈" #
(
≈≈# $
)
≈≈$ %
;
≈≈% &
int
«« 
index
«« 
=
«« 
$num
«« 
;
«« 
var
…… 
	allPoints
…… 
=
…… 
new
…… 
List
……  $
<
……$ %
Vector2
……% ,
>
……, -
(
……- .
points
……. 4
)
……4 5
;
……5 6
Polygon
ÀÀ 
polygon
ÀÀ 
=
ÀÀ 
new
ÀÀ !
Polygon
ÀÀ" )
(
ÀÀ) *
points
ÀÀ* 0
.
ÀÀ0 1
Select
ÀÀ1 7
(
ÀÀ7 8
x
ÀÀ8 9
=>
ÀÀ: <
new
ÀÀ= @
PolygonPoint
ÀÀA M
(
ÀÀM N
x
ÀÀN O
.
ÀÀO P
x
ÀÀP Q
,
ÀÀQ R
x
ÀÀS T
.
ÀÀT U
y
ÀÀU V
,
ÀÀV W
index
ÀÀX ]
++
ÀÀ] _
)
ÀÀ_ `
)
ÀÀ` a
)
ÀÀa b
;
ÀÀb c
if
ÃÃ 
(
ÃÃ 
holes
ÃÃ 
!=
ÃÃ 
null
ÃÃ 
)
ÃÃ 
{
ÕÕ 
for
ŒŒ 
(
ŒŒ 
int
ŒŒ 
i
ŒŒ 
=
ŒŒ 
$num
ŒŒ 
;
ŒŒ 
i
ŒŒ  !
<
ŒŒ" #
holes
ŒŒ$ )
.
ŒŒ) *
Count
ŒŒ* /
;
ŒŒ/ 0
i
ŒŒ1 2
++
ŒŒ2 4
)
ŒŒ4 5
{
œœ 
	allPoints
–– 
.
–– 
AddRange
–– &
(
––& '
holes
––' ,
[
––, -
i
––- .
]
––. /
)
––/ 0
;
––0 1
var
—— 
holePolgyon
—— #
=
——$ %
new
——& )
Polygon
——* 1
(
——1 2
holes
——2 7
[
——7 8
i
——8 9
]
——9 :
.
——: ;
Select
——; A
(
——A B
x
——B C
=>
——D F
new
——G J
PolygonPoint
——K W
(
——W X
x
——X Y
.
——Y Z
x
——Z [
,
——[ \
x
——] ^
.
——^ _
y
——_ `
,
——` a
index
——b g
++
——g i
)
——i j
)
——j k
)
——k l
;
——l m
polygon
““ 
.
““ 
AddHole
““ #
(
““# $
holePolgyon
““$ /
)
““/ 0
;
““0 1
}
”” 
}
‘‘ 
try
÷÷ 
{
◊◊ "
triangulationContext
ÿÿ $
.
ÿÿ$ %
Clear
ÿÿ% *
(
ÿÿ* +
)
ÿÿ+ ,
;
ÿÿ, -"
triangulationContext
ŸŸ $
.
ŸŸ$ %"
PrepareTriangulation
ŸŸ% 9
(
ŸŸ9 :
polygon
ŸŸ: A
)
ŸŸA B
;
ŸŸB C
DTSweep
⁄⁄ 
.
⁄⁄ 
Triangulate
⁄⁄ #
(
⁄⁄# $
(
⁄⁄$ %
DTSweepContext
⁄⁄% 3
)
⁄⁄3 4"
triangulationContext
⁄⁄4 H
)
⁄⁄H I
;
⁄⁄I J
}
€€ 
catch
‹‹ 
(
‹‹ 
System
‹‹ 
.
‹‹ 
	Exception
‹‹ #
e
‹‹$ %
)
‹‹% &
{
›› 
Log
ﬁﬁ 
.
ﬁﬁ 
Info
ﬁﬁ 
(
ﬁﬁ 
$str
ﬁﬁ 1
+
ﬁﬁ2 3
e
ﬁﬁ4 5
.
ﬁﬁ5 6
ToString
ﬁﬁ6 >
(
ﬁﬁ> ?
)
ﬁﬁ? @
)
ﬁﬁ@ A
;
ﬁﬁA B
return
ﬂﬂ 
false
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 
foreach
‚‚ 
(
‚‚ 
DelaunayTriangle
‚‚ %
d
‚‚& '
in
‚‚( *
polygon
‚‚+ 2
.
‚‚2 3
	Triangles
‚‚3 <
)
‚‚< =
{
„„ 
if
‰‰ 
(
‰‰ 
d
‰‰ 
.
‰‰ 
Points
‰‰ 
[
‰‰ 
$num
‰‰ 
]
‰‰ 
.
‰‰  
Index
‰‰  %
<
‰‰& '
$num
‰‰( )
||
‰‰* ,
d
‰‰- .
.
‰‰. /
Points
‰‰/ 5
[
‰‰5 6
$num
‰‰6 7
]
‰‰7 8
.
‰‰8 9
Index
‰‰9 >
<
‰‰? @
$num
‰‰A B
||
‰‰C E
d
‰‰F G
.
‰‰G H
Points
‰‰H N
[
‰‰N O
$num
‰‰O P
]
‰‰P Q
.
‰‰Q R
Index
‰‰R W
<
‰‰X Y
$num
‰‰Z [
)
‰‰[ \
{
ÂÂ 
Log
ÊÊ 
.
ÊÊ 
Info
ÊÊ 
(
ÊÊ 
$str
ÊÊ W
)
ÊÊW X
;
ÊÊX Y
return
ÁÁ 
false
ÁÁ  
;
ÁÁ  !
}
ËË 
indexes
ÍÍ 
.
ÍÍ 
Add
ÍÍ 
(
ÍÍ 
d
ÍÍ 
.
ÍÍ 
Points
ÍÍ $
[
ÍÍ$ %
$num
ÍÍ% &
]
ÍÍ& '
.
ÍÍ' (
Index
ÍÍ( -
)
ÍÍ- .
;
ÍÍ. /
indexes
ÎÎ 
.
ÎÎ 
Add
ÎÎ 
(
ÎÎ 
d
ÎÎ 
.
ÎÎ 
Points
ÎÎ $
[
ÎÎ$ %
$num
ÎÎ% &
]
ÎÎ& '
.
ÎÎ' (
Index
ÎÎ( -
)
ÎÎ- .
;
ÎÎ. /
indexes
ÏÏ 
.
ÏÏ 
Add
ÏÏ 
(
ÏÏ 
d
ÏÏ 
.
ÏÏ 
Points
ÏÏ $
[
ÏÏ$ %
$num
ÏÏ% &
]
ÏÏ& '
.
ÏÏ' (
Index
ÏÏ( -
)
ÏÏ- .
;
ÏÏ. /
}
ÌÌ 
WindingOrder
ÔÔ 
originalWinding
ÔÔ (
=
ÔÔ) *
SurfaceTopology
ÔÔ+ :
.
ÔÔ: ;
GetWindingOrder
ÔÔ; J
(
ÔÔJ K
points
ÔÔK Q
)
ÔÔQ R
;
ÔÔR S
if
ÙÙ 
(
ÙÙ 
SurfaceTopology
ÙÙ 
.
ÙÙ  
GetWindingOrder
ÙÙ  /
(
ÙÙ/ 0
new
ÙÙ0 3
Vector2
ÙÙ4 ;
[
ÙÙ; <
$num
ÙÙ< =
]
ÙÙ= >
{
ıı 
	allPoints
ˆˆ 
[
ˆˆ 
indexes
ˆˆ !
[
ˆˆ! "
$num
ˆˆ" #
]
ˆˆ# $
]
ˆˆ$ %
,
ˆˆ% &
	allPoints
˜˜ 
[
˜˜ 
indexes
˜˜ !
[
˜˜! "
$num
˜˜" #
]
˜˜# $
]
˜˜$ %
,
˜˜% &
	allPoints
¯¯ 
[
¯¯ 
indexes
¯¯ !
[
¯¯! "
$num
¯¯" #
]
¯¯# $
]
¯¯$ %
,
¯¯% &
}
˙˙ 
)
˙˙ 
!=
˙˙ 
originalWinding
˙˙ !
)
˙˙! "
indexes
˚˚ 
.
˚˚ 
Reverse
˚˚ 
(
˚˚  
)
˚˚  !
;
˚˚! "
return
˝˝ 
true
˝˝ 
;
˝˝ 
}
˛˛ 	
}
ˇˇ 
}ÄÄ Ö¶
ôD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\MeshValidation.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
public

 
static

 
class

 
MeshValidation

 #
{ 
public 
static 
bool '
ContainsDegenerateTriangles 6
(6 7
this7 ;
ProBuilderMesh< J
meshK O
)O P
{ 	
return '
ContainsDegenerateTriangles .
(. /
mesh/ 3
,3 4
mesh5 9
.9 :
facesInternal: G
)G H
;H I
} 	
public 
static 
bool '
ContainsDegenerateTriangles 6
(6 7
this7 ;
ProBuilderMesh< J
meshK O
,O P
IListQ V
<V W
FaceW [
>[ \
faces] b
)b c
{ 	
var   
	positions   
=   
mesh    
.    !
positionsInternal  ! 2
;  2 3
foreach"" 
("" 
var"" 
face"" 
in""  
faces""! &
)""& '
{## 
var$$ 
indices$$ 
=$$ 
face$$ "
.$$" #
indexesInternal$$# 2
;$$2 3
for&& 
(&& 
int&& 
i&& 
=&& 
$num&& 
;&& 
i&&  !
<&&" #
indices&&$ +
.&&+ ,
Length&&, 2
;&&2 3
i&&4 5
+=&&6 8
$num&&9 :
)&&: ;
{'' 
float(( 
area(( 
=((  
Math((! %
.((% &
TriangleArea((& 2
(((2 3
	positions)) !
[))! "
indices))" )
[))) *
i))* +
+)), -
$num)). /
]))/ 0
]))0 1
,))1 2
	positions** !
[**! "
indices**" )
[**) *
i*** +
+**, -
$num**. /
]**/ 0
]**0 1
,**1 2
	positions++ !
[++! "
indices++" )
[++) *
i++* +
+++, -
$num++. /
]++/ 0
]++0 1
)++1 2
;++2 3
if-- 
(-- 
area-- 
<=-- 
Mathf--  %
.--% &
Epsilon--& -
)--- .
return.. 
true.. #
;..# $
}// 
}00 
return22 
false22 
;22 
}33 	
public<< 
static<< 
bool<< '
ContainsDegenerateTriangles<< 6
(<<6 7
this<<7 ;
ProBuilderMesh<<< J
mesh<<K O
,<<O P
Face<<Q U
face<<V Z
)<<Z [
{== 	
var>> 
	positions>> 
=>> 
mesh>>  
.>>  !
positionsInternal>>! 2
;>>2 3
var?? 
indices?? 
=?? 
face?? 
.?? 
indexesInternal?? .
;??. /
forAA 
(AA 
intAA 
iAA 
=AA 
$numAA 
;AA 
iAA 
<AA 
indicesAA  '
.AA' (
LengthAA( .
;AA. /
iAA0 1
+=AA2 4
$numAA5 6
)AA6 7
{BB 
floatCC 
areaCC 
=CC 
MathCC !
.CC! "
TriangleAreaCC" .
(CC. /
	positionsDD 
[DD 
indicesDD %
[DD% &
iDD& '
+DD( )
$numDD* +
]DD+ ,
]DD, -
,DD- .
	positionsEE 
[EE 
indicesEE %
[EE% &
iEE& '
+EE( )
$numEE* +
]EE+ ,
]EE, -
,EE- .
	positionsFF 
[FF 
indicesFF %
[FF% &
iFF& '
+FF( )
$numFF* +
]FF+ ,
]FF, -
)FF- .
;FF. /
ifHH 
(HH 
areaHH 
<=HH 
MathfHH !
.HH! "
EpsilonHH" )
)HH) *
returnII 
trueII 
;II  
}JJ 
returnLL 
falseLL 
;LL 
}MM 	
publicUU 
staticUU 
boolUU *
ContainsNonContiguousTrianglesUU 9
(UU9 :
thisUU: >
ProBuilderMeshUU? M
meshUUN R
,UUR S
FaceUUT X
faceUUY ]
)UU] ^
{VV 	
EdgeWW 
currentWW 
=WW 
faceWW 
.WW  
edgesInternalWW  -
[WW- .
$numWW. /
]WW/ 0
,WW0 1
startWW2 7
=WW8 9
currentWW: A
;WWA B
intXX 
indexXX 
=XX 
currentXX 
.XX  
aXX  !
;XX! "
intYY 
countYY 
=YY 
$numYY 
;YY 
while[[ 
([[ 
face[[ 
.[[ 
TryGetNextEdge[[ &
([[& '
current[[' .
,[[. /
current[[0 7
.[[7 8
b[[8 9
,[[9 :
ref[[; >
current[[? F
,[[F G
ref[[H K
index[[L Q
)[[Q R
&&\\ 
current\\ 
!=\\ 
start\\ #
&&]] 
count]] 
<]] 
face]] 
.]]  
edgesInternal]]  -
.]]- .
Length]]. 4
)]]4 5
{^^ 
count__ 
++__ 
;__ 
}`` 
returnbb 
countbb 
!=bb 
facebb  
.bb  !
edgesInternalbb! .
.bb. /
Lengthbb/ 5
;bb5 6
}cc 	
publicpp 
staticpp 
Listpp 
<pp 
Facepp 
>pp  7
+EnsureFacesAreComposedOfContiguousTrianglespp! L
(ppL M
thisppM Q
ProBuilderMeshppR `
meshppa e
,ppe f
IEnumerableppg r
<ppr s
Facepps w
>ppw x
facesppy ~
)pp~ 
{qq 	
varrr 
appendedrr 
=rr 
newrr 
Listrr #
<rr# $
Facerr$ (
>rr( )
(rr) *
)rr* +
;rr+ ,
foreachtt 
(tt 
vartt 
facett 
intt  
facestt! &
)tt& '
{uu 
ifvv 
(vv *
ContainsNonContiguousTrianglesvv 2
(vv2 3
meshvv3 7
,vv7 8
facevv9 =
)vv= >
)vv> ?
{ww 
varxx 
groupsxx 
=xx  
CollectFaceGroupsxx! 2
(xx2 3
meshxx3 7
,xx7 8
facexx9 =
)xx= >
;xx> ?
ifzz 
(zz 
groupszz 
.zz 
Countzz $
(zz$ %
)zz% &
<zz' (
$numzz) *
)zz* +
continue{{  
;{{  !
face}} 
.}} 

SetIndexes}} #
(}}# $
groups}}$ *
[}}* +
$num}}+ ,
]}}, -
.}}- .

SelectMany}}. 8
(}}8 9
x}}9 :
=>}}: <
x}}< =
.}}= >
indices}}> E
)}}E F
)}}F G
;}}G H
for 
( 
int 
i 
=  
$num! "
;" #
i$ %
<& '
groups( .
.. /
Count/ 4
;4 5
i6 7
++7 9
)9 :
{
ÄÄ 
var
ÅÅ 
	duplicate
ÅÅ %
=
ÅÅ& '
new
ÅÅ( +
Face
ÅÅ, 0
(
ÅÅ0 1
face
ÅÅ1 5
)
ÅÅ5 6
;
ÅÅ6 7
	duplicate
ÇÇ !
.
ÇÇ! "

SetIndexes
ÇÇ" ,
(
ÇÇ, -
groups
ÇÇ- 3
[
ÇÇ3 4
i
ÇÇ4 5
]
ÇÇ5 6
.
ÇÇ6 7

SelectMany
ÇÇ7 A
(
ÇÇA B
x
ÇÇB C
=>
ÇÇD F
x
ÇÇG H
.
ÇÇH I
indices
ÇÇI P
)
ÇÇP Q
)
ÇÇQ R
;
ÇÇR S
appended
ÉÉ  
.
ÉÉ  !
Add
ÉÉ! $
(
ÉÉ$ %
	duplicate
ÉÉ% .
)
ÉÉ. /
;
ÉÉ/ 0
}
ÑÑ 
}
ÖÖ 
}
ÜÜ 
var
àà 
rebuilt
àà 
=
àà 
new
àà 
List
àà "
<
àà" #
Face
àà# '
>
àà' (
(
àà( )
mesh
àà) -
.
àà- .
facesInternal
àà. ;
)
àà; <
;
àà< =
rebuilt
ää 
.
ää 
AddRange
ää 
(
ää 
appended
ää %
)
ää% &
;
ää& '
mesh
åå 
.
åå 
faces
åå 
=
åå 
rebuilt
åå  
;
åå  !
return
éé 
appended
éé 
;
éé 
}
èè 	
internal
ëë 
static
ëë 
List
ëë 
<
ëë 
List
ëë !
<
ëë! "
Triangle
ëë" *
>
ëë* +
>
ëë+ ,
CollectFaceGroups
ëë- >
(
ëë> ?
this
ëë? C
ProBuilderMesh
ëëD R
mesh
ëëS W
,
ëëW X
Face
ëëY ]
face
ëë^ b
)
ëëb c
{
íí 	
var
ìì 
groups
ìì 
=
ìì 
new
ìì 
List
ìì !
<
ìì! "
List
ìì" &
<
ìì& '
Triangle
ìì' /
>
ìì/ 0
>
ìì0 1
(
ìì1 2
)
ìì2 3
;
ìì3 4
var
îî 
indices
îî 
=
îî 
face
îî 
.
îî 
indexesInternal
îî .
;
îî. /
for
ññ 
(
ññ 
int
ññ 
i
ññ 
=
ññ 
$num
ññ 
;
ññ 
i
ññ 
<
ññ 
indices
ññ  '
.
ññ' (
Length
ññ( .
;
ññ. /
i
ññ0 1
+=
ññ2 4
$num
ññ5 6
)
ññ6 7
{
óó 
var
òò 
triangle
òò 
=
òò 
new
òò "
Triangle
òò# +
(
òò+ ,
indices
òò, 3
[
òò3 4
i
òò4 5
]
òò5 6
,
òò6 7
indices
òò8 ?
[
òò? @
i
òò@ A
+
òòA B
$num
òòB C
]
òòC D
,
òòD E
indices
òòF M
[
òòM N
i
òòN O
+
òòO P
$num
òòP Q
]
òòQ R
)
òòR S
;
òòS T
var
ôô 
matched
ôô 
=
ôô 
false
ôô #
;
ôô# $
for
õõ 
(
õõ 
int
õõ 
n
õõ 
=
õõ 
$num
õõ 
;
õõ 
n
õõ  
<
õõ! "
groups
õõ# )
.
õõ) *
Count
õõ* /
;
õõ/ 0
n
õõ1 2
++
õõ2 4
)
õõ4 5
{
úú 
if
ûû 
(
ûû 
groups
ûû 
[
ûû 
n
ûû  
]
ûû  !
.
ûû! "
Any
ûû" %
(
ûû% &
x
ûû& '
=>
ûû( *
x
ûû+ ,
.
ûû, -

IsAdjacent
ûû- 7
(
ûû7 8
triangle
ûû8 @
)
ûû@ A
)
ûûA B
)
ûûB C
{
üü 
groups
†† 
[
†† 
n
††  
]
††  !
.
††! "
Add
††" %
(
††% &
triangle
††& .
)
††. /
;
††/ 0
matched
°° 
=
°°  !
true
°°" &
;
°°& '
break
¢¢ 
;
¢¢ 
}
££ 
}
§§ 
if
¶¶ 
(
¶¶ 
!
¶¶ 
matched
¶¶ 
)
¶¶ 
groups
ßß 
.
ßß 
Add
ßß 
(
ßß 
new
ßß "
List
ßß# '
<
ßß' (
Triangle
ßß( 0
>
ßß0 1
(
ßß1 2
)
ßß2 3
{
ßß4 5
triangle
ßß6 >
}
ßß? @
)
ßß@ A
;
ßßA B
}
®® 
return
™™ 
groups
™™ 
;
™™ 
}
´´ 	
public
µµ 
static
µµ 
bool
µµ '
RemoveDegenerateTriangles
µµ 4
(
µµ4 5
ProBuilderMesh
µµ5 C
mesh
µµD H
,
µµH I
List
µµJ N
<
µµN O
int
µµO R
>
µµR S
removed
µµT [
=
µµ\ ]
null
µµ^ b
)
µµb c
{
∂∂ 	
if
∑∑ 
(
∑∑ 
mesh
∑∑ 
==
∑∑ 
null
∑∑ 
)
∑∑ 
throw
∏∏ 
new
∏∏ #
ArgumentNullException
∏∏ /
(
∏∏/ 0
$str
∏∏0 6
)
∏∏6 7
;
∏∏7 8

Dictionary
∫∫ 
<
∫∫ 
int
∫∫ 
,
∫∫ 
int
∫∫ 
>
∫∫  
m_Lookup
∫∫! )
=
∫∫* +
mesh
∫∫, 0
.
∫∫0 1 
sharedVertexLookup
∫∫1 C
;
∫∫C D

Dictionary
ªª 
<
ªª 
int
ªª 
,
ªª 
int
ªª 
>
ªª  

m_LookupUV
ªª! +
=
ªª, -
mesh
ªª. 2
.
ªª2 3!
sharedTextureLookup
ªª3 F
;
ªªF G
Vector3
ºº 
[
ºº 
]
ºº 
m_Positions
ºº !
=
ºº" #
mesh
ºº$ (
.
ºº( )
positionsInternal
ºº) :
;
ºº: ;

Dictionary
ΩΩ 
<
ΩΩ 
int
ΩΩ 
,
ΩΩ 
int
ΩΩ 
>
ΩΩ  
m_RebuiltLookup
ΩΩ! 0
=
ΩΩ1 2
new
ΩΩ3 6

Dictionary
ΩΩ7 A
<
ΩΩA B
int
ΩΩB E
,
ΩΩE F
int
ΩΩG J
>
ΩΩJ K
(
ΩΩK L
m_Lookup
ΩΩL T
.
ΩΩT U
Count
ΩΩU Z
)
ΩΩZ [
;
ΩΩ[ \

Dictionary
ææ 
<
ææ 
int
ææ 
,
ææ 
int
ææ 
>
ææ  
m_RebuiltLookupUV
ææ! 2
=
ææ3 4
new
ææ5 8

Dictionary
ææ9 C
<
ææC D
int
ææD G
,
ææG H
int
ææI L
>
ææL M
(
ææM N

m_LookupUV
ææN X
.
ææX Y
Count
ææY ^
)
ææ^ _
;
ææ_ `
List
øø 
<
øø 
Face
øø 
>
øø 
m_RebuiltFaces
øø %
=
øø& '
new
øø( +
List
øø, 0
<
øø0 1
Face
øø1 5
>
øø5 6
(
øø6 7
mesh
øø7 ;
.
øø; <
	faceCount
øø< E
)
øøE F
;
øøF G

Dictionary
¿¿ 
<
¿¿ 
int
¿¿ 
,
¿¿ 
int
¿¿ 
>
¿¿  $
m_DuplicateIndexFilter
¿¿! 7
=
¿¿8 9
new
¿¿: =

Dictionary
¿¿> H
<
¿¿H I
int
¿¿I L
,
¿¿L M
int
¿¿N Q
>
¿¿Q R
(
¿¿R S
$num
¿¿S T
)
¿¿T U
;
¿¿U V
foreach
¬¬ 
(
¬¬ 
Face
¬¬ 
face
¬¬ 
in
¬¬ !
mesh
¬¬" &
.
¬¬& '
facesInternal
¬¬' 4
)
¬¬4 5
{
√√ $
m_DuplicateIndexFilter
ƒƒ &
.
ƒƒ& '
Clear
ƒƒ' ,
(
ƒƒ, -
)
ƒƒ- .
;
ƒƒ. /
List
≈≈ 
<
≈≈ 
int
≈≈ 
>
≈≈ 
tris
≈≈ 
=
≈≈  
new
≈≈! $
List
≈≈% )
<
≈≈) *
int
≈≈* -
>
≈≈- .
(
≈≈. /
)
≈≈/ 0
;
≈≈0 1
int
∆∆ 
[
∆∆ 
]
∆∆ 
ind
∆∆ 
=
∆∆ 
face
∆∆  
.
∆∆  !
indexesInternal
∆∆! 0
;
∆∆0 1
for
»» 
(
»» 
int
»» 
i
»» 
=
»» 
$num
»» 
;
»» 
i
»»  !
<
»»" #
ind
»»$ '
.
»»' (
Length
»»( .
;
»». /
i
»»0 1
+=
»»2 4
$num
»»5 6
)
»»6 7
{
…… 
float
   
area
   
=
    
Math
  ! %
.
  % &
TriangleArea
  & 2
(
  2 3
m_Positions
  3 >
[
  > ?
ind
  ? B
[
  B C
i
  C D
+
  E F
$num
  G H
]
  H I
]
  I J
,
  J K
m_Positions
  L W
[
  W X
ind
  X [
[
  [ \
i
  \ ]
+
  ^ _
$num
  ` a
]
  a b
]
  b c
,
  c d
m_Positions
  e p
[
  p q
ind
  q t
[
  t u
i
  u v
+
  w x
$num
  y z
]
  z {
]
  { |
)
  | }
;
  } ~
if
ÃÃ 
(
ÃÃ 
area
ÃÃ 
>
ÃÃ 
Mathf
ÃÃ $
.
ÃÃ$ %
Epsilon
ÃÃ% ,
)
ÃÃ, -
{
ÕÕ 
int
œœ 
triangleIndexA
œœ *
=
œœ+ ,
ind
œœ- 0
[
œœ0 1
i
œœ1 2
]
œœ2 3
,
œœ3 4
triangleIndexB
–– *
=
––+ ,
ind
––- 0
[
––0 1
i
––1 2
+
––2 3
$num
––3 4
]
––4 5
,
––5 6
triangleIndexC
—— *
=
——+ ,
ind
——- 0
[
——0 1
i
——1 2
+
——2 3
$num
——3 4
]
——4 5
;
——5 6
int
‘‘ 
sharedIndexA
‘‘ (
=
‘‘) *
m_Lookup
‘‘+ 3
[
‘‘3 4
triangleIndexA
‘‘4 B
]
‘‘B C
,
‘‘C D
sharedIndexB
’’ (
=
’’) *
m_Lookup
’’+ 3
[
’’3 4
triangleIndexB
’’4 B
]
’’B C
,
’’C D
sharedIndexC
÷÷ (
=
÷÷) *
m_Lookup
÷÷+ 3
[
÷÷3 4
triangleIndexC
÷÷4 B
]
÷÷B C
;
÷÷C D
if
ŸŸ 
(
ŸŸ 
!
ŸŸ 
(
ŸŸ 
sharedIndexA
ŸŸ *
==
ŸŸ+ -
sharedIndexB
ŸŸ. :
||
ŸŸ; =
sharedIndexA
ŸŸ> J
==
ŸŸK M
sharedIndexC
ŸŸN Z
||
ŸŸ[ ]
sharedIndexB
ŸŸ^ j
==
ŸŸk m
sharedIndexC
ŸŸn z
)
ŸŸz {
)
ŸŸ{ |
{
⁄⁄ 
int
€€ 
index
€€  %
;
€€% &
if
ﬁﬁ 
(
ﬁﬁ  
!
ﬁﬁ  !$
m_DuplicateIndexFilter
ﬁﬁ! 7
.
ﬁﬁ7 8
TryGetValue
ﬁﬁ8 C
(
ﬁﬁC D
sharedIndexA
ﬁﬁD P
,
ﬁﬁP Q
out
ﬁﬁR U
index
ﬁﬁV [
)
ﬁﬁ[ \
)
ﬁﬁ\ ]$
m_DuplicateIndexFilter
ﬂﬂ  6
.
ﬂﬂ6 7
Add
ﬂﬂ7 :
(
ﬂﬂ: ;
sharedIndexA
ﬂﬂ; G
,
ﬂﬂG H
triangleIndexA
ﬂﬂI W
)
ﬂﬂW X
;
ﬂﬂX Y
else
‡‡  
triangleIndexA
··  .
=
··/ 0
index
··1 6
;
··6 7
if
„„ 
(
„„  
!
„„  !$
m_DuplicateIndexFilter
„„! 7
.
„„7 8
TryGetValue
„„8 C
(
„„C D
sharedIndexB
„„D P
,
„„P Q
out
„„R U
index
„„V [
)
„„[ \
)
„„\ ]$
m_DuplicateIndexFilter
‰‰  6
.
‰‰6 7
Add
‰‰7 :
(
‰‰: ;
sharedIndexB
‰‰; G
,
‰‰G H
triangleIndexB
‰‰I W
)
‰‰W X
;
‰‰X Y
else
ÂÂ  
triangleIndexB
ÊÊ  .
=
ÊÊ/ 0
index
ÊÊ1 6
;
ÊÊ6 7
if
ËË 
(
ËË  
!
ËË  !$
m_DuplicateIndexFilter
ËË! 7
.
ËË7 8
TryGetValue
ËË8 C
(
ËËC D
sharedIndexC
ËËD P
,
ËËP Q
out
ËËR U
index
ËËV [
)
ËË[ \
)
ËË\ ]$
m_DuplicateIndexFilter
ÈÈ  6
.
ÈÈ6 7
Add
ÈÈ7 :
(
ÈÈ: ;
sharedIndexC
ÈÈ; G
,
ÈÈG H
triangleIndexC
ÈÈI W
)
ÈÈW X
;
ÈÈX Y
else
ÍÍ  
triangleIndexC
ÎÎ  .
=
ÎÎ/ 0
index
ÎÎ1 6
;
ÎÎ6 7
tris
ÌÌ  
.
ÌÌ  !
Add
ÌÌ! $
(
ÌÌ$ %
triangleIndexA
ÌÌ% 3
)
ÌÌ3 4
;
ÌÌ4 5
tris
ÓÓ  
.
ÓÓ  !
Add
ÓÓ! $
(
ÓÓ$ %
triangleIndexB
ÓÓ% 3
)
ÓÓ3 4
;
ÓÓ4 5
tris
ÔÔ  
.
ÔÔ  !
Add
ÔÔ! $
(
ÔÔ$ %
triangleIndexC
ÔÔ% 3
)
ÔÔ3 4
;
ÔÔ4 5
if
ÒÒ 
(
ÒÒ  
!
ÒÒ  !
m_RebuiltLookup
ÒÒ! 0
.
ÒÒ0 1
ContainsKey
ÒÒ1 <
(
ÒÒ< =
triangleIndexA
ÒÒ= K
)
ÒÒK L
)
ÒÒL M
m_RebuiltLookup
ÚÚ  /
.
ÚÚ/ 0
Add
ÚÚ0 3
(
ÚÚ3 4
triangleIndexA
ÚÚ4 B
,
ÚÚB C
sharedIndexA
ÚÚD P
)
ÚÚP Q
;
ÚÚQ R
if
ÛÛ 
(
ÛÛ  
!
ÛÛ  !
m_RebuiltLookup
ÛÛ! 0
.
ÛÛ0 1
ContainsKey
ÛÛ1 <
(
ÛÛ< =
triangleIndexB
ÛÛ= K
)
ÛÛK L
)
ÛÛL M
m_RebuiltLookup
ÙÙ  /
.
ÙÙ/ 0
Add
ÙÙ0 3
(
ÙÙ3 4
triangleIndexB
ÙÙ4 B
,
ÙÙB C
sharedIndexB
ÙÙD P
)
ÙÙP Q
;
ÙÙQ R
if
ıı 
(
ıı  
!
ıı  !
m_RebuiltLookup
ıı! 0
.
ıı0 1
ContainsKey
ıı1 <
(
ıı< =
triangleIndexC
ıı= K
)
ııK L
)
ııL M
m_RebuiltLookup
ˆˆ  /
.
ˆˆ/ 0
Add
ˆˆ0 3
(
ˆˆ3 4
triangleIndexC
ˆˆ4 B
,
ˆˆB C
sharedIndexC
ˆˆD P
)
ˆˆP Q
;
ˆˆQ R
if
¯¯ 
(
¯¯  

m_LookupUV
¯¯  *
.
¯¯* +
ContainsKey
¯¯+ 6
(
¯¯6 7
triangleIndexA
¯¯7 E
)
¯¯E F
&&
¯¯G I
!
¯¯J K
m_RebuiltLookupUV
¯¯K \
.
¯¯\ ]
ContainsKey
¯¯] h
(
¯¯h i
triangleIndexA
¯¯i w
)
¯¯w x
)
¯¯x y
m_RebuiltLookupUV
˘˘  1
.
˘˘1 2
Add
˘˘2 5
(
˘˘5 6
triangleIndexA
˘˘6 D
,
˘˘D E

m_LookupUV
˘˘F P
[
˘˘P Q
triangleIndexA
˘˘Q _
]
˘˘_ `
)
˘˘` a
;
˘˘a b
if
˙˙ 
(
˙˙  

m_LookupUV
˙˙  *
.
˙˙* +
ContainsKey
˙˙+ 6
(
˙˙6 7
triangleIndexB
˙˙7 E
)
˙˙E F
&&
˙˙G I
!
˙˙J K
m_RebuiltLookupUV
˙˙K \
.
˙˙\ ]
ContainsKey
˙˙] h
(
˙˙h i
triangleIndexB
˙˙i w
)
˙˙w x
)
˙˙x y
m_RebuiltLookupUV
˚˚  1
.
˚˚1 2
Add
˚˚2 5
(
˚˚5 6
triangleIndexB
˚˚6 D
,
˚˚D E

m_LookupUV
˚˚F P
[
˚˚P Q
triangleIndexB
˚˚Q _
]
˚˚_ `
)
˚˚` a
;
˚˚a b
if
¸¸ 
(
¸¸  

m_LookupUV
¸¸  *
.
¸¸* +
ContainsKey
¸¸+ 6
(
¸¸6 7
triangleIndexC
¸¸7 E
)
¸¸E F
&&
¸¸G I
!
¸¸J K
m_RebuiltLookupUV
¸¸K \
.
¸¸\ ]
ContainsKey
¸¸] h
(
¸¸h i
triangleIndexC
¸¸i w
)
¸¸w x
)
¸¸x y
m_RebuiltLookupUV
˝˝  1
.
˝˝1 2
Add
˝˝2 5
(
˝˝5 6
triangleIndexC
˝˝6 D
,
˝˝D E

m_LookupUV
˝˝F P
[
˝˝P Q
triangleIndexC
˝˝Q _
]
˝˝_ `
)
˝˝` a
;
˝˝a b
}
˛˛ 
}
ˇˇ 
}
ÄÄ 
if
ÇÇ 
(
ÇÇ 
tris
ÇÇ 
.
ÇÇ 
Count
ÇÇ 
>
ÇÇ  
$num
ÇÇ! "
)
ÇÇ" #
{
ÉÉ 
face
ÑÑ 
.
ÑÑ 
indexesInternal
ÑÑ (
=
ÑÑ) *
tris
ÑÑ+ /
.
ÑÑ/ 0
ToArray
ÑÑ0 7
(
ÑÑ7 8
)
ÑÑ8 9
;
ÑÑ9 :
m_RebuiltFaces
ÖÖ "
.
ÖÖ" #
Add
ÖÖ# &
(
ÖÖ& '
face
ÖÖ' +
)
ÖÖ+ ,
;
ÖÖ, -
}
ÜÜ 
}
áá 
mesh
ââ 
.
ââ 
faces
ââ 
=
ââ 
m_RebuiltFaces
ââ '
;
ââ' (
mesh
ää 
.
ää 
SetSharedVertices
ää "
(
ää" #
m_RebuiltLookup
ää# 2
)
ää2 3
;
ää3 4
mesh
ãã 
.
ãã 
SetSharedTextures
ãã "
(
ãã" #
m_RebuiltLookupUV
ãã# 4
)
ãã4 5
;
ãã5 6
return
çç "
RemoveUnusedVertices
çç '
(
çç' (
mesh
çç( ,
,
çç, -
removed
çç. 5
)
çç5 6
;
çç6 7
}
éé 	
public
ññ 
static
ññ 
bool
ññ "
RemoveUnusedVertices
ññ /
(
ññ/ 0
ProBuilderMesh
ññ0 >
mesh
ññ? C
,
ññC D
List
ññE I
<
ññI J
int
ññJ M
>
ññM N
removed
ññO V
=
ññW X
null
ññY ]
)
ññ] ^
{
óó 	
if
òò 
(
òò 
mesh
òò 
==
òò 
null
òò 
)
òò 
throw
ôô 
new
ôô #
ArgumentNullException
ôô /
(
ôô/ 0
$str
ôô0 6
)
ôô6 7
;
ôô7 8
bool
õõ 
saveRemoved
õõ 
=
õõ 
removed
õõ &
!=
õõ' )
null
õõ* .
;
õõ. /
if
ùù 
(
ùù 
saveRemoved
ùù 
)
ùù 
removed
ûû 
.
ûû 
Clear
ûû 
(
ûû 
)
ûû 
;
ûû  
var
†† 
del
†† 
=
†† 
saveRemoved
†† !
?
††" #
removed
††$ +
:
††, -
new
††. 1
List
††2 6
<
††6 7
int
††7 :
>
††: ;
(
††; <
)
††< =
;
††= >
var
¢¢ 
tris
¢¢ 
=
¢¢ 
new
¢¢ 
HashSet
¢¢ "
<
¢¢" #
int
¢¢# &
>
¢¢& '
(
¢¢' (
mesh
¢¢( ,
.
¢¢, -
facesInternal
¢¢- :
.
¢¢: ;

SelectMany
¢¢; E
(
¢¢E F
x
¢¢F G
=>
¢¢H J
x
¢¢K L
.
¢¢L M
indexes
¢¢M T
)
¢¢T U
)
¢¢U V
;
¢¢V W
for
§§ 
(
§§ 
int
§§ 
i
§§ 
=
§§ 
$num
§§ 
;
§§ 
i
§§ 
<
§§ 
mesh
§§  $
.
§§$ %
positionsInternal
§§% 6
.
§§6 7
Length
§§7 =
;
§§= >
i
§§? @
++
§§@ B
)
§§B C
if
•• 
(
•• 
!
•• 
tris
•• 
.
•• 
Contains
•• "
(
••" #
i
••# $
)
••$ %
)
••% &
del
¶¶ 
.
¶¶ 
Add
¶¶ 
(
¶¶ 
i
¶¶ 
)
¶¶ 
;
¶¶ 
mesh
®® 
.
®® 
DeleteVertices
®® 
(
®®  
del
®®  #
)
®®# $
;
®®$ %
return
™™ 
del
™™ 
.
™™ 
Any
™™ 
(
™™ 
)
™™ 
;
™™ 
}
´´ 	
internal
≥≥ 
static
≥≥ 
List
≥≥ 
<
≥≥ 
int
≥≥  
>
≥≥  !
RebuildIndexes
≥≥" 0
(
≥≥0 1
IEnumerable
≥≥1 <
<
≥≥< =
int
≥≥= @
>
≥≥@ A
indices
≥≥B I
,
≥≥I J
List
≥≥K O
<
≥≥O P
int
≥≥P S
>
≥≥S T
removed
≥≥U \
)
≥≥\ ]
{
¥¥ 	
var
µµ 
res
µµ 
=
µµ 
new
µµ 
List
µµ 
<
µµ 
int
µµ "
>
µµ" #
(
µµ# $
)
µµ$ %
;
µµ% &
var
∂∂ 
rmc
∂∂ 
=
∂∂ 
removed
∂∂ 
.
∂∂ 
Count
∂∂ #
;
∂∂# $
foreach
∏∏ 
(
∏∏ 
var
∏∏ 
index
∏∏ 
in
∏∏ !
indices
∏∏" )
)
∏∏) *
{
ππ 
var
∫∫ 
nearestIndex
∫∫  
=
∫∫! "
ArrayUtility
∫∫# /
.
∫∫/ 0&
NearestIndexPriorToValue
∫∫0 H
(
∫∫H I
removed
∫∫I P
,
∫∫P Q
index
∫∫R W
)
∫∫W X
+
∫∫Y Z
$num
∫∫[ \
;
∫∫\ ]
if
ΩΩ 
(
ΩΩ 
nearestIndex
ΩΩ  
>
ΩΩ! "
-
ΩΩ# $
$num
ΩΩ$ %
&&
ΩΩ& (
nearestIndex
ΩΩ) 5
<
ΩΩ6 7
rmc
ΩΩ8 ;
&&
ΩΩ< >
removed
ΩΩ? F
[
ΩΩF G
nearestIndex
ΩΩG S
]
ΩΩS T
==
ΩΩU W
index
ΩΩX ]
)
ΩΩ] ^
continue
ææ 
;
ææ 
res
¿¿ 
.
¿¿ 
Add
¿¿ 
(
¿¿ 
index
¿¿ 
-
¿¿ 
nearestIndex
¿¿  ,
)
¿¿, -
;
¿¿- .
}
¡¡ 
return
√√ 
res
√√ 
;
√√ 
}
ƒƒ 	
internal
ÃÃ 
static
ÃÃ 
List
ÃÃ 
<
ÃÃ 
Edge
ÃÃ !
>
ÃÃ! "
RebuildEdges
ÃÃ# /
(
ÃÃ/ 0
IEnumerable
ÃÃ0 ;
<
ÃÃ; <
Edge
ÃÃ< @
>
ÃÃ@ A
edges
ÃÃB G
,
ÃÃG H
List
ÃÃI M
<
ÃÃM N
int
ÃÃN Q
>
ÃÃQ R
removed
ÃÃS Z
)
ÃÃZ [
{
ÕÕ 	
var
ŒŒ 
res
ŒŒ 
=
ŒŒ 
new
ŒŒ 
List
ŒŒ 
<
ŒŒ 
Edge
ŒŒ #
>
ŒŒ# $
(
ŒŒ$ %
)
ŒŒ% &
;
ŒŒ& '
var
œœ 
rmc
œœ 
=
œœ 
removed
œœ 
.
œœ 
Count
œœ #
;
œœ# $
foreach
—— 
(
—— 
var
—— 
edge
—— 
in
——  
edges
——! &
)
——& '
{
““ 
var
”” 
nearestIndexA
”” !
=
””" #
ArrayUtility
””$ 0
.
””0 1&
NearestIndexPriorToValue
””1 I
(
””I J
removed
””J Q
,
””Q R
edge
””S W
.
””W X
a
””X Y
)
””Y Z
+
””[ \
$num
””] ^
;
””^ _
var
‘‘ 
nearestIndexB
‘‘ !
=
‘‘" #
ArrayUtility
‘‘$ 0
.
‘‘0 1&
NearestIndexPriorToValue
‘‘1 I
(
‘‘I J
removed
‘‘J Q
,
‘‘Q R
edge
‘‘S W
.
‘‘W X
b
‘‘X Y
)
‘‘Y Z
+
‘‘[ \
$num
‘‘] ^
;
‘‘^ _
if
◊◊ 
(
◊◊ 
(
◊◊ 
nearestIndexA
◊◊ "
>
◊◊# $
-
◊◊% &
$num
◊◊& '
&&
◊◊( *
nearestIndexA
◊◊+ 8
<
◊◊9 :
rmc
◊◊; >
&&
◊◊? A
removed
◊◊B I
[
◊◊I J
nearestIndexA
◊◊J W
]
◊◊W X
==
◊◊Y [
edge
◊◊\ `
.
◊◊` a
a
◊◊a b
)
◊◊b c
||
◊◊d f
(
ÿÿ 
nearestIndexB
ÿÿ "
>
ÿÿ# $
-
ÿÿ% &
$num
ÿÿ& '
&&
ÿÿ( *
nearestIndexB
ÿÿ+ 8
<
ÿÿ9 :
rmc
ÿÿ; >
&&
ÿÿ? A
removed
ÿÿB I
[
ÿÿI J
nearestIndexB
ÿÿJ W
]
ÿÿW X
==
ÿÿY [
edge
ÿÿ\ `
.
ÿÿ` a
b
ÿÿa b
)
ÿÿb c
)
ÿÿc d
continue
ŸŸ 
;
ŸŸ 
res
€€ 
.
€€ 
Add
€€ 
(
€€ 
new
€€ 
Edge
€€  
(
€€  !
edge
€€! %
.
€€% &
a
€€& '
-
€€( )
nearestIndexA
€€* 7
,
€€7 8
edge
€€9 =
.
€€= >
b
€€> ?
-
€€@ A
nearestIndexB
€€B O
)
€€O P
)
€€P Q
;
€€Q R
}
‹‹ 
return
ﬁﬁ 
res
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 	
internal
·· 
static
·· 
void
·· %
RebuildSelectionIndexes
·· 4
(
··4 5
ProBuilderMesh
··5 C
mesh
··D H
,
··H I
ref
··J M
Face
··N R
[
··R S
]
··S T
faces
··U Z
,
··Z [
ref
··\ _
Edge
··` d
[
··d e
]
··e f
edges
··g l
,
··l m
ref
··n q
int
··r u
[
··u v
]
··v w
indices
··x 
,·· Ä
IEnumerable··Å å
<··å ç
int··ç ê
>··ê ë
removed··í ô
)··ô ö
{
‚‚ 	
var
„„ 
rm
„„ 
=
„„ 
removed
„„ 
.
„„ 
ToList
„„ #
(
„„# $
)
„„$ %
;
„„% &
rm
‰‰ 
.
‰‰ 
Sort
‰‰ 
(
‰‰ 
)
‰‰ 
;
‰‰ 
if
ÊÊ 
(
ÊÊ 
faces
ÊÊ 
!=
ÊÊ 
null
ÊÊ 
&&
ÊÊ  
faces
ÊÊ! &
.
ÊÊ& '
Length
ÊÊ' -
>
ÊÊ. /
$num
ÊÊ0 1
)
ÊÊ1 2
faces
ÁÁ 
=
ÁÁ 
faces
ÁÁ 
.
ÁÁ 
Where
ÁÁ #
(
ÁÁ# $
x
ÁÁ$ %
=>
ÁÁ& (
mesh
ÁÁ) -
.
ÁÁ- .
facesInternal
ÁÁ. ;
.
ÁÁ; <
Contains
ÁÁ< D
(
ÁÁD E
x
ÁÁE F
)
ÁÁF G
)
ÁÁG H
.
ÁÁH I
ToArray
ÁÁI P
(
ÁÁP Q
)
ÁÁQ R
;
ÁÁR S
if
ÈÈ 
(
ÈÈ 
edges
ÈÈ 
!=
ÈÈ 
null
ÈÈ 
&&
ÈÈ 
edges
ÈÈ  %
.
ÈÈ% &
Length
ÈÈ& ,
>
ÈÈ- .
$num
ÈÈ/ 0
)
ÈÈ0 1
edges
ÍÍ 
=
ÍÍ 
RebuildEdges
ÍÍ $
(
ÍÍ$ %
edges
ÍÍ% *
,
ÍÍ* +
rm
ÍÍ, .
)
ÍÍ. /
.
ÍÍ/ 0
ToArray
ÍÍ0 7
(
ÍÍ7 8
)
ÍÍ8 9
;
ÍÍ9 :
if
ÏÏ 
(
ÏÏ 
indices
ÏÏ 
!=
ÏÏ 
null
ÏÏ 
&&
ÏÏ !
indices
ÏÏ" )
.
ÏÏ) *
Length
ÏÏ* 0
>
ÏÏ1 2
$num
ÏÏ3 4
)
ÏÏ4 5
indices
ÌÌ 
=
ÌÌ 
RebuildIndexes
ÌÌ (
(
ÌÌ( )
indices
ÌÌ) 0
,
ÌÌ0 1
rm
ÌÌ2 4
)
ÌÌ4 5
.
ÌÌ5 6
ToArray
ÌÌ6 =
(
ÌÌ= >
)
ÌÌ> ?
;
ÌÌ? @
}
ÓÓ 	
internal
ˆˆ 
static
ˆˆ 
bool
ˆˆ 
EnsureMeshIsValid
ˆˆ .
(
ˆˆ. /
ProBuilderMesh
ˆˆ/ =
mesh
ˆˆ> B
,
ˆˆB C
out
ˆˆD G
int
ˆˆH K
removedVertices
ˆˆL [
)
ˆˆ[ \
{
˜˜ 	
removedVertices
¯¯ 
=
¯¯ 
$num
¯¯ 
;
¯¯  
if
˙˙ 
(
˙˙ )
ContainsDegenerateTriangles
˙˙ +
(
˙˙+ ,
mesh
˙˙, 0
)
˙˙0 1
)
˙˙1 2
{
˚˚ 
var
¸¸ 
faces
¸¸ 
=
¸¸ 
mesh
¸¸  
.
¸¸  !#
selectedFacesInternal
¸¸! 6
;
¸¸6 7
var
˝˝ 
edges
˝˝ 
=
˝˝ 
mesh
˝˝  
.
˝˝  !#
selectedEdgesInternal
˝˝! 6
;
˝˝6 7
var
˛˛ 
indices
˛˛ 
=
˛˛ 
mesh
˛˛ "
.
˛˛" #%
selectedIndexesInternal
˛˛# :
;
˛˛: ;
List
ÄÄ 
<
ÄÄ 
int
ÄÄ 
>
ÄÄ 
removed
ÄÄ !
=
ÄÄ" #
new
ÄÄ$ '
List
ÄÄ( ,
<
ÄÄ, -
int
ÄÄ- 0
>
ÄÄ0 1
(
ÄÄ1 2
)
ÄÄ2 3
;
ÄÄ3 4
if
ÇÇ 
(
ÇÇ '
RemoveDegenerateTriangles
ÇÇ -
(
ÇÇ- .
mesh
ÇÇ. 2
,
ÇÇ2 3
removed
ÇÇ4 ;
)
ÇÇ; <
)
ÇÇ< =
{
ÉÉ 
mesh
ÑÑ 
.
ÑÑ 
sharedVertices
ÑÑ '
=
ÑÑ( )
SharedVertex
ÑÑ* 6
.
ÑÑ6 7,
GetSharedVerticesWithPositions
ÑÑ7 U
(
ÑÑU V
mesh
ÑÑV Z
.
ÑÑZ [
positionsInternal
ÑÑ[ l
)
ÑÑl m
;
ÑÑm n%
RebuildSelectionIndexes
ÜÜ +
(
ÜÜ+ ,
mesh
ÜÜ, 0
,
ÜÜ0 1
ref
ÜÜ2 5
faces
ÜÜ6 ;
,
ÜÜ; <
ref
ÜÜ= @
edges
ÜÜA F
,
ÜÜF G
ref
ÜÜH K
indices
ÜÜL S
,
ÜÜS T
removed
ÜÜU \
)
ÜÜ\ ]
;
ÜÜ] ^
mesh
áá 
.
áá #
selectedFacesInternal
áá .
=
áá/ 0
faces
áá1 6
;
áá6 7
mesh
àà 
.
àà #
selectedEdgesInternal
àà .
=
àà/ 0
edges
àà1 6
;
àà6 7
mesh
ââ 
.
ââ %
selectedIndexesInternal
ââ 0
=
ââ1 2
indices
ââ3 :
;
ââ: ;
removedVertices
ää #
=
ää$ %
removed
ää& -
.
ää- .
Count
ää. 3
;
ää3 4
return
ãã 
false
ãã  
;
ãã  !
}
åå 
}
çç 
return
èè 
true
èè 
;
èè 
}
êê 	
}
ëë 
}íí ı'
ãD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ObjectPool.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed 

class 

ObjectPool 
< 
T 
> 
:  
IDisposable! ,
{ 
bool 
m_IsDisposed 
; 
Queue 
< 
T 
> 
m_Pool 
= 
new 
Queue #
<# $
T$ %
>% &
(& '
)' (
;( )
public 
int 
desiredSize 
; 
public 
Func 
< 
T 
> 
constructor "
;" #
public 
Action 
< 
T 
> 

destructor #
;# $
public 

ObjectPool 
( 
int 
initialSize )
,) *
int+ .
desiredSize/ :
,: ;
Func< @
<@ A
TA B
>B C
constructorD O
,O P
ActionQ W
<W X
TX Y
>Y Z

destructor[ e
,e f
boolg k
lazyInitializationl ~
=	 Ä
false
Å Ü
)
Ü á
{ 	
if 
( 
constructor 
== 
null #
)# $
throw 
new !
ArgumentNullException /
(/ 0
$str0 =
)= >
;> ?
if 
( 

destructor 
== 
null "
)" #
throw 
new !
ArgumentNullException /
(/ 0
$str0 <
)< =
;= >
this 
. 
constructor 
= 
constructor *
;* +
this 
. 

destructor 
= 

destructor (
;( )
this 
. 
desiredSize 
= 
desiredSize *
;* +
for   
(   
int   
i   
=   
$num   
;   
i   
<   
initialSize    +
&&  , .
i  / 0
<  1 2
desiredSize  3 >
&&  ? A
!  B C
lazyInitialization  C U
;  U V
i  W X
++  X Z
)  Z [
m_Pool!! 
.!! 
Enqueue!! 
(!! 
constructor!! *
(!!* +
)!!+ ,
)!!, -
;!!- .
}"" 	
public$$ 
T$$ 
Dequeue$$ 
($$ 
)$$ 
{%% 	
if&& 
(&& 
m_Pool&& 
.&& 
Count&& 
>&& 
$num&&  
)&&  !
return'' 
m_Pool'' 
.'' 
Dequeue'' %
(''% &
)''& '
;''' (
return(( 
constructor(( 
((( 
)((  
;((  !
})) 	
public++ 
void++ 
Enqueue++ 
(++ 
T++ 
obj++ !
)++! "
{,, 	
if-- 
(-- 
m_Pool-- 
.-- 
Count-- 
<-- 
desiredSize-- *
)--* +
m_Pool.. 
... 
Enqueue.. 
(.. 
obj.. "
).." #
;..# $
else// 

destructor00 
(00 
obj00 
)00 
;00  
}11 	
public33 
void33 
Empty33 
(33 
)33 
{44 	
int55 
count55 
=55 
m_Pool55 
.55 
Count55 $
;55$ %
for77 
(77 
int77 
i77 
=77 
$num77 
;77 
i77 
<77 
count77  %
;77% &
i77' (
++77( *
)77* +

destructor88 
(88 
m_Pool88 !
.88! "
Dequeue88" )
(88) *
)88* +
)88+ ,
;88, -
}99 	
public;; 
void;; 
Dispose;; 
(;; 
);; 
{<< 	
Dispose== 
(== 
true== 
)== 
;== 
}>> 	
void@@ 
Dispose@@ 
(@@ 
bool@@ 
	disposing@@ #
)@@# $
{AA 	
ifBB 
(BB 
	disposingBB 
&&BB 
!BB 
m_IsDisposedBB *
)BB* +
{CC 
EmptyDD 
(DD 
)DD 
;DD 
m_IsDisposedEE 
=EE 
trueEE #
;EE# $
}FF 
}GG 	
}HH 
}II ≤3
äD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Changelog.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{		 
[

 
Serializable

 
]

 
class 	
ChangelogEntry
 
{ 
[ 	
SerializeField	 
] 
SemVer 
m_VersionInfo 
; 
[ 	
SerializeField	 
] 
string 
m_ReleaseNotes 
; 
public 
SemVer 
versionInfo !
{ 	
get 
{ 
return 
m_VersionInfo &
;& '
}( )
} 	
public 
string 
releaseNotes "
{ 	
get 
{ 
return 
m_ReleaseNotes '
;' (
}) *
} 	
public 
ChangelogEntry 
( 
SemVer $
version% ,
,, -
string. 4
releaseNotes5 A
)A B
{ 	
m_VersionInfo 
= 
version #
;# $
m_ReleaseNotes   
=   
releaseNotes   )
;  ) *
}!! 	
public## 
override## 
string## 
ToString## '
(##' (
)##( )
{$$ 	
return%% 
m_VersionInfo%%  
.%%  !
ToString%%! )
(%%) *
)%%* +
+%%, -
$str%%. 4
+%%5 6
m_ReleaseNotes%%7 E
;%%E F
}&& 	
}'' 
[)) 
Serializable)) 
])) 
class** 	
	Changelog**
 
{++ 
const,, 
string,, #
k_ChangelogEntryPattern,, ,
=,,- .
$str,,/ k
;,,k l
const-- 
string--  
k_VersionInfoPattern-- )
=--* +
$str--, B
;--B C
const.. 
string..  
k_VersionDatePattern.. )
=..* +
$str.., J
;..J K
[00 	
SerializeField00	 
]00 
List11 
<11 
ChangelogEntry11 
>11 
	m_Entries11 &
;11& '
public33 
ReadOnlyCollection33 !
<33! "
ChangelogEntry33" 0
>330 1
entries332 9
{44 	
get55 
{55 
return55 
new55 
ReadOnlyCollection55 /
<55/ 0
ChangelogEntry550 >
>55> ?
(55? @
	m_Entries55@ I
)55I J
;55J K
}55L M
}66 	
public88 
	Changelog88 
(88 
string88 
log88  #
)88# $
{99 	
string:: 
version:: 
=:: 
string:: #
.::# $
Empty::$ )
;::) *
StringBuilder;; 
contents;; "
=;;# $
null;;% )
;;;) *
	m_Entries<< 
=<< 
new<< 
List<<  
<<<  !
ChangelogEntry<<! /
><</ 0
(<<0 1
)<<1 2
;<<2 3
ChangelogEntry== 
entry==  
;==  !
foreach?? 
(?? 
var?? 
line?? 
in??  
log??! $
.??$ %
Split??% *
(??* +
$char??+ /
)??/ 0
)??0 1
{@@ 
ifAA 
(AA 
RegexAA 
.AA 
MatchAA 
(AA  
lineAA  $
,AA$ %#
k_ChangelogEntryPatternAA& =
)AA= >
.AA> ?
SuccessAA? F
)AAF G
{BB 
ifCC 
(CC 
(CC 
entryCC 
=CC  
CreateEntryCC! ,
(CC, -
versionCC- 4
,CC4 5
contentsCC6 >
!=CC? A
nullCCB F
?CCG H
contentsCCI Q
.CCQ R
ToStringCCR Z
(CCZ [
)CC[ \
:CC] ^
$strCC_ a
)CCa b
)CCb c
!=CCd f
nullCCg k
)CCk l
	m_EntriesDD !
.DD! "
AddDD" %
(DD% &
entryDD& +
)DD+ ,
;DD, -
versionFF 
=FF 
lineFF "
;FF" #
contentsGG 
=GG 
newGG "
StringBuilderGG# 0
(GG0 1
)GG1 2
;GG2 3
}HH 
elseII 
{JJ 
ifKK 
(KK 
contentsKK  
!=KK! #
nullKK$ (
)KK( )
contentsLL  
.LL  !

AppendLineLL! +
(LL+ ,
lineLL, 0
)LL0 1
;LL1 2
}MM 
}NN 
ifPP 
(PP 
(PP 
entryPP 
=PP 
CreateEntryPP $
(PP$ %
versionPP% ,
,PP, -
contentsPP. 6
.PP6 7
ToStringPP7 ?
(PP? @
)PP@ A
)PPA B
)PPB C
!=PPD F
nullPPG K
)PPK L
	m_EntriesQQ 
.QQ 
AddQQ 
(QQ 
entryQQ #
)QQ# $
;QQ$ %
}RR 	
ChangelogEntryTT 
CreateEntryTT "
(TT" #
stringTT# )
versionTT* 1
,TT1 2
stringTT3 9
contentsTT: B
)TTB C
{UU 	
varVV 
markVV 
=VV 
RegexVV 
.VV 
MatchVV "
(VV" #
versionVV# *
,VV* + 
k_VersionInfoPatternVV, @
)VV@ A
;VVA B
varWW 
dateWW 
=WW 
RegexWW 
.WW 
MatchWW "
(WW" #
versionWW# *
,WW* + 
k_VersionDatePatternWW, @
)WW@ A
;WWA B
ifYY 
(YY 
markYY 
.YY 
SuccessYY 
)YY 
returnZZ 
newZZ 
ChangelogEntryZZ )
(ZZ) *
newZZ* -
SemVerZZ. 4
(ZZ4 5
markZZ5 9
.ZZ9 :
ValueZZ: ?
,ZZ? @
dateZZA E
.ZZE F
ValueZZF K
)ZZK L
,ZZL M
contentsZZN V
.ZZV W
TrimZZW [
(ZZ[ \
)ZZ\ ]
)ZZ] ^
;ZZ^ _
return\\ 
null\\ 
;\\ 
}]] 	
}^^ 
}__  '
ìD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\HandleConstraint2D.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed		 

class		 
HandleConstraint2D		 #
{

 
public 
int 
x 
, 
y 
; 
public 
HandleConstraint2D !
(! "
int" %
x& '
,' (
int) ,
y- .
). /
{ 	
this 
. 
x 
= 
x 
; 
this 
. 
y 
= 
y 
; 
} 	
public 
HandleConstraint2D !
Inverse" )
() *
)* +
{ 	
return 
new 
HandleConstraint2D )
() *
x* +
==, .
$num/ 0
?1 2
$num3 4
:5 6
$num7 8
,8 9
y: ;
==< >
$num? @
?A B
$numC D
:E F
$numG H
)H I
;I J
} 	
public 
Vector2 
Mask 
( 
Vector2 #
v$ %
)% &
{ 	
v 
. 
x 
*= 
this 
. 
x 
; 
v 
. 
y 
*= 
this 
. 
y 
; 
return 
v 
; 
} 	
public 
Vector2 
InverseMask "
(" #
Vector2# *
v+ ,
), -
{   	
v!! 
.!! 
x!! 
*=!! 
this!! 
.!! 
x!! 
==!! 
$num!! 
?!!  
$num!!! #
:!!$ %
$num!!& (
;!!( )
v"" 
."" 
y"" 
*="" 
this"" 
."" 
y"" 
=="" 
$num"" 
?""  
$num""! #
:""$ %
$num""& (
;""( )
return## 
v## 
;## 
}$$ 	
public&& 
static&& 
readonly&& 
HandleConstraint2D&& 1
None&&2 6
=&&7 8
new&&9 <
HandleConstraint2D&&= O
(&&O P
$num&&P Q
,&&Q R
$num&&S T
)&&T U
;&&U V
public(( 
static(( 
bool(( 
operator(( #
==((# %
(((% &
HandleConstraint2D((& 8
a((9 :
,((: ;
HandleConstraint2D((< N
b((O P
)((P Q
{)) 	
return** 
a** 
.** 
x** 
==** 
b** 
.** 
x** 
&&**  
a**! "
.**" #
y**# $
==**% '
b**( )
.**) *
y*** +
;**+ ,
}++ 	
public-- 
static-- 
bool-- 
operator-- #
!=--# %
(--% &
HandleConstraint2D--& 8
a--9 :
,--: ;
HandleConstraint2D--< N
b--O P
)--P Q
{.. 	
return// 
a// 
.// 
x// 
!=// 
b// 
.// 
x// 
||//  
a//! "
.//" #
y//# $
!=//% '
b//( )
.//) *
y//* +
;//+ ,
}00 	
public22 
override22 
int22 
GetHashCode22 '
(22' (
)22( )
{33 	
return44 
base44 
.44 
GetHashCode44 #
(44# $
)44$ %
;44% &
}55 	
public77 
override77 
bool77 
Equals77 #
(77# $
object77$ *
o77+ ,
)77, -
{88 	
return99 
o99 
is99 
HandleConstraint2D99 *
&&99+ -
(99. /
(99/ 0
HandleConstraint2D990 B
)99B C
o99C D
)99D E
.99E F
x99F G
==99H J
this99K O
.99O P
x99P Q
&&99R T
(99U V
(99V W
HandleConstraint2D99W i
)99i j
o99j k
)99k l
.99l m
y99m n
==99o q
this99r v
.99v w
y99w x
;99x y
}:: 	
public<< 
override<< 
string<< 
ToString<< '
(<<' (
)<<( )
{== 	
return>> 
$str>> 
+>> 
x>> 
+>> 
$str>> !
+>>" #
y>>$ %
+>>& '
$str>>( +
;>>+ ,
}?? 	
}@@ 
}AA ÿı
áD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SemVer.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ 
Serializable 
] 
sealed 

class 
SemVer 
: 

IEquatable $
<$ %
SemVer% +
>+ ,
,, -
IComparable. 9
<9 :
SemVer: @
>@ A
,A B
IComparableC N
{ 
[ 	
SerializeField	 
] 
int 
m_Major 
= 
- 
$num 
; 
[ 	
SerializeField	 
] 
int 
m_Minor 
= 
- 
$num 
; 
[ 	
SerializeField	 
] 
int 
m_Patch 
= 
- 
$num 
; 
[ 	
SerializeField	 
] 
int 
m_Build 
= 
- 
$num 
; 
[ 	
SerializeField	 
] 
string 
m_Type 
; 
[ 	
SerializeField	 
] 
string 

m_Metadata 
; 
[   	
SerializeField  	 
]   
string!! 
m_Date!! 
;!! 
public## 
int## 
major## 
{## 
get## 
{##  
return##! '
m_Major##( /
;##/ 0
}##1 2
}##3 4
public$$ 
int$$ 
minor$$ 
{$$ 
get$$ 
{$$  
return$$! '
m_Minor$$( /
;$$/ 0
}$$1 2
}$$3 4
public%% 
int%% 
patch%% 
{%% 
get%% 
{%%  
return%%! '
m_Patch%%( /
;%%/ 0
}%%1 2
}%%3 4
public&& 
int&& 
build&& 
{&& 
get&& 
{&&  
return&&! '
m_Build&&( /
;&&/ 0
}&&1 2
}&&3 4
public'' 
string'' 
type'' 
{'' 
get''  
{''! "
return''# )
m_Type''* 0
!=''1 3
null''4 8
?''9 :
m_Type''; A
:''B C
$str''D F
;''F G
}''H I
}''J K
public(( 
string(( 
metadata(( 
{((  
get((! $
{((% &
return((' -

m_Metadata((. 8
!=((9 ;
null((< @
?((A B

m_Metadata((C M
:((N O
$str((P R
;((R S
}((T U
}((V W
public)) 
string)) 
date)) 
{)) 
get))  
{))! "
return))# )
m_Date))* 0
!=))1 3
null))4 8
?))9 :
m_Date)); A
:))B C
$str))D F
;))F G
}))H I
}))J K
public.. 
SemVer.. 
MajorMinorPatch.. %
{// 	
get00 
{00 
return00 
new00 
SemVer00 #
(00# $
major00$ )
,00) *
minor00+ 0
,000 1
patch002 7
)007 8
;008 9
}00: ;
}11 	
public33 
const33 
string33 
DefaultStringFormat33 /
=330 1
$str332 =
;33= >
public55 
SemVer55 
(55 
)55 
{66 	
m_Major77 
=77 
$num77 
;77 
m_Minor88 
=88 
$num88 
;88 
m_Patch99 
=99 
$num99 
;99 
m_Build:: 
=:: 
-:: 
$num:: 
;:: 
m_Type;; 
=;; 
null;; 
;;; 
m_Date<< 
=<< 
null<< 
;<< 

m_Metadata== 
=== 
null== 
;== 
}>> 	
public@@ 
SemVer@@ 
(@@ 
string@@ 
	formatted@@ &
,@@& '
string@@( .
date@@/ 3
=@@4 5
null@@6 :
)@@: ;
{AA 	
SemVerBB 
parsedBB 
;BB 

m_MetadataDD 
=DD 
	formattedDD "
;DD" #
m_DateEE 
=EE 
dateEE 
;EE 
ifGG 
(GG 
TryGetVersionInfoGG !
(GG! "
	formattedGG" +
,GG+ ,
outGG- 0
parsedGG1 7
)GG7 8
)GG8 9
{HH 
m_MajorII 
=II 
parsedII  
.II  !
m_MajorII! (
;II( )
m_MinorJJ 
=JJ 
parsedJJ  
.JJ  !
m_MinorJJ! (
;JJ( )
m_PatchKK 
=KK 
parsedKK  
.KK  !
m_PatchKK! (
;KK( )
m_BuildLL 
=LL 
parsedLL  
.LL  !
m_BuildLL! (
;LL( )
m_TypeMM 
=MM 
parsedMM 
.MM  
m_TypeMM  &
;MM& '

m_MetadataNN 
=NN 
parsedNN #
.NN# $
metadataNN$ ,
;NN, -
}OO 
}VV 	
publicXX 
SemVerXX 
(XX 
intXX 
majorXX 
,XX  
intXX! $
minorXX% *
,XX* +
intXX, /
patchXX0 5
,XX5 6
intXX7 :
buildXX; @
=XXA B
-XXC D
$numXXD E
,XXE F
stringXXG M
typeXXN R
=XXS T
nullXXU Y
,XXY Z
stringXX[ a
dateXXb f
=XXg h
nullXXi m
,XXm n
stringXXo u
metadataXXv ~
=	XX Ä
null
XXÅ Ö
)
XXÖ Ü
{YY 	
m_MajorZZ 
=ZZ 
majorZZ 
;ZZ 
m_Minor[[ 
=[[ 
minor[[ 
;[[ 
m_Patch\\ 
=\\ 
patch\\ 
;\\ 
m_Build]] 
=]] 
build]] 
;]] 
m_Type^^ 
=^^ 
type^^ 
;^^ 

m_Metadata__ 
=__ 
metadata__ !
;__! "
m_Date`` 
=`` 
date`` 
;`` 
}aa 	
publiccc 
boolcc 
IsValidcc 
(cc 
)cc 
{dd 	
returnee 
majoree 
!=ee 
-ee 
$numee 
&&ee !
minorff 
!=ff 
-ff 
$numff 
&&ff 
patchgg 
!=gg 
-gg 
$numgg 
;gg 
}hh 	
publicjj 
overridejj 
booljj 
Equalsjj #
(jj# $
objectjj$ *
ojj+ ,
)jj, -
{kk 	
returnll 
oll 
isll 
SemVerll 
&&ll !
Equalsll" (
(ll( )
(ll) *
SemVerll* 0
)ll0 1
oll1 2
)ll2 3
;ll3 4
}mm 	
publicoo 
overrideoo 
intoo 
GetHashCodeoo '
(oo' (
)oo( )
{pp 	
intqq 
hashqq 
=qq 
$numqq 
;qq 
	uncheckedss 
{tt 
ifuu 
(uu 
IsValiduu 
(uu 
)uu 
)uu 
{vv 
hashww 
=ww 
(ww 
hashww  
*ww! "
$numww# $
)ww$ %
+ww& '
majorww( -
.ww- .
GetHashCodeww. 9
(ww9 :
)ww: ;
;ww; <
hashxx 
=xx 
(xx 
hashxx  
*xx! "
$numxx# $
)xx$ %
+xx& '
minorxx( -
.xx- .
GetHashCodexx. 9
(xx9 :
)xx: ;
;xx; <
hashyy 
=yy 
(yy 
hashyy  
*yy! "
$numyy# $
)yy$ %
+yy& '
patchyy( -
.yy- .
GetHashCodeyy. 9
(yy9 :
)yy: ;
;yy; <
hashzz 
=zz 
(zz 
hashzz  
*zz! "
$numzz# $
)zz$ %
+zz& '
buildzz( -
.zz- .
GetHashCodezz. 9
(zz9 :
)zz: ;
;zz; <
hash{{ 
={{ 
({{ 
hash{{  
*{{! "
$num{{# $
){{$ %
+{{& '
type{{( ,
.{{, -
GetHashCode{{- 8
({{8 9
){{9 :
;{{: ;
}|| 
else}} 
{~~ 
return 
string !
.! "
IsNullOrEmpty" /
(/ 0
metadata0 8
)8 9
?: ;
metadata< D
.D E
GetHashCodeE P
(P Q
)Q R
:S T
baseU Y
.Y Z
GetHashCodeZ e
(e f
)f g
;g h
}
ÄÄ 
}
ÅÅ 
return
ÉÉ 
hash
ÉÉ 
;
ÉÉ 
}
ÑÑ 	
public
ÜÜ 
bool
ÜÜ 
Equals
ÜÜ 
(
ÜÜ 
SemVer
ÜÜ !
version
ÜÜ" )
)
ÜÜ) *
{
áá 	
if
àà 
(
àà 
object
àà 
.
àà 
ReferenceEquals
àà &
(
àà& '
version
àà' .
,
àà. /
null
àà0 4
)
àà4 5
)
àà5 6
return
ââ 
false
ââ 
;
ââ 
if
ãã 
(
ãã 
IsValid
ãã 
(
ãã 
)
ãã 
!=
ãã 
version
ãã $
.
ãã$ %
IsValid
ãã% ,
(
ãã, -
)
ãã- .
)
ãã. /
return
åå 
false
åå 
;
åå 
if
éé 
(
éé 
IsValid
éé 
(
éé 
)
éé 
)
éé 
{
èè 
return
êê 
major
êê 
==
êê 
version
êê  '
.
êê' (
major
êê( -
&&
êê. 0
minor
ëë 
==
ëë 
version
ëë $
.
ëë$ %
minor
ëë% *
&&
ëë+ -
patch
íí 
==
íí 
version
íí $
.
íí$ %
patch
íí% *
&&
íí+ -
type
ìì 
.
ìì 
Equals
ìì 
(
ìì  
version
ìì  '
.
ìì' (
type
ìì( ,
)
ìì, -
&&
ìì. 0
build
îî 
.
îî 
Equals
îî  
(
îî  !
version
îî! (
.
îî( )
build
îî) .
)
îî. /
;
îî/ 0
}
ïï 
else
ññ 
{
óó 
if
òò 
(
òò 
string
òò 
.
òò 
IsNullOrEmpty
òò (
(
òò( )
metadata
òò) 1
)
òò1 2
||
òò3 5
string
òò6 <
.
òò< =
IsNullOrEmpty
òò= J
(
òòJ K
version
òòK R
.
òòR S
metadata
òòS [
)
òò[ \
)
òò\ ]
return
ôô 
false
ôô  
;
ôô  !
return
õõ 
metadata
õõ 
.
õõ  
Equals
õõ  &
(
õõ& '
version
õõ' .
.
õõ. /
metadata
õõ/ 7
)
õõ7 8
;
õõ8 9
}
úú 
}
ùù 	
public
üü 
int
üü 
	CompareTo
üü 
(
üü 
object
üü #
obj
üü$ '
)
üü' (
{
†† 	
return
°° 
	CompareTo
°° 
(
°° 
obj
°°  
as
°°! #
SemVer
°°$ *
)
°°* +
;
°°+ ,
}
¢¢ 	
static
§§ 
int
§§ 
WrapNoValue
§§ 
(
§§ 
int
§§ "
value
§§# (
)
§§( )
{
•• 	
return
¶¶ 
value
¶¶ 
<
¶¶ 
$num
¶¶ 
?
¶¶ 
int
¶¶ "
.
¶¶" #
MaxValue
¶¶# +
:
¶¶, -
value
¶¶. 3
;
¶¶3 4
}
ßß 	
public
©© 
int
©© 
	CompareTo
©© 
(
©© 
SemVer
©© #
version
©©$ +
)
©©+ ,
{
™™ 	
const
´´ 
int
´´ 
GREATER
´´ 
=
´´ 
$num
´´  !
;
´´! "
const
¨¨ 
int
¨¨ 
EVEN
¨¨ 
=
¨¨ 
$num
¨¨ 
;
¨¨ 
const
≠≠ 
int
≠≠ 
LESS
≠≠ 
=
≠≠ 
-
≠≠ 
$num
≠≠ 
;
≠≠  
if
ØØ 
(
ØØ 
object
ØØ 
.
ØØ 
ReferenceEquals
ØØ &
(
ØØ& '
version
ØØ' .
,
ØØ. /
null
ØØ0 4
)
ØØ4 5
)
ØØ5 6
return
∞∞ 
GREATER
∞∞ 
;
∞∞ 
if
≤≤ 
(
≤≤ 
Equals
≤≤ 
(
≤≤ 
version
≤≤ 
)
≤≤ 
)
≤≤  
return
≥≥ 
EVEN
≥≥ 
;
≥≥ 
if
µµ 
(
µµ 
major
µµ 
>
µµ 
version
µµ 
.
µµ  
major
µµ  %
)
µµ% &
return
∂∂ 
GREATER
∂∂ 
;
∂∂ 
if
∑∑ 
(
∑∑ 
major
∑∑ 
<
∑∑ 
version
∑∑ 
.
∑∑  
major
∑∑  %
)
∑∑% &
return
∏∏ 
LESS
∏∏ 
;
∏∏ 
if
ππ 
(
ππ 
minor
ππ 
>
ππ 
version
ππ 
.
ππ  
minor
ππ  %
)
ππ% &
return
∫∫ 
GREATER
∫∫ 
;
∫∫ 
if
ªª 
(
ªª 
minor
ªª 
<
ªª 
version
ªª 
.
ªª  
minor
ªª  %
)
ªª% &
return
ºº 
LESS
ºº 
;
ºº 
if
¿¿ 
(
¿¿ 
WrapNoValue
¿¿ 
(
¿¿ 
patch
¿¿ !
)
¿¿! "
>
¿¿# $
WrapNoValue
¿¿% 0
(
¿¿0 1
version
¿¿1 8
.
¿¿8 9
patch
¿¿9 >
)
¿¿> ?
)
¿¿? @
return
¡¡ 
GREATER
¡¡ 
;
¡¡ 
if
¬¬ 
(
¬¬ 
WrapNoValue
¬¬ 
(
¬¬ 
patch
¬¬ !
)
¬¬! "
<
¬¬# $
WrapNoValue
¬¬% 0
(
¬¬0 1
version
¬¬1 8
.
¬¬8 9
patch
¬¬9 >
)
¬¬> ?
)
¬¬? @
return
√√ 
LESS
√√ 
;
√√ 
if
ƒƒ 
(
ƒƒ 
string
ƒƒ 
.
ƒƒ 
IsNullOrEmpty
ƒƒ $
(
ƒƒ$ %
type
ƒƒ% )
)
ƒƒ) *
&&
ƒƒ+ -
!
ƒƒ. /
string
ƒƒ/ 5
.
ƒƒ5 6
IsNullOrEmpty
ƒƒ6 C
(
ƒƒC D
version
ƒƒD K
.
ƒƒK L
type
ƒƒL P
)
ƒƒP Q
)
ƒƒQ R
return
≈≈ 
GREATER
≈≈ 
;
≈≈ 
if
∆∆ 
(
∆∆ 
!
∆∆ 
string
∆∆ 
.
∆∆ 
IsNullOrEmpty
∆∆ %
(
∆∆% &
type
∆∆& *
)
∆∆* +
&&
∆∆, .
string
∆∆/ 5
.
∆∆5 6
IsNullOrEmpty
∆∆6 C
(
∆∆C D
version
∆∆D K
.
∆∆K L
type
∆∆L P
)
∆∆P Q
)
∆∆Q R
return
«« 
LESS
«« 
;
«« 
if
»» 
(
»» 
WrapNoValue
»» 
(
»» 
build
»» !
)
»»! "
>
»»# $
WrapNoValue
»»% 0
(
»»0 1
version
»»1 8
.
»»8 9
build
»»9 >
)
»»> ?
)
»»? @
return
…… 
GREATER
…… 
;
…… 
if
   
(
   
WrapNoValue
   
(
   
build
   !
)
  ! "
<
  # $
WrapNoValue
  % 0
(
  0 1
version
  1 8
.
  8 9
build
  9 >
)
  > ?
)
  ? @
return
ÀÀ 
LESS
ÀÀ 
;
ÀÀ 
return
ÕÕ 
EVEN
ÕÕ 
;
ÕÕ 
}
ŒŒ 	
public
–– 
static
–– 
bool
–– 
operator
–– #
==
––# %
(
––% &
SemVer
––& ,
left
––- 1
,
––1 2
SemVer
––3 9
right
––: ?
)
––? @
{
—— 	
if
““ 
(
““ 
object
““ 
.
““ 
ReferenceEquals
““ &
(
““& '
left
““' +
,
““+ ,
null
““- 1
)
““1 2
)
““2 3
return
”” 
object
”” 
.
”” 
ReferenceEquals
”” -
(
””- .
right
””. 3
,
””3 4
null
””5 9
)
””9 :
;
””: ;
return
’’ 
left
’’ 
.
’’ 
Equals
’’ 
(
’’ 
right
’’ $
)
’’$ %
;
’’% &
}
÷÷ 	
public
ÿÿ 
static
ÿÿ 
bool
ÿÿ 
operator
ÿÿ #
!=
ÿÿ# %
(
ÿÿ% &
SemVer
ÿÿ& ,
left
ÿÿ- 1
,
ÿÿ1 2
SemVer
ÿÿ3 9
right
ÿÿ: ?
)
ÿÿ? @
{
ŸŸ 	
return
⁄⁄ 
!
⁄⁄ 
(
⁄⁄ 
left
⁄⁄ 
==
⁄⁄ 
right
⁄⁄ "
)
⁄⁄" #
;
⁄⁄# $
}
€€ 	
public
›› 
static
›› 
bool
›› 
operator
›› #
<
››# $
(
››$ %
SemVer
››% +
left
››, 0
,
››0 1
SemVer
››2 8
right
››9 >
)
››> ?
{
ﬁﬁ 	
if
ﬂﬂ 
(
ﬂﬂ 
object
ﬂﬂ 
.
ﬂﬂ 
ReferenceEquals
ﬂﬂ &
(
ﬂﬂ& '
left
ﬂﬂ' +
,
ﬂﬂ+ ,
null
ﬂﬂ- 1
)
ﬂﬂ1 2
)
ﬂﬂ2 3
return
‡‡ 
!
‡‡ 
object
‡‡ 
.
‡‡ 
ReferenceEquals
‡‡ .
(
‡‡. /
right
‡‡/ 4
,
‡‡4 5
null
‡‡6 :
)
‡‡: ;
;
‡‡; <
return
‚‚ 
left
‚‚ 
.
‚‚ 
	CompareTo
‚‚ !
(
‚‚! "
right
‚‚" '
)
‚‚' (
<
‚‚) *
$num
‚‚+ ,
;
‚‚, -
}
„„ 	
public
ÂÂ 
static
ÂÂ 
bool
ÂÂ 
operator
ÂÂ #
>
ÂÂ# $
(
ÂÂ$ %
SemVer
ÂÂ% +
left
ÂÂ, 0
,
ÂÂ0 1
SemVer
ÂÂ2 8
right
ÂÂ9 >
)
ÂÂ> ?
{
ÊÊ 	
if
ËË 
(
ËË 
object
ËË 
.
ËË 
ReferenceEquals
ËË &
(
ËË& '
left
ËË' +
,
ËË+ ,
null
ËË- 1
)
ËË1 2
)
ËË2 3
return
ÈÈ 
false
ÈÈ 
;
ÈÈ 
return
ÎÎ 
left
ÎÎ 
.
ÎÎ 
	CompareTo
ÎÎ !
(
ÎÎ! "
right
ÎÎ" '
)
ÎÎ' (
>
ÎÎ) *
$num
ÎÎ+ ,
;
ÎÎ, -
}
ÏÏ 	
public
ÓÓ 
static
ÓÓ 
bool
ÓÓ 
operator
ÓÓ #
<=
ÓÓ$ &
(
ÓÓ& '
SemVer
ÓÓ' -
left
ÓÓ. 2
,
ÓÓ2 3
SemVer
ÓÓ4 :
right
ÓÓ; @
)
ÓÓ@ A
{
ÔÔ 	
return
 
left
 
==
 
right
  
||
! #
left
$ (
<
) *
right
+ 0
;
0 1
}
ÒÒ 	
public
ÛÛ 
static
ÛÛ 
bool
ÛÛ 
operator
ÛÛ #
>=
ÛÛ# %
(
ÛÛ% &
SemVer
ÛÛ& ,
left
ÛÛ- 1
,
ÛÛ1 2
SemVer
ÛÛ3 9
right
ÛÛ: ?
)
ÛÛ? @
{
ÙÙ 	
return
ıı 
left
ıı 
==
ıı 
right
ıı  
||
ıı! #
left
ıı$ (
>
ıı) *
right
ıı+ 0
;
ıı0 1
}
ˆˆ 	
public
àà 
string
àà 
ToString
àà 
(
àà 
string
àà %
format
àà& ,
)
àà, -
{
ââ 	
var
ää 
sb
ää 
=
ää 
new
ää 
StringBuilder
ää &
(
ää& '
)
ää' (
;
ää( )
bool
ãã 
skip
ãã 
=
ãã 
false
ãã 
;
ãã 
foreach
çç 
(
çç 
char
çç 
c
çç 
in
çç 
format
çç %
.
çç% &
ToCharArray
çç& 1
(
çç1 2
)
çç2 3
)
çç3 4
{
éé 
if
èè 
(
èè 
skip
èè 
)
èè 
{
êê 
sb
ëë 
.
ëë 
Append
ëë 
(
ëë 
c
ëë 
)
ëë  
;
ëë  !
skip
íí 
=
íí 
false
íí  
;
íí  !
continue
ìì 
;
ìì 
}
îî 
if
ññ 
(
ññ 
c
ññ 
==
ññ 
$char
ññ 
)
ññ 
skip
óó 
=
óó 
true
óó 
;
óó  
else
òò 
if
òò 
(
òò 
c
òò 
==
òò 
$char
òò !
)
òò! "
sb
ôô 
.
ôô 
Append
ôô 
(
ôô 
major
ôô #
)
ôô# $
;
ôô$ %
else
öö 
if
öö 
(
öö 
c
öö 
==
öö 
$char
öö !
)
öö! "
sb
õõ 
.
õõ 
Append
õõ 
(
õõ 
minor
õõ #
)
õõ# $
;
õõ$ %
else
úú 
if
úú 
(
úú 
c
úú 
==
úú 
$char
úú !
)
úú! "
sb
ùù 
.
ùù 
Append
ùù 
(
ùù 
patch
ùù #
)
ùù# $
;
ùù$ %
else
ûû 
if
ûû 
(
ûû 
c
ûû 
==
ûû 
$char
ûû !
)
ûû! "
sb
üü 
.
üü 
Append
üü 
(
üü 
build
üü #
)
üü# $
;
üü$ %
else
†† 
if
†† 
(
†† 
c
†† 
==
†† 
$char
†† !
||
††" $
c
††% &
==
††' )
$char
††* -
)
††- .
sb
°° 
.
°° 
Append
°° 
(
°° 
type
°° "
)
°°" #
;
°°# $
else
¢¢ 
if
¢¢ 
(
¢¢ 
c
¢¢ 
==
¢¢ 
$char
¢¢ !
)
¢¢! "
sb
££ 
.
££ 
Append
££ 
(
££ 
date
££ "
)
££" #
;
££# $
else
§§ 
if
§§ 
(
§§ 
c
§§ 
==
§§ 
$char
§§ !
)
§§! "
sb
•• 
.
•• 
Append
•• 
(
•• 
metadata
•• &
)
••& '
;
••' (
else
¶¶ 
sb
ßß 
.
ßß 
Append
ßß 
(
ßß 
c
ßß 
)
ßß  
;
ßß  !
}
®® 
return
™™ 
sb
™™ 
.
™™ 
ToString
™™ 
(
™™ 
)
™™  
;
™™  !
}
´´ 	
public
±± 
override
±± 
string
±± 
ToString
±± '
(
±±' (
)
±±( )
{
≤≤ 	
var
≥≥ 
sb
≥≥ 
=
≥≥ 
new
≥≥ 
StringBuilder
≥≥ &
(
≥≥& '
)
≥≥' (
;
≥≥( )
sb
µµ 
.
µµ 
Append
µµ 
(
µµ 
ToString
µµ 
(
µµ 
$str
µµ &
)
µµ& '
)
µµ' (
;
µµ( )
if
∑∑ 
(
∑∑ 
!
∑∑ 
string
∑∑ 
.
∑∑ 
IsNullOrEmpty
∑∑ %
(
∑∑% &
type
∑∑& *
)
∑∑* +
)
∑∑+ ,
{
∏∏ 
sb
ππ 
.
ππ 
Append
ππ 
(
ππ 
$str
ππ 
)
ππ 
;
ππ 
sb
∫∫ 
.
∫∫ 
Append
∫∫ 
(
∫∫ 
type
∫∫ 
)
∫∫ 
;
∫∫  
if
ºº 
(
ºº 
build
ºº 
>
ºº 
-
ºº 
$num
ºº 
)
ºº 
{
ΩΩ 
sb
ææ 
.
ææ 
Append
ææ 
(
ææ 
$str
ææ !
)
ææ! "
;
ææ" #
sb
øø 
.
øø 
Append
øø 
(
øø 
build
øø #
.
øø# $
ToString
øø$ ,
(
øø, -
)
øø- .
)
øø. /
;
øø/ 0
}
¿¿ 
}
¡¡ 
if
√√ 
(
√√ 
!
√√ 
string
√√ 
.
√√ 
IsNullOrEmpty
√√ %
(
√√% &
date
√√& *
)
√√* +
)
√√+ ,
{
ƒƒ 
sb
≈≈ 
.
≈≈ 
Append
≈≈ 
(
≈≈ 
$str
≈≈ 
)
≈≈ 
;
≈≈ 
sb
∆∆ 
.
∆∆ 
Append
∆∆ 
(
∆∆ 
date
∆∆ 
)
∆∆ 
;
∆∆  
}
«« 
return
…… 
sb
…… 
.
…… 
ToString
…… 
(
…… 
)
……  
;
……  !
}
   	
public
‘‘ 
static
‘‘ 
bool
‘‘ 
TryGetVersionInfo
‘‘ ,
(
‘‘, -
string
‘‘- 3
input
‘‘4 9
,
‘‘9 :
out
‘‘; >
SemVer
‘‘? E
version
‘‘F M
)
‘‘M N
{
’’ 	
version
÷÷ 
=
÷÷ 
new
÷÷ 
SemVer
÷÷  
(
÷÷  !
)
÷÷! "
;
÷÷" #
bool
◊◊ 
ret
◊◊ 
=
◊◊ 
false
◊◊ 
;
◊◊ 
const
ŸŸ 
string
ŸŸ $
k_MajorMinorPatchRegex
ŸŸ /
=
ŸŸ0 1
$str
ŸŸ2 O
;
ŸŸO P
const
⁄⁄ 
string
⁄⁄ #
k_VersionReleaseRegex
⁄⁄ .
=
⁄⁄/ 0
$str
⁄⁄1 K
;
⁄⁄K L
const
€€ 
string
€€ !
k_VersionBuildRegex
€€ ,
=
€€- .
$str
€€/ R
;
€€R S
const
‹‹ 
string
‹‹ 
k_MetadataRegex
‹‹ (
=
‹‹) *
$str
‹‹+ 7
;
‹‹7 8
try
ﬁﬁ 
{
ﬂﬂ 
var
‡‡ 
mmp
‡‡ 
=
‡‡ 
Regex
‡‡ 
.
‡‡  
Match
‡‡  %
(
‡‡% &
input
‡‡& +
,
‡‡+ ,$
k_MajorMinorPatchRegex
‡‡- C
)
‡‡C D
;
‡‡D E
if
‚‚ 
(
‚‚ 
!
‚‚ 
mmp
‚‚ 
.
‚‚ 
Success
‚‚  
)
‚‚  !
return
„„ 
false
„„  
;
„„  !
string
ÂÂ 
[
ÂÂ 
]
ÂÂ 
mmpSplit
ÂÂ !
=
ÂÂ" #
mmp
ÂÂ$ '
.
ÂÂ' (
Value
ÂÂ( -
.
ÂÂ- .
Split
ÂÂ. 3
(
ÂÂ3 4
$char
ÂÂ4 7
)
ÂÂ7 8
;
ÂÂ8 9
int
ÁÁ 
.
ÁÁ 
TryParse
ÁÁ 
(
ÁÁ 
mmpSplit
ÁÁ %
[
ÁÁ% &
$num
ÁÁ& '
]
ÁÁ' (
,
ÁÁ( )
out
ÁÁ* -
version
ÁÁ. 5
.
ÁÁ5 6
m_Major
ÁÁ6 =
)
ÁÁ= >
;
ÁÁ> ?
int
ËË 
.
ËË 
TryParse
ËË 
(
ËË 
mmpSplit
ËË %
[
ËË% &
$num
ËË& '
]
ËË' (
,
ËË( )
out
ËË* -
version
ËË. 5
.
ËË5 6
m_Minor
ËË6 =
)
ËË= >
;
ËË> ?
int
ÈÈ 
.
ÈÈ 
TryParse
ÈÈ 
(
ÈÈ 
mmpSplit
ÈÈ %
[
ÈÈ% &
$num
ÈÈ& '
]
ÈÈ' (
,
ÈÈ( )
out
ÈÈ* -
version
ÈÈ. 5
.
ÈÈ5 6
m_Patch
ÈÈ6 =
)
ÈÈ= >
;
ÈÈ> ?
ret
ÎÎ 
=
ÎÎ 
true
ÎÎ 
;
ÎÎ 
var
ÓÓ 
preReleaseVersion
ÓÓ %
=
ÓÓ& '
Regex
ÓÓ( -
.
ÓÓ- .
Match
ÓÓ. 3
(
ÓÓ3 4
input
ÓÓ4 9
,
ÓÓ9 :#
k_VersionReleaseRegex
ÓÓ; P
)
ÓÓP Q
;
ÓÓQ R
if
 
(
 
preReleaseVersion
 %
.
% &
Success
& -
)
- .
version
ÒÒ 
.
ÒÒ 
m_Type
ÒÒ "
=
ÒÒ# $
preReleaseVersion
ÒÒ% 6
.
ÒÒ6 7
Value
ÒÒ7 <
;
ÒÒ< =
var
ÛÛ 
preReleaseBuild
ÛÛ #
=
ÛÛ$ %
Regex
ÛÛ& +
.
ÛÛ+ ,
Match
ÛÛ, 1
(
ÛÛ1 2
input
ÛÛ2 7
,
ÛÛ7 8!
k_VersionBuildRegex
ÛÛ9 L
)
ÛÛL M
;
ÛÛM N
version
ÙÙ 
.
ÙÙ 
m_Build
ÙÙ 
=
ÙÙ  !
preReleaseBuild
ÙÙ" 1
.
ÙÙ1 2
Success
ÙÙ2 9
?
ÙÙ: ;
GetBuildNumber
ÙÙ< J
(
ÙÙJ K
preReleaseBuild
ÙÙK Z
.
ÙÙZ [
Value
ÙÙ[ `
)
ÙÙ` a
:
ÙÙb c
-
ÙÙd e
$num
ÙÙe f
;
ÙÙf g
var
ˆˆ 
meta
ˆˆ 
=
ˆˆ 
Regex
ˆˆ  
.
ˆˆ  !
Match
ˆˆ! &
(
ˆˆ& '
input
ˆˆ' ,
,
ˆˆ, -
k_MetadataRegex
ˆˆ. =
)
ˆˆ= >
;
ˆˆ> ?
if
¯¯ 
(
¯¯ 
meta
¯¯ 
.
¯¯ 
Success
¯¯  
)
¯¯  !
version
˘˘ 
.
˘˘ 

m_Metadata
˘˘ &
=
˘˘' (
meta
˘˘) -
.
˘˘- .
Value
˘˘. 3
;
˘˘3 4
}
˙˙ 
catch
˚˚ 
{
¸¸ 
ret
˝˝ 
=
˝˝ 
false
˝˝ 
;
˝˝ 
}
˛˛ 
return
ÄÄ 
ret
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
static
ÉÉ 
int
ÉÉ 
GetBuildNumber
ÉÉ !
(
ÉÉ! "
string
ÉÉ" (
input
ÉÉ) .
)
ÉÉ. /
{
ÑÑ 	
var
ÖÖ 
number
ÖÖ 
=
ÖÖ 
Regex
ÖÖ 
.
ÖÖ 
Match
ÖÖ $
(
ÖÖ$ %
input
ÖÖ% *
,
ÖÖ* +
$str
ÖÖ, 4
)
ÖÖ4 5
;
ÖÖ5 6
int
áá 
buildNo
áá 
=
áá 
$num
áá 
;
áá 
if
ââ 
(
ââ 
number
ââ 
.
ââ 
Success
ââ 
&&
ââ !
int
ââ" %
.
ââ% &
TryParse
ââ& .
(
ââ. /
number
ââ/ 5
.
ââ5 6
Value
ââ6 ;
,
ââ; <
out
ââ= @
buildNo
ââA H
)
ââH I
)
ââI J
return
ää 
buildNo
ää 
;
ää 
return
åå 
-
åå 
$num
åå 
;
åå 
}
çç 	
}
éé 
}èè ¢/
çD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ColorPalette.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{		 
[ 
Serializable 
] 
sealed 

class 
ColorPalette 
: 
ScriptableObject  0
,0 1
IHasDefault2 =
{ 
public 
Color 
current 
{ 
get "
;" #
set$ '
;' (
}) *
[ 	 
FormerlySerializedAs	 
( 
$str &
)& '
]' (
[ 	
SerializeField	 
] 
List 
< 
Color 
> 
m_Colors 
; 
public 
ReadOnlyCollection !
<! "
Color" '
>' (
colors) /
{ 	
get   
{   
return   
new   
ReadOnlyCollection   /
<  / 0
Color  0 5
>  5 6
(  6 7
m_Colors  7 ?
)  ? @
;  @ A
}  B C
}!! 	
public(( 
void(( 
	SetColors(( 
((( 
IEnumerable(( )
<(() *
Color((* /
>((/ 0
colors((1 7
)((7 8
{)) 	
if** 
(** 
colors** 
==** 
null** 
)** 
throw++ 
new++ !
ArgumentNullException++ /
(++/ 0
$str++0 8
)++8 9
;++9 :
m_Colors-- 
=-- 
colors-- 
.-- 
ToList-- $
(--$ %
)--% &
;--& '
}.. 	
public44 
void44 
SetDefaultValues44 $
(44$ %
)44% &
{55 	
m_Colors66 
=66 
new66 
List66 
<66  
Color66  %
>66% &
(66& '
)66' (
{77 
new88 
Color88 
(88 
$num88  
,88  !
$num88" (
,88( )
$num88* 0
,880 1
$num882 4
)884 5
,885 6
new99 
Color99 
(99 
$num99  
,99  !
$num99" (
,99( )
$num99* 0
,990 1
$num992 4
)994 5
,995 6
new:: 
Color:: 
(:: 
$num::  
,::  !
$num::" (
,::( )
$num::* 0
,::0 1
$num::2 4
)::4 5
,::5 6
new;; 
Color;; 
(;; 
$num;;  
,;;  !
$num;;" (
,;;( )
$num;;* 0
,;;0 1
$num;;2 4
);;4 5
,;;5 6
new<< 
Color<< 
(<< 
$num<<  
,<<  !
$num<<" (
,<<( )
$num<<* 0
,<<0 1
$num<<2 4
)<<4 5
,<<5 6
new== 
Color== 
(== 
$num==  
,==  !
$num==" (
,==( )
$num==* 0
,==0 1
$num==2 4
)==4 5
,==5 6
new>> 
Color>> 
(>> 
$num>>  
,>>  !
$num>>" (
,>>( )
$num>>* 0
,>>0 1
$num>>2 4
)>>4 5
,>>5 6
new?? 
Color?? 
(?? 
$num??  
,??  !
$num??" (
,??( )
$num??* 0
,??0 1
$num??2 4
)??4 5
,??5 6
new@@ 
Color@@ 
(@@ 
$num@@  
,@@  !
$num@@" (
,@@( )
$num@@* 0
,@@0 1
$num@@2 4
)@@4 5
,@@5 6
newAA 
ColorAA 
(AA 
$numAA  
,AA  !
$numAA" (
,AA( )
$numAA* 0
,AA0 1
$numAA2 4
)AA4 5
,AA5 6
newBB 
ColorBB 
(BB 
$numBB  
,BB  !
$numBB" (
,BB( )
$numBB* 0
,BB0 1
$numBB2 4
)BB4 5
,BB5 6
newCC 
ColorCC 
(CC 
$numCC  
,CC  !
$numCC" (
,CC( )
$numCC* 0
,CC0 1
$numCC2 4
)CC4 5
,CC5 6
newDD 
ColorDD 
(DD 
$numDD  
,DD  !
$numDD" (
,DD( )
$numDD* 0
,DD0 1
$numDD2 4
)DD4 5
,DD5 6
newEE 
ColorEE 
(EE 
$numEE  
,EE  !
$numEE" (
,EE( )
$numEE* 0
,EE0 1
$numEE2 4
)EE4 5
,EE5 6
newFF 
ColorFF 
(FF 
$numFF  
,FF  !
$numFF" (
,FF( )
$numFF* 0
,FF0 1
$numFF2 4
)FF4 5
,FF5 6
newGG 
ColorGG 
(GG 
$numGG  
,GG  !
$numGG" (
,GG( )
$numGG* 0
,GG0 1
$numGG2 4
)GG4 5
}HH 
;HH 
}II 	
publicQQ 
ColorQQ 
thisQQ 
[QQ 
intQQ 
iQQ 
]QQ  
{RR 	
getSS 
{SS 
returnSS 
m_ColorsSS !
[SS! "
iSS" #
]SS# $
;SS$ %
}SS& '
setTT 
{TT 
m_ColorsTT 
[TT 
iTT 
]TT 
=TT 
valueTT  %
;TT% &
}TT' (
}UU 	
publicZZ 
intZZ 
CountZZ 
{[[ 	
get\\ 
{\\ 
return\\ 
m_Colors\\ !
.\\! "
Count\\" '
;\\' (
}\\) *
}]] 	
}^^ 
}__ ≤ß
çD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SharedVertex.cs
	namespace		 	
UnityEngine		
 
.		 

ProBuilder		  
{

 
[ 
Serializable 
] 
public 

sealed 
class 
SharedVertex $
:% &
ICollection' 2
<2 3
int3 6
>6 7
{ 
[ 	
SerializeField	 
] 
[ 	 
FormerlySerializedAs	 
( 
$str %
)% &
]& '
[ 	 
FormerlySerializedAs	 
( 
$str *
)* +
]+ ,
int 
[ 
] 

m_Vertices 
; 
internal 
int 
[ 
] 
arrayInternal $
{ 	
get 
{ 
return 

m_Vertices #
;# $
}% &
} 	
public%% 
SharedVertex%% 
(%% 
IEnumerable%% '
<%%' (
int%%( +
>%%+ ,
indexes%%- 4
)%%4 5
{&& 	
if'' 
('' 
indexes'' 
=='' 
null'' 
)''  
throw(( 
new(( !
ArgumentNullException(( /
(((/ 0
$str((0 9
)((9 :
;((: ;

m_Vertices)) 
=)) 
indexes))  
.))  !
ToArray))! (
())( )
)))) *
;))* +
}** 	
public00 
SharedVertex00 
(00 
SharedVertex00 (
sharedVertex00) 5
)005 6
{11 	
if22 
(22 
sharedVertex22 
==22 
null22  $
)22$ %
throw33 
new33 !
ArgumentNullException33 /
(33/ 0
$str330 >
)33> ?
;33? @

m_Vertices44 
=44 
new44 
int44  
[44  !
sharedVertex44! -
.44- .
Count44. 3
]443 4
;444 5
Array55 
.55 
Copy55 
(55 
sharedVertex55 #
.55# $

m_Vertices55$ .
,55. /

m_Vertices550 :
,55: ;

m_Vertices55< F
.55F G
Length55G M
)55M N
;55N O
}66 	
public<< 
int<< 
this<< 
[<< 
int<< 
i<< 
]<< 
{== 	
get>> 
{>> 
return>> 

m_Vertices>> #
[>># $
i>>$ %
]>>% &
;>>& '
}>>( )
set?? 
{?? 

m_Vertices?? 
[?? 
i?? 
]?? 
=??  !
value??" '
;??' (
}??) *
}@@ 	
publicCC 
IEnumeratorCC 
<CC 
intCC 
>CC 
GetEnumeratorCC  -
(CC- .
)CC. /
{DD 	
returnEE 
(EE 
(EE 
IEnumerableEE  
<EE  !
intEE! $
>EE$ %
)EE% &

m_VerticesEE& 0
)EE0 1
.EE1 2
GetEnumeratorEE2 ?
(EE? @
)EE@ A
;EEA B
}FF 	
publicII 
overrideII 
stringII 
ToStringII '
(II' (
)II( )
{JJ 	
returnKK 

m_VerticesKK 
.KK 
ToStringKK &
(KK& '
$strKK' *
)KK* +
;KK+ ,
}LL 	
IEnumeratorOO 
IEnumerableOO 
.OO  
GetEnumeratorOO  -
(OO- .
)OO. /
{PP 	
returnQQ 
GetEnumeratorQQ  
(QQ  !
)QQ! "
;QQ" #
}RR 	
publicUU 
voidUU 
AddUU 
(UU 
intUU 
itemUU  
)UU  !
{VV 	

m_VerticesWW 
=WW 
ArrayUtilityWW %
.WW% &
AddWW& )
(WW) *

m_VerticesWW* 4
,WW4 5
itemWW6 :
)WW: ;
;WW; <
}XX 	
public[[ 
void[[ 
Clear[[ 
([[ 
)[[ 
{\\ 	

m_Vertices]] 
=]] 
new]] 
int]]  
[]]  !
$num]]! "
]]]" #
;]]# $
}^^ 	
publicaa 
boolaa 
Containsaa 
(aa 
intaa  
itemaa! %
)aa% &
{bb 	
returncc 
Arraycc 
.cc 
IndexOfcc  
(cc  !

m_Verticescc! +
,cc+ ,
itemcc- 1
)cc1 2
>cc3 4
-cc5 6
$numcc6 7
;cc7 8
}dd 	
publicgg 
voidgg 
CopyTogg 
(gg 
intgg 
[gg 
]gg  
arraygg! &
,gg& '
intgg( +

arrayIndexgg, 6
)gg6 7
{hh 	

m_Verticesii 
.ii 
CopyToii 
(ii 
arrayii #
,ii# $

arrayIndexii% /
)ii/ 0
;ii0 1
}jj 	
publicmm 
boolmm 
Removemm 
(mm 
intmm 
itemmm #
)mm# $
{nn 	
intoo 
indoo 
=oo 
Arrayoo 
.oo 
IndexOfoo #
(oo# $

m_Verticesoo$ .
,oo. /
itemoo0 4
)oo4 5
;oo5 6
ifpp 
(pp 
indpp 
<pp 
$numpp 
)pp 
returnqq 
falseqq 
;qq 

m_Verticesrr 
=rr 

m_Verticesrr #
.rr# $
RemoveAtrr$ ,
(rr, -
itemrr- 1
)rr1 2
;rr2 3
returnss 
truess 
;ss 
}tt 	
publicww 
intww 
Countww 
{xx 	
getyy 
{yy 
returnyy 

m_Verticesyy #
.yy# $
Lengthyy$ *
;yy* +
}yy, -
}zz 	
public}} 
bool}} 

IsReadOnly}} 
{~~ 	
get 
{ 
return 

m_Vertices #
.# $

IsReadOnly$ .
;. /
}0 1
}
ÄÄ 	
public
éé 
static
éé 
void
éé #
GetSharedVertexLookup
éé 0
(
éé0 1
IList
éé1 6
<
éé6 7
SharedVertex
éé7 C
>
ééC D
sharedVertices
ééE S
,
ééS T

Dictionary
ééU _
<
éé_ `
int
éé` c
,
ééc d
int
éée h
>
ééh i
lookup
ééj p
)
éép q
{
èè 	
lookup
êê 
.
êê 
Clear
êê 
(
êê 
)
êê 
;
êê 
for
íí 
(
íí 
int
íí 
i
íí 
=
íí 
$num
íí 
,
íí 
c
íí 
=
íí 
sharedVertices
íí -
.
íí- .
Count
íí. 3
;
íí3 4
i
íí5 6
<
íí7 8
c
íí9 :
;
íí: ;
i
íí< =
++
íí= ?
)
íí? @
{
ìì 
foreach
îî 
(
îî 
var
îî 
index
îî "
in
îî# %
sharedVertices
îî& 4
[
îî4 5
i
îî5 6
]
îî6 7
)
îî7 8
{
ïï 
if
ññ 
(
ññ 
!
ññ 
lookup
ññ 
.
ññ  
ContainsKey
ññ  +
(
ññ+ ,
index
ññ, 1
)
ññ1 2
)
ññ2 3
lookup
óó 
.
óó 
Add
óó "
(
óó" #
index
óó# (
,
óó( )
i
óó* +
)
óó+ ,
;
óó, -
}
òò 
}
ôô 
}
öö 	
internal
úú 
void
úú 
ShiftIndexes
úú "
(
úú" #
int
úú# &
offset
úú' -
)
úú- .
{
ùù 	
for
ûû 
(
ûû 
int
ûû 
i
ûû 
=
ûû 
$num
ûû 
,
ûû 
c
ûû 
=
ûû 
Count
ûû  %
;
ûû% &
i
ûû' (
<
ûû) *
c
ûû+ ,
;
ûû, -
i
ûû. /
++
ûû/ 1
)
ûû1 2

m_Vertices
üü 
[
üü 
i
üü 
]
üü 
+=
üü  
offset
üü! '
;
üü' (
}
†† 	
internal
ßß 
static
ßß 
SharedVertex
ßß $
[
ßß$ %
]
ßß% &
ToSharedVertices
ßß' 7
(
ßß7 8
IEnumerable
ßß8 C
<
ßßC D
KeyValuePair
ßßD P
<
ßßP Q
int
ßßQ T
,
ßßT U
int
ßßV Y
>
ßßY Z
>
ßßZ [
lookup
ßß\ b
)
ßßb c
{
®® 	
if
©© 
(
©© 
lookup
©© 
==
©© 
null
©© 
)
©© 
return
™™ 
new
™™ 
SharedVertex
™™ '
[
™™' (
$num
™™( )
]
™™) *
;
™™* +

Dictionary
¨¨ 
<
¨¨ 
int
¨¨ 
,
¨¨ 
int
¨¨ 
>
¨¨  
map
¨¨! $
=
¨¨% &
new
¨¨' *

Dictionary
¨¨+ 5
<
¨¨5 6
int
¨¨6 9
,
¨¨9 :
int
¨¨; >
>
¨¨> ?
(
¨¨? @
)
¨¨@ A
;
¨¨A B
List
≠≠ 
<
≠≠ 
List
≠≠ 
<
≠≠ 
int
≠≠ 
>
≠≠ 
>
≠≠ 
shared
≠≠ "
=
≠≠# $
new
≠≠% (
List
≠≠) -
<
≠≠- .
List
≠≠. 2
<
≠≠2 3
int
≠≠3 6
>
≠≠6 7
>
≠≠7 8
(
≠≠8 9
)
≠≠9 :
;
≠≠: ;
foreach
ØØ 
(
ØØ 
var
ØØ 
kvp
ØØ 
in
ØØ 
lookup
ØØ  &
)
ØØ& '
{
∞∞ 
if
±± 
(
±± 
kvp
±± 
.
±± 
Value
±± 
<
±± 
$num
±±  !
)
±±! "
{
≤≤ 
shared
≥≥ 
.
≥≥ 
Add
≥≥ 
(
≥≥ 
new
≥≥ "
List
≥≥# '
<
≥≥' (
int
≥≥( +
>
≥≥+ ,
(
≥≥, -
)
≥≥- .
{
≥≥/ 0
kvp
≥≥1 4
.
≥≥4 5
Key
≥≥5 8
}
≥≥9 :
)
≥≥: ;
;
≥≥; <
}
¥¥ 
else
µµ 
{
∂∂ 
int
∑∑ 
index
∑∑ 
=
∑∑ 
-
∑∑  !
$num
∑∑! "
;
∑∑" #
if
ππ 
(
ππ 
map
ππ 
.
ππ 
TryGetValue
ππ '
(
ππ' (
kvp
ππ( +
.
ππ+ ,
Value
ππ, 1
,
ππ1 2
out
ππ3 6
index
ππ7 <
)
ππ< =
)
ππ= >
{
∫∫ 
shared
ªª 
[
ªª 
index
ªª $
]
ªª$ %
.
ªª% &
Add
ªª& )
(
ªª) *
kvp
ªª* -
.
ªª- .
Key
ªª. 1
)
ªª1 2
;
ªª2 3
}
ºº 
else
ΩΩ 
{
ææ 
map
øø 
.
øø 
Add
øø 
(
øø  
kvp
øø  #
.
øø# $
Value
øø$ )
,
øø) *
shared
øø+ 1
.
øø1 2
Count
øø2 7
)
øø7 8
;
øø8 9
shared
¿¿ 
.
¿¿ 
Add
¿¿ "
(
¿¿" #
new
¿¿# &
List
¿¿' +
<
¿¿+ ,
int
¿¿, /
>
¿¿/ 0
(
¿¿0 1
)
¿¿1 2
{
¿¿3 4
kvp
¿¿5 8
.
¿¿8 9
Key
¿¿9 <
}
¿¿= >
)
¿¿> ?
;
¿¿? @
}
¡¡ 
}
¬¬ 
}
√√ 
return
≈≈ 
ToSharedVertices
≈≈ #
(
≈≈# $
shared
≈≈$ *
)
≈≈* +
;
≈≈+ ,
}
∆∆ 	
static
»» 
SharedVertex
»» 
[
»» 
]
»» 
ToSharedVertices
»» .
(
»». /
List
»»/ 3
<
»»3 4
List
»»4 8
<
»»8 9
int
»»9 <
>
»»< =
>
»»= >
list
»»? C
)
»»C D
{
…… 	
if
   
(
   
list
   
==
   
null
   
)
   
throw
ÀÀ 
new
ÀÀ #
ArgumentNullException
ÀÀ /
(
ÀÀ/ 0
$str
ÀÀ0 6
)
ÀÀ6 7
;
ÀÀ7 8
SharedVertex
ÃÃ 
[
ÃÃ 
]
ÃÃ 
arr
ÃÃ 
=
ÃÃ  
new
ÃÃ! $
SharedVertex
ÃÃ% 1
[
ÃÃ1 2
list
ÃÃ2 6
.
ÃÃ6 7
Count
ÃÃ7 <
]
ÃÃ< =
;
ÃÃ= >
for
ÕÕ 
(
ÕÕ 
int
ÕÕ 
i
ÕÕ 
=
ÕÕ 
$num
ÕÕ 
;
ÕÕ 
i
ÕÕ 
<
ÕÕ 
arr
ÕÕ  #
.
ÕÕ# $
Length
ÕÕ$ *
;
ÕÕ* +
i
ÕÕ, -
++
ÕÕ- /
)
ÕÕ/ 0
arr
ŒŒ 
[
ŒŒ 
i
ŒŒ 
]
ŒŒ 
=
ŒŒ 
new
ŒŒ 
SharedVertex
ŒŒ )
(
ŒŒ) *
list
ŒŒ* .
[
ŒŒ. /
i
ŒŒ/ 0
]
ŒŒ0 1
)
ŒŒ1 2
;
ŒŒ2 3
return
œœ 
arr
œœ 
;
œœ 
}
–– 	
public
ﬂﬂ 
static
ﬂﬂ 
SharedVertex
ﬂﬂ "
[
ﬂﬂ" #
]
ﬂﬂ# $,
GetSharedVerticesWithPositions
ﬂﬂ% C
(
ﬂﬂC D
IList
ﬂﬂD I
<
ﬂﬂI J
Vector3
ﬂﬂJ Q
>
ﬂﬂQ R
	positions
ﬂﬂS \
)
ﬂﬂ\ ]
{
‡‡ 	
if
·· 
(
·· 
	positions
·· 
==
·· 
null
·· !
)
··! "
throw
‚‚ 
new
‚‚ #
ArgumentNullException
‚‚ /
(
‚‚/ 0
$str
‚‚0 ;
)
‚‚; <
;
‚‚< =

Dictionary
‰‰ 
<
‰‰ 
IntVec3
‰‰ 
,
‰‰ 
List
‰‰  $
<
‰‰$ %
int
‰‰% (
>
‰‰( )
>
‰‰) *
sorted
‰‰+ 1
=
‰‰2 3
new
‰‰4 7

Dictionary
‰‰8 B
<
‰‰B C
IntVec3
‰‰C J
,
‰‰J K
List
‰‰L P
<
‰‰P Q
int
‰‰Q T
>
‰‰T U
>
‰‰U V
(
‰‰V W
)
‰‰W X
;
‰‰X Y
for
ÊÊ 
(
ÊÊ 
int
ÊÊ 
i
ÊÊ 
=
ÊÊ 
$num
ÊÊ 
;
ÊÊ 
i
ÊÊ 
<
ÊÊ 
	positions
ÊÊ  )
.
ÊÊ) *
Count
ÊÊ* /
;
ÊÊ/ 0
i
ÊÊ1 2
++
ÊÊ2 4
)
ÊÊ4 5
{
ÁÁ 
List
ËË 
<
ËË 
int
ËË 
>
ËË 
ind
ËË 
;
ËË 
if
ÈÈ 
(
ÈÈ 
sorted
ÈÈ 
.
ÈÈ 
TryGetValue
ÈÈ &
(
ÈÈ& '
	positions
ÈÈ' 0
[
ÈÈ0 1
i
ÈÈ1 2
]
ÈÈ2 3
,
ÈÈ3 4
out
ÈÈ5 8
ind
ÈÈ9 <
)
ÈÈ< =
)
ÈÈ= >
ind
ÍÍ 
.
ÍÍ 
Add
ÍÍ 
(
ÍÍ 
i
ÍÍ 
)
ÍÍ 
;
ÍÍ 
else
ÎÎ 
sorted
ÏÏ 
.
ÏÏ 
Add
ÏÏ 
(
ÏÏ 
new
ÏÏ "
IntVec3
ÏÏ# *
(
ÏÏ* +
	positions
ÏÏ+ 4
[
ÏÏ4 5
i
ÏÏ5 6
]
ÏÏ6 7
)
ÏÏ7 8
,
ÏÏ8 9
new
ÏÏ: =
List
ÏÏ> B
<
ÏÏB C
int
ÏÏC F
>
ÏÏF G
(
ÏÏG H
)
ÏÏH I
{
ÏÏJ K
i
ÏÏL M
}
ÏÏN O
)
ÏÏO P
;
ÏÏP Q
}
ÌÌ 
SharedVertex
ÔÔ 
[
ÔÔ 
]
ÔÔ 
share
ÔÔ  
=
ÔÔ! "
new
ÔÔ# &
SharedVertex
ÔÔ' 3
[
ÔÔ3 4
sorted
ÔÔ4 :
.
ÔÔ: ;
Count
ÔÔ; @
]
ÔÔ@ A
;
ÔÔA B
int
ÒÒ 
t
ÒÒ 
=
ÒÒ 
$num
ÒÒ 
;
ÒÒ 
foreach
ÚÚ 
(
ÚÚ 
KeyValuePair
ÚÚ !
<
ÚÚ! "
IntVec3
ÚÚ" )
,
ÚÚ) *
List
ÚÚ+ /
<
ÚÚ/ 0
int
ÚÚ0 3
>
ÚÚ3 4
>
ÚÚ4 5
kvp
ÚÚ6 9
in
ÚÚ: <
sorted
ÚÚ= C
)
ÚÚC D
share
ÛÛ 
[
ÛÛ 
t
ÛÛ 
++
ÛÛ 
]
ÛÛ 
=
ÛÛ 
new
ÛÛ  
SharedVertex
ÛÛ! -
(
ÛÛ- .
kvp
ÛÛ. 1
.
ÛÛ1 2
Value
ÛÛ2 7
.
ÛÛ7 8
ToArray
ÛÛ8 ?
(
ÛÛ? @
)
ÛÛ@ A
)
ÛÛA B
;
ÛÛB C
return
ıı 
share
ıı 
;
ıı 
}
ˆˆ 	
internal
¯¯ 
static
¯¯ 
SharedVertex
¯¯ $
[
¯¯$ %
]
¯¯% &
RemoveAndShift
¯¯' 5
(
¯¯5 6

Dictionary
¯¯6 @
<
¯¯@ A
int
¯¯A D
,
¯¯D E
int
¯¯F I
>
¯¯I J
lookup
¯¯K Q
,
¯¯Q R
IEnumerable
¯¯S ^
<
¯¯^ _
int
¯¯_ b
>
¯¯b c
remove
¯¯d j
)
¯¯j k
{
˘˘ 	
var
˙˙ 
removedVertices
˙˙ 
=
˙˙  !
new
˙˙" %
List
˙˙& *
<
˙˙* +
int
˙˙+ .
>
˙˙. /
(
˙˙/ 0
remove
˙˙0 6
)
˙˙6 7
;
˙˙7 8
removedVertices
˚˚ 
.
˚˚ 
Sort
˚˚  
(
˚˚  !
)
˚˚! "
;
˚˚" #
return
¸¸ "
SortedRemoveAndShift
¸¸ '
(
¸¸' (
lookup
¸¸( .
,
¸¸. /
removedVertices
¸¸0 ?
)
¸¸? @
;
¸¸@ A
}
˝˝ 	
internal
ˇˇ 
static
ˇˇ 
SharedVertex
ˇˇ $
[
ˇˇ$ %
]
ˇˇ% &"
SortedRemoveAndShift
ˇˇ' ;
(
ˇˇ; <

Dictionary
ˇˇ< F
<
ˇˇF G
int
ˇˇG J
,
ˇˇJ K
int
ˇˇL O
>
ˇˇO P
lookup
ˇˇQ W
,
ˇˇW X
List
ˇˇY ]
<
ˇˇ] ^
int
ˇˇ^ a
>
ˇˇa b
remove
ˇˇc i
)
ˇˇi j
{
ÄÄ 	
foreach
ÅÅ 
(
ÅÅ 
int
ÅÅ 
i
ÅÅ 
in
ÅÅ 
remove
ÅÅ $
)
ÅÅ$ %
lookup
ÇÇ 
[
ÇÇ 
i
ÇÇ 
]
ÇÇ 
=
ÇÇ 
-
ÇÇ 
$num
ÇÇ 
;
ÇÇ 
var
ÑÑ 
shared
ÑÑ 
=
ÑÑ 
ToSharedVertices
ÑÑ )
(
ÑÑ) *
lookup
ÑÑ* 0
.
ÑÑ0 1
Where
ÑÑ1 6
(
ÑÑ6 7
x
ÑÑ7 8
=>
ÑÑ9 ;
x
ÑÑ< =
.
ÑÑ= >
Value
ÑÑ> C
>
ÑÑD E
-
ÑÑF G
$num
ÑÑG H
)
ÑÑH I
)
ÑÑI J
;
ÑÑJ K
for
ÜÜ 
(
ÜÜ 
int
ÜÜ 
i
ÜÜ 
=
ÜÜ 
$num
ÜÜ 
,
ÜÜ 
c
ÜÜ 
=
ÜÜ 
shared
ÜÜ  &
.
ÜÜ& '
Length
ÜÜ' -
;
ÜÜ- .
i
ÜÜ/ 0
<
ÜÜ1 2
c
ÜÜ3 4
;
ÜÜ4 5
i
ÜÜ6 7
++
ÜÜ7 9
)
ÜÜ9 :
{
áá 
for
àà 
(
àà 
int
àà 
n
àà 
=
àà 
$num
àà 
,
àà 
l
àà  !
=
àà" #
shared
àà$ *
[
àà* +
i
àà+ ,
]
àà, -
.
àà- .
Count
àà. 3
;
àà3 4
n
àà5 6
<
àà7 8
l
àà9 :
;
àà: ;
n
àà< =
++
àà= ?
)
àà? @
{
ââ 
int
ää 
index
ää 
=
ää 
ArrayUtility
ää  ,
.
ää, -&
NearestIndexPriorToValue
ää- E
(
ääE F
remove
ääF L
,
ääL M
shared
ääN T
[
ääT U
i
ääU V
]
ääV W
[
ääW X
n
ääX Y
]
ääY Z
)
ääZ [
;
ää[ \
shared
åå 
[
åå 
i
åå 
]
åå 
[
åå 
n
åå 
]
åå  
-=
åå! #
index
åå$ )
+
åå* +
$num
åå, -
;
åå- .
}
çç 
}
éé 
return
êê 
shared
êê 
;
êê 
}
ëë 	
internal
ìì 
static
ìì 
void
ìì 
SetCoincident
ìì *
(
ìì* +
ref
ìì+ .

Dictionary
ìì/ 9
<
ìì9 :
int
ìì: =
,
ìì= >
int
ìì? B
>
ììB C
lookup
ììD J
,
ììJ K
IEnumerable
ììL W
<
ììW X
int
ììX [
>
ìì[ \
vertices
ìì] e
)
ììe f
{
îî 	
int
ïï 
index
ïï 
=
ïï 
lookup
ïï 
.
ïï 
Count
ïï $
;
ïï$ %
foreach
ññ 
(
ññ 
var
ññ 
v
ññ 
in
ññ 
vertices
ññ &
)
ññ& '
lookup
óó 
[
óó 
v
óó 
]
óó 
=
óó 
index
óó !
;
óó! "
}
òò 	
}
ôô 
}öö ˙◊
õD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\ElementSelection.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
public 

static 
class 
ElementSelection (
{ 
const		 
int		 
k_MaxHoleIterations		 %
=		& '
$num		( ,
;		, -
internal 
static 
List 
< 
SimpleTuple (
<( )
Face) -
,- .
Edge/ 3
>3 4
>4 5
GetNeighborFaces6 F
(F G
ProBuilderMeshG U
meshV Z
,Z [
Edge\ `
edgea e
)e f
{ 	
List 
< 
SimpleTuple 
< 
Face !
,! "
Edge# '
>' (
>( )
faces* /
=0 1
new2 5
List6 :
<: ;
SimpleTuple; F
<F G
FaceG K
,K L
EdgeM Q
>Q R
>R S
(S T
)T U
;U V
var 
lookup 
= 
mesh 
. 
sharedVertexLookup 0
;0 1
Edge 
uni 
= 
new 
Edge 
(  
lookup  &
[& '
edge' +
.+ ,
a, -
]- .
,. /
lookup0 6
[6 7
edge7 ;
.; <
b< =
]= >
)> ?
;? @
Edge 
e 
= 
new 
Edge 
( 
$num 
,  
$num! "
)" #
;# $
for 
( 
int 
i 
= 
$num 
; 
i 
< 
mesh  $
.$ %
facesInternal% 2
.2 3
Length3 9
;9 :
i; <
++< >
)> ?
{ 
Edge 
[ 
] 
edges 
= 
mesh #
.# $
facesInternal$ 1
[1 2
i2 3
]3 4
.4 5
edgesInternal5 B
;B C
for 
( 
int 
n 
= 
$num 
; 
n  !
<" #
edges$ )
.) *
Length* 0
;0 1
n2 3
++3 5
)5 6
{ 
e 
. 
a 
= 
edges 
[  
n  !
]! "
." #
a# $
;$ %
e 
. 
b 
= 
edges 
[  
n  !
]! "
." #
b# $
;$ %
if!! 
(!! 
(!! 
uni!! 
.!! 
a!! 
==!! !
lookup!!" (
[!!( )
e!!) *
.!!* +
a!!+ ,
]!!, -
&&!!. 0
uni!!1 4
.!!4 5
b!!5 6
==!!7 9
lookup!!: @
[!!@ A
e!!A B
.!!B C
b!!C D
]!!D E
)!!E F
||!!G I
("" 
uni"" 
."" 
a"" 
=="" !
lookup""" (
[""( )
e"") *
.""* +
b""+ ,
]"", -
&&"". 0
uni""1 4
.""4 5
b""5 6
==""7 9
lookup"": @
[""@ A
e""A B
.""B C
a""C D
]""D E
)""E F
)""F G
{## 
faces$$ 
.$$ 
Add$$ !
($$! "
new$$" %
SimpleTuple$$& 1
<$$1 2
Face$$2 6
,$$6 7
Edge$$8 <
>$$< =
($$= >
mesh$$> B
.$$B C
facesInternal$$C P
[$$P Q
i$$Q R
]$$R S
,$$S T
edges$$U Z
[$$Z [
n$$[ \
]$$\ ]
)$$] ^
)$$^ _
;$$_ `
break%% 
;%% 
}&& 
}'' 
}(( 
return)) 
faces)) 
;)) 
}** 	
internal22 
static22 
List22 
<22 
Face22 !
>22! "
GetNeighborFaces22# 3
(223 4
ProBuilderMesh224 B
mesh22C G
,22G H
int22I L
[22L M
]22M N
indexes22O V
)22V W
{33 	
var44 
lookup44 
=44 
mesh44 
.44 
sharedVertexLookup44 0
;440 1
List55 
<55 
Face55 
>55 
neighboring55 "
=55# $
new55% (
List55) -
<55- .
Face55. 2
>552 3
(553 4
)554 5
;555 6
HashSet66 
<66 
int66 
>66 
shared66 
=66  !
new66" %
HashSet66& -
<66- .
int66. 1
>661 2
(662 3
)663 4
;664 5
foreach88 
(88 
int88 
tri88 
in88 
indexes88  '
)88' (
shared99 
.99 
Add99 
(99 
lookup99 !
[99! "
tri99" %
]99% &
)99& '
;99' (
for;; 
(;; 
int;; 
i;; 
=;; 
$num;; 
;;; 
i;; 
<;; 
mesh;;  $
.;;$ %
facesInternal;;% 2
.;;2 3
Length;;3 9
;;;9 :
i;;; <
++;;< >
);;> ?
{<< 
int== 
[== 
]== 
dist== 
=== 
mesh== !
.==! "
facesInternal==" /
[==/ 0
i==0 1
]==1 2
.==2 3#
distinctIndexesInternal==3 J
;==J K
for?? 
(?? 
int?? 
n?? 
=?? 
$num?? 
;?? 
n??  !
<??" #
dist??$ (
.??( )
Length??) /
;??/ 0
n??1 2
++??2 4
)??4 5
{@@ 
ifAA 
(AA 
sharedAA 
.AA 
ContainsAA '
(AA' (
lookupAA( .
[AA. /
distAA/ 3
[AA3 4
nAA4 5
]AA5 6
]AA6 7
)AA7 8
)AA8 9
{BB 
neighboringCC #
.CC# $
AddCC$ '
(CC' (
meshCC( ,
.CC, -
facesInternalCC- :
[CC: ;
iCC; <
]CC< =
)CC= >
;CC> ?
breakDD 
;DD 
}EE 
}FF 
}GG 
returnII 
neighboringII 
;II 
}JJ 	
internalRR 
staticRR 
EdgeRR 
[RR 
]RR 
GetConnectedEdgesRR 0
(RR0 1
ProBuilderMeshRR1 ?
meshRR@ D
,RRD E
intRRF I
[RRI J
]RRJ K
indexesRRL S
)RRS T
{SS 	
varTT 
lookupTT 
=TT 
meshTT 
.TT 
sharedVertexLookupTT 0
;TT0 1
ListVV 
<VV 
EdgeVV 
>VV 
connectedEdgesVV %
=VV& '
newVV( +
ListVV, 0
<VV0 1
EdgeVV1 5
>VV5 6
(VV6 7
)VV7 8
;VV8 9
HashSetXX 
<XX 
intXX 
>XX 
sharedXX 
=XX  !
newXX" %
HashSetXX& -
<XX- .
intXX. 1
>XX1 2
(XX2 3
)XX3 4
;XX4 5
forZZ 
(ZZ 
intZZ 
iZZ 
=ZZ 
$numZZ 
;ZZ 
iZZ 
<ZZ 
indexesZZ  '
.ZZ' (
LengthZZ( .
;ZZ. /
iZZ0 1
++ZZ1 3
)ZZ3 4
shared[[ 
.[[ 
Add[[ 
([[ 
lookup[[ !
[[[! "
indexes[[" )
[[[) *
i[[* +
][[+ ,
][[, -
)[[- .
;[[. /
HashSet]] 
<]] 
Edge]] 
>]] 
used]] 
=]]  
new]]! $
HashSet]]% ,
<]], -
Edge]]- 1
>]]1 2
(]]2 3
)]]3 4
;]]4 5
Edge__ 
uni__ 
=__ 
new__ 
Edge__ 
(__  
$num__  !
,__! "
$num__# $
)__$ %
;__% &
foreachaa 
(aa 
varaa 
faceaa 
inaa  
meshaa! %
.aa% &
facesInternalaa& 3
)aa3 4
{bb 
foreachcc 
(cc 
varcc 
edgecc !
incc" $
facecc% )
.cc) *
edgescc* /
)cc/ 0
{dd 
Edgeee 
keyee 
=ee 
newee "
Edgeee# '
(ee' (
lookupee( .
[ee. /
edgeee/ 3
.ee3 4
aee4 5
]ee5 6
,ee6 7
lookupee8 >
[ee> ?
edgeee? C
.eeC D
beeD E
]eeE F
)eeF G
;eeG H
ifgg 
(gg 
sharedgg 
.gg 
Containsgg '
(gg' (
keygg( +
.gg+ ,
agg, -
)gg- .
||gg/ 1
sharedgg2 8
.gg8 9
Containsgg9 A
(ggA B
keyggB E
.ggE F
bggF G
)ggG H
&&ggI K
!ggL M
usedggM Q
.ggQ R
ContainsggR Z
(ggZ [
unigg[ ^
)gg^ _
)gg_ `
{hh 
connectedEdgesii &
.ii& '
Addii' *
(ii* +
edgeii+ /
)ii/ 0
;ii0 1
usedjj 
.jj 
Addjj  
(jj  !
keyjj! $
)jj$ %
;jj% &
}kk 
}ll 
}mm 
returnoo 
connectedEdgesoo !
.oo! "
ToArrayoo" )
(oo) *
)oo* +
;oo+ ,
}pp 	
publicxx 
staticxx 
IEnumerablexx !
<xx! "
Edgexx" &
>xx& '
GetPerimeterEdgesxx( 9
(xx9 :
thisxx: >
ProBuilderMeshxx? M
meshxxN R
,xxR S
IEnumerablexxT _
<xx_ `
Facexx` d
>xxd e
facesxxf k
)xxk l
{yy 	
ifzz 
(zz 
meshzz 
==zz 
nullzz 
)zz 
throw{{ 
new{{ !
ArgumentNullException{{ /
({{/ 0
$str{{0 6
){{6 7
;{{7 8
if}} 
(}} 
faces}} 
==}} 
null}} 
)}} 
throw~~ 
new~~ !
ArgumentNullException~~ /
(~~/ 0
$str~~0 7
)~~7 8
;~~8 9
List
ÄÄ 
<
ÄÄ 
Edge
ÄÄ 
>
ÄÄ 
	faceEdges
ÄÄ  
=
ÄÄ! "
faces
ÄÄ# (
.
ÄÄ( )

SelectMany
ÄÄ) 3
(
ÄÄ3 4
x
ÄÄ4 5
=>
ÄÄ6 8
x
ÄÄ9 :
.
ÄÄ: ;
edgesInternal
ÄÄ; H
)
ÄÄH I
.
ÄÄI J
ToList
ÄÄJ P
(
ÄÄP Q
)
ÄÄQ R
;
ÄÄR S
var
ÅÅ %
sharedIndexesDictionary
ÅÅ '
=
ÅÅ( )
mesh
ÅÅ* .
.
ÅÅ. / 
sharedVertexLookup
ÅÅ/ A
;
ÅÅA B
int
ÇÇ 
	edgeCount
ÇÇ 
=
ÇÇ 
	faceEdges
ÇÇ %
.
ÇÇ% &
Count
ÇÇ& +
;
ÇÇ+ ,

Dictionary
ÖÖ 
<
ÖÖ 
Edge
ÖÖ 
,
ÖÖ 
List
ÖÖ !
<
ÖÖ! "
Edge
ÖÖ" &
>
ÖÖ& '
>
ÖÖ' (
dup
ÖÖ) ,
=
ÖÖ- .
new
ÖÖ/ 2

Dictionary
ÖÖ3 =
<
ÖÖ= >
Edge
ÖÖ> B
,
ÖÖB C
List
ÖÖD H
<
ÖÖH I
Edge
ÖÖI M
>
ÖÖM N
>
ÖÖN O
(
ÖÖO P
)
ÖÖP Q
;
ÖÖQ R
List
ÜÜ 
<
ÜÜ 
Edge
ÜÜ 
>
ÜÜ 
list
ÜÜ 
;
ÜÜ 
for
àà 
(
àà 
int
àà 
i
àà 
=
àà 
$num
àà 
;
àà 
i
àà 
<
àà 
	edgeCount
àà  )
;
àà) *
i
àà+ ,
++
àà, .
)
àà. /
{
ââ 
Edge
ää 
uni
ää 
=
ää 
new
ää 
Edge
ää #
(
ää# $%
sharedIndexesDictionary
ää$ ;
[
ää; <
	faceEdges
ää< E
[
ääE F
i
ääF G
]
ääG H
.
ääH I
a
ääI J
]
ääJ K
,
ääK L%
sharedIndexesDictionary
ääM d
[
ääd e
	faceEdges
ääe n
[
ään o
i
ääo p
]
ääp q
.
ääq r
b
äär s
]
ääs t
)
äät u
;
ääu v
if
åå 
(
åå 
dup
åå 
.
åå 
TryGetValue
åå #
(
åå# $
uni
åå$ '
,
åå' (
out
åå) ,
list
åå- 1
)
åå1 2
)
åå2 3
list
çç 
.
çç 
Add
çç 
(
çç 
	faceEdges
çç &
[
çç& '
i
çç' (
]
çç( )
)
çç) *
;
çç* +
else
éé 
dup
èè 
.
èè 
Add
èè 
(
èè 
uni
èè 
,
èè  
new
èè! $
List
èè% )
<
èè) *
Edge
èè* .
>
èè. /
(
èè/ 0
)
èè0 1
{
èè2 3
	faceEdges
èè4 =
[
èè= >
i
èè> ?
]
èè? @
}
èèA B
)
èèB C
;
èèC D
}
êê 
return
íí 
dup
íí 
.
íí 
Where
íí 
(
íí 
x
íí 
=>
íí !
x
íí" #
.
íí# $
Value
íí$ )
.
íí) *
Count
íí* /
<
íí0 1
$num
íí2 3
)
íí3 4
.
íí4 5
Select
íí5 ;
(
íí; <
x
íí< =
=>
íí> @
x
ííA B
.
ííB C
Value
ííC H
[
ííH I
$num
ííI J
]
ííJ K
)
ííK L
;
ííL M
}
ìì 	
internal
õõ 
static
õõ 
int
õõ 
[
õõ 
]
õõ 
GetPerimeterEdges
õõ /
(
õõ/ 0
ProBuilderMesh
õõ0 >
mesh
õõ? C
,
õõC D
IList
õõE J
<
õõJ K
Edge
õõK O
>
õõO P
edges
õõQ V
)
õõV W
{
úú 	
int
ùù 
	edgeCount
ùù 
=
ùù 
edges
ùù !
!=
ùù" $
null
ùù% )
?
ùù* +
edges
ùù, 1
.
ùù1 2
Count
ùù2 7
:
ùù8 9
$num
ùù: ;
;
ùù; <
var
†† 
	universal
†† 
=
†† 
mesh
††  
.
††  !(
GetSharedVertexHandleEdges
††! ;
(
††; <
edges
††< A
)
††A B
.
††B C
ToArray
††C J
(
††J K
)
††K L
;
††L M
int
¢¢ 
[
¢¢ 
]
¢¢ 
connections
¢¢ 
=
¢¢ 
new
¢¢  #
int
¢¢$ '
[
¢¢' (
	universal
¢¢( 1
.
¢¢1 2
Length
¢¢2 8
]
¢¢8 9
;
¢¢9 :
for
§§ 
(
§§ 
int
§§ 
i
§§ 
=
§§ 
$num
§§ 
;
§§ 
i
§§ 
<
§§ 
	universal
§§  )
.
§§) *
Length
§§* 0
-
§§1 2
$num
§§3 4
;
§§4 5
i
§§6 7
++
§§7 9
)
§§9 :
{
•• 
for
¶¶ 
(
¶¶ 
int
¶¶ 
n
¶¶ 
=
¶¶ 
i
¶¶ 
+
¶¶  
$num
¶¶! "
;
¶¶" #
n
¶¶$ %
<
¶¶& '
	universal
¶¶( 1
.
¶¶1 2
Length
¶¶2 8
;
¶¶8 9
n
¶¶: ;
++
¶¶; =
)
¶¶= >
{
ßß 
if
®® 
(
®® 
	universal
®® !
[
®®! "
i
®®" #
]
®®# $
.
®®$ %
a
®®% &
==
®®' )
	universal
®®* 3
[
®®3 4
n
®®4 5
]
®®5 6
.
®®6 7
a
®®7 8
||
®®9 ;
	universal
®®< E
[
®®E F
i
®®F G
]
®®G H
.
®®H I
a
®®I J
==
®®K M
	universal
®®N W
[
®®W X
n
®®X Y
]
®®Y Z
.
®®Z [
b
®®[ \
||
®®] _
	universal
©© !
[
©©! "
i
©©" #
]
©©# $
.
©©$ %
b
©©% &
==
©©' )
	universal
©©* 3
[
©©3 4
n
©©4 5
]
©©5 6
.
©©6 7
a
©©7 8
||
©©9 ;
	universal
©©< E
[
©©E F
i
©©F G
]
©©G H
.
©©H I
b
©©I J
==
©©K M
	universal
©©N W
[
©©W X
n
©©X Y
]
©©Y Z
.
©©Z [
b
©©[ \
)
©©\ ]
{
™™ 
connections
´´ #
[
´´# $
i
´´$ %
]
´´% &
++
´´& (
;
´´( )
connections
¨¨ #
[
¨¨# $
n
¨¨$ %
]
¨¨% &
++
¨¨& (
;
¨¨( )
}
≠≠ 
}
ÆÆ 
}
ØØ 
int
±± 
min
±± 
=
±± 
Math
±± 
.
±± 
Min
±± 
(
±± 
connections
±± *
)
±±* +
;
±±+ ,
List
≤≤ 
<
≤≤ 
int
≤≤ 
>
≤≤ 
	perimeter
≤≤ 
=
≤≤  !
new
≤≤" %
List
≤≤& *
<
≤≤* +
int
≤≤+ .
>
≤≤. /
(
≤≤/ 0
)
≤≤0 1
;
≤≤1 2
for
¥¥ 
(
¥¥ 
int
¥¥ 
i
¥¥ 
=
¥¥ 
$num
¥¥ 
;
¥¥ 
i
¥¥ 
<
¥¥ 
connections
¥¥  +
.
¥¥+ ,
Length
¥¥, 2
;
¥¥2 3
i
¥¥4 5
++
¥¥5 7
)
¥¥7 8
{
µµ 
if
∂∂ 
(
∂∂ 
connections
∂∂ 
[
∂∂  
i
∂∂  !
]
∂∂! "
<=
∂∂# %
min
∂∂& )
)
∂∂) *
	perimeter
∑∑ 
.
∑∑ 
Add
∑∑ !
(
∑∑! "
i
∑∑" #
)
∑∑# $
;
∑∑$ %
}
∏∏ 
return
∫∫ 
	perimeter
∫∫ 
.
∫∫ 
Count
∫∫ "
!=
∫∫# %
	edgeCount
∫∫& /
?
∫∫0 1
	perimeter
∫∫2 ;
.
∫∫; <
ToArray
∫∫< C
(
∫∫C D
)
∫∫D E
:
∫∫F G
new
∫∫H K
int
∫∫L O
[
∫∫O P
]
∫∫P Q
{
∫∫R S
}
∫∫S T
;
∫∫T U
}
ªª 	
internal
√√ 
static
√√ 
IEnumerable
√√ #
<
√√# $
Face
√√$ (
>
√√( )
GetPerimeterFaces
√√* ;
(
√√; <
ProBuilderMesh
√√< J
mesh
√√K O
,
√√O P
IEnumerable
√√Q \
<
√√\ ]
Face
√√] a
>
√√a b
faces
√√c h
)
√√h i
{
ƒƒ 	
var
≈≈ 
lookup
≈≈ 
=
≈≈ 
mesh
≈≈ 
.
≈≈  
sharedVertexLookup
≈≈ 0
;
≈≈0 1

Dictionary
∆∆ 
<
∆∆ 
Edge
∆∆ 
,
∆∆ 
List
∆∆ !
<
∆∆! "
Face
∆∆" &
>
∆∆& '
>
∆∆' (
sharedEdges
∆∆) 4
=
∆∆5 6
new
∆∆7 :

Dictionary
∆∆; E
<
∆∆E F
Edge
∆∆F J
,
∆∆J K
List
∆∆L P
<
∆∆P Q
Face
∆∆Q U
>
∆∆U V
>
∆∆V W
(
∆∆W X
)
∆∆X Y
;
∆∆Y Z
foreach
ÕÕ 
(
ÕÕ 
Face
ÕÕ 
face
ÕÕ 
in
ÕÕ !
faces
ÕÕ" '
)
ÕÕ' (
{
ŒŒ 
foreach
œœ 
(
œœ 
Edge
œœ 
e
œœ 
in
œœ  "
face
œœ# '
.
œœ' (
edgesInternal
œœ( 5
)
œœ5 6
{
–– 
Edge
—— 
edge
—— 
=
—— 
new
——  #
Edge
——$ (
(
——( )
lookup
——) /
[
——/ 0
e
——0 1
.
——1 2
a
——2 3
]
——3 4
,
——4 5
lookup
——6 <
[
——< =
e
——= >
.
——> ?
b
——? @
]
——@ A
)
——A B
;
——B C
if
”” 
(
”” 
sharedEdges
”” #
.
””# $
ContainsKey
””$ /
(
””/ 0
edge
””0 4
)
””4 5
)
””5 6
sharedEdges
‘‘ #
[
‘‘# $
edge
‘‘$ (
]
‘‘( )
.
‘‘) *
Add
‘‘* -
(
‘‘- .
face
‘‘. 2
)
‘‘2 3
;
‘‘3 4
else
’’ 
sharedEdges
÷÷ #
.
÷÷# $
Add
÷÷$ '
(
÷÷' (
edge
÷÷( ,
,
÷÷, -
new
÷÷. 1
List
÷÷2 6
<
÷÷6 7
Face
÷÷7 ;
>
÷÷; <
(
÷÷< =
)
÷÷= >
{
÷÷? @
face
÷÷A E
}
÷÷F G
)
÷÷G H
;
÷÷H I
}
◊◊ 
}
ÿÿ 
return
⁄⁄ 
sharedEdges
⁄⁄ 
.
⁄⁄ 
Where
⁄⁄ $
(
⁄⁄$ %
x
⁄⁄% &
=>
⁄⁄' )
x
⁄⁄* +
.
⁄⁄+ ,
Value
⁄⁄, 1
.
⁄⁄1 2
Count
⁄⁄2 7
<
⁄⁄8 9
$num
⁄⁄: ;
)
⁄⁄; <
.
⁄⁄< =
Select
⁄⁄= C
(
⁄⁄C D
x
⁄⁄D E
=>
⁄⁄F H
x
⁄⁄I J
.
⁄⁄J K
Value
⁄⁄K P
[
⁄⁄P Q
$num
⁄⁄Q R
]
⁄⁄R S
)
⁄⁄S T
.
⁄⁄T U
Distinct
⁄⁄U ]
(
⁄⁄] ^
)
⁄⁄^ _
;
⁄⁄_ `
}
€€ 	
internal
›› 
static
›› 
int
›› 
[
›› 
]
›› "
GetPerimeterVertices
›› 2
(
››2 3
ProBuilderMesh
››3 A
mesh
››B F
,
››F G
int
››H K
[
››K L
]
››L M
indexes
››N U
,
››U V
Edge
››W [
[
››[ \
]
››\ ]!
universal_edges_all
››^ q
)
››q r
{
ﬁﬁ 	
int
ﬂﬂ 
len
ﬂﬂ 
=
ﬂﬂ 
indexes
ﬂﬂ 
.
ﬂﬂ 
Length
ﬂﬂ $
;
ﬂﬂ$ %
SharedVertex
‡‡ 
[
‡‡ 
]
‡‡ 
sharedIndexes
‡‡ (
=
‡‡) *
mesh
‡‡+ /
.
‡‡/ 0$
sharedVerticesInternal
‡‡0 F
;
‡‡F G
int
·· 
[
·· 
]
·· 
	universal
·· 
=
·· 
new
·· !
int
··" %
[
··% &
len
··& )
]
··) *
;
··* +
for
„„ 
(
„„ 
int
„„ 
i
„„ 
=
„„ 
$num
„„ 
;
„„ 
i
„„ 
<
„„ 
len
„„  #
;
„„# $
i
„„% &
++
„„& (
)
„„( )
	universal
‰‰ 
[
‰‰ 
i
‰‰ 
]
‰‰ 
=
‰‰ 
mesh
‰‰ #
.
‰‰# $#
GetSharedVertexHandle
‰‰$ 9
(
‰‰9 :
indexes
‰‰: A
[
‰‰A B
i
‰‰B C
]
‰‰C D
)
‰‰D E
;
‰‰E F
int
ÊÊ 
[
ÊÊ 
]
ÊÊ 
connections
ÊÊ 
=
ÊÊ 
new
ÊÊ  #
int
ÊÊ$ '
[
ÊÊ' (
indexes
ÊÊ( /
.
ÊÊ/ 0
Length
ÊÊ0 6
]
ÊÊ6 7
;
ÊÊ7 8
for
ËË 
(
ËË 
int
ËË 
i
ËË 
=
ËË 
$num
ËË 
;
ËË 
i
ËË 
<
ËË 
indexes
ËË  '
.
ËË' (
Length
ËË( .
-
ËË/ 0
$num
ËË1 2
;
ËË2 3
i
ËË4 5
++
ËË5 7
)
ËË7 8
{
ÈÈ 
for
ÍÍ 
(
ÍÍ 
int
ÍÍ 
n
ÍÍ 
=
ÍÍ 
i
ÍÍ 
+
ÍÍ  
$num
ÍÍ! "
;
ÍÍ" #
n
ÍÍ$ %
<
ÍÍ& '
indexes
ÍÍ( /
.
ÍÍ/ 0
Length
ÍÍ0 6
;
ÍÍ6 7
n
ÍÍ8 9
++
ÍÍ9 ;
)
ÍÍ; <
{
ÎÎ 
if
ÏÏ 
(
ÏÏ !
universal_edges_all
ÏÏ +
.
ÏÏ+ ,
Contains
ÏÏ, 4
(
ÏÏ4 5
	universal
ÏÏ5 >
[
ÏÏ> ?
i
ÏÏ? @
]
ÏÏ@ A
,
ÏÏA B
	universal
ÏÏC L
[
ÏÏL M
n
ÏÏM N
]
ÏÏN O
)
ÏÏO P
)
ÏÏP Q
{
ÌÌ 
connections
ÓÓ #
[
ÓÓ# $
i
ÓÓ$ %
]
ÓÓ% &
++
ÓÓ& (
;
ÓÓ( )
connections
ÔÔ #
[
ÔÔ# $
n
ÔÔ$ %
]
ÔÔ% &
++
ÔÔ& (
;
ÔÔ( )
}
 
}
ÒÒ 
}
ÚÚ 
int
ÙÙ 
min
ÙÙ 
=
ÙÙ 
Math
ÙÙ 
.
ÙÙ 
Min
ÙÙ 
(
ÙÙ 
connections
ÙÙ *
)
ÙÙ* +
;
ÙÙ+ ,
List
ıı 
<
ıı 
int
ıı 
>
ıı 
	perimeter
ıı 
=
ıı  !
new
ıı" %
List
ıı& *
<
ıı* +
int
ıı+ .
>
ıı. /
(
ıı/ 0
)
ıı0 1
;
ıı1 2
for
ˆˆ 
(
ˆˆ 
int
ˆˆ 
i
ˆˆ 
=
ˆˆ 
$num
ˆˆ 
;
ˆˆ 
i
ˆˆ 
<
ˆˆ 
len
ˆˆ  #
;
ˆˆ# $
i
ˆˆ% &
++
ˆˆ& (
)
ˆˆ( )
{
˜˜ 
if
¯¯ 
(
¯¯ 
connections
¯¯ 
[
¯¯  
i
¯¯  !
]
¯¯! "
<=
¯¯# %
min
¯¯& )
)
¯¯) *
	perimeter
˘˘ 
.
˘˘ 
Add
˘˘ !
(
˘˘! "
i
˘˘" #
)
˘˘# $
;
˘˘$ %
}
˙˙ 
return
¸¸ 
	perimeter
¸¸ 
.
¸¸ 
Count
¸¸ "
<
¸¸# $
len
¸¸% (
?
¸¸) *
	perimeter
¸¸+ 4
.
¸¸4 5
ToArray
¸¸5 <
(
¸¸< =
)
¸¸= >
:
¸¸? @
new
¸¸A D
int
¸¸E H
[
¸¸H I
]
¸¸I J
{
¸¸K L
}
¸¸L M
;
¸¸M N
}
˝˝ 	
static
ˇˇ 

WingedEdge
ˇˇ 
EdgeRingNext
ˇˇ &
(
ˇˇ& '

WingedEdge
ˇˇ' 1
edge
ˇˇ2 6
)
ˇˇ6 7
{
ÄÄ 	
if
ÅÅ 
(
ÅÅ 
edge
ÅÅ 
==
ÅÅ 
null
ÅÅ 
)
ÅÅ 
return
ÇÇ 
null
ÇÇ 
;
ÇÇ 

WingedEdge
ÑÑ 
next
ÑÑ 
=
ÑÑ 
edge
ÑÑ "
.
ÑÑ" #
next
ÑÑ# '
,
ÑÑ' (
prev
ÑÑ) -
=
ÑÑ. /
edge
ÑÑ0 4
.
ÑÑ4 5
previous
ÑÑ5 =
;
ÑÑ= >
int
ÖÖ 
i
ÖÖ 
=
ÖÖ 
$num
ÖÖ 
;
ÖÖ 
while
áá 
(
áá 
next
áá 
!=
áá 
prev
áá 
&&
áá  "
next
áá# '
!=
áá( *
edge
áá+ /
)
áá/ 0
{
àà 
next
ââ 
=
ââ 
next
ââ 
.
ââ 
next
ââ  
;
ââ  !
if
ãã 
(
ãã 
next
ãã 
==
ãã 
prev
ãã  
)
ãã  !
return
åå 
null
åå 
;
åå  
prev
éé 
=
éé 
prev
éé 
.
éé 
previous
éé $
;
éé$ %
i
êê 
++
êê 
;
êê 
}
ëë 
if
ìì 
(
ìì 
i
ìì 
%
ìì 
$num
ìì 
==
ìì 
$num
ìì 
||
ìì 
next
ìì "
==
ìì# %
edge
ìì& *
)
ìì* +
next
îî 
=
îî 
null
îî 
;
îî 
return
ññ 
next
ññ 
;
ññ 
}
óó 	
internal
üü 
static
üü 
IEnumerable
üü #
<
üü# $
Edge
üü$ (
>
üü( )
GetEdgeRing
üü* 5
(
üü5 6
ProBuilderMesh
üü6 D
pb
üüE G
,
üüG H
IEnumerable
üüI T
<
üüT U
Edge
üüU Y
>
üüY Z
edges
üü[ `
)
üü` a
{
†† 	
List
°° 
<
°° 

WingedEdge
°° 
>
°° 
wings
°° "
=
°°# $

WingedEdge
°°% /
.
°°/ 0
GetWingedEdges
°°0 >
(
°°> ?
pb
°°? A
)
°°A B
;
°°B C
List
¢¢ 
<
¢¢ 

EdgeLookup
¢¢ 
>
¢¢ 

edgeLookup
¢¢ '
=
¢¢( )

EdgeLookup
¢¢* 4
.
¢¢4 5
GetEdgeLookup
¢¢5 B
(
¢¢B C
edges
¢¢C H
,
¢¢H I
pb
¢¢J L
.
¢¢L M 
sharedVertexLookup
¢¢M _
)
¢¢_ `
.
¢¢` a
ToList
¢¢a g
(
¢¢g h
)
¢¢h i
;
¢¢i j

edgeLookup
££ 
=
££ 

edgeLookup
££ #
.
££# $
Distinct
££$ ,
(
££, -
)
££- .
.
££. /
ToList
££/ 5
(
££5 6
)
££6 7
;
££7 8

Dictionary
•• 
<
•• 
Edge
•• 
,
•• 

WingedEdge
•• '
>
••' (
	wings_dic
••) 2
=
••3 4
new
••5 8

Dictionary
••9 C
<
••C D
Edge
••D H
,
••H I

WingedEdge
••J T
>
••T U
(
••U V
)
••V W
;
••W X
for
ßß 
(
ßß 
int
ßß 
i
ßß 
=
ßß 
$num
ßß 
;
ßß 
i
ßß 
<
ßß 
wings
ßß  %
.
ßß% &
Count
ßß& +
;
ßß+ ,
i
ßß- .
++
ßß. 0
)
ßß0 1
if
®® 
(
®® 
!
®® 
	wings_dic
®® 
.
®® 
ContainsKey
®® *
(
®®* +
wings
®®+ 0
[
®®0 1
i
®®1 2
]
®®2 3
.
®®3 4
edge
®®4 8
.
®®8 9
common
®®9 ?
)
®®? @
)
®®@ A
	wings_dic
©© 
.
©© 
Add
©© !
(
©©! "
wings
©©" '
[
©©' (
i
©©( )
]
©©) *
.
©©* +
edge
©©+ /
.
©©/ 0
common
©©0 6
,
©©6 7
wings
©©8 =
[
©©= >
i
©©> ?
]
©©? @
)
©©@ A
;
©©A B
HashSet
´´ 
<
´´ 

EdgeLookup
´´ 
>
´´ 
used
´´  $
=
´´% &
new
´´' *
HashSet
´´+ 2
<
´´2 3

EdgeLookup
´´3 =
>
´´= >
(
´´> ?
)
´´? @
;
´´@ A
for
≠≠ 
(
≠≠ 
int
≠≠ 
i
≠≠ 
=
≠≠ 
$num
≠≠ 
,
≠≠ 
c
≠≠ 
=
≠≠ 

edgeLookup
≠≠  *
.
≠≠* +
Count
≠≠+ 0
;
≠≠0 1
i
≠≠2 3
<
≠≠4 5
c
≠≠6 7
;
≠≠7 8
i
≠≠9 :
++
≠≠: <
)
≠≠< =
{
ÆÆ 

WingedEdge
ØØ 
we
ØØ 
;
ØØ 
if
±± 
(
±± 
!
±± 
	wings_dic
±± 
.
±± 
TryGetValue
±± *
(
±±* +

edgeLookup
±±+ 5
[
±±5 6
i
±±6 7
]
±±7 8
.
±±8 9
common
±±9 ?
,
±±? @
out
±±A D
we
±±E G
)
±±G H
||
±±I K
used
±±L P
.
±±P Q
Contains
±±Q Y
(
±±Y Z
we
±±Z \
.
±±\ ]
edge
±±] a
)
±±a b
)
±±b c
continue
≤≤ 
;
≤≤ 

WingedEdge
¥¥ 
cur
¥¥ 
=
¥¥  
we
¥¥! #
;
¥¥# $
while
∂∂ 
(
∂∂ 
cur
∂∂ 
!=
∂∂ 
null
∂∂ "
)
∂∂" #
{
∑∑ 
if
∏∏ 
(
∏∏ 
!
∏∏ 
used
∏∏ 
.
∏∏ 
Add
∏∏ !
(
∏∏! "
cur
∏∏" %
.
∏∏% &
edge
∏∏& *
)
∏∏* +
)
∏∏+ ,
break
∏∏- 2
;
∏∏2 3
cur
ππ 
=
ππ 
EdgeRingNext
ππ &
(
ππ& '
cur
ππ' *
)
ππ* +
;
ππ+ ,
if
∫∫ 
(
∫∫ 
cur
∫∫ 
!=
∫∫ 
null
∫∫ #
&&
∫∫$ &
cur
∫∫' *
.
∫∫* +
opposite
∫∫+ 3
!=
∫∫4 6
null
∫∫7 ;
)
∫∫; <
cur
∫∫= @
=
∫∫A B
cur
∫∫C F
.
∫∫F G
opposite
∫∫G O
;
∫∫O P
}
ªª 
cur
ΩΩ 
=
ΩΩ 
EdgeRingNext
ΩΩ "
(
ΩΩ" #
we
ΩΩ# %
.
ΩΩ% &
opposite
ΩΩ& .
)
ΩΩ. /
;
ΩΩ/ 0
if
ææ 
(
ææ 
cur
ææ 
!=
ææ 
null
ææ 
&&
ææ  "
cur
ææ# &
.
ææ& '
opposite
ææ' /
!=
ææ0 2
null
ææ3 7
)
ææ7 8
cur
ææ9 <
=
ææ= >
cur
ææ? B
.
ææB C
opposite
ææC K
;
ææK L
while
¡¡ 
(
¡¡ 
cur
¡¡ 
!=
¡¡ 
null
¡¡ "
)
¡¡" #
{
¬¬ 
if
√√ 
(
√√ 
!
√√ 
used
√√ 
.
√√ 
Add
√√ !
(
√√! "
cur
√√" %
.
√√% &
edge
√√& *
)
√√* +
)
√√+ ,
break
√√- 2
;
√√2 3
cur
ƒƒ 
=
ƒƒ 
EdgeRingNext
ƒƒ &
(
ƒƒ& '
cur
ƒƒ' *
)
ƒƒ* +
;
ƒƒ+ ,
if
≈≈ 
(
≈≈ 
cur
≈≈ 
!=
≈≈ 
null
≈≈ #
&&
≈≈$ &
cur
≈≈' *
.
≈≈* +
opposite
≈≈+ 3
!=
≈≈4 6
null
≈≈7 ;
)
≈≈; <
cur
≈≈= @
=
≈≈A B
cur
≈≈C F
.
≈≈F G
opposite
≈≈G O
;
≈≈O P
}
∆∆ 
}
«« 
return
…… 
used
…… 
.
…… 
Select
…… 
(
…… 
x
……  
=>
……! #
x
……$ %
.
……% &
local
……& +
)
……+ ,
;
……, -
}
   	
internal
““ 
static
““ 
IEnumerable
““ #
<
““# $
Edge
““$ (
>
““( )"
GetEdgeRingIterative
““* >
(
““> ?
ProBuilderMesh
““? M
pb
““N P
,
““P Q
IEnumerable
““R ]
<
““] ^
Edge
““^ b
>
““b c
edges
““d i
)
““i j
{
”” 	
List
‘‘ 
<
‘‘ 

WingedEdge
‘‘ 
>
‘‘ 
wings
‘‘ "
=
‘‘# $

WingedEdge
‘‘% /
.
‘‘/ 0
GetWingedEdges
‘‘0 >
(
‘‘> ?
pb
‘‘? A
)
‘‘A B
;
‘‘B C
List
’’ 
<
’’ 

EdgeLookup
’’ 
>
’’ 

edgeLookup
’’ '
=
’’( )

EdgeLookup
’’* 4
.
’’4 5
GetEdgeLookup
’’5 B
(
’’B C
edges
’’C H
,
’’H I
pb
’’J L
.
’’L M 
sharedVertexLookup
’’M _
)
’’_ `
.
’’` a
ToList
’’a g
(
’’g h
)
’’h i
;
’’i j

edgeLookup
÷÷ 
=
÷÷ 

edgeLookup
÷÷ #
.
÷÷# $
Distinct
÷÷$ ,
(
÷÷, -
)
÷÷- .
.
÷÷. /
ToList
÷÷/ 5
(
÷÷5 6
)
÷÷6 7
;
÷÷7 8

Dictionary
ÿÿ 
<
ÿÿ 
Edge
ÿÿ 
,
ÿÿ 

WingedEdge
ÿÿ '
>
ÿÿ' (
	wings_dic
ÿÿ) 2
=
ÿÿ3 4
new
ÿÿ5 8

Dictionary
ÿÿ9 C
<
ÿÿC D
Edge
ÿÿD H
,
ÿÿH I

WingedEdge
ÿÿJ T
>
ÿÿT U
(
ÿÿU V
)
ÿÿV W
;
ÿÿW X
for
⁄⁄ 
(
⁄⁄ 
int
⁄⁄ 
i
⁄⁄ 
=
⁄⁄ 
$num
⁄⁄ 
;
⁄⁄ 
i
⁄⁄ 
<
⁄⁄ 
wings
⁄⁄  %
.
⁄⁄% &
Count
⁄⁄& +
;
⁄⁄+ ,
i
⁄⁄- .
++
⁄⁄. 0
)
⁄⁄0 1
if
€€ 
(
€€ 
!
€€ 
	wings_dic
€€ 
.
€€ 
ContainsKey
€€ *
(
€€* +
wings
€€+ 0
[
€€0 1
i
€€1 2
]
€€2 3
.
€€3 4
edge
€€4 8
.
€€8 9
common
€€9 ?
)
€€? @
)
€€@ A
	wings_dic
‹‹ 
.
‹‹ 
Add
‹‹ !
(
‹‹! "
wings
‹‹" '
[
‹‹' (
i
‹‹( )
]
‹‹) *
.
‹‹* +
edge
‹‹+ /
.
‹‹/ 0
common
‹‹0 6
,
‹‹6 7
wings
‹‹8 =
[
‹‹= >
i
‹‹> ?
]
‹‹? @
)
‹‹@ A
;
‹‹A B
HashSet
ﬁﬁ 
<
ﬁﬁ 

EdgeLookup
ﬁﬁ 
>
ﬁﬁ 
used
ﬁﬁ  $
=
ﬁﬁ% &
new
ﬁﬁ' *
HashSet
ﬁﬁ+ 2
<
ﬁﬁ2 3

EdgeLookup
ﬁﬁ3 =
>
ﬁﬁ= >
(
ﬁﬁ> ?
)
ﬁﬁ? @
;
ﬁﬁ@ A
for
‡‡ 
(
‡‡ 
int
‡‡ 
i
‡‡ 
=
‡‡ 
$num
‡‡ 
,
‡‡ 
c
‡‡ 
=
‡‡ 

edgeLookup
‡‡  *
.
‡‡* +
Count
‡‡+ 0
;
‡‡0 1
i
‡‡2 3
<
‡‡4 5
c
‡‡6 7
;
‡‡7 8
i
‡‡9 :
++
‡‡: <
)
‡‡< =
{
·· 

WingedEdge
‚‚ 
we
‚‚ 
;
‚‚ 
if
‰‰ 
(
‰‰ 
!
‰‰ 
	wings_dic
‰‰ 
.
‰‰ 
TryGetValue
‰‰ *
(
‰‰* +

edgeLookup
‰‰+ 5
[
‰‰5 6
i
‰‰6 7
]
‰‰7 8
.
‰‰8 9
common
‰‰9 ?
,
‰‰? @
out
‰‰A D
we
‰‰E G
)
‰‰G H
)
‰‰H I
continue
ÂÂ 
;
ÂÂ 

WingedEdge
ÁÁ 
cur
ÁÁ 
=
ÁÁ  
we
ÁÁ! #
;
ÁÁ# $
if
ÈÈ 
(
ÈÈ 
!
ÈÈ 
used
ÈÈ 
.
ÈÈ 
Contains
ÈÈ "
(
ÈÈ" #
cur
ÈÈ# &
.
ÈÈ& '
edge
ÈÈ' +
)
ÈÈ+ ,
)
ÈÈ, -
used
ÍÍ 
.
ÍÍ 
Add
ÍÍ 
(
ÍÍ 
cur
ÍÍ  
.
ÍÍ  !
edge
ÍÍ! %
)
ÍÍ% &
;
ÍÍ& '
var
ÎÎ 
next
ÎÎ 
=
ÎÎ 
EdgeRingNext
ÎÎ '
(
ÎÎ' (
cur
ÎÎ( +
)
ÎÎ+ ,
;
ÎÎ, -
if
ÏÏ 
(
ÏÏ 
next
ÏÏ 
!=
ÏÏ 
null
ÏÏ  
&&
ÏÏ! #
next
ÏÏ$ (
.
ÏÏ( )
opposite
ÏÏ) 1
!=
ÏÏ2 4
null
ÏÏ5 9
&&
ÏÏ: <
!
ÏÏ= >
used
ÏÏ> B
.
ÏÏB C
Contains
ÏÏC K
(
ÏÏK L
next
ÏÏL P
.
ÏÏP Q
edge
ÏÏQ U
)
ÏÏU V
)
ÏÏV W
used
ÌÌ 
.
ÌÌ 
Add
ÌÌ 
(
ÌÌ 
next
ÌÌ !
.
ÌÌ! "
edge
ÌÌ" &
)
ÌÌ& '
;
ÌÌ' (
var
ÓÓ 
prev
ÓÓ 
=
ÓÓ 
EdgeRingNext
ÓÓ '
(
ÓÓ' (
cur
ÓÓ( +
.
ÓÓ+ ,
opposite
ÓÓ, 4
)
ÓÓ4 5
;
ÓÓ5 6
if
ÔÔ 
(
ÔÔ 
prev
ÔÔ 
!=
ÔÔ 
null
ÔÔ  
&&
ÔÔ! #
prev
ÔÔ$ (
.
ÔÔ( )
opposite
ÔÔ) 1
!=
ÔÔ2 4
null
ÔÔ5 9
&&
ÔÔ: <
!
ÔÔ= >
used
ÔÔ> B
.
ÔÔB C
Contains
ÔÔC K
(
ÔÔK L
prev
ÔÔL P
.
ÔÔP Q
edge
ÔÔQ U
)
ÔÔU V
)
ÔÔV W
used
 
.
 
Add
 
(
 
prev
 !
.
! "
edge
" &
)
& '
;
' (
}
ÒÒ 
return
ÛÛ 
used
ÛÛ 
.
ÛÛ 
Select
ÛÛ 
(
ÛÛ 
x
ÛÛ  
=>
ÛÛ! #
x
ÛÛ$ %
.
ÛÛ% &
local
ÛÛ& +
)
ÛÛ+ ,
;
ÛÛ, -
}
ÙÙ 	
internal
ÉÉ 
static
ÉÉ 
bool
ÉÉ 
GetEdgeLoop
ÉÉ (
(
ÉÉ( )
ProBuilderMesh
ÉÉ) 7
mesh
ÉÉ8 <
,
ÉÉ< =
IEnumerable
ÉÉ> I
<
ÉÉI J
Edge
ÉÉJ N
>
ÉÉN O
edges
ÉÉP U
,
ÉÉU V
out
ÉÉW Z
Edge
ÉÉ[ _
[
ÉÉ_ `
]
ÉÉ` a
loop
ÉÉb f
)
ÉÉf g
{
ÑÑ 	
List
ÖÖ 
<
ÖÖ 

WingedEdge
ÖÖ 
>
ÖÖ 
wings
ÖÖ "
=
ÖÖ# $

WingedEdge
ÖÖ% /
.
ÖÖ/ 0
GetWingedEdges
ÖÖ0 >
(
ÖÖ> ?
mesh
ÖÖ? C
)
ÖÖC D
;
ÖÖD E
IEnumerable
ÜÜ 
<
ÜÜ 

EdgeLookup
ÜÜ "
>
ÜÜ" #
m_edgeLookup
ÜÜ$ 0
=
ÜÜ1 2

EdgeLookup
ÜÜ3 =
.
ÜÜ= >
GetEdgeLookup
ÜÜ> K
(
ÜÜK L
edges
ÜÜL Q
,
ÜÜQ R
mesh
ÜÜS W
.
ÜÜW X 
sharedVertexLookup
ÜÜX j
)
ÜÜj k
;
ÜÜk l
HashSet
áá 
<
áá 

EdgeLookup
áá 
>
áá 
sources
áá  '
=
áá( )
new
áá* -
HashSet
áá. 5
<
áá5 6

EdgeLookup
áá6 @
>
áá@ A
(
ááA B
m_edgeLookup
ááB N
)
ááN O
;
ááO P
HashSet
àà 
<
àà 

EdgeLookup
àà 
>
àà 
used
àà  $
=
àà% &
new
àà' *
HashSet
àà+ 2
<
àà2 3

EdgeLookup
àà3 =
>
àà= >
(
àà> ?
)
àà? @
;
àà@ A
for
ää 
(
ää 
int
ää 
i
ää 
=
ää 
$num
ää 
;
ää 
i
ää 
<
ää 
wings
ää  %
.
ää% &
Count
ää& +
;
ää+ ,
i
ää- .
++
ää. 0
)
ää0 1
{
ãã 
if
åå 
(
åå 
used
åå 
.
åå 
Contains
åå !
(
åå! "
wings
åå" '
[
åå' (
i
åå( )
]
åå) *
.
åå* +
edge
åå+ /
)
åå/ 0
||
åå1 3
!
åå4 5
sources
åå5 <
.
åå< =
Contains
åå= E
(
ååE F
wings
ååF K
[
ååK L
i
ååL M
]
ååM N
.
ååN O
edge
ååO S
)
ååS T
)
ååT U
continue
çç 
;
çç 
bool
èè 
completeLoop
èè !
=
èè" #!
GetEdgeLoopInternal
èè$ 7
(
èè7 8
wings
èè8 =
[
èè= >
i
èè> ?
]
èè? @
,
èè@ A
wings
èèB G
[
èèG H
i
èèH I
]
èèI J
.
èèJ K
edge
èèK O
.
èèO P
common
èèP V
.
èèV W
b
èèW X
,
èèX Y
used
èèZ ^
)
èè^ _
;
èè_ `
if
íí 
(
íí 
!
íí 
completeLoop
íí !
)
íí! "!
GetEdgeLoopInternal
ìì '
(
ìì' (
wings
ìì( -
[
ìì- .
i
ìì. /
]
ìì/ 0
,
ìì0 1
wings
ìì2 7
[
ìì7 8
i
ìì8 9
]
ìì9 :
.
ìì: ;
edge
ìì; ?
.
ìì? @
common
ìì@ F
.
ììF G
a
ììG H
,
ììH I
used
ììJ N
)
ììN O
;
ììO P
}
îî 
loop
ññ 
=
ññ 
used
ññ 
.
ññ 
Select
ññ 
(
ññ 
x
ññ  
=>
ññ! #
x
ññ$ %
.
ññ% &
local
ññ& +
)
ññ+ ,
.
ññ, -
ToArray
ññ- 4
(
ññ4 5
)
ññ5 6
;
ññ6 7
return
òò 
true
òò 
;
òò 
}
ôô 	
internal
§§ 
static
§§ 
bool
§§ "
GetEdgeLoopIterative
§§ 1
(
§§1 2
ProBuilderMesh
§§2 @
mesh
§§A E
,
§§E F
IEnumerable
§§G R
<
§§R S
Edge
§§S W
>
§§W X
edges
§§Y ^
,
§§^ _
out
§§` c
Edge
§§d h
[
§§h i
]
§§i j
loop
§§k o
)
§§o p
{
•• 	
List
¶¶ 
<
¶¶ 

WingedEdge
¶¶ 
>
¶¶ 
wings
¶¶ "
=
¶¶# $

WingedEdge
¶¶% /
.
¶¶/ 0
GetWingedEdges
¶¶0 >
(
¶¶> ?
mesh
¶¶? C
)
¶¶C D
;
¶¶D E
IEnumerable
ßß 
<
ßß 

EdgeLookup
ßß "
>
ßß" #
m_edgeLookup
ßß$ 0
=
ßß1 2

EdgeLookup
ßß3 =
.
ßß= >
GetEdgeLookup
ßß> K
(
ßßK L
edges
ßßL Q
,
ßßQ R
mesh
ßßS W
.
ßßW X 
sharedVertexLookup
ßßX j
)
ßßj k
;
ßßk l
HashSet
®® 
<
®® 

EdgeLookup
®® 
>
®® 
sources
®®  '
=
®®( )
new
®®* -
HashSet
®®. 5
<
®®5 6

EdgeLookup
®®6 @
>
®®@ A
(
®®A B
m_edgeLookup
®®B N
)
®®N O
;
®®O P
HashSet
©© 
<
©© 

EdgeLookup
©© 
>
©© 
used
©©  $
=
©©% &
new
©©' *
HashSet
©©+ 2
<
©©2 3

EdgeLookup
©©3 =
>
©©= >
(
©©> ?
)
©©? @
;
©©@ A
for
´´ 
(
´´ 
int
´´ 
i
´´ 
=
´´ 
$num
´´ 
;
´´ 
i
´´ 
<
´´ 
wings
´´  %
.
´´% &
Count
´´& +
;
´´+ ,
i
´´- .
++
´´. 0
)
´´0 1
{
¨¨ 
if
≠≠ 
(
≠≠ 
!
≠≠ 
sources
≠≠ 
.
≠≠ 
Contains
≠≠ %
(
≠≠% &
wings
≠≠& +
[
≠≠+ ,
i
≠≠, -
]
≠≠- .
.
≠≠. /
edge
≠≠/ 3
)
≠≠3 4
)
≠≠4 5
continue
ÆÆ 
;
ÆÆ *
GetEdgeLoopInternalIterative
∞∞ ,
(
∞∞, -
wings
∞∞- 2
[
∞∞2 3
i
∞∞3 4
]
∞∞4 5
,
∞∞5 6
wings
∞∞7 <
[
∞∞< =
i
∞∞= >
]
∞∞> ?
.
∞∞? @
edge
∞∞@ D
.
∞∞D E
common
∞∞E K
,
∞∞K L
used
∞∞M Q
)
∞∞Q R
;
∞∞R S
}
±± 
loop
≥≥ 
=
≥≥ 
used
≥≥ 
.
≥≥ 
Select
≥≥ 
(
≥≥ 
x
≥≥  
=>
≥≥! #
x
≥≥$ %
.
≥≥% &
local
≥≥& +
)
≥≥+ ,
.
≥≥, -
ToArray
≥≥- 4
(
≥≥4 5
)
≥≥5 6
;
≥≥6 7
return
µµ 
true
µµ 
;
µµ 
}
∂∂ 	
static
∏∏ 
bool
∏∏ !
GetEdgeLoopInternal
∏∏ '
(
∏∏' (

WingedEdge
∏∏( 2
start
∏∏3 8
,
∏∏8 9
int
∏∏: =

startIndex
∏∏> H
,
∏∏H I
HashSet
∏∏J Q
<
∏∏Q R

EdgeLookup
∏∏R \
>
∏∏\ ]
used
∏∏^ b
)
∏∏b c
{
ππ 	
int
∫∫ 
ind
∫∫ 
=
∫∫ 

startIndex
∫∫  
;
∫∫  !

WingedEdge
ªª 
cur
ªª 
=
ªª 
start
ªª "
;
ªª" #
do
ΩΩ 
{
ææ 
used
øø 
.
øø 
Add
øø 
(
øø 
cur
øø 
.
øø 
edge
øø !
)
øø! "
;
øø" #
List
¡¡ 
<
¡¡ 

WingedEdge
¡¡ 
>
¡¡  
spokes
¡¡! '
=
¡¡( )
	GetSpokes
¡¡* 3
(
¡¡3 4
cur
¡¡4 7
,
¡¡7 8
ind
¡¡9 <
,
¡¡< =
true
¡¡> B
)
¡¡B C
.
¡¡C D

DistinctBy
¡¡D N
(
¡¡N O
x
¡¡O P
=>
¡¡Q S
x
¡¡T U
.
¡¡U V
edge
¡¡V Z
.
¡¡Z [
common
¡¡[ a
)
¡¡a b
.
¡¡b c
ToList
¡¡c i
(
¡¡i j
)
¡¡j k
;
¡¡k l
cur
√√ 
=
√√ 
null
√√ 
;
√√ 
if
≈≈ 
(
≈≈ 
spokes
≈≈ 
.
≈≈ 
Count
≈≈  
==
≈≈! #
$num
≈≈$ %
)
≈≈% &
{
∆∆ 
cur
«« 
=
«« 
spokes
««  
[
««  !
$num
««! "
]
««" #
;
««# $
ind
»» 
=
»» 
cur
»» 
.
»» 
edge
»» "
.
»»" #
common
»»# )
.
»») *
a
»»* +
==
»», .
ind
»»/ 2
?
»»3 4
cur
»»5 8
.
»»8 9
edge
»»9 =
.
»»= >
common
»»> D
.
»»D E
b
»»E F
:
»»G H
cur
»»I L
.
»»L M
edge
»»M Q
.
»»Q R
common
»»R X
.
»»X Y
a
»»Y Z
;
»»Z [
}
…… 
}
   
while
ÀÀ 
(
ÀÀ 
cur
ÀÀ 
!=
ÀÀ 
null
ÀÀ 
&&
ÀÀ !
!
ÀÀ" #
used
ÀÀ# '
.
ÀÀ' (
Contains
ÀÀ( 0
(
ÀÀ0 1
cur
ÀÀ1 4
.
ÀÀ4 5
edge
ÀÀ5 9
)
ÀÀ9 :
)
ÀÀ: ;
;
ÀÀ; <
return
ÕÕ 
cur
ÕÕ 
!=
ÕÕ 
null
ÕÕ 
;
ÕÕ 
}
ŒŒ 	
static
–– 
void
–– *
GetEdgeLoopInternalIterative
–– 0
(
––0 1

WingedEdge
––1 ;
start
––< A
,
––A B
Edge
––C G
edge
––H L
,
––L M
HashSet
––N U
<
––U V

EdgeLookup
––V `
>
––` a
used
––b f
)
––f g
{
—— 	
int
““ 
indA
““ 
=
““ 
edge
““ 
.
““ 
a
““ 
;
““ 
int
”” 
indB
”” 
=
”” 
edge
”” 
.
”” 
b
”” 
;
”” 

WingedEdge
‘‘ 
cur
‘‘ 
=
‘‘ 
start
‘‘ "
;
‘‘" #
if
÷÷ 
(
÷÷ 
!
÷÷ 
used
÷÷ 
.
÷÷ 
Contains
÷÷ 
(
÷÷ 
cur
÷÷ "
.
÷÷" #
edge
÷÷# '
)
÷÷' (
)
÷÷( )
used
◊◊ 
.
◊◊ 
Add
◊◊ 
(
◊◊ 
cur
◊◊ 
.
◊◊ 
edge
◊◊ !
)
◊◊! "
;
◊◊" #
List
ŸŸ 
<
ŸŸ 

WingedEdge
ŸŸ 
>
ŸŸ 
spokesA
ŸŸ $
=
ŸŸ% &
	GetSpokes
ŸŸ' 0
(
ŸŸ0 1
cur
ŸŸ1 4
,
ŸŸ4 5
indA
ŸŸ6 :
,
ŸŸ: ;
true
ŸŸ< @
)
ŸŸ@ A
.
ŸŸA B

DistinctBy
ŸŸB L
(
ŸŸL M
x
ŸŸM N
=>
ŸŸO Q
x
ŸŸR S
.
ŸŸS T
edge
ŸŸT X
.
ŸŸX Y
common
ŸŸY _
)
ŸŸ_ `
.
ŸŸ` a
ToList
ŸŸa g
(
ŸŸg h
)
ŸŸh i
;
ŸŸi j
List
⁄⁄ 
<
⁄⁄ 

WingedEdge
⁄⁄ 
>
⁄⁄ 
spokesB
⁄⁄ $
=
⁄⁄% &
	GetSpokes
⁄⁄' 0
(
⁄⁄0 1
cur
⁄⁄1 4
,
⁄⁄4 5
indB
⁄⁄6 :
,
⁄⁄: ;
true
⁄⁄< @
)
⁄⁄@ A
.
⁄⁄A B

DistinctBy
⁄⁄B L
(
⁄⁄L M
x
⁄⁄M N
=>
⁄⁄O Q
x
⁄⁄R S
.
⁄⁄S T
edge
⁄⁄T X
.
⁄⁄X Y
common
⁄⁄Y _
)
⁄⁄_ `
.
⁄⁄` a
ToList
⁄⁄a g
(
⁄⁄g h
)
⁄⁄h i
;
⁄⁄i j
if
‹‹ 
(
‹‹ 
spokesA
‹‹ 
.
‹‹ 
Count
‹‹ 
==
‹‹  
$num
‹‹! "
)
‹‹" #
{
›› 
cur
ﬁﬁ 
=
ﬁﬁ 
spokesA
ﬁﬁ 
[
ﬁﬁ 
$num
ﬁﬁ 
]
ﬁﬁ  
;
ﬁﬁ  !
if
‡‡ 
(
‡‡ 
!
‡‡ 
used
‡‡ 
.
‡‡ 
Contains
‡‡ "
(
‡‡" #
cur
‡‡# &
.
‡‡& '
edge
‡‡' +
)
‡‡+ ,
)
‡‡, -
used
·· 
.
·· 
Add
·· 
(
·· 
cur
··  
.
··  !
edge
··! %
)
··% &
;
··& '
}
‚‚ 
if
„„ 
(
„„ 
spokesB
„„ 
.
„„ 
Count
„„ 
==
„„  
$num
„„! "
)
„„" #
{
‰‰ 
cur
ÂÂ 
=
ÂÂ 
spokesB
ÂÂ 
[
ÂÂ 
$num
ÂÂ 
]
ÂÂ  
;
ÂÂ  !
if
ÁÁ 
(
ÁÁ 
!
ÁÁ 
used
ÁÁ 
.
ÁÁ 
Contains
ÁÁ "
(
ÁÁ" #
cur
ÁÁ# &
.
ÁÁ& '
edge
ÁÁ' +
)
ÁÁ+ ,
)
ÁÁ, -
used
ËË 
.
ËË 
Add
ËË 
(
ËË 
cur
ËË  
.
ËË  !
edge
ËË! %
)
ËË% &
;
ËË& '
}
ÈÈ 
}
ÍÍ 	
static
ÏÏ 

WingedEdge
ÏÏ 
	NextSpoke
ÏÏ #
(
ÏÏ# $

WingedEdge
ÏÏ$ .
wing
ÏÏ/ 3
,
ÏÏ3 4
int
ÏÏ5 8
pivot
ÏÏ9 >
,
ÏÏ> ?
bool
ÏÏ@ D
opp
ÏÏE H
)
ÏÏH I
{
ÌÌ 	
if
ÓÓ 
(
ÓÓ 
opp
ÓÓ 
)
ÓÓ 
return
ÔÔ 
wing
ÔÔ 
.
ÔÔ 
opposite
ÔÔ $
;
ÔÔ$ %
if
 
(
 
wing
 
.
 
next
 
.
 
edge
 
.
 
common
 %
.
% &
Contains
& .
(
. /
pivot
/ 4
)
4 5
)
5 6
return
ÒÒ 
wing
ÒÒ 
.
ÒÒ 
next
ÒÒ  
;
ÒÒ  !
if
ÚÚ 
(
ÚÚ 
wing
ÚÚ 
.
ÚÚ 
previous
ÚÚ 
.
ÚÚ 
edge
ÚÚ "
.
ÚÚ" #
common
ÚÚ# )
.
ÚÚ) *
Contains
ÚÚ* 2
(
ÚÚ2 3
pivot
ÚÚ3 8
)
ÚÚ8 9
)
ÚÚ9 :
return
ÛÛ 
wing
ÛÛ 
.
ÛÛ 
previous
ÛÛ $
;
ÛÛ$ %
return
ÙÙ 
null
ÙÙ 
;
ÙÙ 
}
ıı 	
internal
˛˛ 
static
˛˛ 
List
˛˛ 
<
˛˛ 

WingedEdge
˛˛ '
>
˛˛' (
	GetSpokes
˛˛) 2
(
˛˛2 3

WingedEdge
˛˛3 =
wing
˛˛> B
,
˛˛B C
int
˛˛D G
sharedIndex
˛˛H S
,
˛˛S T
bool
˛˛U Y

allowHoles
˛˛Z d
=
˛˛e f
false
˛˛g l
)
˛˛l m
{
ˇˇ 	
List
ÄÄ 
<
ÄÄ 

WingedEdge
ÄÄ 
>
ÄÄ 
spokes
ÄÄ #
=
ÄÄ$ %
new
ÄÄ& )
List
ÄÄ* .
<
ÄÄ. /

WingedEdge
ÄÄ/ 9
>
ÄÄ9 :
(
ÄÄ: ;
)
ÄÄ; <
;
ÄÄ< =

WingedEdge
ÅÅ 
cur
ÅÅ 
=
ÅÅ 
wing
ÅÅ !
;
ÅÅ! "
bool
ÇÇ 
opp
ÇÇ 
=
ÇÇ 
false
ÇÇ 
;
ÇÇ 
do
ÑÑ 
{
ÖÖ 
if
áá 
(
áá 
spokes
áá 
.
áá 
Contains
áá #
(
áá# $
cur
áá$ '
)
áá' (
)
áá( )
return
àà 
spokes
àà !
;
àà! "
spokes
ää 
.
ää 
Add
ää 
(
ää 
cur
ää 
)
ää 
;
ää  
cur
ãã 
=
ãã 
	NextSpoke
ãã 
(
ãã  
cur
ãã  #
,
ãã# $
sharedIndex
ãã% 0
,
ãã0 1
opp
ãã2 5
)
ãã5 6
;
ãã6 7
opp
åå 
=
åå 
!
åå 
opp
åå 
;
åå 
if
èè 
(
èè 
cur
èè 
!=
èè 
null
èè 
&&
èè  "
cur
èè# &
.
èè& '
edge
èè' +
.
èè+ ,
common
èè, 2
.
èè2 3
Equals
èè3 9
(
èè9 :
wing
èè: >
.
èè> ?
edge
èè? C
.
èèC D
common
èèD J
)
èèJ K
)
èèK L
return
êê 
spokes
êê !
;
êê! "
}
ëë 
while
íí 
(
íí 
cur
íí 
!=
íí 
null
íí 
)
íí 
;
íí  
if
îî 
(
îî 
!
îî 

allowHoles
îî 
)
îî 
return
ïï 
null
ïï 
;
ïï 
cur
ôô 
=
ôô 
wing
ôô 
.
ôô 
opposite
ôô 
;
ôô  
opp
öö 
=
öö 
false
öö 
;
öö 
List
õõ 
<
õõ 

WingedEdge
õõ 
>
õõ 
fragment
õõ %
=
õõ& '
new
õõ( +
List
õõ, 0
<
õõ0 1

WingedEdge
õõ1 ;
>
õõ; <
(
õõ< =
)
õõ= >
;
õõ> ?
while
ûû 
(
ûû 
cur
ûû 
!=
ûû 
null
ûû 
&&
ûû !
!
ûû" #
cur
ûû# &
.
ûû& '
edge
ûû' +
.
ûû+ ,
common
ûû, 2
.
ûû2 3
Equals
ûû3 9
(
ûû9 :
wing
ûû: >
.
ûû> ?
edge
ûû? C
.
ûûC D
common
ûûD J
)
ûûJ K
)
ûûK L
{
üü 
fragment
†† 
.
†† 
Add
†† 
(
†† 
cur
††  
)
††  !
;
††! "
cur
°° 
=
°° 
	NextSpoke
°° 
(
°°  
cur
°°  #
,
°°# $
sharedIndex
°°% 0
,
°°0 1
opp
°°2 5
)
°°5 6
;
°°6 7
opp
¢¢ 
=
¢¢ 
!
¢¢ 
opp
¢¢ 
;
¢¢ 
}
££ 
fragment
•• 
.
•• 
Reverse
•• 
(
•• 
)
•• 
;
•• 
spokes
¶¶ 
.
¶¶ 
AddRange
¶¶ 
(
¶¶ 
fragment
¶¶ $
)
¶¶$ %
;
¶¶% &
return
®® 
spokes
®® 
;
®® 
}
©© 	
public
≤≤ 
static
≤≤ 
HashSet
≤≤ 
<
≤≤ 
Face
≤≤ "
>
≤≤" #
GrowSelection
≤≤$ 1
(
≤≤1 2
ProBuilderMesh
≤≤2 @
mesh
≤≤A E
,
≤≤E F
IEnumerable
≤≤G R
<
≤≤R S
Face
≤≤S W
>
≤≤W X
faces
≤≤Y ^
,
≤≤^ _
float
≤≤` e
maxAngleDiff
≤≤f r
=
≤≤s t
-
≤≤u v
$num
≤≤v x
)
≤≤x y
{
≥≥ 	
List
¥¥ 
<
¥¥ 

WingedEdge
¥¥ 
>
¥¥ 
wings
¥¥ "
=
¥¥# $

WingedEdge
¥¥% /
.
¥¥/ 0
GetWingedEdges
¥¥0 >
(
¥¥> ?
mesh
¥¥? C
,
¥¥C D
true
¥¥E I
)
¥¥I J
;
¥¥J K
HashSet
µµ 
<
µµ 
Face
µµ 
>
µµ 
source
µµ  
=
µµ! "
new
µµ# &
HashSet
µµ' .
<
µµ. /
Face
µµ/ 3
>
µµ3 4
(
µµ4 5
faces
µµ5 :
)
µµ: ;
;
µµ; <
HashSet
∂∂ 
<
∂∂ 
Face
∂∂ 
>
∂∂ 
neighboring
∂∂ %
=
∂∂& '
new
∂∂( +
HashSet
∂∂, 3
<
∂∂3 4
Face
∂∂4 8
>
∂∂8 9
(
∂∂9 :
)
∂∂: ;
;
∂∂; <
Vector3
∏∏ 
	srcNormal
∏∏ 
=
∏∏ 
Vector3
∏∏  '
.
∏∏' (
zero
∏∏( ,
;
∏∏, -
bool
ππ 

checkAngle
ππ 
=
ππ 
maxAngleDiff
ππ *
>
ππ+ ,
$num
ππ- /
;
ππ/ 0
for
ªª 
(
ªª 
int
ªª 
i
ªª 
=
ªª 
$num
ªª 
;
ªª 
i
ªª 
<
ªª 
wings
ªª  %
.
ªª% &
Count
ªª& +
;
ªª+ ,
i
ªª- .
++
ªª. 0
)
ªª0 1
{
ºº 
if
ΩΩ 
(
ΩΩ 
!
ΩΩ 
source
ΩΩ 
.
ΩΩ 
Contains
ΩΩ $
(
ΩΩ$ %
wings
ΩΩ% *
[
ΩΩ* +
i
ΩΩ+ ,
]
ΩΩ, -
.
ΩΩ- .
face
ΩΩ. 2
)
ΩΩ2 3
)
ΩΩ3 4
continue
ææ 
;
ææ 
if
¿¿ 
(
¿¿ 

checkAngle
¿¿ 
)
¿¿ 
	srcNormal
¡¡ 
=
¡¡ 
Math
¡¡  $
.
¡¡$ %
Normal
¡¡% +
(
¡¡+ ,
mesh
¡¡, 0
,
¡¡0 1
wings
¡¡2 7
[
¡¡7 8
i
¡¡8 9
]
¡¡9 :
.
¡¡: ;
face
¡¡; ?
)
¡¡? @
;
¡¡@ A
using
√√ 
(
√√ 
var
√√ 
it
√√ 
=
√√ 
new
√√  #"
WingedEdgeEnumerator
√√$ 8
(
√√8 9
wings
√√9 >
[
√√> ?
i
√√? @
]
√√@ A
)
√√A B
)
√√B C
{
ƒƒ 
while
≈≈ 
(
≈≈ 
it
≈≈ 
.
≈≈ 
MoveNext
≈≈ &
(
≈≈& '
)
≈≈' (
)
≈≈( )
{
∆∆ 
var
«« 
w
«« 
=
«« 
it
««  "
.
««" #
Current
««# *
;
««* +
if
…… 
(
…… 
w
…… 
.
…… 
opposite
…… &
!=
……' )
null
……* .
&&
……/ 1
!
……2 3
source
……3 9
.
……9 :
Contains
……: B
(
……B C
w
……C D
.
……D E
opposite
……E M
.
……M N
face
……N R
)
……R S
)
……S T
{
   
if
ÀÀ 
(
ÀÀ  

checkAngle
ÀÀ  *
)
ÀÀ* +
{
ÃÃ 
Vector3
ÕÕ  '
	oppNormal
ÕÕ( 1
=
ÕÕ2 3
Math
ÕÕ4 8
.
ÕÕ8 9
Normal
ÕÕ9 ?
(
ÕÕ? @
mesh
ÕÕ@ D
,
ÕÕD E
w
ÕÕF G
.
ÕÕG H
opposite
ÕÕH P
.
ÕÕP Q
face
ÕÕQ U
)
ÕÕU V
;
ÕÕV W
if
œœ  "
(
œœ# $
Vector3
œœ$ +
.
œœ+ ,
Angle
œœ, 1
(
œœ1 2
	srcNormal
œœ2 ;
,
œœ; <
	oppNormal
œœ= F
)
œœF G
<
œœH I
maxAngleDiff
œœJ V
)
œœV W
neighboring
––$ /
.
––/ 0
Add
––0 3
(
––3 4
w
––4 5
.
––5 6
opposite
––6 >
.
––> ?
face
––? C
)
––C D
;
––D E
}
—— 
else
““  
{
”” 
neighboring
‘‘  +
.
‘‘+ ,
Add
‘‘, /
(
‘‘/ 0
w
‘‘0 1
.
‘‘1 2
opposite
‘‘2 :
.
‘‘: ;
face
‘‘; ?
)
‘‘? @
;
‘‘@ A
}
’’ 
}
÷÷ 
}
◊◊ 
}
ÿÿ 
}
ŸŸ 
return
€€ 
neighboring
€€ 
;
€€ 
}
‹‹ 	
static
ﬁﬁ 
readonly
ﬁﬁ 
Vector3
ﬁﬁ 
Vector3_Zero
ﬁﬁ  ,
=
ﬁﬁ- .
new
ﬁﬁ/ 2
Vector3
ﬁﬁ3 :
(
ﬁﬁ: ;
$num
ﬁﬁ; =
,
ﬁﬁ= >
$num
ﬁﬁ? A
,
ﬁﬁA B
$num
ﬁﬁC E
)
ﬁﬁE F
;
ﬁﬁF G
internal
‡‡ 
static
‡‡ 
void
‡‡ 
Flood
‡‡ "
(
‡‡" #

WingedEdge
‡‡# -
wing
‡‡. 2
,
‡‡2 3
HashSet
‡‡4 ;
<
‡‡; <
Face
‡‡< @
>
‡‡@ A
	selection
‡‡B K
)
‡‡K L
{
·· 	
Flood
‚‚ 
(
‚‚ 
null
‚‚ 
,
‚‚ 
wing
‚‚ 
,
‚‚ 
Vector3_Zero
‚‚ *
,
‚‚* +
-
‚‚, -
$num
‚‚- /
,
‚‚/ 0
	selection
‚‚1 :
)
‚‚: ;
;
‚‚; <
}
„„ 	
internal
ÂÂ 
static
ÂÂ 
void
ÂÂ 
Flood
ÂÂ "
(
ÂÂ" #
ProBuilderMesh
ÂÂ# 1
pb
ÂÂ2 4
,
ÂÂ4 5

WingedEdge
ÂÂ6 @
wing
ÂÂA E
,
ÂÂE F
Vector3
ÂÂG N
wingNrm
ÂÂO V
,
ÂÂV W
float
ÂÂX ]
maxAngle
ÂÂ^ f
,
ÂÂf g
HashSet
ÂÂh o
<
ÂÂo p
Face
ÂÂp t
>
ÂÂt u
	selection
ÂÂv 
)ÂÂ Ä
{
ÊÊ 	

WingedEdge
ÁÁ 
next
ÁÁ 
=
ÁÁ 
wing
ÁÁ "
;
ÁÁ" #
do
ÈÈ 
{
ÍÍ 

WingedEdge
ÎÎ 
opp
ÎÎ 
=
ÎÎ  
next
ÎÎ! %
.
ÎÎ% &
opposite
ÎÎ& .
;
ÎÎ. /
if
ÌÌ 
(
ÌÌ 
opp
ÌÌ 
!=
ÌÌ 
null
ÌÌ 
&&
ÌÌ  "
!
ÌÌ# $
	selection
ÌÌ$ -
.
ÌÌ- .
Contains
ÌÌ. 6
(
ÌÌ6 7
opp
ÌÌ7 :
.
ÌÌ: ;
face
ÌÌ; ?
)
ÌÌ? @
)
ÌÌ@ A
{
ÓÓ 
if
ÔÔ 
(
ÔÔ 
maxAngle
ÔÔ  
>
ÔÔ! "
$num
ÔÔ# %
)
ÔÔ% &
{
 
Vector3
ÒÒ 
	oppNormal
ÒÒ  )
=
ÒÒ* +
Math
ÒÒ, 0
.
ÒÒ0 1
Normal
ÒÒ1 7
(
ÒÒ7 8
pb
ÒÒ8 :
,
ÒÒ: ;
opp
ÒÒ< ?
.
ÒÒ? @
face
ÒÒ@ D
)
ÒÒD E
;
ÒÒE F
if
ÛÛ 
(
ÛÛ 
Vector3
ÛÛ #
.
ÛÛ# $
Angle
ÛÛ$ )
(
ÛÛ) *
wingNrm
ÛÛ* 1
,
ÛÛ1 2
	oppNormal
ÛÛ3 <
)
ÛÛ< =
<
ÛÛ> ?
maxAngle
ÛÛ@ H
)
ÛÛH I
{
ÙÙ 
if
ıı 
(
ıı  
	selection
ıı  )
.
ıı) *
Add
ıı* -
(
ıı- .
opp
ıı. 1
.
ıı1 2
face
ıı2 6
)
ıı6 7
)
ıı7 8
Flood
ˆˆ  %
(
ˆˆ% &
pb
ˆˆ& (
,
ˆˆ( )
opp
ˆˆ* -
,
ˆˆ- .
	oppNormal
ˆˆ/ 8
,
ˆˆ8 9
maxAngle
ˆˆ: B
,
ˆˆB C
	selection
ˆˆD M
)
ˆˆM N
;
ˆˆN O
}
˜˜ 
}
¯¯ 
else
˘˘ 
{
˙˙ 
if
˚˚ 
(
˚˚ 
	selection
˚˚ %
.
˚˚% &
Add
˚˚& )
(
˚˚) *
opp
˚˚* -
.
˚˚- .
face
˚˚. 2
)
˚˚2 3
)
˚˚3 4
Flood
¸¸ !
(
¸¸! "
pb
¸¸" $
,
¸¸$ %
opp
¸¸& )
,
¸¸) *
wingNrm
¸¸+ 2
,
¸¸2 3
maxAngle
¸¸4 <
,
¸¸< =
	selection
¸¸> G
)
¸¸G H
;
¸¸H I
}
˝˝ 
}
˛˛ 
next
ÄÄ 
=
ÄÄ 
next
ÄÄ 
.
ÄÄ 
next
ÄÄ  
;
ÄÄ  !
}
ÅÅ 
while
ÇÇ 
(
ÇÇ 
next
ÇÇ 
!=
ÇÇ 
wing
ÇÇ 
)
ÇÇ  
;
ÇÇ  !
}
ÉÉ 	
public
åå 
static
åå 
HashSet
åå 
<
åå 
Face
åå "
>
åå" #
FloodSelection
åå$ 2
(
åå2 3
ProBuilderMesh
åå3 A
mesh
ååB F
,
ååF G
IList
ååH M
<
ååM N
Face
ååN R
>
ååR S
faces
ååT Y
,
ååY Z
float
åå[ `
maxAngleDiff
ååa m
)
ååm n
{
çç 	
List
éé 
<
éé 

WingedEdge
éé 
>
éé 
wings
éé "
=
éé# $

WingedEdge
éé% /
.
éé/ 0
GetWingedEdges
éé0 >
(
éé> ?
mesh
éé? C
,
ééC D
true
ééE I
)
ééI J
;
ééJ K
HashSet
èè 
<
èè 
Face
èè 
>
èè 
source
èè  
=
èè! "
new
èè# &
HashSet
èè' .
<
èè. /
Face
èè/ 3
>
èè3 4
(
èè4 5
faces
èè5 :
)
èè: ;
;
èè; <
HashSet
êê 
<
êê 
Face
êê 
>
êê 
flood
êê 
=
êê  !
new
êê" %
HashSet
êê& -
<
êê- .
Face
êê. 2
>
êê2 3
(
êê3 4
)
êê4 5
;
êê5 6
for
íí 
(
íí 
int
íí 
i
íí 
=
íí 
$num
íí 
;
íí 
i
íí 
<
íí 
wings
íí  %
.
íí% &
Count
íí& +
;
íí+ ,
i
íí- .
++
íí. 0
)
íí0 1
{
ìì 
if
îî 
(
îî 
!
îî 
flood
îî 
.
îî 
Contains
îî #
(
îî# $
wings
îî$ )
[
îî) *
i
îî* +
]
îî+ ,
.
îî, -
face
îî- 1
)
îî1 2
&&
îî3 5
source
îî6 <
.
îî< =
Contains
îî= E
(
îîE F
wings
îîF K
[
îîK L
i
îîL M
]
îîM N
.
îîN O
face
îîO S
)
îîS T
)
îîT U
{
ïï 
flood
ññ 
.
ññ 
Add
ññ 
(
ññ 
wings
ññ #
[
ññ# $
i
ññ$ %
]
ññ% &
.
ññ& '
face
ññ' +
)
ññ+ ,
;
ññ, -
Flood
óó 
(
óó 
mesh
óó 
,
óó 
wings
óó  %
[
óó% &
i
óó& '
]
óó' (
,
óó( )
maxAngleDiff
óó* 6
>
óó7 8
$num
óó9 ;
?
óó< =
Math
óó> B
.
óóB C
Normal
óóC I
(
óóI J
mesh
óóJ N
,
óóN O
wings
óóP U
[
óóU V
i
óóV W
]
óóW X
.
óóX Y
face
óóY ]
)
óó] ^
:
óó_ `
Vector3_Zero
óóa m
,
óóm n
maxAngleDiff
óóo {
,
óó{ |
floodóó} Ç
)óóÇ É
;óóÉ Ñ
}
òò 
}
ôô 
return
öö 
flood
öö 
;
öö 
}
õõ 	
public
§§ 
static
§§ 
HashSet
§§ 
<
§§ 
Face
§§ "
>
§§" #
GetFaceLoop
§§$ /
(
§§/ 0
ProBuilderMesh
§§0 >
mesh
§§? C
,
§§C D
Face
§§E I
[
§§I J
]
§§J K
faces
§§L Q
,
§§Q R
bool
§§S W
ring
§§X \
=
§§] ^
false
§§_ d
)
§§d e
{
•• 	
if
¶¶ 
(
¶¶ 
mesh
¶¶ 
==
¶¶ 
null
¶¶ 
)
¶¶ 
throw
ßß 
new
ßß #
ArgumentNullException
ßß /
(
ßß/ 0
$str
ßß0 6
)
ßß6 7
;
ßß7 8
if
©© 
(
©© 
faces
©© 
==
©© 
null
©© 
)
©© 
throw
™™ 
new
™™ #
ArgumentNullException
™™ /
(
™™/ 0
$str
™™0 7
)
™™7 8
;
™™8 9
HashSet
¨¨ 
<
¨¨ 
Face
¨¨ 
>
¨¨ 
loops
¨¨ 
=
¨¨  !
new
¨¨" %
HashSet
¨¨& -
<
¨¨- .
Face
¨¨. 2
>
¨¨2 3
(
¨¨3 4
)
¨¨4 5
;
¨¨5 6
List
≠≠ 
<
≠≠ 

WingedEdge
≠≠ 
>
≠≠ 
wings
≠≠ "
=
≠≠# $

WingedEdge
≠≠% /
.
≠≠/ 0
GetWingedEdges
≠≠0 >
(
≠≠> ?
mesh
≠≠? C
)
≠≠C D
;
≠≠D E
foreach
ØØ 
(
ØØ 
Face
ØØ 
face
ØØ 
in
ØØ !
faces
ØØ" '
)
ØØ' (
loops
∞∞ 
.
∞∞ 
	UnionWith
∞∞ 
(
∞∞  
GetFaceLoop
∞∞  +
(
∞∞+ ,
wings
∞∞, 1
,
∞∞1 2
face
∞∞3 7
,
∞∞7 8
ring
∞∞9 =
)
∞∞= >
)
∞∞> ?
;
∞∞? @
return
≤≤ 
loops
≤≤ 
;
≤≤ 
}
≥≥ 	
public
ªª 
static
ªª 
HashSet
ªª 
<
ªª 
Face
ªª "
>
ªª" # 
GetFaceRingAndLoop
ªª$ 6
(
ªª6 7
ProBuilderMesh
ªª7 E
mesh
ªªF J
,
ªªJ K
Face
ªªL P
[
ªªP Q
]
ªªQ R
faces
ªªS X
)
ªªX Y
{
ºº 	
if
ΩΩ 
(
ΩΩ 
mesh
ΩΩ 
==
ΩΩ 
null
ΩΩ 
)
ΩΩ 
throw
ææ 
new
ææ #
ArgumentNullException
ææ /
(
ææ/ 0
$str
ææ0 6
)
ææ6 7
;
ææ7 8
if
¿¿ 
(
¿¿ 
faces
¿¿ 
==
¿¿ 
null
¿¿ 
)
¿¿ 
throw
¡¡ 
new
¡¡ #
ArgumentNullException
¡¡ /
(
¡¡/ 0
$str
¡¡0 7
)
¡¡7 8
;
¡¡8 9
HashSet
√√ 
<
√√ 
Face
√√ 
>
√√ 
loops
√√ 
=
√√  !
new
√√" %
HashSet
√√& -
<
√√- .
Face
√√. 2
>
√√2 3
(
√√3 4
)
√√4 5
;
√√5 6
List
ƒƒ 
<
ƒƒ 

WingedEdge
ƒƒ 
>
ƒƒ 
wings
ƒƒ "
=
ƒƒ# $

WingedEdge
ƒƒ% /
.
ƒƒ/ 0
GetWingedEdges
ƒƒ0 >
(
ƒƒ> ?
mesh
ƒƒ? C
)
ƒƒC D
;
ƒƒD E
foreach
∆∆ 
(
∆∆ 
Face
∆∆ 
face
∆∆ 
in
∆∆ !
faces
∆∆" '
)
∆∆' (
{
«« 
loops
»» 
.
»» 
	UnionWith
»» 
(
»»  
GetFaceLoop
»»  +
(
»»+ ,
wings
»», 1
,
»»1 2
face
»»3 7
,
»»7 8
true
»»9 =
)
»»= >
)
»»> ?
;
»»? @
loops
…… 
.
…… 
	UnionWith
…… 
(
……  
GetFaceLoop
……  +
(
……+ ,
wings
……, 1
,
……1 2
face
……3 7
,
……7 8
false
……9 >
)
……> ?
)
……? @
;
……@ A
}
   
return
ÃÃ 
loops
ÃÃ 
;
ÃÃ 
}
ÕÕ 	
static
÷÷ 
HashSet
÷÷ 
<
÷÷ 
Face
÷÷ 
>
÷÷ 
GetFaceLoop
÷÷ (
(
÷÷( )
List
÷÷) -
<
÷÷- .

WingedEdge
÷÷. 8
>
÷÷8 9
wings
÷÷: ?
,
÷÷? @
Face
÷÷A E
face
÷÷F J
,
÷÷J K
bool
÷÷L P
ring
÷÷Q U
)
÷÷U V
{
◊◊ 	
HashSet
ÿÿ 
<
ÿÿ 
Face
ÿÿ 
>
ÿÿ 
loop
ÿÿ 
=
ÿÿ  
new
ÿÿ! $
HashSet
ÿÿ% ,
<
ÿÿ, -
Face
ÿÿ- 1
>
ÿÿ1 2
(
ÿÿ2 3
)
ÿÿ3 4
;
ÿÿ4 5
if
⁄⁄ 
(
⁄⁄ 
face
⁄⁄ 
==
⁄⁄ 
null
⁄⁄ 
)
⁄⁄ 
return
€€ 
loop
€€ 
;
€€ 

WingedEdge
›› 
start
›› 
=
›› 
wings
›› $
.
››$ %
FirstOrDefault
››% 3
(
››3 4
x
››4 5
=>
››6 8
x
››9 :
.
››: ;
face
››; ?
==
››@ B
face
››C G
)
››G H
;
››H I
if
ﬂﬂ 
(
ﬂﬂ 
start
ﬂﬂ 
==
ﬂﬂ 
null
ﬂﬂ 
)
ﬂﬂ 
return
‡‡ 
loop
‡‡ 
;
‡‡ 
if
‚‚ 
(
‚‚ 
ring
‚‚ 
)
‚‚ 
start
„„ 
=
„„ 
start
„„ 
.
„„ 
next
„„ "
??
„„# %
start
„„& +
.
„„+ ,
previous
„„, 4
;
„„4 5
for
ÂÂ 
(
ÂÂ 
int
ÂÂ 
i
ÂÂ 
=
ÂÂ 
$num
ÂÂ 
;
ÂÂ 
i
ÂÂ 
<
ÂÂ 
$num
ÂÂ  !
;
ÂÂ! "
i
ÂÂ# $
++
ÂÂ$ &
)
ÂÂ& '
{
ÊÊ 

WingedEdge
ÁÁ 
cur
ÁÁ 
=
ÁÁ  
start
ÁÁ! &
;
ÁÁ& '
if
ÈÈ 
(
ÈÈ 
i
ÈÈ 
==
ÈÈ 
$num
ÈÈ 
)
ÈÈ 
{
ÍÍ 
if
ÎÎ 
(
ÎÎ 
start
ÎÎ 
.
ÎÎ 
opposite
ÎÎ &
!=
ÎÎ' )
null
ÎÎ* .
&&
ÎÎ/ 1
start
ÎÎ2 7
.
ÎÎ7 8
opposite
ÎÎ8 @
.
ÎÎ@ A
face
ÎÎA E
!=
ÎÎF H
null
ÎÎI M
)
ÎÎM N
cur
ÏÏ 
=
ÏÏ 
start
ÏÏ #
.
ÏÏ# $
opposite
ÏÏ$ ,
;
ÏÏ, -
else
ÌÌ 
break
ÓÓ 
;
ÓÓ 
}
ÔÔ 
do
ÒÒ 
{
ÚÚ 
if
ÛÛ 
(
ÛÛ 
!
ÛÛ 
loop
ÛÛ 
.
ÛÛ 
Add
ÛÛ !
(
ÛÛ! "
cur
ÛÛ" %
.
ÛÛ% &
face
ÛÛ& *
)
ÛÛ* +
)
ÛÛ+ ,
break
ÙÙ 
;
ÙÙ 
if
ˆˆ 
(
ˆˆ 
cur
ˆˆ 
.
ˆˆ 
Count
ˆˆ !
(
ˆˆ! "
)
ˆˆ" #
!=
ˆˆ$ &
$num
ˆˆ' (
)
ˆˆ( )
break
˜˜ 
;
˜˜ 
cur
˙˙ 
=
˙˙ 
cur
˙˙ 
.
˙˙ 
next
˙˙ "
.
˙˙" #
next
˙˙# '
.
˙˙' (
opposite
˙˙( 0
;
˙˙0 1
}
˚˚ 
while
¸¸ 
(
¸¸ 
cur
¸¸ 
!=
¸¸ 
null
¸¸ "
&&
¸¸# %
cur
¸¸& )
.
¸¸) *
face
¸¸* .
!=
¸¸/ 1
null
¸¸2 6
)
¸¸6 7
;
¸¸7 8
}
˝˝ 
return
ˇˇ 
loop
ˇˇ 
;
ˇˇ 
}
ÄÄ 	
internal
àà 
static
àà 
List
àà 
<
àà 
List
àà !
<
àà! "
Edge
àà" &
>
àà& '
>
àà' (
	FindHoles
àà) 2
(
àà2 3
ProBuilderMesh
àà3 A
mesh
ààB F
,
ààF G
IEnumerable
ààH S
<
ààS T
int
ààT W
>
ààW X
indexes
ààY `
)
àà` a
{
ââ 	
HashSet
ää 
<
ää 
int
ää 
>
ää 
common
ää 
=
ää  !
mesh
ää" &
.
ää& '$
GetSharedVertexHandles
ää' =
(
ää= >
indexes
ää> E
)
ääE F
;
ääF G
List
ãã 
<
ãã 
List
ãã 
<
ãã 
Edge
ãã 
>
ãã 
>
ãã 
holes
ãã "
=
ãã# $
new
ãã% (
List
ãã) -
<
ãã- .
List
ãã. 2
<
ãã2 3
Edge
ãã3 7
>
ãã7 8
>
ãã8 9
(
ãã9 :
)
ãã: ;
;
ãã; <
List
åå 
<
åå 

WingedEdge
åå 
>
åå 
wings
åå "
=
åå# $

WingedEdge
åå% /
.
åå/ 0
GetWingedEdges
åå0 >
(
åå> ?
mesh
åå? C
)
ååC D
;
ååD E
foreach
éé 
(
éé 
List
éé 
<
éé 

WingedEdge
éé $
>
éé$ %
hole
éé& *
in
éé+ -
	FindHoles
éé. 7
(
éé7 8
wings
éé8 =
,
éé= >
common
éé? E
)
ééE F
)
ééF G
holes
èè 
.
èè 
Add
èè 
(
èè 
hole
èè 
.
èè 
Select
èè %
(
èè% &
x
èè& '
=>
èè( *
x
èè+ ,
.
èè, -
edge
èè- 1
.
èè1 2
local
èè2 7
)
èè7 8
.
èè8 9
ToList
èè9 ?
(
èè? @
)
èè@ A
)
èèA B
;
èèB C
return
ëë 
holes
ëë 
;
ëë 
}
íí 	
internal
öö 
static
öö 
List
öö 
<
öö 
List
öö !
<
öö! "

WingedEdge
öö" ,
>
öö, -
>
öö- .
	FindHoles
öö/ 8
(
öö8 9
List
öö9 =
<
öö= >

WingedEdge
öö> H
>
ööH I
wings
ööJ O
,
ööO P
HashSet
ööQ X
<
ööX Y
int
ööY \
>
öö\ ]
common
öö^ d
)
ööd e
{
õõ 	
HashSet
úú 
<
úú 

WingedEdge
úú 
>
úú 
used
úú  $
=
úú% &
new
úú' *
HashSet
úú+ 2
<
úú2 3

WingedEdge
úú3 =
>
úú= >
(
úú> ?
)
úú? @
;
úú@ A
List
ùù 
<
ùù 
List
ùù 
<
ùù 

WingedEdge
ùù  
>
ùù  !
>
ùù! "
holes
ùù# (
=
ùù) *
new
ùù+ .
List
ùù/ 3
<
ùù3 4
List
ùù4 8
<
ùù8 9

WingedEdge
ùù9 C
>
ùùC D
>
ùùD E
(
ùùE F
)
ùùF G
;
ùùG H
for
üü 
(
üü 
int
üü 
i
üü 
=
üü 
$num
üü 
;
üü 
i
üü 
<
üü 
wings
üü  %
.
üü% &
Count
üü& +
;
üü+ ,
i
üü- .
++
üü. 0
)
üü0 1
{
†† 

WingedEdge
°° 
c
°° 
=
°° 
wings
°° $
[
°°$ %
i
°°% &
]
°°& '
;
°°' (
if
•• 
(
•• 
c
•• 
.
•• 
opposite
•• 
!=
•• !
null
••" &
||
••' )
used
••* .
.
••. /
Contains
••/ 7
(
••7 8
c
••8 9
)
••9 :
||
••; =
!
••> ?
(
••? @
common
••@ F
.
••F G
Contains
••G O
(
••O P
c
••P Q
.
••Q R
edge
••R V
.
••V W
common
••W ]
.
••] ^
a
••^ _
)
••_ `
||
••a c
common
••d j
.
••j k
Contains
••k s
(
••s t
c
••t u
.
••u v
edge
••v z
.
••z {
common••{ Å
.••Å Ç
b••Ç É
)••É Ñ
)••Ñ Ö
)••Ö Ü
continue
¶¶ 
;
¶¶ 
List
®® 
<
®® 

WingedEdge
®® 
>
®®  
hole
®®! %
=
®®& '
new
®®( +
List
®®, 0
<
®®0 1

WingedEdge
®®1 ;
>
®®; <
(
®®< =
)
®®= >
;
®®> ?

WingedEdge
©© 
it
©© 
=
©© 
c
©©  !
;
©©! "
int
™™ 
ind
™™ 
=
™™ 
it
™™ 
.
™™ 
edge
™™ !
.
™™! "
common
™™" (
.
™™( )
a
™™) *
;
™™* +
int
¨¨ 
counter
¨¨ 
=
¨¨ 
$num
¨¨ 
;
¨¨  
while
ÆÆ 
(
ÆÆ 
it
ÆÆ 
!=
ÆÆ 
null
ÆÆ !
&&
ÆÆ" $
counter
ÆÆ% ,
++
ÆÆ, .
<
ÆÆ/ 0!
k_MaxHoleIterations
ÆÆ1 D
)
ÆÆD E
{
ØØ 
used
∞∞ 
.
∞∞ 
Add
∞∞ 
(
∞∞ 
it
∞∞ 
)
∞∞  
;
∞∞  !
hole
±± 
.
±± 
Add
±± 
(
±± 
it
±± 
)
±±  
;
±±  !
ind
≥≥ 
=
≥≥ 
it
≥≥ 
.
≥≥ 
edge
≥≥ !
.
≥≥! "
common
≥≥" (
.
≥≥( )
a
≥≥) *
==
≥≥+ -
ind
≥≥. 1
?
≥≥2 3
it
≥≥4 6
.
≥≥6 7
edge
≥≥7 ;
.
≥≥; <
common
≥≥< B
.
≥≥B C
b
≥≥C D
:
≥≥E F
it
≥≥G I
.
≥≥I J
edge
≥≥J N
.
≥≥N O
common
≥≥O U
.
≥≥U V
a
≥≥V W
;
≥≥W X
it
¥¥ 
=
¥¥  
FindNextEdgeInHole
¥¥ +
(
¥¥+ ,
it
¥¥, .
,
¥¥. /
ind
¥¥0 3
)
¥¥3 4
;
¥¥4 5
if
∂∂ 
(
∂∂ 
it
∂∂ 
==
∂∂ 
c
∂∂ 
)
∂∂  
break
∑∑ 
;
∑∑ 
}
∏∏ 
List
∫∫ 
<
∫∫ 
SimpleTuple
∫∫  
<
∫∫  !
int
∫∫! $
,
∫∫$ %
int
∫∫& )
>
∫∫) *
>
∫∫* +
splits
∫∫, 2
=
∫∫3 4
new
∫∫5 8
List
∫∫9 =
<
∫∫= >
SimpleTuple
∫∫> I
<
∫∫I J
int
∫∫J M
,
∫∫M N
int
∫∫O R
>
∫∫R S
>
∫∫S T
(
∫∫T U
)
∫∫U V
;
∫∫V W
for
ΩΩ 
(
ΩΩ 
int
ΩΩ 
n
ΩΩ 
=
ΩΩ 
$num
ΩΩ 
;
ΩΩ 
n
ΩΩ  !
<
ΩΩ" #
hole
ΩΩ$ (
.
ΩΩ( )
Count
ΩΩ) .
;
ΩΩ. /
n
ΩΩ0 1
++
ΩΩ1 3
)
ΩΩ3 4
{
ææ 

WingedEdge
øø 
wing
øø #
=
øø$ %
hole
øø& *
[
øø* +
n
øø+ ,
]
øø, -
;
øø- .
for
¡¡ 
(
¡¡ 
int
¡¡ 
p
¡¡ 
=
¡¡  
n
¡¡! "
-
¡¡# $
$num
¡¡% &
;
¡¡& '
p
¡¡( )
>
¡¡* +
-
¡¡, -
$num
¡¡- .
;
¡¡. /
p
¡¡0 1
--
¡¡1 3
)
¡¡3 4
{
¬¬ 
if
√√ 
(
√√ 
wing
√√  
.
√√  !
edge
√√! %
.
√√% &
common
√√& ,
.
√√, -
b
√√- .
==
√√/ 1
hole
√√2 6
[
√√6 7
p
√√7 8
]
√√8 9
.
√√9 :
edge
√√: >
.
√√> ?
common
√√? E
.
√√E F
a
√√F G
)
√√G H
{
ƒƒ 
splits
≈≈ "
.
≈≈" #
Add
≈≈# &
(
≈≈& '
new
≈≈' *
SimpleTuple
≈≈+ 6
<
≈≈6 7
int
≈≈7 :
,
≈≈: ;
int
≈≈< ?
>
≈≈? @
(
≈≈@ A
p
≈≈A B
,
≈≈B C
n
≈≈D E
)
≈≈E F
)
≈≈F G
;
≈≈G H
break
∆∆ !
;
∆∆! "
}
«« 
}
»» 
}
…… 
int
·· 

splitCount
·· 
=
··  
splits
··! '
.
··' (
Count
··( -
;
··- .
splits
„„ 
.
„„ 
Sort
„„ 
(
„„ 
(
„„ 
x
„„ 
,
„„ 
y
„„  !
)
„„! "
=>
„„# %
x
„„& '
.
„„' (
item1
„„( -
.
„„- .
	CompareTo
„„. 7
(
„„7 8
y
„„8 9
.
„„9 :
item1
„„: ?
)
„„? @
)
„„@ A
;
„„A B
int
ÂÂ 
[
ÂÂ 
]
ÂÂ 
shift
ÂÂ 
=
ÂÂ 
new
ÂÂ !
int
ÂÂ" %
[
ÂÂ% &

splitCount
ÂÂ& 0
]
ÂÂ0 1
;
ÂÂ1 2
for
ÈÈ 
(
ÈÈ 
int
ÈÈ 
n
ÈÈ 
=
ÈÈ 

splitCount
ÈÈ '
-
ÈÈ( )
$num
ÈÈ* +
;
ÈÈ+ ,
n
ÈÈ- .
>
ÈÈ/ 0
-
ÈÈ1 2
$num
ÈÈ2 3
;
ÈÈ3 4
n
ÈÈ5 6
--
ÈÈ6 8
)
ÈÈ8 9
{
ÍÍ 
int
ÎÎ 
x
ÎÎ 
=
ÎÎ 
splits
ÎÎ "
[
ÎÎ" #
n
ÎÎ# $
]
ÎÎ$ %
.
ÎÎ% &
item1
ÎÎ& +
,
ÎÎ+ ,
y
ÎÎ- .
=
ÎÎ/ 0
splits
ÎÎ1 7
[
ÎÎ7 8
n
ÎÎ8 9
]
ÎÎ9 :
.
ÎÎ: ;
item2
ÎÎ; @
-
ÎÎA B
shift
ÎÎC H
[
ÎÎH I
n
ÎÎI J
]
ÎÎJ K
;
ÎÎK L
int
ÏÏ 
range
ÏÏ 
=
ÏÏ 
(
ÏÏ  !
y
ÏÏ! "
-
ÏÏ# $
x
ÏÏ% &
)
ÏÏ& '
+
ÏÏ( )
$num
ÏÏ* +
;
ÏÏ+ ,
List
ÓÓ 
<
ÓÓ 

WingedEdge
ÓÓ #
>
ÓÓ# $
section
ÓÓ% ,
=
ÓÓ- .
hole
ÓÓ/ 3
.
ÓÓ3 4
GetRange
ÓÓ4 <
(
ÓÓ< =
x
ÓÓ= >
,
ÓÓ> ?
range
ÓÓ@ E
)
ÓÓE F
;
ÓÓF G
hole
 
.
 
RemoveRange
 $
(
$ %
x
% &
,
& '
range
( -
)
- .
;
. /
for
ÚÚ 
(
ÚÚ 
int
ÚÚ 
m
ÚÚ 
=
ÚÚ  
n
ÚÚ! "
-
ÚÚ# $
$num
ÚÚ% &
;
ÚÚ& '
m
ÚÚ( )
>
ÚÚ* +
-
ÚÚ, -
$num
ÚÚ- .
;
ÚÚ. /
m
ÚÚ0 1
--
ÚÚ1 3
)
ÚÚ3 4
if
ÛÛ 
(
ÛÛ 
splits
ÛÛ "
[
ÛÛ" #
m
ÛÛ# $
]
ÛÛ$ %
.
ÛÛ% &
item2
ÛÛ& +
>
ÛÛ, -
splits
ÛÛ. 4
[
ÛÛ4 5
n
ÛÛ5 6
]
ÛÛ6 7
.
ÛÛ7 8
item2
ÛÛ8 =
)
ÛÛ= >
shift
ÙÙ !
[
ÙÙ! "
m
ÙÙ" #
]
ÙÙ# $
+=
ÙÙ% '
range
ÙÙ( -
;
ÙÙ- .
if
˜˜ 
(
˜˜ 

splitCount
˜˜ "
<
˜˜# $
$num
˜˜% &
||
˜˜' )
section
˜˜* 1
.
˜˜1 2
Any
˜˜2 5
(
˜˜5 6
w
˜˜6 7
=>
˜˜8 :
common
˜˜; A
.
˜˜A B
Contains
˜˜B J
(
˜˜J K
w
˜˜K L
.
˜˜L M
edge
˜˜M Q
.
˜˜Q R
common
˜˜R X
.
˜˜X Y
a
˜˜Y Z
)
˜˜Z [
)
˜˜[ \
||
˜˜] _
section
˜˜` g
.
˜˜g h
Any
˜˜h k
(
˜˜k l
w
˜˜l m
=>
˜˜n p
common
˜˜q w
.
˜˜w x
Contains˜˜x Ä
(˜˜Ä Å
w˜˜Å Ç
.˜˜Ç É
edge˜˜É á
.˜˜á à
common˜˜à é
.˜˜é è
b˜˜è ê
)˜˜ê ë
)˜˜ë í
)˜˜í ì
holes
¯¯ 
.
¯¯ 
Add
¯¯ !
(
¯¯! "
section
¯¯" )
)
¯¯) *
;
¯¯* +
}
˘˘ 
}
˙˙ 
return
¸¸ 
holes
¸¸ 
;
¸¸ 
}
˝˝ 	
static
ˇˇ 

WingedEdge
ˇˇ  
FindNextEdgeInHole
ˇˇ ,
(
ˇˇ, -

WingedEdge
ˇˇ- 7
wing
ˇˇ8 <
,
ˇˇ< =
int
ˇˇ> A
common
ˇˇB H
)
ˇˇH I
{
ÄÄ 	

WingedEdge
ÅÅ 
next
ÅÅ 
=
ÅÅ 
wing
ÅÅ "
.
ÅÅ" #,
GetAdjacentEdgeWithCommonIndex
ÅÅ# A
(
ÅÅA B
common
ÅÅB H
)
ÅÅH I
;
ÅÅI J
int
ÇÇ 
counter
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
;
ÇÇ 
while
ÉÉ 
(
ÉÉ 
next
ÉÉ 
!=
ÉÉ 
null
ÉÉ 
&&
ÉÉ  "
next
ÉÉ# '
!=
ÉÉ( *
wing
ÉÉ+ /
&&
ÉÉ0 2
counter
ÉÉ3 :
++
ÉÉ: <
<
ÉÉ= >!
k_MaxHoleIterations
ÉÉ? R
)
ÉÉR S
{
ÑÑ 
if
ÖÖ 
(
ÖÖ 
next
ÖÖ 
.
ÖÖ 
opposite
ÖÖ !
==
ÖÖ" $
null
ÖÖ% )
)
ÖÖ) *
return
ÜÜ 
next
ÜÜ 
;
ÜÜ  
next
àà 
=
àà 
next
àà 
.
àà 
opposite
àà $
.
àà$ %,
GetAdjacentEdgeWithCommonIndex
àà% C
(
ààC D
common
ààD J
)
ààJ K
;
ààK L
}
ââ 
return
ãã 
null
ãã 
;
ãã 
}
åå 	
}
çç 
}éé Ä
ïD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\WingedEdgeEnumerator.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

sealed 
class  
WingedEdgeEnumerator ,
:- .
IEnumerator/ :
<: ;

WingedEdge; E
>E F
{ 

WingedEdge 
m_Start 
= 
null !
;! "

WingedEdge 
	m_Current 
= 
null #
;# $
public  
WingedEdgeEnumerator #
(# $

WingedEdge$ .
start/ 4
)4 5
{ 	
m_Start 
= 
start 
; 
	m_Current 
= 
null 
; 
} 	
public 
bool 
MoveNext 
( 
) 
{ 	
if   
(   
ReferenceEquals   
(    
	m_Current    )
,  ) *
null  + /
)  / 0
)  0 1
{!! 
	m_Current"" 
="" 
m_Start"" #
;""# $
return## 
!## 
ReferenceEquals## '
(##' (
	m_Current##( 1
,##1 2
null##3 7
)##7 8
;##8 9
}$$ 
	m_Current&& 
=&& 
	m_Current&& !
.&&! "
next&&" &
;&&& '
return(( 
!(( 
ReferenceEquals(( #
(((# $
	m_Current(($ -
,((- .
null((/ 3
)((3 4
&&((5 7
!((8 9
ReferenceEquals((9 H
(((H I
	m_Current((I R
,((R S
m_Start((T [
)(([ \
;((\ ]
})) 	
public,, 
void,, 
Reset,, 
(,, 
),, 
{-- 	
	m_Current.. 
=.. 
null.. 
;.. 
}// 	
public22 

WingedEdge22 
Current22 !
{33 	
get44 
{55 
try66 
{77 
return88 
	m_Current88 $
;88$ %
}99 
catch:: 
(:: $
IndexOutOfRangeException:: /
)::/ 0
{;; 
throw<< 
new<< %
InvalidOperationException<< 7
(<<7 8
)<<8 9
;<<9 :
}== 
}>> 
}?? 	
objectBB 
IEnumeratorBB 
.BB 
CurrentBB "
{CC 	
getDD 
{DD 
returnDD 
CurrentDD  
;DD  !
}DD" #
}EE 	
publicHH 
voidHH 
DisposeHH 
(HH 
)HH 
{HH 
}HH  
}II 
}JJ ˙9
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\MeshTransform.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
public 

static 
class 
MeshTransform %
{ 
internal 
static 
void 
SetPivot %
(% &
this& *
ProBuilderMesh+ 9
mesh: >
,> ?
PivotLocation@ M
	pivotTypeN W
,W X
intY \
firstVertexIndex] m
=n o
$nump q
)q r
{		 	
switch

 
(

 
	pivotType

 
)

 
{ 
case 
PivotLocation "
." #
Center# )
:) *
mesh 
. 
CenterPivot $
($ %
null% )
)) *
;* +
break 
; 
case 
PivotLocation "
." #
FirstVertex# .
:. /
mesh 
. 
CenterPivot $
($ %
new% (
int) ,
[, -
$num- .
]. /
{0 1
firstVertexIndex2 B
}C D
)D E
;E F
break 
; 
} 
} 	
public 
static 
void 
CenterPivot &
(& '
this' +
ProBuilderMesh, :
mesh; ?
,? @
intA D
[D E
]E F
indexesG N
)N O
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new 
System  
.  !!
ArgumentNullException! 6
(6 7
$str7 =
)= >
;> ?
Vector3   
center   
=   
Vector3   $
.  $ %
zero  % )
;  ) *
if"" 
("" 
indexes"" 
!="" 
null"" 
&&""  "
indexes""# *
.""* +
Length""+ 1
>""2 3
$num""4 5
)""5 6
{## 
Vector3$$ 
[$$ 
]$$ 
	positions$$ #
=$$$ %
mesh$$& *
.$$* +
positionsInternal$$+ <
;$$< =
if&& 
(&& 
	positions&& 
==&&  
null&&! %
||&&& (
	positions&&) 2
.&&2 3
Length&&3 9
<&&: ;
$num&&< =
)&&= >
return'' 
;'' 
foreach)) 
()) 
int)) 
i)) 
in)) !
indexes))" )
)))) *
center** 
+=** 
	positions** '
[**' (
i**( )
]**) *
;*** +
center,, 
=,, 
mesh,, 
.,, 
	transform,, '
.,,' (
TransformPoint,,( 6
(,,6 7
center,,7 =
/,,> ?
(,,@ A
float,,A F
),,F G
indexes,,G N
.,,N O
Length,,O U
),,U V
;,,V W
}-- 
else.. 
{// 
center00 
=00 
mesh00 
.00 
	transform00 '
.00' (
TransformPoint00( 6
(006 7
mesh007 ;
.00; <
mesh00< @
.00@ A
bounds00A G
.00G H
center00H N
)00N O
;00O P
}11 
Vector333 
dir33 
=33 
(33 
mesh33 
.33  
	transform33  )
.33) *
position33* 2
-333 4
center335 ;
)33; <
;33< =
mesh55 
.55 
	transform55 
.55 
position55 #
=55$ %
center55& ,
;55, -
mesh77 
.77 
ToMesh77 
(77 
)77 
;77 
mesh88 
.88 )
TranslateVerticesInWorldSpace88 .
(88. /
mesh88/ 3
.883 4
mesh884 8
.888 9
	triangles889 B
,88B C
dir88D G
)88G H
;88H I
mesh99 
.99 
Refresh99 
(99 
)99 
;99 
}:: 	
publicAA 
staticAA 
voidAA 
SetPivotAA #
(AA# $
thisAA$ (
ProBuilderMeshAA) 7
meshAA8 <
,AA< =
Vector3AA> E
worldPositionAAF S
)AAS T
{BB 	
ifCC 
(CC 
meshCC 
==CC 
nullCC 
)CC 
throwDD 
newDD 
SystemDD  
.DD  !!
ArgumentNullExceptionDD! 6
(DD6 7
$strDD7 =
)DD= >
;DD> ?
Vector3FF 
offsetFF 
=FF 
meshFF !
.FF! "
	transformFF" +
.FF+ ,
positionFF, 4
-FF5 6
worldPositionFF7 D
;FFD E
meshGG 
.GG 
	transformGG 
.GG 
positionGG #
=GG$ %
worldPositionGG& 3
;GG3 4
meshHH 
.HH 
ToMeshHH 
(HH 
)HH 
;HH 
meshII 
.II )
TranslateVerticesInWorldSpaceII .
(II. /
meshII/ 3
.II3 4
meshII4 8
.II8 9
	trianglesII9 B
,IIB C
offsetIID J
)IIJ K
;IIK L
meshJJ 
.JJ 
RefreshJJ 
(JJ 
)JJ 
;JJ 
}KK 	
publicQQ 
staticQQ 
voidQQ  
FreezeScaleTransformQQ /
(QQ/ 0
thisQQ0 4
ProBuilderMeshQQ5 C
meshQQD H
)QQH I
{RR 	
ifSS 
(SS 
meshSS 
==SS 
nullSS 
)SS 
throwTT 
newTT 
SystemTT  
.TT  !!
ArgumentNullExceptionTT! 6
(TT6 7
$strTT7 =
)TT= >
;TT> ?
Vector3VV 
[VV 
]VV 
vVV 
=VV 
meshVV 
.VV 
positionsInternalVV 0
;VV0 1
forXX 
(XX 
varXX 
iXX 
=XX 
$numXX 
;XX 
iXX 
<XX 
vXX  !
.XX! "
LengthXX" (
;XX( )
iXX* +
++XX+ -
)XX- .
vYY 
[YY 
iYY 
]YY 
=YY 
Vector3YY 
.YY 
ScaleYY $
(YY$ %
vYY% &
[YY& '
iYY' (
]YY( )
,YY) *
meshYY+ /
.YY/ 0
	transformYY0 9
.YY9 :

localScaleYY: D
)YYD E
;YYE F
mesh[[ 
.[[ 
	transform[[ 
.[[ 

localScale[[ %
=[[& '
new[[( +
Vector3[[, 3
([[3 4
$num[[4 6
,[[6 7
$num[[8 :
,[[: ;
$num[[< >
)[[> ?
;[[? @
}\\ 	
}]] 
}^^ ºÈ
çD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ColorUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed		 

class		 
HSVColor		 
{

 
public 
float 
h 
, 
s 
, 
v 
; 
public 
HSVColor 
( 
float 
h 
,  
float! &
s' (
,( )
float* /
v0 1
)1 2
{ 	
this 
. 
h 
= 
h 
; 
this 
. 
s 
= 
s 
; 
this 
. 
v 
= 
v 
; 
} 	
public 
HSVColor 
( 
float 
h 
,  
float! &
s' (
,( )
float* /
v0 1
,1 2
float3 8
sv_modifier9 D
)D E
{ 	
this 
. 
h 
= 
h 
; 
this 
. 
s 
= 
s 
* 
sv_modifier $
;$ %
this 
. 
v 
= 
v 
* 
sv_modifier $
;$ %
} 	
public 
static 
HSVColor 
FromRGB &
(& '
Color' ,
col- 0
)0 1
{   	
return!! 
ColorUtility!! 
.!!  
RGBtoHSV!!  (
(!!( )
col!!) ,
)!!, -
;!!- .
}"" 	
public$$ 
override$$ 
string$$ 
ToString$$ '
($$' (
)$$( )
{%% 	
return&& 
string&& 
.&& 
Format&&  
(&&  !
$str&&! 4
,&&4 5
h&&6 7
,&&7 8
s&&9 :
,&&: ;
v&&< =
)&&= >
;&&> ?
}'' 	
public)) 
float)) 
SqrDistance))  
())  !
HSVColor))! )
InColor))* 1
)))1 2
{** 	
return++ 
(++ 
InColor++ 
.++ 
h++ 
/++ 
$num++  $
-++% &
this++' +
.+++ ,
h++, -
/++. /
$num++0 4
)++4 5
+++6 7
(++8 9
InColor++9 @
.++@ A
s++A B
-++C D
this++E I
.++I J
s++J K
)++K L
+++M N
(++O P
InColor++P W
.++W X
v++X Y
-++Z [
this++\ `
.++` a
v++a b
)++b c
;++c d
},, 	
}-- 
sealed33 

class33 
XYZColor33 
{44 
public55 
float55 
x55 
,55 
y55 
,55 
z55 
;55 
public77 
XYZColor77 
(77 
float77 
x77 
,77  
float77! &
y77' (
,77( )
float77* /
z770 1
)771 2
{88 	
this99 
.99 
x99 
=99 
x99 
;99 
this:: 
.:: 
y:: 
=:: 
y:: 
;:: 
this;; 
.;; 
z;; 
=;; 
z;; 
;;; 
}<< 	
public>> 
static>> 
XYZColor>> 
FromRGB>> &
(>>& '
Color>>' ,
col>>- 0
)>>0 1
{?? 	
return@@ 
ColorUtility@@ 
.@@  
RGBToXYZ@@  (
(@@( )
col@@) ,
)@@, -
;@@- .
}AA 	
publicCC 
staticCC 
XYZColorCC 
FromRGBCC &
(CC& '
floatCC' ,
RCC- .
,CC. /
floatCC0 5
GCC6 7
,CC7 8
floatCC9 >
BCC? @
)CC@ A
{DD 	
returnEE 
ColorUtilityEE 
.EE  
RGBToXYZEE  (
(EE( )
REE) *
,EE* +
GEE, -
,EE- .
BEE/ 0
)EE0 1
;EE1 2
}FF 	
publicHH 
overrideHH 
stringHH 
ToStringHH '
(HH' (
)HH( )
{II 	
returnJJ 
stringJJ 
.JJ 
FormatJJ  
(JJ  !
$strJJ! 4
,JJ4 5
xJJ6 7
,JJ7 8
yJJ9 :
,JJ: ;
zJJ< =
)JJ= >
;JJ> ?
}KK 	
}LL 
sealedQQ 

classQQ 
CIELabColorQQ 
{RR 
publicSS 
floatSS 
LSS 
,SS 
aSS 
,SS 
bSS 
;SS 
publicUU 
CIELabColorUU 
(UU 
floatUU  
LUU! "
,UU" #
floatUU$ )
aUU* +
,UU+ ,
floatUU- 2
bUU3 4
)UU4 5
{VV 	
thisWW 
.WW 
LWW 
=WW 
LWW 
;WW 
thisXX 
.XX 
aXX 
=XX 
aXX 
;XX 
thisYY 
.YY 
bYY 
=YY 
bYY 
;YY 
}ZZ 	
public\\ 
static\\ 
CIELabColor\\ !
FromXYZ\\" )
(\\) *
XYZColor\\* 2
xyz\\3 6
)\\6 7
{]] 	
return^^ 
ColorUtility^^ 
.^^  
XYZToCIE_Lab^^  ,
(^^, -
xyz^^- 0
)^^0 1
;^^1 2
}__ 	
publicaa 
staticaa 
CIELabColoraa !
FromRGBaa" )
(aa) *
Coloraa* /
colaa0 3
)aa3 4
{bb 	
XYZColorcc 
xyzcc 
=cc 
XYZColorcc #
.cc# $
FromRGBcc$ +
(cc+ ,
colcc, /
)cc/ 0
;cc0 1
returnee 
ColorUtilityee 
.ee  
XYZToCIE_Labee  ,
(ee, -
xyzee- 0
)ee0 1
;ee1 2
}ff 	
publichh 
overridehh 
stringhh 
ToStringhh '
(hh' (
)hh( )
{ii 	
returnjj 
stringjj 
.jj 
Formatjj  
(jj  !
$strjj! 4
,jj4 5
Ljj6 7
,jj7 8
ajj9 :
,jj: ;
bjj< =
)jj= >
;jj> ?
}kk 	
}ll 
staticqq 

classqq 
ColorUtilityqq 
{rr 
staticyy 
boolyy 
approxyy 
(yy 
floatyy  
lhsyy! $
,yy$ %
floatyy& +
rhsyy, /
)yy/ 0
{zz 	
return{{ 
Mathf{{ 
.{{ 
Abs{{ 
({{ 
lhs{{  
-{{! "
rhs{{# &
){{& '
<{{( )
Mathf{{* /
.{{/ 0
Epsilon{{0 7
;{{7 8
}|| 	
public~~ 
static~~ 
Color~~ 
GetColor~~ $
(~~$ %
Vector3~~% ,
vec~~- 0
)~~0 1
{ 	
vec
ÄÄ 
.
ÄÄ 
	Normalize
ÄÄ 
(
ÄÄ 
)
ÄÄ 
;
ÄÄ 
return
ÅÅ 
new
ÅÅ 
Color
ÅÅ 
(
ÅÅ 
Mathf
ÅÅ "
.
ÅÅ" #
Abs
ÅÅ# &
(
ÅÅ& '
vec
ÅÅ' *
.
ÅÅ* +
x
ÅÅ+ ,
)
ÅÅ, -
,
ÅÅ- .
Mathf
ÅÅ/ 4
.
ÅÅ4 5
Abs
ÅÅ5 8
(
ÅÅ8 9
vec
ÅÅ9 <
.
ÅÅ< =
y
ÅÅ= >
)
ÅÅ> ?
,
ÅÅ? @
Mathf
ÅÅA F
.
ÅÅF G
Abs
ÅÅG J
(
ÅÅJ K
vec
ÅÅK N
.
ÅÅN O
z
ÅÅO P
)
ÅÅP Q
,
ÅÅQ R
$num
ÅÅS U
)
ÅÅU V
;
ÅÅV W
}
ÇÇ 	
public
ââ 
static
ââ 
XYZColor
ââ 
RGBToXYZ
ââ '
(
ââ' (
Color
ââ( -
col
ââ. 1
)
ââ1 2
{
ää 	
return
ãã 
RGBToXYZ
ãã 
(
ãã 
col
ãã 
.
ãã  
r
ãã  !
,
ãã! "
col
ãã# &
.
ãã& '
g
ãã' (
,
ãã( )
col
ãã* -
.
ãã- .
b
ãã. /
)
ãã/ 0
;
ãã0 1
}
åå 	
public
éé 
static
éé 
XYZColor
éé 
RGBToXYZ
éé '
(
éé' (
float
éé( -
r
éé. /
,
éé/ 0
float
éé1 6
g
éé7 8
,
éé8 9
float
éé: ?
b
éé@ A
)
ééA B
{
èè 	
if
êê 
(
êê 
r
êê 
>
êê 
$num
êê 
)
êê 
r
ëë 
=
ëë 
Mathf
ëë 
.
ëë 
Pow
ëë 
(
ëë 
(
ëë 
(
ëë  
r
ëë  !
+
ëë" #
$num
ëë$ *
)
ëë* +
/
ëë, -
$num
ëë. 4
)
ëë4 5
,
ëë5 6
$num
ëë7 ;
)
ëë; <
;
ëë< =
else
íí 
r
ìì 
=
ìì 
r
ìì 
/
ìì 
$num
ìì 
;
ìì 
if
ïï 
(
ïï 
g
ïï 
>
ïï 
$num
ïï 
)
ïï 
g
ññ 
=
ññ 
Mathf
ññ 
.
ññ 
Pow
ññ 
(
ññ 
(
ññ 
(
ññ  
g
ññ  !
+
ññ" #
$num
ññ$ *
)
ññ* +
/
ññ, -
$num
ññ. 4
)
ññ4 5
,
ññ5 6
$num
ññ7 ;
)
ññ; <
;
ññ< =
else
óó 
g
òò 
=
òò 
g
òò 
/
òò 
$num
òò 
;
òò 
if
öö 
(
öö 
b
öö 
>
öö 
$num
öö 
)
öö 
b
õõ 
=
õõ 
Mathf
õõ 
.
õõ 
Pow
õõ 
(
õõ 
(
õõ 
(
õõ  
b
õõ  !
+
õõ" #
$num
õõ$ *
)
õõ* +
/
õõ, -
$num
õõ. 4
)
õõ4 5
,
õõ5 6
$num
õõ7 ;
)
õõ; <
;
õõ< =
else
úú 
b
ùù 
=
ùù 
b
ùù 
/
ùù 
$num
ùù 
;
ùù 
r
üü 
=
üü 
r
üü 
*
üü 
$num
üü 
;
üü 
g
†† 
=
†† 
g
†† 
*
†† 
$num
†† 
;
†† 
b
°° 
=
°° 
b
°° 
*
°° 
$num
°° 
;
°° 
float
§§ 
x
§§ 
=
§§ 
r
§§ 
*
§§ 
$num
§§ !
+
§§" #
g
§§$ %
*
§§& '
$num
§§( /
+
§§0 1
b
§§2 3
*
§§4 5
$num
§§6 =
;
§§= >
float
•• 
y
•• 
=
•• 
r
•• 
*
•• 
$num
•• !
+
••" #
g
••$ %
*
••& '
$num
••( /
+
••0 1
b
••2 3
*
••4 5
$num
••6 =
;
••= >
float
¶¶ 
z
¶¶ 
=
¶¶ 
r
¶¶ 
*
¶¶ 
$num
¶¶ !
+
¶¶" #
g
¶¶$ %
*
¶¶& '
$num
¶¶( /
+
¶¶0 1
b
¶¶2 3
*
¶¶4 5
$num
¶¶6 =
;
¶¶= >
return
®® 
new
®® 
XYZColor
®® 
(
®®  
x
®®  !
,
®®! "
y
®®# $
,
®®$ %
z
®®& '
)
®®' (
;
®®( )
}
©© 	
public
∞∞ 
static
∞∞ 
CIELabColor
∞∞ !
XYZToCIE_Lab
∞∞" .
(
∞∞. /
XYZColor
∞∞/ 7
xyz
∞∞8 ;
)
∞∞; <
{
±± 	
float
≤≤ 
var_X
≤≤ 
=
≤≤ 
xyz
≤≤ 
.
≤≤ 
x
≤≤ 
/
≤≤  !
$num
≤≤" )
;
≤≤) *
float
≥≥ 
var_Y
≥≥ 
=
≥≥ 
xyz
≥≥ 
.
≥≥ 
y
≥≥ 
/
≥≥  !
$num
≥≥" *
;
≥≥* +
float
¥¥ 
var_Z
¥¥ 
=
¥¥ 
xyz
¥¥ 
.
¥¥ 
z
¥¥ 
/
¥¥  !
$num
¥¥" *
;
¥¥* +
if
∂∂ 
(
∂∂ 
var_X
∂∂ 
>
∂∂ 
$num
∂∂ !
)
∂∂! "
var_X
∑∑ 
=
∑∑ 
Mathf
∑∑ 
.
∑∑ 
Pow
∑∑ !
(
∑∑! "
var_X
∑∑" '
,
∑∑' (
(
∑∑) *
$num
∑∑* +
/
∑∑, -
$num
∑∑. 0
)
∑∑0 1
)
∑∑1 2
;
∑∑2 3
else
∏∏ 
var_X
ππ 
=
ππ 
(
ππ 
$num
ππ 
*
ππ  !
var_X
ππ" '
)
ππ' (
+
ππ) *
(
ππ+ ,
$num
ππ, /
/
ππ0 1
$num
ππ2 6
)
ππ6 7
;
ππ7 8
if
ªª 
(
ªª 
var_Y
ªª 
>
ªª 
$num
ªª !
)
ªª! "
var_Y
ºº 
=
ºº 
Mathf
ºº 
.
ºº 
Pow
ºº !
(
ºº! "
var_Y
ºº" '
,
ºº' (
(
ºº) *
$num
ºº* +
/
ºº, -
$num
ºº. 0
)
ºº0 1
)
ºº1 2
;
ºº2 3
else
ΩΩ 
var_Y
ææ 
=
ææ 
(
ææ 
$num
ææ 
*
ææ  !
var_Y
ææ" '
)
ææ' (
+
ææ) *
(
ææ+ ,
$num
ææ, /
/
ææ0 1
$num
ææ2 6
)
ææ6 7
;
ææ7 8
if
¿¿ 
(
¿¿ 
var_Z
¿¿ 
>
¿¿ 
$num
¿¿ !
)
¿¿! "
var_Z
¡¡ 
=
¡¡ 
Mathf
¡¡ 
.
¡¡ 
Pow
¡¡ !
(
¡¡! "
var_Z
¡¡" '
,
¡¡' (
(
¡¡) *
$num
¡¡* +
/
¡¡, -
$num
¡¡. 0
)
¡¡0 1
)
¡¡1 2
;
¡¡2 3
else
¬¬ 
var_Z
√√ 
=
√√ 
(
√√ 
$num
√√ 
*
√√  !
var_Z
√√" '
)
√√' (
+
√√) *
(
√√+ ,
$num
√√, /
/
√√0 1
$num
√√2 6
)
√√6 7
;
√√7 8
float
≈≈ 
L
≈≈ 
=
≈≈ 
(
≈≈ 
$num
≈≈ 
*
≈≈ 
var_Y
≈≈ #
)
≈≈# $
-
≈≈% &
$num
≈≈' *
;
≈≈* +
float
∆∆ 
a
∆∆ 
=
∆∆ 
$num
∆∆ 
*
∆∆ 
(
∆∆ 
var_X
∆∆ #
-
∆∆$ %
var_Y
∆∆& +
)
∆∆+ ,
;
∆∆, -
float
«« 
b
«« 
=
«« 
$num
«« 
*
«« 
(
«« 
var_Y
«« #
-
««$ %
var_Z
««& +
)
««+ ,
;
««, -
return
…… 
new
…… 
CIELabColor
…… "
(
……" #
L
……# $
,
……$ %
a
……& '
,
……' (
b
……) *
)
……* +
;
……+ ,
}
   	
public
”” 
static
”” 
float
”” 
DeltaE
”” "
(
””" #
CIELabColor
””# .
lhs
””/ 2
,
””2 3
CIELabColor
””4 ?
rhs
””@ C
)
””C D
{
‘‘ 	
return
’’ 
Mathf
’’ 
.
’’ 
Sqrt
’’ 
(
’’ 
Mathf
÷÷ 
.
÷÷ 
Pow
÷÷ 
(
÷÷ 
(
÷÷ 
lhs
÷÷ 
.
÷÷ 
L
÷÷  
-
÷÷! "
rhs
÷÷# &
.
÷÷& '
L
÷÷' (
)
÷÷( )
,
÷÷) *
$num
÷÷+ ,
)
÷÷, -
+
÷÷. /
Mathf
◊◊ 
.
◊◊ 
Pow
◊◊ 
(
◊◊ 
(
◊◊ 
lhs
◊◊ 
.
◊◊ 
a
◊◊  
-
◊◊! "
rhs
◊◊# &
.
◊◊& '
a
◊◊' (
)
◊◊( )
,
◊◊) *
$num
◊◊+ ,
)
◊◊, -
+
◊◊. /
Mathf
ÿÿ 
.
ÿÿ 
Pow
ÿÿ 
(
ÿÿ 
(
ÿÿ 
lhs
ÿÿ 
.
ÿÿ 
b
ÿÿ  
-
ÿÿ! "
rhs
ÿÿ# &
.
ÿÿ& '
b
ÿÿ' (
)
ÿÿ( )
,
ÿÿ) *
$num
ÿÿ+ ,
)
ÿÿ, -
)
ÿÿ- .
;
ÿÿ. /
}
ŸŸ 	
public
‰‰ 
static
‰‰ 
Color
‰‰ 
HSVtoRGB
‰‰ $
(
‰‰$ %
HSVColor
‰‰% -
hsv
‰‰. 1
)
‰‰1 2
{
ÂÂ 	
return
ÊÊ 
HSVtoRGB
ÊÊ 
(
ÊÊ 
hsv
ÊÊ 
.
ÊÊ  
h
ÊÊ  !
,
ÊÊ! "
hsv
ÊÊ# &
.
ÊÊ& '
s
ÊÊ' (
,
ÊÊ( )
hsv
ÊÊ* -
.
ÊÊ- .
v
ÊÊ. /
)
ÊÊ/ 0
;
ÊÊ0 1
}
ÁÁ 	
public
 
static
 
Color
 
HSVtoRGB
 $
(
$ %
float
% *
h
+ ,
,
, -
float
. 3
s
4 5
,
5 6
float
7 <
v
= >
)
> ?
{
ÒÒ 	
float
ÚÚ 
r
ÚÚ 
,
ÚÚ 
g
ÚÚ 
,
ÚÚ 
b
ÚÚ 
;
ÚÚ 
int
ÛÛ 
i
ÛÛ 
;
ÛÛ 
float
ÙÙ 
f
ÙÙ 
,
ÙÙ 
p
ÙÙ 
,
ÙÙ 
q
ÙÙ 
,
ÙÙ 
t
ÙÙ 
;
ÙÙ 
if
ıı 
(
ıı 
s
ıı 
==
ıı 
$num
ıı 
)
ıı 
{
ˆˆ 
return
¯¯ 
new
¯¯ 
Color
¯¯  
(
¯¯  !
v
¯¯! "
,
¯¯" #
v
¯¯$ %
,
¯¯% &
v
¯¯' (
,
¯¯( )
$num
¯¯* ,
)
¯¯, -
;
¯¯- .
}
˘˘ 
h
˙˙ 
/=
˙˙ 
$num
˙˙ 
;
˙˙ 
i
˚˚ 
=
˚˚ 
(
˚˚ 
int
˚˚ 
)
˚˚ 
Mathf
˚˚ 
.
˚˚ 
Floor
˚˚  
(
˚˚  !
h
˚˚! "
)
˚˚" #
;
˚˚# $
f
¸¸ 
=
¸¸ 
h
¸¸ 
-
¸¸ 
i
¸¸ 
;
¸¸ 
p
˝˝ 
=
˝˝ 
v
˝˝ 
*
˝˝ 
(
˝˝ 
$num
˝˝ 
-
˝˝ 
s
˝˝ 
)
˝˝ 
;
˝˝ 
q
˛˛ 
=
˛˛ 
v
˛˛ 
*
˛˛ 
(
˛˛ 
$num
˛˛ 
-
˛˛ 
s
˛˛ 
*
˛˛ 
f
˛˛ 
)
˛˛ 
;
˛˛  
t
ˇˇ 
=
ˇˇ 
v
ˇˇ 
*
ˇˇ 
(
ˇˇ 
$num
ˇˇ 
-
ˇˇ 
s
ˇˇ 
*
ˇˇ 
(
ˇˇ 
$num
ˇˇ 
-
ˇˇ  !
f
ˇˇ" #
)
ˇˇ# $
)
ˇˇ$ %
;
ˇˇ% &
switch
ÅÅ 
(
ÅÅ 
i
ÅÅ 
)
ÅÅ 
{
ÇÇ 
case
ÉÉ 
$num
ÉÉ 
:
ÉÉ 
r
ÑÑ 
=
ÑÑ 
v
ÑÑ 
;
ÑÑ 
g
ÖÖ 
=
ÖÖ 
t
ÖÖ 
;
ÖÖ 
b
ÜÜ 
=
ÜÜ 
p
ÜÜ 
;
ÜÜ 
break
áá 
;
áá 
case
àà 
$num
àà 
:
àà 
r
ââ 
=
ââ 
q
ââ 
;
ââ 
g
ää 
=
ää 
v
ää 
;
ää 
b
ãã 
=
ãã 
p
ãã 
;
ãã 
break
åå 
;
åå 
case
çç 
$num
çç 
:
çç 
r
éé 
=
éé 
p
éé 
;
éé 
g
èè 
=
èè 
v
èè 
;
èè 
b
êê 
=
êê 
t
êê 
;
êê 
break
ëë 
;
ëë 
case
íí 
$num
íí 
:
íí 
r
ìì 
=
ìì 
p
ìì 
;
ìì 
g
îî 
=
îî 
q
îî 
;
îî 
b
ïï 
=
ïï 
v
ïï 
;
ïï 
break
ññ 
;
ññ 
case
óó 
$num
óó 
:
óó 
r
òò 
=
òò 
t
òò 
;
òò 
g
ôô 
=
ôô 
p
ôô 
;
ôô 
b
öö 
=
öö 
v
öö 
;
öö 
break
õõ 
;
õõ 
default
úú 
:
úú 
r
ùù 
=
ùù 
v
ùù 
;
ùù 
g
ûû 
=
ûû 
p
ûû 
;
ûû 
b
üü 
=
üü 
q
üü 
;
üü 
break
†† 
;
†† 
}
°° 
return
££ 
new
££ 
Color
££ 
(
££ 
r
££ 
,
££ 
g
££  !
,
££! "
b
££# $
,
££$ %
$num
££& (
)
££( )
;
££) *
}
§§ 	
public
ÆÆ 
static
ÆÆ 
HSVColor
ÆÆ 
RGBtoHSV
ÆÆ '
(
ÆÆ' (
Color
ÆÆ( -
color
ÆÆ. 3
)
ÆÆ3 4
{
ØØ 	
float
∞∞ 
h
∞∞ 
,
∞∞ 
s
∞∞ 
,
∞∞ 
v
∞∞ 
;
∞∞ 
float
±± 
r
±± 
=
±± 
color
±± 
.
±± 
r
±± 
,
±± 
b
±±  
=
±±! "
color
±±# (
.
±±( )
b
±±) *
,
±±* +
g
±±, -
=
±±. /
color
±±0 5
.
±±5 6
g
±±6 7
;
±±7 8
float
≥≥ 
min
≥≥ 
,
≥≥ 
max
≥≥ 
,
≥≥ 
delta
≥≥ !
;
≥≥! "
min
¥¥ 
=
¥¥ 
Mathf
¥¥ 
.
¥¥ 
Min
¥¥ 
(
¥¥ 
Mathf
¥¥ !
.
¥¥! "
Min
¥¥" %
(
¥¥% &
r
¥¥& '
,
¥¥' (
g
¥¥) *
)
¥¥* +
,
¥¥+ ,
b
¥¥- .
)
¥¥. /
;
¥¥/ 0
max
µµ 
=
µµ 
Mathf
µµ 
.
µµ 
Max
µµ 
(
µµ 
Mathf
µµ !
.
µµ! "
Max
µµ" %
(
µµ% &
r
µµ& '
,
µµ' (
g
µµ) *
)
µµ* +
,
µµ+ ,
b
µµ- .
)
µµ. /
;
µµ/ 0
v
∑∑ 
=
∑∑ 
max
∑∑ 
;
∑∑ 
delta
ππ 
=
ππ 
max
ππ 
-
ππ 
min
ππ 
;
ππ 
if
ªª 
(
ªª 
max
ªª 
!=
ªª 
$num
ªª 
)
ªª 
{
ºº 
s
ΩΩ 
=
ΩΩ 
delta
ΩΩ 
/
ΩΩ 
max
ΩΩ 
;
ΩΩ  
}
ææ 
else
øø 
{
¿¿ 
s
¬¬ 
=
¬¬ 
$num
¬¬ 
;
¬¬ 
h
√√ 
=
√√ 
$num
√√ 
;
√√ 
return
ƒƒ 
new
ƒƒ 
HSVColor
ƒƒ #
(
ƒƒ# $
h
ƒƒ$ %
,
ƒƒ% &
s
ƒƒ' (
,
ƒƒ( )
v
ƒƒ* +
)
ƒƒ+ ,
;
ƒƒ, -
}
≈≈ 
if
«« 
(
«« 
approx
«« 
(
«« 
r
«« 
,
«« 
max
«« 
)
«« 
)
«« 
{
»» 
h
…… 
=
…… 
(
…… 
g
…… 
-
…… 
b
…… 
)
…… 
/
…… 
delta
…… #
;
……# $
if
   
(
   
float
   
.
   
IsNaN
   
(
    
h
    !
)
  ! "
)
  " #
h
ÀÀ 
=
ÀÀ 
$num
ÀÀ 
;
ÀÀ 
}
ÃÃ 
else
ÕÕ 
if
ÕÕ 
(
ÕÕ 
approx
ÕÕ 
(
ÕÕ 
g
ÕÕ 
,
ÕÕ 
max
ÕÕ "
)
ÕÕ" #
)
ÕÕ# $
{
ŒŒ 
h
œœ 
=
œœ 
$num
œœ 
+
œœ 
(
œœ 
b
œœ 
-
œœ 
r
œœ 
)
œœ  
/
œœ! "
delta
œœ# (
;
œœ( )
}
–– 
else
—— 
{
““ 
h
”” 
=
”” 
$num
”” 
+
”” 
(
”” 
r
”” 
-
”” 
g
”” 
)
””  
/
””! "
delta
””# (
;
””( )
}
‘‘ 
h
÷÷ 
*=
÷÷ 
$num
÷÷ 
;
÷÷ 
if
ÿÿ 
(
ÿÿ 
h
ÿÿ 
<
ÿÿ 
$num
ÿÿ 
)
ÿÿ 
h
ŸŸ 
+=
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
return
€€ 
new
€€ 
HSVColor
€€ 
(
€€  
h
€€  !
,
€€! "
s
€€# $
,
€€$ %
v
€€& '
)
€€' (
;
€€( )
}
‹‹ 	
public
„„ 
static
„„ 
string
„„ 
GetColorName
„„ )
(
„„) *
Color
„„* /
InColor
„„0 7
)
„„7 8
{
‰‰ 	
CIELabColor
ÂÂ 
lab
ÂÂ 
=
ÂÂ 
CIELabColor
ÂÂ )
.
ÂÂ) *
FromRGB
ÂÂ* 1
(
ÂÂ1 2
InColor
ÂÂ2 9
)
ÂÂ9 :
;
ÂÂ: ;
string
ÁÁ 
name
ÁÁ 
=
ÁÁ 
$str
ÁÁ #
;
ÁÁ# $
float
ËË 
diff
ËË 
=
ËË 
Mathf
ËË 
.
ËË 
Infinity
ËË '
;
ËË' (
foreach
ÍÍ 
(
ÍÍ 
KeyValuePair
ÍÍ !
<
ÍÍ! "
string
ÍÍ" (
,
ÍÍ( )
CIELabColor
ÍÍ* 5
>
ÍÍ5 6
kvp
ÍÍ7 :
in
ÍÍ; =
ColorNameLookup
ÍÍ> M
)
ÍÍM N
{
ÎÎ 
float
ÏÏ 
dist
ÏÏ 
=
ÏÏ 
Mathf
ÏÏ "
.
ÏÏ" #
Abs
ÏÏ# &
(
ÏÏ& '
DeltaE
ÏÏ' -
(
ÏÏ- .
lab
ÏÏ. 1
,
ÏÏ1 2
kvp
ÏÏ3 6
.
ÏÏ6 7
Value
ÏÏ7 <
)
ÏÏ< =
)
ÏÏ= >
;
ÏÏ> ?
if
ÓÓ 
(
ÓÓ 
dist
ÓÓ 
<
ÓÓ 
diff
ÓÓ 
)
ÓÓ  
{
ÔÔ 
diff
 
=
 
dist
 
;
  
name
ÒÒ 
=
ÒÒ 
kvp
ÒÒ 
.
ÒÒ 
Key
ÒÒ "
;
ÒÒ" #
}
ÚÚ 
}
ÛÛ 
return
ıı 
name
ıı 
;
ıı 
}
ˆˆ 	
static
¯¯ 
CIELabColor
¯¯ 
CIELabFromRGB
¯¯ (
(
¯¯( )
float
¯¯) .
R
¯¯/ 0
,
¯¯0 1
float
¯¯2 7
G
¯¯8 9
,
¯¯9 :
float
¯¯; @
B
¯¯A B
,
¯¯B C
float
¯¯D I
Scale
¯¯J O
)
¯¯O P
{
˘˘ 	
float
˙˙ 
	inv_scale
˙˙ 
=
˙˙ 
$num
˙˙  
/
˙˙! "
Scale
˙˙# (
;
˙˙( )
XYZColor
˚˚ 
xyz
˚˚ 
=
˚˚ 
XYZColor
˚˚ #
.
˚˚# $
FromRGB
˚˚$ +
(
˚˚+ ,
R
˚˚, -
*
˚˚. /
	inv_scale
˚˚0 9
,
˚˚9 :
G
˚˚; <
*
˚˚= >
	inv_scale
˚˚? H
,
˚˚H I
B
˚˚J K
*
˚˚L M
	inv_scale
˚˚N W
)
˚˚W X
;
˚˚X Y
return
˝˝ 
CIELabColor
˝˝ 
.
˝˝ 
FromXYZ
˝˝ &
(
˝˝& '
xyz
˝˝' *
)
˝˝* +
;
˝˝+ ,
}
˛˛ 	
static
ÉÉ 
readonly
ÉÉ 

Dictionary
ÉÉ "
<
ÉÉ" #
string
ÉÉ# )
,
ÉÉ) *
CIELabColor
ÉÉ+ 6
>
ÉÉ6 7
ColorNameLookup
ÉÉ8 G
=
ÉÉH I
new
ÉÉJ M

Dictionary
ÉÉN X
<
ÉÉX Y
string
ÉÉY _
,
ÉÉ_ `
CIELabColor
ÉÉa l
>
ÉÉl m
(
ÉÉm n
)
ÉÉn o
{
ÑÑ 	
{
ÖÖ 
$str
ÖÖ 
,
ÖÖ 
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ M
,
ÖÖM N
$num
ÖÖO R
,
ÖÖR S
$num
ÖÖT W
,
ÖÖW X
$num
ÖÖY ]
)
ÖÖ] ^
}
ÖÖd e
,
ÖÖe f
{
ÜÜ 
$str
ÜÜ 
,
ÜÜ 
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ M
,
ÜÜM N
$num
ÜÜO R
,
ÜÜR S
$num
ÜÜT W
,
ÜÜW X
$num
ÜÜY ]
)
ÜÜ] ^
}
ÜÜd e
,
ÜÜe f
{
áá 
$str
áá 
,
áá 
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ M
,
ááM N
$num
ááO S
,
ááS T
$num
ááU X
,
ááX Y
$num
ááZ ^
)
áá^ _
}
áád e
,
ááe f
{
àà 
$str
àà 
,
àà 
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ M
,
ààM N
$num
ààO R
,
ààR S
$num
ààT W
,
ààW X
$num
ààY ]
)
àà] ^
}
ààd e
,
ààe f
{
ââ 
$str
ââ $
,
ââ$ %
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ M
,
ââM N
$num
ââO R
,
ââR S
$num
ââT W
,
ââW X
$num
ââY ]
)
ââ] ^
}
ââd e
,
ââe f
{
ää 
$str
ää %
,
ää% &
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ L
,
ääL M
$num
ääN Q
,
ääQ R
$num
ääS V
,
ääV W
$num
ääX \
)
ää\ ]
}
ääd e
,
ääe f
{
ãã 
$str
ãã $
,
ãã$ %
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ M
,
ããM N
$num
ããO R
,
ããR S
$num
ããT W
,
ããW X
$num
ããY ]
)
ãã] ^
}
ããd e
,
ããe f
{
åå 
$str
åå 
,
åå  
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ M
,
ååM N
$num
ååO Q
,
ååQ R
$num
ååS V
,
ååV W
$num
ååX \
)
åå\ ]
}
ååd e
,
ååe f
{
çç 
$str
çç 
,
çç 
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ M
,
ççM N
$num
ççO R
,
ççR S
$num
ççT X
,
ççX Y
$num
ççZ ^
)
çç^ _
}
ççd e
,
ççe f
{
éé 
$str
éé  
,
éé  !
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ M
,
ééM N
$num
ééO R
,
ééR S
$num
ééT W
,
ééW X
$num
ééY ]
)
éé] ^
}
ééd e
,
éée f
{
èè 
$str
èè 
,
èè 
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ M
,
èèM N
$num
èèO R
,
èèR S
$num
èèT V
,
èèV W
$num
èèX \
)
èè\ ]
}
èèd e
,
èèe f
{
êê 
$str
êê 
,
êê 
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ M
,
êêM N
$num
êêO R
,
êêR S
$num
êêT W
,
êêW X
$num
êêY ]
)
êê] ^
}
êêd e
,
êêe f
{
ëë 
$str
ëë 
,
ëë 
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ M
,
ëëM N
$num
ëëO R
,
ëëR S
$num
ëëT W
,
ëëW X
$num
ëëY ]
)
ëë] ^
}
ëëd e
,
ëëe f
{
íí 
$str
íí $
,
íí$ %
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ M
,
ííM N
$num
ííO R
,
ííR S
$num
ííT W
,
ííW X
$num
ííY ]
)
íí] ^
}
ííd e
,
ííe f
{
ìì 
$str
ìì 
,
ìì 
CIELabFromRGB
ìì< I
(
ììI J
$num
ììJ M
,
ììM N
$num
ììO R
,
ììR S
$num
ììT W
,
ììW X
$num
ììY ]
)
ìì] ^
}
ììd e
,
ììe f
{
îî 
$str
îî 
,
îî  
CIELabFromRGB
îî< I
(
îîI J
$num
îîJ M
,
îîM N
$num
îîO R
,
îîR S
$num
îîT W
,
îîW X
$num
îîY ]
)
îî] ^
}
îîd e
,
îîe f
{
ïï 
$str
ïï 
,
ïï 
CIELabFromRGB
ïï< I
(
ïïI J
$num
ïïJ M
,
ïïM N
$num
ïïO R
,
ïïR S
$num
ïïT W
,
ïïW X
$num
ïïY ]
)
ïï] ^
}
ïïd e
,
ïïe f
{
ññ 
$str
ññ 
,
ññ 
CIELabFromRGB
ññ< I
(
ññI J
$num
ññJ M
,
ññM N
$num
ññO R
,
ññR S
$num
ññT W
,
ññW X
$num
ññY ]
)
ññ] ^
}
ññd e
,
ññe f
{
óó 
$str
óó 
,
óó 
CIELabFromRGB
óó< I
(
óóI J
$num
óóJ N
,
óóN O
$num
óóP S
,
óóS T
$num
óóU W
,
óóW X
$num
óóY ]
)
óó] ^
}
óód e
,
óóe f
{
òò 
$str
òò 
,
òò  
CIELabFromRGB
òò< I
(
òòI J
$num
òòJ N
,
òòN O
$num
òòP S
,
òòS T
$num
òòU W
,
òòW X
$num
òòY ]
)
òò] ^
}
òòd e
,
òòe f
{
ôô 
$str
ôô 
,
ôô 
CIELabFromRGB
ôô< I
(
ôôI J
$num
ôôJ N
,
ôôN O
$num
ôôP R
,
ôôR S
$num
ôôT W
,
ôôW X
$num
ôôY ]
)
ôô] ^
}
ôôd e
,
ôôe f
{
öö 
$str
öö 
,
öö 
CIELabFromRGB
öö< I
(
ööI J
$num
ööJ M
,
ööM N
$num
ööO R
,
ööR S
$num
ööT W
,
ööW X
$num
ööY ]
)
öö] ^
}
ööd e
,
ööe f
{
õõ 
$str
õõ 
,
õõ 
CIELabFromRGB
õõ< I
(
õõI J
$num
õõJ M
,
õõM N
$num
õõO R
,
õõR S
$num
õõT W
,
õõW X
$num
õõY ]
)
õõ] ^
}
õõd e
,
õõe f
{
úú 
$str
úú  
,
úú  !
CIELabFromRGB
úú< I
(
úúI J
$num
úúJ M
,
úúM N
$num
úúO R
,
úúR S
$num
úúT W
,
úúW X
$num
úúY ]
)
úú] ^
}
úúd e
,
úúe f
{
ùù 
$str
ùù 
,
ùù 
CIELabFromRGB
ùù< I
(
ùùI J
$num
ùùJ M
,
ùùM N
$num
ùùO R
,
ùùR S
$num
ùùT W
,
ùùW X
$num
ùùY ]
)
ùù] ^
}
ùùd e
,
ùùe f
{
ûû 
$str
ûû 
,
ûû 
CIELabFromRGB
ûû< I
(
ûûI J
$num
ûûJ M
,
ûûM N
$num
ûûO R
,
ûûR S
$num
ûûT W
,
ûûW X
$num
ûûY ]
)
ûû] ^
}
ûûd e
,
ûûe f
{
üü 
$str
üü 
,
üü  
CIELabFromRGB
üü< I
(
üüI J
$num
üüJ M
,
üüM N
$num
üüO R
,
üüR S
$num
üüT W
,
üüW X
$num
üüY ]
)
üü] ^
}
üüd e
,
üüe f
{
†† 
$str
†† 
,
†† 
CIELabFromRGB
††< I
(
††I J
$num
††J M
,
††M N
$num
††O R
,
††R S
$num
††T W
,
††W X
$num
††Y ]
)
††] ^
}
††d e
,
††e f
{
°° 
$str
°° 
,
°° 
CIELabFromRGB
°°< I
(
°°I J
$num
°°J M
,
°°M N
$num
°°O R
,
°°R S
$num
°°T W
,
°°W X
$num
°°Y ]
)
°°] ^
}
°°d e
,
°°e f
{
¢¢ 
$str
¢¢ 
,
¢¢ 
CIELabFromRGB
¢¢< I
(
¢¢I J
$num
¢¢J L
,
¢¢L M
$num
¢¢N Q
,
¢¢Q R
$num
¢¢S U
,
¢¢U V
$num
¢¢W [
)
¢¢[ \
}
¢¢d e
,
¢¢e f
{
££ 
$str
££ 
,
££ 
CIELabFromRGB
££< I
(
££I J
$num
££J M
,
££M N
$num
££O R
,
££R S
$num
££T V
,
££V W
$num
££X \
)
££\ ]
}
££d e
,
££e f
{
§§ 
$str
§§ 
,
§§ 
CIELabFromRGB
§§< I
(
§§I J
$num
§§J M
,
§§M N
$num
§§O R
,
§§R S
$num
§§T W
,
§§W X
$num
§§Y ]
)
§§] ^
}
§§d e
,
§§e f
{
•• 
$str
•• 
,
•• 
CIELabFromRGB
••< I
(
••I J
$num
••J L
,
••L M
$num
••N R
,
••R S
$num
••T X
,
••X Y
$num
••Z ^
)
••^ _
}
••d e
,
••e f
{
¶¶ 
$str
¶¶ 
,
¶¶ 
CIELabFromRGB
¶¶< I
(
¶¶I J
$num
¶¶J M
,
¶¶M N
$num
¶¶O S
,
¶¶S T
$num
¶¶U X
,
¶¶X Y
$num
¶¶Z ^
)
¶¶^ _
}
¶¶d e
,
¶¶e f
{
ßß 
$str
ßß 
,
ßß 
CIELabFromRGB
ßß< I
(
ßßI J
$num
ßßJ M
,
ßßM N
$num
ßßO R
,
ßßR S
$num
ßßT W
,
ßßW X
$num
ßßY ]
)
ßß] ^
}
ßßd e
,
ßße f
{
®® 
$str
®® 
,
®® 
CIELabFromRGB
®®< I
(
®®I J
$num
®®J M
,
®®M N
$num
®®O R
,
®®R S
$num
®®T W
,
®®W X
$num
®®Y ]
)
®®] ^
}
®®d e
,
®®e f
{
©© 
$str
©© 
,
©© 
CIELabFromRGB
©©< I
(
©©I J
$num
©©J M
,
©©M N
$num
©©O R
,
©©R S
$num
©©T W
,
©©W X
$num
©©Y ]
)
©©] ^
}
©©d e
,
©©e f
{
™™ 
$str
™™ 
,
™™ 
CIELabFromRGB
™™< I
(
™™I J
$num
™™J M
,
™™M N
$num
™™O R
,
™™R S
$num
™™T W
,
™™W X
$num
™™Y ]
)
™™] ^
}
™™d e
,
™™e f
{
´´ 
$str
´´ 
,
´´ 
CIELabFromRGB
´´< I
(
´´I J
$num
´´J M
,
´´M N
$num
´´O R
,
´´R S
$num
´´T W
,
´´W X
$num
´´Y ]
)
´´] ^
}
´´d e
,
´´e f
{
¨¨ 
$str
¨¨ 
,
¨¨ 
CIELabFromRGB
¨¨< I
(
¨¨I J
$num
¨¨J M
,
¨¨M N
$num
¨¨O R
,
¨¨R S
$num
¨¨T W
,
¨¨W X
$num
¨¨Y ]
)
¨¨] ^
}
¨¨d e
,
¨¨e f
{
≠≠ 
$str
≠≠  
,
≠≠  !
CIELabFromRGB
≠≠< I
(
≠≠I J
$num
≠≠J N
,
≠≠N O
$num
≠≠P S
,
≠≠S T
$num
≠≠U X
,
≠≠X Y
$num
≠≠Z ^
)
≠≠^ _
}
≠≠d e
,
≠≠e f
{
ÆÆ 
$str
ÆÆ 
,
ÆÆ 
CIELabFromRGB
ÆÆ< I
(
ÆÆI J
$num
ÆÆJ M
,
ÆÆM N
$num
ÆÆO R
,
ÆÆR S
$num
ÆÆT W
,
ÆÆW X
$num
ÆÆY ]
)
ÆÆ] ^
}
ÆÆd e
,
ÆÆe f
{
ØØ 
$str
ØØ 
,
ØØ 
CIELabFromRGB
ØØ< I
(
ØØI J
$num
ØØJ M
,
ØØM N
$num
ØØO R
,
ØØR S
$num
ØØT V
,
ØØV W
$num
ØØX \
)
ØØ\ ]
}
ØØd e
,
ØØe f
{
∞∞ 
$str
∞∞ 
,
∞∞  
CIELabFromRGB
∞∞< I
(
∞∞I J
$num
∞∞J M
,
∞∞M N
$num
∞∞O R
,
∞∞R S
$num
∞∞T W
,
∞∞W X
$num
∞∞Y ]
)
∞∞] ^
}
∞∞d e
,
∞∞e f
{
±± 
$str
±± 
,
±± 
CIELabFromRGB
±±< I
(
±±I J
$num
±±J M
,
±±M N
$num
±±O R
,
±±R S
$num
±±T V
,
±±V W
$num
±±X \
)
±±\ ]
}
±±d e
,
±±e f
{
≤≤ 
$str
≤≤ 
,
≤≤ 
CIELabFromRGB
≤≤< I
(
≤≤I J
$num
≤≤J L
,
≤≤L M
$num
≤≤N Q
,
≤≤Q R
$num
≤≤S W
,
≤≤W X
$num
≤≤Y ]
)
≤≤] ^
}
≤≤d e
,
≤≤e f
{
≥≥ 
$str
≥≥ !
,
≥≥! "
CIELabFromRGB
≥≥< I
(
≥≥I J
$num
≥≥J M
,
≥≥M N
$num
≥≥O S
,
≥≥S T
$num
≥≥U Y
,
≥≥Y Z
$num
≥≥[ _
)
≥≥_ `
}
≥≥d e
,
≥≥e f
{
¥¥ 
$str
¥¥ 
,
¥¥ 
CIELabFromRGB
¥¥< I
(
¥¥I J
$num
¥¥J M
,
¥¥M N
$num
¥¥O S
,
¥¥S T
$num
¥¥U Y
,
¥¥Y Z
$num
¥¥[ _
)
¥¥_ `
}
¥¥d e
,
¥¥e f
{
µµ 
$str
µµ 
,
µµ 
CIELabFromRGB
µµ< I
(
µµI J
$num
µµJ M
,
µµM N
$num
µµO R
,
µµR S
$num
µµT W
,
µµW X
$num
µµY ]
)
µµ] ^
}
µµd e
,
µµe f
{
∂∂ 
$str
∂∂ 
,
∂∂ 
CIELabFromRGB
∂∂< I
(
∂∂I J
$num
∂∂J M
,
∂∂M N
$num
∂∂O R
,
∂∂R S
$num
∂∂T W
,
∂∂W X
$num
∂∂Y ]
)
∂∂] ^
}
∂∂d e
,
∂∂e f
{
∑∑ 
$str
∑∑ 
,
∑∑ 
CIELabFromRGB
∑∑< I
(
∑∑I J
$num
∑∑J M
,
∑∑M N
$num
∑∑O R
,
∑∑R S
$num
∑∑T W
,
∑∑W X
$num
∑∑Y ]
)
∑∑] ^
}
∑∑d e
,
∑∑e f
{
∏∏ 
$str
∏∏ 
,
∏∏ 
CIELabFromRGB
∏∏< I
(
∏∏I J
$num
∏∏J M
,
∏∏M N
$num
∏∏O R
,
∏∏R S
$num
∏∏T W
,
∏∏W X
$num
∏∏Y ]
)
∏∏] ^
}
∏∏d e
,
∏∏e f
{
ππ 
$str
ππ 
,
ππ 
CIELabFromRGB
ππ< I
(
ππI J
$num
ππJ N
,
ππN O
$num
ππP T
,
ππT U
$num
ππV Y
,
ππY Z
$num
ππ[ _
)
ππ_ `
}
ππd e
,
ππe f
{
∫∫ 
$str
∫∫ !
,
∫∫! "
CIELabFromRGB
∫∫< I
(
∫∫I J
$num
∫∫J N
,
∫∫N O
$num
∫∫P S
,
∫∫S T
$num
∫∫U X
,
∫∫X Y
$num
∫∫Z ^
)
∫∫^ _
}
∫∫d e
,
∫∫e f
{
ªª 
$str
ªª 
,
ªª 
CIELabFromRGB
ªª< I
(
ªªI J
$num
ªªJ M
,
ªªM N
$num
ªªO R
,
ªªR S
$num
ªªT W
,
ªªW X
$num
ªªY ]
)
ªª] ^
}
ªªd e
,
ªªe f
{
ºº 
$str
ºº 
,
ºº 
CIELabFromRGB
ºº< I
(
ººI J
$num
ººJ M
,
ººM N
$num
ººO R
,
ººR S
$num
ººT W
,
ººW X
$num
ººY ]
)
ºº] ^
}
ººd e
,
ººe f
{
ΩΩ 
$str
ΩΩ 
,
ΩΩ 
CIELabFromRGB
ΩΩ< I
(
ΩΩI J
$num
ΩΩJ N
,
ΩΩN O
$num
ΩΩP S
,
ΩΩS T
$num
ΩΩU X
,
ΩΩX Y
$num
ΩΩZ ^
)
ΩΩ^ _
}
ΩΩd e
,
ΩΩe f
{
ææ 
$str
ææ  
,
ææ  !
CIELabFromRGB
ææ< I
(
ææI J
$num
ææJ L
,
ææL M
$num
ææN Q
,
ææQ R
$num
ææS V
,
ææV W
$num
ææX \
)
ææ\ ]
}
ææd e
,
ææe f
{
øø 
$str
øø 
,
øø 
CIELabFromRGB
øø< I
(
øøI J
$num
øøJ M
,
øøM N
$num
øøO R
,
øøR S
$num
øøT W
,
øøW X
$num
øøY ]
)
øø] ^
}
øød e
,
øøe f
{
¿¿ 
$str
¿¿ 
,
¿¿ 
CIELabFromRGB
¿¿< I
(
¿¿I J
$num
¿¿J M
,
¿¿M N
$num
¿¿O Q
,
¿¿Q R
$num
¿¿S U
,
¿¿U V
$num
¿¿W [
)
¿¿[ \
}
¿¿d e
,
¿¿e f
{
¡¡ 
$str
¡¡ 
,
¡¡  
CIELabFromRGB
¡¡< I
(
¡¡I J
$num
¡¡J M
,
¡¡M N
$num
¡¡O R
,
¡¡R S
$num
¡¡T W
,
¡¡W X
$num
¡¡Y ]
)
¡¡] ^
}
¡¡d e
,
¡¡e f
{
¬¬ 
$str
¬¬ 
,
¬¬ 
CIELabFromRGB
¬¬< I
(
¬¬I J
$num
¬¬J M
,
¬¬M N
$num
¬¬O R
,
¬¬R S
$num
¬¬T W
,
¬¬W X
$num
¬¬Y ]
)
¬¬] ^
}
¬¬d e
,
¬¬e f
{
√√ 
$str
√√ 
,
√√ 
CIELabFromRGB
√√< I
(
√√I J
$num
√√J M
,
√√M N
$num
√√O R
,
√√R S
$num
√√T W
,
√√W X
$num
√√Y ]
)
√√] ^
}
√√d e
,
√√e f
{
ƒƒ 
$str
ƒƒ 
,
ƒƒ 
CIELabFromRGB
ƒƒ< I
(
ƒƒI J
$num
ƒƒJ M
,
ƒƒM N
$num
ƒƒO R
,
ƒƒR S
$num
ƒƒT W
,
ƒƒW X
$num
ƒƒY ]
)
ƒƒ] ^
}
ƒƒd e
,
ƒƒe f
{
≈≈ 
$str
≈≈ 
,
≈≈ 
CIELabFromRGB
≈≈< I
(
≈≈I J
$num
≈≈J M
,
≈≈M N
$num
≈≈O R
,
≈≈R S
$num
≈≈T W
,
≈≈W X
$num
≈≈Y ]
)
≈≈] ^
}
≈≈d e
,
≈≈e f
{
∆∆ 
$str
∆∆ 
,
∆∆ 
CIELabFromRGB
∆∆< I
(
∆∆I J
$num
∆∆J M
,
∆∆M N
$num
∆∆O R
,
∆∆R S
$num
∆∆T W
,
∆∆W X
$num
∆∆Y ]
)
∆∆] ^
}
∆∆d e
,
∆∆e f
{
«« 
$str
«« 
,
«« 
CIELabFromRGB
««< I
(
««I J
$num
««J M
,
««M N
$num
««O R
,
««R S
$num
««T W
,
««W X
$num
««Y ]
)
««] ^
}
««d e
,
««e f
{
»» 
$str
»» 
,
»» 
CIELabFromRGB
»»< I
(
»»I J
$num
»»J N
,
»»N O
$num
»»P S
,
»»S T
$num
»»U X
,
»»X Y
$num
»»Z ^
)
»»^ _
}
»»d e
,
»»e f
{
…… 
$str
…… 
,
…… 
CIELabFromRGB
……< I
(
……I J
$num
……J M
,
……M N
$num
……O R
,
……R S
$num
……T W
,
……W X
$num
……Y ]
)
……] ^
}
……d e
,
……e f
{
   
$str
   
,
   
CIELabFromRGB
  < I
(
  I J
$num
  J M
,
  M N
$num
  O R
,
  R S
$num
  T V
,
  V W
$num
  X \
)
  \ ]
}
  d e
,
  e f
{
ÀÀ 
$str
ÀÀ 
,
ÀÀ 
CIELabFromRGB
ÀÀ< I
(
ÀÀI J
$num
ÀÀJ M
,
ÀÀM N
$num
ÀÀO R
,
ÀÀR S
$num
ÀÀT V
,
ÀÀV W
$num
ÀÀX \
)
ÀÀ\ ]
}
ÀÀd e
,
ÀÀe f
{
ÃÃ 
$str
ÃÃ 
,
ÃÃ 
CIELabFromRGB
ÃÃ< I
(
ÃÃI J
$num
ÃÃJ M
,
ÃÃM N
$num
ÃÃO S
,
ÃÃS T
$num
ÃÃU W
,
ÃÃW X
$num
ÃÃY ]
)
ÃÃ] ^
}
ÃÃd e
,
ÃÃe f
{
ÕÕ 
$str
ÕÕ 
,
ÕÕ 
CIELabFromRGB
ÕÕ< I
(
ÕÕI J
$num
ÕÕJ N
,
ÕÕN O
$num
ÕÕP S
,
ÕÕS T
$num
ÕÕU X
,
ÕÕX Y
$num
ÕÕZ ^
)
ÕÕ^ _
}
ÕÕd e
,
ÕÕe f
{
ŒŒ 
$str
ŒŒ #
,
ŒŒ# $
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ M
,
ŒŒM N
$num
ŒŒO R
,
ŒŒR S
$num
ŒŒT W
,
ŒŒW X
$num
ŒŒY ]
)
ŒŒ] ^
}
ŒŒd e
,
ŒŒe f
{
œœ 
$str
œœ 
,
œœ 
CIELabFromRGB
œœ< I
(
œœI J
$num
œœJ L
,
œœL M
$num
œœN P
,
œœP Q
$num
œœR T
,
œœT U
$num
œœV Z
)
œœZ [
}
œœd e
,
œœe f
{
–– 
$str
–– 
,
–– 
CIELabFromRGB
––< I
(
––I J
$num
––J M
,
––M N
$num
––O Q
,
––Q R
$num
––S U
,
––U V
$num
––W [
)
––[ \
}
––d e
,
––e f
{
—— 
$str
—— $
,
——$ %
CIELabFromRGB
——< I
(
——I J
$num
——J M
,
——M N
$num
——O R
,
——R S
$num
——T W
,
——W X
$num
——Y ]
)
——] ^
}
——d e
,
——e f
{
““ 
$str
““ 
,
““ 
CIELabFromRGB
““< I
(
““I J
$num
““J M
,
““M N
$num
““O R
,
““R S
$num
““T W
,
““W X
$num
““Y ]
)
““] ^
}
““d e
,
““e f
{
”” 
$str
”” 
,
””  
CIELabFromRGB
””< I
(
””I J
$num
””J N
,
””N O
$num
””P S
,
””S T
$num
””U X
,
””X Y
$num
””Z ^
)
””^ _
}
””d e
,
””e f
{
‘‘ 
$str
‘‘  
,
‘‘  !
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J M
,
‘‘M N
$num
‘‘O R
,
‘‘R S
$num
‘‘T W
,
‘‘W X
$num
‘‘Y ]
)
‘‘] ^
}
‘‘d e
,
‘‘e f
{
’’ 
$str
’’ 
,
’’ 
CIELabFromRGB
’’< I
(
’’I J
$num
’’J M
,
’’M N
$num
’’O R
,
’’R S
$num
’’T W
,
’’W X
$num
’’Y ]
)
’’] ^
}
’’d e
,
’’e f
{
÷÷ 
$str
÷÷ 
,
÷÷ 
CIELabFromRGB
÷÷< I
(
÷÷I J
$num
÷÷J M
,
÷÷M N
$num
÷÷O R
,
÷÷R S
$num
÷÷T W
,
÷÷W X
$num
÷÷Y ]
)
÷÷] ^
}
÷÷d e
,
÷÷e f
{
◊◊ 
$str
◊◊ 
,
◊◊ 
CIELabFromRGB
◊◊< I
(
◊◊I J
$num
◊◊J M
,
◊◊M N
$num
◊◊O R
,
◊◊R S
$num
◊◊T W
,
◊◊W X
$num
◊◊Y ]
)
◊◊] ^
}
◊◊d e
,
◊◊e f
{
ÿÿ 
$str
ÿÿ 
,
ÿÿ 
CIELabFromRGB
ÿÿ< I
(
ÿÿI J
$num
ÿÿJ L
,
ÿÿL M
$num
ÿÿN P
,
ÿÿP Q
$num
ÿÿR V
,
ÿÿV W
$num
ÿÿX \
)
ÿÿ\ ]
}
ÿÿd e
,
ÿÿe f
{
ŸŸ 
$str
ŸŸ 
,
ŸŸ 
CIELabFromRGB
ŸŸ< I
(
ŸŸI J
$num
ŸŸJ M
,
ŸŸM N
$num
ŸŸO R
,
ŸŸR S
$num
ŸŸT X
,
ŸŸX Y
$num
ŸŸZ ^
)
ŸŸ^ _
}
ŸŸd e
,
ŸŸe f
{
⁄⁄ 
$str
⁄⁄ 
,
⁄⁄ 
CIELabFromRGB
⁄⁄< I
(
⁄⁄I J
$num
⁄⁄J L
,
⁄⁄L M
$num
⁄⁄N Q
,
⁄⁄Q R
$num
⁄⁄S V
,
⁄⁄V W
$num
⁄⁄X \
)
⁄⁄\ ]
}
⁄⁄d e
,
⁄⁄e f
{
€€ 
$str
€€ 
,
€€ 
CIELabFromRGB
€€< I
(
€€I J
$num
€€J L
,
€€L M
$num
€€N Q
,
€€Q R
$num
€€S V
,
€€V W
$num
€€X \
)
€€\ ]
}
€€d e
,
€€e f
{
‹‹ 
$str
‹‹ 
,
‹‹ 
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J L
,
‹‹L M
$num
‹‹N P
,
‹‹P Q
$num
‹‹R U
,
‹‹U V
$num
‹‹W [
)
‹‹[ \
}
‹‹d e
,
‹‹e f
{
›› 
$str
›› 
,
›› 
CIELabFromRGB
››< I
(
››I J
$num
››J M
,
››M N
$num
››O R
,
››R S
$num
››T W
,
››W X
$num
››Y ]
)
››] ^
}
››d e
,
››e f
{
ﬁﬁ 
$str
ﬁﬁ 
,
ﬁﬁ 
CIELabFromRGB
ﬁﬁ< I
(
ﬁﬁI J
$num
ﬁﬁJ L
,
ﬁﬁL M
$num
ﬁﬁN Q
,
ﬁﬁQ R
$num
ﬁﬁS W
,
ﬁﬁW X
$num
ﬁﬁY ]
)
ﬁﬁ] ^
}
ﬁﬁd e
,
ﬁﬁe f
{
ﬂﬂ 
$str
ﬂﬂ 
,
ﬂﬂ 
CIELabFromRGB
ﬂﬂ< I
(
ﬂﬂI J
$num
ﬂﬂJ M
,
ﬂﬂM N
$num
ﬂﬂO R
,
ﬂﬂR S
$num
ﬂﬂT W
,
ﬂﬂW X
$num
ﬂﬂY ]
)
ﬂﬂ] ^
}
ﬂﬂd e
,
ﬂﬂe f
{
‡‡ 
$str
‡‡ 
,
‡‡ 
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J M
,
‡‡M N
$num
‡‡O R
,
‡‡R S
$num
‡‡T W
,
‡‡W X
$num
‡‡Y ]
)
‡‡] ^
}
‡‡d e
,
‡‡e f
{
·· 
$str
·· 
,
·· 
CIELabFromRGB
··< I
(
··I J
$num
··J L
,
··L M
$num
··N Q
,
··Q R
$num
··S V
,
··V W
$num
··X \
)
··\ ]
}
··d e
,
··e f
{
‚‚ 
$str
‚‚ 
,
‚‚ 
CIELabFromRGB
‚‚< I
(
‚‚I J
$num
‚‚J M
,
‚‚M N
$num
‚‚O R
,
‚‚R S
$num
‚‚T W
,
‚‚W X
$num
‚‚Y ]
)
‚‚] ^
}
‚‚d e
,
‚‚e f
{
„„ 
$str
„„ #
,
„„# $
CIELabFromRGB
„„< I
(
„„I J
$num
„„J M
,
„„M N
$num
„„O R
,
„„R S
$num
„„T W
,
„„W X
$num
„„Y ]
)
„„] ^
}
„„d e
,
„„e f
{
‰‰ 
$str
‰‰ 
,
‰‰ 
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J L
,
‰‰L M
$num
‰‰N Q
,
‰‰Q R
$num
‰‰S V
,
‰‰V W
$num
‰‰X \
)
‰‰\ ]
}
‰‰d e
,
‰‰e f
{
ÂÂ 
$str
ÂÂ 
,
ÂÂ 
CIELabFromRGB
ÂÂ< I
(
ÂÂI J
$num
ÂÂJ M
,
ÂÂM N
$num
ÂÂO R
,
ÂÂR S
$num
ÂÂT W
,
ÂÂW X
$num
ÂÂY ]
)
ÂÂ] ^
}
ÂÂd e
,
ÂÂe f
{
ÊÊ 
$str
ÊÊ 
,
ÊÊ 
CIELabFromRGB
ÊÊ< I
(
ÊÊI J
$num
ÊÊJ M
,
ÊÊM N
$num
ÊÊO R
,
ÊÊR S
$num
ÊÊT W
,
ÊÊW X
$num
ÊÊY ]
)
ÊÊ] ^
}
ÊÊd e
,
ÊÊe f
{
ÁÁ 
$str
ÁÁ 
,
ÁÁ 
CIELabFromRGB
ÁÁ< I
(
ÁÁI J
$num
ÁÁJ M
,
ÁÁM N
$num
ÁÁO R
,
ÁÁR S
$num
ÁÁT W
,
ÁÁW X
$num
ÁÁY ]
)
ÁÁ] ^
}
ÁÁd e
,
ÁÁe f
{
ËË 
$str
ËË 
,
ËË 
CIELabFromRGB
ËË< I
(
ËËI J
$num
ËËJ M
,
ËËM N
$num
ËËO R
,
ËËR S
$num
ËËT W
,
ËËW X
$num
ËËY ]
)
ËË] ^
}
ËËd e
,
ËËe f
{
ÈÈ 
$str
ÈÈ 
,
ÈÈ 
CIELabFromRGB
ÈÈ< I
(
ÈÈI J
$num
ÈÈJ M
,
ÈÈM N
$num
ÈÈO R
,
ÈÈR S
$num
ÈÈT W
,
ÈÈW X
$num
ÈÈY ]
)
ÈÈ] ^
}
ÈÈd e
,
ÈÈe f
{
ÍÍ 
$str
ÍÍ 
,
ÍÍ 
CIELabFromRGB
ÍÍ< I
(
ÍÍI J
$num
ÍÍJ M
,
ÍÍM N
$num
ÍÍO R
,
ÍÍR S
$num
ÍÍT W
,
ÍÍW X
$num
ÍÍY ]
)
ÍÍ] ^
}
ÍÍd e
,
ÍÍe f
{
ÎÎ 
$str
ÎÎ 
,
ÎÎ 
CIELabFromRGB
ÎÎ< I
(
ÎÎI J
$num
ÎÎJ L
,
ÎÎL M
$num
ÎÎN Q
,
ÎÎQ R
$num
ÎÎS V
,
ÎÎV W
$num
ÎÎX \
)
ÎÎ\ ]
}
ÎÎd e
,
ÎÎe f
{
ÏÏ 
$str
ÏÏ 
,
ÏÏ 
CIELabFromRGB
ÏÏ< I
(
ÏÏI J
$num
ÏÏJ M
,
ÏÏM N
$num
ÏÏO R
,
ÏÏR S
$num
ÏÏT W
,
ÏÏW X
$num
ÏÏY ]
)
ÏÏ] ^
}
ÏÏd e
,
ÏÏe f
{
ÌÌ 
$str
ÌÌ %
,
ÌÌ% &
CIELabFromRGB
ÌÌ< I
(
ÌÌI J
$num
ÌÌJ M
,
ÌÌM N
$num
ÌÌO Q
,
ÌÌQ R
$num
ÌÌS U
,
ÌÌU V
$num
ÌÌW [
)
ÌÌ[ \
}
ÌÌd e
,
ÌÌe f
{
ÓÓ 
$str
ÓÓ 
,
ÓÓ 
CIELabFromRGB
ÓÓ< I
(
ÓÓI J
$num
ÓÓJ L
,
ÓÓL M
$num
ÓÓN Q
,
ÓÓQ R
$num
ÓÓS V
,
ÓÓV W
$num
ÓÓX \
)
ÓÓ\ ]
}
ÓÓd e
,
ÓÓe f
{
ÔÔ 
$str
ÔÔ 
,
ÔÔ 
CIELabFromRGB
ÔÔ< I
(
ÔÔI J
$num
ÔÔJ M
,
ÔÔM N
$num
ÔÔO R
,
ÔÔR S
$num
ÔÔT W
,
ÔÔW X
$num
ÔÔY ]
)
ÔÔ] ^
}
ÔÔd e
,
ÔÔe f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J L
,
L M
$num
N Q
,
Q R
$num
S W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
ÒÒ 
$str
ÒÒ 
,
ÒÒ 
CIELabFromRGB
ÒÒ< I
(
ÒÒI J
$num
ÒÒJ M
,
ÒÒM N
$num
ÒÒO R
,
ÒÒR S
$num
ÒÒT W
,
ÒÒW X
$num
ÒÒY ]
)
ÒÒ] ^
}
ÒÒd e
,
ÒÒe f
{
ÚÚ 
$str
ÚÚ 
,
ÚÚ 
CIELabFromRGB
ÚÚ< I
(
ÚÚI J
$num
ÚÚJ M
,
ÚÚM N
$num
ÚÚO R
,
ÚÚR S
$num
ÚÚT W
,
ÚÚW X
$num
ÚÚY ]
)
ÚÚ] ^
}
ÚÚd e
,
ÚÚe f
{
ÛÛ 
$str
ÛÛ 
,
ÛÛ  
CIELabFromRGB
ÛÛ< I
(
ÛÛI J
$num
ÛÛJ M
,
ÛÛM N
$num
ÛÛO R
,
ÛÛR S
$num
ÛÛT W
,
ÛÛW X
$num
ÛÛY ]
)
ÛÛ] ^
}
ÛÛd e
,
ÛÛe f
{
ÙÙ 
$str
ÙÙ 
,
ÙÙ 
CIELabFromRGB
ÙÙ< I
(
ÙÙI J
$num
ÙÙJ M
,
ÙÙM N
$num
ÙÙO S
,
ÙÙS T
$num
ÙÙU W
,
ÙÙW X
$num
ÙÙY ]
)
ÙÙ] ^
}
ÙÙd e
,
ÙÙe f
{
ıı 
$str
ıı 
,
ıı  
CIELabFromRGB
ıı< I
(
ııI J
$num
ııJ M
,
ııM N
$num
ııO R
,
ııR S
$num
ııT W
,
ııW X
$num
ııY ]
)
ıı] ^
}
ııd e
,
ııe f
{
ˆˆ 
$str
ˆˆ 
,
ˆˆ 
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ M
,
ˆˆM N
$num
ˆˆO R
,
ˆˆR S
$num
ˆˆT W
,
ˆˆW X
$num
ˆˆY ]
)
ˆˆ] ^
}
ˆˆd e
,
ˆˆe f
{
˜˜ 
$str
˜˜ 
,
˜˜ 
CIELabFromRGB
˜˜< I
(
˜˜I J
$num
˜˜J M
,
˜˜M N
$num
˜˜O R
,
˜˜R S
$num
˜˜T W
,
˜˜W X
$num
˜˜Y ]
)
˜˜] ^
}
˜˜d e
,
˜˜e f
{
¯¯ 
$str
¯¯  
,
¯¯  !
CIELabFromRGB
¯¯< I
(
¯¯I J
$num
¯¯J M
,
¯¯M N
$num
¯¯O R
,
¯¯R S
$num
¯¯T W
,
¯¯W X
$num
¯¯Y ]
)
¯¯] ^
}
¯¯d e
,
¯¯e f
{
˘˘ 
$str
˘˘ 
,
˘˘ 
CIELabFromRGB
˘˘< I
(
˘˘I J
$num
˘˘J N
,
˘˘N O
$num
˘˘P R
,
˘˘R S
$num
˘˘T W
,
˘˘W X
$num
˘˘Y ]
)
˘˘] ^
}
˘˘d e
,
˘˘e f
{
˙˙ 
$str
˙˙  
,
˙˙  !
CIELabFromRGB
˙˙< I
(
˙˙I J
$num
˙˙J L
,
˙˙L M
$num
˙˙N Q
,
˙˙Q R
$num
˙˙S V
,
˙˙V W
$num
˙˙X \
)
˙˙\ ]
}
˙˙d e
,
˙˙e f
{
˚˚ 
$str
˚˚ 
,
˚˚ 
CIELabFromRGB
˚˚< I
(
˚˚I J
$num
˚˚J M
,
˚˚M N
$num
˚˚O R
,
˚˚R S
$num
˚˚T W
,
˚˚W X
$num
˚˚Y ]
)
˚˚] ^
}
˚˚d e
,
˚˚e f
{
¸¸ 
$str
¸¸ 
,
¸¸  
CIELabFromRGB
¸¸< I
(
¸¸I J
$num
¸¸J M
,
¸¸M N
$num
¸¸O R
,
¸¸R S
$num
¸¸T X
,
¸¸X Y
$num
¸¸Z ^
)
¸¸^ _
}
¸¸d e
,
¸¸e f
{
˝˝ 
$str
˝˝ "
,
˝˝" #
CIELabFromRGB
˝˝< I
(
˝˝I J
$num
˝˝J M
,
˝˝M N
$num
˝˝O R
,
˝˝R S
$num
˝˝T X
,
˝˝X Y
$num
˝˝Z ^
)
˝˝^ _
}
˝˝d e
,
˝˝e f
{
˛˛ 
$str
˛˛ 
,
˛˛ 
CIELabFromRGB
˛˛< I
(
˛˛I J
$num
˛˛J N
,
˛˛N O
$num
˛˛P S
,
˛˛S T
$num
˛˛U X
,
˛˛X Y
$num
˛˛Z ^
)
˛˛^ _
}
˛˛d e
,
˛˛e f
{
ˇˇ 
$str
ˇˇ 
,
ˇˇ 
CIELabFromRGB
ˇˇ< I
(
ˇˇI J
$num
ˇˇJ M
,
ˇˇM N
$num
ˇˇO R
,
ˇˇR S
$num
ˇˇT W
,
ˇˇW X
$num
ˇˇY ]
)
ˇˇ] ^
}
ˇˇd e
,
ˇˇe f
{
ÄÄ 
$str
ÄÄ $
,
ÄÄ$ %
CIELabFromRGB
ÄÄ< I
(
ÄÄI J
$num
ÄÄJ L
,
ÄÄL M
$num
ÄÄN Q
,
ÄÄQ R
$num
ÄÄS V
,
ÄÄV W
$num
ÄÄX \
)
ÄÄ\ ]
}
ÄÄd e
,
ÄÄe f
{
ÅÅ 
$str
ÅÅ 
,
ÅÅ 
CIELabFromRGB
ÅÅ< I
(
ÅÅI J
$num
ÅÅJ M
,
ÅÅM N
$num
ÅÅO R
,
ÅÅR S
$num
ÅÅT W
,
ÅÅW X
$num
ÅÅY ]
)
ÅÅ] ^
}
ÅÅd e
,
ÅÅe f
{
ÇÇ 
$str
ÇÇ 
,
ÇÇ 
CIELabFromRGB
ÇÇ< I
(
ÇÇI J
$num
ÇÇJ M
,
ÇÇM N
$num
ÇÇO R
,
ÇÇR S
$num
ÇÇT V
,
ÇÇV W
$num
ÇÇX \
)
ÇÇ\ ]
}
ÇÇd e
,
ÇÇe f
{
ÉÉ 
$str
ÉÉ #
,
ÉÉ# $
CIELabFromRGB
ÉÉ< I
(
ÉÉI J
$num
ÉÉJ M
,
ÉÉM N
$num
ÉÉO R
,
ÉÉR S
$num
ÉÉT V
,
ÉÉV W
$num
ÉÉX \
)
ÉÉ\ ]
}
ÉÉd e
,
ÉÉe f
{
ÑÑ 
$str
ÑÑ 
,
ÑÑ 
CIELabFromRGB
ÑÑ< I
(
ÑÑI J
$num
ÑÑJ M
,
ÑÑM N
$num
ÑÑO R
,
ÑÑR S
$num
ÑÑT W
,
ÑÑW X
$num
ÑÑY ]
)
ÑÑ] ^
}
ÑÑd e
,
ÑÑe f
{
ÖÖ 
$str
ÖÖ 
,
ÖÖ 
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ M
,
ÖÖM N
$num
ÖÖO R
,
ÖÖR S
$num
ÖÖT W
,
ÖÖW X
$num
ÖÖY ]
)
ÖÖ] ^
}
ÖÖd e
,
ÖÖe f
{
ÜÜ 
$str
ÜÜ 
,
ÜÜ 
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ M
,
ÜÜM N
$num
ÜÜO R
,
ÜÜR S
$num
ÜÜT W
,
ÜÜW X
$num
ÜÜY ]
)
ÜÜ] ^
}
ÜÜd e
,
ÜÜe f
{
áá 
$str
áá 
,
áá  
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ M
,
ááM N
$num
ááO R
,
ááR S
$num
ááT W
,
ááW X
$num
ááY ]
)
áá] ^
}
áád e
,
ááe f
{
àà 
$str
àà 
,
àà 
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ N
,
ààN O
$num
ààP S
,
ààS T
$num
ààU X
,
ààX Y
$num
ààZ ^
)
àà^ _
}
ààd e
,
ààe f
{
ââ 
$str
ââ 
,
ââ 
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ M
,
ââM N
$num
ââO S
,
ââS T
$num
ââU Y
,
ââY Z
$num
ââ[ _
)
ââ_ `
}
ââd e
,
ââe f
{
ää 
$str
ää 
,
ää 
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ M
,
ääM N
$num
ääO R
,
ääR S
$num
ääT W
,
ääW X
$num
ääY ]
)
ää] ^
}
ääd e
,
ääe f
{
ãã 
$str
ãã 
,
ãã 
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ M
,
ããM N
$num
ããO R
,
ããR S
$num
ããT W
,
ããW X
$num
ããY ]
)
ãã] ^
}
ããd e
,
ããe f
{
åå 
$str
åå 
,
åå 
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ M
,
ååM N
$num
ååO Q
,
ååQ R
$num
ååS U
,
ååU V
$num
ååW [
)
åå[ \
}
ååd e
,
ååe f
{
çç 
$str
çç 
,
çç 
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ M
,
ççM N
$num
ççO Q
,
ççQ R
$num
ççS V
,
ççV W
$num
ççX \
)
çç\ ]
}
ççd e
,
ççe f
{
éé 
$str
éé 
,
éé 
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ M
,
ééM N
$num
ééO R
,
ééR S
$num
ééT W
,
ééW X
$num
ééY ]
)
éé] ^
}
ééd e
,
éée f
{
èè 
$str
èè 
,
èè 
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ M
,
èèM N
$num
èèO R
,
èèR S
$num
èèT V
,
èèV W
$num
èèX \
)
èè\ ]
}
èèd e
,
èèe f
{
êê 
$str
êê 
,
êê 
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ M
,
êêM N
$num
êêO R
,
êêR S
$num
êêT W
,
êêW X
$num
êêY ]
)
êê] ^
}
êêd e
,
êêe f
{
ëë 
$str
ëë 
,
ëë 
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ M
,
ëëM N
$num
ëëO R
,
ëëR S
$num
ëëT W
,
ëëW X
$num
ëëY ]
)
ëë] ^
}
ëëd e
,
ëëe f
{
íí 
$str
íí 
,
íí 
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ M
,
ííM N
$num
ííO R
,
ííR S
$num
ííT W
,
ííW X
$num
ííY ]
)
íí] ^
}
ííd e
,
ííe f
{
ìì 
$str
ìì 
,
ìì 
CIELabFromRGB
ìì< I
(
ììI J
$num
ììJ M
,
ììM N
$num
ììO R
,
ììR S
$num
ììT W
,
ììW X
$num
ììY ]
)
ìì] ^
}
ììd e
,
ììe f
{
îî 
$str
îî 
,
îî 
CIELabFromRGB
îî< I
(
îîI J
$num
îîJ M
,
îîM N
$num
îîO R
,
îîR S
$num
îîT W
,
îîW X
$num
îîY ]
)
îî] ^
}
îîd e
,
îîe f
{
ïï 
$str
ïï 
,
ïï 
CIELabFromRGB
ïï< I
(
ïïI J
$num
ïïJ M
,
ïïM N
$num
ïïO R
,
ïïR S
$num
ïïT W
,
ïïW X
$num
ïïY ]
)
ïï] ^
}
ïïd e
,
ïïe f
{
ññ 
$str
ññ 
,
ññ 
CIELabFromRGB
ññ< I
(
ññI J
$num
ññJ M
,
ññM N
$num
ññO R
,
ññR S
$num
ññT W
,
ññW X
$num
ññY ]
)
ññ] ^
}
ññd e
,
ññe f
{
óó 
$str
óó 
,
óó 
CIELabFromRGB
óó< I
(
óóI J
$num
óóJ L
,
óóL M
$num
óóN Q
,
óóQ R
$num
óóS V
,
óóV W
$num
óóX \
)
óó\ ]
}
óód e
,
óóe f
{
òò 
$str
òò 
,
òò 
CIELabFromRGB
òò< I
(
òòI J
$num
òòJ M
,
òòM N
$num
òòO R
,
òòR S
$num
òòT W
,
òòW X
$num
òòY ]
)
òò] ^
}
òòd e
,
òòe f
{
ôô 
$str
ôô 
,
ôô 
CIELabFromRGB
ôô< I
(
ôôI J
$num
ôôJ M
,
ôôM N
$num
ôôO Q
,
ôôQ R
$num
ôôS V
,
ôôV W
$num
ôôX \
)
ôô\ ]
}
ôôd e
,
ôôe f
{
öö 
$str
öö 
,
öö 
CIELabFromRGB
öö< I
(
ööI J
$num
ööJ N
,
ööN O
$num
ööP S
,
ööS T
$num
ööU W
,
ööW X
$num
ööY ]
)
öö] ^
}
ööd e
,
ööe f
{
õõ 
$str
õõ 
,
õõ 
CIELabFromRGB
õõ< I
(
õõI J
$num
õõJ M
,
õõM N
$num
õõO R
,
õõR S
$num
õõT W
,
õõW X
$num
õõY ]
)
õõ] ^
}
õõd e
,
õõe f
{
úú 
$str
úú 
,
úú 
CIELabFromRGB
úú< I
(
úúI J
$num
úúJ M
,
úúM N
$num
úúO R
,
úúR S
$num
úúT W
,
úúW X
$num
úúY ]
)
úú] ^
}
úúd e
,
úúe f
{
ùù 
$str
ùù 
,
ùù 
CIELabFromRGB
ùù< I
(
ùùI J
$num
ùùJ M
,
ùùM N
$num
ùùO R
,
ùùR S
$num
ùùT W
,
ùùW X
$num
ùùY ]
)
ùù] ^
}
ùùd e
,
ùùe f
{
ûû 
$str
ûû 
,
ûû 
CIELabFromRGB
ûû< I
(
ûûI J
$num
ûûJ M
,
ûûM N
$num
ûûO R
,
ûûR S
$num
ûûT W
,
ûûW X
$num
ûûY ]
)
ûû] ^
}
ûûd e
,
ûûe f
{
üü 
$str
üü 
,
üü 
CIELabFromRGB
üü< I
(
üüI J
$num
üüJ M
,
üüM N
$num
üüO R
,
üüR S
$num
üüT W
,
üüW X
$num
üüY ]
)
üü] ^
}
üüd e
,
üüe f
{
†† 
$str
†† 
,
†† 
CIELabFromRGB
††< I
(
††I J
$num
††J M
,
††M N
$num
††O R
,
††R S
$num
††T W
,
††W X
$num
††Y ]
)
††] ^
}
††d e
,
††e f
{
°° 
$str
°°  
,
°°  !
CIELabFromRGB
°°< I
(
°°I J
$num
°°J M
,
°°M N
$num
°°O R
,
°°R S
$num
°°T W
,
°°W X
$num
°°Y ]
)
°°] ^
}
°°d e
,
°°e f
{
¢¢ 
$str
¢¢ 
,
¢¢ 
CIELabFromRGB
¢¢< I
(
¢¢I J
$num
¢¢J N
,
¢¢N O
$num
¢¢P S
,
¢¢S T
$num
¢¢U W
,
¢¢W X
$num
¢¢Y ]
)
¢¢] ^
}
¢¢d e
,
¢¢e f
{
££ 
$str
££ 
,
££  
CIELabFromRGB
££< I
(
££I J
$num
££J N
,
££N O
$num
££P R
,
££R S
$num
££T V
,
££V W
$num
££X \
)
££\ ]
}
££d e
,
££e f
{
§§ 
$str
§§ 
,
§§ 
CIELabFromRGB
§§< I
(
§§I J
$num
§§J M
,
§§M N
$num
§§O R
,
§§R S
$num
§§T W
,
§§W X
$num
§§Y ]
)
§§] ^
}
§§d e
,
§§e f
{
•• 
$str
•• 
,
•• 
CIELabFromRGB
••< I
(
••I J
$num
••J L
,
••L M
$num
••N Q
,
••Q R
$num
••S W
,
••W X
$num
••Y ]
)
••] ^
}
••d e
,
••e f
{
¶¶ 
$str
¶¶ 
,
¶¶ 
CIELabFromRGB
¶¶< I
(
¶¶I J
$num
¶¶J M
,
¶¶M N
$num
¶¶O R
,
¶¶R S
$num
¶¶T W
,
¶¶W X
$num
¶¶Y ]
)
¶¶] ^
}
¶¶d e
,
¶¶e f
{
ßß 
$str
ßß 
,
ßß 
CIELabFromRGB
ßß< I
(
ßßI J
$num
ßßJ M
,
ßßM N
$num
ßßO R
,
ßßR S
$num
ßßT W
,
ßßW X
$num
ßßY ]
)
ßß] ^
}
ßßd e
,
ßße f
{
®® 
$str
®® 
,
®®  
CIELabFromRGB
®®< I
(
®®I J
$num
®®J L
,
®®L M
$num
®®N Q
,
®®Q R
$num
®®S V
,
®®V W
$num
®®X \
)
®®\ ]
}
®®d e
,
®®e f
{
©© 
$str
©© 
,
©© 
CIELabFromRGB
©©< I
(
©©I J
$num
©©J M
,
©©M N
$num
©©O Q
,
©©Q R
$num
©©S U
,
©©U V
$num
©©W [
)
©©[ \
}
©©d e
,
©©e f
{
™™ 
$str
™™ 
,
™™ 
CIELabFromRGB
™™< I
(
™™I J
$num
™™J M
,
™™M N
$num
™™O Q
,
™™Q R
$num
™™S V
,
™™V W
$num
™™X \
)
™™\ ]
}
™™d e
,
™™e f
{
´´ 
$str
´´ 
,
´´ 
CIELabFromRGB
´´< I
(
´´I J
$num
´´J M
,
´´M N
$num
´´O R
,
´´R S
$num
´´T W
,
´´W X
$num
´´Y ]
)
´´] ^
}
´´d e
,
´´e f
{
¨¨ 
$str
¨¨ 
,
¨¨ 
CIELabFromRGB
¨¨< I
(
¨¨I J
$num
¨¨J N
,
¨¨N O
$num
¨¨P R
,
¨¨R S
$num
¨¨T W
,
¨¨W X
$num
¨¨Y ]
)
¨¨] ^
}
¨¨d e
,
¨¨e f
{
≠≠ 
$str
≠≠ 
,
≠≠ 
CIELabFromRGB
≠≠< I
(
≠≠I J
$num
≠≠J N
,
≠≠N O
$num
≠≠P S
,
≠≠S T
$num
≠≠U X
,
≠≠X Y
$num
≠≠Z ^
)
≠≠^ _
}
≠≠d e
,
≠≠e f
{
ÆÆ 
$str
ÆÆ 
,
ÆÆ 
CIELabFromRGB
ÆÆ< I
(
ÆÆI J
$num
ÆÆJ M
,
ÆÆM N
$num
ÆÆO R
,
ÆÆR S
$num
ÆÆT W
,
ÆÆW X
$num
ÆÆY ]
)
ÆÆ] ^
}
ÆÆd e
,
ÆÆe f
{
ØØ 
$str
ØØ 
,
ØØ 
CIELabFromRGB
ØØ< I
(
ØØI J
$num
ØØJ M
,
ØØM N
$num
ØØO R
,
ØØR S
$num
ØØT W
,
ØØW X
$num
ØØY ]
)
ØØ] ^
}
ØØd e
,
ØØe f
{
∞∞ 
$str
∞∞ 
,
∞∞ 
CIELabFromRGB
∞∞< I
(
∞∞I J
$num
∞∞J M
,
∞∞M N
$num
∞∞O R
,
∞∞R S
$num
∞∞T W
,
∞∞W X
$num
∞∞Y ]
)
∞∞] ^
}
∞∞d e
,
∞∞e f
{
±± 
$str
±± 
,
±±  
CIELabFromRGB
±±< I
(
±±I J
$num
±±J L
,
±±L M
$num
±±N Q
,
±±Q R
$num
±±S V
,
±±V W
$num
±±X \
)
±±\ ]
}
±±d e
,
±±e f
{
≤≤ 
$str
≤≤ 
,
≤≤ 
CIELabFromRGB
≤≤< I
(
≤≤I J
$num
≤≤J L
,
≤≤L M
$num
≤≤N Q
,
≤≤Q R
$num
≤≤S V
,
≤≤V W
$num
≤≤X \
)
≤≤\ ]
}
≤≤d e
,
≤≤e f
{
≥≥ 
$str
≥≥ 
,
≥≥ 
CIELabFromRGB
≥≥< I
(
≥≥I J
$num
≥≥J M
,
≥≥M N
$num
≥≥O R
,
≥≥R S
$num
≥≥T W
,
≥≥W X
$num
≥≥Y ]
)
≥≥] ^
}
≥≥d e
,
≥≥e f
{
¥¥ 
$str
¥¥ 
,
¥¥ 
CIELabFromRGB
¥¥< I
(
¥¥I J
$num
¥¥J M
,
¥¥M N
$num
¥¥O R
,
¥¥R S
$num
¥¥T W
,
¥¥W X
$num
¥¥Y ]
)
¥¥] ^
}
¥¥d e
,
¥¥e f
{
µµ 
$str
µµ 
,
µµ 
CIELabFromRGB
µµ< I
(
µµI J
$num
µµJ M
,
µµM N
$num
µµO R
,
µµR S
$num
µµT W
,
µµW X
$num
µµY ]
)
µµ] ^
}
µµd e
,
µµe f
{
∂∂ 
$str
∂∂ 
,
∂∂ 
CIELabFromRGB
∂∂< I
(
∂∂I J
$num
∂∂J M
,
∂∂M N
$num
∂∂O R
,
∂∂R S
$num
∂∂T W
,
∂∂W X
$num
∂∂Y ]
)
∂∂] ^
}
∂∂d e
,
∂∂e f
{
∑∑ 
$str
∑∑ 
,
∑∑ 
CIELabFromRGB
∑∑< I
(
∑∑I J
$num
∑∑J L
,
∑∑L M
$num
∑∑N Q
,
∑∑Q R
$num
∑∑S V
,
∑∑V W
$num
∑∑X \
)
∑∑\ ]
}
∑∑d e
,
∑∑e f
{
∏∏ 
$str
∏∏ 
,
∏∏ 
CIELabFromRGB
∏∏< I
(
∏∏I J
$num
∏∏J M
,
∏∏M N
$num
∏∏O R
,
∏∏R S
$num
∏∏T W
,
∏∏W X
$num
∏∏Y ]
)
∏∏] ^
}
∏∏d e
,
∏∏e f
{
ππ 
$str
ππ 
,
ππ 
CIELabFromRGB
ππ< I
(
ππI J
$num
ππJ M
,
ππM N
$num
ππO S
,
ππS T
$num
ππU Y
,
ππY Z
$num
ππ[ _
)
ππ_ `
}
ππd e
,
ππe f
{
∫∫ 
$str
∫∫ 
,
∫∫ 
CIELabFromRGB
∫∫< I
(
∫∫I J
$num
∫∫J M
,
∫∫M N
$num
∫∫O R
,
∫∫R S
$num
∫∫T W
,
∫∫W X
$num
∫∫Y ]
)
∫∫] ^
}
∫∫d e
,
∫∫e f
{
ªª 
$str
ªª 
,
ªª 
CIELabFromRGB
ªª< I
(
ªªI J
$num
ªªJ M
,
ªªM N
$num
ªªO R
,
ªªR S
$num
ªªT W
,
ªªW X
$num
ªªY ]
)
ªª] ^
}
ªªd e
,
ªªe f
{
ºº 
$str
ºº 
,
ºº 
CIELabFromRGB
ºº< I
(
ººI J
$num
ººJ M
,
ººM N
$num
ººO R
,
ººR S
$num
ººT W
,
ººW X
$num
ººY ]
)
ºº] ^
}
ººd e
,
ººe f
{
ΩΩ 
$str
ΩΩ 
,
ΩΩ 
CIELabFromRGB
ΩΩ< I
(
ΩΩI J
$num
ΩΩJ L
,
ΩΩL M
$num
ΩΩN Q
,
ΩΩQ R
$num
ΩΩS V
,
ΩΩV W
$num
ΩΩX \
)
ΩΩ\ ]
}
ΩΩd e
,
ΩΩe f
{
ææ 
$str
ææ 
,
ææ 
CIELabFromRGB
ææ< I
(
ææI J
$num
ææJ M
,
ææM N
$num
ææO R
,
ææR S
$num
ææT W
,
ææW X
$num
ææY ]
)
ææ] ^
}
ææd e
,
ææe f
{
øø 
$str
øø 
,
øø 
CIELabFromRGB
øø< I
(
øøI J
$num
øøJ M
,
øøM N
$num
øøO R
,
øøR S
$num
øøT W
,
øøW X
$num
øøY ]
)
øø] ^
}
øød e
,
øøe f
{
¿¿ 
$str
¿¿ 
,
¿¿ 
CIELabFromRGB
¿¿< I
(
¿¿I J
$num
¿¿J L
,
¿¿L M
$num
¿¿N Q
,
¿¿Q R
$num
¿¿S V
,
¿¿V W
$num
¿¿X \
)
¿¿\ ]
}
¿¿d e
,
¿¿e f
{
¡¡ 
$str
¡¡ 
,
¡¡ 
CIELabFromRGB
¡¡< I
(
¡¡I J
$num
¡¡J M
,
¡¡M N
$num
¡¡O R
,
¡¡R S
$num
¡¡T W
,
¡¡W X
$num
¡¡Y ]
)
¡¡] ^
}
¡¡d e
,
¡¡e f
{
¬¬ 
$str
¬¬ 
,
¬¬ 
CIELabFromRGB
¬¬< I
(
¬¬I J
$num
¬¬J M
,
¬¬M N
$num
¬¬O R
,
¬¬R S
$num
¬¬T W
,
¬¬W X
$num
¬¬Y ]
)
¬¬] ^
}
¬¬d e
,
¬¬e f
{
√√ 
$str
√√ 
,
√√ 
CIELabFromRGB
√√< I
(
√√I J
$num
√√J M
,
√√M N
$num
√√O R
,
√√R S
$num
√√T W
,
√√W X
$num
√√Y ]
)
√√] ^
}
√√d e
,
√√e f
{
ƒƒ 
$str
ƒƒ 
,
ƒƒ 
CIELabFromRGB
ƒƒ< I
(
ƒƒI J
$num
ƒƒJ M
,
ƒƒM N
$num
ƒƒO R
,
ƒƒR S
$num
ƒƒT W
,
ƒƒW X
$num
ƒƒY ]
)
ƒƒ] ^
}
ƒƒd e
,
ƒƒe f
{
≈≈ 
$str
≈≈  
,
≈≈  !
CIELabFromRGB
≈≈< I
(
≈≈I J
$num
≈≈J M
,
≈≈M N
$num
≈≈O R
,
≈≈R S
$num
≈≈T W
,
≈≈W X
$num
≈≈Y ]
)
≈≈] ^
}
≈≈d e
,
≈≈e f
{
∆∆ 
$str
∆∆ 
,
∆∆ 
CIELabFromRGB
∆∆< I
(
∆∆I J
$num
∆∆J M
,
∆∆M N
$num
∆∆O R
,
∆∆R S
$num
∆∆T W
,
∆∆W X
$num
∆∆Y ]
)
∆∆] ^
}
∆∆d e
,
∆∆e f
{
«« 
$str
«« (
,
««( )
CIELabFromRGB
««< I
(
««I J
$num
««J M
,
««M N
$num
««O S
,
««S T
$num
««U W
,
««W X
$num
««Y ]
)
««] ^
}
««d e
,
««e f
{
»» 
$str
»»  
,
»»  !
CIELabFromRGB
»»< I
(
»»I J
$num
»»J M
,
»»M N
$num
»»O S
,
»»S T
$num
»»U W
,
»»W X
$num
»»Y ]
)
»»] ^
}
»»d e
,
»»e f
{
…… 
$str
…… 
,
…… 
CIELabFromRGB
……< I
(
……I J
$num
……J M
,
……M N
$num
……O R
,
……R S
$num
……T W
,
……W X
$num
……Y ]
)
……] ^
}
……d e
,
……e f
{
   
$str
   #
,
  # $
CIELabFromRGB
  < I
(
  I J
$num
  J N
,
  N O
$num
  P S
,
  S T
$num
  U X
,
  X Y
$num
  Z ^
)
  ^ _
}
  d e
,
  e f
{
ÀÀ 
$str
ÀÀ 
,
ÀÀ 
CIELabFromRGB
ÀÀ< I
(
ÀÀI J
$num
ÀÀJ M
,
ÀÀM N
$num
ÀÀO R
,
ÀÀR S
$num
ÀÀT W
,
ÀÀW X
$num
ÀÀY ]
)
ÀÀ] ^
}
ÀÀd e
,
ÀÀe f
{
ÃÃ 
$str
ÃÃ 
,
ÃÃ 
CIELabFromRGB
ÃÃ< I
(
ÃÃI J
$num
ÃÃJ M
,
ÃÃM N
$num
ÃÃO R
,
ÃÃR S
$num
ÃÃT W
,
ÃÃW X
$num
ÃÃY ]
)
ÃÃ] ^
}
ÃÃd e
,
ÃÃe f
{
ÕÕ 
$str
ÕÕ 
,
ÕÕ 
CIELabFromRGB
ÕÕ< I
(
ÕÕI J
$num
ÕÕJ M
,
ÕÕM N
$num
ÕÕO R
,
ÕÕR S
$num
ÕÕT W
,
ÕÕW X
$num
ÕÕY ]
)
ÕÕ] ^
}
ÕÕd e
,
ÕÕe f
{
ŒŒ 
$str
ŒŒ 
,
ŒŒ 
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ M
,
ŒŒM N
$num
ŒŒO R
,
ŒŒR S
$num
ŒŒT W
,
ŒŒW X
$num
ŒŒY ]
)
ŒŒ] ^
}
ŒŒd e
,
ŒŒe f
{
œœ 
$str
œœ 
,
œœ 
CIELabFromRGB
œœ< I
(
œœI J
$num
œœJ M
,
œœM N
$num
œœO R
,
œœR S
$num
œœT W
,
œœW X
$num
œœY ]
)
œœ] ^
}
œœd e
,
œœe f
{
–– 
$str
–– '
,
––' (
CIELabFromRGB
––< I
(
––I J
$num
––J M
,
––M N
$num
––O R
,
––R S
$num
––T V
,
––V W
$num
––X \
)
––\ ]
}
––d e
,
––e f
{
—— 
$str
—— 
,
——  
CIELabFromRGB
——< I
(
——I J
$num
——J M
,
——M N
$num
——O R
,
——R S
$num
——T W
,
——W X
$num
——Y ]
)
——] ^
}
——d e
,
——e f
{
““ 
$str
““ 
,
““ 
CIELabFromRGB
““< I
(
““I J
$num
““J N
,
““N O
$num
““P S
,
““S T
$num
““U W
,
““W X
$num
““Y ]
)
““] ^
}
““d e
,
““e f
{
”” 
$str
”” 
,
”” 
CIELabFromRGB
””< I
(
””I J
$num
””J M
,
””M N
$num
””O R
,
””R S
$num
””T W
,
””W X
$num
””Y ]
)
””] ^
}
””d e
,
””e f
{
‘‘ 
$str
‘‘ 
,
‘‘ 
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J M
,
‘‘M N
$num
‘‘O R
,
‘‘R S
$num
‘‘T W
,
‘‘W X
$num
‘‘Y ]
)
‘‘] ^
}
‘‘d e
,
‘‘e f
{
’’ 
$str
’’ 
,
’’ 
CIELabFromRGB
’’< I
(
’’I J
$num
’’J M
,
’’M N
$num
’’O R
,
’’R S
$num
’’T W
,
’’W X
$num
’’Y ]
)
’’] ^
}
’’d e
,
’’e f
{
÷÷ 
$str
÷÷ 
,
÷÷ 
CIELabFromRGB
÷÷< I
(
÷÷I J
$num
÷÷J M
,
÷÷M N
$num
÷÷O R
,
÷÷R S
$num
÷÷T V
,
÷÷V W
$num
÷÷X \
)
÷÷\ ]
}
÷÷d e
,
÷÷e f
{
◊◊ 
$str
◊◊ 
,
◊◊ 
CIELabFromRGB
◊◊< I
(
◊◊I J
$num
◊◊J M
,
◊◊M N
$num
◊◊O R
,
◊◊R S
$num
◊◊T W
,
◊◊W X
$num
◊◊Y ]
)
◊◊] ^
}
◊◊d e
,
◊◊e f
{
ÿÿ 
$str
ÿÿ 
,
ÿÿ 
CIELabFromRGB
ÿÿ< I
(
ÿÿI J
$num
ÿÿJ M
,
ÿÿM N
$num
ÿÿO Q
,
ÿÿQ R
$num
ÿÿS V
,
ÿÿV W
$num
ÿÿX \
)
ÿÿ\ ]
}
ÿÿd e
,
ÿÿe f
{
ŸŸ 
$str
ŸŸ 
,
ŸŸ 
CIELabFromRGB
ŸŸ< I
(
ŸŸI J
$num
ŸŸJ M
,
ŸŸM N
$num
ŸŸO R
,
ŸŸR S
$num
ŸŸT W
,
ŸŸW X
$num
ŸŸY ]
)
ŸŸ] ^
}
ŸŸd e
,
ŸŸe f
{
⁄⁄ 
$str
⁄⁄ 
,
⁄⁄ 
CIELabFromRGB
⁄⁄< I
(
⁄⁄I J
$num
⁄⁄J L
,
⁄⁄L M
$num
⁄⁄N Q
,
⁄⁄Q R
$num
⁄⁄S V
,
⁄⁄V W
$num
⁄⁄X \
)
⁄⁄\ ]
}
⁄⁄d e
,
⁄⁄e f
{
€€ 
$str
€€ 
,
€€ 
CIELabFromRGB
€€< I
(
€€I J
$num
€€J M
,
€€M N
$num
€€O R
,
€€R S
$num
€€T W
,
€€W X
$num
€€Y ]
)
€€] ^
}
€€d e
,
€€e f
{
‹‹ 
$str
‹‹ 
,
‹‹ 
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J M
,
‹‹M N
$num
‹‹O R
,
‹‹R S
$num
‹‹T W
,
‹‹W X
$num
‹‹Y ]
)
‹‹] ^
}
‹‹d e
,
‹‹e f
{
›› 
$str
›› 
,
›› 
CIELabFromRGB
››< I
(
››I J
$num
››J M
,
››M N
$num
››O R
,
››R S
$num
››T W
,
››W X
$num
››Y ]
)
››] ^
}
››d e
,
››e f
{
ﬁﬁ 
$str
ﬁﬁ 
,
ﬁﬁ 
CIELabFromRGB
ﬁﬁ< I
(
ﬁﬁI J
$num
ﬁﬁJ M
,
ﬁﬁM N
$num
ﬁﬁO R
,
ﬁﬁR S
$num
ﬁﬁT W
,
ﬁﬁW X
$num
ﬁﬁY ]
)
ﬁﬁ] ^
}
ﬁﬁd e
,
ﬁﬁe f
{
ﬂﬂ 
$str
ﬂﬂ 
,
ﬂﬂ 
CIELabFromRGB
ﬂﬂ< I
(
ﬂﬂI J
$num
ﬂﬂJ M
,
ﬂﬂM N
$num
ﬂﬂO R
,
ﬂﬂR S
$num
ﬂﬂT W
,
ﬂﬂW X
$num
ﬂﬂY ]
)
ﬂﬂ] ^
}
ﬂﬂd e
,
ﬂﬂe f
{
‡‡ 
$str
‡‡ 
,
‡‡ 
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J L
,
‡‡L M
$num
‡‡N Q
,
‡‡Q R
$num
‡‡S V
,
‡‡V W
$num
‡‡X \
)
‡‡\ ]
}
‡‡d e
,
‡‡e f
{
·· 
$str
·· 
,
·· 
CIELabFromRGB
··< I
(
··I J
$num
··J M
,
··M N
$num
··O R
,
··R S
$num
··T W
,
··W X
$num
··Y ]
)
··] ^
}
··d e
,
··e f
{
‚‚ 
$str
‚‚ 
,
‚‚ 
CIELabFromRGB
‚‚< I
(
‚‚I J
$num
‚‚J M
,
‚‚M N
$num
‚‚O R
,
‚‚R S
$num
‚‚T W
,
‚‚W X
$num
‚‚Y ]
)
‚‚] ^
}
‚‚d e
,
‚‚e f
{
„„ 
$str
„„  
,
„„  !
CIELabFromRGB
„„< I
(
„„I J
$num
„„J M
,
„„M N
$num
„„O R
,
„„R S
$num
„„T W
,
„„W X
$num
„„Y ]
)
„„] ^
}
„„d e
,
„„e f
{
‰‰ 
$str
‰‰ 
,
‰‰ 
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J M
,
‰‰M N
$num
‰‰O R
,
‰‰R S
$num
‰‰T W
,
‰‰W X
$num
‰‰Y ]
)
‰‰] ^
}
‰‰d e
,
‰‰e f
{
ÂÂ 
$str
ÂÂ 
,
ÂÂ 
CIELabFromRGB
ÂÂ< I
(
ÂÂI J
$num
ÂÂJ M
,
ÂÂM N
$num
ÂÂO R
,
ÂÂR S
$num
ÂÂT W
,
ÂÂW X
$num
ÂÂY ]
)
ÂÂ] ^
}
ÂÂd e
,
ÂÂe f
{
ÊÊ 
$str
ÊÊ 
,
ÊÊ 
CIELabFromRGB
ÊÊ< I
(
ÊÊI J
$num
ÊÊJ M
,
ÊÊM N
$num
ÊÊO R
,
ÊÊR S
$num
ÊÊT W
,
ÊÊW X
$num
ÊÊY ]
)
ÊÊ] ^
}
ÊÊd e
,
ÊÊe f
{
ÁÁ 
$str
ÁÁ 
,
ÁÁ 
CIELabFromRGB
ÁÁ< I
(
ÁÁI J
$num
ÁÁJ N
,
ÁÁN O
$num
ÁÁP S
,
ÁÁS T
$num
ÁÁU W
,
ÁÁW X
$num
ÁÁY ]
)
ÁÁ] ^
}
ÁÁd e
,
ÁÁe f
{
ËË 
$str
ËË 
,
ËË 
CIELabFromRGB
ËË< I
(
ËËI J
$num
ËËJ N
,
ËËN O
$num
ËËP S
,
ËËS T
$num
ËËU X
,
ËËX Y
$num
ËËZ ^
)
ËË^ _
}
ËËd e
,
ËËe f
{
ÈÈ 
$str
ÈÈ 
,
ÈÈ 
CIELabFromRGB
ÈÈ< I
(
ÈÈI J
$num
ÈÈJ M
,
ÈÈM N
$num
ÈÈO R
,
ÈÈR S
$num
ÈÈT W
,
ÈÈW X
$num
ÈÈY ]
)
ÈÈ] ^
}
ÈÈd e
,
ÈÈe f
{
ÍÍ 
$str
ÍÍ 
,
ÍÍ 
CIELabFromRGB
ÍÍ< I
(
ÍÍI J
$num
ÍÍJ N
,
ÍÍN O
$num
ÍÍP S
,
ÍÍS T
$num
ÍÍU X
,
ÍÍX Y
$num
ÍÍZ ^
)
ÍÍ^ _
}
ÍÍd e
,
ÍÍe f
{
ÎÎ 
$str
ÎÎ 
,
ÎÎ 
CIELabFromRGB
ÎÎ< I
(
ÎÎI J
$num
ÎÎJ M
,
ÎÎM N
$num
ÎÎO R
,
ÎÎR S
$num
ÎÎT W
,
ÎÎW X
$num
ÎÎY ]
)
ÎÎ] ^
}
ÎÎd e
,
ÎÎe f
{
ÏÏ 
$str
ÏÏ 
,
ÏÏ 
CIELabFromRGB
ÏÏ< I
(
ÏÏI J
$num
ÏÏJ M
,
ÏÏM N
$num
ÏÏO R
,
ÏÏR S
$num
ÏÏT W
,
ÏÏW X
$num
ÏÏY ]
)
ÏÏ] ^
}
ÏÏd e
,
ÏÏe f
{
ÌÌ 
$str
ÌÌ 
,
ÌÌ 
CIELabFromRGB
ÌÌ< I
(
ÌÌI J
$num
ÌÌJ M
,
ÌÌM N
$num
ÌÌO R
,
ÌÌR S
$num
ÌÌT W
,
ÌÌW X
$num
ÌÌY ]
)
ÌÌ] ^
}
ÌÌd e
,
ÌÌe f
{
ÓÓ 
$str
ÓÓ 
,
ÓÓ  
CIELabFromRGB
ÓÓ< I
(
ÓÓI J
$num
ÓÓJ M
,
ÓÓM N
$num
ÓÓO R
,
ÓÓR S
$num
ÓÓT W
,
ÓÓW X
$num
ÓÓY ]
)
ÓÓ] ^
}
ÓÓd e
,
ÓÓe f
{
ÔÔ 
$str
ÔÔ 
,
ÔÔ 
CIELabFromRGB
ÔÔ< I
(
ÔÔI J
$num
ÔÔJ N
,
ÔÔN O
$num
ÔÔP S
,
ÔÔS T
$num
ÔÔU X
,
ÔÔX Y
$num
ÔÔZ ^
)
ÔÔ^ _
}
ÔÔd e
,
ÔÔe f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J N
,
N O
$num
P S
,
S T
$num
U X
,
X Y
$num
Z ^
)
^ _
}
d e
,
e f
{
ÒÒ 
$str
ÒÒ 
,
ÒÒ 
CIELabFromRGB
ÒÒ< I
(
ÒÒI J
$num
ÒÒJ M
,
ÒÒM N
$num
ÒÒO R
,
ÒÒR S
$num
ÒÒT W
,
ÒÒW X
$num
ÒÒY ]
)
ÒÒ] ^
}
ÒÒd e
,
ÒÒe f
{
ÚÚ 
$str
ÚÚ 
,
ÚÚ 
CIELabFromRGB
ÚÚ< I
(
ÚÚI J
$num
ÚÚJ N
,
ÚÚN O
$num
ÚÚP S
,
ÚÚS T
$num
ÚÚU X
,
ÚÚX Y
$num
ÚÚZ ^
)
ÚÚ^ _
}
ÚÚd e
,
ÚÚe f
{
ÛÛ 
$str
ÛÛ 
,
ÛÛ 
CIELabFromRGB
ÛÛ< I
(
ÛÛI J
$num
ÛÛJ N
,
ÛÛN O
$num
ÛÛP S
,
ÛÛS T
$num
ÛÛU X
,
ÛÛX Y
$num
ÛÛZ ^
)
ÛÛ^ _
}
ÛÛd e
,
ÛÛe f
{
ÙÙ 
$str
ÙÙ 
,
ÙÙ 
CIELabFromRGB
ÙÙ< I
(
ÙÙI J
$num
ÙÙJ M
,
ÙÙM N
$num
ÙÙO Q
,
ÙÙQ R
$num
ÙÙS V
,
ÙÙV W
$num
ÙÙX \
)
ÙÙ\ ]
}
ÙÙd e
,
ÙÙe f
{
ıı 
$str
ıı 
,
ıı 
CIELabFromRGB
ıı< I
(
ııI J
$num
ııJ M
,
ııM N
$num
ııO Q
,
ııQ R
$num
ııS V
,
ııV W
$num
ııX \
)
ıı\ ]
}
ııd e
,
ııe f
{
ˆˆ 
$str
ˆˆ 
,
ˆˆ 
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ M
,
ˆˆM N
$num
ˆˆO Q
,
ˆˆQ R
$num
ˆˆS U
,
ˆˆU V
$num
ˆˆW [
)
ˆˆ[ \
}
ˆˆd e
,
ˆˆe f
{
˜˜ 
$str
˜˜ 
,
˜˜ 
CIELabFromRGB
˜˜< I
(
˜˜I J
$num
˜˜J L
,
˜˜L M
$num
˜˜N R
,
˜˜R S
$num
˜˜T X
,
˜˜X Y
$num
˜˜Z ^
)
˜˜^ _
}
˜˜d e
,
˜˜e f
{
¯¯ 
$str
¯¯ 
,
¯¯ 
CIELabFromRGB
¯¯< I
(
¯¯I J
$num
¯¯J M
,
¯¯M N
$num
¯¯O R
,
¯¯R S
$num
¯¯T W
,
¯¯W X
$num
¯¯Y ]
)
¯¯] ^
}
¯¯d e
,
¯¯e f
{
˘˘ 
$str
˘˘ 
,
˘˘  
CIELabFromRGB
˘˘< I
(
˘˘I J
$num
˘˘J M
,
˘˘M N
$num
˘˘O R
,
˘˘R S
$num
˘˘T W
,
˘˘W X
$num
˘˘Y ]
)
˘˘] ^
}
˘˘d e
,
˘˘e f
{
˙˙ 
$str
˙˙  
,
˙˙  !
CIELabFromRGB
˙˙< I
(
˙˙I J
$num
˙˙J M
,
˙˙M N
$num
˙˙O R
,
˙˙R S
$num
˙˙T W
,
˙˙W X
$num
˙˙Y ]
)
˙˙] ^
}
˙˙d e
,
˙˙e f
{
˚˚ 
$str
˚˚ $
,
˚˚$ %
CIELabFromRGB
˚˚< I
(
˚˚I J
$num
˚˚J L
,
˚˚L M
$num
˚˚N Q
,
˚˚Q R
$num
˚˚S V
,
˚˚V W
$num
˚˚X \
)
˚˚\ ]
}
˚˚d e
,
˚˚e f
{
¸¸ 
$str
¸¸ 
,
¸¸ 
CIELabFromRGB
¸¸< I
(
¸¸I J
$num
¸¸J L
,
¸¸L M
$num
¸¸N Q
,
¸¸Q R
$num
¸¸S V
,
¸¸V W
$num
¸¸X \
)
¸¸\ ]
}
¸¸d e
,
¸¸e f
{
˝˝ 
$str
˝˝ 
,
˝˝ 
CIELabFromRGB
˝˝< I
(
˝˝I J
$num
˝˝J M
,
˝˝M N
$num
˝˝O R
,
˝˝R S
$num
˝˝T W
,
˝˝W X
$num
˝˝Y ]
)
˝˝] ^
}
˝˝d e
,
˝˝e f
{
˛˛ 
$str
˛˛ 
,
˛˛ 
CIELabFromRGB
˛˛< I
(
˛˛I J
$num
˛˛J N
,
˛˛N O
$num
˛˛P S
,
˛˛S T
$num
˛˛U W
,
˛˛W X
$num
˛˛Y ]
)
˛˛] ^
}
˛˛d e
,
˛˛e f
{
ˇˇ 
$str
ˇˇ 
,
ˇˇ 
CIELabFromRGB
ˇˇ< I
(
ˇˇI J
$num
ˇˇJ N
,
ˇˇN O
$num
ˇˇP T
,
ˇˇT U
$num
ˇˇV Y
,
ˇˇY Z
$num
ˇˇ[ _
)
ˇˇ_ `
}
ˇˇd e
,
ˇˇe f
{
ÄÄ 
$str
ÄÄ 
,
ÄÄ 
CIELabFromRGB
ÄÄ< I
(
ÄÄI J
$num
ÄÄJ M
,
ÄÄM N
$num
ÄÄO R
,
ÄÄR S
$num
ÄÄT W
,
ÄÄW X
$num
ÄÄY ]
)
ÄÄ] ^
}
ÄÄd e
,
ÄÄe f
{
ÅÅ 
$str
ÅÅ 
,
ÅÅ 
CIELabFromRGB
ÅÅ< I
(
ÅÅI J
$num
ÅÅJ L
,
ÅÅL M
$num
ÅÅN P
,
ÅÅP Q
$num
ÅÅR U
,
ÅÅU V
$num
ÅÅW [
)
ÅÅ[ \
}
ÅÅd e
,
ÅÅe f
{
ÇÇ 
$str
ÇÇ 
,
ÇÇ 
CIELabFromRGB
ÇÇ< I
(
ÇÇI J
$num
ÇÇJ M
,
ÇÇM N
$num
ÇÇO R
,
ÇÇR S
$num
ÇÇT W
,
ÇÇW X
$num
ÇÇY ]
)
ÇÇ] ^
}
ÇÇd e
,
ÇÇe f
{
ÉÉ 
$str
ÉÉ 
,
ÉÉ 
CIELabFromRGB
ÉÉ< I
(
ÉÉI J
$num
ÉÉJ M
,
ÉÉM N
$num
ÉÉO R
,
ÉÉR S
$num
ÉÉT W
,
ÉÉW X
$num
ÉÉY ]
)
ÉÉ] ^
}
ÉÉd e
,
ÉÉe f
{
ÑÑ 
$str
ÑÑ "
,
ÑÑ" #
CIELabFromRGB
ÑÑ< I
(
ÑÑI J
$num
ÑÑJ M
,
ÑÑM N
$num
ÑÑO R
,
ÑÑR S
$num
ÑÑT W
,
ÑÑW X
$num
ÑÑY ]
)
ÑÑ] ^
}
ÑÑd e
,
ÑÑe f
{
ÖÖ 
$str
ÖÖ 
,
ÖÖ 
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ M
,
ÖÖM N
$num
ÖÖO R
,
ÖÖR S
$num
ÖÖT W
,
ÖÖW X
$num
ÖÖY ]
)
ÖÖ] ^
}
ÖÖd e
,
ÖÖe f
{
ÜÜ 
$str
ÜÜ $
,
ÜÜ$ %
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ M
,
ÜÜM N
$num
ÜÜO Q
,
ÜÜQ R
$num
ÜÜS U
,
ÜÜU V
$num
ÜÜW [
)
ÜÜ[ \
}
ÜÜd e
,
ÜÜe f
{
áá 
$str
áá 
,
áá 
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ L
,
ááL M
$num
ááN Q
,
ááQ R
$num
ááS V
,
ááV W
$num
ááX \
)
áá\ ]
}
áád e
,
ááe f
{
àà 
$str
àà 
,
àà 
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ M
,
ààM N
$num
ààO R
,
ààR S
$num
ààT W
,
ààW X
$num
ààY ]
)
àà] ^
}
ààd e
,
ààe f
{
ââ 
$str
ââ 
,
ââ 
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ M
,
ââM N
$num
ââO R
,
ââR S
$num
ââT W
,
ââW X
$num
ââY ]
)
ââ] ^
}
ââd e
,
ââe f
{
ää 
$str
ää 
,
ää 
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ L
,
ääL M
$num
ääN Q
,
ääQ R
$num
ääS V
,
ääV W
$num
ääX \
)
ää\ ]
}
ääd e
,
ääe f
{
ãã 
$str
ãã "
,
ãã" #
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ M
,
ããM N
$num
ããO R
,
ããR S
$num
ããT W
,
ããW X
$num
ããY ]
)
ãã] ^
}
ããd e
,
ããe f
{
åå 
$str
åå 
,
åå 
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ M
,
ååM N
$num
ååO R
,
ååR S
$num
ååT V
,
ååV W
$num
ååX \
)
åå\ ]
}
ååd e
,
ååe f
{
çç 
$str
çç 
,
çç  
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ M
,
ççM N
$num
ççO R
,
ççR S
$num
ççT W
,
ççW X
$num
ççY ]
)
çç] ^
}
ççd e
,
ççe f
{
éé 
$str
éé 
,
éé 
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ L
,
ééL M
$num
ééN Q
,
ééQ R
$num
ééS V
,
ééV W
$num
ééX \
)
éé\ ]
}
ééd e
,
éée f
{
èè 
$str
èè  
,
èè  !
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ L
,
èèL M
$num
èèN Q
,
èèQ R
$num
èèS U
,
èèU V
$num
èèW [
)
èè[ \
}
èèd e
,
èèe f
{
êê 
$str
êê "
,
êê" #
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ L
,
êêL M
$num
êêN Q
,
êêQ R
$num
êêS V
,
êêV W
$num
êêX \
)
êê\ ]
}
êêd e
,
êêe f
{
ëë 
$str
ëë %
,
ëë% &
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ L
,
ëëL M
$num
ëëN P
,
ëëP Q
$num
ëëR U
,
ëëU V
$num
ëëW [
)
ëë[ \
}
ëëd e
,
ëëe f
{
íí 
$str
íí !
,
íí! "
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ M
,
ííM N
$num
ííO R
,
ííR S
$num
ííT W
,
ííW X
$num
ííY ]
)
íí] ^
}
ííd e
,
ííe f
{
ìì 
$str
ìì 
,
ìì 
CIELabFromRGB
ìì< I
(
ììI J
$num
ììJ M
,
ììM N
$num
ììO R
,
ììR S
$num
ììT W
,
ììW X
$num
ììY ]
)
ìì] ^
}
ììd e
,
ììe f
{
îî 
$str
îî 
,
îî 
CIELabFromRGB
îî< I
(
îîI J
$num
îîJ M
,
îîM N
$num
îîO R
,
îîR S
$num
îîT W
,
îîW X
$num
îîY ]
)
îî] ^
}
îîd e
,
îîe f
{
ïï 
$str
ïï 
,
ïï 
CIELabFromRGB
ïï< I
(
ïïI J
$num
ïïJ M
,
ïïM N
$num
ïïO R
,
ïïR S
$num
ïïT W
,
ïïW X
$num
ïïY ]
)
ïï] ^
}
ïïd e
,
ïïe f
{
ññ 
$str
ññ 
,
ññ 
CIELabFromRGB
ññ< I
(
ññI J
$num
ññJ M
,
ññM N
$num
ññO R
,
ññR S
$num
ññT W
,
ññW X
$num
ññY ]
)
ññ] ^
}
ññd e
,
ññe f
{
óó 
$str
óó #
,
óó# $
CIELabFromRGB
óó< I
(
óóI J
$num
óóJ M
,
óóM N
$num
óóO R
,
óóR S
$num
óóT W
,
óóW X
$num
óóY ]
)
óó] ^
}
óód e
,
óóe f
{
òò 
$str
òò 
,
òò 
CIELabFromRGB
òò< I
(
òòI J
$num
òòJ M
,
òòM N
$num
òòO Q
,
òòQ R
$num
òòS V
,
òòV W
$num
òòX \
)
òò\ ]
}
òòd e
,
òòe f
{
ôô 
$str
ôô  
,
ôô  !
CIELabFromRGB
ôô< I
(
ôôI J
$num
ôôJ M
,
ôôM N
$num
ôôO R
,
ôôR S
$num
ôôT W
,
ôôW X
$num
ôôY ]
)
ôô] ^
}
ôôd e
,
ôôe f
{
öö 
$str
öö "
,
öö" #
CIELabFromRGB
öö< I
(
ööI J
$num
ööJ L
,
ööL M
$num
ööN Q
,
ööQ R
$num
ööS V
,
ööV W
$num
ööX \
)
öö\ ]
}
ööd e
,
ööe f
{
õõ 
$str
õõ 
,
õõ  
CIELabFromRGB
õõ< I
(
õõI J
$num
õõJ M
,
õõM N
$num
õõO R
,
õõR S
$num
õõT W
,
õõW X
$num
õõY ]
)
õõ] ^
}
õõd e
,
õõe f
{
úú 
$str
úú  
,
úú  !
CIELabFromRGB
úú< I
(
úúI J
$num
úúJ M
,
úúM N
$num
úúO R
,
úúR S
$num
úúT W
,
úúW X
$num
úúY ]
)
úú] ^
}
úúd e
,
úúe f
{
ùù 
$str
ùù 
,
ùù 
CIELabFromRGB
ùù< I
(
ùùI J
$num
ùùJ N
,
ùùN O
$num
ùùP S
,
ùùS T
$num
ùùU W
,
ùùW X
$num
ùùY ]
)
ùù] ^
}
ùùd e
,
ùùe f
{
ûû 
$str
ûû 
,
ûû 
CIELabFromRGB
ûû< I
(
ûûI J
$num
ûûJ M
,
ûûM N
$num
ûûO R
,
ûûR S
$num
ûûT W
,
ûûW X
$num
ûûY ]
)
ûû] ^
}
ûûd e
,
ûûe f
{
üü 
$str
üü  
,
üü  !
CIELabFromRGB
üü< I
(
üüI J
$num
üüJ M
,
üüM N
$num
üüO R
,
üüR S
$num
üüT W
,
üüW X
$num
üüY ]
)
üü] ^
}
üüd e
,
üüe f
{
†† 
$str
†† !
,
††! "
CIELabFromRGB
††< I
(
††I J
$num
††J L
,
††L M
$num
††N Q
,
††Q R
$num
††S V
,
††V W
$num
††X \
)
††\ ]
}
††d e
,
††e f
{
°° 
$str
°° "
,
°°" #
CIELabFromRGB
°°< I
(
°°I J
$num
°°J M
,
°°M N
$num
°°O R
,
°°R S
$num
°°T W
,
°°W X
$num
°°Y ]
)
°°] ^
}
°°d e
,
°°e f
{
¢¢ 
$str
¢¢ 
,
¢¢  
CIELabFromRGB
¢¢< I
(
¢¢I J
$num
¢¢J M
,
¢¢M N
$num
¢¢O R
,
¢¢R S
$num
¢¢T W
,
¢¢W X
$num
¢¢Y ]
)
¢¢] ^
}
¢¢d e
,
¢¢e f
{
££ 
$str
££ 
,
££ 
CIELabFromRGB
££< I
(
££I J
$num
££J M
,
££M N
$num
££O R
,
££R S
$num
££T W
,
££W X
$num
££Y ]
)
££] ^
}
££d e
,
££e f
{
§§ 
$str
§§  
,
§§  !
CIELabFromRGB
§§< I
(
§§I J
$num
§§J L
,
§§L M
$num
§§N Q
,
§§Q R
$num
§§S V
,
§§V W
$num
§§X \
)
§§\ ]
}
§§d e
,
§§e f
{
•• 
$str
•• 
,
•• 
CIELabFromRGB
••< I
(
••I J
$num
••J M
,
••M N
$num
••O R
,
••R S
$num
••T W
,
••W X
$num
••Y ]
)
••] ^
}
••d e
,
••e f
{
¶¶ 
$str
¶¶ 
,
¶¶ 
CIELabFromRGB
¶¶< I
(
¶¶I J
$num
¶¶J M
,
¶¶M N
$num
¶¶O R
,
¶¶R S
$num
¶¶T W
,
¶¶W X
$num
¶¶Y ]
)
¶¶] ^
}
¶¶d e
,
¶¶e f
{
ßß 
$str
ßß 
,
ßß 
CIELabFromRGB
ßß< I
(
ßßI J
$num
ßßJ M
,
ßßM N
$num
ßßO R
,
ßßR S
$num
ßßT W
,
ßßW X
$num
ßßY ]
)
ßß] ^
}
ßßd e
,
ßße f
{
®® 
$str
®® 
,
®® 
CIELabFromRGB
®®< I
(
®®I J
$num
®®J M
,
®®M N
$num
®®O Q
,
®®Q R
$num
®®S U
,
®®U V
$num
®®W [
)
®®[ \
}
®®d e
,
®®e f
{
©© 
$str
©© 
,
©© 
CIELabFromRGB
©©< I
(
©©I J
$num
©©J M
,
©©M N
$num
©©O R
,
©©R S
$num
©©T W
,
©©W X
$num
©©Y ]
)
©©] ^
}
©©d e
,
©©e f
{
™™ 
$str
™™ 
,
™™ 
CIELabFromRGB
™™< I
(
™™I J
$num
™™J M
,
™™M N
$num
™™O Q
,
™™Q R
$num
™™S V
,
™™V W
$num
™™X \
)
™™\ ]
}
™™d e
,
™™e f
{
´´ 
$str
´´ 
,
´´ 
CIELabFromRGB
´´< I
(
´´I J
$num
´´J M
,
´´M N
$num
´´O R
,
´´R S
$num
´´T W
,
´´W X
$num
´´Y ]
)
´´] ^
}
´´d e
,
´´e f
{
¨¨ 
$str
¨¨ 
,
¨¨ 
CIELabFromRGB
¨¨< I
(
¨¨I J
$num
¨¨J M
,
¨¨M N
$num
¨¨O Q
,
¨¨Q R
$num
¨¨S U
,
¨¨U V
$num
¨¨W [
)
¨¨[ \
}
¨¨d e
,
¨¨e f
{
≠≠ 
$str
≠≠ 
,
≠≠ 
CIELabFromRGB
≠≠< I
(
≠≠I J
$num
≠≠J M
,
≠≠M N
$num
≠≠O R
,
≠≠R S
$num
≠≠T W
,
≠≠W X
$num
≠≠Y ]
)
≠≠] ^
}
≠≠d e
,
≠≠e f
{
ÆÆ 
$str
ÆÆ 
,
ÆÆ  
CIELabFromRGB
ÆÆ< I
(
ÆÆI J
$num
ÆÆJ M
,
ÆÆM N
$num
ÆÆO R
,
ÆÆR S
$num
ÆÆT W
,
ÆÆW X
$num
ÆÆY ]
)
ÆÆ] ^
}
ÆÆd e
,
ÆÆe f
{
ØØ 
$str
ØØ 
,
ØØ  
CIELabFromRGB
ØØ< I
(
ØØI J
$num
ØØJ M
,
ØØM N
$num
ØØO R
,
ØØR S
$num
ØØT W
,
ØØW X
$num
ØØY ]
)
ØØ] ^
}
ØØd e
,
ØØe f
{
∞∞ 
$str
∞∞ !
,
∞∞! "
CIELabFromRGB
∞∞< I
(
∞∞I J
$num
∞∞J L
,
∞∞L M
$num
∞∞N Q
,
∞∞Q R
$num
∞∞S V
,
∞∞V W
$num
∞∞X \
)
∞∞\ ]
}
∞∞d e
,
∞∞e f
{
±± 
$str
±± 
,
±± 
CIELabFromRGB
±±< I
(
±±I J
$num
±±J M
,
±±M N
$num
±±O R
,
±±R S
$num
±±T W
,
±±W X
$num
±±Y ]
)
±±] ^
}
±±d e
,
±±e f
{
≤≤ 
$str
≤≤ 
,
≤≤ 
CIELabFromRGB
≤≤< I
(
≤≤I J
$num
≤≤J N
,
≤≤N O
$num
≤≤P S
,
≤≤S T
$num
≤≤U W
,
≤≤W X
$num
≤≤Y ]
)
≤≤] ^
}
≤≤d e
,
≤≤e f
{
≥≥ 
$str
≥≥ 
,
≥≥ 
CIELabFromRGB
≥≥< I
(
≥≥I J
$num
≥≥J M
,
≥≥M N
$num
≥≥O R
,
≥≥R S
$num
≥≥T W
,
≥≥W X
$num
≥≥Y ]
)
≥≥] ^
}
≥≥d e
,
≥≥e f
{
¥¥ 
$str
¥¥  
,
¥¥  !
CIELabFromRGB
¥¥< I
(
¥¥I J
$num
¥¥J M
,
¥¥M N
$num
¥¥O R
,
¥¥R S
$num
¥¥T W
,
¥¥W X
$num
¥¥Y ]
)
¥¥] ^
}
¥¥d e
,
¥¥e f
{
µµ 
$str
µµ 
,
µµ 
CIELabFromRGB
µµ< I
(
µµI J
$num
µµJ L
,
µµL M
$num
µµN Q
,
µµQ R
$num
µµS V
,
µµV W
$num
µµX \
)
µµ\ ]
}
µµd e
,
µµe f
{
∂∂ 
$str
∂∂ 
,
∂∂ 
CIELabFromRGB
∂∂< I
(
∂∂I J
$num
∂∂J M
,
∂∂M N
$num
∂∂O R
,
∂∂R S
$num
∂∂T W
,
∂∂W X
$num
∂∂Y ]
)
∂∂] ^
}
∂∂d e
,
∂∂e f
{
∑∑ 
$str
∑∑ 
,
∑∑ 
CIELabFromRGB
∑∑< I
(
∑∑I J
$num
∑∑J M
,
∑∑M N
$num
∑∑O Q
,
∑∑Q R
$num
∑∑S V
,
∑∑V W
$num
∑∑X \
)
∑∑\ ]
}
∑∑d e
,
∑∑e f
{
∏∏ 
$str
∏∏ 
,
∏∏ 
CIELabFromRGB
∏∏< I
(
∏∏I J
$num
∏∏J M
,
∏∏M N
$num
∏∏O R
,
∏∏R S
$num
∏∏T V
,
∏∏V W
$num
∏∏X \
)
∏∏\ ]
}
∏∏d e
,
∏∏e f
{
ππ 
$str
ππ 
,
ππ  
CIELabFromRGB
ππ< I
(
ππI J
$num
ππJ L
,
ππL M
$num
ππN Q
,
ππQ R
$num
ππS V
,
ππV W
$num
ππX \
)
ππ\ ]
}
ππd e
,
ππe f
{
∫∫ 
$str
∫∫ 
,
∫∫ 
CIELabFromRGB
∫∫< I
(
∫∫I J
$num
∫∫J M
,
∫∫M N
$num
∫∫O R
,
∫∫R S
$num
∫∫T W
,
∫∫W X
$num
∫∫Y ]
)
∫∫] ^
}
∫∫d e
,
∫∫e f
{
ªª 
$str
ªª 
,
ªª 
CIELabFromRGB
ªª< I
(
ªªI J
$num
ªªJ M
,
ªªM N
$num
ªªO Q
,
ªªQ R
$num
ªªS V
,
ªªV W
$num
ªªX \
)
ªª\ ]
}
ªªd e
,
ªªe f
{
ºº 
$str
ºº 
,
ºº  
CIELabFromRGB
ºº< I
(
ººI J
$num
ººJ M
,
ººM N
$num
ººO R
,
ººR S
$num
ººT W
,
ººW X
$num
ººY ]
)
ºº] ^
}
ººd e
,
ººe f
{
ΩΩ 
$str
ΩΩ 
,
ΩΩ 
CIELabFromRGB
ΩΩ< I
(
ΩΩI J
$num
ΩΩJ M
,
ΩΩM N
$num
ΩΩO R
,
ΩΩR S
$num
ΩΩT W
,
ΩΩW X
$num
ΩΩY ]
)
ΩΩ] ^
}
ΩΩd e
,
ΩΩe f
{
ææ 
$str
ææ !
,
ææ! "
CIELabFromRGB
ææ< I
(
ææI J
$num
ææJ M
,
ææM N
$num
ææO R
,
ææR S
$num
ææT W
,
ææW X
$num
ææY ]
)
ææ] ^
}
ææd e
,
ææe f
{
øø 
$str
øø "
,
øø" #
CIELabFromRGB
øø< I
(
øøI J
$num
øøJ M
,
øøM N
$num
øøO R
,
øøR S
$num
øøT W
,
øøW X
$num
øøY ]
)
øø] ^
}
øød e
,
øøe f
{
¿¿ 
$str
¿¿ 
,
¿¿ 
CIELabFromRGB
¿¿< I
(
¿¿I J
$num
¿¿J M
,
¿¿M N
$num
¿¿O R
,
¿¿R S
$num
¿¿T W
,
¿¿W X
$num
¿¿Y ]
)
¿¿] ^
}
¿¿d e
,
¿¿e f
{
¡¡ 
$str
¡¡ 
,
¡¡ 
CIELabFromRGB
¡¡< I
(
¡¡I J
$num
¡¡J M
,
¡¡M N
$num
¡¡O R
,
¡¡R S
$num
¡¡T W
,
¡¡W X
$num
¡¡Y ]
)
¡¡] ^
}
¡¡d e
,
¡¡e f
{
¬¬ 
$str
¬¬ 
,
¬¬ 
CIELabFromRGB
¬¬< I
(
¬¬I J
$num
¬¬J M
,
¬¬M N
$num
¬¬O R
,
¬¬R S
$num
¬¬T W
,
¬¬W X
$num
¬¬Y ]
)
¬¬] ^
}
¬¬d e
,
¬¬e f
{
√√ 
$str
√√ 
,
√√ 
CIELabFromRGB
√√< I
(
√√I J
$num
√√J M
,
√√M N
$num
√√O R
,
√√R S
$num
√√T W
,
√√W X
$num
√√Y ]
)
√√] ^
}
√√d e
,
√√e f
{
ƒƒ 
$str
ƒƒ 
,
ƒƒ 
CIELabFromRGB
ƒƒ< I
(
ƒƒI J
$num
ƒƒJ M
,
ƒƒM N
$num
ƒƒO R
,
ƒƒR S
$num
ƒƒT W
,
ƒƒW X
$num
ƒƒY ]
)
ƒƒ] ^
}
ƒƒd e
,
ƒƒe f
{
≈≈ 
$str
≈≈ 
,
≈≈ 
CIELabFromRGB
≈≈< I
(
≈≈I J
$num
≈≈J L
,
≈≈L M
$num
≈≈N Q
,
≈≈Q R
$num
≈≈S U
,
≈≈U V
$num
≈≈W [
)
≈≈[ \
}
≈≈d e
,
≈≈e f
{
∆∆ 
$str
∆∆ )
,
∆∆) *
CIELabFromRGB
∆∆< I
(
∆∆I J
$num
∆∆J L
,
∆∆L M
$num
∆∆N Q
,
∆∆Q R
$num
∆∆S V
,
∆∆V W
$num
∆∆X \
)
∆∆\ ]
}
∆∆d e
,
∆∆e f
{
«« 
$str
«« !
,
««! "
CIELabFromRGB
««< I
(
««I J
$num
««J L
,
««L M
$num
««N Q
,
««Q R
$num
««S V
,
««V W
$num
««X \
)
««\ ]
}
««d e
,
««e f
{
»» 
$str
»» 
,
»» 
CIELabFromRGB
»»< I
(
»»I J
$num
»»J M
,
»»M N
$num
»»O R
,
»»R S
$num
»»T W
,
»»W X
$num
»»Y ]
)
»»] ^
}
»»d e
,
»»e f
{
…… 
$str
…… 
,
…… 
CIELabFromRGB
……< I
(
……I J
$num
……J M
,
……M N
$num
……O R
,
……R S
$num
……T W
,
……W X
$num
……Y ]
)
……] ^
}
……d e
,
……e f
{
   
$str
   
,
   
CIELabFromRGB
  < I
(
  I J
$num
  J M
,
  M N
$num
  O R
,
  R S
$num
  T W
,
  W X
$num
  Y ]
)
  ] ^
}
  d e
,
  e f
{
ÀÀ 
$str
ÀÀ 
,
ÀÀ 
CIELabFromRGB
ÀÀ< I
(
ÀÀI J
$num
ÀÀJ M
,
ÀÀM N
$num
ÀÀO Q
,
ÀÀQ R
$num
ÀÀS V
,
ÀÀV W
$num
ÀÀX \
)
ÀÀ\ ]
}
ÀÀd e
,
ÀÀe f
{
ÃÃ 
$str
ÃÃ 
,
ÃÃ 
CIELabFromRGB
ÃÃ< I
(
ÃÃI J
$num
ÃÃJ M
,
ÃÃM N
$num
ÃÃO Q
,
ÃÃQ R
$num
ÃÃS U
,
ÃÃU V
$num
ÃÃW [
)
ÃÃ[ \
}
ÃÃd e
,
ÃÃe f
{
ÕÕ 
$str
ÕÕ 
,
ÕÕ 
CIELabFromRGB
ÕÕ< I
(
ÕÕI J
$num
ÕÕJ M
,
ÕÕM N
$num
ÕÕO R
,
ÕÕR S
$num
ÕÕT W
,
ÕÕW X
$num
ÕÕY ]
)
ÕÕ] ^
}
ÕÕd e
,
ÕÕe f
{
ŒŒ 
$str
ŒŒ 
,
ŒŒ  
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ M
,
ŒŒM N
$num
ŒŒO R
,
ŒŒR S
$num
ŒŒT W
,
ŒŒW X
$num
ŒŒY ]
)
ŒŒ] ^
}
ŒŒd e
,
ŒŒe f
{
œœ 
$str
œœ 
,
œœ 
CIELabFromRGB
œœ< I
(
œœI J
$num
œœJ N
,
œœN O
$num
œœP S
,
œœS T
$num
œœU X
,
œœX Y
$num
œœZ ^
)
œœ^ _
}
œœd e
,
œœe f
{
–– 
$str
–– 
,
–– 
CIELabFromRGB
––< I
(
––I J
$num
––J N
,
––N O
$num
––P R
,
––R S
$num
––T W
,
––W X
$num
––Y ]
)
––] ^
}
––d e
,
––e f
{
—— 
$str
—— 
,
—— 
CIELabFromRGB
——< I
(
——I J
$num
——J M
,
——M N
$num
——O R
,
——R S
$num
——T W
,
——W X
$num
——Y ]
)
——] ^
}
——d e
,
——e f
{
““ 
$str
““ 
,
““ 
CIELabFromRGB
““< I
(
““I J
$num
““J M
,
““M N
$num
““O Q
,
““Q R
$num
““S U
,
““U V
$num
““W [
)
““[ \
}
““d e
,
““e f
{
”” 
$str
”” 
,
”” 
CIELabFromRGB
””< I
(
””I J
$num
””J M
,
””M N
$num
””O R
,
””R S
$num
””T W
,
””W X
$num
””Y ]
)
””] ^
}
””d e
,
””e f
{
‘‘ 
$str
‘‘ 
,
‘‘ 
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J N
,
‘‘N O
$num
‘‘P S
,
‘‘S T
$num
‘‘U X
,
‘‘X Y
$num
‘‘Z ^
)
‘‘^ _
}
‘‘d e
,
‘‘e f
{
’’ 
$str
’’ 
,
’’ 
CIELabFromRGB
’’< I
(
’’I J
$num
’’J L
,
’’L M
$num
’’N Q
,
’’Q R
$num
’’S W
,
’’W X
$num
’’Y ]
)
’’] ^
}
’’d e
,
’’e f
{
÷÷ 
$str
÷÷ "
,
÷÷" #
CIELabFromRGB
÷÷< I
(
÷÷I J
$num
÷÷J M
,
÷÷M N
$num
÷÷O R
,
÷÷R S
$num
÷÷T W
,
÷÷W X
$num
÷÷Y ]
)
÷÷] ^
}
÷÷d e
,
÷÷e f
{
◊◊ 
$str
◊◊ 
,
◊◊  
CIELabFromRGB
◊◊< I
(
◊◊I J
$num
◊◊J M
,
◊◊M N
$num
◊◊O R
,
◊◊R S
$num
◊◊T W
,
◊◊W X
$num
◊◊Y ]
)
◊◊] ^
}
◊◊d e
,
◊◊e f
{
ÿÿ 
$str
ÿÿ 
,
ÿÿ 
CIELabFromRGB
ÿÿ< I
(
ÿÿI J
$num
ÿÿJ M
,
ÿÿM N
$num
ÿÿO R
,
ÿÿR S
$num
ÿÿT W
,
ÿÿW X
$num
ÿÿY ]
)
ÿÿ] ^
}
ÿÿd e
,
ÿÿe f
{
ŸŸ 
$str
ŸŸ 
,
ŸŸ  
CIELabFromRGB
ŸŸ< I
(
ŸŸI J
$num
ŸŸJ M
,
ŸŸM N
$num
ŸŸO R
,
ŸŸR S
$num
ŸŸT W
,
ŸŸW X
$num
ŸŸY ]
)
ŸŸ] ^
}
ŸŸd e
,
ŸŸe f
{
⁄⁄ 
$str
⁄⁄ 
,
⁄⁄ 
CIELabFromRGB
⁄⁄< I
(
⁄⁄I J
$num
⁄⁄J M
,
⁄⁄M N
$num
⁄⁄O Q
,
⁄⁄Q R
$num
⁄⁄S V
,
⁄⁄V W
$num
⁄⁄X \
)
⁄⁄\ ]
}
⁄⁄d e
,
⁄⁄e f
{
€€ 
$str
€€ 
,
€€ 
CIELabFromRGB
€€< I
(
€€I J
$num
€€J M
,
€€M N
$num
€€O R
,
€€R S
$num
€€T W
,
€€W X
$num
€€Y ]
)
€€] ^
}
€€d e
,
€€e f
{
‹‹ 
$str
‹‹ 
,
‹‹ 
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J L
,
‹‹L M
$num
‹‹N Q
,
‹‹Q R
$num
‹‹S V
,
‹‹V W
$num
‹‹X \
)
‹‹\ ]
}
‹‹d e
,
‹‹e f
{
›› 
$str
››  
,
››  !
CIELabFromRGB
››< I
(
››I J
$num
››J M
,
››M N
$num
››O R
,
››R S
$num
››T W
,
››W X
$num
››Y ]
)
››] ^
}
››d e
,
››e f
{
ﬁﬁ 
$str
ﬁﬁ 
,
ﬁﬁ 
CIELabFromRGB
ﬁﬁ< I
(
ﬁﬁI J
$num
ﬁﬁJ M
,
ﬁﬁM N
$num
ﬁﬁO R
,
ﬁﬁR S
$num
ﬁﬁT W
,
ﬁﬁW X
$num
ﬁﬁY ]
)
ﬁﬁ] ^
}
ﬁﬁd e
,
ﬁﬁe f
{
ﬂﬂ 
$str
ﬂﬂ 
,
ﬂﬂ 
CIELabFromRGB
ﬂﬂ< I
(
ﬂﬂI J
$num
ﬂﬂJ M
,
ﬂﬂM N
$num
ﬂﬂO R
,
ﬂﬂR S
$num
ﬂﬂT W
,
ﬂﬂW X
$num
ﬂﬂY ]
)
ﬂﬂ] ^
}
ﬂﬂd e
,
ﬂﬂe f
{
‡‡ 
$str
‡‡ 
,
‡‡ 
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J M
,
‡‡M N
$num
‡‡O R
,
‡‡R S
$num
‡‡T W
,
‡‡W X
$num
‡‡Y ]
)
‡‡] ^
}
‡‡d e
,
‡‡e f
{
·· 
$str
·· 
,
·· 
CIELabFromRGB
··< I
(
··I J
$num
··J M
,
··M N
$num
··O R
,
··R S
$num
··T X
,
··X Y
$num
··Z ^
)
··^ _
}
··d e
,
··e f
{
‚‚ 
$str
‚‚ 
,
‚‚ 
CIELabFromRGB
‚‚< I
(
‚‚I J
$num
‚‚J M
,
‚‚M N
$num
‚‚O R
,
‚‚R S
$num
‚‚T W
,
‚‚W X
$num
‚‚Y ]
)
‚‚] ^
}
‚‚d e
,
‚‚e f
{
„„ 
$str
„„ 
,
„„ 
CIELabFromRGB
„„< I
(
„„I J
$num
„„J M
,
„„M N
$num
„„O R
,
„„R S
$num
„„T W
,
„„W X
$num
„„Y ]
)
„„] ^
}
„„d e
,
„„e f
{
‰‰ 
$str
‰‰ 
,
‰‰ 
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J M
,
‰‰M N
$num
‰‰O R
,
‰‰R S
$num
‰‰T X
,
‰‰X Y
$num
‰‰Z ^
)
‰‰^ _
}
‰‰d e
,
‰‰e f
{
ÂÂ 
$str
ÂÂ 
,
ÂÂ 
CIELabFromRGB
ÂÂ< I
(
ÂÂI J
$num
ÂÂJ M
,
ÂÂM N
$num
ÂÂO Q
,
ÂÂQ R
$num
ÂÂS V
,
ÂÂV W
$num
ÂÂX \
)
ÂÂ\ ]
}
ÂÂd e
,
ÂÂe f
{
ÊÊ 
$str
ÊÊ 
,
ÊÊ 
CIELabFromRGB
ÊÊ< I
(
ÊÊI J
$num
ÊÊJ M
,
ÊÊM N
$num
ÊÊO R
,
ÊÊR S
$num
ÊÊT W
,
ÊÊW X
$num
ÊÊY ]
)
ÊÊ] ^
}
ÊÊd e
,
ÊÊe f
{
ÁÁ 
$str
ÁÁ 
,
ÁÁ 
CIELabFromRGB
ÁÁ< I
(
ÁÁI J
$num
ÁÁJ M
,
ÁÁM N
$num
ÁÁO R
,
ÁÁR S
$num
ÁÁT W
,
ÁÁW X
$num
ÁÁY ]
)
ÁÁ] ^
}
ÁÁd e
,
ÁÁe f
{
ËË 
$str
ËË 
,
ËË 
CIELabFromRGB
ËË< I
(
ËËI J
$num
ËËJ M
,
ËËM N
$num
ËËO R
,
ËËR S
$num
ËËT V
,
ËËV W
$num
ËËX \
)
ËË\ ]
}
ËËd e
,
ËËe f
{
ÈÈ 
$str
ÈÈ 
,
ÈÈ 
CIELabFromRGB
ÈÈ< I
(
ÈÈI J
$num
ÈÈJ L
,
ÈÈL M
$num
ÈÈN P
,
ÈÈP Q
$num
ÈÈR U
,
ÈÈU V
$num
ÈÈW [
)
ÈÈ[ \
}
ÈÈd e
,
ÈÈe f
{
ÍÍ 
$str
ÍÍ 
,
ÍÍ 
CIELabFromRGB
ÍÍ< I
(
ÍÍI J
$num
ÍÍJ M
,
ÍÍM N
$num
ÍÍO R
,
ÍÍR S
$num
ÍÍT W
,
ÍÍW X
$num
ÍÍY ]
)
ÍÍ] ^
}
ÍÍd e
,
ÍÍe f
{
ÎÎ 
$str
ÎÎ 
,
ÎÎ 
CIELabFromRGB
ÎÎ< I
(
ÎÎI J
$num
ÎÎJ M
,
ÎÎM N
$num
ÎÎO R
,
ÎÎR S
$num
ÎÎT W
,
ÎÎW X
$num
ÎÎY ]
)
ÎÎ] ^
}
ÎÎd e
,
ÎÎe f
{
ÏÏ 
$str
ÏÏ 
,
ÏÏ 
CIELabFromRGB
ÏÏ< I
(
ÏÏI J
$num
ÏÏJ M
,
ÏÏM N
$num
ÏÏO R
,
ÏÏR S
$num
ÏÏT W
,
ÏÏW X
$num
ÏÏY ]
)
ÏÏ] ^
}
ÏÏd e
,
ÏÏe f
{
ÌÌ 
$str
ÌÌ 
,
ÌÌ 
CIELabFromRGB
ÌÌ< I
(
ÌÌI J
$num
ÌÌJ M
,
ÌÌM N
$num
ÌÌO R
,
ÌÌR S
$num
ÌÌT W
,
ÌÌW X
$num
ÌÌY ]
)
ÌÌ] ^
}
ÌÌd e
,
ÌÌe f
{
ÓÓ 
$str
ÓÓ 
,
ÓÓ 
CIELabFromRGB
ÓÓ< I
(
ÓÓI J
$num
ÓÓJ M
,
ÓÓM N
$num
ÓÓO R
,
ÓÓR S
$num
ÓÓT W
,
ÓÓW X
$num
ÓÓY ]
)
ÓÓ] ^
}
ÓÓd e
,
ÓÓe f
{
ÔÔ 
$str
ÔÔ 
,
ÔÔ 
CIELabFromRGB
ÔÔ< I
(
ÔÔI J
$num
ÔÔJ M
,
ÔÔM N
$num
ÔÔO R
,
ÔÔR S
$num
ÔÔT W
,
ÔÔW X
$num
ÔÔY ]
)
ÔÔ] ^
}
ÔÔd e
,
ÔÔe f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
ÒÒ 
$str
ÒÒ 
,
ÒÒ 
CIELabFromRGB
ÒÒ< I
(
ÒÒI J
$num
ÒÒJ M
,
ÒÒM N
$num
ÒÒO R
,
ÒÒR S
$num
ÒÒT W
,
ÒÒW X
$num
ÒÒY ]
)
ÒÒ] ^
}
ÒÒd e
,
ÒÒe f
{
ÚÚ 
$str
ÚÚ 
,
ÚÚ 
CIELabFromRGB
ÚÚ< I
(
ÚÚI J
$num
ÚÚJ L
,
ÚÚL M
$num
ÚÚN Q
,
ÚÚQ R
$num
ÚÚS V
,
ÚÚV W
$num
ÚÚX \
)
ÚÚ\ ]
}
ÚÚd e
,
ÚÚe f
{
ÛÛ 
$str
ÛÛ 
,
ÛÛ 
CIELabFromRGB
ÛÛ< I
(
ÛÛI J
$num
ÛÛJ M
,
ÛÛM N
$num
ÛÛO R
,
ÛÛR S
$num
ÛÛT X
,
ÛÛX Y
$num
ÛÛZ ^
)
ÛÛ^ _
}
ÛÛd e
,
ÛÛe f
{
ÙÙ 
$str
ÙÙ  
,
ÙÙ  !
CIELabFromRGB
ÙÙ< I
(
ÙÙI J
$num
ÙÙJ N
,
ÙÙN O
$num
ÙÙP R
,
ÙÙR S
$num
ÙÙT W
,
ÙÙW X
$num
ÙÙY ]
)
ÙÙ] ^
}
ÙÙd e
,
ÙÙe f
{
ıı 
$str
ıı 
,
ıı 
CIELabFromRGB
ıı< I
(
ııI J
$num
ııJ L
,
ııL M
$num
ııN R
,
ııR S
$num
ııT X
,
ııX Y
$num
ııZ ^
)
ıı^ _
}
ııd e
,
ııe f
{
ˆˆ 
$str
ˆˆ 
,
ˆˆ 
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ L
,
ˆˆL M
$num
ˆˆN R
,
ˆˆR S
$num
ˆˆT V
,
ˆˆV W
$num
ˆˆX \
)
ˆˆ\ ]
}
ˆˆd e
,
ˆˆe f
{
˜˜ 
$str
˜˜ 
,
˜˜  
CIELabFromRGB
˜˜< I
(
˜˜I J
$num
˜˜J M
,
˜˜M N
$num
˜˜O Q
,
˜˜Q R
$num
˜˜S W
,
˜˜W X
$num
˜˜Y ]
)
˜˜] ^
}
˜˜d e
,
˜˜e f
{
¯¯ 
$str
¯¯ !
,
¯¯! "
CIELabFromRGB
¯¯< I
(
¯¯I J
$num
¯¯J M
,
¯¯M N
$num
¯¯O R
,
¯¯R S
$num
¯¯T X
,
¯¯X Y
$num
¯¯Z ^
)
¯¯^ _
}
¯¯d e
,
¯¯e f
{
˘˘ 
$str
˘˘ 
,
˘˘ 
CIELabFromRGB
˘˘< I
(
˘˘I J
$num
˘˘J M
,
˘˘M N
$num
˘˘O S
,
˘˘S T
$num
˘˘U W
,
˘˘W X
$num
˘˘Y ]
)
˘˘] ^
}
˘˘d e
,
˘˘e f
{
˙˙ 
$str
˙˙ 
,
˙˙  
CIELabFromRGB
˙˙< I
(
˙˙I J
$num
˙˙J M
,
˙˙M N
$num
˙˙O Q
,
˙˙Q R
$num
˙˙S W
,
˙˙W X
$num
˙˙Y ]
)
˙˙] ^
}
˙˙d e
,
˙˙e f
{
˚˚ 
$str
˚˚ $
,
˚˚$ %
CIELabFromRGB
˚˚< I
(
˚˚I J
$num
˚˚J M
,
˚˚M N
$num
˚˚O Q
,
˚˚Q R
$num
˚˚S W
,
˚˚W X
$num
˚˚Y ]
)
˚˚] ^
}
˚˚d e
,
˚˚e f
{
¸¸ 
$str
¸¸ 
,
¸¸  
CIELabFromRGB
¸¸< I
(
¸¸I J
$num
¸¸J M
,
¸¸M N
$num
¸¸O Q
,
¸¸Q R
$num
¸¸S W
,
¸¸W X
$num
¸¸Y ]
)
¸¸] ^
}
¸¸d e
,
¸¸e f
{
˝˝ 
$str
˝˝ 
,
˝˝  
CIELabFromRGB
˝˝< I
(
˝˝I J
$num
˝˝J N
,
˝˝N O
$num
˝˝P T
,
˝˝T U
$num
˝˝V Y
,
˝˝Y Z
$num
˝˝[ _
)
˝˝_ `
}
˝˝d e
,
˝˝e f
{
˛˛ 
$str
˛˛ 
,
˛˛ 
CIELabFromRGB
˛˛< I
(
˛˛I J
$num
˛˛J M
,
˛˛M N
$num
˛˛O R
,
˛˛R S
$num
˛˛T W
,
˛˛W X
$num
˛˛Y ]
)
˛˛] ^
}
˛˛d e
,
˛˛e f
{
ˇˇ 
$str
ˇˇ 
,
ˇˇ 
CIELabFromRGB
ˇˇ< I
(
ˇˇI J
$num
ˇˇJ M
,
ˇˇM N
$num
ˇˇO R
,
ˇˇR S
$num
ˇˇT W
,
ˇˇW X
$num
ˇˇY ]
)
ˇˇ] ^
}
ˇˇd e
,
ˇˇe f
{
ÄÄ 
$str
ÄÄ 
,
ÄÄ 
CIELabFromRGB
ÄÄ< I
(
ÄÄI J
$num
ÄÄJ M
,
ÄÄM N
$num
ÄÄO R
,
ÄÄR S
$num
ÄÄT W
,
ÄÄW X
$num
ÄÄY ]
)
ÄÄ] ^
}
ÄÄd e
,
ÄÄe f
{
ÅÅ 
$str
ÅÅ  
,
ÅÅ  !
CIELabFromRGB
ÅÅ< I
(
ÅÅI J
$num
ÅÅJ M
,
ÅÅM N
$num
ÅÅO R
,
ÅÅR S
$num
ÅÅT W
,
ÅÅW X
$num
ÅÅY ]
)
ÅÅ] ^
}
ÅÅd e
,
ÅÅe f
{
ÇÇ 
$str
ÇÇ 
,
ÇÇ 
CIELabFromRGB
ÇÇ< I
(
ÇÇI J
$num
ÇÇJ M
,
ÇÇM N
$num
ÇÇO R
,
ÇÇR S
$num
ÇÇT W
,
ÇÇW X
$num
ÇÇY ]
)
ÇÇ] ^
}
ÇÇd e
,
ÇÇe f
{
ÉÉ 
$str
ÉÉ 
,
ÉÉ 
CIELabFromRGB
ÉÉ< I
(
ÉÉI J
$num
ÉÉJ M
,
ÉÉM N
$num
ÉÉO R
,
ÉÉR S
$num
ÉÉT W
,
ÉÉW X
$num
ÉÉY ]
)
ÉÉ] ^
}
ÉÉd e
,
ÉÉe f
{
ÑÑ 
$str
ÑÑ 
,
ÑÑ 
CIELabFromRGB
ÑÑ< I
(
ÑÑI J
$num
ÑÑJ M
,
ÑÑM N
$num
ÑÑO R
,
ÑÑR S
$num
ÑÑT W
,
ÑÑW X
$num
ÑÑY ]
)
ÑÑ] ^
}
ÑÑd e
,
ÑÑe f
{
ÖÖ 
$str
ÖÖ 
,
ÖÖ 
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ M
,
ÖÖM N
$num
ÖÖO R
,
ÖÖR S
$num
ÖÖT W
,
ÖÖW X
$num
ÖÖY ]
)
ÖÖ] ^
}
ÖÖd e
,
ÖÖe f
{
ÜÜ 
$str
ÜÜ 
,
ÜÜ 
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ M
,
ÜÜM N
$num
ÜÜO R
,
ÜÜR S
$num
ÜÜT W
,
ÜÜW X
$num
ÜÜY ]
)
ÜÜ] ^
}
ÜÜd e
,
ÜÜe f
{
áá 
$str
áá 
,
áá 
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ M
,
ááM N
$num
ááO Q
,
ááQ R
$num
ááS U
,
ááU V
$num
ááW [
)
áá[ \
}
áád e
,
ááe f
{
àà 
$str
àà 
,
àà 
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ M
,
ààM N
$num
ààO R
,
ààR S
$num
ààT W
,
ààW X
$num
ààY ]
)
àà] ^
}
ààd e
,
ààe f
{
ââ 
$str
ââ 
,
ââ 
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ M
,
ââM N
$num
ââO R
,
ââR S
$num
ââT W
,
ââW X
$num
ââY ]
)
ââ] ^
}
ââd e
,
ââe f
{
ää 
$str
ää 
,
ää  
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ M
,
ääM N
$num
ääO Q
,
ääQ R
$num
ääS V
,
ääV W
$num
ääX \
)
ää\ ]
}
ääd e
,
ääe f
{
ãã 
$str
ãã 
,
ãã 
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ M
,
ããM N
$num
ããO R
,
ããR S
$num
ããT W
,
ããW X
$num
ããY ]
)
ãã] ^
}
ããd e
,
ããe f
{
åå 
$str
åå 
,
åå 
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ M
,
ååM N
$num
ååO R
,
ååR S
$num
ååT W
,
ååW X
$num
ååY ]
)
åå] ^
}
ååd e
,
ååe f
{
çç 
$str
çç 
,
çç 
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ M
,
ççM N
$num
ççO R
,
ççR S
$num
ççT W
,
ççW X
$num
ççY ]
)
çç] ^
}
ççd e
,
ççe f
{
éé 
$str
éé 
,
éé 
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ M
,
ééM N
$num
ééO R
,
ééR S
$num
ééT W
,
ééW X
$num
ééY ]
)
éé] ^
}
ééd e
,
éée f
{
èè 
$str
èè 
,
èè 
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ N
,
èèN O
$num
èèP S
,
èèS T
$num
èèU W
,
èèW X
$num
èèY ]
)
èè] ^
}
èèd e
,
èèe f
{
êê 
$str
êê 
,
êê 
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ M
,
êêM N
$num
êêO R
,
êêR S
$num
êêT W
,
êêW X
$num
êêY ]
)
êê] ^
}
êêd e
,
êêe f
{
ëë 
$str
ëë 
,
ëë 
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ M
,
ëëM N
$num
ëëO R
,
ëëR S
$num
ëëT W
,
ëëW X
$num
ëëY ]
)
ëë] ^
}
ëëd e
,
ëëe f
{
íí 
$str
íí 
,
íí  
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ M
,
ííM N
$num
ííO R
,
ííR S
$num
ííT W
,
ííW X
$num
ííY ]
)
íí] ^
}
ííd e
,
ííe f
{
ìì 
$str
ìì 
,
ìì 
CIELabFromRGB
ìì< I
(
ììI J
$num
ììJ M
,
ììM N
$num
ììO R
,
ììR S
$num
ììT W
,
ììW X
$num
ììY ]
)
ìì] ^
}
ììd e
,
ììe f
{
îî 
$str
îî 
,
îî 
CIELabFromRGB
îî< I
(
îîI J
$num
îîJ M
,
îîM N
$num
îîO R
,
îîR S
$num
îîT W
,
îîW X
$num
îîY ]
)
îî] ^
}
îîd e
,
îîe f
{
ïï 
$str
ïï 
,
ïï 
CIELabFromRGB
ïï< I
(
ïïI J
$num
ïïJ M
,
ïïM N
$num
ïïO R
,
ïïR S
$num
ïïT W
,
ïïW X
$num
ïïY ]
)
ïï] ^
}
ïïd e
,
ïïe f
{
ññ 
$str
ññ 
,
ññ 
CIELabFromRGB
ññ< I
(
ññI J
$num
ññJ M
,
ññM N
$num
ññO R
,
ññR S
$num
ññT W
,
ññW X
$num
ññY ]
)
ññ] ^
}
ññd e
,
ññe f
{
óó 
$str
óó 
,
óó 
CIELabFromRGB
óó< I
(
óóI J
$num
óóJ M
,
óóM N
$num
óóO R
,
óóR S
$num
óóT W
,
óóW X
$num
óóY ]
)
óó] ^
}
óód e
,
óóe f
{
òò 
$str
òò 
,
òò 
CIELabFromRGB
òò< I
(
òòI J
$num
òòJ M
,
òòM N
$num
òòO Q
,
òòQ R
$num
òòS V
,
òòV W
$num
òòX \
)
òò\ ]
}
òòd e
,
òòe f
{
ôô 
$str
ôô 
,
ôô 
CIELabFromRGB
ôô< I
(
ôôI J
$num
ôôJ N
,
ôôN O
$num
ôôP S
,
ôôS T
$num
ôôU X
,
ôôX Y
$num
ôôZ ^
)
ôô^ _
}
ôôd e
,
ôôe f
{
öö 
$str
öö "
,
öö" #
CIELabFromRGB
öö< I
(
ööI J
$num
ööJ N
,
ööN O
$num
ööP S
,
ööS T
$num
ööU W
,
ööW X
$num
ööY ]
)
öö] ^
}
ööd e
,
ööe f
{
õõ 
$str
õõ  
,
õõ  !
CIELabFromRGB
õõ< I
(
õõI J
$num
õõJ N
,
õõN O
$num
õõP R
,
õõR S
$num
õõT W
,
õõW X
$num
õõY ]
)
õõ] ^
}
õõd e
,
õõe f
{
úú 
$str
úú "
,
úú" #
CIELabFromRGB
úú< I
(
úúI J
$num
úúJ M
,
úúM N
$num
úúO S
,
úúS T
$num
úúU W
,
úúW X
$num
úúY ]
)
úú] ^
}
úúd e
,
úúe f
{
ùù 
$str
ùù 
,
ùù 
CIELabFromRGB
ùù< I
(
ùùI J
$num
ùùJ N
,
ùùN O
$num
ùùP R
,
ùùR S
$num
ùùT W
,
ùùW X
$num
ùùY ]
)
ùù] ^
}
ùùd e
,
ùùe f
{
ûû 
$str
ûû *
,
ûû* +
CIELabFromRGB
ûû< I
(
ûûI J
$num
ûûJ L
,
ûûL M
$num
ûûN Q
,
ûûQ R
$num
ûûS V
,
ûûV W
$num
ûûX \
)
ûû\ ]
}
ûûd e
,
ûûe f
{
üü 
$str
üü "
,
üü" #
CIELabFromRGB
üü< I
(
üüI J
$num
üüJ M
,
üüM N
$num
üüO R
,
üüR S
$num
üüT W
,
üüW X
$num
üüY ]
)
üü] ^
}
üüd e
,
üüe f
{
†† 
$str
†† 
,
†† 
CIELabFromRGB
††< I
(
††I J
$num
††J M
,
††M N
$num
††O R
,
††R S
$num
††T W
,
††W X
$num
††Y ]
)
††] ^
}
††d e
,
††e f
{
°° 
$str
°° 
,
°° 
CIELabFromRGB
°°< I
(
°°I J
$num
°°J M
,
°°M N
$num
°°O R
,
°°R S
$num
°°T W
,
°°W X
$num
°°Y ]
)
°°] ^
}
°°d e
,
°°e f
{
¢¢ 
$str
¢¢ 
,
¢¢ 
CIELabFromRGB
¢¢< I
(
¢¢I J
$num
¢¢J L
,
¢¢L M
$num
¢¢N Q
,
¢¢Q R
$num
¢¢S V
,
¢¢V W
$num
¢¢X \
)
¢¢\ ]
}
¢¢d e
,
¢¢e f
{
££ 
$str
££ 
,
££ 
CIELabFromRGB
££< I
(
££I J
$num
££J M
,
££M N
$num
££O R
,
££R S
$num
££T W
,
££W X
$num
££Y ]
)
££] ^
}
££d e
,
££e f
{
§§ 
$str
§§ 
,
§§ 
CIELabFromRGB
§§< I
(
§§I J
$num
§§J M
,
§§M N
$num
§§O R
,
§§R S
$num
§§T W
,
§§W X
$num
§§Y ]
)
§§] ^
}
§§d e
,
§§e f
{
•• 
$str
•• 
,
•• 
CIELabFromRGB
••< I
(
••I J
$num
••J M
,
••M N
$num
••O R
,
••R S
$num
••T W
,
••W X
$num
••Y ]
)
••] ^
}
••d e
,
••e f
{
¶¶ 
$str
¶¶ 
,
¶¶ 
CIELabFromRGB
¶¶< I
(
¶¶I J
$num
¶¶J M
,
¶¶M N
$num
¶¶O R
,
¶¶R S
$num
¶¶T W
,
¶¶W X
$num
¶¶Y ]
)
¶¶] ^
}
¶¶d e
,
¶¶e f
{
ßß 
$str
ßß 
,
ßß 
CIELabFromRGB
ßß< I
(
ßßI J
$num
ßßJ M
,
ßßM N
$num
ßßO R
,
ßßR S
$num
ßßT W
,
ßßW X
$num
ßßY ]
)
ßß] ^
}
ßßd e
,
ßße f
{
®® 
$str
®® 
,
®® 
CIELabFromRGB
®®< I
(
®®I J
$num
®®J M
,
®®M N
$num
®®O Q
,
®®Q R
$num
®®S V
,
®®V W
$num
®®X \
)
®®\ ]
}
®®d e
,
®®e f
{
©© 
$str
©© 
,
©© 
CIELabFromRGB
©©< I
(
©©I J
$num
©©J M
,
©©M N
$num
©©O Q
,
©©Q R
$num
©©S U
,
©©U V
$num
©©W [
)
©©[ \
}
©©d e
,
©©e f
{
™™ 
$str
™™  
,
™™  !
CIELabFromRGB
™™< I
(
™™I J
$num
™™J M
,
™™M N
$num
™™O R
,
™™R S
$num
™™T W
,
™™W X
$num
™™Y ]
)
™™] ^
}
™™d e
,
™™e f
{
´´ 
$str
´´ 
,
´´ 
CIELabFromRGB
´´< I
(
´´I J
$num
´´J M
,
´´M N
$num
´´O R
,
´´R S
$num
´´T W
,
´´W X
$num
´´Y ]
)
´´] ^
}
´´d e
,
´´e f
{
¨¨ 
$str
¨¨ 
,
¨¨  
CIELabFromRGB
¨¨< I
(
¨¨I J
$num
¨¨J M
,
¨¨M N
$num
¨¨O R
,
¨¨R S
$num
¨¨T X
,
¨¨X Y
$num
¨¨Z ^
)
¨¨^ _
}
¨¨d e
,
¨¨e f
{
≠≠ 
$str
≠≠ 
,
≠≠ 
CIELabFromRGB
≠≠< I
(
≠≠I J
$num
≠≠J M
,
≠≠M N
$num
≠≠O Q
,
≠≠Q R
$num
≠≠S V
,
≠≠V W
$num
≠≠X \
)
≠≠\ ]
}
≠≠d e
,
≠≠e f
{
ÆÆ 
$str
ÆÆ 
,
ÆÆ 
CIELabFromRGB
ÆÆ< I
(
ÆÆI J
$num
ÆÆJ M
,
ÆÆM N
$num
ÆÆO R
,
ÆÆR S
$num
ÆÆT W
,
ÆÆW X
$num
ÆÆY ]
)
ÆÆ] ^
}
ÆÆd e
,
ÆÆe f
{
ØØ 
$str
ØØ 
,
ØØ 
CIELabFromRGB
ØØ< I
(
ØØI J
$num
ØØJ M
,
ØØM N
$num
ØØO R
,
ØØR S
$num
ØØT X
,
ØØX Y
$num
ØØZ ^
)
ØØ^ _
}
ØØd e
,
ØØe f
{
∞∞ 
$str
∞∞ 
,
∞∞ 
CIELabFromRGB
∞∞< I
(
∞∞I J
$num
∞∞J N
,
∞∞N O
$num
∞∞P R
,
∞∞R S
$num
∞∞T X
,
∞∞X Y
$num
∞∞Z ^
)
∞∞^ _
}
∞∞d e
,
∞∞e f
{
±± 
$str
±± !
,
±±! "
CIELabFromRGB
±±< I
(
±±I J
$num
±±J M
,
±±M N
$num
±±O R
,
±±R S
$num
±±T W
,
±±W X
$num
±±Y ]
)
±±] ^
}
±±d e
,
±±e f
{
≤≤ 
$str
≤≤ 
,
≤≤ 
CIELabFromRGB
≤≤< I
(
≤≤I J
$num
≤≤J N
,
≤≤N O
$num
≤≤P S
,
≤≤S T
$num
≤≤U Y
,
≤≤Y Z
$num
≤≤[ _
)
≤≤_ `
}
≤≤d e
,
≤≤e f
{
≥≥ 
$str
≥≥ 
,
≥≥ 
CIELabFromRGB
≥≥< I
(
≥≥I J
$num
≥≥J M
,
≥≥M N
$num
≥≥O R
,
≥≥R S
$num
≥≥T W
,
≥≥W X
$num
≥≥Y ]
)
≥≥] ^
}
≥≥d e
,
≥≥e f
{
¥¥ 
$str
¥¥ 
,
¥¥ 
CIELabFromRGB
¥¥< I
(
¥¥I J
$num
¥¥J M
,
¥¥M N
$num
¥¥O R
,
¥¥R S
$num
¥¥T W
,
¥¥W X
$num
¥¥Y ]
)
¥¥] ^
}
¥¥d e
,
¥¥e f
{
µµ 
$str
µµ 
,
µµ 
CIELabFromRGB
µµ< I
(
µµI J
$num
µµJ M
,
µµM N
$num
µµO R
,
µµR S
$num
µµT V
,
µµV W
$num
µµX \
)
µµ\ ]
}
µµd e
,
µµe f
{
∂∂ 
$str
∂∂ 
,
∂∂ 
CIELabFromRGB
∂∂< I
(
∂∂I J
$num
∂∂J M
,
∂∂M N
$num
∂∂O R
,
∂∂R S
$num
∂∂T W
,
∂∂W X
$num
∂∂Y ]
)
∂∂] ^
}
∂∂d e
,
∂∂e f
{
∑∑ 
$str
∑∑ 
,
∑∑ 
CIELabFromRGB
∑∑< I
(
∑∑I J
$num
∑∑J M
,
∑∑M N
$num
∑∑O R
,
∑∑R S
$num
∑∑T W
,
∑∑W X
$num
∑∑Y ]
)
∑∑] ^
}
∑∑_ `
,
∑∑` a
{
∏∏ 
$str
∏∏ 
,
∏∏ 
CIELabFromRGB
∏∏< I
(
∏∏I J
$num
∏∏J M
,
∏∏M N
$num
∏∏O R
,
∏∏R S
$num
∏∏T V
,
∏∏V W
$num
∏∏X \
)
∏∏\ ]
}
∏∏^ _
,
∏∏_ `
{
ππ 
$str
ππ &
,
ππ& '
CIELabFromRGB
ππ< I
(
ππI J
$num
ππJ M
,
ππM N
$num
ππO R
,
ππR S
$num
ππT V
,
ππV W
$num
ππX \
)
ππ\ ]
}
ππ^ _
,
ππ_ `
{
∫∫ 
$str
∫∫  
,
∫∫  !
CIELabFromRGB
∫∫< I
(
∫∫I J
$num
∫∫J L
,
∫∫L M
$num
∫∫N Q
,
∫∫Q R
$num
∫∫S V
,
∫∫V W
$num
∫∫X \
)
∫∫\ ]
}
∫∫^ _
,
∫∫_ `
{
ªª 
$str
ªª 
,
ªª 
CIELabFromRGB
ªª< I
(
ªªI J
$num
ªªJ M
,
ªªM N
$num
ªªO R
,
ªªR S
$num
ªªT X
,
ªªX Y
$num
ªªZ ^
)
ªª^ _
}
ªª` a
,
ªªa b
{
ºº 
$str
ºº 
,
ºº 
CIELabFromRGB
ºº< I
(
ººI J
$num
ººJ N
,
ººN O
$num
ººP S
,
ººS T
$num
ººU X
,
ººX Y
$num
ººZ ^
)
ºº^ _
}
ºº` a
,
ººa b
{
ΩΩ 
$str
ΩΩ 
,
ΩΩ 
CIELabFromRGB
ΩΩ< I
(
ΩΩI J
$num
ΩΩJ M
,
ΩΩM N
$num
ΩΩO R
,
ΩΩR S
$num
ΩΩT V
,
ΩΩV W
$num
ΩΩX \
)
ΩΩ\ ]
}
ΩΩ^ _
,
ΩΩ_ `
{
ææ 
$str
ææ 
,
ææ 
CIELabFromRGB
ææ< I
(
ææI J
$num
ææJ M
,
ææM N
$num
ææO R
,
ææR S
$num
ææT W
,
ææW X
$num
ææY ]
)
ææ] ^
}
ææ_ `
,
ææ` a
{
øø 
$str
øø 
,
øø 
CIELabFromRGB
øø< I
(
øøI J
$num
øøJ M
,
øøM N
$num
øøO R
,
øøR S
$num
øøT W
,
øøW X
$num
øøY ]
)
øø] ^
}
øø_ `
,
øø` a
{
¿¿ 
$str
¿¿ 
,
¿¿ 
CIELabFromRGB
¿¿< I
(
¿¿I J
$num
¿¿J L
,
¿¿L M
$num
¿¿N Q
,
¿¿Q R
$num
¿¿S V
,
¿¿V W
$num
¿¿X \
)
¿¿\ ]
}
¿¿^ _
,
¿¿_ `
{
¡¡ 
$str
¡¡ 
,
¡¡  
CIELabFromRGB
¡¡< I
(
¡¡I J
$num
¡¡J M
,
¡¡M N
$num
¡¡O R
,
¡¡R S
$num
¡¡T W
,
¡¡W X
$num
¡¡Y ]
)
¡¡] ^
}
¡¡_ `
,
¡¡` a
{
¬¬ 
$str
¬¬ #
,
¬¬# $
CIELabFromRGB
¬¬< I
(
¬¬I J
$num
¬¬J N
,
¬¬N O
$num
¬¬P S
,
¬¬S T
$num
¬¬U W
,
¬¬W X
$num
¬¬Y ]
)
¬¬] ^
}
¬¬_ `
,
¬¬` a
{
√√ 
$str
√√ 
,
√√ 
CIELabFromRGB
√√< I
(
√√I J
$num
√√J M
,
√√M N
$num
√√O R
,
√√R S
$num
√√T W
,
√√W X
$num
√√Y ]
)
√√] ^
}
√√_ `
,
√√` a
{
ƒƒ 
$str
ƒƒ 
,
ƒƒ 
CIELabFromRGB
ƒƒ< I
(
ƒƒI J
$num
ƒƒJ M
,
ƒƒM N
$num
ƒƒO R
,
ƒƒR S
$num
ƒƒT V
,
ƒƒV W
$num
ƒƒX \
)
ƒƒ\ ]
}
ƒƒ^ _
,
ƒƒ_ `
{
≈≈ 
$str
≈≈ 
,
≈≈ 
CIELabFromRGB
≈≈< I
(
≈≈I J
$num
≈≈J M
,
≈≈M N
$num
≈≈O R
,
≈≈R S
$num
≈≈T V
,
≈≈V W
$num
≈≈X \
)
≈≈\ ]
}
≈≈^ _
,
≈≈_ `
{
∆∆ 
$str
∆∆ 
,
∆∆ 
CIELabFromRGB
∆∆< I
(
∆∆I J
$num
∆∆J N
,
∆∆N O
$num
∆∆P S
,
∆∆S T
$num
∆∆U W
,
∆∆W X
$num
∆∆Y ]
)
∆∆] ^
}
∆∆_ `
,
∆∆` a
{
«« 
$str
«« 
,
«« 
CIELabFromRGB
««< I
(
««I J
$num
««J M
,
««M N
$num
««O R
,
««R S
$num
««T W
,
««W X
$num
««Y ]
)
««] ^
}
««_ `
,
««` a
{
»» 
$str
»» "
,
»»" #
CIELabFromRGB
»»< I
(
»»I J
$num
»»J M
,
»»M N
$num
»»O R
,
»»R S
$num
»»T W
,
»»W X
$num
»»Y ]
)
»»] ^
}
»»_ `
,
»»` a
{
…… 
$str
…… 
,
…… 
CIELabFromRGB
……< I
(
……I J
$num
……J M
,
……M N
$num
……O R
,
……R S
$num
……T W
,
……W X
$num
……Y ]
)
……] ^
}
……_ `
,
……` a
{
   
$str
   
,
   
CIELabFromRGB
  < I
(
  I J
$num
  J M
,
  M N
$num
  O R
,
  R S
$num
  T W
,
  W X
$num
  Y ]
)
  ] ^
}
  _ `
,
  ` a
{
ÀÀ 
$str
ÀÀ $
,
ÀÀ$ %
CIELabFromRGB
ÀÀ< I
(
ÀÀI J
$num
ÀÀJ M
,
ÀÀM N
$num
ÀÀO R
,
ÀÀR S
$num
ÀÀT W
,
ÀÀW X
$num
ÀÀY ]
)
ÀÀ] ^
}
ÀÀ_ `
,
ÀÀ` a
{
ÃÃ 
$str
ÃÃ 
,
ÃÃ  
CIELabFromRGB
ÃÃ< I
(
ÃÃI J
$num
ÃÃJ M
,
ÃÃM N
$num
ÃÃO R
,
ÃÃR S
$num
ÃÃT W
,
ÃÃW X
$num
ÃÃY ]
)
ÃÃ] ^
}
ÃÃ_ `
,
ÃÃ` a
{
ÕÕ 
$str
ÕÕ 
,
ÕÕ 
CIELabFromRGB
ÕÕ< I
(
ÕÕI J
$num
ÕÕJ M
,
ÕÕM N
$num
ÕÕO R
,
ÕÕR S
$num
ÕÕT W
,
ÕÕW X
$num
ÕÕY ]
)
ÕÕ] ^
}
ÕÕ_ `
,
ÕÕ` a
{
ŒŒ 
$str
ŒŒ 
,
ŒŒ 
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ M
,
ŒŒM N
$num
ŒŒO R
,
ŒŒR S
$num
ŒŒT W
,
ŒŒW X
$num
ŒŒY ]
)
ŒŒ] ^
}
ŒŒ_ `
,
ŒŒ` a
{
œœ 
$str
œœ /
,
œœ/ 0
CIELabFromRGB
œœ< I
(
œœI J
$num
œœJ L
,
œœL M
$num
œœN R
,
œœR S
$num
œœT V
,
œœV W
$num
œœX \
)
œœ\ ]
}
œœ^ _
,
œœ_ `
{
–– 
$str
–– 
,
––  
CIELabFromRGB
––< I
(
––I J
$num
––J M
,
––M N
$num
––O R
,
––R S
$num
––T W
,
––W X
$num
––Y ]
)
––] ^
}
––_ `
,
––` a
{
—— 
$str
—— &
,
——& '
CIELabFromRGB
——< I
(
——I J
$num
——J L
,
——L M
$num
——N Q
,
——Q R
$num
——S U
,
——U V
$num
——W [
)
——[ \
}
——] ^
,
——^ _
{
““ 
$str
““ 
,
““  
CIELabFromRGB
““< I
(
““I J
$num
““J L
,
““L M
$num
““N Q
,
““Q R
$num
““S V
,
““V W
$num
““X \
)
““\ ]
}
““^ _
,
““_ `
{
”” 
$str
”” 
,
”” 
CIELabFromRGB
””< I
(
””I J
$num
””J L
,
””L M
$num
””N Q
,
””Q R
$num
””S V
,
””V W
$num
””X \
)
””\ ]
}
””^ _
,
””_ `
{
‘‘ 
$str
‘‘ 
,
‘‘  
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J L
,
‘‘L M
$num
‘‘N Q
,
‘‘Q R
$num
‘‘S V
,
‘‘V W
$num
‘‘X \
)
‘‘\ ]
}
‘‘^ _
,
‘‘_ `
{
’’ 
$str
’’ 
,
’’  
CIELabFromRGB
’’< I
(
’’I J
$num
’’J L
,
’’L M
$num
’’N Q
,
’’Q R
$num
’’S V
,
’’V W
$num
’’X \
)
’’\ ]
}
’’^ _
,
’’_ `
{
÷÷ 
$str
÷÷ 
,
÷÷ 
CIELabFromRGB
÷÷< I
(
÷÷I J
$num
÷÷J M
,
÷÷M N
$num
÷÷O R
,
÷÷R S
$num
÷÷T W
,
÷÷W X
$num
÷÷Y ]
)
÷÷] ^
}
÷÷_ `
,
÷÷` a
{
◊◊ 
$str
◊◊ 
,
◊◊ 
CIELabFromRGB
◊◊< I
(
◊◊I J
$num
◊◊J L
,
◊◊L M
$num
◊◊N Q
,
◊◊Q R
$num
◊◊S V
,
◊◊V W
$num
◊◊X \
)
◊◊\ ]
}
◊◊^ _
,
◊◊_ `
{
ÿÿ 
$str
ÿÿ 
,
ÿÿ 
CIELabFromRGB
ÿÿ< I
(
ÿÿI J
$num
ÿÿJ L
,
ÿÿL M
$num
ÿÿN Q
,
ÿÿQ R
$num
ÿÿS V
,
ÿÿV W
$num
ÿÿX \
)
ÿÿ\ ]
}
ÿÿ^ _
,
ÿÿ_ `
{
ŸŸ 
$str
ŸŸ 
,
ŸŸ 
CIELabFromRGB
ŸŸ< I
(
ŸŸI J
$num
ŸŸJ M
,
ŸŸM N
$num
ŸŸO S
,
ŸŸS T
$num
ŸŸU X
,
ŸŸX Y
$num
ŸŸZ ^
)
ŸŸ^ _
}
ŸŸ` a
,
ŸŸa b
{
⁄⁄ 
$str
⁄⁄ 
,
⁄⁄ 
CIELabFromRGB
⁄⁄< I
(
⁄⁄I J
$num
⁄⁄J M
,
⁄⁄M N
$num
⁄⁄O R
,
⁄⁄R S
$num
⁄⁄T V
,
⁄⁄V W
$num
⁄⁄X \
)
⁄⁄\ ]
}
⁄⁄^ _
,
⁄⁄_ `
{
€€ 
$str
€€ 
,
€€ 
CIELabFromRGB
€€< I
(
€€I J
$num
€€J M
,
€€M N
$num
€€O R
,
€€R S
$num
€€T W
,
€€W X
$num
€€Y ]
)
€€] ^
}
€€_ `
,
€€` a
{
‹‹ 
$str
‹‹ 
,
‹‹ 
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J L
,
‹‹L M
$num
‹‹N R
,
‹‹R S
$num
‹‹T W
,
‹‹W X
$num
‹‹Y ]
)
‹‹] ^
}
‹‹_ `
,
‹‹` a
{
›› 
$str
›› 
,
›› 
CIELabFromRGB
››< I
(
››I J
$num
››J M
,
››M N
$num
››O R
,
››R S
$num
››T W
,
››W X
$num
››Y ]
)
››] ^
}
››_ `
,
››` a
{
ﬁﬁ 
$str
ﬁﬁ 
,
ﬁﬁ 
CIELabFromRGB
ﬁﬁ< I
(
ﬁﬁI J
$num
ﬁﬁJ M
,
ﬁﬁM N
$num
ﬁﬁO R
,
ﬁﬁR S
$num
ﬁﬁT W
,
ﬁﬁW X
$num
ﬁﬁY ]
)
ﬁﬁ] ^
}
ﬁﬁ_ `
,
ﬁﬁ` a
{
ﬂﬂ 
$str
ﬂﬂ 
,
ﬂﬂ 
CIELabFromRGB
ﬂﬂ< I
(
ﬂﬂI J
$num
ﬂﬂJ M
,
ﬂﬂM N
$num
ﬂﬂO Q
,
ﬂﬂQ R
$num
ﬂﬂS V
,
ﬂﬂV W
$num
ﬂﬂX \
)
ﬂﬂ\ ]
}
ﬂﬂ^ _
,
ﬂﬂ_ `
{
‡‡ 
$str
‡‡ 
,
‡‡ 
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J M
,
‡‡M N
$num
‡‡O R
,
‡‡R S
$num
‡‡T W
,
‡‡W X
$num
‡‡Y ]
)
‡‡] ^
}
‡‡_ `
,
‡‡` a
{
·· 
$str
·· 
,
·· 
CIELabFromRGB
··< I
(
··I J
$num
··J M
,
··M N
$num
··O S
,
··S T
$num
··U W
,
··W X
$num
··Y ]
)
··] ^
}
··_ `
,
··` a
{
‚‚ 
$str
‚‚ 
,
‚‚  
CIELabFromRGB
‚‚< I
(
‚‚I J
$num
‚‚J M
,
‚‚M N
$num
‚‚O R
,
‚‚R S
$num
‚‚T V
,
‚‚V W
$num
‚‚X \
)
‚‚\ ]
}
‚‚^ _
,
‚‚_ `
{
„„ 
$str
„„ 
,
„„  
CIELabFromRGB
„„< I
(
„„I J
$num
„„J M
,
„„M N
$num
„„O Q
,
„„Q R
$num
„„S U
,
„„U V
$num
„„W [
)
„„[ \
}
„„] ^
,
„„^ _
{
‰‰ 
$str
‰‰ 
,
‰‰ 
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J M
,
‰‰M N
$num
‰‰O R
,
‰‰R S
$num
‰‰T V
,
‰‰V W
$num
‰‰X \
)
‰‰\ ]
}
‰‰^ _
,
‰‰_ `
{
ÂÂ 
$str
ÂÂ 
,
ÂÂ 
CIELabFromRGB
ÂÂ< I
(
ÂÂI J
$num
ÂÂJ M
,
ÂÂM N
$num
ÂÂO R
,
ÂÂR S
$num
ÂÂT V
,
ÂÂV W
$num
ÂÂX \
)
ÂÂ\ ]
}
ÂÂ^ _
,
ÂÂ_ `
{
ÊÊ 
$str
ÊÊ 
,
ÊÊ 
CIELabFromRGB
ÊÊ< I
(
ÊÊI J
$num
ÊÊJ M
,
ÊÊM N
$num
ÊÊO R
,
ÊÊR S
$num
ÊÊT X
,
ÊÊX Y
$num
ÊÊZ ^
)
ÊÊ^ _
}
ÊÊ` a
,
ÊÊa b
{
ÁÁ 
$str
ÁÁ 
,
ÁÁ  
CIELabFromRGB
ÁÁ< I
(
ÁÁI J
$num
ÁÁJ M
,
ÁÁM N
$num
ÁÁO R
,
ÁÁR S
$num
ÁÁT W
,
ÁÁW X
$num
ÁÁY ]
)
ÁÁ] ^
}
ÁÁ_ `
,
ÁÁ` a
{
ËË 
$str
ËË "
,
ËË" #
CIELabFromRGB
ËË< I
(
ËËI J
$num
ËËJ M
,
ËËM N
$num
ËËO Q
,
ËËQ R
$num
ËËS V
,
ËËV W
$num
ËËX \
)
ËË\ ]
}
ËË^ _
,
ËË_ `
{
ÈÈ 
$str
ÈÈ  
,
ÈÈ  !
CIELabFromRGB
ÈÈ< I
(
ÈÈI J
$num
ÈÈJ M
,
ÈÈM N
$num
ÈÈO Q
,
ÈÈQ R
$num
ÈÈS V
,
ÈÈV W
$num
ÈÈX \
)
ÈÈ\ ]
}
ÈÈ^ _
,
ÈÈ_ `
{
ÍÍ 
$str
ÍÍ 
,
ÍÍ 
CIELabFromRGB
ÍÍ< I
(
ÍÍI J
$num
ÍÍJ M
,
ÍÍM N
$num
ÍÍO S
,
ÍÍS T
$num
ÍÍU X
,
ÍÍX Y
$num
ÍÍZ ^
)
ÍÍ^ _
}
ÍÍ` a
,
ÍÍa b
{
ÎÎ 
$str
ÎÎ 
,
ÎÎ 
CIELabFromRGB
ÎÎ< I
(
ÎÎI J
$num
ÎÎJ L
,
ÎÎL M
$num
ÎÎN Q
,
ÎÎQ R
$num
ÎÎS V
,
ÎÎV W
$num
ÎÎX \
)
ÎÎ\ ]
}
ÎÎ^ _
,
ÎÎ_ `
{
ÏÏ 
$str
ÏÏ 
,
ÏÏ 
CIELabFromRGB
ÏÏ< I
(
ÏÏI J
$num
ÏÏJ M
,
ÏÏM N
$num
ÏÏO R
,
ÏÏR S
$num
ÏÏT W
,
ÏÏW X
$num
ÏÏY ]
)
ÏÏ] ^
}
ÏÏ_ `
,
ÏÏ` a
{
ÌÌ 
$str
ÌÌ 
,
ÌÌ 
CIELabFromRGB
ÌÌ< I
(
ÌÌI J
$num
ÌÌJ N
,
ÌÌN O
$num
ÌÌP S
,
ÌÌS T
$num
ÌÌU X
,
ÌÌX Y
$num
ÌÌZ ^
)
ÌÌ^ _
}
ÌÌ` a
,
ÌÌa b
{
ÓÓ 
$str
ÓÓ 
,
ÓÓ 
CIELabFromRGB
ÓÓ< I
(
ÓÓI J
$num
ÓÓJ N
,
ÓÓN O
$num
ÓÓP S
,
ÓÓS T
$num
ÓÓU X
,
ÓÓX Y
$num
ÓÓZ ^
)
ÓÓ^ _
}
ÓÓ` a
,
ÓÓa b
{
ÔÔ 
$str
ÔÔ 
,
ÔÔ 
CIELabFromRGB
ÔÔ< I
(
ÔÔI J
$num
ÔÔJ M
,
ÔÔM N
$num
ÔÔO R
,
ÔÔR S
$num
ÔÔT W
,
ÔÔW X
$num
ÔÔY ]
)
ÔÔ] ^
}
ÔÔ_ `
,
ÔÔ` a
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
ÒÒ 
$str
ÒÒ 
,
ÒÒ 
CIELabFromRGB
ÒÒ< I
(
ÒÒI J
$num
ÒÒJ M
,
ÒÒM N
$num
ÒÒO R
,
ÒÒR S
$num
ÒÒT W
,
ÒÒW X
$num
ÒÒY ]
)
ÒÒ] ^
}
ÒÒ_ `
,
ÒÒ` a
{
ÚÚ 
$str
ÚÚ $
,
ÚÚ$ %
CIELabFromRGB
ÚÚ< I
(
ÚÚI J
$num
ÚÚJ M
,
ÚÚM N
$num
ÚÚO R
,
ÚÚR S
$num
ÚÚT W
,
ÚÚW X
$num
ÚÚY ]
)
ÚÚ] ^
}
ÚÚ_ `
,
ÚÚ` a
{
ÛÛ 
$str
ÛÛ 
,
ÛÛ 
CIELabFromRGB
ÛÛ< I
(
ÛÛI J
$num
ÛÛJ M
,
ÛÛM N
$num
ÛÛO R
,
ÛÛR S
$num
ÛÛT W
,
ÛÛW X
$num
ÛÛY ]
)
ÛÛ] ^
}
ÛÛ_ `
,
ÛÛ` a
{
ÙÙ 
$str
ÙÙ 
,
ÙÙ 
CIELabFromRGB
ÙÙ< I
(
ÙÙI J
$num
ÙÙJ L
,
ÙÙL M
$num
ÙÙN Q
,
ÙÙQ R
$num
ÙÙS V
,
ÙÙV W
$num
ÙÙX \
)
ÙÙ\ ]
}
ÙÙ^ _
,
ÙÙ_ `
{
ıı 
$str
ıı 
,
ıı  
CIELabFromRGB
ıı< I
(
ııI J
$num
ııJ M
,
ııM N
$num
ııO Q
,
ııQ R
$num
ııS V
,
ııV W
$num
ııX \
)
ıı\ ]
}
ıı^ _
,
ıı_ `
{
ˆˆ 
$str
ˆˆ 
,
ˆˆ 
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ M
,
ˆˆM N
$num
ˆˆO R
,
ˆˆR S
$num
ˆˆT W
,
ˆˆW X
$num
ˆˆY ]
)
ˆˆ] ^
}
ˆˆ_ `
,
ˆˆ` a
{
˜˜ 
$str
˜˜ 
,
˜˜ 
CIELabFromRGB
˜˜< I
(
˜˜I J
$num
˜˜J M
,
˜˜M N
$num
˜˜O R
,
˜˜R S
$num
˜˜T W
,
˜˜W X
$num
˜˜Y ]
)
˜˜] ^
}
˜˜_ `
,
˜˜` a
{
¯¯ 
$str
¯¯ 
,
¯¯ 
CIELabFromRGB
¯¯< I
(
¯¯I J
$num
¯¯J M
,
¯¯M N
$num
¯¯O R
,
¯¯R S
$num
¯¯T W
,
¯¯W X
$num
¯¯Y ]
)
¯¯] ^
}
¯¯_ `
,
¯¯` a
{
˘˘ 
$str
˘˘ 
,
˘˘ 
CIELabFromRGB
˘˘< I
(
˘˘I J
$num
˘˘J L
,
˘˘L M
$num
˘˘N Q
,
˘˘Q R
$num
˘˘S U
,
˘˘U V
$num
˘˘W [
)
˘˘[ \
}
˘˘] ^
,
˘˘^ _
{
˙˙ 
$str
˙˙ 
,
˙˙ 
CIELabFromRGB
˙˙< I
(
˙˙I J
$num
˙˙J M
,
˙˙M N
$num
˙˙O R
,
˙˙R S
$num
˙˙T W
,
˙˙W X
$num
˙˙Y ]
)
˙˙] ^
}
˙˙_ `
,
˙˙` a
{
˚˚ 
$str
˚˚ 
,
˚˚ 
CIELabFromRGB
˚˚< I
(
˚˚I J
$num
˚˚J M
,
˚˚M N
$num
˚˚O R
,
˚˚R S
$num
˚˚T W
,
˚˚W X
$num
˚˚Y ]
)
˚˚] ^
}
˚˚_ `
,
˚˚` a
{
¸¸ 
$str
¸¸ 
,
¸¸ 
CIELabFromRGB
¸¸< I
(
¸¸I J
$num
¸¸J M
,
¸¸M N
$num
¸¸O Q
,
¸¸Q R
$num
¸¸S W
,
¸¸W X
$num
¸¸Y ]
)
¸¸] ^
}
¸¸_ `
,
¸¸` a
{
˝˝ 
$str
˝˝ 
,
˝˝ 
CIELabFromRGB
˝˝< I
(
˝˝I J
$num
˝˝J L
,
˝˝L M
$num
˝˝N Q
,
˝˝Q R
$num
˝˝S V
,
˝˝V W
$num
˝˝X \
)
˝˝\ ]
}
˝˝^ _
,
˝˝_ `
{
˛˛ 
$str
˛˛ 
,
˛˛ 
CIELabFromRGB
˛˛< I
(
˛˛I J
$num
˛˛J M
,
˛˛M N
$num
˛˛O Q
,
˛˛Q R
$num
˛˛S V
,
˛˛V W
$num
˛˛X \
)
˛˛\ ]
}
˛˛^ _
,
˛˛_ `
{
ˇˇ 
$str
ˇˇ (
,
ˇˇ( )
CIELabFromRGB
ˇˇ< I
(
ˇˇI J
$num
ˇˇJ L
,
ˇˇL M
$num
ˇˇN Q
,
ˇˇQ R
$num
ˇˇS V
,
ˇˇV W
$num
ˇˇX \
)
ˇˇ\ ]
}
ˇˇ^ _
,
ˇˇ_ `
{
ÄÄ 
$str
ÄÄ 0
,
ÄÄ0 1
CIELabFromRGB
ÄÄ< I
(
ÄÄI J
$num
ÄÄJ N
,
ÄÄN O
$num
ÄÄP S
,
ÄÄS T
$num
ÄÄU W
,
ÄÄW X
$num
ÄÄY ]
)
ÄÄ] ^
}
ÄÄ_ `
,
ÄÄ` a
{
ÅÅ 
$str
ÅÅ 2
,
ÅÅ2 3
CIELabFromRGB
ÅÅ< I
(
ÅÅI J
$num
ÅÅJ M
,
ÅÅM N
$num
ÅÅO Q
,
ÅÅQ R
$num
ÅÅS U
,
ÅÅU V
$num
ÅÅW [
)
ÅÅ[ \
}
ÅÅ] ^
,
ÅÅ^ _
{
ÇÇ 
$str
ÇÇ 9
,
ÇÇ9 :
CIELabFromRGB
ÇÇ< I
(
ÇÇI J
$num
ÇÇJ M
,
ÇÇM N
$num
ÇÇO R
,
ÇÇR S
$num
ÇÇT W
,
ÇÇW X
$num
ÇÇY ]
)
ÇÇ] ^
}
ÇÇ_ `
,
ÇÇ` a
{
ÉÉ 
$str
ÉÉ 
,
ÉÉ 
CIELabFromRGB
ÉÉ< I
(
ÉÉI J
$num
ÉÉJ M
,
ÉÉM N
$num
ÉÉO R
,
ÉÉR S
$num
ÉÉT W
,
ÉÉW X
$num
ÉÉY ]
)
ÉÉ] ^
}
ÉÉ_ `
,
ÉÉ` a
{
ÑÑ 
$str
ÑÑ 
,
ÑÑ 
CIELabFromRGB
ÑÑ< I
(
ÑÑI J
$num
ÑÑJ M
,
ÑÑM N
$num
ÑÑO R
,
ÑÑR S
$num
ÑÑT W
,
ÑÑW X
$num
ÑÑY ]
)
ÑÑ] ^
}
ÑÑ_ `
,
ÑÑ` a
{
ÖÖ 
$str
ÖÖ 
,
ÖÖ 
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ M
,
ÖÖM N
$num
ÖÖO R
,
ÖÖR S
$num
ÖÖT W
,
ÖÖW X
$num
ÖÖY ]
)
ÖÖ] ^
}
ÖÖ_ `
,
ÖÖ` a
{
ÜÜ 
$str
ÜÜ 
,
ÜÜ 
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ L
,
ÜÜL M
$num
ÜÜN Q
,
ÜÜQ R
$num
ÜÜS U
,
ÜÜU V
$num
ÜÜW [
)
ÜÜ[ \
}
ÜÜ] ^
,
ÜÜ^ _
{
áá 
$str
áá  
,
áá  !
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ M
,
ááM N
$num
ááO S
,
ááS T
$num
ááU Y
,
ááY Z
$num
áá[ _
)
áá_ `
}
ááa b
,
ááb c
{
àà 
$str
àà 
,
àà 
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ N
,
ààN O
$num
ààP T
,
ààT U
$num
ààV Y
,
ààY Z
$num
àà[ _
)
àà_ `
}
ààa b
,
ààb c
{
ââ 
$str
ââ 
,
ââ 
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ L
,
ââL M
$num
ââN Q
,
ââQ R
$num
ââS V
,
ââV W
$num
ââX \
)
ââ\ ]
}
ââ^ _
,
ââ_ `
{
ää 
$str
ää  
,
ää  !
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ M
,
ääM N
$num
ääO R
,
ääR S
$num
ääT W
,
ääW X
$num
ääY ]
)
ää] ^
}
ää_ `
,
ää` a
{
ãã 
$str
ãã 
,
ãã  
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ M
,
ããM N
$num
ããO R
,
ããR S
$num
ããT W
,
ããW X
$num
ããY ]
)
ãã] ^
}
ãã_ `
,
ãã` a
{
åå 
$str
åå 
,
åå  
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ M
,
ååM N
$num
ååO R
,
ååR S
$num
ååT W
,
ååW X
$num
ååY ]
)
åå] ^
}
åå_ `
,
åå` a
{
çç 
$str
çç 
,
çç 
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ M
,
ççM N
$num
ççO R
,
ççR S
$num
ççT W
,
ççW X
$num
ççY ]
)
çç] ^
}
çç_ `
,
çç` a
{
éé 
$str
éé 
,
éé 
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ M
,
ééM N
$num
ééO R
,
ééR S
$num
ééT W
,
ééW X
$num
ééY ]
)
éé] ^
}
éé_ `
,
éé` a
{
èè 
$str
èè 
,
èè 
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ M
,
èèM N
$num
èèO Q
,
èèQ R
$num
èèS V
,
èèV W
$num
èèX \
)
èè\ ]
}
èè^ _
,
èè_ `
{
êê 
$str
êê 
,
êê 
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ M
,
êêM N
$num
êêO R
,
êêR S
$num
êêT W
,
êêW X
$num
êêY ]
)
êê] ^
}
êê_ `
,
êê` a
{
ëë 
$str
ëë 
,
ëë 
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ M
,
ëëM N
$num
ëëO R
,
ëëR S
$num
ëëT W
,
ëëW X
$num
ëëY ]
)
ëë] ^
}
ëë_ `
,
ëë` a
{
íí 
$str
íí 
,
íí 
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ M
,
ííM N
$num
ííO R
,
ííR S
$num
ííT V
,
ííV W
$num
ííX \
)
íí\ ]
}
íí^ _
,
íí_ `
{
ìì 
$str
ìì 
,
ìì 
CIELabFromRGB
ìì< I
(
ììI J
$num
ììJ M
,
ììM N
$num
ììO R
,
ììR S
$num
ììT W
,
ììW X
$num
ììY ]
)
ìì] ^
}
ìì_ `
,
ìì` a
{
îî 
$str
îî 
,
îî 
CIELabFromRGB
îî< I
(
îîI J
$num
îîJ M
,
îîM N
$num
îîO R
,
îîR S
$num
îîT W
,
îîW X
$num
îîY ]
)
îî] ^
}
îî_ `
,
îî` a
{
ïï 
$str
ïï 
,
ïï 
CIELabFromRGB
ïï< I
(
ïïI J
$num
ïïJ M
,
ïïM N
$num
ïïO R
,
ïïR S
$num
ïïT W
,
ïïW X
$num
ïïY ]
)
ïï] ^
}
ïï_ `
,
ïï` a
{
ññ 
$str
ññ 
,
ññ 
CIELabFromRGB
ññ< I
(
ññI J
$num
ññJ M
,
ññM N
$num
ññO R
,
ññR S
$num
ññT V
,
ññV W
$num
ññX \
)
ññ\ ]
}
ññ^ _
,
ññ_ `
{
óó 
$str
óó 
,
óó 
CIELabFromRGB
óó< I
(
óóI J
$num
óóJ M
,
óóM N
$num
óóO R
,
óóR S
$num
óóT V
,
óóV W
$num
óóX \
)
óó\ ]
}
óó^ _
,
óó_ `
{
òò 
$str
òò 
,
òò 
CIELabFromRGB
òò< I
(
òòI J
$num
òòJ M
,
òòM N
$num
òòO R
,
òòR S
$num
òòT W
,
òòW X
$num
òòY ]
)
òò] ^
}
òò_ `
,
òò` a
{
ôô 
$str
ôô 6
,
ôô6 7
CIELabFromRGB
ôô< I
(
ôôI J
$num
ôôJ M
,
ôôM N
$num
ôôO R
,
ôôR S
$num
ôôT W
,
ôôW X
$num
ôôY ]
)
ôô] ^
}
ôô_ `
,
ôô` a
{
öö 
$str
öö )
,
öö) *
CIELabFromRGB
öö< I
(
ööI J
$num
ööJ M
,
ööM N
$num
ööO R
,
ööR S
$num
ööT W
,
ööW X
$num
ööY ]
)
öö] ^
}
öö_ `
,
öö` a
{
õõ 
$str
õõ 
,
õõ 
CIELabFromRGB
õõ< I
(
õõI J
$num
õõJ M
,
õõM N
$num
õõO R
,
õõR S
$num
õõT V
,
õõV W
$num
õõX \
)
õõ\ ]
}
õõ^ _
,
õõ_ `
{
úú 
$str
úú 
,
úú 
CIELabFromRGB
úú< I
(
úúI J
$num
úúJ M
,
úúM N
$num
úúO R
,
úúR S
$num
úúT W
,
úúW X
$num
úúY ]
)
úú] ^
}
úú_ `
,
úú` a
{
ùù 
$str
ùù 
,
ùù 
CIELabFromRGB
ùù< I
(
ùùI J
$num
ùùJ M
,
ùùM N
$num
ùùO R
,
ùùR S
$num
ùùT W
,
ùùW X
$num
ùùY ]
)
ùù] ^
}
ùù_ `
,
ùù` a
{
ûû 
$str
ûû 
,
ûû 
CIELabFromRGB
ûû< I
(
ûûI J
$num
ûûJ M
,
ûûM N
$num
ûûO Q
,
ûûQ R
$num
ûûS U
,
ûûU V
$num
ûûW [
)
ûû[ \
}
ûû] ^
,
ûû^ _
{
üü 
$str
üü 
,
üü 
CIELabFromRGB
üü< I
(
üüI J
$num
üüJ L
,
üüL M
$num
üüN Q
,
üüQ R
$num
üüS V
,
üüV W
$num
üüX \
)
üü\ ]
}
üü^ _
,
üü_ `
{
†† 
$str
††  
,
††  !
CIELabFromRGB
††< I
(
††I J
$num
††J M
,
††M N
$num
††O R
,
††R S
$num
††T W
,
††W X
$num
††Y ]
)
††] ^
}
††_ `
,
††` a
{
°° 
$str
°° 
,
°° 
CIELabFromRGB
°°< I
(
°°I J
$num
°°J M
,
°°M N
$num
°°O R
,
°°R S
$num
°°T W
,
°°W X
$num
°°Y ]
)
°°] ^
}
°°_ `
,
°°` a
{
¢¢ 
$str
¢¢ 
,
¢¢ 
CIELabFromRGB
¢¢< I
(
¢¢I J
$num
¢¢J N
,
¢¢N O
$num
¢¢P T
,
¢¢T U
$num
¢¢V Y
,
¢¢Y Z
$num
¢¢[ _
)
¢¢_ `
}
¢¢a b
,
¢¢b c
{
££ 
$str
££ 
,
££ 
CIELabFromRGB
££< I
(
££I J
$num
££J M
,
££M N
$num
££O R
,
££R S
$num
££T W
,
££W X
$num
££Y ]
)
££] ^
}
££_ `
,
££` a
{
§§ 
$str
§§ 
,
§§ 
CIELabFromRGB
§§< I
(
§§I J
$num
§§J M
,
§§M N
$num
§§O Q
,
§§Q R
$num
§§S V
,
§§V W
$num
§§X \
)
§§\ ]
}
§§^ _
,
§§_ `
{
•• 
$str
•• !
,
••! "
CIELabFromRGB
••< I
(
••I J
$num
••J M
,
••M N
$num
••O R
,
••R S
$num
••T W
,
••W X
$num
••Y ]
)
••] ^
}
••_ `
,
••` a
{
¶¶ 
$str
¶¶ 
,
¶¶ 
CIELabFromRGB
¶¶< I
(
¶¶I J
$num
¶¶J M
,
¶¶M N
$num
¶¶O R
,
¶¶R S
$num
¶¶T W
,
¶¶W X
$num
¶¶Y ]
)
¶¶] ^
}
¶¶_ `
,
¶¶` a
{
ßß 
$str
ßß 
,
ßß 
CIELabFromRGB
ßß< I
(
ßßI J
$num
ßßJ M
,
ßßM N
$num
ßßO R
,
ßßR S
$num
ßßT X
,
ßßX Y
$num
ßßZ ^
)
ßß^ _
}
ßß` a
,
ßßa b
{
®® 
$str
®® 
,
®® 
CIELabFromRGB
®®< I
(
®®I J
$num
®®J N
,
®®N O
$num
®®P S
,
®®S T
$num
®®U X
,
®®X Y
$num
®®Z ^
)
®®^ _
}
®®` a
,
®®a b
{
©© 
$str
©© 
,
©© 
CIELabFromRGB
©©< I
(
©©I J
$num
©©J M
,
©©M N
$num
©©O R
,
©©R S
$num
©©T W
,
©©W X
$num
©©Y ]
)
©©] ^
}
©©_ `
,
©©` a
{
™™ 
$str
™™ 
,
™™  
CIELabFromRGB
™™< I
(
™™I J
$num
™™J M
,
™™M N
$num
™™O R
,
™™R S
$num
™™T W
,
™™W X
$num
™™Y ]
)
™™] ^
}
™™_ `
,
™™` a
{
´´ 
$str
´´  
,
´´  !
CIELabFromRGB
´´< I
(
´´I J
$num
´´J M
,
´´M N
$num
´´O R
,
´´R S
$num
´´T W
,
´´W X
$num
´´Y ]
)
´´] ^
}
´´_ `
,
´´` a
{
¨¨ 
$str
¨¨ 
,
¨¨ 
CIELabFromRGB
¨¨< I
(
¨¨I J
$num
¨¨J M
,
¨¨M N
$num
¨¨O R
,
¨¨R S
$num
¨¨T W
,
¨¨W X
$num
¨¨Y ]
)
¨¨] ^
}
¨¨_ `
,
¨¨` a
{
≠≠ 
$str
≠≠ 
,
≠≠ 
CIELabFromRGB
≠≠< I
(
≠≠I J
$num
≠≠J M
,
≠≠M N
$num
≠≠O R
,
≠≠R S
$num
≠≠T W
,
≠≠W X
$num
≠≠Y ]
)
≠≠] ^
}
≠≠_ `
,
≠≠` a
{
ÆÆ 
$str
ÆÆ 
,
ÆÆ  
CIELabFromRGB
ÆÆ< I
(
ÆÆI J
$num
ÆÆJ M
,
ÆÆM N
$num
ÆÆO R
,
ÆÆR S
$num
ÆÆT W
,
ÆÆW X
$num
ÆÆY ]
)
ÆÆ] ^
}
ÆÆ_ `
,
ÆÆ` a
{
ØØ 
$str
ØØ 
,
ØØ 
CIELabFromRGB
ØØ< I
(
ØØI J
$num
ØØJ M
,
ØØM N
$num
ØØO R
,
ØØR S
$num
ØØT W
,
ØØW X
$num
ØØY ]
)
ØØ] ^
}
ØØ_ `
,
ØØ` a
{
∞∞ 
$str
∞∞ 
,
∞∞ 
CIELabFromRGB
∞∞< I
(
∞∞I J
$num
∞∞J M
,
∞∞M N
$num
∞∞O R
,
∞∞R S
$num
∞∞T V
,
∞∞V W
$num
∞∞X \
)
∞∞\ ]
}
∞∞^ _
,
∞∞_ `
{
±± 
$str
±± 
,
±± 
CIELabFromRGB
±±< I
(
±±I J
$num
±±J N
,
±±N O
$num
±±P S
,
±±S T
$num
±±U W
,
±±W X
$num
±±Y ]
)
±±] ^
}
±±_ `
,
±±` a
{
≤≤ 
$str
≤≤ 
,
≤≤ 
CIELabFromRGB
≤≤< I
(
≤≤I J
$num
≤≤J N
,
≤≤N O
$num
≤≤P S
,
≤≤S T
$num
≤≤U X
,
≤≤X Y
$num
≤≤Z ^
)
≤≤^ _
}
≤≤` a
,
≤≤a b
{
≥≥ 
$str
≥≥ 
,
≥≥ 
CIELabFromRGB
≥≥< I
(
≥≥I J
$num
≥≥J M
,
≥≥M N
$num
≥≥O R
,
≥≥R S
$num
≥≥T W
,
≥≥W X
$num
≥≥Y ]
)
≥≥] ^
}
≥≥_ `
,
≥≥` a
{
¥¥ 
$str
¥¥ 
,
¥¥ 
CIELabFromRGB
¥¥< I
(
¥¥I J
$num
¥¥J M
,
¥¥M N
$num
¥¥O S
,
¥¥S T
$num
¥¥U W
,
¥¥W X
$num
¥¥Y ]
)
¥¥] ^
}
¥¥_ `
,
¥¥` a
{
µµ 
$str
µµ 
,
µµ 
CIELabFromRGB
µµ< I
(
µµI J
$num
µµJ M
,
µµM N
$num
µµO S
,
µµS T
$num
µµU W
,
µµW X
$num
µµY ]
)
µµ] ^
}
µµ_ `
,
µµ` a
{
∂∂ 
$str
∂∂ 
,
∂∂ 
CIELabFromRGB
∂∂< I
(
∂∂I J
$num
∂∂J M
,
∂∂M N
$num
∂∂O R
,
∂∂R S
$num
∂∂T W
,
∂∂W X
$num
∂∂Y ]
)
∂∂] ^
}
∂∂_ `
,
∂∂` a
{
∑∑ 
$str
∑∑ 
,
∑∑ 
CIELabFromRGB
∑∑< I
(
∑∑I J
$num
∑∑J N
,
∑∑N O
$num
∑∑P S
,
∑∑S T
$num
∑∑U X
,
∑∑X Y
$num
∑∑Z ^
)
∑∑^ _
}
∑∑` a
,
∑∑a b
{
∏∏ 
$str
∏∏ 
,
∏∏ 
CIELabFromRGB
∏∏< I
(
∏∏I J
$num
∏∏J M
,
∏∏M N
$num
∏∏O R
,
∏∏R S
$num
∏∏T W
,
∏∏W X
$num
∏∏Y ]
)
∏∏] ^
}
∏∏_ `
,
∏∏` a
{
ππ 
$str
ππ 
,
ππ 
CIELabFromRGB
ππ< I
(
ππI J
$num
ππJ M
,
ππM N
$num
ππO Q
,
ππQ R
$num
ππS U
,
ππU V
$num
ππW [
)
ππ[ \
}
ππ] ^
,
ππ^ _
{
∫∫ 
$str
∫∫ 
,
∫∫ 
CIELabFromRGB
∫∫< I
(
∫∫I J
$num
∫∫J M
,
∫∫M N
$num
∫∫O R
,
∫∫R S
$num
∫∫T W
,
∫∫W X
$num
∫∫Y ]
)
∫∫] ^
}
∫∫_ `
,
∫∫` a
{
ªª 
$str
ªª 
,
ªª 
CIELabFromRGB
ªª< I
(
ªªI J
$num
ªªJ M
,
ªªM N
$num
ªªO R
,
ªªR S
$num
ªªT W
,
ªªW X
$num
ªªY ]
)
ªª] ^
}
ªª_ `
,
ªª` a
{
ºº 
$str
ºº 
,
ºº 
CIELabFromRGB
ºº< I
(
ººI J
$num
ººJ M
,
ººM N
$num
ººO R
,
ººR S
$num
ººT W
,
ººW X
$num
ººY ]
)
ºº] ^
}
ºº_ `
,
ºº` a
{
ΩΩ 
$str
ΩΩ #
,
ΩΩ# $
CIELabFromRGB
ΩΩ< I
(
ΩΩI J
$num
ΩΩJ N
,
ΩΩN O
$num
ΩΩP S
,
ΩΩS T
$num
ΩΩU X
,
ΩΩX Y
$num
ΩΩZ ^
)
ΩΩ^ _
}
ΩΩ` a
,
ΩΩa b
{
ææ 
$str
ææ 
,
ææ 
CIELabFromRGB
ææ< I
(
ææI J
$num
ææJ M
,
ææM N
$num
ææO R
,
ææR S
$num
ææT W
,
ææW X
$num
ææY ]
)
ææ] ^
}
ææ_ `
,
ææ` a
{
øø 
$str
øø "
,
øø" #
CIELabFromRGB
øø< I
(
øøI J
$num
øøJ M
,
øøM N
$num
øøO R
,
øøR S
$num
øøT W
,
øøW X
$num
øøY ]
)
øø] ^
}
øø_ `
,
øø` a
{
¿¿ 
$str
¿¿ !
,
¿¿! "
CIELabFromRGB
¿¿< I
(
¿¿I J
$num
¿¿J M
,
¿¿M N
$num
¿¿O R
,
¿¿R S
$num
¿¿T W
,
¿¿W X
$num
¿¿Y ]
)
¿¿] ^
}
¿¿_ `
,
¿¿` a
{
¡¡ 
$str
¡¡ 
,
¡¡ 
CIELabFromRGB
¡¡< I
(
¡¡I J
$num
¡¡J M
,
¡¡M N
$num
¡¡O R
,
¡¡R S
$num
¡¡T W
,
¡¡W X
$num
¡¡Y ]
)
¡¡] ^
}
¡¡_ `
,
¡¡` a
{
¬¬ 
$str
¬¬ %
,
¬¬% &
CIELabFromRGB
¬¬< I
(
¬¬I J
$num
¬¬J M
,
¬¬M N
$num
¬¬O R
,
¬¬R S
$num
¬¬T W
,
¬¬W X
$num
¬¬Y ]
)
¬¬] ^
}
¬¬_ `
,
¬¬` a
{
√√ 
$str
√√ 
,
√√ 
CIELabFromRGB
√√< I
(
√√I J
$num
√√J M
,
√√M N
$num
√√O R
,
√√R S
$num
√√T W
,
√√W X
$num
√√Y ]
)
√√] ^
}
√√_ `
,
√√` a
{
ƒƒ 
$str
ƒƒ 
,
ƒƒ 
CIELabFromRGB
ƒƒ< I
(
ƒƒI J
$num
ƒƒJ M
,
ƒƒM N
$num
ƒƒO S
,
ƒƒS T
$num
ƒƒU Y
,
ƒƒY Z
$num
ƒƒ[ _
)
ƒƒ_ `
}
ƒƒa b
,
ƒƒb c
{
≈≈ 
$str
≈≈ 
,
≈≈  
CIELabFromRGB
≈≈< I
(
≈≈I J
$num
≈≈J N
,
≈≈N O
$num
≈≈P S
,
≈≈S T
$num
≈≈U X
,
≈≈X Y
$num
≈≈Z ^
)
≈≈^ _
}
≈≈` a
,
≈≈a b
{
∆∆ 
$str
∆∆ "
,
∆∆" #
CIELabFromRGB
∆∆< I
(
∆∆I J
$num
∆∆J M
,
∆∆M N
$num
∆∆O R
,
∆∆R S
$num
∆∆T W
,
∆∆W X
$num
∆∆Y ]
)
∆∆] ^
}
∆∆_ `
,
∆∆` a
{
«« 
$str
«« "
,
««" #
CIELabFromRGB
««< I
(
««I J
$num
««J M
,
««M N
$num
««O R
,
««R S
$num
««T W
,
««W X
$num
««Y ]
)
««] ^
}
««_ `
,
««` a
{
»» 
$str
»» &
,
»»& '
CIELabFromRGB
»»< I
(
»»I J
$num
»»J M
,
»»M N
$num
»»O R
,
»»R S
$num
»»T W
,
»»W X
$num
»»Y ]
)
»»] ^
}
»»_ `
,
»»` a
{
…… 
$str
…… 
,
…… 
CIELabFromRGB
……< I
(
……I J
$num
……J M
,
……M N
$num
……O R
,
……R S
$num
……T W
,
……W X
$num
……Y ]
)
……] ^
}
……_ `
,
……` a
{
   
$str
   %
,
  % &
CIELabFromRGB
  < I
(
  I J
$num
  J M
,
  M N
$num
  O R
,
  R S
$num
  T W
,
  W X
$num
  Y ]
)
  ] ^
}
  _ `
,
  ` a
{
ÀÀ 
$str
ÀÀ 
,
ÀÀ 
CIELabFromRGB
ÀÀ< I
(
ÀÀI J
$num
ÀÀJ M
,
ÀÀM N
$num
ÀÀO R
,
ÀÀR S
$num
ÀÀT W
,
ÀÀW X
$num
ÀÀY ]
)
ÀÀ] ^
}
ÀÀ_ `
,
ÀÀ` a
{
ÃÃ 
$str
ÃÃ 
,
ÃÃ 
CIELabFromRGB
ÃÃ< I
(
ÃÃI J
$num
ÃÃJ N
,
ÃÃN O
$num
ÃÃP S
,
ÃÃS T
$num
ÃÃU X
,
ÃÃX Y
$num
ÃÃZ ^
)
ÃÃ^ _
}
ÃÃ` a
,
ÃÃa b
{
ÕÕ 
$str
ÕÕ 
,
ÕÕ 
CIELabFromRGB
ÕÕ< I
(
ÕÕI J
$num
ÕÕJ M
,
ÕÕM N
$num
ÕÕO R
,
ÕÕR S
$num
ÕÕT W
,
ÕÕW X
$num
ÕÕY ]
)
ÕÕ] ^
}
ÕÕ_ `
,
ÕÕ` a
{
ŒŒ 
$str
ŒŒ #
,
ŒŒ# $
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ M
,
ŒŒM N
$num
ŒŒO R
,
ŒŒR S
$num
ŒŒT W
,
ŒŒW X
$num
ŒŒY ]
)
ŒŒ] ^
}
ŒŒ_ `
,
ŒŒ` a
{
œœ 
$str
œœ  
,
œœ  !
CIELabFromRGB
œœ< I
(
œœI J
$num
œœJ M
,
œœM N
$num
œœO R
,
œœR S
$num
œœT W
,
œœW X
$num
œœY ]
)
œœ] ^
}
œœ_ `
,
œœ` a
{
–– 
$str
–– 
,
–– 
CIELabFromRGB
––< I
(
––I J
$num
––J M
,
––M N
$num
––O R
,
––R S
$num
––T W
,
––W X
$num
––Y ]
)
––] ^
}
––_ `
,
––` a
{
—— 
$str
—— #
,
——# $
CIELabFromRGB
——< I
(
——I J
$num
——J M
,
——M N
$num
——O R
,
——R S
$num
——T W
,
——W X
$num
——Y ]
)
——] ^
}
——_ `
,
——` a
{
““ 
$str
““ 
,
““ 
CIELabFromRGB
““< I
(
““I J
$num
““J N
,
““N O
$num
““P S
,
““S T
$num
““U X
,
““X Y
$num
““Z ^
)
““^ _
}
““` a
,
““a b
{
”” 
$str
”” 
,
””  
CIELabFromRGB
””< I
(
””I J
$num
””J M
,
””M N
$num
””O R
,
””R S
$num
””T W
,
””W X
$num
””Y ]
)
””] ^
}
””_ `
,
””` a
{
‘‘ 
$str
‘‘ 
,
‘‘ 
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J N
,
‘‘N O
$num
‘‘P S
,
‘‘S T
$num
‘‘U X
,
‘‘X Y
$num
‘‘Z ^
)
‘‘^ _
}
‘‘` a
,
‘‘a b
{
’’ 
$str
’’ !
,
’’! "
CIELabFromRGB
’’< I
(
’’I J
$num
’’J N
,
’’N O
$num
’’P S
,
’’S T
$num
’’U X
,
’’X Y
$num
’’Z ^
)
’’^ _
}
’’` a
,
’’a b
{
÷÷ 
$str
÷÷ 
,
÷÷  
CIELabFromRGB
÷÷< I
(
÷÷I J
$num
÷÷J M
,
÷÷M N
$num
÷÷O R
,
÷÷R S
$num
÷÷T W
,
÷÷W X
$num
÷÷Y ]
)
÷÷] ^
}
÷÷_ `
,
÷÷` a
{
◊◊ 
$str
◊◊ 
,
◊◊ 
CIELabFromRGB
◊◊< I
(
◊◊I J
$num
◊◊J M
,
◊◊M N
$num
◊◊O R
,
◊◊R S
$num
◊◊T W
,
◊◊W X
$num
◊◊Y ]
)
◊◊] ^
}
◊◊_ `
,
◊◊` a
{
ÿÿ 
$str
ÿÿ  
,
ÿÿ  !
CIELabFromRGB
ÿÿ< I
(
ÿÿI J
$num
ÿÿJ M
,
ÿÿM N
$num
ÿÿO R
,
ÿÿR S
$num
ÿÿT W
,
ÿÿW X
$num
ÿÿY ]
)
ÿÿ] ^
}
ÿÿ_ `
,
ÿÿ` a
{
ŸŸ 
$str
ŸŸ  
,
ŸŸ  !
CIELabFromRGB
ŸŸ< I
(
ŸŸI J
$num
ŸŸJ M
,
ŸŸM N
$num
ŸŸO R
,
ŸŸR S
$num
ŸŸT W
,
ŸŸW X
$num
ŸŸY ]
)
ŸŸ] ^
}
ŸŸ_ `
,
ŸŸ` a
{
⁄⁄ 
$str
⁄⁄ 
,
⁄⁄ 
CIELabFromRGB
⁄⁄< I
(
⁄⁄I J
$num
⁄⁄J M
,
⁄⁄M N
$num
⁄⁄O R
,
⁄⁄R S
$num
⁄⁄T W
,
⁄⁄W X
$num
⁄⁄Y ]
)
⁄⁄] ^
}
⁄⁄_ `
,
⁄⁄` a
{
€€ 
$str
€€ "
,
€€" #
CIELabFromRGB
€€< I
(
€€I J
$num
€€J M
,
€€M N
$num
€€O R
,
€€R S
$num
€€T W
,
€€W X
$num
€€Y ]
)
€€] ^
}
€€_ `
,
€€` a
{
‹‹ 
$str
‹‹ 
,
‹‹ 
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J N
,
‹‹N O
$num
‹‹P T
,
‹‹T U
$num
‹‹V Y
,
‹‹Y Z
$num
‹‹[ _
)
‹‹_ `
}
‹‹a b
,
‹‹b c
{
›› 
$str
›› 
,
›› 
CIELabFromRGB
››< I
(
››I J
$num
››J M
,
››M N
$num
››O R
,
››R S
$num
››T W
,
››W X
$num
››Y ]
)
››] ^
}
››_ `
,
››` a
{
ﬁﬁ 
$str
ﬁﬁ "
,
ﬁﬁ" #
CIELabFromRGB
ﬁﬁ< I
(
ﬁﬁI J
$num
ﬁﬁJ M
,
ﬁﬁM N
$num
ﬁﬁO S
,
ﬁﬁS T
$num
ﬁﬁU W
,
ﬁﬁW X
$num
ﬁﬁY ]
)
ﬁﬁ] ^
}
ﬁﬁ_ `
,
ﬁﬁ` a
{
ﬂﬂ 
$str
ﬂﬂ &
,
ﬂﬂ& '
CIELabFromRGB
ﬂﬂ< I
(
ﬂﬂI J
$num
ﬂﬂJ L
,
ﬂﬂL M
$num
ﬂﬂN R
,
ﬂﬂR S
$num
ﬂﬂT V
,
ﬂﬂV W
$num
ﬂﬂX \
)
ﬂﬂ\ ]
}
ﬂﬂ^ _
,
ﬂﬂ_ `
{
‡‡ 
$str
‡‡ 
,
‡‡ 
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J M
,
‡‡M N
$num
‡‡O R
,
‡‡R S
$num
‡‡T W
,
‡‡W X
$num
‡‡Y ]
)
‡‡] ^
}
‡‡_ `
,
‡‡` a
{
·· 
$str
·· 
,
·· 
CIELabFromRGB
··< I
(
··I J
$num
··J M
,
··M N
$num
··O R
,
··R S
$num
··T V
,
··V W
$num
··X \
)
··\ ]
}
··^ _
,
··_ `
{
‚‚ 
$str
‚‚ 
,
‚‚ 
CIELabFromRGB
‚‚< I
(
‚‚I J
$num
‚‚J M
,
‚‚M N
$num
‚‚O R
,
‚‚R S
$num
‚‚T V
,
‚‚V W
$num
‚‚X \
)
‚‚\ ]
}
‚‚^ _
,
‚‚_ `
{
„„ 
$str
„„ 
,
„„ 
CIELabFromRGB
„„< I
(
„„I J
$num
„„J M
,
„„M N
$num
„„O R
,
„„R S
$num
„„T W
,
„„W X
$num
„„Y ]
)
„„] ^
}
„„_ `
,
„„` a
{
‰‰ 
$str
‰‰ 
,
‰‰ 
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J M
,
‰‰M N
$num
‰‰O R
,
‰‰R S
$num
‰‰T W
,
‰‰W X
$num
‰‰Y ]
)
‰‰] ^
}
‰‰_ `
,
‰‰` a
{
ÂÂ 
$str
ÂÂ 
,
ÂÂ 
CIELabFromRGB
ÂÂ< I
(
ÂÂI J
$num
ÂÂJ M
,
ÂÂM N
$num
ÂÂO R
,
ÂÂR S
$num
ÂÂT W
,
ÂÂW X
$num
ÂÂY ]
)
ÂÂ] ^
}
ÂÂ_ `
,
ÂÂ` a
{
ÊÊ 
$str
ÊÊ 
,
ÊÊ  
CIELabFromRGB
ÊÊ< I
(
ÊÊI J
$num
ÊÊJ M
,
ÊÊM N
$num
ÊÊO R
,
ÊÊR S
$num
ÊÊT W
,
ÊÊW X
$num
ÊÊY ]
)
ÊÊ] ^
}
ÊÊ_ `
,
ÊÊ` a
{
ÁÁ 
$str
ÁÁ 
,
ÁÁ 
CIELabFromRGB
ÁÁ< I
(
ÁÁI J
$num
ÁÁJ M
,
ÁÁM N
$num
ÁÁO R
,
ÁÁR S
$num
ÁÁT W
,
ÁÁW X
$num
ÁÁY ]
)
ÁÁ] ^
}
ÁÁ_ `
,
ÁÁ` a
{
ËË 
$str
ËË 
,
ËË 
CIELabFromRGB
ËË< I
(
ËËI J
$num
ËËJ M
,
ËËM N
$num
ËËO R
,
ËËR S
$num
ËËT W
,
ËËW X
$num
ËËY ]
)
ËË] ^
}
ËË_ `
,
ËË` a
{
ÈÈ 
$str
ÈÈ 
,
ÈÈ 
CIELabFromRGB
ÈÈ< I
(
ÈÈI J
$num
ÈÈJ M
,
ÈÈM N
$num
ÈÈO R
,
ÈÈR S
$num
ÈÈT W
,
ÈÈW X
$num
ÈÈY ]
)
ÈÈ] ^
}
ÈÈ_ `
,
ÈÈ` a
{
ÍÍ 
$str
ÍÍ 
,
ÍÍ 
CIELabFromRGB
ÍÍ< I
(
ÍÍI J
$num
ÍÍJ M
,
ÍÍM N
$num
ÍÍO R
,
ÍÍR S
$num
ÍÍT W
,
ÍÍW X
$num
ÍÍY ]
)
ÍÍ] ^
}
ÍÍ_ `
,
ÍÍ` a
{
ÎÎ 
$str
ÎÎ 
,
ÎÎ 
CIELabFromRGB
ÎÎ< I
(
ÎÎI J
$num
ÎÎJ M
,
ÎÎM N
$num
ÎÎO R
,
ÎÎR S
$num
ÎÎT W
,
ÎÎW X
$num
ÎÎY ]
)
ÎÎ] ^
}
ÎÎ_ `
,
ÎÎ` a
{
ÏÏ 
$str
ÏÏ 
,
ÏÏ 
CIELabFromRGB
ÏÏ< I
(
ÏÏI J
$num
ÏÏJ N
,
ÏÏN O
$num
ÏÏP S
,
ÏÏS T
$num
ÏÏU X
,
ÏÏX Y
$num
ÏÏZ ^
)
ÏÏ^ _
}
ÏÏ` a
,
ÏÏa b
{
ÌÌ 
$str
ÌÌ 
,
ÌÌ 
CIELabFromRGB
ÌÌ< I
(
ÌÌI J
$num
ÌÌJ M
,
ÌÌM N
$num
ÌÌO R
,
ÌÌR S
$num
ÌÌT W
,
ÌÌW X
$num
ÌÌY ]
)
ÌÌ] ^
}
ÌÌ_ `
,
ÌÌ` a
{
ÓÓ 
$str
ÓÓ 
,
ÓÓ 
CIELabFromRGB
ÓÓ< I
(
ÓÓI J
$num
ÓÓJ N
,
ÓÓN O
$num
ÓÓP R
,
ÓÓR S
$num
ÓÓT X
,
ÓÓX Y
$num
ÓÓZ ^
)
ÓÓ^ _
}
ÓÓ` a
,
ÓÓa b
{
ÔÔ 
$str
ÔÔ !
,
ÔÔ! "
CIELabFromRGB
ÔÔ< I
(
ÔÔI J
$num
ÔÔJ N
,
ÔÔN O
$num
ÔÔP S
,
ÔÔS T
$num
ÔÔU X
,
ÔÔX Y
$num
ÔÔZ ^
)
ÔÔ^ _
}
ÔÔ` a
,
ÔÔa b
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
ÒÒ 
$str
ÒÒ !
,
ÒÒ! "
CIELabFromRGB
ÒÒ< I
(
ÒÒI J
$num
ÒÒJ M
,
ÒÒM N
$num
ÒÒO R
,
ÒÒR S
$num
ÒÒT W
,
ÒÒW X
$num
ÒÒY ]
)
ÒÒ] ^
}
ÒÒ_ `
,
ÒÒ` a
{
ÚÚ 
$str
ÚÚ !
,
ÚÚ! "
CIELabFromRGB
ÚÚ< I
(
ÚÚI J
$num
ÚÚJ N
,
ÚÚN O
$num
ÚÚP R
,
ÚÚR S
$num
ÚÚT W
,
ÚÚW X
$num
ÚÚY ]
)
ÚÚ] ^
}
ÚÚ_ `
,
ÚÚ` a
{
ÛÛ 
$str
ÛÛ 
,
ÛÛ 
CIELabFromRGB
ÛÛ< I
(
ÛÛI J
$num
ÛÛJ M
,
ÛÛM N
$num
ÛÛO R
,
ÛÛR S
$num
ÛÛT W
,
ÛÛW X
$num
ÛÛY ]
)
ÛÛ] ^
}
ÛÛ_ `
,
ÛÛ` a
{
ÙÙ 
$str
ÙÙ 
,
ÙÙ 
CIELabFromRGB
ÙÙ< I
(
ÙÙI J
$num
ÙÙJ M
,
ÙÙM N
$num
ÙÙO R
,
ÙÙR S
$num
ÙÙT W
,
ÙÙW X
$num
ÙÙY ]
)
ÙÙ] ^
}
ÙÙ_ `
,
ÙÙ` a
{
ıı 
$str
ıı 
,
ıı 
CIELabFromRGB
ıı< I
(
ııI J
$num
ııJ M
,
ııM N
$num
ııO R
,
ııR S
$num
ııT W
,
ııW X
$num
ııY ]
)
ıı] ^
}
ıı_ `
,
ıı` a
{
ˆˆ 
$str
ˆˆ 
,
ˆˆ 
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ M
,
ˆˆM N
$num
ˆˆO R
,
ˆˆR S
$num
ˆˆT X
,
ˆˆX Y
$num
ˆˆZ ^
)
ˆˆ^ _
}
ˆˆ` a
,
ˆˆa b
{
˜˜ 
$str
˜˜ 
,
˜˜ 
CIELabFromRGB
˜˜< I
(
˜˜I J
$num
˜˜J M
,
˜˜M N
$num
˜˜O R
,
˜˜R S
$num
˜˜T V
,
˜˜V W
$num
˜˜X \
)
˜˜\ ]
}
˜˜^ _
,
˜˜_ `
{
¯¯ 
$str
¯¯ 
,
¯¯ 
CIELabFromRGB
¯¯< I
(
¯¯I J
$num
¯¯J M
,
¯¯M N
$num
¯¯O R
,
¯¯R S
$num
¯¯T W
,
¯¯W X
$num
¯¯Y ]
)
¯¯] ^
}
¯¯_ `
,
¯¯` a
{
˘˘ 
$str
˘˘ 
,
˘˘ 
CIELabFromRGB
˘˘< I
(
˘˘I J
$num
˘˘J M
,
˘˘M N
$num
˘˘O R
,
˘˘R S
$num
˘˘T W
,
˘˘W X
$num
˘˘Y ]
)
˘˘] ^
}
˘˘_ `
,
˘˘` a
{
˙˙ 
$str
˙˙ 
,
˙˙ 
CIELabFromRGB
˙˙< I
(
˙˙I J
$num
˙˙J L
,
˙˙L M
$num
˙˙N Q
,
˙˙Q R
$num
˙˙S V
,
˙˙V W
$num
˙˙X \
)
˙˙\ ]
}
˙˙^ _
,
˙˙_ `
{
˚˚ 
$str
˚˚ 
,
˚˚ 
CIELabFromRGB
˚˚< I
(
˚˚I J
$num
˚˚J M
,
˚˚M N
$num
˚˚O R
,
˚˚R S
$num
˚˚T W
,
˚˚W X
$num
˚˚Y ]
)
˚˚] ^
}
˚˚_ `
,
˚˚` a
{
¸¸ 
$str
¸¸ 
,
¸¸ 
CIELabFromRGB
¸¸< I
(
¸¸I J
$num
¸¸J N
,
¸¸N O
$num
¸¸P S
,
¸¸S T
$num
¸¸U X
,
¸¸X Y
$num
¸¸Z ^
)
¸¸^ _
}
¸¸` a
,
¸¸a b
{
˝˝ 
$str
˝˝ 
,
˝˝ 
CIELabFromRGB
˝˝< I
(
˝˝I J
$num
˝˝J M
,
˝˝M N
$num
˝˝O R
,
˝˝R S
$num
˝˝T W
,
˝˝W X
$num
˝˝Y ]
)
˝˝] ^
}
˝˝_ `
,
˝˝` a
{
˛˛ 
$str
˛˛ 
,
˛˛ 
CIELabFromRGB
˛˛< I
(
˛˛I J
$num
˛˛J M
,
˛˛M N
$num
˛˛O Q
,
˛˛Q R
$num
˛˛S V
,
˛˛V W
$num
˛˛X \
)
˛˛\ ]
}
˛˛^ _
,
˛˛_ `
{
ˇˇ 
$str
ˇˇ 
,
ˇˇ 
CIELabFromRGB
ˇˇ< I
(
ˇˇI J
$num
ˇˇJ M
,
ˇˇM N
$num
ˇˇO R
,
ˇˇR S
$num
ˇˇT W
,
ˇˇW X
$num
ˇˇY ]
)
ˇˇ] ^
}
ˇˇ_ `
,
ˇˇ` a
{
ÄÄ 
$str
ÄÄ  
,
ÄÄ  !
CIELabFromRGB
ÄÄ< I
(
ÄÄI J
$num
ÄÄJ M
,
ÄÄM N
$num
ÄÄO R
,
ÄÄR S
$num
ÄÄT W
,
ÄÄW X
$num
ÄÄY ]
)
ÄÄ] ^
}
ÄÄ_ `
,
ÄÄ` a
{
ÅÅ 
$str
ÅÅ !
,
ÅÅ! "
CIELabFromRGB
ÅÅ< I
(
ÅÅI J
$num
ÅÅJ M
,
ÅÅM N
$num
ÅÅO Q
,
ÅÅQ R
$num
ÅÅS U
,
ÅÅU V
$num
ÅÅW [
)
ÅÅ[ \
}
ÅÅ] ^
,
ÅÅ^ _
{
ÇÇ 
$str
ÇÇ 
,
ÇÇ 
CIELabFromRGB
ÇÇ< I
(
ÇÇI J
$num
ÇÇJ M
,
ÇÇM N
$num
ÇÇO R
,
ÇÇR S
$num
ÇÇT W
,
ÇÇW X
$num
ÇÇY ]
)
ÇÇ] ^
}
ÇÇ_ `
,
ÇÇ` a
{
ÉÉ 
$str
ÉÉ 
,
ÉÉ 
CIELabFromRGB
ÉÉ< I
(
ÉÉI J
$num
ÉÉJ M
,
ÉÉM N
$num
ÉÉO R
,
ÉÉR S
$num
ÉÉT X
,
ÉÉX Y
$num
ÉÉZ ^
)
ÉÉ^ _
}
ÉÉ` a
,
ÉÉa b
{
ÑÑ 
$str
ÑÑ 
,
ÑÑ 
CIELabFromRGB
ÑÑ< I
(
ÑÑI J
$num
ÑÑJ M
,
ÑÑM N
$num
ÑÑO R
,
ÑÑR S
$num
ÑÑT W
,
ÑÑW X
$num
ÑÑY ]
)
ÑÑ] ^
}
ÑÑ_ `
,
ÑÑ` a
{
ÖÖ 
$str
ÖÖ 
,
ÖÖ 
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ M
,
ÖÖM N
$num
ÖÖO R
,
ÖÖR S
$num
ÖÖT W
,
ÖÖW X
$num
ÖÖY ]
)
ÖÖ] ^
}
ÖÖ_ `
,
ÖÖ` a
{
ÜÜ 
$str
ÜÜ 
,
ÜÜ 
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ M
,
ÜÜM N
$num
ÜÜO R
,
ÜÜR S
$num
ÜÜT W
,
ÜÜW X
$num
ÜÜY ]
)
ÜÜ] ^
}
ÜÜ_ `
,
ÜÜ` a
{
áá 
$str
áá 
,
áá 
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ M
,
ááM N
$num
ááO R
,
ááR S
$num
ááT W
,
ááW X
$num
ááY ]
)
áá] ^
}
áá_ `
,
áá` a
{
àà 
$str
àà 
,
àà 
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ M
,
ààM N
$num
ààO R
,
ààR S
$num
ààT W
,
ààW X
$num
ààY ]
)
àà] ^
}
àà_ `
,
àà` a
{
ââ 
$str
ââ !
,
ââ! "
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ M
,
ââM N
$num
ââO R
,
ââR S
$num
ââT W
,
ââW X
$num
ââY ]
)
ââ] ^
}
ââ_ `
,
ââ` a
{
ää 
$str
ää 
,
ää 
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ L
,
ääL M
$num
ääN P
,
ääP Q
$num
ääR U
,
ääU V
$num
ääW [
)
ää[ \
}
ää] ^
,
ää^ _
{
ãã 
$str
ãã &
,
ãã& '
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ M
,
ããM N
$num
ããO Q
,
ããQ R
$num
ããS V
,
ããV W
$num
ããX \
)
ãã\ ]
}
ãã^ _
,
ãã_ `
{
åå 
$str
åå 
,
åå 
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ M
,
ååM N
$num
ååO R
,
ååR S
$num
ååT W
,
ååW X
$num
ååY ]
)
åå] ^
}
åå_ `
,
åå` a
{
çç 
$str
çç  
,
çç  !
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ M
,
ççM N
$num
ççO R
,
ççR S
$num
ççT W
,
ççW X
$num
ççY ]
)
çç] ^
}
çç_ `
,
çç` a
{
éé 
$str
éé $
,
éé$ %
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ L
,
ééL M
$num
ééN Q
,
ééQ R
$num
ééS V
,
ééV W
$num
ééX \
)
éé\ ]
}
éé^ _
,
éé_ `
{
èè 
$str
èè #
,
èè# $
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ M
,
èèM N
$num
èèO R
,
èèR S
$num
èèT W
,
èèW X
$num
èèY ]
)
èè] ^
}
èè_ `
,
èè` a
{
êê 
$str
êê '
,
êê' (
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ M
,
êêM N
$num
êêO R
,
êêR S
$num
êêT W
,
êêW X
$num
êêY ]
)
êê] ^
}
êê_ `
,
êê` a
{
ëë 
$str
ëë 
,
ëë 
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ M
,
ëëM N
$num
ëëO R
,
ëëR S
$num
ëëT W
,
ëëW X
$num
ëëY ]
)
ëë] ^
}
ëë_ `
,
ëë` a
{
íí 
$str
íí #
,
íí# $
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ L
,
ííL M
$num
ííN Q
,
ííQ R
$num
ííS V
,
ííV W
$num
ííX \
)
íí\ ]
}
íí^ _
,
íí_ `
{
ìì 
$str
ìì 
,
ìì 
CIELabFromRGB
ìì< I
(
ììI J
$num
ììJ M
,
ììM N
$num
ììO R
,
ììR S
$num
ììT W
,
ììW X
$num
ììY ]
)
ìì] ^
}
ìì_ `
,
ìì` a
{
îî 
$str
îî !
,
îî! "
CIELabFromRGB
îî< I
(
îîI J
$num
îîJ M
,
îîM N
$num
îîO R
,
îîR S
$num
îîT W
,
îîW X
$num
îîY ]
)
îî] ^
}
îî_ `
,
îî` a
{
ïï 
$str
ïï 
,
ïï 
CIELabFromRGB
ïï< I
(
ïïI J
$num
ïïJ M
,
ïïM N
$num
ïïO R
,
ïïR S
$num
ïïT W
,
ïïW X
$num
ïïY ]
)
ïï] ^
}
ïï_ `
,
ïï` a
{
ññ 
$str
ññ  
,
ññ  !
CIELabFromRGB
ññ< I
(
ññI J
$num
ññJ M
,
ññM N
$num
ññO R
,
ññR S
$num
ññT W
,
ññW X
$num
ññY ]
)
ññ] ^
}
ññ_ `
,
ññ` a
{
óó 
$str
óó 
,
óó  
CIELabFromRGB
óó< I
(
óóI J
$num
óóJ M
,
óóM N
$num
óóO R
,
óóR S
$num
óóT W
,
óóW X
$num
óóY ]
)
óó] ^
}
óó_ `
,
óó` a
{
òò 
$str
òò !
,
òò! "
CIELabFromRGB
òò< I
(
òòI J
$num
òòJ M
,
òòM N
$num
òòO R
,
òòR S
$num
òòT W
,
òòW X
$num
òòY ]
)
òò] ^
}
òò_ `
,
òò` a
{
ôô 
$str
ôô !
,
ôô! "
CIELabFromRGB
ôô< I
(
ôôI J
$num
ôôJ M
,
ôôM N
$num
ôôO R
,
ôôR S
$num
ôôT W
,
ôôW X
$num
ôôY ]
)
ôô] ^
}
ôô_ `
,
ôô` a
{
öö 
$str
öö #
,
öö# $
CIELabFromRGB
öö< I
(
ööI J
$num
ööJ L
,
ööL M
$num
ööN Q
,
ööQ R
$num
ööS V
,
ööV W
$num
ööX \
)
öö\ ]
}
öö^ _
,
öö_ `
{
õõ 
$str
õõ 
,
õõ 
CIELabFromRGB
õõ< I
(
õõI J
$num
õõJ M
,
õõM N
$num
õõO R
,
õõR S
$num
õõT W
,
õõW X
$num
õõY ]
)
õõ] ^
}
õõ_ `
,
õõ` a
{
úú 
$str
úú  
,
úú  !
CIELabFromRGB
úú< I
(
úúI J
$num
úúJ M
,
úúM N
$num
úúO R
,
úúR S
$num
úúT W
,
úúW X
$num
úúY ]
)
úú] ^
}
úú_ `
,
úú` a
{
ùù 
$str
ùù !
,
ùù! "
CIELabFromRGB
ùù< I
(
ùùI J
$num
ùùJ M
,
ùùM N
$num
ùùO R
,
ùùR S
$num
ùùT W
,
ùùW X
$num
ùùY ]
)
ùù] ^
}
ùù_ `
,
ùù` a
{
ûû 
$str
ûû  
,
ûû  !
CIELabFromRGB
ûû< I
(
ûûI J
$num
ûûJ M
,
ûûM N
$num
ûûO R
,
ûûR S
$num
ûûT W
,
ûûW X
$num
ûûY ]
)
ûû] ^
}
ûû_ `
,
ûû` a
{
üü 
$str
üü !
,
üü! "
CIELabFromRGB
üü< I
(
üüI J
$num
üüJ M
,
üüM N
$num
üüO Q
,
üüQ R
$num
üüS V
,
üüV W
$num
üüX \
)
üü\ ]
}
üü^ _
,
üü_ `
{
†† 
$str
†† 
,
†† 
CIELabFromRGB
††< I
(
††I J
$num
††J M
,
††M N
$num
††O R
,
††R S
$num
††T W
,
††W X
$num
††Y ]
)
††] ^
}
††_ `
,
††` a
{
°° 
$str
°° 
,
°° 
CIELabFromRGB
°°< I
(
°°I J
$num
°°J M
,
°°M N
$num
°°O R
,
°°R S
$num
°°T W
,
°°W X
$num
°°Y ]
)
°°] ^
}
°°_ `
,
°°` a
{
¢¢ 
$str
¢¢ 
,
¢¢ 
CIELabFromRGB
¢¢< I
(
¢¢I J
$num
¢¢J M
,
¢¢M N
$num
¢¢O R
,
¢¢R S
$num
¢¢T W
,
¢¢W X
$num
¢¢Y ]
)
¢¢] ^
}
¢¢_ `
,
¢¢` a
{
££ 
$str
££  
,
££  !
CIELabFromRGB
££< I
(
££I J
$num
££J L
,
££L M
$num
££N Q
,
££Q R
$num
££S V
,
££V W
$num
££X \
)
££\ ]
}
££^ _
,
££_ `
{
§§ 
$str
§§ !
,
§§! "
CIELabFromRGB
§§< I
(
§§I J
$num
§§J M
,
§§M N
$num
§§O R
,
§§R S
$num
§§T W
,
§§W X
$num
§§Y ]
)
§§] ^
}
§§_ `
,
§§` a
{
•• 
$str
•• 
,
•• 
CIELabFromRGB
••< I
(
••I J
$num
••J M
,
••M N
$num
••O Q
,
••Q R
$num
••S V
,
••V W
$num
••X \
)
••\ ]
}
••^ _
,
••_ `
{
¶¶ 
$str
¶¶ 
,
¶¶ 
CIELabFromRGB
¶¶< I
(
¶¶I J
$num
¶¶J M
,
¶¶M N
$num
¶¶O R
,
¶¶R S
$num
¶¶T W
,
¶¶W X
$num
¶¶Y ]
)
¶¶] ^
}
¶¶_ `
,
¶¶` a
{
ßß 
$str
ßß ,
,
ßß, -
CIELabFromRGB
ßß< I
(
ßßI J
$num
ßßJ L
,
ßßL M
$num
ßßN Q
,
ßßQ R
$num
ßßS V
,
ßßV W
$num
ßßX \
)
ßß\ ]
}
ßß^ _
,
ßß_ `
{
®® 
$str
®® 
,
®® 
CIELabFromRGB
®®< I
(
®®I J
$num
®®J N
,
®®N O
$num
®®P S
,
®®S T
$num
®®U W
,
®®W X
$num
®®Y ]
)
®®] ^
}
®®_ `
,
®®` a
{
©© 
$str
©© 
,
©© 
CIELabFromRGB
©©< I
(
©©I J
$num
©©J M
,
©©M N
$num
©©O R
,
©©R S
$num
©©T W
,
©©W X
$num
©©Y ]
)
©©] ^
}
©©_ `
,
©©` a
{
™™ 
$str
™™ 
,
™™ 
CIELabFromRGB
™™< I
(
™™I J
$num
™™J M
,
™™M N
$num
™™O R
,
™™R S
$num
™™T W
,
™™W X
$num
™™Y ]
)
™™] ^
}
™™_ `
,
™™` a
{
´´ 
$str
´´ 
,
´´ 
CIELabFromRGB
´´< I
(
´´I J
$num
´´J M
,
´´M N
$num
´´O R
,
´´R S
$num
´´T W
,
´´W X
$num
´´Y ]
)
´´] ^
}
´´_ `
,
´´` a
{
¨¨ 
$str
¨¨ 
,
¨¨ 
CIELabFromRGB
¨¨< I
(
¨¨I J
$num
¨¨J M
,
¨¨M N
$num
¨¨O S
,
¨¨S T
$num
¨¨U X
,
¨¨X Y
$num
¨¨Z ^
)
¨¨^ _
}
¨¨` a
,
¨¨a b
{
≠≠ 
$str
≠≠ 
,
≠≠ 
CIELabFromRGB
≠≠< I
(
≠≠I J
$num
≠≠J M
,
≠≠M N
$num
≠≠O S
,
≠≠S T
$num
≠≠U X
,
≠≠X Y
$num
≠≠Z ^
)
≠≠^ _
}
≠≠` a
,
≠≠a b
{
ÆÆ 
$str
ÆÆ 
,
ÆÆ 
CIELabFromRGB
ÆÆ< I
(
ÆÆI J
$num
ÆÆJ N
,
ÆÆN O
$num
ÆÆP S
,
ÆÆS T
$num
ÆÆU X
,
ÆÆX Y
$num
ÆÆZ ^
)
ÆÆ^ _
}
ÆÆ` a
,
ÆÆa b
{
ØØ 
$str
ØØ 
,
ØØ 
CIELabFromRGB
ØØ< I
(
ØØI J
$num
ØØJ M
,
ØØM N
$num
ØØO R
,
ØØR S
$num
ØØT W
,
ØØW X
$num
ØØY ]
)
ØØ] ^
}
ØØ_ `
,
ØØ` a
{
∞∞ 
$str
∞∞ 
,
∞∞ 
CIELabFromRGB
∞∞< I
(
∞∞I J
$num
∞∞J M
,
∞∞M N
$num
∞∞O R
,
∞∞R S
$num
∞∞T V
,
∞∞V W
$num
∞∞X \
)
∞∞\ ]
}
∞∞^ _
,
∞∞_ `
{
±± 
$str
±± 
,
±± 
CIELabFromRGB
±±< I
(
±±I J
$num
±±J M
,
±±M N
$num
±±O R
,
±±R S
$num
±±T W
,
±±W X
$num
±±Y ]
)
±±] ^
}
±±_ `
,
±±` a
{
≤≤ 
$str
≤≤ 
,
≤≤ 
CIELabFromRGB
≤≤< I
(
≤≤I J
$num
≤≤J M
,
≤≤M N
$num
≤≤O Q
,
≤≤Q R
$num
≤≤S U
,
≤≤U V
$num
≤≤W [
)
≤≤[ \
}
≤≤] ^
,
≤≤^ _
{
≥≥ 
$str
≥≥ 
,
≥≥ 
CIELabFromRGB
≥≥< I
(
≥≥I J
$num
≥≥J M
,
≥≥M N
$num
≥≥O R
,
≥≥R S
$num
≥≥T W
,
≥≥W X
$num
≥≥Y ]
)
≥≥] ^
}
≥≥_ `
,
≥≥` a
{
¥¥ 
$str
¥¥ 
,
¥¥  
CIELabFromRGB
¥¥< I
(
¥¥I J
$num
¥¥J M
,
¥¥M N
$num
¥¥O R
,
¥¥R S
$num
¥¥T W
,
¥¥W X
$num
¥¥Y ]
)
¥¥] ^
}
¥¥_ `
,
¥¥` a
{
µµ 
$str
µµ  
,
µµ  !
CIELabFromRGB
µµ< I
(
µµI J
$num
µµJ M
,
µµM N
$num
µµO R
,
µµR S
$num
µµT W
,
µµW X
$num
µµY ]
)
µµ] ^
}
µµ_ `
,
µµ` a
{
∂∂ 
$str
∂∂ 
,
∂∂ 
CIELabFromRGB
∂∂< I
(
∂∂I J
$num
∂∂J L
,
∂∂L M
$num
∂∂N Q
,
∂∂Q R
$num
∂∂S V
,
∂∂V W
$num
∂∂X \
)
∂∂\ ]
}
∂∂^ _
,
∂∂_ `
{
∑∑ 
$str
∑∑ 
,
∑∑ 
CIELabFromRGB
∑∑< I
(
∑∑I J
$num
∑∑J M
,
∑∑M N
$num
∑∑O R
,
∑∑R S
$num
∑∑T W
,
∑∑W X
$num
∑∑Y ]
)
∑∑] ^
}
∑∑_ `
,
∑∑` a
{
∏∏ 
$str
∏∏ 
,
∏∏ 
CIELabFromRGB
∏∏< I
(
∏∏I J
$num
∏∏J M
,
∏∏M N
$num
∏∏O R
,
∏∏R S
$num
∏∏T W
,
∏∏W X
$num
∏∏Y ]
)
∏∏] ^
}
∏∏_ `
,
∏∏` a
{
ππ 
$str
ππ 
,
ππ 
CIELabFromRGB
ππ< I
(
ππI J
$num
ππJ N
,
ππN O
$num
ππP S
,
ππS T
$num
ππU X
,
ππX Y
$num
ππZ ^
)
ππ^ _
}
ππ` a
,
ππa b
{
∫∫ 
$str
∫∫ 
,
∫∫ 
CIELabFromRGB
∫∫< I
(
∫∫I J
$num
∫∫J M
,
∫∫M N
$num
∫∫O R
,
∫∫R S
$num
∫∫T W
,
∫∫W X
$num
∫∫Y ]
)
∫∫] ^
}
∫∫_ `
,
∫∫` a
{
ªª 
$str
ªª 
,
ªª 
CIELabFromRGB
ªª< I
(
ªªI J
$num
ªªJ M
,
ªªM N
$num
ªªO R
,
ªªR S
$num
ªªT W
,
ªªW X
$num
ªªY ]
)
ªª] ^
}
ªª_ `
,
ªª` a
{
ºº 
$str
ºº 
,
ºº 
CIELabFromRGB
ºº< I
(
ººI J
$num
ººJ M
,
ººM N
$num
ººO R
,
ººR S
$num
ººT V
,
ººV W
$num
ººX \
)
ºº\ ]
}
ºº^ _
,
ºº_ `
{
ΩΩ 
$str
ΩΩ 
,
ΩΩ 
CIELabFromRGB
ΩΩ< I
(
ΩΩI J
$num
ΩΩJ M
,
ΩΩM N
$num
ΩΩO R
,
ΩΩR S
$num
ΩΩT W
,
ΩΩW X
$num
ΩΩY ]
)
ΩΩ] ^
}
ΩΩ_ `
,
ΩΩ` a
{
ææ 
$str
ææ 
,
ææ 
CIELabFromRGB
ææ< I
(
ææI J
$num
ææJ N
,
ææN O
$num
ææP S
,
ææS T
$num
ææU X
,
ææX Y
$num
ææZ ^
)
ææ^ _
}
ææ` a
,
ææa b
{
øø 
$str
øø 
,
øø 
CIELabFromRGB
øø< I
(
øøI J
$num
øøJ L
,
øøL M
$num
øøN P
,
øøP Q
$num
øøR U
,
øøU V
$num
øøW [
)
øø[ \
}
øø] ^
,
øø^ _
{
¿¿ 
$str
¿¿ 
,
¿¿ 
CIELabFromRGB
¿¿< I
(
¿¿I J
$num
¿¿J M
,
¿¿M N
$num
¿¿O R
,
¿¿R S
$num
¿¿T W
,
¿¿W X
$num
¿¿Y ]
)
¿¿] ^
}
¿¿_ `
,
¿¿` a
{
¡¡ 
$str
¡¡ 
,
¡¡ 
CIELabFromRGB
¡¡< I
(
¡¡I J
$num
¡¡J N
,
¡¡N O
$num
¡¡P S
,
¡¡S T
$num
¡¡U X
,
¡¡X Y
$num
¡¡Z ^
)
¡¡^ _
}
¡¡` a
,
¡¡a b
{
¬¬ 
$str
¬¬ 
,
¬¬ 
CIELabFromRGB
¬¬< I
(
¬¬I J
$num
¬¬J N
,
¬¬N O
$num
¬¬P S
,
¬¬S T
$num
¬¬U X
,
¬¬X Y
$num
¬¬Z ^
)
¬¬^ _
}
¬¬` a
,
¬¬a b
{
√√ 
$str
√√ 
,
√√ 
CIELabFromRGB
√√< I
(
√√I J
$num
√√J M
,
√√M N
$num
√√O S
,
√√S T
$num
√√U W
,
√√W X
$num
√√Y ]
)
√√] ^
}
√√_ `
,
√√` a
{
ƒƒ 
$str
ƒƒ 
,
ƒƒ 
CIELabFromRGB
ƒƒ< I
(
ƒƒI J
$num
ƒƒJ M
,
ƒƒM N
$num
ƒƒO R
,
ƒƒR S
$num
ƒƒT W
,
ƒƒW X
$num
ƒƒY ]
)
ƒƒ] ^
}
ƒƒ_ `
,
ƒƒ` a
{
≈≈ 
$str
≈≈ 
,
≈≈ 
CIELabFromRGB
≈≈< I
(
≈≈I J
$num
≈≈J M
,
≈≈M N
$num
≈≈O R
,
≈≈R S
$num
≈≈T W
,
≈≈W X
$num
≈≈Y ]
)
≈≈] ^
}
≈≈_ `
,
≈≈` a
{
∆∆ 
$str
∆∆ 
,
∆∆ 
CIELabFromRGB
∆∆< I
(
∆∆I J
$num
∆∆J M
,
∆∆M N
$num
∆∆O R
,
∆∆R S
$num
∆∆T W
,
∆∆W X
$num
∆∆Y ]
)
∆∆] ^
}
∆∆_ `
,
∆∆` a
{
«« 
$str
«« !
,
««! "
CIELabFromRGB
««< I
(
««I J
$num
««J L
,
««L M
$num
««N Q
,
««Q R
$num
««S V
,
««V W
$num
««X \
)
««\ ]
}
««^ _
,
««_ `
{
»» 
$str
»» 
,
»» 
CIELabFromRGB
»»< I
(
»»I J
$num
»»J M
,
»»M N
$num
»»O S
,
»»S T
$num
»»U X
,
»»X Y
$num
»»Z ^
)
»»^ _
}
»»` a
,
»»a b
{
…… 
$str
…… 
,
……  
CIELabFromRGB
……< I
(
……I J
$num
……J L
,
……L M
$num
……N Q
,
……Q R
$num
……S V
,
……V W
$num
……X \
)
……\ ]
}
……^ _
,
……_ `
{
   
$str
   
,
   
CIELabFromRGB
  < I
(
  I J
$num
  J M
,
  M N
$num
  O R
,
  R S
$num
  T W
,
  W X
$num
  Y ]
)
  ] ^
}
  _ `
,
  ` a
{
ÀÀ 
$str
ÀÀ 
,
ÀÀ 
CIELabFromRGB
ÀÀ< I
(
ÀÀI J
$num
ÀÀJ L
,
ÀÀL M
$num
ÀÀN Q
,
ÀÀQ R
$num
ÀÀS U
,
ÀÀU V
$num
ÀÀW [
)
ÀÀ[ \
}
ÀÀ] ^
,
ÀÀ^ _
{
ÃÃ 
$str
ÃÃ 
,
ÃÃ 
CIELabFromRGB
ÃÃ< I
(
ÃÃI J
$num
ÃÃJ M
,
ÃÃM N
$num
ÃÃO R
,
ÃÃR S
$num
ÃÃT W
,
ÃÃW X
$num
ÃÃY ]
)
ÃÃ] ^
}
ÃÃ_ `
,
ÃÃ` a
{
ÕÕ 
$str
ÕÕ 
,
ÕÕ 
CIELabFromRGB
ÕÕ< I
(
ÕÕI J
$num
ÕÕJ M
,
ÕÕM N
$num
ÕÕO R
,
ÕÕR S
$num
ÕÕT W
,
ÕÕW X
$num
ÕÕY ]
)
ÕÕ] ^
}
ÕÕ_ `
,
ÕÕ` a
{
ŒŒ 
$str
ŒŒ 
,
ŒŒ 
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ M
,
ŒŒM N
$num
ŒŒO R
,
ŒŒR S
$num
ŒŒT W
,
ŒŒW X
$num
ŒŒY ]
)
ŒŒ] ^
}
ŒŒ_ `
,
ŒŒ` a
{
œœ 
$str
œœ 
,
œœ 
CIELabFromRGB
œœ< I
(
œœI J
$num
œœJ M
,
œœM N
$num
œœO R
,
œœR S
$num
œœT W
,
œœW X
$num
œœY ]
)
œœ] ^
}
œœ_ `
,
œœ` a
{
–– 
$str
–– 
,
–– 
CIELabFromRGB
––< I
(
––I J
$num
––J M
,
––M N
$num
––O R
,
––R S
$num
––T W
,
––W X
$num
––Y ]
)
––] ^
}
––_ `
,
––` a
{
—— 
$str
—— 
,
—— 
CIELabFromRGB
——< I
(
——I J
$num
——J M
,
——M N
$num
——O R
,
——R S
$num
——T W
,
——W X
$num
——Y ]
)
——] ^
}
——_ `
,
——` a
{
““ 
$str
““ 
,
““ 
CIELabFromRGB
““< I
(
““I J
$num
““J M
,
““M N
$num
““O R
,
““R S
$num
““T W
,
““W X
$num
““Y ]
)
““] ^
}
““_ `
,
““` a
{
”” 
$str
”” 
,
”” 
CIELabFromRGB
””< I
(
””I J
$num
””J M
,
””M N
$num
””O R
,
””R S
$num
””T W
,
””W X
$num
””Y ]
)
””] ^
}
””_ `
,
””` a
{
‘‘ 
$str
‘‘ 
,
‘‘ 
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J M
,
‘‘M N
$num
‘‘O R
,
‘‘R S
$num
‘‘T W
,
‘‘W X
$num
‘‘Y ]
)
‘‘] ^
}
‘‘_ `
,
‘‘` a
{
’’ 
$str
’’ 
,
’’ 
CIELabFromRGB
’’< I
(
’’I J
$num
’’J M
,
’’M N
$num
’’O R
,
’’R S
$num
’’T V
,
’’V W
$num
’’X \
)
’’\ ]
}
’’^ _
,
’’_ `
{
÷÷ 
$str
÷÷ 
,
÷÷ 
CIELabFromRGB
÷÷< I
(
÷÷I J
$num
÷÷J M
,
÷÷M N
$num
÷÷O R
,
÷÷R S
$num
÷÷T W
,
÷÷W X
$num
÷÷Y ]
)
÷÷] ^
}
÷÷_ `
,
÷÷` a
{
◊◊ 
$str
◊◊ 
,
◊◊ 
CIELabFromRGB
◊◊< I
(
◊◊I J
$num
◊◊J M
,
◊◊M N
$num
◊◊O R
,
◊◊R S
$num
◊◊T W
,
◊◊W X
$num
◊◊Y ]
)
◊◊] ^
}
◊◊_ `
,
◊◊` a
{
ÿÿ 
$str
ÿÿ 
,
ÿÿ 
CIELabFromRGB
ÿÿ< I
(
ÿÿI J
$num
ÿÿJ M
,
ÿÿM N
$num
ÿÿO R
,
ÿÿR S
$num
ÿÿT W
,
ÿÿW X
$num
ÿÿY ]
)
ÿÿ] ^
}
ÿÿ_ `
,
ÿÿ` a
{
ŸŸ 
$str
ŸŸ 
,
ŸŸ 
CIELabFromRGB
ŸŸ< I
(
ŸŸI J
$num
ŸŸJ M
,
ŸŸM N
$num
ŸŸO R
,
ŸŸR S
$num
ŸŸT W
,
ŸŸW X
$num
ŸŸY ]
)
ŸŸ] ^
}
ŸŸ_ `
,
ŸŸ` a
{
⁄⁄ 
$str
⁄⁄ $
,
⁄⁄$ %
CIELabFromRGB
⁄⁄< I
(
⁄⁄I J
$num
⁄⁄J N
,
⁄⁄N O
$num
⁄⁄P S
,
⁄⁄S T
$num
⁄⁄U W
,
⁄⁄W X
$num
⁄⁄Y ]
)
⁄⁄] ^
}
⁄⁄_ `
,
⁄⁄` a
{
€€ 
$str
€€  
,
€€  !
CIELabFromRGB
€€< I
(
€€I J
$num
€€J N
,
€€N O
$num
€€P S
,
€€S T
$num
€€U X
,
€€X Y
$num
€€Z ^
)
€€^ _
}
€€` a
,
€€a b
{
‹‹ 
$str
‹‹  
,
‹‹  !
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J N
,
‹‹N O
$num
‹‹P S
,
‹‹S T
$num
‹‹U W
,
‹‹W X
$num
‹‹Y ]
)
‹‹] ^
}
‹‹_ `
,
‹‹` a
{
›› 
$str
›› 
,
›› 
CIELabFromRGB
››< I
(
››I J
$num
››J M
,
››M N
$num
››O R
,
››R S
$num
››T V
,
››V W
$num
››X \
)
››\ ]
}
››^ _
,
››_ `
{
ﬁﬁ 
$str
ﬁﬁ 
,
ﬁﬁ 
CIELabFromRGB
ﬁﬁ< I
(
ﬁﬁI J
$num
ﬁﬁJ N
,
ﬁﬁN O
$num
ﬁﬁP S
,
ﬁﬁS T
$num
ﬁﬁU W
,
ﬁﬁW X
$num
ﬁﬁY ]
)
ﬁﬁ] ^
}
ﬁﬁ_ `
,
ﬁﬁ` a
{
ﬂﬂ 
$str
ﬂﬂ 
,
ﬂﬂ 
CIELabFromRGB
ﬂﬂ< I
(
ﬂﬂI J
$num
ﬂﬂJ N
,
ﬂﬂN O
$num
ﬂﬂP S
,
ﬂﬂS T
$num
ﬂﬂU W
,
ﬂﬂW X
$num
ﬂﬂY ]
)
ﬂﬂ] ^
}
ﬂﬂ_ `
,
ﬂﬂ` a
{
‡‡ 
$str
‡‡ 
,
‡‡ 
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J N
,
‡‡N O
$num
‡‡P S
,
‡‡S T
$num
‡‡U W
,
‡‡W X
$num
‡‡Y ]
)
‡‡] ^
}
‡‡_ `
,
‡‡` a
{
·· 
$str
·· 
,
·· 
CIELabFromRGB
··< I
(
··I J
$num
··J M
,
··M N
$num
··O R
,
··R S
$num
··T W
,
··W X
$num
··Y ]
)
··] ^
}
··_ `
,
··` a
{
‚‚ 
$str
‚‚ 
,
‚‚ 
CIELabFromRGB
‚‚< I
(
‚‚I J
$num
‚‚J M
,
‚‚M N
$num
‚‚O R
,
‚‚R S
$num
‚‚T W
,
‚‚W X
$num
‚‚Y ]
)
‚‚] ^
}
‚‚_ `
,
‚‚` a
{
„„ 
$str
„„ 
,
„„ 
CIELabFromRGB
„„< I
(
„„I J
$num
„„J M
,
„„M N
$num
„„O R
,
„„R S
$num
„„T W
,
„„W X
$num
„„Y ]
)
„„] ^
}
„„_ `
,
„„` a
{
‰‰ 
$str
‰‰ 
,
‰‰ 
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J M
,
‰‰M N
$num
‰‰O R
,
‰‰R S
$num
‰‰T V
,
‰‰V W
$num
‰‰X \
)
‰‰\ ]
}
‰‰^ _
,
‰‰_ `
{
ÂÂ 
$str
ÂÂ 
,
ÂÂ 
CIELabFromRGB
ÂÂ< I
(
ÂÂI J
$num
ÂÂJ M
,
ÂÂM N
$num
ÂÂO R
,
ÂÂR S
$num
ÂÂT W
,
ÂÂW X
$num
ÂÂY ]
)
ÂÂ] ^
}
ÂÂ_ `
,
ÂÂ` a
{
ÊÊ 
$str
ÊÊ 
,
ÊÊ 
CIELabFromRGB
ÊÊ< I
(
ÊÊI J
$num
ÊÊJ M
,
ÊÊM N
$num
ÊÊO R
,
ÊÊR S
$num
ÊÊT W
,
ÊÊW X
$num
ÊÊY ]
)
ÊÊ] ^
}
ÊÊ_ `
,
ÊÊ` a
{
ÁÁ 
$str
ÁÁ !
,
ÁÁ! "
CIELabFromRGB
ÁÁ< I
(
ÁÁI J
$num
ÁÁJ N
,
ÁÁN O
$num
ÁÁP S
,
ÁÁS T
$num
ÁÁU X
,
ÁÁX Y
$num
ÁÁZ ^
)
ÁÁ^ _
}
ÁÁ` a
,
ÁÁa b
{
ËË 
$str
ËË 
,
ËË 
CIELabFromRGB
ËË< I
(
ËËI J
$num
ËËJ L
,
ËËL M
$num
ËËN Q
,
ËËQ R
$num
ËËS V
,
ËËV W
$num
ËËX \
)
ËË\ ]
}
ËË^ _
,
ËË_ `
{
ÈÈ 
$str
ÈÈ 
,
ÈÈ 
CIELabFromRGB
ÈÈ< I
(
ÈÈI J
$num
ÈÈJ M
,
ÈÈM N
$num
ÈÈO Q
,
ÈÈQ R
$num
ÈÈS U
,
ÈÈU V
$num
ÈÈW [
)
ÈÈ[ \
}
ÈÈ] ^
,
ÈÈ^ _
{
ÍÍ 
$str
ÍÍ 
,
ÍÍ 
CIELabFromRGB
ÍÍ< I
(
ÍÍI J
$num
ÍÍJ L
,
ÍÍL M
$num
ÍÍN Q
,
ÍÍQ R
$num
ÍÍS U
,
ÍÍU V
$num
ÍÍW [
)
ÍÍ[ \
}
ÍÍ] ^
,
ÍÍ^ _
{
ÎÎ 
$str
ÎÎ 
,
ÎÎ  
CIELabFromRGB
ÎÎ< I
(
ÎÎI J
$num
ÎÎJ M
,
ÎÎM N
$num
ÎÎO R
,
ÎÎR S
$num
ÎÎT W
,
ÎÎW X
$num
ÎÎY ]
)
ÎÎ] ^
}
ÎÎ_ `
,
ÎÎ` a
{
ÏÏ 
$str
ÏÏ !
,
ÏÏ! "
CIELabFromRGB
ÏÏ< I
(
ÏÏI J
$num
ÏÏJ M
,
ÏÏM N
$num
ÏÏO R
,
ÏÏR S
$num
ÏÏT W
,
ÏÏW X
$num
ÏÏY ]
)
ÏÏ] ^
}
ÏÏ_ `
,
ÏÏ` a
{
ÌÌ 
$str
ÌÌ 
,
ÌÌ 
CIELabFromRGB
ÌÌ< I
(
ÌÌI J
$num
ÌÌJ M
,
ÌÌM N
$num
ÌÌO R
,
ÌÌR S
$num
ÌÌT W
,
ÌÌW X
$num
ÌÌY ]
)
ÌÌ] ^
}
ÌÌ_ `
,
ÌÌ` a
{
ÓÓ 
$str
ÓÓ 
,
ÓÓ 
CIELabFromRGB
ÓÓ< I
(
ÓÓI J
$num
ÓÓJ M
,
ÓÓM N
$num
ÓÓO R
,
ÓÓR S
$num
ÓÓT W
,
ÓÓW X
$num
ÓÓY ]
)
ÓÓ] ^
}
ÓÓ_ `
,
ÓÓ` a
{
ÔÔ 
$str
ÔÔ 
,
ÔÔ 
CIELabFromRGB
ÔÔ< I
(
ÔÔI J
$num
ÔÔJ M
,
ÔÔM N
$num
ÔÔO R
,
ÔÔR S
$num
ÔÔT W
,
ÔÔW X
$num
ÔÔY ]
)
ÔÔ] ^
}
ÔÔ_ `
,
ÔÔ` a
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
ÒÒ 
$str
ÒÒ 
,
ÒÒ 
CIELabFromRGB
ÒÒ< I
(
ÒÒI J
$num
ÒÒJ M
,
ÒÒM N
$num
ÒÒO R
,
ÒÒR S
$num
ÒÒT W
,
ÒÒW X
$num
ÒÒY ]
)
ÒÒ] ^
}
ÒÒ_ `
,
ÒÒ` a
{
ÚÚ 
$str
ÚÚ 
,
ÚÚ 
CIELabFromRGB
ÚÚ< I
(
ÚÚI J
$num
ÚÚJ M
,
ÚÚM N
$num
ÚÚO R
,
ÚÚR S
$num
ÚÚT W
,
ÚÚW X
$num
ÚÚY ]
)
ÚÚ] ^
}
ÚÚ_ `
,
ÚÚ` a
{
ÛÛ 
$str
ÛÛ 
,
ÛÛ 
CIELabFromRGB
ÛÛ< I
(
ÛÛI J
$num
ÛÛJ M
,
ÛÛM N
$num
ÛÛO R
,
ÛÛR S
$num
ÛÛT W
,
ÛÛW X
$num
ÛÛY ]
)
ÛÛ] ^
}
ÛÛ_ `
,
ÛÛ` a
{
ÙÙ 
$str
ÙÙ $
,
ÙÙ$ %
CIELabFromRGB
ÙÙ< I
(
ÙÙI J
$num
ÙÙJ M
,
ÙÙM N
$num
ÙÙO R
,
ÙÙR S
$num
ÙÙT W
,
ÙÙW X
$num
ÙÙY ]
)
ÙÙ] ^
}
ÙÙ_ `
,
ÙÙ` a
{
ıı 
$str
ıı 
,
ıı 
CIELabFromRGB
ıı< I
(
ııI J
$num
ııJ M
,
ııM N
$num
ııO R
,
ııR S
$num
ııT W
,
ııW X
$num
ııY ]
)
ıı] ^
}
ıı_ `
,
ıı` a
{
ˆˆ 
$str
ˆˆ 
,
ˆˆ 
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ M
,
ˆˆM N
$num
ˆˆO R
,
ˆˆR S
$num
ˆˆT W
,
ˆˆW X
$num
ˆˆY ]
)
ˆˆ] ^
}
ˆˆ_ `
,
ˆˆ` a
{
˜˜ 
$str
˜˜ 
,
˜˜ 
CIELabFromRGB
˜˜< I
(
˜˜I J
$num
˜˜J M
,
˜˜M N
$num
˜˜O R
,
˜˜R S
$num
˜˜T W
,
˜˜W X
$num
˜˜Y ]
)
˜˜] ^
}
˜˜_ `
,
˜˜` a
{
¯¯ 
$str
¯¯ 
,
¯¯ 
CIELabFromRGB
¯¯< I
(
¯¯I J
$num
¯¯J M
,
¯¯M N
$num
¯¯O R
,
¯¯R S
$num
¯¯T W
,
¯¯W X
$num
¯¯Y ]
)
¯¯] ^
}
¯¯_ `
,
¯¯` a
{
˘˘ 
$str
˘˘ 
,
˘˘ 
CIELabFromRGB
˘˘< I
(
˘˘I J
$num
˘˘J M
,
˘˘M N
$num
˘˘O R
,
˘˘R S
$num
˘˘T X
,
˘˘X Y
$num
˘˘Z ^
)
˘˘^ _
}
˘˘` a
,
˘˘a b
{
˙˙ 
$str
˙˙ 
,
˙˙ 
CIELabFromRGB
˙˙< I
(
˙˙I J
$num
˙˙J M
,
˙˙M N
$num
˙˙O R
,
˙˙R S
$num
˙˙T W
,
˙˙W X
$num
˙˙Y ]
)
˙˙] ^
}
˙˙_ `
,
˙˙` a
{
˚˚ 
$str
˚˚ !
,
˚˚! "
CIELabFromRGB
˚˚< I
(
˚˚I J
$num
˚˚J N
,
˚˚N O
$num
˚˚P S
,
˚˚S T
$num
˚˚U X
,
˚˚X Y
$num
˚˚Z ^
)
˚˚^ _
}
˚˚` a
,
˚˚a b
{
¸¸ 
$str
¸¸ 
,
¸¸ 
CIELabFromRGB
¸¸< I
(
¸¸I J
$num
¸¸J M
,
¸¸M N
$num
¸¸O R
,
¸¸R S
$num
¸¸T W
,
¸¸W X
$num
¸¸Y ]
)
¸¸] ^
}
¸¸_ `
,
¸¸` a
{
˝˝ 
$str
˝˝ 
,
˝˝ 
CIELabFromRGB
˝˝< I
(
˝˝I J
$num
˝˝J M
,
˝˝M N
$num
˝˝O R
,
˝˝R S
$num
˝˝T W
,
˝˝W X
$num
˝˝Y ]
)
˝˝] ^
}
˝˝_ `
,
˝˝` a
{
˛˛ 
$str
˛˛ 
,
˛˛  
CIELabFromRGB
˛˛< I
(
˛˛I J
$num
˛˛J M
,
˛˛M N
$num
˛˛O R
,
˛˛R S
$num
˛˛T W
,
˛˛W X
$num
˛˛Y ]
)
˛˛] ^
}
˛˛_ `
,
˛˛` a
{
ˇˇ 
$str
ˇˇ #
,
ˇˇ# $
CIELabFromRGB
ˇˇ< I
(
ˇˇI J
$num
ˇˇJ M
,
ˇˇM N
$num
ˇˇO R
,
ˇˇR S
$num
ˇˇT W
,
ˇˇW X
$num
ˇˇY ]
)
ˇˇ] ^
}
ˇˇ_ `
,
ˇˇ` a
{
Ä	Ä	 
$str
Ä	Ä	 
,
Ä	Ä	 
CIELabFromRGB
Ä	Ä	< I
(
Ä	Ä	I J
$num
Ä	Ä	J M
,
Ä	Ä	M N
$num
Ä	Ä	O R
,
Ä	Ä	R S
$num
Ä	Ä	T W
,
Ä	Ä	W X
$num
Ä	Ä	Y ]
)
Ä	Ä	] ^
}
Ä	Ä	_ `
,
Ä	Ä	` a
{
Å	Å	 
$str
Å	Å	 
,
Å	Å	  
CIELabFromRGB
Å	Å	< I
(
Å	Å	I J
$num
Å	Å	J M
,
Å	Å	M N
$num
Å	Å	O R
,
Å	Å	R S
$num
Å	Å	T W
,
Å	Å	W X
$num
Å	Å	Y ]
)
Å	Å	] ^
}
Å	Å	_ `
,
Å	Å	` a
{
Ç	Ç	 
$str
Ç	Ç	 
,
Ç	Ç	 
CIELabFromRGB
Ç	Ç	< I
(
Ç	Ç	I J
$num
Ç	Ç	J M
,
Ç	Ç	M N
$num
Ç	Ç	O R
,
Ç	Ç	R S
$num
Ç	Ç	T W
,
Ç	Ç	W X
$num
Ç	Ç	Y ]
)
Ç	Ç	] ^
}
Ç	Ç	_ `
,
Ç	Ç	` a
{
É	É	 
$str
É	É	 
,
É	É	 
CIELabFromRGB
É	É	< I
(
É	É	I J
$num
É	É	J M
,
É	É	M N
$num
É	É	O R
,
É	É	R S
$num
É	É	T W
,
É	É	W X
$num
É	É	Y ]
)
É	É	] ^
}
É	É	_ `
,
É	É	` a
{
Ñ	Ñ	 
$str
Ñ	Ñ	 
,
Ñ	Ñ	 
CIELabFromRGB
Ñ	Ñ	< I
(
Ñ	Ñ	I J
$num
Ñ	Ñ	J M
,
Ñ	Ñ	M N
$num
Ñ	Ñ	O R
,
Ñ	Ñ	R S
$num
Ñ	Ñ	T X
,
Ñ	Ñ	X Y
$num
Ñ	Ñ	Z ^
)
Ñ	Ñ	^ _
}
Ñ	Ñ	` a
,
Ñ	Ñ	a b
{
Ö	Ö	 
$str
Ö	Ö	 
,
Ö	Ö	  
CIELabFromRGB
Ö	Ö	< I
(
Ö	Ö	I J
$num
Ö	Ö	J M
,
Ö	Ö	M N
$num
Ö	Ö	O R
,
Ö	Ö	R S
$num
Ö	Ö	T W
,
Ö	Ö	W X
$num
Ö	Ö	Y ]
)
Ö	Ö	] ^
}
Ö	Ö	_ `
,
Ö	Ö	` a
{
Ü	Ü	 
$str
Ü	Ü	 
,
Ü	Ü	 
CIELabFromRGB
Ü	Ü	< I
(
Ü	Ü	I J
$num
Ü	Ü	J M
,
Ü	Ü	M N
$num
Ü	Ü	O Q
,
Ü	Ü	Q R
$num
Ü	Ü	S V
,
Ü	Ü	V W
$num
Ü	Ü	X \
)
Ü	Ü	\ ]
}
Ü	Ü	^ _
,
Ü	Ü	_ `
{
á	á	 
$str
á	á	 $
,
á	á	$ %
CIELabFromRGB
á	á	< I
(
á	á	I J
$num
á	á	J L
,
á	á	L M
$num
á	á	N Q
,
á	á	Q R
$num
á	á	S V
,
á	á	V W
$num
á	á	X \
)
á	á	\ ]
}
á	á	^ _
,
á	á	_ `
{
à	à	 
$str
à	à	 
,
à	à	 
CIELabFromRGB
à	à	< I
(
à	à	I J
$num
à	à	J N
,
à	à	N O
$num
à	à	P S
,
à	à	S T
$num
à	à	U X
,
à	à	X Y
$num
à	à	Z ^
)
à	à	^ _
}
à	à	` a
,
à	à	a b
{
â	â	 
$str
â	â	 
,
â	â	 
CIELabFromRGB
â	â	< I
(
â	â	I J
$num
â	â	J M
,
â	â	M N
$num
â	â	O R
,
â	â	R S
$num
â	â	T W
,
â	â	W X
$num
â	â	Y ]
)
â	â	] ^
}
â	â	_ `
,
â	â	` a
{
ä	ä	 
$str
ä	ä	 
,
ä	ä	 
CIELabFromRGB
ä	ä	< I
(
ä	ä	I J
$num
ä	ä	J M
,
ä	ä	M N
$num
ä	ä	O R
,
ä	ä	R S
$num
ä	ä	T W
,
ä	ä	W X
$num
ä	ä	Y ]
)
ä	ä	] ^
}
ä	ä	_ `
,
ä	ä	` a
{
ã	ã	 
$str
ã	ã	 
,
ã	ã	 
CIELabFromRGB
ã	ã	< I
(
ã	ã	I J
$num
ã	ã	J M
,
ã	ã	M N
$num
ã	ã	O R
,
ã	ã	R S
$num
ã	ã	T W
,
ã	ã	W X
$num
ã	ã	Y ]
)
ã	ã	] ^
}
ã	ã	_ `
,
ã	ã	` a
{
å	å	 
$str
å	å	 
,
å	å	 
CIELabFromRGB
å	å	< I
(
å	å	I J
$num
å	å	J M
,
å	å	M N
$num
å	å	O R
,
å	å	R S
$num
å	å	T W
,
å	å	W X
$num
å	å	Y ]
)
å	å	] ^
}
å	å	_ `
,
å	å	` a
{
ç	ç	 
$str
ç	ç	 
,
ç	ç	 
CIELabFromRGB
ç	ç	< I
(
ç	ç	I J
$num
ç	ç	J M
,
ç	ç	M N
$num
ç	ç	O R
,
ç	ç	R S
$num
ç	ç	T W
,
ç	ç	W X
$num
ç	ç	Y ]
)
ç	ç	] ^
}
ç	ç	_ `
,
ç	ç	` a
{
é	é	 
$str
é	é	 
,
é	é	 
CIELabFromRGB
é	é	< I
(
é	é	I J
$num
é	é	J M
,
é	é	M N
$num
é	é	O R
,
é	é	R S
$num
é	é	T W
,
é	é	W X
$num
é	é	Y ]
)
é	é	] ^
}
é	é	_ `
,
é	é	` a
{
è	è	 
$str
è	è	 
,
è	è	 
CIELabFromRGB
è	è	< I
(
è	è	I J
$num
è	è	J M
,
è	è	M N
$num
è	è	O R
,
è	è	R S
$num
è	è	T W
,
è	è	W X
$num
è	è	Y ]
)
è	è	] ^
}
è	è	_ `
,
è	è	` a
{
ê	ê	 
$str
ê	ê	 
,
ê	ê	 
CIELabFromRGB
ê	ê	< I
(
ê	ê	I J
$num
ê	ê	J N
,
ê	ê	N O
$num
ê	ê	P S
,
ê	ê	S T
$num
ê	ê	U X
,
ê	ê	X Y
$num
ê	ê	Z ^
)
ê	ê	^ _
}
ê	ê	` a
,
ê	ê	a b
{
ë	ë	 
$str
ë	ë	 
,
ë	ë	 
CIELabFromRGB
ë	ë	< I
(
ë	ë	I J
$num
ë	ë	J M
,
ë	ë	M N
$num
ë	ë	O R
,
ë	ë	R S
$num
ë	ë	T W
,
ë	ë	W X
$num
ë	ë	Y ]
)
ë	ë	] ^
}
ë	ë	_ `
,
ë	ë	` a
{
í	í	 
$str
í	í	 
,
í	í	 
CIELabFromRGB
í	í	< I
(
í	í	I J
$num
í	í	J M
,
í	í	M N
$num
í	í	O R
,
í	í	R S
$num
í	í	T W
,
í	í	W X
$num
í	í	Y ]
)
í	í	] ^
}
í	í	_ `
,
í	í	` a
{
ì	ì	 
$str
ì	ì	 
,
ì	ì	 
CIELabFromRGB
ì	ì	< I
(
ì	ì	I J
$num
ì	ì	J N
,
ì	ì	N O
$num
ì	ì	P S
,
ì	ì	S T
$num
ì	ì	U X
,
ì	ì	X Y
$num
ì	ì	Z ^
)
ì	ì	^ _
}
ì	ì	` a
,
ì	ì	a b
{
î	î	 
$str
î	î	 
,
î	î	 
CIELabFromRGB
î	î	< I
(
î	î	I J
$num
î	î	J M
,
î	î	M N
$num
î	î	O R
,
î	î	R S
$num
î	î	T W
,
î	î	W X
$num
î	î	Y ]
)
î	î	] ^
}
î	î	_ `
,
î	î	` a
{
ï	ï	 
$str
ï	ï	 
,
ï	ï	 
CIELabFromRGB
ï	ï	< I
(
ï	ï	I J
$num
ï	ï	J M
,
ï	ï	M N
$num
ï	ï	O R
,
ï	ï	R S
$num
ï	ï	T W
,
ï	ï	W X
$num
ï	ï	Y ]
)
ï	ï	] ^
}
ï	ï	_ `
,
ï	ï	` a
{
ñ	ñ	 
$str
ñ	ñ	 
,
ñ	ñ	 
CIELabFromRGB
ñ	ñ	< I
(
ñ	ñ	I J
$num
ñ	ñ	J M
,
ñ	ñ	M N
$num
ñ	ñ	O Q
,
ñ	ñ	Q R
$num
ñ	ñ	S V
,
ñ	ñ	V W
$num
ñ	ñ	X \
)
ñ	ñ	\ ]
}
ñ	ñ	^ _
,
ñ	ñ	_ `
{
ó	ó	 
$str
ó	ó	 
,
ó	ó	 
CIELabFromRGB
ó	ó	< I
(
ó	ó	I J
$num
ó	ó	J M
,
ó	ó	M N
$num
ó	ó	O R
,
ó	ó	R S
$num
ó	ó	T W
,
ó	ó	W X
$num
ó	ó	Y ]
)
ó	ó	] ^
}
ó	ó	_ `
,
ó	ó	` a
{
ò	ò	 
$str
ò	ò	 
,
ò	ò	 
CIELabFromRGB
ò	ò	< I
(
ò	ò	I J
$num
ò	ò	J N
,
ò	ò	N O
$num
ò	ò	P S
,
ò	ò	S T
$num
ò	ò	U X
,
ò	ò	X Y
$num
ò	ò	Z ^
)
ò	ò	^ _
}
ò	ò	` a
,
ò	ò	a b
{
ô	ô	 
$str
ô	ô	 
,
ô	ô	 
CIELabFromRGB
ô	ô	< I
(
ô	ô	I J
$num
ô	ô	J N
,
ô	ô	N O
$num
ô	ô	P S
,
ô	ô	S T
$num
ô	ô	U X
,
ô	ô	X Y
$num
ô	ô	Z ^
)
ô	ô	^ _
}
ô	ô	` a
,
ô	ô	a b
{
ö	ö	 
$str
ö	ö	 
,
ö	ö	 
CIELabFromRGB
ö	ö	< I
(
ö	ö	I J
$num
ö	ö	J N
,
ö	ö	N O
$num
ö	ö	P S
,
ö	ö	S T
$num
ö	ö	U X
,
ö	ö	X Y
$num
ö	ö	Z ^
)
ö	ö	^ _
}
ö	ö	` a
,
ö	ö	a b
{
õ	õ	 
$str
õ	õ	 
,
õ	õ	 
CIELabFromRGB
õ	õ	< I
(
õ	õ	I J
$num
õ	õ	J N
,
õ	õ	N O
$num
õ	õ	P S
,
õ	õ	S T
$num
õ	õ	U X
,
õ	õ	X Y
$num
õ	õ	Z ^
)
õ	õ	^ _
}
õ	õ	` a
,
õ	õ	a b
{
ú	ú	 
$str
ú	ú	 
,
ú	ú	 
CIELabFromRGB
ú	ú	< I
(
ú	ú	I J
$num
ú	ú	J M
,
ú	ú	M N
$num
ú	ú	O R
,
ú	ú	R S
$num
ú	ú	T W
,
ú	ú	W X
$num
ú	ú	Y ]
)
ú	ú	] ^
}
ú	ú	_ `
,
ú	ú	` a
{
ù	ù	 
$str
ù	ù	 
,
ù	ù	 
CIELabFromRGB
ù	ù	< I
(
ù	ù	I J
$num
ù	ù	J M
,
ù	ù	M N
$num
ù	ù	O R
,
ù	ù	R S
$num
ù	ù	T W
,
ù	ù	W X
$num
ù	ù	Y ]
)
ù	ù	] ^
}
ù	ù	_ `
,
ù	ù	` a
{
û	û	 
$str
û	û	 
,
û	û	 
CIELabFromRGB
û	û	< I
(
û	û	I J
$num
û	û	J M
,
û	û	M N
$num
û	û	O R
,
û	û	R S
$num
û	û	T W
,
û	û	W X
$num
û	û	Y ]
)
û	û	] ^
}
û	û	_ `
,
û	û	` a
{
ü	ü	 
$str
ü	ü	 
,
ü	ü	 
CIELabFromRGB
ü	ü	< I
(
ü	ü	I J
$num
ü	ü	J M
,
ü	ü	M N
$num
ü	ü	O R
,
ü	ü	R S
$num
ü	ü	T W
,
ü	ü	W X
$num
ü	ü	Y ]
)
ü	ü	] ^
}
ü	ü	_ `
,
ü	ü	` a
{
†	†	 
$str
†	†	 
,
†	†	 
CIELabFromRGB
†	†	< I
(
†	†	I J
$num
†	†	J M
,
†	†	M N
$num
†	†	O R
,
†	†	R S
$num
†	†	T W
,
†	†	W X
$num
†	†	Y ]
)
†	†	] ^
}
†	†	_ `
,
†	†	` a
{
°	°	 
$str
°	°	 
,
°	°	 
CIELabFromRGB
°	°	< I
(
°	°	I J
$num
°	°	J M
,
°	°	M N
$num
°	°	O R
,
°	°	R S
$num
°	°	T V
,
°	°	V W
$num
°	°	X \
)
°	°	\ ]
}
°	°	^ _
,
°	°	_ `
{
¢	¢	 
$str
¢	¢	 
,
¢	¢	 
CIELabFromRGB
¢	¢	< I
(
¢	¢	I J
$num
¢	¢	J M
,
¢	¢	M N
$num
¢	¢	O R
,
¢	¢	R S
$num
¢	¢	T X
,
¢	¢	X Y
$num
¢	¢	Z ^
)
¢	¢	^ _
}
¢	¢	` a
,
¢	¢	a b
{
£	£	 
$str
£	£	 
,
£	£	 
CIELabFromRGB
£	£	< I
(
£	£	I J
$num
£	£	J M
,
£	£	M N
$num
£	£	O R
,
£	£	R S
$num
£	£	T W
,
£	£	W X
$num
£	£	Y ]
)
£	£	] ^
}
£	£	_ `
,
£	£	` a
{
§	§	 
$str
§	§	 
,
§	§	 
CIELabFromRGB
§	§	< I
(
§	§	I J
$num
§	§	J L
,
§	§	L M
$num
§	§	N Q
,
§	§	Q R
$num
§	§	S V
,
§	§	V W
$num
§	§	X \
)
§	§	\ ]
}
§	§	^ _
,
§	§	_ `
{
•	•	 
$str
•	•	 
,
•	•	 
CIELabFromRGB
•	•	< I
(
•	•	I J
$num
•	•	J M
,
•	•	M N
$num
•	•	O Q
,
•	•	Q R
$num
•	•	S V
,
•	•	V W
$num
•	•	X \
)
•	•	\ ]
}
•	•	^ _
,
•	•	_ `
{
¶	¶	 
$str
¶	¶	 
,
¶	¶	 
CIELabFromRGB
¶	¶	< I
(
¶	¶	I J
$num
¶	¶	J M
,
¶	¶	M N
$num
¶	¶	O R
,
¶	¶	R S
$num
¶	¶	T W
,
¶	¶	W X
$num
¶	¶	Y ]
)
¶	¶	] ^
}
¶	¶	_ `
,
¶	¶	` a
{
ß	ß	 
$str
ß	ß	 
,
ß	ß	 
CIELabFromRGB
ß	ß	< I
(
ß	ß	I J
$num
ß	ß	J M
,
ß	ß	M N
$num
ß	ß	O R
,
ß	ß	R S
$num
ß	ß	T W
,
ß	ß	W X
$num
ß	ß	Y ]
)
ß	ß	] ^
}
ß	ß	_ `
,
ß	ß	` a
{
®	®	 
$str
®	®	 
,
®	®	 
CIELabFromRGB
®	®	< I
(
®	®	I J
$num
®	®	J M
,
®	®	M N
$num
®	®	O R
,
®	®	R S
$num
®	®	T W
,
®	®	W X
$num
®	®	Y ]
)
®	®	] ^
}
®	®	_ `
,
®	®	` a
{
©	©	 
$str
©	©	 
,
©	©	 
CIELabFromRGB
©	©	< I
(
©	©	I J
$num
©	©	J M
,
©	©	M N
$num
©	©	O R
,
©	©	R S
$num
©	©	T W
,
©	©	W X
$num
©	©	Y ]
)
©	©	] ^
}
©	©	_ `
,
©	©	` a
{
™	™	 
$str
™	™	 
,
™	™	 
CIELabFromRGB
™	™	< I
(
™	™	I J
$num
™	™	J N
,
™	™	N O
$num
™	™	P S
,
™	™	S T
$num
™	™	U X
,
™	™	X Y
$num
™	™	Z ^
)
™	™	^ _
}
™	™	` a
,
™	™	a b
{
´	´	 
$str
´	´	 
,
´	´	 
CIELabFromRGB
´	´	< I
(
´	´	I J
$num
´	´	J M
,
´	´	M N
$num
´	´	O R
,
´	´	R S
$num
´	´	T V
,
´	´	V W
$num
´	´	X \
)
´	´	\ ]
}
´	´	^ _
,
´	´	_ `
{
¨	¨	 
$str
¨	¨	 
,
¨	¨	 
CIELabFromRGB
¨	¨	< I
(
¨	¨	I J
$num
¨	¨	J M
,
¨	¨	M N
$num
¨	¨	O R
,
¨	¨	R S
$num
¨	¨	T W
,
¨	¨	W X
$num
¨	¨	Y ]
)
¨	¨	] ^
}
¨	¨	_ `
,
¨	¨	` a
{
≠	≠	 
$str
≠	≠	 
,
≠	≠	 
CIELabFromRGB
≠	≠	< I
(
≠	≠	I J
$num
≠	≠	J M
,
≠	≠	M N
$num
≠	≠	O Q
,
≠	≠	Q R
$num
≠	≠	S W
,
≠	≠	W X
$num
≠	≠	Y ]
)
≠	≠	] ^
}
≠	≠	_ `
,
≠	≠	` a
{
Æ	Æ	 
$str
Æ	Æ	 
,
Æ	Æ	 
CIELabFromRGB
Æ	Æ	< I
(
Æ	Æ	I J
$num
Æ	Æ	J L
,
Æ	Æ	L M
$num
Æ	Æ	N P
,
Æ	Æ	P Q
$num
Æ	Æ	R U
,
Æ	Æ	U V
$num
Æ	Æ	W [
)
Æ	Æ	[ \
}
Æ	Æ	] ^
,
Æ	Æ	^ _
{
Ø	Ø	 
$str
Ø	Ø	 
,
Ø	Ø	 
CIELabFromRGB
Ø	Ø	< I
(
Ø	Ø	I J
$num
Ø	Ø	J L
,
Ø	Ø	L M
$num
Ø	Ø	N Q
,
Ø	Ø	Q R
$num
Ø	Ø	S V
,
Ø	Ø	V W
$num
Ø	Ø	X \
)
Ø	Ø	\ ]
}
Ø	Ø	^ _
,
Ø	Ø	_ `
{
∞	∞	 
$str
∞	∞	 
,
∞	∞	 
CIELabFromRGB
∞	∞	< I
(
∞	∞	I J
$num
∞	∞	J M
,
∞	∞	M N
$num
∞	∞	O R
,
∞	∞	R S
$num
∞	∞	T W
,
∞	∞	W X
$num
∞	∞	Y ]
)
∞	∞	] ^
}
∞	∞	_ `
,
∞	∞	` a
{
±	±	 
$str
±	±	 !
,
±	±	! "
CIELabFromRGB
±	±	< I
(
±	±	I J
$num
±	±	J M
,
±	±	M N
$num
±	±	O Q
,
±	±	Q R
$num
±	±	S V
,
±	±	V W
$num
±	±	X \
)
±	±	\ ]
}
±	±	^ _
,
±	±	_ `
{
≤	≤	 
$str
≤	≤	 
,
≤	≤	 
CIELabFromRGB
≤	≤	< I
(
≤	≤	I J
$num
≤	≤	J M
,
≤	≤	M N
$num
≤	≤	O R
,
≤	≤	R S
$num
≤	≤	T W
,
≤	≤	W X
$num
≤	≤	Y ]
)
≤	≤	] ^
}
≤	≤	_ `
,
≤	≤	` a
{
≥	≥	 
$str
≥	≥	 
,
≥	≥	 
CIELabFromRGB
≥	≥	< I
(
≥	≥	I J
$num
≥	≥	J L
,
≥	≥	L M
$num
≥	≥	N Q
,
≥	≥	Q R
$num
≥	≥	S V
,
≥	≥	V W
$num
≥	≥	X \
)
≥	≥	\ ]
}
≥	≥	^ _
,
≥	≥	_ `
{
¥	¥	 
$str
¥	¥	 
,
¥	¥	 
CIELabFromRGB
¥	¥	< I
(
¥	¥	I J
$num
¥	¥	J M
,
¥	¥	M N
$num
¥	¥	O R
,
¥	¥	R S
$num
¥	¥	T V
,
¥	¥	V W
$num
¥	¥	X \
)
¥	¥	\ ]
}
¥	¥	^ _
,
¥	¥	_ `
{
µ	µ	 
$str
µ	µ	 
,
µ	µ	 
CIELabFromRGB
µ	µ	< I
(
µ	µ	I J
$num
µ	µ	J N
,
µ	µ	N O
$num
µ	µ	P S
,
µ	µ	S T
$num
µ	µ	U X
,
µ	µ	X Y
$num
µ	µ	Z ^
)
µ	µ	^ _
}
µ	µ	` a
,
µ	µ	a b
{
∂	∂	 
$str
∂	∂	 
,
∂	∂	 
CIELabFromRGB
∂	∂	< I
(
∂	∂	I J
$num
∂	∂	J M
,
∂	∂	M N
$num
∂	∂	O R
,
∂	∂	R S
$num
∂	∂	T W
,
∂	∂	W X
$num
∂	∂	Y ]
)
∂	∂	] ^
}
∂	∂	_ `
,
∂	∂	` a
{
∑	∑	 
$str
∑	∑	 
,
∑	∑	 
CIELabFromRGB
∑	∑	< I
(
∑	∑	I J
$num
∑	∑	J N
,
∑	∑	N O
$num
∑	∑	P S
,
∑	∑	S T
$num
∑	∑	U X
,
∑	∑	X Y
$num
∑	∑	Z ^
)
∑	∑	^ _
}
∑	∑	` a
,
∑	∑	a b
{
∏	∏	 
$str
∏	∏	 
,
∏	∏	 
CIELabFromRGB
∏	∏	< I
(
∏	∏	I J
$num
∏	∏	J M
,
∏	∏	M N
$num
∏	∏	O R
,
∏	∏	R S
$num
∏	∏	T W
,
∏	∏	W X
$num
∏	∏	Y ]
)
∏	∏	] ^
}
∏	∏	_ `
,
∏	∏	` a
{
π	π	 
$str
π	π	 
,
π	π	 
CIELabFromRGB
π	π	< I
(
π	π	I J
$num
π	π	J N
,
π	π	N O
$num
π	π	P S
,
π	π	S T
$num
π	π	U X
,
π	π	X Y
$num
π	π	Z ^
)
π	π	^ _
}
π	π	` a
,
π	π	a b
{
∫	∫	 
$str
∫	∫	 
,
∫	∫	 
CIELabFromRGB
∫	∫	< I
(
∫	∫	I J
$num
∫	∫	J M
,
∫	∫	M N
$num
∫	∫	O R
,
∫	∫	R S
$num
∫	∫	T W
,
∫	∫	W X
$num
∫	∫	Y ]
)
∫	∫	] ^
}
∫	∫	_ `
,
∫	∫	` a
{
ª	ª	 
$str
ª	ª	 
,
ª	ª	 
CIELabFromRGB
ª	ª	< I
(
ª	ª	I J
$num
ª	ª	J M
,
ª	ª	M N
$num
ª	ª	O Q
,
ª	ª	Q R
$num
ª	ª	S V
,
ª	ª	V W
$num
ª	ª	X \
)
ª	ª	\ ]
}
ª	ª	^ _
,
ª	ª	_ `
{
º	º	 
$str
º	º	 
,
º	º	 
CIELabFromRGB
º	º	< I
(
º	º	I J
$num
º	º	J M
,
º	º	M N
$num
º	º	O R
,
º	º	R S
$num
º	º	T W
,
º	º	W X
$num
º	º	Y ]
)
º	º	] ^
}
º	º	_ `
,
º	º	` a
{
Ω	Ω	 
$str
Ω	Ω	 
,
Ω	Ω	 
CIELabFromRGB
Ω	Ω	< I
(
Ω	Ω	I J
$num
Ω	Ω	J M
,
Ω	Ω	M N
$num
Ω	Ω	O R
,
Ω	Ω	R S
$num
Ω	Ω	T W
,
Ω	Ω	W X
$num
Ω	Ω	Y ]
)
Ω	Ω	] ^
}
Ω	Ω	_ `
,
Ω	Ω	` a
{
æ	æ	 
$str
æ	æ	 
,
æ	æ	 
CIELabFromRGB
æ	æ	< I
(
æ	æ	I J
$num
æ	æ	J M
,
æ	æ	M N
$num
æ	æ	O R
,
æ	æ	R S
$num
æ	æ	T W
,
æ	æ	W X
$num
æ	æ	Y ]
)
æ	æ	] ^
}
æ	æ	_ `
,
æ	æ	` a
{
ø	ø	 
$str
ø	ø	 
,
ø	ø	 
CIELabFromRGB
ø	ø	< I
(
ø	ø	I J
$num
ø	ø	J M
,
ø	ø	M N
$num
ø	ø	O R
,
ø	ø	R S
$num
ø	ø	T W
,
ø	ø	W X
$num
ø	ø	Y ]
)
ø	ø	] ^
}
ø	ø	_ `
,
ø	ø	` a
{
¿	¿	 
$str
¿	¿	 
,
¿	¿	 
CIELabFromRGB
¿	¿	< I
(
¿	¿	I J
$num
¿	¿	J M
,
¿	¿	M N
$num
¿	¿	O R
,
¿	¿	R S
$num
¿	¿	T W
,
¿	¿	W X
$num
¿	¿	Y ]
)
¿	¿	] ^
}
¿	¿	_ `
,
¿	¿	` a
{
¡	¡	 
$str
¡	¡	 
,
¡	¡	 
CIELabFromRGB
¡	¡	< I
(
¡	¡	I J
$num
¡	¡	J M
,
¡	¡	M N
$num
¡	¡	O R
,
¡	¡	R S
$num
¡	¡	T W
,
¡	¡	W X
$num
¡	¡	Y ]
)
¡	¡	] ^
}
¡	¡	_ `
,
¡	¡	` a
{
¬	¬	 
$str
¬	¬	 
,
¬	¬	 
CIELabFromRGB
¬	¬	< I
(
¬	¬	I J
$num
¬	¬	J M
,
¬	¬	M N
$num
¬	¬	O R
,
¬	¬	R S
$num
¬	¬	T W
,
¬	¬	W X
$num
¬	¬	Y ]
)
¬	¬	] ^
}
¬	¬	_ `
,
¬	¬	` a
{
√	√	 
$str
√	√	 
,
√	√	  
CIELabFromRGB
√	√	< I
(
√	√	I J
$num
√	√	J N
,
√	√	N O
$num
√	√	P S
,
√	√	S T
$num
√	√	U X
,
√	√	X Y
$num
√	√	Z ^
)
√	√	^ _
}
√	√	` a
,
√	√	a b
{
ƒ	ƒ	 
$str
ƒ	ƒ	 
,
ƒ	ƒ	 
CIELabFromRGB
ƒ	ƒ	< I
(
ƒ	ƒ	I J
$num
ƒ	ƒ	J M
,
ƒ	ƒ	M N
$num
ƒ	ƒ	O R
,
ƒ	ƒ	R S
$num
ƒ	ƒ	T W
,
ƒ	ƒ	W X
$num
ƒ	ƒ	Y ]
)
ƒ	ƒ	] ^
}
ƒ	ƒ	_ `
,
ƒ	ƒ	` a
{
≈	≈	 
$str
≈	≈	  
,
≈	≈	  !
CIELabFromRGB
≈	≈	< I
(
≈	≈	I J
$num
≈	≈	J M
,
≈	≈	M N
$num
≈	≈	O R
,
≈	≈	R S
$num
≈	≈	T W
,
≈	≈	W X
$num
≈	≈	Y ]
)
≈	≈	] ^
}
≈	≈	_ `
,
≈	≈	` a
{
∆	∆	 
$str
∆	∆	 
,
∆	∆	 
CIELabFromRGB
∆	∆	< I
(
∆	∆	I J
$num
∆	∆	J M
,
∆	∆	M N
$num
∆	∆	O R
,
∆	∆	R S
$num
∆	∆	T W
,
∆	∆	W X
$num
∆	∆	Y ]
)
∆	∆	] ^
}
∆	∆	_ `
,
∆	∆	` a
{
«	«	 
$str
«	«	 
,
«	«	 
CIELabFromRGB
«	«	< I
(
«	«	I J
$num
«	«	J L
,
«	«	L M
$num
«	«	N Q
,
«	«	Q R
$num
«	«	S V
,
«	«	V W
$num
«	«	X \
)
«	«	\ ]
}
«	«	^ _
,
«	«	_ `
{
»	»	 
$str
»	»	 "
,
»	»	" #
CIELabFromRGB
»	»	< I
(
»	»	I J
$num
»	»	J M
,
»	»	M N
$num
»	»	O Q
,
»	»	Q R
$num
»	»	S W
,
»	»	W X
$num
»	»	Y ]
)
»	»	] ^
}
»	»	_ `
,
»	»	` a
{
…	…	 
$str
…	…	 
,
…	…	 
CIELabFromRGB
…	…	< I
(
…	…	I J
$num
…	…	J M
,
…	…	M N
$num
…	…	O R
,
…	…	R S
$num
…	…	T W
,
…	…	W X
$num
…	…	Y ]
)
…	…	] ^
}
…	…	_ `
,
…	…	` a
{
 	 	 
$str
 	 	 
,
 	 	 
CIELabFromRGB
 	 	< I
(
 	 	I J
$num
 	 	J M
,
 	 	M N
$num
 	 	O R
,
 	 	R S
$num
 	 	T W
,
 	 	W X
$num
 	 	Y ]
)
 	 	] ^
}
 	 	_ `
,
 	 	` a
{
À	À	 
$str
À	À	 )
,
À	À	) *
CIELabFromRGB
À	À	< I
(
À	À	I J
$num
À	À	J M
,
À	À	M N
$num
À	À	O R
,
À	À	R S
$num
À	À	T V
,
À	À	V W
$num
À	À	X \
)
À	À	\ ]
}
À	À	^ _
,
À	À	_ `
{
Ã	Ã	 
$str
Ã	Ã	 
,
Ã	Ã	 
CIELabFromRGB
Ã	Ã	< I
(
Ã	Ã	I J
$num
Ã	Ã	J M
,
Ã	Ã	M N
$num
Ã	Ã	O R
,
Ã	Ã	R S
$num
Ã	Ã	T W
,
Ã	Ã	W X
$num
Ã	Ã	Y ]
)
Ã	Ã	] ^
}
Ã	Ã	_ `
,
Ã	Ã	` a
{
Õ	Õ	 
$str
Õ	Õ	 
,
Õ	Õ	 
CIELabFromRGB
Õ	Õ	< I
(
Õ	Õ	I J
$num
Õ	Õ	J N
,
Õ	Õ	N O
$num
Õ	Õ	P S
,
Õ	Õ	S T
$num
Õ	Õ	U W
,
Õ	Õ	W X
$num
Õ	Õ	Y ]
)
Õ	Õ	] ^
}
Õ	Õ	_ `
,
Õ	Õ	` a
{
Œ	Œ	 
$str
Œ	Œ	 
,
Œ	Œ	 
CIELabFromRGB
Œ	Œ	< I
(
Œ	Œ	I J
$num
Œ	Œ	J M
,
Œ	Œ	M N
$num
Œ	Œ	O Q
,
Œ	Œ	Q R
$num
Œ	Œ	S V
,
Œ	Œ	V W
$num
Œ	Œ	X \
)
Œ	Œ	\ ]
}
Œ	Œ	^ _
,
Œ	Œ	_ `
{
œ	œ	 
$str
œ	œ	  
,
œ	œ	  !
CIELabFromRGB
œ	œ	< I
(
œ	œ	I J
$num
œ	œ	J M
,
œ	œ	M N
$num
œ	œ	O Q
,
œ	œ	Q R
$num
œ	œ	S V
,
œ	œ	V W
$num
œ	œ	X \
)
œ	œ	\ ]
}
œ	œ	^ _
,
œ	œ	_ `
{
–	–	 
$str
–	–	 
,
–	–	 
CIELabFromRGB
–	–	< I
(
–	–	I J
$num
–	–	J M
,
–	–	M N
$num
–	–	O R
,
–	–	R S
$num
–	–	T W
,
–	–	W X
$num
–	–	Y ]
)
–	–	] ^
}
–	–	_ `
,
–	–	` a
{
—	—	 
$str
—	—	 
,
—	—	 
CIELabFromRGB
—	—	< I
(
—	—	I J
$num
—	—	J M
,
—	—	M N
$num
—	—	O R
,
—	—	R S
$num
—	—	T W
,
—	—	W X
$num
—	—	Y ]
)
—	—	] ^
}
—	—	_ `
,
—	—	` a
{
“	“	 
$str
“	“	 '
,
“	“	' (
CIELabFromRGB
“	“	< I
(
“	“	I J
$num
“	“	J M
,
“	“	M N
$num
“	“	O R
,
“	“	R S
$num
“	“	T W
,
“	“	W X
$num
“	“	Y ]
)
“	“	] ^
}
“	“	_ `
,
“	“	` a
{
”	”	 
$str
”	”	 
,
”	”	 
CIELabFromRGB
”	”	< I
(
”	”	I J
$num
”	”	J M
,
”	”	M N
$num
”	”	O R
,
”	”	R S
$num
”	”	T W
,
”	”	W X
$num
”	”	Y ]
)
”	”	] ^
}
”	”	_ `
,
”	”	` a
{
‘	‘	 
$str
‘	‘	 
,
‘	‘	 
CIELabFromRGB
‘	‘	< I
(
‘	‘	I J
$num
‘	‘	J N
,
‘	‘	N O
$num
‘	‘	P S
,
‘	‘	S T
$num
‘	‘	U X
,
‘	‘	X Y
$num
‘	‘	Z ^
)
‘	‘	^ _
}
‘	‘	` a
,
‘	‘	a b
{
’	’	 
$str
’	’	 
,
’	’	 
CIELabFromRGB
’	’	< I
(
’	’	I J
$num
’	’	J M
,
’	’	M N
$num
’	’	O R
,
’	’	R S
$num
’	’	T W
,
’	’	W X
$num
’	’	Y ]
)
’	’	] ^
}
’	’	_ `
,
’	’	` a
{
÷	÷	 
$str
÷	÷	 
,
÷	÷	 
CIELabFromRGB
÷	÷	< I
(
÷	÷	I J
$num
÷	÷	J M
,
÷	÷	M N
$num
÷	÷	O R
,
÷	÷	R S
$num
÷	÷	T W
,
÷	÷	W X
$num
÷	÷	Y ]
)
÷	÷	] ^
}
÷	÷	_ `
,
÷	÷	` a
{
◊	◊	 
$str
◊	◊	 
,
◊	◊	 
CIELabFromRGB
◊	◊	< I
(
◊	◊	I J
$num
◊	◊	J M
,
◊	◊	M N
$num
◊	◊	O R
,
◊	◊	R S
$num
◊	◊	T W
,
◊	◊	W X
$num
◊	◊	Y ]
)
◊	◊	] ^
}
◊	◊	_ `
,
◊	◊	` a
{
ÿ	ÿ	 
$str
ÿ	ÿ	 
,
ÿ	ÿ	 
CIELabFromRGB
ÿ	ÿ	< I
(
ÿ	ÿ	I J
$num
ÿ	ÿ	J M
,
ÿ	ÿ	M N
$num
ÿ	ÿ	O R
,
ÿ	ÿ	R S
$num
ÿ	ÿ	T W
,
ÿ	ÿ	W X
$num
ÿ	ÿ	Y ]
)
ÿ	ÿ	] ^
}
ÿ	ÿ	_ `
,
ÿ	ÿ	` a
{
Ÿ	Ÿ	 
$str
Ÿ	Ÿ	 
,
Ÿ	Ÿ	 
CIELabFromRGB
Ÿ	Ÿ	< I
(
Ÿ	Ÿ	I J
$num
Ÿ	Ÿ	J M
,
Ÿ	Ÿ	M N
$num
Ÿ	Ÿ	O R
,
Ÿ	Ÿ	R S
$num
Ÿ	Ÿ	T W
,
Ÿ	Ÿ	W X
$num
Ÿ	Ÿ	Y ]
)
Ÿ	Ÿ	] ^
}
Ÿ	Ÿ	_ `
,
Ÿ	Ÿ	` a
{
⁄	⁄	 
$str
⁄	⁄	 $
,
⁄	⁄	$ %
CIELabFromRGB
⁄	⁄	< I
(
⁄	⁄	I J
$num
⁄	⁄	J M
,
⁄	⁄	M N
$num
⁄	⁄	O R
,
⁄	⁄	R S
$num
⁄	⁄	T W
,
⁄	⁄	W X
$num
⁄	⁄	Y ]
)
⁄	⁄	] ^
}
⁄	⁄	_ `
,
⁄	⁄	` a
{
€	€	 
$str
€	€	 
,
€	€	 
CIELabFromRGB
€	€	< I
(
€	€	I J
$num
€	€	J M
,
€	€	M N
$num
€	€	O R
,
€	€	R S
$num
€	€	T W
,
€	€	W X
$num
€	€	Y ]
)
€	€	] ^
}
€	€	_ `
,
€	€	` a
{
‹	‹	 
$str
‹	‹	 
,
‹	‹	 
CIELabFromRGB
‹	‹	< I
(
‹	‹	I J
$num
‹	‹	J N
,
‹	‹	N O
$num
‹	‹	P S
,
‹	‹	S T
$num
‹	‹	U X
,
‹	‹	X Y
$num
‹	‹	Z ^
)
‹	‹	^ _
}
‹	‹	` a
,
‹	‹	a b
{
›	›	 
$str
›	›	 
,
›	›	 
CIELabFromRGB
›	›	< I
(
›	›	I J
$num
›	›	J M
,
›	›	M N
$num
›	›	O R
,
›	›	R S
$num
›	›	T W
,
›	›	W X
$num
›	›	Y ]
)
›	›	] ^
}
›	›	_ `
,
›	›	` a
{
ﬁ	ﬁ	 
$str
ﬁ	ﬁ	 
,
ﬁ	ﬁ	 
CIELabFromRGB
ﬁ	ﬁ	< I
(
ﬁ	ﬁ	I J
$num
ﬁ	ﬁ	J M
,
ﬁ	ﬁ	M N
$num
ﬁ	ﬁ	O Q
,
ﬁ	ﬁ	Q R
$num
ﬁ	ﬁ	S V
,
ﬁ	ﬁ	V W
$num
ﬁ	ﬁ	X \
)
ﬁ	ﬁ	\ ]
}
ﬁ	ﬁ	^ _
,
ﬁ	ﬁ	_ `
{
ﬂ	ﬂ	 
$str
ﬂ	ﬂ	 
,
ﬂ	ﬂ	  
CIELabFromRGB
ﬂ	ﬂ	< I
(
ﬂ	ﬂ	I J
$num
ﬂ	ﬂ	J M
,
ﬂ	ﬂ	M N
$num
ﬂ	ﬂ	O R
,
ﬂ	ﬂ	R S
$num
ﬂ	ﬂ	T W
,
ﬂ	ﬂ	W X
$num
ﬂ	ﬂ	Y ]
)
ﬂ	ﬂ	] ^
}
ﬂ	ﬂ	_ `
,
ﬂ	ﬂ	` a
{
‡	‡	 
$str
‡	‡	 
,
‡	‡	 
CIELabFromRGB
‡	‡	< I
(
‡	‡	I J
$num
‡	‡	J M
,
‡	‡	M N
$num
‡	‡	O R
,
‡	‡	R S
$num
‡	‡	T W
,
‡	‡	W X
$num
‡	‡	Y ]
)
‡	‡	] ^
}
‡	‡	_ `
,
‡	‡	` a
{
·	·	 
$str
·	·	 
,
·	·	 
CIELabFromRGB
·	·	< I
(
·	·	I J
$num
·	·	J M
,
·	·	M N
$num
·	·	O R
,
·	·	R S
$num
·	·	T W
,
·	·	W X
$num
·	·	Y ]
)
·	·	] ^
}
·	·	_ `
,
·	·	` a
{
‚	‚	 
$str
‚	‚	 
,
‚	‚	 
CIELabFromRGB
‚	‚	< I
(
‚	‚	I J
$num
‚	‚	J M
,
‚	‚	M N
$num
‚	‚	O R
,
‚	‚	R S
$num
‚	‚	T W
,
‚	‚	W X
$num
‚	‚	Y ]
)
‚	‚	] ^
}
‚	‚	_ `
,
‚	‚	` a
{
„	„	 
$str
„	„	 "
,
„	„	" #
CIELabFromRGB
„	„	< I
(
„	„	I J
$num
„	„	J N
,
„	„	N O
$num
„	„	P S
,
„	„	S T
$num
„	„	U X
,
„	„	X Y
$num
„	„	Z ^
)
„	„	^ _
}
„	„	` a
,
„	„	a b
{
‰	‰	 
$str
‰	‰	 
,
‰	‰	 
CIELabFromRGB
‰	‰	< I
(
‰	‰	I J
$num
‰	‰	J M
,
‰	‰	M N
$num
‰	‰	O R
,
‰	‰	R S
$num
‰	‰	T W
,
‰	‰	W X
$num
‰	‰	Y ]
)
‰	‰	] ^
}
‰	‰	_ `
,
‰	‰	` a
{
Â	Â	 
$str
Â	Â	 
,
Â	Â	 
CIELabFromRGB
Â	Â	< I
(
Â	Â	I J
$num
Â	Â	J M
,
Â	Â	M N
$num
Â	Â	O R
,
Â	Â	R S
$num
Â	Â	T W
,
Â	Â	W X
$num
Â	Â	Y ]
)
Â	Â	] ^
}
Â	Â	_ `
,
Â	Â	` a
{
Ê	Ê	 
$str
Ê	Ê	 
,
Ê	Ê	 
CIELabFromRGB
Ê	Ê	< I
(
Ê	Ê	I J
$num
Ê	Ê	J M
,
Ê	Ê	M N
$num
Ê	Ê	O R
,
Ê	Ê	R S
$num
Ê	Ê	T W
,
Ê	Ê	W X
$num
Ê	Ê	Y ]
)
Ê	Ê	] ^
}
Ê	Ê	_ `
,
Ê	Ê	` a
{
Á	Á	 
$str
Á	Á	 
,
Á	Á	 
CIELabFromRGB
Á	Á	< I
(
Á	Á	I J
$num
Á	Á	J N
,
Á	Á	N O
$num
Á	Á	P R
,
Á	Á	R S
$num
Á	Á	T V
,
Á	Á	V W
$num
Á	Á	X \
)
Á	Á	\ ]
}
Á	Á	^ _
,
Á	Á	_ `
{
Ë	Ë	 
$str
Ë	Ë	 
,
Ë	Ë	 
CIELabFromRGB
Ë	Ë	< I
(
Ë	Ë	I J
$num
Ë	Ë	J M
,
Ë	Ë	M N
$num
Ë	Ë	O R
,
Ë	Ë	R S
$num
Ë	Ë	T W
,
Ë	Ë	W X
$num
Ë	Ë	Y ]
)
Ë	Ë	] ^
}
Ë	Ë	_ `
,
Ë	Ë	` a
{
È	È	 
$str
È	È	 
,
È	È	 
CIELabFromRGB
È	È	< I
(
È	È	I J
$num
È	È	J M
,
È	È	M N
$num
È	È	O Q
,
È	È	Q R
$num
È	È	S V
,
È	È	V W
$num
È	È	X \
)
È	È	\ ]
}
È	È	^ _
,
È	È	_ `
{
Í	Í	 
$str
Í	Í	 
,
Í	Í	 
CIELabFromRGB
Í	Í	< I
(
Í	Í	I J
$num
Í	Í	J M
,
Í	Í	M N
$num
Í	Í	O Q
,
Í	Í	Q R
$num
Í	Í	S V
,
Í	Í	V W
$num
Í	Í	X \
)
Í	Í	\ ]
}
Í	Í	^ _
,
Í	Í	_ `
{
Î	Î	 
$str
Î	Î	 
,
Î	Î	 
CIELabFromRGB
Î	Î	< I
(
Î	Î	I J
$num
Î	Î	J M
,
Î	Î	M N
$num
Î	Î	O R
,
Î	Î	R S
$num
Î	Î	T W
,
Î	Î	W X
$num
Î	Î	Y ]
)
Î	Î	] ^
}
Î	Î	_ `
,
Î	Î	` a
{
Ï	Ï	 
$str
Ï	Ï	 
,
Ï	Ï	 
CIELabFromRGB
Ï	Ï	< I
(
Ï	Ï	I J
$num
Ï	Ï	J M
,
Ï	Ï	M N
$num
Ï	Ï	O R
,
Ï	Ï	R S
$num
Ï	Ï	T W
,
Ï	Ï	W X
$num
Ï	Ï	Y ]
)
Ï	Ï	] ^
}
Ï	Ï	_ `
,
Ï	Ï	` a
{
Ì	Ì	 
$str
Ì	Ì	 
,
Ì	Ì	 
CIELabFromRGB
Ì	Ì	< I
(
Ì	Ì	I J
$num
Ì	Ì	J N
,
Ì	Ì	N O
$num
Ì	Ì	P S
,
Ì	Ì	S T
$num
Ì	Ì	U W
,
Ì	Ì	W X
$num
Ì	Ì	Y ]
)
Ì	Ì	] ^
}
Ì	Ì	_ `
,
Ì	Ì	` a
{
Ó	Ó	 
$str
Ó	Ó	 
,
Ó	Ó	 
CIELabFromRGB
Ó	Ó	< I
(
Ó	Ó	I J
$num
Ó	Ó	J M
,
Ó	Ó	M N
$num
Ó	Ó	O R
,
Ó	Ó	R S
$num
Ó	Ó	T W
,
Ó	Ó	W X
$num
Ó	Ó	Y ]
)
Ó	Ó	] ^
}
Ó	Ó	_ `
,
Ó	Ó	` a
{
Ô	Ô	 
$str
Ô	Ô	 
,
Ô	Ô	 
CIELabFromRGB
Ô	Ô	< I
(
Ô	Ô	I J
$num
Ô	Ô	J M
,
Ô	Ô	M N
$num
Ô	Ô	O Q
,
Ô	Ô	Q R
$num
Ô	Ô	S U
,
Ô	Ô	U V
$num
Ô	Ô	W [
)
Ô	Ô	[ \
}
Ô	Ô	] ^
,
Ô	Ô	^ _
{
		 
$str
		 
,
		 
CIELabFromRGB
		< I
(
		I J
$num
		J N
,
		N O
$num
		P S
,
		S T
$num
		U X
,
		X Y
$num
		Z ^
)
		^ _
}
		` a
,
		a b
{
Ò	Ò	 
$str
Ò	Ò	 
,
Ò	Ò	 
CIELabFromRGB
Ò	Ò	< I
(
Ò	Ò	I J
$num
Ò	Ò	J M
,
Ò	Ò	M N
$num
Ò	Ò	O Q
,
Ò	Ò	Q R
$num
Ò	Ò	S V
,
Ò	Ò	V W
$num
Ò	Ò	X \
)
Ò	Ò	\ ]
}
Ò	Ò	^ _
,
Ò	Ò	_ `
{
Ú	Ú	 
$str
Ú	Ú	 
,
Ú	Ú	 
CIELabFromRGB
Ú	Ú	< I
(
Ú	Ú	I J
$num
Ú	Ú	J M
,
Ú	Ú	M N
$num
Ú	Ú	O Q
,
Ú	Ú	Q R
$num
Ú	Ú	S V
,
Ú	Ú	V W
$num
Ú	Ú	X \
)
Ú	Ú	\ ]
}
Ú	Ú	^ _
,
Ú	Ú	_ `
{
Û	Û	 
$str
Û	Û	 
,
Û	Û	 
CIELabFromRGB
Û	Û	< I
(
Û	Û	I J
$num
Û	Û	J M
,
Û	Û	M N
$num
Û	Û	O R
,
Û	Û	R S
$num
Û	Û	T W
,
Û	Û	W X
$num
Û	Û	Y ]
)
Û	Û	] ^
}
Û	Û	_ `
,
Û	Û	` a
{
Ù	Ù	 
$str
Ù	Ù	 
,
Ù	Ù	 
CIELabFromRGB
Ù	Ù	< I
(
Ù	Ù	I J
$num
Ù	Ù	J M
,
Ù	Ù	M N
$num
Ù	Ù	O R
,
Ù	Ù	R S
$num
Ù	Ù	T W
,
Ù	Ù	W X
$num
Ù	Ù	Y ]
)
Ù	Ù	] ^
}
Ù	Ù	_ `
,
Ù	Ù	` a
{
ı	ı	 
$str
ı	ı	 "
,
ı	ı	" #
CIELabFromRGB
ı	ı	< I
(
ı	ı	I J
$num
ı	ı	J L
,
ı	ı	L M
$num
ı	ı	N P
,
ı	ı	P Q
$num
ı	ı	R T
,
ı	ı	T U
$num
ı	ı	V Z
)
ı	ı	Z [
}
ı	ı	\ ]
,
ı	ı	] ^
{
ˆ	ˆ	 
$str
ˆ	ˆ	 
,
ˆ	ˆ	  
CIELabFromRGB
ˆ	ˆ	< I
(
ˆ	ˆ	I J
$num
ˆ	ˆ	J L
,
ˆ	ˆ	L M
$num
ˆ	ˆ	N Q
,
ˆ	ˆ	Q R
$num
ˆ	ˆ	S V
,
ˆ	ˆ	V W
$num
ˆ	ˆ	X \
)
ˆ	ˆ	\ ]
}
ˆ	ˆ	^ _
,
ˆ	ˆ	_ `
{
˜	˜	 
$str
˜	˜	 
,
˜	˜	 
CIELabFromRGB
˜	˜	< I
(
˜	˜	I J
$num
˜	˜	J M
,
˜	˜	M N
$num
˜	˜	O R
,
˜	˜	R S
$num
˜	˜	T W
,
˜	˜	W X
$num
˜	˜	Y ]
)
˜	˜	] ^
}
˜	˜	_ `
,
˜	˜	` a
{
¯	¯	 
$str
¯	¯	 
,
¯	¯	 
CIELabFromRGB
¯	¯	< I
(
¯	¯	I J
$num
¯	¯	J L
,
¯	¯	L M
$num
¯	¯	N Q
,
¯	¯	Q R
$num
¯	¯	S V
,
¯	¯	V W
$num
¯	¯	X \
)
¯	¯	\ ]
}
¯	¯	^ _
,
¯	¯	_ `
{
˘	˘	 
$str
˘	˘	 $
,
˘	˘	$ %
CIELabFromRGB
˘	˘	< I
(
˘	˘	I J
$num
˘	˘	J L
,
˘	˘	L M
$num
˘	˘	N P
,
˘	˘	P Q
$num
˘	˘	R T
,
˘	˘	T U
$num
˘	˘	V Z
)
˘	˘	Z [
}
˘	˘	\ ]
,
˘	˘	] ^
{
˙	˙	 
$str
˙	˙	 $
,
˙	˙	$ %
CIELabFromRGB
˙	˙	< I
(
˙	˙	I J
$num
˙	˙	J L
,
˙	˙	L M
$num
˙	˙	N P
,
˙	˙	P Q
$num
˙	˙	R T
,
˙	˙	T U
$num
˙	˙	V Z
)
˙	˙	Z [
}
˙	˙	\ ]
,
˙	˙	] ^
{
˚	˚	 
$str
˚	˚	 '
,
˚	˚	' (
CIELabFromRGB
˚	˚	< I
(
˚	˚	I J
$num
˚	˚	J M
,
˚	˚	M N
$num
˚	˚	O R
,
˚	˚	R S
$num
˚	˚	T X
,
˚	˚	X Y
$num
˚	˚	Z ^
)
˚	˚	^ _
}
˚	˚	` a
,
˚	˚	a b
{
¸	¸	 
$str
¸	¸	 
,
¸	¸	 
CIELabFromRGB
¸	¸	< I
(
¸	¸	I J
$num
¸	¸	J M
,
¸	¸	M N
$num
¸	¸	O Q
,
¸	¸	Q R
$num
¸	¸	S V
,
¸	¸	V W
$num
¸	¸	X \
)
¸	¸	\ ]
}
¸	¸	^ _
,
¸	¸	_ `
{
˝	˝	 
$str
˝	˝	 "
,
˝	˝	" #
CIELabFromRGB
˝	˝	< I
(
˝	˝	I J
$num
˝	˝	J L
,
˝	˝	L M
$num
˝	˝	N Q
,
˝	˝	Q R
$num
˝	˝	S V
,
˝	˝	V W
$num
˝	˝	X \
)
˝	˝	\ ]
}
˝	˝	^ _
,
˝	˝	_ `
{
˛	˛	 
$str
˛	˛	 
,
˛	˛	 
CIELabFromRGB
˛	˛	< I
(
˛	˛	I J
$num
˛	˛	J M
,
˛	˛	M N
$num
˛	˛	O R
,
˛	˛	R S
$num
˛	˛	T W
,
˛	˛	W X
$num
˛	˛	Y ]
)
˛	˛	] ^
}
˛	˛	_ `
,
˛	˛	` a
{
ˇ	ˇ	 
$str
ˇ	ˇ	 
,
ˇ	ˇ	 
CIELabFromRGB
ˇ	ˇ	< I
(
ˇ	ˇ	I J
$num
ˇ	ˇ	J M
,
ˇ	ˇ	M N
$num
ˇ	ˇ	O R
,
ˇ	ˇ	R S
$num
ˇ	ˇ	T W
,
ˇ	ˇ	W X
$num
ˇ	ˇ	Y ]
)
ˇ	ˇ	] ^
}
ˇ	ˇ	_ `
,
ˇ	ˇ	` a
{
Ä
Ä
 
$str
Ä
Ä
 
,
Ä
Ä
 
CIELabFromRGB
Ä
Ä
< I
(
Ä
Ä
I J
$num
Ä
Ä
J M
,
Ä
Ä
M N
$num
Ä
Ä
O R
,
Ä
Ä
R S
$num
Ä
Ä
T W
,
Ä
Ä
W X
$num
Ä
Ä
Y ]
)
Ä
Ä
] ^
}
Ä
Ä
_ `
,
Ä
Ä
` a
{
Å
Å
 
$str
Å
Å
 
,
Å
Å
 
CIELabFromRGB
Å
Å
< I
(
Å
Å
I J
$num
Å
Å
J M
,
Å
Å
M N
$num
Å
Å
O R
,
Å
Å
R S
$num
Å
Å
T W
,
Å
Å
W X
$num
Å
Å
Y ]
)
Å
Å
] ^
}
Å
Å
_ `
,
Å
Å
` a
{
Ç
Ç
 
$str
Ç
Ç
 
,
Ç
Ç
 
CIELabFromRGB
Ç
Ç
< I
(
Ç
Ç
I J
$num
Ç
Ç
J M
,
Ç
Ç
M N
$num
Ç
Ç
O R
,
Ç
Ç
R S
$num
Ç
Ç
T W
,
Ç
Ç
W X
$num
Ç
Ç
Y ]
)
Ç
Ç
] ^
}
Ç
Ç
_ `
,
Ç
Ç
` a
{
É
É
 
$str
É
É
 
,
É
É
 
CIELabFromRGB
É
É
< I
(
É
É
I J
$num
É
É
J L
,
É
É
L M
$num
É
É
N Q
,
É
É
Q R
$num
É
É
S V
,
É
É
V W
$num
É
É
X \
)
É
É
\ ]
}
É
É
^ _
,
É
É
_ `
{
Ñ
Ñ
 
$str
Ñ
Ñ
 
,
Ñ
Ñ
  
CIELabFromRGB
Ñ
Ñ
< I
(
Ñ
Ñ
I J
$num
Ñ
Ñ
J M
,
Ñ
Ñ
M N
$num
Ñ
Ñ
O R
,
Ñ
Ñ
R S
$num
Ñ
Ñ
T W
,
Ñ
Ñ
W X
$num
Ñ
Ñ
Y ]
)
Ñ
Ñ
] ^
}
Ñ
Ñ
_ `
,
Ñ
Ñ
` a
{
Ö
Ö
 
$str
Ö
Ö
 
,
Ö
Ö
 
CIELabFromRGB
Ö
Ö
< I
(
Ö
Ö
I J
$num
Ö
Ö
J M
,
Ö
Ö
M N
$num
Ö
Ö
O R
,
Ö
Ö
R S
$num
Ö
Ö
T W
,
Ö
Ö
W X
$num
Ö
Ö
Y ]
)
Ö
Ö
] ^
}
Ö
Ö
_ `
,
Ö
Ö
` a
{
Ü
Ü
 
$str
Ü
Ü
 
,
Ü
Ü
 
CIELabFromRGB
Ü
Ü
< I
(
Ü
Ü
I J
$num
Ü
Ü
J N
,
Ü
Ü
N O
$num
Ü
Ü
P R
,
Ü
Ü
R S
$num
Ü
Ü
T W
,
Ü
Ü
W X
$num
Ü
Ü
Y ]
)
Ü
Ü
] ^
}
Ü
Ü
_ `
,
Ü
Ü
` a
{
á
á
 
$str
á
á
 
,
á
á
 
CIELabFromRGB
á
á
< I
(
á
á
I J
$num
á
á
J M
,
á
á
M N
$num
á
á
O R
,
á
á
R S
$num
á
á
T W
,
á
á
W X
$num
á
á
Y ]
)
á
á
] ^
}
á
á
_ `
,
á
á
` a
{
à
à
 
$str
à
à
 
,
à
à
 
CIELabFromRGB
à
à
< I
(
à
à
I J
$num
à
à
J M
,
à
à
M N
$num
à
à
O R
,
à
à
R S
$num
à
à
T W
,
à
à
W X
$num
à
à
Y ]
)
à
à
] ^
}
à
à
_ `
,
à
à
` a
{
â
â
 
$str
â
â
 
,
â
â
 
CIELabFromRGB
â
â
< I
(
â
â
I J
$num
â
â
J M
,
â
â
M N
$num
â
â
O R
,
â
â
R S
$num
â
â
T W
,
â
â
W X
$num
â
â
Y ]
)
â
â
] ^
}
â
â
_ `
,
â
â
` a
{
ä
ä
 
$str
ä
ä
 
,
ä
ä
 
CIELabFromRGB
ä
ä
< I
(
ä
ä
I J
$num
ä
ä
J M
,
ä
ä
M N
$num
ä
ä
O R
,
ä
ä
R S
$num
ä
ä
T W
,
ä
ä
W X
$num
ä
ä
Y ]
)
ä
ä
] ^
}
ä
ä
_ `
,
ä
ä
` a
{
ã
ã
 
$str
ã
ã
 
,
ã
ã
 
CIELabFromRGB
ã
ã
< I
(
ã
ã
I J
$num
ã
ã
J N
,
ã
ã
N O
$num
ã
ã
P S
,
ã
ã
S T
$num
ã
ã
U X
,
ã
ã
X Y
$num
ã
ã
Z ^
)
ã
ã
^ _
}
ã
ã
` a
,
ã
ã
a b
{
å
å
 
$str
å
å
 
,
å
å
 
CIELabFromRGB
å
å
< I
(
å
å
I J
$num
å
å
J M
,
å
å
M N
$num
å
å
O R
,
å
å
R S
$num
å
å
T W
,
å
å
W X
$num
å
å
Y ]
)
å
å
] ^
}
å
å
_ `
,
å
å
` a
{
ç
ç
 
$str
ç
ç
 
,
ç
ç
 
CIELabFromRGB
ç
ç
< I
(
ç
ç
I J
$num
ç
ç
J M
,
ç
ç
M N
$num
ç
ç
O R
,
ç
ç
R S
$num
ç
ç
T W
,
ç
ç
W X
$num
ç
ç
Y ]
)
ç
ç
] ^
}
ç
ç
_ `
,
ç
ç
` a
{
é
é
 
$str
é
é
 
,
é
é
 
CIELabFromRGB
é
é
< I
(
é
é
I J
$num
é
é
J M
,
é
é
M N
$num
é
é
O R
,
é
é
R S
$num
é
é
T W
,
é
é
W X
$num
é
é
Y ]
)
é
é
] ^
}
é
é
_ `
,
é
é
` a
{
è
è
 
$str
è
è
 
,
è
è
 
CIELabFromRGB
è
è
< I
(
è
è
I J
$num
è
è
J M
,
è
è
M N
$num
è
è
O R
,
è
è
R S
$num
è
è
T W
,
è
è
W X
$num
è
è
Y ]
)
è
è
] ^
}
è
è
_ `
,
è
è
` a
{
ê
ê
 
$str
ê
ê
 
,
ê
ê
 
CIELabFromRGB
ê
ê
< I
(
ê
ê
I J
$num
ê
ê
J M
,
ê
ê
M N
$num
ê
ê
O Q
,
ê
ê
Q R
$num
ê
ê
S U
,
ê
ê
U V
$num
ê
ê
W [
)
ê
ê
[ \
}
ê
ê
] ^
,
ê
ê
^ _
{
ë
ë
 
$str
ë
ë
 
,
ë
ë
 
CIELabFromRGB
ë
ë
< I
(
ë
ë
I J
$num
ë
ë
J M
,
ë
ë
M N
$num
ë
ë
O Q
,
ë
ë
Q R
$num
ë
ë
S U
,
ë
ë
U V
$num
ë
ë
W [
)
ë
ë
[ \
}
ë
ë
] ^
,
ë
ë
^ _
{
í
í
 
$str
í
í
 
,
í
í
 
CIELabFromRGB
í
í
< I
(
í
í
I J
$num
í
í
J M
,
í
í
M N
$num
í
í
O R
,
í
í
R S
$num
í
í
T W
,
í
í
W X
$num
í
í
Y ]
)
í
í
] ^
}
í
í
_ `
,
í
í
` a
{
ì
ì
 
$str
ì
ì
 
,
ì
ì
 
CIELabFromRGB
ì
ì
< I
(
ì
ì
I J
$num
ì
ì
J L
,
ì
ì
L M
$num
ì
ì
N Q
,
ì
ì
Q R
$num
ì
ì
S V
,
ì
ì
V W
$num
ì
ì
X \
)
ì
ì
\ ]
}
ì
ì
^ _
,
ì
ì
_ `
{
î
î
 
$str
î
î
 
,
î
î
 
CIELabFromRGB
î
î
< I
(
î
î
I J
$num
î
î
J L
,
î
î
L M
$num
î
î
N Q
,
î
î
Q R
$num
î
î
S V
,
î
î
V W
$num
î
î
X \
)
î
î
\ ]
}
î
î
^ _
,
î
î
_ `
{
ï
ï
 
$str
ï
ï
 
,
ï
ï
 
CIELabFromRGB
ï
ï
< I
(
ï
ï
I J
$num
ï
ï
J M
,
ï
ï
M N
$num
ï
ï
O R
,
ï
ï
R S
$num
ï
ï
T W
,
ï
ï
W X
$num
ï
ï
Y ]
)
ï
ï
] ^
}
ï
ï
_ `
,
ï
ï
` a
{
ñ
ñ
 
$str
ñ
ñ
 
,
ñ
ñ
 
CIELabFromRGB
ñ
ñ
< I
(
ñ
ñ
I J
$num
ñ
ñ
J M
,
ñ
ñ
M N
$num
ñ
ñ
O R
,
ñ
ñ
R S
$num
ñ
ñ
T W
,
ñ
ñ
W X
$num
ñ
ñ
Y ]
)
ñ
ñ
] ^
}
ñ
ñ
_ `
,
ñ
ñ
` a
{
ó
ó
 
$str
ó
ó
 
,
ó
ó
 
CIELabFromRGB
ó
ó
< I
(
ó
ó
I J
$num
ó
ó
J M
,
ó
ó
M N
$num
ó
ó
O R
,
ó
ó
R S
$num
ó
ó
T W
,
ó
ó
W X
$num
ó
ó
Y ]
)
ó
ó
] ^
}
ó
ó
_ `
,
ó
ó
` a
{
ò
ò
 
$str
ò
ò
 
,
ò
ò
 
CIELabFromRGB
ò
ò
< I
(
ò
ò
I J
$num
ò
ò
J M
,
ò
ò
M N
$num
ò
ò
O R
,
ò
ò
R S
$num
ò
ò
T W
,
ò
ò
W X
$num
ò
ò
Y ]
)
ò
ò
] ^
}
ò
ò
_ `
,
ò
ò
` a
{
ô
ô
 
$str
ô
ô
 
,
ô
ô
 
CIELabFromRGB
ô
ô
< I
(
ô
ô
I J
$num
ô
ô
J M
,
ô
ô
M N
$num
ô
ô
O R
,
ô
ô
R S
$num
ô
ô
T W
,
ô
ô
W X
$num
ô
ô
Y ]
)
ô
ô
] ^
}
ô
ô
_ `
,
ô
ô
` a
{
ö
ö
 
$str
ö
ö
 
,
ö
ö
 
CIELabFromRGB
ö
ö
< I
(
ö
ö
I J
$num
ö
ö
J M
,
ö
ö
M N
$num
ö
ö
O Q
,
ö
ö
Q R
$num
ö
ö
S V
,
ö
ö
V W
$num
ö
ö
X \
)
ö
ö
\ ]
}
ö
ö
^ _
,
ö
ö
_ `
{
õ
õ
 
$str
õ
õ
 
,
õ
õ
 
CIELabFromRGB
õ
õ
< I
(
õ
õ
I J
$num
õ
õ
J M
,
õ
õ
M N
$num
õ
õ
O Q
,
õ
õ
Q R
$num
õ
õ
S V
,
õ
õ
V W
$num
õ
õ
X \
)
õ
õ
\ ]
}
õ
õ
^ _
,
õ
õ
_ `
{
ú
ú
 
$str
ú
ú
 
,
ú
ú
 
CIELabFromRGB
ú
ú
< I
(
ú
ú
I J
$num
ú
ú
J M
,
ú
ú
M N
$num
ú
ú
O Q
,
ú
ú
Q R
$num
ú
ú
S V
,
ú
ú
V W
$num
ú
ú
X \
)
ú
ú
\ ]
}
ú
ú
^ _
,
ú
ú
_ `
{
ù
ù
 
$str
ù
ù
 
,
ù
ù
 
CIELabFromRGB
ù
ù
< I
(
ù
ù
I J
$num
ù
ù
J N
,
ù
ù
N O
$num
ù
ù
P R
,
ù
ù
R S
$num
ù
ù
T W
,
ù
ù
W X
$num
ù
ù
Y ]
)
ù
ù
] ^
}
ù
ù
_ `
,
ù
ù
` a
{
û
û
 
$str
û
û
 
,
û
û
 
CIELabFromRGB
û
û
< I
(
û
û
I J
$num
û
û
J M
,
û
û
M N
$num
û
û
O R
,
û
û
R S
$num
û
û
T W
,
û
û
W X
$num
û
û
Y ]
)
û
û
] ^
}
û
û
_ `
,
û
û
` a
{
ü
ü
 
$str
ü
ü
 
,
ü
ü
 
CIELabFromRGB
ü
ü
< I
(
ü
ü
I J
$num
ü
ü
J M
,
ü
ü
M N
$num
ü
ü
O R
,
ü
ü
R S
$num
ü
ü
T W
,
ü
ü
W X
$num
ü
ü
Y ]
)
ü
ü
] ^
}
ü
ü
_ `
,
ü
ü
` a
{
†
†
 
$str
†
†
 
,
†
†
 
CIELabFromRGB
†
†
< I
(
†
†
I J
$num
†
†
J M
,
†
†
M N
$num
†
†
O R
,
†
†
R S
$num
†
†
T V
,
†
†
V W
$num
†
†
X \
)
†
†
\ ]
}
†
†
^ _
,
†
†
_ `
{
°
°
 
$str
°
°
 
,
°
°
 
CIELabFromRGB
°
°
< I
(
°
°
I J
$num
°
°
J M
,
°
°
M N
$num
°
°
O R
,
°
°
R S
$num
°
°
T W
,
°
°
W X
$num
°
°
Y ]
)
°
°
] ^
}
°
°
_ `
,
°
°
` a
{
¢
¢
 
$str
¢
¢
 
,
¢
¢
 
CIELabFromRGB
¢
¢
< I
(
¢
¢
I J
$num
¢
¢
J M
,
¢
¢
M N
$num
¢
¢
O R
,
¢
¢
R S
$num
¢
¢
T W
,
¢
¢
W X
$num
¢
¢
Y ]
)
¢
¢
] ^
}
¢
¢
_ `
,
¢
¢
` a
{
£
£
 
$str
£
£
 
,
£
£
 
CIELabFromRGB
£
£
< I
(
£
£
I J
$num
£
£
J M
,
£
£
M N
$num
£
£
O Q
,
£
£
Q R
$num
£
£
S V
,
£
£
V W
$num
£
£
X \
)
£
£
\ ]
}
£
£
^ _
,
£
£
_ `
{
§
§
 
$str
§
§
 
,
§
§
 
CIELabFromRGB
§
§
< I
(
§
§
I J
$num
§
§
J M
,
§
§
M N
$num
§
§
O R
,
§
§
R S
$num
§
§
T V
,
§
§
V W
$num
§
§
X \
)
§
§
\ ]
}
§
§
^ _
,
§
§
_ `
{
•
•
 
$str
•
•
 
,
•
•
 
CIELabFromRGB
•
•
< I
(
•
•
I J
$num
•
•
J M
,
•
•
M N
$num
•
•
O R
,
•
•
R S
$num
•
•
T W
,
•
•
W X
$num
•
•
Y ]
)
•
•
] ^
}
•
•
_ `
,
•
•
` a
{
¶
¶
 
$str
¶
¶
 &
,
¶
¶
& '
CIELabFromRGB
¶
¶
< I
(
¶
¶
I J
$num
¶
¶
J L
,
¶
¶
L M
$num
¶
¶
N Q
,
¶
¶
Q R
$num
¶
¶
S V
,
¶
¶
V W
$num
¶
¶
X \
)
¶
¶
\ ]
}
¶
¶
^ _
,
¶
¶
_ `
{
ß
ß
 
$str
ß
ß
 
,
ß
ß
 
CIELabFromRGB
ß
ß
< I
(
ß
ß
I J
$num
ß
ß
J M
,
ß
ß
M N
$num
ß
ß
O R
,
ß
ß
R S
$num
ß
ß
T V
,
ß
ß
V W
$num
ß
ß
X \
)
ß
ß
\ ]
}
ß
ß
^ _
,
ß
ß
_ `
{
®
®
 
$str
®
®
 
,
®
®
 
CIELabFromRGB
®
®
< I
(
®
®
I J
$num
®
®
J N
,
®
®
N O
$num
®
®
P S
,
®
®
S T
$num
®
®
U W
,
®
®
W X
$num
®
®
Y ]
)
®
®
] ^
}
®
®
_ `
,
®
®
` a
{
©
©
 
$str
©
©
 ,
,
©
©
, -
CIELabFromRGB
©
©
< I
(
©
©
I J
$num
©
©
J N
,
©
©
N O
$num
©
©
P S
,
©
©
S T
$num
©
©
U W
,
©
©
W X
$num
©
©
Y ]
)
©
©
] ^
}
©
©
_ `
,
©
©
` a
{
™
™
 
$str
™
™
 
,
™
™
 
CIELabFromRGB
™
™
< I
(
™
™
I J
$num
™
™
J M
,
™
™
M N
$num
™
™
O R
,
™
™
R S
$num
™
™
T V
,
™
™
V W
$num
™
™
X \
)
™
™
\ ]
}
™
™
^ _
,
™
™
_ `
{
´
´
 
$str
´
´
 
,
´
´
 
CIELabFromRGB
´
´
< I
(
´
´
I J
$num
´
´
J M
,
´
´
M N
$num
´
´
O R
,
´
´
R S
$num
´
´
T W
,
´
´
W X
$num
´
´
Y ]
)
´
´
] ^
}
´
´
_ `
,
´
´
` a
{
¨
¨
 
$str
¨
¨
 
,
¨
¨
 
CIELabFromRGB
¨
¨
< I
(
¨
¨
I J
$num
¨
¨
J M
,
¨
¨
M N
$num
¨
¨
O R
,
¨
¨
R S
$num
¨
¨
T W
,
¨
¨
W X
$num
¨
¨
Y ]
)
¨
¨
] ^
}
¨
¨
_ `
,
¨
¨
` a
{
≠
≠
 
$str
≠
≠
 "
,
≠
≠
" #
CIELabFromRGB
≠
≠
< I
(
≠
≠
I J
$num
≠
≠
J M
,
≠
≠
M N
$num
≠
≠
O R
,
≠
≠
R S
$num
≠
≠
T W
,
≠
≠
W X
$num
≠
≠
Y ]
)
≠
≠
] ^
}
≠
≠
_ `
,
≠
≠
` a
{
Æ
Æ
 
$str
Æ
Æ
 
,
Æ
Æ
 
CIELabFromRGB
Æ
Æ
< I
(
Æ
Æ
I J
$num
Æ
Æ
J M
,
Æ
Æ
M N
$num
Æ
Æ
O R
,
Æ
Æ
R S
$num
Æ
Æ
T W
,
Æ
Æ
W X
$num
Æ
Æ
Y ]
)
Æ
Æ
] ^
}
Æ
Æ
_ `
,
Æ
Æ
` a
{
Ø
Ø
 
$str
Ø
Ø
 
,
Ø
Ø
 
CIELabFromRGB
Ø
Ø
< I
(
Ø
Ø
I J
$num
Ø
Ø
J N
,
Ø
Ø
N O
$num
Ø
Ø
P S
,
Ø
Ø
S T
$num
Ø
Ø
U X
,
Ø
Ø
X Y
$num
Ø
Ø
Z ^
)
Ø
Ø
^ _
}
Ø
Ø
` a
,
Ø
Ø
a b
{
∞
∞
 
$str
∞
∞
 
,
∞
∞
 
CIELabFromRGB
∞
∞
< I
(
∞
∞
I J
$num
∞
∞
J M
,
∞
∞
M N
$num
∞
∞
O R
,
∞
∞
R S
$num
∞
∞
T W
,
∞
∞
W X
$num
∞
∞
Y ]
)
∞
∞
] ^
}
∞
∞
_ `
,
∞
∞
` a
{
±
±
 
$str
±
±
 
,
±
±
 
CIELabFromRGB
±
±
< I
(
±
±
I J
$num
±
±
J M
,
±
±
M N
$num
±
±
O R
,
±
±
R S
$num
±
±
T V
,
±
±
V W
$num
±
±
X \
)
±
±
\ ]
}
±
±
^ _
,
±
±
_ `
{
≤
≤
 
$str
≤
≤
 
,
≤
≤
 
CIELabFromRGB
≤
≤
< I
(
≤
≤
I J
$num
≤
≤
J M
,
≤
≤
M N
$num
≤
≤
O R
,
≤
≤
R S
$num
≤
≤
T W
,
≤
≤
W X
$num
≤
≤
Y ]
)
≤
≤
] ^
}
≤
≤
_ `
,
≤
≤
` a
{
≥
≥
 
$str
≥
≥
 
,
≥
≥
 
CIELabFromRGB
≥
≥
< I
(
≥
≥
I J
$num
≥
≥
J M
,
≥
≥
M N
$num
≥
≥
O R
,
≥
≥
R S
$num
≥
≥
T W
,
≥
≥
W X
$num
≥
≥
Y ]
)
≥
≥
] ^
}
≥
≥
_ `
,
≥
≥
` a
{
¥
¥
 
$str
¥
¥
 
,
¥
¥
 
CIELabFromRGB
¥
¥
< I
(
¥
¥
I J
$num
¥
¥
J M
,
¥
¥
M N
$num
¥
¥
O R
,
¥
¥
R S
$num
¥
¥
T V
,
¥
¥
V W
$num
¥
¥
X \
)
¥
¥
\ ]
}
¥
¥
^ _
,
¥
¥
_ `
{
µ
µ
 
$str
µ
µ
 
,
µ
µ
 
CIELabFromRGB
µ
µ
< I
(
µ
µ
I J
$num
µ
µ
J M
,
µ
µ
M N
$num
µ
µ
O Q
,
µ
µ
Q R
$num
µ
µ
S U
,
µ
µ
U V
$num
µ
µ
W [
)
µ
µ
[ \
}
µ
µ
] ^
,
µ
µ
^ _
{
∂
∂
 
$str
∂
∂
 
,
∂
∂
 
CIELabFromRGB
∂
∂
< I
(
∂
∂
I J
$num
∂
∂
J M
,
∂
∂
M N
$num
∂
∂
O R
,
∂
∂
R S
$num
∂
∂
T W
,
∂
∂
W X
$num
∂
∂
Y ]
)
∂
∂
] ^
}
∂
∂
_ `
,
∂
∂
` a
{
∑
∑
 
$str
∑
∑
 
,
∑
∑
 
CIELabFromRGB
∑
∑
< I
(
∑
∑
I J
$num
∑
∑
J L
,
∑
∑
L M
$num
∑
∑
N Q
,
∑
∑
Q R
$num
∑
∑
S V
,
∑
∑
V W
$num
∑
∑
X \
)
∑
∑
\ ]
}
∑
∑
^ _
,
∑
∑
_ `
{
∏
∏
 
$str
∏
∏
 
,
∏
∏
 
CIELabFromRGB
∏
∏
< I
(
∏
∏
I J
$num
∏
∏
J L
,
∏
∏
L M
$num
∏
∏
N Q
,
∏
∏
Q R
$num
∏
∏
S V
,
∏
∏
V W
$num
∏
∏
X \
)
∏
∏
\ ]
}
∏
∏
^ _
,
∏
∏
_ `
{
π
π
 
$str
π
π
  
,
π
π
  !
CIELabFromRGB
π
π
< I
(
π
π
I J
$num
π
π
J M
,
π
π
M N
$num
π
π
O R
,
π
π
R S
$num
π
π
T W
,
π
π
W X
$num
π
π
Y ]
)
π
π
] ^
}
π
π
_ `
,
π
π
` a
{
∫
∫
 
$str
∫
∫
 
,
∫
∫
 
CIELabFromRGB
∫
∫
< I
(
∫
∫
I J
$num
∫
∫
J N
,
∫
∫
N O
$num
∫
∫
P S
,
∫
∫
S T
$num
∫
∫
U W
,
∫
∫
W X
$num
∫
∫
Y ]
)
∫
∫
] ^
}
∫
∫
_ `
,
∫
∫
` a
{
ª
ª
 
$str
ª
ª
 
,
ª
ª
 
CIELabFromRGB
ª
ª
< I
(
ª
ª
I J
$num
ª
ª
J M
,
ª
ª
M N
$num
ª
ª
O Q
,
ª
ª
Q R
$num
ª
ª
S V
,
ª
ª
V W
$num
ª
ª
X \
)
ª
ª
\ ]
}
ª
ª
^ _
,
ª
ª
_ `
{
º
º
 
$str
º
º
 
,
º
º
 
CIELabFromRGB
º
º
< I
(
º
º
I J
$num
º
º
J N
,
º
º
N O
$num
º
º
P S
,
º
º
S T
$num
º
º
U X
,
º
º
X Y
$num
º
º
Z ^
)
º
º
^ _
}
º
º
` a
,
º
º
a b
{
Ω
Ω
 
$str
Ω
Ω
 !
,
Ω
Ω
! "
CIELabFromRGB
Ω
Ω
< I
(
Ω
Ω
I J
$num
Ω
Ω
J N
,
Ω
Ω
N O
$num
Ω
Ω
P S
,
Ω
Ω
S T
$num
Ω
Ω
U W
,
Ω
Ω
W X
$num
Ω
Ω
Y ]
)
Ω
Ω
] ^
}
Ω
Ω
_ `
,
Ω
Ω
` a
{
æ
æ
 
$str
æ
æ
 
,
æ
æ
  
CIELabFromRGB
æ
æ
< I
(
æ
æ
I J
$num
æ
æ
J M
,
æ
æ
M N
$num
æ
æ
O S
,
æ
æ
S T
$num
æ
æ
U X
,
æ
æ
X Y
$num
æ
æ
Z ^
)
æ
æ
^ _
}
æ
æ
` a
,
æ
æ
a b
{
ø
ø
 
$str
ø
ø
 
,
ø
ø
 
CIELabFromRGB
ø
ø
< I
(
ø
ø
I J
$num
ø
ø
J L
,
ø
ø
L M
$num
ø
ø
N Q
,
ø
ø
Q R
$num
ø
ø
S V
,
ø
ø
V W
$num
ø
ø
X \
)
ø
ø
\ ]
}
ø
ø
^ _
,
ø
ø
_ `
{
¿
¿
 
$str
¿
¿
 
,
¿
¿
 
CIELabFromRGB
¿
¿
< I
(
¿
¿
I J
$num
¿
¿
J M
,
¿
¿
M N
$num
¿
¿
O R
,
¿
¿
R S
$num
¿
¿
T W
,
¿
¿
W X
$num
¿
¿
Y ]
)
¿
¿
] ^
}
¿
¿
_ `
,
¿
¿
` a
{
¡
¡
 
$str
¡
¡
 
,
¡
¡
 
CIELabFromRGB
¡
¡
< I
(
¡
¡
I J
$num
¡
¡
J M
,
¡
¡
M N
$num
¡
¡
O Q
,
¡
¡
Q R
$num
¡
¡
S U
,
¡
¡
U V
$num
¡
¡
W [
)
¡
¡
[ \
}
¡
¡
] ^
,
¡
¡
^ _
{
¬
¬
 
$str
¬
¬
 
,
¬
¬
 
CIELabFromRGB
¬
¬
< I
(
¬
¬
I J
$num
¬
¬
J N
,
¬
¬
N O
$num
¬
¬
P S
,
¬
¬
S T
$num
¬
¬
U X
,
¬
¬
X Y
$num
¬
¬
Z ^
)
¬
¬
^ _
}
¬
¬
` a
,
¬
¬
a b
{
√
√
 
$str
√
√
  
,
√
√
  !
CIELabFromRGB
√
√
< I
(
√
√
I J
$num
√
√
J N
,
√
√
N O
$num
√
√
P S
,
√
√
S T
$num
√
√
U W
,
√
√
W X
$num
√
√
Y ]
)
√
√
] ^
}
√
√
_ `
,
√
√
` a
{
ƒ
ƒ
 
$str
ƒ
ƒ
 
,
ƒ
ƒ
 
CIELabFromRGB
ƒ
ƒ
< I
(
ƒ
ƒ
I J
$num
ƒ
ƒ
J M
,
ƒ
ƒ
M N
$num
ƒ
ƒ
O R
,
ƒ
ƒ
R S
$num
ƒ
ƒ
T V
,
ƒ
ƒ
V W
$num
ƒ
ƒ
X \
)
ƒ
ƒ
\ ]
}
ƒ
ƒ
^ _
,
ƒ
ƒ
_ `
{
≈
≈
 
$str
≈
≈
 
,
≈
≈
 
CIELabFromRGB
≈
≈
< I
(
≈
≈
I J
$num
≈
≈
J M
,
≈
≈
M N
$num
≈
≈
O R
,
≈
≈
R S
$num
≈
≈
T W
,
≈
≈
W X
$num
≈
≈
Y ]
)
≈
≈
] ^
}
≈
≈
_ `
,
≈
≈
` a
{
∆
∆
 
$str
∆
∆
 
,
∆
∆
 
CIELabFromRGB
∆
∆
< I
(
∆
∆
I J
$num
∆
∆
J M
,
∆
∆
M N
$num
∆
∆
O R
,
∆
∆
R S
$num
∆
∆
T W
,
∆
∆
W X
$num
∆
∆
Y ]
)
∆
∆
] ^
}
∆
∆
_ `
,
∆
∆
` a
{
«
«
 
$str
«
«
 
,
«
«
 
CIELabFromRGB
«
«
< I
(
«
«
I J
$num
«
«
J N
,
«
«
N O
$num
«
«
P S
,
«
«
S T
$num
«
«
U X
,
«
«
X Y
$num
«
«
Z ^
)
«
«
^ _
}
«
«
` a
,
«
«
a b
{
»
»
 
$str
»
»
 
,
»
»
 
CIELabFromRGB
»
»
< I
(
»
»
I J
$num
»
»
J L
,
»
»
L M
$num
»
»
N Q
,
»
»
Q R
$num
»
»
S V
,
»
»
V W
$num
»
»
X \
)
»
»
\ ]
}
»
»
^ _
,
»
»
_ `
{
…
…
 
$str
…
…
 
,
…
…
 
CIELabFromRGB
…
…
< I
(
…
…
I J
$num
…
…
J M
,
…
…
M N
$num
…
…
O R
,
…
…
R S
$num
…
…
T V
,
…
…
V W
$num
…
…
X \
)
…
…
\ ]
}
…
…
^ _
,
…
…
_ `
{
 
 
 
$str
 
 
  
,
 
 
  !
CIELabFromRGB
 
 
< I
(
 
 
I J
$num
 
 
J M
,
 
 
M N
$num
 
 
O R
,
 
 
R S
$num
 
 
T W
,
 
 
W X
$num
 
 
Y ]
)
 
 
] ^
}
 
 
_ `
,
 
 
` a
{
À
À
 
$str
À
À
 
,
À
À
 
CIELabFromRGB
À
À
< I
(
À
À
I J
$num
À
À
J M
,
À
À
M N
$num
À
À
O Q
,
À
À
Q R
$num
À
À
S V
,
À
À
V W
$num
À
À
X \
)
À
À
\ ]
}
À
À
^ _
,
À
À
_ `
{
Ã
Ã
 
$str
Ã
Ã
 '
,
Ã
Ã
' (
CIELabFromRGB
Ã
Ã
< I
(
Ã
Ã
I J
$num
Ã
Ã
J N
,
Ã
Ã
N O
$num
Ã
Ã
P S
,
Ã
Ã
S T
$num
Ã
Ã
U Y
,
Ã
Ã
Y Z
$num
Ã
Ã
[ _
)
Ã
Ã
_ `
}
Ã
Ã
a b
,
Ã
Ã
b c
{
Õ
Õ
 
$str
Õ
Õ
 
,
Õ
Õ
 
CIELabFromRGB
Õ
Õ
< I
(
Õ
Õ
I J
$num
Õ
Õ
J M
,
Õ
Õ
M N
$num
Õ
Õ
O R
,
Õ
Õ
R S
$num
Õ
Õ
T V
,
Õ
Õ
V W
$num
Õ
Õ
X \
)
Õ
Õ
\ ]
}
Õ
Õ
^ _
,
Õ
Õ
_ `
{
Œ
Œ
 
$str
Œ
Œ
 
,
Œ
Œ
 
CIELabFromRGB
Œ
Œ
< I
(
Œ
Œ
I J
$num
Œ
Œ
J M
,
Œ
Œ
M N
$num
Œ
Œ
O R
,
Œ
Œ
R S
$num
Œ
Œ
T W
,
Œ
Œ
W X
$num
Œ
Œ
Y ]
)
Œ
Œ
] ^
}
Œ
Œ
_ `
,
Œ
Œ
` a
{
œ
œ
 
$str
œ
œ
 
,
œ
œ
 
CIELabFromRGB
œ
œ
< I
(
œ
œ
I J
$num
œ
œ
J M
,
œ
œ
M N
$num
œ
œ
O R
,
œ
œ
R S
$num
œ
œ
T W
,
œ
œ
W X
$num
œ
œ
Y ]
)
œ
œ
] ^
}
œ
œ
_ `
,
œ
œ
` a
{
–
–
 
$str
–
–
  
,
–
–
  !
CIELabFromRGB
–
–
< I
(
–
–
I J
$num
–
–
J M
,
–
–
M N
$num
–
–
O R
,
–
–
R S
$num
–
–
T W
,
–
–
W X
$num
–
–
Y ]
)
–
–
] ^
}
–
–
_ `
,
–
–
` a
{
—
—
 
$str
—
—
 
,
—
—
 
CIELabFromRGB
—
—
< I
(
—
—
I J
$num
—
—
J M
,
—
—
M N
$num
—
—
O R
,
—
—
R S
$num
—
—
T W
,
—
—
W X
$num
—
—
Y ]
)
—
—
] ^
}
—
—
_ `
,
—
—
` a
{
“
“
 
$str
“
“
 
,
“
“
 
CIELabFromRGB
“
“
< I
(
“
“
I J
$num
“
“
J M
,
“
“
M N
$num
“
“
O R
,
“
“
R S
$num
“
“
T W
,
“
“
W X
$num
“
“
Y ]
)
“
“
] ^
}
“
“
_ `
,
“
“
` a
{
”
”
 
$str
”
”
 
,
”
”
 
CIELabFromRGB
”
”
< I
(
”
”
I J
$num
”
”
J M
,
”
”
M N
$num
”
”
O R
,
”
”
R S
$num
”
”
T V
,
”
”
V W
$num
”
”
X \
)
”
”
\ ]
}
”
”
^ _
,
”
”
_ `
{
‘
‘
 
$str
‘
‘
 
,
‘
‘
 
CIELabFromRGB
‘
‘
< I
(
‘
‘
I J
$num
‘
‘
J L
,
‘
‘
L M
$num
‘
‘
N Q
,
‘
‘
Q R
$num
‘
‘
S V
,
‘
‘
V W
$num
‘
‘
X \
)
‘
‘
\ ]
}
‘
‘
^ _
,
‘
‘
_ `
{
’
’
 
$str
’
’
 
,
’
’
 
CIELabFromRGB
’
’
< I
(
’
’
I J
$num
’
’
J M
,
’
’
M N
$num
’
’
O R
,
’
’
R S
$num
’
’
T W
,
’
’
W X
$num
’
’
Y ]
)
’
’
] ^
}
’
’
_ `
,
’
’
` a
{
÷
÷
 
$str
÷
÷
 
,
÷
÷
 
CIELabFromRGB
÷
÷
< I
(
÷
÷
I J
$num
÷
÷
J M
,
÷
÷
M N
$num
÷
÷
O R
,
÷
÷
R S
$num
÷
÷
T W
,
÷
÷
W X
$num
÷
÷
Y ]
)
÷
÷
] ^
}
÷
÷
_ `
,
÷
÷
` a
{
◊
◊
 
$str
◊
◊
 
,
◊
◊
 
CIELabFromRGB
◊
◊
< I
(
◊
◊
I J
$num
◊
◊
J M
,
◊
◊
M N
$num
◊
◊
O R
,
◊
◊
R S
$num
◊
◊
T W
,
◊
◊
W X
$num
◊
◊
Y ]
)
◊
◊
] ^
}
◊
◊
_ `
,
◊
◊
` a
{
ÿ
ÿ
 
$str
ÿ
ÿ
 
,
ÿ
ÿ
 
CIELabFromRGB
ÿ
ÿ
< I
(
ÿ
ÿ
I J
$num
ÿ
ÿ
J M
,
ÿ
ÿ
M N
$num
ÿ
ÿ
O R
,
ÿ
ÿ
R S
$num
ÿ
ÿ
T W
,
ÿ
ÿ
W X
$num
ÿ
ÿ
Y ]
)
ÿ
ÿ
] ^
}
ÿ
ÿ
_ `
,
ÿ
ÿ
` a
{
Ÿ
Ÿ
 
$str
Ÿ
Ÿ
 (
,
Ÿ
Ÿ
( )
CIELabFromRGB
Ÿ
Ÿ
< I
(
Ÿ
Ÿ
I J
$num
Ÿ
Ÿ
J L
,
Ÿ
Ÿ
L M
$num
Ÿ
Ÿ
N Q
,
Ÿ
Ÿ
Q R
$num
Ÿ
Ÿ
S V
,
Ÿ
Ÿ
V W
$num
Ÿ
Ÿ
X \
)
Ÿ
Ÿ
\ ]
}
Ÿ
Ÿ
^ _
,
Ÿ
Ÿ
_ `
{
⁄
⁄
 
$str
⁄
⁄
 
,
⁄
⁄
 
CIELabFromRGB
⁄
⁄
< I
(
⁄
⁄
I J
$num
⁄
⁄
J M
,
⁄
⁄
M N
$num
⁄
⁄
O R
,
⁄
⁄
R S
$num
⁄
⁄
T W
,
⁄
⁄
W X
$num
⁄
⁄
Y ]
)
⁄
⁄
] ^
}
⁄
⁄
_ `
,
⁄
⁄
` a
{
€
€
 
$str
€
€
 
,
€
€
 
CIELabFromRGB
€
€
< I
(
€
€
I J
$num
€
€
J M
,
€
€
M N
$num
€
€
O R
,
€
€
R S
$num
€
€
T W
,
€
€
W X
$num
€
€
Y ]
)
€
€
] ^
}
€
€
_ `
,
€
€
` a
{
‹
‹
 
$str
‹
‹
 
,
‹
‹
 
CIELabFromRGB
‹
‹
< I
(
‹
‹
I J
$num
‹
‹
J L
,
‹
‹
L M
$num
‹
‹
N P
,
‹
‹
P Q
$num
‹
‹
R T
,
‹
‹
T U
$num
‹
‹
V Z
)
‹
‹
Z [
}
‹
‹
\ ]
,
‹
‹
] ^
{
›
›
 
$str
›
›
 
,
›
›
 
CIELabFromRGB
›
›
< I
(
›
›
I J
$num
›
›
J M
,
›
›
M N
$num
›
›
O R
,
›
›
R S
$num
›
›
T W
,
›
›
W X
$num
›
›
Y ]
)
›
›
] ^
}
›
›
_ `
,
›
›
` a
{
ﬁ
ﬁ
 
$str
ﬁ
ﬁ
 
,
ﬁ
ﬁ
 
CIELabFromRGB
ﬁ
ﬁ
< I
(
ﬁ
ﬁ
I J
$num
ﬁ
ﬁ
J N
,
ﬁ
ﬁ
N O
$num
ﬁ
ﬁ
P S
,
ﬁ
ﬁ
S T
$num
ﬁ
ﬁ
U X
,
ﬁ
ﬁ
X Y
$num
ﬁ
ﬁ
Z ^
)
ﬁ
ﬁ
^ _
}
ﬁ
ﬁ
` a
,
ﬁ
ﬁ
a b
{
ﬂ
ﬂ
 
$str
ﬂ
ﬂ
 
,
ﬂ
ﬂ
 
CIELabFromRGB
ﬂ
ﬂ
< I
(
ﬂ
ﬂ
I J
$num
ﬂ
ﬂ
J M
,
ﬂ
ﬂ
M N
$num
ﬂ
ﬂ
O R
,
ﬂ
ﬂ
R S
$num
ﬂ
ﬂ
T W
,
ﬂ
ﬂ
W X
$num
ﬂ
ﬂ
Y ]
)
ﬂ
ﬂ
] ^
}
ﬂ
ﬂ
_ `
,
ﬂ
ﬂ
` a
{
‡
‡
 
$str
‡
‡
 
,
‡
‡
 
CIELabFromRGB
‡
‡
< I
(
‡
‡
I J
$num
‡
‡
J M
,
‡
‡
M N
$num
‡
‡
O R
,
‡
‡
R S
$num
‡
‡
T W
,
‡
‡
W X
$num
‡
‡
Y ]
)
‡
‡
] ^
}
‡
‡
_ `
,
‡
‡
` a
{
·
·
 
$str
·
·
 
,
·
·
 
CIELabFromRGB
·
·
< I
(
·
·
I J
$num
·
·
J M
,
·
·
M N
$num
·
·
O R
,
·
·
R S
$num
·
·
T W
,
·
·
W X
$num
·
·
Y ]
)
·
·
] ^
}
·
·
_ `
,
·
·
` a
{
‚
‚
 
$str
‚
‚
 
,
‚
‚
  
CIELabFromRGB
‚
‚
< I
(
‚
‚
I J
$num
‚
‚
J M
,
‚
‚
M N
$num
‚
‚
O Q
,
‚
‚
Q R
$num
‚
‚
S U
,
‚
‚
U V
$num
‚
‚
W [
)
‚
‚
[ \
}
‚
‚
] ^
,
‚
‚
^ _
{
„
„
 
$str
„
„
 
,
„
„
 
CIELabFromRGB
„
„
< I
(
„
„
I J
$num
„
„
J M
,
„
„
M N
$num
„
„
O R
,
„
„
R S
$num
„
„
T W
,
„
„
W X
$num
„
„
Y ]
)
„
„
] ^
}
„
„
_ `
,
„
„
` a
{
‰
‰
 
$str
‰
‰
 
,
‰
‰
 
CIELabFromRGB
‰
‰
< I
(
‰
‰
I J
$num
‰
‰
J M
,
‰
‰
M N
$num
‰
‰
O R
,
‰
‰
R S
$num
‰
‰
T W
,
‰
‰
W X
$num
‰
‰
Y ]
)
‰
‰
] ^
}
‰
‰
_ `
,
‰
‰
` a
{
Â
Â
 
$str
Â
Â
 
,
Â
Â
 
CIELabFromRGB
Â
Â
< I
(
Â
Â
I J
$num
Â
Â
J L
,
Â
Â
L M
$num
Â
Â
N Q
,
Â
Â
Q R
$num
Â
Â
S V
,
Â
Â
V W
$num
Â
Â
X \
)
Â
Â
\ ]
}
Â
Â
^ _
,
Â
Â
_ `
{
Ê
Ê
 
$str
Ê
Ê
 
,
Ê
Ê
  
CIELabFromRGB
Ê
Ê
< I
(
Ê
Ê
I J
$num
Ê
Ê
J M
,
Ê
Ê
M N
$num
Ê
Ê
O Q
,
Ê
Ê
Q R
$num
Ê
Ê
S V
,
Ê
Ê
V W
$num
Ê
Ê
X \
)
Ê
Ê
\ ]
}
Ê
Ê
^ _
,
Ê
Ê
_ `
{
Á
Á
 
$str
Á
Á
 
,
Á
Á
  
CIELabFromRGB
Á
Á
< I
(
Á
Á
I J
$num
Á
Á
J M
,
Á
Á
M N
$num
Á
Á
O R
,
Á
Á
R S
$num
Á
Á
T W
,
Á
Á
W X
$num
Á
Á
Y ]
)
Á
Á
] ^
}
Á
Á
_ `
,
Á
Á
` a
{
Ë
Ë
 
$str
Ë
Ë
 
,
Ë
Ë
 
CIELabFromRGB
Ë
Ë
< I
(
Ë
Ë
I J
$num
Ë
Ë
J M
,
Ë
Ë
M N
$num
Ë
Ë
O R
,
Ë
Ë
R S
$num
Ë
Ë
T W
,
Ë
Ë
W X
$num
Ë
Ë
Y ]
)
Ë
Ë
] ^
}
Ë
Ë
_ `
,
Ë
Ë
` a
{
È
È
 
$str
È
È
 
,
È
È
 
CIELabFromRGB
È
È
< I
(
È
È
I J
$num
È
È
J L
,
È
È
L M
$num
È
È
N Q
,
È
È
Q R
$num
È
È
S V
,
È
È
V W
$num
È
È
X \
)
È
È
\ ]
}
È
È
^ _
,
È
È
_ `
{
Í
Í
 
$str
Í
Í
 
,
Í
Í
 
CIELabFromRGB
Í
Í
< I
(
Í
Í
I J
$num
Í
Í
J M
,
Í
Í
M N
$num
Í
Í
O R
,
Í
Í
R S
$num
Í
Í
T V
,
Í
Í
V W
$num
Í
Í
X \
)
Í
Í
\ ]
}
Í
Í
^ _
,
Í
Í
_ `
{
Î
Î
 
$str
Î
Î
 
,
Î
Î
 
CIELabFromRGB
Î
Î
< I
(
Î
Î
I J
$num
Î
Î
J M
,
Î
Î
M N
$num
Î
Î
O R
,
Î
Î
R S
$num
Î
Î
T W
,
Î
Î
W X
$num
Î
Î
Y ]
)
Î
Î
] ^
}
Î
Î
_ `
,
Î
Î
` a
{
Ï
Ï
 
$str
Ï
Ï
 
,
Ï
Ï
 
CIELabFromRGB
Ï
Ï
< I
(
Ï
Ï
I J
$num
Ï
Ï
J M
,
Ï
Ï
M N
$num
Ï
Ï
O Q
,
Ï
Ï
Q R
$num
Ï
Ï
S V
,
Ï
Ï
V W
$num
Ï
Ï
X \
)
Ï
Ï
\ ]
}
Ï
Ï
^ _
,
Ï
Ï
_ `
{
Ì
Ì
 
$str
Ì
Ì
  
,
Ì
Ì
  !
CIELabFromRGB
Ì
Ì
< I
(
Ì
Ì
I J
$num
Ì
Ì
J L
,
Ì
Ì
L M
$num
Ì
Ì
N R
,
Ì
Ì
R S
$num
Ì
Ì
T X
,
Ì
Ì
X Y
$num
Ì
Ì
Z ^
)
Ì
Ì
^ _
}
Ì
Ì
` a
,
Ì
Ì
a b
{
Ó
Ó
 
$str
Ó
Ó
 
,
Ó
Ó
 
CIELabFromRGB
Ó
Ó
< I
(
Ó
Ó
I J
$num
Ó
Ó
J M
,
Ó
Ó
M N
$num
Ó
Ó
O R
,
Ó
Ó
R S
$num
Ó
Ó
T W
,
Ó
Ó
W X
$num
Ó
Ó
Y ]
)
Ó
Ó
] ^
}
Ó
Ó
_ `
,
Ó
Ó
` a
{
Ô
Ô
 
$str
Ô
Ô
  
,
Ô
Ô
  !
CIELabFromRGB
Ô
Ô
< I
(
Ô
Ô
I J
$num
Ô
Ô
J L
,
Ô
Ô
L M
$num
Ô
Ô
N Q
,
Ô
Ô
Q R
$num
Ô
Ô
S V
,
Ô
Ô
V W
$num
Ô
Ô
X \
)
Ô
Ô
\ ]
}
Ô
Ô
^ _
,
Ô
Ô
_ `
{


 
$str


 
,


 
CIELabFromRGB


< I
(


I J
$num


J M
,


M N
$num


O R
,


R S
$num


T W
,


W X
$num


Y ]
)


] ^
}


_ `
,


` a
{
Ò
Ò
 
$str
Ò
Ò
  
,
Ò
Ò
  !
CIELabFromRGB
Ò
Ò
< I
(
Ò
Ò
I J
$num
Ò
Ò
J L
,
Ò
Ò
L M
$num
Ò
Ò
N Q
,
Ò
Ò
Q R
$num
Ò
Ò
S V
,
Ò
Ò
V W
$num
Ò
Ò
X \
)
Ò
Ò
\ ]
}
Ò
Ò
^ _
,
Ò
Ò
_ `
{
Ú
Ú
 
$str
Ú
Ú
 
,
Ú
Ú
 
CIELabFromRGB
Ú
Ú
< I
(
Ú
Ú
I J
$num
Ú
Ú
J M
,
Ú
Ú
M N
$num
Ú
Ú
O R
,
Ú
Ú
R S
$num
Ú
Ú
T V
,
Ú
Ú
V W
$num
Ú
Ú
X \
)
Ú
Ú
\ ]
}
Ú
Ú
^ _
,
Ú
Ú
_ `
{
Û
Û
 
$str
Û
Û
 
,
Û
Û
 
CIELabFromRGB
Û
Û
< I
(
Û
Û
I J
$num
Û
Û
J L
,
Û
Û
L M
$num
Û
Û
N R
,
Û
Û
R S
$num
Û
Û
T W
,
Û
Û
W X
$num
Û
Û
Y ]
)
Û
Û
] ^
}
Û
Û
_ `
,
Û
Û
` a
{
Ù
Ù
 
$str
Ù
Ù
 !
,
Ù
Ù
! "
CIELabFromRGB
Ù
Ù
< I
(
Ù
Ù
I J
$num
Ù
Ù
J L
,
Ù
Ù
L M
$num
Ù
Ù
N Q
,
Ù
Ù
Q R
$num
Ù
Ù
S V
,
Ù
Ù
V W
$num
Ù
Ù
X \
)
Ù
Ù
\ ]
}
Ù
Ù
^ _
,
Ù
Ù
_ `
{
ı
ı
 
$str
ı
ı
 
,
ı
ı
 
CIELabFromRGB
ı
ı
< I
(
ı
ı
I J
$num
ı
ı
J M
,
ı
ı
M N
$num
ı
ı
O R
,
ı
ı
R S
$num
ı
ı
T W
,
ı
ı
W X
$num
ı
ı
Y ]
)
ı
ı
] ^
}
ı
ı
_ `
,
ı
ı
` a
{
ˆ
ˆ
 
$str
ˆ
ˆ
 
,
ˆ
ˆ
 
CIELabFromRGB
ˆ
ˆ
< I
(
ˆ
ˆ
I J
$num
ˆ
ˆ
J M
,
ˆ
ˆ
M N
$num
ˆ
ˆ
O R
,
ˆ
ˆ
R S
$num
ˆ
ˆ
T W
,
ˆ
ˆ
W X
$num
ˆ
ˆ
Y ]
)
ˆ
ˆ
] ^
}
ˆ
ˆ
_ `
,
ˆ
ˆ
` a
{
˜
˜
 
$str
˜
˜
 $
,
˜
˜
$ %
CIELabFromRGB
˜
˜
< I
(
˜
˜
I J
$num
˜
˜
J M
,
˜
˜
M N
$num
˜
˜
O R
,
˜
˜
R S
$num
˜
˜
T W
,
˜
˜
W X
$num
˜
˜
Y ]
)
˜
˜
] ^
}
˜
˜
_ `
,
˜
˜
` a
{
¯
¯
 
$str
¯
¯
 
,
¯
¯
 
CIELabFromRGB
¯
¯
< I
(
¯
¯
I J
$num
¯
¯
J M
,
¯
¯
M N
$num
¯
¯
O Q
,
¯
¯
Q R
$num
¯
¯
S U
,
¯
¯
U V
$num
¯
¯
W [
)
¯
¯
[ \
}
¯
¯
] ^
,
¯
¯
^ _
{
˘
˘
 
$str
˘
˘
 
,
˘
˘
 
CIELabFromRGB
˘
˘
< I
(
˘
˘
I J
$num
˘
˘
J M
,
˘
˘
M N
$num
˘
˘
O R
,
˘
˘
R S
$num
˘
˘
T W
,
˘
˘
W X
$num
˘
˘
Y ]
)
˘
˘
] ^
}
˘
˘
_ `
,
˘
˘
` a
{
˙
˙
 
$str
˙
˙
 
,
˙
˙
 
CIELabFromRGB
˙
˙
< I
(
˙
˙
I J
$num
˙
˙
J M
,
˙
˙
M N
$num
˙
˙
O R
,
˙
˙
R S
$num
˙
˙
T W
,
˙
˙
W X
$num
˙
˙
Y ]
)
˙
˙
] ^
}
˙
˙
_ `
,
˙
˙
` a
{
˚
˚
 
$str
˚
˚
 
,
˚
˚
 
CIELabFromRGB
˚
˚
< I
(
˚
˚
I J
$num
˚
˚
J M
,
˚
˚
M N
$num
˚
˚
O R
,
˚
˚
R S
$num
˚
˚
T W
,
˚
˚
W X
$num
˚
˚
Y ]
)
˚
˚
] ^
}
˚
˚
_ `
,
˚
˚
` a
{
¸
¸
 
$str
¸
¸
 
,
¸
¸
 
CIELabFromRGB
¸
¸
< I
(
¸
¸
I J
$num
¸
¸
J M
,
¸
¸
M N
$num
¸
¸
O R
,
¸
¸
R S
$num
¸
¸
T W
,
¸
¸
W X
$num
¸
¸
Y ]
)
¸
¸
] ^
}
¸
¸
_ `
,
¸
¸
` a
{
˝
˝
 
$str
˝
˝
 
,
˝
˝
 
CIELabFromRGB
˝
˝
< I
(
˝
˝
I J
$num
˝
˝
J N
,
˝
˝
N O
$num
˝
˝
P S
,
˝
˝
S T
$num
˝
˝
U X
,
˝
˝
X Y
$num
˝
˝
Z ^
)
˝
˝
^ _
}
˝
˝
` a
,
˝
˝
a b
{
˛
˛
 
$str
˛
˛
 
,
˛
˛
 
CIELabFromRGB
˛
˛
< I
(
˛
˛
I J
$num
˛
˛
J M
,
˛
˛
M N
$num
˛
˛
O R
,
˛
˛
R S
$num
˛
˛
T W
,
˛
˛
W X
$num
˛
˛
Y ]
)
˛
˛
] ^
}
˛
˛
_ `
,
˛
˛
` a
{
ˇ
ˇ
 
$str
ˇ
ˇ
 
,
ˇ
ˇ
 
CIELabFromRGB
ˇ
ˇ
< I
(
ˇ
ˇ
I J
$num
ˇ
ˇ
J M
,
ˇ
ˇ
M N
$num
ˇ
ˇ
O R
,
ˇ
ˇ
R S
$num
ˇ
ˇ
T W
,
ˇ
ˇ
W X
$num
ˇ
ˇ
Y ]
)
ˇ
ˇ
] ^
}
ˇ
ˇ
_ `
,
ˇ
ˇ
` a
{
ÄÄ 
$str
ÄÄ 
,
ÄÄ 
CIELabFromRGB
ÄÄ< I
(
ÄÄI J
$num
ÄÄJ M
,
ÄÄM N
$num
ÄÄO R
,
ÄÄR S
$num
ÄÄT W
,
ÄÄW X
$num
ÄÄY ]
)
ÄÄ] ^
}
ÄÄ_ `
,
ÄÄ` a
{
ÅÅ 
$str
ÅÅ 
,
ÅÅ 
CIELabFromRGB
ÅÅ< I
(
ÅÅI J
$num
ÅÅJ M
,
ÅÅM N
$num
ÅÅO R
,
ÅÅR S
$num
ÅÅT W
,
ÅÅW X
$num
ÅÅY ]
)
ÅÅ] ^
}
ÅÅ_ `
,
ÅÅ` a
{
ÇÇ 
$str
ÇÇ 
,
ÇÇ 
CIELabFromRGB
ÇÇ< I
(
ÇÇI J
$num
ÇÇJ M
,
ÇÇM N
$num
ÇÇO R
,
ÇÇR S
$num
ÇÇT W
,
ÇÇW X
$num
ÇÇY ]
)
ÇÇ] ^
}
ÇÇ_ `
,
ÇÇ` a
{
ÉÉ 
$str
ÉÉ 
,
ÉÉ 
CIELabFromRGB
ÉÉ< I
(
ÉÉI J
$num
ÉÉJ M
,
ÉÉM N
$num
ÉÉO R
,
ÉÉR S
$num
ÉÉT V
,
ÉÉV W
$num
ÉÉX \
)
ÉÉ\ ]
}
ÉÉ^ _
,
ÉÉ_ `
{
ÑÑ 
$str
ÑÑ 
,
ÑÑ 
CIELabFromRGB
ÑÑ< I
(
ÑÑI J
$num
ÑÑJ M
,
ÑÑM N
$num
ÑÑO R
,
ÑÑR S
$num
ÑÑT V
,
ÑÑV W
$num
ÑÑX \
)
ÑÑ\ ]
}
ÑÑ^ _
,
ÑÑ_ `
{
ÖÖ 
$str
ÖÖ  
,
ÖÖ  !
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ N
,
ÖÖN O
$num
ÖÖP S
,
ÖÖS T
$num
ÖÖU W
,
ÖÖW X
$num
ÖÖY ]
)
ÖÖ] ^
}
ÖÖ_ `
,
ÖÖ` a
{
ÜÜ 
$str
ÜÜ 
,
ÜÜ 
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ M
,
ÜÜM N
$num
ÜÜO R
,
ÜÜR S
$num
ÜÜT W
,
ÜÜW X
$num
ÜÜY ]
)
ÜÜ] ^
}
ÜÜ_ `
,
ÜÜ` a
{
áá 
$str
áá 
,
áá 
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ M
,
ááM N
$num
ááO R
,
ááR S
$num
ááT W
,
ááW X
$num
ááY ]
)
áá] ^
}
áá_ `
,
áá` a
{
àà 
$str
àà 
,
àà 
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ M
,
ààM N
$num
ààO R
,
ààR S
$num
ààT W
,
ààW X
$num
ààY ]
)
àà] ^
}
àà_ `
,
àà` a
{
ââ 
$str
ââ 
,
ââ 
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ M
,
ââM N
$num
ââO R
,
ââR S
$num
ââT W
,
ââW X
$num
ââY ]
)
ââ] ^
}
ââ_ `
,
ââ` a
{
ää 
$str
ää 
,
ää 
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ M
,
ääM N
$num
ääO R
,
ääR S
$num
ääT W
,
ääW X
$num
ääY ]
)
ää] ^
}
ää_ `
,
ää` a
{
ãã 
$str
ãã 
,
ãã 
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ M
,
ããM N
$num
ããO R
,
ããR S
$num
ããT W
,
ããW X
$num
ããY ]
)
ãã] ^
}
ãã_ `
,
ãã` a
{
åå 
$str
åå 
,
åå 
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ L
,
ååL M
$num
ååN Q
,
ååQ R
$num
ååS V
,
ååV W
$num
ååX \
)
åå\ ]
}
åå^ _
,
åå_ `
{
çç 
$str
çç 
,
çç 
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ M
,
ççM N
$num
ççO R
,
ççR S
$num
ççT W
,
ççW X
$num
ççY ]
)
çç] ^
}
çç_ `
,
çç` a
{
éé 
$str
éé 
,
éé 
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ M
,
ééM N
$num
ééO R
,
ééR S
$num
ééT W
,
ééW X
$num
ééY ]
)
éé] ^
}
éé_ `
,
éé` a
{
èè 
$str
èè 
,
èè 
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ L
,
èèL M
$num
èèN Q
,
èèQ R
$num
èèS V
,
èèV W
$num
èèX \
)
èè\ ]
}
èè^ _
,
èè_ `
{
êê 
$str
êê 
,
êê 
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ M
,
êêM N
$num
êêO R
,
êêR S
$num
êêT W
,
êêW X
$num
êêY ]
)
êê] ^
}
êê_ `
,
êê` a
{
ëë 
$str
ëë 
,
ëë 
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ M
,
ëëM N
$num
ëëO R
,
ëëR S
$num
ëëT V
,
ëëV W
$num
ëëX \
)
ëë\ ]
}
ëë^ _
,
ëë_ `
{
íí 
$str
íí 
,
íí 
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ M
,
ííM N
$num
ííO R
,
ííR S
$num
ííT W
,
ííW X
$num
ííY ]
)
íí] ^
}
íí_ `
,
íí` a
{
ìì 
$str
ìì 
,
ìì 
CIELabFromRGB
ìì< I
(
ììI J
$num
ììJ M
,
ììM N
$num
ììO R
,
ììR S
$num
ììT W
,
ììW X
$num
ììY ]
)
ìì] ^
}
ìì_ `
,
ìì` a
{
îî 
$str
îî 
,
îî 
CIELabFromRGB
îî< I
(
îîI J
$num
îîJ M
,
îîM N
$num
îîO R
,
îîR S
$num
îîT W
,
îîW X
$num
îîY ]
)
îî] ^
}
îî_ `
,
îî` a
{
ïï 
$str
ïï 
,
ïï 
CIELabFromRGB
ïï< I
(
ïïI J
$num
ïïJ L
,
ïïL M
$num
ïïN Q
,
ïïQ R
$num
ïïS V
,
ïïV W
$num
ïïX \
)
ïï\ ]
}
ïï^ _
,
ïï_ `
{
ññ 
$str
ññ 
,
ññ 
CIELabFromRGB
ññ< I
(
ññI J
$num
ññJ M
,
ññM N
$num
ññO R
,
ññR S
$num
ññT W
,
ññW X
$num
ññY ]
)
ññ] ^
}
ññ_ `
,
ññ` a
{
óó 
$str
óó 
,
óó 
CIELabFromRGB
óó< I
(
óóI J
$num
óóJ M
,
óóM N
$num
óóO R
,
óóR S
$num
óóT W
,
óóW X
$num
óóY ]
)
óó] ^
}
óó_ `
,
óó` a
{
òò 
$str
òò 
,
òò  
CIELabFromRGB
òò< I
(
òòI J
$num
òòJ M
,
òòM N
$num
òòO R
,
òòR S
$num
òòT V
,
òòV W
$num
òòX \
)
òò\ ]
}
òò^ _
,
òò_ `
{
ôô 
$str
ôô 
,
ôô 
CIELabFromRGB
ôô< I
(
ôôI J
$num
ôôJ N
,
ôôN O
$num
ôôP S
,
ôôS T
$num
ôôU X
,
ôôX Y
$num
ôôZ ^
)
ôô^ _
}
ôô` a
,
ôôa b
{
öö 
$str
öö 
,
öö 
CIELabFromRGB
öö< I
(
ööI J
$num
ööJ M
,
ööM N
$num
ööO R
,
ööR S
$num
ööT W
,
ööW X
$num
ööY ]
)
öö] ^
}
öö_ `
,
öö` a
{
õõ 
$str
õõ 
,
õõ 
CIELabFromRGB
õõ< I
(
õõI J
$num
õõJ N
,
õõN O
$num
õõP S
,
õõS T
$num
õõU X
,
õõX Y
$num
õõZ ^
)
õõ^ _
}
õõ` a
,
õõa b
{
úú 
$str
úú 
,
úú 
CIELabFromRGB
úú< I
(
úúI J
$num
úúJ M
,
úúM N
$num
úúO Q
,
úúQ R
$num
úúS V
,
úúV W
$num
úúX \
)
úú\ ]
}
úú^ _
,
úú_ `
{
ùù 
$str
ùù 
,
ùù 
CIELabFromRGB
ùù< I
(
ùùI J
$num
ùùJ M
,
ùùM N
$num
ùùO R
,
ùùR S
$num
ùùT W
,
ùùW X
$num
ùùY ]
)
ùù] ^
}
ùù_ `
,
ùù` a
{
ûû 
$str
ûû $
,
ûû$ %
CIELabFromRGB
ûû< I
(
ûûI J
$num
ûûJ L
,
ûûL M
$num
ûûN Q
,
ûûQ R
$num
ûûS V
,
ûûV W
$num
ûûX \
)
ûû\ ]
}
ûû^ _
,
ûû_ `
{
üü 
$str
üü 
,
üü 
CIELabFromRGB
üü< I
(
üüI J
$num
üüJ L
,
üüL M
$num
üüN Q
,
üüQ R
$num
üüS V
,
üüV W
$num
üüX \
)
üü\ ]
}
üü^ _
,
üü_ `
{
†† 
$str
†† 
,
†† 
CIELabFromRGB
††< I
(
††I J
$num
††J M
,
††M N
$num
††O R
,
††R S
$num
††T W
,
††W X
$num
††Y ]
)
††] ^
}
††_ `
,
††` a
{
°° 
$str
°° 
,
°° 
CIELabFromRGB
°°< I
(
°°I J
$num
°°J N
,
°°N O
$num
°°P S
,
°°S T
$num
°°U X
,
°°X Y
$num
°°Z ^
)
°°^ _
}
°°` a
,
°°a b
{
¢¢ 
$str
¢¢ 
,
¢¢ 
CIELabFromRGB
¢¢< I
(
¢¢I J
$num
¢¢J M
,
¢¢M N
$num
¢¢O R
,
¢¢R S
$num
¢¢T W
,
¢¢W X
$num
¢¢Y ]
)
¢¢] ^
}
¢¢_ `
,
¢¢` a
{
££ 
$str
££ 
,
££ 
CIELabFromRGB
££< I
(
££I J
$num
££J M
,
££M N
$num
££O R
,
££R S
$num
££T W
,
££W X
$num
££Y ]
)
££] ^
}
££_ `
,
££` a
{
§§ 
$str
§§ 
,
§§ 
CIELabFromRGB
§§< I
(
§§I J
$num
§§J M
,
§§M N
$num
§§O R
,
§§R S
$num
§§T W
,
§§W X
$num
§§Y ]
)
§§] ^
}
§§_ `
,
§§` a
{
•• 
$str
•• 
,
•• 
CIELabFromRGB
••< I
(
••I J
$num
••J L
,
••L M
$num
••N R
,
••R S
$num
••T W
,
••W X
$num
••Y ]
)
••] ^
}
••_ `
,
••` a
{
¶¶ 
$str
¶¶ 
,
¶¶  
CIELabFromRGB
¶¶< I
(
¶¶I J
$num
¶¶J M
,
¶¶M N
$num
¶¶O R
,
¶¶R S
$num
¶¶T W
,
¶¶W X
$num
¶¶Y ]
)
¶¶] ^
}
¶¶_ `
,
¶¶` a
{
ßß 
$str
ßß 
,
ßß 
CIELabFromRGB
ßß< I
(
ßßI J
$num
ßßJ M
,
ßßM N
$num
ßßO R
,
ßßR S
$num
ßßT W
,
ßßW X
$num
ßßY ]
)
ßß] ^
}
ßß_ `
,
ßß` a
{
®® 
$str
®® 
,
®® 
CIELabFromRGB
®®< I
(
®®I J
$num
®®J M
,
®®M N
$num
®®O R
,
®®R S
$num
®®T W
,
®®W X
$num
®®Y ]
)
®®] ^
}
®®_ `
,
®®` a
{
©© 
$str
©© 
,
©© 
CIELabFromRGB
©©< I
(
©©I J
$num
©©J M
,
©©M N
$num
©©O R
,
©©R S
$num
©©T W
,
©©W X
$num
©©Y ]
)
©©] ^
}
©©_ `
,
©©` a
{
™™ 
$str
™™ 
,
™™ 
CIELabFromRGB
™™< I
(
™™I J
$num
™™J M
,
™™M N
$num
™™O R
,
™™R S
$num
™™T W
,
™™W X
$num
™™Y ]
)
™™] ^
}
™™_ `
,
™™` a
{
´´ 
$str
´´ 
,
´´ 
CIELabFromRGB
´´< I
(
´´I J
$num
´´J M
,
´´M N
$num
´´O R
,
´´R S
$num
´´T W
,
´´W X
$num
´´Y ]
)
´´] ^
}
´´_ `
,
´´` a
{
¨¨ 
$str
¨¨ !
,
¨¨! "
CIELabFromRGB
¨¨< I
(
¨¨I J
$num
¨¨J M
,
¨¨M N
$num
¨¨O R
,
¨¨R S
$num
¨¨T W
,
¨¨W X
$num
¨¨Y ]
)
¨¨] ^
}
¨¨_ `
,
¨¨` a
{
≠≠ 
$str
≠≠ 
,
≠≠ 
CIELabFromRGB
≠≠< I
(
≠≠I J
$num
≠≠J M
,
≠≠M N
$num
≠≠O Q
,
≠≠Q R
$num
≠≠S V
,
≠≠V W
$num
≠≠X \
)
≠≠\ ]
}
≠≠^ _
,
≠≠_ `
{
ÆÆ 
$str
ÆÆ 
,
ÆÆ 
CIELabFromRGB
ÆÆ< I
(
ÆÆI J
$num
ÆÆJ L
,
ÆÆL M
$num
ÆÆN Q
,
ÆÆQ R
$num
ÆÆS V
,
ÆÆV W
$num
ÆÆX \
)
ÆÆ\ ]
}
ÆÆ^ _
,
ÆÆ_ `
{
ØØ 
$str
ØØ 
,
ØØ 
CIELabFromRGB
ØØ< I
(
ØØI J
$num
ØØJ M
,
ØØM N
$num
ØØO Q
,
ØØQ R
$num
ØØS V
,
ØØV W
$num
ØØX \
)
ØØ\ ]
}
ØØ^ _
,
ØØ_ `
{
∞∞ 
$str
∞∞ 
,
∞∞ 
CIELabFromRGB
∞∞< I
(
∞∞I J
$num
∞∞J M
,
∞∞M N
$num
∞∞O R
,
∞∞R S
$num
∞∞T W
,
∞∞W X
$num
∞∞Y ]
)
∞∞] ^
}
∞∞_ `
,
∞∞` a
{
±± 
$str
±± 
,
±± 
CIELabFromRGB
±±< I
(
±±I J
$num
±±J M
,
±±M N
$num
±±O R
,
±±R S
$num
±±T W
,
±±W X
$num
±±Y ]
)
±±] ^
}
±±_ `
,
±±` a
{
≤≤ 
$str
≤≤ 
,
≤≤ 
CIELabFromRGB
≤≤< I
(
≤≤I J
$num
≤≤J N
,
≤≤N O
$num
≤≤P S
,
≤≤S T
$num
≤≤U W
,
≤≤W X
$num
≤≤Y ]
)
≤≤] ^
}
≤≤_ `
,
≤≤` a
{
≥≥ 
$str
≥≥ 
,
≥≥ 
CIELabFromRGB
≥≥< I
(
≥≥I J
$num
≥≥J M
,
≥≥M N
$num
≥≥O R
,
≥≥R S
$num
≥≥T W
,
≥≥W X
$num
≥≥Y ]
)
≥≥] ^
}
≥≥_ `
,
≥≥` a
{
¥¥ 
$str
¥¥ 
,
¥¥ 
CIELabFromRGB
¥¥< I
(
¥¥I J
$num
¥¥J L
,
¥¥L M
$num
¥¥N P
,
¥¥P Q
$num
¥¥R U
,
¥¥U V
$num
¥¥W [
)
¥¥[ \
}
¥¥] ^
,
¥¥^ _
{
µµ 
$str
µµ  
,
µµ  !
CIELabFromRGB
µµ< I
(
µµI J
$num
µµJ M
,
µµM N
$num
µµO R
,
µµR S
$num
µµT W
,
µµW X
$num
µµY ]
)
µµ] ^
}
µµ_ `
,
µµ` a
{
∂∂ 
$str
∂∂ 
,
∂∂ 
CIELabFromRGB
∂∂< I
(
∂∂I J
$num
∂∂J N
,
∂∂N O
$num
∂∂P S
,
∂∂S T
$num
∂∂U Y
,
∂∂Y Z
$num
∂∂[ _
)
∂∂_ `
}
∂∂a b
,
∂∂b c
{
∑∑ 
$str
∑∑ 
,
∑∑ 
CIELabFromRGB
∑∑< I
(
∑∑I J
$num
∑∑J M
,
∑∑M N
$num
∑∑O R
,
∑∑R S
$num
∑∑T W
,
∑∑W X
$num
∑∑Y ]
)
∑∑] ^
}
∑∑_ `
,
∑∑` a
{
∏∏ 
$str
∏∏ 
,
∏∏ 
CIELabFromRGB
∏∏< I
(
∏∏I J
$num
∏∏J M
,
∏∏M N
$num
∏∏O R
,
∏∏R S
$num
∏∏T W
,
∏∏W X
$num
∏∏Y ]
)
∏∏] ^
}
∏∏_ `
,
∏∏` a
{
ππ 
$str
ππ 
,
ππ  
CIELabFromRGB
ππ< I
(
ππI J
$num
ππJ N
,
ππN O
$num
ππP S
,
ππS T
$num
ππU X
,
ππX Y
$num
ππZ ^
)
ππ^ _
}
ππ` a
,
ππa b
{
∫∫ 
$str
∫∫ #
,
∫∫# $
CIELabFromRGB
∫∫< I
(
∫∫I J
$num
∫∫J M
,
∫∫M N
$num
∫∫O R
,
∫∫R S
$num
∫∫T W
,
∫∫W X
$num
∫∫Y ]
)
∫∫] ^
}
∫∫_ `
,
∫∫` a
{
ªª 
$str
ªª -
,
ªª- .
CIELabFromRGB
ªª< I
(
ªªI J
$num
ªªJ M
,
ªªM N
$num
ªªO R
,
ªªR S
$num
ªªT W
,
ªªW X
$num
ªªY ]
)
ªª] ^
}
ªª_ `
,
ªª` a
{
ºº 
$str
ºº 
,
ºº  
CIELabFromRGB
ºº< I
(
ººI J
$num
ººJ N
,
ººN O
$num
ººP T
,
ººT U
$num
ººV Y
,
ººY Z
$num
ºº[ _
)
ºº_ `
}
ººa b
,
ººb c
{
ΩΩ 
$str
ΩΩ 
,
ΩΩ  
CIELabFromRGB
ΩΩ< I
(
ΩΩI J
$num
ΩΩJ L
,
ΩΩL M
$num
ΩΩN Q
,
ΩΩQ R
$num
ΩΩS V
,
ΩΩV W
$num
ΩΩX \
)
ΩΩ\ ]
}
ΩΩ^ _
,
ΩΩ_ `
{
ææ 
$str
ææ 
,
ææ 
CIELabFromRGB
ææ< I
(
ææI J
$num
ææJ M
,
ææM N
$num
ææO Q
,
ææQ R
$num
ææS U
,
ææU V
$num
ææW [
)
ææ[ \
}
ææ] ^
,
ææ^ _
{
øø 
$str
øø 
,
øø 
CIELabFromRGB
øø< I
(
øøI J
$num
øøJ M
,
øøM N
$num
øøO R
,
øøR S
$num
øøT W
,
øøW X
$num
øøY ]
)
øø] ^
}
øø_ `
,
øø` a
{
¿¿ 
$str
¿¿ 
,
¿¿ 
CIELabFromRGB
¿¿< I
(
¿¿I J
$num
¿¿J M
,
¿¿M N
$num
¿¿O R
,
¿¿R S
$num
¿¿T W
,
¿¿W X
$num
¿¿Y ]
)
¿¿] ^
}
¿¿_ `
,
¿¿` a
{
¡¡ 
$str
¡¡ 
,
¡¡ 
CIELabFromRGB
¡¡< I
(
¡¡I J
$num
¡¡J L
,
¡¡L M
$num
¡¡N Q
,
¡¡Q R
$num
¡¡S V
,
¡¡V W
$num
¡¡X \
)
¡¡\ ]
}
¡¡^ _
,
¡¡_ `
{
¬¬ 
$str
¬¬ 
,
¬¬ 
CIELabFromRGB
¬¬< I
(
¬¬I J
$num
¬¬J M
,
¬¬M N
$num
¬¬O Q
,
¬¬Q R
$num
¬¬S U
,
¬¬U V
$num
¬¬W [
)
¬¬[ \
}
¬¬] ^
,
¬¬^ _
{
√√ 
$str
√√ 
,
√√ 
CIELabFromRGB
√√< I
(
√√I J
$num
√√J N
,
√√N O
$num
√√P S
,
√√S T
$num
√√U W
,
√√W X
$num
√√Y ]
)
√√] ^
}
√√_ `
,
√√` a
{
ƒƒ 
$str
ƒƒ .
,
ƒƒ. /
CIELabFromRGB
ƒƒ< I
(
ƒƒI J
$num
ƒƒJ M
,
ƒƒM N
$num
ƒƒO R
,
ƒƒR S
$num
ƒƒT V
,
ƒƒV W
$num
ƒƒX \
)
ƒƒ\ ]
}
ƒƒ^ _
,
ƒƒ_ `
{
≈≈ 
$str
≈≈ 
,
≈≈ 
CIELabFromRGB
≈≈< I
(
≈≈I J
$num
≈≈J M
,
≈≈M N
$num
≈≈O Q
,
≈≈Q R
$num
≈≈S V
,
≈≈V W
$num
≈≈X \
)
≈≈\ ]
}
≈≈^ _
,
≈≈_ `
{
∆∆ 
$str
∆∆ 
,
∆∆ 
CIELabFromRGB
∆∆< I
(
∆∆I J
$num
∆∆J M
,
∆∆M N
$num
∆∆O R
,
∆∆R S
$num
∆∆T W
,
∆∆W X
$num
∆∆Y ]
)
∆∆] ^
}
∆∆_ `
,
∆∆` a
{
«« 
$str
«« 
,
«« 
CIELabFromRGB
««< I
(
««I J
$num
««J M
,
««M N
$num
««O R
,
««R S
$num
««T W
,
««W X
$num
««Y ]
)
««] ^
}
««_ `
,
««` a
{
»» 
$str
»» 
,
»» 
CIELabFromRGB
»»< I
(
»»I J
$num
»»J M
,
»»M N
$num
»»O R
,
»»R S
$num
»»T W
,
»»W X
$num
»»Y ]
)
»»] ^
}
»»_ `
,
»»` a
{
…… 
$str
…… 
,
…… 
CIELabFromRGB
……< I
(
……I J
$num
……J M
,
……M N
$num
……O Q
,
……Q R
$num
……S U
,
……U V
$num
……W [
)
……[ \
}
……] ^
,
……^ _
{
   
$str
   
,
   
CIELabFromRGB
  < I
(
  I J
$num
  J M
,
  M N
$num
  O R
,
  R S
$num
  T W
,
  W X
$num
  Y ]
)
  ] ^
}
  _ `
,
  ` a
{
ÀÀ 
$str
ÀÀ 
,
ÀÀ 
CIELabFromRGB
ÀÀ< I
(
ÀÀI J
$num
ÀÀJ M
,
ÀÀM N
$num
ÀÀO R
,
ÀÀR S
$num
ÀÀT W
,
ÀÀW X
$num
ÀÀY ]
)
ÀÀ] ^
}
ÀÀ_ `
,
ÀÀ` a
{
ÃÃ 
$str
ÃÃ 
,
ÃÃ 
CIELabFromRGB
ÃÃ< I
(
ÃÃI J
$num
ÃÃJ M
,
ÃÃM N
$num
ÃÃO R
,
ÃÃR S
$num
ÃÃT W
,
ÃÃW X
$num
ÃÃY ]
)
ÃÃ] ^
}
ÃÃ_ `
,
ÃÃ` a
{
ÕÕ 
$str
ÕÕ 
,
ÕÕ 
CIELabFromRGB
ÕÕ< I
(
ÕÕI J
$num
ÕÕJ M
,
ÕÕM N
$num
ÕÕO R
,
ÕÕR S
$num
ÕÕT W
,
ÕÕW X
$num
ÕÕY ]
)
ÕÕ] ^
}
ÕÕ_ `
,
ÕÕ` a
{
ŒŒ 
$str
ŒŒ  
,
ŒŒ  !
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ M
,
ŒŒM N
$num
ŒŒO R
,
ŒŒR S
$num
ŒŒT W
,
ŒŒW X
$num
ŒŒY ]
)
ŒŒ] ^
}
ŒŒ_ `
,
ŒŒ` a
{
œœ 
$str
œœ 
,
œœ  
CIELabFromRGB
œœ< I
(
œœI J
$num
œœJ M
,
œœM N
$num
œœO R
,
œœR S
$num
œœT X
,
œœX Y
$num
œœZ ^
)
œœ^ _
}
œœ` a
,
œœa b
{
–– 
$str
–– *
,
––* +
CIELabFromRGB
––< I
(
––I J
$num
––J M
,
––M N
$num
––O R
,
––R S
$num
––T W
,
––W X
$num
––Y ]
)
––] ^
}
––_ `
,
––` a
{
—— 
$str
—— "
,
——" #
CIELabFromRGB
——< I
(
——I J
$num
——J N
,
——N O
$num
——P S
,
——S T
$num
——U X
,
——X Y
$num
——Z ^
)
——^ _
}
——` a
,
——a b
{
““ 
$str
““  
,
““  !
CIELabFromRGB
““< I
(
““I J
$num
““J N
,
““N O
$num
““P S
,
““S T
$num
““U X
,
““X Y
$num
““Z ^
)
““^ _
}
““` a
,
““a b
{
”” 
$str
””  
,
””  !
CIELabFromRGB
””< I
(
””I J
$num
””J N
,
””N O
$num
””P T
,
””T U
$num
””V Y
,
””Y Z
$num
””[ _
)
””_ `
}
””a b
,
””b c
{
‘‘ 
$str
‘‘ 
,
‘‘ 
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J M
,
‘‘M N
$num
‘‘O Q
,
‘‘Q R
$num
‘‘S W
,
‘‘W X
$num
‘‘Y ]
)
‘‘] ^
}
‘‘_ `
,
‘‘` a
{
’’ 
$str
’’ $
,
’’$ %
CIELabFromRGB
’’< I
(
’’I J
$num
’’J M
,
’’M N
$num
’’O Q
,
’’Q R
$num
’’S W
,
’’W X
$num
’’Y ]
)
’’] ^
}
’’_ `
,
’’` a
{
÷÷ 
$str
÷÷ 
,
÷÷ 
CIELabFromRGB
÷÷< I
(
÷÷I J
$num
÷÷J M
,
÷÷M N
$num
÷÷O Q
,
÷÷Q R
$num
÷÷S V
,
÷÷V W
$num
÷÷X \
)
÷÷\ ]
}
÷÷^ _
,
÷÷_ `
{
◊◊ 
$str
◊◊ 
,
◊◊ 
CIELabFromRGB
◊◊< I
(
◊◊I J
$num
◊◊J M
,
◊◊M N
$num
◊◊O R
,
◊◊R S
$num
◊◊T W
,
◊◊W X
$num
◊◊Y ]
)
◊◊] ^
}
◊◊_ `
,
◊◊` a
{
ÿÿ 
$str
ÿÿ 
,
ÿÿ 
CIELabFromRGB
ÿÿ< I
(
ÿÿI J
$num
ÿÿJ M
,
ÿÿM N
$num
ÿÿO R
,
ÿÿR S
$num
ÿÿT W
,
ÿÿW X
$num
ÿÿY ]
)
ÿÿ] ^
}
ÿÿ_ `
,
ÿÿ` a
{
ŸŸ 
$str
ŸŸ 
,
ŸŸ 
CIELabFromRGB
ŸŸ< I
(
ŸŸI J
$num
ŸŸJ M
,
ŸŸM N
$num
ŸŸO R
,
ŸŸR S
$num
ŸŸT W
,
ŸŸW X
$num
ŸŸY ]
)
ŸŸ] ^
}
ŸŸ_ `
,
ŸŸ` a
{
⁄⁄ 
$str
⁄⁄ 
,
⁄⁄ 
CIELabFromRGB
⁄⁄< I
(
⁄⁄I J
$num
⁄⁄J M
,
⁄⁄M N
$num
⁄⁄O R
,
⁄⁄R S
$num
⁄⁄T W
,
⁄⁄W X
$num
⁄⁄Y ]
)
⁄⁄] ^
}
⁄⁄_ `
,
⁄⁄` a
{
€€ 
$str
€€ 
,
€€ 
CIELabFromRGB
€€< I
(
€€I J
$num
€€J L
,
€€L M
$num
€€N Q
,
€€Q R
$num
€€S V
,
€€V W
$num
€€X \
)
€€\ ]
}
€€^ _
,
€€_ `
{
‹‹ 
$str
‹‹ 
,
‹‹ 
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J M
,
‹‹M N
$num
‹‹O R
,
‹‹R S
$num
‹‹T W
,
‹‹W X
$num
‹‹Y ]
)
‹‹] ^
}
‹‹_ `
,
‹‹` a
{
›› 
$str
›› 
,
›› 
CIELabFromRGB
››< I
(
››I J
$num
››J M
,
››M N
$num
››O R
,
››R S
$num
››T V
,
››V W
$num
››X \
)
››\ ]
}
››^ _
,
››_ `
{
ﬁﬁ 
$str
ﬁﬁ 
,
ﬁﬁ 
CIELabFromRGB
ﬁﬁ< I
(
ﬁﬁI J
$num
ﬁﬁJ M
,
ﬁﬁM N
$num
ﬁﬁO R
,
ﬁﬁR S
$num
ﬁﬁT W
,
ﬁﬁW X
$num
ﬁﬁY ]
)
ﬁﬁ] ^
}
ﬁﬁ_ `
,
ﬁﬁ` a
{
ﬂﬂ 
$str
ﬂﬂ 
,
ﬂﬂ 
CIELabFromRGB
ﬂﬂ< I
(
ﬂﬂI J
$num
ﬂﬂJ M
,
ﬂﬂM N
$num
ﬂﬂO R
,
ﬂﬂR S
$num
ﬂﬂT W
,
ﬂﬂW X
$num
ﬂﬂY ]
)
ﬂﬂ] ^
}
ﬂﬂ_ `
,
ﬂﬂ` a
{
‡‡ 
$str
‡‡ 
,
‡‡ 
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J M
,
‡‡M N
$num
‡‡O R
,
‡‡R S
$num
‡‡T W
,
‡‡W X
$num
‡‡Y ]
)
‡‡] ^
}
‡‡_ `
,
‡‡` a
{
·· 
$str
·· 
,
·· 
CIELabFromRGB
··< I
(
··I J
$num
··J L
,
··L M
$num
··N Q
,
··Q R
$num
··S V
,
··V W
$num
··X \
)
··\ ]
}
··^ _
,
··_ `
{
‚‚ 
$str
‚‚ 
,
‚‚ 
CIELabFromRGB
‚‚< I
(
‚‚I J
$num
‚‚J M
,
‚‚M N
$num
‚‚O Q
,
‚‚Q R
$num
‚‚S V
,
‚‚V W
$num
‚‚X \
)
‚‚\ ]
}
‚‚^ _
,
‚‚_ `
{
„„ 
$str
„„ 
,
„„ 
CIELabFromRGB
„„< I
(
„„I J
$num
„„J N
,
„„N O
$num
„„P S
,
„„S T
$num
„„U W
,
„„W X
$num
„„Y ]
)
„„] ^
}
„„_ `
,
„„` a
{
‰‰ 
$str
‰‰  
,
‰‰  !
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J M
,
‰‰M N
$num
‰‰O R
,
‰‰R S
$num
‰‰T V
,
‰‰V W
$num
‰‰X \
)
‰‰\ ]
}
‰‰^ _
,
‰‰_ `
{
ÂÂ 
$str
ÂÂ 
,
ÂÂ  
CIELabFromRGB
ÂÂ< I
(
ÂÂI J
$num
ÂÂJ L
,
ÂÂL M
$num
ÂÂN Q
,
ÂÂQ R
$num
ÂÂS V
,
ÂÂV W
$num
ÂÂX \
)
ÂÂ\ ]
}
ÂÂ^ _
,
ÂÂ_ `
{
ÊÊ 
$str
ÊÊ 
,
ÊÊ 
CIELabFromRGB
ÊÊ< I
(
ÊÊI J
$num
ÊÊJ M
,
ÊÊM N
$num
ÊÊO Q
,
ÊÊQ R
$num
ÊÊS V
,
ÊÊV W
$num
ÊÊX \
)
ÊÊ\ ]
}
ÊÊ^ _
,
ÊÊ_ `
{
ÁÁ 
$str
ÁÁ 
,
ÁÁ 
CIELabFromRGB
ÁÁ< I
(
ÁÁI J
$num
ÁÁJ N
,
ÁÁN O
$num
ÁÁP S
,
ÁÁS T
$num
ÁÁU W
,
ÁÁW X
$num
ÁÁY ]
)
ÁÁ] ^
}
ÁÁ_ `
,
ÁÁ` a
{
ËË 
$str
ËË !
,
ËË! "
CIELabFromRGB
ËË< I
(
ËËI J
$num
ËËJ N
,
ËËN O
$num
ËËP S
,
ËËS T
$num
ËËU W
,
ËËW X
$num
ËËY ]
)
ËË] ^
}
ËË_ `
,
ËË` a
{
ÈÈ 
$str
ÈÈ 
,
ÈÈ 
CIELabFromRGB
ÈÈ< I
(
ÈÈI J
$num
ÈÈJ M
,
ÈÈM N
$num
ÈÈO Q
,
ÈÈQ R
$num
ÈÈS W
,
ÈÈW X
$num
ÈÈY ]
)
ÈÈ] ^
}
ÈÈ_ `
,
ÈÈ` a
{
ÍÍ 
$str
ÍÍ 
,
ÍÍ  
CIELabFromRGB
ÍÍ< I
(
ÍÍI J
$num
ÍÍJ N
,
ÍÍN O
$num
ÍÍP R
,
ÍÍR S
$num
ÍÍT W
,
ÍÍW X
$num
ÍÍY ]
)
ÍÍ] ^
}
ÍÍ_ `
,
ÍÍ` a
{
ÎÎ 
$str
ÎÎ 
,
ÎÎ 
CIELabFromRGB
ÎÎ< I
(
ÎÎI J
$num
ÎÎJ M
,
ÎÎM N
$num
ÎÎO Q
,
ÎÎQ R
$num
ÎÎS V
,
ÎÎV W
$num
ÎÎX \
)
ÎÎ\ ]
}
ÎÎ^ _
,
ÎÎ_ `
{
ÏÏ 
$str
ÏÏ !
,
ÏÏ! "
CIELabFromRGB
ÏÏ< I
(
ÏÏI J
$num
ÏÏJ M
,
ÏÏM N
$num
ÏÏO R
,
ÏÏR S
$num
ÏÏT W
,
ÏÏW X
$num
ÏÏY ]
)
ÏÏ] ^
}
ÏÏ_ `
,
ÏÏ` a
{
ÌÌ 
$str
ÌÌ 
,
ÌÌ 
CIELabFromRGB
ÌÌ< I
(
ÌÌI J
$num
ÌÌJ L
,
ÌÌL M
$num
ÌÌN Q
,
ÌÌQ R
$num
ÌÌS W
,
ÌÌW X
$num
ÌÌY ]
)
ÌÌ] ^
}
ÌÌ_ `
,
ÌÌ` a
{
ÓÓ 
$str
ÓÓ 
,
ÓÓ 
CIELabFromRGB
ÓÓ< I
(
ÓÓI J
$num
ÓÓJ M
,
ÓÓM N
$num
ÓÓO R
,
ÓÓR S
$num
ÓÓT W
,
ÓÓW X
$num
ÓÓY ]
)
ÓÓ] ^
}
ÓÓ_ `
,
ÓÓ` a
{
ÔÔ 
$str
ÔÔ 
,
ÔÔ  
CIELabFromRGB
ÔÔ< I
(
ÔÔI J
$num
ÔÔJ N
,
ÔÔN O
$num
ÔÔP S
,
ÔÔS T
$num
ÔÔU X
,
ÔÔX Y
$num
ÔÔZ ^
)
ÔÔ^ _
}
ÔÔ` a
,
ÔÔa b
{
 
$str
 
,
  
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
ÒÒ 
$str
ÒÒ 
,
ÒÒ 
CIELabFromRGB
ÒÒ< I
(
ÒÒI J
$num
ÒÒJ M
,
ÒÒM N
$num
ÒÒO Q
,
ÒÒQ R
$num
ÒÒS W
,
ÒÒW X
$num
ÒÒY ]
)
ÒÒ] ^
}
ÒÒ_ `
,
ÒÒ` a
{
ÚÚ 
$str
ÚÚ 
,
ÚÚ 
CIELabFromRGB
ÚÚ< I
(
ÚÚI J
$num
ÚÚJ N
,
ÚÚN O
$num
ÚÚP S
,
ÚÚS T
$num
ÚÚU W
,
ÚÚW X
$num
ÚÚY ]
)
ÚÚ] ^
}
ÚÚ_ `
,
ÚÚ` a
{
ÛÛ 
$str
ÛÛ 
,
ÛÛ 
CIELabFromRGB
ÛÛ< I
(
ÛÛI J
$num
ÛÛJ L
,
ÛÛL M
$num
ÛÛN Q
,
ÛÛQ R
$num
ÛÛS V
,
ÛÛV W
$num
ÛÛX \
)
ÛÛ\ ]
}
ÛÛ^ _
,
ÛÛ_ `
{
ÙÙ 
$str
ÙÙ 
,
ÙÙ 
CIELabFromRGB
ÙÙ< I
(
ÙÙI J
$num
ÙÙJ M
,
ÙÙM N
$num
ÙÙO R
,
ÙÙR S
$num
ÙÙT W
,
ÙÙW X
$num
ÙÙY ]
)
ÙÙ] ^
}
ÙÙ_ `
,
ÙÙ` a
{
ıı 
$str
ıı 
,
ıı 
CIELabFromRGB
ıı< I
(
ııI J
$num
ııJ M
,
ııM N
$num
ııO R
,
ııR S
$num
ııT W
,
ııW X
$num
ııY ]
)
ıı] ^
}
ıı_ `
,
ıı` a
{
ˆˆ 
$str
ˆˆ 
,
ˆˆ 
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ M
,
ˆˆM N
$num
ˆˆO R
,
ˆˆR S
$num
ˆˆT W
,
ˆˆW X
$num
ˆˆY ]
)
ˆˆ] ^
}
ˆˆ_ `
,
ˆˆ` a
{
˜˜ 
$str
˜˜ 
,
˜˜ 
CIELabFromRGB
˜˜< I
(
˜˜I J
$num
˜˜J N
,
˜˜N O
$num
˜˜P T
,
˜˜T U
$num
˜˜V Z
,
˜˜Z [
$num
˜˜\ `
)
˜˜` a
}
˜˜b c
,
˜˜c d
{
¯¯ 
$str
¯¯ 
,
¯¯ 
CIELabFromRGB
¯¯< I
(
¯¯I J
$num
¯¯J M
,
¯¯M N
$num
¯¯O R
,
¯¯R S
$num
¯¯T W
,
¯¯W X
$num
¯¯Y ]
)
¯¯] ^
}
¯¯_ `
,
¯¯` a
{
˘˘ 
$str
˘˘  
,
˘˘  !
CIELabFromRGB
˘˘< I
(
˘˘I J
$num
˘˘J M
,
˘˘M N
$num
˘˘O R
,
˘˘R S
$num
˘˘T W
,
˘˘W X
$num
˘˘Y ]
)
˘˘] ^
}
˘˘_ `
,
˘˘` a
{
˙˙ 
$str
˙˙ 
,
˙˙ 
CIELabFromRGB
˙˙< I
(
˙˙I J
$num
˙˙J M
,
˙˙M N
$num
˙˙O R
,
˙˙R S
$num
˙˙T W
,
˙˙W X
$num
˙˙Y ]
)
˙˙] ^
}
˙˙_ `
,
˙˙` a
{
˚˚ 
$str
˚˚ 
,
˚˚  
CIELabFromRGB
˚˚< I
(
˚˚I J
$num
˚˚J N
,
˚˚N O
$num
˚˚P S
,
˚˚S T
$num
˚˚U X
,
˚˚X Y
$num
˚˚Z ^
)
˚˚^ _
}
˚˚` a
,
˚˚a b
{
¸¸ 
$str
¸¸ 
,
¸¸  
CIELabFromRGB
¸¸< I
(
¸¸I J
$num
¸¸J M
,
¸¸M N
$num
¸¸O R
,
¸¸R S
$num
¸¸T W
,
¸¸W X
$num
¸¸Y ]
)
¸¸] ^
}
¸¸_ `
,
¸¸` a
{
˝˝ 
$str
˝˝  
,
˝˝  !
CIELabFromRGB
˝˝< I
(
˝˝I J
$num
˝˝J M
,
˝˝M N
$num
˝˝O R
,
˝˝R S
$num
˝˝T V
,
˝˝V W
$num
˝˝X \
)
˝˝\ ]
}
˝˝^ _
,
˝˝_ `
{
˛˛ 
$str
˛˛ 
,
˛˛ 
CIELabFromRGB
˛˛< I
(
˛˛I J
$num
˛˛J M
,
˛˛M N
$num
˛˛O R
,
˛˛R S
$num
˛˛T V
,
˛˛V W
$num
˛˛X \
)
˛˛\ ]
}
˛˛^ _
,
˛˛_ `
{
ˇˇ 
$str
ˇˇ 
,
ˇˇ 
CIELabFromRGB
ˇˇ< I
(
ˇˇI J
$num
ˇˇJ M
,
ˇˇM N
$num
ˇˇO R
,
ˇˇR S
$num
ˇˇT W
,
ˇˇW X
$num
ˇˇY ]
)
ˇˇ] ^
}
ˇˇ_ `
,
ˇˇ` a
{
ÄÄ 
$str
ÄÄ 
,
ÄÄ 
CIELabFromRGB
ÄÄ< I
(
ÄÄI J
$num
ÄÄJ M
,
ÄÄM N
$num
ÄÄO R
,
ÄÄR S
$num
ÄÄT W
,
ÄÄW X
$num
ÄÄY ]
)
ÄÄ] ^
}
ÄÄ_ `
,
ÄÄ` a
{
ÅÅ 
$str
ÅÅ 
,
ÅÅ 
CIELabFromRGB
ÅÅ< I
(
ÅÅI J
$num
ÅÅJ M
,
ÅÅM N
$num
ÅÅO R
,
ÅÅR S
$num
ÅÅT W
,
ÅÅW X
$num
ÅÅY ]
)
ÅÅ] ^
}
ÅÅ_ `
,
ÅÅ` a
{
ÇÇ 
$str
ÇÇ 
,
ÇÇ 
CIELabFromRGB
ÇÇ< I
(
ÇÇI J
$num
ÇÇJ M
,
ÇÇM N
$num
ÇÇO R
,
ÇÇR S
$num
ÇÇT W
,
ÇÇW X
$num
ÇÇY ]
)
ÇÇ] ^
}
ÇÇ_ `
,
ÇÇ` a
{
ÉÉ 
$str
ÉÉ 
,
ÉÉ 
CIELabFromRGB
ÉÉ< I
(
ÉÉI J
$num
ÉÉJ M
,
ÉÉM N
$num
ÉÉO R
,
ÉÉR S
$num
ÉÉT W
,
ÉÉW X
$num
ÉÉY ]
)
ÉÉ] ^
}
ÉÉ_ `
,
ÉÉ` a
{
ÑÑ 
$str
ÑÑ 
,
ÑÑ 
CIELabFromRGB
ÑÑ< I
(
ÑÑI J
$num
ÑÑJ L
,
ÑÑL M
$num
ÑÑN Q
,
ÑÑQ R
$num
ÑÑS V
,
ÑÑV W
$num
ÑÑX \
)
ÑÑ\ ]
}
ÑÑ^ _
,
ÑÑ_ `
{
ÖÖ 
$str
ÖÖ 
,
ÖÖ 
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ M
,
ÖÖM N
$num
ÖÖO R
,
ÖÖR S
$num
ÖÖT W
,
ÖÖW X
$num
ÖÖY ]
)
ÖÖ] ^
}
ÖÖ_ `
,
ÖÖ` a
{
ÜÜ 
$str
ÜÜ 
,
ÜÜ 
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ N
,
ÜÜN O
$num
ÜÜP T
,
ÜÜT U
$num
ÜÜV X
,
ÜÜX Y
$num
ÜÜZ ^
)
ÜÜ^ _
}
ÜÜ` a
,
ÜÜa b
{
áá 
$str
áá  
,
áá  !
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ M
,
ááM N
$num
ááO R
,
ááR S
$num
ááT W
,
ááW X
$num
ááY ]
)
áá] ^
}
áá_ `
,
áá` a
{
àà 
$str
àà  
,
àà  !
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ M
,
ààM N
$num
ààO R
,
ààR S
$num
ààT V
,
ààV W
$num
ààX \
)
àà\ ]
}
àà^ _
,
àà_ `
{
ââ 
$str
ââ 
,
ââ 
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ N
,
ââN O
$num
ââP S
,
ââS T
$num
ââU W
,
ââW X
$num
ââY ]
)
ââ] ^
}
ââ_ `
,
ââ` a
{
ää 
$str
ää  
,
ää  !
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ N
,
ääN O
$num
ääP S
,
ääS T
$num
ääU W
,
ääW X
$num
ääY ]
)
ää] ^
}
ää_ `
,
ää` a
{
ãã 
$str
ãã  
,
ãã  !
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ N
,
ããN O
$num
ããP S
,
ããS T
$num
ããU W
,
ããW X
$num
ããY ]
)
ãã] ^
}
ãã_ `
,
ãã` a
{
åå 
$str
åå 
,
åå 
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ N
,
ååN O
$num
ååP T
,
ååT U
$num
ååV Y
,
ååY Z
$num
åå[ _
)
åå_ `
}
ååa b
,
ååb c
{
çç 
$str
çç 
,
çç 
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ M
,
ççM N
$num
ççO R
,
ççR S
$num
ççT W
,
ççW X
$num
ççY ]
)
çç] ^
}
çç_ `
,
çç` a
{
éé 
$str
éé 
,
éé 
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ N
,
ééN O
$num
ééP S
,
ééS T
$num
ééU X
,
ééX Y
$num
ééZ ^
)
éé^ _
}
éé` a
,
ééa b
{
èè 
$str
èè 
,
èè 
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ N
,
èèN O
$num
èèP S
,
èèS T
$num
èèU W
,
èèW X
$num
èèY ]
)
èè] ^
}
èè_ `
,
èè` a
{
êê 
$str
êê 
,
êê 
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ L
,
êêL M
$num
êêN P
,
êêP Q
$num
êêR U
,
êêU V
$num
êêW [
)
êê[ \
}
êê] ^
,
êê^ _
{
ëë 
$str
ëë !
,
ëë! "
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ M
,
ëëM N
$num
ëëO Q
,
ëëQ R
$num
ëëS U
,
ëëU V
$num
ëëW [
)
ëë[ \
}
ëë] ^
,
ëë^ _
{
íí 
$str
íí 
,
íí 
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ M
,
ííM N
$num
ííO R
,
ííR S
$num
ííT W
,
ííW X
$num
ííY ]
)
íí] ^
}
íí_ `
}
ìì 	
;
ìì	 

}
îî 
}ïï ıÍ
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\VertexEditing.cs
	namespace

 	
UnityEngine


 
.

 

ProBuilder

  
.

  !
MeshOperations

! /
{ 
public 

static 
class 
VertexEditing %
{ 
public 
static 
int 
MergeVertices '
(' (
this( ,
ProBuilderMesh- ;
mesh< @
,@ A
intB E
[E F
]F G
indexesH O
,O P
boolQ U
collapseToFirstV e
=f g
falseh m
)m n
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new !
ArgumentNullException /
(/ 0
$str0 6
)6 7
;7 8
if   
(   
indexes   
==   
null   
)    
throw!! 
new!! !
ArgumentNullException!! /
(!!/ 0
$str!!0 9
)!!9 :
;!!: ;
Vertex## 
[## 
]## 
vertices## 
=## 
mesh##  $
.##$ %
GetVertices##% 0
(##0 1
)##1 2
;##2 3
Vertex$$ 
cen$$ 
=$$ 
collapseToFirst$$ (
?$$) *
vertices$$+ 3
[$$3 4
indexes$$4 ;
[$$; <
$num$$< =
]$$= >
]$$> ?
:$$@ A
Vertex$$B H
.$$H I
Average$$I P
($$P Q
vertices$$Q Y
,$$Y Z
indexes$$[ b
)$$b c
;$$c d
mesh%% 
.%% !
SetVerticesCoincident%% &
(%%& '
indexes%%' .
)%%. /
;%%/ 0
	UVEditing&& 
.&& 
SplitUVs&& 
(&& 
mesh&& #
,&&# $
indexes&&% ,
)&&, -
;&&- .
int'' 
sharedVertexHandle'' "
=''# $
mesh''% )
.'') *!
GetSharedVertexHandle''* ?
(''? @
indexes''@ G
.''G H
First''H M
(''M N
)''N O
)''O P
;''P Q
mesh(( 
.(( !
SetSharedVertexValues(( &
(((& '
sharedVertexHandle((' 9
,((9 :
cen((; >
)((> ?
;((? @
SharedVertex** 
merged** 
=**  !
mesh**" &
.**& '"
sharedVerticesInternal**' =
[**= >
sharedVertexHandle**> P
]**P Q
;**Q R
List++ 
<++ 
int++ 
>++ 
removedIndexes++ $
=++% &
new++' *
List+++ /
<++/ 0
int++0 3
>++3 4
(++4 5
)++5 6
;++6 7
MeshValidation-- 
.-- %
RemoveDegenerateTriangles-- 4
(--4 5
mesh--5 9
,--9 :
removedIndexes--; I
)--I J
;--J K
int00 
ind00 
=00 
-00 
$num00 
;00 
for11 
(11 
int11 
i11 
=11 
$num11 
;11 
i11 
<11 
merged11  &
.11& '
Count11' ,
;11, -
i11. /
++11/ 1
)111 2
if22 
(22 
!22 
removedIndexes22 #
.22# $
Contains22$ ,
(22, -
merged22- 3
[223 4
i224 5
]225 6
)226 7
)227 8
ind33 
=33 
merged33  
[33  !
i33! "
]33" #
;33# $
int55 
res55 
=55 
ind55 
;55 
for77 
(77 
int77 
i77 
=77 
$num77 
;77 
i77 
<77 
removedIndexes77  .
.77. /
Count77/ 4
;774 5
i776 7
++777 9
)779 :
if88 
(88 
ind88 
>88 
removedIndexes88 (
[88( )
i88) *
]88* +
)88+ ,
res99 
--99 
;99 
return;; 
res;; 
;;; 
}<< 	
publicGG 
staticGG 
voidGG 
SplitVerticesGG (
(GG( )
thisGG) -
ProBuilderMeshGG. <
meshGG= A
,GGA B
EdgeGGC G
edgeGGH L
)GGL M
{HH 	
SplitVerticesII 
(II 
meshII 
,II 
newII  #
intII$ '
[II' (
]II( )
{II* +
edgeII, 0
.II0 1
aII1 2
,II2 3
edgeII4 8
.II8 9
bII9 :
}II; <
)II< =
;II= >
}JJ 	
publicRR 
staticRR 
voidRR 
SplitVerticesRR (
(RR( )
thisRR) -
ProBuilderMeshRR. <
meshRR= A
,RRA B
IEnumerableRRC N
<RRN O
intRRO R
>RRR S
verticesRRT \
)RR\ ]
{SS 	
ifTT 
(TT 
meshTT 
==TT 
nullTT 
)TT 
throwUU 
newUU !
ArgumentNullExceptionUU /
(UU/ 0
$strUU0 6
)UU6 7
;UU7 8
ifWW 
(WW 
verticesWW 
==WW 
nullWW  
)WW  !
throwXX 
newXX !
ArgumentNullExceptionXX /
(XX/ 0
$strXX0 :
)XX: ;
;XX; <

Dictionary[[ 
<[[ 
int[[ 
,[[ 
int[[ 
>[[  
lookup[[! '
=[[( )
mesh[[* .
.[[. /
sharedVertexLookup[[/ A
;[[A B
int\\ 
max\\ 
=\\ 
lookup\\ 
.\\ 
Count\\ "
(\\" #
)\\# $
;\\$ %
foreach]] 
(]] 
int]] 
i]] 
in]] 
vertices]] &
)]]& '
lookup^^ 
[^^ 
i^^ 
]^^ 
=^^ 
++^^ 
max^^ !
;^^! "
mesh__ 
.__ 
SetSharedVertices__ "
(__" #
lookup__# )
)__) *
;__* +
}`` 	
publicii 
staticii 
intii 
[ii 
]ii 
WeldVerticesii (
(ii( )
thisii) -
ProBuilderMeshii. <
meshii= A
,iiA B
IEnumerableiiC N
<iiN O
intiiO R
>iiR S
indexesiiT [
,ii[ \
floatii] b
neighborRadiusiic q
)iiq r
{jj 	
ifkk 
(kk 
meshkk 
==kk 
nullkk 
)kk 
throwll 
newll !
ArgumentNullExceptionll /
(ll/ 0
$strll0 6
)ll6 7
;ll7 8
ifnn 
(nn 
indexesnn 
==nn 
nullnn 
)nn  
throwoo 
newoo !
ArgumentNullExceptionoo /
(oo/ 0
$stroo0 9
)oo9 :
;oo: ;
Vertexqq 
[qq 
]qq 
verticesqq 
=qq 
meshqq  $
.qq$ %
GetVerticesqq% 0
(qq0 1
)qq1 2
;qq2 3
SharedVertexrr 
[rr 
]rr 
sharedIndexesrr (
=rr) *
meshrr+ /
.rr/ 0"
sharedVerticesInternalrr0 F
;rrF G
HashSettt 
<tt 
inttt 
>tt 
commontt 
=tt  !
meshtt" &
.tt& '"
GetSharedVertexHandlestt' =
(tt= >
indexestt> E
)ttE F
;ttF G
intuu 
vertexCountuu 
=uu 
commonuu $
.uu$ %
Countuu% *
;uu* +
int{{ 
maxNearestNeighbors{{ #
={{$ %
System{{& ,
.{{, -
Math{{- 1
.{{1 2
Min{{2 5
({{5 6
$num{{6 8
,{{8 9
common{{: @
.{{@ A
Count{{A F
({{F G
){{G H
){{H I
;{{I J
KdTree~~ 
<~~ 
float~~ 
,~~ 
int~~ 
>~~ 
tree~~ #
=~~$ %
new~~& )
KdTree~~* 0
<~~0 1
float~~1 6
,~~6 7
int~~8 ;
>~~; <
(~~< =
$num~~= >
,~~> ?
new~~@ C
	FloatMath~~D M
(~~M N
)~~N O
,~~O P 
AddDuplicateBehavior~~Q e
.~~e f
Collect~~f m
)~~m n
;~~n o
foreach
ÄÄ 
(
ÄÄ 
int
ÄÄ 
i
ÄÄ 
in
ÄÄ 
common
ÄÄ $
)
ÄÄ$ %
{
ÅÅ 
Vector3
ÇÇ 
v
ÇÇ 
=
ÇÇ 
vertices
ÇÇ $
[
ÇÇ$ %
sharedIndexes
ÇÇ% 2
[
ÇÇ2 3
i
ÇÇ3 4
]
ÇÇ4 5
[
ÇÇ5 6
$num
ÇÇ6 7
]
ÇÇ7 8
]
ÇÇ8 9
.
ÇÇ9 :
position
ÇÇ: B
;
ÇÇB C
tree
ÉÉ 
.
ÉÉ 
Add
ÉÉ 
(
ÉÉ 
new
ÉÉ 
float
ÉÉ "
[
ÉÉ" #
]
ÉÉ# $
{
ÉÉ% &
v
ÉÉ' (
.
ÉÉ( )
x
ÉÉ) *
,
ÉÉ* +
v
ÉÉ, -
.
ÉÉ- .
y
ÉÉ. /
,
ÉÉ/ 0
v
ÉÉ1 2
.
ÉÉ2 3
z
ÉÉ3 4
}
ÉÉ5 6
,
ÉÉ6 7
i
ÉÉ8 9
)
ÉÉ9 :
;
ÉÉ: ;
}
ÑÑ 
float
ÜÜ 
[
ÜÜ 
]
ÜÜ 
point
ÜÜ 
=
ÜÜ 
new
ÜÜ 
float
ÜÜ  %
[
ÜÜ% &
$num
ÜÜ& '
]
ÜÜ' (
{
ÜÜ) *
$num
ÜÜ+ ,
,
ÜÜ, -
$num
ÜÜ. /
,
ÜÜ/ 0
$num
ÜÜ1 2
}
ÜÜ3 4
;
ÜÜ4 5

Dictionary
áá 
<
áá 
int
áá 
,
áá 
int
áá 
>
áá  
remapped
áá! )
=
áá* +
new
áá, /

Dictionary
áá0 :
<
áá: ;
int
áá; >
,
áá> ?
int
áá@ C
>
ááC D
(
ááD E
)
ááE F
;
ááF G

Dictionary
àà 
<
àà 
int
àà 
,
àà 
Vector3
àà #
>
àà# $
averages
àà% -
=
àà. /
new
àà0 3

Dictionary
àà4 >
<
àà> ?
int
àà? B
,
ààB C
Vector3
ààD K
>
ààK L
(
ààL M
)
ààM N
;
ààN O
int
ââ 
index
ââ 
=
ââ 
sharedIndexes
ââ %
.
ââ% &
Length
ââ& ,
;
ââ, -
foreach
ãã 
(
ãã 
int
ãã 
commonIndex
ãã $
in
ãã% '
common
ãã( .
)
ãã. /
{
åå 
if
éé 
(
éé 
remapped
éé 
.
éé 
ContainsKey
éé (
(
éé( )
commonIndex
éé) 4
)
éé4 5
)
éé5 6
continue
èè 
;
èè 
Vector3
ëë 
v
ëë 
=
ëë 
vertices
ëë $
[
ëë$ %
sharedIndexes
ëë% 2
[
ëë2 3
commonIndex
ëë3 >
]
ëë> ?
[
ëë? @
$num
ëë@ A
]
ëëA B
]
ëëB C
.
ëëC D
position
ëëD L
;
ëëL M
point
ìì 
[
ìì 
$num
ìì 
]
ìì 
=
ìì 
v
ìì 
.
ìì 
x
ìì 
;
ìì 
point
îî 
[
îî 
$num
îî 
]
îî 
=
îî 
v
îî 
.
îî 
y
îî 
;
îî 
point
ïï 
[
ïï 
$num
ïï 
]
ïï 
=
ïï 
v
ïï 
.
ïï 
z
ïï 
;
ïï 

KdTreeNode
òò 
<
òò 
float
òò  
,
òò  !
int
òò" %
>
òò% &
[
òò& '
]
òò' (
	neighbors
òò) 2
=
òò3 4
tree
òò5 9
.
òò9 :
RadialSearch
òò: F
(
òòF G
point
òòG L
,
òòL M
neighborRadius
òòN \
,
òò\ ]!
maxNearestNeighbors
òò^ q
)
òòq r
;
òòr s
if
úú 
(
úú !
maxNearestNeighbors
úú '
<
úú( )
vertexCount
úú* 5
&&
úú6 8
	neighbors
úú9 B
.
úúB C
Length
úúC I
>=
úúJ L!
maxNearestNeighbors
úúM `
)
úú` a
{
ùù 
	neighbors
ûû 
=
ûû 
tree
ûû  $
.
ûû$ %
RadialSearch
ûû% 1
(
ûû1 2
point
ûû2 7
,
ûû7 8
neighborRadius
ûû9 G
,
ûûG H
vertexCount
ûûI T
)
ûûT U
;
ûûU V!
maxNearestNeighbors
üü '
=
üü( )
System
üü* 0
.
üü0 1
Math
üü1 5
.
üü5 6
Min
üü6 9
(
üü9 :
vertexCount
üü: E
,
üüE F
	neighbors
üüG P
.
üüP Q
Length
üüQ W
+
üüX Y
	neighbors
üüZ c
.
üüc d
Length
üüd j
/
üük l
$num
üüm n
)
üün o
;
üüo p
}
†† 
Vector3
¢¢ 
avg
¢¢ 
=
¢¢ 
Vector3
¢¢ %
.
¢¢% &
zero
¢¢& *
;
¢¢* +
float
££ 
count
££ 
=
££ 
$num
££ 
;
££  
for
•• 
(
•• 
int
•• 
neighborIndex
•• &
=
••' (
$num
••) *
;
••* +
neighborIndex
••, 9
<
••: ;
	neighbors
••< E
.
••E F
Length
••F L
;
••L M
neighborIndex
••N [
++
••[ ]
)
••] ^
{
¶¶ 
int
®® 
c
®® 
=
®® 
	neighbors
®® %
[
®®% &
neighborIndex
®®& 3
]
®®3 4
.
®®4 5
Value
®®5 :
;
®®: ;
if
´´ 
(
´´ 
remapped
´´  
.
´´  !
ContainsKey
´´! ,
(
´´, -
c
´´- .
)
´´. /
)
´´/ 0
continue
¨¨  
;
¨¨  !
avg
ÆÆ 
.
ÆÆ 
x
ÆÆ 
+=
ÆÆ 
	neighbors
ÆÆ &
[
ÆÆ& '
neighborIndex
ÆÆ' 4
]
ÆÆ4 5
.
ÆÆ5 6
Point
ÆÆ6 ;
[
ÆÆ; <
$num
ÆÆ< =
]
ÆÆ= >
;
ÆÆ> ?
avg
ØØ 
.
ØØ 
y
ØØ 
+=
ØØ 
	neighbors
ØØ &
[
ØØ& '
neighborIndex
ØØ' 4
]
ØØ4 5
.
ØØ5 6
Point
ØØ6 ;
[
ØØ; <
$num
ØØ< =
]
ØØ= >
;
ØØ> ?
avg
∞∞ 
.
∞∞ 
z
∞∞ 
+=
∞∞ 
	neighbors
∞∞ &
[
∞∞& '
neighborIndex
∞∞' 4
]
∞∞4 5
.
∞∞5 6
Point
∞∞6 ;
[
∞∞; <
$num
∞∞< =
]
∞∞= >
;
∞∞> ?
remapped
≤≤ 
.
≤≤ 
Add
≤≤  
(
≤≤  !
c
≤≤! "
,
≤≤" #
index
≤≤$ )
)
≤≤) *
;
≤≤* +
count
¥¥ 
++
¥¥ 
;
¥¥ 
if
∂∂ 
(
∂∂ 
	neighbors
∂∂ !
[
∂∂! "
neighborIndex
∂∂" /
]
∂∂/ 0
.
∂∂0 1

Duplicates
∂∂1 ;
!=
∂∂< >
null
∂∂? C
)
∂∂C D
{
∑∑ 
for
∏∏ 
(
∏∏ 
int
∏∏  
duplicateIndex
∏∏! /
=
∏∏0 1
$num
∏∏2 3
;
∏∏3 4
duplicateIndex
∏∏5 C
<
∏∏D E
	neighbors
∏∏F O
[
∏∏O P
neighborIndex
∏∏P ]
]
∏∏] ^
.
∏∏^ _

Duplicates
∏∏_ i
.
∏∏i j
Count
∏∏j o
;
∏∏o p
duplicateIndex
∏∏q 
++∏∏ Å
)∏∏Å Ç
remapped
ππ $
.
ππ$ %
Add
ππ% (
(
ππ( )
	neighbors
ππ) 2
[
ππ2 3
neighborIndex
ππ3 @
]
ππ@ A
.
ππA B

Duplicates
ππB L
[
ππL M
duplicateIndex
ππM [
]
ππ[ \
,
ππ\ ]
index
ππ^ c
)
ππc d
;
ππd e
}
∫∫ 
}
ªª 
avg
ΩΩ 
.
ΩΩ 
x
ΩΩ 
/=
ΩΩ 
count
ΩΩ 
;
ΩΩ 
avg
ææ 
.
ææ 
y
ææ 
/=
ææ 
count
ææ 
;
ææ 
avg
øø 
.
øø 
z
øø 
/=
øø 
count
øø 
;
øø 
averages
¡¡ 
.
¡¡ 
Add
¡¡ 
(
¡¡ 
index
¡¡ "
,
¡¡" #
avg
¡¡$ '
)
¡¡' (
;
¡¡( )
index
√√ 
++
√√ 
;
√√ 
}
ƒƒ 
var
∆∆ 
welds
∆∆ 
=
∆∆ 
new
∆∆ 
int
∆∆ 
[
∆∆  
remapped
∆∆  (
.
∆∆( )
Count
∆∆) .
]
∆∆. /
;
∆∆/ 0
int
«« 
n
«« 
=
«« 
$num
«« 
;
«« 
var
»» 
lookup
»» 
=
»» 
mesh
»» 
.
»»  
sharedVertexLookup
»» 0
;
»»0 1
foreach
   
(
   
var
   
kvp
   
in
   
remapped
    (
)
  ( )
{
ÀÀ 
SharedVertex
ÃÃ 
tris
ÃÃ !
=
ÃÃ" #
sharedIndexes
ÃÃ$ 1
[
ÃÃ1 2
kvp
ÃÃ2 5
.
ÃÃ5 6
Key
ÃÃ6 9
]
ÃÃ9 :
;
ÃÃ: ;
welds
ŒŒ 
[
ŒŒ 
n
ŒŒ 
++
ŒŒ 
]
ŒŒ 
=
ŒŒ 
tris
ŒŒ !
[
ŒŒ! "
$num
ŒŒ" #
]
ŒŒ# $
;
ŒŒ$ %
for
–– 
(
–– 
int
–– 
i
–– 
=
–– 
$num
–– 
;
–– 
i
––  !
<
––" #
tris
––$ (
.
––( )
Count
––) .
;
––. /
i
––0 1
++
––1 3
)
––3 4
{
—— 
lookup
““ 
[
““ 
tris
““ 
[
““  
i
““  !
]
““! "
]
““" #
=
““$ %
kvp
““& )
.
““) *
Value
““* /
;
““/ 0
vertices
”” 
[
”” 
tris
”” !
[
””! "
i
””" #
]
””# $
]
””$ %
.
””% &
position
””& .
=
””/ 0
averages
””1 9
[
””9 :
kvp
””: =
.
””= >
Value
””> C
]
””C D
;
””D E
}
‘‘ 
}
’’ 
mesh
◊◊ 
.
◊◊ 
SetSharedVertices
◊◊ "
(
◊◊" #
lookup
◊◊# )
)
◊◊) *
;
◊◊* +
mesh
ÿÿ 
.
ÿÿ 
SetVertices
ÿÿ 
(
ÿÿ 
vertices
ÿÿ %
)
ÿÿ% &
;
ÿÿ& '
return
ŸŸ 
welds
ŸŸ 
;
ŸŸ 
}
⁄⁄ 	
internal
ÓÓ 
static
ÓÓ 
FaceRebuildData
ÓÓ '
ExplodeVertex
ÓÓ( 5
(
ÓÓ5 6
IList
ÔÔ 
<
ÔÔ 
Vertex
ÔÔ 
>
ÔÔ 
vertices
ÔÔ "
,
ÔÔ" #
IList
 
<
 
SimpleTuple
 
<
 

WingedEdge
 (
,
( )
int
* -
>
- .
>
. / 
edgeAndCommonIndex
0 B
,
B C
float
ÒÒ 
distance
ÒÒ 
,
ÒÒ 
out
ÚÚ 

Dictionary
ÚÚ 
<
ÚÚ 
int
ÚÚ 
,
ÚÚ 
List
ÚÚ  $
<
ÚÚ$ %
int
ÚÚ% (
>
ÚÚ( )
>
ÚÚ) *
appendedVertices
ÚÚ+ ;
)
ÚÚ; <
{
ÛÛ 	
Face
ÙÙ 
face
ÙÙ 
=
ÙÙ  
edgeAndCommonIndex
ÙÙ *
.
ÙÙ* +
FirstOrDefault
ÙÙ+ 9
(
ÙÙ9 :
)
ÙÙ: ;
.
ÙÙ; <
item1
ÙÙ< A
.
ÙÙA B
face
ÙÙB F
;
ÙÙF G
List
ıı 
<
ıı 
Edge
ıı 
>
ıı 
	perimeter
ıı  
=
ıı! "

WingedEdge
ıı# -
.
ıı- ."
SortEdgesByAdjacency
ıı. B
(
ııB C
face
ııC G
)
ııG H
;
ııH I
appendedVertices
ˆˆ 
=
ˆˆ 
new
ˆˆ "

Dictionary
ˆˆ# -
<
ˆˆ- .
int
ˆˆ. 1
,
ˆˆ1 2
List
ˆˆ3 7
<
ˆˆ7 8
int
ˆˆ8 ;
>
ˆˆ; <
>
ˆˆ< =
(
ˆˆ= >
)
ˆˆ> ?
;
ˆˆ? @
Vector3
˜˜ 
	oldNormal
˜˜ 
=
˜˜ 
Math
˜˜  $
.
˜˜$ %
Normal
˜˜% +
(
˜˜+ ,
vertices
˜˜, 4
,
˜˜4 5
face
˜˜6 :
.
˜˜: ;
indexesInternal
˜˜; J
)
˜˜J K
;
˜˜K L

Dictionary
˙˙ 
<
˙˙ 
int
˙˙ 
,
˙˙ 
int
˙˙ 
>
˙˙  
toSplit
˙˙! (
=
˙˙) *
new
˙˙+ .

Dictionary
˙˙/ 9
<
˙˙9 :
int
˙˙: =
,
˙˙= >
int
˙˙? B
>
˙˙B C
(
˙˙C D
)
˙˙D E
;
˙˙E F
foreach
¸¸ 
(
¸¸ 
SimpleTuple
¸¸  
<
¸¸  !

WingedEdge
¸¸! +
,
¸¸+ ,
int
¸¸- 0
>
¸¸0 1
v
¸¸2 3
in
¸¸4 6 
edgeAndCommonIndex
¸¸7 I
)
¸¸I J
{
˝˝ 
if
˛˛ 
(
˛˛ 
v
˛˛ 
.
˛˛ 
item2
˛˛ 
==
˛˛ 
v
˛˛  
.
˛˛  !
item1
˛˛! &
.
˛˛& '
edge
˛˛' +
.
˛˛+ ,
common
˛˛, 2
.
˛˛2 3
a
˛˛3 4
)
˛˛4 5
toSplit
ˇˇ 
.
ˇˇ 
Add
ˇˇ 
(
ˇˇ  
v
ˇˇ  !
.
ˇˇ! "
item1
ˇˇ" '
.
ˇˇ' (
edge
ˇˇ( ,
.
ˇˇ, -
local
ˇˇ- 2
.
ˇˇ2 3
a
ˇˇ3 4
,
ˇˇ4 5
v
ˇˇ6 7
.
ˇˇ7 8
item2
ˇˇ8 =
)
ˇˇ= >
;
ˇˇ> ?
else
ÄÄ 
toSplit
ÅÅ 
.
ÅÅ 
Add
ÅÅ 
(
ÅÅ  
v
ÅÅ  !
.
ÅÅ! "
item1
ÅÅ" '
.
ÅÅ' (
edge
ÅÅ( ,
.
ÅÅ, -
local
ÅÅ- 2
.
ÅÅ2 3
b
ÅÅ3 4
,
ÅÅ4 5
v
ÅÅ6 7
.
ÅÅ7 8
item2
ÅÅ8 =
)
ÅÅ= >
;
ÅÅ> ?
}
ÇÇ 
int
ÑÑ 
pc
ÑÑ 
=
ÑÑ 
	perimeter
ÑÑ 
.
ÑÑ 
Count
ÑÑ $
;
ÑÑ$ %
List
ÖÖ 
<
ÖÖ 
Vertex
ÖÖ 
>
ÖÖ 

n_vertices
ÖÖ #
=
ÖÖ$ %
new
ÖÖ& )
List
ÖÖ* .
<
ÖÖ. /
Vertex
ÖÖ/ 5
>
ÖÖ5 6
(
ÖÖ6 7
)
ÖÖ7 8
;
ÖÖ8 9
for
áá 
(
áá 
int
áá 
i
áá 
=
áá 
$num
áá 
;
áá 
i
áá 
<
áá 
pc
áá  "
;
áá" #
i
áá$ %
++
áá% '
)
áá' (
{
àà 
int
ââ 
index
ââ 
=
ââ 
	perimeter
ââ %
[
ââ% &
i
ââ& '
]
ââ' (
.
ââ( )
b
ââ) *
;
ââ* +
if
åå 
(
åå 
toSplit
åå 
.
åå 
ContainsKey
åå '
(
åå' (
index
åå( -
)
åå- .
)
åå. /
{
çç 
Vertex
èè 
a
èè 
=
èè 
vertices
èè '
[
èè' (
	perimeter
èè( 1
[
èè1 2
i
èè2 3
]
èè3 4
.
èè4 5
a
èè5 6
]
èè6 7
;
èè7 8
Vertex
êê 
b
êê 
=
êê 
vertices
êê '
[
êê' (
	perimeter
êê( 1
[
êê1 2
i
êê2 3
]
êê3 4
.
êê4 5
b
êê5 6
]
êê6 7
;
êê7 8
Vertex
ëë 
c
ëë 
=
ëë 
vertices
ëë '
[
ëë' (
	perimeter
ëë( 1
[
ëë1 2
(
ëë2 3
i
ëë3 4
+
ëë5 6
$num
ëë7 8
)
ëë8 9
%
ëë: ;
pc
ëë< >
]
ëë> ?
.
ëë? @
b
ëë@ A
]
ëëA B
;
ëëB C
Vertex
ìì 
leading_dir
ìì &
=
ìì' (
a
ìì) *
-
ìì+ ,
b
ìì- .
;
ìì. /
Vertex
îî 
following_dir
îî (
=
îî) *
c
îî+ ,
-
îî- .
b
îî/ 0
;
îî0 1
leading_dir
ïï 
.
ïï  
	Normalize
ïï  )
(
ïï) *
)
ïï* +
;
ïï+ ,
following_dir
ññ !
.
ññ! "
	Normalize
ññ" +
(
ññ+ ,
)
ññ, -
;
ññ- .
Vertex
òò 
leading_insert
òò )
=
òò* +
vertices
òò, 4
[
òò4 5
index
òò5 :
]
òò: ;
+
òò< =
leading_dir
òò> I
*
òòJ K
distance
òòL T
;
òòT U
Vertex
ôô 
following_insert
ôô +
=
ôô, -
vertices
ôô. 6
[
ôô6 7
index
ôô7 <
]
ôô< =
+
ôô> ?
following_dir
ôô@ M
*
ôôN O
distance
ôôP X
;
ôôX Y
appendedVertices
õõ $
.
õõ$ %
AddOrAppend
õõ% 0
(
õõ0 1
toSplit
õõ1 8
[
õõ8 9
index
õõ9 >
]
õõ> ?
,
õõ? @

n_vertices
õõA K
.
õõK L
Count
õõL Q
)
õõQ R
;
õõR S

n_vertices
úú 
.
úú 
Add
úú "
(
úú" #
leading_insert
úú# 1
)
úú1 2
;
úú2 3
appendedVertices
ûû $
.
ûû$ %
AddOrAppend
ûû% 0
(
ûû0 1
toSplit
ûû1 8
[
ûû8 9
index
ûû9 >
]
ûû> ?
,
ûû? @

n_vertices
ûûA K
.
ûûK L
Count
ûûL Q
)
ûûQ R
;
ûûR S

n_vertices
üü 
.
üü 
Add
üü "
(
üü" #
following_insert
üü# 3
)
üü3 4
;
üü4 5
}
†† 
else
°° 
{
¢¢ 

n_vertices
££ 
.
££ 
Add
££ "
(
££" #
vertices
££# +
[
££+ ,
index
££, 1
]
££1 2
)
££2 3
;
££3 4
}
§§ 
}
•• 
List
ßß 
<
ßß 
int
ßß 
>
ßß 
	triangles
ßß 
;
ßß  
if
©© 
(
©© 
Triangulation
©© 
.
©© !
TriangulateVertices
©© 1
(
©©1 2

n_vertices
©©2 <
,
©©< =
out
©©> A
	triangles
©©B K
,
©©K L
false
©©M R
)
©©R S
)
©©S T
{
™™ 
FaceRebuildData
´´ 
data
´´  $
=
´´% &
new
´´' *
FaceRebuildData
´´+ :
(
´´: ;
)
´´; <
;
´´< =
data
¨¨ 
.
¨¨ 
vertices
¨¨ 
=
¨¨ 

n_vertices
¨¨  *
;
¨¨* +
data
≠≠ 
.
≠≠ 
face
≠≠ 
=
≠≠ 
new
≠≠ 
Face
≠≠  $
(
≠≠$ %
face
≠≠% )
)
≠≠) *
;
≠≠* +
Vector3
ØØ 
	newNormal
ØØ !
=
ØØ" #
Math
ØØ$ (
.
ØØ( )
Normal
ØØ) /
(
ØØ/ 0

n_vertices
ØØ0 :
,
ØØ: ;
	triangles
ØØ< E
)
ØØE F
;
ØØF G
if
±± 
(
±± 
Vector3
±± 
.
±± 
Dot
±± 
(
±±  
	oldNormal
±±  )
,
±±) *
	newNormal
±±+ 4
)
±±4 5
<
±±6 7
$num
±±8 :
)
±±: ;
	triangles
≤≤ 
.
≤≤ 
Reverse
≤≤ %
(
≤≤% &
)
≤≤& '
;
≤≤' (
data
¥¥ 
.
¥¥ 
face
¥¥ 
.
¥¥ 
indexesInternal
¥¥ )
=
¥¥* +
	triangles
¥¥, 5
.
¥¥5 6
ToArray
¥¥6 =
(
¥¥= >
)
¥¥> ?
;
¥¥? @
return
∂∂ 
data
∂∂ 
;
∂∂ 
}
∑∑ 
return
ππ 
null
ππ 
;
ππ 
}
∫∫ 	
static
ºº 
Edge
ºº $
AlignEdgeWithDirection
ºº *
(
ºº* +

EdgeLookup
ºº+ 5
edge
ºº6 :
,
ºº: ;
int
ºº< ?
commonIndex
ºº@ K
)
ººK L
{
ΩΩ 	
if
ææ 
(
ææ 
edge
ææ 
.
ææ 
common
ææ 
.
ææ 
a
ææ 
==
ææ  
commonIndex
ææ! ,
)
ææ, -
return
øø 
new
øø 
Edge
øø 
(
øø  
edge
øø  $
.
øø$ %
local
øø% *
.
øø* +
a
øø+ ,
,
øø, -
edge
øø. 2
.
øø2 3
local
øø3 8
.
øø8 9
b
øø9 :
)
øø: ;
;
øø; <
else
¿¿ 
return
¡¡ 
new
¡¡ 
Edge
¡¡ 
(
¡¡  
edge
¡¡  $
.
¡¡$ %
local
¡¡% *
.
¡¡* +
b
¡¡+ ,
,
¡¡, -
edge
¡¡. 2
.
¡¡2 3
local
¡¡3 8
.
¡¡8 9
a
¡¡9 :
)
¡¡: ;
;
¡¡; <
}
¬¬ 	
}
√√ 
}ƒƒ Ï'
åD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\BezierShape.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ 
AddComponentMenu 
( 
$str 
) 
] 
[ %
DisallowMultipleComponent 
, 
ExcludeFromPreset  1
,1 2$
ExcludeFromObjectFactory3 K
]K L
[		 
RequireComponent		 
(		 
typeof		 
(		 
ProBuilderMesh		 +
)		+ ,
)		, -
]		- .
sealed

 

class

 
BezierShape

 
:

 
MonoBehaviour

 ,
{ 
public 
List 
< 
BezierPoint 
>  
points! '
=( )
new* -
List. 2
<2 3
BezierPoint3 >
>> ?
(? @
)@ A
;A B
public 
bool 
	closeLoop 
= 
false  %
;% &
public 
float 
radius 
= 
$num !
;! "
public 
int 
rows 
= 
$num 
; 
public 
int 
columns 
= 
$num 
;  
public 
bool 
smooth 
= 
true !
;! "
[ 	
SerializeField	 
] 
bool 
m_IsEditing 
; 
public 
bool 
	isEditing 
{ 	
get 
{ 
return 
m_IsEditing $
;$ %
}& '
set 
{ 
m_IsEditing 
= 
value  %
;% &
}' (
} 	
ProBuilderMesh 
m_Mesh 
; 
public 
ProBuilderMesh 
mesh "
{ 	
get 
{ 
if   
(   
m_Mesh   
==   
null   "
)  " #
m_Mesh!! 
=!! 
GetComponent!! )
<!!) *
ProBuilderMesh!!* 8
>!!8 9
(!!9 :
)!!: ;
;!!; <
return## 
m_Mesh## 
;## 
}$$ 
set&& 
{'' 
m_Mesh(( 
=(( 
value(( 
;(( 
})) 
}** 	
public// 
void// 
Init// 
(// 
)// 
{00 	
Vector311 
tan11 
=11 
new11 
Vector311 %
(11% &
$num11& (
,11( )
$num11* ,
,11, -
$num11. 0
)110 1
;111 2
Vector322 
p122 
=22 
new22 
Vector322 $
(22$ %
$num22% '
,22' (
$num22) +
,22+ ,
$num22- /
)22/ 0
;220 1
points33 
.33 
Add33 
(33 
new33 
BezierPoint33 &
(33& '
Vector333' .
.33. /
zero33/ 3
,333 4
-335 6
tan336 9
,339 :
tan33; >
,33> ?

Quaternion33@ J
.33J K
identity33K S
)33S T
)33T U
;33U V
points44 
.44 
Add44 
(44 
new44 
BezierPoint44 &
(44& '
p144' )
,44) *
p144+ -
+44. /
tan440 3
,443 4
p1445 7
+448 9
-44: ;
tan44; >
,44> ?

Quaternion44@ J
.44J K
identity44K S
)44S T
)44T U
;44U V
}55 	
public:: 
void:: 
Refresh:: 
(:: 
):: 
{;; 	
if<< 
(<< 
points<< 
.<< 
Count<< 
<<< 
$num<<  
)<<  !
{== 
mesh>> 
.>> 
Clear>> 
(>> 
)>> 
;>> 
mesh?? 
.?? 
ToMesh?? 
(?? 
)?? 
;?? 
mesh@@ 
.@@ 
Refresh@@ 
(@@ 
)@@ 
;@@ 
}AA 
elseBB 
{CC 
ProBuilderMeshDD 
mDD  
=DD! "
meshDD# '
;DD' (
SplineEE 
.EE 
ExtrudeEE 
(EE 
pointsEE %
,EE% &
radiusEE' -
,EE- .
columnsEE/ 6
,EE6 7
rowsEE8 <
,EE< =
	closeLoopEE> G
,EEG H
smoothEEI O
,EEO P
refEEQ T
mEEU V
)EEV W
;EEW X
}FF 
}GG 	
}HH 
}II œ

ãD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\RaycastHit.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed 

class 

RaycastHit 
{		 
public

 
float

 
distance

 
;

 
public 
Vector3 
point 
; 
public 
Vector3 
normal 
; 
public 
int 
face 
; 
public 

RaycastHit 
( 
float 
distance 
, 
Vector3 
point 
, 
Vector3 
normal 
, 
int 
face 
) 
{ 	
this 
. 
distance 
= 
distance $
;$ %
this 
. 
point 
= 
point 
; 
this 
. 
normal 
= 
normal  
;  !
this 
. 
face 
= 
face 
; 
} 	
} 
} ∏
çD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\AssemblyInfo.cs
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> _
)_ `
]` a
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> W
)W X
]X Y
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> V
)V W
]W X
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> `
)` a
]a b
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> [
)[ \
]\ ]
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> ]
)] ^
]^ _
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> ]
)] ^
]^ _
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> ^
)^ _
]_ `òL
ëD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\TransformUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public		 

static		 
class		 
TransformUtility		 (
{

 
static 

Dictionary 
< 
	Transform #
,# $
	Transform% .
[. /
]/ 0
>0 1
s_ChildStack2 >
=? @
newA D

DictionaryE O
<O P
	TransformP Y
,Y Z
	Transform[ d
[d e
]e f
>f g
(g h
)h i
;i j
internal 
static 
void 
UnparentChildren -
(- .
	Transform. 7
t8 9
)9 :
{ 	
	Transform 
[ 
] 
children  
=! "
new# &
	Transform' 0
[0 1
t1 2
.2 3

childCount3 =
]= >
;> ?
for 
( 
int 
i 
= 
t 
. 

childCount %
-& '
$num( )
;) *
i+ ,
>=- /
$num0 1
;1 2
--3 5
i5 6
)6 7
{ 
	Transform 
child 
=  !
t" #
.# $
GetChild$ ,
(, -
i- .
). /
;/ 0
children 
[ 
i 
] 
= 
child #
;# $
child 
. 
	SetParent 
(  
null  $
,$ %
true& *
)* +
;+ ,
} 
s_ChildStack 
. 
Add 
( 
t 
, 
children  (
)( )
;) *
} 	
internal## 
static## 
void## 
ReparentChildren## -
(##- .
	Transform##. 7
t##8 9
)##9 :
{$$ 	
	Transform%% 
[%% 
]%% 
children%%  
;%%  !
if'' 
('' 
s_ChildStack'' 
.'' 
TryGetValue'' (
(''( )
t'') *
,''* +
out'', /
children''0 8
)''8 9
)''9 :
{(( 
foreach)) 
()) 
	Transform)) "
c))# $
in))% '
children))( 0
)))0 1
c** 
.** 
	SetParent** 
(**  
t**  !
,**! "
true**# '
)**' (
;**( )
s_ChildStack,, 
.,, 
Remove,, #
(,,# $
t,,$ %
),,% &
;,,& '
}-- 
}.. 	
public66 
static66 
Vertex66 
TransformVertex66 ,
(66, -
this66- 1
	Transform662 ;
	transform66< E
,66E F
Vertex66G M
vertex66N T
)66T U
{77 	
var88 
v88 
=88 
new88 
Vertex88 
(88 
)88  
;88  !
if:: 
(:: 
vertex:: 
.:: 
	HasArrays::  
(::  !

MeshArrays::! +
.::+ ,
Position::, 4
)::4 5
)::5 6
v;; 
.;; 
position;; 
=;; 
	transform;; &
.;;& '
TransformPoint;;' 5
(;;5 6
vertex;;6 <
.;;< =
position;;= E
);;E F
;;;F G
if== 
(== 
vertex== 
.== 
	HasArrays==  
(==  !

MeshArrays==! +
.==+ ,
Color==, 1
)==1 2
)==2 3
v>> 
.>> 
color>> 
=>> 
vertex>>  
.>>  !
color>>! &
;>>& '
if@@ 
(@@ 
vertex@@ 
.@@ 
	HasArrays@@  
(@@  !

MeshArrays@@! +
.@@+ ,
Normal@@, 2
)@@2 3
)@@3 4
vAA 
.AA 
normalAA 
=AA 
	transformAA $
.AA$ %
TransformDirectionAA% 7
(AA7 8
vertexAA8 >
.AA> ?
normalAA? E
)AAE F
;AAF G
ifCC 
(CC 
vertexCC 
.CC 
	HasArraysCC  
(CC  !

MeshArraysCC! +
.CC+ ,
TangentCC, 3
)CC3 4
)CC4 5
vDD 
.DD 
tangentDD 
=DD 
	transformDD %
.DD% &
rotationDD& .
*DD/ 0
vertexDD1 7
.DD7 8
tangentDD8 ?
;DD? @
ifFF 
(FF 
vertexFF 
.FF 
	HasArraysFF  
(FF  !

MeshArraysFF! +
.FF+ ,
Texture0FF, 4
)FF4 5
)FF5 6
vGG 
.GG 
uv0GG 
=GG 
vertexGG 
.GG 
uv0GG "
;GG" #
ifII 
(II 
vertexII 
.II 
	HasArraysII  
(II  !

MeshArraysII! +
.II+ ,
Texture1II, 4
)II4 5
)II5 6
vJJ 
.JJ 
uv2JJ 
=JJ 
vertexJJ 
.JJ 
uv2JJ "
;JJ" #
ifLL 
(LL 
vertexLL 
.LL 
	HasArraysLL  
(LL  !

MeshArraysLL! +
.LL+ ,
Texture2LL, 4
)LL4 5
)LL5 6
vMM 
.MM 
uv3MM 
=MM 
vertexMM 
.MM 
uv3MM "
;MM" #
ifOO 
(OO 
vertexOO 
.OO 
	HasArraysOO  
(OO  !

MeshArraysOO! +
.OO+ ,
Texture3OO, 4
)OO4 5
)OO5 6
vPP 
.PP 
uv4PP 
=PP 
vertexPP 
.PP 
uv4PP "
;PP" #
returnRR 
vRR 
;RR 
}SS 	
public[[ 
static[[ 
Vertex[[ "
InverseTransformVertex[[ 3
([[3 4
this[[4 8
	Transform[[9 B
	transform[[C L
,[[L M
Vertex[[N T
vertex[[U [
)[[[ \
{\\ 	
var]] 
v]] 
=]] 
new]] 
Vertex]] 
(]] 
)]]  
;]]  !
if__ 
(__ 
vertex__ 
.__ 
	HasArrays__  
(__  !

MeshArrays__! +
.__+ ,
Position__, 4
)__4 5
)__5 6
v`` 
.`` 
position`` 
=`` 
	transform`` &
.``& '!
InverseTransformPoint``' <
(``< =
vertex``= C
.``C D
position``D L
)``L M
;``M N
ifbb 
(bb 
vertexbb 
.bb 
	HasArraysbb  
(bb  !

MeshArraysbb! +
.bb+ ,
Colorbb, 1
)bb1 2
)bb2 3
vcc 
.cc 
colorcc 
=cc 
vertexcc  
.cc  !
colorcc! &
;cc& '
ifee 
(ee 
vertexee 
.ee 
	HasArraysee  
(ee  !

MeshArraysee! +
.ee+ ,
Normalee, 2
)ee2 3
)ee3 4
vff 
.ff 
normalff 
=ff 
	transformff $
.ff$ %%
InverseTransformDirectionff% >
(ff> ?
vertexff? E
.ffE F
normalffF L
)ffL M
;ffM N
ifhh 
(hh 
vertexhh 
.hh 
	HasArrayshh  
(hh  !

MeshArrayshh! +
.hh+ ,
Tangenthh, 3
)hh3 4
)hh4 5
vii 
.ii 
tangentii 
=ii 
	transformii %
.ii% &%
InverseTransformDirectionii& ?
(ii? @
vertexii@ F
.iiF G
tangentiiG N
)iiN O
;iiO P
ifkk 
(kk 
vertexkk 
.kk 
	HasArrayskk  
(kk  !

MeshArrayskk! +
.kk+ ,
Texture0kk, 4
)kk4 5
)kk5 6
vll 
.ll 
uv0ll 
=ll 
vertexll 
.ll 
uv0ll "
;ll" #
ifnn 
(nn 
vertexnn 
.nn 
	HasArraysnn  
(nn  !

MeshArraysnn! +
.nn+ ,
Texture1nn, 4
)nn4 5
)nn5 6
voo 
.oo 
uv2oo 
=oo 
vertexoo 
.oo 
uv2oo "
;oo" #
ifqq 
(qq 
vertexqq 
.qq 
	HasArraysqq  
(qq  !

MeshArraysqq! +
.qq+ ,
Texture2qq, 4
)qq4 5
)qq5 6
vrr 
.rr 
uv3rr 
=rr 
vertexrr 
.rr 
uv3rr "
;rr" #
iftt 
(tt 
vertextt 
.tt 
	HasArraystt  
(tt  !

MeshArraystt! +
.tt+ ,
Texture3tt, 4
)tt4 5
)tt5 6
vuu 
.uu 
uv4uu 
=uu 
vertexuu 
.uu 
uv4uu "
;uu" #
returnww 
vww 
;ww 
}xx 	
}yy 
}zz ì!
åD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SimpleTuple.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

struct 
SimpleTuple 
< 
T1  
,  !
T2" $
>$ %
{		 
T1

 

m_Item1

 
;

 
T2 

m_Item2 
; 
public 
T1 
item1 
{ 	
get 
{ 
return 
m_Item1  
;  !
}" #
set 
{ 
m_Item1 
= 
value !
;! "
}# $
} 	
public 
T2 
item2 
{ 	
get 
{ 
return 
m_Item2  
;  !
}" #
set 
{ 
m_Item2 
= 
value !
;! "
}# $
} 	
public 
SimpleTuple 
( 
T1 
item1 #
,# $
T2% '
item2( -
)- .
{ 	
m_Item1 
= 
item1 
; 
m_Item2 
= 
item2 
; 
} 	
public 
override 
string 
ToString '
(' (
)( )
{   	
return!! 
string!! 
.!! 
Format!!  
(!!  !
$str!!! +
,!!+ ,
item1!!- 2
.!!2 3
ToString!!3 ;
(!!; <
)!!< =
,!!= >
item2!!? D
.!!D E
ToString!!E M
(!!M N
)!!N O
)!!O P
;!!P Q
}"" 	
}## 
struct++ 

SimpleTuple++ 
<++ 
T1++ 
,++ 
T2++ 
,++ 
T3++ !
>++! "
{,, 
T1-- 

m_Item1-- 
;-- 
T2.. 

m_Item2.. 
;.. 
T3// 

m_Item3// 
;// 
public11 
T111 
item111 
{22 	
get33 
{33 
return33 
m_Item133  
;33  !
}33" #
set44 
{44 
m_Item144 
=44 
value44 !
;44! "
}44# $
}55 	
public77 
T277 
item277 
{88 	
get99 
{99 
return99 
m_Item299  
;99  !
}99" #
set:: 
{:: 
m_Item2:: 
=:: 
value:: !
;::! "
}::# $
};; 	
public== 
T3== 
item3== 
{>> 	
get?? 
{?? 
return?? 
m_Item3??  
;??  !
}??" #
set@@ 
{@@ 
m_Item3@@ 
=@@ 
value@@ !
;@@! "
}@@# $
}AA 	
publicCC 
SimpleTupleCC 
(CC 
T1CC 
item1CC #
,CC# $
T2CC% '
item2CC( -
,CC- .
T3CC/ 1
item3CC2 7
)CC7 8
{DD 	
m_Item1EE 
=EE 
item1EE 
;EE 
m_Item2FF 
=FF 
item2FF 
;FF 
m_Item3GG 
=GG 
item3GG 
;GG 
}HH 	
publicJJ 
overrideJJ 
stringJJ 
ToStringJJ '
(JJ' (
)JJ( )
{KK 	
returnLL 
stringLL 
.LL 
FormatLL  
(LL  !
$strLL! 0
,LL0 1
item1LL2 7
.LL7 8
ToStringLL8 @
(LL@ A
)LLA B
,LLB C
item2LLD I
.LLI J
ToStringLLJ R
(LLR S
)LLS T
,LLT U
item3LLV [
.LL[ \
ToStringLL\ d
(LLd e
)LLe f
)LLf g
;LLg h
}MM 	
}NN 
}OO Ü
èD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ShapeGenerator.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public

 

enum

 
	ShapeType

 
{ 
Cube 
, 
Stair 
, 
CurvedStair 
, 
Prism 
, 
Cylinder 
, 
Plane## 
,## 
Door'' 
,'' 
Pipe++ 
,++ 
Cone// 
,// 
Sprite33 
,33 
Arch77 
,77 
Sphere;; 
,;; 
TorusBB 
}CC 
publicHH 

enumHH 
PivotLocationHH 
{II 
CenterJJ 
,JJ 
FirstVertexKK 
}LL 
publicQQ 

staticQQ 
classQQ 
ShapeGeneratorQQ &
{RR 
staticSS 
readonlySS 
Vector3SS 
[SS  
]SS  !
k_IcosphereVerticesSS" 5
=SS6 7
newSS8 ;
Vector3SS< C
[SSC D
$numSSD F
]SSF G
{TT 	
newUU 
Vector3UU 
(UU 
-UU 
$numUU 
,UU 
MathUU "
.UU" #
phiUU# &
,UU& '
$numUU) +
)UU+ ,
,UU, -
newVV 
Vector3VV 
(VV 
$numVV 
,VV 
MathVV !
.VV! "
phiVV" %
,VV% &
$numVV( *
)VV* +
,VV+ ,
newWW 
Vector3WW 
(WW 
-WW 
$numWW 
,WW 
-WW 
MathWW "
.WW" #
phiWW# &
,WW& '
$numWW) +
)WW+ ,
,WW, -
newXX 
Vector3XX 
(XX 
$numXX 
,XX 
-XX 
MathXX !
.XX! "
phiXX" %
,XX% &
$numXX( *
)XX* +
,XX+ ,
newZZ 
Vector3ZZ 
(ZZ 
$numZZ 
,ZZ 
-ZZ 
$numZZ 
,ZZ  
MathZZ" &
.ZZ& '
phiZZ' *
)ZZ* +
,ZZ+ ,
new[[ 
Vector3[[ 
([[ 
$num[[ 
,[[ 
$num[[ 
,[[  
Math[[" &
.[[& '
phi[[' *
)[[* +
,[[+ ,
new\\ 
Vector3\\ 
(\\ 
$num\\ 
,\\ 
-\\ 
$num\\ 
,\\  
-\\! "
Math\\" &
.\\& '
phi\\' *
)\\* +
,\\+ ,
new]] 
Vector3]] 
(]] 
$num]] 
,]] 
$num]] 
,]]  
-]]! "
Math]]" &
.]]& '
phi]]' *
)]]* +
,]]+ ,
new__ 
Vector3__ 
(__ 
Math__ 
.__ 
phi__  
,__  !
$num__" $
,__$ %
-__& '
$num__' )
)__) *
,__* +
new`` 
Vector3`` 
(`` 
Math`` 
.`` 
phi``  
,``  !
$num``" $
,``$ %
$num``' )
)``) *
,``* +
newaa 
Vector3aa 
(aa 
-aa 
Mathaa 
.aa 
phiaa !
,aa! "
$numaa# %
,aa% &
-aa' (
$numaa( *
)aa* +
,aa+ ,
newbb 
Vector3bb 
(bb 
-bb 
Mathbb 
.bb 
phibb !
,bb! "
$numbb# %
,bb% &
$numbb( *
)bb* +
}cc 	
;cc	 

staticee 
readonlyee 
intee 
[ee 
]ee  
k_IcosphereTrianglesee 2
=ee3 4
newee5 8
intee9 <
[ee< =
$numee= ?
]ee? @
{ff 	
$numgg 
,gg 
$numgg 
,gg 
$numgg 
,gg 
$numhh 
,hh 
$numhh 
,hh 
$numhh 
,hh 
$numii 
,ii 
$numii 
,ii 
$numii 
,ii 
$numjj 
,jj 
$numjj 
,jj 
$numjj 
,jj 
$numkk 
,kk 
$numkk 
,kk 
$numkk 
,kk 
$nummm 
,mm 
$nummm 
,mm 
$nummm 
,mm 
$numnn 
,nn 
$numnn 
,nn 
$numnn 
,nn 
$numoo 
,oo 
$numoo 
,oo 
$numoo 
,oo 
$numpp 
,pp 
$numpp 
,pp 
$numpp 
,pp 
$numqq 
,qq 
$numqq 
,qq 
$numqq 
,qq 
$numss 
,ss 
$numss 
,ss 
$numss 
,ss 
$numtt 
,tt 
$numtt 
,tt 
$numtt 
,tt 
$numuu 
,uu 
$numuu 
,uu 
$numuu 
,uu 
$numvv 
,vv 
$numvv 
,vv 
$numvv 
,vv 
$numww 
,ww 
$numww 
,ww 
$numww 
,ww 
$numyy 
,yy 
$numyy 
,yy 
$numyy 
,yy 
$numzz 
,zz 
$numzz 
,zz 
$numzz 
,zz 
$num{{ 
,{{ 
$num{{ 
,{{ 
$num{{ 
,{{ 
$num|| 
,|| 
$num|| 
,|| 
$num|| 
,|| 
$num}} 
,}} 
$num}} 
,}} 
$num}} 
}~~ 	
;~~	 

static
ÉÉ 
readonly
ÉÉ 
Vector3
ÉÉ 
[
ÉÉ  
]
ÉÉ  !
k_CubeVertices
ÉÉ" 0
=
ÉÉ1 2
new
ÉÉ3 6
Vector3
ÉÉ7 >
[
ÉÉ> ?
]
ÉÉ? @
{
ÉÉA B
new
ÖÖ 
Vector3
ÖÖ 
(
ÖÖ 
-
ÖÖ 
$num
ÖÖ 
,
ÖÖ 
-
ÖÖ 
$num
ÖÖ "
,
ÖÖ" #
$num
ÖÖ$ '
)
ÖÖ' (
,
ÖÖ( )
new
ÜÜ 
Vector3
ÜÜ 
(
ÜÜ 
$num
ÜÜ 
,
ÜÜ 
-
ÜÜ 
$num
ÜÜ !
,
ÜÜ! "
$num
ÜÜ# &
)
ÜÜ& '
,
ÜÜ' (
new
áá 
Vector3
áá 
(
áá 
$num
áá 
,
áá 
-
áá 
$num
áá !
,
áá! "
-
áá# $
$num
áá$ '
)
áá' (
,
áá( )
new
àà 
Vector3
àà 
(
àà 
-
àà 
$num
àà 
,
àà 
-
àà 
$num
àà "
,
àà" #
-
àà$ %
$num
àà% (
)
àà( )
,
àà) *
new
ãã 
Vector3
ãã 
(
ãã 
-
ãã 
$num
ãã 
,
ãã 
$num
ãã !
,
ãã! "
$num
ãã# &
)
ãã& '
,
ãã' (
new
åå 
Vector3
åå 
(
åå 
$num
åå 
,
åå 
$num
åå  
,
åå  !
$num
åå" %
)
åå% &
,
åå& '
new
çç 
Vector3
çç 
(
çç 
$num
çç 
,
çç 
$num
çç  
,
çç  !
-
çç" #
$num
çç# &
)
çç& '
,
çç' (
new
éé 
Vector3
éé 
(
éé 
-
éé 
$num
éé 
,
éé 
$num
éé !
,
éé! "
-
éé# $
$num
éé$ '
)
éé' (
}
èè 	
;
èè	 

static
îî 
readonly
îî 
int
îî 
[
îî 
]
îî 
k_CubeTriangles
îî -
=
îî. /
new
îî0 3
int
îî4 7
[
îî7 8
]
îî8 9
{
îî: ;
$num
ïï 
,
ïï 
$num
ïï 
,
ïï 
$num
ïï 
,
ïï 
$num
ïï 
,
ïï 
$num
ïï 
,
ïï 
$num
ïï 
,
ïï 
$num
ïï 
,
ïï  
$num
ïï! "
,
ïï" #
$num
ïï$ %
,
ïï% &
$num
ïï' (
,
ïï( )
$num
ïï* +
,
ïï+ ,
$num
ïï- .
,
ïï. /
$num
ïï0 1
,
ïï1 2
$num
ïï3 4
,
ïï4 5
$num
ïï6 7
,
ïï7 8
$num
ïï9 :
,
ïï: ;
$num
ïï< =
,
ïï= >
$num
ïï? @
,
ïï@ A
$num
ïïB C
,
ïïC D
$num
ïïE F
,
ïïF G
$num
ïïH I
,
ïïI J
$num
ïïK L
,
ïïL M
$num
ïïN O
,
ïïO P
$num
ïïQ R
}
ññ 	
;
ññ	 

public
ûû 
static
ûû 
ProBuilderMesh
ûû $
CreateShape
ûû% 0
(
ûû0 1
	ShapeType
ûû1 :
shape
ûû; @
,
ûû@ A
PivotLocation
ûûB O
	pivotType
ûûP Y
=
ûûZ [
PivotLocation
ûû\ i
.
ûûi j
Center
ûûj p
)
ûûp q
{
üü 	
ProBuilderMesh
†† 
pb
†† 
=
†† 
null
††  $
;
††$ %
if
¢¢ 
(
¢¢ 
shape
¢¢ 
==
¢¢ 
	ShapeType
¢¢ "
.
¢¢" #
Cube
¢¢# '
)
¢¢' (
pb
££ 
=
££ 
GenerateCube
££ !
(
££! "
	pivotType
££" +
,
££+ ,
Vector3
££- 4
.
££4 5
one
££5 8
)
££8 9
;
££9 :
if
§§ 
(
§§ 
shape
§§ 
==
§§ 
	ShapeType
§§ "
.
§§" #
Stair
§§# (
)
§§( )
pb
•• 
=
•• 
GenerateStair
•• "
(
••" #
	pivotType
••# ,
,
••, -
new
••. 1
Vector3
••2 9
(
••9 :
$num
••: <
,
••< =
$num
••> B
,
••B C
$num
••D F
)
••F G
,
••G H
$num
••I J
,
••J K
true
••L P
)
••P Q
;
••Q R
if
¶¶ 
(
¶¶ 
shape
¶¶ 
==
¶¶ 
	ShapeType
¶¶ "
.
¶¶" #
CurvedStair
¶¶# .
)
¶¶. /
pb
ßß 
=
ßß !
GenerateCurvedStair
ßß (
(
ßß( )
	pivotType
ßß) 2
,
ßß2 3
$num
ßß4 6
,
ßß6 7
$num
ßß8 <
,
ßß< =
$num
ßß> @
,
ßß@ A
$num
ßßB F
,
ßßF G
$num
ßßH I
,
ßßI J
true
ßßK O
)
ßßO P
;
ßßP Q
if
®® 
(
®® 
shape
®® 
==
®® 
	ShapeType
®® "
.
®®" #
Prism
®®# (
)
®®( )
pb
©© 
=
©© 
GeneratePrism
©© "
(
©©" #
	pivotType
©©# ,
,
©©, -
Vector3
©©. 5
.
©©5 6
one
©©6 9
)
©©9 :
;
©©: ;
if
™™ 
(
™™ 
shape
™™ 
==
™™ 
	ShapeType
™™ "
.
™™" #
Cylinder
™™# +
)
™™+ ,
pb
´´ 
=
´´ 
GenerateCylinder
´´ %
(
´´% &
	pivotType
´´& /
,
´´/ 0
$num
´´1 2
,
´´2 3
$num
´´4 6
,
´´6 7
$num
´´8 :
,
´´: ;
$num
´´< =
)
´´= >
;
´´> ?
if
¨¨ 
(
¨¨ 
shape
¨¨ 
==
¨¨ 
	ShapeType
¨¨ "
.
¨¨" #
Plane
¨¨# (
)
¨¨( )
pb
≠≠ 
=
≠≠ 
GeneratePlane
≠≠ "
(
≠≠" #
	pivotType
≠≠# ,
,
≠≠, -
$num
≠≠. 0
,
≠≠0 1
$num
≠≠2 4
,
≠≠4 5
$num
≠≠6 7
,
≠≠7 8
$num
≠≠9 :
,
≠≠: ;
Axis
≠≠< @
.
≠≠@ A
Up
≠≠A C
)
≠≠C D
;
≠≠D E
if
ÆÆ 
(
ÆÆ 
shape
ÆÆ 
==
ÆÆ 
	ShapeType
ÆÆ "
.
ÆÆ" #
Door
ÆÆ# '
)
ÆÆ' (
pb
ØØ 
=
ØØ 
GenerateDoor
ØØ !
(
ØØ! "
	pivotType
ØØ" +
,
ØØ+ ,
$num
ØØ- /
,
ØØ/ 0
$num
ØØ1 5
,
ØØ5 6
$num
ØØ7 :
,
ØØ: ;
$num
ØØ< @
,
ØØ@ A
$num
ØØB D
)
ØØD E
;
ØØE F
if
∞∞ 
(
∞∞ 
shape
∞∞ 
==
∞∞ 
	ShapeType
∞∞ "
.
∞∞" #
Pipe
∞∞# '
)
∞∞' (
pb
±± 
=
±± 
GeneratePipe
±± !
(
±±! "
	pivotType
±±" +
,
±±+ ,
$num
±±- /
,
±±/ 0
$num
±±1 3
,
±±3 4
$num
±±5 9
,
±±9 :
$num
±±; <
,
±±< =
$num
±±> ?
)
±±? @
;
±±@ A
if
≤≤ 
(
≤≤ 
shape
≤≤ 
==
≤≤ 
	ShapeType
≤≤ "
.
≤≤" #
Cone
≤≤# '
)
≤≤' (
pb
≥≥ 
=
≥≥ 
GenerateCone
≥≥ !
(
≥≥! "
	pivotType
≥≥" +
,
≥≥+ ,
$num
≥≥- 0
,
≥≥0 1
$num
≥≥2 4
,
≥≥4 5
$num
≥≥6 7
)
≥≥7 8
;
≥≥8 9
if
¥¥ 
(
¥¥ 
shape
¥¥ 
==
¥¥ 
	ShapeType
¥¥ "
.
¥¥" #
Sprite
¥¥# )
)
¥¥) *
pb
µµ 
=
µµ 
GeneratePlane
µµ "
(
µµ" #
	pivotType
µµ# ,
,
µµ, -
$num
µµ. 0
,
µµ0 1
$num
µµ2 4
,
µµ4 5
$num
µµ6 7
,
µµ7 8
$num
µµ9 :
,
µµ: ;
Axis
µµ< @
.
µµ@ A
Up
µµA C
)
µµC D
;
µµD E
if
∂∂ 
(
∂∂ 
shape
∂∂ 
==
∂∂ 
	ShapeType
∂∂ "
.
∂∂" #
Arch
∂∂# '
)
∂∂' (
pb
∑∑ 
=
∑∑ 
GenerateArch
∑∑ !
(
∑∑! "
	pivotType
∑∑" +
,
∑∑+ ,
$num
∑∑- 1
,
∑∑1 2
$num
∑∑3 5
,
∑∑5 6
$num
∑∑7 9
,
∑∑9 :
$num
∑∑; =
,
∑∑= >
$num
∑∑? @
,
∑∑@ A
true
∑∑B F
,
∑∑F G
true
∑∑H L
,
∑∑L M
true
∑∑N R
,
∑∑R S
true
∑∑T X
,
∑∑X Y
true
∑∑Z ^
)
∑∑^ _
;
∑∑_ `
if
∏∏ 
(
∏∏ 
shape
∏∏ 
==
∏∏ 
	ShapeType
∏∏ "
.
∏∏" #
Sphere
∏∏# )
)
∏∏) *
pb
ππ 
=
ππ !
GenerateIcosahedron
ππ (
(
ππ( )
	pivotType
ππ) 2
,
ππ2 3
$num
ππ4 7
,
ππ7 8
$num
ππ9 :
,
ππ: ;
true
ππ< @
,
ππ@ A
false
ππB G
)
ππG H
;
ππH I
if
∫∫ 
(
∫∫ 
shape
∫∫ 
==
∫∫ 
	ShapeType
∫∫ "
.
∫∫" #
Torus
∫∫# (
)
∫∫( )
{
ªª 
pb
ºº 
=
ºº 
GenerateTorus
ºº "
(
ºº" #
	pivotType
ºº# ,
,
ºº, -
$num
ºº. 0
,
ºº0 1
$num
ºº2 4
,
ºº4 5
$num
ºº6 8
,
ºº8 9
$num
ºº: =
,
ºº= >
true
ºº? C
,
ººC D
$num
ººE I
,
ººI J
$num
ººK O
,
ººO P
true
ººQ U
)
ººU V
;
ººV W
	UVEditing
ΩΩ 
.
ΩΩ 
ProjectFacesBox
ΩΩ )
(
ΩΩ) *
pb
ΩΩ* ,
,
ΩΩ, -
pb
ΩΩ. 0
.
ΩΩ0 1
facesInternal
ΩΩ1 >
)
ΩΩ> ?
;
ΩΩ? @
}
ææ 
if
¿¿ 
(
¿¿ 
pb
¿¿ 
==
¿¿ 
null
¿¿ 
)
¿¿ 
{
¡¡ 
Log
√√ 
.
√√ 
Error
√√ 
(
√√ 
shape
√√ 
.
√√  
ToString
√√  (
(
√√( )
)
√√) *
+
√√+ ,
$str
√√- D
)
√√D E
;
√√E F
pb
≈≈ 
=
≈≈ 
GenerateCube
≈≈ !
(
≈≈! "
	pivotType
≈≈" +
,
≈≈+ ,
Vector3
≈≈- 4
.
≈≈4 5
one
≈≈5 8
)
≈≈8 9
;
≈≈9 :
}
∆∆ 
pb
»» 
.
»» 

gameObject
»» 
.
»» 
name
»» 
=
»»  
shape
»»! &
.
»»& '
ToString
»»' /
(
»»/ 0
)
»»0 1
;
»»1 2
pb
…… 
.
…… 
renderer
…… 
.
…… 
sharedMaterial
…… &
=
……' (
BuiltinMaterials
……) 9
.
……9 :
defaultMaterial
……: I
;
……I J
return
ÀÀ 
pb
ÀÀ 
;
ÀÀ 
}
ÃÃ 	
public
÷÷ 
static
÷÷ 
ProBuilderMesh
÷÷ $
GenerateStair
÷÷% 2
(
÷÷2 3
PivotLocation
÷÷3 @
	pivotType
÷÷A J
,
÷÷J K
Vector3
÷÷L S
size
÷÷T X
,
÷÷X Y
int
÷÷Z ]
steps
÷÷^ c
,
÷÷c d
bool
÷÷e i

buildSides
÷÷j t
)
÷÷t u
{
◊◊ 	
Vector3
ŸŸ 
[
ŸŸ 
]
ŸŸ 
vertices
ŸŸ 
=
ŸŸ  
new
ŸŸ! $
Vector3
ŸŸ% ,
[
ŸŸ, -
$num
ŸŸ- .
*
ŸŸ/ 0
steps
ŸŸ1 6
*
ŸŸ7 8
$num
ŸŸ9 :
]
ŸŸ: ;
;
ŸŸ; <
Face
⁄⁄ 
[
⁄⁄ 
]
⁄⁄ 
faces
⁄⁄ 
=
⁄⁄ 
new
⁄⁄ 
Face
⁄⁄ #
[
⁄⁄# $
steps
⁄⁄$ )
*
⁄⁄* +
$num
⁄⁄, -
]
⁄⁄- .
;
⁄⁄. /
int
›› 
v
›› 
=
›› 
$num
›› 
,
›› 
t
›› 
=
›› 
$num
›› 
;
›› 
for
ﬂﬂ 
(
ﬂﬂ 
int
ﬂﬂ 
i
ﬂﬂ 
=
ﬂﬂ 
$num
ﬂﬂ 
;
ﬂﬂ 
i
ﬂﬂ 
<
ﬂﬂ 
steps
ﬂﬂ  %
;
ﬂﬂ% &
i
ﬂﬂ' (
++
ﬂﬂ( *
)
ﬂﬂ* +
{
‡‡ 
float
·· 
inc0
·· 
=
·· 
i
·· 
/
··  
(
··! "
float
··" '
)
··' (
steps
··( -
;
··- .
float
‚‚ 
inc1
‚‚ 
=
‚‚ 
(
‚‚ 
i
‚‚ 
+
‚‚  !
$num
‚‚" #
)
‚‚# $
/
‚‚% &
(
‚‚' (
float
‚‚( -
)
‚‚- .
steps
‚‚. 3
;
‚‚3 4
float
‰‰ 
x0
‰‰ 
=
‰‰ 
size
‰‰ 
.
‰‰  
x
‰‰  !
;
‰‰! "
float
ÂÂ 
x1
ÂÂ 
=
ÂÂ 
$num
ÂÂ 
;
ÂÂ 
float
ÊÊ 
y0
ÊÊ 
=
ÊÊ 
size
ÊÊ 
.
ÊÊ  
y
ÊÊ  !
*
ÊÊ" #
inc0
ÊÊ$ (
;
ÊÊ( )
float
ÁÁ 
y1
ÁÁ 
=
ÁÁ 
size
ÁÁ 
.
ÁÁ  
y
ÁÁ  !
*
ÁÁ" #
inc1
ÁÁ$ (
;
ÁÁ( )
float
ËË 
z0
ËË 
=
ËË 
size
ËË 
.
ËË  
z
ËË  !
*
ËË" #
inc0
ËË$ (
;
ËË( )
float
ÈÈ 
z1
ÈÈ 
=
ÈÈ 
size
ÈÈ 
.
ÈÈ  
z
ÈÈ  !
*
ÈÈ" #
inc1
ÈÈ$ (
;
ÈÈ( )
vertices
ÎÎ 
[
ÎÎ 
v
ÎÎ 
+
ÎÎ 
$num
ÎÎ 
]
ÎÎ 
=
ÎÎ  !
new
ÎÎ" %
Vector3
ÎÎ& -
(
ÎÎ- .
x0
ÎÎ. 0
,
ÎÎ0 1
y0
ÎÎ2 4
,
ÎÎ4 5
z0
ÎÎ6 8
)
ÎÎ8 9
;
ÎÎ9 :
vertices
ÏÏ 
[
ÏÏ 
v
ÏÏ 
+
ÏÏ 
$num
ÏÏ 
]
ÏÏ 
=
ÏÏ  !
new
ÏÏ" %
Vector3
ÏÏ& -
(
ÏÏ- .
x1
ÏÏ. 0
,
ÏÏ0 1
y0
ÏÏ2 4
,
ÏÏ4 5
z0
ÏÏ6 8
)
ÏÏ8 9
;
ÏÏ9 :
vertices
ÌÌ 
[
ÌÌ 
v
ÌÌ 
+
ÌÌ 
$num
ÌÌ 
]
ÌÌ 
=
ÌÌ  !
new
ÌÌ" %
Vector3
ÌÌ& -
(
ÌÌ- .
x0
ÌÌ. 0
,
ÌÌ0 1
y1
ÌÌ2 4
,
ÌÌ4 5
z0
ÌÌ6 8
)
ÌÌ8 9
;
ÌÌ9 :
vertices
ÓÓ 
[
ÓÓ 
v
ÓÓ 
+
ÓÓ 
$num
ÓÓ 
]
ÓÓ 
=
ÓÓ  !
new
ÓÓ" %
Vector3
ÓÓ& -
(
ÓÓ- .
x1
ÓÓ. 0
,
ÓÓ0 1
y1
ÓÓ2 4
,
ÓÓ4 5
z0
ÓÓ6 8
)
ÓÓ8 9
;
ÓÓ9 :
vertices
 
[
 
v
 
+
 
$num
 
]
 
=
  !
new
" %
Vector3
& -
(
- .
x0
. 0
,
0 1
y1
2 4
,
4 5
z0
6 8
)
8 9
;
9 :
vertices
ÒÒ 
[
ÒÒ 
v
ÒÒ 
+
ÒÒ 
$num
ÒÒ 
]
ÒÒ 
=
ÒÒ  !
new
ÒÒ" %
Vector3
ÒÒ& -
(
ÒÒ- .
x1
ÒÒ. 0
,
ÒÒ0 1
y1
ÒÒ2 4
,
ÒÒ4 5
z0
ÒÒ6 8
)
ÒÒ8 9
;
ÒÒ9 :
vertices
ÚÚ 
[
ÚÚ 
v
ÚÚ 
+
ÚÚ 
$num
ÚÚ 
]
ÚÚ 
=
ÚÚ  !
new
ÚÚ" %
Vector3
ÚÚ& -
(
ÚÚ- .
x0
ÚÚ. 0
,
ÚÚ0 1
y1
ÚÚ2 4
,
ÚÚ4 5
z1
ÚÚ6 8
)
ÚÚ8 9
;
ÚÚ9 :
vertices
ÛÛ 
[
ÛÛ 
v
ÛÛ 
+
ÛÛ 
$num
ÛÛ 
]
ÛÛ 
=
ÛÛ  !
new
ÛÛ" %
Vector3
ÛÛ& -
(
ÛÛ- .
x1
ÛÛ. 0
,
ÛÛ0 1
y1
ÛÛ2 4
,
ÛÛ4 5
z1
ÛÛ6 8
)
ÛÛ8 9
;
ÛÛ9 :
faces
ıı 
[
ıı 
t
ıı 
+
ıı 
$num
ıı 
]
ıı 
=
ıı 
new
ıı "
Face
ıı# '
(
ıı' (
new
ıı( +
int
ıı, /
[
ıı/ 0
]
ıı0 1
{
ıı2 3
v
ıı5 6
+
ıı7 8
$num
ıı9 :
,
ıı: ;
v
ˆˆ5 6
+
ˆˆ7 8
$num
ˆˆ9 :
,
ˆˆ: ;
v
˜˜5 6
+
˜˜7 8
$num
˜˜9 :
,
˜˜: ;
v
¯¯5 6
+
¯¯7 8
$num
¯¯9 :
,
¯¯: ;
v
˘˘5 6
+
˘˘7 8
$num
˘˘9 :
,
˘˘: ;
v
˙˙5 6
+
˙˙7 8
$num
˙˙9 :
}
˙˙; <
)
˙˙< =
;
˙˙= >
faces
¸¸ 
[
¸¸ 
t
¸¸ 
+
¸¸ 
$num
¸¸ 
]
¸¸ 
=
¸¸ 
new
¸¸ "
Face
¸¸# '
(
¸¸' (
new
¸¸( +
int
¸¸, /
[
¸¸/ 0
]
¸¸0 1
{
¸¸2 3
v
¸¸5 6
+
¸¸7 8
$num
¸¸9 :
,
¸¸: ;
v
˝˝5 6
+
˝˝7 8
$num
˝˝9 :
,
˝˝: ;
v
˛˛5 6
+
˛˛7 8
$num
˛˛9 :
,
˛˛: ;
v
ˇˇ5 6
+
ˇˇ7 8
$num
ˇˇ9 :
,
ˇˇ: ;
v
ÄÄ5 6
+
ÄÄ7 8
$num
ÄÄ9 :
,
ÄÄ: ;
v
ÅÅ5 6
+
ÅÅ7 8
$num
ÅÅ9 :
}
ÅÅ; <
)
ÅÅ< =
;
ÅÅ= >
v
ÉÉ 
+=
ÉÉ 
$num
ÉÉ 
;
ÉÉ 
t
ÑÑ 
+=
ÑÑ 
$num
ÑÑ 
;
ÑÑ 
}
ÖÖ 
if
àà 
(
àà 

buildSides
àà 
)
àà 
{
ââ 
float
åå 
x
åå 
=
åå 
$num
åå 
;
åå 
for
éé 
(
éé 
int
éé 
side
éé 
=
éé 
$num
éé  !
;
éé! "
side
éé# '
<
éé( )
$num
éé* +
;
éé+ ,
side
éé- 1
++
éé1 3
)
éé3 4
{
èè 
Vector3
êê 
[
êê 
]
êê 
sides_v
êê %
=
êê& '
new
êê( +
Vector3
êê, 3
[
êê3 4
steps
êê4 9
*
êê: ;
$num
êê< =
+
êê> ?
(
êê@ A
steps
êêA F
-
êêG H
$num
êêI J
)
êêJ K
*
êêL M
$num
êêN O
]
êêO P
;
êêP Q
Face
ëë 
[
ëë 
]
ëë 
sides_f
ëë "
=
ëë# $
new
ëë% (
Face
ëë) -
[
ëë- .
steps
ëë. 3
+
ëë4 5
steps
ëë6 ;
-
ëë< =
$num
ëë> ?
]
ëë? @
;
ëë@ A
int
ìì 
sv
ìì 
=
ìì 
$num
ìì 
,
ìì 
st
ìì  "
=
ìì# $
$num
ìì% &
;
ìì& '
for
ïï 
(
ïï 
int
ïï 
i
ïï 
=
ïï  
$num
ïï! "
;
ïï" #
i
ïï$ %
<
ïï& '
steps
ïï( -
;
ïï- .
i
ïï/ 0
++
ïï0 2
)
ïï2 3
{
ññ 
float
óó 
y0
óó  
=
óó! "
(
óó# $
Mathf
óó$ )
.
óó) *
Max
óó* -
(
óó- .
i
óó. /
,
óó/ 0
$num
óó1 2
)
óó2 3
/
óó4 5
(
óó6 7
float
óó7 <
)
óó< =
steps
óó= B
)
óóB C
*
óóD E
size
óóF J
.
óóJ K
y
óóK L
;
óóL M
float
òò 
y1
òò  
=
òò! "
(
òò# $
(
òò$ %
i
òò% &
+
òò' (
$num
òò) *
)
òò* +
/
òò, -
(
òò. /
float
òò/ 4
)
òò4 5
steps
òò5 :
)
òò: ;
*
òò< =
size
òò> B
.
òòB C
y
òòC D
;
òòD E
float
öö 
z0
öö  
=
öö! "
(
öö# $
i
öö$ %
/
öö& '
(
öö( )
float
öö) .
)
öö. /
steps
öö/ 4
)
öö4 5
*
öö6 7
size
öö8 <
.
öö< =
z
öö= >
;
öö> ?
float
õõ 
z1
õõ  
=
õõ! "
(
õõ# $
(
õõ$ %
i
õõ% &
+
õõ' (
$num
õõ) *
)
õõ* +
/
õõ, -
(
õõ. /
float
õõ/ 4
)
õõ4 5
steps
õõ5 :
)
õõ: ;
*
õõ< =
size
õõ> B
.
õõB C
z
õõC D
;
õõD E
sides_v
ùù 
[
ùù  
sv
ùù  "
+
ùù# $
$num
ùù% &
]
ùù& '
=
ùù( )
new
ùù* -
Vector3
ùù. 5
(
ùù5 6
x
ùù6 7
,
ùù7 8
$num
ùù9 ;
,
ùù; <
z0
ùù= ?
)
ùù? @
;
ùù@ A
sides_v
ûû 
[
ûû  
sv
ûû  "
+
ûû# $
$num
ûû% &
]
ûû& '
=
ûû( )
new
ûû* -
Vector3
ûû. 5
(
ûû5 6
x
ûû6 7
,
ûû7 8
$num
ûû9 ;
,
ûû; <
z1
ûû= ?
)
ûû? @
;
ûû@ A
sides_v
üü 
[
üü  
sv
üü  "
+
üü# $
$num
üü% &
]
üü& '
=
üü( )
new
üü* -
Vector3
üü. 5
(
üü5 6
x
üü6 7
,
üü7 8
y0
üü9 ;
,
üü; <
z0
üü= ?
)
üü? @
;
üü@ A
sides_v
†† 
[
††  
sv
††  "
+
††# $
$num
††% &
]
††& '
=
††( )
new
††* -
Vector3
††. 5
(
††5 6
x
††6 7
,
††7 8
y1
††9 ;
,
††; <
z1
††= ?
)
††? @
;
††@ A
sides_f
¢¢ 
[
¢¢  
st
¢¢  "
++
¢¢" $
]
¢¢$ %
=
¢¢& '
new
¢¢( +
Face
¢¢, 0
(
¢¢0 1
side
¢¢1 5
%
¢¢6 7
$num
¢¢8 9
==
¢¢: <
$num
¢¢= >
?
¢¢? @
new
££  #
int
££$ '
[
££' (
]
££( )
{
££* +
v
££, -
+
££. /
$num
££0 1
,
££1 2
v
££3 4
+
££5 6
$num
££7 8
,
££8 9
v
££: ;
+
££< =
$num
££> ?
,
££? @
v
££A B
+
££C D
$num
££E F
,
££F G
v
££H I
+
££J K
$num
££L M
,
££M N
v
££O P
+
££Q R
$num
££S T
}
££U V
:
££W X
new
§§  #
int
§§$ '
[
§§' (
]
§§( )
{
§§* +
v
§§, -
+
§§. /
$num
§§0 1
,
§§1 2
v
§§3 4
+
§§5 6
$num
§§7 8
,
§§8 9
v
§§: ;
+
§§< =
$num
§§> ?
,
§§? @
v
§§A B
+
§§C D
$num
§§E F
,
§§F G
v
§§H I
+
§§J K
$num
§§L M
,
§§M N
v
§§O P
+
§§Q R
$num
§§S T
}
§§U V
)
§§V W
;
§§W X
sides_f
¶¶ 
[
¶¶  
st
¶¶  "
-
¶¶# $
$num
¶¶% &
]
¶¶& '
.
¶¶' (
textureGroup
¶¶( 4
=
¶¶5 6
side
¶¶7 ;
+
¶¶< =
$num
¶¶> ?
;
¶¶? @
v
®® 
+=
®® 
$num
®® 
;
®® 
sv
©© 
+=
©© 
$num
©© 
;
©©  
if
¨¨ 
(
¨¨ 
i
¨¨ 
>
¨¨ 
$num
¨¨  !
)
¨¨! "
{
≠≠ 
sides_v
ÆÆ #
[
ÆÆ# $
sv
ÆÆ$ &
+
ÆÆ' (
$num
ÆÆ) *
]
ÆÆ* +
=
ÆÆ, -
new
ÆÆ. 1
Vector3
ÆÆ2 9
(
ÆÆ9 :
x
ÆÆ: ;
,
ÆÆ; <
y0
ÆÆ= ?
,
ÆÆ? @
z0
ÆÆA C
)
ÆÆC D
;
ÆÆD E
sides_v
ØØ #
[
ØØ# $
sv
ØØ$ &
+
ØØ' (
$num
ØØ) *
]
ØØ* +
=
ØØ, -
new
ØØ. 1
Vector3
ØØ2 9
(
ØØ9 :
x
ØØ: ;
,
ØØ; <
y1
ØØ= ?
,
ØØ? @
z0
ØØA C
)
ØØC D
;
ØØD E
sides_v
∞∞ #
[
∞∞# $
sv
∞∞$ &
+
∞∞' (
$num
∞∞) *
]
∞∞* +
=
∞∞, -
new
∞∞. 1
Vector3
∞∞2 9
(
∞∞9 :
x
∞∞: ;
,
∞∞; <
y1
∞∞= ?
,
∞∞? @
z1
∞∞A C
)
∞∞C D
;
∞∞D E
sides_f
≤≤ #
[
≤≤# $
st
≤≤$ &
++
≤≤& (
]
≤≤( )
=
≤≤* +
new
≤≤, /
Face
≤≤0 4
(
≤≤4 5
side
≤≤5 9
%
≤≤: ;
$num
≤≤< =
==
≤≤> @
$num
≤≤A B
?
≤≤C D
new
≥≥$ '
int
≥≥( +
[
≥≥+ ,
]
≥≥, -
{
≥≥. /
v
≥≥0 1
+
≥≥2 3
$num
≥≥4 5
,
≥≥5 6
v
≥≥7 8
+
≥≥9 :
$num
≥≥; <
,
≥≥< =
v
≥≥> ?
+
≥≥@ A
$num
≥≥B C
}
≥≥D E
:
≥≥F G
new
¥¥$ '
int
¥¥( +
[
¥¥+ ,
]
¥¥, -
{
¥¥. /
v
¥¥0 1
+
¥¥2 3
$num
¥¥4 5
,
¥¥5 6
v
¥¥7 8
+
¥¥9 :
$num
¥¥; <
,
¥¥< =
v
¥¥> ?
+
¥¥@ A
$num
¥¥B C
}
¥¥D E
)
¥¥E F
;
¥¥F G
sides_f
∂∂ #
[
∂∂# $
st
∂∂$ &
-
∂∂' (
$num
∂∂) *
]
∂∂* +
.
∂∂+ ,
textureGroup
∂∂, 8
=
∂∂9 :
side
∂∂; ?
+
∂∂@ A
$num
∂∂B C
;
∂∂C D
v
∏∏ 
+=
∏∏  
$num
∏∏! "
;
∏∏" #
sv
ππ 
+=
ππ !
$num
ππ" #
;
ππ# $
}
∫∫ 
}
ªª 
vertices
ΩΩ 
=
ΩΩ 
vertices
ΩΩ '
.
ΩΩ' (
Concat
ΩΩ( .
(
ΩΩ. /
sides_v
ΩΩ/ 6
)
ΩΩ6 7
;
ΩΩ7 8
faces
ææ 
=
ææ 
faces
ææ !
.
ææ! "
Concat
ææ" (
(
ææ( )
sides_f
ææ) 0
)
ææ0 1
;
ææ1 2
x
¿¿ 
+=
¿¿ 
size
¿¿ 
.
¿¿ 
x
¿¿ 
;
¿¿  
}
¡¡ 
vertices
ƒƒ 
=
ƒƒ 
vertices
ƒƒ #
.
ƒƒ# $
Concat
ƒƒ$ *
(
ƒƒ* +
new
ƒƒ+ .
Vector3
ƒƒ/ 6
[
ƒƒ6 7
]
ƒƒ7 8
{
ƒƒ9 :
new
≈≈ 
Vector3
≈≈ 
(
≈≈  
$num
≈≈  "
,
≈≈" #
$num
≈≈$ &
,
≈≈& '
size
≈≈( ,
.
≈≈, -
z
≈≈- .
)
≈≈. /
,
≈≈/ 0
new
∆∆ 
Vector3
∆∆ 
(
∆∆  
size
∆∆  $
.
∆∆$ %
x
∆∆% &
,
∆∆& '
$num
∆∆( *
,
∆∆* +
size
∆∆, 0
.
∆∆0 1
z
∆∆1 2
)
∆∆2 3
,
∆∆3 4
new
«« 
Vector3
«« 
(
««  
$num
««  "
,
««" #
size
««$ (
.
««( )
y
««) *
,
««* +
size
««, 0
.
««0 1
z
««1 2
)
««2 3
,
««3 4
new
»» 
Vector3
»» 
(
»»  
size
»»  $
.
»»$ %
x
»»% &
,
»»& '
size
»»( ,
.
»», -
y
»»- .
,
»». /
size
»»0 4
.
»»4 5
z
»»5 6
)
»»6 7
}
…… 
)
…… 
;
…… 
faces
ÀÀ 
=
ÀÀ 
faces
ÀÀ 
.
ÀÀ 
Add
ÀÀ !
(
ÀÀ! "
new
ÀÀ" %
Face
ÀÀ& *
(
ÀÀ* +
new
ÀÀ+ .
int
ÀÀ/ 2
[
ÀÀ2 3
]
ÀÀ3 4
{
ÀÀ5 6
v
ÀÀ6 7
+
ÀÀ8 9
$num
ÀÀ: ;
,
ÀÀ; <
v
ÀÀ= >
+
ÀÀ? @
$num
ÀÀA B
,
ÀÀB C
v
ÀÀD E
+
ÀÀF G
$num
ÀÀH I
,
ÀÀI J
v
ÀÀK L
+
ÀÀM N
$num
ÀÀO P
,
ÀÀP Q
v
ÀÀR S
+
ÀÀT U
$num
ÀÀV W
,
ÀÀW X
v
ÀÀY Z
+
ÀÀ[ \
$num
ÀÀ] ^
}
ÀÀ^ _
)
ÀÀ_ `
)
ÀÀ` a
;
ÀÀa b
}
ÃÃ 
ProBuilderMesh
ŒŒ 
pb
ŒŒ 
=
ŒŒ 
ProBuilderMesh
ŒŒ  .
.
ŒŒ. /
Create
ŒŒ/ 5
(
ŒŒ5 6
vertices
ŒŒ6 >
,
ŒŒ> ?
faces
ŒŒ@ E
)
ŒŒE F
;
ŒŒF G
pb
œœ 
.
œœ 

gameObject
œœ 
.
œœ 
name
œœ 
=
œœ  
$str
œœ! )
;
œœ) *
pb
–– 
.
–– 
SetPivot
–– 
(
–– 
	pivotType
–– !
)
––! "
;
––" #
return
““ 
pb
““ 
;
““ 
}
”” 	
public
‡‡ 
static
‡‡ 
ProBuilderMesh
‡‡ $!
GenerateCurvedStair
‡‡% 8
(
‡‡8 9
PivotLocation
‡‡9 F
	pivotType
‡‡G P
,
‡‡P Q
float
‡‡R W

stairWidth
‡‡X b
,
‡‡b c
float
‡‡d i
height
‡‡j p
,
‡‡p q
float
‡‡r w
innerRadius‡‡x É
,‡‡É Ñ
float‡‡Ö ä
circumference‡‡ã ò
,‡‡ò ô
int‡‡ö ù
steps‡‡û £
,‡‡£ §
bool‡‡• ©

buildSides‡‡™ ¥
)‡‡¥ µ
{
·· 	
bool
‚‚ 
noInnerSide
‚‚ 
=
‚‚ 
innerRadius
‚‚ *
<
‚‚+ ,
Mathf
‚‚- 2
.
‚‚2 3
Epsilon
‚‚3 :
;
‚‚: ;
Vector3
ÊÊ 
[
ÊÊ 
]
ÊÊ 
	positions
ÊÊ 
=
ÊÊ  !
new
ÊÊ" %
Vector3
ÊÊ& -
[
ÊÊ- .
(
ÊÊ. /
$num
ÊÊ/ 0
*
ÊÊ1 2
steps
ÊÊ3 8
)
ÊÊ8 9
+
ÊÊ: ;
(
ÊÊ< =
(
ÊÊ= >
noInnerSide
ÊÊ> I
?
ÊÊJ K
$num
ÊÊL M
:
ÊÊN O
$num
ÊÊP Q
)
ÊÊQ R
*
ÊÊS T
steps
ÊÊU Z
)
ÊÊZ [
]
ÊÊ[ \
;
ÊÊ\ ]
Face
ÁÁ 
[
ÁÁ 
]
ÁÁ 
faces
ÁÁ 
=
ÁÁ 
new
ÁÁ 
Face
ÁÁ #
[
ÁÁ# $
steps
ÁÁ$ )
*
ÁÁ* +
$num
ÁÁ, -
]
ÁÁ- .
;
ÁÁ. /
int
ÍÍ 
v
ÍÍ 
=
ÍÍ 
$num
ÍÍ 
,
ÍÍ 
t
ÍÍ 
=
ÍÍ 
$num
ÍÍ 
;
ÍÍ 
float
ÏÏ 
cir
ÏÏ 
=
ÏÏ 
Mathf
ÏÏ 
.
ÏÏ 
Abs
ÏÏ !
(
ÏÏ! "
circumference
ÏÏ" /
)
ÏÏ/ 0
*
ÏÏ1 2
Mathf
ÏÏ3 8
.
ÏÏ8 9
Deg2Rad
ÏÏ9 @
;
ÏÏ@ A
float
ÌÌ 
outerRadius
ÌÌ 
=
ÌÌ 
innerRadius
ÌÌ  +
+
ÌÌ, -

stairWidth
ÌÌ. 8
;
ÌÌ8 9
for
ÔÔ 
(
ÔÔ 
int
ÔÔ 
i
ÔÔ 
=
ÔÔ 
$num
ÔÔ 
;
ÔÔ 
i
ÔÔ 
<
ÔÔ 
steps
ÔÔ  %
;
ÔÔ% &
i
ÔÔ' (
++
ÔÔ( *
)
ÔÔ* +
{
 
float
ÒÒ 
inc0
ÒÒ 
=
ÒÒ 
(
ÒÒ 
i
ÒÒ 
/
ÒÒ  !
(
ÒÒ" #
float
ÒÒ# (
)
ÒÒ( )
steps
ÒÒ) .
)
ÒÒ. /
*
ÒÒ0 1
cir
ÒÒ2 5
;
ÒÒ5 6
float
ÚÚ 
inc1
ÚÚ 
=
ÚÚ 
(
ÚÚ 
(
ÚÚ 
i
ÚÚ  
+
ÚÚ! "
$num
ÚÚ# $
)
ÚÚ$ %
/
ÚÚ& '
(
ÚÚ( )
float
ÚÚ) .
)
ÚÚ. /
steps
ÚÚ/ 4
)
ÚÚ4 5
*
ÚÚ6 7
cir
ÚÚ8 ;
;
ÚÚ; <
float
ÙÙ 
h0
ÙÙ 
=
ÙÙ 
(
ÙÙ 
(
ÙÙ 
i
ÙÙ 
/
ÙÙ  
(
ÙÙ! "
float
ÙÙ" '
)
ÙÙ' (
steps
ÙÙ( -
)
ÙÙ- .
*
ÙÙ/ 0
height
ÙÙ1 7
)
ÙÙ7 8
;
ÙÙ8 9
float
ıı 
h1
ıı 
=
ıı 
(
ıı 
(
ıı 
(
ıı 
i
ıı 
+
ıı  !
$num
ıı" #
)
ıı# $
/
ıı% &
(
ıı' (
float
ıı( -
)
ıı- .
steps
ıı. 3
)
ıı3 4
*
ıı5 6
height
ıı7 =
)
ıı= >
;
ıı> ?
Vector3
˜˜ 
v0
˜˜ 
=
˜˜ 
new
˜˜  
Vector3
˜˜! (
(
˜˜( )
-
˜˜) *
Mathf
˜˜* /
.
˜˜/ 0
Cos
˜˜0 3
(
˜˜3 4
inc0
˜˜4 8
)
˜˜8 9
,
˜˜9 :
$num
˜˜; =
,
˜˜= >
Mathf
˜˜? D
.
˜˜D E
Sin
˜˜E H
(
˜˜H I
inc0
˜˜I M
)
˜˜M N
)
˜˜N O
;
˜˜O P
Vector3
¯¯ 
v1
¯¯ 
=
¯¯ 
new
¯¯  
Vector3
¯¯! (
(
¯¯( )
-
¯¯) *
Mathf
¯¯* /
.
¯¯/ 0
Cos
¯¯0 3
(
¯¯3 4
inc1
¯¯4 8
)
¯¯8 9
,
¯¯9 :
$num
¯¯; =
,
¯¯= >
Mathf
¯¯? D
.
¯¯D E
Sin
¯¯E H
(
¯¯H I
inc1
¯¯I M
)
¯¯M N
)
¯¯N O
;
¯¯O P
	positions
ÖÖ 
[
ÖÖ 
v
ÖÖ 
+
ÖÖ 
$num
ÖÖ 
]
ÖÖ  
=
ÖÖ! "
v0
ÖÖ# %
*
ÖÖ& '
innerRadius
ÖÖ( 3
;
ÖÖ3 4
	positions
ÜÜ 
[
ÜÜ 
v
ÜÜ 
+
ÜÜ 
$num
ÜÜ 
]
ÜÜ  
=
ÜÜ! "
v0
ÜÜ# %
*
ÜÜ& '
outerRadius
ÜÜ( 3
;
ÜÜ3 4
	positions
áá 
[
áá 
v
áá 
+
áá 
$num
áá 
]
áá  
=
áá! "
v0
áá# %
*
áá& '
innerRadius
áá( 3
;
áá3 4
	positions
àà 
[
àà 
v
àà 
+
àà 
$num
àà 
]
àà  
=
àà! "
v0
àà# %
*
àà& '
outerRadius
àà( 3
;
àà3 4
	positions
ää 
[
ää 
v
ää 
+
ää 
$num
ää 
]
ää  
.
ää  !
y
ää! "
=
ää# $
h0
ää% '
;
ää' (
	positions
ãã 
[
ãã 
v
ãã 
+
ãã 
$num
ãã 
]
ãã  
.
ãã  !
y
ãã! "
=
ãã# $
h0
ãã% '
;
ãã' (
	positions
åå 
[
åå 
v
åå 
+
åå 
$num
åå 
]
åå  
.
åå  !
y
åå! "
=
åå# $
h1
åå% '
;
åå' (
	positions
çç 
[
çç 
v
çç 
+
çç 
$num
çç 
]
çç  
.
çç  !
y
çç! "
=
çç# $
h1
çç% '
;
çç' (
	positions
èè 
[
èè 
v
èè 
+
èè 
$num
èè 
]
èè  
=
èè! "
	positions
èè# ,
[
èè, -
v
èè- .
+
èè/ 0
$num
èè1 2
]
èè2 3
;
èè3 4
	positions
êê 
[
êê 
v
êê 
+
êê 
$num
êê 
]
êê  
=
êê! "
	positions
êê# ,
[
êê, -
v
êê- .
+
êê/ 0
$num
êê1 2
]
êê2 3
;
êê3 4
	positions
íí 
[
íí 
v
íí 
+
íí 
$num
íí 
]
íí  
=
íí! "
v1
íí# %
*
íí& '
outerRadius
íí( 3
;
íí3 4
	positions
ìì 
[
ìì 
v
ìì 
+
ìì 
$num
ìì 
]
ìì  
.
ìì  !
y
ìì! "
=
ìì# $
h1
ìì% '
;
ìì' (
if
ïï 
(
ïï 
!
ïï 
noInnerSide
ïï  
)
ïï  !
{
ññ 
	positions
óó 
[
óó 
v
óó 
+
óó  !
$num
óó" #
]
óó# $
=
óó% &
v1
óó' )
*
óó* +
innerRadius
óó, 7
;
óó7 8
	positions
òò 
[
òò 
v
òò 
+
òò  !
$num
òò" #
]
òò# $
.
òò$ %
y
òò% &
=
òò' (
h1
òò) +
;
òò+ ,
}
ôô 
faces
õõ 
[
õõ 
t
õõ 
+
õõ 
$num
õõ 
]
õõ 
=
õõ 
new
õõ "
Face
õõ# '
(
õõ' (
new
õõ( +
int
õõ, /
[
õõ/ 0
]
õõ0 1
{
õõ2 3
v
úú 
+
úú 
$num
úú 
,
úú 
v
ùù 
+
ùù 
$num
ùù 
,
ùù 
v
ûû 
+
ûû 
$num
ûû 
,
ûû 
v
üü 
+
üü 
$num
üü 
,
üü 
v
†† 
+
†† 
$num
†† 
,
†† 
v
°° 
+
°° 
$num
°° 
}
¢¢ 
)
¢¢ 
;
¢¢ 
if
§§ 
(
§§ 
noInnerSide
§§ 
)
§§  
{
•• 
faces
¶¶ 
[
¶¶ 
t
¶¶ 
+
¶¶ 
$num
¶¶ 
]
¶¶  
=
¶¶! "
new
¶¶# &
Face
¶¶' +
(
¶¶+ ,
new
¶¶, /
int
¶¶0 3
[
¶¶3 4
]
¶¶4 5
{
¶¶6 7
v
ßß 
+
ßß 
$num
ßß 
,
ßß 
v
®® 
+
®® 
$num
®® 
,
®® 
v
©© 
+
©© 
$num
©© 
}
™™ 
)
™™ 
;
™™ 
}
´´ 
else
¨¨ 
{
≠≠ 
faces
ÆÆ 
[
ÆÆ 
t
ÆÆ 
+
ÆÆ 
$num
ÆÆ 
]
ÆÆ  
=
ÆÆ! "
new
ÆÆ# &
Face
ÆÆ' +
(
ÆÆ+ ,
new
ÆÆ, /
int
ÆÆ0 3
[
ÆÆ3 4
]
ÆÆ4 5
{
ÆÆ6 7
v
ØØ 
+
ØØ 
$num
ØØ 
,
ØØ 
v
∞∞ 
+
∞∞ 
$num
∞∞ 
,
∞∞ 
v
±± 
+
±± 
$num
±± 
,
±± 
v
≤≤ 
+
≤≤ 
$num
≤≤ 
,
≤≤ 
v
≥≥ 
+
≥≥ 
$num
≥≥ 
,
≥≥ 
v
¥¥ 
+
¥¥ 
$num
¥¥ 
}
µµ 
)
µµ 
;
µµ 
}
∂∂ 
float
∏∏ 

uvRotation
∏∏  
=
∏∏! "
(
∏∏# $
(
∏∏$ %
inc1
∏∏% )
+
∏∏* +
inc0
∏∏, 0
)
∏∏0 1
*
∏∏2 3
-
∏∏4 5
$num
∏∏5 8
)
∏∏8 9
*
∏∏: ;
Mathf
∏∏< A
.
∏∏A B
Rad2Deg
∏∏B I
;
∏∏I J

uvRotation
ππ 
%=
ππ 
$num
ππ "
;
ππ" #
if
∫∫ 
(
∫∫ 

uvRotation
∫∫ 
<
∫∫  
$num
∫∫! #
)
∫∫# $

uvRotation
ªª 
=
ªª  
$num
ªª! %
+
ªª& '

uvRotation
ªª( 2
;
ªª2 3
var
ΩΩ 
uv
ΩΩ 
=
ΩΩ 
faces
ΩΩ 
[
ΩΩ 
t
ΩΩ  
+
ΩΩ! "
$num
ΩΩ# $
]
ΩΩ$ %
.
ΩΩ% &
uv
ΩΩ& (
;
ΩΩ( )
uv
ææ 
.
ææ 
rotation
ææ 
=
ææ 

uvRotation
ææ (
;
ææ( )
faces
øø 
[
øø 
t
øø 
+
øø 
$num
øø 
]
øø 
.
øø 
uv
øø 
=
øø  !
uv
øø" $
;
øø$ %
v
¡¡ 
+=
¡¡ 
noInnerSide
¡¡  
?
¡¡! "
$num
¡¡# $
:
¡¡% &
$num
¡¡' (
;
¡¡( )
t
¬¬ 
+=
¬¬ 
$num
¬¬ 
;
¬¬ 
}
√√ 
if
∆∆ 
(
∆∆ 

buildSides
∆∆ 
)
∆∆ 
{
«« 
float
   
x
   
=
   
noInnerSide
   %
?
  & '
innerRadius
  ( 3
+
  4 5

stairWidth
  6 @
:
  A B
innerRadius
  C N
;
  N O
for
ÃÃ 
(
ÃÃ 
int
ÃÃ 
side
ÃÃ 
=
ÃÃ 
(
ÃÃ  !
noInnerSide
ÃÃ! ,
?
ÃÃ- .
$num
ÃÃ/ 0
:
ÃÃ1 2
$num
ÃÃ3 4
)
ÃÃ4 5
;
ÃÃ5 6
side
ÃÃ7 ;
<
ÃÃ< =
$num
ÃÃ> ?
;
ÃÃ? @
side
ÃÃA E
++
ÃÃE G
)
ÃÃG H
{
ÕÕ 
Vector3
ŒŒ 
[
ŒŒ 
]
ŒŒ 
sides_v
ŒŒ %
=
ŒŒ& '
new
ŒŒ( +
Vector3
ŒŒ, 3
[
ŒŒ3 4
steps
ŒŒ4 9
*
ŒŒ: ;
$num
ŒŒ< =
+
ŒŒ> ?
(
ŒŒ@ A
steps
ŒŒA F
-
ŒŒG H
$num
ŒŒI J
)
ŒŒJ K
*
ŒŒL M
$num
ŒŒN O
]
ŒŒO P
;
ŒŒP Q
Face
œœ 
[
œœ 
]
œœ 
sides_f
œœ "
=
œœ# $
new
œœ% (
Face
œœ) -
[
œœ- .
steps
œœ. 3
+
œœ4 5
steps
œœ6 ;
-
œœ< =
$num
œœ> ?
]
œœ? @
;
œœ@ A
int
—— 
sv
—— 
=
—— 
$num
—— 
,
—— 
st
——  "
=
——# $
$num
——% &
;
——& '
for
”” 
(
”” 
int
”” 
i
”” 
=
””  
$num
””! "
;
””" #
i
””$ %
<
””& '
steps
””( -
;
””- .
i
””/ 0
++
””0 2
)
””2 3
{
‘‘ 
float
’’ 
inc0
’’ "
=
’’# $
(
’’% &
i
’’& '
/
’’( )
(
’’* +
float
’’+ 0
)
’’0 1
steps
’’1 6
)
’’6 7
*
’’8 9
cir
’’: =
;
’’= >
float
÷÷ 
inc1
÷÷ "
=
÷÷# $
(
÷÷% &
(
÷÷& '
i
÷÷' (
+
÷÷) *
$num
÷÷+ ,
)
÷÷, -
/
÷÷. /
(
÷÷0 1
float
÷÷1 6
)
÷÷6 7
steps
÷÷7 <
)
÷÷< =
*
÷÷> ?
cir
÷÷@ C
;
÷÷C D
float
ÿÿ 
h0
ÿÿ  
=
ÿÿ! "
(
ÿÿ# $
(
ÿÿ$ %
Mathf
ÿÿ% *
.
ÿÿ* +
Max
ÿÿ+ .
(
ÿÿ. /
i
ÿÿ/ 0
,
ÿÿ0 1
$num
ÿÿ2 3
)
ÿÿ3 4
/
ÿÿ5 6
(
ÿÿ7 8
float
ÿÿ8 =
)
ÿÿ= >
steps
ÿÿ> C
)
ÿÿC D
*
ÿÿE F
height
ÿÿG M
)
ÿÿM N
;
ÿÿN O
float
ŸŸ 
h1
ŸŸ  
=
ŸŸ! "
(
ŸŸ# $
(
ŸŸ$ %
(
ŸŸ% &
i
ŸŸ& '
+
ŸŸ( )
$num
ŸŸ* +
)
ŸŸ+ ,
/
ŸŸ- .
(
ŸŸ/ 0
float
ŸŸ0 5
)
ŸŸ5 6
steps
ŸŸ6 ;
)
ŸŸ; <
*
ŸŸ= >
height
ŸŸ? E
)
ŸŸE F
;
ŸŸF G
Vector3
€€ 
v0
€€  "
=
€€# $
new
€€% (
Vector3
€€) 0
(
€€0 1
-
€€1 2
Mathf
€€2 7
.
€€7 8
Cos
€€8 ;
(
€€; <
inc0
€€< @
)
€€@ A
,
€€A B
$num
€€C E
,
€€E F
Mathf
€€G L
.
€€L M
Sin
€€M P
(
€€P Q
inc0
€€Q U
)
€€U V
)
€€V W
*
€€X Y
x
€€Z [
;
€€[ \
Vector3
‹‹ 
v1
‹‹  "
=
‹‹# $
new
‹‹% (
Vector3
‹‹) 0
(
‹‹0 1
-
‹‹1 2
Mathf
‹‹2 7
.
‹‹7 8
Cos
‹‹8 ;
(
‹‹; <
inc1
‹‹< @
)
‹‹@ A
,
‹‹A B
$num
‹‹C E
,
‹‹E F
Mathf
‹‹G L
.
‹‹L M
Sin
‹‹M P
(
‹‹P Q
inc1
‹‹Q U
)
‹‹U V
)
‹‹V W
*
‹‹X Y
x
‹‹Z [
;
‹‹[ \
sides_v
ﬁﬁ 
[
ﬁﬁ  
sv
ﬁﬁ  "
+
ﬁﬁ# $
$num
ﬁﬁ% &
]
ﬁﬁ& '
=
ﬁﬁ( )
v0
ﬁﬁ* ,
;
ﬁﬁ, -
sides_v
ﬂﬂ 
[
ﬂﬂ  
sv
ﬂﬂ  "
+
ﬂﬂ# $
$num
ﬂﬂ% &
]
ﬂﬂ& '
=
ﬂﬂ( )
v1
ﬂﬂ* ,
;
ﬂﬂ, -
sides_v
‡‡ 
[
‡‡  
sv
‡‡  "
+
‡‡# $
$num
‡‡% &
]
‡‡& '
=
‡‡( )
v0
‡‡* ,
;
‡‡, -
sides_v
·· 
[
··  
sv
··  "
+
··# $
$num
··% &
]
··& '
=
··( )
v1
··* ,
;
··, -
sides_v
„„ 
[
„„  
sv
„„  "
+
„„# $
$num
„„% &
]
„„& '
.
„„' (
y
„„( )
=
„„* +
$num
„„, .
;
„„. /
sides_v
‰‰ 
[
‰‰  
sv
‰‰  "
+
‰‰# $
$num
‰‰% &
]
‰‰& '
.
‰‰' (
y
‰‰( )
=
‰‰* +
$num
‰‰, .
;
‰‰. /
sides_v
ÂÂ 
[
ÂÂ  
sv
ÂÂ  "
+
ÂÂ# $
$num
ÂÂ% &
]
ÂÂ& '
.
ÂÂ' (
y
ÂÂ( )
=
ÂÂ* +
h0
ÂÂ, .
;
ÂÂ. /
sides_v
ÊÊ 
[
ÊÊ  
sv
ÊÊ  "
+
ÊÊ# $
$num
ÊÊ% &
]
ÊÊ& '
.
ÊÊ' (
y
ÊÊ( )
=
ÊÊ* +
h1
ÊÊ, .
;
ÊÊ. /
sides_f
ËË 
[
ËË  
st
ËË  "
++
ËË" $
]
ËË$ %
=
ËË& '
new
ËË( +
Face
ËË, 0
(
ËË0 1
side
ËË1 5
%
ËË6 7
$num
ËË8 9
==
ËË: <
$num
ËË= >
?
ËË? @
new
ÈÈ  #
int
ÈÈ$ '
[
ÈÈ' (
]
ÈÈ( )
{
ÈÈ* +
v
ÈÈ, -
+
ÈÈ. /
$num
ÈÈ0 1
,
ÈÈ1 2
v
ÈÈ3 4
+
ÈÈ5 6
$num
ÈÈ7 8
,
ÈÈ8 9
v
ÈÈ: ;
+
ÈÈ< =
$num
ÈÈ> ?
,
ÈÈ? @
v
ÈÈA B
+
ÈÈC D
$num
ÈÈE F
,
ÈÈF G
v
ÈÈH I
+
ÈÈJ K
$num
ÈÈL M
,
ÈÈM N
v
ÈÈO P
+
ÈÈQ R
$num
ÈÈS T
}
ÈÈU V
:
ÈÈW X
new
ÍÍ  #
int
ÍÍ$ '
[
ÍÍ' (
]
ÍÍ( )
{
ÍÍ* +
v
ÍÍ, -
+
ÍÍ. /
$num
ÍÍ0 1
,
ÍÍ1 2
v
ÍÍ3 4
+
ÍÍ5 6
$num
ÍÍ7 8
,
ÍÍ8 9
v
ÍÍ: ;
+
ÍÍ< =
$num
ÍÍ> ?
,
ÍÍ? @
v
ÍÍA B
+
ÍÍC D
$num
ÍÍE F
,
ÍÍF G
v
ÍÍH I
+
ÍÍJ K
$num
ÍÍL M
,
ÍÍM N
v
ÍÍO P
+
ÍÍQ R
$num
ÍÍS T
}
ÍÍU V
)
ÍÍV W
;
ÍÍW X
sides_f
ÎÎ 
[
ÎÎ  
st
ÎÎ  "
-
ÎÎ# $
$num
ÎÎ% &
]
ÎÎ& '
.
ÎÎ' (
smoothingGroup
ÎÎ( 6
=
ÎÎ7 8
side
ÎÎ9 =
+
ÎÎ> ?
$num
ÎÎ@ A
;
ÎÎA B
v
ÌÌ 
+=
ÌÌ 
$num
ÌÌ 
;
ÌÌ 
sv
ÓÓ 
+=
ÓÓ 
$num
ÓÓ 
;
ÓÓ  
if
ÒÒ 
(
ÒÒ 
i
ÒÒ 
>
ÒÒ 
$num
ÒÒ  !
)
ÒÒ! "
{
ÚÚ 
sides_f
ÛÛ #
[
ÛÛ# $
st
ÛÛ$ &
-
ÛÛ' (
$num
ÛÛ) *
]
ÛÛ* +
.
ÛÛ+ ,
textureGroup
ÛÛ, 8
=
ÛÛ9 :
(
ÛÛ; <
side
ÛÛ< @
*
ÛÛA B
steps
ÛÛC H
)
ÛÛH I
+
ÛÛJ K
i
ÛÛL M
;
ÛÛM N
sides_v
ıı #
[
ıı# $
sv
ıı$ &
+
ıı' (
$num
ıı) *
]
ıı* +
=
ıı, -
v0
ıı. 0
;
ıı0 1
sides_v
ˆˆ #
[
ˆˆ# $
sv
ˆˆ$ &
+
ˆˆ' (
$num
ˆˆ) *
]
ˆˆ* +
=
ˆˆ, -
v1
ˆˆ. 0
;
ˆˆ0 1
sides_v
˜˜ #
[
˜˜# $
sv
˜˜$ &
+
˜˜' (
$num
˜˜) *
]
˜˜* +
=
˜˜, -
v0
˜˜. 0
;
˜˜0 1
sides_v
¯¯ #
[
¯¯# $
sv
¯¯$ &
+
¯¯' (
$num
¯¯) *
]
¯¯* +
.
¯¯+ ,
y
¯¯, -
=
¯¯. /
h0
¯¯0 2
;
¯¯2 3
sides_v
˘˘ #
[
˘˘# $
sv
˘˘$ &
+
˘˘' (
$num
˘˘) *
]
˘˘* +
.
˘˘+ ,
y
˘˘, -
=
˘˘. /
h1
˘˘0 2
;
˘˘2 3
sides_v
˙˙ #
[
˙˙# $
sv
˙˙$ &
+
˙˙' (
$num
˙˙) *
]
˙˙* +
.
˙˙+ ,
y
˙˙, -
=
˙˙. /
h1
˙˙0 2
;
˙˙2 3
sides_f
¸¸ #
[
¸¸# $
st
¸¸$ &
++
¸¸& (
]
¸¸( )
=
¸¸* +
new
¸¸, /
Face
¸¸0 4
(
¸¸4 5
side
¸¸5 9
%
¸¸: ;
$num
¸¸< =
==
¸¸> @
$num
¸¸A B
?
¸¸C D
new
˝˝$ '
int
˝˝( +
[
˝˝+ ,
]
˝˝, -
{
˝˝. /
v
˝˝0 1
+
˝˝2 3
$num
˝˝4 5
,
˝˝5 6
v
˝˝7 8
+
˝˝9 :
$num
˝˝; <
,
˝˝< =
v
˝˝> ?
+
˝˝@ A
$num
˝˝B C
}
˝˝D E
:
˝˝F G
new
˛˛$ '
int
˛˛( +
[
˛˛+ ,
]
˛˛, -
{
˛˛. /
v
˛˛0 1
+
˛˛2 3
$num
˛˛4 5
,
˛˛5 6
v
˛˛7 8
+
˛˛9 :
$num
˛˛; <
,
˛˛< =
v
˛˛> ?
+
˛˛@ A
$num
˛˛B C
}
˛˛D E
)
˛˛E F
;
˛˛F G
sides_f
ÄÄ #
[
ÄÄ# $
st
ÄÄ$ &
-
ÄÄ' (
$num
ÄÄ) *
]
ÄÄ* +
.
ÄÄ+ ,
textureGroup
ÄÄ, 8
=
ÄÄ9 :
(
ÄÄ; <
side
ÄÄ< @
*
ÄÄA B
steps
ÄÄC H
)
ÄÄH I
+
ÄÄJ K
i
ÄÄL M
;
ÄÄM N
sides_f
ÅÅ #
[
ÅÅ# $
st
ÅÅ$ &
-
ÅÅ' (
$num
ÅÅ) *
]
ÅÅ* +
.
ÅÅ+ ,
smoothingGroup
ÅÅ, :
=
ÅÅ; <
side
ÅÅ= A
+
ÅÅB C
$num
ÅÅD E
;
ÅÅE F
v
ÉÉ 
+=
ÉÉ  
$num
ÉÉ! "
;
ÉÉ" #
sv
ÑÑ 
+=
ÑÑ !
$num
ÑÑ" #
;
ÑÑ# $
}
ÖÖ 
}
ÜÜ 
	positions
àà 
=
àà 
	positions
àà  )
.
àà) *
Concat
àà* 0
(
àà0 1
sides_v
àà1 8
)
àà8 9
;
àà9 :
faces
ââ 
=
ââ 
faces
ââ !
.
ââ! "
Concat
ââ" (
(
ââ( )
sides_f
ââ) 0
)
ââ0 1
;
ââ1 2
x
ãã 
+=
ãã 

stairWidth
ãã #
;
ãã# $
}
åå 
float
èè 
cos
èè 
=
èè 
-
èè 
Mathf
èè "
.
èè" #
Cos
èè# &
(
èè& '
cir
èè' *
)
èè* +
,
èè+ ,
sin
èè- 0
=
èè1 2
Mathf
èè3 8
.
èè8 9
Sin
èè9 <
(
èè< =
cir
èè= @
)
èè@ A
;
èèA B
	positions
ëë 
=
ëë 
	positions
ëë %
.
ëë% &
Concat
ëë& ,
(
ëë, -
new
ëë- 0
Vector3
ëë1 8
[
ëë8 9
]
ëë9 :
{
íí 
new
ìì 
Vector3
ìì 
(
ìì  
cos
ìì  #
,
ìì# $
$num
ìì% '
,
ìì' (
sin
ìì) ,
)
ìì, -
*
ìì. /
innerRadius
ìì0 ;
,
ìì; <
new
îî 
Vector3
îî 
(
îî  
cos
îî  #
,
îî# $
$num
îî% '
,
îî' (
sin
îî) ,
)
îî, -
*
îî. /
outerRadius
îî0 ;
,
îî; <
new
ïï 
Vector3
ïï 
(
ïï  
cos
ïï  #
*
ïï$ %
innerRadius
ïï& 1
,
ïï1 2
height
ïï3 9
,
ïï9 :
sin
ïï; >
*
ïï? @
innerRadius
ïïA L
)
ïïL M
,
ïïM N
new
ññ 
Vector3
ññ 
(
ññ  
cos
ññ  #
*
ññ$ %
outerRadius
ññ& 1
,
ññ1 2
height
ññ3 9
,
ññ9 :
sin
ññ; >
*
ññ? @
outerRadius
ññA L
)
ññL M
}
óó 
)
óó 
;
óó 
faces
ôô 
=
ôô 
faces
ôô 
.
ôô 
Add
ôô !
(
ôô! "
new
ôô" %
Face
ôô& *
(
ôô* +
new
ôô+ .
int
ôô/ 2
[
ôô2 3
]
ôô3 4
{
ôô5 6
v
ôô6 7
+
ôô8 9
$num
ôô: ;
,
ôô; <
v
ôô= >
+
ôô? @
$num
ôôA B
,
ôôB C
v
ôôD E
+
ôôF G
$num
ôôH I
,
ôôI J
v
ôôK L
+
ôôM N
$num
ôôO P
,
ôôP Q
v
ôôR S
+
ôôT U
$num
ôôV W
,
ôôW X
v
ôôY Z
+
ôô[ \
$num
ôô] ^
}
ôô^ _
)
ôô_ `
)
ôô` a
;
ôôa b
}
öö 
if
úú 
(
úú 
circumference
úú 
<
úú 
$num
úú  "
)
úú" #
{
ùù 
Vector3
ûû 
flip
ûû 
=
ûû 
new
ûû "
Vector3
ûû# *
(
ûû* +
-
ûû+ ,
$num
ûû, .
,
ûû. /
$num
ûû0 2
,
ûû2 3
$num
ûû4 6
)
ûû6 7
;
ûû7 8
for
†† 
(
†† 
int
†† 
i
†† 
=
†† 
$num
†† 
;
†† 
i
††  !
<
††" #
	positions
††$ -
.
††- .
Length
††. 4
;
††4 5
i
††6 7
++
††7 9
)
††9 :
	positions
°° 
[
°° 
i
°° 
]
°°  
.
°°  !
Scale
°°! &
(
°°& '
flip
°°' +
)
°°+ ,
;
°°, -
foreach
££ 
(
££ 
Face
££ 
f
££ 
in
££  "
faces
££# (
)
££( )
f
§§ 
.
§§ 
Reverse
§§ 
(
§§ 
)
§§ 
;
§§  
}
•• 
ProBuilderMesh
ßß 
pb
ßß 
=
ßß 
ProBuilderMesh
ßß  .
.
ßß. /
Create
ßß/ 5
(
ßß5 6
	positions
ßß6 ?
,
ßß? @
faces
ßßA F
)
ßßF G
;
ßßG H
pb
©© 
.
©© 

gameObject
©© 
.
©© 
name
©© 
=
©©  
$str
©©! )
;
©©) *
pb
™™ 
.
™™ 
SetPivot
™™ 
(
™™ 
	pivotType
™™ !
)
™™! "
;
™™" #
return
¨¨ 
pb
¨¨ 
;
¨¨ 
}
≠≠ 	
internal
ªª 
static
ªª 
ProBuilderMesh
ªª &
GenerateStair
ªª' 4
(
ªª4 5
PivotLocation
ªª5 B
	pivotType
ªªC L
,
ªªL M
int
ªªN Q
steps
ªªR W
,
ªªW X
float
ªªY ^
width
ªª_ d
,
ªªd e
float
ªªf k
height
ªªl r
,
ªªr s
float
ªªt y
depth
ªªz 
,ªª Ä
boolªªÅ Ö
sidesGoToFloorªªÜ î
,ªªî ï
boolªªñ ö
generateBackªªõ ß
,ªªß ®
boolªª© ≠
platformsOnlyªªÆ ª
)ªªª º
{
ºº 	
int
ΩΩ 
i
ΩΩ 
=
ΩΩ 
$num
ΩΩ 
;
ΩΩ 
List
øø 
<
øø 
Vector3
øø 
>
øø 
verts
øø 
=
øø  !
new
øø" %
List
øø& *
<
øø* +
Vector3
øø+ 2
>
øø2 3
(
øø3 4
)
øø4 5
;
øø5 6
Vector3
¿¿ 
[
¿¿ 
]
¿¿ 
v
¿¿ 
=
¿¿ 
(
¿¿ 
platformsOnly
¿¿ (
)
¿¿( )
?
¿¿* +
new
¿¿, /
Vector3
¿¿0 7
[
¿¿7 8
$num
¿¿8 9
]
¿¿9 :
:
¿¿; <
new
¿¿= @
Vector3
¿¿A H
[
¿¿H I
$num
¿¿I K
]
¿¿K L
;
¿¿L M
float
¬¬ 
	stepWidth
¬¬ 
=
¬¬ 
width
¬¬ #
;
¬¬# $
float
√√ 

stepHeight
√√ 
=
√√ 
height
√√ %
/
√√& '
steps
√√( -
;
√√- .
float
ƒƒ 
	stepDepth
ƒƒ 
=
ƒƒ 
depth
ƒƒ #
/
ƒƒ$ %
steps
ƒƒ& +
;
ƒƒ+ ,
float
≈≈ 
yMax
≈≈ 
=
≈≈ 

stepHeight
≈≈ #
;
≈≈# $
for
»» 
(
»» 
i
»» 
=
»» 
$num
»» 
;
»» 
i
»» 
<
»» 
steps
»» !
;
»»! "
i
»»# $
++
»»$ &
)
»»& '
{
…… 
float
   
x
   
=
   
	stepWidth
   #
/
  $ %
$num
  & (
,
  ( )
y
  * +
=
  , -
i
  . /
*
  0 1

stepHeight
  2 <
,
  < =
z
  > ?
=
  @ A
i
  B C
*
  D E
	stepDepth
  F O
;
  O P
if
ÃÃ 
(
ÃÃ 
sidesGoToFloor
ÃÃ "
)
ÃÃ" #
y
ÕÕ 
=
ÕÕ 
$num
ÕÕ 
;
ÕÕ 
yMax
œœ 
=
œœ 
i
œœ 
*
œœ 

stepHeight
œœ %
+
œœ& '

stepHeight
œœ( 2
;
œœ2 3
v
““ 
[
““ 
$num
““ 
]
““ 
=
““ 
new
““ 
Vector3
““ #
(
““# $
x
““$ %
,
““% &
i
““' (
*
““) *

stepHeight
““+ 5
,
““5 6
z
““9 :
)
““: ;
;
““; <
v
”” 
[
”” 
$num
”” 
]
”” 
=
”” 
new
”” 
Vector3
”” #
(
””# $
-
””$ %
x
””% &
,
””& '
i
””( )
*
””* +

stepHeight
””, 6
,
””6 7
z
””: ;
)
””; <
;
””< =
v
‘‘ 
[
‘‘ 
$num
‘‘ 
]
‘‘ 
=
‘‘ 
new
‘‘ 
Vector3
‘‘ "
(
‘‘" #
x
‘‘# $
,
‘‘$ %
yMax
‘‘& *
,
‘‘* +
z
‘‘7 8
)
‘‘8 9
;
‘‘9 :
v
’’ 
[
’’ 
$num
’’ 
]
’’ 
=
’’ 
new
’’ 
Vector3
’’ "
(
’’" #
-
’’# $
x
’’$ %
,
’’% &
yMax
’’' +
,
’’+ ,
z
’’8 9
)
’’9 :
;
’’: ;
v
ÿÿ 
[
ÿÿ 
$num
ÿÿ 
]
ÿÿ 
=
ÿÿ 
new
ÿÿ 
Vector3
ÿÿ "
(
ÿÿ" #
x
ÿÿ# $
,
ÿÿ$ %
yMax
ÿÿ& *
,
ÿÿ* +
z
ÿÿ, -
)
ÿÿ- .
;
ÿÿ. /
v
ŸŸ 
[
ŸŸ 
$num
ŸŸ 
]
ŸŸ 
=
ŸŸ 
new
ŸŸ 
Vector3
ŸŸ "
(
ŸŸ" #
-
ŸŸ# $
x
ŸŸ$ %
,
ŸŸ% &
yMax
ŸŸ' +
,
ŸŸ+ ,
z
ŸŸ- .
)
ŸŸ. /
;
ŸŸ/ 0
v
⁄⁄ 
[
⁄⁄ 
$num
⁄⁄ 
]
⁄⁄ 
=
⁄⁄ 
new
⁄⁄ 
Vector3
⁄⁄ "
(
⁄⁄" #
x
⁄⁄# $
,
⁄⁄$ %
yMax
⁄⁄& *
,
⁄⁄* +
z
⁄⁄, -
+
⁄⁄. /
	stepDepth
⁄⁄0 9
)
⁄⁄9 :
;
⁄⁄: ;
v
€€ 
[
€€ 
$num
€€ 
]
€€ 
=
€€ 
new
€€ 
Vector3
€€ "
(
€€" #
-
€€# $
x
€€$ %
,
€€% &
yMax
€€' +
,
€€+ ,
z
€€- .
+
€€/ 0
	stepDepth
€€1 :
)
€€: ;
;
€€; <
if
›› 
(
›› 
!
›› 
platformsOnly
›› "
)
››" #
{
ﬁﬁ 
v
‡‡ 
[
‡‡ 
$num
‡‡ 
]
‡‡ 
=
‡‡ 
new
‡‡ 
Vector3
‡‡ &
(
‡‡& '
x
‡‡' (
,
‡‡( )
y
‡‡* +
,
‡‡+ ,
z
‡‡3 4
+
‡‡5 6
	stepDepth
‡‡7 @
)
‡‡@ A
;
‡‡A B
v
·· 
[
·· 
$num
·· 
]
·· 
=
·· 
new
·· 
Vector3
·· &
(
··& '
x
··' (
,
··( )
y
··* +
,
··+ ,
z
··3 4
)
··4 5
;
··5 6
v
‚‚ 
[
‚‚ 
$num
‚‚ 
]
‚‚ 
=
‚‚ 
new
‚‚ 
Vector3
‚‚  '
(
‚‚' (
x
‚‚( )
,
‚‚) *
yMax
‚‚+ /
,
‚‚/ 0
z
‚‚4 5
+
‚‚6 7
	stepDepth
‚‚8 A
)
‚‚A B
;
‚‚B C
v
„„ 
[
„„ 
$num
„„ 
]
„„ 
=
„„ 
new
„„ 
Vector3
„„  '
(
„„' (
x
„„( )
,
„„) *
yMax
„„+ /
,
„„/ 0
z
„„4 5
)
„„5 6
;
„„6 7
v
ÊÊ 
[
ÊÊ 
$num
ÊÊ 
]
ÊÊ 
=
ÊÊ 
new
ÊÊ 
Vector3
ÊÊ  '
(
ÊÊ' (
-
ÊÊ( )
x
ÊÊ) *
,
ÊÊ* +
y
ÊÊ, -
,
ÊÊ- .
z
ÊÊ3 4
)
ÊÊ4 5
;
ÊÊ5 6
v
ÁÁ 
[
ÁÁ 
$num
ÁÁ 
]
ÁÁ 
=
ÁÁ 
new
ÁÁ 
Vector3
ÁÁ  '
(
ÁÁ' (
-
ÁÁ( )
x
ÁÁ) *
,
ÁÁ* +
y
ÁÁ, -
,
ÁÁ- .
z
ÁÁ3 4
+
ÁÁ5 6
	stepDepth
ÁÁ7 @
)
ÁÁ@ A
;
ÁÁA B
v
ËË 
[
ËË 
$num
ËË 
]
ËË 
=
ËË 
new
ËË 
Vector3
ËË  '
(
ËË' (
-
ËË( )
x
ËË) *
,
ËË* +
yMax
ËË, 0
,
ËË0 1
z
ËË3 4
)
ËË4 5
;
ËË5 6
v
ÈÈ 
[
ÈÈ 
$num
ÈÈ 
]
ÈÈ 
=
ÈÈ 
new
ÈÈ 
Vector3
ÈÈ  '
(
ÈÈ' (
-
ÈÈ( )
x
ÈÈ) *
,
ÈÈ* +
yMax
ÈÈ, 0
,
ÈÈ0 1
z
ÈÈ3 4
+
ÈÈ5 6
	stepDepth
ÈÈ7 @
)
ÈÈ@ A
;
ÈÈA B
}
ÍÍ 
verts
ÏÏ 
.
ÏÏ 
AddRange
ÏÏ 
(
ÏÏ 
v
ÏÏ  
)
ÏÏ  !
;
ÏÏ! "
}
ÌÌ 
if
ÔÔ 
(
ÔÔ 
generateBack
ÔÔ 
)
ÔÔ 
{
 
verts
ÒÒ 
.
ÒÒ 
Add
ÒÒ 
(
ÒÒ 
new
ÒÒ 
Vector3
ÒÒ %
(
ÒÒ% &
-
ÒÒ& '
	stepWidth
ÒÒ' 0
/
ÒÒ1 2
$num
ÒÒ3 5
,
ÒÒ5 6
$num
ÒÒ7 9
,
ÒÒ9 :
depth
ÒÒ; @
)
ÒÒ@ A
)
ÒÒA B
;
ÒÒB C
verts
ÚÚ 
.
ÚÚ 
Add
ÚÚ 
(
ÚÚ 
new
ÚÚ 
Vector3
ÚÚ %
(
ÚÚ% &
	stepWidth
ÚÚ& /
/
ÚÚ0 1
$num
ÚÚ2 4
,
ÚÚ4 5
$num
ÚÚ6 8
,
ÚÚ8 9
depth
ÚÚ: ?
)
ÚÚ? @
)
ÚÚ@ A
;
ÚÚA B
verts
ÛÛ 
.
ÛÛ 
Add
ÛÛ 
(
ÛÛ 
new
ÛÛ 
Vector3
ÛÛ %
(
ÛÛ% &
-
ÛÛ& '
	stepWidth
ÛÛ' 0
/
ÛÛ1 2
$num
ÛÛ3 5
,
ÛÛ5 6
height
ÛÛ7 =
,
ÛÛ= >
depth
ÛÛ? D
)
ÛÛD E
)
ÛÛE F
;
ÛÛF G
verts
ÙÙ 
.
ÙÙ 
Add
ÙÙ 
(
ÙÙ 
new
ÙÙ 
Vector3
ÙÙ %
(
ÙÙ% &
	stepWidth
ÙÙ& /
/
ÙÙ0 1
$num
ÙÙ2 4
,
ÙÙ4 5
height
ÙÙ6 <
,
ÙÙ< =
depth
ÙÙ> C
)
ÙÙC D
)
ÙÙD E
;
ÙÙE F
}
ıı 
ProBuilderMesh
˜˜ 
pb
˜˜ 
=
˜˜ 
ProBuilderMesh
˜˜  .
.
˜˜. /&
CreateInstanceWithPoints
˜˜/ G
(
˜˜G H
verts
˜˜H M
.
˜˜M N
ToArray
˜˜N U
(
˜˜U V
)
˜˜V W
)
˜˜W X
;
˜˜X Y
pb
¯¯ 
.
¯¯ 

gameObject
¯¯ 
.
¯¯ 
name
¯¯ 
=
¯¯  
$str
¯¯! )
;
¯¯) *
pb
˘˘ 
.
˘˘ 
SetPivot
˘˘ 
(
˘˘ 
	pivotType
˘˘ !
)
˘˘! "
;
˘˘" #
return
˚˚ 
pb
˚˚ 
;
˚˚ 
}
¸¸ 	
public
ÑÑ 
static
ÑÑ 
ProBuilderMesh
ÑÑ $
GenerateCube
ÑÑ% 1
(
ÑÑ1 2
PivotLocation
ÑÑ2 ?
	pivotType
ÑÑ@ I
,
ÑÑI J
Vector3
ÑÑK R
size
ÑÑS W
)
ÑÑW X
{
ÖÖ 	
Vector3
ÜÜ 
[
ÜÜ 
]
ÜÜ 
points
ÜÜ 
=
ÜÜ 
new
ÜÜ "
Vector3
ÜÜ# *
[
ÜÜ* +
k_CubeTriangles
ÜÜ+ :
.
ÜÜ: ;
Length
ÜÜ; A
]
ÜÜA B
;
ÜÜB C
for
àà 
(
àà 
int
àà 
i
àà 
=
àà 
$num
àà 
;
àà 
i
àà 
<
àà 
k_CubeTriangles
àà  /
.
àà/ 0
Length
àà0 6
;
àà6 7
i
àà8 9
++
àà9 ;
)
àà; <
points
ââ 
[
ââ 
i
ââ 
]
ââ 
=
ââ 
Vector3
ââ #
.
ââ# $
Scale
ââ$ )
(
ââ) *
k_CubeVertices
ââ* 8
[
ââ8 9
k_CubeTriangles
ââ9 H
[
ââH I
i
ââI J
]
ââJ K
]
ââK L
,
ââL M
size
ââN R
)
ââR S
;
ââS T
ProBuilderMesh
ãã 
pb
ãã 
=
ãã 
ProBuilderMesh
ãã  .
.
ãã. /&
CreateInstanceWithPoints
ãã/ G
(
ããG H
points
ããH N
)
ããN O
;
ããO P
pb
åå 
.
åå 

gameObject
åå 
.
åå 
name
åå 
=
åå  
$str
åå! '
;
åå' (
pb
çç 
.
çç 
SetPivot
çç 
(
çç 
	pivotType
çç !
)
çç! "
;
çç" #
return
èè 
pb
èè 
;
èè 
}
êê 	
public
úú 
static
úú 
ProBuilderMesh
úú $
GenerateCylinder
úú% 5
(
úú5 6
PivotLocation
úú6 C
	pivotType
úúD M
,
úúM N
int
úúO R
axisDivisions
úúS `
,
úú` a
float
úúb g
radius
úúh n
,
úún o
float
úúp u
height
úúv |
,
úú| }
intúú~ Å

heightCutsúúÇ å
,úúå ç
intúúé ë
	smoothingúúí õ
=úúú ù
-úúû ü
$numúúü †
)úú† °
{
ùù 	
if
ûû 
(
ûû 
axisDivisions
ûû 
%
ûû 
$num
ûû  !
!=
ûû" $
$num
ûû% &
)
ûû& '
axisDivisions
üü 
++
üü 
;
üü  
if
°° 
(
°° 
axisDivisions
°° 
>
°° 
$num
°°  "
)
°°" #
axisDivisions
¢¢ 
=
¢¢ 
$num
¢¢  "
;
¢¢" #
float
§§ 
	stepAngle
§§ 
=
§§ 
$num
§§ "
/
§§# $
axisDivisions
§§% 2
;
§§2 3
float
•• 

heightStep
•• 
=
•• 
height
•• %
/
••& '
(
••( )

heightCuts
••) 3
+
••4 5
$num
••6 7
)
••7 8
;
••8 9
Vector3
ßß 
[
ßß 
]
ßß 
circle
ßß 
=
ßß 
new
ßß "
Vector3
ßß# *
[
ßß* +
axisDivisions
ßß+ 8
]
ßß8 9
;
ßß9 :
for
™™ 
(
™™ 
int
™™ 
i
™™ 
=
™™ 
$num
™™ 
;
™™ 
i
™™ 
<
™™ 
axisDivisions
™™  -
;
™™- .
i
™™/ 0
++
™™0 2
)
™™2 3
{
´´ 
float
¨¨ 
angle0
¨¨ 
=
¨¨ 
	stepAngle
¨¨ (
*
¨¨) *
i
¨¨+ ,
*
¨¨- .
Mathf
¨¨/ 4
.
¨¨4 5
Deg2Rad
¨¨5 <
;
¨¨< =
float
ÆÆ 
x
ÆÆ 
=
ÆÆ 
Mathf
ÆÆ 
.
ÆÆ  
Cos
ÆÆ  #
(
ÆÆ# $
angle0
ÆÆ$ *
)
ÆÆ* +
*
ÆÆ, -
radius
ÆÆ. 4
;
ÆÆ4 5
float
ØØ 
z
ØØ 
=
ØØ 
Mathf
ØØ 
.
ØØ  
Sin
ØØ  #
(
ØØ# $
angle0
ØØ$ *
)
ØØ* +
*
ØØ, -
radius
ØØ. 4
;
ØØ4 5
circle
±± 
[
±± 
i
±± 
]
±± 
=
±± 
new
±± 
Vector3
±±  '
(
±±' (
x
±±( )
,
±±) *
$num
±±+ -
,
±±- .
z
±±/ 0
)
±±0 1
;
±±1 2
}
≤≤ 
Vector3
µµ 
[
µµ 
]
µµ 
verts
µµ 
=
µµ 
new
µµ !
Vector3
µµ" )
[
µµ) *
(
µµ* +
axisDivisions
µµ+ 8
*
µµ9 :
(
µµ; <

heightCuts
µµ< F
+
µµG H
$num
µµI J
)
µµJ K
*
µµL M
$num
µµN O
)
µµO P
+
µµQ R
(
µµS T
axisDivisions
µµT a
*
µµb c
$num
µµd e
)
µµe f
]
µµf g
;
µµg h
Face
∂∂ 
[
∂∂ 
]
∂∂ 
faces
∂∂ 
=
∂∂ 
new
∂∂ 
Face
∂∂ #
[
∂∂# $
axisDivisions
∂∂$ 1
*
∂∂2 3
(
∂∂4 5

heightCuts
∂∂5 ?
+
∂∂@ A
$num
∂∂B C
)
∂∂C D
+
∂∂G H
(
∂∂I J
axisDivisions
∂∂J W
*
∂∂X Y
$num
∂∂Z [
)
∂∂[ \
]
∂∂\ ]
;
∂∂] ^
int
ππ 
it
ππ 
=
ππ 
$num
ππ 
;
ππ 
for
ªª 
(
ªª 
int
ªª 
i
ªª 
=
ªª 
$num
ªª 
;
ªª 
i
ªª 
<
ªª 

heightCuts
ªª  *
+
ªª+ ,
$num
ªª- .
;
ªª. /
i
ªª0 1
++
ªª1 3
)
ªª3 4
{
ºº 
float
ΩΩ 
Y
ΩΩ 
=
ΩΩ 
i
ΩΩ 
*
ΩΩ 

heightStep
ΩΩ (
;
ΩΩ( )
float
ææ 
Y2
ææ 
=
ææ 
(
ææ 
i
ææ 
+
ææ 
$num
ææ  !
)
ææ! "
*
ææ# $

heightStep
ææ% /
;
ææ/ 0
for
¿¿ 
(
¿¿ 
int
¿¿ 
n
¿¿ 
=
¿¿ 
$num
¿¿ 
;
¿¿ 
n
¿¿  !
<
¿¿" #
axisDivisions
¿¿$ 1
;
¿¿1 2
n
¿¿3 4
++
¿¿4 6
)
¿¿6 7
{
¡¡ 
verts
¬¬ 
[
¬¬ 
it
¬¬ 
+
¬¬ 
$num
¬¬  
]
¬¬  !
=
¬¬" #
new
¬¬$ '
Vector3
¬¬( /
(
¬¬/ 0
circle
¬¬0 6
[
¬¬6 7
n
¬¬7 8
+
¬¬9 :
$num
¬¬; <
]
¬¬< =
.
¬¬= >
x
¬¬> ?
,
¬¬? @
Y
¬¬A B
,
¬¬B C
circle
¬¬D J
[
¬¬J K
n
¬¬K L
+
¬¬M N
$num
¬¬O P
]
¬¬P Q
.
¬¬Q R
z
¬¬R S
)
¬¬S T
;
¬¬T U
verts
√√ 
[
√√ 
it
√√ 
+
√√ 
$num
√√  
]
√√  !
=
√√" #
new
√√$ '
Vector3
√√( /
(
√√/ 0
circle
√√0 6
[
√√6 7
n
√√7 8
+
√√9 :
$num
√√; <
]
√√< =
.
√√= >
x
√√> ?
,
√√? @
Y2
√√A C
,
√√C D
circle
√√E K
[
√√K L
n
√√L M
+
√√N O
$num
√√P Q
]
√√Q R
.
√√R S
z
√√S T
)
√√T U
;
√√U V
if
≈≈ 
(
≈≈ 
n
≈≈ 
!=
≈≈ 
axisDivisions
≈≈ *
-
≈≈+ ,
$num
≈≈- .
)
≈≈. /
{
∆∆ 
verts
«« 
[
«« 
it
««  
+
««! "
$num
««# $
]
««$ %
=
««& '
new
««( +
Vector3
««, 3
(
««3 4
circle
««4 :
[
««: ;
n
««; <
+
««= >
$num
««? @
]
««@ A
.
««A B
x
««B C
,
««C D
Y
««E F
,
««F G
circle
««H N
[
««N O
n
««O P
+
««Q R
$num
««S T
]
««T U
.
««U V
z
««V W
)
««W X
;
««X Y
verts
»» 
[
»» 
it
»»  
+
»»! "
$num
»»# $
]
»»$ %
=
»»& '
new
»»( +
Vector3
»», 3
(
»»3 4
circle
»»4 :
[
»»: ;
n
»»; <
+
»»= >
$num
»»? @
]
»»@ A
.
»»A B
x
»»B C
,
»»C D
Y2
»»E G
,
»»G H
circle
»»I O
[
»»O P
n
»»P Q
+
»»R S
$num
»»T U
]
»»U V
.
»»V W
z
»»W X
)
»»X Y
;
»»Y Z
}
…… 
else
   
{
ÀÀ 
verts
ÃÃ 
[
ÃÃ 
it
ÃÃ  
+
ÃÃ! "
$num
ÃÃ# $
]
ÃÃ$ %
=
ÃÃ& '
new
ÃÃ( +
Vector3
ÃÃ, 3
(
ÃÃ3 4
circle
ÃÃ4 :
[
ÃÃ: ;
$num
ÃÃ; <
]
ÃÃ< =
.
ÃÃ= >
x
ÃÃ> ?
,
ÃÃ? @
Y
ÃÃA B
,
ÃÃB C
circle
ÃÃD J
[
ÃÃJ K
$num
ÃÃK L
]
ÃÃL M
.
ÃÃM N
z
ÃÃN O
)
ÃÃO P
;
ÃÃP Q
verts
ÕÕ 
[
ÕÕ 
it
ÕÕ  
+
ÕÕ! "
$num
ÕÕ# $
]
ÕÕ$ %
=
ÕÕ& '
new
ÕÕ( +
Vector3
ÕÕ, 3
(
ÕÕ3 4
circle
ÕÕ4 :
[
ÕÕ: ;
$num
ÕÕ; <
]
ÕÕ< =
.
ÕÕ= >
x
ÕÕ> ?
,
ÕÕ? @
Y2
ÕÕA C
,
ÕÕC D
circle
ÕÕE K
[
ÕÕK L
$num
ÕÕL M
]
ÕÕM N
.
ÕÕN O
z
ÕÕO P
)
ÕÕP Q
;
ÕÕQ R
}
ŒŒ 
it
–– 
+=
–– 
$num
–– 
;
–– 
}
—— 
}
““ 
int
’’ 
f
’’ 
=
’’ 
$num
’’ 
;
’’ 
for
÷÷ 
(
÷÷ 
int
÷÷ 
i
÷÷ 
=
÷÷ 
$num
÷÷ 
;
÷÷ 
i
÷÷ 
<
÷÷ 

heightCuts
÷÷  *
+
÷÷+ ,
$num
÷÷- .
;
÷÷. /
i
÷÷0 1
++
÷÷1 3
)
÷÷3 4
{
◊◊ 
for
ÿÿ 
(
ÿÿ 
int
ÿÿ 
n
ÿÿ 
=
ÿÿ 
$num
ÿÿ 
;
ÿÿ 
n
ÿÿ  !
<
ÿÿ" #
axisDivisions
ÿÿ$ 1
*
ÿÿ2 3
$num
ÿÿ4 5
;
ÿÿ5 6
n
ÿÿ7 8
+=
ÿÿ9 ;
$num
ÿÿ< =
)
ÿÿ= >
{
ŸŸ 
int
⁄⁄ 
index
⁄⁄ 
=
⁄⁄ 
(
⁄⁄  !
i
⁄⁄! "
*
⁄⁄# $
(
⁄⁄% &
axisDivisions
⁄⁄& 3
*
⁄⁄4 5
$num
⁄⁄6 7
)
⁄⁄7 8
)
⁄⁄8 9
+
⁄⁄: ;
n
⁄⁄< =
;
⁄⁄= >
int
€€ 
zero
€€ 
=
€€  !
index
€€" '
;
€€' (
int
‹‹ 
one
‹‹ 
=
‹‹  !
index
‹‹" '
+
‹‹( )
$num
‹‹* +
;
‹‹+ ,
int
›› 
two
›› 
=
››  !
index
››" '
+
››( )
$num
››* +
;
››+ ,
int
ﬁﬁ 
three
ﬁﬁ 
=
ﬁﬁ  !
index
ﬁﬁ" '
+
ﬁﬁ( )
$num
ﬁﬁ* +
;
ﬁﬁ+ ,
faces
‡‡ 
[
‡‡ 
f
‡‡ 
++
‡‡ 
]
‡‡ 
=
‡‡  
new
‡‡! $
Face
‡‡% )
(
‡‡) *
new
·· 
int
··  #
[
··# $
$num
··$ %
]
··% &
{
··' (
zero
··) -
,
··- .
one
··/ 2
,
··2 3
two
··4 7
,
··7 8
one
··9 <
,
··< =
three
··> C
,
··C D
two
··E H
}
··I J
,
··J K
$num
‚‚ 
,
‚‚  
AutoUnwrapSettings
„„ .
.
„„. /
tile
„„/ 3
,
„„3 4
	smoothing
‰‰ %
,
‰‰% &
-
ÂÂ 
$num
ÂÂ 
,
ÂÂ 
-
ÊÊ 
$num
ÊÊ 
,
ÊÊ 
false
ÁÁ !
)
ÁÁ! "
;
ÁÁ" #
}
ËË 
}
ÈÈ 
int
ÏÏ 
ind
ÏÏ 
=
ÏÏ 
(
ÏÏ 
axisDivisions
ÏÏ $
*
ÏÏ% &
(
ÏÏ' (

heightCuts
ÏÏ( 2
+
ÏÏ3 4
$num
ÏÏ5 6
)
ÏÏ6 7
*
ÏÏ8 9
$num
ÏÏ: ;
)
ÏÏ; <
;
ÏÏ< =
int
ÌÌ 
f_ind
ÌÌ 
=
ÌÌ 
axisDivisions
ÌÌ %
*
ÌÌ& '
(
ÌÌ( )

heightCuts
ÌÌ) 3
+
ÌÌ4 5
$num
ÌÌ6 7
)
ÌÌ7 8
;
ÌÌ8 9
for
ÔÔ 
(
ÔÔ 
int
ÔÔ 
n
ÔÔ 
=
ÔÔ 
$num
ÔÔ 
;
ÔÔ 
n
ÔÔ 
<
ÔÔ 
axisDivisions
ÔÔ  -
;
ÔÔ- .
n
ÔÔ/ 0
++
ÔÔ0 2
)
ÔÔ2 3
{
 
verts
ÚÚ 
[
ÚÚ 
ind
ÚÚ 
+
ÚÚ 
$num
ÚÚ 
]
ÚÚ 
=
ÚÚ  
new
ÚÚ! $
Vector3
ÚÚ% ,
(
ÚÚ, -
circle
ÚÚ- 3
[
ÚÚ3 4
n
ÚÚ4 5
]
ÚÚ5 6
.
ÚÚ6 7
x
ÚÚ7 8
,
ÚÚ8 9
$num
ÚÚ: <
,
ÚÚ< =
circle
ÚÚ> D
[
ÚÚD E
n
ÚÚE F
]
ÚÚF G
.
ÚÚG H
z
ÚÚH I
)
ÚÚI J
;
ÚÚJ K
verts
ÙÙ 
[
ÙÙ 
ind
ÙÙ 
+
ÙÙ 
$num
ÙÙ 
]
ÙÙ 
=
ÙÙ  
Vector3
ÙÙ! (
.
ÙÙ( )
zero
ÙÙ) -
;
ÙÙ- .
if
ˆˆ 
(
ˆˆ 
n
ˆˆ 
!=
ˆˆ 
axisDivisions
ˆˆ &
-
ˆˆ' (
$num
ˆˆ) *
)
ˆˆ* +
verts
˜˜ 
[
˜˜ 
ind
˜˜ 
+
˜˜ 
$num
˜˜  !
]
˜˜! "
=
˜˜# $
new
˜˜% (
Vector3
˜˜) 0
(
˜˜0 1
circle
˜˜1 7
[
˜˜7 8
n
˜˜8 9
+
˜˜: ;
$num
˜˜< =
]
˜˜= >
.
˜˜> ?
x
˜˜? @
,
˜˜@ A
$num
˜˜B D
,
˜˜D E
circle
˜˜F L
[
˜˜L M
n
˜˜M N
+
˜˜O P
$num
˜˜Q R
]
˜˜R S
.
˜˜S T
z
˜˜T U
)
˜˜U V
;
˜˜V W
else
¯¯ 
verts
˘˘ 
[
˘˘ 
ind
˘˘ 
+
˘˘ 
$num
˘˘  !
]
˘˘! "
=
˘˘# $
new
˘˘% (
Vector3
˘˘) 0
(
˘˘0 1
circle
˘˘1 7
[
˘˘7 8
$num
˘˘8 ;
]
˘˘; <
.
˘˘< =
x
˘˘= >
,
˘˘> ?
$num
˘˘@ B
,
˘˘B C
circle
˘˘D J
[
˘˘J K
$num
˘˘K N
]
˘˘N O
.
˘˘O P
z
˘˘P Q
)
˘˘Q R
;
˘˘R S
faces
˚˚ 
[
˚˚ 
f_ind
˚˚ 
+
˚˚ 
n
˚˚ 
]
˚˚  
=
˚˚! "
new
˚˚# &
Face
˚˚' +
(
˚˚+ ,
new
˚˚, /
int
˚˚0 3
[
˚˚3 4
$num
˚˚4 5
]
˚˚5 6
{
˚˚7 8
ind
˚˚8 ;
+
˚˚< =
$num
˚˚> ?
,
˚˚? @
ind
˚˚A D
+
˚˚E F
$num
˚˚G H
,
˚˚H I
ind
˚˚J M
+
˚˚N O
$num
˚˚P Q
}
˚˚Q R
)
˚˚R S
;
˚˚S T
ind
˝˝ 
+=
˝˝ 
$num
˝˝ 
;
˝˝ 
verts
ÄÄ 
[
ÄÄ 
ind
ÄÄ 
+
ÄÄ 
$num
ÄÄ 
]
ÄÄ 
=
ÄÄ" #
new
ÄÄ$ '
Vector3
ÄÄ( /
(
ÄÄ/ 0
circle
ÄÄ0 6
[
ÄÄ6 7
n
ÄÄ7 8
]
ÄÄ8 9
.
ÄÄ9 :
x
ÄÄ: ;
,
ÄÄ; <
height
ÄÄ= C
,
ÄÄC D
circle
ÄÄE K
[
ÄÄK L
n
ÄÄL M
]
ÄÄM N
.
ÄÄN O
z
ÄÄO P
)
ÄÄP Q
;
ÄÄQ R
verts
ÅÅ 
[
ÅÅ 
ind
ÅÅ 
+
ÅÅ 
$num
ÅÅ 
]
ÅÅ 
=
ÅÅ" #
new
ÅÅ$ '
Vector3
ÅÅ( /
(
ÅÅ/ 0
$num
ÅÅ0 2
,
ÅÅ2 3
height
ÅÅ4 :
,
ÅÅ: ;
$num
ÅÅ< >
)
ÅÅ> ?
;
ÅÅ? @
if
ÇÇ 
(
ÇÇ 
n
ÇÇ 
!=
ÇÇ 
axisDivisions
ÇÇ &
-
ÇÇ' (
$num
ÇÇ) *
)
ÇÇ* +
verts
ÉÉ 
[
ÉÉ 
ind
ÉÉ 
+
ÉÉ 
$num
ÉÉ  !
]
ÉÉ! "
=
ÉÉ# $
new
ÉÉ% (
Vector3
ÉÉ) 0
(
ÉÉ0 1
circle
ÉÉ1 7
[
ÉÉ7 8
n
ÉÉ8 9
+
ÉÉ: ;
$num
ÉÉ< =
]
ÉÉ= >
.
ÉÉ> ?
x
ÉÉ? @
,
ÉÉ@ A
height
ÉÉB H
,
ÉÉH I
circle
ÉÉJ P
[
ÉÉP Q
n
ÉÉQ R
+
ÉÉS T
$num
ÉÉU V
]
ÉÉV W
.
ÉÉW X
z
ÉÉX Y
)
ÉÉY Z
;
ÉÉZ [
else
ÑÑ 
verts
ÖÖ 
[
ÖÖ 
ind
ÖÖ 
+
ÖÖ 
$num
ÖÖ  !
]
ÖÖ! "
=
ÖÖ# $
new
ÖÖ% (
Vector3
ÖÖ) 0
(
ÖÖ0 1
circle
ÖÖ1 7
[
ÖÖ7 8
$num
ÖÖ8 ;
]
ÖÖ; <
.
ÖÖ< =
x
ÖÖ= >
,
ÖÖ> ?
height
ÖÖ@ F
,
ÖÖF G
circle
ÖÖH N
[
ÖÖN O
$num
ÖÖO R
]
ÖÖR S
.
ÖÖS T
z
ÖÖT U
)
ÖÖU V
;
ÖÖV W
faces
áá 
[
áá 
f_ind
áá 
+
áá 
(
áá 
n
áá  
+
áá! "
axisDivisions
áá# 0
)
áá0 1
]
áá1 2
=
áá3 4
new
áá5 8
Face
áá9 =
(
áá= >
new
áá> A
int
ááB E
[
ááE F
$num
ááF G
]
ááG H
{
ááI J
ind
ááJ M
+
ááN O
$num
ááP Q
,
ááQ R
ind
ááS V
+
ááW X
$num
ááY Z
,
ááZ [
ind
áá\ _
+
áá` a
$num
ááb c
}
áác d
)
áád e
;
ááe f
ind
ââ 
+=
ââ 
$num
ââ 
;
ââ 
}
ää 
ProBuilderMesh
åå 
pb
åå 
=
åå 
ProBuilderMesh
åå  .
.
åå. /
Create
åå/ 5
(
åå5 6
verts
åå6 ;
,
åå; <
faces
åå= B
)
ååB C
;
ååC D
pb
çç 
.
çç 

gameObject
çç 
.
çç 
name
çç 
=
çç  
$str
çç! +
;
çç+ ,
pb
éé 
.
éé 
SetPivot
éé 
(
éé 
	pivotType
éé !
)
éé! "
;
éé" #
return
êê 
pb
êê 
;
êê 
}
ëë 	
public
ôô 
static
ôô 
ProBuilderMesh
ôô $
GeneratePrism
ôô% 2
(
ôô2 3
PivotLocation
ôô3 @
	pivotType
ôôA J
,
ôôJ K
Vector3
ôôL S
size
ôôT X
)
ôôX Y
{
öö 	
size
õõ 
.
õõ 
y
õõ 
*=
õõ 
$num
õõ 
;
õõ 
Vector3
ùù 
[
ùù 
]
ùù 
template
ùù 
=
ùù  
new
ùù! $
Vector3
ùù% ,
[
ùù, -
$num
ùù- .
]
ùù. /
{
ûû 
Vector3
üü 
.
üü 
Scale
üü 
(
üü 
new
üü !
Vector3
üü" )
(
üü) *
-
üü* +
$num
üü+ .
,
üü. /
$num
üü0 2
,
üü2 3
-
üü4 5
$num
üü5 8
)
üü8 9
,
üü9 :
size
üü< @
)
üü@ A
,
üüA B
Vector3
†† 
.
†† 
Scale
†† 
(
†† 
new
†† !
Vector3
††" )
(
††) *
$num
††* -
,
††- .
$num
††/ 1
,
††1 2
-
††3 4
$num
††4 7
)
††7 8
,
††8 9
size
††< @
)
††@ A
,
††A B
Vector3
°° 
.
°° 
Scale
°° 
(
°° 
new
°° !
Vector3
°°" )
(
°°) *
$num
°°* ,
,
°°, -
$num
°°. 1
,
°°1 2
-
°°3 4
$num
°°4 7
)
°°7 8
,
°°8 9
size
°°< @
)
°°@ A
,
°°A B
Vector3
¢¢ 
.
¢¢ 
Scale
¢¢ 
(
¢¢ 
new
¢¢ !
Vector3
¢¢" )
(
¢¢) *
-
¢¢* +
$num
¢¢+ .
,
¢¢. /
$num
¢¢0 2
,
¢¢2 3
$num
¢¢4 7
)
¢¢7 8
,
¢¢8 9
size
¢¢< @
)
¢¢@ A
,
¢¢A B
Vector3
££ 
.
££ 
Scale
££ 
(
££ 
new
££ !
Vector3
££" )
(
££) *
$num
££* .
,
££. /
$num
££0 2
,
££2 3
$num
££4 7
)
££7 8
,
££8 9
size
££< @
)
££@ A
,
££A B
Vector3
§§ 
.
§§ 
Scale
§§ 
(
§§ 
new
§§ !
Vector3
§§" )
(
§§) *
$num
§§* ,
,
§§, -
$num
§§. 1
,
§§1 2
$num
§§3 6
)
§§6 7
,
§§7 8
size
§§< @
)
§§@ A
}
•• 
;
•• 
Vector3
ßß 
[
ßß 
]
ßß 
v
ßß 
=
ßß 
new
ßß 
Vector3
ßß %
[
ßß% &
$num
ßß& (
]
ßß( )
{
®® 
template
©© 
[
©© 
$num
©© 
]
©© 
,
©© 
template
™™ 
[
™™ 
$num
™™ 
]
™™ 
,
™™ 
template
´´ 
[
´´ 
$num
´´ 
]
´´ 
,
´´ 
template
≠≠ 
[
≠≠ 
$num
≠≠ 
]
≠≠ 
,
≠≠ 
template
ÆÆ 
[
ÆÆ 
$num
ÆÆ 
]
ÆÆ 
,
ÆÆ 
template
ØØ 
[
ØØ 
$num
ØØ 
]
ØØ 
,
ØØ 
template
∞∞ 
[
∞∞ 
$num
∞∞ 
]
∞∞ 
,
∞∞ 
template
≤≤ 
[
≤≤ 
$num
≤≤ 
]
≤≤ 
,
≤≤ 
template
≥≥ 
[
≥≥ 
$num
≥≥ 
]
≥≥ 
,
≥≥ 
template
¥¥ 
[
¥¥ 
$num
¥¥ 
]
¥¥ 
,
¥¥ 
template
∂∂ 
[
∂∂ 
$num
∂∂ 
]
∂∂ 
,
∂∂ 
template
∑∑ 
[
∑∑ 
$num
∑∑ 
]
∑∑ 
,
∑∑ 
template
∏∏ 
[
∏∏ 
$num
∏∏ 
]
∏∏ 
,
∏∏ 
template
ππ 
[
ππ 
$num
ππ 
]
ππ 
,
ππ 
template
ªª 
[
ªª 
$num
ªª 
]
ªª 
,
ªª 
template
ºº 
[
ºº 
$num
ºº 
]
ºº 
,
ºº 
template
ΩΩ 
[
ΩΩ 
$num
ΩΩ 
]
ΩΩ 
,
ΩΩ 
template
ææ 
[
ææ 
$num
ææ 
]
ææ 
}
øø 
;
øø 
Face
¡¡ 
[
¡¡ 
]
¡¡ 
f
¡¡ 
=
¡¡ 
new
¡¡ 
Face
¡¡ 
[
¡¡  
$num
¡¡  !
]
¡¡! "
{
¬¬ 
new
√√ 
Face
√√ 
(
√√ 
new
√√ 
int
√√  
[
√√  !
$num
√√! "
]
√√" #
{
√√$ %
$num
√√% &
,
√√& '
$num
√√( )
,
√√) *
$num
√√+ ,
}
√√, -
)
√√- .
,
√√. /
new
ƒƒ 
Face
ƒƒ 
(
ƒƒ 
new
ƒƒ 
int
ƒƒ  
[
ƒƒ  !
$num
ƒƒ! "
]
ƒƒ" #
{
ƒƒ$ %
$num
ƒƒ% &
,
ƒƒ& '
$num
ƒƒ( )
,
ƒƒ) *
$num
ƒƒ+ ,
,
ƒƒ, -
$num
ƒƒ. /
,
ƒƒ/ 0
$num
ƒƒ1 2
,
ƒƒ2 3
$num
ƒƒ4 5
}
ƒƒ5 6
)
ƒƒ6 7
,
ƒƒ7 8
new
≈≈ 
Face
≈≈ 
(
≈≈ 
new
≈≈ 
int
≈≈  
[
≈≈  !
$num
≈≈! "
]
≈≈" #
{
≈≈$ %
$num
≈≈% &
,
≈≈& '
$num
≈≈( )
,
≈≈) *
$num
≈≈+ ,
}
≈≈, -
)
≈≈- .
,
≈≈. /
new
∆∆ 
Face
∆∆ 
(
∆∆ 
new
∆∆ 
int
∆∆  
[
∆∆  !
$num
∆∆! "
]
∆∆" #
{
∆∆$ %
$num
∆∆% '
,
∆∆' (
$num
∆∆) +
,
∆∆+ ,
$num
∆∆- /
,
∆∆/ 0
$num
∆∆1 3
,
∆∆3 4
$num
∆∆5 7
,
∆∆7 8
$num
∆∆9 ;
}
∆∆; <
)
∆∆< =
,
∆∆= >
new
«« 
Face
«« 
(
«« 
new
«« 
int
««  
[
««  !
$num
««! "
]
««" #
{
««$ %
$num
««% '
,
««' (
$num
««) +
,
««+ ,
$num
««- /
,
««/ 0
$num
««1 3
,
««3 4
$num
««5 7
,
««7 8
$num
««9 ;
}
««; <
)
««< =
}
»» 
;
»» 
ProBuilderMesh
   
pb
   
=
   
ProBuilderMesh
    .
.
  . /
Create
  / 5
(
  5 6
v
  6 7
,
  7 8
f
  9 :
)
  : ;
;
  ; <
pb
ÀÀ 
.
ÀÀ 

gameObject
ÀÀ 
.
ÀÀ 
name
ÀÀ 
=
ÀÀ  
$str
ÀÀ! (
;
ÀÀ( )
pb
ÃÃ 
.
ÃÃ 
SetPivot
ÃÃ 
(
ÃÃ 
	pivotType
ÃÃ !
)
ÃÃ! "
;
ÃÃ" #
return
ŒŒ 
pb
ŒŒ 
;
ŒŒ 
}
œœ 	
public
€€ 
static
€€ 
ProBuilderMesh
€€ $
GenerateDoor
€€% 1
(
€€1 2
PivotLocation
€€2 ?
	pivotType
€€@ I
,
€€I J
float
€€K P

totalWidth
€€Q [
,
€€[ \
float
€€] b
totalHeight
€€c n
,
€€n o
float
€€p u
ledgeHeight€€v Å
,€€Å Ç
float€€É à
legWidth€€â ë
,€€ë í
float€€ì ò
depth€€ô û
)€€û ü
{
‹‹ 	
float
›› 
	xLegCoord
›› 
=
›› 

totalWidth
›› (
/
››) *
$num
››+ -
;
››- .
legWidth
ﬁﬁ 
=
ﬁﬁ 
	xLegCoord
ﬁﬁ  
-
ﬁﬁ! "
legWidth
ﬁﬁ# +
;
ﬁﬁ+ ,
ledgeHeight
ﬂﬂ 
=
ﬂﬂ 
totalHeight
ﬂﬂ %
-
ﬂﬂ& '
ledgeHeight
ﬂﬂ( 3
;
ﬂﬂ3 4
Vector3
ÊÊ 
[
ÊÊ 
]
ÊÊ 
template
ÊÊ 
=
ÊÊ  
new
ÊÊ! $
Vector3
ÊÊ% ,
[
ÊÊ, -
$num
ÊÊ- /
]
ÊÊ/ 0
{
ÁÁ 
new
ËË 
Vector3
ËË 
(
ËË 
-
ËË 
	xLegCoord
ËË &
,
ËË& '
$num
ËË( *
,
ËË* +
depth
ËË, 1
)
ËË1 2
,
ËË2 3
new
ÈÈ 
Vector3
ÈÈ 
(
ÈÈ 
-
ÈÈ 
legWidth
ÈÈ %
,
ÈÈ% &
$num
ÈÈ' )
,
ÈÈ) *
depth
ÈÈ+ 0
)
ÈÈ0 1
,
ÈÈ1 2
new
ÍÍ 
Vector3
ÍÍ 
(
ÍÍ 
legWidth
ÍÍ $
,
ÍÍ$ %
$num
ÍÍ& (
,
ÍÍ( )
depth
ÍÍ* /
)
ÍÍ/ 0
,
ÍÍ0 1
new
ÎÎ 
Vector3
ÎÎ 
(
ÎÎ 
	xLegCoord
ÎÎ %
,
ÎÎ% &
$num
ÎÎ' )
,
ÎÎ) *
depth
ÎÎ+ 0
)
ÎÎ0 1
,
ÎÎ1 2
new
ÏÏ 
Vector3
ÏÏ 
(
ÏÏ 
-
ÏÏ 
	xLegCoord
ÏÏ &
,
ÏÏ& '
ledgeHeight
ÏÏ( 3
,
ÏÏ3 4
depth
ÏÏ5 :
)
ÏÏ: ;
,
ÏÏ; <
new
ÌÌ 
Vector3
ÌÌ 
(
ÌÌ 
-
ÌÌ 
legWidth
ÌÌ %
,
ÌÌ% &
ledgeHeight
ÌÌ' 2
,
ÌÌ2 3
depth
ÌÌ4 9
)
ÌÌ9 :
,
ÌÌ: ;
new
ÓÓ 
Vector3
ÓÓ 
(
ÓÓ 
legWidth
ÓÓ $
,
ÓÓ$ %
ledgeHeight
ÓÓ& 1
,
ÓÓ1 2
depth
ÓÓ3 8
)
ÓÓ8 9
,
ÓÓ9 :
new
ÔÔ 
Vector3
ÔÔ 
(
ÔÔ 
	xLegCoord
ÔÔ %
,
ÔÔ% &
ledgeHeight
ÔÔ' 2
,
ÔÔ2 3
depth
ÔÔ4 9
)
ÔÔ9 :
,
ÔÔ: ;
new
 
Vector3
 
(
 
-
 
	xLegCoord
 &
,
& '
totalHeight
( 3
,
3 4
depth
5 :
)
: ;
,
; <
new
ÒÒ 
Vector3
ÒÒ 
(
ÒÒ 
-
ÒÒ 
legWidth
ÒÒ %
,
ÒÒ% &
totalHeight
ÒÒ' 2
,
ÒÒ2 3
depth
ÒÒ4 9
)
ÒÒ9 :
,
ÒÒ: ;
new
ÚÚ 
Vector3
ÚÚ 
(
ÚÚ 
legWidth
ÚÚ $
,
ÚÚ$ %
totalHeight
ÚÚ& 1
,
ÚÚ1 2
depth
ÚÚ3 8
)
ÚÚ8 9
,
ÚÚ9 :
new
ÛÛ 
Vector3
ÛÛ 
(
ÛÛ 
	xLegCoord
ÛÛ %
,
ÛÛ% &
totalHeight
ÛÛ' 2
,
ÛÛ2 3
depth
ÛÛ4 9
)
ÛÛ9 :
}
ÙÙ 
;
ÙÙ 
List
ˆˆ 
<
ˆˆ 
Vector3
ˆˆ 
>
ˆˆ 
points
ˆˆ  
=
ˆˆ! "
new
ˆˆ# &
List
ˆˆ' +
<
ˆˆ+ ,
Vector3
ˆˆ, 3
>
ˆˆ3 4
(
ˆˆ4 5
)
ˆˆ5 6
;
ˆˆ6 7
points
¯¯ 
.
¯¯ 
Add
¯¯ 
(
¯¯ 
template
¯¯ 
[
¯¯  
$num
¯¯  !
]
¯¯! "
)
¯¯" #
;
¯¯# $
points
˘˘ 
.
˘˘ 
Add
˘˘ 
(
˘˘ 
template
˘˘ 
[
˘˘  
$num
˘˘  !
]
˘˘! "
)
˘˘" #
;
˘˘# $
points
˙˙ 
.
˙˙ 
Add
˙˙ 
(
˙˙ 
template
˙˙ 
[
˙˙  
$num
˙˙  !
]
˙˙! "
)
˙˙" #
;
˙˙# $
points
˚˚ 
.
˚˚ 
Add
˚˚ 
(
˚˚ 
template
˚˚ 
[
˚˚  
$num
˚˚  !
]
˚˚! "
)
˚˚" #
;
˚˚# $
points
˝˝ 
.
˝˝ 
Add
˝˝ 
(
˝˝ 
template
˝˝ 
[
˝˝  
$num
˝˝  !
]
˝˝! "
)
˝˝" #
;
˝˝# $
points
˛˛ 
.
˛˛ 
Add
˛˛ 
(
˛˛ 
template
˛˛ 
[
˛˛  
$num
˛˛  !
]
˛˛! "
)
˛˛" #
;
˛˛# $
points
ˇˇ 
.
ˇˇ 
Add
ˇˇ 
(
ˇˇ 
template
ˇˇ 
[
ˇˇ  
$num
ˇˇ  !
]
ˇˇ! "
)
ˇˇ" #
;
ˇˇ# $
points
ÄÄ 
.
ÄÄ 
Add
ÄÄ 
(
ÄÄ 
template
ÄÄ 
[
ÄÄ  
$num
ÄÄ  !
]
ÄÄ! "
)
ÄÄ" #
;
ÄÄ# $
points
ÇÇ 
.
ÇÇ 
Add
ÇÇ 
(
ÇÇ 
template
ÇÇ 
[
ÇÇ  
$num
ÇÇ  !
]
ÇÇ! "
)
ÇÇ" #
;
ÇÇ# $
points
ÉÉ 
.
ÉÉ 
Add
ÉÉ 
(
ÉÉ 
template
ÉÉ 
[
ÉÉ  
$num
ÉÉ  !
]
ÉÉ! "
)
ÉÉ" #
;
ÉÉ# $
points
ÑÑ 
.
ÑÑ 
Add
ÑÑ 
(
ÑÑ 
template
ÑÑ 
[
ÑÑ  
$num
ÑÑ  !
]
ÑÑ! "
)
ÑÑ" #
;
ÑÑ# $
points
ÖÖ 
.
ÖÖ 
Add
ÖÖ 
(
ÖÖ 
template
ÖÖ 
[
ÖÖ  
$num
ÖÖ  !
]
ÖÖ! "
)
ÖÖ" #
;
ÖÖ# $
points
áá 
.
áá 
Add
áá 
(
áá 
template
áá 
[
áá  
$num
áá  !
]
áá! "
)
áá" #
;
áá# $
points
àà 
.
àà 
Add
àà 
(
àà 
template
àà 
[
àà  
$num
àà  !
]
àà! "
)
àà" #
;
àà# $
points
ââ 
.
ââ 
Add
ââ 
(
ââ 
template
ââ 
[
ââ  
$num
ââ  "
]
ââ" #
)
ââ# $
;
ââ$ %
points
ää 
.
ää 
Add
ää 
(
ää 
template
ää 
[
ää  
$num
ää  "
]
ää" #
)
ää# $
;
ää$ %
points
åå 
.
åå 
Add
åå 
(
åå 
template
åå 
[
åå  
$num
åå  !
]
åå! "
)
åå" #
;
åå# $
points
çç 
.
çç 
Add
çç 
(
çç 
template
çç 
[
çç  
$num
çç  !
]
çç! "
)
çç" #
;
çç# $
points
éé 
.
éé 
Add
éé 
(
éé 
template
éé 
[
éé  
$num
éé  !
]
éé! "
)
éé" #
;
éé# $
points
èè 
.
èè 
Add
èè 
(
èè 
template
èè 
[
èè  
$num
èè  "
]
èè" #
)
èè# $
;
èè$ %
List
ëë 
<
ëë 
Vector3
ëë 
>
ëë 
reverse
ëë !
=
ëë" #
new
ëë$ '
List
ëë( ,
<
ëë, -
Vector3
ëë- 4
>
ëë4 5
(
ëë5 6
)
ëë6 7
;
ëë7 8
for
ìì 
(
ìì 
int
ìì 
i
ìì 
=
ìì 
$num
ìì 
;
ìì 
i
ìì 
<
ìì 
points
ìì  &
.
ìì& '
Count
ìì' ,
;
ìì, -
i
ìì. /
+=
ìì0 2
$num
ìì3 4
)
ìì4 5
{
îî 
reverse
ïï 
.
ïï 
Add
ïï 
(
ïï 
points
ïï "
[
ïï" #
i
ïï# $
+
ïï% &
$num
ïï' (
]
ïï( )
-
ïï* +
Vector3
ïï, 3
.
ïï3 4
forward
ïï4 ;
*
ïï< =
depth
ïï> C
)
ïïC D
;
ïïD E
reverse
ññ 
.
ññ 
Add
ññ 
(
ññ 
points
ññ "
[
ññ" #
i
ññ# $
+
ññ% &
$num
ññ' (
]
ññ( )
-
ññ* +
Vector3
ññ, 3
.
ññ3 4
forward
ññ4 ;
*
ññ< =
depth
ññ> C
)
ññC D
;
ññD E
reverse
óó 
.
óó 
Add
óó 
(
óó 
points
óó "
[
óó" #
i
óó# $
+
óó% &
$num
óó' (
]
óó( )
-
óó* +
Vector3
óó, 3
.
óó3 4
forward
óó4 ;
*
óó< =
depth
óó> C
)
óóC D
;
óóD E
reverse
òò 
.
òò 
Add
òò 
(
òò 
points
òò "
[
òò" #
i
òò# $
+
òò% &
$num
òò' (
]
òò( )
-
òò* +
Vector3
òò, 3
.
òò3 4
forward
òò4 ;
*
òò< =
depth
òò> C
)
òòC D
;
òòD E
}
ôô 
points
õõ 
.
õõ 
AddRange
õõ 
(
õõ 
reverse
õõ #
)
õõ# $
;
õõ$ %
points
ùù 
.
ùù 
Add
ùù 
(
ùù 
template
ùù 
[
ùù  
$num
ùù  !
]
ùù! "
)
ùù" #
;
ùù# $
points
ûû 
.
ûû 
Add
ûû 
(
ûû 
template
ûû 
[
ûû  
$num
ûû  !
]
ûû! "
)
ûû" #
;
ûû# $
points
üü 
.
üü 
Add
üü 
(
üü 
template
üü 
[
üü  
$num
üü  !
]
üü! "
-
üü# $
Vector3
üü% ,
.
üü, -
forward
üü- 4
*
üü5 6
depth
üü7 <
)
üü< =
;
üü= >
points
†† 
.
†† 
Add
†† 
(
†† 
template
†† 
[
††  
$num
††  !
]
††! "
-
††# $
Vector3
††% ,
.
††, -
forward
††- 4
*
††5 6
depth
††7 <
)
††< =
;
††= >
points
¢¢ 
.
¢¢ 
Add
¢¢ 
(
¢¢ 
template
¢¢ 
[
¢¢  
$num
¢¢  !
]
¢¢! "
-
¢¢# $
Vector3
¢¢% ,
.
¢¢, -
forward
¢¢- 4
*
¢¢5 6
depth
¢¢7 <
)
¢¢< =
;
¢¢= >
points
££ 
.
££ 
Add
££ 
(
££ 
template
££ 
[
££  
$num
££  !
]
££! "
)
££" #
;
££# $
points
§§ 
.
§§ 
Add
§§ 
(
§§ 
template
§§ 
[
§§  
$num
§§  !
]
§§! "
-
§§# $
Vector3
§§% ,
.
§§, -
forward
§§- 4
*
§§5 6
depth
§§7 <
)
§§< =
;
§§= >
points
•• 
.
•• 
Add
•• 
(
•• 
template
•• 
[
••  
$num
••  !
]
••! "
)
••" #
;
••# $
points
ßß 
.
ßß 
Add
ßß 
(
ßß 
template
ßß 
[
ßß  
$num
ßß  !
]
ßß! "
)
ßß" #
;
ßß# $
points
®® 
.
®® 
Add
®® 
(
®® 
template
®® 
[
®®  
$num
®®  !
]
®®! "
-
®®# $
Vector3
®®% ,
.
®®, -
forward
®®- 4
*
®®5 6
depth
®®7 <
)
®®< =
;
®®= >
points
©© 
.
©© 
Add
©© 
(
©© 
template
©© 
[
©©  
$num
©©  !
]
©©! "
)
©©" #
;
©©# $
points
™™ 
.
™™ 
Add
™™ 
(
™™ 
template
™™ 
[
™™  
$num
™™  !
]
™™! "
-
™™# $
Vector3
™™% ,
.
™™, -
forward
™™- 4
*
™™5 6
depth
™™7 <
)
™™< =
;
™™= >
ProBuilderMesh
¨¨ 
pb
¨¨ 
=
¨¨ 
ProBuilderMesh
¨¨  .
.
¨¨. /&
CreateInstanceWithPoints
¨¨/ G
(
¨¨G H
points
¨¨H N
.
¨¨N O
ToArray
¨¨O V
(
¨¨V W
)
¨¨W X
)
¨¨X Y
;
¨¨Y Z
pb
≠≠ 
.
≠≠ 

gameObject
≠≠ 
.
≠≠ 
name
≠≠ 
=
≠≠  
$str
≠≠! '
;
≠≠' (
pb
ÆÆ 
.
ÆÆ 
SetPivot
ÆÆ 
(
ÆÆ 
	pivotType
ÆÆ !
)
ÆÆ! "
;
ÆÆ" #
return
∞∞ 
pb
∞∞ 
;
∞∞ 
}
±± 	
public
ΩΩ 
static
ΩΩ 
ProBuilderMesh
ΩΩ $
GeneratePlane
ΩΩ% 2
(
ΩΩ2 3
PivotLocation
ΩΩ3 @
	pivotType
ΩΩA J
,
ΩΩJ K
float
ΩΩL Q
width
ΩΩR W
,
ΩΩW X
float
ΩΩY ^
height
ΩΩ_ e
,
ΩΩe f
int
ΩΩg j
	widthCuts
ΩΩk t
,
ΩΩt u
int
ΩΩv y

heightCutsΩΩz Ñ
,ΩΩÑ Ö
AxisΩΩÜ ä
axisΩΩã è
)ΩΩè ê
{
ææ 	
int
øø 
w
øø 
=
øø 
	widthCuts
øø 
+
øø 
$num
øø  !
;
øø! "
int
¿¿ 
h
¿¿ 
=
¿¿ 

heightCuts
¿¿ 
+
¿¿  
$num
¿¿! "
;
¿¿" #
Vector2
¬¬ 
[
¬¬ 
]
¬¬ 
p
¬¬ 
=
¬¬ 
new
¬¬ 
Vector2
¬¬ %
[
¬¬% &
(
¬¬& '
w
¬¬' (
*
¬¬) *
h
¬¬+ ,
)
¬¬, -
*
¬¬. /
$num
¬¬0 1
]
¬¬1 2
;
¬¬2 3
Vector3
√√ 
[
√√ 
]
√√ 
v
√√ 
=
√√ 
new
√√ 
Vector3
√√ %
[
√√% &
(
√√& '
w
√√' (
*
√√) *
h
√√+ ,
)
√√, -
*
√√. /
$num
√√0 1
]
√√1 2
;
√√2 3
Face
ƒƒ 
[
ƒƒ 
]
ƒƒ 
f
ƒƒ 
=
ƒƒ 
new
ƒƒ 
Face
ƒƒ 
[
ƒƒ  
w
ƒƒ  !
*
ƒƒ" #
h
ƒƒ$ %
]
ƒƒ% &
;
ƒƒ& '
int
∆∆ 
i
∆∆ 
=
∆∆ 
$num
∆∆ 
,
∆∆ 
j
∆∆ 
=
∆∆ 
$num
∆∆ 
;
∆∆ 
{
«« 
for
»» 
(
»» 
int
»» 
y
»» 
=
»» 
$num
»» 
;
»» 
y
»»  !
<
»»" #
h
»»$ %
;
»»% &
y
»»' (
++
»»( *
)
»»* +
{
…… 
for
   
(
   
int
   
x
   
=
    
$num
  ! "
;
  " #
x
  $ %
<
  & '
w
  ( )
;
  ) *
x
  + ,
++
  , .
)
  . /
{
ÀÀ 
float
ÃÃ 
x0
ÃÃ  
=
ÃÃ! "
x
ÃÃ# $
*
ÃÃ% &
(
ÃÃ' (
width
ÃÃ( -
/
ÃÃ. /
w
ÃÃ0 1
)
ÃÃ1 2
-
ÃÃ3 4
(
ÃÃ5 6
width
ÃÃ6 ;
/
ÃÃ< =
$num
ÃÃ> @
)
ÃÃ@ A
;
ÃÃA B
float
ÕÕ 
x1
ÕÕ  
=
ÕÕ! "
(
ÕÕ# $
x
ÕÕ$ %
+
ÕÕ& '
$num
ÕÕ( )
)
ÕÕ) *
*
ÕÕ+ ,
(
ÕÕ- .
width
ÕÕ. 3
/
ÕÕ4 5
w
ÕÕ6 7
)
ÕÕ7 8
-
ÕÕ9 :
(
ÕÕ; <
width
ÕÕ< A
/
ÕÕB C
$num
ÕÕD F
)
ÕÕF G
;
ÕÕG H
float
œœ 
y0
œœ  
=
œœ! "
y
œœ# $
*
œœ% &
(
œœ' (
height
œœ( .
/
œœ/ 0
h
œœ1 2
)
œœ2 3
-
œœ4 5
(
œœ6 7
height
œœ7 =
/
œœ> ?
$num
œœ@ B
)
œœB C
;
œœC D
float
–– 
y1
––  
=
––! "
(
––# $
y
––$ %
+
––& '
$num
––( )
)
––) *
*
––+ ,
(
––- .
height
––. 4
/
––5 6
h
––7 8
)
––8 9
-
––: ;
(
––< =
height
––= C
/
––D E
$num
––F H
)
––H I
;
––I J
p
““ 
[
““ 
i
““ 
+
““ 
$num
““ 
]
““  
=
““! "
new
““# &
Vector2
““' .
(
““. /
x0
““/ 1
,
““1 2
y0
““6 8
)
““8 9
;
““9 :
p
”” 
[
”” 
i
”” 
+
”” 
$num
”” 
]
””  
=
””! "
new
””# &
Vector2
””' .
(
””. /
x1
””/ 1
,
””1 2
y0
””6 8
)
””8 9
;
””9 :
p
‘‘ 
[
‘‘ 
i
‘‘ 
+
‘‘ 
$num
‘‘ 
]
‘‘  
=
‘‘! "
new
‘‘# &
Vector2
‘‘' .
(
‘‘. /
x0
‘‘/ 1
,
‘‘1 2
y1
‘‘6 8
)
‘‘8 9
;
‘‘9 :
p
’’ 
[
’’ 
i
’’ 
+
’’ 
$num
’’ 
]
’’  
=
’’! "
new
’’# &
Vector2
’’' .
(
’’. /
x1
’’/ 1
,
’’1 2
y1
’’6 8
)
’’8 9
;
’’9 :
f
◊◊ 
[
◊◊ 
j
◊◊ 
++
◊◊ 
]
◊◊ 
=
◊◊  
new
◊◊! $
Face
◊◊% )
(
◊◊) *
new
◊◊* -
int
◊◊. 1
[
◊◊1 2
$num
◊◊2 3
]
◊◊3 4
{
ÿÿ 
i
ŸŸ 
+
ŸŸ 
$num
ŸŸ  !
,
ŸŸ! "
i
⁄⁄ 
+
⁄⁄ 
$num
⁄⁄  !
,
⁄⁄! "
i
€€ 
+
€€ 
$num
€€  !
,
€€! "
i
‹‹ 
+
‹‹ 
$num
‹‹  !
,
‹‹! "
i
›› 
+
›› 
$num
››  !
,
››! "
i
ﬁﬁ 
+
ﬁﬁ 
$num
ﬁﬁ  !
}
ﬂﬂ 
)
ﬂﬂ 
;
ﬂﬂ 
i
·· 
+=
·· 
$num
·· 
;
·· 
}
‚‚ 
}
„„ 
}
‰‰ 
switch
ÊÊ 
(
ÊÊ 
axis
ÊÊ 
)
ÊÊ 
{
ÁÁ 
case
ËË 
Axis
ËË 
.
ËË 
Right
ËË 
:
ËË  
for
ÈÈ 
(
ÈÈ 
i
ÈÈ 
=
ÈÈ 
$num
ÈÈ 
;
ÈÈ 
i
ÈÈ  !
<
ÈÈ" #
v
ÈÈ$ %
.
ÈÈ% &
Length
ÈÈ& ,
;
ÈÈ, -
i
ÈÈ. /
++
ÈÈ/ 1
)
ÈÈ1 2
v
ÍÍ 
[
ÍÍ 
i
ÍÍ 
]
ÍÍ 
=
ÍÍ 
new
ÍÍ "
Vector3
ÍÍ# *
(
ÍÍ* +
$num
ÍÍ+ -
,
ÍÍ- .
p
ÍÍ/ 0
[
ÍÍ0 1
i
ÍÍ1 2
]
ÍÍ2 3
.
ÍÍ3 4
x
ÍÍ4 5
,
ÍÍ5 6
p
ÍÍ7 8
[
ÍÍ8 9
i
ÍÍ9 :
]
ÍÍ: ;
.
ÍÍ; <
y
ÍÍ< =
)
ÍÍ= >
;
ÍÍ> ?
break
ÎÎ 
;
ÎÎ 
case
ÏÏ 
Axis
ÏÏ 
.
ÏÏ 
Left
ÏÏ 
:
ÏÏ 
for
ÌÌ 
(
ÌÌ 
i
ÌÌ 
=
ÌÌ 
$num
ÌÌ 
;
ÌÌ 
i
ÌÌ  !
<
ÌÌ" #
v
ÌÌ$ %
.
ÌÌ% &
Length
ÌÌ& ,
;
ÌÌ, -
i
ÌÌ. /
++
ÌÌ/ 1
)
ÌÌ1 2
v
ÓÓ 
[
ÓÓ 
i
ÓÓ 
]
ÓÓ 
=
ÓÓ 
new
ÓÓ "
Vector3
ÓÓ# *
(
ÓÓ* +
$num
ÓÓ+ -
,
ÓÓ- .
p
ÓÓ/ 0
[
ÓÓ0 1
i
ÓÓ1 2
]
ÓÓ2 3
.
ÓÓ3 4
y
ÓÓ4 5
,
ÓÓ5 6
p
ÓÓ7 8
[
ÓÓ8 9
i
ÓÓ9 :
]
ÓÓ: ;
.
ÓÓ; <
x
ÓÓ< =
)
ÓÓ= >
;
ÓÓ> ?
break
ÔÔ 
;
ÔÔ 
case
 
Axis
 
.
 
Up
 
:
 
for
ÒÒ 
(
ÒÒ 
i
ÒÒ 
=
ÒÒ 
$num
ÒÒ 
;
ÒÒ 
i
ÒÒ  !
<
ÒÒ" #
v
ÒÒ$ %
.
ÒÒ% &
Length
ÒÒ& ,
;
ÒÒ, -
i
ÒÒ. /
++
ÒÒ/ 1
)
ÒÒ1 2
v
ÚÚ 
[
ÚÚ 
i
ÚÚ 
]
ÚÚ 
=
ÚÚ 
new
ÚÚ "
Vector3
ÚÚ# *
(
ÚÚ* +
p
ÚÚ+ ,
[
ÚÚ, -
i
ÚÚ- .
]
ÚÚ. /
.
ÚÚ/ 0
y
ÚÚ0 1
,
ÚÚ1 2
$num
ÚÚ3 5
,
ÚÚ5 6
p
ÚÚ7 8
[
ÚÚ8 9
i
ÚÚ9 :
]
ÚÚ: ;
.
ÚÚ; <
x
ÚÚ< =
)
ÚÚ= >
;
ÚÚ> ?
break
ÛÛ 
;
ÛÛ 
case
ÙÙ 
Axis
ÙÙ 
.
ÙÙ 
Down
ÙÙ 
:
ÙÙ 
for
ıı 
(
ıı 
i
ıı 
=
ıı 
$num
ıı 
;
ıı 
i
ıı  !
<
ıı" #
v
ıı$ %
.
ıı% &
Length
ıı& ,
;
ıı, -
i
ıı. /
++
ıı/ 1
)
ıı1 2
v
ˆˆ 
[
ˆˆ 
i
ˆˆ 
]
ˆˆ 
=
ˆˆ 
new
ˆˆ "
Vector3
ˆˆ# *
(
ˆˆ* +
p
ˆˆ+ ,
[
ˆˆ, -
i
ˆˆ- .
]
ˆˆ. /
.
ˆˆ/ 0
x
ˆˆ0 1
,
ˆˆ1 2
$num
ˆˆ3 5
,
ˆˆ5 6
p
ˆˆ7 8
[
ˆˆ8 9
i
ˆˆ9 :
]
ˆˆ: ;
.
ˆˆ; <
y
ˆˆ< =
)
ˆˆ= >
;
ˆˆ> ?
break
˜˜ 
;
˜˜ 
case
¯¯ 
Axis
¯¯ 
.
¯¯ 
Forward
¯¯ !
:
¯¯! "
for
˘˘ 
(
˘˘ 
i
˘˘ 
=
˘˘ 
$num
˘˘ 
;
˘˘ 
i
˘˘  !
<
˘˘" #
v
˘˘$ %
.
˘˘% &
Length
˘˘& ,
;
˘˘, -
i
˘˘. /
++
˘˘/ 1
)
˘˘1 2
v
˙˙ 
[
˙˙ 
i
˙˙ 
]
˙˙ 
=
˙˙ 
new
˙˙ "
Vector3
˙˙# *
(
˙˙* +
p
˙˙+ ,
[
˙˙, -
i
˙˙- .
]
˙˙. /
.
˙˙/ 0
x
˙˙0 1
,
˙˙1 2
p
˙˙3 4
[
˙˙4 5
i
˙˙5 6
]
˙˙6 7
.
˙˙7 8
y
˙˙8 9
,
˙˙9 :
$num
˙˙; =
)
˙˙= >
;
˙˙> ?
break
˚˚ 
;
˚˚ 
case
¸¸ 
Axis
¸¸ 
.
¸¸ 
Backward
¸¸ "
:
¸¸" #
for
˝˝ 
(
˝˝ 
i
˝˝ 
=
˝˝ 
$num
˝˝ 
;
˝˝ 
i
˝˝  !
<
˝˝" #
v
˝˝$ %
.
˝˝% &
Length
˝˝& ,
;
˝˝, -
i
˝˝. /
++
˝˝/ 1
)
˝˝1 2
v
˛˛ 
[
˛˛ 
i
˛˛ 
]
˛˛ 
=
˛˛ 
new
˛˛ "
Vector3
˛˛# *
(
˛˛* +
p
˛˛+ ,
[
˛˛, -
i
˛˛- .
]
˛˛. /
.
˛˛/ 0
y
˛˛0 1
,
˛˛1 2
p
˛˛3 4
[
˛˛4 5
i
˛˛5 6
]
˛˛6 7
.
˛˛7 8
x
˛˛8 9
,
˛˛9 :
$num
˛˛; =
)
˛˛= >
;
˛˛> ?
break
ˇˇ 
;
ˇˇ 
}
ÄÄ 
ProBuilderMesh
ÇÇ 
pb
ÇÇ 
=
ÇÇ 
ProBuilderMesh
ÇÇ  .
.
ÇÇ. /
Create
ÇÇ/ 5
(
ÇÇ5 6
v
ÇÇ6 7
,
ÇÇ7 8
f
ÇÇ9 :
)
ÇÇ: ;
;
ÇÇ; <
pb
ÉÉ 
.
ÉÉ 

gameObject
ÉÉ 
.
ÉÉ 
name
ÉÉ 
=
ÉÉ  
$str
ÉÉ! (
;
ÉÉ( )
pb
ÑÑ 
.
ÑÑ 
SetPivot
ÑÑ 
(
ÑÑ 
	pivotType
ÑÑ !
)
ÑÑ! "
;
ÑÑ" #
return
ÜÜ 
pb
ÜÜ 
;
ÜÜ 
}
áá 	
public
ìì 
static
ìì 
ProBuilderMesh
ìì $
GeneratePipe
ìì% 1
(
ìì1 2
PivotLocation
ìì2 ?
	pivotType
ìì@ I
,
ììI J
float
ììK P
radius
ììQ W
,
ììW X
float
ììY ^
height
ìì_ e
,
ììe f
float
ììg l
	thickness
ììm v
,
ììv w
int
ììx {

subdivAxisìì| Ü
,ììÜ á
intììà ã
subdivHeightììå ò
)ììò ô
{
îî 	
Vector2
ññ 
[
ññ 
]
ññ 
templateOut
ññ !
=
ññ" #
new
ññ$ '
Vector2
ññ( /
[
ññ/ 0

subdivAxis
ññ0 :
]
ññ: ;
;
ññ; <
Vector2
óó 
[
óó 
]
óó 

templateIn
óó  
=
óó! "
new
óó# &
Vector2
óó' .
[
óó. /

subdivAxis
óó/ 9
]
óó9 :
;
óó: ;
for
ôô 
(
ôô 
int
ôô 
i
ôô 
=
ôô 
$num
ôô 
;
ôô 
i
ôô 
<
ôô 

subdivAxis
ôô  *
;
ôô* +
i
ôô, -
++
ôô- /
)
ôô/ 0
{
öö 
templateOut
õõ 
[
õõ 
i
õõ 
]
õõ 
=
õõ  
Math
õõ! %
.
õõ% &"
PointInCircumference
õõ& :
(
õõ: ;
radius
õõ; A
,
õõA B
i
õõC D
*
õõE F
(
õõG H
$num
õõH L
/
õõM N

subdivAxis
õõO Y
)
õõY Z
,
õõZ [
Vector2
õõ\ c
.
õõc d
zero
õõd h
)
õõh i
;
õõi j

templateIn
úú 
[
úú 
i
úú 
]
úú 
=
úú 
Math
úú  $
.
úú$ %"
PointInCircumference
úú% 9
(
úú9 :
radius
úú: @
-
úúA B
	thickness
úúC L
,
úúL M
i
úúN O
*
úúP Q
(
úúR S
$num
úúS W
/
úúX Y

subdivAxis
úúZ d
)
úúd e
,
úúe f
Vector2
úúg n
.
úún o
zero
úúo s
)
úús t
;
úút u
}
ùù 
List
üü 
<
üü 
Vector3
üü 
>
üü 
v
üü 
=
üü 
new
üü !
List
üü" &
<
üü& '
Vector3
üü' .
>
üü. /
(
üü/ 0
)
üü0 1
;
üü1 2
subdivHeight
°° 
+=
°° 
$num
°° 
;
°° 
Vector2
§§ 
tmp
§§ 
,
§§ 
tmp2
§§ 
,
§§ 
tmp3
§§ #
,
§§# $
tmp4
§§% )
;
§§) *
for
•• 
(
•• 
int
•• 
i
•• 
=
•• 
$num
•• 
;
•• 
i
•• 
<
•• 
subdivHeight
••  ,
;
••, -
i
••. /
++
••/ 1
)
••1 2
{
¶¶ 
float
®® 
y
®® 
=
®® 
i
®® 
*
®® 
(
®® 
height
®® %
/
®®& '
subdivHeight
®®( 4
)
®®4 5
;
®®5 6
float
©© 
y2
©© 
=
©© 
(
©© 
i
©© 
+
©© 
$num
©©  !
)
©©! "
*
©©# $
(
©©% &
height
©©& ,
/
©©- .
subdivHeight
©©/ ;
)
©©; <
;
©©< =
for
´´ 
(
´´ 
int
´´ 
n
´´ 
=
´´ 
$num
´´ 
;
´´ 
n
´´  !
<
´´" #

subdivAxis
´´$ .
;
´´. /
n
´´0 1
++
´´1 3
)
´´3 4
{
¨¨ 
tmp
≠≠ 
=
≠≠ 
templateOut
≠≠ %
[
≠≠% &
n
≠≠& '
]
≠≠' (
;
≠≠( )
tmp2
ÆÆ 
=
ÆÆ 
n
ÆÆ 
<
ÆÆ 
(
ÆÆ  

subdivAxis
ÆÆ  *
-
ÆÆ+ ,
$num
ÆÆ- .
)
ÆÆ. /
?
ÆÆ0 1
templateOut
ÆÆ2 =
[
ÆÆ= >
n
ÆÆ> ?
+
ÆÆ@ A
$num
ÆÆB C
]
ÆÆC D
:
ÆÆE F
templateOut
ÆÆG R
[
ÆÆR S
$num
ÆÆS T
]
ÆÆT U
;
ÆÆU V
Vector3
±± 
[
±± 
]
±± 
qvo
±± !
=
±±" #
new
±±$ '
Vector3
±±( /
[
±±/ 0
$num
±±0 1
]
±±1 2
{
≤≤ 
new
≥≥ 
Vector3
≥≥ #
(
≥≥# $
tmp2
≥≥$ (
.
≥≥( )
x
≥≥) *
,
≥≥* +
y
≥≥, -
,
≥≥- .
tmp2
≥≥/ 3
.
≥≥3 4
y
≥≥4 5
)
≥≥5 6
,
≥≥6 7
new
¥¥ 
Vector3
¥¥ #
(
¥¥# $
tmp
¥¥$ '
.
¥¥' (
x
¥¥( )
,
¥¥) *
y
¥¥+ ,
,
¥¥, -
tmp
¥¥. 1
.
¥¥1 2
y
¥¥2 3
)
¥¥3 4
,
¥¥4 5
new
µµ 
Vector3
µµ #
(
µµ# $
tmp2
µµ$ (
.
µµ( )
x
µµ) *
,
µµ* +
y2
µµ, .
,
µµ. /
tmp2
µµ0 4
.
µµ4 5
y
µµ5 6
)
µµ6 7
,
µµ7 8
new
∂∂ 
Vector3
∂∂ #
(
∂∂# $
tmp
∂∂$ '
.
∂∂' (
x
∂∂( )
,
∂∂) *
y2
∂∂+ -
,
∂∂- .
tmp
∂∂/ 2
.
∂∂2 3
y
∂∂3 4
)
∂∂4 5
}
∑∑ 
;
∑∑ 
tmp
∫∫ 
=
∫∫ 

templateIn
∫∫ $
[
∫∫$ %
n
∫∫% &
]
∫∫& '
;
∫∫' (
tmp2
ªª 
=
ªª 
n
ªª 
<
ªª 
(
ªª  

subdivAxis
ªª  *
-
ªª+ ,
$num
ªª- .
)
ªª. /
?
ªª0 1

templateIn
ªª2 <
[
ªª< =
n
ªª= >
+
ªª? @
$num
ªªA B
]
ªªB C
:
ªªD E

templateIn
ªªF P
[
ªªP Q
$num
ªªQ R
]
ªªR S
;
ªªS T
Vector3
ºº 
[
ºº 
]
ºº 
qvi
ºº !
=
ºº" #
new
ºº$ '
Vector3
ºº( /
[
ºº/ 0
$num
ºº0 1
]
ºº1 2
{
ΩΩ 
new
ææ 
Vector3
ææ #
(
ææ# $
tmp
ææ$ '
.
ææ' (
x
ææ( )
,
ææ) *
y
ææ+ ,
,
ææ, -
tmp
ææ. 1
.
ææ1 2
y
ææ2 3
)
ææ3 4
,
ææ4 5
new
øø 
Vector3
øø #
(
øø# $
tmp2
øø$ (
.
øø( )
x
øø) *
,
øø* +
y
øø, -
,
øø- .
tmp2
øø/ 3
.
øø3 4
y
øø4 5
)
øø5 6
,
øø6 7
new
¿¿ 
Vector3
¿¿ #
(
¿¿# $
tmp
¿¿$ '
.
¿¿' (
x
¿¿( )
,
¿¿) *
y2
¿¿+ -
,
¿¿- .
tmp
¿¿/ 2
.
¿¿2 3
y
¿¿3 4
)
¿¿4 5
,
¿¿5 6
new
¡¡ 
Vector3
¡¡ #
(
¡¡# $
tmp2
¡¡$ (
.
¡¡( )
x
¡¡) *
,
¡¡* +
y2
¡¡, .
,
¡¡. /
tmp2
¡¡0 4
.
¡¡4 5
y
¡¡5 6
)
¡¡6 7
}
¬¬ 
;
¬¬ 
v
ƒƒ 
.
ƒƒ 
AddRange
ƒƒ 
(
ƒƒ 
qvo
ƒƒ "
)
ƒƒ" #
;
ƒƒ# $
v
≈≈ 
.
≈≈ 
AddRange
≈≈ 
(
≈≈ 
qvi
≈≈ "
)
≈≈" #
;
≈≈# $
}
∆∆ 
}
«« 
for
   
(
   
int
   
i
   
=
   
$num
   
;
   
i
   
<
   

subdivAxis
    *
;
  * +
i
  , -
++
  - /
)
  / 0
{
ÀÀ 
tmp
ÃÃ 
=
ÃÃ 
templateOut
ÃÃ !
[
ÃÃ! "
i
ÃÃ" #
]
ÃÃ# $
;
ÃÃ$ %
tmp2
ÕÕ 
=
ÕÕ 
(
ÕÕ 
i
ÕÕ 
<
ÕÕ 

subdivAxis
ÕÕ &
-
ÕÕ' (
$num
ÕÕ) *
)
ÕÕ* +
?
ÕÕ, -
templateOut
ÕÕ. 9
[
ÕÕ9 :
i
ÕÕ: ;
+
ÕÕ< =
$num
ÕÕ> ?
]
ÕÕ? @
:
ÕÕA B
templateOut
ÕÕC N
[
ÕÕN O
$num
ÕÕO P
]
ÕÕP Q
;
ÕÕQ R
tmp3
ŒŒ 
=
ŒŒ 

templateIn
ŒŒ !
[
ŒŒ! "
i
ŒŒ" #
]
ŒŒ# $
;
ŒŒ$ %
tmp4
œœ 
=
œœ 
(
œœ 
i
œœ 
<
œœ 

subdivAxis
œœ &
-
œœ' (
$num
œœ) *
)
œœ* +
?
œœ, -

templateIn
œœ. 8
[
œœ8 9
i
œœ9 :
+
œœ; <
$num
œœ= >
]
œœ> ?
:
œœ@ A

templateIn
œœB L
[
œœL M
$num
œœM N
]
œœN O
;
œœO P
Vector3
““ 
[
““ 
]
““ 
tpt
““ 
=
““ 
new
““  #
Vector3
““$ +
[
““+ ,
$num
““, -
]
““- .
{
”” 
new
‘‘ 
Vector3
‘‘ 
(
‘‘  
tmp2
‘‘  $
.
‘‘$ %
x
‘‘% &
,
‘‘& '
height
‘‘( .
,
‘‘. /
tmp2
‘‘0 4
.
‘‘4 5
y
‘‘5 6
)
‘‘6 7
,
‘‘7 8
new
’’ 
Vector3
’’ 
(
’’  
tmp
’’  #
.
’’# $
x
’’$ %
,
’’% &
height
’’( .
,
’’. /
tmp
’’0 3
.
’’3 4
y
’’4 5
)
’’5 6
,
’’6 7
new
÷÷ 
Vector3
÷÷ 
(
÷÷  
tmp4
÷÷  $
.
÷÷$ %
x
÷÷% &
,
÷÷& '
height
÷÷( .
,
÷÷. /
tmp4
÷÷0 4
.
÷÷4 5
y
÷÷5 6
)
÷÷6 7
,
÷÷7 8
new
◊◊ 
Vector3
◊◊ 
(
◊◊  
tmp3
◊◊  $
.
◊◊$ %
x
◊◊% &
,
◊◊& '
height
◊◊( .
,
◊◊. /
tmp3
◊◊0 4
.
◊◊4 5
y
◊◊5 6
)
◊◊6 7
}
ÿÿ 
;
ÿÿ 
Vector3
€€ 
[
€€ 
]
€€ 
tpb
€€ 
=
€€ 
new
€€  #
Vector3
€€$ +
[
€€+ ,
$num
€€, -
]
€€- .
{
‹‹ 
new
›› 
Vector3
›› 
(
››  
tmp
››  #
.
››# $
x
››$ %
,
››% &
$num
››' )
,
››) *
tmp
››+ .
.
››. /
y
››/ 0
)
››0 1
,
››1 2
new
ﬁﬁ 
Vector3
ﬁﬁ 
(
ﬁﬁ  
tmp2
ﬁﬁ  $
.
ﬁﬁ$ %
x
ﬁﬁ% &
,
ﬁﬁ& '
$num
ﬁﬁ( *
,
ﬁﬁ* +
tmp2
ﬁﬁ, 0
.
ﬁﬁ0 1
y
ﬁﬁ1 2
)
ﬁﬁ2 3
,
ﬁﬁ3 4
new
ﬂﬂ 
Vector3
ﬂﬂ 
(
ﬂﬂ  
tmp3
ﬂﬂ  $
.
ﬂﬂ$ %
x
ﬂﬂ% &
,
ﬂﬂ& '
$num
ﬂﬂ( *
,
ﬂﬂ* +
tmp3
ﬂﬂ, 0
.
ﬂﬂ0 1
y
ﬂﬂ1 2
)
ﬂﬂ2 3
,
ﬂﬂ3 4
new
‡‡ 
Vector3
‡‡ 
(
‡‡  
tmp4
‡‡  $
.
‡‡$ %
x
‡‡% &
,
‡‡& '
$num
‡‡( *
,
‡‡* +
tmp4
‡‡, 0
.
‡‡0 1
y
‡‡1 2
)
‡‡2 3
,
‡‡3 4
}
·· 
;
·· 
v
„„ 
.
„„ 
AddRange
„„ 
(
„„ 
tpb
„„ 
)
„„ 
;
„„  
v
‰‰ 
.
‰‰ 
AddRange
‰‰ 
(
‰‰ 
tpt
‰‰ 
)
‰‰ 
;
‰‰  
}
ÂÂ 
ProBuilderMesh
ÁÁ 
pb
ÁÁ 
=
ÁÁ 
ProBuilderMesh
ÁÁ  .
.
ÁÁ. /&
CreateInstanceWithPoints
ÁÁ/ G
(
ÁÁG H
v
ÁÁH I
.
ÁÁI J
ToArray
ÁÁJ Q
(
ÁÁQ R
)
ÁÁR S
)
ÁÁS T
;
ÁÁT U
pb
ÈÈ 
.
ÈÈ 

gameObject
ÈÈ 
.
ÈÈ 
name
ÈÈ 
=
ÈÈ  
$str
ÈÈ! '
;
ÈÈ' (
pb
ÍÍ 
.
ÍÍ 
SetPivot
ÍÍ 
(
ÍÍ 
	pivotType
ÍÍ !
,
ÍÍ! "
$num
ÍÍ# $
)
ÍÍ$ %
;
ÍÍ% &
return
ÏÏ 
pb
ÏÏ 
;
ÏÏ 
}
ÌÌ 	
public
˜˜ 
static
˜˜ 
ProBuilderMesh
˜˜ $
GenerateCone
˜˜% 1
(
˜˜1 2
PivotLocation
˜˜2 ?
	pivotType
˜˜@ I
,
˜˜I J
float
˜˜K P
radius
˜˜Q W
,
˜˜W X
float
˜˜Y ^
height
˜˜_ e
,
˜˜e f
int
˜˜g j

subdivAxis
˜˜k u
)
˜˜u v
{
¯¯ 	
Vector3
˙˙ 
[
˙˙ 
]
˙˙ 
template
˙˙ 
=
˙˙  
new
˙˙! $
Vector3
˙˙% ,
[
˙˙, -

subdivAxis
˙˙- 7
]
˙˙7 8
;
˙˙8 9
for
¸¸ 
(
¸¸ 
int
¸¸ 
i
¸¸ 
=
¸¸ 
$num
¸¸ 
;
¸¸ 
i
¸¸ 
<
¸¸ 

subdivAxis
¸¸  *
;
¸¸* +
i
¸¸, -
++
¸¸- /
)
¸¸/ 0
{
˝˝ 
Vector2
˛˛ 
ct
˛˛ 
=
˛˛ 
Math
˛˛ !
.
˛˛! ""
PointInCircumference
˛˛" 6
(
˛˛6 7
radius
˛˛7 =
,
˛˛= >
i
˛˛? @
*
˛˛A B
(
˛˛C D
$num
˛˛D H
/
˛˛I J

subdivAxis
˛˛K U
)
˛˛U V
,
˛˛V W
Vector2
˛˛X _
.
˛˛_ `
zero
˛˛` d
)
˛˛d e
;
˛˛e f
template
ˇˇ 
[
ˇˇ 
i
ˇˇ 
]
ˇˇ 
=
ˇˇ 
new
ˇˇ !
Vector3
ˇˇ" )
(
ˇˇ) *
ct
ˇˇ* ,
.
ˇˇ, -
x
ˇˇ- .
,
ˇˇ. /
$num
ˇˇ0 2
,
ˇˇ2 3
ct
ˇˇ4 6
.
ˇˇ6 7
y
ˇˇ7 8
)
ˇˇ8 9
;
ˇˇ9 :
}
Ä	Ä	 
List
Ç	Ç	 
<
Ç	Ç	 
Vector3
Ç	Ç	 
>
Ç	Ç	 
v
Ç	Ç	 
=
Ç	Ç	 
new
Ç	Ç	 !
List
Ç	Ç	" &
<
Ç	Ç	& '
Vector3
Ç	Ç	' .
>
Ç	Ç	. /
(
Ç	Ç	/ 0
)
Ç	Ç	0 1
;
Ç	Ç	1 2
List
É	É	 
<
É	É	 
Face
É	É	 
>
É	É	 
f
É	É	 
=
É	É	 
new
É	É	 
List
É	É	 #
<
É	É	# $
Face
É	É	$ (
>
É	É	( )
(
É	É	) *
)
É	É	* +
;
É	É	+ ,
for
Ü	Ü	 
(
Ü	Ü	 
int
Ü	Ü	 
i
Ü	Ü	 
=
Ü	Ü	 
$num
Ü	Ü	 
;
Ü	Ü	 
i
Ü	Ü	 
<
Ü	Ü	 

subdivAxis
Ü	Ü	  *
;
Ü	Ü	* +
i
Ü	Ü	, -
++
Ü	Ü	- /
)
Ü	Ü	/ 0
{
á	á	 
v
â	â	 
.
â	â	 
Add
â	â	 
(
â	â	 
template
â	â	 
[
â	â	 
i
â	â	  
]
â	â	  !
)
â	â	! "
;
â	â	" #
v
ä	ä	 
.
ä	ä	 
Add
ä	ä	 
(
ä	ä	 
(
ä	ä	 
i
ä	ä	 
<
ä	ä	 

subdivAxis
ä	ä	 %
-
ä	ä	& '
$num
ä	ä	( )
)
ä	ä	) *
?
ä	ä	+ ,
template
ä	ä	- 5
[
ä	ä	5 6
i
ä	ä	6 7
+
ä	ä	8 9
$num
ä	ä	: ;
]
ä	ä	; <
:
ä	ä	= >
template
ä	ä	? G
[
ä	ä	G H
$num
ä	ä	H I
]
ä	ä	I J
)
ä	ä	J K
;
ä	ä	K L
v
ã	ã	 
.
ã	ã	 
Add
ã	ã	 
(
ã	ã	 
Vector3
ã	ã	 
.
ã	ã	 
up
ã	ã	  
*
ã	ã	! "
height
ã	ã	# )
)
ã	ã	) *
;
ã	ã	* +
v
é	é	 
.
é	é	 
Add
é	é	 
(
é	é	 
template
é	é	 
[
é	é	 
i
é	é	  
]
é	é	  !
)
é	é	! "
;
é	é	" #
v
è	è	 
.
è	è	 
Add
è	è	 
(
è	è	 
(
è	è	 
i
è	è	 
<
è	è	 

subdivAxis
è	è	 %
-
è	è	& '
$num
è	è	( )
)
è	è	) *
?
è	è	+ ,
template
è	è	- 5
[
è	è	5 6
i
è	è	6 7
+
è	è	8 9
$num
è	è	: ;
]
è	è	; <
:
è	è	= >
template
è	è	? G
[
è	è	G H
$num
è	è	H I
]
è	è	I J
)
è	è	J K
;
è	è	K L
v
ê	ê	 
.
ê	ê	 
Add
ê	ê	 
(
ê	ê	 
Vector3
ê	ê	 
.
ê	ê	 
zero
ê	ê	 "
)
ê	ê	" #
;
ê	ê	# $
}
ë	ë	 
List
ì	ì	 
<
ì	ì	 
Face
ì	ì	 
>
ì	ì	 
	sideFaces
ì	ì	  
=
ì	ì	! "
new
ì	ì	# &
List
ì	ì	' +
<
ì	ì	+ ,
Face
ì	ì	, 0
>
ì	ì	0 1
(
ì	ì	1 2
)
ì	ì	2 3
;
ì	ì	3 4
for
î	î	 
(
î	î	 
int
î	î	 
i
î	î	 
=
î	î	 
$num
î	î	 
;
î	î	 
i
î	î	 
<
î	î	 

subdivAxis
î	î	  *
*
î	î	+ ,
$num
î	î	- .
;
î	î	. /
i
î	î	0 1
+=
î	î	2 4
$num
î	î	5 6
)
î	î	6 7
{
ï	ï	 
Face
ñ	ñ	 
face
ñ	ñ	 
=
ñ	ñ	 
new
ñ	ñ	 
Face
ñ	ñ	  $
(
ñ	ñ	$ %
new
ñ	ñ	% (
int
ñ	ñ	) ,
[
ñ	ñ	, -
$num
ñ	ñ	- .
]
ñ	ñ	. /
{
ñ	ñ	0 1
i
ñ	ñ	2 3
+
ñ	ñ	4 5
$num
ñ	ñ	6 7
,
ñ	ñ	7 8
i
ñ	ñ	9 :
+
ñ	ñ	; <
$num
ñ	ñ	= >
,
ñ	ñ	> ?
i
ñ	ñ	@ A
+
ñ	ñ	B C
$num
ñ	ñ	D E
}
ñ	ñ	F G
)
ñ	ñ	G H
;
ñ	ñ	H I
f
ó	ó	 
.
ó	ó	 
Add
ó	ó	 
(
ó	ó	 
face
ó	ó	 
)
ó	ó	 
;
ó	ó	 
	sideFaces
ò	ò	 
.
ò	ò	 
Add
ò	ò	 
(
ò	ò	 
face
ò	ò	 "
)
ò	ò	" #
;
ò	ò	# $
f
ô	ô	 
.
ô	ô	 
Add
ô	ô	 
(
ô	ô	 
new
ô	ô	 
Face
ô	ô	 
(
ô	ô	 
new
ô	ô	 "
int
ô	ô	# &
[
ô	ô	& '
$num
ô	ô	' (
]
ô	ô	( )
{
ô	ô	* +
i
ô	ô	+ ,
+
ô	ô	- .
$num
ô	ô	/ 0
,
ô	ô	0 1
i
ô	ô	2 3
+
ô	ô	4 5
$num
ô	ô	6 7
,
ô	ô	7 8
i
ô	ô	9 :
+
ô	ô	; <
$num
ô	ô	= >
}
ô	ô	> ?
)
ô	ô	? @
)
ô	ô	@ A
;
ô	ô	A B
}
ö	ö	 
ProBuilderMesh
ú	ú	 
pb
ú	ú	 
=
ú	ú	 
ProBuilderMesh
ú	ú	  .
.
ú	ú	. /
Create
ú	ú	/ 5
(
ú	ú	5 6
v
ú	ú	6 7
.
ú	ú	7 8
ToArray
ú	ú	8 ?
(
ú	ú	? @
)
ú	ú	@ A
,
ú	ú	A B
f
ú	ú	C D
.
ú	ú	D E
ToArray
ú	ú	E L
(
ú	ú	L M
)
ú	ú	M N
)
ú	ú	N O
;
ú	ú	O P
pb
ù	ù	 
.
ù	ù	 

gameObject
ù	ù	 
.
ù	ù	 
name
ù	ù	 
=
ù	ù	  
$str
ù	ù	! '
;
ù	ù	' (
pb
û	û	 
.
û	û	 
SetPivot
û	û	 
(
û	û	 
	pivotType
û	û	 !
)
û	û	! "
;
û	û	" #
pb
ü	ü	 
.
ü	ü	 
unwrapParameters
ü	ü	 
=
ü	ü	  !
new
ü	ü	" %
UnwrapParameters
ü	ü	& 6
(
ü	ü	6 7
)
ü	ü	7 8
{
†	†	 

packMargin
°	°	 
=
°	°	 
$num
°	°	  
}
¢	¢	 
;
¢	¢	 
var
¶	¶	 
	firstFace
¶	¶	 
=
¶	¶	 
	sideFaces
¶	¶	 %
[
¶	¶	% &
$num
¶	¶	& '
]
¶	¶	' (
;
¶	¶	( )
var
ß	ß	 
uv
ß	ß	 
=
ß	ß	 
	firstFace
ß	ß	 
.
ß	ß	 
uv
ß	ß	 !
;
ß	ß	! "
uv
®	®	 
.
®	®	 
anchor
®	®	 
=
®	®	  
AutoUnwrapSettings
®	®	 *
.
®	®	* +
Anchor
®	®	+ 1
.
®	®	1 2
	LowerLeft
®	®	2 ;
;
®	®	; <
	firstFace
©	©	 
.
©	©	 
uv
©	©	 
=
©	©	 
uv
©	©	 
;
©	©	 
	firstFace
™	™	 
.
™	™	 
manualUV
™	™	 
=
™	™	  
true
™	™	! %
;
™	™	% &
UvUnwrapping
≠	≠	 
.
≠	≠	 
Unwrap
≠	≠	 
(
≠	≠	  
pb
≠	≠	  "
,
≠	≠	" #
	firstFace
≠	≠	$ -
,
≠	≠	- .

projection
≠	≠	/ 9
:
≠	≠	9 :
Vector3
≠	≠	; B
.
≠	≠	B C
up
≠	≠	C E
)
≠	≠	E F
;
≠	≠	F G
for
Æ	Æ	 
(
Æ	Æ	 
int
Æ	Æ	 
i
Æ	Æ	 
=
Æ	Æ	 
$num
Æ	Æ	 
;
Æ	Æ	 
i
Æ	Æ	 
<
Æ	Æ	 
	sideFaces
Æ	Æ	  )
.
Æ	Æ	) *
Count
Æ	Æ	* /
;
Æ	Æ	/ 0
i
Æ	Æ	1 2
++
Æ	Æ	2 4
)
Æ	Æ	4 5
{
Ø	Ø	 
var
∞	∞	 
sideFace
∞	∞	 
=
∞	∞	 
	sideFaces
∞	∞	 (
[
∞	∞	( )
i
∞	∞	) *
]
∞	∞	* +
;
∞	∞	+ ,
sideFace
±	±	 
.
±	±	 
manualUV
±	±	 !
=
±	±	" #
true
±	±	$ (
;
±	±	( )
UvUnwrapping
≤	≤	 
.
≤	≤	 
CopyUVs
≤	≤	 $
(
≤	≤	$ %
pb
≤	≤	% '
,
≤	≤	' (
	firstFace
≤	≤	) 2
,
≤	≤	2 3
sideFace
≤	≤	4 <
)
≤	≤	< =
;
≤	≤	= >
}
≥	≥	 
pb
¥	¥	 
.
¥	¥	 
	RefreshUV
¥	¥	 
(
¥	¥	 
	sideFaces
¥	¥	 "
)
¥	¥	" #
;
¥	¥	# $
return
µ	µ	 
pb
µ	µ	 
;
µ	µ	 
}
∂	∂	 	
public
«	«	 
static
«	«	 
ProBuilderMesh
«	«	 $
GenerateArch
«	«	% 1
(
«	«	1 2
PivotLocation
«	«	2 ?
	pivotType
«	«	@ I
,
«	«	I J
float
«	«	K P
angle
«	«	Q V
,
«	«	V W
float
«	«	X ]
radius
«	«	^ d
,
«	«	d e
float
«	«	f k
width
«	«	l q
,
«	«	q r
float
«	«	s x
depth
«	«	y ~
,
«	«	~ 
int«	«	Ä É

radialCuts«	«	Ñ é
,«	«	é è
bool«	«	ê î
insideFaces«	«	ï †
,«	«	† °
bool«	«	¢ ¶
outsideFaces«	«	ß ≥
,«	«	≥ ¥
bool«	«	µ π

frontFaces«	«	∫ ƒ
,«	«	ƒ ≈
bool«	«	∆  
	backFaces«	«	À ‘
,«	«	‘ ’
bool«	«	÷ ⁄
endCaps«	«	€ ‚
)«	«	‚ „
{
»	»	 	
Vector2
…	…	 
[
…	…	 
]
…	…	 
templateOut
…	…	 !
=
…	…	" #
new
…	…	$ '
Vector2
…	…	( /
[
…	…	/ 0

radialCuts
…	…	0 :
]
…	…	: ;
;
…	…	; <
Vector2
 	 	 
[
 	 	 
]
 	 	 

templateIn
 	 	  
=
 	 	! "
new
 	 	# &
Vector2
 	 	' .
[
 	 	. /

radialCuts
 	 	/ 9
]
 	 	9 :
;
 	 	: ;
for
Ã	Ã	 
(
Ã	Ã	 
int
Ã	Ã	 
i
Ã	Ã	 
=
Ã	Ã	 
$num
Ã	Ã	 
;
Ã	Ã	 
i
Ã	Ã	 
<
Ã	Ã	 

radialCuts
Ã	Ã	  *
;
Ã	Ã	* +
i
Ã	Ã	, -
++
Ã	Ã	- /
)
Ã	Ã	/ 0
{
Õ	Õ	 
templateOut
Œ	Œ	 
[
Œ	Œ	 
i
Œ	Œ	 
]
Œ	Œ	 
=
Œ	Œ	  
Math
Œ	Œ	! %
.
Œ	Œ	% &"
PointInCircumference
Œ	Œ	& :
(
Œ	Œ	: ;
radius
Œ	Œ	; A
,
Œ	Œ	A B
i
Œ	Œ	C D
*
Œ	Œ	E F
(
Œ	Œ	G H
angle
Œ	Œ	H M
/
Œ	Œ	N O
(
Œ	Œ	P Q

radialCuts
Œ	Œ	Q [
-
Œ	Œ	\ ]
$num
Œ	Œ	^ _
)
Œ	Œ	_ `
)
Œ	Œ	` a
,
Œ	Œ	a b
Vector2
Œ	Œ	c j
.
Œ	Œ	j k
zero
Œ	Œ	k o
)
Œ	Œ	o p
;
Œ	Œ	p q

templateIn
œ	œ	 
[
œ	œ	 
i
œ	œ	 
]
œ	œ	 
=
œ	œ	 
Math
œ	œ	  $
.
œ	œ	$ %"
PointInCircumference
œ	œ	% 9
(
œ	œ	9 :
radius
œ	œ	: @
-
œ	œ	A B
width
œ	œ	C H
,
œ	œ	H I
i
œ	œ	J K
*
œ	œ	L M
(
œ	œ	N O
angle
œ	œ	O T
/
œ	œ	U V
(
œ	œ	W X

radialCuts
œ	œ	X b
-
œ	œ	c d
$num
œ	œ	e f
)
œ	œ	f g
)
œ	œ	g h
,
œ	œ	h i
Vector2
œ	œ	j q
.
œ	œ	q r
zero
œ	œ	r v
)
œ	œ	v w
;
œ	œ	w x
}
–	–	 
List
“	“	 
<
“	“	 
Vector3
“	“	 
>
“	“	 
v
“	“	 
=
“	“	 
new
“	“	 !
List
“	“	" &
<
“	“	& '
Vector3
“	“	' .
>
“	“	. /
(
“	“	/ 0
)
“	“	0 1
;
“	“	1 2
Vector2
‘	‘	 
tmp
‘	‘	 
,
‘	‘	 
tmp2
‘	‘	 
,
‘	‘	 
tmp3
‘	‘	 #
,
‘	‘	# $
tmp4
‘	‘	% )
;
‘	‘	) *
float
÷	÷	 
y
÷	÷	 
=
÷	÷	 
$num
÷	÷	 
;
÷	÷	 
for
ÿ	ÿ	 
(
ÿ	ÿ	 
int
ÿ	ÿ	 
n
ÿ	ÿ	 
=
ÿ	ÿ	 
$num
ÿ	ÿ	 
;
ÿ	ÿ	 
n
ÿ	ÿ	 
<
ÿ	ÿ	 

radialCuts
ÿ	ÿ	  *
-
ÿ	ÿ	+ ,
$num
ÿ	ÿ	- .
;
ÿ	ÿ	. /
n
ÿ	ÿ	0 1
++
ÿ	ÿ	1 3
)
ÿ	ÿ	3 4
{
Ÿ	Ÿ	 
tmp
€	€	 
=
€	€	 
templateOut
€	€	 !
[
€	€	! "
n
€	€	" #
]
€	€	# $
;
€	€	$ %
tmp2
‹	‹	 
=
‹	‹	 
n
‹	‹	 
<
‹	‹	 
(
‹	‹	 

radialCuts
‹	‹	 &
-
‹	‹	' (
$num
‹	‹	) *
)
‹	‹	* +
?
‹	‹	, -
templateOut
‹	‹	. 9
[
‹	‹	9 :
n
‹	‹	: ;
+
‹	‹	< =
$num
‹	‹	> ?
]
‹	‹	? @
:
‹	‹	A B
templateOut
‹	‹	C N
[
‹	‹	N O
n
‹	‹	O P
]
‹	‹	P Q
;
‹	‹	Q R
Vector3
ﬁ	ﬁ	 
[
ﬁ	ﬁ	 
]
ﬁ	ﬁ	 
qvo
ﬁ	ﬁ	 
=
ﬁ	ﬁ	 
new
ﬁ	ﬁ	  #
Vector3
ﬁ	ﬁ	$ +
[
ﬁ	ﬁ	+ ,
$num
ﬁ	ﬁ	, -
]
ﬁ	ﬁ	- .
{
ﬂ	ﬂ	 
new
‡	‡	 
Vector3
‡	‡	 
(
‡	‡	  
tmp
‡	‡	  #
.
‡	‡	# $
x
‡	‡	$ %
,
‡	‡	% &
tmp
‡	‡	' *
.
‡	‡	* +
y
‡	‡	+ ,
,
‡	‡	, -
y
‡	‡	. /
)
‡	‡	/ 0
,
‡	‡	0 1
new
·	·	 
Vector3
·	·	 
(
·	·	  
tmp2
·	·	  $
.
·	·	$ %
x
·	·	% &
,
·	·	& '
tmp2
·	·	( ,
.
·	·	, -
y
·	·	- .
,
·	·	. /
y
·	·	0 1
)
·	·	1 2
,
·	·	2 3
new
‚	‚	 
Vector3
‚	‚	 
(
‚	‚	  
tmp
‚	‚	  #
.
‚	‚	# $
x
‚	‚	$ %
,
‚	‚	% &
tmp
‚	‚	' *
.
‚	‚	* +
y
‚	‚	+ ,
,
‚	‚	, -
depth
‚	‚	. 3
)
‚	‚	3 4
,
‚	‚	4 5
new
„	„	 
Vector3
„	„	 
(
„	„	  
tmp2
„	„	  $
.
„	„	$ %
x
„	„	% &
,
„	„	& '
tmp2
„	„	( ,
.
„	„	, -
y
„	„	- .
,
„	„	. /
depth
„	„	0 5
)
„	„	5 6
}
‰	‰	 
;
‰	‰	 
tmp
Á	Á	 
=
Á	Á	 

templateIn
Á	Á	  
[
Á	Á	  !
n
Á	Á	! "
]
Á	Á	" #
;
Á	Á	# $
tmp2
Ë	Ë	 
=
Ë	Ë	 
n
Ë	Ë	 
<
Ë	Ë	 
(
Ë	Ë	 

radialCuts
Ë	Ë	 &
-
Ë	Ë	' (
$num
Ë	Ë	) *
)
Ë	Ë	* +
?
Ë	Ë	, -

templateIn
Ë	Ë	. 8
[
Ë	Ë	8 9
n
Ë	Ë	9 :
+
Ë	Ë	; <
$num
Ë	Ë	= >
]
Ë	Ë	> ?
:
Ë	Ë	@ A

templateIn
Ë	Ë	B L
[
Ë	Ë	L M
n
Ë	Ë	M N
]
Ë	Ë	N O
;
Ë	Ë	O P
Vector3
Í	Í	 
[
Í	Í	 
]
Í	Í	 
qvi
Í	Í	 
=
Í	Í	 
new
Í	Í	  #
Vector3
Í	Í	$ +
[
Í	Í	+ ,
$num
Í	Í	, -
]
Í	Í	- .
{
Î	Î	 
new
Ï	Ï	 
Vector3
Ï	Ï	 
(
Ï	Ï	  
tmp2
Ï	Ï	  $
.
Ï	Ï	$ %
x
Ï	Ï	% &
,
Ï	Ï	& '
tmp2
Ï	Ï	( ,
.
Ï	Ï	, -
y
Ï	Ï	- .
,
Ï	Ï	. /
y
Ï	Ï	0 1
)
Ï	Ï	1 2
,
Ï	Ï	2 3
new
Ì	Ì	 
Vector3
Ì	Ì	 
(
Ì	Ì	  
tmp
Ì	Ì	  #
.
Ì	Ì	# $
x
Ì	Ì	$ %
,
Ì	Ì	% &
tmp
Ì	Ì	' *
.
Ì	Ì	* +
y
Ì	Ì	+ ,
,
Ì	Ì	, -
y
Ì	Ì	. /
)
Ì	Ì	/ 0
,
Ì	Ì	0 1
new
Ó	Ó	 
Vector3
Ó	Ó	 
(
Ó	Ó	  
tmp2
Ó	Ó	  $
.
Ó	Ó	$ %
x
Ó	Ó	% &
,
Ó	Ó	& '
tmp2
Ó	Ó	( ,
.
Ó	Ó	, -
y
Ó	Ó	- .
,
Ó	Ó	. /
depth
Ó	Ó	0 5
)
Ó	Ó	5 6
,
Ó	Ó	6 7
new
Ô	Ô	 
Vector3
Ô	Ô	 
(
Ô	Ô	  
tmp
Ô	Ô	  #
.
Ô	Ô	# $
x
Ô	Ô	$ %
,
Ô	Ô	% &
tmp
Ô	Ô	' *
.
Ô	Ô	* +
y
Ô	Ô	+ ,
,
Ô	Ô	, -
depth
Ô	Ô	. 3
)
Ô	Ô	3 4
}
		 
;
		 
if
Ú	Ú	 
(
Ú	Ú	 
outsideFaces
Ú	Ú	  
)
Ú	Ú	  !
v
Û	Û	 
.
Û	Û	 
AddRange
Û	Û	 
(
Û	Û	 
qvo
Û	Û	 "
)
Û	Û	" #
;
Û	Û	# $
if
ı	ı	 
(
ı	ı	 
n
ı	ı	 
!=
ı	ı	 

radialCuts
ı	ı	 #
-
ı	ı	$ %
$num
ı	ı	& '
&&
ı	ı	( *
insideFaces
ı	ı	+ 6
)
ı	ı	6 7
v
ˆ	ˆ	 
.
ˆ	ˆ	 
AddRange
ˆ	ˆ	 
(
ˆ	ˆ	 
qvi
ˆ	ˆ	 "
)
ˆ	ˆ	" #
;
ˆ	ˆ	# $
if
˘	˘	 
(
˘	˘	 
angle
˘	˘	 
<
˘	˘	 
$num
˘	˘	  
&&
˘	˘	! #
endCaps
˘	˘	$ +
)
˘	˘	+ ,
{
˙	˙	 
if
˚	˚	 
(
˚	˚	 
n
˚	˚	 
==
˚	˚	 
$num
˚	˚	 
)
˚	˚	 
{
¸	¸	 
v
˝	˝	 
.
˝	˝	 
AddRange
˝	˝	 "
(
˝	˝	" #
new
˛	˛	 
Vector3
˛	˛	  '
[
˛	˛	' (
$num
˛	˛	( )
]
˛	˛	) *
{
ˇ	ˇ	 
new
Ä
Ä
 
Vector3
Ä
Ä
  '
(
Ä
Ä
' (
templateOut
Ä
Ä
( 3
[
Ä
Ä
3 4
n
Ä
Ä
4 5
]
Ä
Ä
5 6
.
Ä
Ä
6 7
x
Ä
Ä
7 8
,
Ä
Ä
8 9
templateOut
Ä
Ä
: E
[
Ä
Ä
E F
n
Ä
Ä
F G
]
Ä
Ä
G H
.
Ä
Ä
H I
y
Ä
Ä
I J
,
Ä
Ä
J K
depth
Ä
Ä
L Q
)
Ä
Ä
Q R
,
Ä
Ä
R S
new
Å
Å
 
Vector3
Å
Å
  '
(
Å
Å
' (

templateIn
Å
Å
( 2
[
Å
Å
2 3
n
Å
Å
3 4
]
Å
Å
4 5
.
Å
Å
5 6
x
Å
Å
6 7
,
Å
Å
7 8

templateIn
Å
Å
9 C
[
Å
Å
C D
n
Å
Å
D E
]
Å
Å
E F
.
Å
Å
F G
y
Å
Å
G H
,
Å
Å
H I
depth
Å
Å
J O
)
Å
Å
O P
,
Å
Å
P Q
new
Ç
Ç
 
Vector3
Ç
Ç
  '
(
Ç
Ç
' (
templateOut
Ç
Ç
( 3
[
Ç
Ç
3 4
n
Ç
Ç
4 5
]
Ç
Ç
5 6
.
Ç
Ç
6 7
x
Ç
Ç
7 8
,
Ç
Ç
8 9
templateOut
Ç
Ç
: E
[
Ç
Ç
E F
n
Ç
Ç
F G
]
Ç
Ç
G H
.
Ç
Ç
H I
y
Ç
Ç
I J
,
Ç
Ç
J K
y
Ç
Ç
L M
)
Ç
Ç
M N
,
Ç
Ç
N O
new
É
É
 
Vector3
É
É
  '
(
É
É
' (

templateIn
É
É
( 2
[
É
É
2 3
n
É
É
3 4
]
É
É
4 5
.
É
É
5 6
x
É
É
6 7
,
É
É
7 8

templateIn
É
É
9 C
[
É
É
C D
n
É
É
D E
]
É
É
E F
.
É
É
F G
y
É
É
G H
,
É
É
H I
y
É
É
J K
)
É
É
K L
}
Ñ
Ñ
 
)
Ñ
Ñ
 
;
Ñ
Ñ
 
}
Ö
Ö
 
if
à
à
 
(
à
à
 
n
à
à
 
==
à
à
 

radialCuts
à
à
 '
-
à
à
( )
$num
à
à
* +
)
à
à
+ ,
{
â
â
 
v
ä
ä
 
.
ä
ä
 
AddRange
ä
ä
 "
(
ä
ä
" #
new
ã
ã
 
Vector3
ã
ã
  '
[
ã
ã
' (
$num
ã
ã
( )
]
ã
ã
) *
{
å
å
 
new
ç
ç
 
Vector3
ç
ç
  '
(
ç
ç
' (

templateIn
ç
ç
( 2
[
ç
ç
2 3
n
ç
ç
3 4
+
ç
ç
5 6
$num
ç
ç
7 8
]
ç
ç
8 9
.
ç
ç
9 :
x
ç
ç
: ;
,
ç
ç
; <

templateIn
ç
ç
= G
[
ç
ç
G H
n
ç
ç
H I
+
ç
ç
J K
$num
ç
ç
L M
]
ç
ç
M N
.
ç
ç
N O
y
ç
ç
O P
,
ç
ç
P Q
depth
ç
ç
R W
)
ç
ç
W X
,
ç
ç
X Y
new
é
é
 
Vector3
é
é
  '
(
é
é
' (
templateOut
é
é
( 3
[
é
é
3 4
n
é
é
4 5
+
é
é
6 7
$num
é
é
8 9
]
é
é
9 :
.
é
é
: ;
x
é
é
; <
,
é
é
< =
templateOut
é
é
> I
[
é
é
I J
n
é
é
J K
+
é
é
L M
$num
é
é
N O
]
é
é
O P
.
é
é
P Q
y
é
é
Q R
,
é
é
R S
depth
é
é
T Y
)
é
é
Y Z
,
é
é
Z [
new
è
è
 
Vector3
è
è
  '
(
è
è
' (

templateIn
è
è
( 2
[
è
è
2 3
n
è
è
3 4
+
è
è
5 6
$num
è
è
7 8
]
è
è
8 9
.
è
è
9 :
x
è
è
: ;
,
è
è
; <

templateIn
è
è
= G
[
è
è
G H
n
è
è
H I
+
è
è
J K
$num
è
è
L M
]
è
è
M N
.
è
è
N O
y
è
è
O P
,
è
è
P Q
y
è
è
R S
)
è
è
S T
,
è
è
T U
new
ê
ê
 
Vector3
ê
ê
  '
(
ê
ê
' (
templateOut
ê
ê
( 3
[
ê
ê
3 4
n
ê
ê
4 5
+
ê
ê
6 7
$num
ê
ê
8 9
]
ê
ê
9 :
.
ê
ê
: ;
x
ê
ê
; <
,
ê
ê
< =
templateOut
ê
ê
> I
[
ê
ê
I J
n
ê
ê
J K
+
ê
ê
L M
$num
ê
ê
N O
]
ê
ê
O P
.
ê
ê
P Q
y
ê
ê
Q R
,
ê
ê
R S
y
ê
ê
T U
)
ê
ê
U V
}
ë
ë
 
)
ë
ë
 
;
ë
ë
 
}
í
í
 
}
ì
ì
 
}
î
î
 
for
ó
ó
 
(
ó
ó
 
int
ó
ó
 
i
ó
ó
 
=
ó
ó
 
$num
ó
ó
 
;
ó
ó
 
i
ó
ó
 
<
ó
ó
 

radialCuts
ó
ó
  *
-
ó
ó
+ ,
$num
ó
ó
- .
;
ó
ó
. /
i
ó
ó
0 1
++
ó
ó
1 3
)
ó
ó
3 4
{
ò
ò
 
tmp
ô
ô
 
=
ô
ô
 
templateOut
ô
ô
 !
[
ô
ô
! "
i
ô
ô
" #
]
ô
ô
# $
;
ô
ô
$ %
tmp2
ö
ö
 
=
ö
ö
 
(
ö
ö
 
i
ö
ö
 
<
ö
ö
 

radialCuts
ö
ö
 &
-
ö
ö
' (
$num
ö
ö
) *
)
ö
ö
* +
?
ö
ö
, -
templateOut
ö
ö
. 9
[
ö
ö
9 :
i
ö
ö
: ;
+
ö
ö
< =
$num
ö
ö
> ?
]
ö
ö
? @
:
ö
ö
A B
templateOut
ö
ö
C N
[
ö
ö
N O
i
ö
ö
O P
]
ö
ö
P Q
;
ö
ö
Q R
tmp3
õ
õ
 
=
õ
õ
 

templateIn
õ
õ
 !
[
õ
õ
! "
i
õ
õ
" #
]
õ
õ
# $
;
õ
õ
$ %
tmp4
ú
ú
 
=
ú
ú
 
(
ú
ú
 
i
ú
ú
 
<
ú
ú
 

radialCuts
ú
ú
 &
-
ú
ú
' (
$num
ú
ú
) *
)
ú
ú
* +
?
ú
ú
, -

templateIn
ú
ú
. 8
[
ú
ú
8 9
i
ú
ú
9 :
+
ú
ú
; <
$num
ú
ú
= >
]
ú
ú
> ?
:
ú
ú
@ A

templateIn
ú
ú
B L
[
ú
ú
L M
i
ú
ú
M N
]
ú
ú
N O
;
ú
ú
O P
Vector3
ü
ü
 
[
ü
ü
 
]
ü
ü
 
tpb
ü
ü
 
=
ü
ü
 
new
ü
ü
  #
Vector3
ü
ü
$ +
[
ü
ü
+ ,
$num
ü
ü
, -
]
ü
ü
- .
{
†
†
 
new
°
°
 
Vector3
°
°
 
(
°
°
  
tmp
°
°
  #
.
°
°
# $
x
°
°
$ %
,
°
°
% &
tmp
°
°
' *
.
°
°
* +
y
°
°
+ ,
,
°
°
, -
depth
°
°
. 3
)
°
°
3 4
,
°
°
4 5
new
¢
¢
 
Vector3
¢
¢
 
(
¢
¢
  
tmp2
¢
¢
  $
.
¢
¢
$ %
x
¢
¢
% &
,
¢
¢
& '
tmp2
¢
¢
( ,
.
¢
¢
, -
y
¢
¢
- .
,
¢
¢
. /
depth
¢
¢
0 5
)
¢
¢
5 6
,
¢
¢
6 7
new
£
£
 
Vector3
£
£
 
(
£
£
  
tmp3
£
£
  $
.
£
£
$ %
x
£
£
% &
,
£
£
& '
tmp3
£
£
( ,
.
£
£
, -
y
£
£
- .
,
£
£
. /
depth
£
£
0 5
)
£
£
5 6
,
£
£
6 7
new
§
§
 
Vector3
§
§
 
(
§
§
  
tmp4
§
§
  $
.
§
§
$ %
x
§
§
% &
,
§
§
& '
tmp4
§
§
( ,
.
§
§
, -
y
§
§
- .
,
§
§
. /
depth
§
§
0 5
)
§
§
5 6
,
§
§
6 7
}
•
•
 
;
•
•
 
Vector3
®
®
 
[
®
®
 
]
®
®
 
tpt
®
®
 
=
®
®
 
new
®
®
  #
Vector3
®
®
$ +
[
®
®
+ ,
$num
®
®
, -
]
®
®
- .
{
©
©
 
new
™
™
 
Vector3
™
™
 
(
™
™
  
tmp2
™
™
  $
.
™
™
$ %
x
™
™
% &
,
™
™
& '
tmp2
™
™
( ,
.
™
™
, -
y
™
™
- .
,
™
™
. /
$num
™
™
0 2
)
™
™
2 3
,
™
™
3 4
new
´
´
 
Vector3
´
´
 
(
´
´
  
tmp
´
´
  #
.
´
´
# $
x
´
´
$ %
,
´
´
% &
tmp
´
´
( +
.
´
´
+ ,
y
´
´
, -
,
´
´
- .
$num
´
´
/ 1
)
´
´
1 2
,
´
´
2 3
new
¨
¨
 
Vector3
¨
¨
 
(
¨
¨
  
tmp4
¨
¨
  $
.
¨
¨
$ %
x
¨
¨
% &
,
¨
¨
& '
tmp4
¨
¨
( ,
.
¨
¨
, -
y
¨
¨
- .
,
¨
¨
. /
$num
¨
¨
0 2
)
¨
¨
2 3
,
¨
¨
3 4
new
≠
≠
 
Vector3
≠
≠
 
(
≠
≠
  
tmp3
≠
≠
  $
.
≠
≠
$ %
x
≠
≠
% &
,
≠
≠
& '
tmp3
≠
≠
( ,
.
≠
≠
, -
y
≠
≠
- .
,
≠
≠
. /
$num
≠
≠
0 2
)
≠
≠
2 3
}
Æ
Æ
 
;
Æ
Æ
 
if
∞
∞
 
(
∞
∞
 

frontFaces
∞
∞
 
)
∞
∞
 
v
±
±
 
.
±
±
 
AddRange
±
±
 
(
±
±
 
tpb
±
±
 "
)
±
±
" #
;
±
±
# $
if
≤
≤
 
(
≤
≤
 
	backFaces
≤
≤
 
)
≤
≤
 
v
≥
≥
 
.
≥
≥
 
AddRange
≥
≥
 
(
≥
≥
 
tpt
≥
≥
 "
)
≥
≥
" #
;
≥
≥
# $
}
¥
¥
 
ProBuilderMesh
∂
∂
 
pb
∂
∂
 
=
∂
∂
 
ProBuilderMesh
∂
∂
  .
.
∂
∂
. /&
CreateInstanceWithPoints
∂
∂
/ G
(
∂
∂
G H
v
∂
∂
H I
.
∂
∂
I J
ToArray
∂
∂
J Q
(
∂
∂
Q R
)
∂
∂
R S
)
∂
∂
S T
;
∂
∂
T U
pb
∏
∏
 
.
∏
∏
 

gameObject
∏
∏
 
.
∏
∏
 
name
∏
∏
 
=
∏
∏
  
$str
∏
∏
! '
;
∏
∏
' (
pb
π
π
 
.
π
π
 
SetPivot
π
π
 
(
π
π
 
	pivotType
π
π
 !
)
π
π
! "
;
π
π
" #
return
ª
ª
 
pb
ª
ª
 
;
ª
ª
 
}
º
º
 	
public
 
 
 
static
 
 
 
ProBuilderMesh
 
 
 $!
GenerateIcosahedron
 
 
% 8
(
 
 
8 9
PivotLocation
 
 
9 F
	pivotType
 
 
G P
,
 
 
P Q
float
 
 
R W
radius
 
 
X ^
,
 
 
^ _
int
 
 
` c
subdivisions
 
 
d p
,
 
 
p q
bool
 
 
r v
weldVertices 
 
w É
= 
 
Ñ Ö
true 
 
Ü ä
, 
 
ä ã
bool 
 
å ê
	manualUvs 
 
ë ö
= 
 
õ ú
true 
 
ù °
) 
 
° ¢
{
À
À
 	
Vector3
Œ
Œ
 
[
Œ
Œ
 
]
Œ
Œ
 
v
Œ
Œ
 
=
Œ
Œ
 
new
Œ
Œ
 
Vector3
Œ
Œ
 %
[
Œ
Œ
% &"
k_IcosphereTriangles
Œ
Œ
& :
.
Œ
Œ
: ;
Length
Œ
Œ
; A
]
Œ
Œ
A B
;
Œ
Œ
B C
for
—
—
 
(
—
—
 
int
—
—
 
i
—
—
 
=
—
—
 
$num
—
—
 
;
—
—
 
i
—
—
 
<
—
—
 "
k_IcosphereTriangles
—
—
  4
.
—
—
4 5
Length
—
—
5 ;
;
—
—
; <
i
—
—
= >
+=
—
—
? A
$num
—
—
B C
)
—
—
C D
{
“
“
 
v
”
”
 
[
”
”
 
i
”
”
 
+
”
”
 
$num
”
”
 
]
”
”
 
=
”
”
 !
k_IcosphereVertices
”
”
 .
[
”
”
. /"
k_IcosphereTriangles
”
”
/ C
[
”
”
C D
i
”
”
D E
+
”
”
F G
$num
”
”
H I
]
”
”
I J
]
”
”
J K
.
”
”
K L

normalized
”
”
L V
*
”
”
W X
radius
”
”
Y _
;
”
”
_ `
v
‘
‘
 
[
‘
‘
 
i
‘
‘
 
+
‘
‘
 
$num
‘
‘
 
]
‘
‘
 
=
‘
‘
 !
k_IcosphereVertices
‘
‘
 .
[
‘
‘
. /"
k_IcosphereTriangles
‘
‘
/ C
[
‘
‘
C D
i
‘
‘
D E
+
‘
‘
F G
$num
‘
‘
H I
]
‘
‘
I J
]
‘
‘
J K
.
‘
‘
K L

normalized
‘
‘
L V
*
‘
‘
W X
radius
‘
‘
Y _
;
‘
‘
_ `
v
’
’
 
[
’
’
 
i
’
’
 
+
’
’
 
$num
’
’
 
]
’
’
 
=
’
’
 !
k_IcosphereVertices
’
’
 .
[
’
’
. /"
k_IcosphereTriangles
’
’
/ C
[
’
’
C D
i
’
’
D E
+
’
’
F G
$num
’
’
H I
]
’
’
I J
]
’
’
J K
.
’
’
K L

normalized
’
’
L V
*
’
’
W X
radius
’
’
Y _
;
’
’
_ `
}
÷
÷
 
for
ÿ
ÿ
 
(
ÿ
ÿ
 
int
ÿ
ÿ
 
i
ÿ
ÿ
 
=
ÿ
ÿ
 
$num
ÿ
ÿ
 
;
ÿ
ÿ
 
i
ÿ
ÿ
 
<
ÿ
ÿ
 
subdivisions
ÿ
ÿ
  ,
;
ÿ
ÿ
, -
i
ÿ
ÿ
. /
++
ÿ
ÿ
/ 1
)
ÿ
ÿ
1 2
{
Ÿ
Ÿ
 
v
⁄
⁄
 
=
⁄
⁄
 "
SubdivideIcosahedron
⁄
⁄
 (
(
⁄
⁄
( )
v
⁄
⁄
) *
,
⁄
⁄
* +
radius
⁄
⁄
, 2
)
⁄
⁄
2 3
;
⁄
⁄
3 4
}
€
€
 
Face
›
›
 
[
›
›
 
]
›
›
 
f
›
›
 
=
›
›
 
new
›
›
 
Face
›
›
 
[
›
›
  
v
›
›
  !
.
›
›
! "
Length
›
›
" (
/
›
›
) *
$num
›
›
+ ,
]
›
›
, -
;
›
›
- .
Vector3
ﬂ
ﬂ
 &
bottomMostVertexPosition
ﬂ
ﬂ
 ,
=
ﬂ
ﬂ
- .
Vector3
ﬂ
ﬂ
/ 6
.
ﬂ
ﬂ
6 7
positiveInfinity
ﬂ
ﬂ
7 G
;
ﬂ
ﬂ
G H
int
‡
‡
 #
bottomMostVertexIndex
‡
‡
 %
=
‡
‡
& '
-
‡
‡
( )
$num
‡
‡
) *
;
‡
‡
* +
for
‚
‚
 
(
‚
‚
 
int
‚
‚
 
i
‚
‚
 
=
‚
‚
 
$num
‚
‚
 
;
‚
‚
 
i
‚
‚
 
<
‚
‚
 
v
‚
‚
  !
.
‚
‚
! "
Length
‚
‚
" (
;
‚
‚
( )
i
‚
‚
* +
+=
‚
‚
, .
$num
‚
‚
/ 0
)
‚
‚
0 1
{
„
„
 
f
‰
‰
 
[
‰
‰
 
i
‰
‰
 
/
‰
‰
 
$num
‰
‰
 
]
‰
‰
 
=
‰
‰
 
new
‰
‰
 
Face
‰
‰
 #
(
‰
‰
# $
new
‰
‰
$ '
int
‰
‰
( +
[
‰
‰
+ ,
$num
‰
‰
, -
]
‰
‰
- .
{
‰
‰
/ 0
i
‰
‰
1 2
,
‰
‰
2 3
i
‰
‰
4 5
+
‰
‰
6 7
$num
‰
‰
8 9
,
‰
‰
9 :
i
‰
‰
; <
+
‰
‰
= >
$num
‰
‰
? @
}
‰
‰
A B
)
‰
‰
B C
;
‰
‰
C D
f
Â
Â
 
[
Â
Â
 
i
Â
Â
 
/
Â
Â
 
$num
Â
Â
 
]
Â
Â
 
.
Â
Â
 
manualUV
Â
Â
 !
=
Â
Â
" #
	manualUvs
Â
Â
$ -
;
Â
Â
- .
for
Ë
Ë
 
(
Ë
Ë
 
int
Ë
Ë
 
j
Ë
Ë
 
=
Ë
Ë
 
$num
Ë
Ë
 
;
Ë
Ë
 
j
Ë
Ë
  !
<
Ë
Ë
" #
f
Ë
Ë
$ %
[
Ë
Ë
% &
i
Ë
Ë
& '
/
Ë
Ë
( )
$num
Ë
Ë
* +
]
Ë
Ë
+ ,
.
Ë
Ë
, -
indexes
Ë
Ë
- 4
.
Ë
Ë
4 5
Count
Ë
Ë
5 :
;
Ë
Ë
: ;
++
Ë
Ë
< >
j
Ë
Ë
> ?
)
Ë
Ë
? @
{
È
È
 
int
Í
Í
 
index
Í
Í
 
=
Í
Í
 
f
Í
Í
  !
[
Í
Í
! "
i
Í
Í
" #
/
Í
Í
$ %
$num
Í
Í
& '
]
Í
Í
' (
.
Í
Í
( )
indexes
Í
Í
) 0
[
Í
Í
0 1
j
Í
Í
1 2
]
Í
Í
2 3
;
Í
Í
3 4
if
Ï
Ï
 
(
Ï
Ï
 
v
Ï
Ï
 
[
Ï
Ï
 
index
Ï
Ï
 
]
Ï
Ï
  
.
Ï
Ï
  !
y
Ï
Ï
! "
<
Ï
Ï
# $&
bottomMostVertexPosition
Ï
Ï
% =
.
Ï
Ï
= >
y
Ï
Ï
> ?
)
Ï
Ï
? @
{
Ì
Ì
 &
bottomMostVertexPosition
Ó
Ó
 0
=
Ó
Ó
1 2
v
Ó
Ó
3 4
[
Ó
Ó
4 5
index
Ó
Ó
5 :
]
Ó
Ó
: ;
;
Ó
Ó
; <#
bottomMostVertexIndex
Ô
Ô
 -
=
Ô
Ô
. /
index
Ô
Ô
0 5
;
Ô
Ô
5 6
}


 
}
Ò
Ò
 
}
Ú
Ú
 
if
Ù
Ù
 
(
Ù
Ù
 
!
Ù
Ù
 
	manualUvs
Ù
Ù
 
)
Ù
Ù
 
{
ı
ı
 
for
ˆ
ˆ
 
(
ˆ
ˆ
 
int
ˆ
ˆ
 
i
ˆ
ˆ
 
=
ˆ
ˆ
 
$num
ˆ
ˆ
 
;
ˆ
ˆ
 
i
ˆ
ˆ
  !
<
ˆ
ˆ
" #
f
ˆ
ˆ
$ %
.
ˆ
ˆ
% &
Length
ˆ
ˆ
& ,
;
ˆ
ˆ
, -
i
ˆ
ˆ
. /
++
ˆ
ˆ
/ 1
)
ˆ
ˆ
1 2
{
˜
˜
 
var
¯
¯
 
nrm
¯
¯
 
=
¯
¯
 
Math
¯
¯
 "
.
¯
¯
" #
Normal
¯
¯
# )
(
¯
¯
) *
v
¯
¯
* +
[
¯
¯
+ ,
f
¯
¯
, -
[
¯
¯
- .
i
¯
¯
. /
]
¯
¯
/ 0
.
¯
¯
0 1
indexesInternal
¯
¯
1 @
[
¯
¯
@ A
$num
¯
¯
A B
]
¯
¯
B C
]
¯
¯
C D
,
¯
¯
D E
v
¯
¯
F G
[
¯
¯
G H
f
¯
¯
H I
[
¯
¯
I J
i
¯
¯
J K
]
¯
¯
K L
.
¯
¯
L M
indexesInternal
¯
¯
M \
[
¯
¯
\ ]
$num
¯
¯
] ^
]
¯
¯
^ _
]
¯
¯
_ `
,
¯
¯
` a
v
¯
¯
b c
[
¯
¯
c d
f
¯
¯
d e
[
¯
¯
e f
i
¯
¯
f g
]
¯
¯
g h
.
¯
¯
h i
indexesInternal
¯
¯
i x
[
¯
¯
x y
$num
¯
¯
y z
]
¯
¯
z {
]
¯
¯
{ |
)
¯
¯
| }
;
¯
¯
} ~
var
˘
˘
 
axis
˘
˘
 
=
˘
˘
 

Projection
˘
˘
 )
.
˘
˘
) *$
VectorToProjectionAxis
˘
˘
* @
(
˘
˘
@ A
nrm
˘
˘
A D
)
˘
˘
D E
;
˘
˘
E F
if
˚
˚
 
(
˚
˚
 
axis
˚
˚
 
==
˚
˚
 
ProjectionAxis
˚
˚
  .
.
˚
˚
. /
X
˚
˚
/ 0
)
˚
˚
0 1
f
¸
¸
 
[
¸
¸
 
i
¸
¸
 
]
¸
¸
 
.
¸
¸
 
textureGroup
¸
¸
 )
=
¸
¸
* +
$num
¸
¸
, -
;
¸
¸
- .
else
˝
˝
 
if
˝
˝
 
(
˝
˝
 
axis
˝
˝
 !
==
˝
˝
" $
ProjectionAxis
˝
˝
% 3
.
˝
˝
3 4
Y
˝
˝
4 5
)
˝
˝
5 6
f
˛
˛
 
[
˛
˛
 
i
˛
˛
 
]
˛
˛
 
.
˛
˛
 
textureGroup
˛
˛
 )
=
˛
˛
* +
$num
˛
˛
, -
;
˛
˛
- .
else
ˇ
ˇ
 
if
ˇ
ˇ
 
(
ˇ
ˇ
 
axis
ˇ
ˇ
 !
==
ˇ
ˇ
" $
ProjectionAxis
ˇ
ˇ
% 3
.
ˇ
ˇ
3 4
Z
ˇ
ˇ
4 5
)
ˇ
ˇ
5 6
f
ÄÄ 
[
ÄÄ 
i
ÄÄ 
]
ÄÄ 
.
ÄÄ 
textureGroup
ÄÄ )
=
ÄÄ* +
$num
ÄÄ, -
;
ÄÄ- .
else
ÅÅ 
if
ÅÅ 
(
ÅÅ 
axis
ÅÅ !
==
ÅÅ" $
ProjectionAxis
ÅÅ% 3
.
ÅÅ3 4
	XNegative
ÅÅ4 =
)
ÅÅ= >
f
ÇÇ 
[
ÇÇ 
i
ÇÇ 
]
ÇÇ 
.
ÇÇ 
textureGroup
ÇÇ )
=
ÇÇ* +
$num
ÇÇ, -
;
ÇÇ- .
else
ÉÉ 
if
ÉÉ 
(
ÉÉ 
axis
ÉÉ !
==
ÉÉ" $
ProjectionAxis
ÉÉ% 3
.
ÉÉ3 4
	YNegative
ÉÉ4 =
)
ÉÉ= >
f
ÑÑ 
[
ÑÑ 
i
ÑÑ 
]
ÑÑ 
.
ÑÑ 
textureGroup
ÑÑ )
=
ÑÑ* +
$num
ÑÑ, -
;
ÑÑ- .
else
ÖÖ 
if
ÖÖ 
(
ÖÖ 
axis
ÖÖ !
==
ÖÖ" $
ProjectionAxis
ÖÖ% 3
.
ÖÖ3 4
	ZNegative
ÖÖ4 =
)
ÖÖ= >
f
ÜÜ 
[
ÜÜ 
i
ÜÜ 
]
ÜÜ 
.
ÜÜ 
textureGroup
ÜÜ )
=
ÜÜ* +
$num
ÜÜ, -
;
ÜÜ- .
}
áá 
}
àà 

GameObject
ää 
go
ää 
=
ää 
new
ää 

GameObject
ää  *
(
ää* +
)
ää+ ,
;
ää, -
ProBuilderMesh
ãã 
pb
ãã 
=
ãã 
go
ãã  "
.
ãã" #
AddComponent
ãã# /
<
ãã/ 0
ProBuilderMesh
ãã0 >
>
ãã> ?
(
ãã? @
)
ãã@ A
;
ããA B
pb
åå 
.
åå 
Clear
åå 
(
åå 
)
åå 
;
åå 
pb
çç 
.
çç 
positionsInternal
çç  
=
çç! "
v
çç# $
;
çç$ %
pb
éé 
.
éé 
facesInternal
éé 
=
éé 
f
éé  
;
éé  !
if
êê 
(
êê 
!
êê 
weldVertices
êê 
)
êê 
{
ëë 
SharedVertex
íí 
[
íí 
]
íí 
si
íí !
=
íí" #
new
íí$ '
SharedVertex
íí( 4
[
íí4 5
v
íí5 6
.
íí6 7
Length
íí7 =
]
íí= >
;
íí> ?
for
ìì 
(
ìì 
int
ìì 
i
ìì 
=
ìì 
$num
ìì 
;
ìì 
i
ìì  !
<
ìì" #
si
ìì$ &
.
ìì& '
Length
ìì' -
;
ìì- .
i
ìì/ 0
++
ìì0 2
)
ìì2 3
si
îî 
[
îî 
i
îî 
]
îî 
=
îî 
new
îî 
SharedVertex
îî  ,
(
îî, -
new
îî- 0
int
îî1 4
[
îî4 5
]
îî5 6
{
îî7 8
i
îî8 9
}
îî9 :
)
îî: ;
;
îî; <
pb
ññ 
.
ññ $
sharedVerticesInternal
ññ )
=
ññ* +
si
ññ, .
;
ññ. /
}
óó 
else
òò 
{
ôô 
pb
öö 
.
öö $
sharedVerticesInternal
öö )
=
öö* +
SharedVertex
öö, 8
.
öö8 9,
GetSharedVerticesWithPositions
öö9 W
(
ööW X
v
ööX Y
)
ööY Z
;
ööZ [
}
õõ 
pb
ùù 
.
ùù 
ToMesh
ùù 
(
ùù 
)
ùù 
;
ùù 
pb
ûû 
.
ûû 
Refresh
ûû 
(
ûû 
)
ûû 
;
ûû 
pb
üü 
.
üü 

gameObject
üü 
.
üü 
name
üü 
=
üü  
$str
üü! ,
;
üü, -
pb
†† 
.
†† 
SetPivot
†† 
(
†† 
	pivotType
†† !
,
††! "#
bottomMostVertexIndex
††# 8
)
††8 9
;
††9 :
pb
¢¢ 
.
¢¢ 
unwrapParameters
¢¢ 
=
¢¢  !
new
¢¢" %
UnwrapParameters
¢¢& 6
(
¢¢6 7
)
¢¢7 8
{
££ 

packMargin
§§ 
=
§§ 
$num
§§  
}
•• 
;
•• 
return
ßß 
pb
ßß 
;
ßß 
}
®® 	
static
∞∞ 
Vector3
∞∞ 
[
∞∞ 
]
∞∞ "
SubdivideIcosahedron
∞∞ -
(
∞∞- .
Vector3
∞∞. 5
[
∞∞5 6
]
∞∞6 7
vertices
∞∞8 @
,
∞∞@ A
float
∞∞B G
radius
∞∞H N
)
∞∞N O
{
±± 	
Vector3
≤≤ 
[
≤≤ 
]
≤≤ 
v
≤≤ 
=
≤≤ 
new
≤≤ 
Vector3
≤≤ %
[
≤≤% &
vertices
≤≤& .
.
≤≤. /
Length
≤≤/ 5
*
≤≤6 7
$num
≤≤8 9
]
≤≤9 :
;
≤≤: ;
int
¥¥ 
index
¥¥ 
=
¥¥ 
$num
¥¥ 
;
¥¥ 
Vector3
∂∂ 
p0
∂∂ 
=
∂∂ 
Vector3
∂∂  
.
∂∂  !
zero
∂∂! %
,
∂∂% &
p1
∑∑ 
=
∑∑ 
Vector3
∑∑  
.
∑∑  !
zero
∑∑! %
,
∑∑% &
p2
∏∏ 
=
∏∏ 
Vector3
∏∏  
.
∏∏  !
zero
∏∏! %
,
∏∏% &
p3
ππ 
=
ππ 
Vector3
ππ  
.
ππ  !
zero
ππ! %
,
ππ% &
p4
∫∫ 
=
∫∫ 
Vector3
∫∫  
.
∫∫  !
zero
∫∫! %
,
∫∫% &
p5
ªª 
=
ªª 
Vector3
ªª  
.
ªª  !
zero
ªª! %
;
ªª% &
for
ΩΩ 
(
ΩΩ 
int
ΩΩ 
i
ΩΩ 
=
ΩΩ 
$num
ΩΩ 
;
ΩΩ 
i
ΩΩ 
<
ΩΩ 
vertices
ΩΩ  (
.
ΩΩ( )
Length
ΩΩ) /
;
ΩΩ/ 0
i
ΩΩ1 2
+=
ΩΩ3 5
$num
ΩΩ6 7
)
ΩΩ7 8
{
ææ 
p0
øø 
=
øø 
vertices
øø 
[
øø 
i
øø 
+
øø  !
$num
øø" #
]
øø# $
;
øø$ %
p2
¿¿ 
=
¿¿ 
vertices
¿¿ 
[
¿¿ 
i
¿¿ 
+
¿¿  !
$num
¿¿" #
]
¿¿# $
;
¿¿$ %
p5
¡¡ 
=
¡¡ 
vertices
¡¡ 
[
¡¡ 
i
¡¡ 
+
¡¡  !
$num
¡¡" #
]
¡¡# $
;
¡¡$ %
p1
¬¬ 
=
¬¬ 
(
¬¬ 
(
¬¬ 
p0
¬¬ 
+
¬¬ 
p2
¬¬ 
)
¬¬ 
*
¬¬  !
$num
¬¬" %
)
¬¬% &
.
¬¬& '

normalized
¬¬' 1
*
¬¬2 3
radius
¬¬4 :
;
¬¬: ;
p3
√√ 
=
√√ 
(
√√ 
(
√√ 
p0
√√ 
+
√√ 
p5
√√ 
)
√√ 
*
√√  !
$num
√√" %
)
√√% &
.
√√& '

normalized
√√' 1
*
√√2 3
radius
√√4 :
;
√√: ;
p4
ƒƒ 
=
ƒƒ 
(
ƒƒ 
(
ƒƒ 
p2
ƒƒ 
+
ƒƒ 
p5
ƒƒ 
)
ƒƒ 
*
ƒƒ  !
$num
ƒƒ" %
)
ƒƒ% &
.
ƒƒ& '

normalized
ƒƒ' 1
*
ƒƒ2 3
radius
ƒƒ4 :
;
ƒƒ: ;
v
∆∆ 
[
∆∆ 
index
∆∆ 
++
∆∆ 
]
∆∆ 
=
∆∆ 
p0
∆∆ 
;
∆∆  
v
«« 
[
«« 
index
«« 
++
«« 
]
«« 
=
«« 
p1
«« 
;
««  
v
»» 
[
»» 
index
»» 
++
»» 
]
»» 
=
»» 
p3
»» 
;
»»  
v
   
[
   
index
   
++
   
]
   
=
   
p1
   
;
    
v
ÀÀ 
[
ÀÀ 
index
ÀÀ 
++
ÀÀ 
]
ÀÀ 
=
ÀÀ 
p2
ÀÀ 
;
ÀÀ  
v
ÃÃ 
[
ÃÃ 
index
ÃÃ 
++
ÃÃ 
]
ÃÃ 
=
ÃÃ 
p4
ÃÃ 
;
ÃÃ  
v
ŒŒ 
[
ŒŒ 
index
ŒŒ 
++
ŒŒ 
]
ŒŒ 
=
ŒŒ 
p1
ŒŒ 
;
ŒŒ  
v
œœ 
[
œœ 
index
œœ 
++
œœ 
]
œœ 
=
œœ 
p4
œœ 
;
œœ  
v
–– 
[
–– 
index
–– 
++
–– 
]
–– 
=
–– 
p3
–– 
;
––  
v
““ 
[
““ 
index
““ 
++
““ 
]
““ 
=
““ 
p3
““ 
;
““  
v
”” 
[
”” 
index
”” 
++
”” 
]
”” 
=
”” 
p4
”” 
;
””  
v
‘‘ 
[
‘‘ 
index
‘‘ 
++
‘‘ 
]
‘‘ 
=
‘‘ 
p5
‘‘ 
;
‘‘  
}
’’ 
return
◊◊ 
v
◊◊ 
;
◊◊ 
}
ÿÿ 	
static
⁄⁄ 
Vector3
⁄⁄ 
[
⁄⁄ 
]
⁄⁄ 
GetCirclePoints
⁄⁄ (
(
⁄⁄( )
int
⁄⁄) ,
segments
⁄⁄- 5
,
⁄⁄5 6
float
⁄⁄7 <
radius
⁄⁄= C
,
⁄⁄C D
float
⁄⁄E J
circumference
⁄⁄K X
,
⁄⁄X Y

Quaternion
⁄⁄Z d
rotation
⁄⁄e m
,
⁄⁄m n
float
⁄⁄o t
offset
⁄⁄u {
)
⁄⁄{ |
{
€€ 	
float
‹‹ 
seg
‹‹ 
=
‹‹ 
(
‹‹ 
float
‹‹ 
)
‹‹ 
segments
‹‹ '
-
‹‹( )
$num
‹‹* +
;
‹‹+ ,
Vector3
ﬁﬁ 
[
ﬁﬁ 
]
ﬁﬁ 
v
ﬁﬁ 
=
ﬁﬁ 
new
ﬁﬁ 
Vector3
ﬁﬁ %
[
ﬁﬁ% &
(
ﬁﬁ& '
segments
ﬁﬁ' /
-
ﬁﬁ0 1
$num
ﬁﬁ2 3
)
ﬁﬁ3 4
*
ﬁﬁ5 6
$num
ﬁﬁ7 8
]
ﬁﬁ8 9
;
ﬁﬁ9 :
v
ﬂﬂ 
[
ﬂﬂ 
$num
ﬂﬂ 
]
ﬂﬂ 
=
ﬂﬂ 
new
ﬂﬂ 
Vector3
ﬂﬂ 
(
ﬂﬂ 
Mathf
ﬂﬂ $
.
ﬂﬂ$ %
Cos
ﬂﬂ% (
(
ﬂﬂ( )
(
ﬂﬂ) *
(
ﬂﬂ* +
$num
ﬂﬂ+ -
/
ﬂﬂ. /
seg
ﬂﬂ0 3
)
ﬂﬂ3 4
*
ﬂﬂ5 6
circumference
ﬂﬂ7 D
)
ﬂﬂD E
*
ﬂﬂF G
Mathf
ﬂﬂH M
.
ﬂﬂM N
Deg2Rad
ﬂﬂN U
)
ﬂﬂU V
*
ﬂﬂW X
radius
ﬂﬂY _
,
ﬂﬂ_ `
Mathf
ﬂﬂa f
.
ﬂﬂf g
Sin
ﬂﬂg j
(
ﬂﬂj k
(
ﬂﬂk l
(
ﬂﬂl m
$num
ﬂﬂm o
/
ﬂﬂp q
seg
ﬂﬂr u
)
ﬂﬂu v
*
ﬂﬂw x
circumferenceﬂﬂy Ü
)ﬂﬂÜ á
*ﬂﬂà â
Mathfﬂﬂä è
.ﬂﬂè ê
Deg2Radﬂﬂê ó
)ﬂﬂó ò
*ﬂﬂô ö
radiusﬂﬂõ °
,ﬂﬂ° ¢
$numﬂﬂ£ •
)ﬂﬂ• ¶
;ﬂﬂ¶ ß
v
‡‡ 
[
‡‡ 
$num
‡‡ 
]
‡‡ 
=
‡‡ 
new
‡‡ 
Vector3
‡‡ 
(
‡‡ 
Mathf
‡‡ $
.
‡‡$ %
Cos
‡‡% (
(
‡‡( )
(
‡‡) *
(
‡‡* +
$num
‡‡+ -
/
‡‡. /
seg
‡‡0 3
)
‡‡3 4
*
‡‡5 6
circumference
‡‡7 D
)
‡‡D E
*
‡‡F G
Mathf
‡‡H M
.
‡‡M N
Deg2Rad
‡‡N U
)
‡‡U V
*
‡‡W X
radius
‡‡Y _
,
‡‡_ `
Mathf
‡‡a f
.
‡‡f g
Sin
‡‡g j
(
‡‡j k
(
‡‡k l
(
‡‡l m
$num
‡‡m o
/
‡‡p q
seg
‡‡r u
)
‡‡u v
*
‡‡w x
circumference‡‡y Ü
)‡‡Ü á
*‡‡à â
Mathf‡‡ä è
.‡‡è ê
Deg2Rad‡‡ê ó
)‡‡ó ò
*‡‡ô ö
radius‡‡õ °
,‡‡° ¢
$num‡‡£ •
)‡‡• ¶
;‡‡¶ ß
v
‚‚ 
[
‚‚ 
$num
‚‚ 
]
‚‚ 
=
‚‚ 
rotation
‚‚ 
*
‚‚ 
(
‚‚ 
(
‚‚  
v
‚‚  !
[
‚‚! "
$num
‚‚" #
]
‚‚# $
+
‚‚% &
Vector3
‚‚' .
.
‚‚. /
right
‚‚/ 4
*
‚‚5 6
offset
‚‚7 =
)
‚‚= >
)
‚‚> ?
;
‚‚? @
v
„„ 
[
„„ 
$num
„„ 
]
„„ 
=
„„ 
rotation
„„ 
*
„„ 
(
„„ 
(
„„  
v
„„  !
[
„„! "
$num
„„" #
]
„„# $
+
„„% &
Vector3
„„' .
.
„„. /
right
„„/ 4
*
„„5 6
offset
„„7 =
)
„„= >
)
„„> ?
;
„„? @
int
ÂÂ 
n
ÂÂ 
=
ÂÂ 
$num
ÂÂ 
;
ÂÂ 
System
ÁÁ 
.
ÁÁ 
Text
ÁÁ 
.
ÁÁ 
StringBuilder
ÁÁ %
sb
ÁÁ& (
=
ÁÁ) *
new
ÁÁ+ .
System
ÁÁ/ 5
.
ÁÁ5 6
Text
ÁÁ6 :
.
ÁÁ: ;
StringBuilder
ÁÁ; H
(
ÁÁH I
)
ÁÁI J
;
ÁÁJ K
for
ÈÈ 
(
ÈÈ 
int
ÈÈ 
i
ÈÈ 
=
ÈÈ 
$num
ÈÈ 
;
ÈÈ 
i
ÈÈ 
<
ÈÈ 
segments
ÈÈ  (
;
ÈÈ( )
i
ÈÈ* +
++
ÈÈ+ -
)
ÈÈ- .
{
ÍÍ 
float
ÎÎ 
rad
ÎÎ 
=
ÎÎ 
(
ÎÎ 
(
ÎÎ 
i
ÎÎ 
/
ÎÎ  !
seg
ÎÎ" %
)
ÎÎ% &
*
ÎÎ' (
circumference
ÎÎ) 6
)
ÎÎ6 7
*
ÎÎ8 9
Mathf
ÎÎ: ?
.
ÎÎ? @
Deg2Rad
ÎÎ@ G
;
ÎÎG H
sb
ÏÏ 
.
ÏÏ 

AppendLine
ÏÏ 
(
ÏÏ 
rad
ÏÏ !
.
ÏÏ! "
ToString
ÏÏ" *
(
ÏÏ* +
)
ÏÏ+ ,
)
ÏÏ, -
;
ÏÏ- .
v
ÓÓ 
[
ÓÓ 
n
ÓÓ 
+
ÓÓ 
$num
ÓÓ 
]
ÓÓ 
=
ÓÓ 
v
ÓÓ 
[
ÓÓ 
n
ÓÓ 
-
ÓÓ  
$num
ÓÓ! "
]
ÓÓ" #
;
ÓÓ# $
v
ÔÔ 
[
ÔÔ 
n
ÔÔ 
+
ÔÔ 
$num
ÔÔ 
]
ÔÔ 
=
ÔÔ 
rotation
ÔÔ #
*
ÔÔ$ %
(
ÔÔ& '
new
ÔÔ' *
Vector3
ÔÔ+ 2
(
ÔÔ2 3
Mathf
ÔÔ3 8
.
ÔÔ8 9
Cos
ÔÔ9 <
(
ÔÔ< =
rad
ÔÔ= @
)
ÔÔ@ A
*
ÔÔB C
radius
ÔÔD J
,
ÔÔJ K
Mathf
ÔÔL Q
.
ÔÔQ R
Sin
ÔÔR U
(
ÔÔU V
rad
ÔÔV Y
)
ÔÔY Z
*
ÔÔ[ \
radius
ÔÔ] c
,
ÔÔc d
$num
ÔÔe g
)
ÔÔg h
+
ÔÔi j
Vector3
ÔÔk r
.
ÔÔr s
right
ÔÔs x
*
ÔÔy z
offsetÔÔ{ Å
)ÔÔÅ Ç
;ÔÔÇ É
n
ÒÒ 
+=
ÒÒ 
$num
ÒÒ 
;
ÒÒ 
}
ÚÚ 
return
ÙÙ 
v
ÙÙ 
;
ÙÙ 
}
ıı 	
public
ÑÑ 
static
ÑÑ 
ProBuilderMesh
ÑÑ $
GenerateTorus
ÑÑ% 2
(
ÑÑ2 3
PivotLocation
ÑÑ3 @
	pivotType
ÑÑA J
,
ÑÑJ K
int
ÑÑL O
rows
ÑÑP T
,
ÑÑT U
int
ÑÑV Y
columns
ÑÑZ a
,
ÑÑa b
float
ÑÑc h
innerRadius
ÑÑi t
,
ÑÑt u
float
ÑÑv {
outerRadiusÑÑ| á
,ÑÑá à
boolÑÑâ ç
smoothÑÑé î
,ÑÑî ï
floatÑÑñ õ'
horizontalCircumferenceÑÑú ≥
,ÑÑ≥ ¥
floatÑÑµ ∫%
verticalCircumferenceÑÑª –
,ÑÑ– —
boolÑÑ“ ÷
	manualUvsÑÑ◊ ‡
=ÑÑ· ‚
falseÑÑ„ Ë
)ÑÑË È
{
ÖÖ 	
int
ÜÜ 
clampedRows
ÜÜ 
=
ÜÜ 
(
ÜÜ 
int
ÜÜ "
)
ÜÜ" #
Mathf
ÜÜ# (
.
ÜÜ( )
Clamp
ÜÜ) .
(
ÜÜ. /
rows
ÜÜ/ 3
+
ÜÜ4 5
$num
ÜÜ6 7
,
ÜÜ7 8
$num
ÜÜ9 :
,
ÜÜ: ;
$num
ÜÜ< ?
)
ÜÜ? @
;
ÜÜ@ A
int
áá 
clampedColumns
áá 
=
áá  
(
áá! "
int
áá" %
)
áá% &
Mathf
áá& +
.
áá+ ,
Clamp
áá, 1
(
áá1 2
columns
áá2 9
+
áá: ;
$num
áá< =
,
áá= >
$num
áá? @
,
áá@ A
$num
ááB E
)
ááE F
;
ááF G
float
àà 
clampedRadius
àà 
=
àà  !
Mathf
àà" '
.
àà' (
Clamp
àà( -
(
àà- .
innerRadius
àà. 9
,
àà9 :
$num
àà; ?
,
àà? @
$num
ààA F
)
ààF G
;
ààG H
float
ââ 
clampedTubeRadius
ââ #
=
ââ$ %
Mathf
ââ& +
.
ââ+ ,
Clamp
ââ, 1
(
ââ1 2
outerRadius
ââ2 =
,
ââ= >
$num
ââ? C
,
ââC D
clampedRadius
ââE R
-
ââS T
$num
ââU Z
)
ââZ [
;
ââ[ \
clampedRadius
ää 
-=
ää 
clampedTubeRadius
ää .
;
ää. /
float
ãã ,
clampedHorizontalCircumference
ãã 0
=
ãã1 2
Mathf
ãã3 8
.
ãã8 9
Clamp
ãã9 >
(
ãã> ?%
horizontalCircumference
ãã? V
,
ããV W
$num
ããX \
,
ãã\ ]
$num
ãã^ b
)
ããb c
;
ããc d
float
åå *
clampedVerticalCircumference
åå .
=
åå/ 0
Mathf
åå1 6
.
åå6 7
Clamp
åå7 <
(
åå< =#
verticalCircumference
åå= R
,
ååR S
$num
ååT X
,
ååX Y
$num
ååZ ^
)
åå^ _
;
åå_ `
List
éé 
<
éé 
Vector3
éé 
>
éé 
vertices
éé "
=
éé# $
new
éé% (
List
éé) -
<
éé- .
Vector3
éé. 5
>
éé5 6
(
éé6 7
)
éé7 8
;
éé8 9
int
êê 
col
êê 
=
êê 
clampedColumns
êê $
-
êê% &
$num
êê' (
;
êê( )
Vector3
íí 
[
íí 
]
íí 
cir
íí 
=
íí 
GetCirclePoints
íí +
(
íí+ ,
clampedRows
íí, 7
,
íí7 8
clampedTubeRadius
íí9 J
,
ííJ K*
clampedVerticalCircumference
ííL h
,
ííh i

Quaternion
ííj t
.
íít u
Euler
ííu z
(
ííz {
Vector3íí{ Ç
.ííÇ É
upííÉ Ö
*ííÜ á
$numííà ä
*ííã å.
clampedHorizontalCircumferenceííç ´
)íí´ ¨
,íí¨ ≠
clampedRadiusííÆ ª
)ííª º
;ííº Ω
for
îî 
(
îî 
int
îî 
i
îî 
=
îî 
$num
îî 
;
îî 
i
îî 
<
îî 
clampedColumns
îî  .
;
îî. /
i
îî0 1
++
îî1 3
)
îî3 4
{
ïï 
vertices
ññ 
.
ññ 
AddRange
ññ !
(
ññ! "
cir
ññ" %
)
ññ% &
;
ññ& '

Quaternion
óó 
rotation
óó #
=
óó$ %

Quaternion
óó& 0
.
óó0 1
Euler
óó1 6
(
óó6 7
Vector3
óó7 >
.
óó> ?
up
óó? A
*
óóB C
(
óóD E
(
óóE F
i
óóF G
/
óóH I
(
óóJ K
float
óóK P
)
óóP Q
col
óóQ T
)
óóT U
*
óóV W,
clampedHorizontalCircumference
óóX v
)
óóv w
)
óów x
;
óóx y
cir
òò 
=
òò 
GetCirclePoints
òò %
(
òò% &
clampedRows
òò& 1
,
òò1 2
clampedTubeRadius
òò3 D
,
òòD E*
clampedVerticalCircumference
òòF b
,
òòb c
rotation
òòd l
,
òòl m
clampedRadius
òòn {
)
òò{ |
;
òò| }
vertices
ôô 
.
ôô 
AddRange
ôô !
(
ôô! "
cir
ôô" %
)
ôô% &
;
ôô& '
}
öö 
List
ùù 
<
ùù 
Face
ùù 
>
ùù 
faces
ùù 
=
ùù 
new
ùù "
List
ùù# '
<
ùù' (
Face
ùù( ,
>
ùù, -
(
ùù- .
)
ùù. /
;
ùù/ 0
int
ûû 
fc
ûû 
=
ûû 
$num
ûû 
;
ûû 
for
°° 
(
°° 
int
°° 
i
°° 
=
°° 
$num
°° 
;
°° 
i
°° 
<
°° 
(
°°  !
clampedColumns
°°! /
-
°°0 1
$num
°°2 3
)
°°3 4
*
°°5 6
$num
°°7 8
;
°°8 9
i
°°: ;
+=
°°< >
$num
°°? @
)
°°@ A
{
¢¢ 
for
££ 
(
££ 
int
££ 
n
££ 
=
££ 
$num
££ 
;
££ 
n
££  !
<
££" #
clampedRows
££$ /
-
££0 1
$num
££2 3
;
££3 4
n
££5 6
++
££6 8
)
££8 9
{
§§ 
int
•• 
a
•• 
=
•• 
(
•• 
i
•• 
+
••  
$num
••! "
)
••" #
*
••$ %
(
••& '
(
••' (
clampedRows
••( 3
-
••4 5
$num
••6 7
)
••7 8
*
••9 :
$num
••; <
)
••< =
+
••> ?
(
••@ A
n
••A B
*
••C D
$num
••E F
)
••F G
;
••G H
int
¶¶ 
b
¶¶ 
=
¶¶ 
(
¶¶ 
i
¶¶ 
+
¶¶  
$num
¶¶! "
)
¶¶" #
*
¶¶$ %
(
¶¶& '
(
¶¶' (
clampedRows
¶¶( 3
-
¶¶4 5
$num
¶¶6 7
)
¶¶7 8
*
¶¶9 :
$num
¶¶; <
)
¶¶< =
+
¶¶> ?
(
¶¶@ A
n
¶¶A B
*
¶¶C D
$num
¶¶E F
)
¶¶F G
;
¶¶G H
int
®® 
c
®® 
=
®® 
(
®® 
i
®® 
+
®®  
$num
®®! "
)
®®" #
*
®®$ %
(
®®& '
(
®®' (
clampedRows
®®( 3
-
®®4 5
$num
®®6 7
)
®®7 8
*
®®9 :
$num
®®; <
)
®®< =
+
®®> ?
(
®®@ A
n
®®A B
*
®®C D
$num
®®E F
)
®®F G
+
®®H I
$num
®®J K
;
®®K L
int
©© 
d
©© 
=
©© 
(
©© 
i
©© 
+
©©  
$num
©©! "
)
©©" #
*
©©$ %
(
©©& '
(
©©' (
clampedRows
©©( 3
-
©©4 5
$num
©©6 7
)
©©7 8
*
©©9 :
$num
©©; <
)
©©< =
+
©©> ?
(
©©@ A
n
©©A B
*
©©C D
$num
©©E F
)
©©F G
+
©©H I
$num
©©J K
;
©©K L
faces
´´ 
.
´´ 
Add
´´ 
(
´´ 
new
´´ !
Face
´´" &
(
´´& '
new
´´' *
int
´´+ .
[
´´. /
]
´´/ 0
{
´´1 2
a
´´3 4
,
´´4 5
b
´´6 7
,
´´7 8
c
´´9 :
,
´´: ;
b
´´< =
,
´´= >
d
´´? @
,
´´@ A
c
´´B C
}
´´D E
)
´´E F
)
´´F G
;
´´G H
faces
¨¨ 
[
¨¨ 
fc
¨¨ 
]
¨¨ 
.
¨¨ 
smoothingGroup
¨¨ ,
=
¨¨- .
smooth
¨¨/ 5
?
¨¨6 7
$num
¨¨8 9
:
¨¨: ;
-
¨¨< =
$num
¨¨= >
;
¨¨> ?
faces
≠≠ 
[
≠≠ 
fc
≠≠ 
]
≠≠ 
.
≠≠ 
manualUV
≠≠ &
=
≠≠' (
	manualUvs
≠≠) 2
;
≠≠2 3
fc
ØØ 
++
ØØ 
;
ØØ 
}
∞∞ 
}
±± 
ProBuilderMesh
≥≥ 
pb
≥≥ 
=
≥≥ 
ProBuilderMesh
≥≥  .
.
≥≥. /
Create
≥≥/ 5
(
≥≥5 6
vertices
≥≥6 >
.
≥≥> ?
ToArray
≥≥? F
(
≥≥F G
)
≥≥G H
,
≥≥H I
faces
≥≥J O
.
≥≥O P
ToArray
≥≥P W
(
≥≥W X
)
≥≥X Y
)
≥≥Y Z
;
≥≥Z [
pb
¥¥ 
.
¥¥ 

gameObject
¥¥ 
.
¥¥ 
name
¥¥ 
=
¥¥  
$str
¥¥! (
;
¥¥( )
pb
µµ 
.
µµ 
SetPivot
µµ 
(
µµ 
	pivotType
µµ !
)
µµ! "
;
µµ" #
return
∑∑ 
pb
∑∑ 
;
∑∑ 
}
∏∏ 	
}
ππ 
}∫∫ úò
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ProBuilderMeshSelection.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

sealed 
partial 
class 
ProBuilderMesh  .
{		 
[

 	
SerializeField

	 
]

 
bool 
m_IsSelectable 
= 
true "
;" #
[ 	
SerializeField	 
] 
int 
[ 
] 
m_SelectedFaces 
= 
new  #
int$ '
[' (
]( )
{* +
}+ ,
;, -
[ 	
SerializeField	 
] 
Edge 
[ 
] 
m_SelectedEdges 
=  
new! $
Edge% )
[) *
]* +
{, -
}- .
;. /
[ 	
SerializeField	 
] 
int 
[ 
] 
m_SelectedVertices  
=! "
new# &
int' *
[* +
]+ ,
{- .
}. /
;/ 0
bool  
m_SelectedCacheDirty !
;! "
int )
m_SelectedSharedVerticesCount )
=* +
$num, -
;- .
int +
m_SelectedCoincidentVertexCount +
=, -
$num. /
;/ 0
HashSet 
< 
int 
> $
m_SelectedSharedVertices -
=. /
new0 3
HashSet4 ;
<; <
int< ?
>? @
(@ A
)A B
;B C
List 
< 
int 
> (
m_SelectedCoincidentVertices .
=/ 0
new1 4
List5 9
<9 :
int: =
>= >
(> ?
)? @
;@ A
public 
bool 

selectable 
{ 	
get   
{   
return   
m_IsSelectable   '
;  ' (
}  ) *
set!! 
{!! 
m_IsSelectable!!  
=!!! "
value!!# (
;!!( )
}!!* +
}"" 	
public'' 
int'' 
selectedFaceCount'' $
{(( 	
get)) 
{)) 
return)) 
m_SelectedFaces)) (
.))( )
Length))) /
;))/ 0
}))1 2
}** 	
public// 
int// 
selectedVertexCount// &
{00 	
get11 
{11 
return11 
m_SelectedVertices11 +
.11+ ,
Length11, 2
;112 3
}114 5
}22 	
public77 
int77 
selectedEdgeCount77 $
{88 	
get99 
{99 
return99 
m_SelectedEdges99 (
.99( )
Length99) /
;99/ 0
}991 2
}:: 	
internal<< 
int<< '
selectedSharedVerticesCount<< 0
{== 	
get>> 
{?? 
CacheSelection@@ 
(@@ 
)@@  
;@@  !
returnAA )
m_SelectedSharedVerticesCountAA 4
;AA4 5
}BB 
}CC 	
internalEE 
intEE )
selectedCoincidentVertexCountEE 2
{FF 	
getGG 
{HH 
CacheSelectionII 
(II 
)II  
;II  !
returnJJ +
m_SelectedCoincidentVertexCountJJ 6
;JJ6 7
}KK 
}LL 	
internalNN 
IEnumerableNN 
<NN 
intNN  
>NN  !"
selectedSharedVerticesNN" 8
{OO 	
getPP 
{QQ 
CacheSelectionRR 
(RR 
)RR  
;RR  !
returnSS $
m_SelectedSharedVerticesSS /
;SS/ 0
}TT 
}UU 	
internalZZ 
IEnumerableZZ 
<ZZ 
intZZ  
>ZZ  !&
selectedCoincidentVerticesZZ" <
{[[ 	
get\\ 
{]] 
CacheSelection^^ 
(^^ 
)^^  
;^^  !
return__ (
m_SelectedCoincidentVertices__ 3
;__3 4
}`` 
}aa 	
voidcc 
CacheSelectioncc 
(cc 
)cc 
{dd 	
ifee 
(ee  
m_SelectedCacheDirtyee $
)ee$ %
{ff  
m_SelectedCacheDirtygg $
=gg% &
falsegg' ,
;gg, -$
m_SelectedSharedVerticeshh (
.hh( )
Clearhh) .
(hh. /
)hh/ 0
;hh0 1(
m_SelectedCoincidentVerticesii ,
.ii, -
Clearii- 2
(ii2 3
)ii3 4
;ii4 5
varjj 
lookupjj 
=jj 
sharedVertexLookupjj /
;jj/ 0)
m_SelectedSharedVerticesCountkk -
=kk. /
$numkk0 1
;kk1 2+
m_SelectedCoincidentVertexCountll /
=ll0 1
$numll2 3
;ll3 4
trynn 
{oo 
foreachpp 
(pp 
varpp  
ipp! "
inpp# %
m_SelectedVerticespp& 8
)pp8 9
{qq 
ifrr 
(rr $
m_SelectedSharedVerticesrr 4
.rr4 5
Addrr5 8
(rr8 9
lookuprr9 ?
[rr? @
irr@ A
]rrA B
)rrB C
)rrC D
{ss 
vartt 

coincidenttt  *
=tt+ ,"
sharedVerticesInternaltt- C
[ttC D
lookupttD J
[ttJ K
ittK L
]ttL M
]ttM N
;ttN O)
m_SelectedSharedVerticesCountvv 9
++vv9 ;
;vv; <+
m_SelectedCoincidentVertexCountww ;
+=ww< >

coincidentww? I
.wwI J
CountwwJ O
;wwO P
foreachyy #
(yy$ %
varyy% (
nyy) *
inyy+ -

coincidentyy. 8
)yy8 9(
m_SelectedCoincidentVerticeszz  <
.zz< =
Addzz= @
(zz@ A
nzzA B
)zzB C
;zzC D
}{{ 
}|| 
}}} 
catch~~ 
{ 
ClearSelection
ÄÄ "
(
ÄÄ" #
)
ÄÄ# $
;
ÄÄ$ %
}
ÅÅ 
}
ÇÇ 
}
ÉÉ 	
public
àà 
Face
àà 
[
àà 
]
àà 
GetSelectedFaces
àà &
(
àà& '
)
àà' (
{
ââ 	
int
ää 
len
ää 
=
ää 
m_SelectedFaces
ää %
.
ää% &
Length
ää& ,
;
ää, -
var
ãã 
selected
ãã 
=
ãã 
new
ãã 
Face
ãã #
[
ãã# $
len
ãã$ '
]
ãã' (
;
ãã( )
for
åå 
(
åå 
var
åå 
i
åå 
=
åå 
$num
åå 
;
åå 
i
åå 
<
åå 
len
åå  #
;
åå# $
i
åå% &
++
åå& (
)
åå( )
selected
çç 
[
çç 
i
çç 
]
çç 
=
çç 
m_Faces
çç %
[
çç% &
m_SelectedFaces
çç& 5
[
çç5 6
i
çç6 7
]
çç7 8
]
çç8 9
;
çç9 :
return
éé 
selected
éé 
;
éé 
}
èè 	
public
îî  
ReadOnlyCollection
îî !
<
îî! "
int
îî" %
>
îî% &!
selectedFaceIndexes
îî' :
{
ïï 	
get
ññ 
{
ññ 
return
ññ 
new
ññ  
ReadOnlyCollection
ññ /
<
ññ/ 0
int
ññ0 3
>
ññ3 4
(
ññ4 5
m_SelectedFaces
ññ5 D
)
ññD E
;
ññE F
}
ññG H
}
óó 	
public
úú  
ReadOnlyCollection
úú !
<
úú! "
int
úú" %
>
úú% &
selectedVertices
úú' 7
{
ùù 	
get
ûû 
{
ûû 
return
ûû 
new
ûû  
ReadOnlyCollection
ûû /
<
ûû/ 0
int
ûû0 3
>
ûû3 4
(
ûû4 5 
m_SelectedVertices
ûû5 G
)
ûûG H
;
ûûH I
}
ûûJ K
}
üü 	
public
§§  
ReadOnlyCollection
§§ !
<
§§! "
Edge
§§" &
>
§§& '
selectedEdges
§§( 5
{
•• 	
get
¶¶ 
{
¶¶ 
return
¶¶ 
new
¶¶  
ReadOnlyCollection
¶¶ /
<
¶¶/ 0
Edge
¶¶0 4
>
¶¶4 5
(
¶¶5 6
m_SelectedEdges
¶¶6 E
)
¶¶E F
;
¶¶F G
}
¶¶H I
}
ßß 	
internal
©© 
Face
©© 
[
©© 
]
©© #
selectedFacesInternal
©© -
{
™™ 	
get
´´ 
{
´´ 
return
´´ 
GetSelectedFaces
´´ )
(
´´) *
)
´´* +
;
´´+ ,
}
´´- .
set
¨¨ 
{
¨¨ 
m_SelectedFaces
¨¨ !
=
¨¨" #
value
¨¨$ )
.
¨¨) *
Select
¨¨* 0
(
¨¨0 1
x
¨¨1 2
=>
¨¨3 5
Array
¨¨6 ;
.
¨¨; <
IndexOf
¨¨< C
(
¨¨C D
m_Faces
¨¨D K
,
¨¨K L
x
¨¨M N
)
¨¨N O
)
¨¨O P
.
¨¨P Q
ToArray
¨¨Q X
(
¨¨X Y
)
¨¨Y Z
;
¨¨Z [
}
¨¨\ ]
}
≠≠ 	
internal
ØØ 
int
ØØ 
[
ØØ 
]
ØØ )
selectedFaceIndicesInternal
ØØ 2
{
∞∞ 	
get
±± 
{
±± 
return
±± 
m_SelectedFaces
±± (
;
±±( )
}
±±* +
set
≤≤ 
{
≤≤ 
m_SelectedFaces
≤≤ !
=
≤≤" #
value
≤≤$ )
;
≤≤) *
}
≤≤+ ,
}
≥≥ 	
internal
µµ 
Edge
µµ 
[
µµ 
]
µµ #
selectedEdgesInternal
µµ -
{
∂∂ 	
get
∑∑ 
{
∑∑ 
return
∑∑ 
m_SelectedEdges
∑∑ (
;
∑∑( )
}
∑∑* +
set
∏∏ 
{
∏∏ 
m_SelectedEdges
∏∏ !
=
∏∏" #
value
∏∏$ )
;
∏∏) *
}
∏∏+ ,
}
ππ 	
internal
ªª 
int
ªª 
[
ªª 
]
ªª %
selectedIndexesInternal
ªª .
{
ºº 	
get
ΩΩ 
{
ΩΩ 
return
ΩΩ  
m_SelectedVertices
ΩΩ +
;
ΩΩ+ ,
}
ΩΩ- .
set
ææ 
{
ææ  
m_SelectedVertices
ææ $
=
ææ% &
value
ææ' ,
;
ææ, -
}
ææ. /
}
øø 	
internal
¡¡ 
Face
¡¡ 
GetActiveFace
¡¡ #
(
¡¡# $
)
¡¡$ %
{
¬¬ 	
if
√√ 
(
√√ 
selectedFaceCount
√√ !
<
√√" #
$num
√√$ %
)
√√% &
return
ƒƒ 
null
ƒƒ 
;
ƒƒ 
return
≈≈ 
m_Faces
≈≈ 
[
≈≈ )
selectedFaceIndicesInternal
≈≈ 6
[
≈≈6 7
selectedFaceCount
≈≈7 H
-
≈≈I J
$num
≈≈K L
]
≈≈L M
]
≈≈M N
;
≈≈N O
}
∆∆ 	
internal
»» 
Edge
»» 
GetActiveEdge
»» #
(
»»# $
)
»»$ %
{
…… 	
if
   
(
   
selectedEdgeCount
   !
<
  " #
$num
  $ %
)
  % &
return
ÀÀ 
Edge
ÀÀ 
.
ÀÀ 
Empty
ÀÀ !
;
ÀÀ! "
return
ÃÃ 
m_SelectedEdges
ÃÃ "
[
ÃÃ" #
selectedEdgeCount
ÃÃ# 4
-
ÃÃ5 6
$num
ÃÃ7 8
]
ÃÃ8 9
;
ÃÃ9 :
}
ÕÕ 	
internal
œœ 
int
œœ 
GetActiveVertex
œœ $
(
œœ$ %
)
œœ% &
{
–– 	
if
—— 
(
—— !
selectedVertexCount
—— #
<
——$ %
$num
——& '
)
——' (
return
““ 
-
““ 
$num
““ 
;
““ 
return
””  
m_SelectedVertices
”” %
[
””% &!
selectedVertexCount
””& 9
-
””: ;
$num
””< =
]
””= >
;
””> ?
}
‘‘ 	
internal
÷÷ 
void
÷÷  
AddToFaceSelection
÷÷ (
(
÷÷( )
int
÷÷) ,
index
÷÷- 2
)
÷÷2 3
{
◊◊ 	
if
ÿÿ 
(
ÿÿ 
index
ÿÿ 
>
ÿÿ 
-
ÿÿ 
$num
ÿÿ 
)
ÿÿ 
SetSelectedFaces
ŸŸ  
(
ŸŸ  !
m_SelectedFaces
ŸŸ! 0
.
ŸŸ0 1
Add
ŸŸ1 4
(
ŸŸ4 5
index
ŸŸ5 :
)
ŸŸ: ;
)
ŸŸ; <
;
ŸŸ< =
}
⁄⁄ 	
public
‡‡ 
void
‡‡ 
SetSelectedFaces
‡‡ $
(
‡‡$ %
IEnumerable
‡‡% 0
<
‡‡0 1
Face
‡‡1 5
>
‡‡5 6
selected
‡‡7 ?
)
‡‡? @
{
·· 	
SetSelectedFaces
‚‚ 
(
‚‚ 
selected
‚‚ %
!=
‚‚& (
null
‚‚) -
?
‚‚. /
selected
‚‚0 8
.
‚‚8 9
Select
‚‚9 ?
(
‚‚? @
x
‚‚@ A
=>
‚‚B D
Array
‚‚E J
.
‚‚J K
IndexOf
‚‚K R
(
‚‚R S
facesInternal
‚‚S `
,
‚‚` a
x
‚‚b c
)
‚‚c d
)
‚‚d e
:
‚‚f g
null
‚‚h l
)
‚‚l m
;
‚‚m n
}
„„ 	
internal
ÂÂ 
void
ÂÂ 
SetSelectedFaces
ÂÂ &
(
ÂÂ& '
IEnumerable
ÂÂ' 2
<
ÂÂ2 3
int
ÂÂ3 6
>
ÂÂ6 7
selected
ÂÂ8 @
)
ÂÂ@ A
{
ÊÊ 	
if
ÁÁ 
(
ÁÁ 
selected
ÁÁ 
==
ÁÁ 
null
ÁÁ  
)
ÁÁ  !
{
ËË 
ClearSelection
ÈÈ 
(
ÈÈ 
)
ÈÈ  
;
ÈÈ  !
}
ÍÍ 
else
ÎÎ 
{
ÏÏ 
m_SelectedFaces
ÌÌ 
=
ÌÌ  !
selected
ÌÌ" *
.
ÌÌ* +
ToArray
ÌÌ+ 2
(
ÌÌ2 3
)
ÌÌ3 4
;
ÌÌ4 5 
m_SelectedVertices
ÓÓ "
=
ÓÓ# $
m_SelectedFaces
ÓÓ% 4
.
ÓÓ4 5

SelectMany
ÓÓ5 ?
(
ÓÓ? @
x
ÓÓ@ A
=>
ÓÓB D
facesInternal
ÓÓE R
[
ÓÓR S
x
ÓÓS T
]
ÓÓT U
.
ÓÓU V%
distinctIndexesInternal
ÓÓV m
)
ÓÓm n
.
ÓÓn o
ToArray
ÓÓo v
(
ÓÓv w
)
ÓÓw x
;
ÓÓx y
m_SelectedEdges
ÔÔ 
=
ÔÔ  !
m_SelectedFaces
ÔÔ" 1
.
ÔÔ1 2

SelectMany
ÔÔ2 <
(
ÔÔ< =
x
ÔÔ= >
=>
ÔÔ? A
facesInternal
ÔÔB O
[
ÔÔO P
x
ÔÔP Q
]
ÔÔQ R
.
ÔÔR S
edges
ÔÔS X
)
ÔÔX Y
.
ÔÔY Z
ToArray
ÔÔZ a
(
ÔÔa b
)
ÔÔb c
;
ÔÔc d
}
 "
m_SelectedCacheDirty
ÚÚ  
=
ÚÚ! "
true
ÚÚ# '
;
ÚÚ' (
if
ÙÙ 
(
ÙÙ %
elementSelectionChanged
ÙÙ '
!=
ÙÙ( *
null
ÙÙ+ /
)
ÙÙ/ 0%
elementSelectionChanged
ıı '
(
ıı' (
this
ıı( ,
)
ıı, -
;
ıı- .
}
ˆˆ 	
public
¸¸ 
void
¸¸ 
SetSelectedEdges
¸¸ $
(
¸¸$ %
IEnumerable
¸¸% 0
<
¸¸0 1
Edge
¸¸1 5
>
¸¸5 6
edges
¸¸7 <
)
¸¸< =
{
˝˝ 	
if
˛˛ 
(
˛˛ 
edges
˛˛ 
==
˛˛ 
null
˛˛ 
)
˛˛ 
{
ˇˇ 
ClearSelection
ÄÄ 
(
ÄÄ 
)
ÄÄ  
;
ÄÄ  !
}
ÅÅ 
else
ÇÇ 
{
ÉÉ 
m_SelectedFaces
ÑÑ 
=
ÑÑ  !
new
ÑÑ" %
int
ÑÑ& )
[
ÑÑ) *
$num
ÑÑ* +
]
ÑÑ+ ,
;
ÑÑ, -
m_SelectedEdges
ÖÖ 
=
ÖÖ  !
edges
ÖÖ" '
.
ÖÖ' (
ToArray
ÖÖ( /
(
ÖÖ/ 0
)
ÖÖ0 1
;
ÖÖ1 2 
m_SelectedVertices
ÜÜ "
=
ÜÜ# $
m_SelectedEdges
ÜÜ% 4
.
ÜÜ4 5
AllTriangles
ÜÜ5 A
(
ÜÜA B
)
ÜÜB C
;
ÜÜC D
}
áá "
m_SelectedCacheDirty
ââ  
=
ââ! "
true
ââ# '
;
ââ' (
if
ãã 
(
ãã %
elementSelectionChanged
ãã '
!=
ãã( *
null
ãã+ /
)
ãã/ 0%
elementSelectionChanged
åå '
(
åå' (
this
åå( ,
)
åå, -
;
åå- .
}
çç 	
public
ìì 
void
ìì !
SetSelectedVertices
ìì '
(
ìì' (
IEnumerable
ìì( 3
<
ìì3 4
int
ìì4 7
>
ìì7 8
vertices
ìì9 A
)
ììA B
{
îî 	
m_SelectedFaces
ïï 
=
ïï 
new
ïï !
int
ïï" %
[
ïï% &
$num
ïï& '
]
ïï' (
;
ïï( )
m_SelectedEdges
ññ 
=
ññ 
new
ññ !
Edge
ññ" &
[
ññ& '
$num
ññ' (
]
ññ( )
;
ññ) * 
m_SelectedVertices
óó 
=
óó  
vertices
óó! )
!=
óó* ,
null
óó- 1
?
óó2 3
vertices
óó4 <
.
óó< =
Distinct
óó= E
(
óóE F
)
óóF G
.
óóG H
ToArray
óóH O
(
óóO P
)
óóP Q
:
óóR S
new
óóT W
int
óóX [
[
óó[ \
$num
óó\ ]
]
óó] ^
;
óó^ _"
m_SelectedCacheDirty
ôô  
=
ôô! "
true
ôô# '
;
ôô' (
if
õõ 
(
õõ %
elementSelectionChanged
õõ '
!=
õõ( *
null
õõ+ /
)
õõ/ 0%
elementSelectionChanged
úú '
(
úú' (
this
úú( ,
)
úú, -
;
úú- .
}
ùù 	
internal
££ 
void
££ ,
RemoveFromFaceSelectionAtIndex
££ 4
(
££4 5
int
££5 8
index
££9 >
)
££> ?
{
§§ 	
SetSelectedFaces
•• 
(
•• 
m_SelectedFaces
•• ,
.
••, -
RemoveAt
••- 5
(
••5 6
index
••6 ;
)
••; <
)
••< =
;
••= >
}
¶¶ 	
public
´´ 
void
´´ 
ClearSelection
´´ "
(
´´" #
)
´´# $
{
¨¨ 	
m_SelectedFaces
≠≠ 
=
≠≠ 
new
≠≠ !
int
≠≠" %
[
≠≠% &
$num
≠≠& '
]
≠≠' (
;
≠≠( )
m_SelectedEdges
ÆÆ 
=
ÆÆ 
new
ÆÆ !
Edge
ÆÆ" &
[
ÆÆ& '
$num
ÆÆ' (
]
ÆÆ( )
;
ÆÆ) * 
m_SelectedVertices
ØØ 
=
ØØ  
new
ØØ! $
int
ØØ% (
[
ØØ( )
$num
ØØ) *
]
ØØ* +
;
ØØ+ ,"
m_SelectedCacheDirty
∞∞  
=
∞∞! "
true
∞∞# '
;
∞∞' (
}
±± 	
}
≤≤ 
}≥≥ ºã
óD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\MeshImporter.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
[ 
Serializable 
] 
public 

sealed 
class 
MeshImportSettings *
{ 
[ 	
SerializeField	 
] 
bool 
m_Quads 
= 
true 
; 
[ 	
SerializeField	 
] 
bool 
m_Smoothing 
= 
true 
;  
[ 	
SerializeField	 
] 
float  
m_SmoothingThreshold "
=# $
$num% '
;' (
public 
bool 
quads 
{ 	
get 
{ 
return 
m_Quads  
;  !
}" #
set 
{ 
m_Quads 
= 
value !
;! "
}# $
} 	
public'' 
bool'' 
	smoothing'' 
{(( 	
get)) 
{)) 
return)) 
m_Smoothing)) $
;))$ %
}))& '
set** 
{** 
m_Smoothing** 
=** 
value**  %
;**% &
}**' (
}++ 	
public00 
float00 
smoothingAngle00 #
{11 	
get22 
{22 
return22  
m_SmoothingThreshold22 -
;22- .
}22/ 0
set33 
{33  
m_SmoothingThreshold33 &
=33' (
value33) .
;33. /
}330 1
}44 	
public66 
override66 
string66 
ToString66 '
(66' (
)66( )
{77 	
return88 
string88 
.88 
Format88  
(88  !
$str88! M
,88M N
quads99 
,99 
	smoothing:: 
,:: 
smoothingAngle;; 
);; 
;;;  
}<< 	
}== 
publicBB 

sealedBB 
classBB 
MeshImporterBB $
{CC 
staticDD 
readonlyDD 
MeshImportSettingsDD *#
k_DefaultImportSettingsDD+ B
=DDC D
newDDE H
MeshImportSettingsDDI [
(DD[ \
)DD\ ]
{EE 	
quadsFF 
=FF 
trueFF 
,FF 
	smoothingGG 
=GG 
trueGG 
,GG 
smoothingAngleHH 
=HH 
$numHH 
}II 	
;II	 

MeshKK 
m_SourceMeshKK 
;KK 
MaterialLL 
[LL 
]LL 
m_SourceMaterialsLL $
;LL$ %
ProBuilderMeshMM 
m_DestinationMM $
;MM$ %
VertexNN 
[NN 
]NN 

m_VerticesNN 
;NN 
publicPP 
MeshImporterPP 
(PP 

GameObjectPP &

gameObjectPP' 1
)PP1 2
{QQ 	

MeshFilterRR 

meshFilterRR !
=RR" #

gameObjectRR$ .
.RR. /
GetComponentRR/ ;
<RR; <

MeshFilterRR< F
>RRF G
(RRG H
)RRH I
;RRI J
m_SourceMeshSS 
=SS 

meshFilterSS %
.SS% &

sharedMeshSS& 0
;SS0 1
ifTT 
(TT 
m_SourceMeshTT 
==TT 
nullTT #
)TT# $
throwUU 
newUU !
ArgumentNullExceptionUU /
(UU/ 0
$strUU0 <
,UU< =
$strUU> z
)UUz {
;UU{ |
m_DestinationVV 
=VV 

gameObjectVV &
.VV& '
DemandComponentVV' 6
<VV6 7
ProBuilderMeshVV7 E
>VVE F
(VVF G
)VVG H
;VVH I
m_SourceMaterialsWW 
=WW 

gameObjectWW  *
.WW* +
GetComponentWW+ 7
<WW7 8
MeshRendererWW8 D
>WWD E
(WWE F
)WWF G
?WWG H
.WWH I
sharedMaterialsWWI X
;WWX Y
}XX 	
public`` 
MeshImporter`` 
(`` 
Mesh``  

sourceMesh``! +
,``+ ,
Material``- 5
[``5 6
]``6 7
sourceMaterials``8 G
,``G H
ProBuilderMesh``I W
destination``X c
)``c d
{aa 	
ifbb 
(bb 

sourceMeshbb 
==bb 
nullbb !
)bb! "
throwcc 
newcc !
ArgumentNullExceptioncc /
(cc/ 0
$strcc0 <
)cc< =
;cc= >
ifdd 
(dd 
destinationdd 
==dd 
nulldd "
)dd" #
throwee 
newee !
ArgumentNullExceptionee /
(ee/ 0
$stree0 =
)ee= >
;ee> ?
m_SourceMeshff 
=ff 

sourceMeshff %
;ff% &
m_SourceMaterialsgg 
=gg 
sourceMaterialsgg  /
;gg/ 0
m_Destinationhh 
=hh 
destinationhh '
;hh' (
}ii 	
[kk 	
Obsoletekk	 
,kk 
EditorBrowsablekk "
(kk" # 
EditorBrowsableStatekk# 7
.kk7 8
Neverkk8 =
)kk= >
]kk> ?
publicll 
MeshImporterll 
(ll 
ProBuilderMeshll *
destinationll+ 6
)ll6 7
{mm 	
m_Destinationnn 
=nn 
destinationnn '
;nn' (
}oo 	
[qq 	
Obsoleteqq	 
,qq 
EditorBrowsableqq "
(qq" # 
EditorBrowsableStateqq# 7
.qq7 8
Neverqq8 =
)qq= >
]qq> ?
publicrr 
boolrr 
Importrr 
(rr 

GameObjectrr %
gorr& (
,rr( )
MeshImportSettingsrr* <
importSettingsrr= K
=rrL M
nullrrN R
)rrR S
{ss 	
trytt 
{uu 
m_SourceMeshvv 
=vv 
govv !
.vv! "
GetComponentvv" .
<vv. /

MeshFiltervv/ 9
>vv9 :
(vv: ;
)vv; <
.vv< =

sharedMeshvv= G
;vvG H
m_SourceMaterialsww !
=ww" #
goww$ &
.ww& '
GetComponentww' 3
<ww3 4
MeshRendererww4 @
>ww@ A
(wwA B
)wwB C
?wwC D
.wwD E
sharedMaterialswwE T
;wwT U
Importxx 
(xx 
importSettingsxx %
)xx% &
;xx& '
}yy 
catchzz 
(zz 
	Exceptionzz 
ezz 
)zz 
{{{ 
Log|| 
.|| 
Error|| 
(|| 
e|| 
.|| 
ToString|| $
(||$ %
)||% &
)||& '
;||' (
return}} 
false}} 
;}} 
}~~ 
return
ÄÄ 
true
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
public
ää 
void
ää 
Import
ää 
(
ää  
MeshImportSettings
ää -
importSettings
ää. <
=
ää= >
null
ää? C
)
ääC D
{
ãã 	
if
åå 
(
åå 
importSettings
åå 
==
åå !
null
åå" &
)
åå& '
importSettings
çç 
=
çç  %
k_DefaultImportSettings
çç! 8
;
çç8 9
Vertex
íí 
[
íí 
]
íí 
sourceVertices
íí #
=
íí$ %
m_SourceMesh
íí& 2
.
íí2 3
GetVertices
íí3 >
(
íí> ?
)
íí? @
;
íí@ A
List
ìì 
<
ìì 
Vertex
ìì 
>
ìì 
splitVertices
ìì &
=
ìì' (
new
ìì) ,
List
ìì- 1
<
ìì1 2
Vertex
ìì2 8
>
ìì8 9
(
ìì9 :
)
ìì: ;
;
ìì; <
List
îî 
<
îî 
Face
îî 
>
îî 
faces
îî 
=
îî 
new
îî "
List
îî# '
<
îî' (
Face
îî( ,
>
îî, -
(
îî- .
)
îî. /
;
îî/ 0
int
òò 
vertexIndex
òò 
=
òò 
$num
òò 
;
òò  
int
ôô 
materialCount
ôô 
=
ôô 
m_SourceMaterials
ôô  1
!=
ôô2 4
null
ôô5 9
?
ôô: ;
m_SourceMaterials
ôô< M
.
ôôM N
Length
ôôN T
:
ôôU V
$num
ôôW X
;
ôôX Y
for
õõ 
(
õõ 
int
õõ 
submeshIndex
õõ !
=
õõ" #
$num
õõ$ %
;
õõ% &
submeshIndex
õõ' 3
<
õõ4 5
m_SourceMesh
õõ6 B
.
õõB C
subMeshCount
õõC O
;
õõO P
submeshIndex
õõQ ]
++
õõ] _
)
õõ_ `
{
úú 
switch
ùù 
(
ùù 
m_SourceMesh
ùù $
.
ùù$ %
GetTopology
ùù% 0
(
ùù0 1
submeshIndex
ùù1 =
)
ùù= >
)
ùù> ?
{
ûû 
case
üü 
MeshTopology
üü %
.
üü% &
	Triangles
üü& /
:
üü/ 0
{
†† 
int
°° 
[
°° 
]
°° 
indexes
°° %
=
°°& '
m_SourceMesh
°°( 4
.
°°4 5

GetIndices
°°5 ?
(
°°? @
submeshIndex
°°@ L
)
°°L M
;
°°M N
for
££ 
(
££ 
int
££  
tri
££! $
=
££% &
$num
££' (
;
££( )
tri
££* -
<
££. /
indexes
££0 7
.
££7 8
Length
££8 >
;
££> ?
tri
££@ C
+=
££D F
$num
££G H
)
££H I
{
§§ 
faces
•• !
.
••! "
Add
••" %
(
••% &
new
••& )
Face
••* .
(
••. /
new
¶¶$ '
int
¶¶( +
[
¶¶+ ,
]
¶¶, -
{
¶¶. /
vertexIndex
¶¶0 ;
,
¶¶; <
vertexIndex
¶¶= H
+
¶¶I J
$num
¶¶K L
,
¶¶L M
vertexIndex
¶¶N Y
+
¶¶Z [
$num
¶¶\ ]
}
¶¶^ _
,
¶¶_ `
Math
ßß$ (
.
ßß( )
Clamp
ßß) .
(
ßß. /
submeshIndex
ßß/ ;
,
ßß; <
$num
ßß= >
,
ßß> ?
materialCount
ßß@ M
-
ßßN O
$num
ßßP Q
)
ßßQ R
,
ßßR S 
AutoUnwrapSettings
®®$ 6
.
®®6 7
tile
®®7 ;
,
®®; <
	Smoothing
©©$ -
.
©©- . 
smoothingGroupNone
©©. @
,
©©@ A
-
™™$ %
$num
™™% &
,
™™& '
-
´´$ %
$num
´´% &
,
´´& '
true
¨¨$ (
)
¨¨( )
)
¨¨) *
;
¨¨* +
splitVertices
ÆÆ )
.
ÆÆ) *
Add
ÆÆ* -
(
ÆÆ- .
sourceVertices
ÆÆ. <
[
ÆÆ< =
indexes
ÆÆ= D
[
ÆÆD E
tri
ÆÆE H
]
ÆÆH I
]
ÆÆI J
)
ÆÆJ K
;
ÆÆK L
splitVertices
ØØ )
.
ØØ) *
Add
ØØ* -
(
ØØ- .
sourceVertices
ØØ. <
[
ØØ< =
indexes
ØØ= D
[
ØØD E
tri
ØØE H
+
ØØI J
$num
ØØK L
]
ØØL M
]
ØØM N
)
ØØN O
;
ØØO P
splitVertices
∞∞ )
.
∞∞) *
Add
∞∞* -
(
∞∞- .
sourceVertices
∞∞. <
[
∞∞< =
indexes
∞∞= D
[
∞∞D E
tri
∞∞E H
+
∞∞I J
$num
∞∞K L
]
∞∞L M
]
∞∞M N
)
∞∞N O
;
∞∞O P
vertexIndex
≤≤ '
+=
≤≤( *
$num
≤≤+ ,
;
≤≤, -
}
≥≥ 
}
¥¥ 
break
µµ 
;
µµ 
case
∑∑ 
MeshTopology
∑∑ %
.
∑∑% &
Quads
∑∑& +
:
∑∑+ ,
{
∏∏ 
int
ππ 
[
ππ 
]
ππ 
indexes
ππ %
=
ππ& '
m_SourceMesh
ππ( 4
.
ππ4 5

GetIndices
ππ5 ?
(
ππ? @
submeshIndex
ππ@ L
)
ππL M
;
ππM N
for
ªª 
(
ªª 
int
ªª  
quad
ªª! %
=
ªª& '
$num
ªª( )
;
ªª) *
quad
ªª+ /
<
ªª0 1
indexes
ªª2 9
.
ªª9 :
Length
ªª: @
;
ªª@ A
quad
ªªB F
+=
ªªG I
$num
ªªJ K
)
ªªK L
{
ºº 
faces
ΩΩ !
.
ΩΩ! "
Add
ΩΩ" %
(
ΩΩ% &
new
ΩΩ& )
Face
ΩΩ* .
(
ΩΩ. /
new
ΩΩ/ 2
int
ΩΩ3 6
[
ΩΩ6 7
]
ΩΩ7 8
{
ææ  !
vertexIndex
øø$ /
,
øø/ 0
vertexIndex
øø1 <
+
øø= >
$num
øø? @
,
øø@ A
vertexIndex
øøB M
+
øøN O
$num
øøP Q
,
øøQ R
vertexIndex
¿¿$ /
+
¿¿0 1
$num
¿¿2 3
,
¿¿3 4
vertexIndex
¿¿5 @
+
¿¿A B
$num
¿¿C D
,
¿¿D E
vertexIndex
¿¿F Q
+
¿¿R S
$num
¿¿T U
}
¡¡  !
,
¡¡! "
Math
¬¬  $
.
¬¬$ %
Clamp
¬¬% *
(
¬¬* +
submeshIndex
¬¬+ 7
,
¬¬7 8
$num
¬¬9 :
,
¬¬: ;
materialCount
¬¬< I
-
¬¬J K
$num
¬¬L M
)
¬¬M N
,
¬¬N O 
AutoUnwrapSettings
√√  2
.
√√2 3
tile
√√3 7
,
√√7 8
	Smoothing
ƒƒ  )
.
ƒƒ) * 
smoothingGroupNone
ƒƒ* <
,
ƒƒ< =
-
≈≈  !
$num
≈≈! "
,
≈≈" #
-
∆∆  !
$num
∆∆! "
,
∆∆" #
true
««  $
)
««$ %
)
««% &
;
««& '
splitVertices
…… )
.
……) *
Add
……* -
(
……- .
sourceVertices
……. <
[
……< =
indexes
……= D
[
……D E
quad
……E I
]
……I J
]
……J K
)
……K L
;
……L M
splitVertices
   )
.
  ) *
Add
  * -
(
  - .
sourceVertices
  . <
[
  < =
indexes
  = D
[
  D E
quad
  E I
+
  J K
$num
  L M
]
  M N
]
  N O
)
  O P
;
  P Q
splitVertices
ÀÀ )
.
ÀÀ) *
Add
ÀÀ* -
(
ÀÀ- .
sourceVertices
ÀÀ. <
[
ÀÀ< =
indexes
ÀÀ= D
[
ÀÀD E
quad
ÀÀE I
+
ÀÀJ K
$num
ÀÀL M
]
ÀÀM N
]
ÀÀN O
)
ÀÀO P
;
ÀÀP Q
splitVertices
ÃÃ )
.
ÃÃ) *
Add
ÃÃ* -
(
ÃÃ- .
sourceVertices
ÃÃ. <
[
ÃÃ< =
indexes
ÃÃ= D
[
ÃÃD E
quad
ÃÃE I
+
ÃÃJ K
$num
ÃÃL M
]
ÃÃM N
]
ÃÃN O
)
ÃÃO P
;
ÃÃP Q
vertexIndex
ŒŒ '
+=
ŒŒ( *
$num
ŒŒ+ ,
;
ŒŒ, -
}
œœ 
}
–– 
break
—— 
;
—— 
default
”” 
:
”” 
throw
‘‘ 
new
‘‘ !#
NotSupportedException
‘‘" 7
(
‘‘7 8
$str
‘‘8 v
)
‘‘v w
;
‘‘w x
}
’’ 
}
÷÷ 

m_Vertices
ÿÿ 
=
ÿÿ 
splitVertices
ÿÿ &
.
ÿÿ& '
ToArray
ÿÿ' .
(
ÿÿ. /
)
ÿÿ/ 0
;
ÿÿ0 1
m_Destination
⁄⁄ 
.
⁄⁄ 
Clear
⁄⁄ 
(
⁄⁄  
)
⁄⁄  !
;
⁄⁄! "
m_Destination
€€ 
.
€€ 
SetVertices
€€ %
(
€€% &

m_Vertices
€€& 0
)
€€0 1
;
€€1 2
m_Destination
‹‹ 
.
‹‹ 
faces
‹‹ 
=
‹‹  !
faces
‹‹" '
;
‹‹' (
m_Destination
›› 
.
›› 
sharedVertices
›› (
=
››) *
SharedVertex
››+ 7
.
››7 8,
GetSharedVerticesWithPositions
››8 V
(
››V W
m_Destination
››W d
.
››d e
positionsInternal
››e v
)
››v w
;
››w x
m_Destination
ﬁﬁ 
.
ﬁﬁ 
sharedTextures
ﬁﬁ (
=
ﬁﬁ) *
new
ﬁﬁ+ .
SharedVertex
ﬁﬁ/ ;
[
ﬁﬁ; <
$num
ﬁﬁ< =
]
ﬁﬁ= >
;
ﬁﬁ> ?
HashSet
‡‡ 
<
‡‡ 
Face
‡‡ 
>
‡‡ 
	processed
‡‡ #
=
‡‡$ %
new
‡‡& )
HashSet
‡‡* 1
<
‡‡1 2
Face
‡‡2 6
>
‡‡6 7
(
‡‡7 8
)
‡‡8 9
;
‡‡9 :
if
‚‚ 
(
‚‚ 
importSettings
‚‚ 
.
‚‚ 
quads
‚‚ $
)
‚‚$ %
{
„„ 
List
‰‰ 
<
‰‰ 

WingedEdge
‰‰ 
>
‰‰  
wings
‰‰! &
=
‰‰' (

WingedEdge
‰‰) 3
.
‰‰3 4
GetWingedEdges
‰‰4 B
(
‰‰B C
m_Destination
‰‰C P
,
‰‰P Q
m_Destination
‰‰R _
.
‰‰_ `
facesInternal
‰‰` m
,
‰‰m n
true
‰‰o s
)
‰‰s t
;
‰‰t u

Dictionary
ÁÁ 
<
ÁÁ 

EdgeLookup
ÁÁ %
,
ÁÁ% &
float
ÁÁ' ,
>
ÁÁ, -
connections
ÁÁ. 9
=
ÁÁ: ;
new
ÁÁ< ?

Dictionary
ÁÁ@ J
<
ÁÁJ K

EdgeLookup
ÁÁK U
,
ÁÁU V
float
ÁÁW \
>
ÁÁ\ ]
(
ÁÁ] ^
)
ÁÁ^ _
;
ÁÁ_ `
for
ÈÈ 
(
ÈÈ 
int
ÈÈ 
i
ÈÈ 
=
ÈÈ 
$num
ÈÈ 
;
ÈÈ 
i
ÈÈ  !
<
ÈÈ" #
wings
ÈÈ$ )
.
ÈÈ) *
Count
ÈÈ* /
;
ÈÈ/ 0
i
ÈÈ1 2
++
ÈÈ2 4
)
ÈÈ4 5
{
ÍÍ 
using
ÎÎ 
(
ÎÎ 
var
ÎÎ 
it
ÎÎ !
=
ÎÎ" #
new
ÎÎ$ '"
WingedEdgeEnumerator
ÎÎ( <
(
ÎÎ< =
wings
ÎÎ= B
[
ÎÎB C
i
ÎÎC D
]
ÎÎD E
)
ÎÎE F
)
ÎÎF G
{
ÏÏ 
while
ÌÌ 
(
ÌÌ 
it
ÌÌ !
.
ÌÌ! "
MoveNext
ÌÌ" *
(
ÌÌ* +
)
ÌÌ+ ,
)
ÌÌ, -
{
ÓÓ 
var
ÔÔ 
border
ÔÔ  &
=
ÔÔ' (
it
ÔÔ) +
.
ÔÔ+ ,
Current
ÔÔ, 3
;
ÔÔ3 4
if
ÒÒ 
(
ÒÒ  
border
ÒÒ  &
.
ÒÒ& '
opposite
ÒÒ' /
!=
ÒÒ0 2
null
ÒÒ3 7
&&
ÒÒ8 :
!
ÒÒ; <
connections
ÒÒ< G
.
ÒÒG H
ContainsKey
ÒÒH S
(
ÒÒS T
border
ÒÒT Z
.
ÒÒZ [
edge
ÒÒ[ _
)
ÒÒ_ `
)
ÒÒ` a
{
ÚÚ 
float
ÛÛ  %
score
ÛÛ& +
=
ÛÛ, -
GetQuadScore
ÛÛ. :
(
ÛÛ: ;
border
ÛÛ; A
,
ÛÛA B
border
ÛÛC I
.
ÛÛI J
opposite
ÛÛJ R
)
ÛÛR S
;
ÛÛS T
connections
ÙÙ  +
.
ÙÙ+ ,
Add
ÙÙ, /
(
ÙÙ/ 0
border
ÙÙ0 6
.
ÙÙ6 7
edge
ÙÙ7 ;
,
ÙÙ; <
score
ÙÙ= B
)
ÙÙB C
;
ÙÙC D
}
ıı 
}
ˆˆ 
}
˜˜ 
}
¯¯ 
List
˙˙ 
<
˙˙ 
SimpleTuple
˙˙  
<
˙˙  !
Face
˙˙! %
,
˙˙% &
Face
˙˙' +
>
˙˙+ ,
>
˙˙, -
quads
˙˙. 3
=
˙˙4 5
new
˙˙6 9
List
˙˙: >
<
˙˙> ?
SimpleTuple
˙˙? J
<
˙˙J K
Face
˙˙K O
,
˙˙O P
Face
˙˙Q U
>
˙˙U V
>
˙˙V W
(
˙˙W X
)
˙˙X Y
;
˙˙Y Z
foreach
˝˝ 
(
˝˝ 

WingedEdge
˝˝ #
face
˝˝$ (
in
˝˝) +
wings
˝˝, 1
)
˝˝1 2
{
˛˛ 
if
ˇˇ 
(
ˇˇ 
!
ˇˇ 
	processed
ˇˇ "
.
ˇˇ" #
Add
ˇˇ# &
(
ˇˇ& '
face
ˇˇ' +
.
ˇˇ+ ,
face
ˇˇ, 0
)
ˇˇ0 1
)
ˇˇ1 2
continue
ÄÄ  
;
ÄÄ  !
float
ÇÇ 
	bestScore
ÇÇ #
=
ÇÇ$ %
$num
ÇÇ& (
;
ÇÇ( )
Face
ÉÉ 
buddy
ÉÉ 
=
ÉÉ  
null
ÉÉ! %
;
ÉÉ% &
using
ÖÖ 
(
ÖÖ 
var
ÖÖ 
it
ÖÖ !
=
ÖÖ" #
new
ÖÖ$ '"
WingedEdgeEnumerator
ÖÖ( <
(
ÖÖ< =
face
ÖÖ= A
)
ÖÖA B
)
ÖÖB C
{
ÜÜ 
while
áá 
(
áá 
it
áá !
.
áá! "
MoveNext
áá" *
(
áá* +
)
áá+ ,
)
áá, -
{
àà 
var
ââ 
border
ââ  &
=
ââ' (
it
ââ) +
.
ââ+ ,
Current
ââ, 3
;
ââ3 4
if
ãã 
(
ãã  
border
ãã  &
.
ãã& '
opposite
ãã' /
!=
ãã0 2
null
ãã3 7
&&
ãã8 :
	processed
ãã; D
.
ããD E
Contains
ããE M
(
ããM N
border
ããN T
.
ããT U
opposite
ããU ]
.
ãã] ^
face
ãã^ b
)
ããb c
)
ããc d
continue
åå  (
;
åå( )
float
éé !
borderScore
éé" -
;
éé- .
if
ëë 
(
ëë  
connections
ëë  +
.
ëë+ ,
TryGetValue
ëë, 7
(
ëë7 8
border
ëë8 >
.
ëë> ?
edge
ëë? C
,
ëëC D
out
ëëE H
borderScore
ëëI T
)
ëëT U
&&
ëëV X
borderScore
íí  +
>
íí, -
	bestScore
íí. 7
&&
íí8 :
face
ìì  $
.
ìì$ %
face
ìì% )
==
ìì* ,#
GetBestQuadConnection
ìì- B
(
ììB C
border
ììC I
.
ììI J
opposite
ììJ R
,
ììR S
connections
ììT _
)
ìì_ `
)
ìì` a
{
îî 
	bestScore
ïï  )
=
ïï* +
borderScore
ïï, 7
;
ïï7 8
buddy
ññ  %
=
ññ& '
border
ññ( .
.
ññ. /
opposite
ññ/ 7
.
ññ7 8
face
ññ8 <
;
ññ< =
}
óó 
}
òò 
}
ôô 
if
õõ 
(
õõ 
buddy
õõ 
!=
õõ  
null
õõ! %
)
õõ% &
{
úú 
	processed
ùù !
.
ùù! "
Add
ùù" %
(
ùù% &
buddy
ùù& +
)
ùù+ ,
;
ùù, -
quads
ûû 
.
ûû 
Add
ûû !
(
ûû! "
new
ûû" %
SimpleTuple
ûû& 1
<
ûû1 2
Face
ûû2 6
,
ûû6 7
Face
ûû8 <
>
ûû< =
(
ûû= >
face
ûû> B
.
ûûB C
face
ûûC G
,
ûûG H
buddy
ûûI N
)
ûûN O
)
ûûO P
;
ûûP Q
}
üü 
}
†† 
MergeElements
££ 
.
££ 

MergePairs
££ (
(
££( )
m_Destination
££) 6
,
££6 7
quads
££8 =
,
££= >
!
££? @
importSettings
££@ N
.
££N O
	smoothing
££O X
)
££X Y
;
££Y Z
}
§§ 
if
¶¶ 
(
¶¶ 
importSettings
¶¶ 
.
¶¶ 
	smoothing
¶¶ (
)
¶¶( )
{
ßß 
	Smoothing
®® 
.
®® "
ApplySmoothingGroups
®® .
(
®®. /
m_Destination
®®/ <
,
®®< =
m_Destination
®®> K
.
®®K L
facesInternal
®®L Y
,
®®Y Z
importSettings
®®[ i
.
®®i j
smoothingAngle
®®j x
,
®®x y

m_Vertices®®z Ñ
.®®Ñ Ö
Select®®Ö ã
(®®ã å
x®®å ç
=>®®é ê
x®®ë í
.®®í ì
normal®®ì ô
)®®ô ö
.®®ö õ
ToArray®®õ ¢
(®®¢ £
)®®£ §
)®®§ •
;®®• ¶
MergeElements
™™ 
.
™™ (
CollapseCoincidentVertices
™™ 8
(
™™8 9
m_Destination
™™9 F
,
™™F G
m_Destination
™™H U
.
™™U V
facesInternal
™™V c
)
™™c d
;
™™d e
}
´´ 
}
¨¨ 	
static
ÆÆ 
Face
ÆÆ #
GetBestQuadConnection
ÆÆ )
(
ÆÆ) *

WingedEdge
ÆÆ* 4
wing
ÆÆ5 9
,
ÆÆ9 :

Dictionary
ÆÆ; E
<
ÆÆE F

EdgeLookup
ÆÆF P
,
ÆÆP Q
float
ÆÆR W
>
ÆÆW X
connections
ÆÆY d
)
ÆÆd e
{
ØØ 	
float
∞∞ 
score
∞∞ 
=
∞∞ 
$num
∞∞ 
;
∞∞ 
Face
±± 
face
±± 
=
±± 
null
±± 
;
±± 
using
≥≥ 
(
≥≥ 
var
≥≥ 
it
≥≥ 
=
≥≥ 
new
≥≥ "
WingedEdgeEnumerator
≥≥  4
(
≥≥4 5
wing
≥≥5 9
)
≥≥9 :
)
≥≥: ;
{
¥¥ 
while
µµ 
(
µµ 
it
µµ 
.
µµ 
MoveNext
µµ "
(
µµ" #
)
µµ# $
)
µµ$ %
{
∂∂ 
var
∑∑ 
border
∑∑ 
=
∑∑  
it
∑∑! #
.
∑∑# $
Current
∑∑$ +
;
∑∑+ ,
float
ππ 
s
ππ 
=
ππ 
$num
ππ  
;
ππ  !
if
ªª 
(
ªª 
connections
ªª #
.
ªª# $
TryGetValue
ªª$ /
(
ªª/ 0
border
ªª0 6
.
ªª6 7
edge
ªª7 ;
,
ªª; <
out
ªª= @
s
ªªA B
)
ªªB C
&&
ªªD F
s
ªªG H
>
ªªI J
score
ªªK P
)
ªªP Q
{
ºº 
score
ΩΩ 
=
ΩΩ 
connections
ΩΩ  +
[
ΩΩ+ ,
border
ΩΩ, 2
.
ΩΩ2 3
edge
ΩΩ3 7
]
ΩΩ7 8
;
ΩΩ8 9
face
ææ 
=
ææ 
border
ææ %
.
ææ% &
opposite
ææ& .
.
ææ. /
face
ææ/ 3
;
ææ3 4
}
øø 
}
¿¿ 
}
¡¡ 
return
√√ 
face
√√ 
;
√√ 
}
ƒƒ 	
float
ÀÀ 
GetQuadScore
ÀÀ 
(
ÀÀ 

WingedEdge
ÀÀ %
left
ÀÀ& *
,
ÀÀ* +

WingedEdge
ÀÀ, 6
right
ÀÀ7 <
,
ÀÀ< =
float
ÀÀ> C
normalThreshold
ÀÀD S
=
ÀÀT U
$num
ÀÀV Y
)
ÀÀY Z
{
ÃÃ 	
int
ÕÕ 
[
ÕÕ 
]
ÕÕ 
quad
ÕÕ 
=
ÕÕ 

WingedEdge
ÕÕ #
.
ÕÕ# $
MakeQuad
ÕÕ$ ,
(
ÕÕ, -
left
ÕÕ- 1
,
ÕÕ1 2
right
ÕÕ3 8
)
ÕÕ8 9
;
ÕÕ9 :
if
œœ 
(
œœ 
quad
œœ 
==
œœ 
null
œœ 
)
œœ 
return
–– 
$num
–– 
;
–– 
Vector3
”” 

leftNormal
”” 
=
””  
Math
””! %
.
””% &
Normal
””& ,
(
””, -

m_Vertices
””- 7
[
””7 8
quad
””8 <
[
””< =
$num
””= >
]
””> ?
]
””? @
.
””@ A
position
””A I
,
””I J

m_Vertices
””K U
[
””U V
quad
””V Z
[
””Z [
$num
””[ \
]
””\ ]
]
””] ^
.
””^ _
position
””_ g
,
””g h

m_Vertices
””i s
[
””s t
quad
””t x
[
””x y
$num
””y z
]
””z {
]
””{ |
.
””| }
position””} Ö
)””Ö Ü
;””Ü á
Vector3
‘‘ 
rightNormal
‘‘ 
=
‘‘  !
Math
‘‘" &
.
‘‘& '
Normal
‘‘' -
(
‘‘- .

m_Vertices
‘‘. 8
[
‘‘8 9
quad
‘‘9 =
[
‘‘= >
$num
‘‘> ?
]
‘‘? @
]
‘‘@ A
.
‘‘A B
position
‘‘B J
,
‘‘J K

m_Vertices
‘‘L V
[
‘‘V W
quad
‘‘W [
[
‘‘[ \
$num
‘‘\ ]
]
‘‘] ^
]
‘‘^ _
.
‘‘_ `
position
‘‘` h
,
‘‘h i

m_Vertices
‘‘j t
[
‘‘t u
quad
‘‘u y
[
‘‘y z
$num
‘‘z {
]
‘‘{ |
]
‘‘| }
.
‘‘} ~
position‘‘~ Ü
)‘‘Ü á
;‘‘á à
float
÷÷ 
score
÷÷ 
=
÷÷ 
Vector3
÷÷ !
.
÷÷! "
Dot
÷÷" %
(
÷÷% &

leftNormal
÷÷& 0
,
÷÷0 1
rightNormal
÷÷2 =
)
÷÷= >
;
÷÷> ?
if
ÿÿ 
(
ÿÿ 
score
ÿÿ 
<
ÿÿ 
normalThreshold
ÿÿ '
)
ÿÿ' (
return
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
Vector3
‹‹ 
a
‹‹ 
=
‹‹ 
(
‹‹ 

m_Vertices
‹‹ #
[
‹‹# $
quad
‹‹$ (
[
‹‹( )
$num
‹‹) *
]
‹‹* +
]
‹‹+ ,
.
‹‹, -
position
‹‹- 5
-
‹‹6 7

m_Vertices
‹‹8 B
[
‹‹B C
quad
‹‹C G
[
‹‹G H
$num
‹‹H I
]
‹‹I J
]
‹‹J K
.
‹‹K L
position
‹‹L T
)
‹‹T U
;
‹‹U V
Vector3
›› 
b
›› 
=
›› 
(
›› 

m_Vertices
›› #
[
››# $
quad
››$ (
[
››( )
$num
››) *
]
››* +
]
››+ ,
.
››, -
position
››- 5
-
››6 7

m_Vertices
››8 B
[
››B C
quad
››C G
[
››G H
$num
››H I
]
››I J
]
››J K
.
››K L
position
››L T
)
››T U
;
››U V
Vector3
ﬁﬁ 
c
ﬁﬁ 
=
ﬁﬁ 
(
ﬁﬁ 

m_Vertices
ﬁﬁ #
[
ﬁﬁ# $
quad
ﬁﬁ$ (
[
ﬁﬁ( )
$num
ﬁﬁ) *
]
ﬁﬁ* +
]
ﬁﬁ+ ,
.
ﬁﬁ, -
position
ﬁﬁ- 5
-
ﬁﬁ6 7

m_Vertices
ﬁﬁ8 B
[
ﬁﬁB C
quad
ﬁﬁC G
[
ﬁﬁG H
$num
ﬁﬁH I
]
ﬁﬁI J
]
ﬁﬁJ K
.
ﬁﬁK L
position
ﬁﬁL T
)
ﬁﬁT U
;
ﬁﬁU V
Vector3
ﬂﬂ 
d
ﬂﬂ 
=
ﬂﬂ 
(
ﬂﬂ 

m_Vertices
ﬂﬂ #
[
ﬂﬂ# $
quad
ﬂﬂ$ (
[
ﬂﬂ( )
$num
ﬂﬂ) *
]
ﬂﬂ* +
]
ﬂﬂ+ ,
.
ﬂﬂ, -
position
ﬂﬂ- 5
-
ﬂﬂ6 7

m_Vertices
ﬂﬂ8 B
[
ﬂﬂB C
quad
ﬂﬂC G
[
ﬂﬂG H
$num
ﬂﬂH I
]
ﬂﬂI J
]
ﬂﬂJ K
.
ﬂﬂK L
position
ﬂﬂL T
)
ﬂﬂT U
;
ﬂﬂU V
a
·· 
.
·· 
	Normalize
·· 
(
·· 
)
·· 
;
·· 
b
‚‚ 
.
‚‚ 
	Normalize
‚‚ 
(
‚‚ 
)
‚‚ 
;
‚‚ 
c
„„ 
.
„„ 
	Normalize
„„ 
(
„„ 
)
„„ 
;
„„ 
d
‰‰ 
.
‰‰ 
	Normalize
‰‰ 
(
‰‰ 
)
‰‰ 
;
‰‰ 
float
ÊÊ 
da
ÊÊ 
=
ÊÊ 
Mathf
ÊÊ 
.
ÊÊ 
Abs
ÊÊ  
(
ÊÊ  !
Vector3
ÊÊ! (
.
ÊÊ( )
Dot
ÊÊ) ,
(
ÊÊ, -
a
ÊÊ- .
,
ÊÊ. /
b
ÊÊ0 1
)
ÊÊ1 2
)
ÊÊ2 3
;
ÊÊ3 4
float
ÁÁ 
db
ÁÁ 
=
ÁÁ 
Mathf
ÁÁ 
.
ÁÁ 
Abs
ÁÁ  
(
ÁÁ  !
Vector3
ÁÁ! (
.
ÁÁ( )
Dot
ÁÁ) ,
(
ÁÁ, -
b
ÁÁ- .
,
ÁÁ. /
c
ÁÁ0 1
)
ÁÁ1 2
)
ÁÁ2 3
;
ÁÁ3 4
float
ËË 
dc
ËË 
=
ËË 
Mathf
ËË 
.
ËË 
Abs
ËË  
(
ËË  !
Vector3
ËË! (
.
ËË( )
Dot
ËË) ,
(
ËË, -
c
ËË- .
,
ËË. /
d
ËË0 1
)
ËË1 2
)
ËË2 3
;
ËË3 4
float
ÈÈ 
dd
ÈÈ 
=
ÈÈ 
Mathf
ÈÈ 
.
ÈÈ 
Abs
ÈÈ  
(
ÈÈ  !
Vector3
ÈÈ! (
.
ÈÈ( )
Dot
ÈÈ) ,
(
ÈÈ, -
d
ÈÈ- .
,
ÈÈ. /
a
ÈÈ0 1
)
ÈÈ1 2
)
ÈÈ2 3
;
ÈÈ3 4
score
ÎÎ 
+=
ÎÎ 
$num
ÎÎ 
-
ÎÎ 
(
ÎÎ 
(
ÎÎ 
da
ÎÎ 
+
ÎÎ  
db
ÎÎ! #
+
ÎÎ$ %
dc
ÎÎ& (
+
ÎÎ) *
dd
ÎÎ+ -
)
ÎÎ- .
*
ÎÎ/ 0
$num
ÎÎ1 5
)
ÎÎ5 6
;
ÎÎ6 7
score
ÓÓ 
+=
ÓÓ 
Mathf
ÓÓ 
.
ÓÓ 
Abs
ÓÓ 
(
ÓÓ 
Vector3
ÓÓ &
.
ÓÓ& '
Dot
ÓÓ' *
(
ÓÓ* +
a
ÓÓ+ ,
,
ÓÓ, -
c
ÓÓ. /
)
ÓÓ/ 0
)
ÓÓ0 1
*
ÓÓ2 3
$num
ÓÓ4 7
;
ÓÓ7 8
score
ÔÔ 
+=
ÔÔ 
Mathf
ÔÔ 
.
ÔÔ 
Abs
ÔÔ 
(
ÔÔ 
Vector3
ÔÔ &
.
ÔÔ& '
Dot
ÔÔ' *
(
ÔÔ* +
b
ÔÔ+ ,
,
ÔÔ, -
d
ÔÔ. /
)
ÔÔ/ 0
)
ÔÔ0 1
*
ÔÔ2 3
$num
ÔÔ4 7
;
ÔÔ7 8
return
ÚÚ 
score
ÚÚ 
*
ÚÚ 
$num
ÚÚ 
;
ÚÚ  
}
ÛÛ 	
}
ÙÙ 
}ıı ÿ%
äD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\PolyShape.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ 
AddComponentMenu 
( 
$str 
) 
] 
[ %
DisallowMultipleComponent 
] 
[ 
ExcludeFromPreset 
, $
ExcludeFromObjectFactory 0
]0 1
[ #
ProGridsConditionalSnap 
] 
public 

sealed 
class 
	PolyShape !
:" #
MonoBehaviour$ 1
{ 
internal 
enum 
PolyEditMode "
{ 	
None 
, 
Path 
, 
Height 
, 
Edit 
} 	
ProBuilderMesh 
m_Mesh 
; 
[ 	 
FormerlySerializedAs	 
( 
$str &
)& '
]' (
[   	
SerializeField  	 
]   
internal!! 
List!! 
<!! 
Vector3!! 
>!! 
m_Points!! '
=!!( )
new!!* -
List!!. 2
<!!2 3
Vector3!!3 :
>!!: ;
(!!; <
)!!< =
;!!= >
[## 	 
FormerlySerializedAs##	 
(## 
$str## '
)##' (
]##( )
[$$ 	
SerializeField$$	 
]$$ 
float%% 
	m_Extrude%% 
=%% 
$num%% 
;%% 
['' 	 
FormerlySerializedAs''	 
('' 
$str'' ,
)'', -
]''- .
[(( 	
SerializeField((	 
](( 
PolyEditMode)) 

m_EditMode)) 
;))  
[++ 	 
FormerlySerializedAs++	 
(++ 
$str++ +
)+++ ,
]++, -
[,, 	
SerializeField,,	 
],, 
bool-- 
m_FlipNormals-- 
;-- 
[// 	
SerializeField//	 
]// 
internal00 
bool00 
isOnGrid00 
=00  
true00! %
;00% &
public55 
ReadOnlyCollection55 !
<55! "
Vector355" )
>55) *
controlPoints55+ 8
{66 	
get77 
{77 
return77 
new77 
ReadOnlyCollection77 /
<77/ 0
Vector3770 7
>777 8
(778 9
m_Points779 A
)77A B
;77B C
}77D E
}88 	
public== 
void== 
SetControlPoints== $
(==$ %
IList==% *
<==* +
Vector3==+ 2
>==2 3
points==4 :
)==: ;
{>> 	
m_Points?? 
=?? 
points?? 
.?? 
ToList?? $
(??$ %
)??% &
;??& '
}@@ 	
publicFF 
floatFF 
extrudeFF 
{GG 	
getHH 
{HH 
returnHH 
	m_ExtrudeHH "
;HH" #
}HH$ %
setII 
{II 
	m_ExtrudeII 
=II 
valueII #
;II# $
}II% &
}JJ 	
internalLL 
PolyEditModeLL 
polyEditModeLL *
{MM 	
getNN 
{NN 
returnNN 

m_EditModeNN #
;NN# $
}NN% &
setOO 
{OO 

m_EditModeOO 
=OO 
valueOO $
;OO$ %
}OO& '
}PP 	
publicUU 
boolUU 
flipNormalsUU 
{VV 	
getWW 
{WW 
returnWW 
m_FlipNormalsWW &
;WW& '
}WW( )
setXX 
{XX 
m_FlipNormalsXX 
=XX  !
valueXX" '
;XX' (
}XX) *
}YY 	
internal[[ 
ProBuilderMesh[[ 
mesh[[  $
{\\ 	
get]] 
{^^ 
if__ 
(__ 
m_Mesh__ 
==__ 
null__ "
)__" #
m_Mesh`` 
=`` 
GetComponent`` )
<``) *
ProBuilderMesh``* 8
>``8 9
(``9 :
)``: ;
;``; <
returnbb 
m_Meshbb 
;bb 
}cc 
setee 
{ff 
m_Meshgg 
=gg 
valuegg 
;gg 
}hh 
}ii 	
booloo 
IsSnapEnabledoo 
(oo 
)oo 
{pp 	
returnqq 
isOnGridqq 
;qq 
}rr 	
}ss 
}tt ı/
ëD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\UnwrapParameters.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[		 
System		 
.		 
Serializable		 
]		 
public

 

sealed

 
class

 
UnwrapParameters

 (
{ 
internal 
const 
float 
k_HardAngle (
=) *
$num+ .
;. /
internal 
const 
float 
k_PackMargin )
=* +
$num, /
;/ 0
internal 
const 
float 
k_AngleError )
=* +
$num, .
;. /
internal 
const 
float 
k_AreaError (
=) *
$num+ .
;. /
[ 	
Tooltip	 
( 
$str L
)L M
]M N
[ 	
Range	 
( 
$num 
, 
$num 
) 
] 
[ 	
SerializeField	 
] 
[ 	 
FormerlySerializedAs	 
( 
$str )
)) *
]* +
float 
m_HardAngle 
= 
k_HardAngle '
;' (
[ 	
Tooltip	 
( 
$str ]
)] ^
]^ _
[ 	
Range	 
( 
$num 
, 
$num 
) 
] 
[ 	
SerializeField	 
] 
[ 	 
FormerlySerializedAs	 
( 
$str *
)* +
]+ ,
float 
m_PackMargin 
= 
k_PackMargin )
;) *
[ 	
Tooltip	 
( 
$str v
+ 
$str o
)o p
]p q
[ 	
Range	 
( 
$num 
, 
$num 
) 
] 
[   	
SerializeField  	 
]   
[!! 	 
FormerlySerializedAs!!	 
(!! 
$str!! *
)!!* +
]!!+ ,
float"" 
m_AngleError"" 
="" 
k_AngleError"" )
;"") *
[$$ 	
Range$$	 
($$ 
$num$$ 
,$$ 
$num$$ 
)$$ 
]$$ 
[%% 	
SerializeField%%	 
]%% 
[&& 	 
FormerlySerializedAs&&	 
(&& 
$str&& )
)&&) *
]&&* +
float'' 
m_AreaError'' 
='' 
k_AreaError'' '
;''' (
public,, 
float,, 
	hardAngle,, 
{,,  
get,,! $
{,,% &
return,,' -
m_HardAngle,,. 9
;,,9 :
},,; <
set,,= @
{,,A B
m_HardAngle,,C N
=,,O P
value,,Q V
;,,V W
},,X Y
},,Z [
public11 
float11 

packMargin11 
{11  !
get11" %
{11& '
return11( .
m_PackMargin11/ ;
;11; <
}11= >
set11? B
{11C D
m_PackMargin11E Q
=11R S
value11T Y
;11Y Z
}11[ \
}11] ^
public77 
float77 

angleError77 
{77  !
get77" %
{77& '
return77( .
m_AngleError77/ ;
;77; <
}77= >
set77? B
{77C D
m_AngleError77E Q
=77R S
value77T Y
;77Y Z
}77[ \
}77] ^
public<< 
float<< 
	areaError<< 
{<<  
get<<! $
{<<% &
return<<' -
m_AreaError<<. 9
;<<9 :
}<<; <
set<<= @
{<<A B
m_AreaError<<C N
=<<O P
value<<Q V
;<<V W
}<<X Y
}<<Z [
public>> 
UnwrapParameters>> 
(>>  
)>>  !
{?? 	
Reset@@ 
(@@ 
)@@ 
;@@ 
}AA 	
publicGG 
UnwrapParametersGG 
(GG  
UnwrapParametersGG  0
otherGG1 6
)GG6 7
{HH 	
ifII 
(II 
otherII 
==II 
nullII 
)II 
throwJJ 
newJJ 
SystemJJ  
.JJ  !!
ArgumentNullExceptionJJ! 6
(JJ6 7
$strJJ7 >
)JJ> ?
;JJ? @
	hardAngleLL 
=LL 
otherLL 
.LL 
	hardAngleLL '
;LL' (

packMarginMM 
=MM 
otherMM 
.MM 

packMarginMM )
;MM) *

angleErrorNN 
=NN 
otherNN 
.NN 

angleErrorNN )
;NN) *
	areaErrorOO 
=OO 
otherOO 
.OO 
	areaErrorOO '
;OO' (
}PP 	
publicUU 
voidUU 
ResetUU 
(UU 
)UU 
{VV 	
	hardAngleWW 
=WW 
k_HardAngleWW #
;WW# $

packMarginXX 
=XX 
k_PackMarginXX %
;XX% &

angleErrorYY 
=YY 
k_AngleErrorYY %
;YY% &
	areaErrorZZ 
=ZZ 
k_AreaErrorZZ #
;ZZ# $
}[[ 	
public]] 
override]] 
string]] 
ToString]] '
(]]' (
)]]( )
{^^ 	
return__ 
string__ 
.__ 
Format__  
(__  !
$str__! c
,__c d
	hardAngle`` 
,`` 

packMarginaa 
,aa 

angleErrorbb 
,bb 
	areaErrorcc 
)cc 
;cc 
}dd 	
}ee 
}ff €˛
çD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ArrayUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
ArrayUtility 
{ 
public		 
static		 
T		 
[		 
]		 
ValuesWithIndexes		 +
<		+ ,
T		, -
>		- .
(		. /
this		/ 3
T		4 5
[		5 6
]		6 7
arr		8 ;
,		; <
int		= @
[		@ A
]		A B
indexes		C J
)		J K
{

 	
T 
[ 
] 
vals 
= 
new 
T 
[ 
indexes $
.$ %
Length% +
]+ ,
;, -
for 
( 
int 
i 
= 
$num 
; 
i 
< 
indexes  '
.' (
Length( .
;. /
i0 1
++1 3
)3 4
vals 
[ 
i 
] 
= 
arr 
[ 
indexes %
[% &
i& '
]' (
]( )
;) *
return 
vals 
; 
} 	
public 
static 
List 
< 
T 
> 
ValuesWithIndexes /
</ 0
T0 1
>1 2
(2 3
this3 7
List8 <
<< =
T= >
>> ?
arr@ C
,C D
IListE J
<J K
intK N
>N O
indexesP W
)W X
{ 	
List 
< 
T 
> 
vals 
= 
new 
List #
<# $
T$ %
>% &
(& '
indexes' .
.. /
Count/ 4
)4 5
;5 6
foreach 
( 
var 
i 
in 
indexes %
)% &
vals 
. 
Add 
( 
arr 
[ 
i 
] 
)  
;  !
return 
vals 
; 
} 	
public 
static 
IEnumerable !
<! "
int" %
>% &
AllIndexesOf' 3
<3 4
T4 5
>5 6
(6 7
this7 ;
IList< A
<A B
TB C
>C D
listE I
,I J
FuncK O
<O P
TP Q
,Q R
boolS W
>W X
lambdaY _
)_ `
{ 	
var 
indexes 
= 
new 
List "
<" #
int# &
>& '
(' (
)( )
;) *
for 
( 
int 
i 
= 
$num 
, 
c 
= 
list  $
.$ %
Count% *
;* +
i, -
<. /
c0 1
;1 2
i3 4
++4 6
)6 7
if 
( 
lambda 
( 
list 
[  
i  !
]! "
)" #
)# $
indexes   
.   
Add   
(    
i    !
)  ! "
;  " #
return!! 
indexes!! 
;!! 
}"" 	
public$$ 
static$$ 
T$$ 
[$$ 
]$$ 
Add$$ 
<$$ 
T$$ 
>$$  
($$  !
this$$! %
T$$& '
[$$' (
]$$( )
arr$$* -
,$$- .
T$$/ 0
val$$1 4
)$$4 5
{%% 	
T&& 
[&& 
]&& 
v&& 
=&& 
new&& 
T&& 
[&& 
arr&& 
.&& 
Length&& $
+&&% &
$num&&' (
]&&( )
;&&) *
System'' 
.'' 
Array'' 
.'' 
ConstrainedCopy'' (
(''( )
arr'') ,
,'', -
$num''. /
,''/ 0
v''1 2
,''2 3
$num''4 5
,''5 6
arr''7 :
.'': ;
Length''; A
)''A B
;''B C
v(( 
[(( 
arr(( 
.(( 
Length(( 
](( 
=(( 
val(( 
;((  
return)) 
v)) 
;)) 
}** 	
public,, 
static,, 
T,, 
[,, 
],, 
AddRange,, "
<,," #
T,,# $
>,,$ %
(,,% &
this,,& *
T,,+ ,
[,,, -
],,- .
arr,,/ 2
,,,2 3
T,,4 5
[,,5 6
],,6 7
val,,8 ;
),,; <
{-- 	
T.. 
[.. 
].. 
ret.. 
=.. 
new.. 
T.. 
[.. 
arr.. 
...  
Length..  &
+..' (
val..) ,
..., -
Length..- 3
]..3 4
;..4 5
System// 
.// 
Array// 
.// 
ConstrainedCopy// (
(//( )
arr//) ,
,//, -
$num//. /
,/// 0
ret//1 4
,//4 5
$num//6 7
,//7 8
arr//9 <
.//< =
Length//= C
)//C D
;//D E
System00 
.00 
Array00 
.00 
ConstrainedCopy00 (
(00( )
val00) ,
,00, -
$num00. /
,00/ 0
ret001 4
,004 5
arr006 9
.009 :
Length00: @
,00@ A
val00B E
.00E F
Length00F L
)00L M
;00M N
return11 
ret11 
;11 
}22 	
public77 
static77 
T77 
[77 
]77 
Remove77  
<77  !
T77! "
>77" #
(77# $
this77$ (
T77) *
[77* +
]77+ ,
arr77- 0
,770 1
T772 3
val774 7
)777 8
{88 	
List99 
<99 
T99 
>99 
list99 
=99 
new99 
List99 #
<99# $
T99$ %
>99% &
(99& '
arr99' *
)99* +
;99+ ,
list:: 
.:: 
Remove:: 
(:: 
val:: 
):: 
;:: 
return;; 
list;; 
.;; 
ToArray;; 
(;;  
);;  !
;;;! "
}<< 	
public>> 
static>> 
T>> 
[>> 
]>> 
Remove>>  
<>>  !
T>>! "
>>>" #
(>># $
this>>$ (
T>>) *
[>>* +
]>>+ ,
arr>>- 0
,>>0 1
IEnumerable>>2 =
<>>= >
T>>> ?
>>>? @
val>>A D
)>>D E
{?? 	
return@@ 
arr@@ 
.@@ 
Except@@ 
(@@ 
val@@ !
)@@! "
.@@" #
ToArray@@# *
(@@* +
)@@+ ,
;@@, -
}AA 	
publicCC 
staticCC 
TCC 
[CC 
]CC 
RemoveAtCC "
<CC" #
TCC# $
>CC$ %
(CC% &
thisCC& *
TCC+ ,
[CC, -
]CC- .
arrCC/ 2
,CC2 3
intCC4 7
indexCC8 =
)CC= >
{DD 	
TEE 
[EE 
]EE 
newArrayEE 
=EE 
newEE 
TEE  
[EE  !
arrEE! $
.EE$ %
LengthEE% +
-EE, -
$numEE. /
]EE/ 0
;EE0 1
intFF 
nFF 
=FF 
$numFF 
;FF 
forGG 
(GG 
intGG 
iGG 
=GG 
$numGG 
;GG 
iGG 
<GG 
arrGG  #
.GG# $
LengthGG$ *
;GG* +
iGG, -
++GG- /
)GG/ 0
{HH 
ifII 
(II 
iII 
!=II 
indexII 
)II 
{JJ 
newArrayKK 
[KK 
nKK 
]KK 
=KK  !
arrKK" %
[KK% &
iKK& '
]KK' (
;KK( )
nLL 
++LL 
;LL 
}MM 
}NN 
returnOO 
newArrayOO 
;OO 
}PP 	
publicRR 
staticRR 
TRR 
[RR 
]RR 
RemoveAtRR "
<RR" #
TRR# $
>RR$ %
(RR% &
thisRR& *
IListRR+ 0
<RR0 1
TRR1 2
>RR2 3
listRR4 8
,RR8 9
IEnumerableRR: E
<RRE F
intRRF I
>RRI J
indexesRRK R
)RRR S
{SS 	
ListTT 
<TT 
intTT 
>TT 
sortedTT 
=TT 
newTT "
ListTT# '
<TT' (
intTT( +
>TT+ ,
(TT, -
indexesTT- 4
)TT4 5
;TT5 6
sortedUU 
.UU 
SortUU 
(UU 
)UU 
;UU 
returnVV 
SortedRemoveAtVV !
(VV! "
listVV" &
,VV& '
sortedVV( .
)VV. /
;VV/ 0
}WW 	
public\\ 
static\\ 
T\\ 
[\\ 
]\\ 
SortedRemoveAt\\ (
<\\( )
T\\) *
>\\* +
(\\+ ,
this\\, 0
IList\\1 6
<\\6 7
T\\7 8
>\\8 9
list\\: >
,\\> ?
IList\\@ E
<\\E F
int\\F I
>\\I J
sorted\\K Q
)\\Q R
{]] 	
int^^ 
indexeSortedCount^^ !
=^^" #
sorted^^$ *
.^^* +
Count^^+ 0
;^^0 1
int__ 
len__ 
=__ 
list__ 
.__ 
Count__  
;__  !
Taa 
[aa 
]aa 
newArrayaa 
=aa 
newaa 
Taa  
[aa  !
lenaa! $
-aa% &
indexeSortedCountaa' 8
]aa8 9
;aa9 :
intbb 
nbb 
=bb 
$numbb 
;bb 
fordd 
(dd 
intdd 
idd 
=dd 
$numdd 
;dd 
idd 
<dd 
lendd  #
;dd# $
idd% &
++dd& (
)dd( )
{ee 
ifff 
(ff 
nff 
<ff 
indexeSortedCountff )
&&ff* ,
sortedff- 3
[ff3 4
nff4 5
]ff5 6
==ff7 9
iff: ;
)ff; <
{gg 
whileii 
(ii 
nii 
<ii 
indexeSortedCountii 0
&&ii1 3
sortedii4 :
[ii: ;
nii; <
]ii< =
==ii> @
iiiA B
)iiB C
njj 
++jj 
;jj 
continuell 
;ll 
}mm 
newArrayoo 
[oo 
ioo 
-oo 
noo 
]oo 
=oo  !
listoo" &
[oo& '
ioo' (
]oo( )
;oo) *
}pp 
returnrr 
newArrayrr 
;rr 
}ss 	
structxx 
SearchRangexx 
{yy 	
publiczz 
intzz 
beginzz 
,zz 
endzz !
;zz! "
public|| 
SearchRange|| 
(|| 
int|| "
begin||# (
,||( )
int||* -
end||. 1
)||1 2
{}} 
this~~ 
.~~ 
begin~~ 
=~~ 
begin~~ "
;~~" #
this 
. 
end 
= 
end 
; 
}
ÄÄ 
public
ÇÇ 
bool
ÇÇ 
Valid
ÇÇ 
(
ÇÇ 
)
ÇÇ 
{
ÇÇ  !
return
ÇÇ" (
end
ÇÇ) ,
-
ÇÇ- .
begin
ÇÇ/ 4
>
ÇÇ5 6
$num
ÇÇ7 8
;
ÇÇ8 9
}
ÇÇ: ;
public
ÉÉ 
int
ÉÉ 
Center
ÉÉ 
(
ÉÉ 
)
ÉÉ 
{
ÉÉ  !
return
ÉÉ" (
begin
ÉÉ) .
+
ÉÉ/ 0
(
ÉÉ1 2
end
ÉÉ2 5
-
ÉÉ6 7
begin
ÉÉ8 =
)
ÉÉ= >
/
ÉÉ? @
$num
ÉÉA B
;
ÉÉB C
}
ÉÉD E
public
ÖÖ 
override
ÖÖ 
string
ÖÖ "
ToString
ÖÖ# +
(
ÖÖ+ ,
)
ÖÖ, -
{
ÜÜ 
return
áá 
$str
áá 
+
áá 
begin
áá "
+
áá# $
$str
áá% )
+
áá* +
end
áá, /
+
áá0 1
$str
áá2 8
+
áá9 :
Center
áá; A
(
ááA B
)
ááB C
;
ááC D
}
àà 
}
ââ 	
public
ëë 
static
ëë 
int
ëë &
NearestIndexPriorToValue
ëë 2
<
ëë2 3
T
ëë3 4
>
ëë4 5
(
ëë5 6
IList
ëë6 ;
<
ëë; <
T
ëë< =
>
ëë= >
sorted_list
ëë? J
,
ëëJ K
T
ëëL M
value
ëëN S
)
ëëS T
where
ëëU Z
T
ëë[ \
:
ëë] ^
System
ëë_ e
.
ëëe f
IComparable
ëëf q
<
ëëq r
T
ëër s
>
ëës t
{
íí 	
int
ìì 
count
ìì 
=
ìì 
sorted_list
ìì #
.
ìì# $
Count
ìì$ )
;
ìì) *
if
îî 
(
îî 
count
îî 
<
îî 
$num
îî 
)
îî 
return
îî !
-
îî" #
$num
îî# $
;
îî$ %
SearchRange
ññ 
range
ññ 
=
ññ 
new
ññ  #
SearchRange
ññ$ /
(
ññ/ 0
$num
ññ0 1
,
ññ1 2
count
ññ3 8
-
ññ9 :
$num
ññ; <
)
ññ< =
;
ññ= >
if
òò 
(
òò 
value
òò 
.
òò 
	CompareTo
òò 
(
òò  
sorted_list
òò  +
[
òò+ ,
$num
òò, -
]
òò- .
)
òò. /
<
òò0 1
$num
òò2 3
)
òò3 4
return
ôô 
-
ôô 
$num
ôô 
;
ôô 
if
õõ 
(
õõ 
value
õõ 
.
õõ 
	CompareTo
õõ 
(
õõ  
sorted_list
õõ  +
[
õõ+ ,
count
õõ, 1
-
õõ2 3
$num
õõ4 5
]
õõ5 6
)
õõ6 7
>
õõ8 9
$num
õõ: ;
)
õõ; <
return
úú 
count
úú 
-
úú 
$num
úú  
;
úú  !
while
ûû 
(
ûû 
range
ûû 
.
ûû 
Valid
ûû 
(
ûû 
)
ûû  
)
ûû  !
{
üü 
if
†† 
(
†† 
sorted_list
†† 
[
††  
range
††  %
.
††% &
Center
††& ,
(
††, -
)
††- .
]
††. /
.
††/ 0
	CompareTo
††0 9
(
††9 :
value
††: ?
)
††? @
>
††A B
$num
††C D
)
††D E
{
°° 
range
££ 
.
££ 
end
££ 
=
££ 
range
££  %
.
££% &
Center
££& ,
(
££, -
)
££- .
;
££. /
}
§§ 
else
•• 
{
¶¶ 
range
®® 
.
®® 
begin
®® 
=
®®  !
range
®®" '
.
®®' (
Center
®®( .
(
®®. /
)
®®/ 0
;
®®0 1
if
™™ 
(
™™ 
sorted_list
™™ #
[
™™# $
range
™™$ )
.
™™) *
begin
™™* /
+
™™0 1
$num
™™2 3
]
™™3 4
.
™™4 5
	CompareTo
™™5 >
(
™™> ?
value
™™? D
)
™™D E
>=
™™F H
$num
™™I J
)
™™J K
{
´´ 
return
¨¨ 
range
¨¨ $
.
¨¨$ %
begin
¨¨% *
;
¨¨* +
}
≠≠ 
}
ÆÆ 
}
ØØ 
return
±± 
$num
±± 
;
±± 
}
≤≤ 	
public
¥¥ 
static
¥¥ 
List
¥¥ 
<
¥¥ 
T
¥¥ 
>
¥¥ 
Fill
¥¥ "
<
¥¥" #
T
¥¥# $
>
¥¥$ %
(
¥¥% &
System
¥¥& ,
.
¥¥, -
Func
¥¥- 1
<
¥¥1 2
int
¥¥2 5
,
¥¥5 6
T
¥¥7 8
>
¥¥8 9
ctor
¥¥: >
,
¥¥> ?
int
¥¥@ C
length
¥¥D J
)
¥¥J K
{
µµ 	
List
∂∂ 
<
∂∂ 
T
∂∂ 
>
∂∂ 
list
∂∂ 
=
∂∂ 
new
∂∂ 
List
∂∂ #
<
∂∂# $
T
∂∂$ %
>
∂∂% &
(
∂∂& '
length
∂∂' -
)
∂∂- .
;
∂∂. /
for
∑∑ 
(
∑∑ 
int
∑∑ 
i
∑∑ 
=
∑∑ 
$num
∑∑ 
;
∑∑ 
i
∑∑ 
<
∑∑ 
length
∑∑  &
;
∑∑& '
i
∑∑( )
++
∑∑) +
)
∑∑+ ,
list
∏∏ 
.
∏∏ 
Add
∏∏ 
(
∏∏ 
ctor
∏∏ 
(
∏∏ 
i
∏∏ 
)
∏∏  
)
∏∏  !
;
∏∏! "
return
ππ 
list
ππ 
;
ππ 
}
∫∫ 	
public
ºº 
static
ºº 
T
ºº 
[
ºº 
]
ºº 
Fill
ºº 
<
ºº 
T
ºº  
>
ºº  !
(
ºº! "
T
ºº" #
val
ºº$ '
,
ºº' (
int
ºº) ,
length
ºº- 3
)
ºº3 4
{
ΩΩ 	
T
ææ 
[
ææ 
]
ææ 
arr
ææ 
=
ææ 
new
ææ 
T
ææ 
[
ææ 
length
ææ "
]
ææ" #
;
ææ# $
for
øø 
(
øø 
int
øø 
i
øø 
=
øø 
$num
øø 
;
øø 
i
øø 
<
øø 
length
øø  &
;
øø& '
i
øø( )
++
øø) +
)
øø+ ,
{
¿¿ 
arr
¡¡ 
[
¡¡ 
i
¡¡ 
]
¡¡ 
=
¡¡ 
val
¡¡ 
;
¡¡ 
}
¬¬ 
return
√√ 
arr
√√ 
;
√√ 
}
ƒƒ 	
public
…… 
static
…… 
bool
…… 
ContainsMatch
…… (
<
……( )
T
……) *
>
……* +
(
……+ ,
this
……, 0
T
……1 2
[
……2 3
]
……3 4
a
……5 6
,
……6 7
T
……8 9
[
……9 :
]
……: ;
b
……< =
)
……= >
{
   	
int
ÀÀ 
ind
ÀÀ 
=
ÀÀ 
-
ÀÀ 
$num
ÀÀ 
;
ÀÀ 
for
ÃÃ 
(
ÃÃ 
int
ÃÃ 
i
ÃÃ 
=
ÃÃ 
$num
ÃÃ 
;
ÃÃ 
i
ÃÃ 
<
ÃÃ 
a
ÃÃ  !
.
ÃÃ! "
Length
ÃÃ" (
;
ÃÃ( )
i
ÃÃ* +
++
ÃÃ+ -
)
ÃÃ- .
{
ÕÕ 
ind
ŒŒ 
=
ŒŒ 
System
ŒŒ 
.
ŒŒ 
Array
ŒŒ "
.
ŒŒ" #
IndexOf
ŒŒ# *
(
ŒŒ* +
b
ŒŒ+ ,
,
ŒŒ, -
a
ŒŒ. /
[
ŒŒ/ 0
i
ŒŒ0 1
]
ŒŒ1 2
)
ŒŒ2 3
;
ŒŒ3 4
if
œœ 
(
œœ 
ind
œœ 
>
œœ 
-
œœ 
$num
œœ 
)
œœ 
return
œœ $
true
œœ% )
;
œœ) *
}
–– 
return
—— 
false
—— 
;
—— 
}
““ 	
public
◊◊ 
static
◊◊ 
bool
◊◊ 
ContainsMatch
◊◊ (
<
◊◊( )
T
◊◊) *
>
◊◊* +
(
◊◊+ ,
this
◊◊, 0
T
◊◊1 2
[
◊◊2 3
]
◊◊3 4
a
◊◊5 6
,
◊◊6 7
T
◊◊8 9
[
◊◊9 :
]
◊◊: ;
b
◊◊< =
,
◊◊= >
out
◊◊? B
int
◊◊C F
index_a
◊◊G N
,
◊◊N O
out
◊◊P S
int
◊◊T W
index_b
◊◊X _
)
◊◊_ `
{
ÿÿ 	
index_b
ŸŸ 
=
ŸŸ 
-
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
for
⁄⁄ 
(
⁄⁄ 
index_a
⁄⁄ 
=
⁄⁄ 
$num
⁄⁄ 
;
⁄⁄ 
index_a
⁄⁄ %
<
⁄⁄& '
a
⁄⁄( )
.
⁄⁄) *
Length
⁄⁄* 0
;
⁄⁄0 1
index_a
⁄⁄2 9
++
⁄⁄9 ;
)
⁄⁄; <
{
€€ 
index_b
‹‹ 
=
‹‹ 
Array
‹‹ 
.
‹‹  
IndexOf
‹‹  '
(
‹‹' (
b
‹‹( )
,
‹‹) *
a
‹‹+ ,
[
‹‹, -
index_a
‹‹- 4
]
‹‹4 5
)
‹‹5 6
;
‹‹6 7
if
›› 
(
›› 
index_b
›› 
>
›› 
-
›› 
$num
››  
)
››  !
return
ﬁﬁ 
true
ﬁﬁ 
;
ﬁﬁ  
}
ﬂﬂ 
return
·· 
false
·· 
;
·· 
}
‚‚ 	
public
ÁÁ 
static
ÁÁ 
T
ÁÁ 
[
ÁÁ 
]
ÁÁ 
Concat
ÁÁ  
<
ÁÁ  !
T
ÁÁ! "
>
ÁÁ" #
(
ÁÁ# $
this
ÁÁ$ (
T
ÁÁ) *
[
ÁÁ* +
]
ÁÁ+ ,
x
ÁÁ- .
,
ÁÁ. /
T
ÁÁ0 1
[
ÁÁ1 2
]
ÁÁ2 3
y
ÁÁ4 5
)
ÁÁ5 6
{
ËË 	
if
ÈÈ 
(
ÈÈ 
x
ÈÈ 
==
ÈÈ 
null
ÈÈ 
)
ÈÈ 
throw
ÈÈ  
new
ÈÈ! $#
ArgumentNullException
ÈÈ% :
(
ÈÈ: ;
$str
ÈÈ; >
)
ÈÈ> ?
;
ÈÈ? @
if
ÍÍ 
(
ÍÍ 
y
ÍÍ 
==
ÍÍ 
null
ÍÍ 
)
ÍÍ 
throw
ÍÍ  
new
ÍÍ! $#
ArgumentNullException
ÍÍ% :
(
ÍÍ: ;
$str
ÍÍ; >
)
ÍÍ> ?
;
ÍÍ? @
int
ÎÎ 
oldLen
ÎÎ 
=
ÎÎ 
x
ÎÎ 
.
ÎÎ 
Length
ÎÎ !
;
ÎÎ! "
Array
ÏÏ 
.
ÏÏ 
Resize
ÏÏ 
<
ÏÏ 
T
ÏÏ 
>
ÏÏ 
(
ÏÏ 
ref
ÏÏ 
x
ÏÏ  !
,
ÏÏ! "
x
ÏÏ# $
.
ÏÏ$ %
Length
ÏÏ% +
+
ÏÏ, -
y
ÏÏ. /
.
ÏÏ/ 0
Length
ÏÏ0 6
)
ÏÏ6 7
;
ÏÏ7 8
Array
ÌÌ 
.
ÌÌ 
Copy
ÌÌ 
(
ÌÌ 
y
ÌÌ 
,
ÌÌ 
$num
ÌÌ 
,
ÌÌ 
x
ÌÌ 
,
ÌÌ 
oldLen
ÌÌ  &
,
ÌÌ& '
y
ÌÌ( )
.
ÌÌ) *
Length
ÌÌ* 0
)
ÌÌ0 1
;
ÌÌ1 2
return
ÓÓ 
x
ÓÓ 
;
ÓÓ 
}
ÔÔ 	
public
ÙÙ 
static
ÙÙ 
int
ÙÙ 
IndexOf
ÙÙ !
<
ÙÙ! "
T
ÙÙ" #
>
ÙÙ# $
(
ÙÙ$ %
this
ÙÙ% )
List
ÙÙ* .
<
ÙÙ. /
List
ÙÙ/ 3
<
ÙÙ3 4
T
ÙÙ4 5
>
ÙÙ5 6
>
ÙÙ6 7
InList
ÙÙ8 >
,
ÙÙ> ?
T
ÙÙ@ A
InValue
ÙÙB I
)
ÙÙI J
{
ıı 	
for
ˆˆ 
(
ˆˆ 
int
ˆˆ 
i
ˆˆ 
=
ˆˆ 
$num
ˆˆ 
;
ˆˆ 
i
ˆˆ 
<
ˆˆ 
InList
ˆˆ  &
.
ˆˆ& '
Count
ˆˆ' ,
;
ˆˆ, -
i
ˆˆ. /
++
ˆˆ/ 1
)
ˆˆ1 2
{
˜˜ 
for
¯¯ 
(
¯¯ 
int
¯¯ 
x
¯¯ 
=
¯¯ 
$num
¯¯ 
;
¯¯ 
x
¯¯  !
<
¯¯" #
InList
¯¯$ *
[
¯¯* +
i
¯¯+ ,
]
¯¯, -
.
¯¯- .
Count
¯¯. 3
;
¯¯3 4
x
¯¯5 6
++
¯¯6 8
)
¯¯8 9
if
˘˘ 
(
˘˘ 
InList
˘˘ 
[
˘˘ 
i
˘˘  
]
˘˘  !
[
˘˘! "
x
˘˘" #
]
˘˘# $
.
˘˘$ %
Equals
˘˘% +
(
˘˘+ ,
InValue
˘˘, 3
)
˘˘3 4
)
˘˘4 5
return
˙˙ 
i
˙˙  
;
˙˙  !
}
˚˚ 
return
˝˝ 
-
˝˝ 
$num
˝˝ 
;
˝˝ 
}
˛˛ 	
public
ÉÉ 
static
ÉÉ 
T
ÉÉ 
[
ÉÉ 
]
ÉÉ 
Fill
ÉÉ 
<
ÉÉ 
T
ÉÉ  
>
ÉÉ  !
(
ÉÉ! "
int
ÉÉ" %
count
ÉÉ& +
,
ÉÉ+ ,
System
ÉÉ- 3
.
ÉÉ3 4
Func
ÉÉ4 8
<
ÉÉ8 9
int
ÉÉ9 <
,
ÉÉ< =
T
ÉÉ> ?
>
ÉÉ? @
ctor
ÉÉA E
)
ÉÉE F
{
ÑÑ 	
T
ÖÖ 
[
ÖÖ 
]
ÖÖ 
arr
ÖÖ 
=
ÖÖ 
new
ÖÖ 
T
ÖÖ 
[
ÖÖ 
count
ÖÖ !
]
ÖÖ! "
;
ÖÖ" #
for
ÜÜ 
(
ÜÜ 
int
ÜÜ 
i
ÜÜ 
=
ÜÜ 
$num
ÜÜ 
;
ÜÜ 
i
ÜÜ 
<
ÜÜ 
count
ÜÜ  %
;
ÜÜ% &
i
ÜÜ' (
++
ÜÜ( *
)
ÜÜ* +
arr
áá 
[
áá 
i
áá 
]
áá 
=
áá 
ctor
áá 
(
áá 
i
áá 
)
áá  
;
áá  !
return
àà 
arr
àà 
;
àà 
}
ââ 	
public
éé 
static
éé 
void
éé 
AddOrAppend
éé &
<
éé& '
T
éé' (
,
éé( )
K
éé* +
>
éé+ ,
(
éé, -
this
éé- 1

Dictionary
éé2 <
<
éé< =
T
éé= >
,
éé> ?
List
éé@ D
<
ééD E
K
ééE F
>
ééF G
>
ééG H

dictionary
ééI S
,
ééS T
T
ééU V
key
ééW Z
,
ééZ [
K
éé\ ]
value
éé^ c
)
ééc d
{
èè 	
List
êê 
<
êê 
K
êê 
>
êê 
list
êê 
;
êê 
if
íí 
(
íí 

dictionary
íí 
.
íí 
TryGetValue
íí &
(
íí& '
key
íí' *
,
íí* +
out
íí, /
list
íí0 4
)
íí4 5
)
íí5 6
list
ìì 
.
ìì 
Add
ìì 
(
ìì 
value
ìì 
)
ìì 
;
ìì  
else
îî 

dictionary
ïï 
.
ïï 
Add
ïï 
(
ïï 
key
ïï "
,
ïï" #
new
ïï$ '
List
ïï( ,
<
ïï, -
K
ïï- .
>
ïï. /
(
ïï/ 0
)
ïï0 1
{
ïï2 3
value
ïï4 9
}
ïï: ;
)
ïï; <
;
ïï< =
}
ññ 	
public
õõ 
static
õõ 
void
õõ 
AddOrAppendRange
õõ +
<
õõ+ ,
T
õõ, -
,
õõ- .
K
õõ/ 0
>
õõ0 1
(
õõ1 2
this
õõ2 6

Dictionary
õõ7 A
<
õõA B
T
õõB C
,
õõC D
List
õõE I
<
õõI J
K
õõJ K
>
õõK L
>
õõL M

dictionary
õõN X
,
õõX Y
T
õõZ [
key
õõ\ _
,
õõ_ `
List
õõa e
<
õõe f
K
õõf g
>
õõg h
value
õõi n
)
õõn o
{
úú 	
List
ùù 
<
ùù 
K
ùù 
>
ùù 
list
ùù 
;
ùù 
if
üü 
(
üü 

dictionary
üü 
.
üü 
TryGetValue
üü &
(
üü& '
key
üü' *
,
üü* +
out
üü, /
list
üü0 4
)
üü4 5
)
üü5 6
list
†† 
.
†† 
AddRange
†† 
(
†† 
value
†† #
)
††# $
;
††$ %
else
°° 

dictionary
¢¢ 
.
¢¢ 
Add
¢¢ 
(
¢¢ 
key
¢¢ "
,
¢¢" #
value
¢¢$ )
)
¢¢) *
;
¢¢* +
}
££ 	
public
®® 
static
®® 
IEnumerable
®® !
<
®®! "
TSource
®®" )
>
®®) *

DistinctBy
®®+ 5
<
®®5 6
TSource
®®6 =
,
®®= >
TKey
®®? C
>
®®C D
(
®®D E
this
©© 
IEnumerable
©© 
<
©© 
TSource
©© $
>
©©$ %
source
©©& ,
,
©©, -
Func
™™ 
<
™™ 
TSource
™™ 
,
™™ 
TKey
™™ 
>
™™ 
keySelector
™™  +
)
™™+ ,
{
´´ 	
HashSet
¨¨ 
<
¨¨ 
TKey
¨¨ 
>
¨¨ 
	knownKeys
¨¨ #
=
¨¨$ %
new
¨¨& )
HashSet
¨¨* 1
<
¨¨1 2
TKey
¨¨2 6
>
¨¨6 7
(
¨¨7 8
)
¨¨8 9
;
¨¨9 :
return
≠≠ 
source
≠≠ 
.
≠≠ 
Where
≠≠ 
(
≠≠  
x
≠≠  !
=>
≠≠" $
	knownKeys
≠≠% .
.
≠≠. /
Add
≠≠/ 2
(
≠≠2 3
keySelector
≠≠3 >
(
≠≠> ?
x
≠≠? @
)
≠≠@ A
)
≠≠A B
)
≠≠B C
;
≠≠C D
}
ÆÆ 	
public
∞∞ 
static
∞∞ 
string
∞∞ 
ToString
∞∞ %
<
∞∞% &
TKey
∞∞& *
,
∞∞* +
TValue
∞∞, 2
>
∞∞2 3
(
∞∞3 4
this
∞∞4 8

Dictionary
∞∞9 C
<
∞∞C D
TKey
∞∞D H
,
∞∞H I
TValue
∞∞J P
>
∞∞P Q
dict
∞∞R V
)
∞∞V W
{
±± 	
System
≤≤ 
.
≤≤ 
Text
≤≤ 
.
≤≤ 
StringBuilder
≤≤ %
sb
≤≤& (
=
≤≤) *
new
≤≤+ .
System
≤≤/ 5
.
≤≤5 6
Text
≤≤6 :
.
≤≤: ;
StringBuilder
≤≤; H
(
≤≤H I
)
≤≤I J
;
≤≤J K
foreach
¥¥ 
(
¥¥ 
KeyValuePair
¥¥ !
<
¥¥! "
TKey
¥¥" &
,
¥¥& '
TValue
¥¥( .
>
¥¥. /
kvp
¥¥0 3
in
¥¥4 6
dict
¥¥7 ;
)
¥¥; <
sb
µµ 
.
µµ 

AppendLine
µµ 
(
µµ 
string
µµ $
.
µµ$ %
Format
µµ% +
(
µµ+ ,
$str
µµ, B
,
µµB C
kvp
µµD G
.
µµG H
Key
µµH K
,
µµK L
kvp
µµM P
.
µµP Q
Value
µµQ V
)
µµV W
)
µµW X
;
µµX Y
return
∂∂ 
sb
∂∂ 
.
∂∂ 
ToString
∂∂ 
(
∂∂ 
)
∂∂  
;
∂∂  !
}
∑∑ 	
public
ππ 
static
ππ 
string
ππ 
ToString
ππ %
<
ππ% &
T
ππ& '
>
ππ' (
(
ππ( )
this
ππ) -
IEnumerable
ππ. 9
<
ππ9 :
T
ππ: ;
>
ππ; <
arr
ππ= @
,
ππ@ A
string
ππB H
	separator
ππI R
=
ππS T
$str
ππU Y
)
ππY Z
{
∫∫ 	
return
ªª 
string
ªª 
.
ªª 
Join
ªª 
(
ªª 
	separator
ªª (
,
ªª( )
arr
ªª* -
.
ªª- .
Select
ªª. 4
(
ªª4 5
x
ªª5 6
=>
ªª7 9
x
ªª: ;
.
ªª; <
ToString
ªª< D
(
ªªD E
)
ªªE F
)
ªªF G
.
ªªG H
ToArray
ªªH O
(
ªªO P
)
ªªP Q
)
ªªQ R
;
ªªR S
}
ºº 	
}
ΩΩ 
}ææ ò
ïD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SerializationUtility.csçˇ
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\CombineMeshes.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
public

 
static

 
class

 
CombineMeshes

 "
{ 
[ 	
Obsolete	 
( 
$str	 †
)
† °
]
° ¢
public 
static 
List 
< 
ProBuilderMesh )
>) *
Combine+ 2
(2 3
IEnumerable3 >
<> ?
ProBuilderMesh? M
>M N
meshesO U
)U V
{ 	
return 
CombineToNewMeshes %
(% &
meshes& ,
), -
;- .
} 	
public&& 
static&& 
List&& 
<&& 
ProBuilderMesh&& )
>&&) *
Combine&&+ 2
(&&2 3
IEnumerable&&3 >
<&&> ?
ProBuilderMesh&&? M
>&&M N
meshes&&O U
,&&U V
ProBuilderMesh&&W e

meshTarget&&f p
)&&p q
{'' 	
if(( 
((( 
meshes(( 
==(( 
null(( 
)(( 
throw)) 
new)) !
ArgumentNullException)) /
())/ 0
$str))0 8
)))8 9
;))9 :
if++ 
(++ 

meshTarget++ 
==++ 
null++ "
)++" #
throw,, 
new,, !
ArgumentNullException,, /
(,,/ 0
$str,,0 <
),,< =
;,,= >
if.. 
(.. 
!.. 
meshes.. 
... 
Any.. 
(.. 
).. 
||..  
meshes..! '
...' (
Count..( -
(..- .
)... /
<..0 1
$num..2 3
)..4 5
return// 
null// 
;// 
if11 
(11 
!11 
meshes11 
.11 
Contains11  
(11  !

meshTarget11! +
)11+ ,
)11, -
return22 
null22 
;22 
var44 
vertices44 
=44 
new44 
List44 #
<44# $
Vertex44$ *
>44* +
(44+ ,

meshTarget44, 6
.446 7
GetVertices447 B
(44B C
)44C D
)44D E
;44E F
var55 
faces55 
=55 
new55 
List55  
<55  !
Face55! %
>55% &
(55& '

meshTarget55' 1
.551 2
facesInternal552 ?
)55? @
;55@ A
var66 
sharedVertices66 
=66  
new66! $
List66% )
<66) *
SharedVertex66* 6
>666 7
(667 8

meshTarget668 B
.66B C
sharedVertices66C Q
)66Q R
;66R S
var77 
sharedTextures77 
=77  
new77! $
List77% )
<77) *
SharedVertex77* 6
>776 7
(777 8

meshTarget778 B
.77B C
sharedTextures77C Q
)77Q R
;77R S
int88 
offset88 
=88 

meshTarget88 #
.88# $
vertexCount88$ /
;88/ 0
var99 
materialMap99 
=99 
new99 !
List99" &
<99& '
Material99' /
>99/ 0
(990 1

meshTarget991 ;
.99; <
renderer99< D
.99D E
sharedMaterials99E T
)99T U
;99U V
var:: 
targetTransform:: 
=::  !

meshTarget::" ,
.::, -
	transform::- 6
;::6 7
var<< !
firstMeshContributors<< %
=<<& '
new<<( +
List<<, 0
<<<0 1
ProBuilderMesh<<1 ?
><<? @
(<<@ A
)<<A B
;<<B C
var== %
remainderMeshContributors== )
===* +
new==, /
List==0 4
<==4 5
ProBuilderMesh==5 C
>==C D
(==D E
)==E F
;==F G
var?? "
currentMeshVertexCount?? &
=??' (
offset??) /
;??/ 0
foreach@@ 
(@@ 
var@@ 
mesh@@ 
in@@  
meshes@@! '
)@@' (
{AA 
ifBB 
(BB 
meshBB 
!=BB 

meshTargetBB &
)BB& '
{CC 
ifDD 
(DD "
currentMeshVertexCountDD .
+DD/ 0
meshDD1 5
.DD5 6
vertexCountDD6 A
<DDB C
ProBuilderMeshDDD R
.DDR S
maxVertexCountDDS a
)DDa b
{EE "
currentMeshVertexCountFF .
+=FF/ 1
meshFF2 6
.FF6 7
vertexCountFF7 B
;FFB C!
firstMeshContributorsGG -
.GG- .
AddGG. 1
(GG1 2
meshGG2 6
)GG6 7
;GG7 8
}HH 
elseII 
{JJ %
remainderMeshContributorsKK 1
.KK1 2
AddKK2 5
(KK5 6
meshKK6 :
)KK: ;
;KK; <
}LL 
}MM 
}NN 
varPP 
autoUvFacesPP 
=PP 
newPP !
ListPP" &
<PP& '
FacePP' +
>PP+ ,
(PP, -
)PP- .
;PP. / 
AccumulateMeshesInfoQQ  
(QQ  !!
firstMeshContributorsRR %
,RR% &
offsetSS 
,SS 
refTT 
verticesTT 
,TT 
refUU 
facesUU 
,UU 
refVV 
autoUvFacesVV 
,VV  
refWW 
sharedVerticesWW "
,WW" #
refXX 
sharedTexturesXX "
,XX" #
refYY 
materialMapYY 
,YY  
targetTransformZZ 
)[[ 
;[[ 

meshTarget]] 
.]] 
SetVertices]] "
(]]" #
vertices]]# +
)]]+ ,
;]], -

meshTarget^^ 
.^^ 
faces^^ 
=^^ 
faces^^ $
;^^$ %

meshTarget__ 
.__ 
sharedVertices__ %
=__& '
sharedVertices__( 6
;__6 7

meshTarget`` 
.`` 
sharedTextures`` %
=``& '
sharedTextures``( 6
!=``7 9
null``: >
?``? @
sharedTextures``A O
.``O P
ToArray``P W
(``W X
)``X Y
:``Z [
null``\ `
;``` a

meshTargetaa 
.aa 
rendereraa 
.aa  
sharedMaterialsaa  /
=aa0 1
materialMapaa2 =
.aa= >
ToArrayaa> E
(aaE F
)aaF G
;aaG H

meshTargetbb 
.bb 
ToMeshbb 
(bb 
)bb 
;bb  

meshTargetcc 
.cc 
Refreshcc 
(cc 
)cc  
;cc  !
	UVEditingdd 
.dd ,
 SetAutoAndAlignUnwrapParamsToUVsdd 6
(dd6 7

meshTargetdd7 A
,ddA B
autoUvFacesddC N
)ddN O
;ddO P
MeshValidationff 
.ff 
EnsureMeshIsValidff ,
(ff, -

meshTargetff- 7
,ff7 8
outff9 <
intff= @
removedVerticesffA P
)ffP Q
;ffQ R
varhh 
returnedMeshhh 
=hh 
newhh "
Listhh# '
<hh' (
ProBuilderMeshhh( 6
>hh6 7
(hh7 8
)hh8 9
{hh: ;

meshTargethh< F
}hhG H
;hhH I
ifii 
(ii %
remainderMeshContributorsii )
.ii) *
Countii* /
>ii0 1
$numii2 3
)ii3 4
{jj 
varkk 
	newMesheskk 
=kk 
CombineToNewMesheskk  2
(kk2 3%
remainderMeshContributorskk3 L
)kkL M
;kkM N
foreachll 
(ll 
varll 
meshll !
inll" $
	newMeshesll% .
)ll. /
{mm 
MeshValidationnn "
.nn" #
EnsureMeshIsValidnn# 4
(nn4 5
meshnn5 9
,nn9 :
outnn; >
removedVerticesnn? N
)nnN O
;nnO P
returnedMeshoo  
.oo  !
Addoo! $
(oo$ %
meshoo% )
)oo) *
;oo* +
}pp 
}qq 
elserr 
ifrr 
(rr %
remainderMeshContributorsrr .
.rr. /
Countrr/ 4
==rr5 7
$numrr8 9
)rr9 :
{ss 
returnedMeshtt 
.tt 
Addtt  
(tt  !%
remainderMeshContributorstt! :
[tt: ;
$numtt; <
]tt< =
)tt= >
;tt> ?
}uu 
returnww 
returnedMeshww 
;ww  
}xx 	
staticzz 
Listzz 
<zz 
ProBuilderMeshzz "
>zz" #
CombineToNewMesheszz$ 6
(zz6 7
IEnumerablezz7 B
<zzB C
ProBuilderMeshzzC Q
>zzQ R
mesheszzS Y
)zzY Z
{{{ 	
if|| 
(|| 
meshes|| 
==|| 
null|| 
)|| 
throw}} 
new}} !
ArgumentNullException}} /
(}}/ 0
$str}}0 8
)}}8 9
;}}9 :
if 
( 
! 
meshes 
. 
Any 
( 
) 
||  
meshes! '
.' (
Count( -
(- .
). /
<0 1
$num2 3
)3 4
return
ÄÄ 
null
ÄÄ 
;
ÄÄ 
var
ÇÇ 
vertices
ÇÇ 
=
ÇÇ 
new
ÇÇ 
List
ÇÇ #
<
ÇÇ# $
Vertex
ÇÇ$ *
>
ÇÇ* +
(
ÇÇ+ ,
)
ÇÇ, -
;
ÇÇ- .
var
ÉÉ 
faces
ÉÉ 
=
ÉÉ 
new
ÉÉ 
List
ÉÉ  
<
ÉÉ  !
Face
ÉÉ! %
>
ÉÉ% &
(
ÉÉ& '
)
ÉÉ' (
;
ÉÉ( )
var
ÑÑ 
autoUvFaces
ÑÑ 
=
ÑÑ 
new
ÑÑ !
List
ÑÑ" &
<
ÑÑ& '
Face
ÑÑ' +
>
ÑÑ+ ,
(
ÑÑ, -
)
ÑÑ- .
;
ÑÑ. /
var
ÖÖ 
sharedVertices
ÖÖ 
=
ÖÖ  
new
ÖÖ! $
List
ÖÖ% )
<
ÖÖ) *
SharedVertex
ÖÖ* 6
>
ÖÖ6 7
(
ÖÖ7 8
)
ÖÖ8 9
;
ÖÖ9 :
var
ÜÜ 
sharedTextures
ÜÜ 
=
ÜÜ  
new
ÜÜ! $
List
ÜÜ% )
<
ÜÜ) *
SharedVertex
ÜÜ* 6
>
ÜÜ6 7
(
ÜÜ7 8
)
ÜÜ8 9
;
ÜÜ9 :
int
áá 
offset
áá 
=
áá 
$num
áá 
;
áá 
var
àà 
materialMap
àà 
=
àà 
new
àà !
List
àà" &
<
àà& '
Material
àà' /
>
àà/ 0
(
àà0 1
)
àà1 2
;
àà2 3"
AccumulateMeshesInfo
ää  
(
ää  !
meshes
ãã 
,
ãã 
offset
åå 
,
åå 
ref
çç 
vertices
çç 
,
çç 
ref
éé 
faces
éé 
,
éé 
ref
èè 
autoUvFaces
èè 
,
èè 
ref
êê 
sharedVertices
êê !
,
êê! "
ref
ëë 
sharedTextures
ëë !
,
ëë! "
ref
íí 
materialMap
íí 
)
ìì 
;
ìì 
var
ïï 
res
ïï 
=
ïï #
SplitByMaxVertexCount
ïï +
(
ïï+ ,
vertices
ïï, 4
,
ïï4 5
faces
ïï6 ;
,
ïï; <
sharedVertices
ïï= K
,
ïïK L
sharedTextures
ïïM [
)
ïï[ \
;
ïï\ ]
var
ññ 
pivot
ññ 
=
ññ 
meshes
ññ 
.
ññ 
LastOrDefault
ññ ,
(
ññ, -
)
ññ- .
.
ññ. /
	transform
ññ/ 8
.
ññ8 9
position
ññ9 A
;
ññA B
foreach
òò 
(
òò 
var
òò 
m
òò 
in
òò 
res
òò !
)
òò! "
{
ôô 
m
öö 
.
öö 
renderer
öö 
.
öö 
sharedMaterials
öö *
=
öö+ ,
materialMap
öö- 8
.
öö8 9
ToArray
öö9 @
(
öö@ A
)
ööA B
;
ööB C!
InternalMeshUtility
õõ #
.
õõ# $(
FilterUnusedSubmeshIndexes
õõ$ >
(
õõ> ?
m
õõ? @
)
õõ@ A
;
õõA B
m
úú 
.
úú 
SetPivot
úú 
(
úú 
pivot
úú  
)
úú  !
;
úú! "
	UVEditing
ùù 
.
ùù .
 SetAutoAndAlignUnwrapParamsToUVs
ùù :
(
ùù: ;
m
ùù; <
,
ùù< =
autoUvFaces
ùù> I
)
ùùI J
;
ùùJ K
}
üü 
return
°° 
res
°° 
;
°° 
}
¢¢ 	
static
§§ 
void
§§ "
AccumulateMeshesInfo
§§ (
(
§§( )
IEnumerable
•• 
<
•• 
ProBuilderMesh
•• *
>
••* +
meshes
••, 2
,
••2 3
int
¶¶ 
offset
¶¶ 
,
¶¶ 
ref
ßß 
List
ßß 
<
ßß 
Vertex
ßß 
>
ßß  
vertices
ßß! )
,
ßß) *
ref
®® 
List
®® 
<
®® 
Face
®® 
>
®® 
faces
®® $
,
®®$ %
ref
©© 
List
©© 
<
©© 
Face
©© 
>
©© 
autoUvFaces
©© *
,
©©* +
ref
™™ 
List
™™ 
<
™™ 
SharedVertex
™™ %
>
™™% &
sharedVertices
™™' 5
,
™™5 6
ref
´´ 
List
´´ 
<
´´ 
SharedVertex
´´ %
>
´´% &
sharedTextures
´´' 5
,
´´5 6
ref
¨¨ 
List
¨¨ 
<
¨¨ 
Material
¨¨ !
>
¨¨! "
materialMap
¨¨# .
,
¨¨. /
	Transform
≠≠ 
targetTransform
≠≠ )
=
≠≠* +
null
≠≠, 0
)
ÆÆ 
{
ØØ 	
foreach
∞∞ 
(
∞∞ 
var
∞∞ 
mesh
∞∞ 
in
∞∞  
meshes
∞∞! '
)
∞∞' (
{
±± 
var
≤≤ 
meshVertexCount
≤≤ #
=
≤≤$ %
mesh
≤≤& *
.
≤≤* +
vertexCount
≤≤+ 6
;
≤≤6 7
var
≥≥ 
	transform
≥≥ 
=
≥≥ 
mesh
≥≥  $
.
≥≥$ %
	transform
≥≥% .
;
≥≥. /
var
¥¥ 
meshVertices
¥¥  
=
¥¥! "
mesh
¥¥# '
.
¥¥' (
GetVertices
¥¥( 3
(
¥¥3 4
)
¥¥4 5
;
¥¥5 6
var
µµ 
	meshFaces
µµ 
=
µµ 
mesh
µµ  $
.
µµ$ %
facesInternal
µµ% 2
;
µµ2 3
var
∂∂  
meshSharedVertices
∂∂ &
=
∂∂' (
mesh
∂∂) -
.
∂∂- .
sharedVertices
∂∂. <
;
∂∂< =
var
∑∑  
meshSharedTextures
∑∑ &
=
∑∑' (
mesh
∑∑) -
.
∑∑- .
sharedTextures
∑∑. <
;
∑∑< =
var
∏∏ 
	materials
∏∏ 
=
∏∏ 
mesh
∏∏  $
.
∏∏$ %
renderer
∏∏% -
.
∏∏- .
sharedMaterials
∏∏. =
;
∏∏= >
var
ππ 
materialCount
ππ !
=
ππ" #
	materials
ππ$ -
.
ππ- .
Length
ππ. 4
;
ππ4 5
for
ªª 
(
ªª 
int
ªª 
i
ªª 
=
ªª 
$num
ªª 
;
ªª 
i
ªª  !
<
ªª" #
meshVertexCount
ªª$ 3
;
ªª3 4
i
ªª5 6
++
ªª6 8
)
ªª8 9
{
ºº 
var
ΩΩ 
worldVertex
ΩΩ #
=
ΩΩ$ %
	transform
ΩΩ& /
.
ΩΩ/ 0
TransformVertex
ΩΩ0 ?
(
ΩΩ? @
meshVertices
ΩΩ@ L
[
ΩΩL M
i
ΩΩM N
]
ΩΩN O
)
ΩΩO P
;
ΩΩP Q
if
ææ 
(
ææ 
targetTransform
ææ '
!=
ææ( *
null
ææ+ /
)
ææ/ 0
vertices
øø  
.
øø  !
Add
øø! $
(
øø$ %
targetTransform
øø% 4
.
øø4 5$
InverseTransformVertex
øø5 K
(
øøK L
worldVertex
øøL W
)
øøW X
)
øøX Y
;
øøY Z
else
¿¿ 
vertices
¡¡  
.
¡¡  !
Add
¡¡! $
(
¡¡$ %
worldVertex
¡¡% 0
)
¡¡0 1
;
¡¡1 2
}
¬¬ 
foreach
ƒƒ 
(
ƒƒ 
var
ƒƒ 
face
ƒƒ !
in
ƒƒ" $
	meshFaces
ƒƒ% .
)
ƒƒ. /
{
≈≈ 
var
∆∆ 
newFace
∆∆ 
=
∆∆  !
new
∆∆" %
Face
∆∆& *
(
∆∆* +
face
∆∆+ /
)
∆∆/ 0
;
∆∆0 1
newFace
«« 
.
«« 
ShiftIndexes
«« (
(
««( )
offset
««) /
)
««/ 0
;
««0 1
if
   
(
   
!
   
newFace
    
.
    !
manualUV
  ! )
&&
  * ,
!
  - .
newFace
  . 5
.
  5 6
uv
  6 8
.
  8 9
useWorldSpace
  9 F
)
  F G
{
ÀÀ 
newFace
ÃÃ 
.
ÃÃ  
manualUV
ÃÃ  (
=
ÃÃ) *
true
ÃÃ+ /
;
ÃÃ/ 0
autoUvFaces
ÕÕ #
.
ÕÕ# $
Add
ÕÕ$ '
(
ÕÕ' (
newFace
ÕÕ( /
)
ÕÕ/ 0
;
ÕÕ0 1
}
ŒŒ 
var
œœ 
material
œœ  
=
œœ! "
	materials
œœ# ,
[
œœ, -
Math
œœ- 1
.
œœ1 2
Clamp
œœ2 7
(
œœ7 8
face
œœ8 <
.
œœ< =
submeshIndex
œœ= I
,
œœI J
$num
œœK L
,
œœL M
materialCount
œœN [
-
œœ\ ]
$num
œœ^ _
)
œœ_ `
]
œœ` a
;
œœa b
var
–– 
submeshIndex
–– $
=
––% &
materialMap
––' 2
.
––2 3
IndexOf
––3 :
(
––: ;
material
––; C
)
––C D
;
––D E
if
““ 
(
““ 
submeshIndex
““ $
>
““% &
-
““' (
$num
““( )
)
““) *
{
”” 
newFace
‘‘ 
.
‘‘  
submeshIndex
‘‘  ,
=
‘‘- .
submeshIndex
‘‘/ ;
;
‘‘; <
}
’’ 
else
÷÷ 
{
◊◊ 
if
ÿÿ 
(
ÿÿ 
material
ÿÿ $
==
ÿÿ% '
null
ÿÿ( ,
)
ÿÿ, -
{
ŸŸ 
newFace
⁄⁄ #
.
⁄⁄# $
submeshIndex
⁄⁄$ 0
=
⁄⁄1 2
$num
⁄⁄3 4
;
⁄⁄4 5
}
€€ 
else
‹‹ 
{
›› 
newFace
ﬁﬁ #
.
ﬁﬁ# $
submeshIndex
ﬁﬁ$ 0
=
ﬁﬁ1 2
materialMap
ﬁﬁ3 >
.
ﬁﬁ> ?
Count
ﬁﬁ? D
;
ﬁﬁD E
materialMap
ﬂﬂ '
.
ﬂﬂ' (
Add
ﬂﬂ( +
(
ﬂﬂ+ ,
material
ﬂﬂ, 4
)
ﬂﬂ4 5
;
ﬂﬂ5 6
}
‡‡ 
}
·· 
faces
„„ 
.
„„ 
Add
„„ 
(
„„ 
newFace
„„ %
)
„„% &
;
„„& '
}
‰‰ 
foreach
ÊÊ 
(
ÊÊ 
var
ÊÊ 
sv
ÊÊ 
in
ÊÊ  " 
meshSharedVertices
ÊÊ# 5
)
ÊÊ5 6
{
ÁÁ 
var
ËË 
nsv
ËË 
=
ËË 
new
ËË !
SharedVertex
ËË" .
(
ËË. /
sv
ËË/ 1
)
ËË1 2
;
ËË2 3
nsv
ÈÈ 
.
ÈÈ 
ShiftIndexes
ÈÈ $
(
ÈÈ$ %
offset
ÈÈ% +
)
ÈÈ+ ,
;
ÈÈ, -
sharedVertices
ÍÍ "
.
ÍÍ" #
Add
ÍÍ# &
(
ÍÍ& '
nsv
ÍÍ' *
)
ÍÍ* +
;
ÍÍ+ ,
}
ÎÎ 
foreach
ÌÌ 
(
ÌÌ 
var
ÌÌ 
st
ÌÌ 
in
ÌÌ  " 
meshSharedTextures
ÌÌ# 5
)
ÌÌ5 6
{
ÓÓ 
var
ÔÔ 
nst
ÔÔ 
=
ÔÔ 
new
ÔÔ !
SharedVertex
ÔÔ" .
(
ÔÔ. /
st
ÔÔ/ 1
)
ÔÔ1 2
;
ÔÔ2 3
nst
 
.
 
ShiftIndexes
 $
(
$ %
offset
% +
)
+ ,
;
, -
sharedTextures
ÒÒ "
.
ÒÒ" #
Add
ÒÒ# &
(
ÒÒ& '
nst
ÒÒ' *
)
ÒÒ* +
;
ÒÒ+ ,
}
ÚÚ 
offset
ÙÙ 
+=
ÙÙ 
meshVertexCount
ÙÙ )
;
ÙÙ) *
}
ıı 
}
ˆˆ 	
static
¯¯ 
ProBuilderMesh
¯¯ !
CreateMeshFromSplit
¯¯ 1
(
¯¯1 2
List
¯¯2 6
<
¯¯6 7
Vertex
¯¯7 =
>
¯¯= >
vertices
¯¯? G
,
¯¯G H
List
˘˘ 
<
˘˘ 
Face
˘˘ 
>
˘˘ 
faces
˘˘ 
,
˘˘ 

Dictionary
˙˙ 
<
˙˙ 
int
˙˙ 
,
˙˙ 
int
˙˙ 
>
˙˙   
sharedVertexLookup
˙˙! 3
,
˙˙3 4

Dictionary
˚˚ 
<
˚˚ 
int
˚˚ 
,
˚˚ 
int
˚˚ 
>
˚˚  !
sharedTextureLookup
˚˚! 4
,
˚˚4 5

Dictionary
¸¸ 
<
¸¸ 
int
¸¸ 
,
¸¸ 
int
¸¸ 
>
¸¸  
remap
¸¸! &
,
¸¸& '
Material
˝˝ 
[
˝˝ 
]
˝˝ 
	materials
˝˝  
)
˝˝  !
{
˛˛ 	
var
ÄÄ 
sv
ÄÄ 
=
ÄÄ 
new
ÄÄ 

Dictionary
ÄÄ #
<
ÄÄ# $
int
ÄÄ$ '
,
ÄÄ' (
int
ÄÄ) ,
>
ÄÄ, -
(
ÄÄ- .
)
ÄÄ. /
;
ÄÄ/ 0
var
ÅÅ 
st
ÅÅ 
=
ÅÅ 
new
ÅÅ 

Dictionary
ÅÅ #
<
ÅÅ# $
int
ÅÅ$ '
,
ÅÅ' (
int
ÅÅ) ,
>
ÅÅ, -
(
ÅÅ- .
)
ÅÅ. /
;
ÅÅ/ 0
foreach
ÉÉ 
(
ÉÉ 
var
ÉÉ 
f
ÉÉ 
in
ÉÉ 
faces
ÉÉ #
)
ÉÉ# $
{
ÑÑ 
for
ÖÖ 
(
ÖÖ 
int
ÖÖ 
i
ÖÖ 
=
ÖÖ 
$num
ÖÖ 
,
ÖÖ 
c
ÖÖ  !
=
ÖÖ" #
f
ÖÖ$ %
.
ÖÖ% &
indexesInternal
ÖÖ& 5
.
ÖÖ5 6
Length
ÖÖ6 <
;
ÖÖ< =
i
ÖÖ> ?
<
ÖÖ@ A
c
ÖÖB C
;
ÖÖC D
i
ÖÖE F
++
ÖÖF H
)
ÖÖH I
f
ÜÜ 
.
ÜÜ 
indexesInternal
ÜÜ %
[
ÜÜ% &
i
ÜÜ& '
]
ÜÜ' (
=
ÜÜ) *
remap
ÜÜ+ 0
[
ÜÜ0 1
f
ÜÜ1 2
.
ÜÜ2 3
indexesInternal
ÜÜ3 B
[
ÜÜB C
i
ÜÜC D
]
ÜÜD E
]
ÜÜE F
;
ÜÜF G
f
àà 
.
àà 
InvalidateCache
àà !
(
àà! "
)
àà" #
;
àà# $
}
ââ 
foreach
ãã 
(
ãã 
var
ãã 
kvp
ãã 
in
ãã 
remap
ãã  %
)
ãã% &
{
åå 
int
çç 
v
çç 
;
çç 
if
èè 
(
èè  
sharedVertexLookup
èè &
.
èè& '
TryGetValue
èè' 2
(
èè2 3
kvp
èè3 6
.
èè6 7
Key
èè7 :
,
èè: ;
out
èè< ?
v
èè@ A
)
èèA B
)
èèB C
sv
êê 
.
êê 
Add
êê 
(
êê 
kvp
êê 
.
êê 
Value
êê $
,
êê$ %
v
êê& '
)
êê' (
;
êê( )
if
íí 
(
íí !
sharedTextureLookup
íí '
.
íí' (
TryGetValue
íí( 3
(
íí3 4
kvp
íí4 7
.
íí7 8
Key
íí8 ;
,
íí; <
out
íí= @
v
ííA B
)
ííB C
)
ííC D
st
ìì 
.
ìì 
Add
ìì 
(
ìì 
kvp
ìì 
.
ìì 
Value
ìì $
,
ìì$ %
v
ìì& '
)
ìì' (
;
ìì( )
}
îî 
return
ññ 
ProBuilderMesh
ññ !
.
ññ! "
Create
ññ" (
(
ññ( )
vertices
óó 
,
óó 
faces
òò 
,
òò 
SharedVertex
ôô 
.
ôô 
ToSharedVertices
ôô -
(
ôô- .
sv
ôô. 0
)
ôô0 1
,
ôô1 2
st
öö 
.
öö 
Any
öö 
(
öö 
)
öö 
?
öö 
SharedVertex
öö '
.
öö' (
ToSharedVertices
öö( 8
(
öö8 9
st
öö9 ;
)
öö; <
:
öö= >
null
öö? C
,
ööC D
	materials
õõ 
)
õõ 
;
õõ 
}
úú 	
internal
¢¢ 
static
¢¢ 
List
¢¢ 
<
¢¢ 
ProBuilderMesh
¢¢ +
>
¢¢+ ,#
SplitByMaxVertexCount
¢¢- B
(
¢¢B C
IList
¢¢C H
<
¢¢H I
Vertex
¢¢I O
>
¢¢O P
vertices
¢¢Q Y
,
¢¢Y Z
IList
¢¢[ `
<
¢¢` a
Face
¢¢a e
>
¢¢e f
faces
¢¢g l
,
¢¢l m
IList
¢¢n s
<
¢¢s t
SharedVertex¢¢t Ä
>¢¢Ä Å
sharedVertices¢¢Ç ê
,¢¢ê ë
IList¢¢í ó
<¢¢ó ò
SharedVertex¢¢ò §
>¢¢§ •
sharedTextures¢¢¶ ¥
,¢¢¥ µ
uint¢¢∂ ∫
maxVertexCount¢¢ª …
=¢¢  À
ProBuilderMesh¢¢Ã ⁄
.¢¢⁄ €
maxVertexCount¢¢€ È
)¢¢È Í
{
££ 	
uint
§§ 
vertexCount
§§ 
=
§§ 
(
§§  
uint
§§  $
)
§§$ %
vertices
§§% -
.
§§- .
Count
§§. 3
;
§§3 4
uint
•• 
	meshCount
•• 
=
•• 
System
•• #
.
••# $
Math
••$ (
.
••( )
Max
••) ,
(
••, -
$num
••- /
,
••/ 0
vertexCount
••1 <
/
••= >
maxVertexCount
••? M
)
••M N
;
••N O
var
¶¶ 
submeshCount
¶¶ 
=
¶¶ 
faces
¶¶ $
.
¶¶$ %
Max
¶¶% (
(
¶¶( )
x
¶¶) *
=>
¶¶+ -
x
¶¶. /
.
¶¶/ 0
submeshIndex
¶¶0 <
)
¶¶< =
+
¶¶> ?
$num
¶¶@ A
;
¶¶A B
if
®® 
(
®® 
	meshCount
®® 
<
®® 
$num
®® 
)
®® 
return
©© 
new
©© 
List
©© 
<
©©  
ProBuilderMesh
©©  .
>
©©. /
(
©©/ 0
)
©©0 1
{
©©2 3
ProBuilderMesh
©©4 B
.
©©B C
Create
©©C I
(
©©I J
vertices
©©J R
,
©©R S
faces
©©T Y
,
©©Y Z
sharedVertices
©©[ i
,
©©i j
sharedTextures
©©k y
,
©©y z
new
©©{ ~
Material©© á
[©©á à
submeshCount©©à î
]©©î ï
)©©ï ñ
}©©ó ò
;©©ò ô
var
´´  
sharedVertexLookup
´´ "
=
´´# $
new
´´% (

Dictionary
´´) 3
<
´´3 4
int
´´4 7
,
´´7 8
int
´´9 <
>
´´< =
(
´´= >
)
´´> ?
;
´´? @
SharedVertex
¨¨ 
.
¨¨ #
GetSharedVertexLookup
¨¨ .
(
¨¨. /
sharedVertices
¨¨/ =
,
¨¨= > 
sharedVertexLookup
¨¨? Q
)
¨¨Q R
;
¨¨R S
var
ÆÆ !
sharedTextureLookup
ÆÆ #
=
ÆÆ$ %
new
ÆÆ& )

Dictionary
ÆÆ* 4
<
ÆÆ4 5
int
ÆÆ5 8
,
ÆÆ8 9
int
ÆÆ: =
>
ÆÆ= >
(
ÆÆ> ?
)
ÆÆ? @
;
ÆÆ@ A
SharedVertex
ØØ 
.
ØØ #
GetSharedVertexLookup
ØØ .
(
ØØ. /
sharedTextures
ØØ/ =
,
ØØ= >!
sharedTextureLookup
ØØ? R
)
ØØR S
;
ØØS T
var
±± 
meshes
±± 
=
±± 
new
±± 
List
±± !
<
±±! "
ProBuilderMesh
±±" 0
>
±±0 1
(
±±1 2
)
±±2 3
;
±±3 4
var
≤≤ 
mv
≤≤ 
=
≤≤ 
new
≤≤ 
List
≤≤ 
<
≤≤ 
Vertex
≤≤ $
>
≤≤$ %
(
≤≤% &
)
≤≤& '
;
≤≤' (
var
≥≥ 
mf
≥≥ 
=
≥≥ 
new
≥≥ 
List
≥≥ 
<
≥≥ 
Face
≥≥ "
>
≥≥" #
(
≥≥# $
)
≥≥$ %
;
≥≥% &
var
¥¥ 
remap
¥¥ 
=
¥¥ 
new
¥¥ 

Dictionary
¥¥ &
<
¥¥& '
int
¥¥' *
,
¥¥* +
int
¥¥, /
>
¥¥/ 0
(
¥¥0 1
)
¥¥1 2
;
¥¥2 3
foreach
∂∂ 
(
∂∂ 
var
∂∂ 
face
∂∂ 
in
∂∂  
faces
∂∂! &
)
∂∂& '
{
∑∑ 
if
∏∏ 
(
∏∏ 
mv
∏∏ 
.
∏∏ 
Count
∏∏ 
+
∏∏ 
face
∏∏ #
.
∏∏# $
distinctIndexes
∏∏$ 3
.
∏∏3 4
Count
∏∏4 9
>
∏∏: ;
maxVertexCount
∏∏< J
)
∏∏J K
{
ππ 
meshes
ªª 
.
ªª 
Add
ªª 
(
ªª !
CreateMeshFromSplit
ªª 2
(
ªª2 3
mv
ªª3 5
,
ªª5 6
mf
ªª7 9
,
ªª9 : 
sharedVertexLookup
ªª; M
,
ªªM N!
sharedTextureLookup
ªªO b
,
ªªb c
remap
ªªd i
,
ªªi j
new
ªªk n
Material
ªªo w
[
ªªw x
submeshCountªªx Ñ
]ªªÑ Ö
)ªªÖ Ü
)ªªÜ á
;ªªá à
mv
ºº 
.
ºº 
Clear
ºº 
(
ºº 
)
ºº 
;
ºº 
mf
ΩΩ 
.
ΩΩ 
Clear
ΩΩ 
(
ΩΩ 
)
ΩΩ 
;
ΩΩ 
remap
ææ 
.
ææ 
Clear
ææ 
(
ææ  
)
ææ  !
;
ææ! "
}
øø 
foreach
¡¡ 
(
¡¡ 
int
¡¡ 
i
¡¡ 
in
¡¡ !
face
¡¡" &
.
¡¡& '
distinctIndexes
¡¡' 6
)
¡¡6 7
{
¬¬ 
mv
√√ 
.
√√ 
Add
√√ 
(
√√ 
vertices
√√ #
[
√√# $
i
√√$ %
]
√√% &
)
√√& '
;
√√' (
remap
ƒƒ 
.
ƒƒ 
Add
ƒƒ 
(
ƒƒ 
i
ƒƒ 
,
ƒƒ  
mv
ƒƒ! #
.
ƒƒ# $
Count
ƒƒ$ )
-
ƒƒ* +
$num
ƒƒ, -
)
ƒƒ- .
;
ƒƒ. /
}
≈≈ 
mf
«« 
.
«« 
Add
«« 
(
«« 
face
«« 
)
«« 
;
«« 
}
»» 
if
   
(
   
mv
   
.
   
Any
   
(
   
)
   
)
   
meshes
ÀÀ 
.
ÀÀ 
Add
ÀÀ 
(
ÀÀ !
CreateMeshFromSplit
ÀÀ .
(
ÀÀ. /
mv
ÀÀ/ 1
,
ÀÀ1 2
mf
ÀÀ3 5
,
ÀÀ5 6 
sharedVertexLookup
ÀÀ7 I
,
ÀÀI J!
sharedTextureLookup
ÀÀK ^
,
ÀÀ^ _
remap
ÀÀ` e
,
ÀÀe f
new
ÀÀg j
Material
ÀÀk s
[
ÀÀs t
submeshCountÀÀt Ä
]ÀÀÄ Å
)ÀÀÅ Ç
)ÀÀÇ É
;ÀÀÉ Ñ
return
ÕÕ 
meshes
ÕÕ 
;
ÕÕ 
}
ŒŒ 	
}
œœ 
}–– –ë
ûD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\InternalMeshUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
static		 

class		 
InternalMeshUtility		 $
{

 
internal 
static 
Vector3 $
AverageNormalWithIndexes  8
(8 9
SharedVertex9 E
sharedF L
,L M
intN Q
[Q R
]R S
allT W
,W X
IListY ^
<^ _
Vector3_ f
>f g
normh l
)l m
{ 	
Vector3 
n 
= 
Vector3 
.  
zero  $
;$ %
int 
count 
= 
$num 
; 
for 
( 
int 
i 
= 
$num 
; 
i 
< 
all  #
.# $
Length$ *
;* +
i, -
++- /
)/ 0
{ 
if 
( 
shared 
. 
Contains #
(# $
all$ '
[' (
i( )
]) *
)* +
)+ ,
{ 
n 
+= 
norm 
[ 
all !
[! "
i" #
]# $
]$ %
;% &
count 
++ 
; 
} 
} 
return 
( 
n 
/ 
( 
float 
) 
count $
)$ %
;% &
} 	
public$$ 
static$$ 
ProBuilderMesh$$ $#
CreateMeshWithTransform$$% <
($$< =
	Transform$$= F
t$$G H
,$$H I
bool$$J N
preserveFaces$$O \
)$$\ ]
{%% 	
Mesh&& 
m&& 
=&& 
t&& 
.&& 
GetComponent&& #
<&&# $

MeshFilter&&$ .
>&&. /
(&&/ 0
)&&0 1
.&&1 2

sharedMesh&&2 <
;&&< =
Vector3(( 
[(( 
](( 

m_vertices((  
=((! "
MeshUtility((# .
.((. /
GetMeshChannel((/ =
(((= >
t((> ?
.((? @

gameObject((@ J
,((J K
x((L M
=>((N P
x((Q R
.((R S
vertices((S [
)(([ \
;((\ ]
Color)) 
[)) 
])) 
m_colors)) 
=)) 
MeshUtility)) *
.))* +
GetMeshChannel))+ 9
())9 :
t)): ;
.)); <

gameObject))< F
,))F G
x))H I
=>))J L
x))M N
.))N O
colors))O U
)))U V
;))V W
Vector2** 
[** 
]** 
m_uvs** 
=** 
MeshUtility** )
.**) *
GetMeshChannel*** 8
(**8 9
t**9 :
.**: ;

gameObject**; E
,**E F
x**G H
=>**I K
x**L M
.**M N
uv**N P
)**P Q
;**Q R
List,, 
<,, 
Vector3,, 
>,, 
verts,, 
=,,  !
preserveFaces,," /
?,,0 1
new,,2 5
List,,6 :
<,,: ;
Vector3,,; B
>,,B C
(,,C D
m,,D E
.,,E F
vertices,,F N
),,N O
:,,P Q
new,,R U
List,,V Z
<,,Z [
Vector3,,[ b
>,,b c
(,,c d
),,d e
;,,e f
List-- 
<-- 
Color-- 
>-- 
cols-- 
=-- 
preserveFaces-- ,
?--- .
new--/ 2
List--3 7
<--7 8
Color--8 =
>--= >
(--> ?
m--? @
.--@ A
colors--A G
)--G H
:--I J
new--K N
List--O S
<--S T
Color--T Y
>--Y Z
(--Z [
)--[ \
;--\ ]
List.. 
<.. 
Vector2.. 
>.. 
uvs.. 
=.. 
preserveFaces..  -
?... /
new..0 3
List..4 8
<..8 9
Vector2..9 @
>..@ A
(..A B
m..B C
...C D
uv..D F
)..F G
:..H I
new..J M
List..N R
<..R S
Vector2..S Z
>..Z [
(..[ \
)..\ ]
;..] ^
List// 
<// 
Face// 
>// 
faces// 
=// 
new// "
List//# '
<//' (
Face//( ,
>//, -
(//- .
)//. /
;/// 0
for11 
(11 
int11 
n11 
=11 
$num11 
;11 
n11 
<11 
m11  !
.11! "
subMeshCount11" .
;11. /
n110 1
++111 3
)113 4
{22 
int33 
[33 
]33 
tris33 
=33 
m33 
.33 
GetTriangles33 +
(33+ ,
n33, -
)33- .
;33. /
for55 
(55 
int55 
i55 
=55 
$num55 
;55 
i55  !
<55" #
tris55$ (
.55( )
Length55) /
;55/ 0
i551 2
+=553 5
$num556 7
)557 8
{66 
int77 
index77 
=77 
-77  !
$num77! "
;77" #
if88 
(88 
preserveFaces88 %
)88% &
{99 
for:: 
(:: 
int::  
j::! "
=::# $
$num::% &
;::& '
j::( )
<::* +
faces::, 1
.::1 2
Count::2 7
;::7 8
j::9 :
++::: <
)::< =
{;; 
if<< 
(<<  
faces<<  %
[<<% &
j<<& '
]<<' (
.<<( )#
distinctIndexesInternal<<) @
.<<@ A
Contains<<A I
(<<I J
tris<<J N
[<<N O
i<<O P
+<<Q R
$num<<S T
]<<T U
)<<U V
||<<W Y
faces==  %
[==% &
j==& '
]==' (
.==( )#
distinctIndexesInternal==) @
.==@ A
Contains==A I
(==I J
tris==J N
[==N O
i==O P
+==Q R
$num==S T
]==T U
)==U V
||==W Y
faces>>  %
[>>% &
j>>& '
]>>' (
.>>( )#
distinctIndexesInternal>>) @
.>>@ A
Contains>>A I
(>>I J
tris>>J N
[>>N O
i>>O P
+>>Q R
$num>>S T
]>>T U
)>>U V
)>>V W
{?? 
index@@  %
=@@& '
j@@( )
;@@) *
breakAA  %
;AA% &
}BB 
}CC 
}DD 
ifFF 
(FF 
indexFF 
>FF 
-FF  !
$numFF! "
&&FF# %
preserveFacesFF& 3
)FF3 4
{GG 
intHH 
lenHH 
=HH  !
facesHH" '
[HH' (
indexHH( -
]HH- .
.HH. /
indexesInternalHH/ >
.HH> ?
LengthHH? E
;HHE F
intII 
[II 
]II 
arrII !
=II" #
newII$ '
intII( +
[II+ ,
lenII, /
+II0 1
$numII2 3
]II3 4
;II4 5
SystemJJ 
.JJ 
ArrayJJ $
.JJ$ %
CopyJJ% )
(JJ) *
facesJJ* /
[JJ/ 0
indexJJ0 5
]JJ5 6
.JJ6 7
indexesInternalJJ7 F
,JJF G
$numJJH I
,JJI J
arrJJK N
,JJN O
$numJJP Q
,JJQ R
lenJJS V
)JJV W
;JJW X
arrKK 
[KK 
lenKK 
+KK  !
$numKK" #
]KK# $
=KK% &
trisKK' +
[KK+ ,
iKK, -
+KK. /
$numKK0 1
]KK1 2
;KK2 3
arrLL 
[LL 
lenLL 
+LL  !
$numLL" #
]LL# $
=LL% &
trisLL' +
[LL+ ,
iLL, -
+LL. /
$numLL0 1
]LL1 2
;LL2 3
arrMM 
[MM 
lenMM 
+MM  !
$numMM" #
]MM# $
=MM% &
trisMM' +
[MM+ ,
iMM, -
+MM. /
$numMM0 1
]MM1 2
;MM2 3
facesNN 
[NN 
indexNN #
]NN# $
.NN$ %
indexesInternalNN% 4
=NN5 6
arrNN7 :
;NN: ;
}OO 
elsePP 
{QQ 
intRR 
[RR 
]RR 
faceTrisRR &
;RR& '
ifTT 
(TT 
preserveFacesTT )
)TT) *
{UU 
faceTrisVV $
=VV% &
newVV' *
intVV+ .
[VV. /
$numVV/ 0
]VV0 1
{WW 
trisXX  $
[XX$ %
iXX% &
+XX' (
$numXX) *
]XX* +
,XX+ ,
trisYY  $
[YY$ %
iYY% &
+YY' (
$numYY) *
]YY* +
,YY+ ,
trisZZ  $
[ZZ$ %
iZZ% &
+ZZ' (
$numZZ) *
]ZZ* +
}[[ 
;[[ 
}\\ 
else]] 
{^^ 
verts__ !
.__! "
Add__" %
(__% &

m_vertices__& 0
[__0 1
tris__1 5
[__5 6
i__6 7
+__8 9
$num__: ;
]__; <
]__< =
)__= >
;__> ?
verts`` !
.``! "
Add``" %
(``% &

m_vertices``& 0
[``0 1
tris``1 5
[``5 6
i``6 7
+``8 9
$num``: ;
]``; <
]``< =
)``= >
;``> ?
vertsaa !
.aa! "
Addaa" %
(aa% &

m_verticesaa& 0
[aa0 1
trisaa1 5
[aa5 6
iaa6 7
+aa8 9
$numaa: ;
]aa; <
]aa< =
)aa= >
;aa> ?
colscc  
.cc  !
Addcc! $
(cc$ %
m_colorscc% -
!=cc. 0
nullcc1 5
?cc6 7
m_colorscc8 @
[cc@ A
trisccA E
[ccE F
iccF G
+ccH I
$numccJ K
]ccK L
]ccL M
:ccN O
ColorccP U
.ccU V
whiteccV [
)cc[ \
;cc\ ]
colsdd  
.dd  !
Adddd! $
(dd$ %
m_colorsdd% -
!=dd. 0
nulldd1 5
?dd6 7
m_colorsdd8 @
[dd@ A
trisddA E
[ddE F
iddF G
+ddH I
$numddJ K
]ddK L
]ddL M
:ddN O
ColorddP U
.ddU V
whiteddV [
)dd[ \
;dd\ ]
colsee  
.ee  !
Addee! $
(ee$ %
m_colorsee% -
!=ee. 0
nullee1 5
?ee6 7
m_colorsee8 @
[ee@ A
triseeA E
[eeE F
ieeF G
+eeH I
$numeeJ K
]eeK L
]eeL M
:eeN O
ColoreeP U
.eeU V
whiteeeV [
)ee[ \
;ee\ ]
uvsgg 
.gg  
Addgg  #
(gg# $
m_uvsgg$ )
[gg) *
trisgg* .
[gg. /
igg/ 0
+gg1 2
$numgg3 4
]gg4 5
]gg5 6
)gg6 7
;gg7 8
uvshh 
.hh  
Addhh  #
(hh# $
m_uvshh$ )
[hh) *
trishh* .
[hh. /
ihh/ 0
+hh1 2
$numhh3 4
]hh4 5
]hh5 6
)hh6 7
;hh7 8
uvsii 
.ii  
Addii  #
(ii# $
m_uvsii$ )
[ii) *
trisii* .
[ii. /
iii/ 0
+ii1 2
$numii3 4
]ii4 5
]ii5 6
)ii6 7
;ii7 8
faceTriskk $
=kk% &
newkk' *
intkk+ .
[kk. /
$numkk/ 0
]kk0 1
{kk2 3
ikk4 5
+kk6 7
$numkk8 9
,kk9 :
ikk; <
+kk= >
$numkk? @
,kk@ A
ikkB C
+kkD E
$numkkF G
}kkH I
;kkI J
}ll 
facesnn 
.nn 
Addnn !
(nn! "
newoo 
Faceoo  $
(oo$ %
faceTrispp  (
,pp( )
nqq  !
,qq! "
AutoUnwrapSettingsrr  2
.rr2 3
tilerr3 7
,rr7 8
$numss  !
,ss! "
-tt  !
$numtt! "
,tt" #
-uu  !
$numuu! "
,uu" #
truevv  $
)ww  !
)ww! "
;ww" #
}xx 
}yy 
}zz 

GameObject|| 
go|| 
=|| 
(|| 

GameObject|| '
)||' (
Object||( .
.||. /
Instantiate||/ :
(||: ;
t||; <
.||< =

gameObject||= G
)||G H
;||H I
go}} 
.}} 
GetComponent}} 
<}} 

MeshFilter}} &
>}}& '
(}}' (
)}}( )
.}}) *

sharedMesh}}* 4
=}}5 6
null}}7 ;
;}}; <
ProBuilderMesh 
pb 
= 
go  "
." #
AddComponent# /
</ 0
ProBuilderMesh0 >
>> ?
(? @
)@ A
;A B
pb
ÄÄ 
.
ÄÄ *
RebuildWithPositionsAndFaces
ÄÄ +
(
ÄÄ+ ,
verts
ÄÄ, 1
.
ÄÄ1 2
ToArray
ÄÄ2 9
(
ÄÄ9 :
)
ÄÄ: ;
,
ÄÄ; <
faces
ÄÄ= B
.
ÄÄB C
ToArray
ÄÄC J
(
ÄÄJ K
)
ÄÄK L
)
ÄÄL M
;
ÄÄM N
pb
ÇÇ 
.
ÇÇ 
colorsInternal
ÇÇ 
=
ÇÇ 
cols
ÇÇ  $
.
ÇÇ$ %
ToArray
ÇÇ% ,
(
ÇÇ, -
)
ÇÇ- .
;
ÇÇ. /
pb
ÉÉ 
.
ÉÉ 
textures
ÉÉ 
=
ÉÉ 
uvs
ÉÉ 
;
ÉÉ 
pb
ÖÖ 
.
ÖÖ 

gameObject
ÖÖ 
.
ÖÖ 
name
ÖÖ 
=
ÖÖ  
t
ÖÖ! "
.
ÖÖ" #
name
ÖÖ# '
;
ÖÖ' (
go
áá 
.
áá 
	transform
áá 
.
áá 
position
áá !
=
áá" #
t
áá$ %
.
áá% &
position
áá& .
;
áá. /
go
àà 
.
àà 
	transform
àà 
.
àà 
localRotation
àà &
=
àà' (
t
àà) *
.
àà* +
localRotation
àà+ 8
;
àà8 9
go
ââ 
.
ââ 
	transform
ââ 
.
ââ 

localScale
ââ #
=
ââ$ %
t
ââ& '
.
ââ' (

localScale
ââ( 2
;
ââ2 3
pb
ãã 
.
ãã 
CenterPivot
ãã 
(
ãã 
null
ãã 
)
ãã  
;
ãã  !
return
çç 
pb
çç 
;
çç 
}
éé 	
public
òò 
static
òò 
bool
òò )
ResetPbObjectWithMeshFilter
òò 6
(
òò6 7
ProBuilderMesh
òò7 E
pb
òòF H
,
òòH I
bool
òòJ N
preserveFaces
òòO \
)
òò\ ]
{
ôô 	

MeshFilter
öö 
mf
öö 
=
öö 
pb
öö 
.
öö 

gameObject
öö )
.
öö) *
GetComponent
öö* 6
<
öö6 7

MeshFilter
öö7 A
>
ööA B
(
ööB C
)
ööC D
;
ööD E
if
úú 
(
úú 
mf
úú 
==
úú 
null
úú 
||
úú 
mf
úú  
.
úú  !

sharedMesh
úú! +
==
úú, .
null
úú/ 3
)
úú3 4
{
ùù 
Log
ûû 
.
ûû 
Error
ûû 
(
ûû 
pb
ûû 
.
ûû 
name
ûû !
+
ûû" #
$str
ûû$ U
)
ûûU V
;
ûûV W
return
üü 
false
üü 
;
üü 
}
†† 
Mesh
¢¢ 
m
¢¢ 
=
¢¢ 
mf
¢¢ 
.
¢¢ 

sharedMesh
¢¢ "
;
¢¢" #
int
§§ 
vertexCount
§§ 
=
§§ 
m
§§ 
.
§§  
vertexCount
§§  +
;
§§+ ,
Vector3
•• 
[
•• 
]
•• 
m_positions
•• !
=
••" #
MeshUtility
••$ /
.
••/ 0
GetMeshChannel
••0 >
<
••> ?
Vector3
••? F
[
••F G
]
••G H
>
••H I
(
••I J
pb
••J L
.
••L M

gameObject
••M W
,
••W X
x
••Y Z
=>
••[ ]
x
••^ _
.
••_ `
vertices
••` h
)
••h i
;
••i j
Color
¶¶ 
[
¶¶ 
]
¶¶ 
m_colors
¶¶ 
=
¶¶ 
MeshUtility
¶¶ *
.
¶¶* +
GetMeshChannel
¶¶+ 9
<
¶¶9 :
Color
¶¶: ?
[
¶¶? @
]
¶¶@ A
>
¶¶A B
(
¶¶B C
pb
¶¶C E
.
¶¶E F

gameObject
¶¶F P
,
¶¶P Q
x
¶¶R S
=>
¶¶T V
x
¶¶W X
.
¶¶X Y
colors
¶¶Y _
)
¶¶_ `
;
¶¶` a
Vector2
ßß 
[
ßß 
]
ßß 
m_uvs
ßß 
=
ßß 
MeshUtility
ßß )
.
ßß) *
GetMeshChannel
ßß* 8
<
ßß8 9
Vector2
ßß9 @
[
ßß@ A
]
ßßA B
>
ßßB C
(
ßßC D
pb
ßßD F
.
ßßF G

gameObject
ßßG Q
,
ßßQ R
x
ßßS T
=>
ßßU W
x
ßßX Y
.
ßßY Z
uv
ßßZ \
)
ßß\ ]
;
ßß] ^
List
©© 
<
©© 
Vector3
©© 
>
©© 
verts
©© 
=
©©  !
preserveFaces
©©" /
?
©©0 1
new
©©2 5
List
©©6 :
<
©©: ;
Vector3
©©; B
>
©©B C
(
©©C D
m
©©D E
.
©©E F
vertices
©©F N
)
©©N O
:
©©P Q
new
©©R U
List
©©V Z
<
©©Z [
Vector3
©©[ b
>
©©b c
(
©©c d
)
©©d e
;
©©e f
List
™™ 
<
™™ 
Color
™™ 
>
™™ 
cols
™™ 
=
™™ 
preserveFaces
™™ ,
?
™™- .
new
™™/ 2
List
™™3 7
<
™™7 8
Color
™™8 =
>
™™= >
(
™™> ?
m
™™? @
.
™™@ A
colors
™™A G
)
™™G H
:
™™I J
new
™™K N
List
™™O S
<
™™S T
Color
™™T Y
>
™™Y Z
(
™™Z [
)
™™[ \
;
™™\ ]
List
´´ 
<
´´ 
Vector2
´´ 
>
´´ 
uvs
´´ 
=
´´ 
preserveFaces
´´  -
?
´´. /
new
´´0 3
List
´´4 8
<
´´8 9
Vector2
´´9 @
>
´´@ A
(
´´A B
m
´´B C
.
´´C D
uv
´´D F
)
´´F G
:
´´H I
new
´´J M
List
´´N R
<
´´R S
Vector2
´´S Z
>
´´Z [
(
´´[ \
)
´´\ ]
;
´´] ^
List
¨¨ 
<
¨¨ 
Face
¨¨ 
>
¨¨ 
faces
¨¨ 
=
¨¨ 
new
¨¨ "
List
¨¨# '
<
¨¨' (
Face
¨¨( ,
>
¨¨, -
(
¨¨- .
)
¨¨. /
;
¨¨/ 0
MeshRenderer
ÆÆ 
mr
ÆÆ 
=
ÆÆ 
pb
ÆÆ  
.
ÆÆ  !

gameObject
ÆÆ! +
.
ÆÆ+ ,
GetComponent
ÆÆ, 8
<
ÆÆ8 9
MeshRenderer
ÆÆ9 E
>
ÆÆE F
(
ÆÆF G
)
ÆÆG H
;
ÆÆH I
if
ØØ 
(
ØØ 
mr
ØØ 
==
ØØ 
null
ØØ 
)
ØØ 
mr
ØØ 
=
ØØ  
pb
ØØ! #
.
ØØ# $

gameObject
ØØ$ .
.
ØØ. /
AddComponent
ØØ/ ;
<
ØØ; <
MeshRenderer
ØØ< H
>
ØØH I
(
ØØI J
)
ØØJ K
;
ØØK L
Material
±± 
[
±± 
]
±± 
sharedMaterials
±± &
=
±±' (
mr
±±) +
.
±±+ ,
sharedMaterials
±±, ;
;
±±; <
int
≤≤ 

mat_length
≤≤ 
=
≤≤ 
sharedMaterials
≤≤ ,
.
≤≤, -
Length
≤≤- 3
;
≤≤3 4
for
¥¥ 
(
¥¥ 
int
¥¥ 
n
¥¥ 
=
¥¥ 
$num
¥¥ 
;
¥¥ 
n
¥¥ 
<
¥¥ 
m
¥¥  !
.
¥¥! "
subMeshCount
¥¥" .
;
¥¥. /
n
¥¥0 1
++
¥¥1 3
)
¥¥3 4
{
µµ 
int
∂∂ 
[
∂∂ 
]
∂∂ 
tris
∂∂ 
=
∂∂ 
m
∂∂ 
.
∂∂ 
GetTriangles
∂∂ +
(
∂∂+ ,
n
∂∂, -
)
∂∂- .
;
∂∂. /
for
∑∑ 
(
∑∑ 
int
∑∑ 
i
∑∑ 
=
∑∑ 
$num
∑∑ 
;
∑∑ 
i
∑∑  !
<
∑∑" #
tris
∑∑$ (
.
∑∑( )
Length
∑∑) /
;
∑∑/ 0
i
∑∑1 2
+=
∑∑3 5
$num
∑∑6 7
)
∑∑7 8
{
∏∏ 
int
ππ 
index
ππ 
=
ππ 
-
ππ  !
$num
ππ! "
;
ππ" #
if
∫∫ 
(
∫∫ 
preserveFaces
∫∫ %
)
∫∫% &
{
ªª 
for
ºº 
(
ºº 
int
ºº  
j
ºº! "
=
ºº# $
$num
ºº% &
;
ºº& '
j
ºº( )
<
ºº* +
faces
ºº, 1
.
ºº1 2
Count
ºº2 7
;
ºº7 8
j
ºº9 :
++
ºº: <
)
ºº< =
{
ΩΩ 
if
ææ 
(
ææ  
faces
ææ  %
[
ææ% &
j
ææ& '
]
ææ' (
.
ææ( )%
distinctIndexesInternal
ææ) @
.
ææ@ A
Contains
ææA I
(
ææI J
tris
ææJ N
[
ææN O
i
ææO P
+
ææQ R
$num
ææS T
]
ææT U
)
ææU V
||
ææW Y
faces
øø  %
[
øø% &
j
øø& '
]
øø' (
.
øø( )%
distinctIndexesInternal
øø) @
.
øø@ A
Contains
øøA I
(
øøI J
tris
øøJ N
[
øøN O
i
øøO P
+
øøQ R
$num
øøS T
]
øøT U
)
øøU V
||
øøW Y
faces
¿¿  %
[
¿¿% &
j
¿¿& '
]
¿¿' (
.
¿¿( )%
distinctIndexesInternal
¿¿) @
.
¿¿@ A
Contains
¿¿A I
(
¿¿I J
tris
¿¿J N
[
¿¿N O
i
¿¿O P
+
¿¿Q R
$num
¿¿S T
]
¿¿T U
)
¿¿U V
)
¿¿V W
{
¡¡ 
index
¬¬  %
=
¬¬& '
j
¬¬( )
;
¬¬) *
break
√√  %
;
√√% &
}
ƒƒ 
}
≈≈ 
}
∆∆ 
if
»» 
(
»» 
index
»» 
>
»» 
-
»»  !
$num
»»! "
&&
»»# %
preserveFaces
»»& 3
)
»»3 4
{
…… 
int
   
len
   
=
    !
faces
  " '
[
  ' (
index
  ( -
]
  - .
.
  . /
indexesInternal
  / >
.
  > ?
Length
  ? E
;
  E F
int
ÀÀ 
[
ÀÀ 
]
ÀÀ 
arr
ÀÀ !
=
ÀÀ" #
new
ÀÀ$ '
int
ÀÀ( +
[
ÀÀ+ ,
len
ÀÀ, /
+
ÀÀ0 1
$num
ÀÀ2 3
]
ÀÀ3 4
;
ÀÀ4 5
System
ÃÃ 
.
ÃÃ 
Array
ÃÃ $
.
ÃÃ$ %
Copy
ÃÃ% )
(
ÃÃ) *
faces
ÃÃ* /
[
ÃÃ/ 0
index
ÃÃ0 5
]
ÃÃ5 6
.
ÃÃ6 7
indexesInternal
ÃÃ7 F
,
ÃÃF G
$num
ÃÃH I
,
ÃÃI J
arr
ÃÃK N
,
ÃÃN O
$num
ÃÃP Q
,
ÃÃQ R
len
ÃÃS V
)
ÃÃV W
;
ÃÃW X
arr
ÕÕ 
[
ÕÕ 
len
ÕÕ 
+
ÕÕ  !
$num
ÕÕ" #
]
ÕÕ# $
=
ÕÕ% &
tris
ÕÕ' +
[
ÕÕ+ ,
i
ÕÕ, -
+
ÕÕ. /
$num
ÕÕ0 1
]
ÕÕ1 2
;
ÕÕ2 3
arr
ŒŒ 
[
ŒŒ 
len
ŒŒ 
+
ŒŒ  !
$num
ŒŒ" #
]
ŒŒ# $
=
ŒŒ% &
tris
ŒŒ' +
[
ŒŒ+ ,
i
ŒŒ, -
+
ŒŒ. /
$num
ŒŒ0 1
]
ŒŒ1 2
;
ŒŒ2 3
arr
œœ 
[
œœ 
len
œœ 
+
œœ  !
$num
œœ" #
]
œœ# $
=
œœ% &
tris
œœ' +
[
œœ+ ,
i
œœ, -
+
œœ. /
$num
œœ0 1
]
œœ1 2
;
œœ2 3
faces
–– 
[
–– 
index
–– #
]
––# $
.
––$ %
indexesInternal
––% 4
=
––5 6
arr
––7 :
;
––: ;
}
—— 
else
““ 
{
”” 
int
‘‘ 
[
‘‘ 
]
‘‘ 
faceTris
‘‘ &
;
‘‘& '
if
÷÷ 
(
÷÷ 
preserveFaces
÷÷ )
)
÷÷) *
{
◊◊ 
faceTris
ÿÿ $
=
ÿÿ% &
new
ÿÿ' *
int
ÿÿ+ .
[
ÿÿ. /
$num
ÿÿ/ 0
]
ÿÿ0 1
{
ŸŸ 
tris
⁄⁄  $
[
⁄⁄$ %
i
⁄⁄% &
+
⁄⁄' (
$num
⁄⁄) *
]
⁄⁄* +
,
⁄⁄+ ,
tris
€€  $
[
€€$ %
i
€€% &
+
€€' (
$num
€€) *
]
€€* +
,
€€+ ,
tris
‹‹  $
[
‹‹$ %
i
‹‹% &
+
‹‹' (
$num
‹‹) *
]
‹‹* +
}
›› 
;
›› 
}
ﬁﬁ 
else
ﬂﬂ 
{
‡‡ 
verts
·· !
.
··! "
Add
··" %
(
··% &
m_positions
··& 1
[
··1 2
tris
··2 6
[
··6 7
i
··7 8
+
··9 :
$num
··; <
]
··< =
]
··= >
)
··> ?
;
··? @
verts
‚‚ !
.
‚‚! "
Add
‚‚" %
(
‚‚% &
m_positions
‚‚& 1
[
‚‚1 2
tris
‚‚2 6
[
‚‚6 7
i
‚‚7 8
+
‚‚9 :
$num
‚‚; <
]
‚‚< =
]
‚‚= >
)
‚‚> ?
;
‚‚? @
verts
„„ !
.
„„! "
Add
„„" %
(
„„% &
m_positions
„„& 1
[
„„1 2
tris
„„2 6
[
„„6 7
i
„„7 8
+
„„9 :
$num
„„; <
]
„„< =
]
„„= >
)
„„> ?
;
„„? @
cols
ÂÂ  
.
ÂÂ  !
Add
ÂÂ! $
(
ÂÂ$ %
m_colors
ÂÂ% -
!=
ÂÂ. 0
null
ÂÂ1 5
&&
ÂÂ6 8
m_colors
ÂÂ9 A
.
ÂÂA B
Length
ÂÂB H
==
ÂÂI K
vertexCount
ÂÂL W
?
ÂÂX Y
m_colors
ÂÂZ b
[
ÂÂb c
tris
ÂÂc g
[
ÂÂg h
i
ÂÂh i
+
ÂÂj k
$num
ÂÂl m
]
ÂÂm n
]
ÂÂn o
:
ÂÂp q
Color
ÂÂr w
.
ÂÂw x
white
ÂÂx }
)
ÂÂ} ~
;
ÂÂ~ 
cols
ÊÊ  
.
ÊÊ  !
Add
ÊÊ! $
(
ÊÊ$ %
m_colors
ÊÊ% -
!=
ÊÊ. 0
null
ÊÊ1 5
&&
ÊÊ6 8
m_colors
ÊÊ9 A
.
ÊÊA B
Length
ÊÊB H
==
ÊÊI K
vertexCount
ÊÊL W
?
ÊÊX Y
m_colors
ÊÊZ b
[
ÊÊb c
tris
ÊÊc g
[
ÊÊg h
i
ÊÊh i
+
ÊÊj k
$num
ÊÊl m
]
ÊÊm n
]
ÊÊn o
:
ÊÊp q
Color
ÊÊr w
.
ÊÊw x
white
ÊÊx }
)
ÊÊ} ~
;
ÊÊ~ 
cols
ÁÁ  
.
ÁÁ  !
Add
ÁÁ! $
(
ÁÁ$ %
m_colors
ÁÁ% -
!=
ÁÁ. 0
null
ÁÁ1 5
&&
ÁÁ6 8
m_colors
ÁÁ9 A
.
ÁÁA B
Length
ÁÁB H
==
ÁÁI K
vertexCount
ÁÁL W
?
ÁÁX Y
m_colors
ÁÁZ b
[
ÁÁb c
tris
ÁÁc g
[
ÁÁg h
i
ÁÁh i
+
ÁÁj k
$num
ÁÁl m
]
ÁÁm n
]
ÁÁn o
:
ÁÁp q
Color
ÁÁr w
.
ÁÁw x
white
ÁÁx }
)
ÁÁ} ~
;
ÁÁ~ 
uvs
ÈÈ 
.
ÈÈ  
Add
ÈÈ  #
(
ÈÈ# $
m_uvs
ÈÈ$ )
[
ÈÈ) *
tris
ÈÈ* .
[
ÈÈ. /
i
ÈÈ/ 0
+
ÈÈ1 2
$num
ÈÈ3 4
]
ÈÈ4 5
]
ÈÈ5 6
)
ÈÈ6 7
;
ÈÈ7 8
uvs
ÍÍ 
.
ÍÍ  
Add
ÍÍ  #
(
ÍÍ# $
m_uvs
ÍÍ$ )
[
ÍÍ) *
tris
ÍÍ* .
[
ÍÍ. /
i
ÍÍ/ 0
+
ÍÍ1 2
$num
ÍÍ3 4
]
ÍÍ4 5
]
ÍÍ5 6
)
ÍÍ6 7
;
ÍÍ7 8
uvs
ÎÎ 
.
ÎÎ  
Add
ÎÎ  #
(
ÎÎ# $
m_uvs
ÎÎ$ )
[
ÎÎ) *
tris
ÎÎ* .
[
ÎÎ. /
i
ÎÎ/ 0
+
ÎÎ1 2
$num
ÎÎ3 4
]
ÎÎ4 5
]
ÎÎ5 6
)
ÎÎ6 7
;
ÎÎ7 8
faceTris
ÌÌ $
=
ÌÌ% &
new
ÌÌ' *
int
ÌÌ+ .
[
ÌÌ. /
$num
ÌÌ/ 0
]
ÌÌ0 1
{
ÌÌ2 3
i
ÌÌ4 5
+
ÌÌ6 7
$num
ÌÌ8 9
,
ÌÌ9 :
i
ÌÌ; <
+
ÌÌ= >
$num
ÌÌ? @
,
ÌÌ@ A
i
ÌÌB C
+
ÌÌD E
$num
ÌÌF G
}
ÌÌH I
;
ÌÌI J
}
ÓÓ 
faces
 
.
 
Add
 !
(
! "
new
ÒÒ 
Face
ÒÒ  $
(
ÒÒ$ %
faceTris
ÚÚ  (
,
ÚÚ( )
Math
ÛÛ  $
.
ÛÛ$ %
Clamp
ÛÛ% *
(
ÛÛ* +
n
ÛÛ+ ,
,
ÛÛ, -
$num
ÛÛ. /
,
ÛÛ/ 0

mat_length
ÛÛ1 ;
-
ÛÛ< =
$num
ÛÛ> ?
)
ÛÛ? @
,
ÛÛ@ A 
AutoUnwrapSettings
ÙÙ  2
.
ÙÙ2 3
tile
ÙÙ3 7
,
ÙÙ7 8
$num
ıı  !
,
ıı! "
-
ˆˆ  !
$num
ˆˆ! "
,
ˆˆ" #
-
˜˜  !
$num
˜˜! "
,
˜˜" #
true
¯¯  $
)
˘˘  !
)
˘˘! "
;
˘˘" #
}
˙˙ 
}
˚˚ 
}
¸¸ 
pb
˛˛ 
.
˛˛ 
positionsInternal
˛˛  
=
˛˛! "
verts
˛˛# (
.
˛˛( )
ToArray
˛˛) 0
(
˛˛0 1
)
˛˛1 2
;
˛˛2 3
pb
ˇˇ 
.
ˇˇ 
texturesInternal
ˇˇ 
=
ˇˇ  !
uvs
ˇˇ" %
.
ˇˇ% &
ToArray
ˇˇ& -
(
ˇˇ- .
)
ˇˇ. /
;
ˇˇ/ 0
pb
ÄÄ 
.
ÄÄ 
facesInternal
ÄÄ 
=
ÄÄ 
faces
ÄÄ $
.
ÄÄ$ %
ToArray
ÄÄ% ,
(
ÄÄ, -
)
ÄÄ- .
;
ÄÄ. /
pb
ÅÅ 
.
ÅÅ $
sharedVerticesInternal
ÅÅ %
=
ÅÅ& '
SharedVertex
ÅÅ( 4
.
ÅÅ4 5,
GetSharedVerticesWithPositions
ÅÅ5 S
(
ÅÅS T
verts
ÅÅT Y
.
ÅÅY Z
ToArray
ÅÅZ a
(
ÅÅa b
)
ÅÅb c
)
ÅÅc d
;
ÅÅd e
pb
ÇÇ 
.
ÇÇ 
colorsInternal
ÇÇ 
=
ÇÇ 
cols
ÇÇ  $
.
ÇÇ$ %
ToArray
ÇÇ% ,
(
ÇÇ, -
)
ÇÇ- .
;
ÇÇ. /
return
ÑÑ 
true
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
internal
áá 
static
áá 
void
áá (
FilterUnusedSubmeshIndexes
áá 7
(
áá7 8
ProBuilderMesh
áá8 F
mesh
ááG K
)
ááK L
{
àà 	
var
ââ 
	materials
ââ 
=
ââ 
mesh
ââ  
.
ââ  !
renderer
ââ! )
.
ââ) *
sharedMaterials
ââ* 9
;
ââ9 :
var
ää 
submeshCount
ää 
=
ää 
	materials
ää (
.
ää( )
Length
ää) /
;
ää/ 0
var
ãã 
used
ãã 
=
ãã 
new
ãã 
bool
ãã 
[
ãã  
submeshCount
ãã  ,
]
ãã, -
;
ãã- .
foreach
çç 
(
çç 
var
çç 
face
çç 
in
çç  
mesh
çç! %
.
çç% &
facesInternal
çç& 3
)
çç3 4
used
éé 
[
éé 
Math
éé 
.
éé 
Clamp
éé 
(
éé  
face
éé  $
.
éé$ %
submeshIndex
éé% 1
,
éé1 2
$num
éé3 4
,
éé4 5
submeshCount
éé6 B
-
ééC D
$num
ééE F
)
ééF G
]
ééG H
=
ééI J
true
ééK O
;
ééO P
var
êê 
unused
êê 
=
êê 
ArrUtil
êê  
.
êê  !
AllIndexesOf
êê! -
(
êê- .
used
êê. 2
,
êê2 3
x
êê4 5
=>
êê6 8
!
êê9 :
x
êê: ;
)
êê; <
;
êê< =
if
íí 
(
íí 
unused
íí 
.
íí 
Any
íí 
(
íí 
)
íí 
)
íí 
{
ìì 
foreach
îî 
(
îî 
var
îî 
face
îî !
in
îî" $
mesh
îî% )
.
îî) *
facesInternal
îî* 7
)
îî7 8
{
ïï 
var
ññ 
original
ññ  
=
ññ! "
face
ññ# '
.
ññ' (
submeshIndex
ññ( 4
;
ññ4 5
foreach
óó 
(
óó 
var
óó  
index
óó! &
in
óó' )
unused
óó* 0
)
óó0 1
if
òò 
(
òò 
original
òò $
>
òò% &
index
òò' ,
)
òò, -
face
ôô  
.
ôô  !
submeshIndex
ôô! -
--
ôô- /
;
ôô/ 0
}
öö 
mesh
úú 
.
úú 
renderer
úú 
.
úú 
sharedMaterials
úú -
=
úú. /
ArrUtil
úú0 7
.
úú7 8
RemoveAt
úú8 @
(
úú@ A
	materials
úúA J
,
úúJ K
unused
úúL R
)
úúR S
;
úúS T
}
ùù 
}
ûû 	
}
üü 
}†† Õ
ÑD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Log.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ 
Flags 

]
 
enum 
LogLevel	 
{ 
None 
= 
$num 
, 
Error 
= 
$num 
, 
Warning 
= 
$num 
, 
Info 
= 
$num 
, 
Default 
= 
Error 
| 
Warning %
,% &
All 
= 
$num 
} 
[ 
Flags 

]
 
enum 
	LogOutput	 
{   
None!! 
=!! 
$num!! 
,!! 
Console"" 
="" 
$num"" 
,"" 
File## 
=## 
$num## 
,## 
}$$ 
static,, 

class,, 
Log,, 
{-- 
public.. 
const.. 
string.. #
k_ProBuilderLogFileName.. 3
=..4 5
$str..6 I
;..I J
static11 
Stack11 
<11 
LogLevel11 
>11 

s_logStack11 )
=11* +
new11, /
Stack110 5
<115 6
LogLevel116 >
>11> ?
(11? @
)11@ A
;11A B
static44 
LogLevel44 

s_LogLevel44 "
=44# $
LogLevel44% -
.44- .
All44. 1
;441 2
static77 
	LogOutput77 
s_Output77 !
=77" #
	LogOutput77$ -
.77- .
Console77. 5
;775 6
static:: 
string:: 
s_LogFilePath:: #
=::$ %#
k_ProBuilderLogFileName::& =
;::= >
public@@ 
static@@ 
void@@ 
PushLogLevel@@ '
(@@' (
LogLevel@@( 0
level@@1 6
)@@6 7
{AA 	

s_logStackBB 
.BB 
PushBB 
(BB 

s_LogLevelBB &
)BB& '
;BB' (

s_LogLevelCC 
=CC 
levelCC 
;CC 
}DD 	
publicII 
staticII 
voidII 
PopLogLevelII &
(II& '
)II' (
{JJ 	

s_LogLevelKK 
=KK 

s_logStackKK #
.KK# $
PopKK$ '
(KK' (
)KK( )
;KK) *
}LL 	
publicRR 
staticRR 
voidRR 
SetLogLevelRR &
(RR& '
LogLevelRR' /
levelRR0 5
)RR5 6
{SS 	

s_LogLevelTT 
=TT 
levelTT 
;TT 
}UU 	
public\\ 
static\\ 
void\\ 
	SetOutput\\ $
(\\$ %
	LogOutput\\% .
output\\/ 5
)\\5 6
{]] 	
s_Output^^ 
=^^ 
output^^ 
;^^ 
}__ 	
publicee 
staticee 
voidee 

SetLogFileee %
(ee% &
stringee& ,
pathee- 1
)ee1 2
{ff 	
s_LogFilePathgg 
=gg 
pathgg  
;gg  !
}hh 	
[pp 	
Conditionalpp	 
(pp 
$strpp 
)pp 
]pp 
publicqq 
staticqq 
voidqq 
Debugqq  
<qq  !
Tqq! "
>qq" #
(qq# $
Tqq$ %
valueqq& +
)qq+ ,
{rr 	
Debugss 
(ss 
valuess 
.ss 
ToStringss  
(ss  !
)ss! "
)ss" #
;ss# $
}tt 	
[}} 	
Conditional}}	 
(}} 
$str}} 
)}} 
]}} 
public~~ 
static~~ 
void~~ 
Debug~~  
(~~  !
string~~! '
message~~( /
)~~/ 0
{ 	
DoPrint
ÄÄ 
(
ÄÄ 
message
ÄÄ 
,
ÄÄ 
LogType
ÄÄ $
.
ÄÄ$ %
Log
ÄÄ% (
)
ÄÄ( )
;
ÄÄ) *
}
ÅÅ 	
[
ÉÉ 	
Conditional
ÉÉ	 
(
ÉÉ 
$str
ÉÉ 
)
ÉÉ 
]
ÉÉ 
public
ÑÑ 
static
ÑÑ 
void
ÑÑ 
Debug
ÑÑ  
(
ÑÑ  !
string
ÑÑ! '
format
ÑÑ( .
,
ÑÑ. /
params
ÑÑ0 6
object
ÑÑ7 =
[
ÑÑ= >
]
ÑÑ> ?
values
ÑÑ@ F
)
ÑÑF G
{
ÖÖ 	
Debug
ÜÜ 
(
ÜÜ 
string
ÜÜ 
.
ÜÜ 
Format
ÜÜ 
(
ÜÜ  
format
ÜÜ  &
,
ÜÜ& '
values
ÜÜ( .
)
ÜÜ. /
)
ÜÜ/ 0
;
ÜÜ0 1
}
áá 	
public
éé 
static
éé 
void
éé 
Info
éé 
(
éé  
string
éé  &
format
éé' -
,
éé- .
params
éé/ 5
object
éé6 <
[
éé< =
]
éé= >
values
éé? E
)
ééE F
{
èè 	
Info
êê 
(
êê 
string
êê 
.
êê 
Format
êê 
(
êê 
format
êê %
,
êê% &
values
êê' -
)
êê- .
)
êê. /
;
êê/ 0
}
ëë 	
public
ìì 
static
ìì 
void
ìì 
Info
ìì 
(
ìì  
string
ìì  &
message
ìì' .
)
ìì. /
{
îî 	
if
ïï 
(
ïï 
(
ïï 

s_LogLevel
ïï 
&
ïï 
LogLevel
ïï &
.
ïï& '
Info
ïï' +
)
ïï+ ,
>
ïï- .
$num
ïï/ 0
)
ïï0 1
DoPrint
ññ 
(
ññ 
message
ññ 
,
ññ  
LogType
ññ! (
.
ññ( )
Log
ññ) ,
)
ññ, -
;
ññ- .
}
óó 	
public
ûû 
static
ûû 
void
ûû 
Warning
ûû "
(
ûû" #
string
ûû# )
format
ûû* 0
,
ûû0 1
params
ûû2 8
object
ûû9 ?
[
ûû? @
]
ûû@ A
values
ûûB H
)
ûûH I
{
üü 	
Warning
†† 
(
†† 
string
†† 
.
†† 
Format
†† !
(
††! "
format
††" (
,
††( )
values
††* 0
)
††0 1
)
††1 2
;
††2 3
}
°° 	
public
££ 
static
££ 
void
££ 
Warning
££ "
(
££" #
string
££# )
message
££* 1
)
££1 2
{
§§ 	
if
•• 
(
•• 
(
•• 

s_LogLevel
•• 
&
•• 
LogLevel
•• &
.
••& '
Warning
••' .
)
••. /
>
••0 1
$num
••2 3
)
••3 4
DoPrint
¶¶ 
(
¶¶ 
message
¶¶ 
,
¶¶  
LogType
¶¶! (
.
¶¶( )
Warning
¶¶) 0
)
¶¶0 1
;
¶¶1 2
}
ßß 	
public
ÆÆ 
static
ÆÆ 
void
ÆÆ 
Error
ÆÆ  
(
ÆÆ  !
string
ÆÆ! '
format
ÆÆ( .
,
ÆÆ. /
params
ÆÆ0 6
object
ÆÆ7 =
[
ÆÆ= >
]
ÆÆ> ?
values
ÆÆ@ F
)
ÆÆF G
{
ØØ 	
Error
∞∞ 
(
∞∞ 
string
∞∞ 
.
∞∞ 
Format
∞∞ 
(
∞∞  
format
∞∞  &
,
∞∞& '
values
∞∞( .
)
∞∞. /
)
∞∞/ 0
;
∞∞0 1
}
±± 	
public
≥≥ 
static
≥≥ 
void
≥≥ 
Error
≥≥  
(
≥≥  !
string
≥≥! '
message
≥≥( /
)
≥≥/ 0
{
¥¥ 	
if
µµ 
(
µµ 
(
µµ 

s_LogLevel
µµ 
&
µµ 
LogLevel
µµ &
.
µµ& '
Error
µµ' ,
)
µµ, -
>
µµ. /
$num
µµ0 1
)
µµ1 2
DoPrint
∂∂ 
(
∂∂ 
message
∂∂ 
,
∂∂  
LogType
∂∂! (
.
∂∂( )
Error
∂∂) .
)
∂∂. /
;
∂∂/ 0
}
∑∑ 	
[
¿¿ 	
Conditional
¿¿	 
(
¿¿ 
$str
¿¿ *
)
¿¿* +
]
¿¿+ ,
internal
¡¡ 
static
¡¡ 
void
¡¡ 
Watch
¡¡ "
<
¡¡" #
T
¡¡# $
,
¡¡$ %
K
¡¡& '
>
¡¡' (
(
¡¡( )
T
¡¡) *
key
¡¡+ .
,
¡¡. /
K
¡¡0 1
value
¡¡2 7
)
¡¡7 8
{
¬¬ 	
UnityEngine
√√ 
.
√√ 
Debug
√√ 
.
√√ 
Log
√√ !
(
√√! "
string
√√" (
.
√√( )
Format
√√) /
(
√√/ 0
$str
√√0 i
,
√√i j
key
√√k n
.
√√n o
ToString
√√o w
(
√√w x
)
√√x y
,
√√y z
value√√{ Ä
.√√Ä Å
ToString√√Å â
(√√â ä
)√√ä ã
)√√ã å
)√√å ç
;√√ç é
}
ƒƒ 	
static
∆∆ 
void
∆∆ 
DoPrint
∆∆ 
(
∆∆ 
string
∆∆ "
message
∆∆# *
,
∆∆* +
LogType
∆∆, 3
type
∆∆4 8
)
∆∆8 9
{
«« 	
if
»» 
(
»» 
(
»» 
s_Output
»» 
&
»» 
	LogOutput
»» %
.
»»% &
Console
»»& -
)
»»- .
>
»»/ 0
$num
»»1 2
)
»»2 3
PrintToConsole
…… 
(
…… 
message
…… &
,
……& '
type
……( ,
)
……, -
;
……- .
if
ÀÀ 
(
ÀÀ 
(
ÀÀ 
s_Output
ÀÀ 
&
ÀÀ 
	LogOutput
ÀÀ %
.
ÀÀ% &
File
ÀÀ& *
)
ÀÀ* +
>
ÀÀ, -
$num
ÀÀ. /
)
ÀÀ/ 0
PrintToFile
ÃÃ 
(
ÃÃ 
message
ÃÃ #
,
ÃÃ# $
s_LogFilePath
ÃÃ% 2
)
ÃÃ2 3
;
ÃÃ3 4
}
ÕÕ 	
static
‘‘ 
void
‘‘ 
PrintToFile
‘‘ 
(
‘‘  
string
‘‘  &
message
‘‘' .
,
‘‘. /
string
‘‘0 6
path
‘‘7 ;
)
‘‘; <
{
’’ 	
if
÷÷ 
(
÷÷ 
string
÷÷ 
.
÷÷ 
IsNullOrEmpty
÷÷ $
(
÷÷$ %
path
÷÷% )
)
÷÷) *
)
÷÷* +
return
◊◊ 
;
◊◊ 
string
ŸŸ 
	full_path
ŸŸ 
=
ŸŸ 
Path
ŸŸ #
.
ŸŸ# $
GetFullPath
ŸŸ$ /
(
ŸŸ/ 0
path
ŸŸ0 4
)
ŸŸ4 5
;
ŸŸ5 6
if
€€ 
(
€€ 
string
€€ 
.
€€ 
IsNullOrEmpty
€€ $
(
€€$ %
	full_path
€€% .
)
€€. /
)
€€/ 0
{
‹‹ 
Log
›› 
.
›› 
PrintToConsole
›› "
(
››" #
$str
››# 8
+
››9 :
	full_path
››; D
)
››D E
;
››E F
return
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 
if
·· 
(
·· 
!
·· 
File
·· 
.
·· 
Exists
·· 
(
·· 
	full_path
·· &
)
··& '
)
··' (
{
‚‚ 
string
„„ 
	directory
„„  
=
„„! "
Path
„„# '
.
„„' (
GetDirectoryName
„„( 8
(
„„8 9
	full_path
„„9 B
)
„„B C
;
„„C D
if
ÂÂ 
(
ÂÂ 
string
ÂÂ 
.
ÂÂ 
IsNullOrEmpty
ÂÂ (
(
ÂÂ( )
	directory
ÂÂ) 2
)
ÂÂ2 3
)
ÂÂ3 4
{
ÊÊ 
Log
ÁÁ 
.
ÁÁ 
PrintToConsole
ÁÁ &
(
ÁÁ& '
$str
ÁÁ' <
+
ÁÁ= >
	full_path
ÁÁ? H
)
ÁÁH I
;
ÁÁI J
return
ËË 
;
ËË 
}
ÈÈ 
	Directory
ÎÎ 
.
ÎÎ 
CreateDirectory
ÎÎ )
(
ÎÎ) *
	directory
ÎÎ* 3
)
ÎÎ3 4
;
ÎÎ4 5
using
ÌÌ 
(
ÌÌ 
StreamWriter
ÌÌ #
sw
ÌÌ$ &
=
ÌÌ' (
File
ÌÌ) -
.
ÌÌ- .

CreateText
ÌÌ. 8
(
ÌÌ8 9
	full_path
ÌÌ9 B
)
ÌÌB C
)
ÌÌC D
{
ÓÓ 
sw
ÔÔ 
.
ÔÔ 
	WriteLine
ÔÔ  
(
ÔÔ  !
message
ÔÔ! (
)
ÔÔ( )
;
ÔÔ) *
}
 
}
ÒÒ 
else
ÚÚ 
{
ÛÛ 
using
ÙÙ 
(
ÙÙ 
StreamWriter
ÙÙ #
sw
ÙÙ$ &
=
ÙÙ' (
File
ÙÙ) -
.
ÙÙ- .

AppendText
ÙÙ. 8
(
ÙÙ8 9
	full_path
ÙÙ9 B
)
ÙÙB C
)
ÙÙC D
{
ıı 
sw
˜˜ 
.
˜˜ 
	WriteLine
˜˜  
(
˜˜  !
message
˜˜! (
)
˜˜( )
;
˜˜) *
}
¯¯ 
}
˘˘ 
}
˙˙ 	
public
ˇˇ 
static
ˇˇ 
void
ˇˇ 
ClearLogFile
ˇˇ '
(
ˇˇ' (
)
ˇˇ( )
{
ÄÄ 	
if
ÅÅ 
(
ÅÅ 
File
ÅÅ 
.
ÅÅ 
Exists
ÅÅ 
(
ÅÅ 
s_LogFilePath
ÅÅ )
)
ÅÅ) *
)
ÅÅ* +
File
ÇÇ 
.
ÇÇ 
Delete
ÇÇ 
(
ÇÇ 
s_LogFilePath
ÇÇ )
)
ÇÇ) *
;
ÇÇ* +
}
ÉÉ 	
static
ää 
void
ää 
PrintToConsole
ää "
(
ää" #
string
ää# )
message
ää* 1
,
ää1 2
LogType
ää3 :
type
ää; ?
=
ää@ A
LogType
ääB I
.
ääI J
Log
ääJ M
)
ääM N
{
ãã 	
if
åå 
(
åå 
type
åå 
==
åå 
LogType
åå 
.
åå  
Log
åå  #
)
åå# $
UnityEngine
çç 
.
çç 
Debug
çç !
.
çç! "
Log
çç" %
(
çç% &
message
çç& -
)
çç- .
;
çç. /
else
éé 
if
éé 
(
éé 
type
éé 
==
éé 
LogType
éé $
.
éé$ %
Warning
éé% ,
)
éé, -
UnityEngine
èè 
.
èè 
Debug
èè !
.
èè! "

LogWarning
èè" ,
(
èè, -
message
èè- 4
)
èè4 5
;
èè5 6
else
êê 
if
êê 
(
êê 
type
êê 
==
êê 
LogType
êê $
.
êê$ %
Error
êê% *
)
êê* +
UnityEngine
ëë 
.
ëë 
Debug
ëë !
.
ëë! "
LogError
ëë" *
(
ëë* +
message
ëë+ 2
)
ëë2 3
;
ëë3 4
else
íí 
if
íí 
(
íí 
type
íí 
==
íí 
LogType
íí $
.
íí$ %
Assert
íí% +
)
íí+ ,
UnityEngine
îî 
.
îî 
Debug
îî !
.
îî! "
LogAssertion
îî" .
(
îî. /
message
îî/ 6
)
îî6 7
;
îî7 8
else
òò 
UnityEngine
ôô 
.
ôô 
Debug
ôô !
.
ôô! "
Log
ôô" %
(
ôô% &
message
ôô& -
)
ôô- .
;
ôô. /
}
öö 	
internal
úú 
static
úú 
void
úú 
NotNull
úú $
<
úú$ %
T
úú% &
>
úú& '
(
úú' (
T
úú( )
obj
úú* -
,
úú- .
string
úú/ 5
message
úú6 =
)
úú= >
{
ùù 	
if
ûû 
(
ûû 
obj
ûû 
==
ûû 
null
ûû 
)
ûû 
throw
üü 
new
üü #
ArgumentNullException
üü /
(
üü/ 0
message
üü0 7
)
üü7 8
;
üü8 9
}
†† 	
}
°° 
}¢¢ Î
êD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\EntityBehaviour.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
abstract 
class 
EntityBehaviour "
:# $
MonoBehaviour% 2
{		 
[

 	
Tooltip

	 
(

 
$str

 r
)

r s
]

s t
public 
bool 
manageVisibility $
=% &
true' +
;+ ,
public 
abstract 
void 

Initialize '
(' (
)( )
;) *
public 
abstract 
void 
OnEnterPlayMode ,
(, -
)- .
;. /
public 
abstract 
void 
OnSceneLoaded *
(* +
Scene+ 0
scene1 6
,6 7
LoadSceneMode8 E
modeF J
)J K
;K L
	protected 
void 
SetMaterial "
(" #
Material# +
material, 4
)4 5
{ 	
if 
( 
GetComponent 
< 
Renderer %
>% &
(& '
)' (
)( )
GetComponent 
< 
Renderer %
>% &
(& '
)' (
.( )
sharedMaterial) 7
=8 9
material: B
;B C
else 

gameObject 
. 
AddComponent '
<' (
MeshRenderer( 4
>4 5
(5 6
)6 7
.7 8
sharedMaterial8 F
=G H
materialI Q
;Q R
} 	
} 
} ùn
íD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\VertexPositioning.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

static 
class 
VertexPositioning )
{ 
static 
List 
< 
int 
>  
s_CoincidentVertices -
=. /
new0 3
List4 8
<8 9
int9 <
>< =
(= >
)> ?
;? @
public 
static 
Vector3 
[ 
]  
VerticesInWorldSpace  4
(4 5
this5 9
ProBuilderMesh: H
meshI M
)M N
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new !
ArgumentNullException /
(/ 0
$str0 6
)6 7
;7 8
int 
len 
= 
mesh 
. 
vertexCount &
;& '
Vector3 
[ 
] 
worldPoints !
=" #
new$ '
Vector3( /
[/ 0
len0 3
]3 4
;4 5
Vector3 
[ 
] 
localPoints !
=" #
mesh$ (
.( )
positionsInternal) :
;: ;
for 
( 
int 
i 
= 
$num 
; 
i 
< 
len  #
;# $
i% &
++& (
)( )
worldPoints 
[ 
i 
] 
=  
mesh! %
.% &
	transform& /
./ 0
TransformPoint0 >
(> ?
localPoints? J
[J K
iK L
]L M
)M N
;N O
return!! 
worldPoints!! 
;!! 
}"" 	
public,, 
static,, 
void,, )
TranslateVerticesInWorldSpace,, 8
(,,8 9
this,,9 =
ProBuilderMesh,,> L
mesh,,M Q
,,,Q R
int,,S V
[,,V W
],,W X
indexes,,Y `
,,,` a
Vector3,,b i
offset,,j p
),,p q
{-- 	
if.. 
(.. 
mesh.. 
==.. 
null.. 
).. 
throw// 
new// !
ArgumentNullException// /
(/// 0
$str//0 6
)//6 7
;//7 8
mesh11 
.11 )
TranslateVerticesInWorldSpace11 .
(11. /
indexes11/ 6
,116 7
offset118 >
,11> ?
$num11@ B
,11B C
false11D I
)11I J
;11J K
}22 	
internal>> 
static>> 
void>> )
TranslateVerticesInWorldSpace>> :
(>>: ;
this>>; ?
ProBuilderMesh>>@ N
mesh>>O S
,>>S T
int?? 
[?? 
]?? 
indexes?? 
,?? 
Vector3@@ 
offset@@ 
,@@ 
floatAA 
	snapValueAA 
,AA 
boolBB 
snapAxisOnlyBB 
)BB 
{CC 	
ifDD 
(DD 
meshDD 
==DD 
nullDD 
)DD 
throwEE 
newEE !
ArgumentNullExceptionEE /
(EE/ 0
$strEE0 6
)EE6 7
;EE7 8
intGG 
iGG 
=GG 
$numGG 
;GG 
meshII 
.II !
GetCoincidentVerticesII &
(II& '
indexesII' .
,II. / 
s_CoincidentVerticesII0 D
)IID E
;IIE F
	Matrix4x4KK 
w2lKK 
=KK 
meshKK  
.KK  !
	transformKK! *
.KK* +
worldToLocalMatrixKK+ =
;KK= >
Vector3MM 
localOffsetMM 
=MM  !
w2lMM" %
*MM& '
offsetMM( .
;MM. /
Vector3OO 
[OO 
]OO 
vertsOO 
=OO 
meshOO "
.OO" #
positionsInternalOO# 4
;OO4 5
ifRR 
(RR 
MathfRR 
.RR 
AbsRR 
(RR 
	snapValueRR #
)RR# $
>RR% &
MathfRR' ,
.RR, -
EpsilonRR- 4
)RR4 5
{SS 
	Matrix4x4TT 
l2wTT 
=TT 
meshTT  $
.TT$ %
	transformTT% .
.TT. /
localToWorldMatrixTT/ A
;TTA B
varUU 
maskUU 
=UU 
snapAxisOnlyUU '
?UU( )
newUU* -
Vector3MaskUU. 9
(UU9 :
offsetUU: @
,UU@ A
MathUUB F
.UUF G
handleEpsilonUUG T
)UUT U
:UUV W
Vector3MaskUUX c
.UUc d
XYZUUd g
;UUg h
forWW 
(WW 
iWW 
=WW 
$numWW 
;WW 
iWW 
<WW  
s_CoincidentVerticesWW  4
.WW4 5
CountWW5 :
;WW: ;
iWW< =
++WW= ?
)WW? @
{XX 
varYY 
vYY 
=YY 
l2wYY 
.YY  
MultiplyPoint3x4YY  0
(YY0 1
vertsYY1 6
[YY6 7 
s_CoincidentVerticesYY7 K
[YYK L
iYYL M
]YYM N
]YYN O
+YYP Q
localOffsetYYR ]
)YY] ^
;YY^ _
vertsZZ 
[ZZ  
s_CoincidentVerticesZZ .
[ZZ. /
iZZ/ 0
]ZZ0 1
]ZZ1 2
=ZZ3 4
w2lZZ5 8
.ZZ8 9
MultiplyPoint3x4ZZ9 I
(ZZI J
ProBuilderSnappingZZJ \
.ZZ\ ]
	SnapValueZZ] f
(ZZf g
vZZg h
,ZZh i
(ZZj k
(ZZk l
Vector3ZZl s
)ZZs t
maskZZt x
)ZZx y
*ZZz {
	snapValue	ZZ| Ö
)
ZZÖ Ü
)
ZZÜ á
;
ZZá à
}[[ 
}\\ 
else]] 
{^^ 
for__ 
(__ 
i__ 
=__ 
$num__ 
;__ 
i__ 
<__  
s_CoincidentVertices__  4
.__4 5
Count__5 :
;__: ;
i__< =
++__= ?
)__? @
verts`` 
[``  
s_CoincidentVertices`` .
[``. /
i``/ 0
]``0 1
]``1 2
+=``3 5
localOffset``6 A
;``A B
}aa 
meshdd 
.dd 
positionsInternaldd "
=dd# $
vertsdd% *
;dd* +
meshee 
.ee 
meshee 
.ee 
verticesee 
=ee  
vertsee! &
;ee& '
}ff 	
publicpp 
staticpp 
voidpp 
TranslateVerticespp ,
(pp, -
thispp- 1
ProBuilderMeshpp2 @
meshppA E
,ppE F
IEnumerableppG R
<ppR S
intppS V
>ppV W
indexesppX _
,pp_ `
Vector3ppa h
offsetppi o
)ppo p
{qq 	
ifrr 
(rr 
meshrr 
==rr 
nullrr 
)rr 
throwss 
newss !
ArgumentNullExceptionss /
(ss/ 0
$strss0 6
)ss6 7
;ss7 8
meshtt 
.tt !
GetCoincidentVerticestt &
(tt& '
indexestt' .
,tt. / 
s_CoincidentVerticestt0 D
)ttD E
;ttE F%
TranslateVerticesInternaluu %
(uu% &
meshuu& *
,uu* + 
s_CoincidentVerticesuu, @
,uu@ A
offsetuuB H
)uuH I
;uuI J
}vv 	
public
ÄÄ 
static
ÄÄ 
void
ÄÄ 
TranslateVertices
ÄÄ ,
(
ÄÄ, -
this
ÄÄ- 1
ProBuilderMesh
ÄÄ2 @
mesh
ÄÄA E
,
ÄÄE F
IEnumerable
ÄÄG R
<
ÄÄR S
Edge
ÄÄS W
>
ÄÄW X
edges
ÄÄY ^
,
ÄÄ^ _
Vector3
ÄÄ` g
offset
ÄÄh n
)
ÄÄn o
{
ÅÅ 	
if
ÇÇ 
(
ÇÇ 
mesh
ÇÇ 
==
ÇÇ 
null
ÇÇ 
)
ÇÇ 
throw
ÉÉ 
new
ÉÉ #
ArgumentNullException
ÉÉ /
(
ÉÉ/ 0
$str
ÉÉ0 6
)
ÉÉ6 7
;
ÉÉ7 8
mesh
ÑÑ 
.
ÑÑ #
GetCoincidentVertices
ÑÑ &
(
ÑÑ& '
edges
ÑÑ' ,
,
ÑÑ, -"
s_CoincidentVertices
ÑÑ. B
)
ÑÑB C
;
ÑÑC D'
TranslateVerticesInternal
ÖÖ %
(
ÖÖ% &
mesh
ÖÖ& *
,
ÖÖ* +"
s_CoincidentVertices
ÖÖ, @
,
ÖÖ@ A
offset
ÖÖB H
)
ÖÖH I
;
ÖÖI J
}
ÜÜ 	
public
êê 
static
êê 
void
êê 
TranslateVertices
êê ,
(
êê, -
this
êê- 1
ProBuilderMesh
êê2 @
mesh
êêA E
,
êêE F
IEnumerable
êêG R
<
êêR S
Face
êêS W
>
êêW X
faces
êêY ^
,
êê^ _
Vector3
êê` g
offset
êêh n
)
êên o
{
ëë 	
if
íí 
(
íí 
mesh
íí 
==
íí 
null
íí 
)
íí 
throw
ìì 
new
ìì #
ArgumentNullException
ìì /
(
ìì/ 0
$str
ìì0 6
)
ìì6 7
;
ìì7 8
mesh
îî 
.
îî #
GetCoincidentVertices
îî &
(
îî& '
faces
îî' ,
,
îî, -"
s_CoincidentVertices
îî. B
)
îîB C
;
îîC D'
TranslateVerticesInternal
ïï %
(
ïï% &
mesh
ïï& *
,
ïï* +"
s_CoincidentVertices
ïï, @
,
ïï@ A
offset
ïïB H
)
ïïH I
;
ïïI J
}
ññ 	
static
òò 
void
òò '
TranslateVerticesInternal
òò -
(
òò- .
ProBuilderMesh
òò. <
mesh
òò= A
,
òòA B
IEnumerable
òòC N
<
òòN O
int
òòO R
>
òòR S
indices
òòT [
,
òò[ \
Vector3
òò] d
offset
òòe k
)
òòk l
{
ôô 	
Vector3
öö 
[
öö 
]
öö 
verts
öö 
=
öö 
mesh
öö "
.
öö" #
positionsInternal
öö# 4
;
öö4 5
for
úú 
(
úú 
int
úú 
i
úú 
=
úú 
$num
úú 
,
úú 
c
úú 
=
úú "
s_CoincidentVertices
úú  4
.
úú4 5
Count
úú5 :
;
úú: ;
i
úú< =
<
úú> ?
c
úú@ A
;
úúA B
i
úúC D
++
úúD F
)
úúF G
verts
ùù 
[
ùù "
s_CoincidentVertices
ùù *
[
ùù* +
i
ùù+ ,
]
ùù, -
]
ùù- .
+=
ùù/ 1
offset
ùù2 8
;
ùù8 9
mesh
†† 
.
†† 
mesh
†† 
.
†† 
vertices
†† 
=
††  
verts
††! &
;
††& '
}
°° 	
public
¨¨ 
static
¨¨ 
void
¨¨ %
SetSharedVertexPosition
¨¨ 2
(
¨¨2 3
this
¨¨3 7
ProBuilderMesh
¨¨8 F
mesh
¨¨G K
,
¨¨K L
int
¨¨M P 
sharedVertexHandle
¨¨Q c
,
¨¨c d
Vector3
¨¨e l
position
¨¨m u
)
¨¨u v
{
≠≠ 	
if
ÆÆ 
(
ÆÆ 
mesh
ÆÆ 
==
ÆÆ 
null
ÆÆ 
)
ÆÆ 
throw
ØØ 
new
ØØ #
ArgumentNullException
ØØ /
(
ØØ/ 0
$str
ØØ0 6
)
ØØ6 7
;
ØØ7 8
Vector3
±± 
[
±± 
]
±± 
v
±± 
=
±± 
mesh
±± 
.
±± 
positionsInternal
±± 0
;
±±0 1
foreach
≥≥ 
(
≥≥ 
var
≥≥ 
index
≥≥ 
in
≥≥ !
mesh
≥≥" &
.
≥≥& '$
sharedVerticesInternal
≥≥' =
[
≥≥= > 
sharedVertexHandle
≥≥> P
]
≥≥P Q
)
≥≥Q R
v
¥¥ 
[
¥¥ 
index
¥¥ 
]
¥¥ 
=
¥¥ 
position
¥¥ #
;
¥¥# $
mesh
∂∂ 
.
∂∂ 
positionsInternal
∂∂ "
=
∂∂# $
v
∂∂% &
;
∂∂& '
mesh
∑∑ 
.
∑∑ 
mesh
∑∑ 
.
∑∑ 
vertices
∑∑ 
=
∑∑  
v
∑∑! "
;
∑∑" #
}
∏∏ 	
internal
¬¬ 
static
¬¬ 
void
¬¬ #
SetSharedVertexValues
¬¬ 2
(
¬¬2 3
this
¬¬3 7
ProBuilderMesh
¬¬8 F
mesh
¬¬G K
,
¬¬K L
int
¬¬M P 
sharedVertexHandle
¬¬Q c
,
¬¬c d
Vertex
¬¬e k
vertex
¬¬l r
)
¬¬r s
{
√√ 	
Vertex
ƒƒ 
[
ƒƒ 
]
ƒƒ 
vertices
ƒƒ 
=
ƒƒ 
mesh
ƒƒ  $
.
ƒƒ$ %
GetVertices
ƒƒ% 0
(
ƒƒ0 1
)
ƒƒ1 2
;
ƒƒ2 3
foreach
∆∆ 
(
∆∆ 
var
∆∆ 
index
∆∆ 
in
∆∆ !
mesh
∆∆" &
.
∆∆& '$
sharedVerticesInternal
∆∆' =
[
∆∆= > 
sharedVertexHandle
∆∆> P
]
∆∆P Q
)
∆∆Q R
vertices
«« 
[
«« 
index
«« 
]
«« 
=
««  !
vertex
««" (
;
««( )
mesh
…… 
.
…… 
SetVertices
…… 
(
…… 
vertices
…… %
)
……% &
;
……& '
}
   	
}
ÀÀ 
}ÃÃ ãÎ
êD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SelectionPicker.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

static 
class 
SelectionPicker '
{		 
public 
static 

Dictionary  
<  !
ProBuilderMesh! /
,/ 0
HashSet1 8
<8 9
int9 <
>< =
>= >
PickVerticesInRect? Q
(Q R
Camera 
cam 
, 
Rect 
rect 
, 
IList 
< 
ProBuilderMesh  
>  !

selectable" ,
,, -
PickerOptions 
options !
,! "
float 
pixelsPerPoint  
=! "
$num# %
)% &
{ 	
if 
( 
options 
. 
	depthTest !
)! "
{ 
return #
SelectionPickerRenderer .
.. /
PickVerticesInRect/ A
(A B
cam 
, 
rect 
, 

selectable 
, 
true   
,   
(!! 
int!! 
)!! 
(!! 
cam!! 
.!! 

pixelWidth!! (
/!!) *
pixelsPerPoint!!+ 9
)!!9 :
,!!: ;
("" 
int"" 
)"" 
("" 
cam"" 
."" 
pixelHeight"" )
/""* +
pixelsPerPoint"", :
)"": ;
)""; <
;""< =
}## 
var'' 
selected'' 
='' 
new'' 

Dictionary'' )
<'') *
ProBuilderMesh''* 8
,''8 9
HashSet'': A
<''A B
int''B E
>''E F
>''F G
(''G H
)''H I
;''I J
foreach)) 
()) 
var)) 
pb)) 
in)) 

selectable)) )
)))) *
{** 
if++ 
(++ 
!++ 
pb++ 
.++ 

selectable++ "
)++" #
continue,, 
;,, 
SharedVertex.. 
[.. 
].. 
sharedIndexes.. ,
=..- .
pb../ 1
...1 2"
sharedVerticesInternal..2 H
;..H I
HashSet// 
<// 
int// 
>// 
inRect// #
=//$ %
new//& )
HashSet//* 1
<//1 2
int//2 5
>//5 6
(//6 7
)//7 8
;//8 9
Vector300 
[00 
]00 
	positions00 #
=00$ %
pb00& (
.00( )
positionsInternal00) :
;00: ;
var11 
trs11 
=11 
pb11 
.11 
	transform11 &
;11& '
float22 
pixelHeight22 !
=22" #
cam22$ '
.22' (
pixelHeight22( 3
;223 4
for44 
(44 
int44 
n44 
=44 
$num44 
;44 
n44  !
<44" #
sharedIndexes44$ 1
.441 2
Length442 8
;448 9
n44: ;
++44; =
)44= >
{55 
Vector366 
v66 
=66 
trs66  #
.66# $
TransformPoint66$ 2
(662 3
	positions663 <
[66< =
sharedIndexes66= J
[66J K
n66K L
]66L M
[66M N
$num66N O
]66O P
]66P Q
)66Q R
;66R S
Vector377 
p77 
=77 
cam77  #
.77# $
WorldToScreenPoint77$ 6
(776 7
v777 8
)778 9
;779 :
if99 
(99 
p99 
.99 
z99 
<99 
cam99 !
.99! "
nearClipPlane99" /
)99/ 0
continue::  
;::  !
p<< 
.<< 
x<< 
/=<< 
pixelsPerPoint<< )
;<<) *
p== 
.== 
y== 
=== 
(== 
pixelHeight== &
-==' (
p==) *
.==* +
y==+ ,
)==, -
/==. /
pixelsPerPoint==0 >
;==> ?
if?? 
(?? 
rect?? 
.?? 
Contains?? %
(??% &
p??& '
)??' (
)??( )
inRect@@ 
.@@ 
Add@@ "
(@@" #
n@@# $
)@@$ %
;@@% &
}AA 
selectedCC 
.CC 
AddCC 
(CC 
pbCC 
,CC  
inRectCC! '
)CC' (
;CC( )
}DD 
returnFF 
selectedFF 
;FF 
}GG 	
publicRR 
staticRR 

DictionaryRR  
<RR  !
ProBuilderMeshRR! /
,RR/ 0
HashSetRR1 8
<RR8 9
FaceRR9 =
>RR= >
>RR> ?
PickFacesInRectRR@ O
(RRO P
CameraSS 
camSS 
,SS 
RectTT 
rectTT 
,TT 
IListUU 
<UU 
ProBuilderMeshUU  
>UU  !

selectableUU" ,
,UU, -
PickerOptionsVV 
optionsVV !
,VV! "
floatWW 
pixelsPerPointWW  
=WW! "
$numWW# %
)WW% &
{XX 	
ifYY 
(YY 
optionsYY 
.YY 
	depthTestYY !
&&YY" $
optionsYY% ,
.YY, -
rectSelectModeYY- ;
==YY< >
RectSelectModeYY? M
.YYM N
PartialYYN U
)YYU V
{ZZ 
return[[ #
SelectionPickerRenderer[[ .
.[[. /
PickFacesInRect[[/ >
([[> ?
cam\\ 
,\\ 
rect]] 
,]] 

selectable^^ 
,^^ 
(__ 
int__ 
)__ 
(__ 
cam__ 
.__ 

pixelWidth__ (
/__) *
pixelsPerPoint__+ 9
)__9 :
,__: ;
(`` 
int`` 
)`` 
(`` 
cam`` 
.`` 
pixelHeight`` )
/``* +
pixelsPerPoint``, :
)``: ;
)``; <
;``< =
}aa 
varcc 
selectedcc 
=cc 
newcc 

Dictionarycc )
<cc) *
ProBuilderMeshcc* 8
,cc8 9
HashSetcc: A
<ccA B
FaceccB F
>ccF G
>ccG H
(ccH I
)ccI J
;ccJ K
foreachee 
(ee 
varee 
pbee 
inee 

selectableee )
)ee) *
{ff 
ifgg 
(gg 
!gg 
pbgg 
.gg 

selectablegg "
)gg" #
continuehh 
;hh 
HashSetjj 
<jj 
Facejj 
>jj 
selectedFacesjj +
=jj, -
newjj. 1
HashSetjj2 9
<jj9 :
Facejj: >
>jj> ?
(jj? @
)jj@ A
;jjA B
	Transformkk 
trskk 
=kk 
pbkk  "
.kk" #
	transformkk# ,
;kk, -
Vector3ll 
[ll 
]ll 
	positionsll #
=ll$ %
pbll& (
.ll( )
positionsInternalll) :
;ll: ;
Vector3mm 
[mm 
]mm 
screenPointsmm &
=mm' (
newmm) ,
Vector3mm- 4
[mm4 5
pbmm5 7
.mm7 8
vertexCountmm8 C
]mmC D
;mmD E
foroo 
(oo 
intoo 
nnoo 
=oo 
$numoo 
;oo  
nnoo! #
<oo$ %
pboo& (
.oo( )
vertexCountoo) 4
;oo4 5
nnoo6 8
++oo8 :
)oo: ;
screenPointspp  
[pp  !
nnpp! #
]pp# $
=pp% &
campp' *
.pp* +
ScreenToGuiPointpp+ ;
(pp; <
campp< ?
.pp? @
WorldToScreenPointpp@ R
(ppR S
trsppS V
.ppV W
TransformPointppW e
(ppe f
	positionsppf o
[ppo p
nnppp r
]ppr s
)pps t
)ppt u
,ppu v
pixelsPerPoint	ppw Ö
)
ppÖ Ü
;
ppÜ á
forrr 
(rr 
intrr 
nrr 
=rr 
$numrr 
;rr 
nrr  !
<rr" #
pbrr$ &
.rr& '
facesInternalrr' 4
.rr4 5
Lengthrr5 ;
;rr; <
nrr= >
++rr> @
)rr@ A
{ss 
Facett 
facett 
=tt 
pbtt  "
.tt" #
facesInternaltt# 0
[tt0 1
ntt1 2
]tt2 3
;tt3 4
ifww 
(ww 
optionsww 
.ww  
rectSelectModeww  .
==ww/ 1
RectSelectModeww2 @
.ww@ A
CompletewwA I
)wwI J
{xx 
ifzz 
(zz 
screenPointszz (
[zz( )
facezz) -
.zz- .
indexesInternalzz. =
[zz= >
$numzz> ?
]zz? @
]zz@ A
.zzA B
zzzB C
<zzD E
camzzF I
.zzI J
nearClipPlanezzJ W
)zzW X
continue{{ $
;{{$ %
if~~ 
(~~ 
rect~~  
.~~  !
Contains~~! )
(~~) *
screenPoints~~* 6
[~~6 7
face~~7 ;
.~~; <
indexesInternal~~< K
[~~K L
$num~~L M
]~~M N
]~~N O
)~~O P
)~~P Q
{ 
bool
ÄÄ  
nope
ÄÄ! %
=
ÄÄ& '
false
ÄÄ( -
;
ÄÄ- .
for
ÇÇ 
(
ÇÇ  !
int
ÇÇ! $
q
ÇÇ% &
=
ÇÇ' (
$num
ÇÇ) *
;
ÇÇ* +
q
ÇÇ, -
<
ÇÇ. /
face
ÇÇ0 4
.
ÇÇ4 5%
distinctIndexesInternal
ÇÇ5 L
.
ÇÇL M
Length
ÇÇM S
;
ÇÇS T
q
ÇÇU V
++
ÇÇV X
)
ÇÇX Y
{
ÉÉ 
int
ÑÑ  #
index
ÑÑ$ )
=
ÑÑ* +
face
ÑÑ, 0
.
ÑÑ0 1%
distinctIndexesInternal
ÑÑ1 H
[
ÑÑH I
q
ÑÑI J
]
ÑÑJ K
;
ÑÑK L
if
ÜÜ  "
(
ÜÜ# $
screenPoints
ÜÜ$ 0
[
ÜÜ0 1
index
ÜÜ1 6
]
ÜÜ6 7
.
ÜÜ7 8
z
ÜÜ8 9
<
ÜÜ: ;
cam
ÜÜ< ?
.
ÜÜ? @
nearClipPlane
ÜÜ@ M
||
ÜÜN P
!
ÜÜQ R
rect
ÜÜR V
.
ÜÜV W
Contains
ÜÜW _
(
ÜÜ_ `
screenPoints
ÜÜ` l
[
ÜÜl m
index
ÜÜm r
]
ÜÜr s
)
ÜÜs t
)
ÜÜt u
{
áá  !
nope
àà$ (
=
àà) *
true
àà+ /
;
àà/ 0
break
ââ$ )
;
ââ) *
}
ää  !
}
ãã 
if
çç 
(
çç  
!
çç  !
nope
çç! %
)
çç% &
{
éé 
if
èè  "
(
èè# $
!
èè$ %
options
èè% ,
.
èè, -
	depthTest
èè- 6
||
èè7 9
!
êê$ %
HandleUtility
êê% 2
.
êê2 3
PointIsOccluded
êê3 B
(
êêB C
cam
êêC F
,
êêF G
pb
êêH J
,
êêJ K
trs
êêL O
.
êêO P
TransformPoint
êêP ^
(
êê^ _
Math
êê_ c
.
êêc d
Average
êêd k
(
êêk l
	positions
êêl u
,
êêu v
face
êêw {
.
êê{ |&
distinctIndexesInternalêê| ì
)êêì î
)êêî ï
)êêï ñ
)êêñ ó
{
ëë  !
selectedFaces
íí$ 1
.
íí1 2
Add
íí2 5
(
íí5 6
face
íí6 :
)
íí: ;
;
íí; <
}
ìì  !
}
îî 
}
ïï 
}
ññ 
else
òò 
{
ôô 
Bounds2D
öö  
poly
öö! %
=
öö& '
new
öö( +
Bounds2D
öö, 4
(
öö4 5
screenPoints
öö5 A
,
ööA B
face
ööC G
.
ööG H
edgesInternal
ööH U
)
ööU V
;
ööV W
bool
õõ 
overlaps
õõ %
=
õõ& '
false
õõ( -
;
õõ- .
if
ùù 
(
ùù 
poly
ùù  
.
ùù  !

Intersects
ùù! +
(
ùù+ ,
rect
ùù, 0
)
ùù0 1
)
ùù1 2
{
ûû 
for
†† 
(
††  !
int
††! $
nn
††% '
=
††( )
$num
††* +
;
††+ ,
nn
††- /
<
††0 1
face
††2 6
.
††6 7%
distinctIndexesInternal
††7 N
.
††N O
Length
††O U
&&
††V X
!
††Y Z
overlaps
††Z b
;
††b c
nn
††d f
++
††f h
)
††h i
{
°° 
Vector3
¢¢  '
p
¢¢( )
=
¢¢* +
screenPoints
¢¢, 8
[
¢¢8 9
face
¢¢9 =
.
¢¢= >%
distinctIndexesInternal
¢¢> U
[
¢¢U V
nn
¢¢V X
]
¢¢X Y
]
¢¢Y Z
;
¢¢Z [
overlaps
££  (
=
££) *
p
££+ ,
.
££, -
z
££- .
>
££/ 0
cam
££1 4
.
££4 5
nearClipPlane
££5 B
&&
££C E
rect
££F J
.
££J K
Contains
££K S
(
££S T
p
££T U
)
££U V
;
££V W
}
§§ 
if
ßß 
(
ßß  
!
ßß  !
overlaps
ßß! )
)
ßß) *
{
®® 
Vector2
©©  '
tl
©©( *
=
©©+ ,
new
©©- 0
Vector2
©©1 8
(
©©8 9
rect
©©9 =
.
©©= >
xMin
©©> B
,
©©B C
rect
©©D H
.
©©H I
yMax
©©I M
)
©©M N
;
©©N O
Vector2
™™  '
tr
™™( *
=
™™+ ,
new
™™- 0
Vector2
™™1 8
(
™™8 9
rect
™™9 =
.
™™= >
xMax
™™> B
,
™™B C
rect
™™D H
.
™™H I
yMax
™™I M
)
™™M N
;
™™N O
Vector2
´´  '
bl
´´( *
=
´´+ ,
new
´´- 0
Vector2
´´1 8
(
´´8 9
rect
´´9 =
.
´´= >
xMin
´´> B
,
´´B C
rect
´´D H
.
´´H I
yMin
´´I M
)
´´M N
;
´´N O
Vector2
¨¨  '
br
¨¨( *
=
¨¨+ ,
new
¨¨- 0
Vector2
¨¨1 8
(
¨¨8 9
rect
¨¨9 =
.
¨¨= >
xMax
¨¨> B
,
¨¨B C
rect
¨¨D H
.
¨¨H I
yMin
¨¨I M
)
¨¨M N
;
¨¨N O
overlaps
ÆÆ  (
=
ÆÆ) *
Math
ÆÆ+ /
.
ÆÆ/ 0
PointInPolygon
ÆÆ0 >
(
ÆÆ> ?
screenPoints
ÆÆ? K
,
ÆÆK L
poly
ÆÆM Q
,
ÆÆQ R
face
ÆÆS W
.
ÆÆW X
edgesInternal
ÆÆX e
,
ÆÆe f
tl
ÆÆg i
)
ÆÆi j
;
ÆÆj k
if
ØØ  "
(
ØØ# $
!
ØØ$ %
overlaps
ØØ% -
)
ØØ- .
overlaps
ØØ/ 7
=
ØØ8 9
Math
ØØ: >
.
ØØ> ?
PointInPolygon
ØØ? M
(
ØØM N
screenPoints
ØØN Z
,
ØØZ [
poly
ØØ\ `
,
ØØ` a
face
ØØb f
.
ØØf g
edgesInternal
ØØg t
,
ØØt u
tr
ØØv x
)
ØØx y
;
ØØy z
if
∞∞  "
(
∞∞# $
!
∞∞$ %
overlaps
∞∞% -
)
∞∞- .
overlaps
∞∞/ 7
=
∞∞8 9
Math
∞∞: >
.
∞∞> ?
PointInPolygon
∞∞? M
(
∞∞M N
screenPoints
∞∞N Z
,
∞∞Z [
poly
∞∞\ `
,
∞∞` a
face
∞∞b f
.
∞∞f g
edgesInternal
∞∞g t
,
∞∞t u
br
∞∞v x
)
∞∞x y
;
∞∞y z
if
±±  "
(
±±# $
!
±±$ %
overlaps
±±% -
)
±±- .
overlaps
±±/ 7
=
±±8 9
Math
±±: >
.
±±> ?
PointInPolygon
±±? M
(
±±M N
screenPoints
±±N Z
,
±±Z [
poly
±±\ `
,
±±` a
face
±±b f
.
±±f g
edgesInternal
±±g t
,
±±t u
bl
±±v x
)
±±x y
;
±±y z
for
¥¥  #
(
¥¥$ %
int
¥¥% (
nn
¥¥) +
=
¥¥, -
$num
¥¥. /
;
¥¥/ 0
nn
¥¥1 3
<
¥¥4 5
face
¥¥6 :
.
¥¥: ;
edgesInternal
¥¥; H
.
¥¥H I
Length
¥¥I O
&&
¥¥P R
!
¥¥S T
overlaps
¥¥T \
;
¥¥\ ]
nn
¥¥^ `
++
¥¥` b
)
¥¥b c
{
µµ  !
if
∂∂$ &
(
∂∂' (
Math
∂∂( ,
.
∂∂, -%
GetLineSegmentIntersect
∂∂- D
(
∂∂D E
tr
∂∂E G
,
∂∂G H
tl
∂∂I K
,
∂∂K L
screenPoints
∂∂M Y
[
∂∂Y Z
face
∂∂Z ^
.
∂∂^ _
edgesInternal
∂∂_ l
[
∂∂l m
nn
∂∂m o
]
∂∂o p
.
∂∂p q
a
∂∂q r
]
∂∂r s
,
∂∂s t
screenPoints∂∂u Å
[∂∂Å Ç
face∂∂Ç Ü
.∂∂Ü á
edgesInternal∂∂á î
[∂∂î ï
nn∂∂ï ó
]∂∂ó ò
.∂∂ò ô
b∂∂ô ö
]∂∂ö õ
)∂∂õ ú
)∂∂ú ù
overlaps
∑∑( 0
=
∑∑1 2
true
∑∑3 7
;
∑∑7 8
else
∏∏$ (
if
∏∏) +
(
∏∏, -
Math
∏∏- 1
.
∏∏1 2%
GetLineSegmentIntersect
∏∏2 I
(
∏∏I J
tl
∏∏J L
,
∏∏L M
bl
∏∏N P
,
∏∏P Q
screenPoints
∏∏R ^
[
∏∏^ _
face
∏∏_ c
.
∏∏c d
edgesInternal
∏∏d q
[
∏∏q r
nn
∏∏r t
]
∏∏t u
.
∏∏u v
a
∏∏v w
]
∏∏w x
,
∏∏x y
screenPoints∏∏z Ü
[∏∏Ü á
face∏∏á ã
.∏∏ã å
edgesInternal∏∏å ô
[∏∏ô ö
nn∏∏ö ú
]∏∏ú ù
.∏∏ù û
b∏∏û ü
]∏∏ü †
)∏∏† °
)∏∏° ¢
overlaps
ππ( 0
=
ππ1 2
true
ππ3 7
;
ππ7 8
else
∫∫$ (
if
∫∫) +
(
∫∫, -
Math
∫∫- 1
.
∫∫1 2%
GetLineSegmentIntersect
∫∫2 I
(
∫∫I J
bl
∫∫J L
,
∫∫L M
br
∫∫N P
,
∫∫P Q
screenPoints
∫∫R ^
[
∫∫^ _
face
∫∫_ c
.
∫∫c d
edgesInternal
∫∫d q
[
∫∫q r
nn
∫∫r t
]
∫∫t u
.
∫∫u v
a
∫∫v w
]
∫∫w x
,
∫∫x y
screenPoints∫∫z Ü
[∫∫Ü á
face∫∫á ã
.∫∫ã å
edgesInternal∫∫å ô
[∫∫ô ö
nn∫∫ö ú
]∫∫ú ù
.∫∫ù û
b∫∫û ü
]∫∫ü †
)∫∫† °
)∫∫° ¢
overlaps
ªª( 0
=
ªª1 2
true
ªª3 7
;
ªª7 8
else
ºº$ (
if
ºº) +
(
ºº, -
Math
ºº- 1
.
ºº1 2%
GetLineSegmentIntersect
ºº2 I
(
ººI J
br
ººJ L
,
ººL M
tl
ººN P
,
ººP Q
screenPoints
ººR ^
[
ºº^ _
face
ºº_ c
.
ººc d
edgesInternal
ººd q
[
ººq r
nn
ººr t
]
ººt u
.
ººu v
a
ººv w
]
ººw x
,
ººx y
screenPointsººz Ü
[ººÜ á
faceººá ã
.ººã å
edgesInternalººå ô
[ººô ö
nnººö ú
]ººú ù
.ººù û
bººû ü
]ººü †
)ºº† °
)ºº° ¢
overlaps
ΩΩ( 0
=
ΩΩ1 2
true
ΩΩ3 7
;
ΩΩ7 8
}
ææ  !
}
øø 
}
¿¿ 
if
√√ 
(
√√ 
overlaps
√√ $
)
√√$ %
selectedFaces
ƒƒ )
.
ƒƒ) *
Add
ƒƒ* -
(
ƒƒ- .
face
ƒƒ. 2
)
ƒƒ2 3
;
ƒƒ3 4
}
≈≈ 
}
∆∆ 
selected
»» 
.
»» 
Add
»» 
(
»» 
pb
»» 
,
»»  
selectedFaces
»»! .
)
»». /
;
»»/ 0
}
…… 
return
ÀÀ 
selected
ÀÀ 
;
ÀÀ 
}
ÃÃ 	
public
◊◊ 
static
◊◊ 

Dictionary
◊◊  
<
◊◊  !
ProBuilderMesh
◊◊! /
,
◊◊/ 0
HashSet
◊◊1 8
<
◊◊8 9
Edge
◊◊9 =
>
◊◊= >
>
◊◊> ?
PickEdgesInRect
◊◊@ O
(
◊◊O P
Camera
ÿÿ 
cam
ÿÿ 
,
ÿÿ 
Rect
ŸŸ 
rect
ŸŸ 
,
ŸŸ 
IList
⁄⁄ 
<
⁄⁄ 
ProBuilderMesh
⁄⁄  
>
⁄⁄  !

selectable
⁄⁄" ,
,
⁄⁄, -
PickerOptions
€€ 
options
€€ !
,
€€! "
float
‹‹ 
pixelsPerPoint
‹‹  
=
‹‹! "
$num
‹‹# %
)
‹‹% &
{
›› 	
if
ﬁﬁ 
(
ﬁﬁ 
options
ﬁﬁ 
.
ﬁﬁ 
	depthTest
ﬁﬁ !
&&
ﬁﬁ" $
options
ﬁﬁ% ,
.
ﬁﬁ, -
rectSelectMode
ﬁﬁ- ;
==
ﬁﬁ< >
RectSelectMode
ﬁﬁ? M
.
ﬁﬁM N
Partial
ﬁﬁN U
)
ﬁﬁU V
{
ﬂﬂ 
return
‡‡ %
SelectionPickerRenderer
‡‡ .
.
‡‡. /
PickEdgesInRect
‡‡/ >
(
‡‡> ?
cam
·· 
,
·· 
rect
‚‚ 
,
‚‚ 

selectable
„„ 
,
„„ 
true
‰‰ 
,
‰‰ 
(
ÂÂ 
int
ÂÂ 
)
ÂÂ 
(
ÂÂ 
cam
ÂÂ 
.
ÂÂ 

pixelWidth
ÂÂ (
/
ÂÂ) *
pixelsPerPoint
ÂÂ+ 9
)
ÂÂ9 :
,
ÂÂ: ;
(
ÊÊ 
int
ÊÊ 
)
ÊÊ 
(
ÊÊ 
cam
ÊÊ 
.
ÊÊ 
pixelHeight
ÊÊ )
/
ÊÊ* +
pixelsPerPoint
ÊÊ, :
)
ÊÊ: ;
)
ÊÊ; <
;
ÊÊ< =
}
ÁÁ 
var
ÈÈ 
selected
ÈÈ 
=
ÈÈ 
new
ÈÈ 

Dictionary
ÈÈ )
<
ÈÈ) *
ProBuilderMesh
ÈÈ* 8
,
ÈÈ8 9
HashSet
ÈÈ: A
<
ÈÈA B
Edge
ÈÈB F
>
ÈÈF G
>
ÈÈG H
(
ÈÈH I
)
ÈÈI J
;
ÈÈJ K
foreach
ÎÎ 
(
ÎÎ 
var
ÎÎ 
pb
ÎÎ 
in
ÎÎ 

selectable
ÎÎ )
)
ÎÎ) *
{
ÏÏ 
if
ÌÌ 
(
ÌÌ 
!
ÌÌ 
pb
ÌÌ 
.
ÌÌ 

selectable
ÌÌ "
)
ÌÌ" #
continue
ÓÓ 
;
ÓÓ 
	Transform
 
trs
 
=
 
pb
  "
.
" #
	transform
# ,
;
, -
var
ÒÒ 
selectedEdges
ÒÒ !
=
ÒÒ" #
new
ÒÒ$ '
HashSet
ÒÒ( /
<
ÒÒ/ 0
Edge
ÒÒ0 4
>
ÒÒ4 5
(
ÒÒ5 6
)
ÒÒ6 7
;
ÒÒ7 8
for
ÛÛ 
(
ÛÛ 
int
ÛÛ 
i
ÛÛ 
=
ÛÛ 
$num
ÛÛ 
,
ÛÛ 
fc
ÛÛ  "
=
ÛÛ# $
pb
ÛÛ% '
.
ÛÛ' (
	faceCount
ÛÛ( 1
;
ÛÛ1 2
i
ÛÛ3 4
<
ÛÛ5 6
fc
ÛÛ7 9
;
ÛÛ9 :
i
ÛÛ; <
++
ÛÛ< >
)
ÛÛ> ?
{
ÙÙ 
var
ıı 
edges
ıı 
=
ıı 
pb
ıı  "
.
ıı" #
facesInternal
ıı# 0
[
ıı0 1
i
ıı1 2
]
ıı2 3
.
ıı3 4
edgesInternal
ıı4 A
;
ııA B
for
˜˜ 
(
˜˜ 
int
˜˜ 
n
˜˜ 
=
˜˜  
$num
˜˜! "
,
˜˜" #
ec
˜˜$ &
=
˜˜' (
edges
˜˜) .
.
˜˜. /
Length
˜˜/ 5
;
˜˜5 6
n
˜˜7 8
<
˜˜9 :
ec
˜˜; =
;
˜˜= >
n
˜˜? @
++
˜˜@ B
)
˜˜B C
{
¯¯ 
var
˘˘ 
edge
˘˘  
=
˘˘! "
edges
˘˘# (
[
˘˘( )
n
˘˘) *
]
˘˘* +
;
˘˘+ ,
var
˚˚ 
posA
˚˚  
=
˚˚! "
trs
˚˚# &
.
˚˚& '
TransformPoint
˚˚' 5
(
˚˚5 6
pb
˚˚6 8
.
˚˚8 9
positionsInternal
˚˚9 J
[
˚˚J K
edge
˚˚K O
.
˚˚O P
a
˚˚P Q
]
˚˚Q R
)
˚˚R S
;
˚˚S T
var
¸¸ 
posB
¸¸  
=
¸¸! "
trs
¸¸# &
.
¸¸& '
TransformPoint
¸¸' 5
(
¸¸5 6
pb
¸¸6 8
.
¸¸8 9
positionsInternal
¸¸9 J
[
¸¸J K
edge
¸¸K O
.
¸¸O P
b
¸¸P Q
]
¸¸Q R
)
¸¸R S
;
¸¸S T
Vector3
˛˛ 
a
˛˛  !
=
˛˛" #
cam
˛˛$ '
.
˛˛' (
ScreenToGuiPoint
˛˛( 8
(
˛˛8 9
cam
˛˛9 <
.
˛˛< = 
WorldToScreenPoint
˛˛= O
(
˛˛O P
posA
˛˛P T
)
˛˛T U
,
˛˛U V
pixelsPerPoint
˛˛W e
)
˛˛e f
;
˛˛f g
Vector3
ˇˇ 
b
ˇˇ  !
=
ˇˇ" #
cam
ˇˇ$ '
.
ˇˇ' (
ScreenToGuiPoint
ˇˇ( 8
(
ˇˇ8 9
cam
ˇˇ9 <
.
ˇˇ< = 
WorldToScreenPoint
ˇˇ= O
(
ˇˇO P
posB
ˇˇP T
)
ˇˇT U
,
ˇˇU V
pixelsPerPoint
ˇˇW e
)
ˇˇe f
;
ˇˇf g
switch
ÅÅ 
(
ÅÅ  
options
ÅÅ  '
.
ÅÅ' (
rectSelectMode
ÅÅ( 6
)
ÅÅ6 7
{
ÇÇ 
case
ÉÉ  
RectSelectMode
ÉÉ! /
.
ÉÉ/ 0
Complete
ÉÉ0 8
:
ÉÉ8 9
{
ÑÑ 
if
ÜÜ  "
(
ÜÜ# $
(
ÜÜ$ %
a
ÜÜ% &
.
ÜÜ& '
z
ÜÜ' (
<
ÜÜ) *
cam
ÜÜ+ .
.
ÜÜ. /
nearClipPlane
ÜÜ/ <
||
ÜÜ= ?
b
ÜÜ@ A
.
ÜÜA B
z
ÜÜB C
<
ÜÜD E
cam
ÜÜF I
.
ÜÜI J
nearClipPlane
ÜÜJ W
)
ÜÜW X
)
ÜÜX Y
continue
áá$ ,
;
áá, -
if
ââ  "
(
ââ# $
rect
ââ$ (
.
ââ( )
Contains
ââ) 1
(
ââ1 2
a
ââ2 3
)
ââ3 4
&&
ââ5 7
rect
ââ8 <
.
ââ< =
Contains
ââ= E
(
ââE F
b
ââF G
)
ââG H
)
ââH I
{
ää  !
if
ãã$ &
(
ãã' (
!
ãã( )
options
ãã) 0
.
ãã0 1
	depthTest
ãã1 :
||
ãã; =
!
ãã> ?
HandleUtility
ãã? L
.
ããL M
PointIsOccluded
ããM \
(
ãã\ ]
cam
ãã] `
,
ãã` a
pb
ããb d
,
ããd e
(
ããf g
posA
ããg k
+
ããl m
posB
ããn r
)
ããr s
*
ããt u
$num
ããv y
)
ããy z
)
ããz {
selectedEdges
åå( 5
.
åå5 6
Add
åå6 9
(
åå9 :
edge
åå: >
)
åå> ?
;
åå? @
}
çç  !
break
èè  %
;
èè% &
}
êê 
case
íí  
RectSelectMode
íí! /
.
íí/ 0
Partial
íí0 7
:
íí7 8
{
ìì 
if
ïï  "
(
ïï# $
Math
ïï$ (
.
ïï( )'
RectIntersectsLineSegment
ïï) B
(
ïïB C
rect
ïïC G
,
ïïG H
a
ïïI J
,
ïïJ K
b
ïïL M
)
ïïM N
)
ïïN O
selectedEdges
ññ$ 1
.
ññ1 2
Add
ññ2 5
(
ññ5 6
edge
ññ6 :
)
ññ: ;
;
ññ; <
break
òò  %
;
òò% &
}
ôô 
}
öö 
}
õõ 
}
úú 
selected
ûû 
.
ûû 
Add
ûû 
(
ûû 
pb
ûû 
,
ûû  
selectedEdges
ûû! .
)
ûû. /
;
ûû/ 0
}
üü 
return
°° 
selected
°° 
;
°° 
}
¢¢ 	
public
´´ 
static
´´ 
Face
´´ 
PickFace
´´ #
(
´´# $
Camera
´´$ *
camera
´´+ 1
,
´´1 2
Vector3
´´3 :
mousePosition
´´; H
,
´´H I
ProBuilderMesh
´´J X
pickable
´´Y a
)
´´a b
{
¨¨ 	
Ray
≠≠ 
ray
≠≠ 
=
≠≠ 
camera
≠≠ 
.
≠≠ 
ScreenPointToRay
≠≠ -
(
≠≠- .
mousePosition
≠≠. ;
)
≠≠; <
;
≠≠< =

RaycastHit
ØØ 
hit
ØØ 
;
ØØ 
if
±± 
(
±± 
HandleUtility
±± 
.
±± 
FaceRaycast
±± )
(
±±) *
ray
±±* -
,
±±- .
pickable
±±/ 7
,
±±7 8
out
±±9 <
hit
±±= @
,
±±@ A
Mathf
±±B G
.
±±G H
Infinity
±±H P
,
±±P Q
CullingMode
±±R ]
.
±±] ^
Back
±±^ b
)
±±b c
)
±±c d
return
≤≤ 
pickable
≤≤ 
.
≤≤  
facesInternal
≤≤  -
[
≤≤- .
hit
≤≤. 1
.
≤≤1 2
face
≤≤2 6
]
≤≤6 7
;
≤≤7 8
return
¥¥ 
null
¥¥ 
;
¥¥ 
}
µµ 	
}
∂∂ 
}∑∑ “´
ãD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\VectorMask.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
struct 

Vector2Mask 
{ 
const 
byte 
X 
= 
$num 
<< 
$num 
; 
const 
byte 
Y 
= 
$num 
<< 
$num 
; 
public

 
static

 
readonly

 
Vector2Mask

 *
XY

+ -
=

. /
new

0 3
Vector2Mask

4 ?
(

? @
X

@ A
|

B C
Y

D E
)

E F
;

F G
byte 
m_Mask 
; 
public 
float 
x 
{ 	
get 
{ 
return 
( 
m_Mask  
&! "
X# $
)$ %
==& (
X) *
?+ ,
$num- /
:0 1
$num2 4
;4 5
}6 7
} 	
public 
float 
y 
{ 	
get 
{ 
return 
( 
m_Mask  
&! "
Y# $
)$ %
==& (
Y) *
?+ ,
$num- /
:0 1
$num2 4
;4 5
}6 7
} 	
public 
Vector2Mask 
( 
Vector3 "
v# $
,$ %
float& +
epsilon, 3
=4 5
float6 ;
.; <
Epsilon< C
)C D
{ 	
m_Mask 
= 
$num 
; 
if 
( 
Mathf 
. 
Abs 
( 
v 
. 
x 
) 
>  
epsilon! (
)( )
m_Mask 
|= 
X 
; 
if 
( 
Mathf 
. 
Abs 
( 
v 
. 
y 
) 
>  
epsilon! (
)( )
m_Mask 
|= 
Y 
; 
}   	
public"" 
Vector2Mask"" 
("" 
byte"" 
mask""  $
)""$ %
{## 	
m_Mask$$ 
=$$ 
mask$$ 
;$$ 
}%% 	
public'' 
static'' 
implicit'' 
operator'' '
Vector2''( /
(''/ 0
Vector2Mask''0 ;
mask''< @
)''@ A
{(( 	
return)) 
new)) 
Vector2)) 
()) 
mask)) #
.))# $
x))$ %
,))% &
mask))' +
.))+ ,
y)), -
)))- .
;)). /
}** 	
public,, 
static,, 
implicit,, 
operator,, '
Vector2Mask,,( 3
(,,3 4
Vector2,,4 ;
v,,< =
),,= >
{-- 	
return.. 
new.. 
Vector2Mask.. "
(.." #
v..# $
)..$ %
;..% &
}// 	
public11 
static11 
Vector2Mask11 !
operator11" *
|11* +
(11+ ,
Vector2Mask11, 7
left118 <
,11< =
Vector2Mask11> I
right11J O
)11O P
{22 	
return33 
new33 
Vector2Mask33 "
(33" #
(33# $
byte33$ (
)33( )
(33) *
left33* .
.33. /
m_Mask33/ 5
|336 7
right338 =
.33= >
m_Mask33> D
)33D E
)33E F
;33F G
}44 	
public66 
static66 
Vector2Mask66 !
operator66" *
&66* +
(66+ ,
Vector2Mask66, 7
left668 <
,66< =
Vector2Mask66> I
right66J O
)66O P
{77 	
return88 
new88 
Vector2Mask88 "
(88" #
(88# $
byte88$ (
)88( )
(88) *
left88* .
.88. /
m_Mask88/ 5
&886 7
right888 =
.88= >
m_Mask88> D
)88D E
)88E F
;88F G
}99 	
public;; 
static;; 
Vector2Mask;; !
operator;;" *
^;;* +
(;;+ ,
Vector2Mask;;, 7
left;;8 <
,;;< =
Vector2Mask;;> I
right;;J O
);;O P
{<< 	
return== 
new== 
Vector2Mask== "
(==" #
(==# $
byte==$ (
)==( )
(==) *
left==* .
.==. /
m_Mask==/ 5
^==6 7
right==8 =
.=== >
m_Mask==> D
)==D E
)==E F
;==F G
}>> 	
public@@ 
static@@ 
Vector2@@ 
operator@@ &
*@@& '
(@@' (
Vector2Mask@@( 3
mask@@4 8
,@@8 9
float@@: ?
value@@@ E
)@@E F
{AA 	
returnBB 
newBB 
Vector2BB 
(BB 
maskBB #
.BB# $
xBB$ %
*BB& '
valueBB( -
,BB- .
maskBB/ 3
.BB3 4
yBB4 5
*BB6 7
valueBB8 =
)BB= >
;BB> ?
}CC 	
}DD 
structFF 

Vector3MaskFF 
:FF 

IEquatableFF #
<FF# $
Vector3MaskFF$ /
>FF/ 0
{GG 
constHH 
byteHH 
XHH 
=HH 
$numHH 
<<HH 
$numHH 
;HH 
constII 
byteII 
YII 
=II 
$numII 
<<II 
$numII 
;II 
constJJ 
byteJJ 
ZJJ 
=JJ 
$numJJ 
<<JJ 
$numJJ 
;JJ 
publicLL 
staticLL 
readonlyLL 
Vector3MaskLL *
XYZLL+ .
=LL/ 0
newLL1 4
Vector3MaskLL5 @
(LL@ A
XLLA B
|LLC D
YLLE F
|LLG H
ZLLI J
)LLJ K
;LLK L
byteNN 
m_MaskNN 
;NN 
publicPP 
floatPP 
xPP 
{QQ 	
getRR 
{RR 
returnRR 
(RR 
m_MaskRR  
&RR! "
XRR# $
)RR$ %
==RR& (
XRR) *
?RR+ ,
$numRR- /
:RR0 1
$numRR2 4
;RR4 5
}RR6 7
}SS 	
publicUU 
floatUU 
yUU 
{VV 	
getWW 
{WW 
returnWW 
(WW 
m_MaskWW  
&WW! "
YWW# $
)WW$ %
==WW& (
YWW) *
?WW+ ,
$numWW- /
:WW0 1
$numWW2 4
;WW4 5
}WW6 7
}XX 	
publicZZ 
floatZZ 
zZZ 
{[[ 	
get\\ 
{\\ 
return\\ 
(\\ 
m_Mask\\  
&\\! "
Z\\# $
)\\$ %
==\\& (
Z\\) *
?\\+ ,
$num\\- /
:\\0 1
$num\\2 4
;\\4 5
}\\6 7
}]] 	
public__ 
Vector3Mask__ 
(__ 
Vector3__ "
v__# $
,__$ %
float__& +
epsilon__, 3
=__4 5
float__6 ;
.__; <
Epsilon__< C
)__C D
{`` 	
m_Maskaa 
=aa 
$numaa 
;aa 
ifcc 
(cc 
Mathfcc 
.cc 
Abscc 
(cc 
vcc 
.cc 
xcc 
)cc 
>cc  
epsiloncc! (
)cc( )
m_Maskdd 
|=dd 
Xdd 
;dd 
ifee 
(ee 
Mathfee 
.ee 
Absee 
(ee 
vee 
.ee 
yee 
)ee 
>ee  
epsilonee! (
)ee( )
m_Maskff 
|=ff 
Yff 
;ff 
ifgg 
(gg 
Mathfgg 
.gg 
Absgg 
(gg 
vgg 
.gg 
zgg 
)gg 
>gg  
epsilongg! (
)gg( )
m_Maskhh 
|=hh 
Zhh 
;hh 
}ii 	
publickk 
Vector3Maskkk 
(kk 
bytekk 
maskkk  $
)kk$ %
{ll 	
m_Maskmm 
=mm 
maskmm 
;mm 
}nn 	
publicpp 
overridepp 
stringpp 
ToStringpp '
(pp' (
)pp( )
{qq 	
returnrr 
stringrr 
.rr 
Formatrr  
(rr  !
$strrr! 4
,rr4 5
xrr6 7
,rr7 8
yrr9 :
,rr: ;
zrr< =
)rr= >
;rr> ?
}ss 	
publicxx 
intxx 
activexx 
{yy 	
getzz 
{{{ 
int|| 
count|| 
=|| 
$num|| 
;|| 
if}} 
(}} 
(}} 
m_Mask}} 
&}} 
X}} 
)}}  
>}}! "
$num}}# $
)}}$ %
count~~ 
++~~ 
;~~ 
if 
( 
( 
m_Mask 
& 
Y 
)  
>! "
$num# $
)$ %
count
ÄÄ 
++
ÄÄ 
;
ÄÄ 
if
ÅÅ 
(
ÅÅ 
(
ÅÅ 
m_Mask
ÅÅ 
&
ÅÅ 
Z
ÅÅ 
)
ÅÅ  
>
ÅÅ! "
$num
ÅÅ# $
)
ÅÅ$ %
count
ÇÇ 
++
ÇÇ 
;
ÇÇ 
return
ÉÉ 
count
ÉÉ 
;
ÉÉ 
}
ÑÑ 
}
ÖÖ 	
public
áá 
static
áá 
implicit
áá 
operator
áá '
Vector3
áá( /
(
áá/ 0
Vector3Mask
áá0 ;
mask
áá< @
)
áá@ A
{
àà 	
return
ââ 
new
ââ 
Vector3
ââ 
(
ââ 
mask
ââ #
.
ââ# $
x
ââ$ %
,
ââ% &
mask
ââ' +
.
ââ+ ,
y
ââ, -
,
ââ- .
mask
ââ/ 3
.
ââ3 4
z
ââ4 5
)
ââ5 6
;
ââ6 7
}
ää 	
public
åå 
static
åå 
explicit
åå 
operator
åå '
Vector3Mask
åå( 3
(
åå3 4
Vector3
åå4 ;
v
åå< =
)
åå= >
{
çç 	
return
éé 
new
éé 
Vector3Mask
éé "
(
éé" #
v
éé# $
)
éé$ %
;
éé% &
}
èè 	
public
ëë 
static
ëë 
Vector3Mask
ëë !
operator
ëë" *
|
ëë* +
(
ëë+ ,
Vector3Mask
ëë, 7
left
ëë8 <
,
ëë< =
Vector3Mask
ëë> I
right
ëëJ O
)
ëëO P
{
íí 	
return
ìì 
new
ìì 
Vector3Mask
ìì "
(
ìì" #
(
ìì# $
byte
ìì$ (
)
ìì( )
(
ìì) *
left
ìì* .
.
ìì. /
m_Mask
ìì/ 5
|
ìì6 7
right
ìì8 =
.
ìì= >
m_Mask
ìì> D
)
ììD E
)
ììE F
;
ììF G
}
îî 	
public
ññ 
static
ññ 
Vector3Mask
ññ !
operator
ññ" *
&
ññ* +
(
ññ+ ,
Vector3Mask
ññ, 7
left
ññ8 <
,
ññ< =
Vector3Mask
ññ> I
right
ññJ O
)
ññO P
{
óó 	
return
òò 
new
òò 
Vector3Mask
òò "
(
òò" #
(
òò# $
byte
òò$ (
)
òò( )
(
òò) *
left
òò* .
.
òò. /
m_Mask
òò/ 5
&
òò6 7
right
òò8 =
.
òò= >
m_Mask
òò> D
)
òòD E
)
òòE F
;
òòF G
}
ôô 	
public
õõ 
static
õõ 
Vector3Mask
õõ !
operator
õõ" *
^
õõ* +
(
õõ+ ,
Vector3Mask
õõ, 7
left
õõ8 <
,
õõ< =
Vector3Mask
õõ> I
right
õõJ O
)
õõO P
{
úú 	
return
ùù 
new
ùù 
Vector3Mask
ùù "
(
ùù" #
(
ùù# $
byte
ùù$ (
)
ùù( )
(
ùù) *
left
ùù* .
.
ùù. /
m_Mask
ùù/ 5
^
ùù6 7
right
ùù8 =
.
ùù= >
m_Mask
ùù> D
)
ùùD E
)
ùùE F
;
ùùF G
}
ûû 	
public
†† 
static
†† 
Vector3
†† 
operator
†† &
*
††& '
(
††' (
Vector3Mask
††( 3
mask
††4 8
,
††8 9
float
††: ?
value
††@ E
)
††E F
{
°° 	
return
¢¢ 
new
¢¢ 
Vector3
¢¢ 
(
¢¢ 
mask
¢¢ #
.
¢¢# $
x
¢¢$ %
*
¢¢& '
value
¢¢( -
,
¢¢- .
mask
¢¢/ 3
.
¢¢3 4
y
¢¢4 5
*
¢¢6 7
value
¢¢8 =
,
¢¢= >
mask
¢¢? C
.
¢¢C D
z
¢¢D E
*
¢¢F G
value
¢¢H M
)
¢¢M N
;
¢¢N O
}
££ 	
public
•• 
static
•• 
Vector3
•• 
operator
•• &
*
••& '
(
••' (
Vector3Mask
••( 3
mask
••4 8
,
••8 9
Vector3
••: A
value
••B G
)
••G H
{
¶¶ 	
return
ßß 
new
ßß 
Vector3
ßß 
(
ßß 
mask
ßß #
.
ßß# $
x
ßß$ %
*
ßß& '
value
ßß( -
.
ßß- .
x
ßß. /
,
ßß/ 0
mask
ßß1 5
.
ßß5 6
y
ßß6 7
*
ßß8 9
value
ßß: ?
.
ßß? @
y
ßß@ A
,
ßßA B
mask
ßßC G
.
ßßG H
z
ßßH I
*
ßßJ K
value
ßßL Q
.
ßßQ R
z
ßßR S
)
ßßS T
;
ßßT U
}
®® 	
public
™™ 
static
™™ 
Vector3
™™ 
operator
™™ &
*
™™& '
(
™™' (

Quaternion
™™( 2
rotation
™™3 ;
,
™™; <
Vector3Mask
™™= H
mask
™™I M
)
™™M N
{
´´ 	
var
¨¨ 
active
¨¨ 
=
¨¨ 
mask
¨¨ 
.
¨¨ 
active
¨¨ $
;
¨¨$ %
if
ÆÆ 
(
ÆÆ 
active
ÆÆ 
>
ÆÆ 
$num
ÆÆ 
)
ÆÆ 
return
ØØ 
mask
ØØ 
;
ØØ 
var
±± 
rotated
±± 
=
±± 
(
±± 
rotation
±± #
*
±±$ %
(
±±& '
Vector3
±±' .
)
±±. /
mask
±±/ 3
)
±±3 4
.
±±4 5
Abs
±±5 8
(
±±8 9
)
±±9 :
;
±±: ;
if
≥≥ 
(
≥≥ 
active
≥≥ 
>
≥≥ 
$num
≥≥ 
)
≥≥ 
{
¥¥ 
return
µµ 
new
µµ 
Vector3
µµ "
(
µµ" #
rotated
∂∂ 
.
∂∂ 
x
∂∂ 
>
∂∂ 
rotated
∂∂  '
.
∂∂' (
y
∂∂( )
||
∂∂* ,
rotated
∂∂- 4
.
∂∂4 5
x
∂∂5 6
>
∂∂7 8
rotated
∂∂9 @
.
∂∂@ A
z
∂∂A B
?
∂∂C D
$num
∂∂E F
:
∂∂G H
$num
∂∂I J
,
∂∂J K
rotated
∑∑ 
.
∑∑ 
y
∑∑ 
>
∑∑ 
rotated
∑∑  '
.
∑∑' (
x
∑∑( )
||
∑∑* ,
rotated
∑∑- 4
.
∑∑4 5
y
∑∑5 6
>
∑∑7 8
rotated
∑∑9 @
.
∑∑@ A
z
∑∑A B
?
∑∑C D
$num
∑∑E F
:
∑∑G H
$num
∑∑I J
,
∑∑J K
rotated
∏∏ 
.
∏∏ 
z
∏∏ 
>
∏∏ 
rotated
∏∏  '
.
∏∏' (
x
∏∏( )
||
∏∏* ,
rotated
∏∏- 4
.
∏∏4 5
z
∏∏5 6
>
∏∏7 8
rotated
∏∏9 @
.
∏∏@ A
y
∏∏A B
?
∏∏C D
$num
∏∏E F
:
∏∏G H
$num
∏∏I J
)
ππ 
;
ππ 
}
∫∫ 
return
ºº 
new
ºº 
Vector3
ºº 
(
ºº 
rotated
ΩΩ 
.
ΩΩ 
x
ΩΩ 
>
ΩΩ 
rotated
ΩΩ #
.
ΩΩ# $
y
ΩΩ$ %
&&
ΩΩ& (
rotated
ΩΩ) 0
.
ΩΩ0 1
x
ΩΩ1 2
>
ΩΩ3 4
rotated
ΩΩ5 <
.
ΩΩ< =
z
ΩΩ= >
?
ΩΩ? @
$num
ΩΩA B
:
ΩΩC D
$num
ΩΩE F
,
ΩΩF G
rotated
ææ 
.
ææ 
y
ææ 
>
ææ 
rotated
ææ #
.
ææ# $
z
ææ$ %
&&
ææ& (
rotated
ææ) 0
.
ææ0 1
y
ææ1 2
>
ææ3 4
rotated
ææ5 <
.
ææ< =
x
ææ= >
?
ææ? @
$num
ææA B
:
ææC D
$num
ææE F
,
ææF G
rotated
øø 
.
øø 
z
øø 
>
øø 
rotated
øø #
.
øø# $
x
øø$ %
&&
øø& (
rotated
øø) 0
.
øø0 1
z
øø1 2
>
øø3 4
rotated
øø5 <
.
øø< =
y
øø= >
?
øø? @
$num
øøA B
:
øøC D
$num
øøE F
)
øøF G
;
øøG H
}
¿¿ 	
public
¬¬ 
static
¬¬ 
bool
¬¬ 
operator
¬¬ #
==
¬¬$ &
(
¬¬& '
Vector3Mask
¬¬' 2
left
¬¬3 7
,
¬¬7 8
Vector3Mask
¬¬9 D
right
¬¬E J
)
¬¬J K
{
√√ 	
return
ƒƒ 
left
ƒƒ 
.
ƒƒ 
m_Mask
ƒƒ 
==
ƒƒ !
right
ƒƒ" '
.
ƒƒ' (
m_Mask
ƒƒ( .
;
ƒƒ. /
}
≈≈ 	
public
«« 
static
«« 
bool
«« 
operator
«« #
!=
««$ &
(
««& '
Vector3Mask
««' 2
left
««3 7
,
««7 8
Vector3Mask
««9 D
right
««E J
)
««J K
{
»» 	
return
…… 
!
…… 
(
…… 
left
…… 
==
…… 
right
…… "
)
……" #
;
……# $
}
   	
public
ÃÃ 
float
ÃÃ 
this
ÃÃ 
[
ÃÃ 
int
ÃÃ 
i
ÃÃ 
]
ÃÃ  
{
ÕÕ 	
get
ŒŒ 
{
œœ 
if
–– 
(
–– 
i
–– 
<
–– 
$num
–– 
||
–– 
i
–– 
>
–– 
$num
––  !
)
––! "
throw
—— 
new
—— &
IndexOutOfRangeException
—— 6
(
——6 7
)
——7 8
;
——8 9
return
”” 
(
”” 
$num
”” 
&
”” 
(
”” 
m_Mask
”” #
>>
””$ &
i
””' (
)
””( )
)
””) *
*
””+ ,
$num
””- /
;
””/ 0
}
‘‘ 
set
÷÷ 
{
◊◊ 
if
ÿÿ 
(
ÿÿ 
i
ÿÿ 
<
ÿÿ 
$num
ÿÿ 
||
ÿÿ 
i
ÿÿ 
>
ÿÿ 
$num
ÿÿ  !
)
ÿÿ! "
throw
ŸŸ 
new
ŸŸ &
IndexOutOfRangeException
ŸŸ 6
(
ŸŸ6 7
)
ŸŸ7 8
;
ŸŸ8 9
m_Mask
€€ 
&=
€€ 
(
€€ 
byte
€€ 
)
€€  
~
€€! "
(
€€" #
$num
€€# $
<<
€€% '
i
€€( )
)
€€) *
;
€€* +
m_Mask
‹‹ 
|=
‹‹ 
(
‹‹ 
byte
‹‹ 
)
‹‹  
(
‹‹! "
(
‹‹" #
value
‹‹# (
>
‹‹) *
$num
‹‹+ -
?
‹‹. /
$num
‹‹0 1
:
‹‹2 3
$num
‹‹4 5
)
‹‹5 6
<<
‹‹7 9
i
‹‹: ;
)
‹‹; <
;
‹‹< =
}
›› 
}
ﬁﬁ 	
public
‡‡ 
bool
‡‡ 
Equals
‡‡ 
(
‡‡ 
Vector3Mask
‡‡ &
other
‡‡' ,
)
‡‡, -
{
·· 	
return
‚‚ 
m_Mask
‚‚ 
==
‚‚ 
other
‚‚ "
.
‚‚" #
m_Mask
‚‚# )
;
‚‚) *
}
„„ 	
public
ÂÂ 
override
ÂÂ 
bool
ÂÂ 
Equals
ÂÂ #
(
ÂÂ# $
object
ÂÂ$ *
obj
ÂÂ+ .
)
ÂÂ. /
{
ÊÊ 	
if
ÁÁ 
(
ÁÁ 
ReferenceEquals
ÁÁ 
(
ÁÁ  
null
ÁÁ  $
,
ÁÁ$ %
obj
ÁÁ& )
)
ÁÁ) *
)
ÁÁ* +
return
ÁÁ, 2
false
ÁÁ3 8
;
ÁÁ8 9
return
ËË 
obj
ËË 
is
ËË 
Vector3Mask
ËË %
&&
ËË& (
Equals
ËË) /
(
ËË/ 0
(
ËË0 1
Vector3Mask
ËË1 <
)
ËË< =
obj
ËË> A
)
ËËA B
;
ËËB C
}
ÈÈ 	
public
ÎÎ 
override
ÎÎ 
int
ÎÎ 
GetHashCode
ÎÎ '
(
ÎÎ' (
)
ÎÎ( )
{
ÏÏ 	
return
ÌÌ 
m_Mask
ÌÌ 
.
ÌÌ 
GetHashCode
ÌÌ %
(
ÌÌ% &
)
ÌÌ& '
;
ÌÌ' (
}
ÓÓ 	
}
ÔÔ 
} œ¢
óD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\UV\UVEditing.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
static 

partial 
class 
	UVEditing "
{ 
internal 
static 
Vector2 
[  
]  !
GetUVs" (
(( )
ProBuilderMesh) 7
mesh8 <
,< =
int> A
channelB I
)I J
{ 	
switch 
( 
channel 
) 
{ 
case 
$num 
: 
{ 
Mesh 
m 
= 
mesh !
.! "
mesh" &
;& '
if 
( 
m 
== 
null !
)! "
return 
null #
;# $
return 
mesh 
.  
mesh  $
.$ %
uv2% (
;( )
} 
case 
$num 
: 
case   
$num   
:   
{!! 
if"" 
("" 
channel"" 
==""  "
$num""# $
?""% &
mesh""' +
.""+ ,
	HasArrays"", 5
(""5 6

MeshArrays""6 @
.""@ A
Texture2""A I
)""I J
:""K L
mesh""M Q
.""Q R
	HasArrays""R [
(""[ \

MeshArrays""\ f
.""f g
Texture3""g o
)""o p
)""p q
{## 
List$$ 
<$$ 
Vector4$$ $
>$$$ %
uvs$$& )
=$$* +
new$$, /
List$$0 4
<$$4 5
Vector4$$5 <
>$$< =
($$= >
)$$> ?
;$$? @
mesh%% 
.%% 
GetUVs%% #
(%%# $
channel%%$ +
,%%+ ,
uvs%%- 0
)%%0 1
;%%1 2
return&& 
uvs&& "
.&&" #
Select&&# )
(&&) *
x&&* +
=>&&, .
(&&/ 0
Vector2&&0 7
)&&7 8
x&&8 9
)&&9 :
.&&: ;
ToArray&&; B
(&&B C
)&&C D
;&&D E
}'' 
return)) 
null)) 
;))  
}** 
default,, 
:,, 
return-- 
mesh-- 
.--  
texturesInternal--  0
;--0 1
}.. 
}// 	
internal44 
static44 
void44 
ApplyUVs44 %
(44% &
ProBuilderMesh44& 4
mesh445 9
,449 :
Vector244; B
[44B C
]44C D
uvs44E H
,44H I
int44J M
channel44N U
,44U V
bool44W [
applyToMesh44\ g
=44h i
true44j n
)44n o
{55 	
switch66 
(66 
channel66 
)66 
{77 
case88 
$num88 
:88 
mesh99 
.99 
texturesInternal99 )
=99* +
uvs99, /
;99/ 0
if:: 
(:: 
applyToMesh:: #
&&::$ &
mesh::' +
.::+ ,
mesh::, 0
!=::1 3
null::4 8
)::8 9
mesh;; 
.;; 
mesh;; !
.;;! "
uv;;" $
=;;% &
uvs;;' *
;;;* +
break<< 
;<< 
case>> 
$num>> 
:>> 
if?? 
(?? 
applyToMesh?? #
&&??$ &
mesh??' +
.??+ ,
mesh??, 0
!=??1 3
null??4 8
)??8 9
mesh@@ 
.@@ 
mesh@@ !
.@@! "
uv2@@" %
=@@& '
uvs@@( +
;@@+ ,
breakAA 
;AA 
caseCC 
$numCC 
:CC 
caseDD 
$numDD 
:DD 
intEE 
vcEE 
=EE 
meshEE !
.EE! "
vertexCountEE" -
;EE- .
ifFF 
(FF 
vcFF 
!=FF 
uvsFF !
.FF! "
LengthFF" (
)FF( )
throwGG 
newGG !$
IndexOutOfRangeExceptionGG" :
(GG: ;
$strGG; @
)GG@ A
;GGA B
ListHH 
<HH 
Vector4HH  
>HH  !
listHH" &
=HH' (
newHH) ,
ListHH- 1
<HH1 2
Vector4HH2 9
>HH9 :
(HH: ;
vcHH; =
)HH= >
;HH> ?
forII 
(II 
intII 
iII 
=II  
$numII! "
;II" #
iII$ %
<II& '
vcII( *
;II* +
iII, -
++II- /
)II/ 0
listJJ 
.JJ 
AddJJ  
(JJ  !
uvsJJ! $
[JJ$ %
iJJ% &
]JJ& '
)JJ' (
;JJ( )
meshKK 
.KK 
SetUVsKK 
(KK  
channelKK  '
,KK' (
listKK) -
)KK- .
;KK. /
ifLL 
(LL 
applyToMeshLL #
&&LL$ &
meshLL' +
.LL+ ,
meshLL, 0
!=LL1 3
nullLL4 8
)LL8 9
meshMM 
.MM 
meshMM !
.MM! "
SetUVsMM" (
(MM( )
channelMM) 0
,MM0 1
listMM2 6
)MM6 7
;MM7 8
breakNN 
;NN 
}OO 
}PP 	
publicYY 
staticYY 
voidYY 
SewUVsYY !
(YY! "
thisYY" &
ProBuilderMeshYY' 5
meshYY6 :
,YY: ;
intYY< ?
[YY? @
]YY@ A
indexesYYB I
,YYI J
floatYYK P
deltaYYQ V
)YYV W
{ZZ 	
Vector2[[ 
[[[ 
][[ 
uvs[[ 
=[[ 
mesh[[  
.[[  !
texturesInternal[[! 1
;[[1 2
if]] 
(]] 
uvs]] 
==]] 
null]] 
||]] 
uvs]] "
.]]" #
Length]]# )
!=]]* ,
mesh]]- 1
.]]1 2
vertexCount]]2 =
)]]= >
uvs^^ 
=^^ 
new^^ 
Vector2^^ !
[^^! "
mesh^^" &
.^^& '
vertexCount^^' 2
]^^2 3
;^^3 4
var`` 
lookup`` 
=`` 
mesh`` 
.`` 
sharedTextureLookup`` 1
;``1 2
forbb 
(bb 
intbb 
ibb 
=bb 
$numbb 
;bb 
ibb 
<bb 
indexesbb  '
.bb' (
Lengthbb( .
-bb/ 0
$numbb1 2
;bb2 3
ibb4 5
++bb5 7
)bb7 8
{cc 
fordd 
(dd 
intdd 
ndd 
=dd 
idd 
+dd  
$numdd! "
;dd" #
ndd$ %
<dd& '
indexesdd( /
.dd/ 0
Lengthdd0 6
;dd6 7
ndd8 9
++dd9 ;
)dd; <
{ee 
intff 
aff 
,ff 
bff 
;ff 
ifhh 
(hh 
!hh 
lookuphh 
.hh  
TryGetValuehh  +
(hh+ ,
indexeshh, 3
[hh3 4
ihh4 5
]hh5 6
,hh6 7
outhh8 ;
ahh< =
)hh= >
)hh> ?
lookupii 
.ii 
Addii "
(ii" #
indexesii# *
[ii* +
iii+ ,
]ii, -
,ii- .
aii/ 0
=ii1 2
lookupii3 9
.ii9 :
Countii: ?
(ii? @
)ii@ A
)iiA B
;iiB C
ifkk 
(kk 
!kk 
lookupkk 
.kk  
TryGetValuekk  +
(kk+ ,
indexeskk, 3
[kk3 4
nkk4 5
]kk5 6
,kk6 7
outkk8 ;
bkk< =
)kk= >
)kk> ?
lookupll 
.ll 
Addll "
(ll" #
indexesll# *
[ll* +
nll+ ,
]ll, -
,ll- .
bll/ 0
=ll1 2
lookupll3 9
.ll9 :
Countll: ?
(ll? @
)ll@ A
)llA B
;llB C
ifnn 
(nn 
ann 
==nn 
bnn 
)nn 
continueoo  
;oo  !
ifqq 
(qq 
Vector2qq 
.qq  
Distanceqq  (
(qq( )
uvsqq) ,
[qq, -
indexesqq- 4
[qq4 5
iqq5 6
]qq6 7
]qq7 8
,qq8 9
uvsqq: =
[qq= >
indexesqq> E
[qqE F
nqqF G
]qqG H
]qqH I
)qqI J
<qqK L
deltaqqM R
)qqR S
{rr 
Vector3ss 
censs  #
=ss$ %
(ss& '
uvsss' *
[ss* +
indexesss+ 2
[ss2 3
iss3 4
]ss4 5
]ss5 6
+ss7 8
uvsss9 <
[ss< =
indexesss= D
[ssD E
nssE F
]ssF G
]ssG H
)ssH I
/ssJ K
$numssL N
;ssN O
uvsuu 
[uu 
indexesuu #
[uu# $
iuu$ %
]uu% &
]uu& '
=uu( )
cenuu* -
;uu- .
uvsvv 
[vv 
indexesvv #
[vv# $
nvv$ %
]vv% &
]vv& '
=vv( )
cenvv* -
;vv- .
varzz 
mergezz !
=zz" #
lookupzz$ *
.zz* +
Wherezz+ 0
(zz0 1
xzz1 2
=>zz3 5
xzz6 7
.zz7 8
Valuezz8 =
==zz> @
bzzA B
)zzB C
.zzC D
SelectzzD J
(zzJ K
yzzK L
=>zzM O
yzzP Q
.zzQ R
KeyzzR U
)zzU V
.zzV W
ToArrayzzW ^
(zz^ _
)zz_ `
;zz` a
foreach|| 
(||  !
var||! $
key||% (
in||) +
merge||, 1
)||1 2
lookup}} "
[}}" #
key}}# &
]}}& '
=}}( )
a}}* +
;}}+ ,
}~~ 
} 
}
ÄÄ 
mesh
ÇÇ 
.
ÇÇ 
SetSharedTextures
ÇÇ "
(
ÇÇ" #
lookup
ÇÇ# )
)
ÇÇ) *
;
ÇÇ* +
}
ÉÉ 	
public
ää 
static
ää 
void
ää 
CollapseUVs
ää &
(
ää& '
this
ää' +
ProBuilderMesh
ää, :
mesh
ää; ?
,
ää? @
int
ääA D
[
ääD E
]
ääE F
indexes
ääG N
)
ääN O
{
ãã 	
Vector2
åå 
[
åå 
]
åå 
uvs
åå 
=
åå 
mesh
åå  
.
åå  !
texturesInternal
åå! 1
;
åå1 2
Vector2
èè 
cen
èè 
=
èè 
Math
èè 
.
èè 
Average
èè &
(
èè& '
ArrayUtility
èè' 3
.
èè3 4
ValuesWithIndexes
èè4 E
(
èèE F
uvs
èèF I
,
èèI J
indexes
èèK R
)
èèR S
)
èèS T
;
èèT U
foreach
ëë 
(
ëë 
int
ëë 
i
ëë 
in
ëë 
indexes
ëë %
)
ëë% &
uvs
íí 
[
íí 
i
íí 
]
íí 
=
íí 
cen
íí 
;
íí 
mesh
îî 
.
îî #
SetTexturesCoincident
îî &
(
îî& '
indexes
îî' .
)
îî. /
;
îî/ 0
}
ïï 	
public
úú 
static
úú 
void
úú 
SplitUVs
úú #
(
úú# $
this
úú$ (
ProBuilderMesh
úú) 7
mesh
úú8 <
,
úú< =
IEnumerable
úú> I
<
úúI J
int
úúJ M
>
úúM N
indexes
úúO V
)
úúV W
{
ùù 	
var
ûû 
lookup
ûû 
=
ûû 
mesh
ûû 
.
ûû !
sharedTextureLookup
ûû 1
;
ûû1 2
var
üü 
index
üü 
=
üü 
lookup
üü 
.
üü 
Count
üü $
;
üü$ %
foreach
°° 
(
°° 
var
°° 
vertex
°° 
in
°°  "
indexes
°°# *
)
°°* +
{
¢¢ 
int
££ 
a
££ 
;
££ 
if
•• 
(
•• 
lookup
•• 
.
•• 
TryGetValue
•• &
(
••& '
vertex
••' -
,
••- .
out
••/ 2
a
••3 4
)
••4 5
)
••5 6
lookup
¶¶ 
[
¶¶ 
vertex
¶¶ !
]
¶¶! "
=
¶¶# $
index
¶¶% *
++
¶¶* ,
;
¶¶, -
}
ßß 
mesh
©© 
.
©© 
SetSharedTextures
©© "
(
©©" #
lookup
©©# )
)
©©) *
;
©©* +
}
™™ 	
internal
ØØ 
static
ØØ 
void
ØØ 
SplitUVs
ØØ %
(
ØØ% &
ProBuilderMesh
ØØ& 4
mesh
ØØ5 9
,
ØØ9 :
IEnumerable
ØØ; F
<
ØØF G
Face
ØØG K
>
ØØK L
faces
ØØM R
)
ØØR S
{
∞∞ 	
var
±± 
lookup
±± 
=
±± 
mesh
±± 
.
±± !
sharedTextureLookup
±± 1
;
±±1 2
var
≤≤ 
index
≤≤ 
=
≤≤ 
lookup
≤≤ 
.
≤≤ 
Count
≤≤ $
;
≤≤$ %
foreach
¥¥ 
(
¥¥ 
var
¥¥ 
face
¥¥ 
in
¥¥ 
faces
¥¥  %
)
¥¥% &
{
µµ 
foreach
∂∂ 
(
∂∂ 
var
∂∂ 
vertex
∂∂ #
in
∂∂$ &
face
∂∂' +
.
∂∂+ ,%
distinctIndexesInternal
∂∂, C
)
∂∂C D
{
∑∑ 
int
∏∏ 
a
∏∏ 
;
∏∏ 
if
∫∫ 
(
∫∫ 
lookup
∫∫ 
.
∫∫ 
TryGetValue
∫∫ *
(
∫∫* +
vertex
∫∫+ 1
,
∫∫1 2
out
∫∫3 6
a
∫∫7 8
)
∫∫8 9
)
∫∫9 :
lookup
ªª 
[
ªª 
vertex
ªª %
]
ªª% &
=
ªª' (
index
ªª) .
++
ªª. 0
;
ªª0 1
}
ºº 
}
ΩΩ 
mesh
øø 
.
øø 
SetSharedTextures
øø "
(
øø" #
lookup
øø# )
)
øø) *
;
øø* +
}
¿¿ 	
internal
…… 
static
…… 
void
…… 
ProjectFacesAuto
…… -
(
……- .
ProBuilderMesh
……. <
mesh
……= A
,
……A B
Face
……C G
[
……G H
]
……H I
faces
……J O
,
……O P
int
……Q T
channel
……U \
)
……\ ]
{
   	
if
ÀÀ 
(
ÀÀ 
faces
ÀÀ 
.
ÀÀ 
Length
ÀÀ 
<
ÀÀ 
$num
ÀÀ  
)
ÀÀ  !
return
ÃÃ 
;
ÃÃ 
int
ŒŒ 
[
ŒŒ 
]
ŒŒ 
ind
ŒŒ 
=
ŒŒ 
faces
ŒŒ 
.
ŒŒ 

SelectMany
ŒŒ (
(
ŒŒ( )
x
ŒŒ) *
=>
ŒŒ+ -
x
ŒŒ. /
.
ŒŒ/ 0%
distinctIndexesInternal
ŒŒ0 G
)
ŒŒG H
.
ŒŒH I
ToArray
ŒŒI P
(
ŒŒP Q
)
ŒŒQ R
;
ŒŒR S
var
—— !
projectionDirection
—— #
=
——$ %
Vector3
——& -
.
——- .
zero
——. 2
;
——2 3
foreach
”” 
(
”” 
var
”” 
face
”” 
in
””  
faces
””! &
)
””& '
{
‘‘ 
var
’’ 
nrm
’’ 
=
’’ 
Math
’’ 
.
’’ 
Normal
’’ %
(
’’% &
mesh
’’& *
,
’’* +
face
’’, 0
)
’’0 1
;
’’1 2!
projectionDirection
÷÷ #
+=
÷÷$ &
nrm
÷÷' *
;
÷÷* +
}
◊◊ !
projectionDirection
ŸŸ 
/=
ŸŸ  "
(
ŸŸ# $
float
ŸŸ$ )
)
ŸŸ) *
faces
ŸŸ+ 0
.
ŸŸ0 1
Length
ŸŸ1 7
;
ŸŸ7 8
Vector2
‹‹ 
[
‹‹ 
]
‹‹ 
uvs
‹‹ 
=
‹‹ 

Projection
‹‹ &
.
‹‹& '
PlanarProject
‹‹' 4
(
‹‹4 5
mesh
‹‹5 9
.
‹‹9 :
positionsInternal
‹‹: K
,
‹‹K L
ind
‹‹M P
,
‹‹P Q!
projectionDirection
‹‹R e
)
‹‹e f
;
‹‹f g
Vector2
ﬂﬂ 
[
ﬂﬂ 
]
ﬂﬂ 

rebuiltUVs
ﬂﬂ  
=
ﬂﬂ! "
GetUVs
ﬂﬂ# )
(
ﬂﬂ) *
mesh
ﬂﬂ* .
,
ﬂﬂ. /
channel
ﬂﬂ0 7
)
ﬂﬂ7 8
;
ﬂﬂ8 9
for
·· 
(
·· 
int
·· 
i
·· 
=
·· 
$num
·· 
;
·· 
i
·· 
<
·· 
ind
··  #
.
··# $
Length
··$ *
;
··* +
i
··, -
++
··- /
)
··/ 0

rebuiltUVs
‚‚ 
[
‚‚ 
ind
‚‚ 
[
‚‚ 
i
‚‚  
]
‚‚  !
]
‚‚! "
=
‚‚# $
uvs
‚‚% (
[
‚‚( )
i
‚‚) *
]
‚‚* +
;
‚‚+ ,
ApplyUVs
ÂÂ 
(
ÂÂ 
mesh
ÂÂ 
,
ÂÂ 

rebuiltUVs
ÂÂ %
,
ÂÂ% &
channel
ÂÂ' .
)
ÂÂ. /
;
ÂÂ/ 0
foreach
ËË 
(
ËË 
Face
ËË 
f
ËË 
in
ËË 
faces
ËË $
)
ËË$ %
{
ÈÈ 
f
ÍÍ 
.
ÍÍ 
elementGroup
ÍÍ 
=
ÍÍ  
-
ÍÍ! "
$num
ÍÍ" #
;
ÍÍ# $
SplitUVs
ÎÎ 
(
ÎÎ 
mesh
ÎÎ 
,
ÎÎ 
f
ÎÎ  
.
ÎÎ  !%
distinctIndexesInternal
ÎÎ! 8
)
ÎÎ8 9
;
ÎÎ9 :
}
ÏÏ 
mesh
ÓÓ 
.
ÓÓ 
SewUVs
ÓÓ 
(
ÓÓ 
faces
ÓÓ 
.
ÓÓ 

SelectMany
ÓÓ (
(
ÓÓ( )
x
ÓÓ) *
=>
ÓÓ+ -
x
ÓÓ. /
.
ÓÓ/ 0%
distinctIndexesInternal
ÓÓ0 G
)
ÓÓG H
.
ÓÓH I
ToArray
ÓÓI P
(
ÓÓP Q
)
ÓÓQ R
,
ÓÓR S
$num
ÓÓT Y
)
ÓÓY Z
;
ÓÓZ [
}
ÔÔ 	
public
˜˜ 
static
˜˜ 
void
˜˜ 
ProjectFacesBox
˜˜ *
(
˜˜* +
ProBuilderMesh
˜˜+ 9
mesh
˜˜: >
,
˜˜> ?
Face
˜˜@ D
[
˜˜D E
]
˜˜E F
faces
˜˜G L
,
˜˜L M
int
˜˜N Q
channel
˜˜R Y
=
˜˜Z [
$num
˜˜\ ]
)
˜˜] ^
{
¯¯ 	
Vector2
˘˘ 
[
˘˘ 
]
˘˘ 
uv
˘˘ 
=
˘˘ 
GetUVs
˘˘ !
(
˘˘! "
mesh
˘˘" &
,
˘˘& '
channel
˘˘( /
)
˘˘/ 0
;
˘˘0 1

Dictionary
˚˚ 
<
˚˚ 
ProjectionAxis
˚˚ %
,
˚˚% &
List
˚˚' +
<
˚˚+ ,
Face
˚˚, 0
>
˚˚0 1
>
˚˚1 2
sorted
˚˚3 9
=
˚˚: ;
new
˚˚< ?

Dictionary
˚˚@ J
<
˚˚J K
ProjectionAxis
˚˚K Y
,
˚˚Y Z
List
˚˚[ _
<
˚˚_ `
Face
˚˚` d
>
˚˚d e
>
˚˚e f
(
˚˚f g
)
˚˚g h
;
˚˚h i
for
˝˝ 
(
˝˝ 
int
˝˝ 
i
˝˝ 
=
˝˝ 
$num
˝˝ 
;
˝˝ 
i
˝˝ 
<
˝˝ 
faces
˝˝  %
.
˝˝% &
Length
˝˝& ,
;
˝˝, -
i
˝˝. /
++
˝˝/ 1
)
˝˝1 2
{
˛˛ 
Vector3
ˇˇ 
nrm
ˇˇ 
=
ˇˇ 
Math
ˇˇ "
.
ˇˇ" #
Normal
ˇˇ# )
(
ˇˇ) *
mesh
ˇˇ* .
,
ˇˇ. /
faces
ˇˇ0 5
[
ˇˇ5 6
i
ˇˇ6 7
]
ˇˇ7 8
)
ˇˇ8 9
;
ˇˇ9 :
ProjectionAxis
ÄÄ 
axis
ÄÄ #
=
ÄÄ$ %

Projection
ÄÄ& 0
.
ÄÄ0 1$
VectorToProjectionAxis
ÄÄ1 G
(
ÄÄG H
nrm
ÄÄH K
)
ÄÄK L
;
ÄÄL M
if
ÇÇ 
(
ÇÇ 
sorted
ÇÇ 
.
ÇÇ 
ContainsKey
ÇÇ &
(
ÇÇ& '
axis
ÇÇ' +
)
ÇÇ+ ,
)
ÇÇ, -
sorted
ÉÉ 
[
ÉÉ 
axis
ÉÉ 
]
ÉÉ  
.
ÉÉ  !
Add
ÉÉ! $
(
ÉÉ$ %
faces
ÉÉ% *
[
ÉÉ* +
i
ÉÉ+ ,
]
ÉÉ, -
)
ÉÉ- .
;
ÉÉ. /
else
ÑÑ 
sorted
ÖÖ 
.
ÖÖ 
Add
ÖÖ 
(
ÖÖ 
axis
ÖÖ #
,
ÖÖ# $
new
ÖÖ% (
List
ÖÖ) -
<
ÖÖ- .
Face
ÖÖ. 2
>
ÖÖ2 3
(
ÖÖ3 4
)
ÖÖ4 5
{
ÖÖ6 7
faces
ÖÖ8 =
[
ÖÖ= >
i
ÖÖ> ?
]
ÖÖ? @
}
ÖÖA B
)
ÖÖB C
;
ÖÖC D
faces
àà 
[
àà 
i
àà 
]
àà 
.
àà 
elementGroup
àà %
=
àà& '
-
àà( )
$num
àà) *
;
àà* +
faces
ââ 
[
ââ 
i
ââ 
]
ââ 
.
ââ 
manualUV
ââ !
=
ââ" #
true
ââ$ (
;
ââ( )
}
ää 
foreach
åå 
(
åå 
KeyValuePair
åå !
<
åå! "
ProjectionAxis
åå" 0
,
åå0 1
List
åå2 6
<
åå6 7
Face
åå7 ;
>
åå; <
>
åå< =
kvp
åå> A
in
ååB D
sorted
ååE K
)
ååK L
{
çç 
int
éé 
[
éé 
]
éé 
distinct
éé 
=
éé  
kvp
éé! $
.
éé$ %
Value
éé% *
.
éé* +

SelectMany
éé+ 5
(
éé5 6
x
éé6 7
=>
éé8 :
x
éé; <
.
éé< =%
distinctIndexesInternal
éé= T
)
ééT U
.
ééU V
ToArray
ééV ]
(
éé] ^
)
éé^ _
;
éé_ `
Vector2
êê 
[
êê 
]
êê 
uvs
êê 
=
êê 

Projection
êê  *
.
êê* +
PlanarProject
êê+ 8
(
êê8 9
mesh
êê9 =
.
êê= >
positionsInternal
êê> O
,
êêO P
distinct
êêQ Y
,
êêY Z

Projection
êê[ e
.
êêe f$
ProjectionAxisToVector
êêf |
(
êê| }
kvpêê} Ä
.êêÄ Å
KeyêêÅ Ñ
)êêÑ Ö
)êêÖ Ü
;êêÜ á
for
íí 
(
íí 
int
íí 
n
íí 
=
íí 
$num
íí 
;
íí 
n
íí  !
<
íí" #
distinct
íí$ ,
.
íí, -
Length
íí- 3
;
íí3 4
n
íí5 6
++
íí6 8
)
íí8 9
uv
ìì 
[
ìì 
distinct
ìì 
[
ìì  
n
ìì  !
]
ìì! "
]
ìì" #
=
ìì$ %
uvs
ìì& )
[
ìì) *
n
ìì* +
]
ìì+ ,
;
ìì, -
SplitUVs
ïï 
(
ïï 
mesh
ïï 
,
ïï 
distinct
ïï '
)
ïï' (
;
ïï( )
}
ññ 
ApplyUVs
ôô 
(
ôô 
mesh
ôô 
,
ôô 
uv
ôô 
,
ôô 
channel
ôô &
)
ôô& '
;
ôô' (
}
öö 	
internal
üü 
static
üü 
Vector2
üü 
FindMinimalUV
üü  -
(
üü- .
Vector2
üü. 5
[
üü5 6
]
üü6 7
uvs
üü8 ;
,
üü; <
int
üü= @
[
üü@ A
]
üüA B
indices
üüC J
=
üüK L
null
üüM Q
,
üüQ R
float
üüS X
xMin
üüY ]
=
üü^ _
$num
üü` b
,
üüb c
float
üüd i
yMin
üüj n
=
üüo p
$num
üüq s
)
üüs t
{
†† 	
int
°° 

nbElements
°° 
=
°° 
(
°° 
indices
°° %
==
°°& (
null
°°) -
?
°°. /
uvs
°°0 3
.
°°3 4
Length
°°4 :
:
°°; <
indices
°°= D
.
°°D E
Length
°°E K
)
°°K L
;
°°L M
bool
¢¢ 
first
¢¢ 
=
¢¢ 
(
¢¢ 
xMin
¢¢ 
==
¢¢ !
$num
¢¢" $
&&
¢¢% '
yMin
¢¢( ,
==
¢¢- /
$num
¢¢0 2
)
¢¢2 3
;
¢¢3 4
for
££ 
(
££ 
int
££ 
i
££ 
=
££ 
$num
££ 
;
££ 
i
££ 
<
££ 

nbElements
££  *
;
££* +
++
££, .
i
££. /
)
££/ 0
{
§§ 
int
•• 
currentIndex
••  
=
••! "
(
••# $
indices
••$ +
==
••, .
null
••/ 3
?
••4 5
i
••6 7
:
••8 9
indices
••: A
[
••A B
i
••B C
]
••C D
)
••D E
;
••E F
if
¶¶ 
(
¶¶ 
first
¶¶ 
)
¶¶ 
{
ßß 
xMin
®® 
=
®® 
uvs
®® 
[
®® 
currentIndex
®® +
]
®®+ ,
.
®®, -
x
®®- .
;
®®. /
yMin
©© 
=
©© 
uvs
©© 
[
©© 
currentIndex
©© +
]
©©+ ,
.
©©, -
y
©©- .
;
©©. /
first
™™ 
=
™™ 
false
™™ !
;
™™! "
}
´´ 
else
¨¨ 
{
≠≠ 
if
ØØ 
(
ØØ 
uvs
ØØ 
[
ØØ 
currentIndex
ØØ (
]
ØØ( )
.
ØØ) *
x
ØØ* +
<
ØØ, -
xMin
ØØ. 2
)
ØØ2 3
{
∞∞ 
xMin
±± 
=
±± 
uvs
±± "
[
±±" #
currentIndex
±±# /
]
±±/ 0
.
±±0 1
x
±±1 2
;
±±2 3
}
≤≤ 
if
¥¥ 
(
¥¥ 
uvs
¥¥ 
[
¥¥ 
currentIndex
¥¥ (
]
¥¥( )
.
¥¥) *
y
¥¥* +
<
¥¥, -
yMin
¥¥. 2
)
¥¥2 3
{
µµ 
yMin
∂∂ 
=
∂∂ 
uvs
∂∂ "
[
∂∂" #
currentIndex
∂∂# /
]
∂∂/ 0
.
∂∂0 1
y
∂∂1 2
;
∂∂2 3
}
∑∑ 
}
∏∏ 
}
ππ 
return
ªª 
new
ªª 
Vector2
ªª 
(
ªª 
xMin
ªª #
,
ªª# $
yMin
ªª% )
)
ªª) *
;
ªª* +
}
ºº 	
public
≈≈ 
static
≈≈ 
void
≈≈ 
ProjectFacesBox
≈≈ *
(
≈≈* +
ProBuilderMesh
≈≈+ 9
mesh
≈≈: >
,
≈≈> ?
Face
≈≈@ D
[
≈≈D E
]
≈≈E F
faces
≈≈G L
,
≈≈L M
Vector2
≈≈N U
lowerLeftAnchor
≈≈V e
,
≈≈e f
int
≈≈g j
channel
≈≈k r
=
≈≈s t
$num
≈≈u v
)
≈≈v w
{
∆∆ 	
Vector2
«« 
[
«« 
]
«« 
uv
«« 
=
«« 
GetUVs
«« !
(
««! "
mesh
««" &
,
««& '
channel
««( /
)
««/ 0
;
««0 1

Dictionary
…… 
<
…… 
ProjectionAxis
…… %
,
……% &
List
……' +
<
……+ ,
Face
……, 0
>
……0 1
>
……1 2
sorted
……3 9
=
……: ;
new
……< ?

Dictionary
……@ J
<
……J K
ProjectionAxis
……K Y
,
……Y Z
List
……[ _
<
……_ `
Face
……` d
>
……d e
>
……e f
(
……f g
)
……g h
;
……h i
for
ÀÀ 
(
ÀÀ 
int
ÀÀ 
i
ÀÀ 
=
ÀÀ 
$num
ÀÀ 
;
ÀÀ 
i
ÀÀ 
<
ÀÀ 
faces
ÀÀ  %
.
ÀÀ% &
Length
ÀÀ& ,
;
ÀÀ, -
i
ÀÀ. /
++
ÀÀ/ 1
)
ÀÀ1 2
{
ÃÃ 
Vector3
ÕÕ 
nrm
ÕÕ 
=
ÕÕ 
Math
ÕÕ "
.
ÕÕ" #
Normal
ÕÕ# )
(
ÕÕ) *
mesh
ÕÕ* .
,
ÕÕ. /
faces
ÕÕ0 5
[
ÕÕ5 6
i
ÕÕ6 7
]
ÕÕ7 8
)
ÕÕ8 9
;
ÕÕ9 :
ProjectionAxis
ŒŒ 
axis
ŒŒ #
=
ŒŒ$ %

Projection
ŒŒ& 0
.
ŒŒ0 1$
VectorToProjectionAxis
ŒŒ1 G
(
ŒŒG H
nrm
ŒŒH K
)
ŒŒK L
;
ŒŒL M
if
–– 
(
–– 
sorted
–– 
.
–– 
ContainsKey
–– &
(
––& '
axis
––' +
)
––+ ,
)
––, -
sorted
—— 
[
—— 
axis
—— 
]
——  
.
——  !
Add
——! $
(
——$ %
faces
——% *
[
——* +
i
——+ ,
]
——, -
)
——- .
;
——. /
else
““ 
sorted
”” 
.
”” 
Add
”” 
(
”” 
axis
”” #
,
””# $
new
””% (
List
””) -
<
””- .
Face
””. 2
>
””2 3
(
””3 4
)
””4 5
{
””6 7
faces
””8 =
[
””= >
i
””> ?
]
””? @
}
””A B
)
””B C
;
””C D
faces
÷÷ 
[
÷÷ 
i
÷÷ 
]
÷÷ 
.
÷÷ 
elementGroup
÷÷ %
=
÷÷& '
-
÷÷( )
$num
÷÷) *
;
÷÷* +
faces
◊◊ 
[
◊◊ 
i
◊◊ 
]
◊◊ 
.
◊◊ 
manualUV
◊◊ !
=
◊◊" #
true
◊◊$ (
;
◊◊( )
}
ÿÿ 
foreach
⁄⁄ 
(
⁄⁄ 
KeyValuePair
⁄⁄ !
<
⁄⁄! "
ProjectionAxis
⁄⁄" 0
,
⁄⁄0 1
List
⁄⁄2 6
<
⁄⁄6 7
Face
⁄⁄7 ;
>
⁄⁄; <
>
⁄⁄< =
kvp
⁄⁄> A
in
⁄⁄B D
sorted
⁄⁄E K
)
⁄⁄K L
{
€€ 
int
‹‹ 
[
‹‹ 
]
‹‹ 
distinct
‹‹ 
=
‹‹  
kvp
‹‹! $
.
‹‹$ %
Value
‹‹% *
.
‹‹* +

SelectMany
‹‹+ 5
(
‹‹5 6
x
‹‹6 7
=>
‹‹8 :
x
‹‹; <
.
‹‹< =%
distinctIndexesInternal
‹‹= T
)
‹‹T U
.
‹‹U V
ToArray
‹‹V ]
(
‹‹] ^
)
‹‹^ _
;
‹‹_ `
Vector2
ﬁﬁ 
[
ﬁﬁ 
]
ﬁﬁ 
uvs
ﬁﬁ 
=
ﬁﬁ 

Projection
ﬁﬁ  *
.
ﬁﬁ* +
PlanarProject
ﬁﬁ+ 8
(
ﬁﬁ8 9
mesh
ﬁﬁ9 =
.
ﬁﬁ= >
positionsInternal
ﬁﬁ> O
,
ﬁﬁO P
distinct
ﬁﬁQ Y
,
ﬁﬁY Z

Projection
ﬁﬁ[ e
.
ﬁﬁe f$
ProjectionAxisToVector
ﬁﬁf |
(
ﬁﬁ| }
kvpﬁﬁ} Ä
.ﬁﬁÄ Å
KeyﬁﬁÅ Ñ
)ﬁﬁÑ Ö
)ﬁﬁÖ Ü
;ﬁﬁÜ á
Vector2
·· 
	minimalUV
·· !
=
··" #
FindMinimalUV
··$ 1
(
··1 2
uvs
··2 5
)
··5 6
;
··6 7
for
„„ 
(
„„ 
int
„„ 
n
„„ 
=
„„ 
$num
„„ 
;
„„ 
n
„„  !
<
„„" #
distinct
„„$ ,
.
„„, -
Length
„„- 3
;
„„3 4
n
„„5 6
++
„„6 8
)
„„8 9
uv
‰‰ 
[
‰‰ 
distinct
‰‰ 
[
‰‰  
n
‰‰  !
]
‰‰! "
]
‰‰" #
=
‰‰$ %
uvs
‰‰& )
[
‰‰) *
n
‰‰* +
]
‰‰+ ,
-
‰‰- .
	minimalUV
‰‰/ 8
;
‰‰8 9
SplitUVs
ÊÊ 
(
ÊÊ 
mesh
ÊÊ 
,
ÊÊ 
distinct
ÊÊ '
)
ÊÊ' (
;
ÊÊ( )
}
ÁÁ 
ApplyUVs
ÍÍ 
(
ÍÍ 
mesh
ÍÍ 
,
ÍÍ 
uv
ÍÍ 
,
ÍÍ 
channel
ÍÍ &
)
ÍÍ& '
;
ÍÍ' (
}
ÎÎ 	
public
ÛÛ 
static
ÛÛ 
void
ÛÛ  
ProjectFacesSphere
ÛÛ -
(
ÛÛ- .
ProBuilderMesh
ÛÛ. <
pb
ÛÛ= ?
,
ÛÛ? @
int
ÛÛA D
[
ÛÛD E
]
ÛÛE F
indexes
ÛÛG N
,
ÛÛN O
int
ÛÛP S
channel
ÛÛT [
=
ÛÛ\ ]
$num
ÛÛ^ _
)
ÛÛ_ `
{
ÙÙ 	
foreach
ıı 
(
ıı 
Face
ıı 
f
ıı 
in
ıı 
pb
ıı !
.
ıı! "
facesInternal
ıı" /
)
ıı/ 0
{
ˆˆ 
if
˜˜ 
(
˜˜ 
ArrayUtility
˜˜  
.
˜˜  !
ContainsMatch
˜˜! .
<
˜˜. /
int
˜˜/ 2
>
˜˜2 3
(
˜˜3 4
f
˜˜4 5
.
˜˜5 6%
distinctIndexesInternal
˜˜6 M
,
˜˜M N
indexes
˜˜O V
)
˜˜V W
)
˜˜W X
{
¯¯ 
f
˘˘ 
.
˘˘ 
elementGroup
˘˘ "
=
˘˘# $
-
˘˘% &
$num
˘˘& '
;
˘˘' (
f
˙˙ 
.
˙˙ 
manualUV
˙˙ 
=
˙˙  
true
˙˙! %
;
˙˙% &
}
˚˚ 
}
¸¸ 
SplitUVs
˛˛ 
(
˛˛ 
pb
˛˛ 
,
˛˛ 
indexes
˛˛  
)
˛˛  !
;
˛˛! "
Vector2
ÄÄ 
[
ÄÄ 
]
ÄÄ 
	projected
ÄÄ 
=
ÄÄ  !

Projection
ÄÄ" ,
.
ÄÄ, -
SphericalProject
ÄÄ- =
(
ÄÄ= >
pb
ÄÄ> @
.
ÄÄ@ A
positionsInternal
ÄÄA R
,
ÄÄR S
indexes
ÄÄT [
)
ÄÄ[ \
;
ÄÄ\ ]
Vector2
ÅÅ 
[
ÅÅ 
]
ÅÅ 
uv
ÅÅ 
=
ÅÅ 
GetUVs
ÅÅ !
(
ÅÅ! "
pb
ÅÅ" $
,
ÅÅ$ %
channel
ÅÅ& -
)
ÅÅ- .
;
ÅÅ. /
for
ÉÉ 
(
ÉÉ 
int
ÉÉ 
i
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
;
ÉÉ 
i
ÉÉ 
<
ÉÉ 
indexes
ÉÉ  '
.
ÉÉ' (
Length
ÉÉ( .
;
ÉÉ. /
i
ÉÉ0 1
++
ÉÉ1 3
)
ÉÉ3 4
uv
ÑÑ 
[
ÑÑ 
indexes
ÑÑ 
[
ÑÑ 
i
ÑÑ 
]
ÑÑ 
]
ÑÑ 
=
ÑÑ  
	projected
ÑÑ! *
[
ÑÑ* +
i
ÑÑ+ ,
]
ÑÑ, -
;
ÑÑ- .
ApplyUVs
áá 
(
áá 
pb
áá 
,
áá 
uv
áá 
,
áá 
channel
áá $
)
áá$ %
;
áá% &
}
àà 	
public
çç 
static
çç 
Vector2
çç 
[
çç 
]
çç 
FitUVs
çç  &
(
çç& '
Vector2
çç' .
[
çç. /
]
çç/ 0
uvs
çç1 4
)
çç4 5
{
éé 	
Vector2
êê 
smallestVector2
êê #
=
êê$ %
Math
êê& *
.
êê* +
SmallestVector2
êê+ :
(
êê: ;
uvs
êê; >
)
êê> ?
;
êê? @
int
íí 
i
íí 
;
íí 
for
ìì 
(
ìì 
i
ìì 
=
ìì 
$num
ìì 
;
ìì 
i
ìì 
<
ìì 
uvs
ìì 
.
ìì  
Length
ìì  &
;
ìì& '
i
ìì( )
++
ìì) +
)
ìì+ ,
{
îî 
uvs
ïï 
[
ïï 
i
ïï 
]
ïï 
-=
ïï 
smallestVector2
ïï )
;
ïï) *
}
ññ 
float
òò 
scale
òò 
=
òò 
Math
òò 
.
òò 
LargestValue
òò +
(
òò+ ,
Math
òò, 0
.
òò0 1
LargestVector2
òò1 ?
(
òò? @
uvs
òò@ C
)
òòC D
)
òòD E
;
òòE F
for
öö 
(
öö 
i
öö 
=
öö 
$num
öö 
;
öö 
i
öö 
<
öö 
uvs
öö 
.
öö  
Length
öö  &
;
öö& '
i
öö( )
++
öö) +
)
öö+ ,
{
õõ 
uvs
úú 
[
úú 
i
úú 
]
úú 
/=
úú 
scale
úú 
;
úú  
}
ùù 
return
üü 
uvs
üü 
;
üü 
}
†† 	
}
°° 
}¢¢ å
âD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Shortcut.csÎÄ
êD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SelectPathFaces.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
SelectPathFaces  
{ 
static 
int 
[ 
]  
s_cachedPredecessors )
;) *
static		 
int		 
s_cachedStart		  
;		  !
static

 
ProBuilderMesh

 
s_cachedMesh

 *
;

* +
static 
int 
s_cachedFacesCount %
;% &
static 
List 
< 

WingedEdge 
> 
s_cachedWings  -
;- .
static 

Dictionary 
< 
Face 
, 
int  #
># $
s_cachedFacesIndex% 7
=8 9
new: =

Dictionary> H
<H I
FaceI M
,M N
intO R
>R S
(S T
)T U
;U V
public 
static 
List 
< 
int 
> 
GetPath  '
(' (
ProBuilderMesh( 6
mesh7 ;
,; <
int= @
startA F
,F G
intH K
endL O
)O P
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new 
System  
.  !
ArgumentException! 2
(2 3
$str3 M
,M N
$strO U
)U V
;V W
if 
( 
start 
< 
$num 
|| 
start "
># $
mesh% )
.) *
	faceCount* 3
-4 5
$num6 7
)7 8
throw 
new 
System  
.  !
ArgumentException! 2
(2 3
$str3 O
,O P
$strQ X
)X Y
;Y Z
if 
( 
end 
< 
$num 
|| 
end 
>  
mesh! %
.% &
	faceCount& /
-0 1
$num2 3
)3 4
throw 
new 
System  
.  !
ArgumentException! 2
(2 3
$str3 O
,O P
$strQ V
)V W
;W X
List 
< 
int 
> 
path 
; 
if!! 
(!! 
start!! 
==!! 
s_cachedStart!! &
&&!!' )
mesh!!* .
==!!/ 1
s_cachedMesh!!2 >
&&!!? A
mesh!!C G
.!!G H
	faceCount!!H Q
==!!R T
s_cachedFacesCount!!U g
)!!g h
return"" 
GetMinimalPath"" %
(""% & 
s_cachedPredecessors""& :
,"": ;
start""< A
,""A B
end""C F
)""F G
;""G H
var$$ 
predecessors$$ 
=$$ 
Dijkstra$$ '
($$' (
mesh$$( ,
,$$, -
start$$. 3
)$$3 4
;$$4 5
path%% 
=%% 
GetMinimalPath%% !
(%%! "
predecessors%%" .
,%%. /
start%%0 5
,%%5 6
end%%7 :
)%%: ;
;%%; < 
s_cachedPredecessors&&  
=&&! "
predecessors&&# /
;&&/ 0
s_cachedStart'' 
='' 
start'' !
;''! "
s_cachedMesh(( 
=(( 
mesh(( 
;((  
return** 
path** 
;** 
}++ 	
static44 
int44 
[44 
]44 
Dijkstra44 
(44 
ProBuilderMesh44 ,
mesh44- 1
,441 2
int443 6
start447 <
)44< =
{55 	
HashSet66 
<66 
int66 
>66 
visited66  
=66! "
new66# &
HashSet66' .
<66. /
int66/ 2
>662 3
(663 4
)664 5
;665 6
HashSet77 
<77 
int77 
>77 
toVisit77  
=77! "
new77# &
HashSet77' .
<77. /
int77/ 2
>772 3
(773 4
)774 5
;775 6
if88 
(88 
s_cachedMesh88 
!=88 
mesh88  $
||88% '
s_cachedFacesCount88( :
!=88; =
mesh88> B
.88B C
	faceCount88C L
)88L M
{99 
s_cachedWings:: 
=:: 

WingedEdge::  *
.::* +
GetWingedEdges::+ 9
(::9 :
mesh::: >
,::> ?
true::@ D
)::D E
;::E F
s_cachedFacesIndex;; "
.;;" #
Clear;;# (
(;;( )
);;) *
;;;* +
s_cachedFacesCount<< "
=<<# $
mesh<<% )
.<<) *
	faceCount<<* 3
;<<3 4
for>> 
(>> 
int>> 
i>> 
=>> 
$num>> 
;>> 
i>>  !
<>>" #
mesh>>$ (
.>>( )
facesInternal>>) 6
.>>6 7
Length>>7 =
;>>= >
i>>? @
++>>@ B
)>>B C
{?? 
s_cachedFacesIndex@@ &
.@@& '
Add@@' *
(@@* +
mesh@@+ /
.@@/ 0
facesInternal@@0 =
[@@= >
i@@> ?
]@@? @
,@@@ A
i@@B C
)@@C D
;@@D E
}AA 
}BB 
intCC 
	wingCountCC 
=CC 
s_cachedWingsCC )
.CC) *
CountCC* /
;CC/ 0
floatEE 
[EE 
]EE 
weightsEE 
=EE 
newEE !
floatEE" '
[EE' (
	wingCountEE( 1
]EE1 2
;EE2 3
intFF 
[FF 
]FF 
predecessorsFF 
=FF  
newFF! $
intFF% (
[FF( )
	wingCountFF) 2
]FF2 3
;FF3 4
forHH 
(HH 
intHH 
iHH 
=HH 
$numHH 
;HH 
iHH 
<HH 
	wingCountHH  )
;HH) *
iHH+ ,
++HH, .
)HH. /
{II 
weightsJJ 
[JJ 
iJJ 
]JJ 
=JJ 
floatJJ "
.JJ" #
MaxValueJJ# +
;JJ+ ,
predecessorsKK 
[KK 
iKK 
]KK 
=KK  !
-KK" #
$numKK# $
;KK$ %
}LL 
intNN 
currentNN 
=NN 
startNN 
;NN  
weightsOO 
[OO 
currentOO 
]OO 
=OO 
$numOO  
;OO  !
visitedPP 
.PP 
AddPP 
(PP 
currentPP 
)PP  
;PP  !
whileSS 
(SS 
visitedSS 
.SS 
CountSS  
<SS! "
	wingCountSS# ,
)SS, -
{TT 
varUU 
currentWingUU 
=UU  !
s_cachedWingsUU" /
[UU/ 0
currentUU0 7
]UU7 8
;UU8 9
varVV 
	otherWingVV 
=VV 
currentWingVV  +
;VV+ ,
doXX 
{YY 
varZZ 
oppositeZZ  
=ZZ! "
	otherWingZZ# ,
.ZZ, -
oppositeZZ- 5
;ZZ5 6
if[[ 
([[ 
opposite[[  
==[[! #
null[[$ (
)[[( )
{\\ 
	otherWing]] !
=]]" #
	otherWing]]$ -
.]]- .
next]]. 2
;]]2 3
continue^^  
;^^  !
}__ 
varaa 
idxaa 
=aa 
s_cachedFacesIndexaa 0
[aa0 1
oppositeaa1 9
.aa9 :
faceaa: >
]aa> ?
;aa? @
varbb 
weightbb 
=bb  
	GetWeightbb! *
(bb* +
currentbb+ 2
,bb2 3
idxbb4 7
,bb7 8
meshbb9 =
)bb= >
;bb> ?
ifdd 
(dd 
weightsdd 
[dd  
currentdd  '
]dd' (
+dd) *
weightdd+ 1
<dd2 3
weightsdd4 ;
[dd; <
idxdd< ?
]dd? @
)dd@ A
{ee 
weightsff 
[ff  
idxff  #
]ff# $
=ff% &
weightsff' .
[ff. /
currentff/ 6
]ff6 7
+ff8 9
weightff: @
;ff@ A
predecessorsgg $
[gg$ %
idxgg% (
]gg( )
=gg* +
currentgg, 3
;gg3 4
}hh 
ifjj 
(jj 
!jj 
toVisitjj  
.jj  !
Containsjj! )
(jj) *
idxjj* -
)jj- .
&&jj/ 1
!jj2 3
visitedjj3 :
.jj: ;
Containsjj; C
(jjC D
idxjjD G
)jjG H
)jjH I
{kk 
toVisitll 
.ll  
Addll  #
(ll# $
idxll$ '
)ll' (
;ll( )
}mm 
	otherWingoo 
=oo 
	otherWingoo  )
.oo) *
nextoo* .
;oo. /
}qq 
whileqq 
(qq 
	otherWingqq "
!=qq# %
currentWingqq& 1
)qq1 2
;qq2 3
iftt 
(tt 
toVisittt 
.tt 
Counttt !
==tt" $
$numtt% &
)tt& '
{uu 
returnvv 
predecessorsvv '
;vv' (
}ww 
floatyy 
minyy 
=yy 
floatyy !
.yy! "
MaxValueyy" *
;yy* +
foreachzz 
(zz 
varzz 
izz 
inzz !
toVisitzz" )
)zz) *
{{{ 
if|| 
(|| 
weights|| 
[||  
i||  !
]||! "
<||# $
min||% (
)||( )
{}} 
min~~ 
=~~ 
weights~~ %
[~~% &
i~~& '
]~~' (
;~~( )
current 
=  !
i" #
;# $
}
ÄÄ 
}
ÅÅ 
visited
ÇÇ 
.
ÇÇ 
Add
ÇÇ 
(
ÇÇ 
current
ÇÇ #
)
ÇÇ# $
;
ÇÇ$ %
toVisit
ÉÉ 
.
ÉÉ 
Remove
ÉÉ 
(
ÉÉ 
current
ÉÉ &
)
ÉÉ& '
;
ÉÉ' (
}
ÑÑ 
return
ÜÜ 
predecessors
ÜÜ 
;
ÜÜ  
}
áá 	
static
ââ 
float
ââ 
	GetWeight
ââ 
(
ââ 
int
ââ "
face1
ââ# (
,
ââ( )
int
ââ* -
face2
ââ. 3
,
ââ3 4
ProBuilderMesh
ââ5 C
mesh
ââD H
)
ââH I
{
ää 	
const
ãã 
float
ãã 
baseCost
ãã  
=
ãã! "
$num
ãã# &
;
ãã& '
const
åå 
float
åå 

normalMult
åå "
=
åå# $
$num
åå% '
;
åå' (
const
çç 
float
çç 
distMult
çç  
=
çç! "
$num
çç# %
;
çç% &
var
êê 
n1
êê 
=
êê 
Math
êê 
.
êê 
Normal
êê  
(
êê  !
mesh
êê! %
,
êê% &
mesh
êê' +
.
êê+ ,
facesInternal
êê, 9
[
êê9 :
face1
êê: ?
]
êê? @
)
êê@ A
;
êêA B
var
ëë 
n2
ëë 
=
ëë 
Math
ëë 
.
ëë 
Normal
ëë  
(
ëë  !
mesh
ëë! %
,
ëë% &
mesh
ëë' +
.
ëë+ ,
facesInternal
ëë, 9
[
ëë9 :
face2
ëë: ?
]
ëë? @
)
ëë@ A
;
ëëA B
float
íí 

normalCost
íí 
=
íí 
(
íí  
$num
íí  "
-
íí# $
Vector3
íí% ,
.
íí, -
Dot
íí- 0
(
íí0 1
n1
íí1 3
.
íí3 4

normalized
íí4 >
,
íí> ?
n2
íí@ B
.
ííB C

normalized
ííC M
)
ííM N
)
ííN O
*
ííP Q

normalMult
ííR \
;
íí\ ]
Vector3
ïï 
p1
ïï 
=
ïï 
Vector3
ïï  
.
ïï  !
zero
ïï! %
;
ïï% &
Vector3
ññ 
p2
ññ 
=
ññ 
Vector3
ññ  
.
ññ  !
zero
ññ! %
;
ññ% &
foreach
óó 
(
óó 
var
óó 
point
óó 
in
óó !
mesh
óó" &
.
óó& '
facesInternal
óó' 4
[
óó4 5
face1
óó5 :
]
óó: ;
.
óó; <
indexesInternal
óó< K
)
óóK L
{
òò 
p1
ôô 
+=
ôô 
mesh
ôô 
.
ôô 
positionsInternal
ôô ,
[
ôô, -
point
ôô- 2
]
ôô2 3
/
ôô4 5
mesh
ôô6 :
.
ôô: ;
facesInternal
ôô; H
[
ôôH I
face1
ôôI N
]
ôôN O
.
ôôO P
indexesInternal
ôôP _
.
ôô_ `
Count
ôô` e
(
ôôe f
)
ôôf g
;
ôôg h
}
öö 
foreach
õõ 
(
õõ 
var
õõ 
point
õõ 
in
õõ !
mesh
õõ" &
.
õõ& '
facesInternal
õõ' 4
[
õõ4 5
face2
õõ5 :
]
õõ: ;
.
õõ; <
indexesInternal
õõ< K
)
õõK L
{
úú 
p2
ùù 
+=
ùù 
mesh
ùù 
.
ùù 
positionsInternal
ùù ,
[
ùù, -
point
ùù- 2
]
ùù2 3
/
ùù4 5
mesh
ùù6 :
.
ùù: ;
facesInternal
ùù; H
[
ùùH I
face2
ùùI N
]
ùùN O
.
ùùO P
indexesInternal
ùùP _
.
ùù_ `
Count
ùù` e
(
ùùe f
)
ùùf g
;
ùùg h
}
ûû 
float
†† 
distCost
†† 
=
†† 
(
†† 
p2
††  
-
††! "
p1
††# %
)
††% &
.
††& '
	magnitude
††' 0
*
††1 2
distMult
††3 ;
;
††; <
return
¢¢ 
baseCost
¢¢ 
+
¢¢ 
distCost
¢¢ &
+
¢¢' (

normalCost
¢¢) 3
;
¢¢3 4
}
££ 	
static
•• 
List
•• 
<
•• 
int
•• 
>
•• 
GetMinimalPath
•• '
(
••' (
int
••( +
[
••+ ,
]
••, -
predecessors
••. :
,
••: ;
int
••< ?
start
••@ E
,
••E F
int
••G J
end
••K N
)
••N O
{
¶¶ 	
if
ßß 
(
ßß 
predecessors
ßß 
[
ßß 
end
ßß  
]
ßß  !
==
ßß" $
-
ßß% &
$num
ßß& '
)
ßß' (
{
®® 
return
©© 
null
©© 
;
©© 
}
™™ 
Stack
´´ 
<
´´ 
int
´´ 
>
´´ 
list
´´ 
=
´´ 
new
´´ !
Stack
´´" '
<
´´' (
int
´´( +
>
´´+ ,
(
´´, -
)
´´- .
;
´´. /
int
¨¨ 
a
¨¨ 
=
¨¨ 
end
¨¨ 
;
¨¨ 
while
≠≠ 
(
≠≠ 
a
≠≠ 
!=
≠≠ 
start
≠≠ 
)
≠≠ 
{
ÆÆ 
list
ØØ 
.
ØØ 
Push
ØØ 
(
ØØ 
a
ØØ 
)
ØØ 
;
ØØ 
a
∞∞ 
=
∞∞ 
predecessors
∞∞  
[
∞∞  !
a
∞∞! "
]
∞∞" #
;
∞∞# $
}
±± 
return
≤≤ 
list
≤≤ 
.
≤≤ 
ToList
≤≤ 
(
≤≤ 
)
≤≤  
;
≤≤  !
}
≥≥ 	
}
¥¥ 
}µµ Ã1
†D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SelectionPickerRendererStandard.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
internal 
partial 
class #
SelectionPickerRenderer 2
{ 
internal 
class +
SelectionPickerRendererStandard 6
:6 7$
ISelectionPickerRenderer8 P
{ 	
public 
	Texture2D 
RenderLookupTexture 0
(0 1
Camera 
camera 
, 
Shader 
shader 
, 
string 
tag 
, 
int 
width 
= 
- 
$num 
, 
int 
height 
= 
- 
$num 
)  
{ 
bool 
autoSize 
= 
width  %
<& '
$num( )
||* ,
height- 3
<4 5
$num6 7
;7 8
int 
_width 
= 
autoSize %
?& '
(( )
int) ,
), -
camera- 3
.3 4
	pixelRect4 =
.= >
width> C
:D E
widthF K
;K L
int 
_height 
= 
autoSize &
?' (
() *
int* -
)- .
camera. 4
.4 5
	pixelRect5 >
.> ?
height? E
:F G
heightH N
;N O

GameObject 
go 
= 
new  #

GameObject$ .
(. /
)/ 0
;0 1
Camera   
	renderCam    
=  ! "
go  # %
.  % &
AddComponent  & 2
<  2 3
Camera  3 9
>  9 :
(  : ;
)  ; <
;  < =
	renderCam!! 
.!! 
CopyFrom!! "
(!!" #
camera!!# )
)!!) *
;!!* +
	renderCam## 
.## 
renderingPath## '
=##( )
RenderingPath##* 7
.##7 8
Forward##8 ?
;##? @
	renderCam$$ 
.$$ 
enabled$$ !
=$$" #
false$$$ )
;$$) *
	renderCam%% 
.%% 

clearFlags%% $
=%%% &
CameraClearFlags%%' 7
.%%7 8

SolidColor%%8 B
;%%B C
	renderCam&& 
.&& 
backgroundColor&& )
=&&* +
Color&&, 1
.&&1 2
white&&2 7
;&&7 8
	renderCam(( 
.(( 
allowHDR(( "
=((# $
false((% *
;((* +
	renderCam)) 
.)) 
	allowMSAA)) #
=))$ %
false))& +
;))+ ,
	renderCam** 
.** "
forceIntoRenderTexture** 0
=**1 2
true**3 7
;**7 8#
RenderTextureDescriptor.. '

descriptor..( 2
=..3 4
new..5 8#
RenderTextureDescriptor..9 P
(..P Q
)..Q R
{// 
width00 
=00 
_width00 "
,00" #
height11 
=11 
_height11 $
,11$ %
colorFormat22 
=22  !
renderTextureFormat22" 5
,225 6
autoGenerateMips33 $
=33% &
false33' ,
,33, -
depthBufferBits44 #
=44$ %
$num44& (
,44( )
	dimension55 
=55 
UnityEngine55  +
.55+ ,
	Rendering55, 5
.555 6
TextureDimension556 F
.55F G
Tex2D55G L
,55L M
enableRandomWrite66 %
=66& '
false66( -
,66- .

memoryless77 
=77  #
RenderTextureMemoryless77! 8
.778 9
None779 =
,77= >
sRGB88 
=88 
false88  
,88  !
	useMipMap99 
=99 
false99  %
,99% &
volumeDepth:: 
=::  !
$num::" #
,::# $
msaaSamples;; 
=;;  !
$num;;" #
}<< 
;<< 
RenderTexture== 
rt==  
===! "
RenderTexture==# 0
.==0 1
GetTemporary==1 =
(=== >

descriptor==> H
)==H I
;==I J
RenderTextureHH 
prevHH "
=HH# $
RenderTextureHH% 2
.HH2 3
activeHH3 9
;HH9 :
	renderCamII 
.II 
targetTextureII '
=II( )
rtII* ,
;II, -
RenderTextureJJ 
.JJ 
activeJJ $
=JJ% &
rtJJ' )
;JJ) *
	renderCam^^ 
.^^ 
RenderWithShader^^ *
(^^* +
shader^^+ 1
,^^1 2
tag^^3 6
)^^6 7
;^^7 8
	Texture2D`` 
img`` 
=`` 
new``  #
	Texture2D``$ -
(``- .
_width``. 4
,``4 5
_height``6 =
,``= >
textureFormat``? L
,``L M
false``N S
,``S T
false``U Z
)``Z [
;``[ \
imgaa 
.aa 

ReadPixelsaa 
(aa 
newaa "
Rectaa# '
(aa' (
$numaa( )
,aa) *
$numaa+ ,
,aa, -
_widthaa. 4
,aa4 5
_heightaa6 =
)aa= >
,aa> ?
$numaa@ A
,aaA B
$numaaC D
)aaD E
;aaE F
imgbb 
.bb 
Applybb 
(bb 
)bb 
;bb 
RenderTexturedd 
.dd 
activedd $
=dd% &
prevdd' +
;dd+ ,
RenderTextureee 
.ee 
ReleaseTemporaryee .
(ee. /
rtee/ 1
)ee1 2
;ee2 3
UObjectgg 
.gg 
DestroyImmediategg (
(gg( )
gogg) +
)gg+ ,
;gg, -
returnii 
imgii 
;ii 
}jj 
}kk 	
}ll 
}mm ⁄ë
öD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\SurfaceTopology.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{		 
public 

static 
class 
SurfaceTopology '
{ 
public 
static 
Face 
[ 
] 
ToTriangles (
(( )
this) -
ProBuilderMesh. <
mesh= A
,A B
IListC H
<H I
FaceI M
>M N
facesO T
)T U
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new 
System  
.  !!
ArgumentNullException! 6
(6 7
$str7 =
)= >
;> ?
if 
( 
faces 
== 
null 
) 
throw 
new 
System  
.  !!
ArgumentNullException! 6
(6 7
$str7 >
)> ?
;? @
List 
< 
Vertex 
> 
vertices !
=" #
new$ '
List( ,
<, -
Vertex- 3
>3 4
(4 5
mesh5 9
.9 :
GetVertices: E
(E F
)F G
)G H
;H I

Dictionary   
<   
int   
,   
int   
>    
lookup  ! '
=  ( )
mesh  * .
.  . /
sharedVertexLookup  / A
;  A B
List"" 
<"" 
FaceRebuildData""  
>""  !
rebuild""" )
=""* +
new"", /
List""0 4
<""4 5
FaceRebuildData""5 D
>""D E
(""E F
)""F G
;""G H
foreach$$ 
($$ 
Face$$ 
face$$ 
in$$ !
faces$$" '
)$$' (
{%% 
List&& 
<&& 
FaceRebuildData&& $
>&&$ %
res&&& )
=&&* +
BreakFaceIntoTris&&, =
(&&= >
face&&> B
,&&B C
vertices&&D L
,&&L M
lookup&&N T
)&&T U
;&&U V
rebuild'' 
.'' 
AddRange''  
(''  !
res''! $
)''$ %
;''% &
}(( 
FaceRebuildData** 
.** 
Apply** !
(**! "
rebuild**" )
,**) *
mesh**+ /
,**/ 0
vertices**1 9
,**9 :
null**; ?
)**? @
;**@ A
mesh++ 
.++ 
DeleteFaces++ 
(++ 
faces++ "
)++" #
;++# $
mesh,, 
.,, 
ToMesh,, 
(,, 
),, 
;,, 
return.. 
rebuild.. 
... 
Select.. !
(..! "
x.." #
=>..$ &
x..' (
...( )
face..) -
)..- .
.... /
ToArray../ 6
(..6 7
)..7 8
;..8 9
}// 	
static11 
List11 
<11 
FaceRebuildData11 #
>11# $
BreakFaceIntoTris11% 6
(116 7
Face117 ;
face11< @
,11@ A
List11B F
<11F G
Vertex11G M
>11M N
vertices11O W
,11W X

Dictionary11Y c
<11c d
int11d g
,11g h
int11i l
>11l m
lookup11n t
)11t u
{22 	
int33 
[33 
]33 
tris33 
=33 
face33 
.33 
indexesInternal33 -
;33- .
int44 
triCount44 
=44 
tris44 
.44  
Length44  &
;44& '
List55 
<55 
FaceRebuildData55  
>55  !
rebuild55" )
=55* +
new55, /
List550 4
<554 5
FaceRebuildData555 D
>55D E
(55E F
triCount55F N
/55O P
$num55Q R
)55R S
;55S T
for77 
(77 
int77 
i77 
=77 
$num77 
;77 
i77 
<77 
triCount77  (
;77( )
i77* +
+=77, .
$num77/ 0
)770 1
{88 
FaceRebuildData99 
r99  !
=99" #
new99$ '
FaceRebuildData99( 7
(997 8
)998 9
;999 :
r;; 
.;; 
face;; 
=;; 
new;; 
Face;; !
(;;! "
face;;" &
);;& '
;;;' (
r<< 
.<< 
face<< 
.<< 
indexesInternal<< &
=<<' (
new<<) ,
int<<- 0
[<<0 1
]<<1 2
{<<3 4
$num<<5 6
,<<6 7
$num<<8 9
,<<9 :
$num<<; <
}<<< =
;<<= >
r>> 
.>> 
vertices>> 
=>> 
new>>  
List>>! %
<>>% &
Vertex>>& ,
>>>, -
(>>- .
)>>. /
{>>0 1
vertices?? 
[?? 
tris?? !
[??! "
i??" #
]??# $
]??$ %
,??% &
vertices@@ 
[@@ 
tris@@ !
[@@! "
i@@" #
+@@$ %
$num@@& '
]@@' (
]@@( )
,@@) *
verticesAA 
[AA 
trisAA !
[AA! "
iAA" #
+AA$ %
$numAA& '
]AA' (
]AA( )
}BB 
;BB 
rDD 
.DD 
sharedIndexesDD 
=DD  !
newDD" %
ListDD& *
<DD* +
intDD+ .
>DD. /
(DD/ 0
)DD0 1
{DD2 3
lookupEE 
[EE 
trisEE 
[EE  
iEE  !
]EE! "
]EE" #
,EE# $
lookupFF 
[FF 
trisFF 
[FF  
iFF  !
+FF" #
$numFF$ %
]FF% &
]FF& '
,FF' (
lookupGG 
[GG 
trisGG 
[GG  
iGG  !
+GG" #
$numGG$ %
]GG% &
]GG& '
}HH 
;HH 
rebuildJJ 
.JJ 
AddJJ 
(JJ 
rJJ 
)JJ 
;JJ 
}KK 
returnMM 
rebuildMM 
;MM 
}NN 	
publicVV 
staticVV 
WindingOrderVV "
GetWindingOrderVV# 2
(VV2 3
thisVV3 7
ProBuilderMeshVV8 F
meshVVG K
,VVK L
FaceVVM Q
faceVVR V
)VVV W
{WW 	
Vector2XX 
[XX 
]XX 
pXX 
=XX 

ProjectionXX $
.XX$ %
PlanarProjectXX% 2
(XX2 3
meshXX3 7
.XX7 8
positionsInternalXX8 I
,XXI J
faceXXK O
.XXO P#
distinctIndexesInternalXXP g
)XXg h
;XXh i
returnYY 
GetWindingOrderYY "
(YY" #
pYY# $
)YY$ %
;YY% &
}ZZ 	
static\\ 
WindingOrder\\ 
GetWindingOrder\\ +
(\\+ ,
IList\\, 1
<\\1 2
Vertex\\2 8
>\\8 9
vertices\\: B
,\\B C
IList\\D I
<\\I J
int\\J M
>\\M N
indexes\\O V
)\\V W
{]] 	
if^^ 
(^^ 
vertices^^ 
==^^ 
null^^  
)^^  !
throw__ 
new__ !
ArgumentNullException__ /
(__/ 0
$str__0 :
)__: ;
;__; <
ifaa 
(aa 
indexesaa 
==aa 
nullaa 
)aa  
throwbb 
newbb !
ArgumentNullExceptionbb /
(bb/ 0
$strbb0 9
)bb9 :
;bb: ;
Vector2dd 
[dd 
]dd 
pdd 
=dd 

Projectiondd $
.dd$ %
PlanarProjectdd% 2
(dd2 3
verticesdd3 ;
.dd; <
Selectdd< B
(ddB C
xddC D
=>ddE G
xddH I
.ddI J
positionddJ R
)ddR S
.ddS T
ToArrayddT [
(dd[ \
)dd\ ]
,dd] ^
indexesdd_ f
)ddf g
;ddg h
returnee 
GetWindingOrderee "
(ee" #
pee# $
)ee$ %
;ee% &
}ff 	
publicnn 
staticnn 
WindingOrdernn "
GetWindingOrdernn# 2
(nn2 3
IListnn3 8
<nn8 9
Vector2nn9 @
>nn@ A
pointsnnB H
)nnH I
{oo 	
ifpp 
(pp 
pointspp 
==pp 
nullpp 
)pp 
throwqq 
newqq !
ArgumentNullExceptionqq /
(qq/ 0
$strqq0 8
)qq8 9
;qq9 :
floatss 
sumss 
=ss 
$numss 
;ss 
intuu 
lenuu 
=uu 
pointsuu 
.uu 
Countuu "
;uu" #
forxx 
(xx 
intxx 
ixx 
=xx 
$numxx 
;xx 
ixx 
<xx 
lenxx  #
;xx# $
ixx% &
++xx& (
)xx( )
{yy 
Vector2zz 
azz 
=zz 
pointszz "
[zz" #
izz# $
]zz$ %
;zz% &
Vector2{{ 
b{{ 
={{ 
i{{ 
<{{ 
len{{  #
-{{$ %
$num{{& '
?{{( )
points{{* 0
[{{0 1
i{{1 2
+{{3 4
$num{{5 6
]{{6 7
:{{8 9
points{{: @
[{{@ A
$num{{A B
]{{B C
;{{C D
sum}} 
+=}} 
(}} 
(}} 
b}} 
.}} 
x}} 
-}} 
a}}  
.}}  !
x}}! "
)}}" #
*}}$ %
(}}& '
b}}' (
.}}( )
y}}) *
+}}+ ,
a}}- .
.}}. /
y}}/ 0
)}}0 1
)}}1 2
;}}2 3
}~~ 
return
ÄÄ 
sum
ÄÄ 
==
ÄÄ 
$num
ÄÄ 
?
ÄÄ 
WindingOrder
ÄÄ +
.
ÄÄ+ ,
Unknown
ÄÄ, 3
:
ÄÄ4 5
(
ÄÄ6 7
sum
ÄÄ7 :
>
ÄÄ; <
$num
ÄÄ= ?
?
ÄÄ@ A
WindingOrder
ÄÄB N
.
ÄÄN O
	Clockwise
ÄÄO X
:
ÄÄY Z
WindingOrder
ÄÄ[ g
.
ÄÄg h
CounterClockwise
ÄÄh x
)
ÄÄx y
;
ÄÄy z
}
ÅÅ 	
public
ëë 
static
ëë 
bool
ëë 
FlipEdge
ëë #
(
ëë# $
this
ëë$ (
ProBuilderMesh
ëë) 7
mesh
ëë8 <
,
ëë< =
Face
ëë> B
face
ëëC G
)
ëëG H
{
íí 	
if
ìì 
(
ìì 
mesh
ìì 
==
ìì 
null
ìì 
)
ìì 
throw
îî 
new
îî #
ArgumentNullException
îî /
(
îî/ 0
$str
îî0 6
)
îî6 7
;
îî7 8
if
ññ 
(
ññ 
face
ññ 
==
ññ 
null
ññ 
)
ññ 
throw
óó 
new
óó #
ArgumentNullException
óó /
(
óó/ 0
$str
óó0 6
)
óó6 7
;
óó7 8
int
ôô 
[
ôô 
]
ôô 
indexes
ôô 
=
ôô 
face
ôô  
.
ôô  !
indexesInternal
ôô! 0
;
ôô0 1
if
õõ 
(
õõ 
indexes
õõ 
.
õõ 
Length
õõ 
!=
õõ !
$num
õõ" #
)
õõ# $
return
úú 
false
úú 
;
úú 
int
ûû 
[
ûû 
]
ûû 
mode
ûû 
=
ûû 
ArrayUtility
ûû %
.
ûû% &
Fill
ûû& *
<
ûû* +
int
ûû+ .
>
ûû. /
(
ûû/ 0
$num
ûû0 1
,
ûû1 2
indexes
ûû3 :
.
ûû: ;
Length
ûû; A
)
ûûA B
;
ûûB C
for
†† 
(
†† 
int
†† 
x
†† 
=
†† 
$num
†† 
;
†† 
x
†† 
<
†† 
indexes
††  '
.
††' (
Length
††( .
-
††/ 0
$num
††1 2
;
††2 3
x
††4 5
++
††5 7
)
††7 8
{
°° 
for
¢¢ 
(
¢¢ 
int
¢¢ 
y
¢¢ 
=
¢¢ 
x
¢¢ 
+
¢¢  
$num
¢¢! "
;
¢¢" #
y
¢¢$ %
<
¢¢& '
indexes
¢¢( /
.
¢¢/ 0
Length
¢¢0 6
;
¢¢6 7
y
¢¢8 9
++
¢¢9 ;
)
¢¢; <
{
££ 
if
§§ 
(
§§ 
indexes
§§ 
[
§§  
x
§§  !
]
§§! "
==
§§# %
indexes
§§& -
[
§§- .
y
§§. /
]
§§/ 0
)
§§0 1
{
•• 
mode
¶¶ 
[
¶¶ 
x
¶¶ 
]
¶¶ 
++
¶¶ !
;
¶¶! "
mode
ßß 
[
ßß 
y
ßß 
]
ßß 
++
ßß !
;
ßß! "
}
®® 
}
©© 
}
™™ 
if
¨¨ 
(
¨¨ 
mode
¨¨ 
[
¨¨ 
$num
¨¨ 
]
¨¨ 
+
¨¨ 
mode
¨¨ 
[
¨¨ 
$num
¨¨  
]
¨¨  !
+
¨¨" #
mode
¨¨$ (
[
¨¨( )
$num
¨¨) *
]
¨¨* +
!=
¨¨, .
$num
¨¨/ 0
||
¨¨1 3
mode
≠≠ 
[
≠≠ 
$num
≠≠ 
]
≠≠ 
+
≠≠ 
mode
≠≠ 
[
≠≠ 
$num
≠≠  
]
≠≠  !
+
≠≠" #
mode
≠≠$ (
[
≠≠( )
$num
≠≠) *
]
≠≠* +
!=
≠≠, .
$num
≠≠/ 0
)
≠≠0 1
return
ÆÆ 
false
ÆÆ 
;
ÆÆ 
int
∞∞ 
i0
∞∞ 
=
∞∞ 
indexes
∞∞ 
[
∞∞ 
mode
∞∞ !
[
∞∞! "
$num
∞∞" #
]
∞∞# $
==
∞∞% '
$num
∞∞( )
?
∞∞* +
$num
∞∞, -
:
∞∞. /
mode
∞∞0 4
[
∞∞4 5
$num
∞∞5 6
]
∞∞6 7
==
∞∞8 :
$num
∞∞; <
?
∞∞= >
$num
∞∞? @
:
∞∞A B
$num
∞∞C D
]
∞∞D E
;
∞∞E F
int
±± 
i1
±± 
=
±± 
indexes
±± 
[
±± 
mode
±± !
[
±±! "
$num
±±" #
]
±±# $
==
±±% '
$num
±±( )
?
±±* +
$num
±±, -
:
±±. /
mode
±±0 4
[
±±4 5
$num
±±5 6
]
±±6 7
==
±±8 :
$num
±±; <
?
±±= >
$num
±±? @
:
±±A B
$num
±±C D
]
±±D E
;
±±E F
int
≥≥ 
used
≥≥ 
=
≥≥ 
-
≥≥ 
$num
≥≥ 
;
≥≥ 
if
µµ 
(
µµ 
mode
µµ 
[
µµ 
$num
µµ 
]
µµ 
==
µµ 
$num
µµ 
)
µµ 
{
∂∂ 
used
∑∑ 
=
∑∑ 
indexes
∑∑ 
[
∑∑ 
$num
∑∑  
]
∑∑  !
;
∑∑! "
indexes
∏∏ 
[
∏∏ 
$num
∏∏ 
]
∏∏ 
=
∏∏ 
i1
∏∏  
;
∏∏  !
}
ππ 
else
∫∫ 
if
∫∫ 
(
∫∫ 
mode
∫∫ 
[
∫∫ 
$num
∫∫ 
]
∫∫ 
==
∫∫ 
$num
∫∫  !
)
∫∫! "
{
ªª 
used
ºº 
=
ºº 
indexes
ºº 
[
ºº 
$num
ºº  
]
ºº  !
;
ºº! "
indexes
ΩΩ 
[
ΩΩ 
$num
ΩΩ 
]
ΩΩ 
=
ΩΩ 
i1
ΩΩ 
;
ΩΩ  
}
ææ 
else
øø 
if
øø 
(
øø 
mode
øø 
[
øø 
$num
øø 
]
øø 
==
øø 
$num
øø  !
)
øø! "
{
¿¿ 
used
¡¡ 
=
¡¡ 
indexes
¡¡ 
[
¡¡ 
$num
¡¡  
]
¡¡  !
;
¡¡! "
indexes
¬¬ 
[
¬¬ 
$num
¬¬ 
]
¬¬ 
=
¬¬ 
i1
¬¬ 
;
¬¬  
}
√√ 
if
≈≈ 
(
≈≈ 
mode
≈≈ 
[
≈≈ 
$num
≈≈ 
]
≈≈ 
==
≈≈ 
$num
≈≈ 
&&
≈≈ 
indexes
≈≈  '
[
≈≈' (
$num
≈≈( )
]
≈≈) *
!=
≈≈+ -
used
≈≈. 2
)
≈≈2 3
indexes
∆∆ 
[
∆∆ 
$num
∆∆ 
]
∆∆ 
=
∆∆ 
i0
∆∆ 
;
∆∆  
else
«« 
if
«« 
(
«« 
mode
«« 
[
«« 
$num
«« 
]
«« 
==
«« 
$num
««  !
&&
««" $
indexes
««% ,
[
««, -
$num
««- .
]
««. /
!=
««0 2
used
««3 7
)
««7 8
indexes
»» 
[
»» 
$num
»» 
]
»» 
=
»» 
i0
»» 
;
»»  
else
…… 
if
…… 
(
…… 
mode
…… 
[
…… 
$num
…… 
]
…… 
==
…… 
$num
……  !
&&
……" $
indexes
……% ,
[
……, -
$num
……- .
]
……. /
!=
……0 2
used
……3 7
)
……7 8
indexes
   
[
   
$num
   
]
   
=
   
i0
   
;
    
face
ÃÃ 
.
ÃÃ 
InvalidateCache
ÃÃ  
(
ÃÃ  !
)
ÃÃ! "
;
ÃÃ" #
return
ŒŒ 
true
ŒŒ 
;
ŒŒ 
}
œœ 	
public
◊◊ 
static
◊◊ 
ActionResult
◊◊ "
ConformNormals
◊◊# 1
(
◊◊1 2
this
◊◊2 6
ProBuilderMesh
◊◊7 E
mesh
◊◊F J
,
◊◊J K
IEnumerable
◊◊L W
<
◊◊W X
Face
◊◊X \
>
◊◊\ ]
faces
◊◊^ c
)
◊◊c d
{
ÿÿ 	
List
ŸŸ 
<
ŸŸ 

WingedEdge
ŸŸ 
>
ŸŸ 
wings
ŸŸ "
=
ŸŸ# $

WingedEdge
ŸŸ% /
.
ŸŸ/ 0
GetWingedEdges
ŸŸ0 >
(
ŸŸ> ?
mesh
ŸŸ? C
,
ŸŸC D
faces
ŸŸE J
)
ŸŸJ K
;
ŸŸK L
HashSet
⁄⁄ 
<
⁄⁄ 
Face
⁄⁄ 
>
⁄⁄ 
used
⁄⁄ 
=
⁄⁄  
new
⁄⁄! $
HashSet
⁄⁄% ,
<
⁄⁄, -
Face
⁄⁄- 1
>
⁄⁄1 2
(
⁄⁄2 3
)
⁄⁄3 4
;
⁄⁄4 5
int
€€ 
count
€€ 
=
€€ 
$num
€€ 
;
€€ 
for
ﬁﬁ 
(
ﬁﬁ 
int
ﬁﬁ 
i
ﬁﬁ 
=
ﬁﬁ 
$num
ﬁﬁ 
;
ﬁﬁ 
i
ﬁﬁ 
<
ﬁﬁ 
wings
ﬁﬁ  %
.
ﬁﬁ% &
Count
ﬁﬁ& +
;
ﬁﬁ+ ,
i
ﬁﬁ- .
++
ﬁﬁ. 0
)
ﬁﬁ0 1
{
ﬂﬂ 
if
‡‡ 
(
‡‡ 
used
‡‡ 
.
‡‡ 
Contains
‡‡ !
(
‡‡! "
wings
‡‡" '
[
‡‡' (
i
‡‡( )
]
‡‡) *
.
‡‡* +
face
‡‡+ /
)
‡‡/ 0
)
‡‡0 1
continue
·· 
;
·· 

Dictionary
„„ 
<
„„ 
Face
„„ 
,
„„  
bool
„„! %
>
„„% &
flags
„„' ,
=
„„- .
new
„„/ 2

Dictionary
„„3 =
<
„„= >
Face
„„> B
,
„„B C
bool
„„D H
>
„„H I
(
„„I J
)
„„J K
;
„„K L
GetWindingFlags
ÂÂ 
(
ÂÂ  
wings
ÂÂ  %
[
ÂÂ% &
i
ÂÂ& '
]
ÂÂ' (
,
ÂÂ( )
true
ÂÂ* .
,
ÂÂ. /
flags
ÂÂ0 5
)
ÂÂ5 6
;
ÂÂ6 7
int
ÁÁ 
flip
ÁÁ 
=
ÁÁ 
$num
ÁÁ 
;
ÁÁ 
foreach
ÈÈ 
(
ÈÈ 
var
ÈÈ 
kvp
ÈÈ  
in
ÈÈ! #
flags
ÈÈ$ )
)
ÈÈ) *
flip
ÍÍ 
+=
ÍÍ 
kvp
ÍÍ 
.
ÍÍ  
Value
ÍÍ  %
?
ÍÍ& '
$num
ÍÍ( )
:
ÍÍ* +
-
ÍÍ, -
$num
ÍÍ- .
;
ÍÍ. /
bool
ÏÏ 
	direction
ÏÏ 
=
ÏÏ  
flip
ÏÏ! %
>
ÏÏ& '
$num
ÏÏ( )
;
ÏÏ) *
foreach
ÓÓ 
(
ÓÓ 
var
ÓÓ 
kvp
ÓÓ  
in
ÓÓ! #
flags
ÓÓ$ )
)
ÓÓ) *
{
ÔÔ 
if
 
(
 
	direction
 !
!=
" $
kvp
% (
.
( )
Value
) .
)
. /
{
ÒÒ 
count
ÚÚ 
++
ÚÚ 
;
ÚÚ  
kvp
ÛÛ 
.
ÛÛ 
Key
ÛÛ 
.
ÛÛ  
Reverse
ÛÛ  '
(
ÛÛ' (
)
ÛÛ( )
;
ÛÛ) *
}
ÙÙ 
}
ıı 
used
˜˜ 
.
˜˜ 
	UnionWith
˜˜ 
(
˜˜ 
flags
˜˜ $
.
˜˜$ %
Keys
˜˜% )
)
˜˜) *
;
˜˜* +
}
¯¯ 
if
˙˙ 
(
˙˙ 
count
˙˙ 
>
˙˙ 
$num
˙˙ 
)
˙˙ 
return
˚˚ 
new
˚˚ 
ActionResult
˚˚ '
(
˚˚' (
ActionResult
˚˚( 4
.
˚˚4 5
Status
˚˚5 ;
.
˚˚; <
Success
˚˚< C
,
˚˚C D
count
˚˚E J
>
˚˚K L
$num
˚˚M N
?
˚˚O P
string
˚˚Q W
.
˚˚W X
Format
˚˚X ^
(
˚˚^ _
$str
˚˚_ r
,
˚˚r s
count
˚˚t y
)
˚˚y z
:
˚˚{ |
$str˚˚} ç
)˚˚ç é
;˚˚é è
else
¸¸ 
return
˝˝ 
new
˝˝ 
ActionResult
˝˝ '
(
˝˝' (
ActionResult
˝˝( 4
.
˝˝4 5
Status
˝˝5 ;
.
˝˝; <
NoChange
˝˝< D
,
˝˝D E
$str
˝˝F U
)
˝˝U V
;
˝˝V W
}
˛˛ 	
static
ÄÄ 
void
ÄÄ 
GetWindingFlags
ÄÄ #
(
ÄÄ# $

WingedEdge
ÄÄ$ .
edge
ÄÄ/ 3
,
ÄÄ3 4
bool
ÄÄ5 9
flag
ÄÄ: >
,
ÄÄ> ?

Dictionary
ÄÄ@ J
<
ÄÄJ K
Face
ÄÄK O
,
ÄÄO P
bool
ÄÄQ U
>
ÄÄU V
flags
ÄÄW \
)
ÄÄ\ ]
{
ÅÅ 	
flags
ÇÇ 
.
ÇÇ 
Add
ÇÇ 
(
ÇÇ 
edge
ÇÇ 
.
ÇÇ 
face
ÇÇ 
,
ÇÇ  
flag
ÇÇ! %
)
ÇÇ% &
;
ÇÇ& '

WingedEdge
ÑÑ 
next
ÑÑ 
=
ÑÑ 
edge
ÑÑ "
;
ÑÑ" #
do
ÜÜ 
{
áá 

WingedEdge
àà 
opp
àà 
=
àà  
next
àà! %
.
àà% &
opposite
àà& .
;
àà. /
if
ää 
(
ää 
opp
ää 
!=
ää 
null
ää 
&&
ää  "
!
ää# $
flags
ää$ )
.
ää) *
ContainsKey
ää* 5
(
ää5 6
opp
ää6 9
.
ää9 :
face
ää: >
)
ää> ?
)
ää? @
{
ãã 
Edge
åå 
cea
åå 
=
åå )
GetCommonEdgeInWindingOrder
åå :
(
åå: ;
next
åå; ?
)
åå? @
;
åå@ A
Edge
çç 
ceb
çç 
=
çç )
GetCommonEdgeInWindingOrder
çç :
(
çç: ;
opp
çç; >
)
çç> ?
;
çç? @
GetWindingFlags
èè #
(
èè# $
opp
èè$ '
,
èè' (
cea
èè) ,
.
èè, -
a
èè- .
==
èè/ 1
ceb
èè2 5
.
èè5 6
a
èè6 7
?
èè8 9
!
èè: ;
flag
èè; ?
:
èè@ A
flag
èèB F
,
èèF G
flags
èèH M
)
èèM N
;
èèN O
}
êê 
next
íí 
=
íí 
next
íí 
.
íí 
next
íí  
;
íí  !
}
ìì 
while
îî 
(
îî 
next
îî 
!=
îî 
edge
îî 
)
îî  
;
îî  !
}
ïï 	
internal
úú 
static
úú 
ActionResult
úú $#
ConformOppositeNormal
úú% :
(
úú: ;

WingedEdge
úú; E
source
úúF L
)
úúL M
{
ùù 	
if
ûû 
(
ûû 
source
ûû 
==
ûû 
null
ûû 
||
ûû !
source
ûû" (
.
ûû( )
opposite
ûû) 1
==
ûû2 4
null
ûû5 9
)
ûû9 :
return
üü 
new
üü 
ActionResult
üü '
(
üü' (
ActionResult
üü( 4
.
üü4 5
Status
üü5 ;
.
üü; <
Failure
üü< C
,
üüC D
$str
üüE |
)
üü| }
;
üü} ~
Edge
°° 
cea
°° 
=
°° )
GetCommonEdgeInWindingOrder
°° 2
(
°°2 3
source
°°3 9
)
°°9 :
;
°°: ;
Edge
¢¢ 
ceb
¢¢ 
=
¢¢ )
GetCommonEdgeInWindingOrder
¢¢ 2
(
¢¢2 3
source
¢¢3 9
.
¢¢9 :
opposite
¢¢: B
)
¢¢B C
;
¢¢C D
if
§§ 
(
§§ 
cea
§§ 
.
§§ 
a
§§ 
==
§§ 
ceb
§§ 
.
§§ 
a
§§ 
)
§§ 
{
•• 
source
¶¶ 
.
¶¶ 
opposite
¶¶ 
.
¶¶  
face
¶¶  $
.
¶¶$ %
Reverse
¶¶% ,
(
¶¶, -
)
¶¶- .
;
¶¶. /
return
®® 
new
®® 
ActionResult
®® '
(
®®' (
ActionResult
®®( 4
.
®®4 5
Status
®®5 ;
.
®®; <
Success
®®< C
,
®®C D
$str
®®E j
)
®®j k
;
®®k l
}
©© 
return
´´ 
new
´´ 
ActionResult
´´ #
(
´´# $
ActionResult
´´$ 0
.
´´0 1
Status
´´1 7
.
´´7 8
NoChange
´´8 @
,
´´@ A
$str
´´B Z
)
´´Z [
;
´´[ \
}
¨¨ 	
static
≥≥ 
Edge
≥≥ )
GetCommonEdgeInWindingOrder
≥≥ /
(
≥≥/ 0

WingedEdge
≥≥0 :
wing
≥≥; ?
)
≥≥? @
{
¥¥ 	
int
µµ 
[
µµ 
]
µµ 
indexes
µµ 
=
µµ 
wing
µµ  
.
µµ  !
face
µµ! %
.
µµ% &
indexesInternal
µµ& 5
;
µµ5 6
int
∂∂ 
len
∂∂ 
=
∂∂ 
indexes
∂∂ 
.
∂∂ 
Length
∂∂ $
;
∂∂$ %
for
∏∏ 
(
∏∏ 
int
∏∏ 
i
∏∏ 
=
∏∏ 
$num
∏∏ 
;
∏∏ 
i
∏∏ 
<
∏∏ 
len
∏∏  #
;
∏∏# $
i
∏∏% &
+=
∏∏' )
$num
∏∏* +
)
∏∏+ ,
{
ππ 
Edge
∫∫ 
e
∫∫ 
=
∫∫ 
wing
∫∫ 
.
∫∫ 
edge
∫∫ "
.
∫∫" #
local
∫∫# (
;
∫∫( )
int
ªª 
a
ªª 
=
ªª 
indexes
ªª 
[
ªª  
i
ªª  !
]
ªª! "
,
ªª" #
b
ªª$ %
=
ªª& '
indexes
ªª( /
[
ªª/ 0
i
ªª0 1
+
ªª2 3
$num
ªª4 5
]
ªª5 6
,
ªª6 7
c
ªª8 9
=
ªª: ;
indexes
ªª< C
[
ªªC D
i
ªªD E
+
ªªF G
$num
ªªH I
]
ªªI J
;
ªªJ K
if
ΩΩ 
(
ΩΩ 
e
ΩΩ 
.
ΩΩ 
a
ΩΩ 
==
ΩΩ 
a
ΩΩ 
&&
ΩΩ 
e
ΩΩ  !
.
ΩΩ! "
b
ΩΩ" #
==
ΩΩ$ &
b
ΩΩ' (
)
ΩΩ( )
return
ææ 
wing
ææ 
.
ææ  
edge
ææ  $
.
ææ$ %
common
ææ% +
;
ææ+ ,
else
øø 
if
øø 
(
øø 
e
øø 
.
øø 
a
øø 
==
øø 
b
øø  !
&&
øø" $
e
øø% &
.
øø& '
b
øø' (
==
øø) +
a
øø, -
)
øø- .
return
¿¿ 
new
¿¿ 
Edge
¿¿ #
(
¿¿# $
wing
¿¿$ (
.
¿¿( )
edge
¿¿) -
.
¿¿- .
common
¿¿. 4
.
¿¿4 5
b
¿¿5 6
,
¿¿6 7
wing
¿¿8 <
.
¿¿< =
edge
¿¿= A
.
¿¿A B
common
¿¿B H
.
¿¿H I
a
¿¿I J
)
¿¿J K
;
¿¿K L
else
¡¡ 
if
¡¡ 
(
¡¡ 
e
¡¡ 
.
¡¡ 
a
¡¡ 
==
¡¡ 
b
¡¡  !
&&
¡¡" $
e
¡¡% &
.
¡¡& '
b
¡¡' (
==
¡¡) +
c
¡¡, -
)
¡¡- .
return
¬¬ 
wing
¬¬ 
.
¬¬  
edge
¬¬  $
.
¬¬$ %
common
¬¬% +
;
¬¬+ ,
else
√√ 
if
√√ 
(
√√ 
e
√√ 
.
√√ 
a
√√ 
==
√√ 
c
√√  !
&&
√√" $
e
√√% &
.
√√& '
b
√√' (
==
√√) +
b
√√, -
)
√√- .
return
ƒƒ 
new
ƒƒ 
Edge
ƒƒ #
(
ƒƒ# $
wing
ƒƒ$ (
.
ƒƒ( )
edge
ƒƒ) -
.
ƒƒ- .
common
ƒƒ. 4
.
ƒƒ4 5
b
ƒƒ5 6
,
ƒƒ6 7
wing
ƒƒ8 <
.
ƒƒ< =
edge
ƒƒ= A
.
ƒƒA B
common
ƒƒB H
.
ƒƒH I
a
ƒƒI J
)
ƒƒJ K
;
ƒƒK L
else
≈≈ 
if
≈≈ 
(
≈≈ 
e
≈≈ 
.
≈≈ 
a
≈≈ 
==
≈≈ 
c
≈≈  !
&&
≈≈" $
e
≈≈% &
.
≈≈& '
b
≈≈' (
==
≈≈) +
a
≈≈, -
)
≈≈- .
return
∆∆ 
wing
∆∆ 
.
∆∆  
edge
∆∆  $
.
∆∆$ %
common
∆∆% +
;
∆∆+ ,
else
«« 
if
«« 
(
«« 
e
«« 
.
«« 
a
«« 
==
«« 
a
««  !
&&
««" $
e
««% &
.
««& '
b
««' (
==
««) +
c
««, -
)
««- .
return
»» 
new
»» 
Edge
»» #
(
»»# $
wing
»»$ (
.
»»( )
edge
»») -
.
»»- .
common
»». 4
.
»»4 5
b
»»5 6
,
»»6 7
wing
»»8 <
.
»»< =
edge
»»= A
.
»»A B
common
»»B H
.
»»H I
a
»»I J
)
»»J K
;
»»K L
}
…… 
return
ÀÀ 
Edge
ÀÀ 
.
ÀÀ 
Empty
ÀÀ 
;
ÀÀ 
}
ÃÃ 	
internal
‘‘ 
static
‘‘ 
void
‘‘ 
MatchNormal
‘‘ (
(
‘‘( )
Face
‘‘) -
source
‘‘. 4
,
‘‘4 5
Face
‘‘6 :
target
‘‘; A
,
‘‘A B

Dictionary
‘‘C M
<
‘‘M N
int
‘‘N Q
,
‘‘Q R
int
‘‘S V
>
‘‘V W
lookup
‘‘X ^
)
‘‘^ _
{
’’ 	
List
÷÷ 
<
÷÷ 

EdgeLookup
÷÷ 
>
÷÷ 
sourceEdges
÷÷ (
=
÷÷) *

EdgeLookup
÷÷+ 5
.
÷÷5 6
GetEdgeLookup
÷÷6 C
(
÷÷C D
source
÷÷D J
.
÷÷J K
edgesInternal
÷÷K X
,
÷÷X Y
lookup
÷÷Z `
)
÷÷` a
.
÷÷a b
ToList
÷÷b h
(
÷÷h i
)
÷÷i j
;
÷÷j k
List
◊◊ 
<
◊◊ 

EdgeLookup
◊◊ 
>
◊◊ 
targetEdges
◊◊ (
=
◊◊) *

EdgeLookup
◊◊+ 5
.
◊◊5 6
GetEdgeLookup
◊◊6 C
(
◊◊C D
target
◊◊D J
.
◊◊J K
edgesInternal
◊◊K X
,
◊◊X Y
lookup
◊◊Z `
)
◊◊` a
.
◊◊a b
ToList
◊◊b h
(
◊◊h i
)
◊◊i j
;
◊◊j k
bool
ŸŸ 

superBreak
ŸŸ 
=
ŸŸ 
false
ŸŸ #
;
ŸŸ# $
Edge
€€ 
src
€€ 
,
€€ 
tar
€€ 
;
€€ 
for
›› 
(
›› 
int
›› 
i
›› 
=
›› 
$num
›› 
;
›› 
!
›› 

superBreak
›› '
&&
››( *
i
››+ ,
<
››- .
sourceEdges
››/ :
.
››: ;
Count
››; @
;
››@ A
i
››B C
++
››C E
)
››E F
{
ﬁﬁ 
src
ﬂﬂ 
=
ﬂﬂ 
sourceEdges
ﬂﬂ !
[
ﬂﬂ! "
i
ﬂﬂ" #
]
ﬂﬂ# $
.
ﬂﬂ$ %
common
ﬂﬂ% +
;
ﬂﬂ+ ,
for
·· 
(
·· 
int
·· 
n
·· 
=
·· 
$num
·· 
;
·· 
!
··  !

superBreak
··! +
&&
··, .
n
··/ 0
<
··1 2
targetEdges
··3 >
.
··> ?
Count
··? D
;
··D E
n
··F G
++
··G I
)
··I J
{
‚‚ 
tar
„„ 
=
„„ 
targetEdges
„„ %
[
„„% &
n
„„& '
]
„„' (
.
„„( )
common
„„) /
;
„„/ 0
if
ÂÂ 
(
ÂÂ 
src
ÂÂ 
.
ÂÂ 
Equals
ÂÂ "
(
ÂÂ" #
tar
ÂÂ# &
)
ÂÂ& '
)
ÂÂ' (
{
ÊÊ 
if
ÁÁ 
(
ÁÁ 
src
ÁÁ 
.
ÁÁ  
a
ÁÁ  !
==
ÁÁ" $
tar
ÁÁ% (
.
ÁÁ( )
a
ÁÁ) *
)
ÁÁ* +
target
ËË "
.
ËË" #
Reverse
ËË# *
(
ËË* +
)
ËË+ ,
;
ËË, -

superBreak
ÍÍ "
=
ÍÍ# $
true
ÍÍ% )
;
ÍÍ) *
}
ÎÎ 
}
ÏÏ 
}
ÌÌ 
}
ÓÓ 	
}
ÔÔ 
} ·Á
èD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ProBuilderMesh.cs
	namespace		 	
UnityEngine		
 
.		 

ProBuilder		  
{

 
[ 
AddComponentMenu 
( 
$str /
)/ 0
]0 1
[ 
RequireComponent 
( 
typeof 
( 
MeshRenderer )
)) *
)* +
]+ ,
[ %
DisallowMultipleComponent 
, 
ExecuteInEditMode  1
,1 2
ExcludeFromPreset3 D
,D E$
ExcludeFromObjectFactoryF ^
]^ _
public 

sealed 
partial 
class 
ProBuilderMesh  .
:/ 0
MonoBehaviour1 >
{ 
internal 
const 
	HideFlags  !
k_MeshFilterHideFlags! 6
=7 8
	HideFlags9 B
.B C
HideInInspectorC R
|S T
	HideFlagsU ^
.^ _
NotEditable_ j
;j k
const   
int   
k_UVChannelCount   "
=  # $
$num  % &
;  & '
const%% 
int%% 
k_MeshFormatVersion%% %
=%%& '
$num%%( )
;%%) *
const'' 
int'' 6
*k_MeshFormatVersionSubmeshMaterialRefactor'' <
=''= >
$num''? @
;''@ A
public,, 
const,, 
uint,, 
maxVertexCount,, (
=,,) *
ushort,,+ 1
.,,1 2
MaxValue,,2 :
;,,: ;
[.. 	
SerializeField..	 
].. 
int// 
m_MeshFormatVersion// 
;//  
[11 	
SerializeField11	 
]11 
[22 	 
FormerlySerializedAs22	 
(22 
$str22 &
)22& '
]22' (
Face33 
[33 
]33 
m_Faces33 
;33 
[55 	
SerializeField55	 
]55 
[66 	 
FormerlySerializedAs66	 
(66 
$str66 .
)66. /
]66/ 0
[77 	 
FormerlySerializedAs77	 
(77 
$str77 0
)770 1
]771 2
SharedVertex88 
[88 
]88 
m_SharedVertices88 '
;88' (
[:: 	
Flags::	 
]:: 
enum;; 
CacheValidState;; 
:;; 
byte;; #
{<< 	
SharedVertex== 
=== 
$num== 
<<== 
$num==  !
,==! "
SharedTexture>> 
=>> 
$num>> 
<<>>  
$num>>! "
}?? 	
[AA 	
NonSerializedAA	 
]AA 
CacheValidStateBB 
m_CacheValidBB $
;BB$ %
[DD 	
NonSerializedDD	 
]DD 

DictionaryEE 
<EE 
intEE 
,EE 
intEE 
>EE  
m_SharedVertexLookupEE 1
;EE1 2
[GG 	
SerializeFieldGG	 
]GG 
[HH 	 
FormerlySerializedAsHH	 
(HH 
$strHH 0
)HH0 1
]HH1 2
SharedVertexII 
[II 
]II 
m_SharedTexturesII '
;II' (
[KK 	
NonSerializedKK	 
]KK 

DictionaryLL 
<LL 
intLL 
,LL 
intLL 
>LL !
m_SharedTextureLookupLL 2
;LL2 3
[NN 	
SerializeFieldNN	 
]NN 
[OO 	 
FormerlySerializedAsOO	 
(OO 
$strOO )
)OO) *
]OO* +
Vector3PP 
[PP 
]PP 
m_PositionsPP 
;PP 
[RR 	
SerializeFieldRR	 
]RR 
[SS 	 
FormerlySerializedAsSS	 
(SS 
$strSS #
)SS# $
]SS$ %
Vector2TT 
[TT 
]TT 
m_Textures0TT 
;TT 
[VV 	
SerializeFieldVV	 
]VV 
[WW 	 
FormerlySerializedAsWW	 
(WW 
$strWW $
)WW$ %
]WW% &
ListXX 
<XX 
Vector4XX 
>XX 
m_Textures2XX !
;XX! "
[ZZ 	
SerializeFieldZZ	 
]ZZ 
[[[ 	 
FormerlySerializedAs[[	 
([[ 
$str[[ $
)[[$ %
][[% &
List\\ 
<\\ 
Vector4\\ 
>\\ 
m_Textures3\\ !
;\\! "
[^^ 	
SerializeField^^	 
]^^ 
[__ 	 
FormerlySerializedAs__	 
(__ 
$str__ )
)__) *
]__* +
Vector4`` 
[`` 
]`` 

m_Tangents`` 
;`` 
[bb 	
NonSerializedbb	 
]bb 
Vector3cc 
[cc 
]cc 
	m_Normalscc 
;cc 
[ee 	
SerializeFieldee	 
]ee 
[ff 	 
FormerlySerializedAsff	 
(ff 
$strff '
)ff' (
]ff( )
Colorgg 
[gg 
]gg 
m_Colorsgg 
;gg 
publicll 
boolll 
userCollisionsll "
{ll# $
getll% (
;ll( )
setll* -
;ll- .
}ll/ 0
[nn 	 
FormerlySerializedAsnn	 
(nn 
$strnn 0
)nn0 1
]nn1 2
[oo 	
SerializeFieldoo	 
]oo 
UnwrapParameterspp 
m_UnwrapParameterspp +
;pp+ ,
publicuu 
UnwrapParametersuu 
unwrapParametersuu  0
{vv 	
getww 
{ww 
returnww 
m_UnwrapParametersww +
;ww+ ,
}ww- .
setxx 
{xx 
m_UnwrapParametersxx $
=xx% &
valuexx' ,
;xx, -
}xx. /
}yy 	
[{{ 	 
FormerlySerializedAs{{	 
({{ 
$str{{ 7
){{7 8
]{{8 9
[|| 	
SerializeField||	 
]|| 
bool}} (
m_PreserveMeshAssetOnDestroy}} )
;}}) *
[
ÇÇ 	
SerializeField
ÇÇ	 
]
ÇÇ 
internal
ÉÉ 
string
ÉÉ 
	assetGuid
ÉÉ !
;
ÉÉ! "
[
ÖÖ 	
SerializeField
ÖÖ	 
]
ÖÖ 
Mesh
ÜÜ 
m_Mesh
ÜÜ 
;
ÜÜ 
[
àà 	
NonSerialized
àà	 
]
àà 
MeshRenderer
ââ 
m_MeshRenderer
ââ #
;
ââ# $
internal
åå 
new
åå 
MeshRenderer
åå !
renderer
åå" *
{
çç 	
get
éé 
{
èè 
if
êê 
(
êê 
!
êê 

gameObject
êê 
.
êê  
TryGetComponent
êê  /
<
êê/ 0
MeshRenderer
êê0 <
>
êê< =
(
êê= >
out
êê> A
m_MeshRenderer
êêB P
)
êêP Q
)
êêQ R
return
ëë 
null
ëë 
;
ëë  
return
íí 
m_MeshRenderer
íí %
;
íí% &
}
ìì 
}
îî 	
[
óó 	
NonSerialized
óó	 
]
óó 

MeshFilter
òò 
m_MeshFilter
òò 
;
òò  
internal
õõ 
new
õõ 

MeshFilter
õõ 
filter
õõ  &
{
úú 	
get
ùù 
{
ûû 
if
üü 
(
üü 
m_MeshFilter
üü  
==
üü! #
null
üü$ (
)
üü( )
{
†† 
if
°° 
(
°° 
!
°° 

gameObject
°° #
.
°°# $
TryGetComponent
°°$ 3
<
°°3 4

MeshFilter
°°4 >
>
°°> ?
(
°°? @
out
°°@ C
m_MeshFilter
°°D P
)
°°P Q
)
°°Q R
return
¢¢ 
null
¢¢ #
;
¢¢# $
m_MeshFilter
§§  
.
§§  !
	hideFlags
§§! *
=
§§+ ,#
k_MeshFilterHideFlags
§§- B
;
§§B C
}
¶¶ 
return
®® 
m_MeshFilter
®® #
;
®®# $
}
©© 
}
™™ 	
public
±± 
bool
±± (
preserveMeshAssetOnDestroy
±± .
{
≤≤ 	
get
≥≥ 
{
≥≥ 
return
≥≥ *
m_PreserveMeshAssetOnDestroy
≥≥ 5
;
≥≥5 6
}
≥≥7 8
set
¥¥ 
{
¥¥ *
m_PreserveMeshAssetOnDestroy
¥¥ .
=
¥¥/ 0
value
¥¥1 6
;
¥¥6 7
}
¥¥8 9
}
µµ 	
public
ºº 
bool
ºº 
	HasArrays
ºº 
(
ºº 

MeshArrays
ºº (
channels
ºº) 1
)
ºº1 2
{
ΩΩ 	
bool
ææ 
missing
ææ 
=
ææ 
false
ææ  
;
ææ  !
int
¿¿ 
vc
¿¿ 
=
¿¿ 
vertexCount
¿¿  
;
¿¿  !
missing
¬¬ 
|=
¬¬ 
(
¬¬ 
channels
¬¬  
&
¬¬! "

MeshArrays
¬¬# -
.
¬¬- .
Position
¬¬. 6
)
¬¬6 7
==
¬¬8 :

MeshArrays
¬¬; E
.
¬¬E F
Position
¬¬F N
&&
¬¬O Q
m_Positions
¬¬R ]
==
¬¬^ `
null
¬¬a e
;
¬¬e f
missing
√√ 
|=
√√ 
(
√√ 
channels
√√  
&
√√! "

MeshArrays
√√# -
.
√√- .
Normal
√√. 4
)
√√4 5
==
√√6 8

MeshArrays
√√9 C
.
√√C D
Normal
√√D J
&&
√√K M
(
√√N O
	m_Normals
√√O X
==
√√Y [
null
√√\ `
||
√√a c
	m_Normals
√√d m
.
√√m n
Length
√√n t
!=
√√u w
vc
√√x z
)
√√z {
;
√√{ |
missing
ƒƒ 
|=
ƒƒ 
(
ƒƒ 
channels
ƒƒ  
&
ƒƒ! "

MeshArrays
ƒƒ# -
.
ƒƒ- .
Texture0
ƒƒ. 6
)
ƒƒ6 7
==
ƒƒ8 :

MeshArrays
ƒƒ; E
.
ƒƒE F
Texture0
ƒƒF N
&&
ƒƒO Q
(
ƒƒR S
m_Textures0
ƒƒS ^
==
ƒƒ_ a
null
ƒƒb f
||
ƒƒg i
m_Textures0
ƒƒj u
.
ƒƒu v
Length
ƒƒv |
!=
ƒƒ} 
vcƒƒÄ Ç
)ƒƒÇ É
;ƒƒÉ Ñ
missing
≈≈ 
|=
≈≈ 
(
≈≈ 
channels
≈≈  
&
≈≈! "

MeshArrays
≈≈# -
.
≈≈- .
Texture2
≈≈. 6
)
≈≈6 7
==
≈≈8 :

MeshArrays
≈≈; E
.
≈≈E F
Texture2
≈≈F N
&&
≈≈O Q
(
≈≈R S
m_Textures2
≈≈S ^
==
≈≈_ a
null
≈≈b f
||
≈≈g i
m_Textures2
≈≈j u
.
≈≈u v
Count
≈≈v {
!=
≈≈| ~
vc≈≈ Å
)≈≈Å Ç
;≈≈Ç É
missing
∆∆ 
|=
∆∆ 
(
∆∆ 
channels
∆∆  
&
∆∆! "

MeshArrays
∆∆# -
.
∆∆- .
Texture3
∆∆. 6
)
∆∆6 7
==
∆∆8 :

MeshArrays
∆∆; E
.
∆∆E F
Texture3
∆∆F N
&&
∆∆O Q
(
∆∆R S
m_Textures3
∆∆S ^
==
∆∆_ a
null
∆∆b f
||
∆∆g i
m_Textures3
∆∆j u
.
∆∆u v
Count
∆∆v {
!=
∆∆| ~
vc∆∆ Å
)∆∆Å Ç
;∆∆Ç É
missing
«« 
|=
«« 
(
«« 
channels
««  
&
««! "

MeshArrays
««# -
.
««- .
Color
««. 3
)
««3 4
==
««5 7

MeshArrays
««8 B
.
««B C
Color
««C H
&&
««I K
(
««L M
m_Colors
««M U
==
««V X
null
««Y ]
||
««^ `
m_Colors
««a i
.
««i j
Length
««j p
!=
««q s
vc
««t v
)
««v w
;
««w x
missing
»» 
|=
»» 
(
»» 
channels
»»  
&
»»! "

MeshArrays
»»# -
.
»»- .
Tangent
»». 5
)
»»5 6
==
»»7 9

MeshArrays
»»: D
.
»»D E
Tangent
»»E L
&&
»»M O
(
»»P Q

m_Tangents
»»Q [
==
»»\ ^
null
»»_ c
||
»»d f

m_Tangents
»»g q
.
»»q r
Length
»»r x
!=
»»y {
vc
»»| ~
)
»»~ 
;»» Ä
if
ÃÃ 
(
ÃÃ 
(
ÃÃ 
channels
ÃÃ 
&
ÃÃ 

MeshArrays
ÃÃ &
.
ÃÃ& '
Texture1
ÃÃ' /
)
ÃÃ/ 0
==
ÃÃ1 3

MeshArrays
ÃÃ4 >
.
ÃÃ> ?
Texture1
ÃÃ? G
&&
ÃÃH J
mesh
ÃÃK O
!=
ÃÃP R
null
ÃÃS W
)
ÃÃW X
{
ÕÕ 
missing
œœ 
|=
œœ 
!
œœ 
mesh
œœ  
.
œœ  ! 
HasVertexAttribute
œœ! 3
(
œœ3 4
VertexAttribute
œœ4 C
.
œœC D
	TexCoord1
œœD M
)
œœM N
;
œœN O
}
‘‘ 
return
÷÷ 
!
÷÷ 
missing
÷÷ 
;
÷÷ 
}
◊◊ 	
internal
ŸŸ 
Face
ŸŸ 
[
ŸŸ 
]
ŸŸ 
facesInternal
ŸŸ %
{
⁄⁄ 	
get
€€ 
{
€€ 
return
€€ 
m_Faces
€€  
;
€€  !
}
€€" #
set
‹‹ 
{
‹‹ 
m_Faces
‹‹ 
=
‹‹ 
value
‹‹ !
;
‹‹! "
}
‹‹# $
}
›› 	
public
ÂÂ 
IList
ÂÂ 
<
ÂÂ 
Face
ÂÂ 
>
ÂÂ 
faces
ÂÂ  
{
ÊÊ 	
get
ÁÁ 
{
ÁÁ 
return
ÁÁ 
new
ÁÁ  
ReadOnlyCollection
ÁÁ /
<
ÁÁ/ 0
Face
ÁÁ0 4
>
ÁÁ4 5
(
ÁÁ5 6
m_Faces
ÁÁ6 =
)
ÁÁ= >
;
ÁÁ> ?
}
ÁÁ@ A
set
ËË 
{
ÈÈ 
if
ÍÍ 
(
ÍÍ 
value
ÍÍ 
==
ÍÍ 
null
ÍÍ !
)
ÍÍ! "
throw
ÎÎ 
new
ÎÎ #
ArgumentNullException
ÎÎ 3
(
ÎÎ3 4
$str
ÎÎ4 ;
)
ÎÎ; <
;
ÎÎ< =
m_Faces
ÏÏ 
=
ÏÏ 
value
ÏÏ 
.
ÏÏ  
ToArray
ÏÏ  '
(
ÏÏ' (
)
ÏÏ( )
;
ÏÏ) *
}
ÌÌ 
}
ÓÓ 	
internal
 
void
 *
InvalidateSharedVertexLookup
 2
(
2 3
)
3 4
{
ÒÒ 	
if
ÚÚ 
(
ÚÚ "
m_SharedVertexLookup
ÚÚ $
==
ÚÚ% '
null
ÚÚ( ,
)
ÚÚ, -"
m_SharedVertexLookup
ÛÛ $
=
ÛÛ% &
new
ÛÛ' *

Dictionary
ÛÛ+ 5
<
ÛÛ5 6
int
ÛÛ6 9
,
ÛÛ9 :
int
ÛÛ; >
>
ÛÛ> ?
(
ÛÛ? @
)
ÛÛ@ A
;
ÛÛA B"
m_SharedVertexLookup
ÙÙ  
.
ÙÙ  !
Clear
ÙÙ! &
(
ÙÙ& '
)
ÙÙ' (
;
ÙÙ( )
m_CacheValid
ıı 
&=
ıı 
~
ıı 
CacheValidState
ıı ,
.
ıı, -
SharedVertex
ıı- 9
;
ıı9 :
}
ˆˆ 	
internal
¯¯ 
void
¯¯ +
InvalidateSharedTextureLookup
¯¯ 3
(
¯¯3 4
)
¯¯4 5
{
˘˘ 	
if
˙˙ 
(
˙˙ #
m_SharedTextureLookup
˙˙ %
==
˙˙& (
null
˙˙) -
)
˙˙- .#
m_SharedTextureLookup
˚˚ %
=
˚˚& '
new
˚˚( +

Dictionary
˚˚, 6
<
˚˚6 7
int
˚˚7 :
,
˚˚: ;
int
˚˚< ?
>
˚˚? @
(
˚˚@ A
)
˚˚A B
;
˚˚B C#
m_SharedTextureLookup
¸¸ !
.
¸¸! "
Clear
¸¸" '
(
¸¸' (
)
¸¸( )
;
¸¸) *
m_CacheValid
˝˝ 
&=
˝˝ 
~
˝˝ 
CacheValidState
˝˝ ,
.
˝˝, -
SharedTexture
˝˝- :
;
˝˝: ;
}
˛˛ 	
internal
ÄÄ 
void
ÄÄ 
InvalidateFaces
ÄÄ %
(
ÄÄ% &
)
ÄÄ& '
{
ÅÅ 	
if
ÇÇ 
(
ÇÇ 
m_Faces
ÇÇ 
==
ÇÇ 
null
ÇÇ 
)
ÇÇ  
{
ÉÉ 
m_Faces
ÑÑ 
=
ÑÑ 
new
ÑÑ 
Face
ÑÑ "
[
ÑÑ" #
$num
ÑÑ# $
]
ÑÑ$ %
;
ÑÑ% &
return
ÖÖ 
;
ÖÖ 
}
ÜÜ 
foreach
àà 
(
àà 
var
àà 
face
àà 
in
àà  
faces
àà! &
)
àà& '
face
ââ 
.
ââ 
InvalidateCache
ââ $
(
ââ$ %
)
ââ% &
;
ââ& '
}
ää 	
internal
åå 
void
åå 
InvalidateCaches
åå &
(
åå& '
)
åå' (
{
çç 	*
InvalidateSharedVertexLookup
éé (
(
éé( )
)
éé) *
;
éé* ++
InvalidateSharedTextureLookup
èè )
(
èè) *
)
èè* +
;
èè+ ,
InvalidateFaces
êê 
(
êê 
)
êê 
;
êê "
m_SelectedCacheDirty
ëë  
=
ëë! "
true
ëë# '
;
ëë' (
}
íí 	
internal
îî 
SharedVertex
îî 
[
îî 
]
îî $
sharedVerticesInternal
îî  6
{
ïï 	
get
ññ 
{
ññ 
return
ññ 
m_SharedVertices
ññ )
;
ññ) *
}
ññ+ ,
set
òò 
{
ôô 
m_SharedVertices
öö  
=
öö! "
value
öö# (
;
öö( )*
InvalidateSharedVertexLookup
õõ ,
(
õõ, -
)
õõ- .
;
õõ. /
}
úú 
}
ùù 	
public
™™ 
IList
™™ 
<
™™ 
SharedVertex
™™ !
>
™™! "
sharedVertices
™™# 1
{
´´ 	
get
¨¨ 
{
¨¨ 
return
¨¨ 
new
¨¨  
ReadOnlyCollection
¨¨ /
<
¨¨/ 0
SharedVertex
¨¨0 <
>
¨¨< =
(
¨¨= >
m_SharedVertices
¨¨> N
)
¨¨N O
;
¨¨O P
}
¨¨Q R
set
ÆÆ 
{
ØØ 
if
∞∞ 
(
∞∞ 
value
∞∞ 
==
∞∞ 
null
∞∞ !
)
∞∞! "
throw
±± 
new
±± #
ArgumentNullException
±± 3
(
±±3 4
$str
±±4 ;
)
±±; <
;
±±< =
int
≥≥ 
len
≥≥ 
=
≥≥ 
value
≥≥ 
.
≥≥  
Count
≥≥  %
;
≥≥% &
m_SharedVertices
¥¥  
=
¥¥! "
new
¥¥# &
SharedVertex
¥¥' 3
[
¥¥3 4
len
¥¥4 7
]
¥¥7 8
;
¥¥8 9
for
µµ 
(
µµ 
var
µµ 
i
µµ 
=
µµ 
$num
µµ 
;
µµ 
i
µµ  !
<
µµ" #
len
µµ$ '
;
µµ' (
i
µµ) *
++
µµ* ,
)
µµ, -
m_SharedVertices
∂∂ $
[
∂∂$ %
i
∂∂% &
]
∂∂& '
=
∂∂( )
new
∂∂* -
SharedVertex
∂∂. :
(
∂∂: ;
value
∂∂; @
[
∂∂@ A
i
∂∂A B
]
∂∂B C
)
∂∂C D
;
∂∂D E*
InvalidateSharedVertexLookup
∏∏ ,
(
∏∏, -
)
∏∏- .
;
∏∏. /
}
ππ 
}
∫∫ 	
internal
ºº 

Dictionary
ºº 
<
ºº 
int
ºº 
,
ºº  
int
ºº! $
>
ºº$ % 
sharedVertexLookup
ºº& 8
{
ΩΩ 	
get
ææ 
{
øø 
if
¿¿ 
(
¿¿ 
(
¿¿ 
m_CacheValid
¿¿ !
&
¿¿" #
CacheValidState
¿¿$ 3
.
¿¿3 4
SharedVertex
¿¿4 @
)
¿¿@ A
!=
¿¿B D
CacheValidState
¿¿E T
.
¿¿T U
SharedVertex
¿¿U a
)
¿¿a b
{
¡¡ 
if
¬¬ 
(
¬¬ "
m_SharedVertexLookup
¬¬ ,
==
¬¬- /
null
¬¬0 4
)
¬¬4 5"
m_SharedVertexLookup
√√ ,
=
√√- .
new
√√/ 2

Dictionary
√√3 =
<
√√= >
int
√√> A
,
√√A B
int
√√C F
>
√√F G
(
√√G H
)
√√H I
;
√√I J
SharedVertex
ƒƒ  
.
ƒƒ  !#
GetSharedVertexLookup
ƒƒ! 6
(
ƒƒ6 7
m_SharedVertices
ƒƒ7 G
,
ƒƒG H"
m_SharedVertexLookup
ƒƒI ]
)
ƒƒ] ^
;
ƒƒ^ _
m_CacheValid
≈≈  
|=
≈≈! #
CacheValidState
≈≈$ 3
.
≈≈3 4
SharedVertex
≈≈4 @
;
≈≈@ A
}
∆∆ 
return
»» "
m_SharedVertexLookup
»» +
;
»»+ ,
}
…… 
}
   	
internal
”” 
void
”” 
SetSharedVertices
”” '
(
””' (
IEnumerable
””( 3
<
””3 4
KeyValuePair
””4 @
<
””@ A
int
””A D
,
””D E
int
””F I
>
””I J
>
””J K
indexes
””L S
)
””S T
{
‘‘ 	
if
’’ 
(
’’ 
indexes
’’ 
==
’’ 
null
’’ 
)
’’  
throw
÷÷ 
new
÷÷ #
ArgumentNullException
÷÷ /
(
÷÷/ 0
$str
÷÷0 9
)
÷÷9 :
;
÷÷: ;
m_SharedVertices
◊◊ 
=
◊◊ 
SharedVertex
◊◊ +
.
◊◊+ ,
ToSharedVertices
◊◊, <
(
◊◊< =
indexes
◊◊= D
)
◊◊D E
;
◊◊E F*
InvalidateSharedVertexLookup
ÿÿ (
(
ÿÿ( )
)
ÿÿ) *
;
ÿÿ* +
}
ŸŸ 	
internal
€€ 
SharedVertex
€€ 
[
€€ 
]
€€ 
sharedTextures
€€  .
{
‹‹ 	
get
›› 
{
›› 
return
›› 
m_SharedTextures
›› )
;
››) *
}
››+ ,
set
ﬁﬁ 
{
ﬂﬂ 
m_SharedTextures
‡‡  
=
‡‡! "
value
‡‡# (
;
‡‡( )+
InvalidateSharedTextureLookup
·· -
(
··- .
)
··. /
;
··/ 0
}
‚‚ 
}
„„ 	
internal
ÂÂ 

Dictionary
ÂÂ 
<
ÂÂ 
int
ÂÂ 
,
ÂÂ  
int
ÂÂ! $
>
ÂÂ$ %!
sharedTextureLookup
ÂÂ& 9
{
ÊÊ 	
get
ÁÁ 
{
ËË 
if
ÈÈ 
(
ÈÈ 
(
ÈÈ 
m_CacheValid
ÈÈ !
&
ÈÈ" #
CacheValidState
ÈÈ$ 3
.
ÈÈ3 4
SharedTexture
ÈÈ4 A
)
ÈÈA B
!=
ÈÈC E
CacheValidState
ÈÈF U
.
ÈÈU V
SharedTexture
ÈÈV c
)
ÈÈc d
{
ÍÍ 
m_CacheValid
ÎÎ  
|=
ÎÎ! #
CacheValidState
ÎÎ$ 3
.
ÎÎ3 4
SharedTexture
ÎÎ4 A
;
ÎÎA B
if
ÏÏ 
(
ÏÏ #
m_SharedTextureLookup
ÏÏ -
==
ÏÏ. 0
null
ÏÏ1 5
)
ÏÏ5 6#
m_SharedTextureLookup
ÌÌ -
=
ÌÌ. /
new
ÌÌ0 3

Dictionary
ÌÌ4 >
<
ÌÌ> ?
int
ÌÌ? B
,
ÌÌB C
int
ÌÌD G
>
ÌÌG H
(
ÌÌH I
)
ÌÌI J
;
ÌÌJ K
SharedVertex
ÓÓ  
.
ÓÓ  !#
GetSharedVertexLookup
ÓÓ! 6
(
ÓÓ6 7
m_SharedTextures
ÓÓ7 G
,
ÓÓG H#
m_SharedTextureLookup
ÓÓI ^
)
ÓÓ^ _
;
ÓÓ_ `
}
ÔÔ 
return
ÒÒ #
m_SharedTextureLookup
ÒÒ ,
;
ÒÒ, -
}
ÚÚ 
}
ÛÛ 	
internal
ıı 
void
ıı 
SetSharedTextures
ıı '
(
ıı' (
IEnumerable
ıı( 3
<
ıı3 4
KeyValuePair
ıı4 @
<
ıı@ A
int
ııA D
,
ııD E
int
ııF I
>
ııI J
>
ııJ K
indexes
ııL S
)
ııS T
{
ˆˆ 	
if
˜˜ 
(
˜˜ 
indexes
˜˜ 
==
˜˜ 
null
˜˜ 
)
˜˜  
throw
¯¯ 
new
¯¯ #
ArgumentNullException
¯¯ /
(
¯¯/ 0
$str
¯¯0 9
)
¯¯9 :
;
¯¯: ;
m_SharedTextures
˘˘ 
=
˘˘ 
SharedVertex
˘˘ +
.
˘˘+ ,
ToSharedVertices
˘˘, <
(
˘˘< =
indexes
˘˘= D
)
˘˘D E
;
˘˘E F+
InvalidateSharedTextureLookup
˙˙ )
(
˙˙) *
)
˙˙* +
;
˙˙+ ,
}
˚˚ 	
internal
˝˝ 
Vector3
˝˝ 
[
˝˝ 
]
˝˝ 
positionsInternal
˝˝ ,
{
˛˛ 	
get
ˇˇ 
{
ˇˇ 
return
ˇˇ 
m_Positions
ˇˇ $
;
ˇˇ$ %
}
ˇˇ& '
set
ÄÄ 
{
ÄÄ 
m_Positions
ÄÄ 
=
ÄÄ 
value
ÄÄ  %
;
ÄÄ% &
}
ÄÄ' (
}
ÅÅ 	
public
ÜÜ 
IList
ÜÜ 
<
ÜÜ 
Vector3
ÜÜ 
>
ÜÜ 
	positions
ÜÜ '
{
áá 	
get
àà 
{
àà 
return
àà 
new
àà  
ReadOnlyCollection
àà /
<
àà/ 0
Vector3
àà0 7
>
àà7 8
(
àà8 9
m_Positions
àà9 D
)
ààD E
;
ààE F
}
ààG H
set
ââ 
{
ää 
if
ãã 
(
ãã 
value
ãã 
==
ãã 
null
ãã !
)
ãã! "
throw
åå 
new
åå #
ArgumentNullException
åå 3
(
åå3 4
$str
åå4 ;
)
åå; <
;
åå< =
m_Positions
çç 
=
çç 
value
çç #
.
çç# $
ToArray
çç$ +
(
çç+ ,
)
çç, -
;
çç- .
}
éé 
}
èè 	
public
ññ 
Vertex
ññ 
[
ññ 
]
ññ 
GetVertices
ññ #
(
ññ# $
IList
ññ$ )
<
ññ) *
int
ññ* -
>
ññ- .
indexes
ññ/ 6
=
ññ7 8
null
ññ9 =
)
ññ= >
{
óó 	
int
òò 
meshVertexCount
òò 
=
òò  !
vertexCount
òò" -
;
òò- .
int
ôô 
vc
ôô 
=
ôô 
indexes
ôô 
!=
ôô 
null
ôô  $
?
ôô% &
indexes
ôô' .
.
ôô. /
Count
ôô/ 4
:
ôô5 6
vertexCount
ôô7 B
;
ôôB C
Vertex
õõ 
[
õõ 
]
õõ 
v
õõ 
=
õõ 
new
õõ 
Vertex
õõ #
[
õõ# $
vc
õõ$ &
]
õõ& '
;
õõ' (
Vector3
ùù 
[
ùù 
]
ùù 
	positions
ùù 
=
ùù  !
positionsInternal
ùù" 3
;
ùù3 4
Color
ûû 
[
ûû 
]
ûû 
colors
ûû 
=
ûû 
colorsInternal
ûû +
;
ûû+ ,
Vector2
üü 
[
üü 
]
üü 
uv0s
üü 
=
üü 
texturesInternal
üü -
;
üü- .
Vector4
†† 
[
†† 
]
†† 
tangents
†† 
=
††  
GetTangents
††! ,
(
††, -
)
††- .
;
††. /
Vector3
°° 
[
°° 
]
°° 
normals
°° 
=
°° 

GetNormals
°°  *
(
°°* +
)
°°+ ,
;
°°, -
Vector2
¢¢ 
[
¢¢ 
]
¢¢ 
uv2s
¢¢ 
=
¢¢ 
mesh
¢¢ !
!=
¢¢" $
null
¢¢% )
?
¢¢* +
mesh
¢¢, 0
.
¢¢0 1
uv2
¢¢1 4
:
¢¢5 6
null
¢¢7 ;
;
¢¢; <
List
§§ 
<
§§ 
Vector4
§§ 
>
§§ 
uv3s
§§ 
=
§§  
new
§§! $
List
§§% )
<
§§) *
Vector4
§§* 1
>
§§1 2
(
§§2 3
)
§§3 4
;
§§4 5
List
•• 
<
•• 
Vector4
•• 
>
•• 
uv4s
•• 
=
••  
new
••! $
List
••% )
<
••) *
Vector4
••* 1
>
••1 2
(
••2 3
)
••3 4
;
••4 5
GetUVs
ßß 
(
ßß 
$num
ßß 
,
ßß 
uv3s
ßß 
)
ßß 
;
ßß 
GetUVs
®® 
(
®® 
$num
®® 
,
®® 
uv4s
®® 
)
®® 
;
®® 
bool
™™ 
_hasPositions
™™ 
=
™™  
	positions
™™! *
!=
™™+ -
null
™™. 2
&&
™™3 5
	positions
™™6 ?
.
™™? @
Count
™™@ E
(
™™E F
)
™™F G
==
™™H J
meshVertexCount
™™K Z
;
™™Z [
bool
´´ 

_hasColors
´´ 
=
´´ 
colors
´´ $
!=
´´% '
null
´´( ,
&&
´´- /
colors
´´0 6
.
´´6 7
Count
´´7 <
(
´´< =
)
´´= >
==
´´? A
meshVertexCount
´´B Q
;
´´Q R
bool
¨¨ 
_hasNormals
¨¨ 
=
¨¨ 
normals
¨¨ &
!=
¨¨' )
null
¨¨* .
&&
¨¨/ 1
normals
¨¨2 9
.
¨¨9 :
Count
¨¨: ?
(
¨¨? @
)
¨¨@ A
==
¨¨B D
meshVertexCount
¨¨E T
;
¨¨T U
bool
≠≠ 
_hasTangents
≠≠ 
=
≠≠ 
tangents
≠≠  (
!=
≠≠) +
null
≠≠, 0
&&
≠≠1 3
tangents
≠≠4 <
.
≠≠< =
Count
≠≠= B
(
≠≠B C
)
≠≠C D
==
≠≠E G
meshVertexCount
≠≠H W
;
≠≠W X
bool
ÆÆ 
_hasUv0
ÆÆ 
=
ÆÆ 
uv0s
ÆÆ 
!=
ÆÆ  "
null
ÆÆ# '
&&
ÆÆ( *
uv0s
ÆÆ+ /
.
ÆÆ/ 0
Count
ÆÆ0 5
(
ÆÆ5 6
)
ÆÆ6 7
==
ÆÆ8 :
meshVertexCount
ÆÆ; J
;
ÆÆJ K
bool
ØØ 
_hasUv2
ØØ 
=
ØØ 
uv2s
ØØ 
!=
ØØ  "
null
ØØ# '
&&
ØØ( *
uv2s
ØØ+ /
.
ØØ/ 0
Count
ØØ0 5
(
ØØ5 6
)
ØØ6 7
==
ØØ8 :
meshVertexCount
ØØ; J
;
ØØJ K
bool
∞∞ 
_hasUv3
∞∞ 
=
∞∞ 
uv3s
∞∞ 
.
∞∞  
Count
∞∞  %
(
∞∞% &
)
∞∞& '
==
∞∞( *
meshVertexCount
∞∞+ :
;
∞∞: ;
bool
±± 
_hasUv4
±± 
=
±± 
uv4s
±± 
.
±±  
Count
±±  %
(
±±% &
)
±±& '
==
±±( *
meshVertexCount
±±+ :
;
±±: ;
for
≥≥ 
(
≥≥ 
int
≥≥ 
i
≥≥ 
=
≥≥ 
$num
≥≥ 
;
≥≥ 
i
≥≥ 
<
≥≥ 
vc
≥≥  "
;
≥≥" #
i
≥≥$ %
++
≥≥% '
)
≥≥' (
{
¥¥ 
v
µµ 
[
µµ 
i
µµ 
]
µµ 
=
µµ 
new
µµ 
Vertex
µµ !
(
µµ! "
)
µµ" #
;
µµ# $
int
∑∑ 
ind
∑∑ 
=
∑∑ 
indexes
∑∑ !
==
∑∑" $
null
∑∑% )
?
∑∑* +
i
∑∑, -
:
∑∑. /
indexes
∑∑0 7
[
∑∑7 8
i
∑∑8 9
]
∑∑9 :
;
∑∑: ;
if
ππ 
(
ππ 
_hasPositions
ππ !
)
ππ! "
v
∫∫ 
[
∫∫ 
i
∫∫ 
]
∫∫ 
.
∫∫ 
position
∫∫ !
=
∫∫" #
	positions
∫∫$ -
[
∫∫- .
ind
∫∫. 1
]
∫∫1 2
;
∫∫2 3
if
ºº 
(
ºº 

_hasColors
ºº 
)
ºº 
v
ΩΩ 
[
ΩΩ 
i
ΩΩ 
]
ΩΩ 
.
ΩΩ 
color
ΩΩ 
=
ΩΩ  
colors
ΩΩ! '
[
ΩΩ' (
ind
ΩΩ( +
]
ΩΩ+ ,
;
ΩΩ, -
if
øø 
(
øø 
_hasNormals
øø 
)
øø  
v
¿¿ 
[
¿¿ 
i
¿¿ 
]
¿¿ 
.
¿¿ 
normal
¿¿ 
=
¿¿  !
normals
¿¿" )
[
¿¿) *
ind
¿¿* -
]
¿¿- .
;
¿¿. /
if
¬¬ 
(
¬¬ 
_hasTangents
¬¬  
)
¬¬  !
v
√√ 
[
√√ 
i
√√ 
]
√√ 
.
√√ 
tangent
√√  
=
√√! "
tangents
√√# +
[
√√+ ,
ind
√√, /
]
√√/ 0
;
√√0 1
if
≈≈ 
(
≈≈ 
_hasUv0
≈≈ 
)
≈≈ 
v
∆∆ 
[
∆∆ 
i
∆∆ 
]
∆∆ 
.
∆∆ 
uv0
∆∆ 
=
∆∆ 
uv0s
∆∆ #
[
∆∆# $
ind
∆∆$ '
]
∆∆' (
;
∆∆( )
if
»» 
(
»» 
_hasUv2
»» 
)
»» 
v
…… 
[
…… 
i
…… 
]
…… 
.
…… 
uv2
…… 
=
…… 
uv2s
…… #
[
……# $
ind
……$ '
]
……' (
;
……( )
if
ÀÀ 
(
ÀÀ 
_hasUv3
ÀÀ 
)
ÀÀ 
v
ÃÃ 
[
ÃÃ 
i
ÃÃ 
]
ÃÃ 
.
ÃÃ 
uv3
ÃÃ 
=
ÃÃ 
uv3s
ÃÃ #
[
ÃÃ# $
ind
ÃÃ$ '
]
ÃÃ' (
;
ÃÃ( )
if
ŒŒ 
(
ŒŒ 
_hasUv4
ŒŒ 
)
ŒŒ 
v
œœ 
[
œœ 
i
œœ 
]
œœ 
.
œœ 
uv4
œœ 
=
œœ 
uv4s
œœ #
[
œœ# $
ind
œœ$ '
]
œœ' (
;
œœ( )
}
–– 
return
““ 
v
““ 
;
““ 
}
”” 	
public
⁄⁄ 
void
⁄⁄ 
SetVertices
⁄⁄ 
(
⁄⁄  
IList
⁄⁄  %
<
⁄⁄% &
Vertex
⁄⁄& ,
>
⁄⁄, -
vertices
⁄⁄. 6
,
⁄⁄6 7
bool
⁄⁄8 <
	applyMesh
⁄⁄= F
=
⁄⁄G H
false
⁄⁄I N
)
⁄⁄N O
{
€€ 	
if
‹‹ 
(
‹‹ 
vertices
‹‹ 
==
‹‹ 
null
‹‹  
)
‹‹  !
throw
›› 
new
›› #
ArgumentNullException
›› /
(
››/ 0
$str
››0 :
)
››: ;
;
››; <
var
ﬂﬂ 
first
ﬂﬂ 
=
ﬂﬂ 
vertices
ﬂﬂ  
.
ﬂﬂ  !
FirstOrDefault
ﬂﬂ! /
(
ﬂﬂ/ 0
)
ﬂﬂ0 1
;
ﬂﬂ1 2
if
·· 
(
·· 
first
·· 
==
·· 
null
·· 
||
··  
!
··! "
first
··" '
.
··' (
	HasArrays
··( 1
(
··1 2

MeshArrays
··2 <
.
··< =
Position
··= E
)
··E F
)
··F G
{
‚‚ 
Clear
„„ 
(
„„ 
)
„„ 
;
„„ 
return
‰‰ 
;
‰‰ 
}
ÂÂ 
Vector3
ÁÁ 
[
ÁÁ 
]
ÁÁ 
position
ÁÁ 
;
ÁÁ 
Color
ËË 
[
ËË 
]
ËË 
color
ËË 
;
ËË 
Vector3
ÈÈ 
[
ÈÈ 
]
ÈÈ 
normal
ÈÈ 
;
ÈÈ 
Vector4
ÍÍ 
[
ÍÍ 
]
ÍÍ 
tangent
ÍÍ 
;
ÍÍ 
Vector2
ÎÎ 
[
ÎÎ 
]
ÎÎ 
uv0
ÎÎ 
;
ÎÎ 
Vector2
ÏÏ 
[
ÏÏ 
]
ÏÏ 
uv2
ÏÏ 
;
ÏÏ 
List
ÌÌ 
<
ÌÌ 
Vector4
ÌÌ 
>
ÌÌ 
uv3
ÌÌ 
;
ÌÌ 
List
ÓÓ 
<
ÓÓ 
Vector4
ÓÓ 
>
ÓÓ 
uv4
ÓÓ 
;
ÓÓ 
Vertex
 
.
 
	GetArrays
 
(
 
vertices
 %
,
% &
out
' *
position
+ 3
,
3 4
out
5 8
color
9 >
,
> ?
out
@ C
uv0
D G
,
G H
out
I L
normal
M S
,
S T
out
U X
tangent
Y `
,
` a
out
b e
uv2
f i
,
i j
out
k n
uv3
o r
,
r s
out
t w
uv4
x {
)
{ |
;
| }
m_Positions
ÚÚ 
=
ÚÚ 
position
ÚÚ "
;
ÚÚ" #
m_Colors
ÛÛ 
=
ÛÛ 
color
ÛÛ 
;
ÛÛ 

m_Tangents
ÙÙ 
=
ÙÙ 
tangent
ÙÙ  
;
ÙÙ  !
m_Textures0
ıı 
=
ıı 
uv0
ıı 
;
ıı 
m_Textures2
ˆˆ 
=
ˆˆ 
uv3
ˆˆ 
;
ˆˆ 
m_Textures3
˜˜ 
=
˜˜ 
uv4
˜˜ 
;
˜˜ 
if
˘˘ 
(
˘˘ 
	applyMesh
˘˘ 
)
˘˘ 
{
˙˙ 
Mesh
˚˚ 
umesh
˚˚ 
=
˚˚ 
mesh
˚˚ !
;
˚˚! "
if
˝˝ 
(
˝˝ 
first
˝˝ 
.
˝˝ 
	HasArrays
˝˝ #
(
˝˝# $

MeshArrays
˝˝$ .
.
˝˝. /
Position
˝˝/ 7
)
˝˝7 8
)
˝˝8 9
umesh
˛˛ 
.
˛˛ 
vertices
˛˛ "
=
˛˛# $
position
˛˛% -
;
˛˛- .
if
ˇˇ 
(
ˇˇ 
first
ˇˇ 
.
ˇˇ 
	HasArrays
ˇˇ #
(
ˇˇ# $

MeshArrays
ˇˇ$ .
.
ˇˇ. /
Color
ˇˇ/ 4
)
ˇˇ4 5
)
ˇˇ5 6
umesh
ÄÄ 
.
ÄÄ 
colors
ÄÄ  
=
ÄÄ! "
color
ÄÄ# (
;
ÄÄ( )
if
ÅÅ 
(
ÅÅ 
first
ÅÅ 
.
ÅÅ 
	HasArrays
ÅÅ #
(
ÅÅ# $

MeshArrays
ÅÅ$ .
.
ÅÅ. /
Texture0
ÅÅ/ 7
)
ÅÅ7 8
)
ÅÅ8 9
umesh
ÇÇ 
.
ÇÇ 
uv
ÇÇ 
=
ÇÇ 
uv0
ÇÇ "
;
ÇÇ" #
if
ÉÉ 
(
ÉÉ 
first
ÉÉ 
.
ÉÉ 
	HasArrays
ÉÉ #
(
ÉÉ# $

MeshArrays
ÉÉ$ .
.
ÉÉ. /
Normal
ÉÉ/ 5
)
ÉÉ5 6
)
ÉÉ6 7
umesh
ÑÑ 
.
ÑÑ 
normals
ÑÑ !
=
ÑÑ" #
normal
ÑÑ$ *
;
ÑÑ* +
if
ÖÖ 
(
ÖÖ 
first
ÖÖ 
.
ÖÖ 
	HasArrays
ÖÖ #
(
ÖÖ# $

MeshArrays
ÖÖ$ .
.
ÖÖ. /
Tangent
ÖÖ/ 6
)
ÖÖ6 7
)
ÖÖ7 8
umesh
ÜÜ 
.
ÜÜ 
tangents
ÜÜ "
=
ÜÜ# $
tangent
ÜÜ% ,
;
ÜÜ, -
if
áá 
(
áá 
first
áá 
.
áá 
	HasArrays
áá #
(
áá# $

MeshArrays
áá$ .
.
áá. /
Texture1
áá/ 7
)
áá7 8
)
áá8 9
umesh
àà 
.
àà 
uv2
àà 
=
àà 
uv2
àà  #
;
àà# $
if
ââ 
(
ââ 
first
ââ 
.
ââ 
	HasArrays
ââ #
(
ââ# $

MeshArrays
ââ$ .
.
ââ. /
Texture2
ââ/ 7
)
ââ7 8
)
ââ8 9
umesh
ää 
.
ää 
SetUVs
ää  
(
ää  !
$num
ää! "
,
ää" #
uv3
ää$ '
)
ää' (
;
ää( )
if
ãã 
(
ãã 
first
ãã 
.
ãã 
	HasArrays
ãã #
(
ãã# $

MeshArrays
ãã$ .
.
ãã. /
Texture3
ãã/ 7
)
ãã7 8
)
ãã8 9
umesh
åå 
.
åå 
SetUVs
åå  
(
åå  !
$num
åå! "
,
åå" #
uv4
åå$ '
)
åå' (
;
åå( )
}
çç 
}
éé 	
public
ïï 
IList
ïï 
<
ïï 
Vector3
ïï 
>
ïï 
normals
ïï %
{
ññ 	
get
óó 
{
óó 
return
óó 
	m_Normals
óó "
!=
óó# %
null
óó& *
?
óó+ ,
new
óó- 0 
ReadOnlyCollection
óó1 C
<
óóC D
Vector3
óóD K
>
óóK L
(
óóL M
	m_Normals
óóM V
)
óóV W
:
óóX Y
null
óóZ ^
;
óó^ _
}
óó` a
}
òò 	
internal
öö 
Vector3
öö 
[
öö 
]
öö 
normalsInternal
öö *
{
õõ 	
get
úú 
{
úú 
return
úú 
	m_Normals
úú "
;
úú" #
}
úú$ %
set
ùù 
{
ùù 
	m_Normals
ùù 
=
ùù 
value
ùù #
;
ùù# $
}
ùù% &
}
ûû 	
public
¶¶ 
Vector3
¶¶ 
[
¶¶ 
]
¶¶ 

GetNormals
¶¶ #
(
¶¶# $
)
¶¶$ %
{
ßß 	
if
®® 
(
®® 
!
®® 
	HasArrays
®® 
(
®® 

MeshArrays
®® %
.
®®% &
Normal
®®& ,
)
®®, -
)
®®- .
Normals
©© 
.
©© 
CalculateNormals
©© (
(
©©( )
this
©©) -
)
©©- .
;
©©. /
return
´´ 
normals
´´ 
.
´´ 
ToArray
´´ "
(
´´" #
)
´´# $
;
´´$ %
}
¨¨ 	
internal
ÆÆ 
Color
ÆÆ 
[
ÆÆ 
]
ÆÆ 
colorsInternal
ÆÆ '
{
ØØ 	
get
∞∞ 
{
∞∞ 
return
∞∞ 
m_Colors
∞∞ !
;
∞∞! "
}
∞∞# $
set
±± 
{
±± 
m_Colors
±± 
=
±± 
value
±± "
;
±±" #
}
±±$ %
}
≤≤ 	
public
∑∑ 
IList
∑∑ 
<
∑∑ 
Color
∑∑ 
>
∑∑ 
colors
∑∑ "
{
∏∏ 	
get
ππ 
{
ππ 
return
ππ 
m_Colors
ππ !
!=
ππ" $
null
ππ% )
?
ππ* +
new
ππ, / 
ReadOnlyCollection
ππ0 B
<
ππB C
Color
ππC H
>
ππH I
(
ππI J
m_Colors
ππJ R
)
ππR S
:
ππT U
null
ππV Z
;
ππZ [
}
ππ\ ]
set
ªª 
{
ºº 
if
ΩΩ 
(
ΩΩ 
value
ΩΩ 
==
ΩΩ 
null
ΩΩ !
)
ΩΩ! "
m_Colors
ææ 
=
ææ 
null
ææ #
;
ææ# $
else
øø 
if
øø 
(
øø 
value
øø 
.
øø 
Count
øø $
(
øø$ %
)
øø% &
!=
øø' )
vertexCount
øø* 5
)
øø5 6
throw
¿¿ 
new
¿¿ )
ArgumentOutOfRangeException
¿¿ 9
(
¿¿9 :
$str
¿¿: A
,
¿¿A B
$str
¿¿C j
)
¿¿j k
;
¿¿k l
else
¡¡ 
m_Colors
¬¬ 
=
¬¬ 
value
¬¬ $
.
¬¬$ %
ToArray
¬¬% ,
(
¬¬, -
)
¬¬- .
;
¬¬. /
}
√√ 
}
ƒƒ 	
public
   
Color
   
[
   
]
   
	GetColors
    
(
    !
)
  ! "
{
ÀÀ 	
if
ÃÃ 
(
ÃÃ 
	HasArrays
ÃÃ 
(
ÃÃ 

MeshArrays
ÃÃ $
.
ÃÃ$ %
Color
ÃÃ% *
)
ÃÃ* +
)
ÃÃ+ ,
return
ÕÕ 
colors
ÕÕ 
.
ÕÕ 
ToArray
ÕÕ %
(
ÕÕ% &
)
ÕÕ& '
;
ÕÕ' (
return
ŒŒ 
ArrayUtility
ŒŒ 
.
ŒŒ  
Fill
ŒŒ  $
(
ŒŒ$ %
Color
ŒŒ% *
.
ŒŒ* +
white
ŒŒ+ 0
,
ŒŒ0 1
vertexCount
ŒŒ2 =
)
ŒŒ= >
;
ŒŒ> ?
}
œœ 	
public
ÿÿ 
IList
ÿÿ 
<
ÿÿ 
Vector4
ÿÿ 
>
ÿÿ 
tangents
ÿÿ &
{
ŸŸ 	
get
⁄⁄ 
{
€€ 
return
‹‹ 

m_Tangents
‹‹ !
==
‹‹" $
null
‹‹% )
||
‹‹* ,

m_Tangents
‹‹- 7
.
‹‹7 8
Length
‹‹8 >
!=
‹‹? A
vertexCount
‹‹B M
?
›› 
null
›› 
:
ﬁﬁ 
new
ﬁﬁ  
ReadOnlyCollection
ﬁﬁ ,
<
ﬁﬁ, -
Vector4
ﬁﬁ- 4
>
ﬁﬁ4 5
(
ﬁﬁ5 6

m_Tangents
ﬁﬁ6 @
)
ﬁﬁ@ A
;
ﬁﬁA B
}
ﬂﬂ 
set
·· 
{
‚‚ 
if
„„ 
(
„„ 
value
„„ 
==
„„ 
null
„„ !
)
„„! "

m_Tangents
‰‰ 
=
‰‰  
null
‰‰! %
;
‰‰% &
else
ÂÂ 
if
ÂÂ 
(
ÂÂ 
value
ÂÂ 
.
ÂÂ 
Count
ÂÂ $
(
ÂÂ$ %
)
ÂÂ% &
!=
ÂÂ' )
vertexCount
ÂÂ* 5
)
ÂÂ5 6
throw
ÊÊ 
new
ÊÊ )
ArgumentOutOfRangeException
ÊÊ 9
(
ÊÊ9 :
$str
ÊÊ: A
,
ÊÊA B
$str
ÊÊC q
)
ÊÊq r
;
ÊÊr s
else
ÁÁ 

m_Tangents
ËË 
=
ËË  
value
ËË! &
.
ËË& '
ToArray
ËË' .
(
ËË. /
)
ËË/ 0
;
ËË0 1
}
ÈÈ 
}
ÍÍ 	
internal
ÏÏ 
Vector4
ÏÏ 
[
ÏÏ 
]
ÏÏ 
tangentsInternal
ÏÏ +
{
ÌÌ 	
get
ÓÓ 
{
ÓÓ 
return
ÓÓ 

m_Tangents
ÓÓ #
;
ÓÓ# $
}
ÓÓ% &
set
ÔÔ 
{
ÔÔ 

m_Tangents
ÔÔ 
=
ÔÔ 
value
ÔÔ $
;
ÔÔ$ %
}
ÔÔ& '
}
 	
public
ˆˆ 
Vector4
ˆˆ 
[
ˆˆ 
]
ˆˆ 
GetTangents
ˆˆ $
(
ˆˆ$ %
)
ˆˆ% &
{
˜˜ 	
if
¯¯ 
(
¯¯ 
!
¯¯ 
	HasArrays
¯¯ 
(
¯¯ 

MeshArrays
¯¯ %
.
¯¯% &
Tangent
¯¯& -
)
¯¯- .
)
¯¯. /
Normals
˘˘ 
.
˘˘ 
CalculateTangents
˘˘ )
(
˘˘) *
this
˘˘* .
)
˘˘. /
;
˘˘/ 0
return
˚˚ 
tangents
˚˚ 
.
˚˚ 
ToArray
˚˚ #
(
˚˚# $
)
˚˚$ %
;
˚˚% &
}
¸¸ 	
internal
˛˛ 
Vector2
˛˛ 
[
˛˛ 
]
˛˛ 
texturesInternal
˛˛ +
{
ˇˇ 	
get
ÄÄ 
{
ÄÄ 
return
ÄÄ 
m_Textures0
ÄÄ $
;
ÄÄ$ %
}
ÄÄ& '
set
ÅÅ 
{
ÅÅ 
m_Textures0
ÅÅ 
=
ÅÅ 
value
ÅÅ  %
;
ÅÅ% &
}
ÅÅ' (
}
ÇÇ 	
public
àà 
IList
àà 
<
àà 
Vector2
àà 
>
àà 
textures
àà &
{
ââ 	
get
ää 
{
ää 
return
ää 
m_Textures0
ää $
!=
ää% '
null
ää( ,
?
ää- .
new
ää/ 2 
ReadOnlyCollection
ää3 E
<
ääE F
Vector2
ääF M
>
ääM N
(
ääN O
m_Textures0
ääO Z
)
ääZ [
:
ää\ ]
null
ää^ b
;
ääb c
}
ääd e
set
ãã 
{
åå 
if
çç 
(
çç 
value
çç 
==
çç 
null
çç !
)
çç! "
m_Textures0
éé 
=
éé  !
null
éé" &
;
éé& '
else
èè 
if
èè 
(
èè 
value
èè 
.
èè 
Count
èè $
(
èè$ %
)
èè% &
!=
èè' )
vertexCount
èè* 5
)
èè5 6
throw
êê 
new
êê )
ArgumentOutOfRangeException
êê 9
(
êê9 :
$str
êê: A
)
êêA B
;
êêB C
else
ëë 
m_Textures0
íí 
=
íí  !
value
íí" '
.
íí' (
ToArray
íí( /
(
íí/ 0
)
íí0 1
;
íí1 2
}
ìì 
}
îî 	
public
õõ 
void
õõ 
GetUVs
õõ 
(
õõ 
int
õõ 
channel
õõ &
,
õõ& '
List
õõ( ,
<
õõ, -
Vector4
õõ- 4
>
õõ4 5
uvs
õõ6 9
)
õõ9 :
{
úú 	
if
ùù 
(
ùù 
uvs
ùù 
==
ùù 
null
ùù 
)
ùù 
throw
ûû 
new
ûû #
ArgumentNullException
ûû /
(
ûû/ 0
$str
ûû0 5
)
ûû5 6
;
ûû6 7
if
†† 
(
†† 
channel
†† 
<
†† 
$num
†† 
||
†† 
channel
†† &
>
††' (
$num
††) *
)
††* +
throw
°° 
new
°° )
ArgumentOutOfRangeException
°° 5
(
°°5 6
$str
°°6 ?
)
°°? @
;
°°@ A
uvs
££ 
.
££ 
Clear
££ 
(
££ 
)
££ 
;
££ 
switch
•• 
(
•• 
channel
•• 
)
•• 
{
¶¶ 
case
ßß 
$num
ßß 
:
ßß 
for
®® 
(
®® 
int
®® 
i
®® 
=
®®  
$num
®®! "
;
®®" #
i
®®$ %
<
®®& '
vertexCount
®®( 3
;
®®3 4
i
®®5 6
++
®®6 8
)
®®8 9
uvs
©© 
.
©© 
Add
©© 
(
©©  
(
©©  !
Vector4
©©! (
)
©©( )
m_Textures0
©©) 4
[
©©4 5
i
©©5 6
]
©©6 7
)
©©7 8
;
©©8 9
break
™™ 
;
™™ 
case
¨¨ 
$num
¨¨ 
:
¨¨ 
if
≠≠ 
(
≠≠ 
mesh
≠≠ 
!=
≠≠ 
null
≠≠  $
&&
≠≠% '
mesh
≠≠( ,
.
≠≠, -
uv2
≠≠- 0
!=
≠≠1 3
null
≠≠4 8
)
≠≠8 9
{
ÆÆ 
Vector2
ØØ 
[
ØØ  
]
ØØ  !
uv2
ØØ" %
=
ØØ& '
mesh
ØØ( ,
.
ØØ, -
uv2
ØØ- 0
;
ØØ0 1
for
∞∞ 
(
∞∞ 
int
∞∞  
i
∞∞! "
=
∞∞# $
$num
∞∞% &
;
∞∞& '
i
∞∞( )
<
∞∞* +
uv2
∞∞, /
.
∞∞/ 0
Length
∞∞0 6
;
∞∞6 7
i
∞∞8 9
++
∞∞9 ;
)
∞∞; <
uvs
±± 
.
±±  
Add
±±  #
(
±±# $
(
±±$ %
Vector4
±±% ,
)
±±, -
uv2
±±- 0
[
±±0 1
i
±±1 2
]
±±2 3
)
±±3 4
;
±±4 5
}
≤≤ 
break
≥≥ 
;
≥≥ 
case
µµ 
$num
µµ 
:
µµ 
if
∂∂ 
(
∂∂ 
m_Textures2
∂∂ #
!=
∂∂$ &
null
∂∂' +
)
∂∂+ ,
uvs
∑∑ 
.
∑∑ 
AddRange
∑∑ $
(
∑∑$ %
m_Textures2
∑∑% 0
)
∑∑0 1
;
∑∑1 2
break
∏∏ 
;
∏∏ 
case
∫∫ 
$num
∫∫ 
:
∫∫ 
if
ªª 
(
ªª 
m_Textures3
ªª #
!=
ªª$ &
null
ªª' +
)
ªª+ ,
uvs
ºº 
.
ºº 
AddRange
ºº $
(
ºº$ %
m_Textures3
ºº% 0
)
ºº0 1
;
ºº1 2
break
ΩΩ 
;
ΩΩ 
}
ææ 
}
øø 	
internal
¡¡  
ReadOnlyCollection
¡¡ #
<
¡¡# $
Vector2
¡¡$ +
>
¡¡+ ,
GetUVs
¡¡- 3
(
¡¡3 4
int
¡¡4 7
channel
¡¡8 ?
)
¡¡? @
{
¬¬ 	
if
√√ 
(
√√ 
channel
√√ 
==
√√ 
$num
√√ 
)
√√ 
return
ƒƒ 
new
ƒƒ  
ReadOnlyCollection
ƒƒ -
<
ƒƒ- .
Vector2
ƒƒ. 5
>
ƒƒ5 6
(
ƒƒ6 7
m_Textures0
ƒƒ7 B
)
ƒƒB C
;
ƒƒC D
if
∆∆ 
(
∆∆ 
channel
∆∆ 
==
∆∆ 
$num
∆∆ 
)
∆∆ 
return
«« 
new
««  
ReadOnlyCollection
«« -
<
««- .
Vector2
««. 5
>
««5 6
(
««6 7
mesh
««7 ;
.
««; <
uv2
««< ?
)
««? @
;
««@ A
if
…… 
(
…… 
channel
…… 
==
…… 
$num
…… 
)
…… 
return
   
m_Textures2
   "
==
  # %
null
  & *
?
  + ,
null
  - 1
:
  2 3
new
  4 7 
ReadOnlyCollection
  8 J
<
  J K
Vector2
  K R
>
  R S
(
  S T
m_Textures2
  T _
.
  _ `
Cast
  ` d
<
  d e
Vector2
  e l
>
  l m
(
  m n
)
  n o
.
  o p
ToList
  p v
(
  v w
)
  w x
)
  x y
;
  y z
if
ÃÃ 
(
ÃÃ 
channel
ÃÃ 
==
ÃÃ 
$num
ÃÃ 
)
ÃÃ 
return
ÕÕ 
m_Textures3
ÕÕ "
==
ÕÕ# %
null
ÕÕ& *
?
ÕÕ+ ,
null
ÕÕ- 1
:
ÕÕ2 3
new
ÕÕ4 7 
ReadOnlyCollection
ÕÕ8 J
<
ÕÕJ K
Vector2
ÕÕK R
>
ÕÕR S
(
ÕÕS T
m_Textures3
ÕÕT _
.
ÕÕ_ `
Cast
ÕÕ` d
<
ÕÕd e
Vector2
ÕÕe l
>
ÕÕl m
(
ÕÕm n
)
ÕÕn o
.
ÕÕo p
ToList
ÕÕp v
(
ÕÕv w
)
ÕÕw x
)
ÕÕx y
;
ÕÕy z
return
œœ 
null
œœ 
;
œœ 
}
–– 	
public
ÿÿ 
void
ÿÿ 
SetUVs
ÿÿ 
(
ÿÿ 
int
ÿÿ 
channel
ÿÿ &
,
ÿÿ& '
List
ÿÿ( ,
<
ÿÿ, -
Vector4
ÿÿ- 4
>
ÿÿ4 5
uvs
ÿÿ6 9
)
ÿÿ9 :
{
ŸŸ 	
switch
⁄⁄ 
(
⁄⁄ 
channel
⁄⁄ 
)
⁄⁄ 
{
€€ 
case
‹‹ 
$num
‹‹ 
:
‹‹ 
m_Textures0
›› 
=
››  !
uvs
››" %
!=
››& (
null
››) -
?
››. /
uvs
››0 3
.
››3 4
Select
››4 :
(
››: ;
x
››; <
=>
››= ?
(
››@ A
Vector2
››A H
)
››H I
x
››I J
)
››J K
.
››K L
ToArray
››L S
(
››S T
)
››T U
:
››V W
null
››X \
;
››\ ]
break
ﬁﬁ 
;
ﬁﬁ 
case
‡‡ 
$num
‡‡ 
:
‡‡ 
mesh
·· 
.
·· 
uv2
·· 
=
·· 
uvs
·· "
!=
··# %
null
··& *
?
··+ ,
uvs
··- 0
.
··0 1
Select
··1 7
(
··7 8
x
··8 9
=>
··: <
(
··= >
Vector2
··> E
)
··E F
x
··F G
)
··G H
.
··H I
ToArray
··I P
(
··P Q
)
··Q R
:
··S T
null
··U Y
;
··Y Z
break
‚‚ 
;
‚‚ 
case
‰‰ 
$num
‰‰ 
:
‰‰ 
m_Textures2
ÂÂ 
=
ÂÂ  !
uvs
ÂÂ" %
!=
ÂÂ& (
null
ÂÂ) -
?
ÂÂ. /
new
ÂÂ0 3
List
ÂÂ4 8
<
ÂÂ8 9
Vector4
ÂÂ9 @
>
ÂÂ@ A
(
ÂÂA B
uvs
ÂÂB E
)
ÂÂE F
:
ÂÂG H
null
ÂÂI M
;
ÂÂM N
break
ÊÊ 
;
ÊÊ 
case
ËË 
$num
ËË 
:
ËË 
m_Textures3
ÈÈ 
=
ÈÈ  !
uvs
ÈÈ" %
!=
ÈÈ& (
null
ÈÈ) -
?
ÈÈ. /
new
ÈÈ0 3
List
ÈÈ4 8
<
ÈÈ8 9
Vector4
ÈÈ9 @
>
ÈÈ@ A
(
ÈÈA B
uvs
ÈÈB E
)
ÈÈE F
:
ÈÈG H
null
ÈÈI M
;
ÈÈM N
break
ÍÍ 
;
ÍÍ 
}
ÎÎ 
}
ÏÏ 	
public
ÒÒ 
int
ÒÒ 
	faceCount
ÒÒ 
{
ÚÚ 	
get
ÛÛ 
{
ÛÛ 
return
ÛÛ 
m_Faces
ÛÛ  
==
ÛÛ! #
null
ÛÛ$ (
?
ÛÛ) *
$num
ÛÛ+ ,
:
ÛÛ- .
m_Faces
ÛÛ/ 6
.
ÛÛ6 7
Length
ÛÛ7 =
;
ÛÛ= >
}
ÛÛ? @
}
ÙÙ 	
public
˘˘ 
int
˘˘ 
vertexCount
˘˘ 
{
˙˙ 	
get
˚˚ 
{
˚˚ 
return
˚˚ 
m_Positions
˚˚ $
==
˚˚% '
null
˚˚( ,
?
˚˚- .
$num
˚˚/ 0
:
˚˚1 2
m_Positions
˚˚3 >
.
˚˚> ?
Length
˚˚? E
;
˚˚E F
}
˚˚G H
}
¸¸ 	
public
ÅÅ 
int
ÅÅ 
	edgeCount
ÅÅ 
{
ÇÇ 	
get
ÉÉ 
{
ÑÑ 
int
ÖÖ 
count
ÖÖ 
=
ÖÖ 
$num
ÖÖ 
;
ÖÖ 
for
ÜÜ 
(
ÜÜ 
int
ÜÜ 
i
ÜÜ 
=
ÜÜ 
$num
ÜÜ 
,
ÜÜ 
c
ÜÜ  !
=
ÜÜ" #
	faceCount
ÜÜ$ -
;
ÜÜ- .
i
ÜÜ/ 0
<
ÜÜ1 2
c
ÜÜ3 4
;
ÜÜ4 5
i
ÜÜ6 7
++
ÜÜ7 9
)
ÜÜ9 :
count
áá 
+=
áá 
facesInternal
áá *
[
áá* +
i
áá+ ,
]
áá, -
.
áá- .
edgesInternal
áá. ;
.
áá; <
Length
áá< B
;
ááB C
return
àà 
count
àà 
;
àà 
}
ââ 
}
ää 	
public
èè 
int
èè 

indexCount
èè 
{
êê 	
get
ëë 
{
ëë 
return
ëë 
m_Faces
ëë  
==
ëë! #
null
ëë$ (
?
ëë) *
$num
ëë+ ,
:
ëë- .
m_Faces
ëë/ 6
.
ëë6 7
Sum
ëë7 :
(
ëë: ;
x
ëë; <
=>
ëë= ?
x
ëë@ A
.
ëëA B
indexesInternal
ëëB Q
.
ëëQ R
Length
ëëR X
)
ëëX Y
;
ëëY Z
}
ëë[ \
}
íí 	
public
óó 
int
óó 
triangleCount
óó  
{
òò 	
get
ôô 
{
ôô 
return
ôô 
m_Faces
ôô  
==
ôô! #
null
ôô$ (
?
ôô) *
$num
ôô+ ,
:
ôô- .
m_Faces
ôô/ 6
.
ôô6 7
Sum
ôô7 :
(
ôô: ;
x
ôô; <
=>
ôô= ?
x
ôô@ A
.
ôôA B
indexesInternal
ôôB Q
.
ôôQ R
Length
ôôR X
)
ôôX Y
/
ôôZ [
$num
ôô\ ]
;
ôô] ^
}
ôô_ `
}
öö 	
public
§§ 
static
§§ 
event
§§ 
Action
§§ "
<
§§" #
ProBuilderMesh
§§# 1
>
§§1 2!
meshWillBeDestroyed
§§3 F
;
§§F G
internal
©© 
static
©© 
event
©© 
Action
©© $
<
©©$ %
ProBuilderMesh
©©% 3
>
©©3 4&
componentWillBeDestroyed
©©5 M
;
©©M N
internal
ÆÆ 
static
ÆÆ 
event
ÆÆ 
Action
ÆÆ $
<
ÆÆ$ %
ProBuilderMesh
ÆÆ% 3
>
ÆÆ3 4#
componentHasBeenReset
ÆÆ5 J
;
ÆÆJ K
public
∂∂ 
static
∂∂ 
event
∂∂ 
Action
∂∂ "
<
∂∂" #
ProBuilderMesh
∂∂# 1
>
∂∂1 2%
elementSelectionChanged
∂∂3 J
;
∂∂J K
internal
∏∏ 
Mesh
∏∏ 
mesh
∏∏ 
{
ππ 	
get
∫∫ 
{
ªª 
if
ºº 
(
ºº 
m_Mesh
ºº 
==
ºº 
null
ºº "
&&
ºº# %
filter
ºº& ,
!=
ºº- /
null
ºº0 4
)
ºº4 5
m_Mesh
ΩΩ 
=
ΩΩ 
filter
ΩΩ #
.
ΩΩ# $

sharedMesh
ΩΩ$ .
;
ΩΩ. /
return
ææ 
m_Mesh
ææ 
;
ææ 
}
øø 
set
¡¡ 
{
¡¡ 
m_Mesh
¡¡ 
=
¡¡ 
value
¡¡  
;
¡¡  !
}
¡¡" #
}
¬¬ 	
internal
ƒƒ 
int
ƒƒ 
id
ƒƒ 
{
≈≈ 	
get
∆∆ 
{
∆∆ 
return
∆∆ 

gameObject
∆∆ #
.
∆∆# $
GetInstanceID
∆∆$ 1
(
∆∆1 2
)
∆∆2 3
;
∆∆3 4
}
∆∆5 6
}
«« 	
public
ÕÕ 
MeshSyncState
ÕÕ 
meshSyncState
ÕÕ *
{
ŒŒ 	
get
œœ 
{
–– 
if
—— 
(
—— 
mesh
—— 
==
—— 
null
——  
)
——  !
return
““ 
MeshSyncState
““ (
.
““( )
Null
““) -
;
““- .
int
‘‘ 
meshNo
‘‘ 
;
‘‘ 
int
÷÷ 
.
÷÷ 
TryParse
÷÷ 
(
÷÷ 
mesh
÷÷ !
.
÷÷! "
name
÷÷" &
.
÷÷& '
Replace
÷÷' .
(
÷÷. /
$str
÷÷/ 8
,
÷÷8 9
$str
÷÷: <
)
÷÷< =
,
÷÷= >
out
÷÷? B
meshNo
÷÷C I
)
÷÷I J
;
÷÷J K
if
ÿÿ 
(
ÿÿ 
meshNo
ÿÿ 
!=
ÿÿ 
id
ÿÿ  
)
ÿÿ  !
return
ŸŸ 
MeshSyncState
ŸŸ (
.
ŸŸ( ) 
InstanceIDMismatch
ŸŸ) ;
;
ŸŸ; <
return
€€ 
mesh
€€ 
.
€€ 
uv2
€€ 
==
€€  "
null
€€# '
?
€€( )
MeshSyncState
€€* 7
.
€€7 8
Lightmap
€€8 @
:
€€A B
MeshSyncState
€€C P
.
€€P Q
InSync
€€Q W
;
€€W X
}
‹‹ 
}
›› 	
}
ﬁﬁ 
}ﬂﬂ ‰
íD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ColliderBehaviour.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ %
DisallowMultipleComponent 
] 
sealed 

class 
ColliderBehaviour "
:# $
EntityBehaviour% 4
{ 
public 
override 
void 

Initialize '
(' (
)( )
{ 	
var 
	collision 
= 

gameObject &
.& '
GetComponent' 3
<3 4
Collider4 <
>< =
(= >
)> ?
;? @
if 
( 
! 
	collision 
) 
	collision 
= 

gameObject &
.& '
AddComponent' 3
<3 4
MeshCollider4 @
>@ A
(A B
)B C
;C D
	collision 
. 
	isTrigger 
=  !
false" '
;' (
SetMaterial 
( 
BuiltinMaterials (
.( )
colliderMaterial) 9
)9 :
;: ;
var 
r 
= 
GetComponent  
<  !
Renderer! )
>) *
(* +
)+ ,
;, -
if 
( 
r 
!= 
null 
) 
r 
. 
	hideFlags 
= 
	HideFlags '
.' (
DontSaveInBuild( 7
;7 8
} 	
public 
override 
void 
OnEnterPlayMode ,
(, -
)- .
{ 	
var 
r 
= 
GetComponent  
<  !
Renderer! )
>) *
(* +
)+ ,
;, -
if 
( 
r 
!= 
null 
) 
r 
. 
enabled 
= 
false !
;! "
}   	
public"" 
override"" 
void"" 
OnSceneLoaded"" *
(""* +
Scene""+ 0
scene""1 6
,""6 7
LoadSceneMode""8 E
mode""F J
)""J K
{## 	
var$$ 
r$$ 
=$$ 
GetComponent$$  
<$$  !
Renderer$$! )
>$$) *
($$* +
)$$+ ,
;$$, -
if&& 
(&& 
r&& 
!=&& 
null&& 
)&& 
r'' 
.'' 
enabled'' 
='' 
false'' !
;''! "
}(( 	
})) 
}** ®ˆ
ãD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Projection.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

static 
class 

Projection "
{ 
public 
static 
Vector2 
[ 
] 
PlanarProject  -
(- .
IList. 3
<3 4
Vector34 ;
>; <
	positions= F
,F G
IListH M
<M N
intN Q
>Q R
indexesS Z
=[ \
null] a
)a b
{ 	
return 
PlanarProject  
(  !
	positions! *
,* +
indexes, 3
,3 4
FindBestPlane5 B
(B C
	positionsC L
,L M
indexesN U
)U V
.V W
normalW ]
)] ^
;^ _
} 	
public"" 
static"" 
Vector2"" 
["" 
]"" 
PlanarProject""  -
(""- .
IList"". 3
<""3 4
Vector3""4 ;
>""; <
	positions""= F
,""F G
IList""H M
<""M N
int""N Q
>""Q R
indexes""S Z
,""Z [
Vector3""\ c
	direction""d m
)""m n
{## 	
List$$ 
<$$ 
Vector2$$ 
>$$ 
results$$ !
=$$" #
new$$$ '
List$$( ,
<$$, -
Vector2$$- 4
>$$4 5
($$5 6
indexes$$6 =
!=$$> @
null$$A E
?$$F G
indexes$$H O
.$$O P
Count$$P U
:$$V W
	positions$$X a
.$$a b
Count$$b g
)$$g h
;$$h i
PlanarProject%% 
(%% 
	positions%% #
,%%# $
indexes%%% ,
,%%, -
	direction%%. 7
,%%7 8
results%%9 @
)%%@ A
;%%A B
return&& 
results&& 
.&& 
ToArray&& "
(&&" #
)&&# $
;&&$ %
}'' 	
internal)) 
static)) 
void)) 
PlanarProject)) *
())* +
IList))+ 0
<))0 1
Vector3))1 8
>))8 9
	positions)): C
,))C D
IList))E J
<))J K
int))K N
>))N O
indexes))P W
,))W X
Vector3))Y `
	direction))a j
,))j k
List))l p
<))p q
Vector2))q x
>))x y
results	))z Å
)
))Å Ç
{** 	
if++ 
(++ 
	positions++ 
==++ 
null++  
)++  !
throw,, 
new,, !
ArgumentNullException,, /
(,,/ 0
$str,,0 ;
),,; <
;,,< =
if.. 
(.. 
results.. 
==.. 
null.. 
).. 
throw// 
new// !
ArgumentNullException// /
(/// 0
$str//0 9
)//9 :
;//: ;
var11 
nrm11 
=11 
	direction11 
;11  
var22 
axis22 
=22 "
VectorToProjectionAxis22 -
(22- .
nrm22. 1
)221 2
;222 3
var33 
prj33 
=33 
GetTangentToAxis33 &
(33& '
axis33' +
)33+ ,
;33, -
var44 
len44 
=44 
indexes44 
==44  
null44! %
?44& '
	positions44( 1
.441 2
Count442 7
:448 9
indexes44: A
.44A B
Count44B G
;44G H
results55 
.55 
Clear55 
(55 
)55 
;55 
var77 
u77 
=77 
Vector377 
.77 
Cross77 !
(77! "
nrm77" %
,77% &
prj77' *
)77* +
;77+ ,
var88 
v88 
=88 
Vector388 
.88 
Cross88 !
(88! "
u88" #
,88# $
nrm88% (
)88( )
;88) *
u:: 
.:: 
	Normalize:: 
(:: 
):: 
;:: 
v;; 
.;; 
	Normalize;; 
(;; 
);; 
;;; 
if== 
(== 
indexes== 
!=== 
null== 
)==  
{>> 
for?? 
(?? 
int?? 
i?? 
=?? 
$num?? 
,?? 
ic??  "
=??# $
len??% (
;??( )
i??* +
<??, -
ic??. 0
;??0 1
++??2 4
i??4 5
)??5 6
results@@ 
.@@ 
Add@@ 
(@@  
new@@  #
Vector2@@$ +
(@@+ ,
Vector3@@, 3
.@@3 4
Dot@@4 7
(@@7 8
u@@8 9
,@@9 :
	positions@@; D
[@@D E
indexes@@E L
[@@L M
i@@M N
]@@N O
]@@O P
)@@P Q
,@@Q R
Vector3@@S Z
.@@Z [
Dot@@[ ^
(@@^ _
v@@_ `
,@@` a
	positions@@b k
[@@k l
indexes@@l s
[@@s t
i@@t u
]@@u v
]@@v w
)@@w x
)@@x y
)@@y z
;@@z {
}AA 
elseBB 
{CC 
forDD 
(DD 
intDD 
iDD 
=DD 
$numDD 
,DD 
icDD  "
=DD# $
lenDD% (
;DD( )
iDD* +
<DD, -
icDD. 0
;DD0 1
++DD2 4
iDD4 5
)DD5 6
resultsEE 
.EE 
AddEE 
(EE  
newEE  #
Vector2EE$ +
(EE+ ,
Vector3EE, 3
.EE3 4
DotEE4 7
(EE7 8
uEE8 9
,EE9 :
	positionsEE; D
[EED E
iEEE F
]EEF G
)EEG H
,EEH I
Vector3EEJ Q
.EEQ R
DotEER U
(EEU V
vEEV W
,EEW X
	positionsEEY b
[EEb c
iEEc d
]EEd e
)EEe f
)EEf g
)EEg h
;EEh i
}FF 
}GG 	
internalII 
staticII 
voidII 
PlanarProjectII *
(II* +
ProBuilderMeshII+ 9
meshII: >
,II> ?
intII@ C
textureGroupIID P
,IIP Q
AutoUnwrapSettingsIIR d
unwrapSettingsIIe s
)IIs t
{JJ 	
varKK 

worldSpaceKK 
=KK 
unwrapSettingsKK +
.KK+ ,
useWorldSpaceKK, 9
;KK9 :
varLL 
trsLL 
=LL 
(LL 
	TransformLL  
)LL  !
nullLL! %
;LL% &
varMM 
facesMM 
=MM 
meshMM 
.MM 
facesInternalMM *
;MM* +
varPP 
projectionDirectionPP #
=PP$ %
Vector3PP& -
.PP- .
zeroPP. 2
;PP2 3
forRR 
(RR 
intRR 
fRR 
=RR 
$numRR 
,RR 
fcRR 
=RR  
facesRR! &
.RR& '
LengthRR' -
;RR- .
fRR/ 0
<RR1 2
fcRR3 5
;RR5 6
++RR7 9
fRR9 :
)RR: ;
{SS 
ifTT 
(TT 
facesTT 
[TT 
fTT 
]TT 
.TT 
textureGroupTT )
!=TT* ,
textureGroupTT- 9
)TT9 :
continueUU 
;UU 
varWW 
nrmWW 
=WW 
MathWW 
.WW 
NormalWW %
(WW% &
meshWW& *
,WW* +
facesWW, 1
[WW1 2
fWW2 3
]WW3 4
)WW4 5
;WW5 6
projectionDirectionXX #
+=XX$ &
nrmXX' *
;XX* +
}YY 
if[[ 
([[ 

worldSpace[[ 
)[[ 
{\\ 
trs]] 
=]] 
mesh]] 
.]] 
	transform]] $
;]]$ %
projectionDirection^^ #
=^^$ %
trs^^& )
.^^) *
TransformDirection^^* <
(^^< =
projectionDirection^^= P
)^^P Q
;^^Q R
}__ 
varaa 
axisaa 
=aa "
VectorToProjectionAxisaa -
(aa- .
projectionDirectionaa. A
)aaA B
;aaB C
varbb 
prjbb 
=bb 
GetTangentToAxisbb &
(bb& '
axisbb' +
)bb+ ,
;bb, -
vardd 
udd 
=dd 
Vector3dd 
.dd 
Crossdd !
(dd! "
projectionDirectiondd" 5
,dd5 6
prjdd7 :
)dd: ;
;dd; <
varee 
vee 
=ee 
Vector3ee 
.ee 
Crossee !
(ee! "
uee" #
,ee# $
projectionDirectionee% 8
)ee8 9
;ee9 :
ugg 
.gg 
	Normalizegg 
(gg 
)gg 
;gg 
vhh 
.hh 
	Normalizehh 
(hh 
)hh 
;hh 
varjj 
	positionsjj 
=jj 
meshjj  
.jj  !
positionsInternaljj! 2
;jj2 3
varkk 
textureskk 
=kk 
meshkk 
.kk  
texturesInternalkk  0
;kk0 1
formm 
(mm 
intmm 
fmm 
=mm 
$nummm 
,mm 
fcmm 
=mm  
facesmm! &
.mm& '
Lengthmm' -
;mm- .
fmm/ 0
<mm1 2
fcmm3 5
;mm5 6
++mm7 9
fmm9 :
)mm: ;
{nn 
ifoo 
(oo 
facesoo 
[oo 
foo 
]oo 
.oo 
textureGroupoo )
!=oo* ,
textureGroupoo- 9
)oo9 :
continuepp 
;pp 
varrr 
indexesrr 
=rr 
facesrr #
[rr# $
frr$ %
]rr% &
.rr& '#
distinctIndexesInternalrr' >
;rr> ?
fortt 
(tt 
inttt 
itt 
=tt 
$numtt 
,tt 
ictt  "
=tt# $
indexestt% ,
.tt, -
Lengthtt- 3
;tt3 4
itt5 6
<tt7 8
ictt9 ;
;tt; <
++tt= ?
itt? @
)tt@ A
{uu 
varvv 
pvv 
=vv 

worldSpacevv &
?vv' (
trsvv) ,
.vv, -
TransformPointvv- ;
(vv; <
	positionsvv< E
[vvE F
indexesvvF M
[vvM N
ivvN O
]vvO P
]vvP Q
)vvQ R
:vvS T
	positionsvvU ^
[vv^ _
indexesvv_ f
[vvf g
ivvg h
]vvh i
]vvi j
;vvj k
texturesxx 
[xx 
indexesxx $
[xx$ %
ixx% &
]xx& '
]xx' (
.xx( )
xxx) *
=xx+ ,
Vector3xx- 4
.xx4 5
Dotxx5 8
(xx8 9
uxx9 :
,xx: ;
pxx< =
)xx= >
;xx> ?
texturesyy 
[yy 
indexesyy $
[yy$ %
iyy% &
]yy& '
]yy' (
.yy( )
yyy) *
=yy+ ,
Vector3yy- 4
.yy4 5
Dotyy5 8
(yy8 9
vyy9 :
,yy: ;
pyy< =
)yy= >
;yy> ?
}zz 
}{{ 
}|| 	
internal~~ 
static~~ 
void~~ 
PlanarProject~~ *
(~~* +
ProBuilderMesh~~+ 9
mesh~~: >
,~~> ?
Face~~@ D
face~~E I
,~~I J
Vector3~~K R

projection~~S ]
=~~^ _
default~~` g
)~~g h
{ 	
var
ÄÄ 
nrm
ÄÄ 
=
ÄÄ 
Math
ÄÄ 
.
ÄÄ 
Normal
ÄÄ !
(
ÄÄ! "
mesh
ÄÄ" &
,
ÄÄ& '
face
ÄÄ( ,
)
ÄÄ, -
;
ÄÄ- .
var
ÅÅ 
trs
ÅÅ 
=
ÅÅ 
(
ÅÅ 
	Transform
ÅÅ  
)
ÅÅ  !
null
ÅÅ! %
;
ÅÅ% &
var
ÇÇ 

worldSpace
ÇÇ 
=
ÇÇ 
face
ÇÇ !
.
ÇÇ! "
uv
ÇÇ" $
.
ÇÇ$ %
useWorldSpace
ÇÇ% 2
;
ÇÇ2 3
if
ÑÑ 
(
ÑÑ 

worldSpace
ÑÑ 
)
ÑÑ 
{
ÖÖ 
trs
ÜÜ 
=
ÜÜ 
mesh
ÜÜ 
.
ÜÜ 
	transform
ÜÜ $
;
ÜÜ$ %
nrm
áá 
=
áá 
trs
áá 
.
áá  
TransformDirection
áá ,
(
áá, -
nrm
áá- 0
)
áá0 1
;
áá1 2
}
àà 
Vector3
ää 
prj
ää 
=
ää 

projection
ää $
;
ää$ %
if
ãã 
(
ãã 
prj
ãã 
==
ãã 
Vector3
ãã 
.
ãã 
zero
ãã #
)
ãã# $
{
åå 
var
çç 
axis
çç 
=
çç $
VectorToProjectionAxis
çç 1
(
çç1 2
nrm
çç2 5
)
çç5 6
;
çç6 7
prj
éé 
=
éé 
GetTangentToAxis
éé &
(
éé& '
axis
éé' +
)
éé+ ,
;
éé, -
}
èè 
var
ëë 
uAxis
ëë 
=
ëë 
Vector3
ëë 
.
ëë  
Cross
ëë  %
(
ëë% &
nrm
ëë& )
,
ëë) *
prj
ëë+ .
)
ëë. /
;
ëë/ 0
var
íí 
vAxis
íí 
=
íí 
Vector3
íí 
.
íí  
Cross
íí  %
(
íí% &
uAxis
íí& +
,
íí+ ,
nrm
íí- 0
)
íí0 1
;
íí1 2
uAxis
îî 
.
îî 
	Normalize
îî 
(
îî 
)
îî 
;
îî 
vAxis
ïï 
.
ïï 
	Normalize
ïï 
(
ïï 
)
ïï 
;
ïï 
var
óó 
	positions
óó 
=
óó 
mesh
óó  
.
óó  !
positionsInternal
óó! 2
;
óó2 3
var
òò 
textures
òò 
=
òò 
mesh
òò 
.
òò  
texturesInternal
òò  0
;
òò0 1
int
öö 
[
öö 
]
öö 
indexes
öö 
=
öö 
face
öö  
.
öö  !%
distinctIndexesInternal
öö! 8
;
öö8 9
for
úú 
(
úú 
int
úú 
i
úú 
=
úú 
$num
úú 
,
úú 
ic
úú 
=
úú  
indexes
úú! (
.
úú( )
Length
úú) /
;
úú/ 0
i
úú1 2
<
úú3 4
ic
úú5 7
;
úú7 8
++
úú9 ;
i
úú; <
)
úú< =
{
ùù 
var
ûû 
p
ûû 
=
ûû 

worldSpace
ûû "
?
ûû# $
trs
ûû% (
.
ûû( )
TransformPoint
ûû) 7
(
ûû7 8
	positions
ûû8 A
[
ûûA B
indexes
ûûB I
[
ûûI J
i
ûûJ K
]
ûûK L
]
ûûL M
)
ûûM N
:
ûûO P
	positions
ûûQ Z
[
ûûZ [
indexes
ûû[ b
[
ûûb c
i
ûûc d
]
ûûd e
]
ûûe f
;
ûûf g
textures
†† 
[
†† 
indexes
††  
[
††  !
i
††! "
]
††" #
]
††# $
.
††$ %
x
††% &
=
††' (
Vector3
††) 0
.
††0 1
Dot
††1 4
(
††4 5
uAxis
††5 :
,
††: ;
p
††< =
)
††= >
;
††> ?
textures
°° 
[
°° 
indexes
°°  
[
°°  !
i
°°! "
]
°°" #
]
°°# $
.
°°$ %
y
°°% &
=
°°' (
Vector3
°°) 0
.
°°0 1
Dot
°°1 4
(
°°4 5
vAxis
°°5 :
,
°°: ;
p
°°< =
)
°°= >
;
°°> ?
}
¢¢ 
}
££ 	
internal
•• 
static
•• 
Vector2
•• 
[
••  
]
••  !
SphericalProject
••" 2
(
••2 3
IList
••3 8
<
••8 9
Vector3
••9 @
>
••@ A
vertices
••B J
,
••J K
IList
••L Q
<
••Q R
int
••R U
>
••U V
indexes
••W ^
=
••_ `
null
••a e
)
••e f
{
¶¶ 	
int
ßß 
len
ßß 
=
ßß 
indexes
ßß 
==
ßß  
null
ßß! %
?
ßß& '
vertices
ßß( 0
.
ßß0 1
Count
ßß1 6
:
ßß7 8
indexes
ßß9 @
.
ßß@ A
Count
ßßA F
;
ßßF G
Vector2
®® 
[
®® 
]
®® 
uv
®® 
=
®® 
new
®® 
Vector2
®® &
[
®®& '
len
®®' *
]
®®* +
;
®®+ ,
Vector3
©© 
cen
©© 
=
©© 
Math
©© 
.
©© 
Average
©© &
(
©©& '
vertices
©©' /
,
©©/ 0
indexes
©©1 8
)
©©8 9
;
©©9 :
for
´´ 
(
´´ 
int
´´ 
i
´´ 
=
´´ 
$num
´´ 
;
´´ 
i
´´ 
<
´´ 
len
´´  #
;
´´# $
i
´´% &
++
´´& (
)
´´( )
{
¨¨ 
int
≠≠ 
indx
≠≠ 
=
≠≠ 
indexes
≠≠ "
==
≠≠# %
null
≠≠& *
?
≠≠+ ,
i
≠≠- .
:
≠≠/ 0
indexes
≠≠1 8
[
≠≠8 9
i
≠≠9 :
]
≠≠: ;
;
≠≠; <
Vector3
ÆÆ 
p
ÆÆ 
=
ÆÆ 
(
ÆÆ 
vertices
ÆÆ %
[
ÆÆ% &
indx
ÆÆ& *
]
ÆÆ* +
-
ÆÆ, -
cen
ÆÆ. 1
)
ÆÆ1 2
;
ÆÆ2 3
p
ØØ 
.
ØØ 
	Normalize
ØØ 
(
ØØ 
)
ØØ 
;
ØØ 
uv
∞∞ 
[
∞∞ 
i
∞∞ 
]
∞∞ 
.
∞∞ 
x
∞∞ 
=
∞∞ 
$num
∞∞ 
+
∞∞ 
(
∞∞  !
Mathf
∞∞! &
.
∞∞& '
Atan2
∞∞' ,
(
∞∞, -
p
∞∞- .
.
∞∞. /
z
∞∞/ 0
,
∞∞0 1
p
∞∞2 3
.
∞∞3 4
x
∞∞4 5
)
∞∞5 6
/
∞∞7 8
(
∞∞9 :
$num
∞∞: <
*
∞∞= >
Mathf
∞∞? D
.
∞∞D E
PI
∞∞E G
)
∞∞G H
)
∞∞H I
;
∞∞I J
uv
±± 
[
±± 
i
±± 
]
±± 
.
±± 
y
±± 
=
±± 
$num
±± 
-
±± 
(
±±  !
Mathf
±±! &
.
±±& '
Asin
±±' +
(
±±+ ,
p
±±, -
.
±±- .
y
±±. /
)
±±/ 0
/
±±1 2
Mathf
±±3 8
.
±±8 9
PI
±±9 ;
)
±±; <
;
±±< =
}
≤≤ 
return
¥¥ 
uv
¥¥ 
;
¥¥ 
}
µµ 	
internal
ΩΩ 
static
ΩΩ 
IList
ΩΩ 
<
ΩΩ 
Vector2
ΩΩ %
>
ΩΩ% &
Sort
ΩΩ' +
(
ΩΩ+ ,
IList
ΩΩ, 1
<
ΩΩ1 2
Vector2
ΩΩ2 9
>
ΩΩ9 :
verts
ΩΩ; @
,
ΩΩ@ A

SortMethod
ΩΩB L
method
ΩΩM S
=
ΩΩT U

SortMethod
ΩΩV `
.
ΩΩ` a
CounterClockwise
ΩΩa q
)
ΩΩq r
{
ææ 	
Vector2
øø 
cen
øø 
=
øø 
Math
øø 
.
øø 
Average
øø &
(
øø& '
verts
øø' ,
)
øø, -
;
øø- .
Vector2
¿¿ 
up
¿¿ 
=
¿¿ 
Vector2
¿¿  
.
¿¿  !
up
¿¿! #
;
¿¿# $
int
¡¡ 
count
¡¡ 
=
¡¡ 
verts
¡¡ 
.
¡¡ 
Count
¡¡ #
;
¡¡# $
List
√√ 
<
√√ 
SimpleTuple
√√ 
<
√√ 
float
√√ "
,
√√" #
Vector2
√√$ +
>
√√+ ,
>
√√, -
angles
√√. 4
=
√√5 6
new
√√7 :
List
√√; ?
<
√√? @
SimpleTuple
√√@ K
<
√√K L
float
√√L Q
,
√√Q R
Vector2
√√S Z
>
√√Z [
>
√√[ \
(
√√\ ]
count
√√] b
)
√√b c
;
√√c d
for
≈≈ 
(
≈≈ 
int
≈≈ 
i
≈≈ 
=
≈≈ 
$num
≈≈ 
;
≈≈ 
i
≈≈ 
<
≈≈ 
count
≈≈  %
;
≈≈% &
i
≈≈' (
++
≈≈( *
)
≈≈* +
angles
∆∆ 
.
∆∆ 
Add
∆∆ 
(
∆∆ 
new
∆∆ 
SimpleTuple
∆∆ *
<
∆∆* +
float
∆∆+ 0
,
∆∆0 1
Vector2
∆∆2 9
>
∆∆9 :
(
∆∆: ;
Math
∆∆; ?
.
∆∆? @
SignedAngle
∆∆@ K
(
∆∆K L
up
∆∆L N
,
∆∆N O
verts
∆∆P U
[
∆∆U V
i
∆∆V W
]
∆∆W X
-
∆∆Y Z
cen
∆∆[ ^
)
∆∆^ _
,
∆∆_ `
verts
∆∆a f
[
∆∆f g
i
∆∆g h
]
∆∆h i
)
∆∆i j
)
∆∆j k
;
∆∆k l
angles
»» 
.
»» 
Sort
»» 
(
»» 
(
»» 
a
»» 
,
»» 
b
»» 
)
»» 
=>
»» !
{
»»" #
return
»»$ *
a
»»+ ,
.
»», -
item1
»»- 2
<
»»3 4
b
»»5 6
.
»»6 7
item1
»»7 <
?
»»= >
-
»»? @
$num
»»@ A
:
»»B C
$num
»»D E
;
»»E F
}
»»G H
)
»»H I
;
»»I J
IList
   
<
   
Vector2
   
>
   
values
   !
=
  " #
angles
  $ *
.
  * +
Select
  + 1
(
  1 2
x
  2 3
=>
  4 6
x
  7 8
.
  8 9
item2
  9 >
)
  > ?
.
  ? @
ToList
  @ F
(
  F G
)
  G H
;
  H I
if
ÃÃ 
(
ÃÃ 
method
ÃÃ 
==
ÃÃ 

SortMethod
ÃÃ $
.
ÃÃ$ %
	Clockwise
ÃÃ% .
)
ÃÃ. /
values
ÕÕ 
=
ÕÕ 
values
ÕÕ 
.
ÕÕ  
Reverse
ÕÕ  '
(
ÕÕ' (
)
ÕÕ( )
.
ÕÕ) *
ToList
ÕÕ* 0
(
ÕÕ0 1
)
ÕÕ1 2
;
ÕÕ2 3
return
œœ 
values
œœ 
;
œœ 
}
–– 	
internal
““ 
static
““ 
Vector3
““ 
GetTangentToAxis
““  0
(
““0 1
ProjectionAxis
““1 ?
axis
““@ D
)
““D E
{
”” 	
switch
÷÷ 
(
÷÷ 
axis
÷÷ 
)
÷÷ 
{
◊◊ 
case
ÿÿ 
ProjectionAxis
ÿÿ #
.
ÿÿ# $
X
ÿÿ$ %
:
ÿÿ% &
case
ŸŸ 
ProjectionAxis
ŸŸ #
.
ŸŸ# $
	XNegative
ŸŸ$ -
:
ŸŸ- .
return
⁄⁄ 
Vector3
⁄⁄ "
.
⁄⁄" #
up
⁄⁄# %
;
⁄⁄% &
case
‹‹ 
ProjectionAxis
‹‹ #
.
‹‹# $
Y
‹‹$ %
:
‹‹% &
case
›› 
ProjectionAxis
›› #
.
››# $
	YNegative
››$ -
:
››- .
return
ﬁﬁ 
Vector3
ﬁﬁ "
.
ﬁﬁ" #
forward
ﬁﬁ# *
;
ﬁﬁ* +
case
‡‡ 
ProjectionAxis
‡‡ #
.
‡‡# $
Z
‡‡$ %
:
‡‡% &
case
·· 
ProjectionAxis
·· #
.
··# $
	ZNegative
··$ -
:
··- .
return
‚‚ 
Vector3
‚‚ "
.
‚‚" #
up
‚‚# %
;
‚‚% &
default
‰‰ 
:
‰‰ 
return
ÂÂ 
Vector3
ÂÂ "
.
ÂÂ" #
up
ÂÂ# %
;
ÂÂ% &
}
ÊÊ 
}
ÁÁ 	
internal
ÓÓ 
static
ÓÓ 
Vector3
ÓÓ $
ProjectionAxisToVector
ÓÓ  6
(
ÓÓ6 7
ProjectionAxis
ÓÓ7 E
axis
ÓÓF J
)
ÓÓJ K
{
ÔÔ 	
switch
 
(
 
axis
 
)
 
{
ÒÒ 
case
ÚÚ 
ProjectionAxis
ÚÚ #
.
ÚÚ# $
X
ÚÚ$ %
:
ÚÚ% &
return
ÛÛ 
Vector3
ÛÛ "
.
ÛÛ" #
right
ÛÛ# (
;
ÛÛ( )
case
ıı 
ProjectionAxis
ıı #
.
ıı# $
Y
ıı$ %
:
ıı% &
return
ˆˆ 
Vector3
ˆˆ "
.
ˆˆ" #
up
ˆˆ# %
;
ˆˆ% &
case
¯¯ 
ProjectionAxis
¯¯ #
.
¯¯# $
Z
¯¯$ %
:
¯¯% &
return
˘˘ 
Vector3
˘˘ "
.
˘˘" #
forward
˘˘# *
;
˘˘* +
case
˚˚ 
ProjectionAxis
˚˚ #
.
˚˚# $
	XNegative
˚˚$ -
:
˚˚- .
return
¸¸ 
-
¸¸ 
Vector3
¸¸ #
.
¸¸# $
right
¸¸$ )
;
¸¸) *
case
˛˛ 
ProjectionAxis
˛˛ #
.
˛˛# $
	YNegative
˛˛$ -
:
˛˛- .
return
ˇˇ 
-
ˇˇ 
Vector3
ˇˇ #
.
ˇˇ# $
up
ˇˇ$ &
;
ˇˇ& '
case
ÅÅ 
ProjectionAxis
ÅÅ #
.
ÅÅ# $
	ZNegative
ÅÅ$ -
:
ÅÅ- .
return
ÇÇ 
-
ÇÇ 
Vector3
ÇÇ #
.
ÇÇ# $
forward
ÇÇ$ +
;
ÇÇ+ ,
default
ÑÑ 
:
ÑÑ 
return
ÖÖ 
Vector3
ÖÖ "
.
ÖÖ" #
zero
ÖÖ# '
;
ÖÖ' (
}
ÜÜ 
}
áá 	
internal
éé 
static
éé 
ProjectionAxis
éé &$
VectorToProjectionAxis
éé' =
(
éé= >
Vector3
éé> E
	direction
ééF O
)
ééO P
{
èè 	
float
êê 
x
êê 
=
êê 
System
êê 
.
êê 
Math
êê !
.
êê! "
Abs
êê" %
(
êê% &
	direction
êê& /
.
êê/ 0
x
êê0 1
)
êê1 2
;
êê2 3
float
ëë 
y
ëë 
=
ëë 
System
ëë 
.
ëë 
Math
ëë !
.
ëë! "
Abs
ëë" %
(
ëë% &
	direction
ëë& /
.
ëë/ 0
y
ëë0 1
)
ëë1 2
;
ëë2 3
float
íí 
z
íí 
=
íí 
System
íí 
.
íí 
Math
íí !
.
íí! "
Abs
íí" %
(
íí% &
	direction
íí& /
.
íí/ 0
z
íí0 1
)
íí1 2
;
íí2 3
if
öö 
(
öö 
!
öö 
Math
öö 
.
öö 
Approx
öö 
(
öö 
x
öö 
,
öö 
y
öö  !
)
öö! "
&&
öö# %
x
öö& '
>
öö( )
y
öö* +
&&
öö, .
!
öö/ 0
Math
öö0 4
.
öö4 5
Approx
öö5 ;
(
öö; <
x
öö< =
,
öö= >
z
öö? @
)
öö@ A
&&
ööB D
x
ööE F
>
ööG H
z
ööI J
)
ööJ K
return
õõ 
	direction
õõ  
.
õõ  !
x
õõ! "
>
õõ# $
$num
õõ% &
?
õõ' (
ProjectionAxis
õõ) 7
.
õõ7 8
X
õõ8 9
:
õõ: ;
ProjectionAxis
õõ< J
.
õõJ K
	XNegative
õõK T
;
õõT U
if
ùù 
(
ùù 
!
ùù 
Math
ùù 
.
ùù 
Approx
ùù 
(
ùù 
y
ùù 
,
ùù 
z
ùù  !
)
ùù! "
&&
ùù# %
y
ùù& '
>
ùù( )
z
ùù* +
)
ùù+ ,
return
ûû 
	direction
ûû  
.
ûû  !
y
ûû! "
>
ûû# $
$num
ûû% &
?
ûû' (
ProjectionAxis
ûû) 7
.
ûû7 8
Y
ûû8 9
:
ûû: ;
ProjectionAxis
ûû< J
.
ûûJ K
	YNegative
ûûK T
;
ûûT U
return
†† 
	direction
†† 
.
†† 
z
†† 
>
††  
$num
††! "
?
††# $
ProjectionAxis
††% 3
.
††3 4
Z
††4 5
:
††6 7
ProjectionAxis
††8 F
.
††F G
	ZNegative
††G P
;
††P Q
}
°° 	
public
™™ 
static
™™ 
Plane
™™ 
FindBestPlane
™™ )
(
™™) *
IList
™™* /
<
™™/ 0
Vector3
™™0 7
>
™™7 8
points
™™9 ?
,
™™? @
IList
™™A F
<
™™F G
int
™™G J
>
™™J K
indexes
™™L S
=
™™T U
null
™™V Z
)
™™Z [
{
´´ 	
float
¨¨ 
xx
¨¨ 
=
¨¨ 
$num
¨¨ 
,
¨¨ 
xy
¨¨ 
=
¨¨  !
$num
¨¨" $
,
¨¨$ %
xz
¨¨& (
=
¨¨) *
$num
¨¨+ -
,
¨¨- .
yy
≠≠ 
=
≠≠ 
$num
≠≠ 
,
≠≠ 
yz
≠≠ 
=
≠≠  !
$num
≠≠" $
,
≠≠$ %
zz
≠≠& (
=
≠≠) *
$num
≠≠+ -
;
≠≠- .
if
ØØ 
(
ØØ 
points
ØØ 
==
ØØ 
null
ØØ 
)
ØØ 
throw
∞∞ 
new
∞∞ 
System
∞∞  
.
∞∞  !#
ArgumentNullException
∞∞! 6
(
∞∞6 7
$str
∞∞7 ?
)
∞∞? @
;
∞∞@ A
bool
≤≤ 
ind
≤≤ 
=
≤≤ 
indexes
≤≤ 
!=
≤≤ !
null
≤≤" &
&&
≤≤' )
indexes
≤≤* 1
.
≤≤1 2
Count
≤≤2 7
>
≤≤8 9
$num
≤≤: ;
;
≤≤; <
int
≥≥ 
len
≥≥ 
=
≥≥ 
ind
≥≥ 
?
≥≥ 
indexes
≥≥ #
.
≥≥# $
Count
≥≥$ )
:
≥≥* +
points
≥≥, 2
.
≥≥2 3
Count
≥≥3 8
;
≥≥8 9
Vector3
µµ 
c
µµ 
=
µµ 
Vector3
µµ 
.
µµ  
zero
µµ  $
,
µµ$ %
n
µµ& '
=
µµ( )
Vector3
µµ* 1
.
µµ1 2
zero
µµ2 6
;
µµ6 7
for
∑∑ 
(
∑∑ 
int
∑∑ 
i
∑∑ 
=
∑∑ 
$num
∑∑ 
;
∑∑ 
i
∑∑ 
<
∑∑ 
len
∑∑  #
;
∑∑# $
i
∑∑% &
++
∑∑& (
)
∑∑( )
{
∏∏ 
c
ππ 
.
ππ 
x
ππ 
+=
ππ 
points
ππ 
[
ππ 
ind
ππ !
?
ππ" #
indexes
ππ$ +
[
ππ+ ,
i
ππ, -
]
ππ- .
:
ππ/ 0
i
ππ1 2
]
ππ2 3
.
ππ3 4
x
ππ4 5
;
ππ5 6
c
∫∫ 
.
∫∫ 
y
∫∫ 
+=
∫∫ 
points
∫∫ 
[
∫∫ 
ind
∫∫ !
?
∫∫" #
indexes
∫∫$ +
[
∫∫+ ,
i
∫∫, -
]
∫∫- .
:
∫∫/ 0
i
∫∫1 2
]
∫∫2 3
.
∫∫3 4
y
∫∫4 5
;
∫∫5 6
c
ªª 
.
ªª 
z
ªª 
+=
ªª 
points
ªª 
[
ªª 
ind
ªª !
?
ªª" #
indexes
ªª$ +
[
ªª+ ,
i
ªª, -
]
ªª- .
:
ªª/ 0
i
ªª1 2
]
ªª2 3
.
ªª3 4
z
ªª4 5
;
ªª5 6
}
ºº 
c
ææ 
.
ææ 
x
ææ 
/=
ææ 
(
ææ 
float
ææ 
)
ææ 
len
ææ 
;
ææ 
c
øø 
.
øø 
y
øø 
/=
øø 
(
øø 
float
øø 
)
øø 
len
øø 
;
øø 
c
¿¿ 
.
¿¿ 
z
¿¿ 
/=
¿¿ 
(
¿¿ 
float
¿¿ 
)
¿¿ 
len
¿¿ 
;
¿¿ 
for
¬¬ 
(
¬¬ 
int
¬¬ 
i
¬¬ 
=
¬¬ 
$num
¬¬ 
;
¬¬ 
i
¬¬ 
<
¬¬ 
len
¬¬  #
;
¬¬# $
i
¬¬% &
++
¬¬& (
)
¬¬( )
{
√√ 
Vector3
ƒƒ 
r
ƒƒ 
=
ƒƒ 
points
ƒƒ "
[
ƒƒ" #
ind
ƒƒ# &
?
ƒƒ' (
indexes
ƒƒ) 0
[
ƒƒ0 1
i
ƒƒ1 2
]
ƒƒ2 3
:
ƒƒ4 5
i
ƒƒ6 7
]
ƒƒ7 8
-
ƒƒ9 :
c
ƒƒ; <
;
ƒƒ< =
xx
∆∆ 
+=
∆∆ 
r
∆∆ 
.
∆∆ 
x
∆∆ 
*
∆∆ 
r
∆∆ 
.
∆∆ 
x
∆∆ 
;
∆∆  
xy
«« 
+=
«« 
r
«« 
.
«« 
x
«« 
*
«« 
r
«« 
.
«« 
y
«« 
;
««  
xz
»» 
+=
»» 
r
»» 
.
»» 
x
»» 
*
»» 
r
»» 
.
»» 
z
»» 
;
»»  
yy
…… 
+=
…… 
r
…… 
.
…… 
y
…… 
*
…… 
r
…… 
.
…… 
y
…… 
;
……  
yz
   
+=
   
r
   
.
   
y
   
*
   
r
   
.
   
z
   
;
    
zz
ÀÀ 
+=
ÀÀ 
r
ÀÀ 
.
ÀÀ 
z
ÀÀ 
*
ÀÀ 
r
ÀÀ 
.
ÀÀ 
z
ÀÀ 
;
ÀÀ  
}
ÃÃ 
float
ŒŒ 
det_x
ŒŒ 
=
ŒŒ 
yy
ŒŒ 
*
ŒŒ 
zz
ŒŒ !
-
ŒŒ" #
yz
ŒŒ$ &
*
ŒŒ' (
yz
ŒŒ) +
;
ŒŒ+ ,
float
œœ 
det_y
œœ 
=
œœ 
xx
œœ 
*
œœ 
zz
œœ !
-
œœ" #
xz
œœ$ &
*
œœ' (
xz
œœ) +
;
œœ+ ,
float
–– 
det_z
–– 
=
–– 
xx
–– 
*
–– 
yy
–– !
-
––" #
xy
––$ &
*
––' (
xy
––) +
;
––+ ,
if
““ 
(
““ 
det_x
““ 
>
““ 
det_y
““ 
&&
““  
det_x
““! &
>
““' (
det_z
““) .
)
““. /
{
”” 
n
‘‘ 
.
‘‘ 
x
‘‘ 
=
‘‘ 
$num
‘‘ 
;
‘‘ 
n
’’ 
.
’’ 
y
’’ 
=
’’ 
(
’’ 
xz
’’ 
*
’’ 
yz
’’ 
-
’’  
xy
’’! #
*
’’$ %
zz
’’& (
)
’’( )
/
’’* +
det_x
’’, 1
;
’’1 2
n
÷÷ 
.
÷÷ 
z
÷÷ 
=
÷÷ 
(
÷÷ 
xy
÷÷ 
*
÷÷ 
yz
÷÷ 
-
÷÷  
xz
÷÷! #
*
÷÷$ %
yy
÷÷& (
)
÷÷( )
/
÷÷* +
det_x
÷÷, 1
;
÷÷1 2
}
◊◊ 
else
ÿÿ 
if
ÿÿ 
(
ÿÿ 
det_y
ÿÿ 
>
ÿÿ 
det_z
ÿÿ "
)
ÿÿ" #
{
ŸŸ 
n
⁄⁄ 
.
⁄⁄ 
x
⁄⁄ 
=
⁄⁄ 
(
⁄⁄ 
yz
⁄⁄ 
*
⁄⁄ 
xz
⁄⁄ 
-
⁄⁄  
xy
⁄⁄! #
*
⁄⁄$ %
zz
⁄⁄& (
)
⁄⁄( )
/
⁄⁄* +
det_y
⁄⁄, 1
;
⁄⁄1 2
n
€€ 
.
€€ 
y
€€ 
=
€€ 
$num
€€ 
;
€€ 
n
‹‹ 
.
‹‹ 
z
‹‹ 
=
‹‹ 
(
‹‹ 
xy
‹‹ 
*
‹‹ 
xz
‹‹ 
-
‹‹  
yz
‹‹! #
*
‹‹$ %
xx
‹‹& (
)
‹‹( )
/
‹‹* +
det_y
‹‹, 1
;
‹‹1 2
}
›› 
else
ﬁﬁ 
{
ﬂﬂ 
n
‡‡ 
.
‡‡ 
x
‡‡ 
=
‡‡ 
(
‡‡ 
yz
‡‡ 
*
‡‡ 
xy
‡‡ 
-
‡‡  
xz
‡‡! #
*
‡‡$ %
yy
‡‡& (
)
‡‡( )
/
‡‡* +
det_z
‡‡, 1
;
‡‡1 2
n
·· 
.
·· 
y
·· 
=
·· 
(
·· 
xz
·· 
*
·· 
xy
·· 
-
··  
yz
··! #
*
··$ %
xx
··& (
)
··( )
/
··* +
det_z
··, 1
;
··1 2
n
‚‚ 
.
‚‚ 
z
‚‚ 
=
‚‚ 
$num
‚‚ 
;
‚‚ 
}
„„ 
n
ÂÂ 
.
ÂÂ 
	Normalize
ÂÂ 
(
ÂÂ 
)
ÂÂ 
;
ÂÂ 
return
ÁÁ 
new
ÁÁ 
Plane
ÁÁ 
(
ÁÁ 
n
ÁÁ 
,
ÁÁ 
c
ÁÁ  !
)
ÁÁ! "
;
ÁÁ" #
}
ËË 	
internal
ÓÓ 
static
ÓÓ 
Plane
ÓÓ 
FindBestPlane
ÓÓ +
(
ÓÓ+ ,
ProBuilderMesh
ÓÓ, :
mesh
ÓÓ; ?
,
ÓÓ? @
int
ÓÓA D
textureGroup
ÓÓE Q
)
ÓÓQ R
{
ÔÔ 	
float
 
xx
 
=
 
$num
 
,
 
xy
 
=
  !
$num
" $
,
$ %
xz
& (
=
) *
$num
+ -
,
- .
yy
ÒÒ 
=
ÒÒ 
$num
ÒÒ 
,
ÒÒ 
yz
ÒÒ 
=
ÒÒ  !
$num
ÒÒ" $
,
ÒÒ$ %
zz
ÒÒ& (
=
ÒÒ) *
$num
ÒÒ+ -
;
ÒÒ- .
if
ÛÛ 
(
ÛÛ 
mesh
ÛÛ 
==
ÛÛ 
null
ÛÛ 
)
ÛÛ 
throw
ÙÙ 
new
ÙÙ 
System
ÙÙ  
.
ÙÙ  !#
ArgumentNullException
ÙÙ! 6
(
ÙÙ6 7
$str
ÙÙ7 =
)
ÙÙ= >
;
ÙÙ> ?
Vector3
ˆˆ 
c
ˆˆ 
=
ˆˆ 
Vector3
ˆˆ 
.
ˆˆ  
zero
ˆˆ  $
;
ˆˆ$ %
int
˜˜ 
len
˜˜ 
=
˜˜ 
$num
˜˜ 
;
˜˜ 
Vector3
¯¯ 
[
¯¯ 
]
¯¯ 
	positions
¯¯ 
=
¯¯  !
mesh
¯¯" &
.
¯¯& '
positionsInternal
¯¯' 8
;
¯¯8 9
int
˘˘ 
	faceCount
˘˘ 
=
˘˘ 
mesh
˘˘  
.
˘˘  !
	faceCount
˘˘! *
;
˘˘* +
Face
˙˙ 
[
˙˙ 
]
˙˙ 
faces
˙˙ 
=
˙˙ 
mesh
˙˙ 
.
˙˙  
facesInternal
˙˙  -
;
˙˙- .
for
¸¸ 
(
¸¸ 
int
¸¸ 
	faceIndex
¸¸ 
=
¸¸  
$num
¸¸! "
;
¸¸" #
	faceIndex
¸¸$ -
<
¸¸. /
	faceCount
¸¸0 9
;
¸¸9 :
	faceIndex
¸¸; D
++
¸¸D F
)
¸¸F G
{
˝˝ 
if
˛˛ 
(
˛˛ 
faces
˛˛ 
[
˛˛ 
	faceIndex
˛˛ #
]
˛˛# $
.
˛˛$ %
textureGroup
˛˛% 1
!=
˛˛2 4
textureGroup
˛˛5 A
)
˛˛A B
continue
ˇˇ 
;
ˇˇ 
int
ÅÅ 
[
ÅÅ 
]
ÅÅ 
indexes
ÅÅ 
=
ÅÅ 
faces
ÅÅ  %
[
ÅÅ% &
	faceIndex
ÅÅ& /
]
ÅÅ/ 0
.
ÅÅ0 1
indexesInternal
ÅÅ1 @
;
ÅÅ@ A
for
ÉÉ 
(
ÉÉ 
int
ÉÉ 
index
ÉÉ 
=
ÉÉ  
$num
ÉÉ! "
,
ÉÉ" #

indexCount
ÉÉ$ .
=
ÉÉ/ 0
indexes
ÉÉ1 8
.
ÉÉ8 9
Length
ÉÉ9 ?
;
ÉÉ? @
index
ÉÉA F
<
ÉÉG H

indexCount
ÉÉI S
;
ÉÉS T
index
ÉÉU Z
++
ÉÉZ \
)
ÉÉ\ ]
{
ÑÑ 
c
ÖÖ 
.
ÖÖ 
x
ÖÖ 
+=
ÖÖ 
	positions
ÖÖ $
[
ÖÖ$ %
indexes
ÖÖ% ,
[
ÖÖ, -
index
ÖÖ- 2
]
ÖÖ2 3
]
ÖÖ3 4
.
ÖÖ4 5
x
ÖÖ5 6
;
ÖÖ6 7
c
ÜÜ 
.
ÜÜ 
y
ÜÜ 
+=
ÜÜ 
	positions
ÜÜ $
[
ÜÜ$ %
indexes
ÜÜ% ,
[
ÜÜ, -
index
ÜÜ- 2
]
ÜÜ2 3
]
ÜÜ3 4
.
ÜÜ4 5
y
ÜÜ5 6
;
ÜÜ6 7
c
áá 
.
áá 
z
áá 
+=
áá 
	positions
áá $
[
áá$ %
indexes
áá% ,
[
áá, -
index
áá- 2
]
áá2 3
]
áá3 4
.
áá4 5
z
áá5 6
;
áá6 7
len
ââ 
++
ââ 
;
ââ 
}
ää 
}
ãã 
c
çç 
.
çç 
x
çç 
/=
çç 
len
çç 
;
çç 
c
éé 
.
éé 
y
éé 
/=
éé 
len
éé 
;
éé 
c
èè 
.
èè 
z
èè 
/=
èè 
len
èè 
;
èè 
for
ëë 
(
ëë 
int
ëë 
	faceIndex
ëë 
=
ëë  
$num
ëë! "
;
ëë" #
	faceIndex
ëë$ -
<
ëë. /
	faceCount
ëë0 9
;
ëë9 :
	faceIndex
ëë; D
++
ëëD F
)
ëëF G
{
íí 
if
ìì 
(
ìì 
faces
ìì 
[
ìì 
	faceIndex
ìì #
]
ìì# $
.
ìì$ %
textureGroup
ìì% 1
!=
ìì2 4
textureGroup
ìì5 A
)
ììA B
continue
îî 
;
îî 
int
ññ 
[
ññ 
]
ññ 
indexes
ññ 
=
ññ 
faces
ññ  %
[
ññ% &
	faceIndex
ññ& /
]
ññ/ 0
.
ññ0 1
indexesInternal
ññ1 @
;
ññ@ A
for
òò 
(
òò 
int
òò 
index
òò 
=
òò  
$num
òò! "
,
òò" #

indexCount
òò$ .
=
òò/ 0
indexes
òò1 8
.
òò8 9
Length
òò9 ?
;
òò? @
index
òòA F
<
òòG H

indexCount
òòI S
;
òòS T
index
òòU Z
++
òòZ \
)
òò\ ]
{
ôô 
Vector3
öö 
r
öö 
=
öö 
	positions
öö  )
[
öö) *
indexes
öö* 1
[
öö1 2
index
öö2 7
]
öö7 8
]
öö8 9
-
öö: ;
c
öö< =
;
öö= >
xx
úú 
+=
úú 
r
úú 
.
úú 
x
úú 
*
úú 
r
úú  !
.
úú! "
x
úú" #
;
úú# $
xy
ùù 
+=
ùù 
r
ùù 
.
ùù 
x
ùù 
*
ùù 
r
ùù  !
.
ùù! "
y
ùù" #
;
ùù# $
xz
ûû 
+=
ûû 
r
ûû 
.
ûû 
x
ûû 
*
ûû 
r
ûû  !
.
ûû! "
z
ûû" #
;
ûû# $
yy
üü 
+=
üü 
r
üü 
.
üü 
y
üü 
*
üü 
r
üü  !
.
üü! "
y
üü" #
;
üü# $
yz
†† 
+=
†† 
r
†† 
.
†† 
y
†† 
*
†† 
r
††  !
.
††! "
z
††" #
;
††# $
zz
°° 
+=
°° 
r
°° 
.
°° 
z
°° 
*
°° 
r
°°  !
.
°°! "
z
°°" #
;
°°# $
}
¢¢ 
}
££ 
float
•• 
det_x
•• 
=
•• 
yy
•• 
*
•• 
zz
•• !
-
••" #
yz
••$ &
*
••' (
yz
••) +
;
••+ ,
float
¶¶ 
det_y
¶¶ 
=
¶¶ 
xx
¶¶ 
*
¶¶ 
zz
¶¶ !
-
¶¶" #
xz
¶¶$ &
*
¶¶' (
xz
¶¶) +
;
¶¶+ ,
float
ßß 
det_z
ßß 
=
ßß 
xx
ßß 
*
ßß 
yy
ßß !
-
ßß" #
xy
ßß$ &
*
ßß' (
xy
ßß) +
;
ßß+ ,
Vector3
®® 
n
®® 
=
®® 
Vector3
®® 
.
®®  
zero
®®  $
;
®®$ %
if
™™ 
(
™™ 
det_x
™™ 
>
™™ 
det_y
™™ 
&&
™™  
det_x
™™! &
>
™™' (
det_z
™™) .
)
™™. /
{
´´ 
n
¨¨ 
.
¨¨ 
x
¨¨ 
=
¨¨ 
$num
¨¨ 
;
¨¨ 
n
≠≠ 
.
≠≠ 
y
≠≠ 
=
≠≠ 
(
≠≠ 
xz
≠≠ 
*
≠≠ 
yz
≠≠ 
-
≠≠  
xy
≠≠! #
*
≠≠$ %
zz
≠≠& (
)
≠≠( )
/
≠≠* +
det_x
≠≠, 1
;
≠≠1 2
n
ÆÆ 
.
ÆÆ 
z
ÆÆ 
=
ÆÆ 
(
ÆÆ 
xy
ÆÆ 
*
ÆÆ 
yz
ÆÆ 
-
ÆÆ  
xz
ÆÆ! #
*
ÆÆ$ %
yy
ÆÆ& (
)
ÆÆ( )
/
ÆÆ* +
det_x
ÆÆ, 1
;
ÆÆ1 2
}
ØØ 
else
∞∞ 
if
∞∞ 
(
∞∞ 
det_y
∞∞ 
>
∞∞ 
det_z
∞∞ "
)
∞∞" #
{
±± 
n
≤≤ 
.
≤≤ 
x
≤≤ 
=
≤≤ 
(
≤≤ 
yz
≤≤ 
*
≤≤ 
xz
≤≤ 
-
≤≤  
xy
≤≤! #
*
≤≤$ %
zz
≤≤& (
)
≤≤( )
/
≤≤* +
det_y
≤≤, 1
;
≤≤1 2
n
≥≥ 
.
≥≥ 
y
≥≥ 
=
≥≥ 
$num
≥≥ 
;
≥≥ 
n
¥¥ 
.
¥¥ 
z
¥¥ 
=
¥¥ 
(
¥¥ 
xy
¥¥ 
*
¥¥ 
xz
¥¥ 
-
¥¥  
yz
¥¥! #
*
¥¥$ %
xx
¥¥& (
)
¥¥( )
/
¥¥* +
det_y
¥¥, 1
;
¥¥1 2
}
µµ 
else
∂∂ 
{
∑∑ 
n
∏∏ 
.
∏∏ 
x
∏∏ 
=
∏∏ 
(
∏∏ 
yz
∏∏ 
*
∏∏ 
xy
∏∏ 
-
∏∏  
xz
∏∏! #
*
∏∏$ %
yy
∏∏& (
)
∏∏( )
/
∏∏* +
det_z
∏∏, 1
;
∏∏1 2
n
ππ 
.
ππ 
y
ππ 
=
ππ 
(
ππ 
xz
ππ 
*
ππ 
xy
ππ 
-
ππ  
yz
ππ! #
*
ππ$ %
xx
ππ& (
)
ππ( )
/
ππ* +
det_z
ππ, 1
;
ππ1 2
n
∫∫ 
.
∫∫ 
z
∫∫ 
=
∫∫ 
$num
∫∫ 
;
∫∫ 
}
ªª 
n
ΩΩ 
.
ΩΩ 
	Normalize
ΩΩ 
(
ΩΩ 
)
ΩΩ 
;
ΩΩ 
return
øø 
new
øø 
Plane
øø 
(
øø 
n
øø 
,
øø 
c
øø  !
)
øø! "
;
øø" #
}
¿¿ 	
}
¡¡ 
}¬¬ ˙
çD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ActionResult.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

sealed 
class 
ActionResult $
{		 
public 
enum 
Status 
{ 	
Success 
, 
Failure 
, 
Canceled 
, 
NoChange 
} 	
public$$ 
Status$$ 
status$$ 
{$$ 
get$$ "
;$$" #
private$$$ +
set$$, /
;$$/ 0
}$$1 2
public)) 
string)) 
notification)) "
{))# $
get))% (
;))( )
private))* 1
set))2 5
;))5 6
}))7 8
public00 
ActionResult00 
(00 
ActionResult00 (
.00( )
Status00) /
status000 6
,006 7
string008 >
notification00? K
)00K L
{11 	
this22 
.22 
status22 
=22 
status22  
;22  !
this33 
.33 
notification33 
=33 
notification33  ,
;33, -
}44 	
public;; 
static;; 
implicit;; 
operator;; '
bool;;( ,
(;;, -
ActionResult;;- 9
res;;: =
);;= >
{<< 	
return== 
res== 
!=== 
null== 
&&== !
res==" %
.==% &
status==& ,
====- /
Status==0 6
.==6 7
Success==7 >
;==> ?
}>> 	
public@@ 
bool@@ 
ToBool@@ 
(@@ 
)@@ 
{AA 	
returnBB 
statusBB 
==BB 
StatusBB #
.BB# $
SuccessBB$ +
;BB+ ,
}CC 	
publicEE 
staticEE 
boolEE 
FromBoolEE #
(EE# $
boolEE$ (
successEE) 0
)EE0 1
{FF 	
returnGG 
successGG 
?GG 
ActionResultGG )
.GG) *
SuccessGG* 1
:GG2 3
newGG4 7
ActionResultGG8 D
(GGD E
ActionResultGGE Q
.GGQ R
StatusGGR X
.GGX Y
FailureGGY `
,GG` a
$strGGb k
)GGk l
;GGl m
}HH 	
publicMM 
staticMM 
ActionResultMM "
SuccessMM# *
{NN 	
getOO 
{OO 
returnOO 
newOO 
ActionResultOO )
(OO) *
ActionResultOO* 6
.OO6 7
StatusOO7 =
.OO= >
SuccessOO> E
,OOE F
$strOOG I
)OOI J
;OOJ K
}OOL M
}PP 	
publicUU 
staticUU 
ActionResultUU "
NoSelectionUU# .
{VV 	
getWW 
{WW 
returnWW 
newWW 
ActionResultWW )
(WW) *
ActionResultWW* 6
.WW6 7
StatusWW7 =
.WW= >
CanceledWW> F
,WWF G
$strWWH Z
)WWZ [
;WW[ \
}WW] ^
}XX 	
public]] 
static]] 
ActionResult]] "
UserCanceled]]# /
{^^ 	
get__ 
{__ 
return__ 
new__ 
ActionResult__ )
(__) *
ActionResult__* 6
.__6 7
Status__7 =
.__= >
Canceled__> F
,__F G
$str__H W
)__W X
;__X Y
}__Z [
}`` 	
}aa 
}bb Æî
ïD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\PreferenceDictionary.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed 

class  
PreferenceDictionary %
:& '
ScriptableObject 
, *
ISerializationCallbackReceiver &
,& '
IHasDefault 
{ 

Dictionary 
< 
string 
, 
bool 
>  
m_Bool( .
=4 5
new6 9

Dictionary: D
<D E
stringE K
,K L
boolM Q
>Q R
(R S
)S T
;T U

Dictionary 
< 
string 
, 
int 
> 
m_Int( -
=4 5
new6 9

Dictionary: D
<D E
stringE K
,K L
intM P
>P Q
(Q R
)R S
;S T

Dictionary 
< 
string 
, 
float  
>  !
m_Float( /
=4 5
new6 9

Dictionary: D
<D E
stringE K
,K L
floatM R
>R S
(S T
)T U
;U V

Dictionary 
< 
string 
, 
string !
>! "
m_String( 0
=4 5
new6 9

Dictionary: D
<D E
stringE K
,K L
stringM S
>S T
(T U
)U V
;V W

Dictionary 
< 
string 
, 
Color  
>  !
m_Color( /
=4 5
new6 9

Dictionary: D
<D E
stringE K
,K L
ColorM R
>R S
(S T
)T U
;U V

Dictionary 
< 
string 
, 
Material #
># $

m_Material( 2
=4 5
new6 9

Dictionary: D
<D E
stringE K
,K L
MaterialM U
>U V
(V W
)W X
;X Y
[ 	
SerializeField	 
] 
List 
< 
string $
>$ %
m_Bool_keys( 3
;3 4
[ 	
SerializeField	 
] 
List 
< 
string $
>$ %

m_Int_keys( 2
;2 3
[ 	
SerializeField	 
] 
List 
< 
string $
>$ %
m_Float_keys( 4
;4 5
[ 	
SerializeField	 
] 
List 
< 
string $
>$ %
m_String_keys( 5
;5 6
[ 	
SerializeField	 
] 
List 
< 
string $
>$ %
m_Color_keys( 4
;4 5
[ 	
SerializeField	 
] 
List 
< 
string $
>$ %
m_Material_keys( 7
;7 8
[ 	
SerializeField	 
] 
List 
< 
bool "
>" #
m_Bool_values( 5
;5 6
[ 	
SerializeField	 
] 
List 
< 
int !
>! "
m_Int_values( 4
;4 5
[   	
SerializeField  	 
]   
List   
<   
float   #
>  # $
m_Float_values  ( 6
;  6 7
[!! 	
SerializeField!!	 
]!! 
List!! 
<!! 
string!! $
>!!$ %
m_String_values!!( 7
;!!7 8
["" 	
SerializeField""	 
]"" 
List"" 
<"" 
Color"" #
>""# $
m_Color_values""( 6
;""6 7
[## 	
SerializeField##	 
]## 
List## 
<## 
Material## &
>##& '
m_Material_values##( 9
;##9 :
public(( 
void(( 
OnBeforeSerialize(( %
(((% &
)((& '
{)) 	
m_Bool_keys** 
=**  !
m_Bool**" (
.**( )
Keys**) -
.**- .
ToList**. 4
(**4 5
)**5 6
;**6 7

m_Int_keys++ 
=++  !
m_Int++" '
.++' (
Keys++( ,
.++, -
ToList++- 3
(++3 4
)++4 5
;++5 6
m_Float_keys,, 
=,,  !
m_Float,," )
.,,) *
Keys,,* .
.,,. /
ToList,,/ 5
(,,5 6
),,6 7
;,,7 8
m_String_keys-- 
=--  !
m_String--" *
.--* +
Keys--+ /
.--/ 0
ToList--0 6
(--6 7
)--7 8
;--8 9
m_Color_keys.. 
=..  !
m_Color.." )
...) *
Keys..* .
.... /
ToList../ 5
(..5 6
)..6 7
;..7 8
m_Material_keys// 
=//  !

m_Material//" ,
.//, -
Keys//- 1
.//1 2
ToList//2 8
(//8 9
)//9 :
;//: ;
m_Bool_values11 
=11  !
m_Bool11" (
.11( )
Values11) /
.11/ 0
ToList110 6
(116 7
)117 8
;118 9
m_Int_values22 
=22  !
m_Int22" '
.22' (
Values22( .
.22. /
ToList22/ 5
(225 6
)226 7
;227 8
m_Float_values33 
=33  !
m_Float33" )
.33) *
Values33* 0
.330 1
ToList331 7
(337 8
)338 9
;339 :
m_String_values44 
=44  !
m_String44" *
.44* +
Values44+ 1
.441 2
ToList442 8
(448 9
)449 :
;44: ;
m_Color_values55 
=55  !
m_Color55" )
.55) *
Values55* 0
.550 1
ToList551 7
(557 8
)558 9
;559 :
m_Material_values66 
=66  !

m_Material66" ,
.66, -
Values66- 3
.663 4
ToList664 :
(66: ;
)66; <
;66< =
}77 	
public<< 
void<< 
OnAfterDeserialize<< &
(<<& '
)<<' (
{== 	
for>> 
(>> 
int>> 
i>> 
=>> 
$num>> 
;>> 
i>> 
<>> 
m_Bool_keys>>  +
.>>+ ,
Count>>, 1
;>>1 2
i>>3 4
++>>4 6
)>>6 7
m_Bool?? 
.?? 
Add?? 
(?? 
m_Bool_keys?? &
[??& '
i??' (
]??( )
,??) *
m_Bool_values??+ 8
[??8 9
i??9 :
]??: ;
)??; <
;??< =
forAA 
(AA 
intAA 
iAA 
=AA 
$numAA 
;AA 
iAA 
<AA 

m_Int_keysAA  *
.AA* +
CountAA+ 0
;AA0 1
iAA2 3
++AA3 5
)AA5 6
m_IntBB 
.BB 
AddBB 
(BB 

m_Int_keysBB $
[BB$ %
iBB% &
]BB& '
,BB' (
m_Int_valuesBB) 5
[BB5 6
iBB6 7
]BB7 8
)BB8 9
;BB9 :
forDD 
(DD 
intDD 
iDD 
=DD 
$numDD 
;DD 
iDD 
<DD 
m_Float_keysDD  ,
.DD, -
CountDD- 2
;DD2 3
iDD4 5
++DD5 7
)DD7 8
m_FloatEE 
.EE 
AddEE 
(EE 
m_Float_keysEE (
[EE( )
iEE) *
]EE* +
,EE+ ,
m_Float_valuesEE- ;
[EE; <
iEE< =
]EE= >
)EE> ?
;EE? @
forGG 
(GG 
intGG 
iGG 
=GG 
$numGG 
;GG 
iGG 
<GG 
m_String_keysGG  -
.GG- .
CountGG. 3
;GG3 4
iGG5 6
++GG6 8
)GG8 9
m_StringHH 
.HH 
AddHH 
(HH 
m_String_keysHH *
[HH* +
iHH+ ,
]HH, -
,HH- .
m_String_valuesHH/ >
[HH> ?
iHH? @
]HH@ A
)HHA B
;HHB C
forJJ 
(JJ 
intJJ 
iJJ 
=JJ 
$numJJ 
;JJ 
iJJ 
<JJ 
m_Color_keysJJ  ,
.JJ, -
CountJJ- 2
;JJ2 3
iJJ4 5
++JJ5 7
)JJ7 8
m_ColorKK 
.KK 
AddKK 
(KK 
m_Color_keysKK (
[KK( )
iKK) *
]KK* +
,KK+ ,
m_Color_valuesKK- ;
[KK; <
iKK< =
]KK= >
)KK> ?
;KK? @
forMM 
(MM 
intMM 
iMM 
=MM 
$numMM 
;MM 
iMM 
<MM 
m_Material_keysMM  /
.MM/ 0
CountMM0 5
;MM5 6
iMM7 8
++MM8 :
)MM: ;

m_MaterialNN 
.NN 
AddNN 
(NN 
m_Material_keysNN .
[NN. /
iNN/ 0
]NN0 1
,NN1 2
m_Material_valuesNN3 D
[NND E
iNNE F
]NNF G
)NNG H
;NNH I
}OO 	
publicTT 
voidTT 
SetDefaultValuesTT $
(TT$ %
)TT% &
{UU 	
m_BoolVV 
.VV 
ClearVV 
(VV 
)VV 
;VV 
m_IntWW 
.WW 
ClearWW 
(WW 
)WW 
;WW 
m_FloatXX 
.XX 
ClearXX 
(XX 
)XX 
;XX 
m_StringYY 
.YY 
ClearYY 
(YY 
)YY 
;YY 
m_ColorZZ 
.ZZ 
ClearZZ 
(ZZ 
)ZZ 
;ZZ 

m_Material[[ 
.[[ 
Clear[[ 
([[ 
)[[ 
;[[ 
}\\ 	
publiccc 
boolcc 
HasKeycc 
(cc 
stringcc !
keycc" %
)cc% &
{dd 	
returnee 
m_Boolee 
.ee 
ContainsKeyee %
(ee% &
keyee& )
)ee) *
||ee+ -
m_Intff 
.ff 
ContainsKeyff !
(ff! "
keyff" %
)ff% &
||ff' )
m_Floatgg 
.gg 
ContainsKeygg #
(gg# $
keygg$ '
)gg' (
||gg) +
m_Stringhh 
.hh 
ContainsKeyhh $
(hh$ %
keyhh% (
)hh( )
||hh* ,
m_Colorii 
.ii 
ContainsKeyii #
(ii# $
keyii$ '
)ii' (
||ii) +

m_Materialjj 
.jj 
ContainsKeyjj &
(jj& '
keyjj' *
)jj* +
;jj+ ,
}kk 	
publicss 
boolss 
HasKeyss 
<ss 
Tss 
>ss 
(ss 
stringss $
keyss% (
)ss( )
{tt 	
Systemuu 
.uu 
Typeuu 
typeuu 
=uu 
typeofuu %
(uu% &
Tuu& '
)uu' (
;uu( )
ifww 
(ww 
typeww 
==ww 
typeofww 
(ww 
intww "
)ww" #
)ww# $
returnxx 
m_Intxx 
.xx 
ContainsKeyxx (
(xx( )
keyxx) ,
)xx, -
;xx- .
elseyy 
ifyy 
(yy 
typeyy 
==yy 
typeofyy #
(yy# $
floatyy$ )
)yy) *
)yy* +
returnzz 
m_Floatzz 
.zz 
ContainsKeyzz *
(zz* +
keyzz+ .
)zz. /
;zz/ 0
else{{ 
if{{ 
({{ 
type{{ 
=={{ 
typeof{{ #
({{# $
bool{{$ (
){{( )
){{) *
return|| 
m_Bool|| 
.|| 
ContainsKey|| )
(||) *
key||* -
)||- .
;||. /
else}} 
if}} 
(}} 
type}} 
==}} 
typeof}} #
(}}# $
string}}$ *
)}}* +
)}}+ ,
return~~ 
m_String~~ 
.~~  
ContainsKey~~  +
(~~+ ,
key~~, /
)~~/ 0
;~~0 1
else 
if 
( 
type 
== 
typeof #
(# $
Color$ )
)) *
)* +
return
ÄÄ 
m_Color
ÄÄ 
.
ÄÄ 
ContainsKey
ÄÄ *
(
ÄÄ* +
key
ÄÄ+ .
)
ÄÄ. /
;
ÄÄ/ 0
else
ÅÅ 
if
ÅÅ 
(
ÅÅ 
type
ÅÅ 
==
ÅÅ 
typeof
ÅÅ #
(
ÅÅ# $
Material
ÅÅ$ ,
)
ÅÅ, -
)
ÅÅ- .
return
ÇÇ 

m_Material
ÇÇ !
.
ÇÇ! "
ContainsKey
ÇÇ" -
(
ÇÇ- .
key
ÇÇ. 1
)
ÇÇ1 2
;
ÇÇ2 3
else
ÉÉ 
{
ÑÑ 
Debug
ÖÖ 
.
ÖÖ 

LogWarning
ÖÖ  
(
ÖÖ  !
string
ÖÖ! '
.
ÖÖ' (
Format
ÖÖ( .
(
ÖÖ. /
$str
ÖÖ/ \
,
ÖÖ\ ]
typeof
ÜÜ 
(
ÜÜ 
T
ÜÜ  
)
ÜÜ  !
.
ÜÜ! "
ToString
ÜÜ" *
(
ÜÜ* +
)
ÜÜ+ ,
,
ÜÜ, -
key
áá 
)
áá 
)
áá 
;
áá 
}
àà 
return
ää 
false
ää 
;
ää 
}
ãã 	
public
çç 
void
çç 
	DeleteKey
çç 
(
çç 
string
çç $
key
çç% (
)
çç( )
{
éé 	
if
èè 
(
èè 
m_Bool
èè 
.
èè 
ContainsKey
èè "
(
èè" #
key
èè# &
)
èè& '
)
èè' (
m_Bool
êê 
.
êê 
Remove
êê 
(
êê 
key
êê !
)
êê! "
;
êê" #
if
ëë 
(
ëë 
m_Int
ëë 
.
ëë 
ContainsKey
ëë !
(
ëë! "
key
ëë" %
)
ëë% &
)
ëë& '
m_Int
íí 
.
íí 
Remove
íí 
(
íí 
key
íí  
)
íí  !
;
íí! "
if
ìì 
(
ìì 
m_Float
ìì 
.
ìì 
ContainsKey
ìì #
(
ìì# $
key
ìì$ '
)
ìì' (
)
ìì( )
m_Float
îî 
.
îî 
Remove
îî 
(
îî 
key
îî "
)
îî" #
;
îî# $
if
ïï 
(
ïï 
m_String
ïï 
.
ïï 
ContainsKey
ïï $
(
ïï$ %
key
ïï% (
)
ïï( )
)
ïï) *
m_String
ññ 
.
ññ 
Remove
ññ 
(
ññ  
key
ññ  #
)
ññ# $
;
ññ$ %
if
óó 
(
óó 
m_Color
óó 
.
óó 
ContainsKey
óó #
(
óó# $
key
óó$ '
)
óó' (
)
óó( )
m_Color
òò 
.
òò 
Remove
òò 
(
òò 
key
òò "
)
òò" #
;
òò# $
if
ôô 
(
ôô 

m_Material
ôô 
.
ôô 
ContainsKey
ôô &
(
ôô& '
key
ôô' *
)
ôô* +
)
ôô+ ,

m_Material
öö 
.
öö 
Remove
öö !
(
öö! "
key
öö" %
)
öö% &
;
öö& '
}
õõ 	
public
§§ 
T
§§ 
Get
§§ 
<
§§ 
T
§§ 
>
§§ 
(
§§ 
string
§§ 
key
§§ "
,
§§" #
T
§§$ %
fallback
§§& .
=
§§/ 0
default
§§1 8
(
§§8 9
T
§§9 :
)
§§: ;
)
§§; <
{
•• 	
System
¶¶ 
.
¶¶ 
Type
¶¶ 
type
¶¶ 
=
¶¶ 
typeof
¶¶ %
(
¶¶% &
T
¶¶& '
)
¶¶' (
;
¶¶( )
if
®® 
(
®® 
type
®® 
==
®® 
typeof
®® 
(
®® 
int
®® "
)
®®" #
)
®®# $
{
©© 
if
™™ 
(
™™ 
m_Int
™™ 
.
™™ 
ContainsKey
™™ %
(
™™% &
key
™™& )
)
™™) *
)
™™* +
return
´´ 
(
´´ 
T
´´ 
)
´´ 
(
´´ 
object
´´ %
)
´´% &
GetInt
´´& ,
(
´´, -
key
´´- 0
)
´´0 1
;
´´1 2
}
¨¨ 
else
≠≠ 
if
≠≠ 
(
≠≠ 
type
≠≠ 
==
≠≠ 
typeof
≠≠ #
(
≠≠# $
float
≠≠$ )
)
≠≠) *
)
≠≠* +
{
ÆÆ 
if
ØØ 
(
ØØ 
m_Float
ØØ 
.
ØØ 
ContainsKey
ØØ '
(
ØØ' (
key
ØØ( +
)
ØØ+ ,
)
ØØ, -
return
∞∞ 
(
∞∞ 
T
∞∞ 
)
∞∞ 
(
∞∞ 
object
∞∞ %
)
∞∞% &
GetFloat
∞∞& .
(
∞∞. /
key
∞∞/ 2
)
∞∞2 3
;
∞∞3 4
}
±± 
else
≤≤ 
if
≤≤ 
(
≤≤ 
type
≤≤ 
==
≤≤ 
typeof
≤≤ #
(
≤≤# $
bool
≤≤$ (
)
≤≤( )
)
≤≤) *
{
≥≥ 
if
¥¥ 
(
¥¥ 
m_Bool
¥¥ 
.
¥¥ 
ContainsKey
¥¥ &
(
¥¥& '
key
¥¥' *
)
¥¥* +
)
¥¥+ ,
return
µµ 
(
µµ 
T
µµ 
)
µµ 
(
µµ 
object
µµ %
)
µµ% &
GetBool
µµ& -
(
µµ- .
key
µµ. 1
)
µµ1 2
;
µµ2 3
}
∂∂ 
else
∑∑ 
if
∑∑ 
(
∑∑ 
type
∑∑ 
==
∑∑ 
typeof
∑∑ #
(
∑∑# $
string
∑∑$ *
)
∑∑* +
)
∑∑+ ,
{
∏∏ 
if
ππ 
(
ππ 
m_String
ππ 
.
ππ 
ContainsKey
ππ (
(
ππ( )
key
ππ) ,
)
ππ, -
)
ππ- .
return
∫∫ 
(
∫∫ 
T
∫∫ 
)
∫∫ 
(
∫∫ 
object
∫∫ %
)
∫∫% &
	GetString
∫∫& /
(
∫∫/ 0
key
∫∫0 3
)
∫∫3 4
;
∫∫4 5
}
ªª 
else
ºº 
if
ºº 
(
ºº 
type
ºº 
==
ºº 
typeof
ºº #
(
ºº# $
Color
ºº$ )
)
ºº) *
)
ºº* +
{
ΩΩ 
if
ææ 
(
ææ 
m_Color
ææ 
.
ææ 
ContainsKey
ææ '
(
ææ' (
key
ææ( +
)
ææ+ ,
)
ææ, -
return
øø 
(
øø 
T
øø 
)
øø 
(
øø 
object
øø %
)
øø% &
GetColor
øø& .
(
øø. /
key
øø/ 2
)
øø2 3
;
øø3 4
}
¿¿ 
else
¡¡ 
if
¡¡ 
(
¡¡ 
type
¡¡ 
==
¡¡ 
typeof
¡¡ #
(
¡¡# $
Material
¡¡$ ,
)
¡¡, -
)
¡¡- .
{
¬¬ 
if
√√ 
(
√√ 

m_Material
√√ 
.
√√ 
ContainsKey
√√ *
(
√√* +
key
√√+ .
)
√√. /
)
√√/ 0
return
ƒƒ 
(
ƒƒ 
T
ƒƒ 
)
ƒƒ 
(
ƒƒ 
object
ƒƒ %
)
ƒƒ% &
GetMaterial
ƒƒ& 1
(
ƒƒ1 2
key
ƒƒ2 5
)
ƒƒ5 6
;
ƒƒ6 7
}
≈≈ 
else
∆∆ 
{
«« 
Debug
»» 
.
»» 

LogWarning
»»  
(
»»  !
string
»»! '
.
»»' (
Format
»»( .
(
»». /
$str
»»/ Y
,
»»Y Z
typeof
…… 
(
…… 
T
……  
)
……  !
.
……! "
ToString
……" *
(
……* +
)
……+ ,
,
……, -
key
   
)
   
)
   
;
   
}
ÀÀ 
return
ÕÕ 
fallback
ÕÕ 
;
ÕÕ 
}
ŒŒ 	
public
‹‹ 
void
‹‹ 
Set
‹‹ 
<
‹‹ 
T
‹‹ 
>
‹‹ 
(
‹‹ 
string
‹‹ !
key
‹‹" %
,
‹‹% &
T
‹‹' (
value
‹‹) .
)
‹‹. /
{
›› 	
object
ﬁﬁ 
o
ﬁﬁ 
=
ﬁﬁ 
(
ﬁﬁ 
object
ﬁﬁ 
)
ﬁﬁ 
value
ﬁﬁ $
;
ﬁﬁ$ %
if
‡‡ 
(
‡‡ 
value
‡‡ 
is
‡‡ 
int
‡‡ 
)
‡‡ 
SetInt
·· 
(
·· 
key
·· 
,
·· 
(
·· 
int
··  
)
··  !
o
··! "
)
··" #
;
··# $
else
‚‚ 
if
‚‚ 
(
‚‚ 
value
‚‚ 
is
‚‚ 
float
‚‚ #
)
‚‚# $
SetFloat
„„ 
(
„„ 
key
„„ 
,
„„ 
(
„„ 
float
„„ $
)
„„$ %
o
„„% &
)
„„& '
;
„„' (
else
‰‰ 
if
‰‰ 
(
‰‰ 
value
‰‰ 
is
‰‰ 
bool
‰‰ "
)
‰‰" #
SetBool
ÂÂ 
(
ÂÂ 
key
ÂÂ 
,
ÂÂ 
(
ÂÂ 
bool
ÂÂ "
)
ÂÂ" #
o
ÂÂ# $
)
ÂÂ$ %
;
ÂÂ% &
else
ÊÊ 
if
ÊÊ 
(
ÊÊ 
value
ÊÊ 
is
ÊÊ 
string
ÊÊ $
)
ÊÊ$ %
	SetString
ÁÁ 
(
ÁÁ 
key
ÁÁ 
,
ÁÁ 
(
ÁÁ  
string
ÁÁ  &
)
ÁÁ& '
o
ÁÁ' (
)
ÁÁ( )
;
ÁÁ) *
else
ËË 
if
ËË 
(
ËË 
value
ËË 
is
ËË 
Color
ËË #
)
ËË# $
SetColor
ÈÈ 
(
ÈÈ 
key
ÈÈ 
,
ÈÈ 
(
ÈÈ 
Color
ÈÈ $
)
ÈÈ$ %
o
ÈÈ% &
)
ÈÈ& '
;
ÈÈ' (
else
ÍÍ 
if
ÍÍ 
(
ÍÍ 
value
ÍÍ 
is
ÍÍ 
Material
ÍÍ &
)
ÍÍ& '
SetMaterial
ÎÎ 
(
ÎÎ 
key
ÎÎ 
,
ÎÎ  
(
ÎÎ! "
Material
ÎÎ" *
)
ÎÎ* +
o
ÎÎ+ ,
)
ÎÎ, -
;
ÎÎ- .
else
ÏÏ 
Debug
ÌÌ 
.
ÌÌ 

LogWarning
ÌÌ  
(
ÌÌ  !
string
ÌÌ! '
.
ÌÌ' (
Format
ÌÌ( .
(
ÌÌ. /
$str
ÌÌ/ ^
,
ÌÌ^ _
typeof
ÓÓ 
(
ÓÓ 
T
ÓÓ  
)
ÓÓ  !
.
ÓÓ! "
ToString
ÓÓ" *
(
ÓÓ* +
)
ÓÓ+ ,
,
ÓÓ, -
key
ÔÔ 
,
ÔÔ 
value
 
.
 
ToString
 &
(
& '
)
' (
)
( )
)
) *
;
* +
}
ÒÒ 	
public
ˆˆ 
bool
ˆˆ 
GetBool
ˆˆ 
(
ˆˆ 
string
ˆˆ "
key
ˆˆ# &
,
ˆˆ& '
bool
ˆˆ( ,
fallback
ˆˆ- 5
=
ˆˆ6 7
default
ˆˆ8 ?
(
ˆˆ? @
bool
ˆˆ@ D
)
ˆˆD E
)
ˆˆE F
{
˜˜ 	
bool
¯¯ 
value
¯¯ 
;
¯¯ 
if
˘˘ 
(
˘˘ 
m_Bool
˘˘ 
.
˘˘ 
TryGetValue
˘˘ "
(
˘˘" #
key
˘˘# &
,
˘˘& '
out
˘˘( +
value
˘˘, 1
)
˘˘1 2
)
˘˘2 3
return
˙˙ 
value
˙˙ 
;
˙˙ 
return
˚˚ 
fallback
˚˚ 
;
˚˚ 
}
¸¸ 	
public
ÅÅ 
int
ÅÅ 
GetInt
ÅÅ 
(
ÅÅ 
string
ÅÅ  
key
ÅÅ! $
,
ÅÅ$ %
int
ÅÅ& )
fallback
ÅÅ* 2
=
ÅÅ3 4
default
ÅÅ5 <
(
ÅÅ< =
int
ÅÅ= @
)
ÅÅ@ A
)
ÅÅA B
{
ÇÇ 	
int
ÉÉ 
value
ÉÉ 
;
ÉÉ 
if
ÑÑ 
(
ÑÑ 
m_Int
ÑÑ 
.
ÑÑ 
TryGetValue
ÑÑ !
(
ÑÑ! "
key
ÑÑ" %
,
ÑÑ% &
out
ÑÑ' *
value
ÑÑ+ 0
)
ÑÑ0 1
)
ÑÑ1 2
return
ÖÖ 
value
ÖÖ 
;
ÖÖ 
return
ÜÜ 
fallback
ÜÜ 
;
ÜÜ 
}
áá 	
public
åå 
float
åå 
GetFloat
åå 
(
åå 
string
åå $
key
åå% (
,
åå( )
float
åå* /
fallback
åå0 8
=
åå9 :
default
åå; B
(
ååB C
float
ååC H
)
ååH I
)
ååI J
{
çç 	
float
éé 
value
éé 
;
éé 
if
èè 
(
èè 
m_Float
èè 
.
èè 
TryGetValue
èè #
(
èè# $
key
èè$ '
,
èè' (
out
èè) ,
value
èè- 2
)
èè2 3
)
èè3 4
return
êê 
value
êê 
;
êê 
return
ëë 
fallback
ëë 
;
ëë 
}
íí 	
public
óó 
string
óó 
	GetString
óó 
(
óó  
string
óó  &
key
óó' *
,
óó* +
string
óó, 2
fallback
óó3 ;
=
óó< =
default
óó> E
(
óóE F
string
óóF L
)
óóL M
)
óóM N
{
òò 	
string
ôô 
value
ôô 
;
ôô 
if
öö 
(
öö 
m_String
öö 
.
öö 
TryGetValue
öö $
(
öö$ %
key
öö% (
,
öö( )
out
öö* -
value
öö. 3
)
öö3 4
)
öö4 5
return
õõ 
value
õõ 
;
õõ 
return
úú 
fallback
úú 
;
úú 
}
ùù 	
public
¢¢ 
Color
¢¢ 
GetColor
¢¢ 
(
¢¢ 
string
¢¢ $
key
¢¢% (
,
¢¢( )
Color
¢¢* /
fallback
¢¢0 8
=
¢¢9 :
default
¢¢; B
(
¢¢B C
Color
¢¢C H
)
¢¢H I
)
¢¢I J
{
££ 	
Color
§§ 
value
§§ 
;
§§ 
if
•• 
(
•• 
m_Color
•• 
.
•• 
TryGetValue
•• #
(
••# $
key
••$ '
,
••' (
out
••) ,
value
••- 2
)
••2 3
)
••3 4
return
¶¶ 
value
¶¶ 
;
¶¶ 
return
ßß 
fallback
ßß 
;
ßß 
}
®® 	
public
≠≠ 
Material
≠≠ 
GetMaterial
≠≠ #
(
≠≠# $
string
≠≠$ *
key
≠≠+ .
,
≠≠. /
Material
≠≠0 8
fallback
≠≠9 A
=
≠≠B C
default
≠≠D K
(
≠≠K L
Material
≠≠L T
)
≠≠T U
)
≠≠U V
{
ÆÆ 	
Material
ØØ 
value
ØØ 
;
ØØ 
if
∞∞ 
(
∞∞ 

m_Material
∞∞ 
.
∞∞ 
TryGetValue
∞∞ &
(
∞∞& '
key
∞∞' *
,
∞∞* +
out
∞∞, /
value
∞∞0 5
)
∞∞5 6
)
∞∞6 7
return
±± 
value
±± 
;
±± 
return
≤≤ 
fallback
≤≤ 
;
≤≤ 
}
≥≥ 	
public
∏∏ 
void
∏∏ 
SetBool
∏∏ 
(
∏∏ 
string
∏∏ "
key
∏∏# &
,
∏∏& '
bool
∏∏( ,
value
∏∏- 2
)
∏∏2 3
{
ππ 	
if
∫∫ 
(
∫∫ 
m_Bool
∫∫ 
.
∫∫ 
ContainsKey
∫∫ "
(
∫∫" #
key
∫∫# &
)
∫∫& '
)
∫∫' (
m_Bool
ªª 
[
ªª 
key
ªª 
]
ªª 
=
ªª 
value
ªª #
;
ªª# $
else
ºº 
m_Bool
ΩΩ 
.
ΩΩ 
Add
ΩΩ 
(
ΩΩ 
key
ΩΩ 
,
ΩΩ 
value
ΩΩ  %
)
ΩΩ% &
;
ΩΩ& '
}
ææ 	
public
√√ 
void
√√ 
SetInt
√√ 
(
√√ 
string
√√ !
key
√√" %
,
√√% &
int
√√' *
value
√√+ 0
)
√√0 1
{
ƒƒ 	
if
≈≈ 
(
≈≈ 
m_Int
≈≈ 
.
≈≈ 
ContainsKey
≈≈ !
(
≈≈! "
key
≈≈" %
)
≈≈% &
)
≈≈& '
m_Int
∆∆ 
[
∆∆ 
key
∆∆ 
]
∆∆ 
=
∆∆ 
value
∆∆ "
;
∆∆" #
else
«« 
m_Int
»» 
.
»» 
Add
»» 
(
»» 
key
»» 
,
»» 
value
»» $
)
»»$ %
;
»»% &
}
…… 	
public
ŒŒ 
void
ŒŒ 
SetFloat
ŒŒ 
(
ŒŒ 
string
ŒŒ #
key
ŒŒ$ '
,
ŒŒ' (
float
ŒŒ) .
value
ŒŒ/ 4
)
ŒŒ4 5
{
œœ 	
if
–– 
(
–– 
m_Float
–– 
.
–– 
ContainsKey
–– #
(
––# $
key
––$ '
)
––' (
)
––( )
m_Float
—— 
[
—— 
key
—— 
]
—— 
=
—— 
value
—— $
;
——$ %
else
““ 
m_Float
”” 
.
”” 
Add
”” 
(
”” 
key
”” 
,
””  
value
””! &
)
””& '
;
””' (
}
‘‘ 	
public
ŸŸ 
void
ŸŸ 
	SetString
ŸŸ 
(
ŸŸ 
string
ŸŸ $
key
ŸŸ% (
,
ŸŸ( )
string
ŸŸ* 0
value
ŸŸ1 6
)
ŸŸ6 7
{
⁄⁄ 	
if
€€ 
(
€€ 
m_String
€€ 
.
€€ 
ContainsKey
€€ $
(
€€$ %
key
€€% (
)
€€( )
)
€€) *
m_String
‹‹ 
[
‹‹ 
key
‹‹ 
]
‹‹ 
=
‹‹ 
value
‹‹  %
;
‹‹% &
else
›› 
m_String
ﬁﬁ 
.
ﬁﬁ 
Add
ﬁﬁ 
(
ﬁﬁ 
key
ﬁﬁ  
,
ﬁﬁ  !
value
ﬁﬁ" '
)
ﬁﬁ' (
;
ﬁﬁ( )
}
ﬂﬂ 	
public
‰‰ 
void
‰‰ 
SetColor
‰‰ 
(
‰‰ 
string
‰‰ #
key
‰‰$ '
,
‰‰' (
Color
‰‰) .
value
‰‰/ 4
)
‰‰4 5
{
ÂÂ 	
if
ÊÊ 
(
ÊÊ 
m_Color
ÊÊ 
.
ÊÊ 
ContainsKey
ÊÊ #
(
ÊÊ# $
key
ÊÊ$ '
)
ÊÊ' (
)
ÊÊ( )
m_Color
ÁÁ 
[
ÁÁ 
key
ÁÁ 
]
ÁÁ 
=
ÁÁ 
value
ÁÁ $
;
ÁÁ$ %
else
ËË 
m_Color
ÈÈ 
.
ÈÈ 
Add
ÈÈ 
(
ÈÈ 
key
ÈÈ 
,
ÈÈ  
value
ÈÈ! &
)
ÈÈ& '
;
ÈÈ' (
}
ÍÍ 	
public
ÔÔ 
void
ÔÔ 
SetMaterial
ÔÔ 
(
ÔÔ  
string
ÔÔ  &
key
ÔÔ' *
,
ÔÔ* +
Material
ÔÔ, 4
value
ÔÔ5 :
)
ÔÔ: ;
{
 	
if
ÒÒ 
(
ÒÒ 

m_Material
ÒÒ 
.
ÒÒ 
ContainsKey
ÒÒ &
(
ÒÒ& '
key
ÒÒ' *
)
ÒÒ* +
)
ÒÒ+ ,

m_Material
ÚÚ 
[
ÚÚ 
key
ÚÚ 
]
ÚÚ 
=
ÚÚ  !
value
ÚÚ" '
;
ÚÚ' (
else
ÛÛ 

m_Material
ÙÙ 
.
ÙÙ 
Add
ÙÙ 
(
ÙÙ 
key
ÙÙ "
,
ÙÙ" #
value
ÙÙ$ )
)
ÙÙ) *
;
ÙÙ* +
}
ıı 	
public
˙˙ 

Dictionary
˙˙ 
<
˙˙ 
string
˙˙  
,
˙˙  !
bool
˙˙" &
>
˙˙& '
GetBoolDictionary
˙˙( 9
(
˙˙9 :
)
˙˙: ;
{
˙˙< =
return
˙˙> D
m_Bool
˙˙E K
;
˙˙K L
}
˙˙M N
public
ˇˇ 

Dictionary
ˇˇ 
<
ˇˇ 
string
ˇˇ  
,
ˇˇ  !
int
ˇˇ" %
>
ˇˇ% &
GetIntDictionary
ˇˇ' 7
(
ˇˇ7 8
)
ˇˇ8 9
{
ˇˇ: ;
return
ˇˇ< B
m_Int
ˇˇC H
;
ˇˇH I
}
ˇˇJ K
public
ÑÑ 

Dictionary
ÑÑ 
<
ÑÑ 
string
ÑÑ  
,
ÑÑ  !
float
ÑÑ" '
>
ÑÑ' ( 
GetFloatDictionary
ÑÑ) ;
(
ÑÑ; <
)
ÑÑ< =
{
ÑÑ> ?
return
ÑÑ@ F
m_Float
ÑÑG N
;
ÑÑN O
}
ÑÑP Q
public
ââ 

Dictionary
ââ 
<
ââ 
string
ââ  
,
ââ  !
string
ââ" (
>
ââ( )!
GetStringDictionary
ââ* =
(
ââ= >
)
ââ> ?
{
ââ@ A
return
ââB H
m_String
ââI Q
;
ââQ R
}
ââS T
public
éé 

Dictionary
éé 
<
éé 
string
éé  
,
éé  !
Color
éé" '
>
éé' ( 
GetColorDictionary
éé) ;
(
éé; <
)
éé< =
{
éé> ?
return
éé@ F
m_Color
ééG N
;
ééN O
}
ééP Q
public
ìì 

Dictionary
ìì 
<
ìì 
string
ìì  
,
ìì  !
Material
ìì" *
>
ìì* +#
GetMaterialDictionary
ìì, A
(
ììA B
)
ììB C
{
ììD E
return
ììF L

m_Material
ììM W
;
ììW X
}
ììY Z
public
òò 
void
òò 
Clear
òò 
(
òò 
)
òò 
{
ôô 	
m_Bool
öö 
.
öö 
Clear
öö 
(
öö 
)
öö 
;
öö 
m_Int
õõ 
.
õõ 
Clear
õõ 
(
õõ 
)
õõ 
;
õõ 
m_Float
úú 
.
úú 
Clear
úú 
(
úú 
)
úú 
;
úú 
m_String
ùù 
.
ùù 
Clear
ùù 
(
ùù 
)
ùù 
;
ùù 
m_Color
ûû 
.
ûû 
Clear
ûû 
(
ûû 
)
ûû 
;
ûû 
}
üü 	
}
†† 
}°° ˘*
àD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\IntVec2.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
struct 
IntVec2 
: 
System 
. 

IEquatable #
<# $
IntVec2$ +
>+ ,
{		 
public

 
Vector2

	 
value

 
;

 
public 
float	 
x 
{ 
get 
{ 
return 
value  %
.% &
x& '
;' (
}) *
}+ ,
public 
float	 
y 
{ 
get 
{ 
return 
value  %
.% &
y& '
;' (
}) *
}+ ,
public 
IntVec2	 
( 
Vector2 
vector 
)  
{ 
this 
. 
value 
= 
vector 
; 
} 
public 
override	 
string 
ToString !
(! "
)" #
{ 
return 	
string
 
. 
Format 
( 
$str *
,* +
x, -
,- .
y/ 0
)0 1
;1 2
} 
public 
static	 
bool 
operator 
== 
(  
IntVec2  '
a( )
,) *
IntVec2+ 2
b3 4
)4 5
{ 
return 	
a
 
. 
Equals 
( 
b 
) 
; 
} 
public 
static	 
bool 
operator 
!= 
(  
IntVec2  '
a( )
,) *
IntVec2+ 2
b3 4
)4 5
{ 
return   	
!  
 
(   
a   
==   
b   
)   
;   
}!! 
public## 
bool##	 
Equals## 
(## 
IntVec2## 
p## 
)## 
{$$ 
return%% 	
round%%
 
(%% 
x%% 
)%% 
==%% 
round%% 
(%% 
p%% 
.%% 
x%% 
)%%  
&&%%! #
round&& 	
(&&	 

y&&
 
)&& 
==&& 
round&& 
(&& 
p&& 
.&& 
y&& 
)&& 
;&& 
}'' 
public)) 
bool))	 
Equals)) 
()) 
Vector2)) 
p)) 
))) 
{** 
return++ 	
round++
 
(++ 
x++ 
)++ 
==++ 
round++ 
(++ 
p++ 
.++ 
x++ 
)++  
&&++! #
round,, 	
(,,	 

y,,
 
),, 
==,, 
round,, 
(,, 
p,, 
.,, 
y,, 
),, 
;,, 
}-- 
public// 
override//	 
bool// 
Equals// 
(// 
System// $
.//$ %
Object//% +
b//, -
)//- .
{00 
return11 	
(11
 
b11 
is11 
IntVec211 
&&11 
(11 
this11  
.11  !
Equals11! '
(11' (
(11( )
IntVec211) 0
)110 1
b111 2
)112 3
)113 4
)114 5
||116 8
(22 
b22 
is22 	
Vector222
 
&&22 
this22 
.22 
Equals22  
(22  !
(22! "
Vector222" )
)22) *
b22* +
)22+ ,
)22, -
;22- .
}33 
public55 
override55	 
int55 
GetHashCode55 !
(55! "
)55" #
{66 
return77 	

VectorHash77
 
.77 
GetHashCode77  
(77  !
value77! &
)77& '
;77' (
}88 
private:: 	
static::
 
int:: 
round:: 
(:: 
float::  
v::! "
)::" #
{;; 
return<< 	
System<<
 
.<< 
Convert<< 
.<< 
ToInt32<<  
(<<  !
v<<! "
*<<# $

VectorHash<<% /
.<</ 0 
FltCompareResolution<<0 D
)<<D E
;<<E F
}== 
public?? 
static??	 
implicit?? 
operator?? !
Vector2??" )
(??) *
IntVec2??* 1
p??2 3
)??3 4
{@@ 
returnAA 	
pAA
 
.AA 
valueAA 
;AA 
}BB 
publicDD 
staticDD	 
implicitDD 
operatorDD !
IntVec2DD" )
(DD) *
Vector2DD* 1
pDD2 3
)DD3 4
{EE 
returnFF 	
newFF
 
IntVec2FF 
(FF 
pFF 
)FF 
;FF 
}GG 
}HH 
}II ¿
êD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\MaterialUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
MaterialUtility  
{ 
static

 
List

 
<

 
Material

 
>

 
s_MaterialArray

 -
=

. /
new

0 3
List

4 8
<

8 9
Material

9 A
>

A B
(

B C
)

C D
;

D E
internal 
static 
int 
GetMaterialCount ,
(, -
Renderer- 5
renderer6 >
)> ?
{ 	
s_MaterialArray 
. 
Clear !
(! "
)" #
;# $
renderer 
. 
GetSharedMaterials '
(' (
s_MaterialArray( 7
)7 8
;8 9
return 
s_MaterialArray "
." #
Count# (
;( )
} 	
internal 
static 
Material  
GetSharedMaterial! 2
(2 3
Renderer3 ;
renderer< D
,D E
intF I
indexJ O
)O P
{ 	
s_MaterialArray 
. 
Clear !
(! "
)" #
;# $
renderer 
. 
GetSharedMaterials '
(' (
s_MaterialArray( 7
)7 8
;8 9
var 
count 
= 
s_MaterialArray '
.' (
Count( -
;- .
if 
( 
count 
< 
$num 
) 
return 
null 
; 
return   
s_MaterialArray   "
[  " #
Math  # '
.  ' (
Clamp  ( -
(  - .
index  . 3
,  3 4
$num  5 6
,  6 7
count  8 =
-  > ?
$num  @ A
)  A B
]  B C
;  C D
}(( 	
})) 
}** ªˆ
ãD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\WingedEdge.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

sealed 
class 

WingedEdge "
:# $

IEquatable% /
</ 0

WingedEdge0 :
>: ;
{ 
static 
readonly 

Dictionary "
<" #
Edge# '
,' (

WingedEdge) 3
>3 4$
k_OppositeEdgeDictionary5 M
=N O
newP S

DictionaryT ^
<^ _
Edge_ c
,c d

WingedEdgee o
>o p
(p q
)q r
;r s
public!! 

EdgeLookup!! 
edge!! 
{!!  
get!!! $
;!!$ %
private!!& -
set!!. 1
;!!1 2
}!!3 4
public&& 
Face&& 
face&& 
{&& 
get&& 
;&& 
private&&  '
set&&( +
;&&+ ,
}&&- .
public++ 

WingedEdge++ 
next++ 
{++  
get++! $
;++$ %
private++& -
set++. 1
;++1 2
}++3 4
public00 

WingedEdge00 
previous00 "
{00# $
get00% (
;00( )
private00* 1
set002 5
;005 6
}007 8
public55 

WingedEdge55 
opposite55 "
{55# $
get55% (
;55( )
private55* 1
set552 5
;555 6
}557 8

WingedEdge77 
(77 
)77 
{77 
}77 
public>> 
bool>> 
Equals>> 
(>> 

WingedEdge>> %
other>>& +
)>>+ ,
{?? 	
return@@ 
!@@ 
ReferenceEquals@@ #
(@@# $
other@@$ )
,@@) *
null@@+ /
)@@/ 0
&&@@1 3
edge@@4 8
.@@8 9
local@@9 >
.@@> ?
Equals@@? E
(@@E F
other@@F K
.@@K L
edge@@L P
.@@P Q
local@@Q V
)@@V W
;@@W X
}AA 	
publicHH 
overrideHH 
boolHH 
EqualsHH #
(HH# $
objectHH$ *
objHH+ .
)HH. /
{II 	

WingedEdgeJJ 
beJJ 
=JJ 
objJJ 
asJJ  "

WingedEdgeJJ# -
;JJ- .
ifLL 
(LL 
beLL 
!=LL 
nullLL 
&&LL 
thisLL "
.LL" #
EqualsLL# )
(LL) *
beLL* ,
)LL, -
)LL- .
returnMM 
trueMM 
;MM 
ifOO 
(OO 
objOO 
isOO 
EdgeOO 
&&OO 
thisOO #
.OO# $
edgeOO$ (
.OO( )
localOO) .
.OO. /
EqualsOO/ 5
(OO5 6
(OO6 7
EdgeOO7 ;
)OO; <
objOO< ?
)OO? @
)OO@ A
returnPP 
truePP 
;PP 
returnRR 
falseRR 
;RR 
}SS 	
publicYY 
overrideYY 
intYY 
GetHashCodeYY '
(YY' (
)YY( )
{ZZ 	
return[[ 
edge[[ 
.[[ 
local[[ 
.[[ 
GetHashCode[[ )
([[) *
)[[* +
;[[+ ,
}\\ 	
publicbb 
intbb 
Countbb 
(bb 
)bb 
{cc 	

WingedEdgedd 
currentdd 
=dd  
thisdd! %
;dd% &
intee 
countee 
=ee 
$numee 
;ee 
dogg 
{hh 
countii 
++ii 
;ii 
currentjj 
=jj 
currentjj !
.jj! "
nextjj" &
;jj& '
}kk 
whilell 
(ll 
currentll 
!=ll 
nullll "
&&ll# %
!ll& '
ReferenceEqualsll' 6
(ll6 7
currentll7 >
,ll> ?
thisll@ D
)llD E
)llE F
;llF G
returnnn 
countnn 
;nn 
}oo 	
publicrr 
overriderr 
stringrr 
ToStringrr '
(rr' (
)rr( )
{ss 	
returntt 
stringtt 
.tt 
Formattt  
(tt  !
$strtt! T
,ttT U
edgeuu 
.uu 
commonuu 
.uu 
ToStringuu $
(uu$ %
)uu% &
,uu& '
edgevv 
.vv 
localvv 
.vv 
ToStringvv #
(vv# $
)vv$ %
,vv% &
oppositeww 
==ww 
nullww  
?ww! "
$strww# )
:ww* +
oppositeww, 4
.ww4 5
edgeww5 9
.ww9 :
ToStringww: B
(wwB C
)wwC D
,wwD E
facexx 
.xx 
ToStringxx 
(xx 
)xx 
)xx  
;xx  !
}yy 	
internal
ÅÅ 
static
ÅÅ 
int
ÅÅ 
[
ÅÅ 
]
ÅÅ 
MakeQuad
ÅÅ &
(
ÅÅ& '

WingedEdge
ÅÅ' 1
left
ÅÅ2 6
,
ÅÅ6 7

WingedEdge
ÅÅ8 B
right
ÅÅC H
)
ÅÅH I
{
ÇÇ 	
if
ÑÑ 
(
ÑÑ 
left
ÑÑ 
.
ÑÑ 
Count
ÑÑ 
(
ÑÑ 
)
ÑÑ 
!=
ÑÑ 
$num
ÑÑ  !
||
ÑÑ" $
right
ÑÑ% *
.
ÑÑ* +
Count
ÑÑ+ 0
(
ÑÑ0 1
)
ÑÑ1 2
!=
ÑÑ3 5
$num
ÑÑ6 7
)
ÑÑ7 8
return
ÖÖ 
null
ÖÖ 
;
ÖÖ 

EdgeLookup
áá 
[
áá 
]
áá 
all
áá 
=
áá 
new
áá "

EdgeLookup
áá# -
[
áá- .
$num
áá. /
]
áá/ 0
{
àà 
left
ââ 
.
ââ 
edge
ââ 
,
ââ 
left
ää 
.
ää 
next
ää 
.
ää 
edge
ää 
,
ää 
left
ãã 
.
ãã 
next
ãã 
.
ãã 
next
ãã 
.
ãã 
edge
ãã #
,
ãã# $
right
åå 
.
åå 
edge
åå 
,
åå 
right
çç 
.
çç 
next
çç 
.
çç 
edge
çç 
,
çç  
right
éé 
.
éé 
next
éé 
.
éé 
next
éé 
.
éé  
edge
éé  $
}
èè 
;
èè 
int
ëë 
[
ëë 
]
ëë 
dup
ëë 
=
ëë 
new
ëë 
int
ëë 
[
ëë  
$num
ëë  !
]
ëë! "
;
ëë" #
int
íí 
matches
íí 
=
íí 
$num
íí 
;
íí 
for
îî 
(
îî 
int
îî 
i
îî 
=
îî 
$num
îî 
;
îî 
i
îî 
<
îî 
$num
îî  !
;
îî! "
i
îî# $
++
îî$ &
)
îî& '
{
ïï 
for
ññ 
(
ññ 
int
ññ 
n
ññ 
=
ññ 
$num
ññ 
;
ññ 
n
ññ  !
<
ññ" #
$num
ññ$ %
;
ññ% &
n
ññ' (
++
ññ( *
)
ññ* +
{
óó 
if
òò 
(
òò 
all
òò 
[
òò 
i
òò 
]
òò 
.
òò 
Equals
òò %
(
òò% &
all
òò& )
[
òò) *
n
òò* +
]
òò+ ,
)
òò, -
)
òò- .
{
ôô 
matches
öö 
++
öö !
;
öö! "
dup
õõ 
[
õõ 
i
õõ 
]
õõ 
=
õõ  
$num
õõ! "
;
õõ" #
dup
úú 
[
úú 
n
úú 
]
úú 
=
úú  
$num
úú! "
;
úú" #
break
ùù 
;
ùù 
}
ûû 
}
üü 
}
†† 
if
££ 
(
££ 
matches
££ 
!=
££ 
$num
££ 
)
££ 
return
§§ 
null
§§ 
;
§§ 
int
¶¶ 
qi
¶¶ 
=
¶¶ 
$num
¶¶ 
;
¶¶ 

EdgeLookup
®® 
[
®® 
]
®® 
edges
®® 
=
®®  
new
®®! $

EdgeLookup
®®% /
[
®®/ 0
$num
®®0 1
]
®®1 2
;
®®2 3
for
™™ 
(
™™ 
int
™™ 
i
™™ 
=
™™ 
$num
™™ 
;
™™ 
i
™™ 
<
™™ 
$num
™™  !
;
™™! "
i
™™# $
++
™™$ &
)
™™& '
if
´´ 
(
´´ 
dup
´´ 
[
´´ 
i
´´ 
]
´´ 
<
´´ 
$num
´´ 
)
´´ 
edges
¨¨ 
[
¨¨ 
qi
¨¨ 
++
¨¨ 
]
¨¨ 
=
¨¨  !
all
¨¨" %
[
¨¨% &
i
¨¨& '
]
¨¨' (
;
¨¨( )
int
ÆÆ 
[
ÆÆ 
]
ÆÆ 
quad
ÆÆ 
=
ÆÆ 
new
ÆÆ 
int
ÆÆ  
[
ÆÆ  !
$num
ÆÆ! "
]
ÆÆ" #
{
ÆÆ$ %
edges
ÆÆ& +
[
ÆÆ+ ,
$num
ÆÆ, -
]
ÆÆ- .
.
ÆÆ. /
local
ÆÆ/ 4
.
ÆÆ4 5
a
ÆÆ5 6
,
ÆÆ6 7
edges
ÆÆ8 =
[
ÆÆ= >
$num
ÆÆ> ?
]
ÆÆ? @
.
ÆÆ@ A
local
ÆÆA F
.
ÆÆF G
b
ÆÆG H
,
ÆÆH I
-
ÆÆJ K
$num
ÆÆK L
,
ÆÆL M
-
ÆÆN O
$num
ÆÆO P
}
ÆÆQ R
;
ÆÆR S
int
∞∞ 
c1
∞∞ 
=
∞∞ 
edges
∞∞ 
[
∞∞ 
$num
∞∞ 
]
∞∞ 
.
∞∞ 
common
∞∞ $
.
∞∞$ %
b
∞∞% &
,
∞∞& '
c2
∞∞( *
=
∞∞+ ,
-
∞∞- .
$num
∞∞. /
;
∞∞/ 0
if
≤≤ 
(
≤≤ 
edges
≤≤ 
[
≤≤ 
$num
≤≤ 
]
≤≤ 
.
≤≤ 
common
≤≤ 
.
≤≤  
a
≤≤  !
==
≤≤" $
c1
≤≤% '
)
≤≤' (
{
≥≥ 
quad
¥¥ 
[
¥¥ 
$num
¥¥ 
]
¥¥ 
=
¥¥ 
edges
¥¥ 
[
¥¥  
$num
¥¥  !
]
¥¥! "
.
¥¥" #
local
¥¥# (
.
¥¥( )
b
¥¥) *
;
¥¥* +
c2
µµ 
=
µµ 
edges
µµ 
[
µµ 
$num
µµ 
]
µµ 
.
µµ 
common
µµ $
.
µµ$ %
b
µµ% &
;
µµ& '
}
∂∂ 
else
∑∑ 
if
∑∑ 
(
∑∑ 
edges
∑∑ 
[
∑∑ 
$num
∑∑ 
]
∑∑ 
.
∑∑ 
common
∑∑ $
.
∑∑$ %
a
∑∑% &
==
∑∑' )
c1
∑∑* ,
)
∑∑, -
{
∏∏ 
quad
ππ 
[
ππ 
$num
ππ 
]
ππ 
=
ππ 
edges
ππ 
[
ππ  
$num
ππ  !
]
ππ! "
.
ππ" #
local
ππ# (
.
ππ( )
b
ππ) *
;
ππ* +
c2
∫∫ 
=
∫∫ 
edges
∫∫ 
[
∫∫ 
$num
∫∫ 
]
∫∫ 
.
∫∫ 
common
∫∫ $
.
∫∫$ %
b
∫∫% &
;
∫∫& '
}
ªª 
else
ºº 
if
ºº 
(
ºº 
edges
ºº 
[
ºº 
$num
ºº 
]
ºº 
.
ºº 
common
ºº $
.
ºº$ %
a
ºº% &
==
ºº' )
c1
ºº* ,
)
ºº, -
{
ΩΩ 
quad
ææ 
[
ææ 
$num
ææ 
]
ææ 
=
ææ 
edges
ææ 
[
ææ  
$num
ææ  !
]
ææ! "
.
ææ" #
local
ææ# (
.
ææ( )
b
ææ) *
;
ææ* +
c2
øø 
=
øø 
edges
øø 
[
øø 
$num
øø 
]
øø 
.
øø 
common
øø $
.
øø$ %
b
øø% &
;
øø& '
}
¿¿ 
if
¬¬ 
(
¬¬ 
edges
¬¬ 
[
¬¬ 
$num
¬¬ 
]
¬¬ 
.
¬¬ 
common
¬¬ 
.
¬¬  
a
¬¬  !
==
¬¬" $
c2
¬¬% '
)
¬¬' (
quad
√√ 
[
√√ 
$num
√√ 
]
√√ 
=
√√ 
edges
√√ 
[
√√  
$num
√√  !
]
√√! "
.
√√" #
local
√√# (
.
√√( )
b
√√) *
;
√√* +
else
ƒƒ 
if
ƒƒ 
(
ƒƒ 
edges
ƒƒ 
[
ƒƒ 
$num
ƒƒ 
]
ƒƒ 
.
ƒƒ 
common
ƒƒ $
.
ƒƒ$ %
a
ƒƒ% &
==
ƒƒ' )
c2
ƒƒ* ,
)
ƒƒ, -
quad
≈≈ 
[
≈≈ 
$num
≈≈ 
]
≈≈ 
=
≈≈ 
edges
≈≈ 
[
≈≈  
$num
≈≈  !
]
≈≈! "
.
≈≈" #
local
≈≈# (
.
≈≈( )
b
≈≈) *
;
≈≈* +
else
∆∆ 
if
∆∆ 
(
∆∆ 
edges
∆∆ 
[
∆∆ 
$num
∆∆ 
]
∆∆ 
.
∆∆ 
common
∆∆ $
.
∆∆$ %
a
∆∆% &
==
∆∆' )
c2
∆∆* ,
)
∆∆, -
quad
«« 
[
«« 
$num
«« 
]
«« 
=
«« 
edges
«« 
[
««  
$num
««  !
]
««! "
.
««" #
local
««# (
.
««( )
b
««) *
;
««* +
if
…… 
(
…… 
quad
…… 
[
…… 
$num
…… 
]
…… 
==
…… 
-
…… 
$num
…… 
||
……  
quad
……! %
[
……% &
$num
……& '
]
……' (
==
……) +
-
……, -
$num
……- .
)
……. /
return
   
null
   
;
   
return
ÃÃ 
quad
ÃÃ 
;
ÃÃ 
}
ÕÕ 	
public
‘‘ 

WingedEdge
‘‘ ,
GetAdjacentEdgeWithCommonIndex
‘‘ 8
(
‘‘8 9
int
‘‘9 <
common
‘‘= C
)
‘‘C D
{
’’ 	
if
÷÷ 
(
÷÷ 
next
÷÷ 
.
÷÷ 
edge
÷÷ 
.
÷÷ 
common
÷÷  
.
÷÷  !
Contains
÷÷! )
(
÷÷) *
common
÷÷* 0
)
÷÷0 1
)
÷÷1 2
return
◊◊ 
next
◊◊ 
;
◊◊ 
else
ÿÿ 
if
ÿÿ 
(
ÿÿ 
previous
ÿÿ 
.
ÿÿ 
edge
ÿÿ "
.
ÿÿ" #
common
ÿÿ# )
.
ÿÿ) *
Contains
ÿÿ* 2
(
ÿÿ2 3
common
ÿÿ3 9
)
ÿÿ9 :
)
ÿÿ: ;
return
ŸŸ 
previous
ŸŸ 
;
ŸŸ  
return
€€ 
null
€€ 
;
€€ 
}
‹‹ 	
public
‰‰ 
static
‰‰ 
List
‰‰ 
<
‰‰ 
Edge
‰‰ 
>
‰‰  "
SortEdgesByAdjacency
‰‰! 5
(
‰‰5 6
Face
‰‰6 :
face
‰‰; ?
)
‰‰? @
{
ÂÂ 	
if
ÊÊ 
(
ÊÊ 
face
ÊÊ 
==
ÊÊ 
null
ÊÊ 
||
ÊÊ 
face
ÊÊ  $
.
ÊÊ$ %
edgesInternal
ÊÊ% 2
==
ÊÊ3 5
null
ÊÊ6 :
)
ÊÊ: ;
throw
ÁÁ 
new
ÁÁ #
ArgumentNullException
ÁÁ /
(
ÁÁ/ 0
$str
ÁÁ0 6
)
ÁÁ6 7
;
ÁÁ7 8
List
ËË 
<
ËË 
Edge
ËË 
>
ËË 
edges
ËË 
=
ËË 
new
ËË "
List
ËË# '
<
ËË' (
Edge
ËË( ,
>
ËË, -
(
ËË- .
face
ËË. 2
.
ËË2 3
edgesInternal
ËË3 @
)
ËË@ A
;
ËËA B"
SortEdgesByAdjacency
ÈÈ  
(
ÈÈ  !
edges
ÈÈ! &
)
ÈÈ& '
;
ÈÈ' (
return
ÍÍ 
edges
ÍÍ 
;
ÍÍ 
}
ÎÎ 	
public
ÒÒ 
static
ÒÒ 
void
ÒÒ "
SortEdgesByAdjacency
ÒÒ /
(
ÒÒ/ 0
List
ÒÒ0 4
<
ÒÒ4 5
Edge
ÒÒ5 9
>
ÒÒ9 :
edges
ÒÒ; @
)
ÒÒ@ A
{
ÚÚ 	
if
ÛÛ 
(
ÛÛ 
edges
ÛÛ 
==
ÛÛ 
null
ÛÛ 
)
ÛÛ 
throw
ÙÙ 
new
ÙÙ #
ArgumentNullException
ÙÙ /
(
ÙÙ/ 0
$str
ÙÙ0 7
)
ÙÙ7 8
;
ÙÙ8 9
for
ˆˆ 
(
ˆˆ 
int
ˆˆ 
i
ˆˆ 
=
ˆˆ 
$num
ˆˆ 
;
ˆˆ 
i
ˆˆ 
<
ˆˆ 
edges
ˆˆ  %
.
ˆˆ% &
Count
ˆˆ& +
;
ˆˆ+ ,
i
ˆˆ- .
++
ˆˆ. 0
)
ˆˆ0 1
{
˜˜ 
int
¯¯ 
want
¯¯ 
=
¯¯ 
edges
¯¯  
[
¯¯  !
i
¯¯! "
-
¯¯# $
$num
¯¯% &
]
¯¯& '
.
¯¯' (
b
¯¯( )
;
¯¯) *
for
˙˙ 
(
˙˙ 
int
˙˙ 
n
˙˙ 
=
˙˙ 
i
˙˙ 
+
˙˙  
$num
˙˙! "
;
˙˙" #
n
˙˙$ %
<
˙˙& '
edges
˙˙( -
.
˙˙- .
Count
˙˙. 3
;
˙˙3 4
n
˙˙5 6
++
˙˙6 8
)
˙˙8 9
{
˚˚ 
if
¸¸ 
(
¸¸ 
edges
¸¸ 
[
¸¸ 
n
¸¸ 
]
¸¸  
.
¸¸  !
a
¸¸! "
==
¸¸# %
want
¸¸& *
||
¸¸+ -
edges
¸¸. 3
[
¸¸3 4
n
¸¸4 5
]
¸¸5 6
.
¸¸6 7
b
¸¸7 8
==
¸¸9 ;
want
¸¸< @
)
¸¸@ A
{
˝˝ 
Edge
˛˛ 
swap
˛˛ !
=
˛˛" #
edges
˛˛$ )
[
˛˛) *
n
˛˛* +
]
˛˛+ ,
;
˛˛, -
edges
ˇˇ 
[
ˇˇ 
n
ˇˇ 
]
ˇˇ  
=
ˇˇ! "
edges
ˇˇ# (
[
ˇˇ( )
i
ˇˇ) *
]
ˇˇ* +
;
ˇˇ+ ,
edges
ÄÄ 
[
ÄÄ 
i
ÄÄ 
]
ÄÄ  
=
ÄÄ! "
swap
ÄÄ# '
;
ÄÄ' (
}
ÅÅ 
}
ÇÇ 
}
ÉÉ 
}
ÑÑ 	
public
ãã 
static
ãã 

Dictionary
ãã  
<
ãã  !
int
ãã! $
,
ãã$ %
List
ãã& *
<
ãã* +

WingedEdge
ãã+ 5
>
ãã5 6
>
ãã6 7
	GetSpokes
ãã8 A
(
ããA B
List
ããB F
<
ããF G

WingedEdge
ããG Q
>
ããQ R
wings
ããS X
)
ããX Y
{
åå 	
if
çç 
(
çç 
wings
çç 
==
çç 
null
çç 
)
çç 
throw
éé 
new
éé #
ArgumentNullException
éé /
(
éé/ 0
$str
éé0 7
)
éé7 8
;
éé8 9

Dictionary
êê 
<
êê 
int
êê 
,
êê 
List
êê  
<
êê  !

WingedEdge
êê! +
>
êê+ ,
>
êê, -
spokes
êê. 4
=
êê5 6
new
êê7 :

Dictionary
êê; E
<
êêE F
int
êêF I
,
êêI J
List
êêK O
<
êêO P

WingedEdge
êêP Z
>
êêZ [
>
êê[ \
(
êê\ ]
)
êê] ^
;
êê^ _
List
ëë 
<
ëë 

WingedEdge
ëë 
>
ëë 
l
ëë 
=
ëë  
null
ëë! %
;
ëë% &
for
ìì 
(
ìì 
int
ìì 
i
ìì 
=
ìì 
$num
ìì 
;
ìì 
i
ìì 
<
ìì 
wings
ìì  %
.
ìì% &
Count
ìì& +
;
ìì+ ,
i
ìì- .
++
ìì. 0
)
ìì0 1
{
îî 
if
ïï 
(
ïï 
spokes
ïï 
.
ïï 
TryGetValue
ïï &
(
ïï& '
wings
ïï' ,
[
ïï, -
i
ïï- .
]
ïï. /
.
ïï/ 0
edge
ïï0 4
.
ïï4 5
common
ïï5 ;
.
ïï; <
a
ïï< =
,
ïï= >
out
ïï? B
l
ïïC D
)
ïïD E
)
ïïE F
l
ññ 
.
ññ 
Add
ññ 
(
ññ 
wings
ññ 
[
ññ  
i
ññ  !
]
ññ! "
)
ññ" #
;
ññ# $
else
óó 
spokes
òò 
.
òò 
Add
òò 
(
òò 
wings
òò $
[
òò$ %
i
òò% &
]
òò& '
.
òò' (
edge
òò( ,
.
òò, -
common
òò- 3
.
òò3 4
a
òò4 5
,
òò5 6
new
òò7 :
List
òò; ?
<
òò? @

WingedEdge
òò@ J
>
òòJ K
(
òòK L
)
òòL M
{
òòN O
wings
òòP U
[
òòU V
i
òòV W
]
òòW X
}
òòY Z
)
òòZ [
;
òò[ \
if
öö 
(
öö 
spokes
öö 
.
öö 
TryGetValue
öö &
(
öö& '
wings
öö' ,
[
öö, -
i
öö- .
]
öö. /
.
öö/ 0
edge
öö0 4
.
öö4 5
common
öö5 ;
.
öö; <
b
öö< =
,
öö= >
out
öö? B
l
ööC D
)
ööD E
)
ööE F
l
õõ 
.
õõ 
Add
õõ 
(
õõ 
wings
õõ 
[
õõ  
i
õõ  !
]
õõ! "
)
õõ" #
;
õõ# $
else
úú 
spokes
ùù 
.
ùù 
Add
ùù 
(
ùù 
wings
ùù $
[
ùù$ %
i
ùù% &
]
ùù& '
.
ùù' (
edge
ùù( ,
.
ùù, -
common
ùù- 3
.
ùù3 4
b
ùù4 5
,
ùù5 6
new
ùù7 :
List
ùù; ?
<
ùù? @

WingedEdge
ùù@ J
>
ùùJ K
(
ùùK L
)
ùùL M
{
ùùN O
wings
ùùP U
[
ùùU V
i
ùùV W
]
ùùW X
}
ùùY Z
)
ùùZ [
;
ùù[ \
}
ûû 
return
†† 
spokes
†† 
;
†† 
}
°° 	
internal
´´ 
static
´´ 
List
´´ 
<
´´ 
int
´´  
>
´´  !*
SortCommonIndexesByAdjacency
´´" >
(
´´> ?
List
´´? C
<
´´C D

WingedEdge
´´D N
>
´´N O
wings
´´P U
,
´´U V
HashSet
´´W ^
<
´´^ _
int
´´_ b
>
´´b c
common
´´d j
)
´´j k
{
¨¨ 	
List
≠≠ 
<
≠≠ 
Edge
≠≠ 
>
≠≠ 
matches
≠≠ 
=
≠≠  
wings
≠≠! &
.
≠≠& '
Where
≠≠' ,
(
≠≠, -
x
≠≠- .
=>
≠≠/ 1
common
≠≠2 8
.
≠≠8 9
Contains
≠≠9 A
(
≠≠A B
x
≠≠B C
.
≠≠C D
edge
≠≠D H
.
≠≠H I
common
≠≠I O
.
≠≠O P
a
≠≠P Q
)
≠≠Q R
&&
≠≠S U
common
≠≠V \
.
≠≠\ ]
Contains
≠≠] e
(
≠≠e f
x
≠≠f g
.
≠≠g h
edge
≠≠h l
.
≠≠l m
common
≠≠m s
.
≠≠s t
b
≠≠t u
)
≠≠u v
)
≠≠v w
.
≠≠w x
Select
≠≠x ~
(
≠≠~ 
y≠≠ Ä
=>≠≠Å É
y≠≠Ñ Ö
.≠≠Ö Ü
edge≠≠Ü ä
.≠≠ä ã
common≠≠ã ë
)≠≠ë í
.≠≠í ì
ToList≠≠ì ô
(≠≠ô ö
)≠≠ö õ
;≠≠õ ú
if
∞∞ 
(
∞∞ 
matches
∞∞ 
.
∞∞ 
Count
∞∞ 
!=
∞∞  
common
∞∞! '
.
∞∞' (
Count
∞∞( -
)
∞∞- .
return
±± 
null
±± 
;
±± "
SortEdgesByAdjacency
≥≥  
(
≥≥  !
matches
≥≥! (
)
≥≥( )
;
≥≥) *
return
¥¥ 
matches
¥¥ 
.
¥¥ 
Select
¥¥ !
(
¥¥! "
x
¥¥" #
=>
¥¥$ &
x
¥¥' (
.
¥¥( )
a
¥¥) *
)
¥¥* +
.
¥¥+ ,
ToList
¥¥, 2
(
¥¥2 3
)
¥¥3 4
;
¥¥4 5
}
µµ 	
public
ΩΩ 
static
ΩΩ 
List
ΩΩ 
<
ΩΩ 

WingedEdge
ΩΩ %
>
ΩΩ% &
GetWingedEdges
ΩΩ' 5
(
ΩΩ5 6
ProBuilderMesh
ΩΩ6 D
mesh
ΩΩE I
,
ΩΩI J
bool
ΩΩK O
oneWingPerFace
ΩΩP ^
=
ΩΩ_ `
false
ΩΩa f
)
ΩΩf g
{
ææ 	
if
øø 
(
øø 
mesh
øø 
==
øø 
null
øø 
)
øø 
throw
¿¿ 
new
¿¿ #
ArgumentNullException
¿¿ /
(
¿¿/ 0
$str
¿¿0 6
)
¿¿6 7
;
¿¿7 8
return
¬¬ 
GetWingedEdges
¬¬ !
(
¬¬! "
mesh
¬¬" &
,
¬¬& '
mesh
¬¬( ,
.
¬¬, -
facesInternal
¬¬- :
,
¬¬: ;
oneWingPerFace
¬¬< J
)
¬¬J K
;
¬¬K L
}
√√ 	
public
ÃÃ 
static
ÃÃ 
List
ÃÃ 
<
ÃÃ 

WingedEdge
ÃÃ %
>
ÃÃ% &
GetWingedEdges
ÃÃ' 5
(
ÃÃ5 6
ProBuilderMesh
ÃÃ6 D
mesh
ÃÃE I
,
ÃÃI J
IEnumerable
ÃÃK V
<
ÃÃV W
Face
ÃÃW [
>
ÃÃ[ \
faces
ÃÃ] b
,
ÃÃb c
bool
ÃÃd h
oneWingPerFace
ÃÃi w
=
ÃÃx y
false
ÃÃz 
)ÃÃ Ä
{
ÕÕ 	
if
ŒŒ 
(
ŒŒ 
mesh
ŒŒ 
==
ŒŒ 
null
ŒŒ 
)
ŒŒ 
throw
œœ 
new
œœ #
ArgumentNullException
œœ /
(
œœ/ 0
$str
œœ0 6
)
œœ6 7
;
œœ7 8
var
—— 
lookup
—— 
=
—— 
mesh
—— 
.
——  
sharedVertexLookup
—— 0
;
——0 1
List
”” 
<
”” 

WingedEdge
”” 
>
”” 
winged
”” #
=
””$ %
new
””& )
List
””* .
<
””. /

WingedEdge
””/ 9
>
””9 :
(
””: ;
)
””; <
;
””< =&
k_OppositeEdgeDictionary
‘‘ $
.
‘‘$ %
Clear
‘‘% *
(
‘‘* +
)
‘‘+ ,
;
‘‘, -
foreach
÷÷ 
(
÷÷ 
Face
÷÷ 
f
÷÷ 
in
÷÷ 
faces
÷÷ $
)
÷÷$ %
{
◊◊ 
List
ÿÿ 
<
ÿÿ 
Edge
ÿÿ 
>
ÿÿ 
edges
ÿÿ  
=
ÿÿ! ""
SortEdgesByAdjacency
ÿÿ# 7
(
ÿÿ7 8
f
ÿÿ8 9
)
ÿÿ9 :
;
ÿÿ: ;
int
ŸŸ 

edgeLength
ŸŸ 
=
ŸŸ  
edges
ŸŸ! &
.
ŸŸ& '
Count
ŸŸ' ,
;
ŸŸ, -

WingedEdge
⁄⁄ 
first
⁄⁄  
=
⁄⁄! "
null
⁄⁄# '
,
⁄⁄' (
prev
⁄⁄) -
=
⁄⁄. /
null
⁄⁄0 4
;
⁄⁄4 5
for
‹‹ 
(
‹‹ 
int
‹‹ 
n
‹‹ 
=
‹‹ 
$num
‹‹ 
;
‹‹ 
n
‹‹  !
<
‹‹" #

edgeLength
‹‹$ .
;
‹‹. /
n
‹‹0 1
++
‹‹1 3
)
‹‹3 4
{
›› 
Edge
ﬁﬁ 
e
ﬁﬁ 
=
ﬁﬁ 
edges
ﬁﬁ "
[
ﬁﬁ" #
n
ﬁﬁ# $
]
ﬁﬁ$ %
;
ﬁﬁ% &

WingedEdge
‡‡ 
w
‡‡  
=
‡‡! "
new
‡‡# &

WingedEdge
‡‡' 1
(
‡‡1 2
)
‡‡2 3
;
‡‡3 4
w
·· 
.
·· 
edge
·· 
=
·· 
new
··  

EdgeLookup
··! +
(
··+ ,
lookup
··, 2
[
··2 3
e
··3 4
.
··4 5
a
··5 6
]
··6 7
,
··7 8
lookup
··9 ?
[
··? @
e
··@ A
.
··A B
b
··B C
]
··C D
,
··D E
e
··F G
.
··G H
a
··H I
,
··I J
e
··K L
.
··L M
b
··M N
)
··N O
;
··O P
w
‚‚ 
.
‚‚ 
face
‚‚ 
=
‚‚ 
f
‚‚ 
;
‚‚ 
if
„„ 
(
„„ 
n
„„ 
<
„„ 
$num
„„ 
)
„„ 
first
‰‰ 
=
‰‰ 
w
‰‰  !
;
‰‰! "
if
ÊÊ 
(
ÊÊ 
n
ÊÊ 
>
ÊÊ 
$num
ÊÊ 
)
ÊÊ 
{
ÁÁ 
w
ËË 
.
ËË 
previous
ËË "
=
ËË# $
prev
ËË% )
;
ËË) *
prev
ÈÈ 
.
ÈÈ 
next
ÈÈ !
=
ÈÈ" #
w
ÈÈ$ %
;
ÈÈ% &
}
ÍÍ 
if
ÏÏ 
(
ÏÏ 
n
ÏÏ 
==
ÏÏ 

edgeLength
ÏÏ '
-
ÏÏ( )
$num
ÏÏ* +
)
ÏÏ+ ,
{
ÌÌ 
w
ÓÓ 
.
ÓÓ 
next
ÓÓ 
=
ÓÓ  
first
ÓÓ! &
;
ÓÓ& '
first
ÔÔ 
.
ÔÔ 
previous
ÔÔ &
=
ÔÔ' (
w
ÔÔ) *
;
ÔÔ* +
}
 
prev
ÚÚ 
=
ÚÚ 
w
ÚÚ 
;
ÚÚ 

WingedEdge
ÙÙ 
opp
ÙÙ "
;
ÙÙ" #
if
ˆˆ 
(
ˆˆ &
k_OppositeEdgeDictionary
ˆˆ 0
.
ˆˆ0 1
TryGetValue
ˆˆ1 <
(
ˆˆ< =
w
ˆˆ= >
.
ˆˆ> ?
edge
ˆˆ? C
.
ˆˆC D
common
ˆˆD J
,
ˆˆJ K
out
ˆˆL O
opp
ˆˆP S
)
ˆˆS T
)
ˆˆT U
{
˜˜ 
opp
¯¯ 
.
¯¯ 
opposite
¯¯ $
=
¯¯% &
w
¯¯' (
;
¯¯( )
w
˘˘ 
.
˘˘ 
opposite
˘˘ "
=
˘˘# $
opp
˘˘% (
;
˘˘( )
}
˙˙ 
else
˚˚ 
{
¸¸ 
w
˝˝ 
.
˝˝ 
opposite
˝˝ "
=
˝˝# $
null
˝˝% )
;
˝˝) *&
k_OppositeEdgeDictionary
˛˛ 0
.
˛˛0 1
Add
˛˛1 4
(
˛˛4 5
w
˛˛5 6
.
˛˛6 7
edge
˛˛7 ;
.
˛˛; <
common
˛˛< B
,
˛˛B C
w
˛˛D E
)
˛˛E F
;
˛˛F G
}
ˇˇ 
if
ÅÅ 
(
ÅÅ 
!
ÅÅ 
oneWingPerFace
ÅÅ '
||
ÅÅ( *
n
ÅÅ+ ,
<
ÅÅ- .
$num
ÅÅ/ 0
)
ÅÅ0 1
winged
ÇÇ 
.
ÇÇ 
Add
ÇÇ "
(
ÇÇ" #
w
ÇÇ# $
)
ÇÇ$ %
;
ÇÇ% &
}
ÉÉ 
}
ÑÑ 
return
ÜÜ 
winged
ÜÜ 
;
ÜÜ 
}
áá 	
}
àà 
}ââ Ä[
ÖD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Edge.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[

 
System

 
.

 
Serializable

 
]

 
public 

struct 
Edge 
: 
System 
.  

IEquatable  *
<* +
Edge+ /
>/ 0
{ 
public 
int 
a 
; 
public 
int 
b 
; 
public 
static 
readonly 
Edge #
Empty$ )
=* +
new, /
Edge0 4
(4 5
-5 6
$num6 7
,7 8
-9 :
$num: ;
); <
;< =
public!! 
Edge!! 
(!! 
int!! 
a!! 
,!! 
int!! 
b!!  
)!!  !
{"" 	
this## 
.## 
a## 
=## 
a## 
;## 
this$$ 
.$$ 
b$$ 
=$$ 
b$$ 
;$$ 
}%% 	
public++ 
bool++ 
IsValid++ 
(++ 
)++ 
{,, 	
return-- 
a-- 
>-- 
--- 
$num-- 
&&-- 
b-- 
>--  
---! "
$num--" #
&&--$ &
a--' (
!=--) +
b--, -
;--- .
}.. 	
public00 
override00 
string00 
ToString00 '
(00' (
)00( )
{11 	
return22 
$str22 
+22 
a22 
+22 
$str22 !
+22" #
b22$ %
+22& '
$str22( +
;22+ ,
}33 	
public55 
bool55 
Equals55 
(55 
Edge55 
other55  %
)55% &
{66 	
return77 
(77 
a77 
==77 
other77 
.77 
a77  
&&77! #
b77$ %
==77& (
other77) .
.77. /
b77/ 0
)770 1
||772 4
(775 6
a776 7
==778 :
other77; @
.77@ A
b77A B
&&77C E
b77F G
==77H J
other77K P
.77P Q
a77Q R
)77R S
;77S T
}88 	
public:: 
override:: 
bool:: 
Equals:: #
(::# $
object::$ *
obj::+ .
)::. /
{;; 	
return<< 
obj<< 
is<< 
Edge<< 
&&<< !
Equals<<" (
(<<( )
(<<) *
Edge<<* .
)<<. /
obj<</ 2
)<<2 3
;<<3 4
}== 	
public?? 
override?? 
int?? 
GetHashCode?? '
(??' (
)??( )
{@@ 	
intBB 
hashBB 
=BB 
$numBB 
;BB 
	uncheckedDD 
{EE 
hashFF 
=FF 
hashFF 
*FF 
$numFF  
+FF! "
(FF# $
aFF$ %
<FF& '
bFF( )
?FF* +
aFF, -
:FF. /
bFF0 1
)FF1 2
;FF2 3
hashGG 
=GG 
hashGG 
*GG 
$numGG  
+GG! "
(GG# $
aGG$ %
<GG& '
bGG( )
?GG* +
bGG, -
:GG. /
aGG0 1
)GG1 2
;GG2 3
}HH 
returnJJ 
hashJJ 
;JJ 
}KK 	
publicMM 
staticMM 
EdgeMM 
operatorMM #
+MM# $
(MM$ %
EdgeMM% )
aMM* +
,MM+ ,
EdgeMM- 1
bMM2 3
)MM3 4
{NN 	
returnOO 
newOO 
EdgeOO 
(OO 
aOO 
.OO 
aOO 
+OO  !
bOO" #
.OO# $
aOO$ %
,OO% &
aOO' (
.OO( )
bOO) *
+OO+ ,
bOO- .
.OO. /
bOO/ 0
)OO0 1
;OO1 2
}PP 	
publicRR 
staticRR 
EdgeRR 
operatorRR #
-RR# $
(RR$ %
EdgeRR% )
aRR* +
,RR+ ,
EdgeRR- 1
bRR2 3
)RR3 4
{SS 	
returnTT 
newTT 
EdgeTT 
(TT 
aTT 
.TT 
aTT 
-TT  !
bTT" #
.TT# $
aTT$ %
,TT% &
aTT' (
.TT( )
bTT) *
-TT+ ,
bTT- .
.TT. /
bTT/ 0
)TT0 1
;TT1 2
}UU 	
publicWW 
staticWW 
EdgeWW 
operatorWW #
+WW# $
(WW$ %
EdgeWW% )
aWW* +
,WW+ ,
intWW- 0
bWW1 2
)WW2 3
{XX 	
returnYY 
newYY 
EdgeYY 
(YY 
aYY 
.YY 
aYY 
+YY  !
bYY" #
,YY# $
aYY% &
.YY& '
bYY' (
+YY) *
bYY+ ,
)YY, -
;YY- .
}ZZ 	
public\\ 
static\\ 
Edge\\ 
operator\\ #
-\\# $
(\\$ %
Edge\\% )
a\\* +
,\\+ ,
int\\- 0
b\\1 2
)\\2 3
{]] 	
return^^ 
new^^ 
Edge^^ 
(^^ 
a^^ 
.^^ 
a^^ 
-^^  !
b^^" #
,^^# $
a^^% &
.^^& '
b^^' (
-^^) *
b^^+ ,
)^^, -
;^^- .
}__ 	
publicaa 
staticaa 
boolaa 
operatoraa #
==aa# %
(aa% &
Edgeaa& *
aaa+ ,
,aa, -
Edgeaa. 2
baa3 4
)aa4 5
{bb 	
returncc 
acc 
.cc 
Equalscc 
(cc 
bcc 
)cc 
;cc 
}dd 	
publicff 
staticff 
boolff 
operatorff #
!=ff# %
(ff% &
Edgeff& *
aff+ ,
,ff, -
Edgeff. 2
bff3 4
)ff4 5
{gg 	
returnhh 
!hh 
(hh 
ahh 
==hh 
bhh 
)hh 
;hh 
}ii 	
publictt 
statictt 
Edgett 
Addtt 
(tt 
Edgett #
att$ %
,tt% &
Edgett' +
btt, -
)tt- .
{uu 	
returnvv 
avv 
+vv 
bvv 
;vv 
}ww 	
public
ÇÇ 
static
ÇÇ 
Edge
ÇÇ 
Subtract
ÇÇ #
(
ÇÇ# $
Edge
ÇÇ$ (
a
ÇÇ) *
,
ÇÇ* +
Edge
ÇÇ, 0
b
ÇÇ1 2
)
ÇÇ2 3
{
ÉÉ 	
return
ÑÑ 
a
ÑÑ 
-
ÑÑ 
b
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
public
éé 
bool
éé 
Equals
éé 
(
éé 
Edge
éé 
other
éé  %
,
éé% &

Dictionary
éé' 1
<
éé1 2
int
éé2 5
,
éé5 6
int
éé7 :
>
éé: ;
lookup
éé< B
)
ééB C
{
èè 	
if
êê 
(
êê 
lookup
êê 
==
êê 
null
êê 
)
êê 
return
ëë 
Equals
ëë 
(
ëë 
other
ëë #
)
ëë# $
;
ëë$ %
int
íí 
x0
íí 
=
íí 
lookup
íí 
[
íí 
a
íí 
]
íí 
,
íí 
y0
íí  "
=
íí# $
lookup
íí% +
[
íí+ ,
b
íí, -
]
íí- .
,
íí. /
x1
íí0 2
=
íí3 4
lookup
íí5 ;
[
íí; <
other
íí< A
.
ííA B
a
ííB C
]
ííC D
,
ííD E
y1
ííF H
=
ííI J
lookup
ííK Q
[
ííQ R
other
ííR W
.
ííW X
b
ííX Y
]
ííY Z
;
ííZ [
return
ìì 
(
ìì 
x0
ìì 
==
ìì 
x1
ìì 
&&
ìì 
y0
ìì  "
==
ìì# %
y1
ìì& (
)
ìì( )
||
ìì* ,
(
ìì- .
x0
ìì. 0
==
ìì1 3
y1
ìì4 6
&&
ìì7 9
y0
ìì: <
==
ìì= ?
x1
ìì@ B
)
ììB C
;
ììC D
}
îî 	
public
õõ 
bool
õõ 
Contains
õõ 
(
õõ 
int
õõ  
index
õõ! &
)
õõ& '
{
úú 	
return
ùù 
(
ùù 
a
ùù 
==
ùù 
index
ùù 
||
ùù !
b
ùù" #
==
ùù$ &
index
ùù' ,
)
ùù, -
;
ùù- .
}
ûû 	
public
•• 
bool
•• 
Contains
•• 
(
•• 
Edge
•• !
other
••" '
)
••' (
{
¶¶ 	
return
ßß 
(
ßß 
a
ßß 
==
ßß 
other
ßß 
.
ßß 
a
ßß  
||
ßß! #
b
ßß$ %
==
ßß& (
other
ßß) .
.
ßß. /
a
ßß/ 0
||
ßß1 3
a
ßß4 5
==
ßß6 8
other
ßß9 >
.
ßß> ?
b
ßß? @
||
ßßA C
b
ßßD E
==
ßßF H
other
ßßI N
.
ßßN O
a
ßßO P
)
ßßP Q
;
ßßQ R
}
®® 	
internal
™™ 
bool
™™ 
Contains
™™ 
(
™™ 
int
™™ "
index
™™# (
,
™™( )

Dictionary
™™* 4
<
™™4 5
int
™™5 8
,
™™8 9
int
™™: =
>
™™= >
lookup
™™? E
)
™™E F
{
´´ 	
var
¨¨ 
common
¨¨ 
=
¨¨ 
lookup
¨¨ 
[
¨¨  
index
¨¨  %
]
¨¨% &
;
¨¨& '
return
≠≠ 
lookup
≠≠ 
[
≠≠ 
a
≠≠ 
]
≠≠ 
==
≠≠ 
common
≠≠  &
||
≠≠' )
lookup
≠≠* 0
[
≠≠0 1
b
≠≠1 2
]
≠≠2 3
==
≠≠4 6
common
≠≠7 =
;
≠≠= >
}
ÆÆ 	
internal
∞∞ 
static
∞∞ 
void
∞∞ 

GetIndices
∞∞ '
(
∞∞' (
IEnumerable
∞∞( 3
<
∞∞3 4
Edge
∞∞4 8
>
∞∞8 9
edges
∞∞: ?
,
∞∞? @
List
∞∞A E
<
∞∞E F
int
∞∞F I
>
∞∞I J
indices
∞∞K R
)
∞∞R S
{
±± 	
indices
≤≤ 
.
≤≤ 
Clear
≤≤ 
(
≤≤ 
)
≤≤ 
;
≤≤ 
foreach
¥¥ 
(
¥¥ 
var
¥¥ 
edge
¥¥ 
in
¥¥  
edges
¥¥! &
)
¥¥& '
{
µµ 
indices
∂∂ 
.
∂∂ 
Add
∂∂ 
(
∂∂ 
edge
∂∂  
.
∂∂  !
a
∂∂! "
)
∂∂" #
;
∂∂# $
indices
∑∑ 
.
∑∑ 
Add
∑∑ 
(
∑∑ 
edge
∑∑  
.
∑∑  !
b
∑∑! "
)
∑∑" #
;
∑∑# $
}
∏∏ 
}
ππ 	
}
∫∫ 
}ªª •~
ëD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\BuiltinMaterials.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

static 
class 
BuiltinMaterials (
{ 
static 
bool 
s_IsInitialized #
;# $
public 
const 
string 

faceShader &
=' (
$str) J
;J K
public 
const 
string 

lineShader &
=' (
$str) J
;J K
public"" 
const"" 
string"" 
lineShaderMetal"" +
="", -
$str"". T
;""T U
public++ 
const++ 
string++ 
pointShader++ '
=++( )
$str++* L
;++L M
public11 
const11 
string11 

wireShader11 &
=11' (
$str11) J
;11J K
public77 
const77 
string77 
	dotShader77 %
=77& '
$str77( H
;77H I
internal99 
static99 
readonly99  
Color99! &
previewColor99' 3
=994 5
new996 9
Color99: ?
(99? @
$num99@ C
,99C D
$num99E H
,99H I
$num99J L
,99L M
$num99N R
)99R S
;99S T
static;; 
Shader;; #
s_SelectionPickerShader;; -
;;;- .
static== 
bool== &
s_GeometryShadersSupported== .
;==. /
static?? 
Material?? 
s_DefaultMaterial?? )
;??) *
static@@ 
Material@@  
s_FacePickerMaterial@@ ,
;@@, -
staticAA 
MaterialAA "
s_VertexPickerMaterialAA .
;AA. /
staticBB 
MaterialBB  
s_EdgePickerMaterialBB ,
;BB, -
staticCC 
MaterialCC !
s_UnityDefaultDiffuseCC -
;CC- .
staticDD 
MaterialDD &
s_UnlitVertexColorMaterialDD 2
;DD2 3
staticEE 
MaterialEE "
s_ShapePreviewMaterialEE .
;EE. /
staticQQ 
stringQQ  
k_EdgePickerMaterialQQ *
=QQ+ ,
$strQQ- C
;QQC D
staticRR 
stringRR  
k_FacePickerMaterialRR *
=RR+ ,
$strRR- C
;RRC D
staticSS 
stringSS "
k_VertexPickerMaterialSS ,
=SS- .
$strSS/ G
;SSG H
staticUU 
stringUU 
k_EdgePickerShaderUU (
=UU) *
$strUU+ I
;UUI J
staticVV 
stringVV 
k_FacePickerShaderVV (
=VV) *
$strVV+ I
;VVI J
staticWW 
stringWW  
k_VertexPickerShaderWW *
=WW+ ,
$strWW- M
;WWM N
staticZZ 
voidZZ 
InitZZ 
(ZZ 
)ZZ 
{[[ 	
if\\ 
(\\ 
s_IsInitialized\\ 
)\\  
return]] 
;]] 
s_IsInitialized__ 
=__ 
true__ "
;__" #
varaa 
geoaa 
=aa 
Shaderaa 
.aa 
Findaa !
(aa! "

lineShaderaa" ,
)aa, -
;aa- .&
s_GeometryShadersSupportedbb &
=bb' (
geobb) ,
!=bb- /
nullbb0 4
&&bb5 7
geobb8 ;
.bb; <
isSupportedbb< G
;bbG H
s_DefaultMaterialdd 
=dd 
GetDefaultMaterialdd  2
(dd2 3
)dd3 4
;dd4 5#
s_SelectionPickerShadergg #
=gg$ %
(gg& '
Shadergg' -
)gg- .
Shadergg. 4
.gg4 5
Findgg5 9
(gg9 :
$strgg: ]
)gg] ^
;gg^ _
ifii 
(ii 
(ii  
s_FacePickerMaterialii %
=ii& '
	Resourcesii( 1
.ii1 2
Loadii2 6
<ii6 7
Materialii7 ?
>ii? @
(ii@ A 
k_FacePickerMaterialiiA U
)iiU V
)iiV W
==iiX Z
nullii[ _
)ii_ `
{jj 
Logkk 
.kk 
Errorkk 
(kk 
$strkk m
)kkm n
;kkn o 
s_FacePickerMaterialll $
=ll% &
newll' *
Materialll+ 3
(ll3 4
Shaderll4 :
.ll: ;
Findll; ?
(ll? @
k_FacePickerShaderll@ R
)llR S
)llS T
;llT U
}mm 
ifoo 
(oo 
(oo "
s_VertexPickerMaterialoo '
=oo( )
	Resourcesoo* 3
.oo3 4
Loadoo4 8
<oo8 9
Materialoo9 A
>ooA B
(ooB C"
k_VertexPickerMaterialooC Y
)ooY Z
)ooZ [
==oo\ ^
nulloo_ c
)ooc d
{pp 
Logqq 
.qq 
Errorqq 
(qq 
$strqq o
)qqo p
;qqp q"
s_VertexPickerMaterialrr &
=rr' (
newrr) ,
Materialrr- 5
(rr5 6
Shaderrr6 <
.rr< =
Findrr= A
(rrA B 
k_VertexPickerShaderrrB V
)rrV W
)rrW X
;rrX Y
}ss 	
ifuu 
(uu 
(uu  
s_EdgePickerMaterialuu %
=uu& '
	Resourcesuu( 1
.uu1 2
Loaduu2 6
<uu6 7
Materialuu7 ?
>uu? @
(uu@ A 
k_EdgePickerMaterialuuA U
)uuU V
)uuV W
==uuX Z
nulluu[ _
)uu_ `
{vv 
Logww 
.ww 
Errorww 
(ww 
$strww m
)wwm n
;wwn o 
s_EdgePickerMaterialxx $
=xx% &
newxx' *
Materialxx+ 3
(xx3 4
Shaderxx4 :
.xx: ;
Findxx; ?
(xx? @
k_EdgePickerShaderxx@ R
)xxR S
)xxS T
;xxT U
}yy &
s_UnlitVertexColorMaterial{{ &
={{' (
({{) *
Material{{* 2
){{2 3
	Resources{{3 <
.{{< =
Load{{= A
({{A B
$str{{B ^
,{{^ _
typeof{{` f
({{f g
Material{{g o
){{o p
){{p q
;{{q r"
s_ShapePreviewMaterial}} "
=}}# $
new}}% (
Material}}) 1
(}}1 2
s_DefaultMaterial}}2 C
.}}C D
shader}}D J
)}}J K
;}}K L"
s_ShapePreviewMaterial~~ "
.~~" #
	hideFlags~~# ,
=~~- .
	HideFlags~~/ 8
.~~8 9
HideAndDontSave~~9 H
;~~H I
if
ÄÄ 
(
ÄÄ $
s_ShapePreviewMaterial
ÄÄ &
.
ÄÄ& '
HasProperty
ÄÄ' 2
(
ÄÄ2 3
$str
ÄÄ3 =
)
ÄÄ= >
)
ÄÄ> ?$
s_ShapePreviewMaterial
ÅÅ &
.
ÅÅ& '
mainTexture
ÅÅ' 2
=
ÅÅ3 4
(
ÅÅ5 6
	Texture2D
ÅÅ6 ?
)
ÅÅ? @
	Resources
ÅÅ@ I
.
ÅÅI J
Load
ÅÅJ N
(
ÅÅN O
$str
ÅÅO i
)
ÅÅi j
;
ÅÅj k
if
ÉÉ 
(
ÉÉ $
s_ShapePreviewMaterial
ÉÉ &
.
ÉÉ& '
HasProperty
ÉÉ' 2
(
ÉÉ2 3
$str
ÉÉ3 ;
)
ÉÉ; <
)
ÉÉ< =$
s_ShapePreviewMaterial
ÑÑ &
.
ÑÑ& '
SetColor
ÑÑ' /
(
ÑÑ/ 0
$str
ÑÑ0 8
,
ÑÑ8 9
previewColor
ÑÑ: F
)
ÑÑF G
;
ÑÑG H
}
ÖÖ 	
public
ää 
static
ää 
bool
ää &
geometryShadersSupported
ää 3
{
ãã 	
get
åå 
{
çç 
Init
éé 
(
éé 
)
éé 
;
éé 
return
èè (
s_GeometryShadersSupported
èè 1
;
èè1 2
}
êê 
}
ëë 	
public
ôô 
static
ôô 
Material
ôô 
defaultMaterial
ôô .
{
öö 	
get
õõ 
{
úú 
Init
ùù 
(
ùù 
)
ùù 
;
ùù 
return
ûû 
s_DefaultMaterial
ûû (
;
ûû( )
}
üü 
}
†† 	
internal
•• 
static
•• 
Shader
•• #
selectionPickerShader
•• 4
{
¶¶ 	
get
ßß 
{
®® 
Init
©© 
(
©© 
)
©© 
;
©© 
return
™™ %
s_SelectionPickerShader
™™ .
;
™™. /
}
´´ 
}
¨¨ 	
internal
±± 
static
±± 
Material
±±   
facePickerMaterial
±±! 3
{
≤≤ 	
get
≥≥ 
{
¥¥ 
Init
µµ 
(
µµ 
)
µµ 
;
µµ 
return
∂∂ "
s_FacePickerMaterial
∂∂ +
;
∂∂+ ,
}
∑∑ 
}
∏∏ 	
internal
ΩΩ 
static
ΩΩ 
Material
ΩΩ  "
vertexPickerMaterial
ΩΩ! 5
{
ææ 	
get
øø 
{
¿¿ 
Init
¡¡ 
(
¡¡ 
)
¡¡ 
;
¡¡ 
return
¬¬ $
s_VertexPickerMaterial
¬¬ -
;
¬¬- .
}
√√ 
}
ƒƒ 	
internal
…… 
static
…… 
Material
……   
edgePickerMaterial
……! 3
{
   	
get
ÀÀ 
{
ÃÃ 
Init
ÕÕ 
(
ÕÕ 
)
ÕÕ 
;
ÕÕ 
return
ŒŒ "
s_EdgePickerMaterial
ŒŒ +
;
ŒŒ+ ,
}
œœ 
}
–– 	
internal
’’ 
static
’’ 
Material
’’  
triggerMaterial
’’! 0
{
÷÷ 	
get
◊◊ 
{
ÿÿ 
Init
ŸŸ 
(
ŸŸ 
)
ŸŸ 
;
ŸŸ 
return
⁄⁄ 
(
⁄⁄ 
Material
⁄⁄  
)
⁄⁄  !
	Resources
⁄⁄! *
.
⁄⁄* +
Load
⁄⁄+ /
(
⁄⁄/ 0
$str
⁄⁄0 C
,
⁄⁄C D
typeof
⁄⁄E K
(
⁄⁄K L
Material
⁄⁄L T
)
⁄⁄T U
)
⁄⁄U V
;
⁄⁄V W
}
€€ 
}
‹‹ 	
internal
·· 
static
·· 
Material
··  
colliderMaterial
··! 1
{
‚‚ 	
get
„„ 
{
‰‰ 
Init
ÂÂ 
(
ÂÂ 
)
ÂÂ 
;
ÂÂ 
return
ÊÊ 
(
ÊÊ 
Material
ÊÊ  
)
ÊÊ  !
	Resources
ÊÊ! *
.
ÊÊ* +
Load
ÊÊ+ /
(
ÊÊ/ 0
$str
ÊÊ0 D
,
ÊÊD E
typeof
ÊÊF L
(
ÊÊL M
Material
ÊÊM U
)
ÊÊU V
)
ÊÊV W
;
ÊÊW X
}
ÁÁ 
}
ËË 	
[
ÌÌ 	
Obsolete
ÌÌ	 
(
ÌÌ 
$str
ÌÌ 2
)
ÌÌ2 3
]
ÌÌ3 4
internal
ÓÓ 
static
ÓÓ 
Material
ÓÓ  
noDrawMaterial
ÓÓ! /
{
ÔÔ 	
get
 
{
ÒÒ 
Init
ÚÚ 
(
ÚÚ 
)
ÚÚ 
;
ÚÚ 
return
ÛÛ 
(
ÛÛ 
Material
ÛÛ  
)
ÛÛ  !
	Resources
ÛÛ! *
.
ÛÛ* +
Load
ÛÛ+ /
(
ÛÛ/ 0
$str
ÛÛ0 B
,
ÛÛB C
typeof
ÛÛD J
(
ÛÛJ K
Material
ÛÛK S
)
ÛÛS T
)
ÛÛT U
;
ÛÛU V
}
ÙÙ 
}
ıı 	
internal
˙˙ 
static
˙˙ 
Material
˙˙  
GetLegacyDiffuse
˙˙! 1
(
˙˙1 2
)
˙˙2 3
{
˚˚ 	
Init
¸¸ 
(
¸¸ 
)
¸¸ 
;
¸¸ 
if
˛˛ 
(
˛˛ #
s_UnityDefaultDiffuse
˛˛ %
==
˛˛& (
null
˛˛) -
)
˛˛- .
{
ˇˇ 
var
ÄÄ 
mi
ÄÄ 
=
ÄÄ 
typeof
ÄÄ 
(
ÄÄ  
Material
ÄÄ  (
)
ÄÄ( )
.
ÄÄ) *
	GetMethod
ÄÄ* 3
(
ÄÄ3 4
$str
ÄÄ4 H
,
ÄÄH I
BindingFlags
ÅÅ $
.
ÅÅ$ %
	NonPublic
ÅÅ% .
|
ÅÅ/ 0
BindingFlags
ÅÅ1 =
.
ÅÅ= >
Public
ÅÅ> D
|
ÅÅE F
BindingFlags
ÅÅG S
.
ÅÅS T
Static
ÅÅT Z
)
ÅÅZ [
;
ÅÅ[ \
if
ÉÉ 
(
ÉÉ 
mi
ÉÉ 
!=
ÉÉ 
null
ÉÉ 
)
ÉÉ #
s_UnityDefaultDiffuse
ÑÑ )
=
ÑÑ* +
mi
ÑÑ, .
.
ÑÑ. /
Invoke
ÑÑ/ 5
(
ÑÑ5 6
null
ÑÑ6 :
,
ÑÑ: ;
null
ÑÑ< @
)
ÑÑ@ A
as
ÑÑB D
Material
ÑÑE M
;
ÑÑM N
if
ÜÜ 
(
ÜÜ #
s_UnityDefaultDiffuse
ÜÜ )
==
ÜÜ* ,
null
ÜÜ- 1
)
ÜÜ1 2
{
áá 
var
àà 
go
àà 
=
àà 

GameObject
àà '
.
àà' (
CreatePrimitive
àà( 7
(
àà7 8
PrimitiveType
àà8 E
.
ààE F
Cube
ààF J
)
ààJ K
;
ààK L#
s_UnityDefaultDiffuse
ââ )
=
ââ* +
go
ââ, .
.
ââ. /
GetComponent
ââ/ ;
<
ââ; <
MeshRenderer
ââ< H
>
ââH I
(
ââI J
)
ââJ K
.
ââK L
sharedMaterial
ââL Z
;
ââZ [
Object
ää 
.
ää 
DestroyImmediate
ää +
(
ää+ ,
go
ää, .
)
ää. /
;
ää/ 0
}
ãã 
}
åå 
return
éé #
s_UnityDefaultDiffuse
éé (
;
éé( )
}
èè 	
internal
ëë 
static
ëë 
Material
ëë   
GetDefaultMaterial
ëë! 3
(
ëë3 4
)
ëë4 5
{
íí 	
Material
ìì 
material
ìì 
=
ìì 
null
ìì  $
;
ìì$ %
if
ïï 
(
ïï 
GraphicsSettings
ïï  
.
ïï  !!
renderPipelineAsset
ïï! 4
!=
ïï5 7
null
ïï8 <
)
ïï< =
{
ññ 
material
òò 
=
òò 
GraphicsSettings
òò /
.
òò/ 0!
renderPipelineAsset
òò0 C
.
òòC D
defaultMaterial
òòD S
;
òòS T
}
úú 
if
ûû 
(
ûû 
material
ûû 
==
ûû 
null
ûû  
)
ûû  !
{
üü 
material
†† 
=
†† 
(
†† 
Material
†† $
)
††$ %
	Resources
††& /
.
††/ 0
Load
††0 4
(
††4 5
$str
††5 R
,
††R S
typeof
††T Z
(
††Z [
Material
††[ c
)
††c d
)
††d e
;
††e f
if
¢¢ 
(
¢¢ 
material
¢¢ 
==
¢¢ 
null
¢¢  $
||
¢¢% '
!
¢¢( )
material
¢¢) 1
.
¢¢1 2
shader
¢¢2 8
.
¢¢8 9
isSupported
¢¢9 D
)
¢¢D E
material
££ 
=
££ 
GetLegacyDiffuse
££ /
(
££/ 0
)
££0 1
;
££1 2
}
§§ 
return
¶¶ 
material
¶¶ 
;
¶¶ 
}
ßß 	
internal
¨¨ 
static
¨¨ 
Material
¨¨  
unlitVertexColor
¨¨! 1
{
≠≠ 	
get
ÆÆ 
{
ØØ 
Init
∞∞ 
(
∞∞ 
)
∞∞ 
;
∞∞ 
return
±± (
s_UnlitVertexColorMaterial
±± 1
;
±±1 2
}
≤≤ 
}
≥≥ 	
internal
µµ 
static
µµ 
Material
µµ  "
ShapePreviewMaterial
µµ! 5
{
∂∂ 	
get
∑∑ 
{
∏∏ 
Init
ππ 
(
ππ 
)
ππ 
;
ππ 
return
∫∫ $
s_ShapePreviewMaterial
∫∫ -
;
∫∫- .
}
ªª 
}
ºº 	
}
ΩΩ 
}ææ À±
åD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\MeshHandles.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
MeshHandles 
{ 
static		 
List		 
<		 
Vector3		 
>		 
s_Vector2List		 *
=		+ ,
new		- 0
List		1 5
<		5 6
Vector3		6 =
>		= >
(		> ?
)		? @
;		@ A
static

 
List

 
<

 
Vector3

 
>

 
s_Vector3List

 *
=

+ ,
new

- 0
List

1 5
<

5 6
Vector3

6 =
>

= >
(

> ?
)

? @
;

@ A
static 
List 
< 
Vector4 
> 
s_Vector4List *
=+ ,
new- 0
List1 5
<5 6
Vector46 =
>= >
(> ?
)? @
;@ A
static 
List 
< 
int 
> 
s_IndexList $
=% &
new' *
List+ /
</ 0
int0 3
>3 4
(4 5
)5 6
;6 7
static 
List 
< 
int 
> #
s_SharedVertexIndexList 0
=1 2
new3 6
List7 ;
<; <
int< ?
>? @
(@ A
)A B
;B C
static 
readonly 
Vector2 
k_Billboard0  ,
=- .
new/ 2
Vector23 :
(: ;
-; <
$num< >
,> ?
-@ A
$numA C
)C D
;D E
static 
readonly 
Vector2 
k_Billboard1  ,
=- .
new/ 2
Vector23 :
(: ;
-; <
$num< >
,> ?
$numA C
)C D
;D E
static 
readonly 
Vector2 
k_Billboard2  ,
=- .
new/ 2
Vector23 :
(: ;
$num< >
,> ?
-@ A
$numA C
)C D
;D E
static 
readonly 
Vector2 
k_Billboard3  ,
=- .
new/ 2
Vector23 :
(: ;
$num< >
,> ?
$numA C
)C D
;D E
internal 
static 
void 
CreateFaceMesh +
(+ ,
ProBuilderMesh, :
mesh; ?
,? @
MeshA E
targetF L
)L M
{ 	
target 
. 
Clear 
( 
) 
; 
target 
. 
vertices 
= 
mesh "
." #
positionsInternal# 4
;4 5
target 
. 
	triangles 
= 
mesh #
.# $!
selectedFacesInternal$ 9
.9 :

SelectMany: D
(D E
xE F
=>G I
xJ K
.K L
indexesL S
)S T
.T U
ToArrayU \
(\ ]
)] ^
;^ _
} 	
internal 
static 
void 
CreateEdgeMesh +
(+ ,
ProBuilderMesh, :
mesh; ?
,? @
MeshA E
targetF L
)L M
{ 	
int 
	edgeCount 
= 
$num 
; 
int 
	faceCount 
= 
mesh  
.  !
	faceCount! *
;* +
for   
(   
int   
i   
=   
$num   
;   
i   
<   
	faceCount    )
;  ) *
i  + ,
++  , .
)  . /
	edgeCount!! 
+=!! 
mesh!! !
.!!! "
facesInternal!!" /
[!!/ 0
i!!0 1
]!!1 2
.!!2 3
edgesInternal!!3 @
.!!@ A
Length!!A G
;!!G H
s_IndexList## 
.## 
Clear## 
(## 
)## 
;##  
s_IndexList$$ 
.$$ 
Capacity$$  
=$$! "
	edgeCount$$# ,
*$$- .
$num$$/ 0
;$$0 1
int&& 
	edgeIndex&& 
=&& 
$num&& 
;&& 
for(( 
((( 
int(( 
i(( 
=(( 
$num(( 
;(( 
i(( 
<(( 
	faceCount((  )
&&((* ,
	edgeIndex((- 6
<((7 8
	edgeCount((9 B
;((B C
i((D E
++((E G
)((G H
{)) 
for** 
(** 
int** 
n** 
=** 
$num** 
;** 
n**  !
<**" #
mesh**$ (
.**( )
facesInternal**) 6
[**6 7
i**7 8
]**8 9
.**9 :
edgesInternal**: G
.**G H
Length**H N
&&**O Q
	edgeIndex**R [
<**\ ]
	edgeCount**^ g
;**g h
n**i j
++**j l
)**l m
{++ 
var,, 
edge,, 
=,, 
mesh,, #
.,,# $
facesInternal,,$ 1
[,,1 2
i,,2 3
],,3 4
.,,4 5
edgesInternal,,5 B
[,,B C
n,,C D
],,D E
;,,E F
s_IndexList-- 
.--  
Add--  #
(--# $
edge--$ (
.--( )
a--) *
)--* +
;--+ ,
s_IndexList.. 
...  
Add..  #
(..# $
edge..$ (
...( )
b..) *
)..* +
;..+ ,
	edgeIndex00 
++00 
;00  
}11 
}22 
target44 
.44 
Clear44 
(44 
)44 
;44 
target55 
.55 
indexFormat55 
=55  
	edgeCount55! *
*55+ ,
$num55- .
>55/ 0
ushort551 7
.557 8
MaxValue558 @
?55A B
	Rendering55C L
.55L M
IndexFormat55M X
.55X Y
UInt1655Y _
:55` a
	Rendering55b k
.55k l
IndexFormat55l w
.55w x
UInt3255x ~
;55~ 
target66 
.66 
name66 
=66 
$str66 0
+661 2
target663 9
.669 :
GetInstanceID66: G
(66G H
)66H I
;66I J
target77 
.77 
vertices77 
=77 
mesh77 "
.77" #
positionsInternal77# 4
;774 5
target88 
.88 
subMeshCount88 
=88  !
$num88" #
;88# $
target:: 
.:: 

SetIndices:: 
(:: 
s_IndexList:: )
,::) *
MeshTopology::+ 7
.::7 8
Lines::8 =
,::= >
$num::? @
)::@ A
;::A B
}>> 	
internal@@ 
static@@ 
void@@ 
CreateEdgeMesh@@ +
(@@+ ,
ProBuilderMesh@@, :
mesh@@; ?
,@@? @
Mesh@@A E
target@@F L
,@@L M
Edge@@N R
[@@R S
]@@S T
edges@@U Z
)@@Z [
{AA 	
intBB 
	edgeCountBB 
=BB 
edgesBB !
.BB! "
LengthBB" (
;BB( )
intCC 
vertexCountCC 
=CC 
	edgeCountCC '
*CC( )
$numCC* +
;CC+ ,
s_IndexListEE 
.EE 
ClearEE 
(EE 
)EE 
;EE  
s_IndexListFF 
.FF 
CapacityFF  
=FF! "
vertexCountFF# .
;FF. /
forHH 
(HH 
intHH 
nHH 
=HH 
$numHH 
;HH 
nHH 
<HH 
	edgeCountHH  )
;HH) *
nHH+ ,
++HH, .
)HH. /
{II 
varJJ 
edgeJJ 
=JJ 
edgesJJ  
[JJ  !
nJJ! "
]JJ" #
;JJ# $
s_IndexListKK 
.KK 
AddKK 
(KK  
edgeKK  $
.KK$ %
aKK% &
)KK& '
;KK' (
s_IndexListLL 
.LL 
AddLL 
(LL  
edgeLL  $
.LL$ %
bLL% &
)LL& '
;LL' (
}MM 
targetOO 
.OO 
ClearOO 
(OO 
)OO 
;OO 
targetPP 
.PP 
indexFormatPP 
=PP  
vertexCountPP! ,
>PP- .
ushortPP/ 5
.PP5 6
MaxValuePP6 >
?PP? @
	RenderingPPA J
.PPJ K
IndexFormatPPK V
.PPV W
UInt16PPW ]
:PP^ _
	RenderingPP` i
.PPi j
IndexFormatPPj u
.PPu v
UInt32PPv |
;PP| }
targetQQ 
.QQ 
nameQQ 
=QQ 
$strQQ 0
+QQ1 2
targetQQ3 9
.QQ9 :
GetInstanceIDQQ: G
(QQG H
)QQH I
;QQI J
targetRR 
.RR 
verticesRR 
=RR 
meshRR "
.RR" #
positionsInternalRR# 4
;RR4 5
targetSS 
.SS 
subMeshCountSS 
=SS  !
$numSS" #
;SS# $
targetUU 
.UU 

SetIndicesUU 
(UU 
s_IndexListUU )
,UU) *
MeshTopologyUU+ 7
.UU7 8
LinesUU8 =
,UU= >
$numUU? @
)UU@ A
;UUA B
}YY 	
internal[[ 
static[[ 
void[[ 
CreateVertexMesh[[ -
([[- .
ProBuilderMesh[[. <
mesh[[= A
,[[A B
Mesh[[C G
target[[H N
)[[N O
{\\ 	#
s_SharedVertexIndexList]] #
.]]# $
Clear]]$ )
(]]) *
)]]* +
;]]+ ,
int^^ 
sharedVertexCount^^ !
=^^" #
mesh^^$ (
.^^( )"
sharedVerticesInternal^^) ?
.^^? @
Length^^@ F
;^^F G#
s_SharedVertexIndexList__ #
.__# $
Capacity__$ ,
=__- .
sharedVertexCount__/ @
;__@ A
foraa 
(aa 
intaa 
iaa 
=aa 
$numaa 
;aa 
iaa 
<aa 
sharedVertexCountaa  1
;aa1 2
iaa3 4
++aa4 6
)aa6 7#
s_SharedVertexIndexListbb '
.bb' (
Addbb( +
(bb+ ,
meshbb, 0
.bb0 1"
sharedVerticesInternalbb1 G
[bbG H
ibbH I
]bbI J
[bbJ K
$numbbK L
]bbL M
)bbM N
;bbN O
CreateVertexMeshdd 
(dd 
meshdd !
,dd! "
targetdd# )
,dd) *#
s_SharedVertexIndexListdd+ B
)ddB C
;ddC D
}ee 	
internalgg 
staticgg 
voidgg 
CreateVertexMeshgg -
(gg- .
ProBuilderMeshgg. <
meshgg= A
,ggA B
MeshggC G
targetggH N
,ggN O
IListggP U
<ggU V
intggV Y
>ggY Z
indexesgg[ b
)ggb c
{hh 	
ifii 
(ii 
BuiltinMaterialsii  
.ii  !$
geometryShadersSupportedii! 9
)ii9 :
CreatePointMeshjj 
(jj  
meshjj  $
.jj$ %
positionsInternaljj% 6
,jj6 7
indexesjj8 ?
,jj? @
targetjjA G
)jjG H
;jjH I
elsekk $
CreatePointBillboardMeshll (
(ll( )
meshll) -
.ll- .
positionsInternalll. ?
,ll? @
indexesllA H
,llH I
targetllJ P
)llP Q
;llQ R
}mm 	
staticoo 
voidoo 
CreatePointMeshoo #
(oo# $
Vector3oo$ +
[oo+ ,
]oo, -
	positionsoo. 7
,oo7 8
IListoo9 >
<oo> ?
intoo? B
>ooB C
indexesooD K
,ooK L
MeshooM Q
targetooR X
)ooX Y
{pp 	
intqq 
vertexCountqq 
=qq 
	positionsqq '
.qq' (
Lengthqq( .
;qq. /
targetrr 
.rr 
Clearrr 
(rr 
)rr 
;rr 
targetss 
.ss 
indexFormatss 
=ss  
vertexCountss! ,
>ss- .
ushortss/ 5
.ss5 6
MaxValuess6 >
?ss? @
	RenderingssA J
.ssJ K
IndexFormatssK V
.ssV W
UInt16ssW ]
:ss^ _
	Renderingss` i
.ssi j
IndexFormatssj u
.ssu v
UInt32ssv |
;ss| }
targettt 
.tt 
namett 
=tt 
$strtt 1
;tt1 2
targetuu 
.uu 
verticesuu 
=uu 
	positionsuu '
;uu' (
targetvv 
.vv 
subMeshCountvv 
=vv  !
$numvv" #
;vv# $
ifxx 
(xx 
indexesxx 
isxx 
intxx 
[xx 
]xx 
)xx  
targetyy 
.yy 

SetIndicesyy !
(yy! "
(yy" #
intyy# &
[yy& '
]yy' (
)yy( )
indexesyy* 1
,yy1 2
MeshTopologyyy3 ?
.yy? @
Pointsyy@ F
,yyF G
$numyyH I
)yyI J
;yyJ K
else{{ 
if{{ 
({{ 
indexes{{ 
is{{ 
List{{ #
<{{# $
int{{$ '
>{{' (
){{( )
target|| 
.|| 

SetIndices|| !
(||! "
(||" #
List||# '
<||' (
int||( +
>||+ ,
)||, -
indexes||. 5
,||5 6
MeshTopology||7 C
.||C D
Points||D J
,||J K
$num||L M
)||M N
;||N O
else~~ 
target 
. 

SetIndices !
(! "
indexes" )
.) *
ToArray* 1
(1 2
)2 3
,3 4
MeshTopology5 A
.A B
PointsB H
,H I
$numJ K
)K L
;L M
}
ÄÄ 	
internal
ÇÇ 
static
ÇÇ 
void
ÇÇ &
CreatePointBillboardMesh
ÇÇ 5
(
ÇÇ5 6
IList
ÇÇ6 ;
<
ÇÇ; <
Vector3
ÇÇ< C
>
ÇÇC D
	positions
ÇÇE N
,
ÇÇN O
Mesh
ÇÇP T
target
ÇÇU [
)
ÇÇ[ \
{
ÉÉ 	
var
ÑÑ 

pointCount
ÑÑ 
=
ÑÑ 
	positions
ÑÑ &
.
ÑÑ& '
Count
ÑÑ' ,
;
ÑÑ, -
var
ÖÖ 
vertexCount
ÖÖ 
=
ÖÖ 

pointCount
ÖÖ (
*
ÖÖ) *
$num
ÖÖ+ ,
;
ÖÖ, -
s_Vector2List
áá 
.
áá 
Clear
áá 
(
áá  
)
áá  !
;
áá! "
s_Vector3List
àà 
.
àà 
Clear
àà 
(
àà  
)
àà  !
;
àà! "
s_IndexList
ââ 
.
ââ 
Clear
ââ 
(
ââ 
)
ââ 
;
ââ  
s_Vector2List
ää 
.
ää 
Capacity
ää "
=
ää# $
vertexCount
ää% 0
;
ää0 1
s_Vector3List
ãã 
.
ãã 
Capacity
ãã "
=
ãã# $
vertexCount
ãã% 0
;
ãã0 1
s_IndexList
åå 
.
åå 
Capacity
åå  
=
åå! "
vertexCount
åå# .
;
åå. /
for
éé 
(
éé 
int
éé 
i
éé 
=
éé 
$num
éé 
;
éé 
i
éé 
<
éé 

pointCount
éé  *
;
éé* +
i
éé, -
++
éé- /
)
éé/ 0
{
èè 
s_Vector3List
êê 
.
êê 
Add
êê !
(
êê! "
	positions
êê" +
[
êê+ ,
i
êê, -
]
êê- .
)
êê. /
;
êê/ 0
s_Vector3List
ëë 
.
ëë 
Add
ëë !
(
ëë! "
	positions
ëë" +
[
ëë+ ,
i
ëë, -
]
ëë- .
)
ëë. /
;
ëë/ 0
s_Vector3List
íí 
.
íí 
Add
íí !
(
íí! "
	positions
íí" +
[
íí+ ,
i
íí, -
]
íí- .
)
íí. /
;
íí/ 0
s_Vector3List
ìì 
.
ìì 
Add
ìì !
(
ìì! "
	positions
ìì" +
[
ìì+ ,
i
ìì, -
]
ìì- .
)
ìì. /
;
ìì/ 0
s_Vector2List
ïï 
.
ïï 
Add
ïï !
(
ïï! "
k_Billboard0
ïï" .
)
ïï. /
;
ïï/ 0
s_Vector2List
ññ 
.
ññ 
Add
ññ !
(
ññ! "
k_Billboard1
ññ" .
)
ññ. /
;
ññ/ 0
s_Vector2List
óó 
.
óó 
Add
óó !
(
óó! "
k_Billboard2
óó" .
)
óó. /
;
óó/ 0
s_Vector2List
òò 
.
òò 
Add
òò !
(
òò! "
k_Billboard3
òò" .
)
òò. /
;
òò/ 0
s_IndexList
öö 
.
öö 
Add
öö 
(
öö  
i
öö  !
*
öö" #
$num
öö$ %
+
öö& '
$num
öö( )
)
öö) *
;
öö* +
s_IndexList
õõ 
.
õõ 
Add
õõ 
(
õõ  
i
õõ  !
*
õõ" #
$num
õõ$ %
+
õõ& '
$num
õõ( )
)
õõ) *
;
õõ* +
s_IndexList
úú 
.
úú 
Add
úú 
(
úú  
i
úú  !
*
úú" #
$num
úú$ %
+
úú& '
$num
úú( )
)
úú) *
;
úú* +
s_IndexList
ùù 
.
ùù 
Add
ùù 
(
ùù  
i
ùù  !
*
ùù" #
$num
ùù$ %
+
ùù& '
$num
ùù( )
)
ùù) *
;
ùù* +
}
ûû 
target
†† 
.
†† 
Clear
†† 
(
†† 
)
†† 
;
†† 
target
°° 
.
°° 
indexFormat
°° 
=
°°  
vertexCount
°°! ,
>
°°- .
ushort
°°/ 5
.
°°5 6
MaxValue
°°6 >
?
°°? @
	Rendering
°°A J
.
°°J K
IndexFormat
°°K V
.
°°V W
UInt32
°°W ]
:
°°^ _
	Rendering
°°` i
.
°°i j
IndexFormat
°°j u
.
°°u v
UInt16
°°v |
;
°°| }
target
¢¢ 
.
¢¢ 
SetVertices
¢¢ 
(
¢¢ 
s_Vector3List
¢¢ ,
)
¢¢, -
;
¢¢- .
target
££ 
.
££ 
SetUVs
££ 
(
££ 
$num
££ 
,
££ 
s_Vector2List
££ *
)
££* +
;
££+ ,
target
§§ 
.
§§ 
subMeshCount
§§ 
=
§§  !
$num
§§" #
;
§§# $
target
¶¶ 
.
¶¶ 

SetIndices
¶¶ 
(
¶¶ 
s_IndexList
¶¶ )
,
¶¶) *
MeshTopology
¶¶+ 7
.
¶¶7 8
Quads
¶¶8 =
,
¶¶= >
$num
¶¶? @
)
¶¶@ A
;
¶¶A B
}
™™ 	
static
¨¨ 
void
¨¨ &
CreatePointBillboardMesh
¨¨ ,
(
¨¨, -
IList
¨¨- 2
<
¨¨2 3
Vector3
¨¨3 :
>
¨¨: ;
	positions
¨¨< E
,
¨¨E F
IList
¨¨G L
<
¨¨L M
int
¨¨M P
>
¨¨P Q
indexes
¨¨R Y
,
¨¨Y Z
Mesh
¨¨[ _
target
¨¨` f
)
¨¨f g
{
≠≠ 	
var
ÆÆ 

pointCount
ÆÆ 
=
ÆÆ 
indexes
ÆÆ $
.
ÆÆ$ %
Count
ÆÆ% *
;
ÆÆ* +
var
ØØ 
vertexCount
ØØ 
=
ØØ 

pointCount
ØØ (
*
ØØ) *
$num
ØØ+ ,
;
ØØ, -
s_Vector2List
±± 
.
±± 
Clear
±± 
(
±±  
)
±±  !
;
±±! "
s_Vector3List
≤≤ 
.
≤≤ 
Clear
≤≤ 
(
≤≤  
)
≤≤  !
;
≤≤! "
s_IndexList
≥≥ 
.
≥≥ 
Clear
≥≥ 
(
≥≥ 
)
≥≥ 
;
≥≥  
s_Vector2List
¥¥ 
.
¥¥ 
Capacity
¥¥ "
=
¥¥# $
vertexCount
¥¥% 0
;
¥¥0 1
s_Vector3List
µµ 
.
µµ 
Capacity
µµ "
=
µµ# $
vertexCount
µµ% 0
;
µµ0 1
s_IndexList
∂∂ 
.
∂∂ 
Capacity
∂∂  
=
∂∂! "
vertexCount
∂∂# .
;
∂∂. /
for
∏∏ 
(
∏∏ 
int
∏∏ 
i
∏∏ 
=
∏∏ 
$num
∏∏ 
;
∏∏ 
i
∏∏ 
<
∏∏ 

pointCount
∏∏  *
;
∏∏* +
i
∏∏, -
++
∏∏- /
)
∏∏/ 0
{
ππ 
var
∫∫ 
index
∫∫ 
=
∫∫ 
indexes
∫∫ #
[
∫∫# $
i
∫∫$ %
]
∫∫% &
;
∫∫& '
s_Vector3List
ºº 
.
ºº 
Add
ºº !
(
ºº! "
	positions
ºº" +
[
ºº+ ,
index
ºº, 1
]
ºº1 2
)
ºº2 3
;
ºº3 4
s_Vector3List
ΩΩ 
.
ΩΩ 
Add
ΩΩ !
(
ΩΩ! "
	positions
ΩΩ" +
[
ΩΩ+ ,
index
ΩΩ, 1
]
ΩΩ1 2
)
ΩΩ2 3
;
ΩΩ3 4
s_Vector3List
ææ 
.
ææ 
Add
ææ !
(
ææ! "
	positions
ææ" +
[
ææ+ ,
index
ææ, 1
]
ææ1 2
)
ææ2 3
;
ææ3 4
s_Vector3List
øø 
.
øø 
Add
øø !
(
øø! "
	positions
øø" +
[
øø+ ,
index
øø, 1
]
øø1 2
)
øø2 3
;
øø3 4
s_Vector2List
¡¡ 
.
¡¡ 
Add
¡¡ !
(
¡¡! "
k_Billboard0
¡¡" .
)
¡¡. /
;
¡¡/ 0
s_Vector2List
¬¬ 
.
¬¬ 
Add
¬¬ !
(
¬¬! "
k_Billboard1
¬¬" .
)
¬¬. /
;
¬¬/ 0
s_Vector2List
√√ 
.
√√ 
Add
√√ !
(
√√! "
k_Billboard2
√√" .
)
√√. /
;
√√/ 0
s_Vector2List
ƒƒ 
.
ƒƒ 
Add
ƒƒ !
(
ƒƒ! "
k_Billboard3
ƒƒ" .
)
ƒƒ. /
;
ƒƒ/ 0
s_IndexList
∆∆ 
.
∆∆ 
Add
∆∆ 
(
∆∆  
i
∆∆  !
*
∆∆" #
$num
∆∆$ %
+
∆∆& '
$num
∆∆( )
)
∆∆) *
;
∆∆* +
s_IndexList
«« 
.
«« 
Add
«« 
(
««  
i
««  !
*
««" #
$num
««$ %
+
««& '
$num
««( )
)
««) *
;
««* +
s_IndexList
»» 
.
»» 
Add
»» 
(
»»  
i
»»  !
*
»»" #
$num
»»$ %
+
»»& '
$num
»»( )
)
»») *
;
»»* +
s_IndexList
…… 
.
…… 
Add
…… 
(
……  
i
……  !
*
……" #
$num
……$ %
+
……& '
$num
……( )
)
……) *
;
……* +
}
   
target
ÃÃ 
.
ÃÃ 
Clear
ÃÃ 
(
ÃÃ 
)
ÃÃ 
;
ÃÃ 
target
ÕÕ 
.
ÕÕ 
indexFormat
ÕÕ 
=
ÕÕ  
vertexCount
ÕÕ! ,
>
ÕÕ- .
ushort
ÕÕ/ 5
.
ÕÕ5 6
MaxValue
ÕÕ6 >
?
ÕÕ? @
	Rendering
ÕÕA J
.
ÕÕJ K
IndexFormat
ÕÕK V
.
ÕÕV W
UInt32
ÕÕW ]
:
ÕÕ^ _
	Rendering
ÕÕ` i
.
ÕÕi j
IndexFormat
ÕÕj u
.
ÕÕu v
UInt16
ÕÕv |
;
ÕÕ| }
target
ŒŒ 
.
ŒŒ 
SetVertices
ŒŒ 
(
ŒŒ 
s_Vector3List
ŒŒ ,
)
ŒŒ, -
;
ŒŒ- .
target
œœ 
.
œœ 
SetUVs
œœ 
(
œœ 
$num
œœ 
,
œœ 
s_Vector2List
œœ *
)
œœ* +
;
œœ+ ,
target
–– 
.
–– 
subMeshCount
–– 
=
––  !
$num
––" #
;
––# $
target
““ 
.
““ 

SetIndices
““ 
(
““ 
s_IndexList
““ )
,
““) *
MeshTopology
““+ 7
.
““7 8
Quads
““8 =
,
““= >
$num
““? @
)
““@ A
;
““A B
}
÷÷ 	
internal
ÿÿ 
static
ÿÿ 
void
ÿÿ %
CreateEdgeBillboardMesh
ÿÿ 4
(
ÿÿ4 5
ProBuilderMesh
ÿÿ5 C
mesh
ÿÿD H
,
ÿÿH I
Mesh
ÿÿJ N
target
ÿÿO U
)
ÿÿU V
{
ŸŸ 	
target
⁄⁄ 
.
⁄⁄ 
Clear
⁄⁄ 
(
⁄⁄ 
)
⁄⁄ 
;
⁄⁄ 
const
€€ 
ushort
€€ #
k_MaxPointCountUShort
€€ .
=
€€/ 0
ushort
€€1 7
.
€€7 8
MaxValue
€€8 @
/
€€A B
$num
€€C D
;
€€D E
var
‹‹ 
	lineCount
‹‹ 
=
‹‹ 
mesh
‹‹  
.
‹‹  !
	edgeCount
‹‹! *
;
‹‹* +
target
ﬁﬁ 
.
ﬁﬁ 
indexFormat
ﬁﬁ 
=
ﬁﬁ  
	lineCount
ﬁﬁ! *
>
ﬁﬁ+ ,#
k_MaxPointCountUShort
ﬁﬁ- B
?
ﬂﬂ 
	Rendering
ﬂﬂ 
.
ﬂﬂ 
IndexFormat
ﬂﬂ '
.
ﬂﬂ' (
UInt32
ﬂﬂ( .
:
‡‡ 
	Rendering
‡‡ 
.
‡‡ 
IndexFormat
‡‡ '
.
‡‡' (
UInt16
‡‡( .
;
‡‡. /
var
‚‚ 
vertices
‚‚ 
=
‚‚ 
mesh
‚‚ 
.
‚‚  
positionsInternal
‚‚  1
;
‚‚1 2
s_Vector3List
‰‰ 
.
‰‰ 
Clear
‰‰ 
(
‰‰  
)
‰‰  !
;
‰‰! "
s_Vector4List
ÂÂ 
.
ÂÂ 
Clear
ÂÂ 
(
ÂÂ  
)
ÂÂ  !
;
ÂÂ! "
s_IndexList
ÊÊ 
.
ÊÊ 
Clear
ÊÊ 
(
ÊÊ 
)
ÊÊ 
;
ÊÊ  
s_Vector3List
ÁÁ 
.
ÁÁ 
Capacity
ÁÁ "
=
ÁÁ# $
	lineCount
ÁÁ% .
*
ÁÁ/ 0
$num
ÁÁ1 2
;
ÁÁ2 3
s_Vector4List
ËË 
.
ËË 
Capacity
ËË "
=
ËË# $
	lineCount
ËË% .
*
ËË/ 0
$num
ËË1 2
;
ËË2 3
s_IndexList
ÈÈ 
.
ÈÈ 
Capacity
ÈÈ  
=
ÈÈ! "
	lineCount
ÈÈ# ,
*
ÈÈ- .
$num
ÈÈ/ 0
;
ÈÈ0 1
int
ÎÎ 
n
ÎÎ 
=
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
foreach
ÌÌ 
(
ÌÌ 
var
ÌÌ 
face
ÌÌ 
in
ÌÌ 
mesh
ÌÌ  $
.
ÌÌ$ %
facesInternal
ÌÌ% 2
)
ÌÌ2 3
{
ÓÓ 
foreach
ÔÔ 
(
ÔÔ 
var
ÔÔ 
edge
ÔÔ !
in
ÔÔ" $
face
ÔÔ% )
.
ÔÔ) *
edgesInternal
ÔÔ* 7
)
ÔÔ7 8
{
 
Vector3
ÒÒ 
a
ÒÒ 
=
ÒÒ 
vertices
ÒÒ  (
[
ÒÒ( )
edge
ÒÒ) -
.
ÒÒ- .
a
ÒÒ. /
]
ÒÒ/ 0
,
ÒÒ0 1
b
ÒÒ2 3
=
ÒÒ4 5
vertices
ÒÒ6 >
[
ÒÒ> ?
edge
ÒÒ? C
.
ÒÒC D
b
ÒÒD E
]
ÒÒE F
;
ÒÒF G
Vector3
ÚÚ 
c
ÚÚ 
=
ÚÚ 
b
ÚÚ  !
+
ÚÚ" #
(
ÚÚ$ %
b
ÚÚ% &
-
ÚÚ' (
a
ÚÚ) *
)
ÚÚ* +
;
ÚÚ+ ,
s_Vector3List
ÙÙ !
.
ÙÙ! "
Add
ÙÙ" %
(
ÙÙ% &
a
ÙÙ& '
)
ÙÙ' (
;
ÙÙ( )
s_Vector3List
ıı !
.
ıı! "
Add
ıı" %
(
ıı% &
a
ıı& '
)
ıı' (
;
ıı( )
s_Vector3List
ˆˆ !
.
ˆˆ! "
Add
ˆˆ" %
(
ˆˆ% &
b
ˆˆ& '
)
ˆˆ' (
;
ˆˆ( )
s_Vector3List
˜˜ !
.
˜˜! "
Add
˜˜" %
(
˜˜% &
b
˜˜& '
)
˜˜' (
;
˜˜( )
s_Vector4List
˘˘ !
.
˘˘! "
Add
˘˘" %
(
˘˘% &
new
˘˘& )
Vector4
˘˘* 1
(
˘˘1 2
b
˘˘2 3
.
˘˘3 4
x
˘˘4 5
,
˘˘5 6
b
˘˘7 8
.
˘˘8 9
y
˘˘9 :
,
˘˘: ;
b
˘˘< =
.
˘˘= >
z
˘˘> ?
,
˘˘? @
$num
˘˘A C
)
˘˘C D
)
˘˘D E
;
˘˘E F
s_Vector4List
˙˙ !
.
˙˙! "
Add
˙˙" %
(
˙˙% &
new
˙˙& )
Vector4
˙˙* 1
(
˙˙1 2
b
˙˙2 3
.
˙˙3 4
x
˙˙4 5
,
˙˙5 6
b
˙˙7 8
.
˙˙8 9
y
˙˙9 :
,
˙˙: ;
b
˙˙< =
.
˙˙= >
z
˙˙> ?
,
˙˙? @
-
˙˙A B
$num
˙˙B D
)
˙˙D E
)
˙˙E F
;
˙˙F G
s_Vector4List
˚˚ !
.
˚˚! "
Add
˚˚" %
(
˚˚% &
new
˚˚& )
Vector4
˚˚* 1
(
˚˚1 2
c
˚˚2 3
.
˚˚3 4
x
˚˚4 5
,
˚˚5 6
c
˚˚7 8
.
˚˚8 9
y
˚˚9 :
,
˚˚: ;
c
˚˚< =
.
˚˚= >
z
˚˚> ?
,
˚˚? @
$num
˚˚A C
)
˚˚C D
)
˚˚D E
;
˚˚E F
s_Vector4List
¸¸ !
.
¸¸! "
Add
¸¸" %
(
¸¸% &
new
¸¸& )
Vector4
¸¸* 1
(
¸¸1 2
c
¸¸2 3
.
¸¸3 4
x
¸¸4 5
,
¸¸5 6
c
¸¸7 8
.
¸¸8 9
y
¸¸9 :
,
¸¸: ;
c
¸¸< =
.
¸¸= >
z
¸¸> ?
,
¸¸? @
-
¸¸A B
$num
¸¸B D
)
¸¸D E
)
¸¸E F
;
¸¸F G
s_IndexList
˛˛ 
.
˛˛  
Add
˛˛  #
(
˛˛# $
n
˛˛$ %
+
˛˛& '
$num
˛˛( )
)
˛˛) *
;
˛˛* +
s_IndexList
ˇˇ 
.
ˇˇ  
Add
ˇˇ  #
(
ˇˇ# $
n
ˇˇ$ %
+
ˇˇ& '
$num
ˇˇ( )
)
ˇˇ) *
;
ˇˇ* +
s_IndexList
ÄÄ 
.
ÄÄ  
Add
ÄÄ  #
(
ÄÄ# $
n
ÄÄ$ %
+
ÄÄ& '
$num
ÄÄ( )
)
ÄÄ) *
;
ÄÄ* +
s_IndexList
ÅÅ 
.
ÅÅ  
Add
ÅÅ  #
(
ÅÅ# $
n
ÅÅ$ %
+
ÅÅ& '
$num
ÅÅ( )
)
ÅÅ) *
;
ÅÅ* +
n
ÉÉ 
+=
ÉÉ 
$num
ÉÉ 
;
ÉÉ 
}
ÑÑ 
}
ÖÖ 
target
áá 
.
áá 
SetVertices
áá 
(
áá 
s_Vector3List
áá ,
)
áá, -
;
áá- .
target
àà 
.
àà 
SetTangents
àà 
(
àà 
s_Vector4List
àà ,
)
àà, -
;
àà- .
target
ââ 
.
ââ 
subMeshCount
ââ 
=
ââ  !
$num
ââ" #
;
ââ# $
target
ãã 
.
ãã 

SetIndices
ãã 
(
ãã 
s_IndexList
ãã )
,
ãã) *
MeshTopology
ãã+ 7
.
ãã7 8
Quads
ãã8 =
,
ãã= >
$num
ãã? @
)
ãã@ A
;
ããA B
}
èè 	
internal
ëë 
static
ëë 
void
ëë %
CreateEdgeBillboardMesh
ëë 4
(
ëë4 5
ProBuilderMesh
ëë5 C
mesh
ëëD H
,
ëëH I
Mesh
ëëJ N
target
ëëO U
,
ëëU V
ICollection
ëëW b
<
ëëb c
Edge
ëëc g
>
ëëg h
edges
ëëi n
)
ëën o
{
íí 	
target
ìì 
.
ìì 
Clear
ìì 
(
ìì 
)
ìì 
;
ìì 
const
ïï 
ushort
ïï #
k_MaxPointCountUShort
ïï .
=
ïï/ 0
ushort
ïï1 7
.
ïï7 8
MaxValue
ïï8 @
/
ïïA B
$num
ïïC D
;
ïïD E
var
óó 
	lineCount
óó 
=
óó 
edges
óó !
.
óó! "
Count
óó" '
;
óó' (
target
ôô 
.
ôô 
indexFormat
ôô 
=
ôô  
	lineCount
ôô! *
>
ôô+ ,#
k_MaxPointCountUShort
ôô- B
?
öö 
	Rendering
öö 
.
öö 
IndexFormat
öö '
.
öö' (
UInt32
öö( .
:
õõ 
	Rendering
õõ 
.
õõ 
IndexFormat
õõ '
.
õõ' (
UInt16
õõ( .
;
õõ. /
var
ùù 
vertices
ùù 
=
ùù 
mesh
ùù 
.
ùù  
positionsInternal
ùù  1
;
ùù1 2
s_Vector3List
üü 
.
üü 
Clear
üü 
(
üü  
)
üü  !
;
üü! "
s_Vector4List
†† 
.
†† 
Clear
†† 
(
††  
)
††  !
;
††! "
s_IndexList
°° 
.
°° 
Clear
°° 
(
°° 
)
°° 
;
°°  
s_Vector3List
¢¢ 
.
¢¢ 
Capacity
¢¢ "
=
¢¢# $
	lineCount
¢¢% .
*
¢¢/ 0
$num
¢¢1 2
;
¢¢2 3
s_Vector4List
££ 
.
££ 
Capacity
££ "
=
££# $
	lineCount
££% .
*
££/ 0
$num
££1 2
;
££2 3
s_IndexList
§§ 
.
§§ 
Capacity
§§  
=
§§! "
	lineCount
§§# ,
*
§§- .
$num
§§/ 0
;
§§0 1
int
¶¶ 
n
¶¶ 
=
¶¶ 
$num
¶¶ 
;
¶¶ 
foreach
®® 
(
®® 
var
®® 
edge
®® 
in
®®  
edges
®®! &
)
®®& '
{
©© 
Vector3
™™ 
a
™™ 
=
™™ 
vertices
™™ $
[
™™$ %
edge
™™% )
.
™™) *
a
™™* +
]
™™+ ,
,
™™, -
b
™™. /
=
™™0 1
vertices
™™2 :
[
™™: ;
edge
™™; ?
.
™™? @
b
™™@ A
]
™™A B
;
™™B C
Vector3
´´ 
c
´´ 
=
´´ 
b
´´ 
+
´´ 
(
´´  !
b
´´! "
-
´´# $
a
´´% &
)
´´& '
;
´´' (
s_Vector3List
≠≠ 
.
≠≠ 
Add
≠≠ !
(
≠≠! "
a
≠≠" #
)
≠≠# $
;
≠≠$ %
s_Vector3List
ÆÆ 
.
ÆÆ 
Add
ÆÆ !
(
ÆÆ! "
a
ÆÆ" #
)
ÆÆ# $
;
ÆÆ$ %
s_Vector3List
ØØ 
.
ØØ 
Add
ØØ !
(
ØØ! "
b
ØØ" #
)
ØØ# $
;
ØØ$ %
s_Vector3List
∞∞ 
.
∞∞ 
Add
∞∞ !
(
∞∞! "
b
∞∞" #
)
∞∞# $
;
∞∞$ %
s_Vector4List
≤≤ 
.
≤≤ 
Add
≤≤ !
(
≤≤! "
new
≤≤" %
Vector4
≤≤& -
(
≤≤- .
b
≤≤. /
.
≤≤/ 0
x
≤≤0 1
,
≤≤1 2
b
≤≤3 4
.
≤≤4 5
y
≤≤5 6
,
≤≤6 7
b
≤≤8 9
.
≤≤9 :
z
≤≤: ;
,
≤≤; <
$num
≤≤= ?
)
≤≤? @
)
≤≤@ A
;
≤≤A B
s_Vector4List
≥≥ 
.
≥≥ 
Add
≥≥ !
(
≥≥! "
new
≥≥" %
Vector4
≥≥& -
(
≥≥- .
b
≥≥. /
.
≥≥/ 0
x
≥≥0 1
,
≥≥1 2
b
≥≥3 4
.
≥≥4 5
y
≥≥5 6
,
≥≥6 7
b
≥≥8 9
.
≥≥9 :
z
≥≥: ;
,
≥≥; <
-
≥≥= >
$num
≥≥> @
)
≥≥@ A
)
≥≥A B
;
≥≥B C
s_Vector4List
¥¥ 
.
¥¥ 
Add
¥¥ !
(
¥¥! "
new
¥¥" %
Vector4
¥¥& -
(
¥¥- .
c
¥¥. /
.
¥¥/ 0
x
¥¥0 1
,
¥¥1 2
c
¥¥3 4
.
¥¥4 5
y
¥¥5 6
,
¥¥6 7
c
¥¥8 9
.
¥¥9 :
z
¥¥: ;
,
¥¥; <
$num
¥¥= ?
)
¥¥? @
)
¥¥@ A
;
¥¥A B
s_Vector4List
µµ 
.
µµ 
Add
µµ !
(
µµ! "
new
µµ" %
Vector4
µµ& -
(
µµ- .
c
µµ. /
.
µµ/ 0
x
µµ0 1
,
µµ1 2
c
µµ3 4
.
µµ4 5
y
µµ5 6
,
µµ6 7
c
µµ8 9
.
µµ9 :
z
µµ: ;
,
µµ; <
-
µµ= >
$num
µµ> @
)
µµ@ A
)
µµA B
;
µµB C
s_IndexList
∑∑ 
.
∑∑ 
Add
∑∑ 
(
∑∑  
n
∑∑  !
+
∑∑" #
$num
∑∑$ %
)
∑∑% &
;
∑∑& '
s_IndexList
∏∏ 
.
∏∏ 
Add
∏∏ 
(
∏∏  
n
∏∏  !
+
∏∏" #
$num
∏∏$ %
)
∏∏% &
;
∏∏& '
s_IndexList
ππ 
.
ππ 
Add
ππ 
(
ππ  
n
ππ  !
+
ππ" #
$num
ππ$ %
)
ππ% &
;
ππ& '
s_IndexList
∫∫ 
.
∫∫ 
Add
∫∫ 
(
∫∫  
n
∫∫  !
+
∫∫" #
$num
∫∫$ %
)
∫∫% &
;
∫∫& '
n
ºº 
+=
ºº 
$num
ºº 
;
ºº 
}
ΩΩ 
target
øø 
.
øø 
SetVertices
øø 
(
øø 
s_Vector3List
øø ,
)
øø, -
;
øø- .
target
¿¿ 
.
¿¿ 
SetTangents
¿¿ 
(
¿¿ 
s_Vector4List
¿¿ ,
)
¿¿, -
;
¿¿- .
target
¡¡ 
.
¡¡ 
subMeshCount
¡¡ 
=
¡¡  !
$num
¡¡" #
;
¡¡# $
target
√√ 
.
√√ 

SetIndices
√√ 
(
√√ 
s_IndexList
√√ )
,
√√) *
MeshTopology
√√+ 7
.
√√7 8
Quads
√√8 =
,
√√= >
$num
√√? @
)
√√@ A
;
√√A B
}
«« 	
}
»» 
}…… §Ø
öD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\UV\UvUnwrapping.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
UvUnwrapping 
{ 
static 
Vector2 
s_TempVector2 $
=% &
Vector2' .
.. /
zero/ 3
;3 4
static 
readonly 
List 
< 
int  
>  !
s_IndexBuffer" /
=0 1
new2 5
List6 :
<: ;
int; >
>> ?
(? @
$num@ B
)B C
;C D
internal

 
static

 
void

 
Unwrap

 #
(

# $
ProBuilderMesh

$ 2
mesh

3 7
,

7 8
Face

9 =
face

> B
,

B C
Vector3

D K

projection

L V
=

W X
default

Y `
)

` a
{ 	

Projection 
. 
PlanarProject $
($ %
mesh% )
,) *
face+ /
,/ 0

projection1 ;
!=< >
Vector3? F
.F G
zeroG K
?K L

projectionM W
:X Y
Vector3Z a
.a b
zerob f
)f g
;g h
ApplyUVSettings 
( 
mesh  
.  !
texturesInternal! 1
,1 2
face3 7
.7 8#
distinctIndexesInternal8 O
,O P
faceQ U
.U V
uvV X
)X Y
;Y Z
} 	
internal 
static 
void 
CopyUVs $
($ %
ProBuilderMesh% 3
mesh4 8
,8 9
Face: >
source? E
,E F
FaceG K
destL P
)P Q
{ 	
var 
uvs 
= 
mesh 
. 
texturesInternal +
;+ ,
var 
sourceIndexes 
= 
source  &
.& '#
distinctIndexesInternal' >
;> ?
var 
destIndexes 
= 
dest "
." ##
distinctIndexesInternal# :
;: ;
for 
( 
int 
i 
= 
$num 
; 
i 
< 
sourceIndexes  -
.- .
Length. 4
;4 5
i6 7
++7 9
)9 :
{ 
uvs 
[ 
destIndexes 
[  
i  !
]! "
]" #
.# $
x$ %
=& '
uvs( +
[+ ,
sourceIndexes, 9
[9 :
i: ;
]; <
]< =
.= >
x> ?
;? @
uvs 
[ 
destIndexes 
[  
i  !
]! "
]" #
.# $
y$ %
=& '
uvs( +
[+ ,
sourceIndexes, 9
[9 :
i: ;
]; <
]< =
.= >
y> ?
;? @
} 
}   	
internal"" 
static"" 
void"" 
ProjectTextureGroup"" 0
(""0 1
ProBuilderMesh""1 ?
mesh""@ D
,""D E
int""F I
group""J O
,""O P
AutoUnwrapSettings""Q c
unwrapSettings""d r
)""r s
{## 	

Projection$$ 
.$$ 
PlanarProject$$ $
($$$ %
mesh$$% )
,$$) *
group$$+ 0
,$$0 1
unwrapSettings$$2 @
)$$@ A
;$$A B
s_IndexBuffer&& 
.&& 
Clear&& 
(&&  
)&&  !
;&&! "
foreach'' 
('' 
var'' 
face'' 
in''  
mesh''! %
.''% &
facesInternal''& 3
)''3 4
{(( 
if)) 
()) 
face)) 
.)) 
textureGroup)) %
==))& (
group))) .
))). /
{** 
s_IndexBuffer++ !
.++! "
AddRange++" *
(++* +
face+++ /
.++/ 0#
distinctIndexesInternal++0 G
)++G H
;++H I
},, 
}-- 
ApplyUVSettings// 
(// 
mesh//  
.//  !
texturesInternal//! 1
,//1 2
s_IndexBuffer//3 @
,//@ A
unwrapSettings//B P
)//P Q
;//Q R
}00 	
static22 
void22 
ApplyUVSettings22 #
(22# $
Vector222$ +
[22+ ,
]22, -
uvs22. 1
,221 2
IList223 8
<228 9
int229 <
>22< =
indexes22> E
,22E F
AutoUnwrapSettings22G Y

uvSettings22Z d
)22d e
{33 	
int44 
len44 
=44 
indexes44 
.44 
Count44 #
;44# $
switch66 
(66 

uvSettings66 
.66 
fill66 #
)66# $
{77 
case88 
AutoUnwrapSettings88 '
.88' (
Fill88( ,
.88, -
Tile88- 1
:881 2
break99 
;99 
case:: 
AutoUnwrapSettings:: '
.::' (
Fill::( ,
.::, -
Fit::- 0
:::0 1
FitUVs;; 
(;; 
uvs;; 
,;; 
indexes;;  '
);;' (
;;;( )
break<< 
;<< 
case== 
AutoUnwrapSettings== '
.==' (
Fill==( ,
.==, -
Stretch==- 4
:==4 5

StretchUVs>> 
(>> 
uvs>> "
,>>" #
indexes>>$ +
)>>+ ,
;>>, -
break?? 
;?? 
}@@ 
ifCC 
(CC 

uvSettingsCC 
.CC 
scaleCC  
.CC  !
xCC! "
!=CC# %
$numCC& (
||CC) +

uvSettingsDD 
.DD 
scaleDD  
.DD  !
yDD! "
!=DD# %
$numDD& (
||DD) +

uvSettingsEE 
.EE 
rotationEE #
!=EE$ &
$numEE' )
)EE) *
{FF 
Vector2GG 
centerGG 
=GG  
Bounds2DGG! )
.GG) *
CenterGG* 0
(GG0 1
uvsGG1 4
,GG4 5
indexesGG6 =
)GG= >
;GG> ?
forII 
(II 
intII 
iII 
=II 
$numII 
;II 
iII  !
<II" #
lenII$ '
;II' (
iII) *
++II* ,
)II, -
{JJ 
uvsKK 
[KK 
indexesKK 
[KK  
iKK  !
]KK! "
]KK" #
=KK$ %
uvsKK& )
[KK) *
indexesKK* 1
[KK1 2
iKK2 3
]KK3 4
]KK4 5
.KK5 6
ScaleAroundPointKK6 F
(KKF G
centerKKG M
,KKM N

uvSettingsKKO Y
.KKY Z
scaleKKZ _
)KK_ `
;KK` a
uvsLL 
[LL 
indexesLL 
[LL  
iLL  !
]LL! "
]LL" #
=LL$ %
uvsLL& )
[LL) *
indexesLL* 1
[LL1 2
iLL2 3
]LL3 4
]LL4 5
.LL5 6
RotateAroundPointLL6 G
(LLG H
centerLLH N
,LLN O

uvSettingsLLP Z
.LLZ [
rotationLL[ c
)LLc d
;LLd e
}MM 
}NN 
ifPP 
(PP 
!PP 

uvSettingsPP 
.PP 
useWorldSpacePP )
&&PP* ,

uvSettingsPP- 7
.PP7 8
anchorPP8 >
!=PP? A
AutoUnwrapSettingsPPB T
.PPT U
AnchorPPU [
.PP[ \
NonePP\ `
)PP` a
ApplyUVAnchorQQ 
(QQ 
uvsQQ !
,QQ! "
indexesQQ# *
,QQ* +

uvSettingsQQ, 6
.QQ6 7
anchorQQ7 =
)QQ= >
;QQ> ?
ifSS 
(SS 

uvSettingsSS 
.SS 
flipUSS  
||SS! #

uvSettingsSS$ .
.SS. /
flipVSS/ 4
||SS5 7

uvSettingsSS8 B
.SSB C
swapUVSSC I
)SSI J
{TT 
forUU 
(UU 
intUU 
iUU 
=UU 
$numUU 
;UU 
iUU  !
<UU" #
lenUU$ '
;UU' (
iUU) *
++UU* ,
)UU, -
{VV 
floatWW 
uWW 
=WW 
uvsWW  #
[WW# $
indexesWW$ +
[WW+ ,
iWW, -
]WW- .
]WW. /
.WW/ 0
xWW0 1
,WW1 2
vXX 
=XX 
uvsXX  #
[XX# $
indexesXX$ +
[XX+ ,
iXX, -
]XX- .
]XX. /
.XX/ 0
yXX0 1
;XX1 2
ifZZ 
(ZZ 

uvSettingsZZ "
.ZZ" #
flipUZZ# (
)ZZ( )
u[[ 
=[[ 
-[[ 
u[[ 
;[[ 
if]] 
(]] 

uvSettings]] "
.]]" #
flipV]]# (
)]]( )
v^^ 
=^^ 
-^^ 
v^^ 
;^^ 
if`` 
(`` 
!`` 

uvSettings`` #
.``# $
swapUV``$ *
)``* +
{aa 
uvsbb 
[bb 
indexesbb #
[bb# $
ibb$ %
]bb% &
]bb& '
.bb' (
xbb( )
=bb* +
ubb, -
;bb- .
uvscc 
[cc 
indexescc #
[cc# $
icc$ %
]cc% &
]cc& '
.cc' (
ycc( )
=cc* +
vcc, -
;cc- .
}dd 
elseee 
{ff 
uvsgg 
[gg 
indexesgg #
[gg# $
igg$ %
]gg% &
]gg& '
.gg' (
xgg( )
=gg* +
vgg, -
;gg- .
uvshh 
[hh 
indexeshh #
[hh# $
ihh$ %
]hh% &
]hh& '
.hh' (
yhh( )
=hh* +
uhh, -
;hh- .
}ii 
}jj 
}kk 
formm 
(mm 
intmm 
imm 
=mm 
$nummm 
;mm 
imm 
<mm 
indexesmm  '
.mm' (
Countmm( -
;mm- .
imm/ 0
++mm0 2
)mm2 3
{nn 
uvsoo 
[oo 
indexesoo 
[oo 
ioo 
]oo 
]oo 
.oo  
xoo  !
-=oo" $

uvSettingsoo% /
.oo/ 0
offsetoo0 6
.oo6 7
xoo7 8
;oo8 9
uvspp 
[pp 
indexespp 
[pp 
ipp 
]pp 
]pp 
.pp  
ypp  !
-=pp" $

uvSettingspp% /
.pp/ 0
offsetpp0 6
.pp6 7
ypp7 8
;pp8 9
}qq 
}rr 	
statictt 
voidtt 

StretchUVstt 
(tt 
Vector2tt &
[tt& '
]tt' (
uvstt) ,
,tt, -
IListtt. 3
<tt3 4
inttt4 7
>tt7 8
indexestt9 @
)tt@ A
{uu 	
varvv 
boundsvv 
=vv 
newvv 
Bounds2Dvv %
(vv% &
)vv& '
;vv' (
boundsww 
.ww 
SetWithPointsww  
(ww  !
uvsww! $
,ww$ %
indexesww& -
)ww- .
;ww. /
varxx 
cxx 
=xx 
boundsxx 
.xx 
centerxx !
;xx! "
varyy 
syy 
=yy 
boundsyy 
.yy 
sizeyy 
;yy  
for{{ 
({{ 
int{{ 
i{{ 
={{ 
$num{{ 
;{{ 
i{{ 
<{{ 
indexes{{  '
.{{' (
Count{{( -
;{{- .
i{{/ 0
++{{0 2
){{2 3
{|| 
var}} 
uv}} 
=}} 
uvs}} 
[}} 
indexes}} $
[}}$ %
i}}% &
]}}& '
]}}' (
;}}( )
uv 
. 
x 
= 
( 
( 
uv 
. 
x 
- 
c  !
.! "
x" #
)# $
/% &
s' (
.( )
x) *
)* +
+, -
c. /
./ 0
x0 1
;1 2
uv
ÄÄ 
.
ÄÄ 
y
ÄÄ 
=
ÄÄ 
(
ÄÄ 
(
ÄÄ 
uv
ÄÄ 
.
ÄÄ 
y
ÄÄ 
-
ÄÄ 
c
ÄÄ  !
.
ÄÄ! "
y
ÄÄ" #
)
ÄÄ# $
/
ÄÄ% &
s
ÄÄ' (
.
ÄÄ( )
y
ÄÄ) *
)
ÄÄ* +
+
ÄÄ, -
c
ÄÄ. /
.
ÄÄ/ 0
y
ÄÄ0 1
;
ÄÄ1 2
uvs
ÇÇ 
[
ÇÇ 
indexes
ÇÇ 
[
ÇÇ 
i
ÇÇ 
]
ÇÇ 
]
ÇÇ 
=
ÇÇ  !
uv
ÇÇ" $
;
ÇÇ$ %
}
ÉÉ 
}
ÑÑ 	
static
ÜÜ 
void
ÜÜ 
FitUVs
ÜÜ 
(
ÜÜ 
Vector2
ÜÜ "
[
ÜÜ" #
]
ÜÜ# $
uvs
ÜÜ% (
,
ÜÜ( )
IList
ÜÜ* /
<
ÜÜ/ 0
int
ÜÜ0 3
>
ÜÜ3 4
indexes
ÜÜ5 <
)
ÜÜ< =
{
áá 	
var
àà 
bounds
àà 
=
àà 
new
àà 
Bounds2D
àà %
(
àà% &
)
àà& '
;
àà' (
bounds
ââ 
.
ââ 
SetWithPoints
ââ  
(
ââ  !
uvs
ââ! $
,
ââ$ %
indexes
ââ& -
)
ââ- .
;
ââ. /
var
ää 
c
ää 
=
ää 
bounds
ää 
.
ää 
center
ää !
;
ää! "
var
ãã 
s
ãã 
=
ãã 
Mathf
ãã 
.
ãã 
Max
ãã 
(
ãã 
bounds
ãã $
.
ãã$ %
size
ãã% )
.
ãã) *
x
ãã* +
,
ãã+ ,
bounds
ãã- 3
.
ãã3 4
size
ãã4 8
.
ãã8 9
y
ãã9 :
)
ãã: ;
;
ãã; <
for
çç 
(
çç 
int
çç 
i
çç 
=
çç 
$num
çç 
;
çç 
i
çç 
<
çç 
indexes
çç  '
.
çç' (
Count
çç( -
;
çç- .
i
çç/ 0
++
çç0 2
)
çç2 3
{
éé 
var
èè 
uv
èè 
=
èè 
uvs
èè 
[
èè 
indexes
èè $
[
èè$ %
i
èè% &
]
èè& '
]
èè' (
;
èè( )
uv
ëë 
.
ëë 
x
ëë 
=
ëë 
(
ëë 
(
ëë 
uv
ëë 
.
ëë 
x
ëë 
-
ëë 
c
ëë  !
.
ëë! "
x
ëë" #
)
ëë# $
/
ëë% &
s
ëë' (
)
ëë( )
+
ëë* +
c
ëë, -
.
ëë- .
x
ëë. /
;
ëë/ 0
uv
íí 
.
íí 
y
íí 
=
íí 
(
íí 
(
íí 
uv
íí 
.
íí 
y
íí 
-
íí 
c
íí  !
.
íí! "
y
íí" #
)
íí# $
/
íí% &
s
íí' (
)
íí( )
+
íí* +
c
íí, -
.
íí- .
y
íí. /
;
íí/ 0
uvs
îî 
[
îî 
indexes
îî 
[
îî 
i
îî 
]
îî 
]
îî 
=
îî  !
uv
îî" $
;
îî$ %
}
ïï 
}
ññ 	
static
òò 
void
òò 
ApplyUVAnchor
òò !
(
òò! "
Vector2
òò" )
[
òò) *
]
òò* +
uvs
òò, /
,
òò/ 0
IList
òò1 6
<
òò6 7
int
òò7 :
>
òò: ;
indexes
òò< C
,
òòC D 
AutoUnwrapSettings
òòE W
.
òòW X
Anchor
òòX ^
anchor
òò_ e
)
òòe f
{
ôô 	
s_TempVector2
öö 
.
öö 
x
öö 
=
öö 
$num
öö  
;
öö  !
s_TempVector2
õõ 
.
õõ 
y
õõ 
=
õõ 
$num
õõ  
;
õõ  !
Vector2
ùù 
min
ùù 
=
ùù 
Math
ùù 
.
ùù 
SmallestVector2
ùù .
(
ùù. /
uvs
ùù/ 2
,
ùù2 3
indexes
ùù4 ;
)
ùù; <
;
ùù< =
Vector2
ûû 
max
ûû 
=
ûû 
Math
ûû 
.
ûû 
LargestVector2
ûû -
(
ûû- .
uvs
ûû. 1
,
ûû1 2
indexes
ûû3 :
)
ûû: ;
;
ûû; <
if
†† 
(
†† 
anchor
†† 
==
††  
AutoUnwrapSettings
†† ,
.
††, -
Anchor
††- 3
.
††3 4
	UpperLeft
††4 =
||
††> @
anchor
††A G
==
††H J 
AutoUnwrapSettings
††K ]
.
††] ^
Anchor
††^ d
.
††d e

MiddleLeft
††e o
||
††p r
anchor
††s y
==
††z |!
AutoUnwrapSettings††} è
.††è ê
Anchor††ê ñ
.††ñ ó
	LowerLeft††ó †
)††† °
s_TempVector2
°° 
.
°° 
x
°° 
=
°°  !
min
°°" %
.
°°% &
x
°°& '
;
°°' (
else
¢¢ 
if
¢¢ 
(
¢¢ 
anchor
¢¢ 
==
¢¢  
AutoUnwrapSettings
¢¢ 1
.
¢¢1 2
Anchor
¢¢2 8
.
¢¢8 9

UpperRight
¢¢9 C
||
¢¢D F
anchor
¢¢G M
==
¢¢N P 
AutoUnwrapSettings
¢¢Q c
.
¢¢c d
Anchor
¢¢d j
.
¢¢j k
MiddleRight
¢¢k v
||
¢¢w y
anchor¢¢z Ä
==¢¢Å É"
AutoUnwrapSettings¢¢Ñ ñ
.¢¢ñ ó
Anchor¢¢ó ù
.¢¢ù û

LowerRight¢¢û ®
)¢¢® ©
s_TempVector2
££ 
.
££ 
x
££ 
=
££  !
max
££" %
.
££% &
x
££& '
-
££( )
$num
££* ,
;
££, -
else
§§ 
s_TempVector2
•• 
.
•• 
x
•• 
=
••  !
(
••" #
min
••# &
.
••& '
x
••' (
+
••) *
(
••+ ,
(
••, -
max
••- 0
.
••0 1
x
••1 2
-
••3 4
min
••5 8
.
••8 9
x
••9 :
)
••: ;
*
••< =
$num
••> A
)
••A B
)
••B C
-
••D E
$num
••F I
;
••I J
if
ßß 
(
ßß 
anchor
ßß 
==
ßß  
AutoUnwrapSettings
ßß ,
.
ßß, -
Anchor
ßß- 3
.
ßß3 4
	UpperLeft
ßß4 =
||
ßß> @
anchor
ßßA G
==
ßßH J 
AutoUnwrapSettings
ßßK ]
.
ßß] ^
Anchor
ßß^ d
.
ßßd e
UpperCenter
ßße p
||
ßßq s
anchor
ßßt z
==
ßß{ }!
AutoUnwrapSettingsßß~ ê
.ßßê ë
Anchorßßë ó
.ßßó ò

UpperRightßßò ¢
)ßß¢ £
s_TempVector2
®® 
.
®® 
y
®® 
=
®®  !
max
®®" %
.
®®% &
y
®®& '
-
®®( )
$num
®®* ,
;
®®, -
else
©© 
if
©© 
(
©© 
anchor
©© 
==
©©  
AutoUnwrapSettings
©© 1
.
©©1 2
Anchor
©©2 8
.
©©8 9

MiddleLeft
©©9 C
||
©©D F
anchor
©©G M
==
©©N P 
AutoUnwrapSettings
©©Q c
.
©©c d
Anchor
©©d j
.
©©j k
MiddleCenter
©©k w
||
©©x z
anchor©©{ Å
==©©Ç Ñ"
AutoUnwrapSettings©©Ö ó
.©©ó ò
Anchor©©ò û
.©©û ü
MiddleRight©©ü ™
)©©™ ´
s_TempVector2
™™ 
.
™™ 
y
™™ 
=
™™  !
(
™™" #
min
™™# &
.
™™& '
y
™™' (
+
™™) *
(
™™+ ,
(
™™, -
max
™™- 0
.
™™0 1
y
™™1 2
-
™™3 4
min
™™5 8
.
™™8 9
y
™™9 :
)
™™: ;
*
™™< =
$num
™™> A
)
™™A B
)
™™B C
-
™™D E
$num
™™F I
;
™™I J
else
´´ 
s_TempVector2
¨¨ 
.
¨¨ 
y
¨¨ 
=
¨¨  !
min
¨¨" %
.
¨¨% &
y
¨¨& '
;
¨¨' (
int
ÆÆ 
len
ÆÆ 
=
ÆÆ 
indexes
ÆÆ 
.
ÆÆ 
Count
ÆÆ #
;
ÆÆ# $
for
∞∞ 
(
∞∞ 
int
∞∞ 
i
∞∞ 
=
∞∞ 
$num
∞∞ 
;
∞∞ 
i
∞∞ 
<
∞∞ 
len
∞∞  #
;
∞∞# $
i
∞∞% &
++
∞∞& (
)
∞∞( )
{
±± 
uvs
≤≤ 
[
≤≤ 
indexes
≤≤ 
[
≤≤ 
i
≤≤ 
]
≤≤ 
]
≤≤ 
.
≤≤  
x
≤≤  !
-=
≤≤" $
s_TempVector2
≤≤% 2
.
≤≤2 3
x
≤≤3 4
;
≤≤4 5
uvs
≥≥ 
[
≥≥ 
indexes
≥≥ 
[
≥≥ 
i
≥≥ 
]
≥≥ 
]
≥≥ 
.
≥≥  
y
≥≥  !
-=
≥≥" $
s_TempVector2
≥≥% 2
.
≥≥2 3
y
≥≥3 4
;
≥≥4 5
}
¥¥ 
}
µµ 	
}
∂∂ 
}∑∑ âC
êD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\FaceRebuildData.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed

 

class

 
FaceRebuildData

  
{ 
public 
Face 
face 
; 
public 
List 
< 
Vertex 
> 
vertices $
;$ %
public 
List 
< 
int 
> 
sharedIndexes &
;& '
public 
List 
< 
int 
> 
sharedIndexesUV (
;( )
private 
int 
_appliedOffset "
=# $
$num% &
;& '
public 
int 
Offset 
( 
) 
{ 	
return 
_appliedOffset !
;! "
} 	
public!! 
override!! 
string!! 
ToString!! '
(!!' (
)!!( )
{"" 	
return## 
string## 
.## 
Format##  
(##  !
$str##! +
,##+ ,
vertices##- 5
.##5 6
ToString##6 >
(##> ?
$str##? C
)##C D
,##D E
sharedIndexes##F S
.##S T
ToString##T \
(##\ ]
$str##] a
)##a b
)##b c
;##c d
}$$ 	
public&& 
static&& 
void&& 
Apply&&  
(&&  !
IEnumerable'' 
<'' 
FaceRebuildData'' '
>''' (
newFaces'') 1
,''1 2
ProBuilderMesh(( 
mesh(( 
,((  
List)) 
<)) 
Vertex)) 
>)) 
vertices)) !
=))" #
null))$ (
,))( )
List** 
<** 
Face** 
>** 
faces** 
=** 
null** #
)**# $
{++ 	
if,, 
(,, 
faces,, 
==,, 
null,, 
),, 
faces-- 
=-- 
new-- 
List--  
<--  !
Face--! %
>--% &
(--& '
mesh--' +
.--+ ,
facesInternal--, 9
)--9 :
;--: ;
if// 
(// 
vertices// 
==// 
null//  
)//  !
vertices00 
=00 
new00 
List00 #
<00# $
Vertex00$ *
>00* +
(00+ ,
mesh00, 0
.000 1
GetVertices001 <
(00< =
)00= >
)00> ?
;00? @
var22 
lookup22 
=22 
mesh22 
.22 
sharedVertexLookup22 0
;220 1
var33 
lookupUV33 
=33 
mesh33 
.33  
sharedTextureLookup33  3
;333 4
Apply55 
(55 
newFaces55 
,55 
vertices55 $
,55$ %
faces55& +
,55+ ,
lookup55- 3
,553 4
lookupUV555 =
)55= >
;55> ?
mesh77 
.77 
SetVertices77 
(77 
vertices77 %
)77% &
;77& '
mesh88 
.88 
faces88 
=88 
faces88 
;88 
mesh99 
.99 
SetSharedVertices99 "
(99" #
lookup99# )
)99) *
;99* +
mesh:: 
.:: 
SetSharedTextures:: "
(::" #
lookupUV::# +
)::+ ,
;::, -
};; 	
publicEE 
staticEE 
voidEE 
ApplyEE  
(EE  !
IEnumerableFF 
<FF 
FaceRebuildDataFF '
>FF' (
newFacesFF) 1
,FF1 2
ListGG 
<GG 
VertexGG 
>GG 
verticesGG !
,GG! "
ListHH 
<HH 
FaceHH 
>HH 
facesHH 
,HH 

DictionaryII 
<II 
intII 
,II 
intII 
>II  
sharedVertexLookupII! 3
,II3 4

DictionaryJJ 
<JJ 
intJJ 
,JJ 
intJJ 
>JJ  
sharedTextureLookupJJ! 4
=JJ5 6
nullJJ7 ;
)JJ; <
{KK 	
intLL 
indexLL 
=LL 
verticesLL  
.LL  !
CountLL! &
;LL& '
foreachNN 
(NN 
FaceRebuildDataNN $
rdNN% '
inNN( *
newFacesNN+ 3
)NN3 4
{OO 
FacePP 
facePP 
=PP 
rdPP 
.PP 
facePP #
;PP# $
intQQ 
faceVertexCountQQ #
=QQ$ %
rdQQ& (
.QQ( )
verticesQQ) 1
.QQ1 2
CountQQ2 7
;QQ7 8
boolSS 
hasSharedIndexesSS %
=SS& '
sharedVertexLookupSS( :
!=SS; =
nullSS> B
&&SSC E
rdSSF H
.SSH I
sharedIndexesSSI V
!=SSW Y
nullSSZ ^
&&SS_ a
rdSSb d
.SSd e
sharedIndexesSSe r
.SSr s
CountSSs x
==SSy {
faceVertexCount	SS| ã
;
SSã å
boolTT 
hasSharedIndexesUVTT '
=TT( )
sharedTextureLookupTT* =
!=TT> @
nullTTA E
&&TTF H
rdTTI K
.TTK L
sharedIndexesUVTTL [
!=TT\ ^
nullTT_ c
&&TTd f
rdTTg i
.TTi j
sharedIndexesUVTTj y
.TTy z
CountTTz 
==
TTÄ Ç
faceVertexCount
TTÉ í
;
TTí ì
forVV 
(VV 
intVV 
nVV 
=VV 
$numVV 
;VV 
nVV  !
<VV" #
faceVertexCountVV$ 3
;VV3 4
nVV5 6
++VV6 8
)VV8 9
{WW 
intXX 

localIndexXX "
=XX# $
nXX% &
;XX& '
ifZZ 
(ZZ 
sharedVertexLookupZZ *
!=ZZ+ -
nullZZ. 2
)ZZ2 3
sharedVertexLookup[[ *
.[[* +
Add[[+ .
([[. /

localIndex[[/ 9
+[[: ;
index[[< A
,[[A B
hasSharedIndexes[[C S
?[[T U
rd[[V X
.[[X Y
sharedIndexes[[Y f
[[[f g

localIndex[[g q
][[q r
:[[s t
-[[u v
$num[[v w
)[[w x
;[[x y
if]] 
(]] 
sharedTextureLookup]] +
!=]], .
null]]/ 3
&&]]4 6
hasSharedIndexesUV]]7 I
)]]I J
sharedTextureLookup^^ +
.^^+ ,
Add^^, /
(^^/ 0

localIndex^^0 :
+^^; <
index^^= B
,^^B C
rd^^D F
.^^F G
sharedIndexesUV^^G V
[^^V W

localIndex^^W a
]^^a b
)^^b c
;^^c d
}__ 
rdaa 
.aa 
_appliedOffsetaa !
=aa" #
indexaa$ )
;aa) *
intbb 
[bb 
]bb 
faceIndexesbb !
=bb" #
facebb$ (
.bb( )
indexesInternalbb) 8
;bb8 9
fordd 
(dd 
intdd 
ndd 
=dd 
$numdd 
,dd 
cdd  !
=dd" #
faceIndexesdd$ /
.dd/ 0
Lengthdd0 6
;dd6 7
ndd8 9
<dd: ;
cdd< =
;dd= >
ndd? @
++dd@ B
)ddB C
faceIndexesee 
[ee  
nee  !
]ee! "
+=ee# %
indexee& +
;ee+ ,
indexgg 
+=gg 
rdgg 
.gg 
verticesgg $
.gg$ %
Countgg% *
;gg* +
facehh 
.hh 
indexesInternalhh $
=hh% &
faceIndexeshh' 2
;hh2 3
facesii 
.ii 
Addii 
(ii 
faceii 
)ii 
;ii  
verticesjj 
.jj 
AddRangejj !
(jj! "
rdjj" $
.jj$ %
verticesjj% -
)jj- .
;jj. /
}kk 
}ll 	
}mm 
}nn ø
íD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\HandleOrientation.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public

 

enum

 
HandleOrientation

 !
{ 
World 
= 
$num 
, 
ActiveObject 
= 
$num 
, 
ActiveElement 
= 
$num 
, 
} 
}   µ{
êD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\InternalUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
InternalUtility  
{ 
[ 	
Obsolete	 
] 
public 
static 
T 
[ 
] 
GetComponents '
<' (
T( )
>) *
(* +
this+ /
IEnumerable0 ;
<; <

GameObject< F
>F G
gameObjectsH S
)S T
whereU Z
T[ \
:] ^
	Component_ h
{ 	
List 
< 
T 
> 
c 
= 
new 
List  
<  !
T! "
>" #
(# $
)$ %
;% &
foreach 
( 

GameObject 
go  "
in# %
gameObjects& 1
)1 2
c 
. 
AddRange 
( 
go 
. 
	transform '
.' (#
GetComponentsInChildren( ?
<? @
T@ A
>A B
(B C
)C D
)D E
;E F
return 
c 
. 
ToArray 
( 
) 
; 
} 	
public 
static 
T 
[ 
] 
GetComponents '
<' (
T( )
>) *
(* +

GameObject+ 5
go6 8
)8 9
where: ?
T@ A
:B C
	ComponentD M
{ 	
return 
go 
. 
	transform 
.  #
GetComponentsInChildren  7
<7 8
T8 9
>9 :
(: ;
); <
;< =
} 	
public 
static 
T 
[ 
] 
GetComponents '
<' (
T( )
>) *
(* +
this+ /
IEnumerable0 ;
<; <
	Transform< E
>E F

transformsG Q
)Q R
whereS X
TY Z
:[ \
	Component] f
{   	
List!! 
<!! 
T!! 
>!! 
c!! 
=!! 
new!! 
List!!  
<!!  !
T!!! "
>!!" #
(!!# $
)!!$ %
;!!% &
foreach"" 
("" 
	Transform"" 
t""  
in""! #

transforms""$ .
)"". /
c## 
.## 
AddRange## 
(## 
t## 
.## #
GetComponentsInChildren## 4
<##4 5
T##5 6
>##6 7
(##7 8
)##8 9
)##9 :
;##: ;
return$$ 
c$$ 
.$$ 
ToArray$$ 
($$ 
)$$ 
as$$ !
T$$" #
[$$# $
]$$$ %
;$$% &
}%% 	
public'' 
static'' 

GameObject''  (
EmptyGameObjectWithTransform''! =
(''= >
	Transform''> G
t''H I
)''I J
{(( 	

GameObject)) 
go)) 
=)), -
new)). 1

GameObject))2 <
())< =
)))= >
;))> ?
go** 
.** 
	transform** 
.** 
position** !
=**, -
t**. /
.**/ 0
position**0 8
;**8 9
go++ 
.++ 
	transform++ 
.++ 
localRotation++ &
=++, -
t++. /
.++/ 0
localRotation++0 =
;++= >
go,, 
.,, 
	transform,, 
.,, 

localScale,, #
=,,, -
t,,. /
.,,/ 0

localScale,,0 :
;,,: ;
StageUtility// 
.// )
PlaceGameObjectInCurrentStage// 6
(//6 7
go//7 9
)//9 :
;//: ;
return22 
go22 
;22 
}33 	
public55 
static55 
T55 
NextEnumValue55 %
<55% &
T55& '
>55' (
(55( )
this55) -
T55. /
current550 7
)557 8
where559 >
T55? @
:55A B
IConvertible55C O
{66 	
Assert77 
.77 
IsTrue77 
(77 
current77 !
is77" $
Enum77% )
)77) *
;77* +
var99 
values99 
=99 
Enum99 
.99 
	GetValues99 '
(99' (
current99( /
.99/ 0
GetType990 7
(997 8
)998 9
)999 :
;99: ;
for;; 
(;; 
int;; 
i;; 
=;; 
$num;; 
,;; 
c;; 
=;; 
values;;  &
.;;& '
Length;;' -
;;;- .
i;;/ 0
<;;1 2
c;;3 4
;;;4 5
i;;6 7
++;;7 9
);;9 :
if<< 
(<< 
current<< 
.<< 
Equals<< "
(<<" #
values<<# )
.<<) *
GetValue<<* 2
(<<2 3
(<<3 4
i<<4 5
)<<5 6
)<<6 7
)<<7 8
)<<8 9
return== 
(== 
T== 
)== 
values== $
.==$ %
GetValue==% -
(==- .
(==. /
i==/ 0
+==1 2
$num==3 4
)==4 5
%==6 7
c==8 9
)==9 :
;==: ;
return?? 
current?? 
;?? 
}@@ 	
publicBB 
staticBB 
stringBB 
ControlKeyStringBB -
(BB- .
charBB. 2
	characterBB3 <
)BB< =
{CC 	
ifDD 
(DD 
	characterDD 
==DD 
PreferenceKeysDD +
.DD+ ,
	CMD_SUPERDD, 5
)DD5 6
returnEE 
$strEE  
;EE  !
elseFF 
ifFF 
(FF 
	characterFF 
==FF !
PreferenceKeysFF" 0
.FF0 1
	CMD_SHIFTFF1 :
)FF: ;
returnGG 
$strGG 
;GG 
elseHH 
ifHH 
(HH 
	characterHH 
==HH !
PreferenceKeysHH" 0
.HH0 1

CMD_OPTIONHH1 ;
)HH; <
returnII 
$strII 
;II 
elseJJ 
ifJJ 
(JJ 
	characterJJ 
==JJ !
PreferenceKeysJJ" 0
.JJ0 1
CMD_ALTJJ1 8
)JJ8 9
returnKK 
$strKK 
;KK 
elseLL 
ifLL 
(LL 
	characterLL 
==LL !
PreferenceKeysLL" 0
.LL0 1

CMD_DELETELL1 ;
)LL; <
returnNN 
$strNN "
;NN" #
elseRR 
returnSS 
	characterSS  
.SS  !
ToStringSS! )
(SS) *
)SS* +
;SS+ ,
}TT 	
publicYY 
staticYY 
boolYY 
TryParseColorYY (
(YY( )
stringYY) /
valueYY0 5
,YY5 6
refYY7 :
ColorYY; @
colYYA D
)YYD E
{ZZ 	
string[[ 
valid[[ 
=[[ 
$str[[ *
;[[* +
value\\ 
=\\ 
new\\ 
string\\ 
(\\ 
value\\ $
.\\$ %
Where\\% *
(\\* +
c\\+ ,
=>\\- /
valid\\0 5
.\\5 6
Contains\\6 >
(\\> ?
c\\? @
)\\@ A
)\\A B
.\\B C
ToArray\\C J
(\\J K
)\\K L
)\\L M
;\\M N
string]] 
[]] 
]]] 
rgba]] 
=]] 
value]] !
.]]! "
Split]]" '
(]]' (
$char]]( +
)]]+ ,
;]], -
if__ 
(__ 
rgba__ 
.__ 
Length__ 
<__ 
$num__ 
)__  
return`` 
false`` 
;`` 
trybb 
{cc 
floatdd 
rdd 
=dd 
floatdd 
.dd  
Parsedd  %
(dd% &
rgbadd& *
[dd* +
$numdd+ ,
]dd, -
)dd- .
;dd. /
floatee 
gee 
=ee 
floatee 
.ee  
Parseee  %
(ee% &
rgbaee& *
[ee* +
$numee+ ,
]ee, -
)ee- .
;ee. /
floatff 
bff 
=ff 
floatff 
.ff  
Parseff  %
(ff% &
rgbaff& *
[ff* +
$numff+ ,
]ff, -
)ff- .
;ff. /
floatgg 
agg 
=gg 
floatgg 
.gg  
Parsegg  %
(gg% &
rgbagg& *
[gg* +
$numgg+ ,
]gg, -
)gg- .
;gg. /
colii 
.ii 
rii 
=ii 
rii 
;ii 
coljj 
.jj 
gjj 
=jj 
gjj 
;jj 
colkk 
.kk 
bkk 
=kk 
bkk 
;kk 
colll 
.ll 
all 
=ll 
all 
;ll 
}mm 
catchnn 
{oo 
returnpp 
falsepp 
;pp 
}qq 
returnss 
truess 
;ss 
}tt 	
public}} 
static}} 
Vector3}} 
[}} 
]}}  
StringToVector3Array}}  4
(}}4 5
string}}5 ;
str}}< ?
)}}? @
{~~ 	
List 
< 
Vector3 
> 
v 
= 
new !
List" &
<& '
Vector3' .
>. /
(/ 0
)0 1
;1 2
str
ÅÅ 
=
ÅÅ 
str
ÅÅ 
.
ÅÅ 
Replace
ÅÅ 
(
ÅÅ 
$str
ÅÅ !
,
ÅÅ! "
$str
ÅÅ# %
)
ÅÅ% &
;
ÅÅ& '
string
ÇÇ 
[
ÇÇ 
]
ÇÇ 
lines
ÇÇ 
=
ÇÇ 
str
ÇÇ  
.
ÇÇ  !
Split
ÇÇ! &
(
ÇÇ& '
$char
ÇÇ' +
)
ÇÇ+ ,
;
ÇÇ, -
foreach
ÑÑ 
(
ÑÑ 
string
ÑÑ 
vec
ÑÑ 
in
ÑÑ  "
lines
ÑÑ# (
)
ÑÑ( )
{
ÖÖ 
if
ÜÜ 
(
ÜÜ 
vec
ÜÜ 
.
ÜÜ 
Contains
ÜÜ  
(
ÜÜ  !
$str
ÜÜ! %
)
ÜÜ% &
)
ÜÜ& '
continue
áá 
;
áá 
string
ââ 
[
ââ 
]
ââ 
values
ââ 
=
ââ  !
vec
ââ" %
.
ââ% &
Split
ââ& +
(
ââ+ ,
$char
ââ, /
)
ââ/ 0
;
ââ0 1
if
ãã 
(
ãã 
values
ãã 
.
ãã 
Length
ãã !
<
ãã" #
$num
ãã$ %
)
ãã% &
continue
åå 
;
åå 
float
éé 
v0
éé 
,
éé 
v1
éé 
,
éé 
v2
éé  
;
éé  !
if
èè 
(
èè 
!
èè 
float
èè 
.
èè 
TryParse
èè #
(
èè# $
values
èè$ *
[
èè* +
$num
èè+ ,
]
èè, -
,
èè- .
System
èè/ 5
.
èè5 6
Globalization
èè6 C
.
èèC D
NumberStyles
èèD P
.
èèP Q
Any
èèQ T
,
èèT U
System
èèV \
.
èè\ ]
Globalization
èè] j
.
èèj k
CultureInfo
èèk v
.
èèv w
InvariantCultureèèw á
,èèá à
outèèâ å
v0èèç è
)èèè ê
)èèê ë
continue
êê 
;
êê 
if
ëë 
(
ëë 
!
ëë 
float
ëë 
.
ëë 
TryParse
ëë #
(
ëë# $
values
ëë$ *
[
ëë* +
$num
ëë+ ,
]
ëë, -
,
ëë- .
System
ëë/ 5
.
ëë5 6
Globalization
ëë6 C
.
ëëC D
NumberStyles
ëëD P
.
ëëP Q
Any
ëëQ T
,
ëëT U
System
ëëV \
.
ëë\ ]
Globalization
ëë] j
.
ëëj k
CultureInfo
ëëk v
.
ëëv w
InvariantCultureëëw á
,ëëá à
outëëâ å
v1ëëç è
)ëëè ê
)ëëê ë
continue
íí 
;
íí 
if
ìì 
(
ìì 
!
ìì 
float
ìì 
.
ìì 
TryParse
ìì #
(
ìì# $
values
ìì$ *
[
ìì* +
$num
ìì+ ,
]
ìì, -
,
ìì- .
System
ìì/ 5
.
ìì5 6
Globalization
ìì6 C
.
ììC D
NumberStyles
ììD P
.
ììP Q
Any
ììQ T
,
ììT U
System
ììV \
.
ìì\ ]
Globalization
ìì] j
.
ììj k
CultureInfo
ììk v
.
ììv w
InvariantCultureììw á
,ììá à
outììâ å
v2ììç è
)ììè ê
)ììê ë
continue
îî 
;
îî 
v
ïï 
.
ïï 
Add
ïï 
(
ïï 
new
ïï 
Vector3
ïï !
(
ïï! "
v0
ïï" $
,
ïï$ %
v1
ïï& (
,
ïï( )
v2
ïï* ,
)
ïï, -
)
ïï- .
;
ïï. /
}
ññ 
return
óó 
v
óó 
.
óó 
ToArray
óó 
(
óó 
)
óó 
;
óó 
}
òò 	
public
©© 
static
©© 
T
©© 
DemandComponent
©© '
<
©©' (
T
©©( )
>
©©) *
(
©©* +
this
©©+ /
	Component
©©0 9
	component
©©: C
)
©©C D
where
©©E J
T
©©K L
:
©©M N
	Component
©©O X
{
™™ 	
return
´´ 
	component
´´ 
.
´´ 

gameObject
´´ '
.
´´' (
DemandComponent
´´( 7
<
´´7 8
T
´´8 9
>
´´9 :
(
´´: ;
)
´´; <
;
´´< =
}
¨¨ 	
public
ÆÆ 
static
ÆÆ 
T
ÆÆ 
DemandComponent
ÆÆ '
<
ÆÆ' (
T
ÆÆ( )
>
ÆÆ) *
(
ÆÆ* +
this
ÆÆ+ /

GameObject
ÆÆ0 :

gameObject
ÆÆ; E
)
ÆÆE F
where
ÆÆG L
T
ÆÆM N
:
ÆÆO P
	Component
ÆÆQ Z
{
ØØ 	
T
∞∞ 
	component
∞∞ 
;
∞∞ 
if
±± 
(
±± 
!
±± 

gameObject
±± 
.
±± 
TryGetComponent
±± +
<
±±+ ,
T
±±, -
>
±±- .
(
±±. /
out
±±/ 2
	component
±±3 <
)
±±< =
)
±±= >
	component
≤≤ 
=
≤≤ 

gameObject
≤≤ &
.
≤≤& '
AddComponent
≤≤' 3
<
≤≤3 4
T
≤≤4 5
>
≤≤5 6
(
≤≤6 7
)
≤≤7 8
;
≤≤8 9
return
≥≥ 
	component
≥≥ 
;
≥≥ 
}
¥¥ 	
}
µµ 
}∂∂ ≠
áD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Normal.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

struct 
Normal 
: 

IEquatable %
<% &
Normal& ,
>, -
{		 
public 
Vector3 
normal 
{ 
get  #
;# $
set% (
;( )
}* +
public 
Vector4 
tangent 
{  
get! $
;$ %
set& )
;) *
}+ ,
public 
Vector3 
	bitangent  
{! "
get# &
;& '
set( +
;+ ,
}- .
public 
override 
bool 
Equals #
(# $
object$ *
obj+ .
). /
{ 	
return 
obj 
is 
Normal  
&&! #
Equals$ *
(* +
(+ ,
Normal, 2
)2 3
obj3 6
)6 7
;7 8
} 	
public 
override 
int 
GetHashCode '
(' (
)( )
{ 	
	unchecked   
{!! 
int"" 
hashCode"" 
="" 

VectorHash"" )
."") *
GetHashCode""* 5
(""5 6
normal""6 <
)""< =
;""= >
hashCode## 
=## 
(## 
hashCode## $
*##% &
$num##' *
)##* +
^##, -

VectorHash##. 8
.##8 9
GetHashCode##9 D
(##D E
tangent##E L
)##L M
;##M N
hashCode$$ 
=$$ 
($$ 
hashCode$$ $
*$$% &
$num$$' *
)$$* +
^$$, -

VectorHash$$. 8
.$$8 9
GetHashCode$$9 D
($$D E
	bitangent$$E N
)$$N O
;$$O P
return%% 
hashCode%% 
;%%  
}&& 
}'' 	
public)) 
bool)) 
Equals)) 
()) 
Normal)) !
other))" '
)))' (
{** 	
return++ 
Math++ 
.++ 
Approx3++ 
(++  
normal++  &
,++& '
other++( -
.++- .
normal++. 4
)++4 5
&&++6 8
Math,, 
.,, 
Approx3,, 
(,, 
tangent,, $
,,,$ %
other,,& +
.,,+ ,
tangent,,, 3
),,3 4
&&,,5 7
Math-- 
.-- 
Approx3-- 
(-- 
	bitangent-- &
,--& '
other--( -
.--- .
	bitangent--. 7
)--7 8
;--8 9
}.. 	
public00 
static00 
bool00 
operator00 #
==00# %
(00% &
Normal00& ,
a00- .
,00. /
Normal000 6
b007 8
)008 9
{11 	
return22 
a22 
.22 
Equals22 
(22 
b22 
)22 
;22 
}33 	
public55 
static55 
bool55 
operator55 #
!=55# %
(55% &
Normal55& ,
a55- .
,55. /
Normal550 6
b557 8
)558 9
{66 	
return77 
!77 
(77 
a77 
==77 
b77 
)77 
;77 
}88 	
}99 
}:: ‘
áD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Entity.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[		 %
DisallowMultipleComponent		 
]		 
[

 
AddComponentMenu

 
(

 
$str

 
)

 
]

 
sealed 

class 
Entity 
: 
MonoBehaviour '
{ 
public 

EntityType 

entityType $
{% &
get' *
{+ ,
return- 3
m_EntityType4 @
;@ A
}B C
}D E
[ 	
SerializeField	 
] 
[ 	
HideInInspector	 
] 
[ 	 
FormerlySerializedAs	 
( 
$str +
)+ ,
], -

EntityType 
m_EntityType 
;  
public 
void 
Awake 
( 
) 
{ 	
MeshRenderer 
mr 
= 
GetComponent *
<* +
MeshRenderer+ 7
>7 8
(8 9
)9 :
;: ;
if 
( 
! 
mr 
) 
return 
; 
switch 
( 

entityType 
) 
{ 
case 

EntityType 
.  
Occluder  (
:( )
break   
;   
case"" 

EntityType"" 
.""  
Detail""  &
:""& '
break## 
;## 
case%% 

EntityType%% 
.%%  
Trigger%%  '
:%%' (
mr&& 
.&& 
enabled&& 
=&&  
false&&! &
;&&& '
break'' 
;'' 
case)) 

EntityType)) 
.))  
Collider))  (
:))( )
mr** 
.** 
enabled** 
=**  
false**! &
;**& '
break++ 
;++ 
},, 
}-- 	
public33 
void33 
	SetEntity33 
(33 

EntityType33 (
t33) *
)33* +
{44 	
m_EntityType55 
=55 
t55 
;55 
}66 	
}77 
}88 ˛6
ãD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\EdgeLookup.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

struct 

EdgeLookup 
: 

IEquatable )
<) *

EdgeLookup* 4
>4 5
{ 
Edge 
m_Local 
; 
Edge 
m_Common 
; 
public 
Edge 
local 
{ 	
get 
{ 
return 
m_Local  
;  !
}" #
set 
{ 
m_Local 
= 
value !
;! "
}# $
} 	
public   
Edge   
common   
{!! 	
get"" 
{"" 
return"" 
m_Common"" !
;""! "
}""# $
set## 
{## 
m_Common## 
=## 
value## "
;##" #
}##$ %
}$$ 	
public++ 

EdgeLookup++ 
(++ 
Edge++ 
common++ %
,++% &
Edge++' +
local++, 1
)++1 2
{,, 	
m_Common-- 
=-- 
common-- 
;-- 
m_Local.. 
=.. 
local.. 
;.. 
}// 	
public88 

EdgeLookup88 
(88 
int88 
cx88  
,88  !
int88" %
cy88& (
,88( )
int88* -
x88. /
,88/ 0
int881 4
y885 6
)886 7
{99 	
m_Common:: 
=:: 
new:: 
Edge:: 
(::  
cx::  "
,::" #
cy::$ &
)::& '
;::' (
m_Local;; 
=;; 
new;; 
Edge;; 
(;; 
x;;  
,;;  !
y;;" #
);;# $
;;;$ %
}<< 	
publicCC 
boolCC 
EqualsCC 
(CC 

EdgeLookupCC %
otherCC& +
)CC+ ,
{DD 	
returnEE 
otherEE 
.EE 
commonEE 
.EE  
EqualsEE  &
(EE& '
commonEE' -
)EE- .
;EE. /
}FF 	
publicMM 
overrideMM 
boolMM 
EqualsMM #
(MM# $
objectMM$ *
objMM+ .
)MM. /
{NN 	
returnOO 
!OO 
ReferenceEqualsOO #
(OO# $
objOO$ '
,OO' (
nullOO) -
)OO- .
&&OO/ 1
EqualsOO2 8
(OO8 9
(OO9 :

EdgeLookupOO: D
)OOD E
objOOE H
)OOH I
;OOI J
}PP 	
publicRR 
overrideRR 
intRR 
GetHashCodeRR '
(RR' (
)RR( )
{SS 	
returnTT 
commonTT 
.TT 
GetHashCodeTT %
(TT% &
)TT& '
;TT' (
}UU 	
publicWW 
staticWW 
boolWW 
operatorWW #
==WW# %
(WW% &

EdgeLookupWW& 0
aWW1 2
,WW2 3

EdgeLookupWW4 >
bWW? @
)WW@ A
{XX 	
returnYY 
EqualsYY 
(YY 
aYY 
,YY 
bYY 
)YY 
;YY  
}ZZ 	
public\\ 
static\\ 
bool\\ 
operator\\ #
!=\\# %
(\\% &

EdgeLookup\\& 0
a\\1 2
,\\2 3

EdgeLookup\\4 >
b\\? @
)\\@ A
{]] 	
return^^ 
!^^ 
Equals^^ 
(^^ 
a^^ 
,^^ 
b^^ 
)^^  
;^^  !
}__ 	
publicee 
overrideee 
stringee 
ToStringee '
(ee' (
)ee( )
{ff 	
returngg 
stringgg 
.gg 
Formatgg  
(gg  !
$strgg! H
,ggH I
commonggJ P
.ggP Q
aggQ R
,ggR S
commonggT Z
.ggZ [
bgg[ \
,gg\ ]
localgg^ c
.ggc d
aggd e
,gge f
localggg l
.ggl m
bggm n
)ggn o
;ggo p
}hh 	
publicpp 
staticpp 
IEnumerablepp !
<pp! "

EdgeLookuppp" ,
>pp, -
GetEdgeLookuppp. ;
(pp; <
IEnumerablepp< G
<ppG H
EdgeppH L
>ppL M
edgesppN S
,ppS T

DictionaryppU _
<pp_ `
intpp` c
,ppc d
intppe h
>pph i
lookupppj p
)ppp q
{qq 	
returnrr 
edgesrr 
.rr 
Selectrr 
(rr  
xrr  !
=>rr" $
newrr% (

EdgeLookuprr) 3
(rr3 4
newrr4 7
Edgerr8 <
(rr< =
lookuprr= C
[rrC D
xrrD E
.rrE F
arrF G
]rrG H
,rrH I
lookuprrJ P
[rrP Q
xrrQ R
.rrR S
brrS T
]rrT U
)rrU V
,rrV W
xrrX Y
)rrY Z
)rrZ [
;rr[ \
}ss 	
public{{ 
static{{ 
HashSet{{ 
<{{ 

EdgeLookup{{ (
>{{( ) 
GetEdgeLookupHashSet{{* >
({{> ?
IEnumerable{{? J
<{{J K
Edge{{K O
>{{O P
edges{{Q V
,{{V W

Dictionary{{X b
<{{b c
int{{c f
,{{f g
int{{h k
>{{k l
lookup{{m s
){{s t
{|| 	
if}} 
(}} 
lookup}} 
==}} 
null}} 
||}} !
edges}}" '
==}}( *
null}}+ /
)}}/ 0
return~~ 
null~~ 
;~~ 
var 
hash 
= 
new 
HashSet "
<" #

EdgeLookup# -
>- .
(. /
)/ 0
;0 1
foreach
ÄÄ 
(
ÄÄ 
var
ÄÄ 
local
ÄÄ 
in
ÄÄ !
edges
ÄÄ" '
)
ÄÄ' (
hash
ÅÅ 
.
ÅÅ 
Add
ÅÅ 
(
ÅÅ 
new
ÅÅ 

EdgeLookup
ÅÅ '
(
ÅÅ' (
new
ÅÅ( +
Edge
ÅÅ, 0
(
ÅÅ0 1
lookup
ÅÅ1 7
[
ÅÅ7 8
local
ÅÅ8 =
.
ÅÅ= >
a
ÅÅ> ?
]
ÅÅ? @
,
ÅÅ@ A
lookup
ÅÅB H
[
ÅÅH I
local
ÅÅI N
.
ÅÅN O
b
ÅÅO P
]
ÅÅP Q
)
ÅÅQ R
,
ÅÅR S
local
ÅÅT Y
)
ÅÅY Z
)
ÅÅZ [
;
ÅÅ[ \
return
ÇÇ 
hash
ÇÇ 
;
ÇÇ 
}
ÉÉ 	
}
ÑÑ 
}ÖÖ ƒ≥
âD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Bounds2D.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed

 

class

 
Bounds2D

 
{ 
public 
Vector2 
center 
= 
Vector2  '
.' (
zero( ,
;, -
[ 	
SerializeField	 
] 
Vector2  
m_Size! '
=( )
Vector2* 1
.1 2
zero2 6
;6 7
[ 	
SerializeField	 
] 
Vector2  
	m_Extents! *
=+ ,
Vector2- 4
.4 5
zero5 9
;9 :
public 
Vector2 
size 
{ 	
get 
{ 
return 
m_Size 
;  
}! "
set 
{ 
m_Size 
= 
value 
; 
	m_Extents 
. 
x 
= 
m_Size $
.$ %
x% &
*' (
$num) ,
;, -
	m_Extents 
. 
y 
= 
m_Size $
.$ %
y% &
*' (
$num) ,
;, -
} 
} 	
public 
Vector2 
extents 
{ 	
get 
{ 
return 
	m_Extents "
;" #
}$ %
}   	
public%% 
Vector2%% 
[%% 
]%% 
corners%%  
{&& 	
get'' 
{(( 
return)) 
new)) 
Vector2)) "
[))" #
]))# $
{))% &
new** 
Vector2** 
(**  
center**  &
.**& '
x**' (
-**) *
extents**+ 2
.**2 3
x**3 4
,**4 5
center**6 <
.**< =
y**= >
+**? @
extents**A H
.**H I
y**I J
)**J K
,**K L
new++ 
Vector2++ 
(++  
center++  &
.++& '
x++' (
+++) *
extents+++ 2
.++2 3
x++3 4
,++4 5
center++6 <
.++< =
y++= >
+++? @
extents++A H
.++H I
y++I J
)++J K
,++K L
new,, 
Vector2,, 
(,,  
center,,  &
.,,& '
x,,' (
-,,) *
extents,,+ 2
.,,2 3
x,,3 4
,,,4 5
center,,6 <
.,,< =
y,,= >
-,,? @
extents,,A H
.,,H I
y,,I J
),,J K
,,,K L
new-- 
Vector2-- 
(--  
center--  &
.--& '
x--' (
+--) *
extents--+ 2
.--2 3
x--3 4
,--4 5
center--6 <
.--< =
y--= >
---? @
extents--A H
.--H I
y--I J
)--J K
}.. 
;.. 
}// 
}00 	
public22 
Bounds2D22 
(22 
)22 
{33 	
}33	 

public55 
Bounds2D55 
(55 
Vector255 
center55  &
,55& '
Vector255( /
size550 4
)554 5
{66 	
this77 
.77 
center77 
=77 
center77  
;77  !
this88 
.88 
size88 
=88 
size88 
;88 
}99 	
public?? 
Bounds2D?? 
(?? 
IList?? 
<?? 
Vector2?? %
>??% &
points??' -
)??- .
{@@ 	
SetWithPointsAA 
(AA 
pointsAA  
)AA  !
;AA! "
}BB 	
publicII 
Bounds2DII 
(II 
IListII 
<II 
Vector2II %
>II% &
pointsII' -
,II- .
IListII/ 4
<II4 5
intII5 8
>II8 9
indexesII: A
)IIA B
{JJ 	
SetWithPointsKK 
(KK 
pointsKK  
,KK  !
indexesKK" )
)KK) *
;KK* +
}LL 	
internalSS 
Bounds2DSS 
(SS 
Vector3SS !
[SS! "
]SS" #
pointsSS$ *
,SS* +
EdgeSS, 0
[SS0 1
]SS1 2
edgesSS3 8
)SS8 9
{TT 	
floatUU 
xMinUU 
=UU 
$numUU 
,UU 
xMaxVV$ (
=VV) *
$numVV+ -
,VV- .
yMinWW$ (
=WW) *
$numWW+ -
,WW- .
yMaxXX$ (
=XX) *
$numXX+ -
;XX- .
ifZZ 
(ZZ 
pointsZZ 
.ZZ 
LengthZZ 
>ZZ 
$numZZ  !
&&ZZ" $
edgesZZ% *
.ZZ* +
LengthZZ+ 1
>ZZ2 3
$numZZ4 5
)ZZ5 6
{[[ 
xMin\\ 
=\\ 
points\\ 
[\\ 
edges\\ #
[\\# $
$num\\$ %
]\\% &
.\\& '
a\\' (
]\\( )
.\\) *
x\\* +
;\\+ ,
yMin]] 
=]] 
points]] 
[]] 
edges]] #
[]]# $
$num]]$ %
]]]% &
.]]& '
a]]' (
]]]( )
.]]) *
y]]* +
;]]+ ,
xMax^^ 
=^^ 
xMin^^ 
;^^ 
yMax__ 
=__ 
yMin__ 
;__ 
foraa 
(aa 
intaa 
iaa 
=aa 
$numaa 
;aa 
iaa  !
<aa" #
edgesaa$ )
.aa) *
Lengthaa* 0
;aa0 1
iaa2 3
++aa3 5
)aa5 6
{bb 
xMincc 
=cc 
Mathfcc  
.cc  !
Mincc! $
(cc$ %
xMincc% )
,cc) *
pointscc+ 1
[cc1 2
edgescc2 7
[cc7 8
icc8 9
]cc9 :
.cc: ;
acc; <
]cc< =
.cc= >
xcc> ?
)cc? @
;cc@ A
xMindd 
=dd 
Mathfdd  
.dd  !
Mindd! $
(dd$ %
xMindd% )
,dd) *
pointsdd+ 1
[dd1 2
edgesdd2 7
[dd7 8
idd8 9
]dd9 :
.dd: ;
bdd; <
]dd< =
.dd= >
xdd> ?
)dd? @
;dd@ A
yMinee 
=ee 
Mathfee  
.ee  !
Minee! $
(ee$ %
yMinee% )
,ee) *
pointsee+ 1
[ee1 2
edgesee2 7
[ee7 8
iee8 9
]ee9 :
.ee: ;
aee; <
]ee< =
.ee= >
yee> ?
)ee? @
;ee@ A
yMinff 
=ff 
Mathfff  
.ff  !
Minff! $
(ff$ %
yMinff% )
,ff) *
pointsff+ 1
[ff1 2
edgesff2 7
[ff7 8
iff8 9
]ff9 :
.ff: ;
bff; <
]ff< =
.ff= >
yff> ?
)ff? @
;ff@ A
xMaxhh 
=hh 
Mathfhh  
.hh  !
Maxhh! $
(hh$ %
xMaxhh% )
,hh) *
pointshh+ 1
[hh1 2
edgeshh2 7
[hh7 8
ihh8 9
]hh9 :
.hh: ;
ahh; <
]hh< =
.hh= >
xhh> ?
)hh? @
;hh@ A
xMaxii 
=ii 
Mathfii  
.ii  !
Maxii! $
(ii$ %
xMaxii% )
,ii) *
pointsii+ 1
[ii1 2
edgesii2 7
[ii7 8
iii8 9
]ii9 :
.ii: ;
bii; <
]ii< =
.ii= >
xii> ?
)ii? @
;ii@ A
yMaxjj 
=jj 
Mathfjj  
.jj  !
Maxjj! $
(jj$ %
yMaxjj% )
,jj) *
pointsjj+ 1
[jj1 2
edgesjj2 7
[jj7 8
ijj8 9
]jj9 :
.jj: ;
ajj; <
]jj< =
.jj= >
yjj> ?
)jj? @
;jj@ A
yMaxkk 
=kk 
Mathfkk  
.kk  !
Maxkk! $
(kk$ %
yMaxkk% )
,kk) *
pointskk+ 1
[kk1 2
edgeskk2 7
[kk7 8
ikk8 9
]kk9 :
.kk: ;
bkk; <
]kk< =
.kk= >
ykk> ?
)kk? @
;kk@ A
}ll 
}mm 
thisoo 
.oo 
centeroo 
=oo 
newoo 
Vector2oo %
(oo% &
(oo& '
xMinoo' +
+oo, -
xMaxoo. 2
)oo2 3
/oo4 5
$numoo6 8
,oo8 9
(oo: ;
yMinoo; ?
+oo@ A
yMaxooB F
)ooF G
/ooH I
$numooJ L
)ooL M
;ooM N
thispp 
.pp 
sizepp 
=pp 
newpp 
Vector3pp #
(pp# $
xMaxpp$ (
-pp) *
xMinpp+ /
,pp/ 0
yMaxpp1 5
-pp6 7
yMinpp8 <
)pp< =
;pp= >
}qq 	
publicss 
Bounds2Dss 
(ss 
Vector2ss 
[ss  
]ss  !
pointsss" (
,ss( )
intss* -
lengthss. 4
)ss4 5
{tt 	
floatuu 
xMinuu 
=uu 
$numuu 
,uu 
xMaxvv" &
=vv' (
$numvv) +
,vv+ ,
yMinww" &
=ww' (
$numww) +
,ww+ ,
yMaxxx" &
=xx' (
$numxx) +
;xx+ ,
ifzz 
(zz 
pointszz 
.zz 
Lengthzz 
>zz 
$numzz  !
)zz! "
{{{ 
xMin|| 
=|| 
points|| 
[|| 
$num|| 
]||  
.||  !
x||! "
;||" #
yMin}} 
=}} 
points}} 
[}} 
$num}} 
]}}  
.}}  !
y}}! "
;}}" #
xMax~~ 
=~~ 
xMin~~ 
;~~ 
yMax 
= 
yMin 
; 
for
ÅÅ 
(
ÅÅ 
int
ÅÅ 
i
ÅÅ 
=
ÅÅ 
$num
ÅÅ 
;
ÅÅ 
i
ÅÅ  !
<
ÅÅ" #
length
ÅÅ$ *
;
ÅÅ* +
i
ÅÅ, -
++
ÅÅ- /
)
ÅÅ/ 0
{
ÇÇ 
xMin
ÉÉ 
=
ÉÉ 
Mathf
ÉÉ  
.
ÉÉ  !
Min
ÉÉ! $
(
ÉÉ$ %
xMin
ÉÉ% )
,
ÉÉ) *
points
ÉÉ+ 1
[
ÉÉ1 2
i
ÉÉ2 3
]
ÉÉ3 4
.
ÉÉ4 5
x
ÉÉ5 6
)
ÉÉ6 7
;
ÉÉ7 8
yMin
ÑÑ 
=
ÑÑ 
Mathf
ÑÑ  
.
ÑÑ  !
Min
ÑÑ! $
(
ÑÑ$ %
yMin
ÑÑ% )
,
ÑÑ) *
points
ÑÑ+ 1
[
ÑÑ1 2
i
ÑÑ2 3
]
ÑÑ3 4
.
ÑÑ4 5
y
ÑÑ5 6
)
ÑÑ6 7
;
ÑÑ7 8
xMax
ÜÜ 
=
ÜÜ 
Mathf
ÜÜ  
.
ÜÜ  !
Max
ÜÜ! $
(
ÜÜ$ %
xMax
ÜÜ% )
,
ÜÜ) *
points
ÜÜ+ 1
[
ÜÜ1 2
i
ÜÜ2 3
]
ÜÜ3 4
.
ÜÜ4 5
x
ÜÜ5 6
)
ÜÜ6 7
;
ÜÜ7 8
yMax
áá 
=
áá 
Mathf
áá  
.
áá  !
Max
áá! $
(
áá$ %
yMax
áá% )
,
áá) *
points
áá+ 1
[
áá1 2
i
áá2 3
]
áá3 4
.
áá4 5
y
áá5 6
)
áá6 7
;
áá7 8
}
àà 
}
ââ 
this
ãã 
.
ãã 
center
ãã 
=
ãã 
new
ãã 
Vector2
ãã %
(
ãã% &
(
ãã& '
xMin
ãã' +
+
ãã, -
xMax
ãã. 2
)
ãã2 3
/
ãã4 5
$num
ãã6 8
,
ãã8 9
(
ãã: ;
yMin
ãã; ?
+
ãã@ A
yMax
ããB F
)
ããF G
/
ããH I
$num
ããJ L
)
ããL M
;
ããM N
this
åå 
.
åå 
size
åå 
=
åå 
new
åå 
Vector3
åå #
(
åå# $
xMax
åå$ (
-
åå) *
xMin
åå+ /
,
åå/ 0
yMax
åå1 5
-
åå6 7
yMin
åå8 <
)
åå< =
;
åå= >
}
çç 	
public
îî 
bool
îî 
ContainsPoint
îî !
(
îî! "
Vector2
îî" )
point
îî* /
)
îî/ 0
{
ïï 	
return
ññ 
!
ññ 
(
ññ 
point
ññ 
.
ññ 
x
ññ 
>
ññ 
center
ññ %
.
ññ% &
x
ññ& '
+
ññ( )
extents
ññ* 1
.
ññ1 2
x
ññ2 3
||
ññ4 6
point
óó 
.
óó 
x
óó 
<
óó 
center
óó %
.
óó% &
x
óó& '
-
óó( )
extents
óó* 1
.
óó1 2
x
óó2 3
||
óó4 6
point
òò 
.
òò 
y
òò 
>
òò 
center
òò %
.
òò% &
y
òò& '
+
òò( )
extents
òò* 1
.
òò1 2
y
òò2 3
||
òò4 6
point
ôô 
.
ôô 
y
ôô 
<
ôô 
center
ôô %
.
ôô% &
y
ôô& '
-
ôô( )
extents
ôô* 1
.
ôô1 2
y
ôô2 3
)
ôô3 4
;
ôô4 5
}
öö 	
public
¢¢ 
bool
¢¢ #
IntersectsLineSegment
¢¢ )
(
¢¢) *
Vector2
¢¢* 1
	lineStart
¢¢2 ;
,
¢¢; <
Vector2
¢¢= D
lineEnd
¢¢E L
)
¢¢L M
{
££ 	
if
§§ 
(
§§ 
ContainsPoint
§§ 
(
§§ 
	lineStart
§§ '
)
§§' (
||
§§) +
ContainsPoint
§§, 9
(
§§9 :
lineEnd
§§: A
)
§§A B
)
§§B C
{
•• 
return
¶¶ 
true
¶¶ 
;
¶¶ 
}
ßß 
else
®® 
{
©© 
Vector2
™™ 
[
™™ 
]
™™ 
aabb
™™ 
=
™™  
corners
™™! (
;
™™( )
return
´´ 
(
´´ 
Math
´´ 
.
´´ %
GetLineSegmentIntersect
´´ 4
(
´´4 5
aabb
´´5 9
[
´´9 :
$num
´´: ;
]
´´; <
,
´´< =
aabb
´´> B
[
´´B C
$num
´´C D
]
´´D E
,
´´E F
	lineStart
´´G P
,
´´P Q
lineEnd
´´R Y
)
´´Y Z
||
´´[ ]
Math
¨¨ 
.
¨¨ %
GetLineSegmentIntersect
¨¨ 4
(
¨¨4 5
aabb
¨¨5 9
[
¨¨9 :
$num
¨¨: ;
]
¨¨; <
,
¨¨< =
aabb
¨¨> B
[
¨¨B C
$num
¨¨C D
]
¨¨D E
,
¨¨E F
	lineStart
¨¨G P
,
¨¨P Q
lineEnd
¨¨R Y
)
¨¨Y Z
||
¨¨[ ]
Math
≠≠ 
.
≠≠ %
GetLineSegmentIntersect
≠≠ 4
(
≠≠4 5
aabb
≠≠5 9
[
≠≠9 :
$num
≠≠: ;
]
≠≠; <
,
≠≠< =
aabb
≠≠> B
[
≠≠B C
$num
≠≠C D
]
≠≠D E
,
≠≠E F
	lineStart
≠≠G P
,
≠≠P Q
lineEnd
≠≠R Y
)
≠≠Y Z
||
≠≠[ ]
Math
ÆÆ 
.
ÆÆ %
GetLineSegmentIntersect
ÆÆ 4
(
ÆÆ4 5
aabb
ÆÆ5 9
[
ÆÆ9 :
$num
ÆÆ: ;
]
ÆÆ; <
,
ÆÆ< =
aabb
ÆÆ> B
[
ÆÆB C
$num
ÆÆC D
]
ÆÆD E
,
ÆÆE F
	lineStart
ÆÆG P
,
ÆÆP Q
lineEnd
ÆÆR Y
)
ÆÆY Z
)
ÆÆZ [
;
ÆÆ[ \
}
ØØ 
}
∞∞ 	
public
∑∑ 
bool
∑∑ 

Intersects
∑∑ 
(
∑∑ 
Bounds2D
∑∑ '
bounds
∑∑( .
)
∑∑. /
{
∏∏ 	
Vector2
ππ 
dist
ππ 
=
ππ 
this
ππ 
.
ππ  
center
ππ  &
-
ππ' (
bounds
ππ) /
.
ππ/ 0
center
ππ0 6
;
ππ6 7
Vector2
∫∫ 
size
∫∫ 
=
∫∫ 
this
∫∫ 
.
∫∫  
size
∫∫  $
+
∫∫% &
bounds
∫∫' -
.
∫∫- .
size
∫∫. 2
;
∫∫2 3
return
ºº 
Mathf
ºº 
.
ºº 
Abs
ºº 
(
ºº 
dist
ºº !
.
ºº! "
x
ºº" #
)
ºº# $
*
ºº% &
$num
ºº' )
<
ºº* +
size
ºº, 0
.
ºº0 1
x
ºº1 2
&&
ºº3 5
Mathf
ΩΩ 
.
ΩΩ 
Abs
ΩΩ 
(
ΩΩ 
dist
ΩΩ 
.
ΩΩ 
y
ΩΩ  
)
ΩΩ  !
*
ΩΩ" #
$num
ΩΩ$ &
<
ΩΩ' (
size
ΩΩ) -
.
ΩΩ- .
y
ΩΩ. /
;
ΩΩ/ 0
}
ææ 	
public
≈≈ 
bool
≈≈ 

Intersects
≈≈ 
(
≈≈ 
Rect
≈≈ #
rect
≈≈$ (
)
≈≈( )
{
∆∆ 	
Vector2
«« 
dist
«« 
=
«« 
this
«« 
.
««  
center
««  &
-
««' (
rect
««) -
.
««- .
center
««. 4
;
««4 5
Vector2
»» 
size
»» 
=
»» 
this
»» 
.
»»  
size
»»  $
+
»»% &
rect
»»' +
.
»»+ ,
size
»», 0
;
»»0 1
return
   
Mathf
   
.
   
Abs
   
(
   
dist
   !
.
  ! "
x
  " #
)
  # $
*
  % &
$num
  ' )
<
  * +
size
  , 0
.
  0 1
x
  1 2
&&
  3 5
Mathf
ÀÀ 
.
ÀÀ 
Abs
ÀÀ 
(
ÀÀ 
dist
ÀÀ 
.
ÀÀ 
y
ÀÀ  
)
ÀÀ  !
*
ÀÀ" #
$num
ÀÀ$ &
<
ÀÀ' (
size
ÀÀ) -
.
ÀÀ- .
y
ÀÀ. /
;
ÀÀ/ 0
}
ÃÃ 	
public
““ 
void
““ 
SetWithPoints
““ !
(
““! "
IList
““" '
<
““' (
Vector2
““( /
>
““/ 0
points
““1 7
)
““7 8
{
”” 	
float
‘‘ 
xMin
‘‘ 
=
‘‘ 
$num
‘‘ 
,
‘‘ 
xMax
’’ 
=
’’ 
$num
’’ 
,
’’ 
yMin
÷÷ 
=
÷÷ 
$num
÷÷ 
,
÷÷ 
yMax
◊◊ 
=
◊◊ 
$num
◊◊ 
;
◊◊ 
int
ŸŸ 
len
ŸŸ 
=
ŸŸ 
points
ŸŸ 
.
ŸŸ 
Count
ŸŸ "
;
ŸŸ" #
if
€€ 
(
€€ 
len
€€ 
>
€€ 
$num
€€ 
)
€€ 
{
‹‹ 
xMin
›› 
=
›› 
points
›› 
[
›› 
$num
›› 
]
››  
.
››  !
x
››! "
;
››" #
yMin
ﬁﬁ 
=
ﬁﬁ 
points
ﬁﬁ 
[
ﬁﬁ 
$num
ﬁﬁ 
]
ﬁﬁ  
.
ﬁﬁ  !
y
ﬁﬁ! "
;
ﬁﬁ" #
xMax
ﬂﬂ 
=
ﬂﬂ 
xMin
ﬂﬂ 
;
ﬂﬂ 
yMax
‡‡ 
=
‡‡ 
yMin
‡‡ 
;
‡‡ 
for
‚‚ 
(
‚‚ 
int
‚‚ 
i
‚‚ 
=
‚‚ 
$num
‚‚ 
;
‚‚ 
i
‚‚  !
<
‚‚" #
len
‚‚$ '
;
‚‚' (
i
‚‚) *
++
‚‚* ,
)
‚‚, -
{
„„ 
float
‰‰ 
x
‰‰ 
=
‰‰ 
points
‰‰ $
[
‰‰$ %
i
‰‰% &
]
‰‰& '
.
‰‰' (
x
‰‰( )
;
‰‰) *
float
ÂÂ 
y
ÂÂ 
=
ÂÂ 
points
ÂÂ $
[
ÂÂ$ %
i
ÂÂ% &
]
ÂÂ& '
.
ÂÂ' (
y
ÂÂ( )
;
ÂÂ) *
if
ÁÁ 
(
ÁÁ 
x
ÁÁ 
<
ÁÁ 
xMin
ÁÁ  
)
ÁÁ  !
xMin
ÁÁ" &
=
ÁÁ' (
x
ÁÁ) *
;
ÁÁ* +
if
ËË 
(
ËË 
x
ËË 
>
ËË 
xMax
ËË  
)
ËË  !
xMax
ËË" &
=
ËË' (
x
ËË) *
;
ËË* +
if
ÍÍ 
(
ÍÍ 
y
ÍÍ 
<
ÍÍ 
yMin
ÍÍ  
)
ÍÍ  !
yMin
ÍÍ" &
=
ÍÍ' (
y
ÍÍ) *
;
ÍÍ* +
if
ÎÎ 
(
ÎÎ 
y
ÎÎ 
>
ÎÎ 
yMax
ÎÎ  
)
ÎÎ  !
yMax
ÎÎ" &
=
ÎÎ' (
y
ÎÎ) *
;
ÎÎ* +
}
ÏÏ 
}
ÌÌ 
center
ÔÔ 
.
ÔÔ 
x
ÔÔ 
=
ÔÔ 
(
ÔÔ 
xMin
ÔÔ 
+
ÔÔ 
xMax
ÔÔ #
)
ÔÔ# $
/
ÔÔ% &
$num
ÔÔ' )
;
ÔÔ) *
center
 
.
 
y
 
=
 
(
 
yMin
 
+
 
yMax
 #
)
# $
/
% &
$num
' )
;
) *
m_Size
ÚÚ 
.
ÚÚ 
x
ÚÚ 
=
ÚÚ 
xMax
ÚÚ 
-
ÚÚ 
xMin
ÚÚ "
;
ÚÚ" #
m_Size
ÛÛ 
.
ÛÛ 
y
ÛÛ 
=
ÛÛ 
yMax
ÛÛ 
-
ÛÛ 
yMin
ÛÛ "
;
ÛÛ" #
	m_Extents
ıı 
.
ıı 
x
ıı 
=
ıı 
m_Size
ıı  
.
ıı  !
x
ıı! "
*
ıı# $
$num
ıı% (
;
ıı( )
	m_Extents
ˆˆ 
.
ˆˆ 
y
ˆˆ 
=
ˆˆ 
m_Size
ˆˆ  
.
ˆˆ  !
y
ˆˆ! "
*
ˆˆ# $
$num
ˆˆ% (
;
ˆˆ( )
}
˜˜ 	
public
˛˛ 
void
˛˛ 
SetWithPoints
˛˛ !
(
˛˛! "
IList
˛˛" '
<
˛˛' (
Vector2
˛˛( /
>
˛˛/ 0
points
˛˛1 7
,
˛˛7 8
IList
˛˛9 >
<
˛˛> ?
int
˛˛? B
>
˛˛B C
indexes
˛˛D K
)
˛˛K L
{
ˇˇ 	
float
ÄÄ 
xMin
ÄÄ 
=
ÄÄ 
$num
ÄÄ 
,
ÄÄ 
xMax
ÅÅ 
=
ÅÅ 
$num
ÅÅ 
,
ÅÅ 
yMin
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
,
ÇÇ 
yMax
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
;
ÉÉ 
if
ÖÖ 
(
ÖÖ 
points
ÖÖ 
.
ÖÖ 
Count
ÖÖ 
>
ÖÖ 
$num
ÖÖ  
&&
ÖÖ! #
indexes
ÖÖ$ +
.
ÖÖ+ ,
Count
ÖÖ, 1
>
ÖÖ2 3
$num
ÖÖ4 5
)
ÖÖ5 6
{
ÜÜ 
xMin
áá 
=
áá 
points
áá 
[
áá 
indexes
áá %
[
áá% &
$num
áá& '
]
áá' (
]
áá( )
.
áá) *
x
áá* +
;
áá+ ,
yMin
àà 
=
àà 
points
àà 
[
àà 
indexes
àà %
[
àà% &
$num
àà& '
]
àà' (
]
àà( )
.
àà) *
y
àà* +
;
àà+ ,
xMax
ââ 
=
ââ 
xMin
ââ 
;
ââ 
yMax
ää 
=
ää 
yMin
ää 
;
ää 
for
åå 
(
åå 
int
åå 
i
åå 
=
åå 
$num
åå 
;
åå 
i
åå  !
<
åå" #
indexes
åå$ +
.
åå+ ,
Count
åå, 1
;
åå1 2
i
åå3 4
++
åå4 6
)
åå6 7
{
çç 
float
éé 
x
éé 
=
éé 
points
éé $
[
éé$ %
indexes
éé% ,
[
éé, -
i
éé- .
]
éé. /
]
éé/ 0
.
éé0 1
x
éé1 2
;
éé2 3
float
èè 
y
èè 
=
èè 
points
èè $
[
èè$ %
indexes
èè% ,
[
èè, -
i
èè- .
]
èè. /
]
èè/ 0
.
èè0 1
y
èè1 2
;
èè2 3
if
ëë 
(
ëë 
x
ëë 
<
ëë 
xMin
ëë  
)
ëë  !
xMin
ëë" &
=
ëë' (
x
ëë) *
;
ëë* +
if
íí 
(
íí 
x
íí 
>
íí 
xMax
íí  
)
íí  !
xMax
íí" &
=
íí' (
x
íí) *
;
íí* +
if
îî 
(
îî 
y
îî 
<
îî 
yMin
îî  
)
îî  !
yMin
îî" &
=
îî' (
y
îî) *
;
îî* +
if
ïï 
(
ïï 
y
ïï 
>
ïï 
yMax
ïï  
)
ïï  !
yMax
ïï" &
=
ïï' (
y
ïï) *
;
ïï* +
}
ññ 
}
óó 
center
ôô 
.
ôô 
x
ôô 
=
ôô 
(
ôô 
xMin
ôô 
+
ôô 
xMax
ôô #
)
ôô# $
/
ôô% &
$num
ôô' )
;
ôô) *
center
öö 
.
öö 
y
öö 
=
öö 
(
öö 
yMin
öö 
+
öö 
yMax
öö #
)
öö# $
/
öö% &
$num
öö' )
;
öö) *
m_Size
úú 
.
úú 
x
úú 
=
úú 
xMax
úú 
-
úú 
xMin
úú "
;
úú" #
m_Size
ùù 
.
ùù 
y
ùù 
=
ùù 
yMax
ùù 
-
ùù 
yMin
ùù "
;
ùù" #
	m_Extents
üü 
.
üü 
x
üü 
=
üü 
m_Size
üü  
.
üü  !
x
üü! "
*
üü# $
$num
üü% (
;
üü( )
	m_Extents
†† 
.
†† 
y
†† 
=
†† 
m_Size
††  
.
††  !
y
††! "
*
††# $
$num
††% (
;
††( )
}
°° 	
public
™™ 
static
™™ 
Vector2
™™ 
Center
™™ $
(
™™$ %
IList
™™% *
<
™™* +
Vector2
™™+ 2
>
™™2 3
points
™™4 :
)
™™: ;
{
´´ 	
float
¨¨ 
xMin
¨¨ 
=
¨¨ 
$num
¨¨ 
,
¨¨ 
xMax
≠≠ 
=
≠≠ 
$num
≠≠ 
,
≠≠ 
yMin
ÆÆ 
=
ÆÆ 
$num
ÆÆ 
,
ÆÆ 
yMax
ØØ 
=
ØØ 
$num
ØØ 
;
ØØ 
int
±± 
size
±± 
=
±± 
points
±± 
.
±± 
Count
±± #
;
±±# $
xMin
≥≥ 
=
≥≥ 
points
≥≥ 
[
≥≥ 
$num
≥≥ 
]
≥≥ 
.
≥≥ 
x
≥≥ 
;
≥≥ 
yMin
¥¥ 
=
¥¥ 
points
¥¥ 
[
¥¥ 
$num
¥¥ 
]
¥¥ 
.
¥¥ 
y
¥¥ 
;
¥¥ 
xMax
µµ 
=
µµ 
xMin
µµ 
;
µµ 
yMax
∂∂ 
=
∂∂ 
yMin
∂∂ 
;
∂∂ 
for
∏∏ 
(
∏∏ 
int
∏∏ 
i
∏∏ 
=
∏∏ 
$num
∏∏ 
;
∏∏ 
i
∏∏ 
<
∏∏ 
size
∏∏  $
;
∏∏$ %
i
∏∏& '
++
∏∏' )
)
∏∏) *
{
ππ 
float
∫∫ 
x
∫∫ 
=
∫∫ 
points
∫∫  
[
∫∫  !
i
∫∫! "
]
∫∫" #
.
∫∫# $
x
∫∫$ %
;
∫∫% &
float
ªª 
y
ªª 
=
ªª 
points
ªª  
[
ªª  !
i
ªª! "
]
ªª" #
.
ªª# $
y
ªª$ %
;
ªª% &
if
ΩΩ 
(
ΩΩ 
x
ΩΩ 
<
ΩΩ 
xMin
ΩΩ 
)
ΩΩ 
xMin
ΩΩ "
=
ΩΩ# $
x
ΩΩ% &
;
ΩΩ& '
if
ææ 
(
ææ 
x
ææ 
>
ææ 
xMax
ææ 
)
ææ 
xMax
ææ "
=
ææ# $
x
ææ% &
;
ææ& '
if
¿¿ 
(
¿¿ 
y
¿¿ 
<
¿¿ 
yMin
¿¿ 
)
¿¿ 
yMin
¿¿ "
=
¿¿# $
y
¿¿% &
;
¿¿& '
if
¡¡ 
(
¡¡ 
y
¡¡ 
>
¡¡ 
yMax
¡¡ 
)
¡¡ 
yMax
¡¡ "
=
¡¡# $
y
¡¡% &
;
¡¡& '
}
¬¬ 
return
ƒƒ 
new
ƒƒ 
Vector2
ƒƒ 
(
ƒƒ 
(
ƒƒ  
xMin
ƒƒ  $
+
ƒƒ% &
xMax
ƒƒ' +
)
ƒƒ+ ,
/
ƒƒ- .
$num
ƒƒ/ 1
,
ƒƒ1 2
(
ƒƒ3 4
yMin
ƒƒ4 8
+
ƒƒ9 :
yMax
ƒƒ; ?
)
ƒƒ? @
/
ƒƒA B
$num
ƒƒC E
)
ƒƒE F
;
ƒƒF G
}
≈≈ 	
public
«« 
static
«« 
Vector2
«« 
Center
«« $
(
««$ %
IList
««% *
<
««* +
Vector2
««+ 2
>
««2 3
points
««4 :
,
««: ;
IList
««< A
<
««A B
int
««B E
>
««E F
indexes
««G N
)
««N O
{
»» 	
float
…… 
xMin
…… 
=
…… 
$num
…… 
,
…… 
xMax
   
=
   
$num
   
,
   
yMin
ÀÀ 
=
ÀÀ 
$num
ÀÀ 
,
ÀÀ 
yMax
ÃÃ 
=
ÃÃ 
$num
ÃÃ 
;
ÃÃ 
int
ŒŒ 
size
ŒŒ 
=
ŒŒ 
indexes
ŒŒ 
.
ŒŒ 
Count
ŒŒ $
;
ŒŒ$ %
xMin
–– 
=
–– 
points
–– 
[
–– 
indexes
–– !
[
––! "
$num
––" #
]
––# $
]
––$ %
.
––% &
x
––& '
;
––' (
yMin
—— 
=
—— 
points
—— 
[
—— 
indexes
—— !
[
——! "
$num
——" #
]
——# $
]
——$ %
.
——% &
y
——& '
;
——' (
xMax
““ 
=
““ 
xMin
““ 
;
““ 
yMax
”” 
=
”” 
yMin
”” 
;
”” 
for
’’ 
(
’’ 
int
’’ 
i
’’ 
=
’’ 
$num
’’ 
;
’’ 
i
’’ 
<
’’ 
size
’’  $
;
’’$ %
i
’’& '
++
’’' )
)
’’) *
{
÷÷ 
float
◊◊ 
x
◊◊ 
=
◊◊ 
points
◊◊  
[
◊◊  !
indexes
◊◊! (
[
◊◊( )
i
◊◊) *
]
◊◊* +
]
◊◊+ ,
.
◊◊, -
x
◊◊- .
;
◊◊. /
float
ÿÿ 
y
ÿÿ 
=
ÿÿ 
points
ÿÿ  
[
ÿÿ  !
indexes
ÿÿ! (
[
ÿÿ( )
i
ÿÿ) *
]
ÿÿ* +
]
ÿÿ+ ,
.
ÿÿ, -
y
ÿÿ- .
;
ÿÿ. /
if
⁄⁄ 
(
⁄⁄ 
x
⁄⁄ 
<
⁄⁄ 
xMin
⁄⁄ 
)
⁄⁄ 
xMin
⁄⁄ "
=
⁄⁄# $
x
⁄⁄% &
;
⁄⁄& '
if
€€ 
(
€€ 
x
€€ 
>
€€ 
xMax
€€ 
)
€€ 
xMax
€€ "
=
€€# $
x
€€% &
;
€€& '
if
›› 
(
›› 
y
›› 
<
›› 
yMin
›› 
)
›› 
yMin
›› "
=
››# $
y
››% &
;
››& '
if
ﬁﬁ 
(
ﬁﬁ 
y
ﬁﬁ 
>
ﬁﬁ 
yMax
ﬁﬁ 
)
ﬁﬁ 
yMax
ﬁﬁ "
=
ﬁﬁ# $
y
ﬁﬁ% &
;
ﬁﬁ& '
}
ﬂﬂ 
return
·· 
new
·· 
Vector2
·· 
(
·· 
(
··  
xMin
··  $
+
··% &
xMax
··' +
)
··+ ,
/
··- .
$num
··/ 1
,
··1 2
(
··3 4
yMin
··4 8
+
··9 :
yMax
··; ?
)
··? @
/
··A B
$num
··C E
)
··E F
;
··F G
}
‚‚ 	
public
‰‰ 
static
‰‰ 
Vector2
‰‰ 
Size
‰‰ "
(
‰‰" #
IList
‰‰# (
<
‰‰( )
Vector2
‰‰) 0
>
‰‰0 1
points
‰‰2 8
,
‰‰8 9
IList
‰‰: ?
<
‰‰? @
int
‰‰@ C
>
‰‰C D
indexes
‰‰E L
)
‰‰L M
{
ÂÂ 	
float
ÊÊ 
xMin
ÊÊ 
=
ÊÊ 
$num
ÊÊ 
,
ÊÊ 
xMax
ÁÁ 
=
ÁÁ 
$num
ÁÁ 
,
ÁÁ 
yMin
ËË 
=
ËË 
$num
ËË 
,
ËË 
yMax
ÈÈ 
=
ÈÈ 
$num
ÈÈ 
;
ÈÈ 
int
ÎÎ 
size
ÎÎ 
=
ÎÎ 
indexes
ÎÎ 
.
ÎÎ 
Count
ÎÎ $
;
ÎÎ$ %
xMin
ÌÌ 
=
ÌÌ 
points
ÌÌ 
[
ÌÌ 
indexes
ÌÌ !
[
ÌÌ! "
$num
ÌÌ" #
]
ÌÌ# $
]
ÌÌ$ %
.
ÌÌ% &
x
ÌÌ& '
;
ÌÌ' (
yMin
ÓÓ 
=
ÓÓ 
points
ÓÓ 
[
ÓÓ 
indexes
ÓÓ !
[
ÓÓ! "
$num
ÓÓ" #
]
ÓÓ# $
]
ÓÓ$ %
.
ÓÓ% &
y
ÓÓ& '
;
ÓÓ' (
xMax
ÔÔ 
=
ÔÔ 
xMin
ÔÔ 
;
ÔÔ 
yMax
 
=
 
yMin
 
;
 
for
ÚÚ 
(
ÚÚ 
int
ÚÚ 
i
ÚÚ 
=
ÚÚ 
$num
ÚÚ 
;
ÚÚ 
i
ÚÚ 
<
ÚÚ 
size
ÚÚ  $
;
ÚÚ$ %
i
ÚÚ& '
++
ÚÚ' )
)
ÚÚ) *
{
ÛÛ 
float
ÙÙ 
x
ÙÙ 
=
ÙÙ 
points
ÙÙ  
[
ÙÙ  !
indexes
ÙÙ! (
[
ÙÙ( )
i
ÙÙ) *
]
ÙÙ* +
]
ÙÙ+ ,
.
ÙÙ, -
x
ÙÙ- .
;
ÙÙ. /
float
ıı 
y
ıı 
=
ıı 
points
ıı  
[
ıı  !
indexes
ıı! (
[
ıı( )
i
ıı) *
]
ıı* +
]
ıı+ ,
.
ıı, -
y
ıı- .
;
ıı. /
if
˜˜ 
(
˜˜ 
x
˜˜ 
<
˜˜ 
xMin
˜˜ 
)
˜˜ 
xMin
˜˜ "
=
˜˜# $
x
˜˜% &
;
˜˜& '
if
¯¯ 
(
¯¯ 
x
¯¯ 
>
¯¯ 
xMax
¯¯ 
)
¯¯ 
xMax
¯¯ "
=
¯¯# $
x
¯¯% &
;
¯¯& '
if
˙˙ 
(
˙˙ 
y
˙˙ 
<
˙˙ 
yMin
˙˙ 
)
˙˙ 
yMin
˙˙ "
=
˙˙# $
y
˙˙% &
;
˙˙& '
if
˚˚ 
(
˚˚ 
y
˚˚ 
>
˚˚ 
yMax
˚˚ 
)
˚˚ 
yMax
˚˚ "
=
˚˚# $
y
˚˚% &
;
˚˚& '
}
¸¸ 
return
˛˛ 
new
˛˛ 
Vector2
˛˛ 
(
˛˛ 
xMax
˛˛ #
-
˛˛$ %
xMin
˛˛& *
,
˛˛* +
yMax
˛˛, 0
-
˛˛1 2
yMin
˛˛3 7
)
˛˛7 8
;
˛˛8 9
}
ˇˇ 	
internal
ÅÅ 
static
ÅÅ 
Vector2
ÅÅ 
Center
ÅÅ  &
(
ÅÅ& '
IList
ÅÅ' ,
<
ÅÅ, -
Vector4
ÅÅ- 4
>
ÅÅ4 5
points
ÅÅ6 <
,
ÅÅ< =
IEnumerable
ÅÅ> I
<
ÅÅI J
int
ÅÅJ M
>
ÅÅM N
indexes
ÅÅO V
)
ÅÅV W
{
ÇÇ 	
float
ÉÉ 
xMin
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
,
ÉÉ 
xMax
ÑÑ 
=
ÑÑ 
$num
ÑÑ 
,
ÑÑ 
yMin
ÖÖ 
=
ÖÖ 
$num
ÖÖ 
,
ÖÖ 
yMax
ÜÜ 
=
ÜÜ 
$num
ÜÜ 
;
ÜÜ 
if
àà 
(
àà 
indexes
àà 
.
àà 
Any
àà 
(
àà 
)
àà 
)
àà 
{
ââ 
var
ää 
first
ää 
=
ää 
indexes
ää #
.
ää# $
First
ää$ )
(
ää) *
)
ää* +
;
ää+ ,
xMin
åå 
=
åå 
points
åå 
[
åå 
first
åå #
]
åå# $
.
åå$ %
x
åå% &
;
åå& '
yMin
çç 
=
çç 
points
çç 
[
çç 
first
çç #
]
çç# $
.
çç$ %
y
çç% &
;
çç& '
xMax
éé 
=
éé 
xMin
éé 
;
éé 
yMax
èè 
=
èè 
yMin
èè 
;
èè 
foreach
ëë 
(
ëë 
var
ëë 
index
ëë "
in
ëë# %
indexes
ëë& -
)
ëë- .
{
íí 
float
ìì 
x
ìì 
=
ìì 
points
ìì $
[
ìì$ %
index
ìì% *
]
ìì* +
.
ìì+ ,
x
ìì, -
;
ìì- .
float
îî 
y
îî 
=
îî 
points
îî $
[
îî$ %
index
îî% *
]
îî* +
.
îî+ ,
y
îî, -
;
îî- .
if
ññ 
(
ññ 
x
ññ 
<
ññ 
xMin
ññ  
)
ññ  !
xMin
ññ" &
=
ññ' (
x
ññ) *
;
ññ* +
if
óó 
(
óó 
x
óó 
>
óó 
xMax
óó  
)
óó  !
xMax
óó" &
=
óó' (
x
óó) *
;
óó* +
if
ôô 
(
ôô 
y
ôô 
<
ôô 
yMin
ôô  
)
ôô  !
yMin
ôô" &
=
ôô' (
y
ôô) *
;
ôô* +
if
öö 
(
öö 
y
öö 
>
öö 
yMax
öö  
)
öö  !
yMax
öö" &
=
öö' (
y
öö) *
;
öö* +
}
õõ 
}
úú 
return
ùù 
new
ùù 
Vector2
ùù 
(
ùù 
(
ùù  
xMin
ùù  $
+
ùù% &
xMax
ùù' +
)
ùù+ ,
/
ùù- .
$num
ùù/ 1
,
ùù1 2
(
ùù3 4
yMin
ùù4 8
+
ùù9 :
yMax
ùù; ?
)
ùù? @
/
ùùA B
$num
ùùC E
)
ùùE F
;
ùùF G
}
ûû 	
public
†† 
override
†† 
string
†† 
ToString
†† '
(
††' (
)
††( )
{
°° 	
return
¢¢ 
$str
¢¢ 
+
¢¢ 
center
¢¢ $
+
¢¢% &
$str
¢¢' 0
+
¢¢1 2
size
¢¢3 7
+
¢¢8 9
$str
¢¢: =
;
¢¢= >
}
££ 	
}
§§ 
}•• …Ù
öD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\ExtrudeElements.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
public 

static 
class 
ExtrudeElements '
{ 
public 
static 
Face 
[ 
] 
Extrude $
($ %
this% )
ProBuilderMesh* 8
mesh9 =
,= >
IEnumerable? J
<J K
FaceK O
>O P
facesQ V
,V W
ExtrudeMethodX e
methodf l
,l m
floatn s
distancet |
)| }
{ 	
switch 
( 
method 
) 
{ 
case 
ExtrudeMethod "
." #
IndividualFaces# 2
:2 3
return 
ExtrudePerFace )
() *
mesh* .
,. /
faces0 5
,5 6
distance7 ?
)? @
;@ A
default 
: 
return 
ExtrudeAsGroups *
(* +
mesh+ /
,/ 0
faces1 6
,6 7
method8 >
==? A
ExtrudeMethodB O
.O P

FaceNormalP Z
,Z [
distance\ d
)d e
;e f
} 
}   	
public++ 
static++ 
Edge++ 
[++ 
]++ 
Extrude++ $
(++$ %
this++% )
ProBuilderMesh++* 8
mesh++9 =
,++= >
IEnumerable++? J
<++J K
Edge++K O
>++O P
edges++Q V
,++V W
float++X ]
distance++^ f
,++f g
bool++h l
extrudeAsGroup++m {
,++{ |
bool	++} Å#
enableManifoldExtrude
++Ç ó
)
++ó ò
{,, 	
if-- 
(-- 
mesh-- 
==-- 
null-- 
)-- 
throw.. 
new.. !
ArgumentNullException.. /
(../ 0
$str..0 6
)..6 7
;..7 8
if00 
(00 
edges00 
==00 
null00 
)00 
throw11 
new11 !
ArgumentNullException11 /
(11/ 0
$str110 7
)117 8
;118 9
SharedVertex33 
[33 
]33 
sharedIndexes33 (
=33) *
mesh33+ /
.33/ 0"
sharedVerticesInternal330 F
;33F G
List55 
<55 
Edge55 
>55 

validEdges55 !
=55" #
new55$ '
List55( ,
<55, -
Edge55- 1
>551 2
(552 3
)553 4
;554 5
List66 
<66 
Face66 
>66 
	edgeFaces66  
=66! "
new66# &
List66' +
<66+ ,
Face66, 0
>660 1
(661 2
)662 3
;663 4
foreach88 
(88 
Edge88 
e88 
in88 
edges88 $
)88$ %
{99 
int:: 
	faceCount:: 
=:: 
$num::  !
;::! "
Face;; 
fa;; 
=;; 
null;; 
;;; 
foreach== 
(== 
Face== 
face== "
in==# %
mesh==& *
.==* +
facesInternal==+ 8
)==8 9
{>> 
if?? 
(?? 
mesh?? 
.?? 
IndexOf?? $
(??$ %
face??% )
.??) *
edgesInternal??* 7
,??7 8
e??9 :
)??: ;
>??< =
-??> ?
$num??? @
)??@ A
{@@ 
faAA 
=AA 
faceAA !
;AA! "
ifCC 
(CC 
++CC 
	faceCountCC '
>CC( )
$numCC* +
)CC+ ,
breakDD !
;DD! "
}EE 
}FF 
ifHH 
(HH !
enableManifoldExtrudeHH )
||HH* ,
	faceCountHH- 6
<HH7 8
$numHH9 :
)HH: ;
{II 

validEdgesJJ 
.JJ 
AddJJ "
(JJ" #
eJJ# $
)JJ$ %
;JJ% &
	edgeFacesKK 
.KK 
AddKK !
(KK! "
faKK" $
)KK$ %
;KK% &
}LL 
}MM 
ifOO 
(OO 

validEdgesOO 
.OO 
CountOO  
<OO! "
$numOO# $
)OO$ %
returnPP 
nullPP 
;PP 
Vector3RR 
[RR 
]RR 

localVertsRR  
=RR! "
meshRR# '
.RR' (
positionsInternalRR( 9
;RR9 :
ifSS 
(SS 
!SS 
meshSS 
.SS 
	HasArraysSS 
(SS  

MeshArraysSS  *
.SS* +
NormalSS+ 1
)SS1 2
)SS2 3
meshTT 
.TT 
RefreshTT 
(TT 
RefreshMaskTT (
.TT( )
NormalsTT) 0
)TT0 1
;TT1 2
IListUU 
<UU 
Vector3UU 
>UU 
oNormalsUU #
=UU$ %
meshUU& *
.UU* +
normalsUU+ 2
;UU2 3
intWW 
[WW 
]WW 
allEdgeIndexesWW  
=WW! "
newWW# &
intWW' *
[WW* +

validEdgesWW+ 5
.WW5 6
CountWW6 ;
*WW< =
$numWW> ?
]WW? @
;WW@ A
intXX 
cXX 
=XX 
$numXX 
;XX 
forYY 
(YY 
intYY 
iYY 
=YY 
$numYY 
;YY 
iYY 
<YY 

validEdgesYY  *
.YY* +
CountYY+ 0
;YY0 1
iYY2 3
++YY3 5
)YY5 6
{ZZ 
allEdgeIndexes[[ 
[[[ 
c[[  
++[[  "
][[" #
=[[$ %

validEdges[[& 0
[[[0 1
i[[1 2
][[2 3
.[[3 4
a[[4 5
;[[5 6
allEdgeIndexes\\ 
[\\ 
c\\  
++\\  "
]\\" #
=\\$ %

validEdges\\& 0
[\\0 1
i\\1 2
]\\2 3
.\\3 4
b\\4 5
;\\5 6
}]] 
List__ 
<__ 
Edge__ 
>__ 
extrudedIndexes__ &
=__' (
new__) ,
List__- 1
<__1 2
Edge__2 6
>__6 7
(__7 8
)__8 9
;__9 :
Listaa 
<aa 
Edgeaa 
>aa 
newEdgesaa 
=aa  !
newaa" %
Listaa& *
<aa* +
Edgeaa+ /
>aa/ 0
(aa0 1
)aa1 2
;aa2 3
boolbb 
	hasColorsbb 
=bb 
meshbb !
.bb! "
	HasArraysbb" +
(bb+ ,

MeshArraysbb, 6
.bb6 7
Colorbb7 <
)bb< =
;bb= >
foree 
(ee 
intee 
iee 
=ee 
$numee 
;ee 
iee 
<ee 

validEdgesee  *
.ee* +
Countee+ 0
;ee0 1
iee2 3
++ee3 5
)ee5 6
{ff 
Edgegg 
edgegg 
=gg 

validEdgesgg &
[gg& '
igg' (
]gg( )
;gg) *
Facehh 
facehh 
=hh 
	edgeFaceshh %
[hh% &
ihh& '
]hh' (
;hh( )
Vector3kk 
xnormkk 
=kk 
extrudeAsGroupkk  .
?ll 
InternalMeshUtilityll )
.ll) *$
AverageNormalWithIndexesll* B
(llB C
sharedIndexesllC P
[llP Q
meshllQ U
.llU V!
GetSharedVertexHandlellV k
(llk l
edgelll p
.llp q
allq r
)llr s
]lls t
,llt u
allEdgeIndexes	llv Ñ
,
llÑ Ö
oNormals
llÜ é
)
llé è
:mm 
Mathmm 
.mm 
Normalmm !
(mm! "
meshmm" &
,mm& '
facemm( ,
)mm, -
;mm- .
Vector3oo 
ynormoo 
=oo 
extrudeAsGroupoo  .
?pp 
InternalMeshUtilitypp )
.pp) *$
AverageNormalWithIndexespp* B
(ppB C
sharedIndexesppC P
[ppP Q
meshppQ U
.ppU V!
GetSharedVertexHandleppV k
(ppk l
edgeppl p
.ppp q
bppq r
)ppr s
]pps t
,ppt u
allEdgeIndexes	ppv Ñ
,
ppÑ Ö
oNormals
ppÜ é
)
ppé è
:qq 
Mathqq 
.qq 
Normalqq !
(qq! "
meshqq" &
,qq& '
faceqq( ,
)qq, -
;qq- .
intss 
x_sharedIndexss !
=ss" #
meshss$ (
.ss( )!
GetSharedVertexHandless) >
(ss> ?
edgess? C
.ssC D
assD E
)ssE F
;ssF G
inttt 
y_sharedIndextt !
=tt" #
meshtt$ (
.tt( )!
GetSharedVertexHandlett) >
(tt> ?
edgett? C
.ttC D
bttD E
)ttE F
;ttF G
varvv 
	positionsvv 
=vv 
newvv  #
Vector3vv$ +
[vv+ ,
$numvv, -
]vv- .
{ww 

localVertsxx 
[xx 
edgexx #
.xx# $
axx$ %
]xx% &
,xx& '

localVertsyy 
[yy 
edgeyy #
.yy# $
byy$ %
]yy% &
,yy& '

localVertszz 
[zz 
edgezz #
.zz# $
azz$ %
]zz% &
+zz' (
xnormzz) .
.zz. /

normalizedzz/ 9
*zz: ;
distancezz< D
,zzD E

localVerts{{ 
[{{ 
edge{{ #
.{{# $
b{{$ %
]{{% &
+{{' (
ynorm{{) .
.{{. /

normalized{{/ 9
*{{: ;
distance{{< D
}|| 
;|| 
var~~ 
colors~~ 
=~~ 
	hasColors~~ &
? 
new 
Color 
[  
$num  !
]! "
{
ÄÄ 
mesh
ÅÅ 
.
ÅÅ 
colorsInternal
ÅÅ +
[
ÅÅ+ ,
edge
ÅÅ, 0
.
ÅÅ0 1
a
ÅÅ1 2
]
ÅÅ2 3
,
ÅÅ3 4
mesh
ÇÇ 
.
ÇÇ 
colorsInternal
ÇÇ +
[
ÇÇ+ ,
edge
ÇÇ, 0
.
ÇÇ0 1
b
ÇÇ1 2
]
ÇÇ2 3
,
ÇÇ3 4
mesh
ÉÉ 
.
ÉÉ 
colorsInternal
ÉÉ +
[
ÉÉ+ ,
edge
ÉÉ, 0
.
ÉÉ0 1
a
ÉÉ1 2
]
ÉÉ2 3
,
ÉÉ3 4
mesh
ÑÑ 
.
ÑÑ 
colorsInternal
ÑÑ +
[
ÑÑ+ ,
edge
ÑÑ, 0
.
ÑÑ0 1
b
ÑÑ1 2
]
ÑÑ2 3
}
ÖÖ 
:
ÜÜ 
null
ÜÜ 
;
ÜÜ 
Face
àà 
newFace
àà 
=
àà 
mesh
àà #
.
àà# $

AppendFace
àà$ .
(
àà. /
	positions
ââ !
,
ââ! "
colors
ää 
,
ää 
new
ãã 
Vector2
ãã #
[
ãã# $
$num
ãã$ %
]
ãã% &
,
ãã& '
new
åå 
Face
åå  
(
åå  !
new
åå! $
int
åå% (
[
åå( )
$num
åå) *
]
åå* +
{
åå, -
$num
åå. /
,
åå/ 0
$num
åå1 2
,
åå2 3
$num
åå4 5
,
åå5 6
$num
åå7 8
,
åå8 9
$num
åå: ;
,
åå; <
$num
åå= >
}
åå? @
,
åå@ A
face
ååB F
.
ååF G
submeshIndex
ååG S
,
ååS T 
AutoUnwrapSettings
ååU g
.
ååg h
tile
ååh l
,
åål m
$num
åån o
,
ååo p
-
ååq r
$num
åår s
,
åås t
-
ååu v
$num
ååv w
,
ååw x
false
ååy ~
)
åå~ 
,åå Ä
new
çç 
int
çç 
[
çç  
$num
çç  !
]
çç! "
{
çç# $
x_sharedIndex
çç% 2
,
çç2 3
y_sharedIndex
çç4 A
,
ççA B
-
ççC D
$num
ççD E
,
ççE F
-
ççG H
$num
ççH I
}
ççJ K
)
ççK L
;
ççL M
newEdges
èè 
.
èè 
Add
èè 
(
èè 
new
èè  
Edge
èè! %
(
èè% &
newFace
èè& -
.
èè- .
indexesInternal
èè. =
[
èè= >
$num
èè> ?
]
èè? @
,
èè@ A
newFace
èèB I
.
èèI J
indexesInternal
èèJ Y
[
èèY Z
$num
èèZ [
]
èè[ \
)
èè\ ]
)
èè] ^
;
èè^ _
extrudedIndexes
ëë 
.
ëë  
Add
ëë  #
(
ëë# $
new
ëë$ '
Edge
ëë( ,
(
ëë, -
x_sharedIndex
ëë- :
,
ëë: ;
newFace
ëë< C
.
ëëC D
indexesInternal
ëëD S
[
ëëS T
$num
ëëT U
]
ëëU V
)
ëëV W
)
ëëW X
;
ëëX Y
extrudedIndexes
íí 
.
íí  
Add
íí  #
(
íí# $
new
íí$ '
Edge
íí( ,
(
íí, -
y_sharedIndex
íí- :
,
íí: ;
newFace
íí< C
.
ííC D
indexesInternal
ííD S
[
ííS T
$num
ííT U
]
ííU V
)
ííV W
)
ííW X
;
ííX Y
}
ìì 
if
ññ 
(
ññ 
extrudeAsGroup
ññ 
)
ññ 
{
óó 
for
òò 
(
òò 
int
òò 
i
òò 
=
òò 
$num
òò 
;
òò 
i
òò  !
<
òò" #
extrudedIndexes
òò$ 3
.
òò3 4
Count
òò4 9
;
òò9 :
i
òò; <
++
òò< >
)
òò> ?
{
ôô 
int
öö 
val
öö 
=
öö 
extrudedIndexes
öö -
[
öö- .
i
öö. /
]
öö/ 0
.
öö0 1
a
öö1 2
;
öö2 3
for
úú 
(
úú 
int
úú 
n
úú 
=
úú  
$num
úú! "
;
úú" #
n
úú$ %
<
úú& '
extrudedIndexes
úú( 7
.
úú7 8
Count
úú8 =
;
úú= >
n
úú? @
++
úú@ B
)
úúB C
{
ùù 
if
ûû 
(
ûû 
n
ûû 
==
ûû  
i
ûû! "
)
ûû" #
continue
üü $
;
üü$ %
if
°° 
(
°° 
extrudedIndexes
°° +
[
°°+ ,
n
°°, -
]
°°- .
.
°°. /
a
°°/ 0
==
°°1 3
val
°°4 7
)
°°7 8
{
¢¢ 
mesh
££  
.
££  !#
SetVerticesCoincident
££! 6
(
££6 7
new
££7 :
int
££; >
[
££> ?
]
££? @
{
££A B
extrudedIndexes
££C R
[
££R S
n
££S T
]
££T U
.
££U V
b
££V W
,
££W X
extrudedIndexes
££Y h
[
££h i
i
££i j
]
££j k
.
££k l
b
££l m
}
££n o
)
££o p
;
££p q
break
§§ !
;
§§! "
}
•• 
}
¶¶ 
}
ßß 
}
®® 
foreach
´´ 
(
´´ 
Face
´´ 
f
´´ 
in
´´ 
mesh
´´ #
.
´´# $
facesInternal
´´$ 1
)
´´1 2
f
¨¨ 
.
¨¨ 
InvalidateCache
¨¨ !
(
¨¨! "
)
¨¨" #
;
¨¨# $
return
ÆÆ 
newEdges
ÆÆ 
.
ÆÆ 
ToArray
ÆÆ #
(
ÆÆ# $
)
ÆÆ$ %
;
ÆÆ% &
}
ØØ 	
public
∑∑ 
static
∑∑ 
List
∑∑ 
<
∑∑ 
Face
∑∑ 
>
∑∑  
DetachFaces
∑∑! ,
(
∑∑, -
this
∑∑- 1
ProBuilderMesh
∑∑2 @
mesh
∑∑A E
,
∑∑E F
IEnumerable
∑∑G R
<
∑∑R S
Face
∑∑S W
>
∑∑W X
faces
∑∑Y ^
)
∑∑^ _
{
∏∏ 	
return
ππ 
DetachFaces
ππ 
(
ππ 
mesh
ππ #
,
ππ# $
faces
ππ% *
,
ππ* +
true
ππ, 0
)
ππ0 1
;
ππ1 2
}
∫∫ 	
public
√√ 
static
√√ 
List
√√ 
<
√√ 
Face
√√ 
>
√√  
DetachFaces
√√! ,
(
√√, -
this
√√- 1
ProBuilderMesh
√√2 @
mesh
√√A E
,
√√E F
IEnumerable
√√G R
<
√√R S
Face
√√S W
>
√√W X
faces
√√Y ^
,
√√^ _
bool
√√` d
deleteSourceFaces
√√e v
)
√√v w
{
ƒƒ 	
if
≈≈ 
(
≈≈ 
mesh
≈≈ 
==
≈≈ 
null
≈≈ 
)
≈≈ 
throw
∆∆ 
new
∆∆ 
System
∆∆  
.
∆∆  !#
ArgumentNullException
∆∆! 6
(
∆∆6 7
$str
∆∆7 =
)
∆∆= >
;
∆∆> ?
if
»» 
(
»» 
faces
»» 
==
»» 
null
»» 
)
»» 
throw
…… 
new
…… 
System
……  
.
……  !#
ArgumentNullException
……! 6
(
……6 7
$str
……7 >
)
……> ?
;
……? @
List
ÀÀ 
<
ÀÀ 
Vertex
ÀÀ 
>
ÀÀ 
vertices
ÀÀ !
=
ÀÀ" #
new
ÀÀ$ '
List
ÀÀ( ,
<
ÀÀ, -
Vertex
ÀÀ- 3
>
ÀÀ3 4
(
ÀÀ4 5
mesh
ÀÀ5 9
.
ÀÀ9 :
GetVertices
ÀÀ: E
(
ÀÀE F
)
ÀÀF G
)
ÀÀG H
;
ÀÀH I
int
ÃÃ 
sharedIndexOffset
ÃÃ !
=
ÃÃ" #
mesh
ÃÃ$ (
.
ÃÃ( )$
sharedVerticesInternal
ÃÃ) ?
.
ÃÃ? @
Length
ÃÃ@ F
;
ÃÃF G
var
ÕÕ 
lookup
ÕÕ 
=
ÕÕ 
mesh
ÕÕ 
.
ÕÕ  
sharedVertexLookup
ÕÕ 0
;
ÕÕ0 1
List
œœ 
<
œœ 
FaceRebuildData
œœ  
>
œœ  !
detached
œœ" *
=
œœ+ ,
new
œœ- 0
List
œœ1 5
<
œœ5 6
FaceRebuildData
œœ6 E
>
œœE F
(
œœF G
)
œœG H
;
œœH I
foreach
—— 
(
—— 
Face
—— 
face
—— 
in
—— !
faces
——" '
)
——' (
{
““ 
FaceRebuildData
”” 
data
””  $
=
””% &
new
””' *
FaceRebuildData
””+ :
(
””: ;
)
””; <
;
””< =
data
‘‘ 
.
‘‘ 
vertices
‘‘ 
=
‘‘ 
new
‘‘  #
List
‘‘$ (
<
‘‘( )
Vertex
‘‘) /
>
‘‘/ 0
(
‘‘0 1
)
‘‘1 2
;
‘‘2 3
data
’’ 
.
’’ 
sharedIndexes
’’ "
=
’’# $
new
’’% (
List
’’) -
<
’’- .
int
’’. 1
>
’’1 2
(
’’2 3
)
’’3 4
;
’’4 5
data
÷÷ 
.
÷÷ 
face
÷÷ 
=
÷÷ 
new
÷÷ 
Face
÷÷  $
(
÷÷$ %
face
÷÷% )
)
÷÷) *
;
÷÷* +

Dictionary
ÿÿ 
<
ÿÿ 
int
ÿÿ 
,
ÿÿ 
int
ÿÿ  #
>
ÿÿ# $
match
ÿÿ% *
=
ÿÿ+ ,
new
ÿÿ- 0

Dictionary
ÿÿ1 ;
<
ÿÿ; <
int
ÿÿ< ?
,
ÿÿ? @
int
ÿÿA D
>
ÿÿD E
(
ÿÿE F
)
ÿÿF G
;
ÿÿG H
int
ŸŸ 
[
ŸŸ 
]
ŸŸ 
indexes
ŸŸ 
=
ŸŸ 
new
ŸŸ  #
int
ŸŸ$ '
[
ŸŸ' (
face
ŸŸ( ,
.
ŸŸ, -
indexesInternal
ŸŸ- <
.
ŸŸ< =
Length
ŸŸ= C
]
ŸŸC D
;
ŸŸD E
for
€€ 
(
€€ 
int
€€ 
i
€€ 
=
€€ 
$num
€€ 
;
€€ 
i
€€  !
<
€€" #
face
€€$ (
.
€€( )
indexesInternal
€€) 8
.
€€8 9
Length
€€9 ?
;
€€? @
i
€€A B
++
€€B D
)
€€D E
{
‹‹ 
int
›› 
local
›› 
;
›› 
if
ﬂﬂ 
(
ﬂﬂ 
match
ﬂﬂ 
.
ﬂﬂ 
TryGetValue
ﬂﬂ )
(
ﬂﬂ) *
face
ﬂﬂ* .
.
ﬂﬂ. /
indexesInternal
ﬂﬂ/ >
[
ﬂﬂ> ?
i
ﬂﬂ? @
]
ﬂﬂ@ A
,
ﬂﬂA B
out
ﬂﬂC F
local
ﬂﬂG L
)
ﬂﬂL M
)
ﬂﬂM N
{
‡‡ 
indexes
·· 
[
··  
i
··  !
]
··! "
=
··# $
local
··% *
;
··* +
}
‚‚ 
else
„„ 
{
‰‰ 
local
ÂÂ 
=
ÂÂ 
data
ÂÂ  $
.
ÂÂ$ %
vertices
ÂÂ% -
.
ÂÂ- .
Count
ÂÂ. 3
;
ÂÂ3 4
indexes
ÊÊ 
[
ÊÊ  
i
ÊÊ  !
]
ÊÊ! "
=
ÊÊ# $
local
ÊÊ% *
;
ÊÊ* +
match
ÁÁ 
.
ÁÁ 
Add
ÁÁ !
(
ÁÁ! "
face
ÁÁ" &
.
ÁÁ& '
indexesInternal
ÁÁ' 6
[
ÁÁ6 7
i
ÁÁ7 8
]
ÁÁ8 9
,
ÁÁ9 :
local
ÁÁ; @
)
ÁÁ@ A
;
ÁÁA B
data
ËË 
.
ËË 
vertices
ËË %
.
ËË% &
Add
ËË& )
(
ËË) *
vertices
ËË* 2
[
ËË2 3
face
ËË3 7
.
ËË7 8
indexesInternal
ËË8 G
[
ËËG H
i
ËËH I
]
ËËI J
]
ËËJ K
)
ËËK L
;
ËËL M
data
ÈÈ 
.
ÈÈ 
sharedIndexes
ÈÈ *
.
ÈÈ* +
Add
ÈÈ+ .
(
ÈÈ. /
lookup
ÈÈ/ 5
[
ÈÈ5 6
face
ÈÈ6 :
.
ÈÈ: ;
indexesInternal
ÈÈ; J
[
ÈÈJ K
i
ÈÈK L
]
ÈÈL M
]
ÈÈM N
+
ÈÈO P
sharedIndexOffset
ÈÈQ b
)
ÈÈb c
;
ÈÈc d
}
ÍÍ 
}
ÎÎ 
data
ÌÌ 
.
ÌÌ 
face
ÌÌ 
.
ÌÌ 
indexesInternal
ÌÌ )
=
ÌÌ* +
indexes
ÌÌ, 3
.
ÌÌ3 4
ToArray
ÌÌ4 ;
(
ÌÌ; <
)
ÌÌ< =
;
ÌÌ= >
detached
ÓÓ 
.
ÓÓ 
Add
ÓÓ 
(
ÓÓ 
data
ÓÓ !
)
ÓÓ! "
;
ÓÓ" #
}
ÔÔ 
FaceRebuildData
ÒÒ 
.
ÒÒ 
Apply
ÒÒ !
(
ÒÒ! "
detached
ÒÒ" *
,
ÒÒ* +
mesh
ÒÒ, 0
,
ÒÒ0 1
vertices
ÒÒ2 :
)
ÒÒ: ;
;
ÒÒ; <
if
ÚÚ 
(
ÚÚ 
deleteSourceFaces
ÚÚ !
)
ÚÚ! "
{
ÛÛ 
mesh
ÙÙ 
.
ÙÙ 
DeleteFaces
ÙÙ  
(
ÙÙ  !
faces
ÙÙ! &
)
ÙÙ& '
;
ÙÙ' (
}
ıı 
mesh
˜˜ 
.
˜˜ 
ToMesh
˜˜ 
(
˜˜ 
)
˜˜ 
;
˜˜ 
return
˘˘ 
detached
˘˘ 
.
˘˘ 
Select
˘˘ "
(
˘˘" #
x
˘˘# $
=>
˘˘% '
x
˘˘( )
.
˘˘) *
face
˘˘* .
)
˘˘. /
.
˘˘/ 0
ToList
˘˘0 6
(
˘˘6 7
)
˘˘7 8
;
˘˘8 9
}
˙˙ 	
static
ÑÑ 
Face
ÑÑ 
[
ÑÑ 
]
ÑÑ 
ExtrudePerFace
ÑÑ $
(
ÑÑ$ %
ProBuilderMesh
ÑÑ% 3
pb
ÑÑ4 6
,
ÑÑ6 7
IEnumerable
ÑÑ8 C
<
ÑÑC D
Face
ÑÑD H
>
ÑÑH I
faces
ÑÑJ O
,
ÑÑO P
float
ÑÑQ V
distance
ÑÑW _
)
ÑÑ_ `
{
ÖÖ 	
Face
ÜÜ 
[
ÜÜ 
]
ÜÜ 
	faceArray
ÜÜ 
=
ÜÜ 
faces
ÜÜ $
as
ÜÜ% '
Face
ÜÜ( ,
[
ÜÜ, -
]
ÜÜ- .
??
ÜÜ/ 1
faces
ÜÜ2 7
.
ÜÜ7 8
ToArray
ÜÜ8 ?
(
ÜÜ? @
)
ÜÜ@ A
;
ÜÜA B
if
àà 
(
àà 
!
àà 
	faceArray
àà 
.
àà 
Any
àà 
(
àà 
)
àà  
)
àà  !
return
ââ 
null
ââ 
;
ââ 
List
ãã 
<
ãã 
Vertex
ãã 
>
ãã 
vertices
ãã !
=
ãã" #
new
ãã$ '
List
ãã( ,
<
ãã, -
Vertex
ãã- 3
>
ãã3 4
(
ãã4 5
pb
ãã5 7
.
ãã7 8
GetVertices
ãã8 C
(
ããC D
)
ããD E
)
ããE F
;
ããF G
int
åå 
sharedIndexMax
åå 
=
åå  
pb
åå! #
.
åå# $$
sharedVerticesInternal
åå$ :
.
åå: ;
Length
åå; A
;
ååA B
int
çç 
sharedIndexOffset
çç !
=
çç" #
$num
çç$ %
;
çç% &
int
éé 
	faceIndex
éé 
=
éé 
$num
éé 
;
éé 

Dictionary
èè 
<
èè 
int
èè 
,
èè 
int
èè 
>
èè  
lookup
èè! '
=
èè( )
pb
èè* ,
.
èè, - 
sharedVertexLookup
èè- ?
;
èè? @

Dictionary
êê 
<
êê 
int
êê 
,
êê 
int
êê 
>
êê  
lookupUV
êê! )
=
êê* +
pb
êê, .
.
êê. /!
sharedTextureLookup
êê/ B
;
êêB C

Dictionary
ëë 
<
ëë 
int
ëë 
,
ëë 
int
ëë 
>
ëë  
used
ëë! %
=
ëë& '
new
ëë( +

Dictionary
ëë, 6
<
ëë6 7
int
ëë7 :
,
ëë: ;
int
ëë< ?
>
ëë? @
(
ëë@ A
)
ëëA B
;
ëëB C
Face
íí 
[
íí 
]
íí 
newFaces
íí 
=
íí 
new
íí !
Face
íí" &
[
íí& '
	faceArray
íí' 0
.
íí0 1
Sum
íí1 4
(
íí4 5
x
íí5 6
=>
íí7 9
x
íí: ;
.
íí; <
edges
íí< A
.
ííA B
Count
ííB G
)
ííG H
]
ííH I
;
ííI J
foreach
îî 
(
îî 
Face
îî 
face
îî 
in
îî !
	faceArray
îî" +
)
îî+ ,
{
ïï 
face
ññ 
.
ññ 
smoothingGroup
ññ #
=
ññ$ %
	Smoothing
ññ& /
.
ññ/ 0 
smoothingGroupNone
ññ0 B
;
ññB C
face
óó 
.
óó 
textureGroup
óó !
=
óó" #
-
óó$ %
$num
óó% &
;
óó& '
Vector3
ôô 
delta
ôô 
=
ôô 
Math
ôô  $
.
ôô$ %
Normal
ôô% +
(
ôô+ ,
pb
ôô, .
,
ôô. /
face
ôô0 4
)
ôô4 5
*
ôô6 7
distance
ôô8 @
;
ôô@ A
Edge
öö 
[
öö 
]
öö 
edges
öö 
=
öö 
face
öö #
.
öö# $
edgesInternal
öö$ 1
;
öö1 2
used
úú 
.
úú 
Clear
úú 
(
úú 
)
úú 
;
úú 
for
ûû 
(
ûû 
int
ûû 
i
ûû 
=
ûû 
$num
ûû 
;
ûû 
i
ûû  !
<
ûû" #
edges
ûû$ )
.
ûû) *
Length
ûû* 0
;
ûû0 1
i
ûû2 3
++
ûû3 5
)
ûû5 6
{
üü 
int
†† 
vc
†† 
=
†† 
vertices
†† %
.
††% &
Count
††& +
;
††+ ,
int
°° 
x
°° 
=
°° 
edges
°° !
[
°°! "
i
°°" #
]
°°# $
.
°°$ %
a
°°% &
,
°°& '
y
°°( )
=
°°* +
edges
°°, 1
[
°°1 2
i
°°2 3
]
°°3 4
.
°°4 5
b
°°5 6
;
°°6 7
if
££ 
(
££ 
!
££ 
used
££ 
.
££ 
ContainsKey
££ )
(
££) *
x
££* +
)
££+ ,
)
££, -
{
§§ 
used
•• 
.
•• 
Add
••  
(
••  !
x
••! "
,
••" #
lookup
••$ *
[
••* +
x
••+ ,
]
••, -
)
••- .
;
••. /
lookup
¶¶ 
[
¶¶ 
x
¶¶  
]
¶¶  !
=
¶¶" #
sharedIndexMax
¶¶$ 2
+
¶¶3 4
(
¶¶5 6
sharedIndexOffset
¶¶6 G
++
¶¶G I
)
¶¶I J
;
¶¶J K
}
ßß 
if
©© 
(
©© 
!
©© 
used
©© 
.
©© 
ContainsKey
©© )
(
©©) *
y
©©* +
)
©©+ ,
)
©©, -
{
™™ 
used
´´ 
.
´´ 
Add
´´  
(
´´  !
y
´´! "
,
´´" #
lookup
´´$ *
[
´´* +
y
´´+ ,
]
´´, -
)
´´- .
;
´´. /
lookup
¨¨ 
[
¨¨ 
y
¨¨  
]
¨¨  !
=
¨¨" #
sharedIndexMax
¨¨$ 2
+
¨¨3 4
(
¨¨5 6
sharedIndexOffset
¨¨6 G
++
¨¨G I
)
¨¨I J
;
¨¨J K
}
≠≠ 
lookup
ØØ 
.
ØØ 
Add
ØØ 
(
ØØ 
vc
ØØ !
+
ØØ" #
$num
ØØ$ %
,
ØØ% &
used
ØØ' +
[
ØØ+ ,
x
ØØ, -
]
ØØ- .
)
ØØ. /
;
ØØ/ 0
lookup
∞∞ 
.
∞∞ 
Add
∞∞ 
(
∞∞ 
vc
∞∞ !
+
∞∞" #
$num
∞∞$ %
,
∞∞% &
used
∞∞' +
[
∞∞+ ,
y
∞∞, -
]
∞∞- .
)
∞∞. /
;
∞∞/ 0
lookup
±± 
.
±± 
Add
±± 
(
±± 
vc
±± !
+
±±" #
$num
±±$ %
,
±±% &
lookup
±±' -
[
±±- .
x
±±. /
]
±±/ 0
)
±±0 1
;
±±1 2
lookup
≤≤ 
.
≤≤ 
Add
≤≤ 
(
≤≤ 
vc
≤≤ !
+
≤≤" #
$num
≤≤$ %
,
≤≤% &
lookup
≤≤' -
[
≤≤- .
y
≤≤. /
]
≤≤/ 0
)
≤≤0 1
;
≤≤1 2
Vertex
¥¥ 
xx
¥¥ 
=
¥¥ 
new
¥¥  #
Vertex
¥¥$ *
(
¥¥* +
vertices
¥¥+ 3
[
¥¥3 4
x
¥¥4 5
]
¥¥5 6
)
¥¥6 7
,
¥¥7 8
yy
¥¥9 ;
=
¥¥< =
new
¥¥> A
Vertex
¥¥B H
(
¥¥H I
vertices
¥¥I Q
[
¥¥Q R
y
¥¥R S
]
¥¥S T
)
¥¥T U
;
¥¥U V
xx
µµ 
.
µµ 
position
µµ 
+=
µµ  "
delta
µµ# (
;
µµ( )
yy
∂∂ 
.
∂∂ 
position
∂∂ 
+=
∂∂  "
delta
∂∂# (
;
∂∂( )
vertices
∏∏ 
.
∏∏ 
Add
∏∏  
(
∏∏  !
new
∏∏! $
Vertex
∏∏% +
(
∏∏+ ,
vertices
∏∏, 4
[
∏∏4 5
x
∏∏5 6
]
∏∏6 7
)
∏∏7 8
)
∏∏8 9
;
∏∏9 :
vertices
ππ 
.
ππ 
Add
ππ  
(
ππ  !
new
ππ! $
Vertex
ππ% +
(
ππ+ ,
vertices
ππ, 4
[
ππ4 5
y
ππ5 6
]
ππ6 7
)
ππ7 8
)
ππ8 9
;
ππ9 :
vertices
ªª 
.
ªª 
Add
ªª  
(
ªª  !
xx
ªª! #
)
ªª# $
;
ªª$ %
vertices
ºº 
.
ºº 
Add
ºº  
(
ºº  !
yy
ºº! #
)
ºº# $
;
ºº$ %
Face
ææ 
bridge
ææ 
=
ææ  !
new
ææ" %
Face
ææ& *
(
ææ* +
new
øø 
int
øø  #
[
øø# $
$num
øø$ %
]
øø% &
{
øø' (
vc
øø) +
+
øø, -
$num
øø. /
,
øø/ 0
vc
øø1 3
+
øø4 5
$num
øø6 7
,
øø7 8
vc
øø9 ;
+
øø< =
$num
øø> ?
,
øø? @
vc
øøA C
+
øøD E
$num
øøF G
,
øøG H
vc
øøI K
+
øøL M
$num
øøN O
,
øøO P
vc
øøQ S
+
øøT U
$num
øøV W
}
øøX Y
,
øøY Z
face
¿¿  
.
¿¿  !
submeshIndex
¿¿! -
,
¿¿- .
new
¡¡  
AutoUnwrapSettings
¡¡  2
(
¡¡2 3
face
¡¡3 7
.
¡¡7 8
uv
¡¡8 :
)
¡¡: ;
,
¡¡; <
face
¬¬  
.
¬¬  !
smoothingGroup
¬¬! /
,
¬¬/ 0
-
√√ 
$num
√√ 
,
√√ 
-
ƒƒ 
$num
ƒƒ 
,
ƒƒ 
false
≈≈ !
)
∆∆ 
;
∆∆ 
newFaces
»» 
[
»» 
	faceIndex
»» &
++
»»& (
]
»»( )
=
»»* +
bridge
»», 2
;
»»2 3
}
…… 
for
ÀÀ 
(
ÀÀ 
int
ÀÀ 
i
ÀÀ 
=
ÀÀ 
$num
ÀÀ 
;
ÀÀ 
i
ÀÀ  !
<
ÀÀ" #
face
ÀÀ$ (
.
ÀÀ( )%
distinctIndexesInternal
ÀÀ) @
.
ÀÀ@ A
Length
ÀÀA G
;
ÀÀG H
i
ÀÀI J
++
ÀÀJ L
)
ÀÀL M
{
ÃÃ 
vertices
ÕÕ 
[
ÕÕ 
face
ÕÕ !
.
ÕÕ! "%
distinctIndexesInternal
ÕÕ" 9
[
ÕÕ9 :
i
ÕÕ: ;
]
ÕÕ; <
]
ÕÕ< =
.
ÕÕ= >
position
ÕÕ> F
+=
ÕÕG I
delta
ÕÕJ O
;
ÕÕO P
if
–– 
(
–– 
lookupUV
––  
!=
––! #
null
––$ (
&&
––) +
lookupUV
––, 4
.
––4 5
ContainsKey
––5 @
(
––@ A
face
––A E
.
––E F%
distinctIndexesInternal
––F ]
[
––] ^
i
––^ _
]
––_ `
)
––` a
)
––a b
lookupUV
——  
.
——  !
Remove
——! '
(
——' (
face
——( ,
.
——, -%
distinctIndexesInternal
——- D
[
——D E
i
——E F
]
——F G
)
——G H
;
——H I
}
““ 
}
”” 
pb
’’ 
.
’’ 
SetVertices
’’ 
(
’’ 
vertices
’’ #
)
’’# $
;
’’$ %
var
◊◊ 
fc
◊◊ 
=
◊◊ 
pb
◊◊ 
.
◊◊ 
	faceCount
◊◊ !
;
◊◊! "
var
ÿÿ 
nc
ÿÿ 
=
ÿÿ 
newFaces
ÿÿ 
.
ÿÿ 
Length
ÿÿ $
;
ÿÿ$ %
var
ŸŸ 
appended
ŸŸ 
=
ŸŸ 
new
ŸŸ 
Face
ŸŸ #
[
ŸŸ# $
fc
ŸŸ$ &
+
ŸŸ' (
nc
ŸŸ) +
]
ŸŸ+ ,
;
ŸŸ, -
Array
⁄⁄ 
.
⁄⁄ 
Copy
⁄⁄ 
(
⁄⁄ 
pb
⁄⁄ 
.
⁄⁄ 
facesInternal
⁄⁄ '
,
⁄⁄' (
$num
⁄⁄) *
,
⁄⁄* +
appended
⁄⁄, 4
,
⁄⁄4 5
$num
⁄⁄6 7
,
⁄⁄7 8
fc
⁄⁄9 ;
)
⁄⁄; <
;
⁄⁄< =
Array
€€ 
.
€€ 
Copy
€€ 
(
€€ 
newFaces
€€ 
,
€€  
$num
€€! "
,
€€" #
appended
€€$ ,
,
€€, -
fc
€€. 0
,
€€0 1
nc
€€2 4
)
€€4 5
;
€€5 6
pb
‹‹ 
.
‹‹ 
faces
‹‹ 
=
‹‹ 
appended
‹‹ 
;
‹‹  
pb
›› 
.
›› 
SetSharedVertices
››  
(
››  !
lookup
››! '
)
››' (
;
››( )
pb
ﬁﬁ 
.
ﬁﬁ 
SetSharedTextures
ﬁﬁ  
(
ﬁﬁ  !
lookupUV
ﬁﬁ! )
)
ﬁﬁ) *
;
ﬁﬁ* +
return
‡‡ 
newFaces
‡‡ 
;
‡‡ 
}
·· 	
static
ÎÎ 
Face
ÎÎ 
[
ÎÎ 
]
ÎÎ 
ExtrudeAsGroups
ÎÎ %
(
ÎÎ% &
ProBuilderMesh
ÎÎ& 4
mesh
ÎÎ5 9
,
ÎÎ9 :
IEnumerable
ÎÎ; F
<
ÎÎF G
Face
ÎÎG K
>
ÎÎK L
faces
ÎÎM R
,
ÎÎR S
bool
ÎÎT X+
compensateAngleVertexDistance
ÎÎY v
,
ÎÎv w
float
ÎÎx }
distanceÎÎ~ Ü
)ÎÎÜ á
{
ÏÏ 	
if
ÌÌ 
(
ÌÌ 
faces
ÌÌ 
==
ÌÌ 
null
ÌÌ 
||
ÌÌ  
!
ÌÌ! "
faces
ÌÌ" '
.
ÌÌ' (
Any
ÌÌ( +
(
ÌÌ+ ,
)
ÌÌ, -
)
ÌÌ- .
return
ÓÓ 
null
ÓÓ 
;
ÓÓ 
List
 
<
 
Vertex
 
>
 
vertices
 !
=
" #
new
$ '
List
( ,
<
, -
Vertex
- 3
>
3 4
(
4 5
mesh
5 9
.
9 :
GetVertices
: E
(
E F
)
F G
)
G H
;
H I
int
ÒÒ 
sharedIndexMax
ÒÒ 
=
ÒÒ  
mesh
ÒÒ! %
.
ÒÒ% &$
sharedVerticesInternal
ÒÒ& <
.
ÒÒ< =
Length
ÒÒ= C
;
ÒÒC D
int
ÚÚ 
sharedIndexOffset
ÚÚ !
=
ÚÚ" #
$num
ÚÚ$ %
;
ÚÚ% &

Dictionary
ÛÛ 
<
ÛÛ 
int
ÛÛ 
,
ÛÛ 
int
ÛÛ 
>
ÛÛ  
lookup
ÛÛ! '
=
ÛÛ( )
mesh
ÛÛ* .
.
ÛÛ. / 
sharedVertexLookup
ÛÛ/ A
;
ÛÛA B

Dictionary
ÙÙ 
<
ÙÙ 
int
ÙÙ 
,
ÙÙ 
int
ÙÙ 
>
ÙÙ  
lookupUV
ÙÙ! )
=
ÙÙ* +
mesh
ÙÙ, 0
.
ÙÙ0 1!
sharedTextureLookup
ÙÙ1 D
;
ÙÙD E
List
ˆˆ 
<
ˆˆ 
Face
ˆˆ 
>
ˆˆ 
newFaces
ˆˆ 
=
ˆˆ  !
new
ˆˆ" %
List
ˆˆ& *
<
ˆˆ* +
Face
ˆˆ+ /
>
ˆˆ/ 0
(
ˆˆ0 1
)
ˆˆ1 2
;
ˆˆ2 3

Dictionary
¯¯ 
<
¯¯ 
int
¯¯ 
,
¯¯ 
int
¯¯ 
>
¯¯  
oldSharedMap
¯¯! -
=
¯¯. /
new
¯¯0 3

Dictionary
¯¯4 >
<
¯¯> ?
int
¯¯? B
,
¯¯B C
int
¯¯D G
>
¯¯G H
(
¯¯H I
)
¯¯I J
;
¯¯J K

Dictionary
˙˙ 
<
˙˙ 
int
˙˙ 
,
˙˙ 
int
˙˙ 
>
˙˙  
newSharedMap
˙˙! -
=
˙˙. /
new
˙˙0 3

Dictionary
˙˙4 >
<
˙˙> ?
int
˙˙? B
,
˙˙B C
int
˙˙D G
>
˙˙G H
(
˙˙H I
)
˙˙I J
;
˙˙J K

Dictionary
¸¸ 
<
¸¸ 
int
¸¸ 
,
¸¸ 
int
¸¸ 
>
¸¸  
delayPosition
¸¸! .
=
¸¸/ 0
new
¸¸1 4

Dictionary
¸¸5 ?
<
¸¸? @
int
¸¸@ C
,
¸¸C D
int
¸¸E H
>
¸¸H I
(
¸¸I J
)
¸¸J K
;
¸¸K L

Dictionary
ˇˇ 
<
ˇˇ 
int
ˇˇ 
,
ˇˇ 
SimpleTuple
ˇˇ '
<
ˇˇ' (
Vector3
ˇˇ( /
,
ˇˇ/ 0
Vector3
ˇˇ1 8
,
ˇˇ8 9
List
ˇˇ: >
<
ˇˇ> ?
int
ˇˇ? B
>
ˇˇB C
>
ˇˇC D
>
ˇˇD E

extrudeMap
ˇˇF P
=
ˇˇQ R
new
ˇˇS V

Dictionary
ˇˇW a
<
ˇˇa b
int
ˇˇb e
,
ˇˇe f
SimpleTuple
ˇˇg r
<
ˇˇr s
Vector3
ˇˇs z
,
ˇˇz {
Vector3ˇˇ| É
,ˇˇÉ Ñ
ListˇˇÖ â
<ˇˇâ ä
intˇˇä ç
>ˇˇç é
>ˇˇé è
>ˇˇè ê
(ˇˇê ë
)ˇˇë í
;ˇˇí ì
List
ÅÅ 
<
ÅÅ 

WingedEdge
ÅÅ 
>
ÅÅ 
wings
ÅÅ "
=
ÅÅ# $

WingedEdge
ÅÅ% /
.
ÅÅ/ 0
GetWingedEdges
ÅÅ0 >
(
ÅÅ> ?
mesh
ÅÅ? C
,
ÅÅC D
faces
ÅÅE J
,
ÅÅJ K
true
ÅÅL P
)
ÅÅP Q
;
ÅÅQ R
List
ÇÇ 
<
ÇÇ 
HashSet
ÇÇ 
<
ÇÇ 
Face
ÇÇ 
>
ÇÇ 
>
ÇÇ 
groups
ÇÇ  &
=
ÇÇ' (
GetFaceGroups
ÇÇ) 6
(
ÇÇ6 7
wings
ÇÇ7 <
)
ÇÇ< =
;
ÇÇ= >
foreach
ÑÑ 
(
ÑÑ 
HashSet
ÑÑ 
<
ÑÑ 
Face
ÑÑ !
>
ÑÑ! "
group
ÑÑ# (
in
ÑÑ) +
groups
ÑÑ, 2
)
ÑÑ2 3
{
ÖÖ 

Dictionary
ÜÜ 
<
ÜÜ 

EdgeLookup
ÜÜ %
,
ÜÜ% &
Face
ÜÜ' +
>
ÜÜ+ ,
	perimeter
ÜÜ- 6
=
ÜÜ7 8
GetPerimeterEdges
ÜÜ9 J
(
ÜÜJ K
group
ÜÜK P
,
ÜÜP Q
lookup
ÜÜR X
)
ÜÜX Y
;
ÜÜY Z
newSharedMap
àà 
.
àà 
Clear
àà "
(
àà" #
)
àà# $
;
àà$ %
oldSharedMap
ââ 
.
ââ 
Clear
ââ "
(
ââ" #
)
ââ# $
;
ââ$ %
foreach
ãã 
(
ãã 
var
ãã 
edgeAndFace
ãã (
in
ãã) +
	perimeter
ãã, 5
)
ãã5 6
{
åå 

EdgeLookup
çç 
edge
çç #
=
çç$ %
edgeAndFace
çç& 1
.
çç1 2
Key
çç2 5
;
çç5 6
Face
éé 
face
éé 
=
éé 
edgeAndFace
éé  +
.
éé+ ,
Value
éé, 1
;
éé1 2
int
êê 
vc
êê 
=
êê 
vertices
êê %
.
êê% &
Count
êê& +
;
êê+ ,
int
ëë 
x
ëë 
=
ëë 
edge
ëë  
.
ëë  !
local
ëë! &
.
ëë& '
a
ëë' (
,
ëë( )
y
ëë* +
=
ëë, -
edge
ëë. 2
.
ëë2 3
local
ëë3 8
.
ëë8 9
b
ëë9 :
;
ëë: ;
if
ìì 
(
ìì 
!
ìì 
oldSharedMap
ìì %
.
ìì% &
ContainsKey
ìì& 1
(
ìì1 2
x
ìì2 3
)
ìì3 4
)
ìì4 5
{
îî 
oldSharedMap
ïï $
.
ïï$ %
Add
ïï% (
(
ïï( )
x
ïï) *
,
ïï* +
lookup
ïï, 2
[
ïï2 3
x
ïï3 4
]
ïï4 5
)
ïï5 6
;
ïï6 7
int
ññ 
newSharedIndex
ññ *
=
ññ+ ,
-
ññ- .
$num
ññ. /
;
ññ/ 0
if
òò 
(
òò 
newSharedMap
òò (
.
òò( )
TryGetValue
òò) 4
(
òò4 5
lookup
òò5 ;
[
òò; <
x
òò< =
]
òò= >
,
òò> ?
out
òò@ C
newSharedIndex
òòD R
)
òòR S
)
òòS T
{
ôô 
lookup
öö "
[
öö" #
x
öö# $
]
öö$ %
=
öö& '
newSharedIndex
öö( 6
;
öö6 7
}
õõ 
else
úú 
{
ùù 
newSharedIndex
ûû *
=
ûû+ ,
sharedIndexMax
ûû- ;
+
ûû< =
(
ûû> ?
sharedIndexOffset
ûû? P
++
ûûP R
)
ûûR S
;
ûûS T
newSharedMap
üü (
.
üü( )
Add
üü) ,
(
üü, -
lookup
üü- 3
[
üü3 4
x
üü4 5
]
üü5 6
,
üü6 7
newSharedIndex
üü8 F
)
üüF G
;
üüG H
lookup
†† "
[
††" #
x
††# $
]
††$ %
=
††& '
newSharedIndex
††( 6
;
††6 7
}
°° 
}
¢¢ 
if
§§ 
(
§§ 
!
§§ 
oldSharedMap
§§ %
.
§§% &
ContainsKey
§§& 1
(
§§1 2
y
§§2 3
)
§§3 4
)
§§4 5
{
•• 
oldSharedMap
¶¶ $
.
¶¶$ %
Add
¶¶% (
(
¶¶( )
y
¶¶) *
,
¶¶* +
lookup
¶¶, 2
[
¶¶2 3
y
¶¶3 4
]
¶¶4 5
)
¶¶5 6
;
¶¶6 7
int
ßß 
newSharedIndex
ßß *
=
ßß+ ,
-
ßß- .
$num
ßß. /
;
ßß/ 0
if
©© 
(
©© 
newSharedMap
©© (
.
©©( )
TryGetValue
©©) 4
(
©©4 5
lookup
©©5 ;
[
©©; <
y
©©< =
]
©©= >
,
©©> ?
out
©©@ C
newSharedIndex
©©D R
)
©©R S
)
©©S T
{
™™ 
lookup
´´ "
[
´´" #
y
´´# $
]
´´$ %
=
´´& '
newSharedIndex
´´( 6
;
´´6 7
}
¨¨ 
else
≠≠ 
{
ÆÆ 
newSharedIndex
ØØ *
=
ØØ+ ,
sharedIndexMax
ØØ- ;
+
ØØ< =
(
ØØ> ?
sharedIndexOffset
ØØ? P
++
ØØP R
)
ØØR S
;
ØØS T
newSharedMap
∞∞ (
.
∞∞( )
Add
∞∞) ,
(
∞∞, -
lookup
∞∞- 3
[
∞∞3 4
y
∞∞4 5
]
∞∞5 6
,
∞∞6 7
newSharedIndex
∞∞8 F
)
∞∞F G
;
∞∞G H
lookup
±± "
[
±±" #
y
±±# $
]
±±$ %
=
±±& '
newSharedIndex
±±( 6
;
±±6 7
}
≤≤ 
}
≥≥ 
lookup
µµ 
.
µµ 
Add
µµ 
(
µµ 
vc
µµ !
+
µµ" #
$num
µµ$ %
,
µµ% &
oldSharedMap
µµ' 3
[
µµ3 4
x
µµ4 5
]
µµ5 6
)
µµ6 7
;
µµ7 8
lookup
∂∂ 
.
∂∂ 
Add
∂∂ 
(
∂∂ 
vc
∂∂ !
+
∂∂" #
$num
∂∂$ %
,
∂∂% &
oldSharedMap
∂∂' 3
[
∂∂3 4
y
∂∂4 5
]
∂∂5 6
)
∂∂6 7
;
∂∂7 8
lookup
∑∑ 
.
∑∑ 
Add
∑∑ 
(
∑∑ 
vc
∑∑ !
+
∑∑" #
$num
∑∑$ %
,
∑∑% &
lookup
∑∑' -
[
∑∑- .
x
∑∑. /
]
∑∑/ 0
)
∑∑0 1
;
∑∑1 2
lookup
∏∏ 
.
∏∏ 
Add
∏∏ 
(
∏∏ 
vc
∏∏ !
+
∏∏" #
$num
∏∏$ %
,
∏∏% &
lookup
∏∏' -
[
∏∏- .
y
∏∏. /
]
∏∏/ 0
)
∏∏0 1
;
∏∏1 2
delayPosition
∫∫ !
.
∫∫! "
Add
∫∫" %
(
∫∫% &
vc
∫∫& (
+
∫∫) *
$num
∫∫+ ,
,
∫∫, -
x
∫∫. /
)
∫∫/ 0
;
∫∫0 1
delayPosition
ªª !
.
ªª! "
Add
ªª" %
(
ªª% &
vc
ªª& (
+
ªª) *
$num
ªª+ ,
,
ªª, -
y
ªª. /
)
ªª/ 0
;
ªª0 1
vertices
ΩΩ 
.
ΩΩ 
Add
ΩΩ  
(
ΩΩ  !
new
ΩΩ! $
Vertex
ΩΩ% +
(
ΩΩ+ ,
vertices
ΩΩ, 4
[
ΩΩ4 5
x
ΩΩ5 6
]
ΩΩ6 7
)
ΩΩ7 8
)
ΩΩ8 9
;
ΩΩ9 :
vertices
ææ 
.
ææ 
Add
ææ  
(
ææ  !
new
ææ! $
Vertex
ææ% +
(
ææ+ ,
vertices
ææ, 4
[
ææ4 5
y
ææ5 6
]
ææ6 7
)
ææ7 8
)
ææ8 9
;
ææ9 :
vertices
¡¡ 
.
¡¡ 
Add
¡¡  
(
¡¡  !
null
¡¡! %
)
¡¡% &
;
¡¡& '
vertices
¬¬ 
.
¬¬ 
Add
¬¬  
(
¬¬  !
null
¬¬! %
)
¬¬% &
;
¬¬& '
Face
ƒƒ 
bridge
ƒƒ 
=
ƒƒ  !
new
ƒƒ" %
Face
ƒƒ& *
(
ƒƒ* +
new
≈≈ 
int
≈≈  #
[
≈≈# $
$num
≈≈$ %
]
≈≈% &
{
≈≈' (
vc
≈≈) +
+
≈≈, -
$num
≈≈. /
,
≈≈/ 0
vc
≈≈1 3
+
≈≈4 5
$num
≈≈6 7
,
≈≈7 8
vc
≈≈9 ;
+
≈≈< =
$num
≈≈> ?
,
≈≈? @
vc
≈≈A C
+
≈≈D E
$num
≈≈F G
,
≈≈G H
vc
≈≈I K
+
≈≈L M
$num
≈≈N O
,
≈≈O P
vc
≈≈Q S
+
≈≈T U
$num
≈≈V W
}
≈≈X Y
,
≈≈Y Z
face
∆∆  
.
∆∆  !
submeshIndex
∆∆! -
,
∆∆- .
new
««  
AutoUnwrapSettings
««  2
(
««2 3
face
««3 7
.
««7 8
uv
««8 :
)
««: ;
,
««; <
	Smoothing
»» %
.
»»% & 
smoothingGroupNone
»»& 8
,
»»8 9
-
…… 
$num
…… 
,
…… 
-
   
$num
   
,
   
false
ÀÀ !
)
ÃÃ 
;
ÃÃ 
newFaces
ŒŒ 
.
ŒŒ 
Add
ŒŒ  
(
ŒŒ  !
bridge
ŒŒ! '
)
ŒŒ' (
;
ŒŒ( )
}
œœ 
foreach
—— 
(
—— 
Face
—— 
face
—— "
in
——# %
group
——& +
)
——+ ,
{
““ 
face
‘‘ 
.
‘‘ 
textureGroup
‘‘ %
=
‘‘& '
-
‘‘( )
$num
‘‘) *
;
‘‘* +
Vector3
÷÷ 
normal
÷÷ "
=
÷÷# $
Math
÷÷% )
.
÷÷) *
Normal
÷÷* 0
(
÷÷0 1
mesh
÷÷1 5
,
÷÷5 6
face
÷÷7 ;
)
÷÷; <
;
÷÷< =
for
ÿÿ 
(
ÿÿ 
int
ÿÿ 
i
ÿÿ 
=
ÿÿ  
$num
ÿÿ! "
;
ÿÿ" #
i
ÿÿ$ %
<
ÿÿ& '
face
ÿÿ( ,
.
ÿÿ, -%
distinctIndexesInternal
ÿÿ- D
.
ÿÿD E
Length
ÿÿE K
;
ÿÿK L
i
ÿÿM N
++
ÿÿN P
)
ÿÿP Q
{
ŸŸ 
int
⁄⁄ 
idx
⁄⁄ 
=
⁄⁄  !
face
⁄⁄" &
.
⁄⁄& '%
distinctIndexesInternal
⁄⁄' >
[
⁄⁄> ?
i
⁄⁄? @
]
⁄⁄@ A
;
⁄⁄A B
if
ﬁﬁ 
(
ﬁﬁ 
!
ﬁﬁ 
oldSharedMap
ﬁﬁ )
.
ﬁﬁ) *
ContainsKey
ﬁﬁ* 5
(
ﬁﬁ5 6
idx
ﬁﬁ6 9
)
ﬁﬁ9 :
&&
ﬁﬁ; =
newSharedMap
ﬁﬁ> J
.
ﬁﬁJ K
ContainsKey
ﬁﬁK V
(
ﬁﬁV W
lookup
ﬁﬁW ]
[
ﬁﬁ] ^
idx
ﬁﬁ^ a
]
ﬁﬁa b
)
ﬁﬁb c
)
ﬁﬁc d
lookup
ﬂﬂ "
[
ﬂﬂ" #
idx
ﬂﬂ# &
]
ﬂﬂ& '
=
ﬂﬂ( )
newSharedMap
ﬂﬂ* 6
[
ﬂﬂ6 7
lookup
ﬂﬂ7 =
[
ﬂﬂ= >
idx
ﬂﬂ> A
]
ﬂﬂA B
]
ﬂﬂB C
;
ﬂﬂC D
int
·· 
com
·· 
=
··  !
lookup
··" (
[
··( )
idx
··) ,
]
··, -
;
··- .
if
‰‰ 
(
‰‰ 
lookupUV
‰‰ $
!=
‰‰% '
null
‰‰( ,
&&
‰‰- /
lookupUV
‰‰0 8
.
‰‰8 9
ContainsKey
‰‰9 D
(
‰‰D E
face
‰‰E I
.
‰‰I J%
distinctIndexesInternal
‰‰J a
[
‰‰a b
i
‰‰b c
]
‰‰c d
)
‰‰d e
)
‰‰e f
lookupUV
ÂÂ $
.
ÂÂ$ %
Remove
ÂÂ% +
(
ÂÂ+ ,
face
ÂÂ, 0
.
ÂÂ0 1%
distinctIndexesInternal
ÂÂ1 H
[
ÂÂH I
i
ÂÂI J
]
ÂÂJ K
)
ÂÂK L
;
ÂÂL M
SimpleTuple
ËË #
<
ËË# $
Vector3
ËË$ +
,
ËË+ ,
Vector3
ËË- 4
,
ËË4 5
List
ËË6 :
<
ËË: ;
int
ËË; >
>
ËË> ?
>
ËË? @
dir
ËËA D
;
ËËD E
if
ÍÍ 
(
ÍÍ 

extrudeMap
ÍÍ &
.
ÍÍ& '
TryGetValue
ÍÍ' 2
(
ÍÍ2 3
com
ÍÍ3 6
,
ÍÍ6 7
out
ÍÍ8 ;
dir
ÍÍ< ?
)
ÍÍ? @
)
ÍÍ@ A
{
ÎÎ 
dir
ÏÏ 
.
ÏÏ  
item1
ÏÏ  %
+=
ÏÏ& (
normal
ÏÏ) /
;
ÏÏ/ 0
dir
ÌÌ 
.
ÌÌ  
item3
ÌÌ  %
.
ÌÌ% &
Add
ÌÌ& )
(
ÌÌ) *
idx
ÌÌ* -
)
ÌÌ- .
;
ÌÌ. /

extrudeMap
ÓÓ &
[
ÓÓ& '
com
ÓÓ' *
]
ÓÓ* +
=
ÓÓ, -
dir
ÓÓ. 1
;
ÓÓ1 2
}
ÔÔ 
else
 
{
ÒÒ 

extrudeMap
ÚÚ &
.
ÚÚ& '
Add
ÚÚ' *
(
ÚÚ* +
com
ÚÚ+ .
,
ÚÚ. /
new
ÚÚ0 3
SimpleTuple
ÚÚ4 ?
<
ÚÚ? @
Vector3
ÚÚ@ G
,
ÚÚG H
Vector3
ÚÚI P
,
ÚÚP Q
List
ÚÚR V
<
ÚÚV W
int
ÚÚW Z
>
ÚÚZ [
>
ÚÚ[ \
(
ÚÚ\ ]
normal
ÚÚ] c
,
ÚÚc d
normal
ÚÚe k
,
ÚÚk l
new
ÚÚm p
List
ÚÚq u
<
ÚÚu v
int
ÚÚv y
>
ÚÚy z
(
ÚÚz {
)
ÚÚ{ |
{
ÚÚ} ~
idxÚÚ Ç
}ÚÚÉ Ñ
)ÚÚÑ Ö
)ÚÚÖ Ü
;ÚÚÜ á
}
ÛÛ 
}
ÙÙ 
}
ıı 
}
ˆˆ 
foreach
¯¯ 
(
¯¯ 
var
¯¯ 
kvp
¯¯ 
in
¯¯ 

extrudeMap
¯¯  *
)
¯¯* +
{
˘˘ 
Vector3
˙˙ 
	direction
˙˙ !
=
˙˙" #
(
˙˙$ %
kvp
˙˙% (
.
˙˙( )
Value
˙˙) .
.
˙˙. /
item1
˙˙/ 4
/
˙˙5 6
kvp
˙˙7 :
.
˙˙: ;
Value
˙˙; @
.
˙˙@ A
item3
˙˙A F
.
˙˙F G
Count
˙˙G L
)
˙˙L M
;
˙˙M N
	direction
˚˚ 
.
˚˚ 
	Normalize
˚˚ #
(
˚˚# $
)
˚˚$ %
;
˚˚% &
float
˛˛ 
modifier
˛˛ 
=
˛˛  +
compensateAngleVertexDistance
˛˛! >
?
˛˛? @
Math
˛˛A E
.
˛˛E F
Secant
˛˛F L
(
˛˛L M
Vector3
˛˛M T
.
˛˛T U
Angle
˛˛U Z
(
˛˛Z [
	direction
˛˛[ d
,
˛˛d e
kvp
˛˛f i
.
˛˛i j
Value
˛˛j o
.
˛˛o p
item2
˛˛p u
)
˛˛u v
*
˛˛w x
Mathf
˛˛y ~
.
˛˛~ 
Deg2Rad˛˛ Ü
)˛˛Ü á
:˛˛à â
$num˛˛ä å
;˛˛å ç
	direction
ÄÄ 
.
ÄÄ 
x
ÄÄ 
*=
ÄÄ 
distance
ÄÄ '
*
ÄÄ( )
modifier
ÄÄ* 2
;
ÄÄ2 3
	direction
ÅÅ 
.
ÅÅ 
y
ÅÅ 
*=
ÅÅ 
distance
ÅÅ '
*
ÅÅ( )
modifier
ÅÅ* 2
;
ÅÅ2 3
	direction
ÇÇ 
.
ÇÇ 
z
ÇÇ 
*=
ÇÇ 
distance
ÇÇ '
*
ÇÇ( )
modifier
ÇÇ* 2
;
ÇÇ2 3
foreach
ÑÑ 
(
ÑÑ 
int
ÑÑ 
i
ÑÑ 
in
ÑÑ !
kvp
ÑÑ" %
.
ÑÑ% &
Value
ÑÑ& +
.
ÑÑ+ ,
item3
ÑÑ, 1
)
ÑÑ1 2
{
ÖÖ 
vertices
ÜÜ 
[
ÜÜ 
i
ÜÜ 
]
ÜÜ 
.
ÜÜ  
position
ÜÜ  (
+=
ÜÜ) +
	direction
ÜÜ, 5
;
ÜÜ5 6
}
áá 
}
àà 
foreach
ää 
(
ää 
var
ää 
kvp
ää 
in
ää 
delayPosition
ää  -
)
ää- .
vertices
ãã 
[
ãã 
kvp
ãã 
.
ãã 
Key
ãã  
]
ãã  !
=
ãã" #
new
ãã$ '
Vertex
ãã( .
(
ãã. /
vertices
ãã/ 7
[
ãã7 8
kvp
ãã8 ;
.
ãã; <
Value
ãã< A
]
ããA B
)
ããB C
;
ããC D
mesh
çç 
.
çç 
SetVertices
çç 
(
çç 
vertices
çç %
)
çç% &
;
çç& '
var
èè 
fc
èè 
=
èè 
mesh
èè 
.
èè 
	faceCount
èè #
;
èè# $
var
êê 
nc
êê 
=
êê 
newFaces
êê 
.
êê 
Count
êê #
;
êê# $
var
ëë 
appended
ëë 
=
ëë 
new
ëë 
Face
ëë #
[
ëë# $
fc
ëë$ &
+
ëë' (
nc
ëë) +
]
ëë+ ,
;
ëë, -
Array
íí 
.
íí 
Copy
íí 
(
íí 
mesh
íí 
.
íí 
facesInternal
íí )
,
íí) *
$num
íí+ ,
,
íí, -
appended
íí. 6
,
íí6 7
$num
íí8 9
,
íí9 :
fc
íí; =
)
íí= >
;
íí> ?
for
ìì 
(
ìì 
int
ìì 
i
ìì 
=
ìì 
fc
ìì 
,
ìì 
c
ìì 
=
ìì  
fc
ìì! #
+
ìì$ %
nc
ìì& (
;
ìì( )
i
ìì* +
<
ìì, -
c
ìì. /
;
ìì/ 0
i
ìì1 2
++
ìì2 4
)
ìì4 5
appended
îî 
[
îî 
i
îî 
]
îî 
=
îî 
newFaces
îî &
[
îî& '
i
îî' (
-
îî) *
fc
îî+ -
]
îî- .
;
îî. /
mesh
ïï 
.
ïï 
faces
ïï 
=
ïï 
appended
ïï !
;
ïï! "
mesh
ññ 
.
ññ 
SetSharedVertices
ññ "
(
ññ" #
lookup
ññ# )
)
ññ) *
;
ññ* +
mesh
óó 
.
óó 
SetSharedTextures
óó "
(
óó" #
lookupUV
óó# +
)
óó+ ,
;
óó, -
return
ôô 
newFaces
ôô 
.
ôô 
ToArray
ôô #
(
ôô# $
)
ôô$ %
;
ôô% &
}
öö 	
static
úú 
List
úú 
<
úú 
HashSet
úú 
<
úú 
Face
úú  
>
úú  !
>
úú! "
GetFaceGroups
úú# 0
(
úú0 1
List
úú1 5
<
úú5 6

WingedEdge
úú6 @
>
úú@ A
wings
úúB G
)
úúG H
{
ùù 	
HashSet
ûû 
<
ûû 
Face
ûû 
>
ûû 
used
ûû 
=
ûû  
new
ûû! $
HashSet
ûû% ,
<
ûû, -
Face
ûû- 1
>
ûû1 2
(
ûû2 3
)
ûû3 4
;
ûû4 5
List
üü 
<
üü 
HashSet
üü 
<
üü 
Face
üü 
>
üü 
>
üü 
groups
üü  &
=
üü' (
new
üü) ,
List
üü- 1
<
üü1 2
HashSet
üü2 9
<
üü9 :
Face
üü: >
>
üü> ?
>
üü? @
(
üü@ A
)
üüA B
;
üüB C
foreach
°° 
(
°° 

WingedEdge
°° 
wing
°°  $
in
°°% '
wings
°°( -
)
°°- .
{
¢¢ 
if
££ 
(
££ 
used
££ 
.
££ 
Add
££ 
(
££ 
wing
££ !
.
££! "
face
££" &
)
££& '
)
££' (
{
§§ 
HashSet
•• 
<
•• 
Face
••  
>
••  !
group
••" '
=
••( )
new
••* -
HashSet
••. 5
<
••5 6
Face
••6 :
>
••: ;
(
••; <
)
••< =
{
••> ?
wing
••@ D
.
••D E
face
••E I
}
••J K
;
••K L
ElementSelection
ßß $
.
ßß$ %
Flood
ßß% *
(
ßß* +
wing
ßß+ /
,
ßß/ 0
group
ßß1 6
)
ßß6 7
;
ßß7 8
foreach
©© 
(
©© 
Face
©© !
f
©©" #
in
©©$ &
group
©©' ,
)
©©, -
used
™™ 
.
™™ 
Add
™™  
(
™™  !
f
™™! "
)
™™" #
;
™™# $
groups
¨¨ 
.
¨¨ 
Add
¨¨ 
(
¨¨ 
group
¨¨ $
)
¨¨$ %
;
¨¨% &
}
≠≠ 
}
ÆÆ 
return
∞∞ 
groups
∞∞ 
;
∞∞ 
}
±± 	
static
≥≥ 

Dictionary
≥≥ 
<
≥≥ 

EdgeLookup
≥≥ $
,
≥≥$ %
Face
≥≥& *
>
≥≥* +
GetPerimeterEdges
≥≥, =
(
≥≥= >
HashSet
≥≥> E
<
≥≥E F
Face
≥≥F J
>
≥≥J K
faces
≥≥L Q
,
≥≥Q R

Dictionary
≥≥S ]
<
≥≥] ^
int
≥≥^ a
,
≥≥a b
int
≥≥c f
>
≥≥f g
lookup
≥≥h n
)
≥≥n o
{
¥¥ 	

Dictionary
µµ 
<
µµ 

EdgeLookup
µµ !
,
µµ! "
Face
µµ# '
>
µµ' (
	perimeter
µµ) 2
=
µµ3 4
new
µµ5 8

Dictionary
µµ9 C
<
µµC D

EdgeLookup
µµD N
,
µµN O
Face
µµP T
>
µµT U
(
µµU V
)
µµV W
;
µµW X
HashSet
∂∂ 
<
∂∂ 

EdgeLookup
∂∂ 
>
∂∂ 
used
∂∂  $
=
∂∂% &
new
∂∂' *
HashSet
∂∂+ 2
<
∂∂2 3

EdgeLookup
∂∂3 =
>
∂∂= >
(
∂∂> ?
)
∂∂? @
;
∂∂@ A
foreach
∏∏ 
(
∏∏ 
Face
∏∏ 
face
∏∏ 
in
∏∏ !
faces
∏∏" '
)
∏∏' (
{
ππ 
foreach
∫∫ 
(
∫∫ 
Edge
∫∫ 
edge
∫∫ "
in
∫∫# %
face
∫∫& *
.
∫∫* +
edgesInternal
∫∫+ 8
)
∫∫8 9
{
ªª 

EdgeLookup
ºº 
e
ºº  
=
ºº! "
new
ºº# &

EdgeLookup
ºº' 1
(
ºº1 2
lookup
ºº2 8
[
ºº8 9
edge
ºº9 =
.
ºº= >
a
ºº> ?
]
ºº? @
,
ºº@ A
lookup
ººB H
[
ººH I
edge
ººI M
.
ººM N
b
ººN O
]
ººO P
,
ººP Q
edge
ººR V
.
ººV W
a
ººW X
,
ººX Y
edge
ººZ ^
.
ºº^ _
b
ºº_ `
)
ºº` a
;
ººa b
if
ææ 
(
ææ 
!
ææ 
used
ææ 
.
ææ 
Add
ææ !
(
ææ! "
e
ææ" #
)
ææ# $
)
ææ$ %
{
øø 
if
¿¿ 
(
¿¿ 
	perimeter
¿¿ %
.
¿¿% &
ContainsKey
¿¿& 1
(
¿¿1 2
e
¿¿2 3
)
¿¿3 4
)
¿¿4 5
	perimeter
¡¡ %
.
¡¡% &
Remove
¡¡& ,
(
¡¡, -
e
¡¡- .
)
¡¡. /
;
¡¡/ 0
}
¬¬ 
else
√√ 
{
ƒƒ 
	perimeter
≈≈ !
.
≈≈! "
Add
≈≈" %
(
≈≈% &
e
≈≈& '
,
≈≈' (
face
≈≈) -
)
≈≈- .
;
≈≈. /
}
∆∆ 
}
«« 
}
»» 
return
   
	perimeter
   
;
   
}
ÀÀ 	
}
ÃÃ 
}ÕÕ àÛ
éD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\HandleUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

static 
class 
HandleUtility %
{ 
internal 
static 
Vector3 
ScreenToGuiPoint  0
(0 1
this1 5
Camera6 <
camera= C
,C D
Vector3E L
pointM R
,R S
floatT Y
pixelsPerPointZ h
)h i
{ 	
return 
new 
Vector3 
( 
point $
.$ %
x% &
/' (
pixelsPerPoint) 7
,7 8
(9 :
camera: @
.@ A
pixelHeightA L
-M N
pointO T
.T U
yU V
)V W
/X Y
pixelsPerPointZ h
,h i
pointj o
.o p
zp q
)q r
;r s
} 	
internal## 
static## 
bool## 
FaceRaycast## (
(##( )
Ray##) ,
worldRay##- 5
,##5 6
ProBuilderMesh##7 E
mesh##F J
,##J K
out##L O

RaycastHit##P Z
hit##[ ^
,##^ _
HashSet##` g
<##g h
Face##h l
>##l m
ignore##n t
=##u v
null##w {
)##{ |
{$$ 	
return%% 
FaceRaycast%% 
(%% 
worldRay%% '
,%%' (
mesh%%) -
,%%- .
out%%/ 2
hit%%3 6
,%%6 7
Mathf%%8 =
.%%= >
Infinity%%> F
,%%F G
CullingMode%%H S
.%%S T
Back%%T X
,%%X Y
ignore%%Z `
)%%` a
;%%a b
}&& 	
internal22 
static22 
bool22 
FaceRaycast22 (
(22( )
Ray22) ,
worldRay22- 5
,225 6
ProBuilderMesh227 E
mesh22F J
,22J K
out22L O

RaycastHit22P Z
hit22[ ^
,22^ _
float22` e
distance22f n
,22n o
CullingMode22p {
cullingMode	22| á
,
22á à
HashSet
22â ê
<
22ê ë
Face
22ë ï
>
22ï ñ
ignore
22ó ù
=
22û ü
null
22† §
)
22§ •
{33 	
worldRay55 
.55 
origin55 
-=55 
mesh55 #
.55# $
	transform55$ -
.55- .
position55. 6
;556 7
worldRay66 
.66 
origin66 
=66 
mesh66 "
.66" #
	transform66# ,
.66, -
worldToLocalMatrix66- ?
*66@ A
worldRay66B J
.66J K
origin66K Q
;66Q R
worldRay77 
.77 
	direction77 
=77  
mesh77! %
.77% &
	transform77& /
.77/ 0
worldToLocalMatrix770 B
*77C D
worldRay77E M
.77M N
	direction77N W
;77W X
var99 
	positions99 
=99 
mesh99  
.99  !
positionsInternal99! 2
;992 3
var:: 
faces:: 
=:: 
mesh:: 
.:: 
facesInternal:: *
;::* +
float<< 
OutHitPoint<< 
=<< 
Mathf<<  %
.<<% &
Infinity<<& .
;<<. /
int== 

OutHitFace== 
=== 
-== 
$num== 
;==  
Vector3>> 
OutNrm>> 
=>> 
Vector3>> $
.>>$ %
zero>>% )
;>>) *
forAA 
(AA 
intAA 
iAA 
=AA 
$numAA 
,AA 
fcAA 
=AA  
facesAA! &
.AA& '
LengthAA' -
;AA- .
iAA/ 0
<AA1 2
fcAA3 5
;AA5 6
++AA7 9
iAA9 :
)AA: ;
{BB 
ifCC 
(CC 
ignoreCC 
!=CC 
nullCC "
&&CC# %
ignoreCC& ,
.CC, -
ContainsCC- 5
(CC5 6
facesCC6 ;
[CC; <
iCC< =
]CC= >
)CC> ?
)CC? @
continueDD 
;DD 
intFF 
[FF 
]FF 
indexesFF 
=FF 
meshFF  $
.FF$ %
facesInternalFF% 2
[FF2 3
iFF3 4
]FF4 5
.FF5 6
indexesInternalFF6 E
;FFE F
forHH 
(HH 
intHH 
jHH 
=HH 
$numHH 
,HH 
icHH  "
=HH# $
indexesHH% ,
.HH, -
LengthHH- 3
;HH3 4
jHH5 6
<HH7 8
icHH9 ;
;HH; <
jHH= >
+=HH? A
$numHHB C
)HHC D
{II 
Vector3JJ 
aJJ 
=JJ 
	positionsJJ  )
[JJ) *
indexesJJ* 1
[JJ1 2
jJJ2 3
+JJ4 5
$numJJ6 7
]JJ7 8
]JJ8 9
;JJ9 :
Vector3KK 
bKK 
=KK 
	positionsKK  )
[KK) *
indexesKK* 1
[KK1 2
jKK2 3
+KK4 5
$numKK6 7
]KK7 8
]KK8 9
;KK9 :
Vector3LL 
cLL 
=LL 
	positionsLL  )
[LL) *
indexesLL* 1
[LL1 2
jLL2 3
+LL4 5
$numLL6 7
]LL7 8
]LL8 9
;LL9 :
Vector3NN 
nrmNN 
=NN  !
Vector3NN" )
.NN) *
CrossNN* /
(NN/ 0
bNN0 1
-NN2 3
aNN4 5
,NN5 6
cNN7 8
-NN9 :
aNN; <
)NN< =
;NN= >
floatOO 
dotOO 
=OO 
Vector3OO  '
.OO' (
DotOO( +
(OO+ ,
worldRayOO, 4
.OO4 5
	directionOO5 >
,OO> ?
nrmOO@ C
)OOC D
;OOD E
boolQQ 
skipQQ 
=QQ 
falseQQ  %
;QQ% &
switchSS 
(SS 
cullingModeSS '
)SS' (
{TT 
caseUU 
CullingModeUU (
.UU( )
FrontUU) .
:UU. /
ifVV 
(VV  
dotVV  #
<VV$ %
$numVV& (
)VV( )
skipVV* .
=VV/ 0
trueVV1 5
;VV5 6
breakWW !
;WW! "
caseYY 
CullingModeYY (
.YY( )
BackYY) -
:YY- .
ifZZ 
(ZZ  
dotZZ  #
>ZZ$ %
$numZZ& (
)ZZ( )
skipZZ* .
=ZZ/ 0
trueZZ1 5
;ZZ5 6
break[[ !
;[[! "
}\\ 
var^^ 
dist^^ 
=^^ 
$num^^ !
;^^! "
Vector3`` 
point`` !
;``! "
ifaa 
(aa 
!aa 
skipaa 
&&aa  
Mathaa! %
.aa% &!
RayIntersectsTriangleaa& ;
(aa; <
worldRayaa< D
,aaD E
aaaF G
,aaG H
baaI J
,aaJ K
caaL M
,aaM N
outaaO R
distaaS W
,aaW X
outaaY \
pointaa] b
)aab c
)aac d
{bb 
ifcc 
(cc 
distcc  
>cc! "
OutHitPointcc# .
||cc/ 1
distcc2 6
>cc7 8
distancecc9 A
)ccA B
continuedd $
;dd$ %
OutNrmff 
=ff  
nrmff! $
;ff$ %

OutHitFacegg "
=gg# $
igg% &
;gg& '
OutHitPointhh #
=hh$ %
disthh& *
;hh* +
}ii 
}jj 
}kk 
hitmm 
=mm 
newmm 

RaycastHitmm  
(mm  !
OutHitPointmm! ,
,mm, -
worldRaynn 
.nn 
GetPointnn %
(nn% &
OutHitPointnn& 1
)nn1 2
,nn2 3
OutNrmoo 
,oo 

OutHitFacepp 
)pp 
;pp  
returnrr 

OutHitFacerr 
>rr 
-rr  !
$numrr! "
;rr" #
}ss 	
internaluu 
staticuu 
booluu $
FaceRaycastBothCullModesuu 5
(uu5 6
Rayuu6 9
worldRayuu: B
,uuB C
ProBuilderMeshuuD R
meshuuS W
,uuW X
refuuY \
SimpleTupleuu] h
<uuh i
Faceuui m
,uum n
Vector3uuo v
>uuv w
backuux |
,uu| }
ref	uu~ Å
SimpleTuple
uuÇ ç
<
uuç é
Face
uué í
,
uuí ì
Vector3
uuî õ
>
uuõ ú
front
uuù ¢
)
uu¢ £
{vv 	
worldRayxx 
.xx 
originxx 
-=xx 
meshxx #
.xx# $
	transformxx$ -
.xx- .
positionxx. 6
;xx6 7
worldRayyy 
.yy 
originyy 
=yy 
meshyy "
.yy" #
	transformyy# ,
.yy, -
worldToLocalMatrixyy- ?
*yy@ A
worldRayyyB J
.yyJ K
originyyK Q
;yyQ R
worldRayzz 
.zz 
	directionzz 
=zz  
meshzz! %
.zz% &
	transformzz& /
.zz/ 0
worldToLocalMatrixzz0 B
*zzC D
worldRayzzE M
.zzM N
	directionzzN W
;zzW X
var|| 
	positions|| 
=|| 
mesh||  
.||  !
positionsInternal||! 2
;||2 3
var}} 
faces}} 
=}} 
mesh}} 
.}} 
facesInternal}} *
;}}* +
back 
. 
item1 
= 
null 
; 
front
ÄÄ 
.
ÄÄ 
item1
ÄÄ 
=
ÄÄ 
null
ÄÄ 
;
ÄÄ 
float
ÇÇ 
backDistance
ÇÇ 
=
ÇÇ  
Mathf
ÇÇ! &
.
ÇÇ& '
Infinity
ÇÇ' /
;
ÇÇ/ 0
float
ÉÉ 
frontDistance
ÉÉ 
=
ÉÉ  !
Mathf
ÉÉ" '
.
ÉÉ' (
Infinity
ÉÉ( 0
;
ÉÉ0 1
for
ÜÜ 
(
ÜÜ 
int
ÜÜ 
i
ÜÜ 
=
ÜÜ 
$num
ÜÜ 
,
ÜÜ 
fc
ÜÜ 
=
ÜÜ  
faces
ÜÜ! &
.
ÜÜ& '
Length
ÜÜ' -
;
ÜÜ- .
i
ÜÜ/ 0
<
ÜÜ1 2
fc
ÜÜ3 5
;
ÜÜ5 6
++
ÜÜ7 9
i
ÜÜ9 :
)
ÜÜ: ;
{
áá 
int
àà 
[
àà 
]
àà 
indexes
àà 
=
àà 
mesh
àà  $
.
àà$ %
facesInternal
àà% 2
[
àà2 3
i
àà3 4
]
àà4 5
.
àà5 6
indexesInternal
àà6 E
;
ààE F
for
ää 
(
ää 
int
ää 
j
ää 
=
ää 
$num
ää 
,
ää 
ic
ää  "
=
ää# $
indexes
ää% ,
.
ää, -
Length
ää- 3
;
ää3 4
j
ää5 6
<
ää7 8
ic
ää9 ;
;
ää; <
j
ää= >
+=
ää? A
$num
ääB C
)
ääC D
{
ãã 
Vector3
åå 
a
åå 
=
åå 
	positions
åå  )
[
åå) *
indexes
åå* 1
[
åå1 2
j
åå2 3
+
åå4 5
$num
åå6 7
]
åå7 8
]
åå8 9
;
åå9 :
Vector3
çç 
b
çç 
=
çç 
	positions
çç  )
[
çç) *
indexes
çç* 1
[
çç1 2
j
çç2 3
+
çç4 5
$num
çç6 7
]
çç7 8
]
çç8 9
;
çç9 :
Vector3
éé 
c
éé 
=
éé 
	positions
éé  )
[
éé) *
indexes
éé* 1
[
éé1 2
j
éé2 3
+
éé4 5
$num
éé6 7
]
éé7 8
]
éé8 9
;
éé9 :
float
êê 
dist
êê 
;
êê 
Vector3
ëë 
point
ëë !
;
ëë! "
if
ìì 
(
ìì 
Math
ìì 
.
ìì #
RayIntersectsTriangle
ìì 2
(
ìì2 3
worldRay
ìì3 ;
,
ìì; <
a
ìì= >
,
ìì> ?
b
ìì@ A
,
ììA B
c
ììC D
,
ììD E
out
ììF I
dist
ììJ N
,
ììN O
out
ììP S
point
ììT Y
)
ììY Z
)
ììZ [
{
îî 
if
ïï 
(
ïï 
dist
ïï  
<
ïï! "
backDistance
ïï# /
||
ïï0 2
dist
ïï3 7
<
ïï8 9
frontDistance
ïï: G
)
ïïG H
{
ññ 
Vector3
óó #
nrm
óó$ '
=
óó( )
Vector3
óó* 1
.
óó1 2
Cross
óó2 7
(
óó7 8
b
óó8 9
-
óó: ;
a
óó< =
,
óó= >
c
óó? @
-
óóA B
a
óóC D
)
óóD E
;
óóE F
float
òò !
dot
òò" %
=
òò& '
Vector3
òò( /
.
òò/ 0
Dot
òò0 3
(
òò3 4
worldRay
òò4 <
.
òò< =
	direction
òò= F
,
òòF G
nrm
òòH K
)
òòK L
;
òòL M
if
öö 
(
öö  
dot
öö  #
<
öö$ %
$num
öö& (
)
öö( )
{
õõ 
if
úú  "
(
úú# $
dist
úú$ (
<
úú) *
backDistance
úú+ 7
)
úú7 8
{
ùù  !
backDistance
ûû$ 0
=
ûû1 2
dist
ûû3 7
;
ûû7 8
back
üü$ (
.
üü( )
item1
üü) .
=
üü/ 0
faces
üü1 6
[
üü6 7
i
üü7 8
]
üü8 9
;
üü9 :
}
††  !
}
°° 
else
¢¢  
{
££ 
if
§§  "
(
§§# $
dist
§§$ (
<
§§) *
frontDistance
§§+ 8
)
§§8 9
{
••  !
frontDistance
¶¶$ 1
=
¶¶2 3
dist
¶¶4 8
;
¶¶8 9
front
ßß$ )
.
ßß) *
item1
ßß* /
=
ßß0 1
faces
ßß2 7
[
ßß7 8
i
ßß8 9
]
ßß9 :
;
ßß: ;
}
®®  !
}
©© 
}
™™ 
}
´´ 
}
¨¨ 
}
≠≠ 
if
ØØ 
(
ØØ 
back
ØØ 
.
ØØ 
item1
ØØ 
!=
ØØ 
null
ØØ "
)
ØØ" #
back
∞∞ 
.
∞∞ 
item2
∞∞ 
=
∞∞ 
worldRay
∞∞ %
.
∞∞% &
GetPoint
∞∞& .
(
∞∞. /
backDistance
∞∞/ ;
)
∞∞; <
;
∞∞< =
if
≤≤ 
(
≤≤ 
front
≤≤ 
.
≤≤ 
item1
≤≤ 
!=
≤≤ 
null
≤≤ #
)
≤≤# $
front
≥≥ 
.
≥≥ 
item2
≥≥ 
=
≥≥ 
worldRay
≥≥ &
.
≥≥& '
GetPoint
≥≥' /
(
≥≥/ 0
frontDistance
≥≥0 =
)
≥≥= >
;
≥≥> ?
return
µµ 
back
µµ 
.
µµ 
item1
µµ 
!=
µµ  
null
µµ! %
||
µµ& (
front
µµ) .
.
µµ. /
item1
µµ/ 4
!=
µµ5 7
null
µµ8 <
;
µµ< =
}
∂∂ 	
internal
¡¡ 
static
¡¡ 
bool
¡¡ 
FaceRaycast
¡¡ (
(
¡¡( )
Ray
¬¬ 

InWorldRay
¬¬ 
,
¬¬ 
ProBuilderMesh
√√ 
mesh
√√ 
,
√√  
out
ƒƒ 
List
ƒƒ 
<
ƒƒ 

RaycastHit
ƒƒ 
>
ƒƒ  
hits
ƒƒ! %
,
ƒƒ% &
CullingMode
≈≈ 
cullingMode
≈≈ #
,
≈≈# $
HashSet
∆∆ 
<
∆∆ 
Face
∆∆ 
>
∆∆ 
ignore
∆∆  
=
∆∆! "
null
∆∆# '
)
∆∆' (
{
«« 	

InWorldRay
…… 
.
…… 
origin
…… 
-=
……  
mesh
……! %
.
……% &
	transform
……& /
.
……/ 0
position
……0 8
;
……8 9

InWorldRay
ÀÀ 
.
ÀÀ 
origin
ÀÀ 
=
ÀÀ$ %
mesh
ÀÀ& *
.
ÀÀ* +
	transform
ÀÀ+ 4
.
ÀÀ4 5 
worldToLocalMatrix
ÀÀ5 G
*
ÀÀH I

InWorldRay
ÀÀJ T
.
ÀÀT U
origin
ÀÀU [
;
ÀÀ[ \

InWorldRay
ÃÃ 
.
ÃÃ 
	direction
ÃÃ  
=
ÃÃ$ %
mesh
ÃÃ& *
.
ÃÃ* +
	transform
ÃÃ+ 4
.
ÃÃ4 5 
worldToLocalMatrix
ÃÃ5 G
*
ÃÃH I

InWorldRay
ÃÃJ T
.
ÃÃT U
	direction
ÃÃU ^
;
ÃÃ^ _
Vector3
ŒŒ 
[
ŒŒ 
]
ŒŒ 
vertices
ŒŒ 
=
ŒŒ  
mesh
ŒŒ! %
.
ŒŒ% &
positionsInternal
ŒŒ& 7
;
ŒŒ7 8
hits
–– 
=
–– 
new
–– 
List
–– 
<
–– 

RaycastHit
–– &
>
––& '
(
––' (
)
––( )
;
––) *
for
”” 
(
”” 
int
”” 
CurFace
”” 
=
”” 
$num
””  
;
””  !
CurFace
””" )
<
””* +
mesh
””, 0
.
””0 1
facesInternal
””1 >
.
””> ?
Length
””? E
;
””E F
++
””G I
CurFace
””I P
)
””P Q
{
‘‘ 
if
’’ 
(
’’ 
ignore
’’ 
!=
’’ 
null
’’ "
&&
’’# %
ignore
’’& ,
.
’’, -
Contains
’’- 5
(
’’5 6
mesh
’’6 :
.
’’: ;
facesInternal
’’; H
[
’’H I
CurFace
’’I P
]
’’P Q
)
’’Q R
)
’’R S
continue
÷÷ 
;
÷÷ 
int
ÿÿ 
[
ÿÿ 
]
ÿÿ 
indexes
ÿÿ 
=
ÿÿ 
mesh
ÿÿ  $
.
ÿÿ$ %
facesInternal
ÿÿ% 2
[
ÿÿ2 3
CurFace
ÿÿ3 :
]
ÿÿ: ;
.
ÿÿ; <
indexesInternal
ÿÿ< K
;
ÿÿK L
for
⁄⁄ 
(
⁄⁄ 
int
⁄⁄ 
CurTriangle
⁄⁄ $
=
⁄⁄% &
$num
⁄⁄' (
;
⁄⁄( )
CurTriangle
⁄⁄* 5
<
⁄⁄6 7
indexes
⁄⁄8 ?
.
⁄⁄? @
Length
⁄⁄@ F
;
⁄⁄F G
CurTriangle
⁄⁄H S
+=
⁄⁄T V
$num
⁄⁄W X
)
⁄⁄X Y
{
€€ 
Vector3
‹‹ 
a
‹‹ 
=
‹‹ 
vertices
‹‹  (
[
‹‹( )
indexes
‹‹) 0
[
‹‹0 1
CurTriangle
‹‹1 <
+
‹‹= >
$num
‹‹? @
]
‹‹@ A
]
‹‹A B
;
‹‹B C
Vector3
›› 
b
›› 
=
›› 
vertices
››  (
[
››( )
indexes
››) 0
[
››0 1
CurTriangle
››1 <
+
››= >
$num
››? @
]
››@ A
]
››A B
;
››B C
Vector3
ﬁﬁ 
c
ﬁﬁ 
=
ﬁﬁ 
vertices
ﬁﬁ  (
[
ﬁﬁ( )
indexes
ﬁﬁ) 0
[
ﬁﬁ0 1
CurTriangle
ﬁﬁ1 <
+
ﬁﬁ= >
$num
ﬁﬁ? @
]
ﬁﬁ@ A
]
ﬁﬁA B
;
ﬁﬁB C
var
‡‡ 
dist
‡‡ 
=
‡‡ 
$num
‡‡ !
;
‡‡! "
Vector3
·· 
point
·· !
;
··! "
if
„„ 
(
„„ 
Math
„„ 
.
„„ #
RayIntersectsTriangle
„„ 2
(
„„2 3

InWorldRay
„„3 =
,
„„= >
a
„„? @
,
„„@ A
b
„„B C
,
„„C D
c
„„E F
,
„„F G
out
„„H K
dist
„„L P
,
„„P Q
out
„„R U
point
„„V [
)
„„[ \
)
„„\ ]
{
‰‰ 
Vector3
ÂÂ 
nrm
ÂÂ  #
=
ÂÂ$ %
Vector3
ÂÂ& -
.
ÂÂ- .
Cross
ÂÂ. 3
(
ÂÂ3 4
b
ÂÂ4 5
-
ÂÂ6 7
a
ÂÂ8 9
,
ÂÂ9 :
c
ÂÂ; <
-
ÂÂ= >
a
ÂÂ? @
)
ÂÂ@ A
;
ÂÂA B
float
ÁÁ 
dot
ÁÁ !
;
ÁÁ! "
switch
ËË 
(
ËË  
cullingMode
ËË  +
)
ËË+ ,
{
ÈÈ 
case
ÍÍ  
CullingMode
ÍÍ! ,
.
ÍÍ, -
Front
ÍÍ- 2
:
ÍÍ2 3
dot
ÎÎ  #
=
ÎÎ$ %
Vector3
ÎÎ& -
.
ÎÎ- .
Dot
ÎÎ. 1
(
ÎÎ1 2

InWorldRay
ÎÎ2 <
.
ÎÎ< =
	direction
ÎÎ= F
,
ÎÎF G
nrm
ÎÎH K
)
ÎÎK L
;
ÎÎL M
if
ÌÌ  "
(
ÌÌ# $
dot
ÌÌ$ '
>
ÌÌ( )
$num
ÌÌ* ,
)
ÌÌ, -
goto
ÓÓ$ (
case
ÓÓ) -
CullingMode
ÓÓ. 9
.
ÓÓ9 :
	FrontBack
ÓÓ: C
;
ÓÓC D
break
ÔÔ  %
;
ÔÔ% &
case
ÒÒ  
CullingMode
ÒÒ! ,
.
ÒÒ, -
Back
ÒÒ- 1
:
ÒÒ1 2
dot
ÚÚ  #
=
ÚÚ$ %
Vector3
ÚÚ& -
.
ÚÚ- .
Dot
ÚÚ. 1
(
ÚÚ1 2

InWorldRay
ÚÚ2 <
.
ÚÚ< =
	direction
ÚÚ= F
,
ÚÚF G
nrm
ÚÚH K
)
ÚÚK L
;
ÚÚL M
if
ÙÙ  "
(
ÙÙ# $
dot
ÙÙ$ '
<
ÙÙ( )
$num
ÙÙ* ,
)
ÙÙ, -
goto
ıı$ (
case
ıı) -
CullingMode
ıı. 9
.
ıı9 :
	FrontBack
ıı: C
;
ııC D
break
ˆˆ  %
;
ˆˆ% &
case
¯¯  
CullingMode
¯¯! ,
.
¯¯, -
	FrontBack
¯¯- 6
:
¯¯6 7
hits
˘˘  $
.
˘˘$ %
Add
˘˘% (
(
˘˘( )
new
˘˘) ,

RaycastHit
˘˘- 7
(
˘˘7 8
dist
˘˘8 <
,
˘˘< =

InWorldRay
˙˙$ .
.
˙˙. /
GetPoint
˙˙/ 7
(
˙˙7 8
dist
˙˙8 <
)
˙˙< =
,
˙˙= >
nrm
˚˚$ '
,
˚˚' (
CurFace
¸¸$ +
)
¸¸+ ,
)
¸¸, -
;
¸¸- .
break
˝˝  %
;
˝˝% &
}
˛˛ 
continue
ÄÄ  
;
ÄÄ  !
}
ÅÅ 
}
ÇÇ 
}
ÉÉ 
return
ÖÖ 
hits
ÖÖ 
.
ÖÖ 
Count
ÖÖ 
>
ÖÖ 
$num
ÖÖ  !
;
ÖÖ! "
}
ÜÜ 	
internal
éé 
static
éé 
Ray
éé !
InverseTransformRay
éé /
(
éé/ 0
this
éé0 4
	Transform
éé5 >
	transform
éé? H
,
ééH I
Ray
ééJ M

InWorldRay
ééN X
)
ééX Y
{
èè 	
Vector3
êê 
o
êê 
=
êê 

InWorldRay
êê "
.
êê" #
origin
êê# )
;
êê) *
o
ëë 
-=
ëë 
	transform
ëë 
.
ëë 
position
ëë #
;
ëë# $
o
íí 
=
íí 
	transform
íí 
.
íí  
worldToLocalMatrix
íí ,
*
íí- .
o
íí/ 0
;
íí0 1
Vector3
ìì 
d
ìì 
=
ìì 
	transform
ìì !
.
ìì! " 
worldToLocalMatrix
ìì" 4
.
ìì4 5
MultiplyVector
ìì5 C
(
ììC D

InWorldRay
ììD N
.
ììN O
	direction
ììO X
)
ììX Y
;
ììY Z
return
îî 
new
îî 
Ray
îî 
(
îî 
o
îî 
,
îî 
d
îî 
)
îî  
;
îî  !
}
ïï 	
internal
ûû 
static
ûû 
bool
ûû 
MeshRaycast
ûû (
(
ûû( )
Ray
ûû) ,

InWorldRay
ûû- 7
,
ûû7 8

GameObject
ûû9 C

gameObject
ûûD N
,
ûûN O
out
ûûP S

RaycastHit
ûûT ^
hit
ûû_ b
,
ûûb c
float
ûûd i
distance
ûûj r
=
ûûs t
Mathf
ûûu z
.
ûûz {
Infinityûû{ É
)ûûÉ Ñ
{
üü 	
var
†† 

meshFilter
†† 
=
†† 

gameObject
†† '
.
††' (
GetComponent
††( 4
<
††4 5

MeshFilter
††5 ?
>
††? @
(
††@ A
)
††A B
;
††B C
var
°° 
mesh
°° 
=
°° 

meshFilter
°° !
!=
°°" $
null
°°% )
?
°°* +

meshFilter
°°, 6
.
°°6 7

sharedMesh
°°7 A
:
°°B C
null
°°D H
;
°°H I
if
££ 
(
££ 
!
££ 
mesh
££ 
)
££ 
{
§§ 
hit
•• 
=
•• 
default
•• 
(
•• 

RaycastHit
•• (
)
••( )
;
••) *
return
¶¶ 
false
¶¶ 
;
¶¶ 
}
ßß 
var
©© 
	transform
©© 
=
©© 

gameObject
©© &
.
©©& '
	transform
©©' 0
;
©©0 1
var
™™ 
ray
™™ 
=
™™ 
	transform
™™ 
.
™™  !
InverseTransformRay
™™  3
(
™™3 4

InWorldRay
™™4 >
)
™™> ?
;
™™? @
return
´´ 
MeshRaycast
´´ 
(
´´ 
ray
´´ "
,
´´" #
mesh
´´$ (
.
´´( )
vertices
´´) 1
,
´´1 2
mesh
´´3 7
.
´´7 8
	triangles
´´8 A
,
´´A B
out
´´C F
hit
´´G J
,
´´J K
distance
´´L T
)
´´T U
;
´´U V
}
¨¨ 	
internal
∑∑ 
static
∑∑ 
bool
∑∑ 
MeshRaycast
∑∑ (
(
∑∑( )
Ray
∑∑) ,
InRay
∑∑- 2
,
∑∑2 3
Vector3
∑∑4 ;
[
∑∑; <
]
∑∑< =
mesh
∑∑> B
,
∑∑B C
int
∑∑D G
[
∑∑G H
]
∑∑H I
	triangles
∑∑J S
,
∑∑S T
out
∑∑U X

RaycastHit
∑∑Y c
hit
∑∑d g
,
∑∑g h
float
∑∑i n
distance
∑∑o w
=
∑∑x y
Mathf
∑∑z 
.∑∑ Ä
Infinity∑∑Ä à
)∑∑à â
{
∏∏ 	
float
∫∫ 
hitDistance
∫∫ 
=
∫∫ 
Mathf
∫∫  %
.
∫∫% &
Infinity
∫∫& .
;
∫∫. /
Vector3
ªª 
	hitNormal
ªª 
=
ªª 
new
ªª  #
Vector3
ªª$ +
(
ªª+ ,
$num
ªª, .
,
ªª. /
$num
ªª0 2
,
ªª2 3
$num
ªª4 6
)
ªª6 7
;
ªª7 8
Vector3
ºº 
a
ºº 
,
ºº 
b
ºº 
,
ºº 
c
ºº 
;
ºº 
int
ΩΩ 
hitFace
ΩΩ 
=
ΩΩ 
-
ΩΩ 
$num
ΩΩ 
;
ΩΩ 
Vector3
ææ 
o
ææ 
=
ææ 
InRay
ææ 
.
ææ 
origin
ææ $
,
ææ$ %
d
ææ& '
=
ææ( )
InRay
ææ* /
.
ææ/ 0
	direction
ææ0 9
;
ææ9 :
for
¡¡ 
(
¡¡ 
int
¡¡ 
CurTri
¡¡ 
=
¡¡ 
$num
¡¡ 
;
¡¡  
CurTri
¡¡! '
<
¡¡( )
	triangles
¡¡* 3
.
¡¡3 4
Length
¡¡4 :
;
¡¡: ;
CurTri
¡¡< B
+=
¡¡C E
$num
¡¡F G
)
¡¡G H
{
¬¬ 
a
√√ 
=
√√ 
mesh
√√ 
[
√√ 
	triangles
√√ "
[
√√" #
CurTri
√√# )
+
√√* +
$num
√√, -
]
√√- .
]
√√. /
;
√√/ 0
b
ƒƒ 
=
ƒƒ 
mesh
ƒƒ 
[
ƒƒ 
	triangles
ƒƒ "
[
ƒƒ" #
CurTri
ƒƒ# )
+
ƒƒ* +
$num
ƒƒ, -
]
ƒƒ- .
]
ƒƒ. /
;
ƒƒ/ 0
c
≈≈ 
=
≈≈ 
mesh
≈≈ 
[
≈≈ 
	triangles
≈≈ "
[
≈≈" #
CurTri
≈≈# )
+
≈≈* +
$num
≈≈, -
]
≈≈- .
]
≈≈. /
;
≈≈/ 0
if
«« 
(
«« 
Math
«« 
.
«« $
RayIntersectsTriangle2
«« /
(
««/ 0
o
««0 1
,
««1 2
d
««3 4
,
««4 5
a
««6 7
,
««7 8
b
««9 :
,
««: ;
c
««< =
,
««= >
ref
««? B
distance
««C K
,
««K L
ref
««M P
	hitNormal
««Q Z
)
««Z [
)
««[ \
{
»» 
hitFace
…… 
=
…… 
CurTri
…… $
/
……% &
$num
……' (
;
……( )
hitDistance
   
=
    !
distance
  " *
;
  * +
break
ÀÀ 
;
ÀÀ 
}
ÃÃ 
}
ÕÕ 
hit
œœ 
=
œœ 
new
œœ 

RaycastHit
œœ  
(
œœ  !
hitDistance
œœ! ,
,
œœ, -
InRay
–– 
.
–– 
GetPoint
–– "
(
––" #
hitDistance
––# .
)
––. /
,
––/ 0
	hitNormal
—— 
,
—— 
hitFace
““ 
)
““ 
;
““ 
return
‘‘ 
hitFace
‘‘ 
>
‘‘ 
-
‘‘ 
$num
‘‘ 
;
‘‘  
}
’’ 	
internal
ﬂﬂ 
static
ﬂﬂ 
bool
ﬂﬂ 
PointIsOccluded
ﬂﬂ ,
(
ﬂﬂ, -
Camera
ﬂﬂ- 3
cam
ﬂﬂ4 7
,
ﬂﬂ7 8
ProBuilderMesh
ﬂﬂ9 G
pb
ﬂﬂH J
,
ﬂﬂJ K
Vector3
ﬂﬂL S

worldPoint
ﬂﬂT ^
)
ﬂﬂ^ _
{
‡‡ 	
Vector3
·· 
dir
·· 
=
·· 
(
·· 
cam
·· 
.
·· 
	transform
·· (
.
··( )
position
··) 1
-
··2 3

worldPoint
··4 >
)
··> ?
.
··? @

normalized
··@ J
;
··J K
Ray
‰‰ 
ray
‰‰ 
=
‰‰ 
new
‰‰ 
Ray
‰‰ 
(
‰‰ 

worldPoint
‰‰ (
+
‰‰) *
dir
‰‰+ .
*
‰‰/ 0
$num
‰‰1 7
,
‰‰7 8
dir
‰‰9 <
)
‰‰< =
;
‰‰= >

RaycastHit
ÊÊ 
hit
ÊÊ 
;
ÊÊ 
return
ËË 
FaceRaycast
ËË 
(
ËË 
ray
ËË "
,
ËË" #
pb
ËË$ &
,
ËË& '
out
ËË( +
hit
ËË, /
,
ËË/ 0
Vector3
ËË1 8
.
ËË8 9
Distance
ËË9 A
(
ËËA B
cam
ËËB E
.
ËËE F
	transform
ËËF O
.
ËËO P
position
ËËP X
,
ËËX Y

worldPoint
ËËZ d
)
ËËd e
,
ËËe f
CullingMode
ËËg r
.
ËËr s
Front
ËËs x
)
ËËx y
;
ËËy z
}
ÈÈ 	
public
ÒÒ 
static
ÒÒ 

Quaternion
ÒÒ  
GetRotation
ÒÒ! ,
(
ÒÒ, -
ProBuilderMesh
ÒÒ- ;
mesh
ÒÒ< @
,
ÒÒ@ A
IEnumerable
ÒÒB M
<
ÒÒM N
int
ÒÒN Q
>
ÒÒQ R
indices
ÒÒS Z
)
ÒÒZ [
{
ÚÚ 	
if
ÛÛ 
(
ÛÛ 
!
ÛÛ 
mesh
ÛÛ 
.
ÛÛ 
	HasArrays
ÛÛ 
(
ÛÛ  

MeshArrays
ÛÛ  *
.
ÛÛ* +
Normal
ÛÛ+ 1
)
ÛÛ1 2
)
ÛÛ2 3
Normals
ÙÙ 
.
ÙÙ 
CalculateNormals
ÙÙ (
(
ÙÙ( )
mesh
ÙÙ) -
)
ÙÙ- .
;
ÙÙ. /
if
ˆˆ 
(
ˆˆ 
!
ˆˆ 
mesh
ˆˆ 
.
ˆˆ 
	HasArrays
ˆˆ 
(
ˆˆ  

MeshArrays
ˆˆ  *
.
ˆˆ* +
Tangent
ˆˆ+ 2
)
ˆˆ2 3
)
ˆˆ3 4
Normals
˜˜ 
.
˜˜ 
CalculateTangents
˜˜ )
(
˜˜) *
mesh
˜˜* .
)
˜˜. /
;
˜˜/ 0
var
˘˘ 
normals
˘˘ 
=
˘˘ 
mesh
˘˘ 
.
˘˘ 
normalsInternal
˘˘ .
;
˘˘. /
var
˙˙ 
tangents
˙˙ 
=
˙˙ 
mesh
˙˙ 
.
˙˙  
tangentsInternal
˙˙  0
;
˙˙0 1
var
¸¸ 
nrm
¸¸ 
=
¸¸ 
Vector3
¸¸ 
.
¸¸ 
zero
¸¸ "
;
¸¸" #
var
˝˝ 
tan
˝˝ 
=
˝˝ 
Vector4
˝˝ 
.
˝˝ 
zero
˝˝ "
;
˝˝" #
float
˛˛ 
count
˛˛ 
=
˛˛ 
$num
˛˛ 
;
˛˛ 
foreach
ÄÄ 
(
ÄÄ 
var
ÄÄ 
index
ÄÄ 
in
ÄÄ !
indices
ÄÄ" )
)
ÄÄ) *
{
ÅÅ 
var
ÇÇ 
n
ÇÇ 
=
ÇÇ 
normals
ÇÇ 
[
ÇÇ  
index
ÇÇ  %
]
ÇÇ% &
;
ÇÇ& '
var
ÉÉ 
t
ÉÉ 
=
ÉÉ 
tangents
ÉÉ  
[
ÉÉ  !
index
ÉÉ! &
]
ÉÉ& '
;
ÉÉ' (
nrm
ÖÖ 
.
ÖÖ 
x
ÖÖ 
+=
ÖÖ 
n
ÖÖ 
.
ÖÖ 
x
ÖÖ 
;
ÖÖ 
nrm
ÜÜ 
.
ÜÜ 
y
ÜÜ 
+=
ÜÜ 
n
ÜÜ 
.
ÜÜ 
y
ÜÜ 
;
ÜÜ 
nrm
áá 
.
áá 
z
áá 
+=
áá 
n
áá 
.
áá 
z
áá 
;
áá 
tan
ââ 
.
ââ 
x
ââ 
+=
ââ 
t
ââ 
.
ââ 
x
ââ 
;
ââ 
tan
ää 
.
ää 
y
ää 
+=
ää 
t
ää 
.
ää 
y
ää 
;
ää 
tan
ãã 
.
ãã 
z
ãã 
+=
ãã 
t
ãã 
.
ãã 
z
ãã 
;
ãã 
tan
åå 
.
åå 
w
åå 
+=
åå 
t
åå 
.
åå 
w
åå 
;
åå 
count
éé 
++
éé 
;
éé 
}
èè 
nrm
ëë 
.
ëë 
x
ëë 
/=
ëë 
count
ëë 
;
ëë 
nrm
íí 
.
íí 
y
íí 
/=
íí 
count
íí 
;
íí 
nrm
ìì 
.
ìì 
z
ìì 
/=
ìì 
count
ìì 
;
ìì 
tan
ïï 
.
ïï 
x
ïï 
/=
ïï 
count
ïï 
;
ïï 
tan
ññ 
.
ññ 
y
ññ 
/=
ññ 
count
ññ 
;
ññ 
tan
óó 
.
óó 
z
óó 
/=
óó 
count
óó 
;
óó 
tan
òò 
.
òò 
w
òò 
/=
òò 
count
òò 
;
òò 
if
öö 
(
öö 
nrm
öö 
==
öö 
Vector3
öö 
.
öö 
zero
öö #
||
öö$ &
tan
öö' *
==
öö+ -
Vector4
öö. 5
.
öö5 6
zero
öö6 :
)
öö: ;
return
õõ 
mesh
õõ 
.
õõ 
	transform
õõ %
.
õõ% &
rotation
õõ& .
;
õõ. /
var
ùù 
bit
ùù 
=
ùù 
Vector3
ùù 
.
ùù 
Cross
ùù #
(
ùù# $
nrm
ùù$ '
,
ùù' (
tan
ùù) ,
*
ùù- .
tan
ùù/ 2
.
ùù2 3
w
ùù3 4
)
ùù4 5
;
ùù5 6
return
üü 
mesh
üü 
.
üü 
	transform
üü !
.
üü! "
rotation
üü" *
*
üü+ ,

Quaternion
üü- 7
.
üü7 8
LookRotation
üü8 D
(
üüD E
nrm
üüE H
,
üüH I
bit
üüJ M
)
üüM N
;
üüN O
}
†† 	
public
™™ 
static
™™ 

Quaternion
™™  
GetFaceRotation
™™! 0
(
™™0 1
ProBuilderMesh
™™1 ?
mesh
™™@ D
,
™™D E
HandleOrientation
™™F W
orientation
™™X c
,
™™c d
IEnumerable
™™e p
<
™™p q
Face
™™q u
>
™™u v
faces
™™w |
)
™™| }
{
´´ 	
if
¨¨ 
(
¨¨ 
mesh
¨¨ 
==
¨¨ 
null
¨¨ 
)
¨¨ 
return
≠≠ 

Quaternion
≠≠ !
.
≠≠! "
identity
≠≠" *
;
≠≠* +
switch
ØØ 
(
ØØ 
orientation
ØØ 
)
ØØ  
{
∞∞ 
case
±± 
HandleOrientation
±± &
.
±±& '
ActiveElement
±±' 4
:
±±4 5
return
¥¥ 
GetFaceRotation
¥¥ *
(
¥¥* +
mesh
¥¥+ /
,
¥¥/ 0
faces
¥¥1 6
.
¥¥6 7
Last
¥¥7 ;
(
¥¥; <
)
¥¥< =
)
¥¥= >
;
¥¥> ?
case
∂∂ 
HandleOrientation
∂∂ &
.
∂∂& '
ActiveObject
∂∂' 3
:
∂∂3 4
return
∑∑ 
mesh
∑∑ 
.
∑∑  
	transform
∑∑  )
.
∑∑) *
rotation
∑∑* 2
;
∑∑2 3
default
ππ 
:
ππ 
return
∫∫ 

Quaternion
∫∫ %
.
∫∫% &
identity
∫∫& .
;
∫∫. /
}
ªª 
}
ºº 	
public
ƒƒ 
static
ƒƒ 

Quaternion
ƒƒ  
GetFaceRotation
ƒƒ! 0
(
ƒƒ0 1
ProBuilderMesh
ƒƒ1 ?
mesh
ƒƒ@ D
,
ƒƒD E
Face
ƒƒF J
face
ƒƒK O
)
ƒƒO P
{
≈≈ 	
if
∆∆ 
(
∆∆ 
mesh
∆∆ 
==
∆∆ 
null
∆∆ 
)
∆∆ 
return
«« 

Quaternion
«« !
.
««! "
identity
««" *
;
««* +
if
…… 
(
…… 
face
…… 
==
…… 
null
…… 
)
…… 
return
   
mesh
   
.
   
	transform
   %
.
  % &
rotation
  & .
;
  . /
Normal
ŒŒ 
nrm
ŒŒ 
=
ŒŒ 
Math
ŒŒ 
.
ŒŒ $
NormalTangentBitangent
ŒŒ 4
(
ŒŒ4 5
mesh
ŒŒ5 9
,
ŒŒ9 :
face
ŒŒ; ?
)
ŒŒ? @
;
ŒŒ@ A
if
–– 
(
–– 
nrm
–– 
.
–– 
normal
–– 
==
–– 
Vector3
–– %
.
––% &
zero
––& *
||
––+ -
nrm
––. 1
.
––1 2
	bitangent
––2 ;
==
––< >
Vector3
––? F
.
––F G
zero
––G K
)
––K L
return
—— 
mesh
—— 
.
—— 
	transform
—— %
.
——% &
rotation
——& .
;
——. /
return
”” 
mesh
”” 
.
”” 
	transform
”” !
.
””! "
rotation
””" *
*
””+ ,

Quaternion
””- 7
.
””7 8
LookRotation
””8 D
(
””D E
nrm
””E H
.
””H I
normal
””I O
,
””O P
nrm
””Q T
.
””T U
	bitangent
””U ^
)
””^ _
;
””_ `
}
‘‘ 	
public
ﬁﬁ 
static
ﬁﬁ 

Quaternion
ﬁﬁ  
GetEdgeRotation
ﬁﬁ! 0
(
ﬁﬁ0 1
ProBuilderMesh
ﬁﬁ1 ?
mesh
ﬁﬁ@ D
,
ﬁﬁD E
HandleOrientation
ﬁﬁF W
orientation
ﬁﬁX c
,
ﬁﬁc d
IEnumerable
ﬁﬁe p
<
ﬁﬁp q
Edge
ﬁﬁq u
>
ﬁﬁu v
edges
ﬁﬁw |
)
ﬁﬁ| }
{
ﬂﬂ 	
if
‡‡ 
(
‡‡ 
mesh
‡‡ 
==
‡‡ 
null
‡‡ 
)
‡‡ 
return
·· 

Quaternion
·· !
.
··! "
identity
··" *
;
··* +
switch
„„ 
(
„„ 
orientation
„„ 
)
„„  
{
‰‰ 
case
ÂÂ 
HandleOrientation
ÂÂ &
.
ÂÂ& '
ActiveElement
ÂÂ' 4
:
ÂÂ4 5
return
ÍÍ 
GetEdgeRotation
ÍÍ *
(
ÍÍ* +
mesh
ÍÍ+ /
,
ÍÍ/ 0
edges
ÍÍ1 6
.
ÍÍ6 7
Last
ÍÍ7 ;
(
ÍÍ; <
)
ÍÍ< =
)
ÍÍ= >
;
ÍÍ> ?
case
ÏÏ 
HandleOrientation
ÏÏ &
.
ÏÏ& '
ActiveObject
ÏÏ' 3
:
ÏÏ3 4
return
ÌÌ 
mesh
ÌÌ 
.
ÌÌ  
	transform
ÌÌ  )
.
ÌÌ) *
rotation
ÌÌ* 2
;
ÌÌ2 3
default
ÔÔ 
:
ÔÔ 
return
 

Quaternion
 %
.
% &
identity
& .
;
. /
}
ÒÒ 
}
ÚÚ 	
public
˙˙ 
static
˙˙ 

Quaternion
˙˙  
GetEdgeRotation
˙˙! 0
(
˙˙0 1
ProBuilderMesh
˙˙1 ?
mesh
˙˙@ D
,
˙˙D E
Edge
˙˙F J
edge
˙˙K O
)
˙˙O P
{
˚˚ 	
if
¸¸ 
(
¸¸ 
mesh
¸¸ 
==
¸¸ 
null
¸¸ 
)
¸¸ 
return
˝˝ 

Quaternion
˝˝ !
.
˝˝! "
identity
˝˝" *
;
˝˝* +
return
ˇˇ 
GetFaceRotation
ˇˇ "
(
ˇˇ" #
mesh
ˇˇ# '
,
ˇˇ' (
EdgeUtility
ˇˇ) 4
.
ˇˇ4 5
GetFace
ˇˇ5 <
(
ˇˇ< =
mesh
ˇˇ= A
,
ˇˇA B
edge
ˇˇC G
)
ˇˇG H
)
ˇˇH I
;
ˇˇI J
}
ÄÄ 	
public
ää 
static
ää 

Quaternion
ää  
GetVertexRotation
ää! 2
(
ää2 3
ProBuilderMesh
ää3 A
mesh
ääB F
,
ääF G
HandleOrientation
ääH Y
orientation
ääZ e
,
ääe f
IEnumerable
ääg r
<
äär s
int
ääs v
>
ääv w
verticesääx Ä
)ääÄ Å
{
ãã 	
if
åå 
(
åå 
mesh
åå 
==
åå 
null
åå 
)
åå 
return
çç 

Quaternion
çç !
.
çç! "
identity
çç" *
;
çç* +
switch
èè 
(
èè 
orientation
èè 
)
èè  
{
êê 
case
ëë 
HandleOrientation
ëë &
.
ëë& '
ActiveElement
ëë' 4
:
ëë4 5
if
íí 
(
íí 
mesh
íí 
.
íí !
selectedVertexCount
íí 0
<
íí1 2
$num
íí3 4
)
íí4 5
goto
ìì 
case
ìì !
HandleOrientation
ìì" 3
.
ìì3 4
ActiveObject
ìì4 @
;
ìì@ A
return
îî 
GetRotation
îî &
(
îî& '
mesh
îî' +
,
îî+ ,
vertices
îî- 5
)
îî5 6
;
îî6 7
case
ññ 
HandleOrientation
ññ &
.
ññ& '
ActiveObject
ññ' 3
:
ññ3 4
return
óó 
mesh
óó 
.
óó  
	transform
óó  )
.
óó) *
rotation
óó* 2
;
óó2 3
default
ôô 
:
ôô 
return
öö 

Quaternion
öö %
.
öö% &
identity
öö& .
;
öö. /
}
õõ 
}
úú 	
public
§§ 
static
§§ 

Quaternion
§§  
GetVertexRotation
§§! 2
(
§§2 3
ProBuilderMesh
§§3 A
mesh
§§B F
,
§§F G
int
§§H K
vertex
§§L R
)
§§R S
{
•• 	
if
¶¶ 
(
¶¶ 
mesh
¶¶ 
==
¶¶ 
null
¶¶ 
)
¶¶ 
return
ßß 

Quaternion
ßß !
.
ßß! "
identity
ßß" *
;
ßß* +
if
©© 
(
©© 
vertex
©© 
<
©© 
$num
©© 
)
©© 
return
™™ 
mesh
™™ 
.
™™ 
	transform
™™ %
.
™™% &
rotation
™™& .
;
™™. /
return
¨¨ 
GetRotation
¨¨ 
(
¨¨ 
mesh
¨¨ #
,
¨¨# $
new
¨¨% (
int
¨¨) ,
[
¨¨, -
]
¨¨- .
{
¨¨/ 0
vertex
¨¨1 7
}
¨¨8 9
)
¨¨9 :
;
¨¨: ;
}
≠≠ 	
internal
ØØ 
static
ØØ 
Vector3
ØØ &
GetActiveElementPosition
ØØ  8
(
ØØ8 9
ProBuilderMesh
ØØ9 G
mesh
ØØH L
,
ØØL M
IEnumerable
ØØN Y
<
ØØY Z
Face
ØØZ ^
>
ØØ^ _
faces
ØØ` e
)
ØØe f
{
∞∞ 	
return
±± 
mesh
±± 
.
±± 
	transform
±± !
.
±±! "
TransformPoint
±±" 0
(
±±0 1
Math
±±1 5
.
±±5 6
	GetBounds
±±6 ?
(
±±? @
mesh
±±@ D
.
±±D E
positionsInternal
±±E V
,
±±V W
faces
±±X ]
.
±±] ^
Last
±±^ b
(
±±b c
)
±±c d
.
±±d e%
distinctIndexesInternal
±±e |
)
±±| }
.
±±} ~
center±±~ Ñ
)±±Ñ Ö
;±±Ö Ü
}
≤≤ 	
internal
¥¥ 
static
¥¥ 
Vector3
¥¥ &
GetActiveElementPosition
¥¥  8
(
¥¥8 9
ProBuilderMesh
¥¥9 G
mesh
¥¥H L
,
¥¥L M
IEnumerable
¥¥N Y
<
¥¥Y Z
Edge
¥¥Z ^
>
¥¥^ _
edges
¥¥` e
)
¥¥e f
{
µµ 	
var
∂∂ 
edge
∂∂ 
=
∂∂ 
edges
∂∂ 
.
∂∂ 
Last
∂∂ !
(
∂∂! "
)
∂∂" #
;
∂∂# $
return
∑∑ 
mesh
∑∑ 
.
∑∑ 
	transform
∑∑ !
.
∑∑! "
TransformPoint
∑∑" 0
(
∑∑0 1
Math
∑∑1 5
.
∑∑5 6
	GetBounds
∑∑6 ?
(
∑∑? @
mesh
∑∑@ D
.
∑∑D E
positionsInternal
∑∑E V
,
∑∑V W
new
∑∑X [
int
∑∑\ _
[
∑∑_ `
]
∑∑` a
{
∑∑b c
edge
∑∑d h
.
∑∑h i
a
∑∑i j
,
∑∑j k
edge
∑∑l p
.
∑∑p q
b
∑∑q r
}
∑∑s t
)
∑∑t u
.
∑∑u v
center
∑∑v |
)
∑∑| }
;
∑∑} ~
}
∏∏ 	
internal
∫∫ 
static
∫∫ 
Vector3
∫∫ &
GetActiveElementPosition
∫∫  8
(
∫∫8 9
ProBuilderMesh
∫∫9 G
mesh
∫∫H L
,
∫∫L M
IEnumerable
∫∫N Y
<
∫∫Y Z
int
∫∫Z ]
>
∫∫] ^
vertices
∫∫_ g
)
∫∫g h
{
ªª 	
return
ºº 
mesh
ºº 
.
ºº 
	transform
ºº !
.
ºº! "
TransformPoint
ºº" 0
(
ºº0 1
mesh
ºº1 5
.
ºº5 6
positionsInternal
ºº6 G
[
ººG H
vertices
ººH P
.
ººP Q
First
ººQ V
(
ººV W
)
ººW X
]
ººX Y
)
ººY Z
;
ººZ [
}
ΩΩ 	
}
ææ 
}øø Ùu
äD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Smoothing.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

static 
class 
	Smoothing !
{ 
internal 
const 
int 
smoothingGroupNone -
=. /
$num0 1
;1 2
internal 
const 
int 
smoothRangeMin )
=* +
$num, -
;- .
internal 
const 
int 
smoothRangeMax )
=* +
$num, .
;. /
internal!! 
const!! 
int!! 
hardRangeMin!! '
=!!( )
$num!!* ,
;!!, -
internal&& 
const&& 
int&& 
hardRangeMax&& '
=&&( )
$num&&* ,
;&&, -
public-- 
static-- 
int-- #
GetUnusedSmoothingGroup-- 1
(--1 2
ProBuilderMesh--2 @
mesh--A E
)--E F
{.. 	
if// 
(// 
mesh// 
==// 
null// 
)// 
throw00 
new00 
System00  
.00  !!
ArgumentNullException00! 6
(006 7
$str007 =
)00= >
;00> ?
return22 '
GetNextUnusedSmoothingGroup22 .
(22. /
smoothRangeMin22/ =
,22= >
new22? B
HashSet22C J
<22J K
int22K N
>22N O
(22O P
mesh22P T
.22T U
facesInternal22U b
.22b c
Select22c i
(22i j
x22j k
=>22l n
x22o p
.22p q
smoothingGroup22q 
)	22 Ä
)
22Ä Å
)
22Å Ç
;
22Ç É
}33 	
static;; 
int;; '
GetNextUnusedSmoothingGroup;; .
(;;. /
int;;/ 2
start;;3 8
,;;8 9
HashSet;;: A
<;;A B
int;;B E
>;;E F
used;;G K
);;K L
{<< 	
while== 
(== 
used== 
.== 
Contains==  
(==  !
start==! &
)==& '
&&==( *
start==+ 0
<==1 2
int==3 6
.==6 7
MaxValue==7 ?
-==@ A
$num==B C
)==C D
{>> 
start?? 
++?? 
;?? 
ifAA 
(AA 
startAA 
>AA 
smoothRangeMaxAA *
&&AA+ -
startAA. 3
<AA4 5
hardRangeMaxAA6 B
)AAB C
startBB 
=BB 
hardRangeMaxBB (
+BB) *
$numBB+ ,
;BB, -
}CC 
returnEE 
startEE 
;EE 
}FF 	
publicMM 
staticMM 
boolMM 
IsSmoothMM #
(MM# $
intMM$ '
indexMM( -
)MM- .
{NN 	
returnOO 
(OO 
indexOO 
>OO 
smoothingGroupNoneOO .
&&OO/ 1
(OO2 3
indexOO3 8
<OO9 :
hardRangeMinOO; G
||OOH J
indexOOK P
>OOQ R
hardRangeMaxOOS _
)OO_ `
)OO` a
;OOa b
}PP 	
publicXX 
staticXX 
voidXX  
ApplySmoothingGroupsXX /
(XX/ 0
ProBuilderMeshXX0 >
meshXX? C
,XXC D
IEnumerableXXE P
<XXP Q
FaceXXQ U
>XXU V
facesXXW \
,XX\ ]
floatXX^ c
angleThresholdXXd r
)XXr s
{YY 	 
ApplySmoothingGroupsZZ  
(ZZ  !
meshZZ! %
,ZZ% &
facesZZ' ,
,ZZ, -
angleThresholdZZ. <
,ZZ< =
nullZZ> B
)ZZB C
;ZZC D
}[[ 	
internal]] 
static]] 
void]]  
ApplySmoothingGroups]] 1
(]]1 2
ProBuilderMesh]]2 @
mesh]]A E
,]]E F
IEnumerable]]G R
<]]R S
Face]]S W
>]]W X
faces]]Y ^
,]]^ _
float]]` e
angleThreshold]]f t
,]]t u
Vector3]]v }
[]]} ~
]]]~ 
normals
]]Ä á
)
]]á à
{^^ 	
if__ 
(__ 
mesh__ 
==__ 
null__ 
||__ 
faces__  %
==__& (
null__) -
)__- .
throw`` 
new`` 
System``  
.``  !!
ArgumentNullException``! 6
(``6 7
$str``7 =
)``= >
;``> ?
boolcc 
anySmoothedcc 
=cc 
falsecc $
;cc$ %
foreachee 
(ee 
Faceee 
faceee 
inee !
facesee" '
)ee' (
{ff 
ifgg 
(gg 
facegg 
.gg 
smoothingGroupgg '
!=gg( *
smoothingGroupNonegg+ =
)gg= >
anySmoothedhh 
=hh  !
truehh" &
;hh& '
facejj 
.jj 
smoothingGroupjj #
=jj$ %
	Smoothingjj& /
.jj/ 0
smoothingGroupNonejj0 B
;jjB C
}kk 
ifoo 
(oo 
normalsoo 
==oo 
nulloo 
)oo  
{pp 
ifqq 
(qq 
anySmoothedqq 
)qq  
meshrr 
.rr 
meshrr 
.rr 
normalsrr %
=rr& '
nullrr( ,
;rr, -
normalsss 
=ss 
meshss 
.ss 

GetNormalsss )
(ss) *
)ss* +
;ss+ ,
}tt 
floatvv 
	thresholdvv 
=vv 
Mathfvv #
.vv# $
Absvv$ '
(vv' (
Mathfvv( -
.vv- .
Cosvv. 1
(vv1 2
Mathfvv2 7
.vv7 8
Clampvv8 =
(vv= >
angleThresholdvv> L
,vvL M
$numvvN P
,vvP Q
$numvvR Y
)vvY Z
*vv[ \
Mathfvv] b
.vvb c
Deg2Radvvc j
)vvj k
)vvk l
;vvl m
HashSetww 
<ww 
intww 
>ww 
usedww 
=ww 
newww  #
HashSetww$ +
<ww+ ,
intww, /
>ww/ 0
(ww0 1
meshww1 5
.ww5 6
facesInternalww6 C
.wwC D
SelectwwD J
(wwJ K
xwwK L
=>wwM O
xwwP Q
.wwQ R
smoothingGroupwwR `
)ww` a
)wwa b
;wwb c
intxx 
groupxx 
=xx '
GetNextUnusedSmoothingGroupxx 3
(xx3 4
$numxx4 5
,xx5 6
usedxx7 ;
)xx; <
;xx< =
HashSetyy 
<yy 
Faceyy 
>yy 
	processedyy #
=yy$ %
newyy& )
HashSetyy* 1
<yy1 2
Faceyy2 6
>yy6 7
(yy7 8
)yy8 9
;yy9 :
Listzz 
<zz 

WingedEdgezz 
>zz 
wingszz "
=zz# $

WingedEdgezz% /
.zz/ 0
GetWingedEdgeszz0 >
(zz> ?
meshzz? C
,zzC D
faceszzE J
,zzJ K
truezzL P
)zzP Q
;zzQ R
foreach|| 
(|| 

WingedEdge|| 
wing||  $
in||% '
wings||( -
)||- .
{}} 
if 
( 
! 
	processed 
. 
Add "
(" #
wing# '
.' (
face( ,
), -
)- .
continue
ÄÄ 
;
ÄÄ 
wing
ÇÇ 
.
ÇÇ 
face
ÇÇ 
.
ÇÇ 
smoothingGroup
ÇÇ (
=
ÇÇ) *
group
ÇÇ+ 0
;
ÇÇ0 1
if
ÑÑ 
(
ÑÑ $
FindSoftEdgesRecursive
ÑÑ *
(
ÑÑ* +
normals
ÑÑ+ 2
,
ÑÑ2 3
wing
ÑÑ4 8
,
ÑÑ8 9
	threshold
ÑÑ: C
,
ÑÑC D
	processed
ÑÑE N
)
ÑÑN O
)
ÑÑO P
{
ÖÖ 
used
ÜÜ 
.
ÜÜ 
Add
ÜÜ 
(
ÜÜ 
group
ÜÜ "
)
ÜÜ" #
;
ÜÜ# $
group
áá 
=
áá )
GetNextUnusedSmoothingGroup
áá 7
(
áá7 8
group
áá8 =
,
áá= >
used
áá? C
)
ááC D
;
ááD E
}
àà 
else
ââ 
{
ää 
wing
ãã 
.
ãã 
face
ãã 
.
ãã 
smoothingGroup
ãã ,
=
ãã- .
	Smoothing
ãã/ 8
.
ãã8 9 
smoothingGroupNone
ãã9 K
;
ããK L
}
åå 
}
çç 
}
éé 	
static
ëë 
bool
ëë $
FindSoftEdgesRecursive
ëë *
(
ëë* +
Vector3
ëë+ 2
[
ëë2 3
]
ëë3 4
normals
ëë5 <
,
ëë< =

WingedEdge
ëë> H
wing
ëëI M
,
ëëM N
float
ëëO T
angleThreshold
ëëU c
,
ëëc d
HashSet
ëëe l
<
ëël m
Face
ëëm q
>
ëëq r
	processed
ëës |
)
ëë| }
{
íí 	
bool
ìì 
foundSmoothEdge
ìì  
=
ìì! "
false
ìì# (
;
ìì( )
using
ïï 
(
ïï 
var
ïï 
it
ïï 
=
ïï 
new
ïï "
WingedEdgeEnumerator
ïï  4
(
ïï4 5
wing
ïï5 9
)
ïï9 :
)
ïï: ;
{
ññ 
while
óó 
(
óó 
it
óó 
.
óó 
MoveNext
óó "
(
óó" #
)
óó# $
)
óó$ %
{
òò 
var
ôô 
border
ôô 
=
ôô  
it
ôô! #
.
ôô# $
Current
ôô$ +
;
ôô+ ,
if
õõ 
(
õõ 
border
õõ 
.
õõ 
opposite
õõ '
==
õõ( *
null
õõ+ /
)
õõ/ 0
continue
úú  
;
úú  !
if
ûû 
(
ûû 
border
ûû 
.
ûû 
opposite
ûû '
.
ûû' (
face
ûû( ,
.
ûû, -
smoothingGroup
ûû- ;
==
ûû< >
	Smoothing
ûû? H
.
ûûH I 
smoothingGroupNone
ûûI [
&&
üü 

IsSoftEdge
üü %
(
üü% &
normals
üü& -
,
üü- .
border
üü/ 5
.
üü5 6
edge
üü6 :
,
üü: ;
border
üü< B
.
üüB C
opposite
üüC K
.
üüK L
edge
üüL P
,
üüP Q
angleThreshold
üüR `
)
üü` a
)
üüa b
{
†† 
if
°° 
(
°° 
	processed
°° %
.
°°% &
Add
°°& )
(
°°) *
border
°°* 0
.
°°0 1
opposite
°°1 9
.
°°9 :
face
°°: >
)
°°> ?
)
°°? @
{
¢¢ 
foundSmoothEdge
££ +
=
££, -
true
££. 2
;
££2 3
border
§§ "
.
§§" #
opposite
§§# +
.
§§+ ,
face
§§, 0
.
§§0 1
smoothingGroup
§§1 ?
=
§§@ A
wing
§§B F
.
§§F G
face
§§G K
.
§§K L
smoothingGroup
§§L Z
;
§§Z [$
FindSoftEdgesRecursive
•• 2
(
••2 3
normals
••3 :
,
••: ;
border
••< B
.
••B C
opposite
••C K
,
••K L
angleThreshold
••M [
,
••[ \
	processed
••] f
)
••f g
;
••g h
}
¶¶ 
}
ßß 
}
®® 
}
©© 
return
´´ 
foundSmoothEdge
´´ "
;
´´" #
}
¨¨ 	
static
ÆÆ 
bool
ÆÆ 

IsSoftEdge
ÆÆ 
(
ÆÆ 
Vector3
ÆÆ &
[
ÆÆ& '
]
ÆÆ' (
normals
ÆÆ) 0
,
ÆÆ0 1

EdgeLookup
ÆÆ2 <
left
ÆÆ= A
,
ÆÆA B

EdgeLookup
ÆÆC M
right
ÆÆN S
,
ÆÆS T
float
ÆÆU Z
	threshold
ÆÆ[ d
)
ÆÆd e
{
ØØ 	
Vector3
∞∞ 
lx
∞∞ 
=
∞∞ 
normals
∞∞  
[
∞∞  !
left
∞∞! %
.
∞∞% &
local
∞∞& +
.
∞∞+ ,
a
∞∞, -
]
∞∞- .
;
∞∞. /
Vector3
±± 
ly
±± 
=
±± 
normals
±±  
[
±±  !
left
±±! %
.
±±% &
local
±±& +
.
±±+ ,
b
±±, -
]
±±- .
;
±±. /
Vector3
≤≤ 
rx
≤≤ 
=
≤≤ 
normals
≤≤  
[
≤≤  !
right
≤≤! &
.
≤≤& '
common
≤≤' -
.
≤≤- .
a
≤≤. /
==
≤≤0 2
left
≤≤3 7
.
≤≤7 8
common
≤≤8 >
.
≤≤> ?
a
≤≤? @
?
≤≤A B
right
≤≤C H
.
≤≤H I
local
≤≤I N
.
≤≤N O
a
≤≤O P
:
≤≤Q R
right
≤≤S X
.
≤≤X Y
local
≤≤Y ^
.
≤≤^ _
b
≤≤_ `
]
≤≤` a
;
≤≤a b
Vector3
≥≥ 
ry
≥≥ 
=
≥≥ 
normals
≥≥  
[
≥≥  !
right
≥≥! &
.
≥≥& '
common
≥≥' -
.
≥≥- .
b
≥≥. /
==
≥≥0 2
left
≥≥3 7
.
≥≥7 8
common
≥≥8 >
.
≥≥> ?
b
≥≥? @
?
≥≥A B
right
≥≥C H
.
≥≥H I
local
≥≥I N
.
≥≥N O
b
≥≥O P
:
≥≥Q R
right
≥≥S X
.
≥≥X Y
local
≥≥Y ^
.
≥≥^ _
a
≥≥_ `
]
≥≥` a
;
≥≥a b
lx
¥¥ 
.
¥¥ 
	Normalize
¥¥ 
(
¥¥ 
)
¥¥ 
;
¥¥ 
ly
µµ 
.
µµ 
	Normalize
µµ 
(
µµ 
)
µµ 
;
µµ 
rx
∂∂ 
.
∂∂ 
	Normalize
∂∂ 
(
∂∂ 
)
∂∂ 
;
∂∂ 
ry
∑∑ 
.
∑∑ 
	Normalize
∑∑ 
(
∑∑ 
)
∑∑ 
;
∑∑ 
return
∏∏ 
Mathf
∏∏ 
.
∏∏ 
Abs
∏∏ 
(
∏∏ 
Vector3
∏∏ $
.
∏∏$ %
Dot
∏∏% (
(
∏∏( )
lx
∏∏) +
,
∏∏+ ,
rx
∏∏- /
)
∏∏/ 0
)
∏∏0 1
>
∏∏2 3
	threshold
∏∏4 =
&&
∏∏> @
Mathf
∏∏A F
.
∏∏F G
Abs
∏∏G J
(
∏∏J K
Vector3
∏∏K R
.
∏∏R S
Dot
∏∏S V
(
∏∏V W
ly
∏∏W Y
,
∏∏Y Z
ry
∏∏[ ]
)
∏∏] ^
)
∏∏^ _
>
∏∏` a
	threshold
∏∏b k
;
∏∏k l
}
ππ 	
}
∫∫ 
}ªª Ë?
âD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Clipping.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
Clipping 
{ 
[ 	
System	 
. 
Flags 
] 
enum 
OutCode 
{ 	
Inside 
= 
$num 
, 
Left 
= 
$num 
, 
Right 
= 
$num 
, 
Bottom 
= 
$num 
, 
Top 
= 
$num 
, 
} 	
static 
OutCode 
ComputeOutCode %
(% &
Rect& *
rect+ /
,/ 0
float1 6
x7 8
,8 9
float: ?
y@ A
)A B
{ 	
OutCode 
code 
= 
OutCode "
." #
Inside# )
;) *
if   
(   
x   
<   
rect   
.   
xMin   
)   
code!! 
|=!! 
OutCode!! 
.!!  
Left!!  $
;!!$ %
else"" 
if"" 
("" 
x"" 
>"" 
rect"" 
."" 
xMax"" "
)""" #
code## 
|=## 
OutCode## 
.##  
Right##  %
;##% &
if$$ 
($$ 
y$$ 
<$$ 
rect$$ 
.$$ 
yMin$$ 
)$$ 
code%% 
|=%% 
OutCode%% 
.%%  
Bottom%%  &
;%%& '
else&& 
if&& 
(&& 
y&& 
>&& 
rect&& 
.&& 
yMax&& "
)&&" #
code'' 
|='' 
OutCode'' 
.''  
Top''  #
;''# $
return)) 
code)) 
;)) 
}** 	
internal// 
static// 
bool// #
RectContainsLineSegment// 4
(//4 5
Rect//5 9
rect//: >
,//> ?
float//@ E
x0//F H
,//H I
float//J O
y0//P R
,//R S
float//T Y
x1//Z \
,//\ ]
float//^ c
y1//d f
)//f g
{00 	
OutCode22 
outcode022 
=22 
ComputeOutCode22 -
(22- .
rect22. 2
,222 3
x0224 6
,226 7
y0228 :
)22: ;
;22; <
OutCode33 
outcode133 
=33 
ComputeOutCode33 -
(33- .
rect33. 2
,332 3
x1334 6
,336 7
y1338 :
)33: ;
;33; <
bool55 
accept55 
=55 
false55 
;55  
while77 
(77 
true77 
)77 
{88 
if99 
(99 
(99 
outcode099 
|99 
outcode199  (
)99( )
==99* ,
OutCode99- 4
.994 5
Inside995 ;
)99; <
{:: 
accept<< 
=<< 
true<< !
;<<! "
break== 
;== 
}>> 
else?? 
if?? 
(?? 
(?? 
outcode0?? "
&??# $
outcode1??% -
)??- .
!=??/ 1
OutCode??2 9
.??9 :
Inside??: @
)??@ A
{@@ 
breakCC 
;CC 
}DD 
elseEE 
{FF 
floatII 
xII 
=II 
$numII  
,II  !
yII" #
=II$ %
$numII& (
;II( )
OutCodeLL 

outcodeOutLL &
=LL' (
outcode0LL) 1
!=LL2 4
OutCodeLL5 <
.LL< =
InsideLL= C
?LLD E
outcode0LLF N
:LLO P
outcode1LLQ Y
;LLY Z
ifUU 
(UU 
(UU 

outcodeOutUU #
&UU$ %
OutCodeUU& -
.UU- .
TopUU. 1
)UU1 2
==UU3 5
OutCodeUU6 =
.UU= >
TopUU> A
)UUA B
{VV 
xXX 
=XX 
x0XX 
+XX  
(XX! "
x1XX" $
-XX% &
x0XX' )
)XX) *
*XX+ ,
(XX- .
rectXX. 2
.XX2 3
yMaxXX3 7
-XX8 9
y0XX: <
)XX< =
/XX> ?
(XX@ A
y1XXA C
-XXD E
y0XXF H
)XXH I
;XXI J
yYY 
=YY 
rectYY  
.YY  !
yMaxYY! %
;YY% &
}ZZ 
else[[ 
if[[ 
([[ 
([[ 

outcodeOut[[ (
&[[) *
OutCode[[+ 2
.[[2 3
Bottom[[3 9
)[[9 :
==[[; =
OutCode[[> E
.[[E F
Bottom[[F L
)[[L M
{\\ 
x^^ 
=^^ 
x0^^ 
+^^  
(^^! "
x1^^" $
-^^% &
x0^^' )
)^^) *
*^^+ ,
(^^- .
rect^^. 2
.^^2 3
yMin^^3 7
-^^8 9
y0^^: <
)^^< =
/^^> ?
(^^@ A
y1^^A C
-^^D E
y0^^F H
)^^H I
;^^I J
y__ 
=__ 
rect__  
.__  !
yMin__! %
;__% &
}`` 
elseaa 
ifaa 
(aa 
(aa 

outcodeOutaa (
&aa) *
OutCodeaa+ 2
.aa2 3
Rightaa3 8
)aa8 9
==aa: <
OutCodeaa= D
.aaD E
RightaaE J
)aaJ K
{bb 
ydd 
=dd 
y0dd 
+dd  
(dd! "
y1dd" $
-dd% &
y0dd' )
)dd) *
*dd+ ,
(dd- .
rectdd. 2
.dd2 3
xMaxdd3 7
-dd8 9
x0dd: <
)dd< =
/dd> ?
(dd@ A
x1ddA C
-ddD E
x0ddF H
)ddH I
;ddI J
xee 
=ee 
rectee  
.ee  !
xMaxee! %
;ee% &
}ff 
elsegg 
ifgg 
(gg 
(gg 

outcodeOutgg (
&gg) *
OutCodegg+ 2
.gg2 3
Leftgg3 7
)gg7 8
==gg9 ;
OutCodegg< C
.ggC D
LeftggD H
)ggH I
{hh 
yjj 
=jj 
y0jj 
+jj  
(jj! "
y1jj" $
-jj% &
y0jj' )
)jj) *
*jj+ ,
(jj- .
rectjj. 2
.jj2 3
xMinjj3 7
-jj8 9
x0jj: <
)jj< =
/jj> ?
(jj@ A
x1jjA C
-jjD E
x0jjF H
)jjH I
;jjI J
xkk 
=kk 
rectkk  
.kk  !
xMinkk! %
;kk% &
}ll 
ifpp 
(pp 

outcodeOutpp "
==pp# %
outcode0pp& .
)pp. /
{qq 
x0rr 
=rr 
xrr 
;rr 
y0ss 
=ss 
yss 
;ss 
outcode0tt  
=tt! "
ComputeOutCodett# 1
(tt1 2
recttt2 6
,tt6 7
x0tt8 :
,tt: ;
y0tt< >
)tt> ?
;tt? @
}uu 
elsevv 
{ww 
x1xx 
=xx 
xxx 
;xx 
y1yy 
=yy 
yyy 
;yy 
outcode1zz  
=zz! "
ComputeOutCodezz# 1
(zz1 2
rectzz2 6
,zz6 7
x1zz8 :
,zz: ;
y1zz< >
)zz> ?
;zz? @
}{{ 
}|| 
}}} 
return 
accept 
; 
}
ÄÄ 	
}
ÅÅ 
}ÇÇ ‘
ãD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\PivotPoint.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

enum 

PivotPoint 
{ 
Center		 
,		 
IndividualOrigins 
, 
ActiveElement 
, 
} 
} ‚Ω
áD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Spline.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
Spline 
{ 
internal 
static 
ProBuilderMesh &
Extrude' .
(. /
IList/ 4
<4 5
BezierPoint5 @
>@ A
pointsB H
,H I
float 
radius 
= 
$num 
, 
int 
columns 
= 
$num 
, 
int 
rows 
= 
$num 
, 
bool 
	closeLoop 
= 
false "
," #
bool 
smooth 
= 
true 
) 
{ 	
ProBuilderMesh 
pb 
= 
null  $
;$ %
Extrude 
( 
points 
, 
radius "
," #
columns$ +
,+ ,
rows- 1
,1 2
	closeLoop3 <
,< =
smooth> D
,D E
refF I
pbJ L
)L M
;M N
return 
pb 
; 
} 	
internal   
static   
void   
Extrude   $
(  $ %
IList  % *
<  * +
BezierPoint  + 6
>  6 7
bezierPoints  8 D
,  D E
float!! 
radius!! 
,!! 
int"" 
columns"" 
,"" 
int## 
rows## 
,## 
bool$$ 
	closeLoop$$ 
,$$ 
bool%% 
smooth%% 
,%% 
ref&& 
ProBuilderMesh&& 
target&& %
)&&% &
{'' 	
List(( 
<(( 

Quaternion(( 
>(( 
	rotations(( &
=((' (
new(() ,
List((- 1
<((1 2

Quaternion((2 <
>((< =
(((= >
)((> ?
;((? @
List)) 
<)) 
Vector3)) 
>)) 
	positions)) #
=))$ %
GetControlPoints))& 6
())6 7
bezierPoints))7 C
,))C D
columns))E L
,))L M
	closeLoop))N W
,))W X
	rotations))Y b
)))b c
;))c d
Extrude** 
(** 
	positions** 
,** 
radius** %
,**% &
rows**' +
,**+ ,
	closeLoop**- 6
,**6 7
smooth**8 >
,**> ?
ref**@ C
target**D J
,**J K
	rotations**L U
)**U V
;**V W
}++ 	
internal.. 
static.. 
List.. 
<.. 
Vector3.. $
>..$ %
GetControlPoints..& 6
(..6 7
IList..7 <
<..< =
BezierPoint..= H
>..H I
bezierPoints..J V
,..V W
int..X ["
subdivisionsPerSegment..\ r
,..r s
bool..t x
	closeLoop	..y Ç
,
..Ç É
List
..Ñ à
<
..à â

Quaternion
..â ì
>
..ì î
	rotations
..ï û
)
..û ü
{// 	
int00 
cols00 
=00 "
subdivisionsPerSegment00 -
;00- .
int11 
c11 
=11 
bezierPoints11  
.11  !
Count11! &
;11& '
List22 
<22 
Vector322 
>22 
	positions22 #
=22$ %
new22& )
List22* .
<22. /
Vector322/ 6
>226 7
(227 8
cols228 <
*22= >
c22? @
)22@ A
;22A B
if44 
(44 
	rotations44 
!=44 
null44 !
)44! "
{55 
	rotations66 
.66 
Clear66 
(66  
)66  !
;66! "
	rotations77 
.77 
Capacity77 "
=77# $
cols77% )
*77* +
c77, -
;77- .
}88 
int:: 
	keyframes:: 
=:: 
(:: 
	closeLoop:: &
?::' (
c::) *
:::+ ,
c::- .
-::/ 0
$num::1 2
)::2 3
;::3 4
for<< 
(<< 
int<< 
i<< 
=<< 
$num<< 
;<< 
i<< 
<<< 
	keyframes<<  )
;<<) *
i<<+ ,
++<<, .
)<<. /
{== 
int>> !
segments_per_keyframe>> )
=>>* +
(>>, -
(>>- .
!>>. /
	closeLoop>>/ 8
&&>>9 ;
i>>< =
>=>>> @
c>>A B
->>C D
$num>>E F
)>>F G
?>>H I
cols>>J N
+>>O P
$num>>Q R
:>>S T
cols>>U Y
)>>Y Z
;>>Z [
for@@ 
(@@ 
int@@ 
n@@ 
=@@ 
$num@@ 
;@@ 
n@@  !
<@@" #!
segments_per_keyframe@@$ 9
;@@9 :
n@@; <
++@@< >
)@@> ?
{AA 
floatBB 
sBB 
=BB 
colsBB "
;BB" #
	positionsDD 
.DD 
AddDD !
(DD! "
BezierPointDD" -
.DD- .
CubicPositionDD. ;
(DD; <
bezierPointsDD< H
[DDH I
iDDI J
]DDJ K
,DDK L
bezierPointsDDM Y
[DDY Z
(DDZ [
iDD[ \
+DD] ^
$numDD_ `
)DD` a
%DDb c
cDDd e
]DDe f
,DDf g
nDDh i
/DDj k
sDDl m
)DDm n
)DDn o
;DDo p
ifFF 
(FF 
	rotationsFF !
!=FF" $
nullFF% )
)FF) *
	rotationsGG !
.GG! "
AddGG" %
(GG% &

QuaternionGG& 0
.GG0 1
SlerpGG1 6
(GG6 7
bezierPointsGG7 C
[GGC D
iGGD E
]GGE F
.GGF G
rotationGGG O
,GGO P
bezierPointsGGQ ]
[GG] ^
(GG^ _
iGG_ `
+GGa b
$numGGc d
)GGd e
%GGf g
cGGh i
]GGi j
.GGj k
rotationGGk s
,GGs t
nGGu v
/GGw x
(GGy z
floatGGz 
)	GG Ä
(
GGÄ Å#
segments_per_keyframe
GGÅ ñ
-
GGó ò
$num
GGô ö
)
GGö õ
)
GGõ ú
)
GGú ù
;
GGù û
}HH 
}II 
returnKK 
	positionsKK 
;KK 
}LL 	
internalOO 
staticOO 
voidOO 
ExtrudeOO $
(OO$ %
IListOO% *
<OO* +
Vector3OO+ 2
>OO2 3
pointsOO4 :
,OO: ;
floatPP 
radiusPP 
,PP 
intQQ 

radiusRowsQQ 
,QQ 
boolRR 
	closeLoopRR 
,RR 
boolSS 
smoothSS 
,SS 
refTT 
ProBuilderMeshTT 
targetTT %
,TT% &
IListUU 
<UU 

QuaternionUU 
>UU 
pointRotationsUU ,
=UU- .
nullUU/ 3
)UU3 4
{VV 	
ifWW 
(WW 
pointsWW 
==WW 
nullWW 
||WW !
pointsWW" (
.WW( )
CountWW) .
<WW/ 0
$numWW1 2
)WW2 3
returnXX 
;XX 
intZZ 
cntZZ 
=ZZ 
pointsZZ 
.ZZ 
CountZZ "
;ZZ" #
int[[ 
rows[[ 
=[[ 
System[[ 
.[[ 
Math[[ "
.[[" #
Max[[# &
([[& '
$num[[' (
,[[( )

radiusRows[[* 4
)[[4 5
;[[5 6
int\\ 
	rowsPlus1\\ 
=\\ 
rows\\  
+\\! "
$num\\# $
;\\$ %
int]] 
rowsPlus1Times2]] 
=]]  !
rows]]" &
*]]' (
$num]]) *
;]]* +
int^^ 
vertexCount^^ 
=^^ 
(^^ 
(^^  
	closeLoop^^  )
?^^* +
cnt^^, /
:^^0 1
cnt^^2 5
-^^6 7
$num^^8 9
)^^9 :
*^^; <
$num^^= >
)^^> ?
*^^@ A
rowsPlus1Times2^^B Q
;^^Q R
bool__ 
vertexCountsMatch__ "
=__# $
false__% *
;__* +
bool`` 
hasPointRotations`` "
=``# $
pointRotations``% 3
!=``4 6
null``7 ;
&&``< >
pointRotations``? M
.``M N
Count``N S
==``T V
points``W ]
.``] ^
Count``^ c
;``c d
Vector3bb 
[bb 
]bb 
	positionsbb 
=bb  !
newbb" %
Vector3bb& -
[bb- .
vertexCountbb. 9
]bb9 :
;bb: ;
Facecc 
[cc 
]cc 
facescc 
=cc 
vertexCountsMatchcc ,
?cc- .
nullcc/ 3
:cc4 5
newcc6 9
Facecc: >
[cc> ?
(cc? @
	closeLoopcc@ I
?ccJ K
cntccL O
:ccP Q
cntccR U
-ccV W
$numccX Y
)ccY Z
*cc[ \
rowscc] a
]cca b
;ccb c
intee 
triangleIndexee 
=ee 
$numee  !
,ee! "
	faceIndexee# ,
=ee- .
$numee/ 0
,ee0 1
vertexIndexee2 =
=ee> ?
$numee@ A
;eeA B
intff 
segmentCountff 
=ff 
(ff  
	closeLoopff  )
?ff* +
cntff, /
:ff0 1
cntff2 5
-ff6 7
$numff8 9
)ff9 :
;ff: ;
forhh 
(hh 
inthh 
ihh 
=hh 
$numhh 
;hh 
ihh 
<hh 
segmentCounthh  ,
;hh, -
ihh. /
++hh/ 1
)hh1 2
{ii 
floatjj 
secant_ajj 
,jj 
secant_bjj  (
;jj( )

Quaternionll 

rotation_all %
=ll& '
GetRingRotationll( 7
(ll7 8
pointsll8 >
,ll> ?
ill@ A
,llA B
	closeLoopllC L
,llL M
outllN Q
secant_allR Z
)llZ [
;ll[ \

Quaternionmm 

rotation_bmm %
=mm& '
GetRingRotationmm( 7
(mm7 8
pointsmm8 >
,mm> ?
(mm@ A
immA B
+mmC D
$nummmE F
)mmF G
%mmH I
cntmmJ M
,mmM N
	closeLoopmmO X
,mmX Y
outmmZ ]
secant_bmm^ f
)mmf g
;mmg h
ifoo 
(oo 
hasPointRotationsoo %
)oo% &
{pp 

rotation_aqq 
=qq  

rotation_aqq! +
*qq, -
pointRotationsqq. <
[qq< =
iqq= >
]qq> ?
;qq? @

rotation_brr 
=rr  

rotation_brr! +
*rr, -
pointRotationsrr. <
[rr< =
(rr= >
irr> ?
+rr@ A
$numrrB C
)rrC D
%rrE F
cntrrG J
]rrJ K
;rrK L
}ss 
Vector3uu 
[uu 
]uu 
ringAuu 
=uu  !

VertexRinguu" ,
(uu, -

rotation_auu- 7
,uu7 8
pointsuu9 ?
[uu? @
iuu@ A
]uuA B
,uuB C
radiusuuD J
,uuJ K
	rowsPlus1uuL U
)uuU V
;uuV W
Vector3vv 
[vv 
]vv 
ringBvv 
=vv  !

VertexRingvv" ,
(vv, -

rotation_bvv- 7
,vv7 8
pointsvv9 ?
[vv? @
(vv@ A
ivvA B
+vvC D
$numvvE F
)vvF G
%vvH I
cntvvJ M
]vvM N
,vvN O
radiusvvP V
,vvV W
	rowsPlus1vvX a
)vva b
;vvb c
Systemxx 
.xx 
Arrayxx 
.xx 
Copyxx !
(xx! "
ringAxx" '
,xx' (
$numxx) *
,xx* +
	positionsxx, 5
,xx5 6
vertexIndexxx7 B
,xxB C
rowsPlus1Times2xxD S
)xxS T
;xxT U
vertexIndexyy 
+=yy 
rowsPlus1Times2yy .
;yy. /
Systemzz 
.zz 
Arrayzz 
.zz 
Copyzz !
(zz! "
ringBzz" '
,zz' (
$numzz) *
,zz* +
	positionszz, 5
,zz5 6
vertexIndexzz7 B
,zzB C
rowsPlus1Times2zzD S
)zzS T
;zzT U
vertexIndex{{ 
+={{ 
rowsPlus1Times2{{ .
;{{. /
if}} 
(}} 
!}} 
vertexCountsMatch}} &
)}}& '
{~~ 
for 
( 
int 
n 
=  
$num! "
;" #
n$ %
<& '
rowsPlus1Times2( 7
;7 8
n9 :
+=; =
$num> ?
)? @
{
ÄÄ 
faces
ÅÅ 
[
ÅÅ 
	faceIndex
ÅÅ '
]
ÅÅ' (
=
ÅÅ) *
new
ÅÅ+ .
Face
ÅÅ/ 3
(
ÅÅ3 4
new
ÅÅ4 7
int
ÅÅ8 ;
[
ÅÅ; <
$num
ÅÅ< =
]
ÅÅ= >
{
ÇÇ 
triangleIndex
ÉÉ )
,
ÉÉ) *
triangleIndex
ÉÉ+ 8
+
ÉÉ9 :
$num
ÉÉ; <
,
ÉÉ< =
triangleIndex
ÉÉ> K
+
ÉÉL M
rowsPlus1Times2
ÉÉN ]
,
ÉÉ] ^
triangleIndex
ÑÑ )
+
ÑÑ* +
rowsPlus1Times2
ÑÑ, ;
,
ÑÑ; <
triangleIndex
ÑÑ= J
+
ÑÑK L
$num
ÑÑM N
,
ÑÑN O
triangleIndex
ÑÑP ]
+
ÑÑ^ _
rowsPlus1Times2
ÑÑ` o
+
ÑÑp q
$num
ÑÑr s
}
ÖÖ 
)
ÖÖ 
;
ÖÖ 
if
áá 
(
áá 
smooth
áá "
)
áá" #
faces
àà !
[
àà! "
	faceIndex
àà" +
]
àà+ ,
.
àà, -
smoothingGroup
àà- ;
=
àà< =
$num
àà> ?
;
àà? @
	faceIndex
ää !
++
ää! #
;
ää# $
triangleIndex
ãã %
+=
ãã& (
$num
ãã) *
;
ãã* +
}
åå 
triangleIndex
éé !
+=
éé" $
rowsPlus1Times2
éé% 4
;
éé4 5
}
èè 
}
êê 
if
íí 
(
íí 
target
íí 
!=
íí 
null
íí 
)
íí 
{
ìì 
if
îî 
(
îî 
faces
îî 
!=
îî 
null
îî !
)
îî! "
{
ïï 
target
ññ 
.
ññ *
RebuildWithPositionsAndFaces
ññ 7
(
ññ7 8
	positions
ññ8 A
,
ññA B
faces
ññC H
)
ññH I
;
ññI J
}
óó 
else
òò 
{
ôô 
target
öö 
.
öö 
	positions
öö $
=
öö% &
	positions
öö' 0
;
öö0 1
target
õõ 
.
õõ 
ToMesh
õõ !
(
õõ! "
)
õõ" #
;
õõ# $
target
úú 
.
úú 
Refresh
úú "
(
úú" #
RefreshMask
úú# .
.
úú. /
UV
úú/ 1
|
úú2 3
RefreshMask
úú4 ?
.
úú? @
Colors
úú@ F
|
úúG H
RefreshMask
úúI T
.
úúT U
Normals
úúU \
|
úú] ^
RefreshMask
úú_ j
.
úúj k
Tangents
úúk s
)
úús t
;
úút u
}
ùù 
}
ûû 
else
üü 
{
†† 
target
°° 
=
°° 
ProBuilderMesh
°° '
.
°°' (
Create
°°( .
(
°°. /
	positions
°°/ 8
,
°°8 9
faces
°°: ?
)
°°? @
;
°°@ A
}
¢¢ 
}
££ 	
static
•• 

Quaternion
•• 
GetRingRotation
•• )
(
••) *
IList
••* /
<
••/ 0
Vector3
••0 7
>
••7 8
points
••9 ?
,
••? @
int
••A D
i
••E F
,
••F G
bool
••H L
	closeLoop
••M V
,
••V W
out
••X [
float
••\ a
secant
••b h
)
••h i
{
¶¶ 	
int
ßß 
cnt
ßß 
=
ßß 
points
ßß 
.
ßß 
Count
ßß "
;
ßß" #
Vector3
®® 
dir
®® 
;
®® 
if
™™ 
(
™™ 
	closeLoop
™™ 
||
™™ 
(
™™ 
i
™™ 
>
™™  !
$num
™™" #
&&
™™$ &
i
™™' (
<
™™) *
cnt
™™+ .
-
™™/ 0
$num
™™1 2
)
™™2 3
)
™™3 4
{
´´ 
int
¨¨ 
a
¨¨ 
=
¨¨ 
i
¨¨ 
<
¨¨ 
$num
¨¨ 
?
¨¨ 
cnt
¨¨  #
-
¨¨$ %
$num
¨¨& '
:
¨¨( )
i
¨¨* +
-
¨¨, -
$num
¨¨. /
;
¨¨/ 0
int
≠≠ 
b
≠≠ 
=
≠≠ 
i
≠≠ 
;
≠≠ 
int
ÆÆ 
c
ÆÆ 
=
ÆÆ 
(
ÆÆ 
i
ÆÆ 
+
ÆÆ 
$num
ÆÆ 
)
ÆÆ 
%
ÆÆ  !
cnt
ÆÆ" %
;
ÆÆ% &
Vector3
∞∞ 
coming
∞∞ 
=
∞∞  
(
∞∞! "
points
∞∞" (
[
∞∞( )
b
∞∞) *
]
∞∞* +
-
∞∞, -
points
∞∞. 4
[
∞∞4 5
a
∞∞5 6
]
∞∞6 7
)
∞∞7 8
.
∞∞8 9

normalized
∞∞9 C
;
∞∞C D
Vector3
±± 
leaving
±± 
=
±±  !
(
±±" #
points
±±# )
[
±±) *
c
±±* +
]
±±+ ,
-
±±- .
points
±±/ 5
[
±±5 6
b
±±6 7
]
±±7 8
)
±±8 9
.
±±9 :

normalized
±±: D
;
±±D E
dir
≥≥ 
=
≥≥ 
(
≥≥ 
coming
≥≥ 
+
≥≥ 
leaving
≥≥  '
)
≥≥' (
*
≥≥) *
$num
≥≥+ .
;
≥≥. /
secant
µµ 
=
µµ 
Math
µµ 
.
µµ 
Secant
µµ $
(
µµ$ %
Vector3
µµ% ,
.
µµ, -
Angle
µµ- 2
(
µµ2 3
coming
µµ3 9
,
µµ9 :
dir
µµ; >
)
µµ> ?
*
µµ@ A
Mathf
µµB G
.
µµG H
Deg2Rad
µµH O
)
µµO P
;
µµP Q
}
∂∂ 
else
∑∑ 
{
∏∏ 
if
ππ 
(
ππ 
i
ππ 
<
ππ 
$num
ππ 
)
ππ 
dir
∫∫ 
=
∫∫ 
points
∫∫  
[
∫∫  !
i
∫∫! "
+
∫∫# $
$num
∫∫% &
]
∫∫& '
-
∫∫( )
points
∫∫* 0
[
∫∫0 1
i
∫∫1 2
]
∫∫2 3
;
∫∫3 4
else
ªª 
dir
ºº 
=
ºº 
points
ºº  
[
ºº  !
i
ºº! "
]
ºº" #
-
ºº$ %
points
ºº& ,
[
ºº, -
i
ºº- .
-
ºº/ 0
$num
ºº1 2
]
ºº2 3
;
ºº3 4
secant
ææ 
=
ææ 
$num
ææ 
;
ææ 
}
øø 
dir
¡¡ 
.
¡¡ 
	Normalize
¡¡ 
(
¡¡ 
)
¡¡ 
;
¡¡ 
if
√√ 
(
√√ 
Math
√√ 
.
√√ 
Approx3
√√ 
(
√√ 
dir
√√  
,
√√  !
Vector3
√√" )
.
√√) *
up
√√* ,
)
√√, -
||
√√. 0
Math
√√1 5
.
√√5 6
Approx3
√√6 =
(
√√= >
dir
√√> A
,
√√A B
Vector3
√√C J
.
√√J K
zero
√√K O
)
√√O P
)
√√P Q
return
ƒƒ 

Quaternion
ƒƒ !
.
ƒƒ! "
identity
ƒƒ" *
;
ƒƒ* +
return
∆∆ 

Quaternion
∆∆ 
.
∆∆ 
LookRotation
∆∆ *
(
∆∆* +
dir
∆∆+ .
)
∆∆. /
;
∆∆/ 0
}
«« 	
static
…… 
Vector3
…… 
[
…… 
]
…… 

VertexRing
…… #
(
……# $

Quaternion
……$ .
orientation
……/ :
,
……: ;
Vector3
……< C
offset
……D J
,
……J K
float
……L Q
radius
……R X
,
……X Y
int
……Z ]
segments
……^ f
)
……f g
{
   	
Vector3
ÀÀ 
[
ÀÀ 
]
ÀÀ 
v
ÀÀ 
=
ÀÀ 
new
ÀÀ 
Vector3
ÀÀ %
[
ÀÀ% &
segments
ÀÀ& .
*
ÀÀ/ 0
$num
ÀÀ1 2
]
ÀÀ2 3
;
ÀÀ3 4
for
ÕÕ 
(
ÕÕ 
int
ÕÕ 
i
ÕÕ 
=
ÕÕ 
$num
ÕÕ 
;
ÕÕ 
i
ÕÕ 
<
ÕÕ 
segments
ÕÕ  (
;
ÕÕ( )
i
ÕÕ* +
++
ÕÕ+ -
)
ÕÕ- .
{
ŒŒ 
float
œœ 
rad0
œœ 
=
œœ 
(
œœ 
i
œœ 
/
œœ  !
(
œœ" #
float
œœ# (
)
œœ( )
(
œœ) *
segments
œœ* 2
-
œœ3 4
$num
œœ5 6
)
œœ6 7
)
œœ7 8
*
œœ9 :
$num
œœ; ?
*
œœ@ A
Mathf
œœB G
.
œœG H
Deg2Rad
œœH O
;
œœO P
int
–– 
n
–– 
=
–– 
(
–– 
i
–– 
+
–– 
$num
–– 
)
–– 
%
––  !
segments
––" *
;
––* +
float
—— 
rad1
—— 
=
—— 
(
—— 
n
—— 
/
——  !
(
——" #
float
——# (
)
——( )
(
——) *
segments
——* 2
-
——3 4
$num
——5 6
)
——6 7
)
——7 8
*
——9 :
$num
——; ?
*
——@ A
Mathf
——B G
.
——G H
Deg2Rad
——H O
;
——O P
v
”” 
[
”” 
i
”” 
*
”” 
$num
”” 
]
”” 
=
”” 
offset
”” !
+
””" #
(
””$ %
orientation
””% 0
*
””1 2
new
””3 6
Vector3
””7 >
(
””> ?
Mathf
””? D
.
””D E
Cos
””E H
(
””H I
rad0
””I M
)
””M N
*
””O P
radius
””Q W
,
””W X
Mathf
””Y ^
.
””^ _
Sin
””_ b
(
””b c
rad0
””c g
)
””g h
*
””i j
radius
””k q
,
””q r
$num
””s u
)
””u v
)
””v w
;
””w x
v
‘‘ 
[
‘‘ 
i
‘‘ 
*
‘‘ 
$num
‘‘ 
+
‘‘ 
$num
‘‘ 
]
‘‘ 
=
‘‘ 
offset
‘‘ %
+
‘‘& '
(
‘‘( )
orientation
‘‘) 4
*
‘‘5 6
new
‘‘7 :
Vector3
‘‘; B
(
‘‘B C
Mathf
‘‘C H
.
‘‘H I
Cos
‘‘I L
(
‘‘L M
rad1
‘‘M Q
)
‘‘Q R
*
‘‘S T
radius
‘‘U [
,
‘‘[ \
Mathf
‘‘] b
.
‘‘b c
Sin
‘‘c f
(
‘‘f g
rad1
‘‘g k
)
‘‘k l
*
‘‘m n
radius
‘‘o u
,
‘‘u v
$num
‘‘w y
)
‘‘y z
)
‘‘z {
;
‘‘{ |
}
’’ 
return
◊◊ 
v
◊◊ 
;
◊◊ 
}
ÿÿ 	
}
ŸŸ 
}⁄⁄ €4
àD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\IntVec4.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
struct 
IntVec4 
: 
System 
. 

IEquatable #
<# $
IntVec4$ +
>+ ,
{		 
public

 
Vector4

	 
value

 
;

 
public 
float	 
x 
{ 
get 
{ 
return 
value  %
.% &
x& '
;' (
}) *
}+ ,
public 
float	 
y 
{ 
get 
{ 
return 
value  %
.% &
y& '
;' (
}) *
}+ ,
public 
float	 
z 
{ 
get 
{ 
return 
value  %
.% &
z& '
;' (
}) *
}+ ,
public 
float	 
w 
{ 
get 
{ 
return 
value  %
.% &
w& '
;' (
}) *
}+ ,
public 
IntVec4	 
( 
Vector4 
vector 
)  
{ 
this 
. 
value 
= 
vector 
; 
} 
public 
override	 
string 
ToString !
(! "
)" #
{ 
return 	
string
 
. 
Format 
( 
$str :
,: ;
x< =
,= >
y? @
,@ A
zB C
,C D
wE F
)F G
;G H
} 
public 
static	 
bool 
operator 
== 
(  
IntVec4  '
a( )
,) *
IntVec4+ 2
b3 4
)4 5
{ 
return 	
a
 
. 
Equals 
( 
b 
) 
; 
} 
public   
static  	 
bool   
operator   
!=   
(    
IntVec4    '
a  ( )
,  ) *
IntVec4  + 2
b  3 4
)  4 5
{!! 
return"" 	
!""
 
("" 
a"" 
=="" 
b"" 
)"" 
;"" 
}## 
public%% 
bool%%	 
Equals%% 
(%% 
IntVec4%% 
p%% 
)%% 
{&& 
return'' 	
round''
 
('' 
x'' 
)'' 
=='' 
round'' 
('' 
p'' 
.'' 
x'' 
)''  
&&''! #
round(( 	
(((	 

y((
 
)(( 
==(( 
round(( 
((( 
p(( 
.(( 
y(( 
)(( 
&&(( 
round)) 	
())	 

z))
 
))) 
==)) 
round)) 
()) 
p)) 
.)) 
z)) 
))) 
&&)) 
round** 	
(**	 

w**
 
)** 
==** 
round** 
(** 
p** 
.** 
w** 
)** 
;** 
}++ 
public-- 
bool--	 
Equals-- 
(-- 
Vector4-- 
p-- 
)-- 
{.. 
return// 	
round//
 
(// 
x// 
)// 
==// 
round// 
(// 
p// 
.// 
x// 
)//  
&&//! #
round00 	
(00	 

y00
 
)00 
==00 
round00 
(00 
p00 
.00 
y00 
)00 
&&00 
round11 	
(11	 

z11
 
)11 
==11 
round11 
(11 
p11 
.11 
z11 
)11 
&&11 
round22 	
(22	 

w22
 
)22 
==22 
round22 
(22 
p22 
.22 
w22 
)22 
;22 
}33 
public55 
override55	 
bool55 
Equals55 
(55 
System55 $
.55$ %
Object55% +
b55, -
)55- .
{66 
return77 	
(77
 
b77 
is77 
IntVec477 
&&77 
(77 
this77  
.77  !
Equals77! '
(77' (
(77( )
IntVec477) 0
)770 1
b771 2
)772 3
)773 4
)774 5
||776 8
(88 
b88 
is88 	
Vector488
 
&&88 
this88 
.88 
Equals88  
(88  !
(88! "
Vector488" )
)88) *
b88* +
)88+ ,
)88, -
;88- .
}99 
public;; 
override;;	 
int;; 
GetHashCode;; !
(;;! "
);;" #
{<< 
return== 	

VectorHash==
 
.== 
GetHashCode==  
(==  !
value==! &
)==& '
;==' (
}>> 
private@@ 	
static@@
 
int@@ 
round@@ 
(@@ 
float@@  
v@@! "
)@@" #
{AA 
returnBB 	
SystemBB
 
.BB 
ConvertBB 
.BB 
ToInt32BB  
(BB  !
vBB! "
*BB# $

VectorHashBB% /
.BB/ 0 
FltCompareResolutionBB0 D
)BBD E
;BBE F
}CC 
publicEE 
staticEE	 
implicitEE 
operatorEE !
Vector4EE" )
(EE) *
IntVec4EE* 1
pEE2 3
)EE3 4
{FF 
returnGG 	
pGG
 
.GG 
valueGG 
;GG 
}HH 
publicJJ 
staticJJ	 
implicitJJ 
operatorJJ !
IntVec4JJ" )
(JJ) *
Vector4JJ* 1
pJJ2 3
)JJ3 4
{KK 
returnLL 	
newLL
 
IntVec4LL 
(LL 
pLL 
)LL 
;LL 
}MM 
}NN 
}OO ü
ëD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\TriggerBehaviour.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[		 %
DisallowMultipleComponent		 
]		 
sealed

 

class

 
TriggerBehaviour

 !
:

" #
EntityBehaviour

$ 3
{ 
public 
override 
void 

Initialize '
(' (
)( )
{ 	
var 
	collision 
= 

gameObject &
.& '
GetComponent' 3
<3 4
Collider4 <
>< =
(= >
)> ?
;? @
if 
( 
! 
	collision 
) 
	collision 
= 

gameObject &
.& '
AddComponent' 3
<3 4
MeshCollider4 @
>@ A
(A B
)B C
;C D
var 
meshCollider 
= 
	collision (
as) +
MeshCollider, 8
;8 9
if 
( 
meshCollider 
) 
meshCollider 
. 
convex #
=$ %
true& *
;* +
	collision 
. 
	isTrigger 
=  !
true" &
;& '
SetMaterial 
( 
BuiltinMaterials (
.( )
triggerMaterial) 8
)8 9
;9 :
var 
r 
= 
GetComponent  
<  !
Renderer! )
>) *
(* +
)+ ,
;, -
if 
( 
r 
!= 
null 
) 
r 
. 
	hideFlags 
= 
	HideFlags '
.' (
DontSaveInBuild( 7
;7 8
}   	
public"" 
override"" 
void"" 
OnEnterPlayMode"" ,
("", -
)""- .
{## 	
var$$ 
r$$ 
=$$ 
GetComponent$$  
<$$  !
Renderer$$! )
>$$) *
($$* +
)$$+ ,
;$$, -
if&& 
(&& 
r&& 
!=&& 
null&& 
)&& 
r'' 
.'' 
enabled'' 
='' 
false'' !
;''! "
}(( 	
public** 
override** 
void** 
OnSceneLoaded** *
(*** +
Scene**+ 0
scene**1 6
,**6 7
LoadSceneMode**8 E
mode**F J
)**J K
{++ 	
var,, 
r,, 
=,, 
GetComponent,,  
<,,  !
Renderer,,! )
>,,) *
(,,* +
),,+ ,
;,,, -
if.. 
(.. 
r.. 
!=.. 
null.. 
).. 
r// 
.// 
enabled// 
=// 
false// !
;//! "
}00 	
}11 
}22 ¯Ù
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SelectionPickerRenderer.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

struct 
PickerOptions 
{ 
public 
bool 
	depthTest 
{ 
get  #
;# $
set% (
;( )
}* +
public 
RectSelectMode 
rectSelectMode ,
{- .
get/ 2
;2 3
set4 7
;7 8
}9 :
static 
readonly 
PickerOptions %
	k_Default& /
=0 1
new2 5
PickerOptions6 C
(C D
)D E
{ 	
	depthTest 
= 
true 
, 
rectSelectMode 
= 
RectSelectMode +
.+ ,
Partial, 3
,3 4
}   	
;  	 

public%% 
static%% 
PickerOptions%% #
Default%%$ +
{&& 	
get'' 
{'' 
return'' 
	k_Default'' "
;''" #
}''$ %
}(( 	
public** 
override** 
bool** 
Equals** #
(**# $
object**$ *
obj**+ .
)**. /
{++ 	
if,, 
(,, 
!,, 
(,, 
obj,, 
is,, 
PickerOptions,, &
),,& '
),,' (
return-- 
false-- 
;-- 
return// 
Equals// 
(// 
(// 
PickerOptions// (
)//( )
obj//) ,
)//, -
;//- .
}00 	
public22 
bool22 
Equals22 
(22 
PickerOptions22 (
other22) .
)22. /
{33 	
return44 
	depthTest44 
==44 
other44  %
.44% &
	depthTest44& /
&&440 2
rectSelectMode443 A
==44B D
other44E J
.44J K
rectSelectMode44K Y
;44Y Z
}55 	
public77 
override77 
int77 
GetHashCode77 '
(77' (
)77( )
{88 	
	unchecked99 
{:: 
return;; 
(;; 
	depthTest;; !
.;;! "
GetHashCode;;" -
(;;- .
);;. /
*;;0 1
$num;;2 5
);;5 6
^;;7 8
(;;9 :
int;;: =
);;= >
rectSelectMode;;> L
;;;L M
}<< 
}== 	
public?? 
static?? 
bool?? 
operator?? #
==??# %
(??% &
PickerOptions??& 3
a??4 5
,??5 6
PickerOptions??7 D
b??E F
)??F G
{@@ 	
returnAA 
aAA 
.AA 
EqualsAA 
(AA 
bAA 
)AA 
;AA 
}BB 	
publicDD 
staticDD 
boolDD 
operatorDD #
!=DD# %
(DD% &
PickerOptionsDD& 3
aDD4 5
,DD5 6
PickerOptionsDD7 D
bDDE F
)DDF G
{EE 	
returnFF 
!FF 
aFF 
.FF 
EqualsFF 
(FF 
bFF 
)FF 
;FF  
}GG 	
}HH 
staticMM 

partialMM 
classMM #
SelectionPickerRendererMM 0
{NN 
internalOO 
	interfaceOO $
ISelectionPickerRendererOO 3
{PP 	
	Texture2DQQ 
RenderLookupTextureQQ )
(QQ) *
CameraQQ* 0
cameraQQ1 7
,QQ7 8
ShaderQQ9 ?
shaderQQ@ F
,QQF G
stringQQH N
tagQQO R
,QQR S
intQQT W
widthQQX ]
,QQ] ^
intQQ_ b
heightQQc i
)QQi j
;QQj k
}RR 	
constTT 
stringTT ,
 k_FacePickerOcclusionTintUniformTT 5
=TT6 7
$strTT8 ?
;TT? @
staticUU 
readonlyUU 
ColorUU 
k_BlackfUU &
=UU' (
newUU) ,
ColorUU- 2
(UU2 3
$numUU3 5
,UU5 6
$numUU7 9
,UU9 :
$numUU; =
,UU= >
$numUU? A
)UUA B
;UUB C
staticVV 
readonlyVV 
ColorVV 
k_WhitefVV &
=VV' (
newVV) ,
ColorVV- 2
(VV2 3
$numVV3 5
,VV5 6
$numVV7 9
,VV9 :
$numVV; =
,VV= >
$numVV? A
)VVA B
;VVB C
constWW 
uintWW 
k_PickerHashNoneWW #
=WW$ %
$numWW& *
;WW* +
constXX 
uintXX 
k_PickerHashMinXX "
=XX# $
$numXX% (
;XX( )
constYY 
uintYY 
k_PickerHashMaxYY "
=YY# $
$numYY% /
;YY/ 0
constZZ 
uintZZ ,
 k_MinEdgePixelsForValidSelectionZZ 3
=ZZ4 5
$numZZ6 7
;ZZ7 8
static\\ 
bool\\ 
s_Initialized\\ !
=\\" #
false\\$ )
;\\) *
static]] $
ISelectionPickerRenderer]] '
s_PickerRenderer]]( 8
=]]9 :
null]]; ?
;]]? @
static__ 
RenderTextureFormat__ "
renderTextureFormat__# 6
{`` 	
getaa 
{bb 
ifcc 
(cc 
s_Initializedcc !
)cc! "
returndd !
s_RenderTextureFormatdd 0
;dd0 1
s_Initializedff 
=ff 
trueff  $
;ff$ %
forhh 
(hh 
inthh 
ihh 
=hh 
$numhh 
;hh 
ihh  !
<hh" #
s_PreferredFormatshh$ 6
.hh6 7
Lengthhh7 =
;hh= >
ihh? @
++hh@ B
)hhB C
{ii 
ifjj 
(jj 

SystemInfojj "
.jj" #'
SupportsRenderTextureFormatjj# >
(jj> ?
s_PreferredFormatsjj? Q
[jjQ R
ijjR S
]jjS T
)jjT U
)jjU V
{kk !
s_RenderTextureFormatll -
=ll. /
s_PreferredFormatsll0 B
[llB C
illC D
]llD E
;llE F
breakmm 
;mm 
}nn 
}oo 
returnqq !
s_RenderTextureFormatqq ,
;qq, -
}rr 
}ss 	
staticuu 
TextureFormatuu 
textureFormatuu *
{uu+ ,
getuu- 0
{uu1 2
returnuu3 9
TextureFormatuu: G
.uuG H
ARGB32uuH N
;uuN O
}uuP Q
}uuR S
staticww 
RenderTextureFormatww "!
s_RenderTextureFormatww# 8
=ww9 :
RenderTextureFormatww; N
.wwN O
DefaultwwO V
;wwV W
staticyy 
RenderTextureFormatyy "
[yy" #
]yy# $
s_PreferredFormatsyy% 7
=yy8 9
newyy: =
RenderTextureFormatyy> Q
[yyQ R
]yyR S
{zz 	
RenderTextureFormat 
.  
ARGB32  &
,& '!
RenderTextureFormat
ÄÄ 
.
ÄÄ  
	ARGBFloat
ÄÄ  )
,
ÄÄ) *
}
ÇÇ 	
;
ÇÇ	 

static
ââ &
ISelectionPickerRenderer
ââ '
pickerRenderer
ââ( 6
{
ää 	
get
ãã 
{
åå 
if
çç 
(
çç 
s_PickerRenderer
çç $
==
çç% '
null
çç( ,
)
çç, -
s_PickerRenderer
éé $
=
éé% &
ShouldUseHDRP
èè %
(
èè% &
)
èè& '
?
èè' (
(
êê &
ISelectionPickerRenderer
êê 1
)
êê1 2
new
êê2 5)
SelectionPickerRendererHDRP
êê6 Q
(
êêQ R
)
êêR S
:
ëë 
new
ëë -
SelectionPickerRendererStandard
ëë =
(
ëë= >
)
ëë> ?
;
ëë? @
return
íí 
s_PickerRenderer
íí '
;
íí' (
}
ìì 
}
îî 	
public
üü 
static
üü 

Dictionary
üü  
<
üü  !
ProBuilderMesh
üü! /
,
üü/ 0
HashSet
üü1 8
<
üü8 9
Face
üü9 =
>
üü= >
>
üü> ?
PickFacesInRect
üü@ O
(
üüO P
Camera
†† 
camera
†† 
,
†† 
Rect
°° 

pickerRect
°° 
,
°° 
IList
¢¢ 
<
¢¢ 
ProBuilderMesh
¢¢  
>
¢¢  !
	selection
¢¢" +
,
¢¢+ ,
int
££  
renderTextureWidth
££ "
=
££# $
-
££% &
$num
££& '
,
££' (
int
§§ !
renderTextureHeight
§§ #
=
§§$ %
-
§§& '
$num
§§' (
)
§§( )
{
•• 	

Dictionary
¶¶ 
<
¶¶ 
uint
¶¶ 
,
¶¶ 
SimpleTuple
¶¶ (
<
¶¶( )
ProBuilderMesh
¶¶) 7
,
¶¶7 8
Face
¶¶9 =
>
¶¶= >
>
¶¶> ?
map
¶¶@ C
;
¶¶C D
	Texture2D
ßß 
tex
ßß 
=
ßß *
RenderSelectionPickerTexture
ßß 8
(
ßß8 9
camera
ßß9 ?
,
ßß? @
	selection
ßßA J
,
ßßJ K
out
ßßL O
map
ßßP S
,
ßßS T 
renderTextureWidth
ßßU g
,
ßßg h!
renderTextureHeight
ßßi |
)
ßß| }
;
ßß} ~
Color32
©© 
[
©© 
]
©© 
pix
©© 
=
©© 
tex
©© 
.
©©  
GetPixels32
©©  +
(
©©+ ,
)
©©, -
;
©©- .
int
´´ 
ox
´´ 
=
´´ 
System
´´ 
.
´´ 
Math
´´  
.
´´  !
Max
´´! $
(
´´$ %
$num
´´% &
,
´´& '
Mathf
´´( -
.
´´- .

FloorToInt
´´. 8
(
´´8 9

pickerRect
´´9 C
.
´´C D
x
´´D E
)
´´E F
)
´´F G
;
´´G H
int
¨¨ 
oy
¨¨ 
=
¨¨ 
System
¨¨ 
.
¨¨ 
Math
¨¨  
.
¨¨  !
Max
¨¨! $
(
¨¨$ %
$num
¨¨% &
,
¨¨& '
Mathf
¨¨( -
.
¨¨- .

FloorToInt
¨¨. 8
(
¨¨8 9
(
¨¨9 :
tex
¨¨: =
.
¨¨= >
height
¨¨> D
-
¨¨E F

pickerRect
¨¨G Q
.
¨¨Q R
y
¨¨R S
)
¨¨S T
-
¨¨U V

pickerRect
¨¨W a
.
¨¨a b
height
¨¨b h
)
¨¨h i
)
¨¨i j
;
¨¨j k
int
≠≠ 

imageWidth
≠≠ 
=
≠≠ 
tex
≠≠  
.
≠≠  !
width
≠≠! &
;
≠≠& '
int
ÆÆ 
imageHeight
ÆÆ 
=
ÆÆ 
tex
ÆÆ !
.
ÆÆ! "
height
ÆÆ" (
;
ÆÆ( )
int
ØØ 
width
ØØ 
=
ØØ 
Mathf
ØØ 
.
ØØ 

FloorToInt
ØØ (
(
ØØ( )

pickerRect
ØØ) 3
.
ØØ3 4
width
ØØ4 9
)
ØØ9 :
;
ØØ: ;
int
∞∞ 
height
∞∞ 
=
∞∞ 
Mathf
∞∞ 
.
∞∞ 

FloorToInt
∞∞ )
(
∞∞) *

pickerRect
∞∞* 4
.
∞∞4 5
height
∞∞5 ;
)
∞∞; <
;
∞∞< =
UObject
±± 
.
±± 
DestroyImmediate
±± $
(
±±$ %
tex
±±% (
)
±±( )
;
±±) *

Dictionary
≥≥ 
<
≥≥ 
ProBuilderMesh
≥≥ %
,
≥≥% &
HashSet
≥≥' .
<
≥≥. /
Face
≥≥/ 3
>
≥≥3 4
>
≥≥4 5
selected
≥≥6 >
=
≥≥? @
new
≥≥A D

Dictionary
≥≥E O
<
≥≥O P
ProBuilderMesh
≥≥P ^
,
≥≥^ _
HashSet
≥≥` g
<
≥≥g h
Face
≥≥h l
>
≥≥l m
>
≥≥m n
(
≥≥n o
)
≥≥o p
;
≥≥p q
SimpleTuple
¥¥ 
<
¥¥ 
ProBuilderMesh
¥¥ &
,
¥¥& '
Face
¥¥( ,
>
¥¥, -
hit
¥¥. 1
;
¥¥1 2
HashSet
µµ 
<
µµ 
Face
µµ 
>
µµ 
faces
µµ 
=
µµ  !
null
µµ" &
;
µµ& '
HashSet
∂∂ 
<
∂∂ 
uint
∂∂ 
>
∂∂ 
used
∂∂ 
=
∂∂  
new
∂∂! $
HashSet
∂∂% ,
<
∂∂, -
uint
∂∂- 1
>
∂∂1 2
(
∂∂2 3
)
∂∂3 4
;
∂∂4 5
for
ºº 
(
ºº 
int
ºº 
y
ºº 
=
ºº 
oy
ºº 
;
ºº 
y
ºº 
<
ºº  
System
ºº! '
.
ºº' (
Math
ºº( ,
.
ºº, -
Min
ºº- 0
(
ºº0 1
oy
ºº1 3
+
ºº4 5
height
ºº6 <
,
ºº< =
imageHeight
ºº> I
)
ººI J
;
ººJ K
y
ººL M
++
ººM O
)
ººO P
{
ΩΩ 
for
ææ 
(
ææ 
int
ææ 
x
ææ 
=
ææ 
ox
ææ 
;
ææ  
x
ææ! "
<
ææ# $
System
ææ% +
.
ææ+ ,
Math
ææ, 0
.
ææ0 1
Min
ææ1 4
(
ææ4 5
ox
ææ5 7
+
ææ8 9
width
ææ: ?
,
ææ? @

imageWidth
ææA K
)
ææK L
;
ææL M
x
ææN O
++
ææO Q
)
ææQ R
{
øø 
uint
ƒƒ 
v
ƒƒ 
=
ƒƒ %
SelectionPickerRenderer
ƒƒ 4
.
ƒƒ4 5

DecodeRGBA
ƒƒ5 ?
(
ƒƒ? @
pix
ƒƒ@ C
[
ƒƒC D
y
ƒƒD E
*
ƒƒF G

imageWidth
ƒƒH R
+
ƒƒS T
x
ƒƒU V
]
ƒƒV W
)
ƒƒW X
;
ƒƒX Y
if
∆∆ 
(
∆∆ 
used
∆∆ 
.
∆∆ 
Add
∆∆  
(
∆∆  !
v
∆∆! "
)
∆∆" #
&&
∆∆$ &
map
∆∆' *
.
∆∆* +
TryGetValue
∆∆+ 6
(
∆∆6 7
v
∆∆7 8
,
∆∆8 9
out
∆∆: =
hit
∆∆> A
)
∆∆A B
)
∆∆B C
{
«« 
if
»» 
(
»» 
selected
»» $
.
»»$ %
TryGetValue
»»% 0
(
»»0 1
hit
»»1 4
.
»»4 5
item1
»»5 :
,
»»: ;
out
»»< ?
faces
»»@ E
)
»»E F
)
»»F G
faces
…… !
.
……! "
Add
……" %
(
……% &
hit
……& )
.
……) *
item2
……* /
)
……/ 0
;
……0 1
else
   
selected
ÀÀ $
.
ÀÀ$ %
Add
ÀÀ% (
(
ÀÀ( )
hit
ÀÀ) ,
.
ÀÀ, -
item1
ÀÀ- 2
,
ÀÀ2 3
new
ÀÀ4 7
HashSet
ÀÀ8 ?
<
ÀÀ? @
Face
ÀÀ@ D
>
ÀÀD E
(
ÀÀE F
)
ÀÀF G
{
ÀÀH I
hit
ÀÀJ M
.
ÀÀM N
item2
ÀÀN S
}
ÀÀT U
)
ÀÀU V
;
ÀÀV W
}
ÃÃ 
}
ÕÕ 
}
ŒŒ 
return
‡‡ 
selected
‡‡ 
;
‡‡ 
}
·· 	
public
ÌÌ 
static
ÌÌ 

Dictionary
ÌÌ  
<
ÌÌ  !
ProBuilderMesh
ÌÌ! /
,
ÌÌ/ 0
HashSet
ÌÌ1 8
<
ÌÌ8 9
int
ÌÌ9 <
>
ÌÌ< =
>
ÌÌ= > 
PickVerticesInRect
ÌÌ? Q
(
ÌÌQ R
Camera
ÓÓ 
camera
ÓÓ 
,
ÓÓ 
Rect
ÔÔ 

pickerRect
ÔÔ 
,
ÔÔ 
IList
 
<
 
ProBuilderMesh
  
>
  !
	selection
" +
,
+ ,
bool
ÒÒ 
doDepthTest
ÒÒ 
,
ÒÒ 
int
ÚÚ  
renderTextureWidth
ÚÚ "
=
ÚÚ# $
-
ÚÚ% &
$num
ÚÚ& '
,
ÚÚ' (
int
ÛÛ !
renderTextureHeight
ÛÛ #
=
ÛÛ$ %
-
ÛÛ& '
$num
ÛÛ' (
)
ÛÛ( )
{
ÙÙ 	

Dictionary
ıı 
<
ıı 
uint
ıı 
,
ıı 
SimpleTuple
ıı (
<
ıı( )
ProBuilderMesh
ıı) 7
,
ıı7 8
int
ıı9 <
>
ıı< =
>
ıı= >
map
ıı? B
;
ııB C

Dictionary
ˆˆ 
<
ˆˆ 
ProBuilderMesh
ˆˆ %
,
ˆˆ% &
HashSet
ˆˆ' .
<
ˆˆ. /
int
ˆˆ/ 2
>
ˆˆ2 3
>
ˆˆ3 4
selected
ˆˆ5 =
=
ˆˆ> ?
new
ˆˆ@ C

Dictionary
ˆˆD N
<
ˆˆN O
ProBuilderMesh
ˆˆO ]
,
ˆˆ] ^
HashSet
ˆˆ_ f
<
ˆˆf g
int
ˆˆg j
>
ˆˆj k
>
ˆˆk l
(
ˆˆl m
)
ˆˆm n
;
ˆˆn o
	Texture2D
¸¸ 
tex
¸¸ 
=
¸¸ *
RenderSelectionPickerTexture
¸¸ 8
(
¸¸8 9
camera
¸¸9 ?
,
¸¸? @
	selection
¸¸A J
,
¸¸J K
doDepthTest
¸¸L W
,
¸¸W X
out
¸¸Y \
map
¸¸] `
,
¸¸` a 
renderTextureWidth
¸¸b t
,
¸¸t u"
renderTextureHeight¸¸v â
)¸¸â ä
;¸¸ä ã
Color32
˝˝ 
[
˝˝ 
]
˝˝ 
pix
˝˝ 
=
˝˝ 
tex
˝˝ 
.
˝˝  
GetPixels32
˝˝  +
(
˝˝+ ,
)
˝˝, -
;
˝˝- .
int
ˇˇ 
ox
ˇˇ 
=
ˇˇ 
System
ˇˇ 
.
ˇˇ 
Math
ˇˇ  
.
ˇˇ  !
Max
ˇˇ! $
(
ˇˇ$ %
$num
ˇˇ% &
,
ˇˇ& '
Mathf
ˇˇ( -
.
ˇˇ- .

FloorToInt
ˇˇ. 8
(
ˇˇ8 9

pickerRect
ˇˇ9 C
.
ˇˇC D
x
ˇˇD E
)
ˇˇE F
)
ˇˇF G
;
ˇˇG H
int
ÄÄ 
oy
ÄÄ 
=
ÄÄ 
System
ÄÄ 
.
ÄÄ 
Math
ÄÄ  
.
ÄÄ  !
Max
ÄÄ! $
(
ÄÄ$ %
$num
ÄÄ% &
,
ÄÄ& '
Mathf
ÄÄ( -
.
ÄÄ- .

FloorToInt
ÄÄ. 8
(
ÄÄ8 9
(
ÄÄ9 :
tex
ÄÄ: =
.
ÄÄ= >
height
ÄÄ> D
-
ÄÄE F

pickerRect
ÄÄG Q
.
ÄÄQ R
y
ÄÄR S
)
ÄÄS T
-
ÄÄU V

pickerRect
ÄÄW a
.
ÄÄa b
height
ÄÄb h
)
ÄÄh i
)
ÄÄi j
;
ÄÄj k
int
ÅÅ 

imageWidth
ÅÅ 
=
ÅÅ 
tex
ÅÅ  
.
ÅÅ  !
width
ÅÅ! &
;
ÅÅ& '
int
ÇÇ 
imageHeight
ÇÇ 
=
ÇÇ 
tex
ÇÇ !
.
ÇÇ! "
height
ÇÇ" (
;
ÇÇ( )
int
ÉÉ 
width
ÉÉ 
=
ÉÉ 
Mathf
ÉÉ 
.
ÉÉ 

FloorToInt
ÉÉ (
(
ÉÉ( )

pickerRect
ÉÉ) 3
.
ÉÉ3 4
width
ÉÉ4 9
)
ÉÉ9 :
;
ÉÉ: ;
int
ÑÑ 
height
ÑÑ 
=
ÑÑ 
Mathf
ÑÑ 
.
ÑÑ 

FloorToInt
ÑÑ )
(
ÑÑ) *

pickerRect
ÑÑ* 4
.
ÑÑ4 5
height
ÑÑ5 ;
)
ÑÑ; <
;
ÑÑ< =
UObject
ÜÜ 
.
ÜÜ 
DestroyImmediate
ÜÜ $
(
ÜÜ$ %
tex
ÜÜ% (
)
ÜÜ( )
;
ÜÜ) *
SimpleTuple
àà 
<
àà 
ProBuilderMesh
àà &
,
àà& '
int
àà( +
>
àà+ ,
hit
àà- 0
;
àà0 1
HashSet
ââ 
<
ââ 
int
ââ 
>
ââ 
indexes
ââ  
=
ââ! "
null
ââ# '
;
ââ' (
HashSet
ää 
<
ää 
uint
ää 
>
ää 
used
ää 
=
ää  
new
ää! $
HashSet
ää% ,
<
ää, -
uint
ää- 1
>
ää1 2
(
ää2 3
)
ää3 4
;
ää4 5
for
åå 
(
åå 
int
åå 
y
åå 
=
åå 
oy
åå 
;
åå 
y
åå 
<
åå  
System
åå! '
.
åå' (
Math
åå( ,
.
åå, -
Min
åå- 0
(
åå0 1
oy
åå1 3
+
åå4 5
height
åå6 <
,
åå< =
imageHeight
åå> I
)
ååI J
;
ååJ K
y
ååL M
++
ååM O
)
ååO P
{
çç 
for
éé 
(
éé 
int
éé 
x
éé 
=
éé 
ox
éé 
;
éé  
x
éé! "
<
éé# $
System
éé% +
.
éé+ ,
Math
éé, 0
.
éé0 1
Min
éé1 4
(
éé4 5
ox
éé5 7
+
éé8 9
width
éé: ?
,
éé? @

imageWidth
ééA K
)
ééK L
;
ééL M
x
ééN O
++
ééO Q
)
ééQ R
{
èè 
uint
êê 
v
êê 
=
êê 

DecodeRGBA
êê '
(
êê' (
pix
êê( +
[
êê+ ,
y
êê, -
*
êê. /

imageWidth
êê0 :
+
êê; <
x
êê= >
]
êê> ?
)
êê? @
;
êê@ A
if
ññ 
(
ññ 
used
ññ 
.
ññ 
Add
ññ  
(
ññ  !
v
ññ! "
)
ññ" #
&&
ññ$ &
map
ññ' *
.
ññ* +
TryGetValue
ññ+ 6
(
ññ6 7
v
ññ7 8
,
ññ8 9
out
ññ: =
hit
ññ> A
)
ññA B
)
ññB C
{
óó 
if
òò 
(
òò 
selected
òò $
.
òò$ %
TryGetValue
òò% 0
(
òò0 1
hit
òò1 4
.
òò4 5
item1
òò5 :
,
òò: ;
out
òò< ?
indexes
òò@ G
)
òòG H
)
òòH I
indexes
ôô #
.
ôô# $
Add
ôô$ '
(
ôô' (
hit
ôô( +
.
ôô+ ,
item2
ôô, 1
)
ôô1 2
;
ôô2 3
else
öö 
selected
õõ $
.
õõ$ %
Add
õõ% (
(
õõ( )
hit
õõ) ,
.
õõ, -
item1
õõ- 2
,
õõ2 3
new
õõ4 7
HashSet
õõ8 ?
<
õõ? @
int
õõ@ C
>
õõC D
(
õõD E
)
õõE F
{
õõG H
hit
õõI L
.
õõL M
item2
õõM R
}
õõS T
)
õõT U
;
õõU V
}
úú 
}
ùù 
}
ûû 
var
†† !
coincidentSelection
†† #
=
††$ %
new
††& )

Dictionary
††* 4
<
††4 5
ProBuilderMesh
††5 C
,
††C D
HashSet
††E L
<
††L M
int
††M P
>
††P Q
>
††Q R
(
††R S
)
††S T
;
††T U
foreach
££ 
(
££ 
var
££ 
meshSelection
££ &
in
££' )
selected
££* 2
)
££2 3
{
§§ 
var
•• 
	positions
•• 
=
•• 
meshSelection
••  -
.
••- .
Key
••. 1
.
••1 2
positionsInternal
••2 C
;
••C D
var
¶¶ 
sharedVertices
¶¶ "
=
¶¶# $
meshSelection
¶¶% 2
.
¶¶2 3
Key
¶¶3 6
.
¶¶6 7$
sharedVerticesInternal
¶¶7 M
;
¶¶M N
var
ßß 
positionHash
ßß  
=
ßß! "
new
ßß# &
HashSet
ßß' .
<
ßß. /
int
ßß/ 2
>
ßß2 3
(
ßß3 4
meshSelection
ßß4 A
.
ßßA B
Value
ßßB G
.
ßßG H
Select
ßßH N
(
ßßN O
x
ßßO P
=>
ßßQ S

VectorHash
ßßT ^
.
ßß^ _
GetHashCode
ßß_ j
(
ßßj k
	positions
ßßk t
[
ßßt u
sharedVerticesßßu É
[ßßÉ Ñ
xßßÑ Ö
]ßßÖ Ü
[ßßÜ á
$numßßá à
]ßßà â
]ßßâ ä
)ßßä ã
)ßßã å
)ßßå ç
;ßßç é
var
®® 
	collected
®® 
=
®® 
new
®®  #
HashSet
®®$ +
<
®®+ ,
int
®®, /
>
®®/ 0
(
®®0 1
)
®®1 2
;
®®2 3
for
™™ 
(
™™ 
int
™™ 
i
™™ 
=
™™ 
$num
™™ 
,
™™ 
c
™™  !
=
™™" #
sharedVertices
™™$ 2
.
™™2 3
Length
™™3 9
;
™™9 :
i
™™; <
<
™™= >
c
™™? @
;
™™@ A
i
™™B C
++
™™C E
)
™™E F
{
´´ 
var
¨¨ 
hash
¨¨ 
=
¨¨ 

VectorHash
¨¨ )
.
¨¨) *
GetHashCode
¨¨* 5
(
¨¨5 6
	positions
¨¨6 ?
[
¨¨? @
sharedVertices
¨¨@ N
[
¨¨N O
i
¨¨O P
]
¨¨P Q
[
¨¨Q R
$num
¨¨R S
]
¨¨S T
]
¨¨T U
)
¨¨U V
;
¨¨V W
if
≠≠ 
(
≠≠ 
positionHash
≠≠ $
.
≠≠$ %
Contains
≠≠% -
(
≠≠- .
hash
≠≠. 2
)
≠≠2 3
)
≠≠3 4
	collected
ÆÆ !
.
ÆÆ! "
Add
ÆÆ" %
(
ÆÆ% &
i
ÆÆ& '
)
ÆÆ' (
;
ÆÆ( )
}
ØØ !
coincidentSelection
±± #
.
±±# $
Add
±±$ '
(
±±' (
meshSelection
±±( 5
.
±±5 6
Key
±±6 9
,
±±9 :
	collected
±±; D
)
±±D E
;
±±E F
}
≤≤ 
selected
≥≥ 
=
≥≥ !
coincidentSelection
≥≥ *
;
≥≥* +
return
√√ 
selected
√√ 
;
√√ 
}
ƒƒ 	
public
–– 
static
–– 

Dictionary
––  
<
––  !
ProBuilderMesh
––! /
,
––/ 0
HashSet
––1 8
<
––8 9
Edge
––9 =
>
––= >
>
––> ?
PickEdgesInRect
––@ O
(
––O P
Camera
—— 
camera
—— 
,
—— 
Rect
““ 

pickerRect
““ 
,
““ 
IList
”” 
<
”” 
ProBuilderMesh
””  
>
””  !
	selection
””" +
,
””+ ,
bool
‘‘ 
doDepthTest
‘‘ 
,
‘‘ 
int
’’  
renderTextureWidth
’’ "
=
’’# $
-
’’% &
$num
’’& '
,
’’' (
int
÷÷ !
renderTextureHeight
÷÷ #
=
÷÷$ %
-
÷÷& '
$num
÷÷' (
)
÷÷( )
{
◊◊ 	
var
ÿÿ 
selected
ÿÿ 
=
ÿÿ 
new
ÿÿ 

Dictionary
ÿÿ )
<
ÿÿ) *
ProBuilderMesh
ÿÿ* 8
,
ÿÿ8 9
HashSet
ÿÿ: A
<
ÿÿA B
Edge
ÿÿB F
>
ÿÿF G
>
ÿÿG H
(
ÿÿH I
)
ÿÿI J
;
ÿÿJ K

Dictionary
ﬁﬁ 
<
ﬁﬁ 
uint
ﬁﬁ 
,
ﬁﬁ 
SimpleTuple
ﬁﬁ (
<
ﬁﬁ( )
ProBuilderMesh
ﬁﬁ) 7
,
ﬁﬁ7 8
Edge
ﬁﬁ9 =
>
ﬁﬁ= >
>
ﬁﬁ> ?
map
ﬁﬁ@ C
;
ﬁﬁC D
	Texture2D
ﬂﬂ 
tex
ﬂﬂ 
=
ﬂﬂ *
RenderSelectionPickerTexture
ﬂﬂ 8
(
ﬂﬂ8 9
camera
ﬂﬂ9 ?
,
ﬂﬂ? @
	selection
ﬂﬂA J
,
ﬂﬂJ K
doDepthTest
ﬂﬂL W
,
ﬂﬂW X
out
ﬂﬂY \
map
ﬂﬂ] `
,
ﬂﬂ` a 
renderTextureWidth
ﬂﬂb t
,
ﬂﬂt u"
renderTextureHeightﬂﬂv â
)ﬂﬂâ ä
;ﬂﬂä ã
Color32
‡‡ 
[
‡‡ 
]
‡‡ 
pix
‡‡ 
=
‡‡ 
tex
‡‡ 
.
‡‡  
GetPixels32
‡‡  +
(
‡‡+ ,
)
‡‡, -
;
‡‡- .
int
ÊÊ 
ox
ÊÊ 
=
ÊÊ 
System
ÊÊ 
.
ÊÊ 
Math
ÊÊ  
.
ÊÊ  !
Max
ÊÊ! $
(
ÊÊ$ %
$num
ÊÊ% &
,
ÊÊ& '
Mathf
ÊÊ( -
.
ÊÊ- .

FloorToInt
ÊÊ. 8
(
ÊÊ8 9

pickerRect
ÊÊ9 C
.
ÊÊC D
x
ÊÊD E
)
ÊÊE F
)
ÊÊF G
;
ÊÊG H
int
ÁÁ 
oy
ÁÁ 
=
ÁÁ 
System
ÁÁ 
.
ÁÁ 
Math
ÁÁ  
.
ÁÁ  !
Max
ÁÁ! $
(
ÁÁ$ %
$num
ÁÁ% &
,
ÁÁ& '
Mathf
ÁÁ( -
.
ÁÁ- .

FloorToInt
ÁÁ. 8
(
ÁÁ8 9
(
ÁÁ9 :
tex
ÁÁ: =
.
ÁÁ= >
height
ÁÁ> D
-
ÁÁE F

pickerRect
ÁÁG Q
.
ÁÁQ R
y
ÁÁR S
)
ÁÁS T
-
ÁÁU V

pickerRect
ÁÁW a
.
ÁÁa b
height
ÁÁb h
)
ÁÁh i
)
ÁÁi j
;
ÁÁj k
int
ËË 

imageWidth
ËË 
=
ËË 
tex
ËË  
.
ËË  !
width
ËË! &
;
ËË& '
int
ÈÈ 
imageHeight
ÈÈ 
=
ÈÈ 
tex
ÈÈ !
.
ÈÈ! "
height
ÈÈ" (
;
ÈÈ( )
int
ÍÍ 
width
ÍÍ 
=
ÍÍ 
Mathf
ÍÍ 
.
ÍÍ 

FloorToInt
ÍÍ (
(
ÍÍ( )

pickerRect
ÍÍ) 3
.
ÍÍ3 4
width
ÍÍ4 9
)
ÍÍ9 :
;
ÍÍ: ;
int
ÎÎ 
height
ÎÎ 
=
ÎÎ 
Mathf
ÎÎ 
.
ÎÎ 

FloorToInt
ÎÎ )
(
ÎÎ) *

pickerRect
ÎÎ* 4
.
ÎÎ4 5
height
ÎÎ5 ;
)
ÎÎ; <
;
ÎÎ< =
UObject
ÏÏ 
.
ÏÏ 
DestroyImmediate
ÏÏ $
(
ÏÏ$ %
tex
ÏÏ% (
)
ÏÏ( )
;
ÏÏ) *
var
ÓÓ 

pixelCount
ÓÓ 
=
ÓÓ 
new
ÓÓ  

Dictionary
ÓÓ! +
<
ÓÓ+ ,
uint
ÓÓ, 0
,
ÓÓ0 1
uint
ÓÓ2 6
>
ÓÓ6 7
(
ÓÓ7 8
)
ÓÓ8 9
;
ÓÓ9 :
for
 
(
 
int
 
y
 
=
 
oy
 
;
 
y
 
<
  
System
! '
.
' (
Math
( ,
.
, -
Min
- 0
(
0 1
oy
1 3
+
4 5
height
6 <
,
< =
imageHeight
> I
)
I J
;
J K
y
L M
++
M O
)
O P
{
ÒÒ 
for
ÚÚ 
(
ÚÚ 
int
ÚÚ 
x
ÚÚ 
=
ÚÚ 
ox
ÚÚ 
;
ÚÚ  
x
ÚÚ! "
<
ÚÚ# $
System
ÚÚ% +
.
ÚÚ+ ,
Math
ÚÚ, 0
.
ÚÚ0 1
Min
ÚÚ1 4
(
ÚÚ4 5
ox
ÚÚ5 7
+
ÚÚ8 9
width
ÚÚ: ?
,
ÚÚ? @

imageWidth
ÚÚA K
)
ÚÚK L
;
ÚÚL M
x
ÚÚN O
++
ÚÚO Q
)
ÚÚQ R
{
ÛÛ 
uint
˜˜ 
v
˜˜ 
=
˜˜ 

DecodeRGBA
˜˜ '
(
˜˜' (
pix
˜˜( +
[
˜˜+ ,
y
˜˜, -
*
˜˜. /

imageWidth
˜˜0 :
+
˜˜; <
x
˜˜= >
]
˜˜> ?
)
˜˜? @
;
˜˜@ A
if
˘˘ 
(
˘˘ 
v
˘˘ 
==
˘˘ 
k_PickerHashNone
˘˘ -
||
˘˘. 0
v
˘˘1 2
==
˘˘3 5
k_PickerHashMax
˘˘6 E
)
˘˘E F
continue
˙˙  
;
˙˙  !
if
¸¸ 
(
¸¸ 
!
¸¸ 

pixelCount
¸¸ #
.
¸¸# $
ContainsKey
¸¸$ /
(
¸¸/ 0
v
¸¸0 1
)
¸¸1 2
)
¸¸2 3

pixelCount
˝˝ "
.
˝˝" #
Add
˝˝# &
(
˝˝& '
v
˝˝' (
,
˝˝( )
$num
˝˝* +
)
˝˝+ ,
;
˝˝, -
else
˛˛ 

pixelCount
ˇˇ "
[
ˇˇ" #
v
ˇˇ# $
]
ˇˇ$ %
=
ˇˇ& '

pixelCount
ˇˇ( 2
[
ˇˇ2 3
v
ˇˇ3 4
]
ˇˇ4 5
+
ˇˇ6 7
$num
ˇˇ8 9
;
ˇˇ9 :
}
ÄÄ 
}
ÅÅ 
foreach
ÉÉ 
(
ÉÉ 
var
ÉÉ 
kvp
ÉÉ 
in
ÉÉ 

pixelCount
ÉÉ  *
)
ÉÉ* +
{
ÑÑ 
SimpleTuple
ÖÖ 
<
ÖÖ 
ProBuilderMesh
ÖÖ *
,
ÖÖ* +
Edge
ÖÖ, 0
>
ÖÖ0 1
hit
ÖÖ2 5
;
ÖÖ5 6
if
áá 
(
áá 
kvp
áá 
.
áá 
Value
áá 
>
áá .
 k_MinEdgePixelsForValidSelection
áá  @
&&
ááA C
map
ááD G
.
ááG H
TryGetValue
ááH S
(
ááS T
kvp
ááT W
.
ááW X
Key
ááX [
,
áá[ \
out
áá] `
hit
ááa d
)
áád e
)
ááe f
{
àà 
HashSet
ââ 
<
ââ 
Edge
ââ  
>
ââ  !
edges
ââ" '
=
ââ( )
null
ââ* .
;
ââ. /
if
ãã 
(
ãã 
selected
ãã  
.
ãã  !
TryGetValue
ãã! ,
(
ãã, -
hit
ãã- 0
.
ãã0 1
item1
ãã1 6
,
ãã6 7
out
ãã8 ;
edges
ãã< A
)
ããA B
)
ããB C
edges
åå 
.
åå 
Add
åå !
(
åå! "
hit
åå" %
.
åå% &
item2
åå& +
)
åå+ ,
;
åå, -
else
çç 
selected
éé  
.
éé  !
Add
éé! $
(
éé$ %
hit
éé% (
.
éé( )
item1
éé) .
,
éé. /
new
éé0 3
HashSet
éé4 ;
<
éé; <
Edge
éé< @
>
éé@ A
(
ééA B
)
ééB C
{
ééD E
hit
ééE H
.
ééH I
item2
ééI N
}
ééN O
)
ééO P
;
ééP Q
}
èè 
}
êê 
return
†† 
selected
†† 
;
†† 
}
°° 	
internal
¨¨ 
static
¨¨ 
	Texture2D
¨¨ !*
RenderSelectionPickerTexture
¨¨" >
(
¨¨> ?
Camera
≠≠ 
camera
≠≠ 
,
≠≠ 
IList
ÆÆ 
<
ÆÆ 
ProBuilderMesh
ÆÆ  
>
ÆÆ  !
	selection
ÆÆ" +
,
ÆÆ+ ,
out
ØØ 

Dictionary
ØØ 
<
ØØ 
uint
ØØ 
,
ØØ  
SimpleTuple
ØØ! ,
<
ØØ, -
ProBuilderMesh
ØØ- ;
,
ØØ; <
Face
ØØ= A
>
ØØA B
>
ØØB C
map
ØØD G
,
ØØG H
int
∞∞ 
width
∞∞ 
=
∞∞ 
-
∞∞ 
$num
∞∞ 
,
∞∞ 
int
±± 
height
±± 
=
±± 
-
±± 
$num
±± 
)
±± 
{
≤≤ 	
var
≥≥ 
pickerObjects
≥≥ 
=
≥≥ (
GenerateFacePickingObjects
≥≥  :
(
≥≥: ;
	selection
≥≥; D
,
≥≥D E
out
≥≥F I
map
≥≥J M
)
≥≥M N
;
≥≥N O
BuiltinMaterials
µµ 
.
µµ  
facePickerMaterial
µµ /
.
µµ/ 0
SetColor
µµ0 8
(
µµ8 9.
 k_FacePickerOcclusionTintUniform
µµ9 Y
,
µµY Z
k_Whitef
µµ[ c
)
µµc d
;
µµd e
	Texture2D
∑∑ 
tex
∑∑ 
=
∑∑ 
pickerRenderer
∑∑ *
.
∑∑* +!
RenderLookupTexture
∑∑+ >
(
∑∑> ?
camera
∑∑? E
,
∑∑E F
BuiltinMaterials
∑∑G W
.
∑∑W X#
selectionPickerShader
∑∑X m
,
∑∑m n
$str∑∑o Å
,∑∑Å Ç
width∑∑É à
,∑∑à â
height∑∑ä ê
)∑∑ê ë
;∑∑ë í
foreach
ππ 
(
ππ 

GameObject
ππ 
go
ππ  "
in
ππ# %
pickerObjects
ππ& 3
)
ππ3 4
{
∫∫ 
UObject
ªª 
.
ªª 
DestroyImmediate
ªª (
(
ªª( )
go
ªª) +
.
ªª+ ,
GetComponent
ªª, 8
<
ªª8 9

MeshFilter
ªª9 C
>
ªªC D
(
ªªD E
)
ªªE F
.
ªªF G

sharedMesh
ªªG Q
)
ªªQ R
;
ªªR S
UObject
ºº 
.
ºº 
DestroyImmediate
ºº (
(
ºº( )
go
ºº) +
)
ºº+ ,
;
ºº, -
}
ΩΩ 
return
øø 
tex
øø 
;
øø 
}
¿¿ 	
internal
ÃÃ 
static
ÃÃ 
	Texture2D
ÃÃ !*
RenderSelectionPickerTexture
ÃÃ" >
(
ÃÃ> ?
Camera
ÕÕ 
camera
ÕÕ 
,
ÕÕ 
IList
ŒŒ 
<
ŒŒ 
ProBuilderMesh
ŒŒ  
>
ŒŒ  !
	selection
ŒŒ" +
,
ŒŒ+ ,
bool
œœ 
doDepthTest
œœ 
,
œœ 
out
–– 

Dictionary
–– 
<
–– 
uint
–– 
,
––  
SimpleTuple
––! ,
<
––, -
ProBuilderMesh
––- ;
,
––; <
int
––= @
>
––@ A
>
––A B
map
––C F
,
––F G
int
—— 
width
—— 
=
—— 
-
—— 
$num
—— 
,
—— 
int
““ 
height
““ 
=
““ 
-
““ 
$num
““ 
)
““ 
{
”” 	

GameObject
‘‘ 
[
‘‘ 
]
‘‘ 
depthObjects
‘‘ %
,
‘‘% &
pickerObjects
‘‘' 4
;
‘‘4 5*
GenerateVertexPickingObjects
÷÷ (
(
÷÷( )
	selection
÷÷) 2
,
÷÷2 3
doDepthTest
÷÷4 ?
,
÷÷? @
out
÷÷A D
map
÷÷E H
,
÷÷H I
out
÷÷J M
depthObjects
÷÷N Z
,
÷÷Z [
out
÷÷\ _
pickerObjects
÷÷` m
)
÷÷m n
;
÷÷n o
BuiltinMaterials
ÿÿ 
.
ÿÿ  
facePickerMaterial
ÿÿ /
.
ÿÿ/ 0
SetColor
ÿÿ0 8
(
ÿÿ8 9.
 k_FacePickerOcclusionTintUniform
ÿÿ9 Y
,
ÿÿY Z
k_Blackf
ÿÿ[ c
)
ÿÿc d
;
ÿÿd e
	Texture2D
⁄⁄ 
tex
⁄⁄ 
=
⁄⁄ 
pickerRenderer
⁄⁄ *
.
⁄⁄* +!
RenderLookupTexture
⁄⁄+ >
(
⁄⁄> ?
camera
⁄⁄? E
,
⁄⁄E F
BuiltinMaterials
⁄⁄G W
.
⁄⁄W X#
selectionPickerShader
⁄⁄X m
,
⁄⁄m n
$str⁄⁄o Å
,⁄⁄Å Ç
width⁄⁄É à
,⁄⁄à â
height⁄⁄ä ê
)⁄⁄ê ë
;⁄⁄ë í
for
‹‹ 
(
‹‹ 
int
‹‹ 
i
‹‹ 
=
‹‹ 
$num
‹‹ 
,
‹‹ 
c
‹‹ 
=
‹‹ 
pickerObjects
‹‹  -
.
‹‹- .
Length
‹‹. 4
;
‹‹4 5
i
‹‹6 7
<
‹‹8 9
c
‹‹: ;
;
‹‹; <
i
‹‹= >
++
‹‹> @
)
‹‹@ A
{
›› 
UObject
ﬁﬁ 
.
ﬁﬁ 
DestroyImmediate
ﬁﬁ (
(
ﬁﬁ( )
pickerObjects
ﬁﬁ) 6
[
ﬁﬁ6 7
i
ﬁﬁ7 8
]
ﬁﬁ8 9
.
ﬁﬁ9 :
GetComponent
ﬁﬁ: F
<
ﬁﬁF G

MeshFilter
ﬁﬁG Q
>
ﬁﬁQ R
(
ﬁﬁR S
)
ﬁﬁS T
.
ﬁﬁT U

sharedMesh
ﬁﬁU _
)
ﬁﬁ_ `
;
ﬁﬁ` a
UObject
ﬂﬂ 
.
ﬂﬂ 
DestroyImmediate
ﬂﬂ (
(
ﬂﬂ( )
pickerObjects
ﬂﬂ) 6
[
ﬂﬂ6 7
i
ﬂﬂ7 8
]
ﬂﬂ8 9
)
ﬂﬂ9 :
;
ﬂﬂ: ;
}
‡‡ 
if
‚‚ 
(
‚‚ 
doDepthTest
‚‚ 
)
‚‚ 
{
„„ 
for
‰‰ 
(
‰‰ 
int
‰‰ 
i
‰‰ 
=
‰‰ 
$num
‰‰ 
,
‰‰ 
c
‰‰  !
=
‰‰" #
depthObjects
‰‰$ 0
.
‰‰0 1
Length
‰‰1 7
;
‰‰7 8
i
‰‰9 :
<
‰‰; <
c
‰‰= >
;
‰‰> ?
i
‰‰@ A
++
‰‰A C
)
‰‰C D
{
ÂÂ 
UObject
ÊÊ 
.
ÊÊ 
DestroyImmediate
ÊÊ ,
(
ÊÊ, -
depthObjects
ÊÊ- 9
[
ÊÊ9 :
i
ÊÊ: ;
]
ÊÊ; <
)
ÊÊ< =
;
ÊÊ= >
}
ÁÁ 
}
ËË 
return
ÍÍ 
tex
ÍÍ 
;
ÍÍ 
}
ÎÎ 	
internal
˜˜ 
static
˜˜ 
	Texture2D
˜˜ !*
RenderSelectionPickerTexture
˜˜" >
(
˜˜> ?
Camera
¯¯ 
camera
¯¯ 
,
¯¯ 
IList
˘˘ 
<
˘˘ 
ProBuilderMesh
˘˘  
>
˘˘  !
	selection
˘˘" +
,
˘˘+ ,
bool
˙˙ 
doDepthTest
˙˙ 
,
˙˙ 
out
˚˚ 

Dictionary
˚˚ 
<
˚˚ 
uint
˚˚ 
,
˚˚  
SimpleTuple
˚˚! ,
<
˚˚, -
ProBuilderMesh
˚˚- ;
,
˚˚; <
Edge
˚˚= A
>
˚˚A B
>
˚˚B C
map
˚˚D G
,
˚˚G H
int
¸¸ 
width
¸¸ 
=
¸¸ 
-
¸¸ 
$num
¸¸ 
,
¸¸ 
int
˝˝ 
height
˝˝ 
=
˝˝ 
-
˝˝ 
$num
˝˝ 
)
˝˝ 
{
˛˛ 	

GameObject
ˇˇ 
[
ˇˇ 
]
ˇˇ 
depthObjects
ˇˇ %
,
ˇˇ% &
pickerObjects
ˇˇ' 4
;
ˇˇ4 5(
GenerateEdgePickingObjects
ÄÄ &
(
ÄÄ& '
	selection
ÄÄ' 0
,
ÄÄ0 1
doDepthTest
ÄÄ2 =
,
ÄÄ= >
out
ÄÄ? B
map
ÄÄC F
,
ÄÄF G
out
ÄÄH K
depthObjects
ÄÄL X
,
ÄÄX Y
out
ÄÄZ ]
pickerObjects
ÄÄ^ k
)
ÄÄk l
;
ÄÄl m
BuiltinMaterials
ÇÇ 
.
ÇÇ  
facePickerMaterial
ÇÇ /
.
ÇÇ/ 0
SetColor
ÇÇ0 8
(
ÇÇ8 9.
 k_FacePickerOcclusionTintUniform
ÇÇ9 Y
,
ÇÇY Z
k_Blackf
ÇÇ[ c
)
ÇÇc d
;
ÇÇd e
	Texture2D
ÑÑ 
tex
ÑÑ 
=
ÑÑ 
pickerRenderer
ÑÑ *
.
ÑÑ* +!
RenderLookupTexture
ÑÑ+ >
(
ÑÑ> ?
camera
ÑÑ? E
,
ÑÑE F
BuiltinMaterials
ÑÑG W
.
ÑÑW X#
selectionPickerShader
ÑÑX m
,
ÑÑm n
$strÑÑo Å
,ÑÑÅ Ç
widthÑÑÉ à
,ÑÑà â
heightÑÑä ê
)ÑÑê ë
;ÑÑë í
for
ÜÜ 
(
ÜÜ 
int
ÜÜ 
i
ÜÜ 
=
ÜÜ 
$num
ÜÜ 
,
ÜÜ 
c
ÜÜ 
=
ÜÜ 
pickerObjects
ÜÜ  -
.
ÜÜ- .
Length
ÜÜ. 4
;
ÜÜ4 5
i
ÜÜ6 7
<
ÜÜ8 9
c
ÜÜ: ;
;
ÜÜ; <
i
ÜÜ= >
++
ÜÜ> @
)
ÜÜ@ A
{
áá 
UObject
àà 
.
àà 
DestroyImmediate
àà (
(
àà( )
pickerObjects
àà) 6
[
àà6 7
i
àà7 8
]
àà8 9
.
àà9 :
GetComponent
àà: F
<
ààF G

MeshFilter
ààG Q
>
ààQ R
(
ààR S
)
ààS T
.
ààT U

sharedMesh
ààU _
)
àà_ `
;
àà` a
UObject
ââ 
.
ââ 
DestroyImmediate
ââ (
(
ââ( )
pickerObjects
ââ) 6
[
ââ6 7
i
ââ7 8
]
ââ8 9
)
ââ9 :
;
ââ: ;
}
ää 
if
åå 
(
åå 
doDepthTest
åå 
)
åå 
{
çç 
for
éé 
(
éé 
int
éé 
i
éé 
=
éé 
$num
éé 
,
éé 
c
éé  !
=
éé" #
depthObjects
éé$ 0
.
éé0 1
Length
éé1 7
;
éé7 8
i
éé9 :
<
éé; <
c
éé= >
;
éé> ?
i
éé@ A
++
ééA C
)
ééC D
{
èè 
UObject
êê 
.
êê 
DestroyImmediate
êê ,
(
êê, -
depthObjects
êê- 9
[
êê9 :
i
êê: ;
]
êê; <
)
êê< =
;
êê= >
}
ëë 
}
íí 
return
ìì 
tex
ìì 
;
ìì 
}
îî 	
static
ññ 

GameObject
ññ 
[
ññ 
]
ññ (
GenerateFacePickingObjects
ññ 6
(
ññ6 7
IList
óó 
<
óó 
ProBuilderMesh
óó  
>
óó  !
	selection
óó" +
,
óó+ ,
out
òò 

Dictionary
òò 
<
òò 
uint
òò 
,
òò  
SimpleTuple
òò! ,
<
òò, -
ProBuilderMesh
òò- ;
,
òò; <
Face
òò= A
>
òòA B
>
òòB C
map
òòD G
)
òòG H
{
ôô 	
int
öö 
selectionCount
öö 
=
öö  
	selection
öö! *
.
öö* +
Count
öö+ 0
;
öö0 1

GameObject
õõ 
[
õõ 
]
õõ 
pickerObjects
õõ &
=
õõ' (
new
õõ) ,

GameObject
õõ- 7
[
õõ7 8
selectionCount
õõ8 F
]
õõF G
;
õõG H
map
úú 
=
úú 
new
úú 

Dictionary
úú  
<
úú  !
uint
úú! %
,
úú% &
SimpleTuple
úú' 2
<
úú2 3
ProBuilderMesh
úú3 A
,
úúA B
Face
úúC G
>
úúG H
>
úúH I
(
úúI J
)
úúJ K
;
úúK L
uint
ûû 
index
ûû 
=
ûû 
$num
ûû 
;
ûû 
for
†† 
(
†† 
int
†† 
i
†† 
=
†† 
$num
†† 
;
†† 
i
†† 
<
†† 
selectionCount
††  .
;
††. /
i
††0 1
++
††1 3
)
††3 4
{
°° 
var
¢¢ 
pb
¢¢ 
=
¢¢ 
	selection
¢¢ "
[
¢¢" #
i
¢¢# $
]
¢¢$ %
;
¢¢% &

GameObject
§§ 
go
§§ 
=
§§ 
InternalUtility
§§  /
.
§§/ 0*
EmptyGameObjectWithTransform
§§0 L
(
§§L M
pb
§§M O
.
§§O P
	transform
§§P Y
)
§§Y Z
;
§§Z [
go
•• 
.
•• 
name
•• 
=
•• 
pb
•• 
.
•• 
name
•• !
+
••" #
$str
••$ 8
;
••8 9
Mesh
ßß 
m
ßß 
=
ßß 
new
ßß 
Mesh
ßß !
(
ßß! "
)
ßß" #
;
ßß# $
m
®® 
.
®® 
vertices
®® 
=
®® 
pb
®® 
.
®®  
positionsInternal
®®  1
;
®®1 2
m
©© 
.
©© 
	triangles
©© 
=
©© 
pb
©©  
.
©©  !
facesInternal
©©! .
.
©©. /

SelectMany
©©/ 9
(
©©9 :
x
©©: ;
=>
©©< >
x
©©? @
.
©©@ A
indexesInternal
©©A P
)
©©P Q
.
©©Q R
ToArray
©©R Y
(
©©Y Z
)
©©Z [
;
©©[ \
Color32
™™ 
[
™™ 
]
™™ 
colors
™™  
=
™™! "
new
™™# &
Color32
™™' .
[
™™. /
m
™™/ 0
.
™™0 1
vertexCount
™™1 <
]
™™< =
;
™™= >
foreach
¨¨ 
(
¨¨ 
Face
¨¨ 
f
¨¨ 
in
¨¨  "
pb
¨¨# %
.
¨¨% &
facesInternal
¨¨& 3
)
¨¨3 4
{
≠≠ 
Color32
ÆÆ 
color
ÆÆ !
=
ÆÆ" #

EncodeRGBA
ÆÆ$ .
(
ÆÆ. /
index
ÆÆ/ 4
++
ÆÆ4 6
)
ÆÆ6 7
;
ÆÆ7 8
map
ØØ 
.
ØØ 
Add
ØØ 
(
ØØ 

DecodeRGBA
ØØ &
(
ØØ& '
color
ØØ' ,
)
ØØ, -
,
ØØ- .
new
ØØ/ 2
SimpleTuple
ØØ3 >
<
ØØ> ?
ProBuilderMesh
ØØ? M
,
ØØM N
Face
ØØO S
>
ØØS T
(
ØØT U
pb
ØØU W
,
ØØW X
f
ØØY Z
)
ØØZ [
)
ØØ[ \
;
ØØ\ ]
for
±± 
(
±± 
int
±± 
n
±± 
=
±±  
$num
±±! "
;
±±" #
n
±±$ %
<
±±& '
f
±±( )
.
±±) *%
distinctIndexesInternal
±±* A
.
±±A B
Length
±±B H
;
±±H I
n
±±J K
++
±±K M
)
±±M N
colors
≤≤ 
[
≤≤ 
f
≤≤  
.
≤≤  !%
distinctIndexesInternal
≤≤! 8
[
≤≤8 9
n
≤≤9 :
]
≤≤: ;
]
≤≤; <
=
≤≤= >
color
≤≤? D
;
≤≤D E
}
≥≥ 
m
µµ 
.
µµ 
colors32
µµ 
=
µµ 
colors
µµ #
;
µµ# $
go
∑∑ 
.
∑∑ 
AddComponent
∑∑ 
<
∑∑  

MeshFilter
∑∑  *
>
∑∑* +
(
∑∑+ ,
)
∑∑, -
.
∑∑- .

sharedMesh
∑∑. 8
=
∑∑9 :
m
∑∑; <
;
∑∑< =
go
∏∏ 
.
∏∏ 
AddComponent
∏∏ 
<
∏∏  
MeshRenderer
∏∏  ,
>
∏∏, -
(
∏∏- .
)
∏∏. /
.
∏∏/ 0
sharedMaterial
∏∏0 >
=
∏∏? @
BuiltinMaterials
∏∏A Q
.
∏∏Q R 
facePickerMaterial
∏∏R d
;
∏∏d e
pickerObjects
∫∫ 
[
∫∫ 
i
∫∫ 
]
∫∫  
=
∫∫! "
go
∫∫# %
;
∫∫% &
}
ªª 
return
ΩΩ 
pickerObjects
ΩΩ  
;
ΩΩ  !
}
ææ 	
static
¿¿ 
void
¿¿ *
GenerateVertexPickingObjects
¿¿ 0
(
¿¿0 1
IList
¡¡ 
<
¡¡ 
ProBuilderMesh
¡¡  
>
¡¡  !
	selection
¡¡" +
,
¡¡+ ,
bool
¬¬ 
doDepthTest
¬¬ 
,
¬¬ 
out
√√ 

Dictionary
√√ 
<
√√ 
uint
√√ 
,
√√  
SimpleTuple
√√! ,
<
√√, -
ProBuilderMesh
√√- ;
,
√√; <
int
√√= @
>
√√@ A
>
√√A B
map
√√C F
,
√√F G
out
ƒƒ 

GameObject
ƒƒ 
[
ƒƒ 
]
ƒƒ 
depthObjects
ƒƒ )
,
ƒƒ) *
out
≈≈ 

GameObject
≈≈ 
[
≈≈ 
]
≈≈ 
pickerObjects
≈≈ *
)
≈≈* +
{
∆∆ 	
map
«« 
=
«« 
new
«« 

Dictionary
««  
<
««  !
uint
««! %
,
««% &
SimpleTuple
««' 2
<
««2 3
ProBuilderMesh
««3 A
,
««A B
int
««C F
>
««F G
>
««G H
(
««H I
)
««I J
;
««J K
uint
ÀÀ 
index
ÀÀ 
=
ÀÀ 
$num
ÀÀ 
;
ÀÀ 
int
ÃÃ 
selectionCount
ÃÃ 
=
ÃÃ  
	selection
ÃÃ! *
.
ÃÃ* +
Count
ÃÃ+ 0
;
ÃÃ0 1
pickerObjects
ÕÕ 
=
ÕÕ 
new
ÕÕ 

GameObject
ÕÕ  *
[
ÕÕ* +
selectionCount
ÕÕ+ 9
]
ÕÕ9 :
;
ÕÕ: ;
for
œœ 
(
œœ 
int
œœ 
i
œœ 
=
œœ 
$num
œœ 
;
œœ 
i
œœ 
<
œœ 
selectionCount
œœ  .
;
œœ. /
i
œœ0 1
++
œœ1 3
)
œœ3 4
{
–– 
var
““ 
pb
““ 
=
““ 
	selection
““ "
[
““" #
i
““# $
]
““$ %
;
““% &

GameObject
”” 
go
”” 
=
”” 
InternalUtility
””  /
.
””/ 0*
EmptyGameObjectWithTransform
””0 L
(
””L M
pb
””M O
.
””O P
	transform
””P Y
)
””Y Z
;
””Z [
go
‘‘ 
.
‘‘ 
name
‘‘ 
=
‘‘ 
pb
‘‘ 
.
‘‘ 
name
‘‘ !
+
‘‘" #
$str
‘‘$ ;
;
‘‘; <
go
’’ 
.
’’ 
AddComponent
’’ 
<
’’  

MeshFilter
’’  *
>
’’* +
(
’’+ ,
)
’’, -
.
’’- .

sharedMesh
’’. 8
=
’’9 :
BuildVertexMesh
’’; J
(
’’J K
pb
’’K M
,
’’M N
map
’’O R
,
’’R S
ref
’’T W
index
’’X ]
)
’’] ^
;
’’^ _
go
÷÷ 
.
÷÷ 
AddComponent
÷÷ 
<
÷÷  
MeshRenderer
÷÷  ,
>
÷÷, -
(
÷÷- .
)
÷÷. /
.
÷÷/ 0
sharedMaterial
÷÷0 >
=
÷÷? @
BuiltinMaterials
÷÷A Q
.
÷÷Q R"
vertexPickerMaterial
÷÷R f
;
÷÷f g
pickerObjects
◊◊ 
[
◊◊ 
i
◊◊ 
]
◊◊  
=
◊◊! "
go
◊◊# %
;
◊◊% &
}
ÿÿ 
if
⁄⁄ 
(
⁄⁄ 
doDepthTest
⁄⁄ 
)
⁄⁄ 
{
€€ 
depthObjects
‹‹ 
=
‹‹ 
new
‹‹ "

GameObject
‹‹# -
[
‹‹- .
selectionCount
‹‹. <
]
‹‹< =
;
‹‹= >
for
ﬂﬂ 
(
ﬂﬂ 
int
ﬂﬂ 
i
ﬂﬂ 
=
ﬂﬂ 
$num
ﬂﬂ 
;
ﬂﬂ 
i
ﬂﬂ  !
<
ﬂﬂ" #
selectionCount
ﬂﬂ$ 2
;
ﬂﬂ2 3
i
ﬂﬂ4 5
++
ﬂﬂ5 7
)
ﬂﬂ7 8
{
‡‡ 
var
·· 
pb
·· 
=
·· 
	selection
·· &
[
··& '
i
··' (
]
··( )
;
··) *

GameObject
‚‚ 
go
‚‚ !
=
‚‚" #
InternalUtility
‚‚$ 3
.
‚‚3 4*
EmptyGameObjectWithTransform
‚‚4 P
(
‚‚P Q
pb
‚‚Q S
.
‚‚S T
	transform
‚‚T ]
)
‚‚] ^
;
‚‚^ _
go
„„ 
.
„„ 
name
„„ 
=
„„ 
pb
„„  
.
„„  !
name
„„! %
+
„„& '
$str
„„( 8
;
„„8 9
go
‰‰ 
.
‰‰ 
AddComponent
‰‰ #
<
‰‰# $

MeshFilter
‰‰$ .
>
‰‰. /
(
‰‰/ 0
)
‰‰0 1
.
‰‰1 2

sharedMesh
‰‰2 <
=
‰‰= >
pb
‰‰? A
.
‰‰A B
mesh
‰‰B F
;
‰‰F G
go
ÂÂ 
.
ÂÂ 
AddComponent
ÂÂ #
<
ÂÂ# $
MeshRenderer
ÂÂ$ 0
>
ÂÂ0 1
(
ÂÂ1 2
)
ÂÂ2 3
.
ÂÂ3 4
sharedMaterial
ÂÂ4 B
=
ÂÂC D
BuiltinMaterials
ÂÂE U
.
ÂÂU V 
facePickerMaterial
ÂÂV h
;
ÂÂh i
depthObjects
ÊÊ  
[
ÊÊ  !
i
ÊÊ! "
]
ÊÊ" #
=
ÊÊ$ %
go
ÊÊ& (
;
ÊÊ( )
}
ÁÁ 
}
ËË 
else
ÈÈ 
{
ÍÍ 
depthObjects
ÎÎ 
=
ÎÎ 
null
ÎÎ #
;
ÎÎ# $
}
ÏÏ 
}
ÌÌ 	
static
ÔÔ 
void
ÔÔ (
GenerateEdgePickingObjects
ÔÔ .
(
ÔÔ. /
IList
 
<
 
ProBuilderMesh
  
>
  !
	selection
" +
,
+ ,
bool
ÒÒ 
doDepthTest
ÒÒ 
,
ÒÒ 
out
ÚÚ 

Dictionary
ÚÚ 
<
ÚÚ 
uint
ÚÚ 
,
ÚÚ  
SimpleTuple
ÚÚ! ,
<
ÚÚ, -
ProBuilderMesh
ÚÚ- ;
,
ÚÚ; <
Edge
ÚÚ= A
>
ÚÚA B
>
ÚÚB C
map
ÚÚD G
,
ÚÚG H
out
ÛÛ 

GameObject
ÛÛ 
[
ÛÛ 
]
ÛÛ 
depthObjects
ÛÛ )
,
ÛÛ) *
out
ÙÙ 

GameObject
ÙÙ 
[
ÙÙ 
]
ÙÙ 
pickerObjects
ÙÙ *
)
ÙÙ* +
{
ıı 	
map
ˆˆ 
=
ˆˆ 
new
ˆˆ 

Dictionary
ˆˆ  
<
ˆˆ  !
uint
ˆˆ! %
,
ˆˆ% &
SimpleTuple
ˆˆ' 2
<
ˆˆ2 3
ProBuilderMesh
ˆˆ3 A
,
ˆˆA B
Edge
ˆˆC G
>
ˆˆG H
>
ˆˆH I
(
ˆˆI J
)
ˆˆJ K
;
ˆˆK L
uint
¯¯ 
index
¯¯ 
=
¯¯ 
$num
¯¯ 
;
¯¯ 
int
˘˘ 
selectionCount
˘˘ 
=
˘˘  
	selection
˘˘! *
.
˘˘* +
Count
˘˘+ 0
;
˘˘0 1
pickerObjects
˙˙ 
=
˙˙ 
new
˙˙ 

GameObject
˙˙  *
[
˙˙* +
selectionCount
˙˙+ 9
]
˙˙9 :
;
˙˙: ;
for
¸¸ 
(
¸¸ 
int
¸¸ 
i
¸¸ 
=
¸¸ 
$num
¸¸ 
;
¸¸ 
i
¸¸ 
<
¸¸ 
selectionCount
¸¸  .
;
¸¸. /
i
¸¸0 1
++
¸¸1 3
)
¸¸3 4
{
˝˝ 
var
ˇˇ 
pb
ˇˇ 
=
ˇˇ 
	selection
ˇˇ "
[
ˇˇ" #
i
ˇˇ# $
]
ˇˇ$ %
;
ˇˇ% &

GameObject
ÄÄ 
go
ÄÄ 
=
ÄÄ 
InternalUtility
ÄÄ  /
.
ÄÄ/ 0*
EmptyGameObjectWithTransform
ÄÄ0 L
(
ÄÄL M
pb
ÄÄM O
.
ÄÄO P
	transform
ÄÄP Y
)
ÄÄY Z
;
ÄÄZ [
go
ÅÅ 
.
ÅÅ 
name
ÅÅ 
=
ÅÅ 
pb
ÅÅ 
.
ÅÅ 
name
ÅÅ !
+
ÅÅ" #
$str
ÅÅ$ 9
;
ÅÅ9 :
go
ÇÇ 
.
ÇÇ 
AddComponent
ÇÇ 
<
ÇÇ  

MeshFilter
ÇÇ  *
>
ÇÇ* +
(
ÇÇ+ ,
)
ÇÇ, -
.
ÇÇ- .

sharedMesh
ÇÇ. 8
=
ÇÇ9 :
BuildEdgeMesh
ÇÇ; H
(
ÇÇH I
pb
ÇÇI K
,
ÇÇK L
map
ÇÇM P
,
ÇÇP Q
ref
ÇÇR U
index
ÇÇV [
)
ÇÇ[ \
;
ÇÇ\ ]
go
ÉÉ 
.
ÉÉ 
AddComponent
ÉÉ 
<
ÉÉ  
MeshRenderer
ÉÉ  ,
>
ÉÉ, -
(
ÉÉ- .
)
ÉÉ. /
.
ÉÉ/ 0
sharedMaterial
ÉÉ0 >
=
ÉÉ? @
BuiltinMaterials
ÉÉA Q
.
ÉÉQ R 
edgePickerMaterial
ÉÉR d
;
ÉÉd e
pickerObjects
ÑÑ 
[
ÑÑ 
i
ÑÑ 
]
ÑÑ  
=
ÑÑ! "
go
ÑÑ# %
;
ÑÑ% &
}
ÖÖ 
if
áá 
(
áá 
doDepthTest
áá 
)
áá 
{
àà 
depthObjects
ââ 
=
ââ 
new
ââ "

GameObject
ââ# -
[
ââ- .
selectionCount
ââ. <
]
ââ< =
;
ââ= >
for
ãã 
(
ãã 
int
ãã 
i
ãã 
=
ãã 
$num
ãã 
;
ãã 
i
ãã  !
<
ãã" #
selectionCount
ãã$ 2
;
ãã2 3
i
ãã4 5
++
ãã5 7
)
ãã7 8
{
åå 
var
çç 
pb
çç 
=
çç 
	selection
çç &
[
çç& '
i
çç' (
]
çç( )
;
çç) *

GameObject
èè 
go
èè !
=
èè" #
InternalUtility
èè$ 3
.
èè3 4*
EmptyGameObjectWithTransform
èè4 P
(
èèP Q
pb
èèQ S
.
èèS T
	transform
èèT ]
)
èè] ^
;
èè^ _
go
êê 
.
êê 
name
êê 
=
êê 
pb
êê  
.
êê  !
name
êê! %
+
êê& '
$str
êê( 8
;
êê8 9
go
ëë 
.
ëë 
AddComponent
ëë #
<
ëë# $

MeshFilter
ëë$ .
>
ëë. /
(
ëë/ 0
)
ëë0 1
.
ëë1 2

sharedMesh
ëë2 <
=
ëë= >
pb
ëë? A
.
ëëA B
mesh
ëëB F
;
ëëF G
go
íí 
.
íí 
AddComponent
íí #
<
íí# $
MeshRenderer
íí$ 0
>
íí0 1
(
íí1 2
)
íí2 3
.
íí3 4
sharedMaterial
íí4 B
=
ííC D
BuiltinMaterials
ííE U
.
ííU V 
facePickerMaterial
ííV h
;
ííh i
depthObjects
ìì  
[
ìì  !
i
ìì! "
]
ìì" #
=
ìì$ %
go
ìì& (
;
ìì( )
}
îî 
}
ïï 
else
ññ 
{
óó 
depthObjects
òò 
=
òò 
null
òò #
;
òò# $
}
ôô 
}
öö 	
static
úú 
Mesh
úú 
BuildVertexMesh
úú #
(
úú# $
ProBuilderMesh
úú$ 2
pb
úú3 5
,
úú5 6

Dictionary
úú7 A
<
úúA B
uint
úúB F
,
úúF G
SimpleTuple
úúH S
<
úúS T
ProBuilderMesh
úúT b
,
úúb c
int
úúd g
>
úúg h
>
úúh i
map
úúj m
,
úúm n
ref
úúo r
uint
úús w
index
úúx }
)
úú} ~
{
ùù 	
int
ûû 
length
ûû 
=
ûû 
System
ûû 
.
ûû  
Math
ûû  $
.
ûû$ %
Min
ûû% (
(
ûû( )
pb
ûû) +
.
ûû+ ,$
sharedVerticesInternal
ûû, B
.
ûûB C
Length
ûûC I
,
ûûI J
ushort
ûûK Q
.
ûûQ R
MaxValue
ûûR Z
/
ûû[ \
$num
ûû] ^
-
ûû_ `
$num
ûûa b
)
ûûb c
;
ûûc d
Vector3
†† 
[
†† 
]
†† 
t_billboards
†† $
=
††, -
new
††. 1
Vector3
††2 9
[
††9 :
length
††: @
*
††A B
$num
††C D
]
††D E
;
††E F
Vector2
°° 
[
°° 
]
°° 
t_uvs
°° 
=
°°, -
new
°°. 1
Vector2
°°2 9
[
°°9 :
length
°°: @
*
°°A B
$num
°°C D
]
°°D E
;
°°E F
Vector2
¢¢ 
[
¢¢ 
]
¢¢ 
t_uv2
¢¢ 
=
¢¢, -
new
¢¢. 1
Vector2
¢¢2 9
[
¢¢9 :
length
¢¢: @
*
¢¢A B
$num
¢¢C D
]
¢¢D E
;
¢¢E F
Color
££ 
[
££ 
]
££ 
t_col
££ 
=
££, -
new
££. 1
Color
££2 7
[
££7 8
length
££8 >
*
££? @
$num
££A B
]
££B C
;
££C D
int
§§ 
[
§§ 
]
§§ 
t_tris
§§ 
=
§§, -
new
§§. 1
int
§§2 5
[
§§5 6
length
§§6 <
*
§§= >
$num
§§? @
]
§§@ A
;
§§A B
int
¶¶ 
n
¶¶ 
=
¶¶ 
$num
¶¶ 
;
¶¶ 
int
ßß 
t
ßß 
=
ßß 
$num
ßß 
;
ßß 
Vector3
©© 
up
©© 
=
©© 
Vector3
©©  
.
©©  !
up
©©! #
;
©©# $
Vector3
™™ 
right
™™ 
=
™™ 
Vector3
™™ #
.
™™# $
right
™™$ )
;
™™) *
for
¨¨ 
(
¨¨ 
int
¨¨ 
i
¨¨ 
=
¨¨ 
$num
¨¨ 
;
¨¨ 
i
¨¨ 
<
¨¨ 
length
¨¨  &
;
¨¨& '
i
¨¨( )
++
¨¨) +
)
¨¨+ ,
{
≠≠ 
Vector3
ÆÆ 
v
ÆÆ 
=
ÆÆ 
pb
ÆÆ 
.
ÆÆ 
positionsInternal
ÆÆ 0
[
ÆÆ0 1
pb
ÆÆ1 3
.
ÆÆ3 4$
sharedVerticesInternal
ÆÆ4 J
[
ÆÆJ K
i
ÆÆK L
]
ÆÆL M
[
ÆÆM N
$num
ÆÆN O
]
ÆÆO P
]
ÆÆP Q
;
ÆÆQ R
t_billboards
∞∞ 
[
∞∞ 
t
∞∞ 
+
∞∞  
$num
∞∞! "
]
∞∞" #
=
∞∞$ %
v
∞∞& '
;
∞∞' (
t_billboards
±± 
[
±± 
t
±± 
+
±±  
$num
±±! "
]
±±" #
=
±±$ %
v
±±& '
;
±±' (
t_billboards
≤≤ 
[
≤≤ 
t
≤≤ 
+
≤≤  
$num
≤≤! "
]
≤≤" #
=
≤≤$ %
v
≤≤& '
;
≤≤' (
t_billboards
≥≥ 
[
≥≥ 
t
≥≥ 
+
≥≥  
$num
≥≥! "
]
≥≥" #
=
≥≥$ %
v
≥≥& '
;
≥≥' (
t_uvs
µµ 
[
µµ 
t
µµ 
+
µµ 
$num
µµ 
]
µµ 
=
µµ 
Vector3
µµ &
.
µµ& '
zero
µµ' +
;
µµ+ ,
t_uvs
∂∂ 
[
∂∂ 
t
∂∂ 
+
∂∂ 
$num
∂∂ 
]
∂∂ 
=
∂∂ 
Vector3
∂∂ &
.
∂∂& '
right
∂∂' ,
;
∂∂, -
t_uvs
∑∑ 
[
∑∑ 
t
∑∑ 
+
∑∑ 
$num
∑∑ 
]
∑∑ 
=
∑∑ 
Vector3
∑∑ &
.
∑∑& '
up
∑∑' )
;
∑∑) *
t_uvs
∏∏ 
[
∏∏ 
t
∏∏ 
+
∏∏ 
$num
∏∏ 
]
∏∏ 
=
∏∏ 
Vector3
∏∏ &
.
∏∏& '
one
∏∏' *
;
∏∏* +
t_uv2
∫∫ 
[
∫∫ 
t
∫∫ 
+
∫∫ 
$num
∫∫ 
]
∫∫ 
=
∫∫ 
-
∫∫  
up
∫∫  "
-
∫∫# $
right
∫∫% *
;
∫∫* +
t_uv2
ªª 
[
ªª 
t
ªª 
+
ªª 
$num
ªª 
]
ªª 
=
ªª 
-
ªª  
up
ªª  "
+
ªª# $
right
ªª% *
;
ªª* +
t_uv2
ºº 
[
ºº 
t
ºº 
+
ºº 
$num
ºº 
]
ºº 
=
ºº 
up
ºº  "
-
ºº# $
right
ºº% *
;
ºº* +
t_uv2
ΩΩ 
[
ΩΩ 
t
ΩΩ 
+
ΩΩ 
$num
ΩΩ 
]
ΩΩ 
=
ΩΩ 
up
ΩΩ  "
+
ΩΩ# $
right
ΩΩ% *
;
ΩΩ* +
t_tris
øø 
[
øø 
n
øø 
+
øø 
$num
øø 
]
øø 
=
øø 
t
øø  !
+
øø" #
$num
øø$ %
;
øø% &
t_tris
¿¿ 
[
¿¿ 
n
¿¿ 
+
¿¿ 
$num
¿¿ 
]
¿¿ 
=
¿¿ 
t
¿¿  !
+
¿¿" #
$num
¿¿$ %
;
¿¿% &
t_tris
¡¡ 
[
¡¡ 
n
¡¡ 
+
¡¡ 
$num
¡¡ 
]
¡¡ 
=
¡¡ 
t
¡¡  !
+
¡¡" #
$num
¡¡$ %
;
¡¡% &
t_tris
¬¬ 
[
¬¬ 
n
¬¬ 
+
¬¬ 
$num
¬¬ 
]
¬¬ 
=
¬¬ 
t
¬¬  !
+
¬¬" #
$num
¬¬$ %
;
¬¬% &
t_tris
√√ 
[
√√ 
n
√√ 
+
√√ 
$num
√√ 
]
√√ 
=
√√ 
t
√√  !
+
√√" #
$num
√√$ %
;
√√% &
t_tris
ƒƒ 
[
ƒƒ 
n
ƒƒ 
+
ƒƒ 
$num
ƒƒ 
]
ƒƒ 
=
ƒƒ 
t
ƒƒ  !
+
ƒƒ" #
$num
ƒƒ$ %
;
ƒƒ% &
Color32
∆∆ 
color
∆∆ 
=
∆∆ 

EncodeRGBA
∆∆  *
(
∆∆* +
index
∆∆+ 0
)
∆∆0 1
;
∆∆1 2
map
«« 
.
«« 
Add
«« 
(
«« 
index
«« 
++
«« 
,
««  
new
««! $
SimpleTuple
««% 0
<
««0 1
ProBuilderMesh
««1 ?
,
««? @
int
««A D
>
««D E
(
««E F
pb
««F H
,
««H I
i
««J K
)
««K L
)
««L M
;
««M N
t_col
…… 
[
…… 
t
…… 
+
…… 
$num
…… 
]
…… 
=
…… 
color
…… $
;
……$ %
t_col
   
[
   
t
   
+
   
$num
   
]
   
=
   
color
   $
;
  $ %
t_col
ÀÀ 
[
ÀÀ 
t
ÀÀ 
+
ÀÀ 
$num
ÀÀ 
]
ÀÀ 
=
ÀÀ 
color
ÀÀ $
;
ÀÀ$ %
t_col
ÃÃ 
[
ÃÃ 
t
ÃÃ 
+
ÃÃ 
$num
ÃÃ 
]
ÃÃ 
=
ÃÃ 
color
ÃÃ $
;
ÃÃ$ %
t
ŒŒ 
+=
ŒŒ 
$num
ŒŒ 
;
ŒŒ 
n
œœ 
+=
œœ 
$num
œœ 
;
œœ 
}
–– 
Mesh
““ 
mesh
““ 
=
““ 
new
““ 
Mesh
““  
(
““  !
)
““! "
;
““" #
mesh
”” 
.
”” 
name
”” 
=
”” 
$str
”” *
;
””* +
mesh
‘‘ 
.
‘‘ 
vertices
‘‘ 
=
‘‘ 
t_billboards
‘‘ (
;
‘‘( )
mesh
’’ 
.
’’ 
uv
’’ 
=
’’ 
t_uvs
’’ 
;
’’ 
mesh
÷÷ 
.
÷÷ 
uv2
÷÷ 
=
÷÷ 
t_uv2
÷÷ 
;
÷÷ 
mesh
◊◊ 
.
◊◊ 
colors
◊◊ 
=
◊◊ 
t_col
◊◊ 
;
◊◊  
mesh
ÿÿ 
.
ÿÿ 
	triangles
ÿÿ 
=
ÿÿ 
t_tris
ÿÿ #
;
ÿÿ# $
return
⁄⁄ 
mesh
⁄⁄ 
;
⁄⁄ 
}
€€ 	
static
›› 
Mesh
›› 
BuildEdgeMesh
›› !
(
››! "
ProBuilderMesh
››" 0
pb
››1 3
,
››3 4

Dictionary
››5 ?
<
››? @
uint
››@ D
,
››D E
SimpleTuple
››F Q
<
››Q R
ProBuilderMesh
››R `
,
››` a
Edge
››b f
>
››f g
>
››g h
map
››i l
,
››l m
ref
››n q
uint
››r v
index
››w |
)
››| }
{
ﬁﬁ 	
int
ﬂﬂ 
	edgeCount
ﬂﬂ 
=
ﬂﬂ 
$num
ﬂﬂ 
;
ﬂﬂ 
int
‡‡ 
	faceCount
‡‡ 
=
‡‡ 
pb
‡‡ 
.
‡‡ 
	faceCount
‡‡ (
;
‡‡( )
for
‚‚ 
(
‚‚ 
int
‚‚ 
i
‚‚ 
=
‚‚ 
$num
‚‚ 
;
‚‚ 
i
‚‚ 
<
‚‚ 
	faceCount
‚‚  )
;
‚‚) *
i
‚‚+ ,
++
‚‚, .
)
‚‚. /
	edgeCount
„„ 
+=
„„ 
pb
„„ 
.
„„  
facesInternal
„„  -
[
„„- .
i
„„. /
]
„„/ 0
.
„„0 1
edgesInternal
„„1 >
.
„„> ?
Length
„„? E
;
„„E F
int
ÂÂ 
elementCount
ÂÂ 
=
ÂÂ 
System
ÂÂ %
.
ÂÂ% &
Math
ÂÂ& *
.
ÂÂ* +
Min
ÂÂ+ .
(
ÂÂ. /
	edgeCount
ÂÂ/ 8
,
ÂÂ8 9
ushort
ÂÂ: @
.
ÂÂ@ A
MaxValue
ÂÂA I
/
ÂÂJ K
$num
ÂÂL M
-
ÂÂN O
$num
ÂÂP Q
)
ÂÂQ R
;
ÂÂR S
Vector3
ÁÁ 
[
ÁÁ 
]
ÁÁ 
	positions
ÁÁ 
=
ÁÁ  !
new
ÁÁ" %
Vector3
ÁÁ& -
[
ÁÁ- .
elementCount
ÁÁ. :
*
ÁÁ; <
$num
ÁÁ= >
]
ÁÁ> ?
;
ÁÁ? @
Color32
ËË 
[
ËË 
]
ËË 
color
ËË 
=
ËË 
new
ËË !
Color32
ËË" )
[
ËË) *
elementCount
ËË* 6
*
ËË7 8
$num
ËË9 :
]
ËË: ;
;
ËË; <
int
ÈÈ 
[
ÈÈ 
]
ÈÈ 
tris
ÈÈ 
=
ÈÈ 
new
ÈÈ 
int
ÈÈ  
[
ÈÈ  !
elementCount
ÈÈ! -
*
ÈÈ. /
$num
ÈÈ0 1
]
ÈÈ1 2
;
ÈÈ2 3
int
ÎÎ 
	edgeIndex
ÎÎ 
=
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
for
ÌÌ 
(
ÌÌ 
int
ÌÌ 
i
ÌÌ 
=
ÌÌ 
$num
ÌÌ 
;
ÌÌ 
i
ÌÌ 
<
ÌÌ 
	faceCount
ÌÌ  )
&&
ÌÌ* ,
	edgeIndex
ÌÌ- 6
<
ÌÌ7 8
elementCount
ÌÌ9 E
;
ÌÌE F
i
ÌÌG H
++
ÌÌH J
)
ÌÌJ K
{
ÓÓ 
for
ÔÔ 
(
ÔÔ 
int
ÔÔ 
n
ÔÔ 
=
ÔÔ 
$num
ÔÔ 
;
ÔÔ 
n
ÔÔ  !
<
ÔÔ" #
pb
ÔÔ$ &
.
ÔÔ& '
facesInternal
ÔÔ' 4
[
ÔÔ4 5
i
ÔÔ5 6
]
ÔÔ6 7
.
ÔÔ7 8
edgesInternal
ÔÔ8 E
.
ÔÔE F
Length
ÔÔF L
&&
ÔÔM O
	edgeIndex
ÔÔP Y
<
ÔÔZ [
elementCount
ÔÔ\ h
;
ÔÔh i
n
ÔÔj k
++
ÔÔk m
)
ÔÔm n
{
 
var
ÒÒ 
edge
ÒÒ 
=
ÒÒ 
pb
ÒÒ !
.
ÒÒ! "
facesInternal
ÒÒ" /
[
ÒÒ/ 0
i
ÒÒ0 1
]
ÒÒ1 2
.
ÒÒ2 3
edgesInternal
ÒÒ3 @
[
ÒÒ@ A
n
ÒÒA B
]
ÒÒB C
;
ÒÒC D
Vector3
ÛÛ 
a
ÛÛ 
=
ÛÛ 
pb
ÛÛ  "
.
ÛÛ" #
positionsInternal
ÛÛ# 4
[
ÛÛ4 5
edge
ÛÛ5 9
.
ÛÛ9 :
a
ÛÛ: ;
]
ÛÛ; <
;
ÛÛ< =
Vector3
ÙÙ 
b
ÙÙ 
=
ÙÙ 
pb
ÙÙ  "
.
ÙÙ" #
positionsInternal
ÙÙ# 4
[
ÙÙ4 5
edge
ÙÙ5 9
.
ÙÙ9 :
b
ÙÙ: ;
]
ÙÙ; <
;
ÙÙ< =
int
ıı 
positionIndex
ıı %
=
ıı& '
	edgeIndex
ıı( 1
*
ıı2 3
$num
ıı4 5
;
ıı5 6
	positions
˜˜ 
[
˜˜ 
positionIndex
˜˜ +
+
˜˜, -
$num
˜˜. /
]
˜˜/ 0
=
˜˜1 2
a
˜˜3 4
;
˜˜4 5
	positions
¯¯ 
[
¯¯ 
positionIndex
¯¯ +
+
¯¯, -
$num
¯¯. /
]
¯¯/ 0
=
¯¯1 2
b
¯¯3 4
;
¯¯4 5
Color32
˙˙ 
c
˙˙ 
=
˙˙ 

EncodeRGBA
˙˙  *
(
˙˙* +
index
˙˙+ 0
)
˙˙0 1
;
˙˙1 2
map
¸¸ 
.
¸¸ 
Add
¸¸ 
(
¸¸ 
index
¸¸ !
++
¸¸! #
,
¸¸# $
new
¸¸% (
SimpleTuple
¸¸) 4
<
¸¸4 5
ProBuilderMesh
¸¸5 C
,
¸¸C D
Edge
¸¸E I
>
¸¸I J
(
¸¸J K
pb
¸¸K M
,
¸¸M N
edge
¸¸O S
)
¸¸S T
)
¸¸T U
;
¸¸U V
color
˛˛ 
[
˛˛ 
positionIndex
˛˛ '
+
˛˛( )
$num
˛˛* +
]
˛˛+ ,
=
˛˛- .
c
˛˛/ 0
;
˛˛0 1
color
ˇˇ 
[
ˇˇ 
positionIndex
ˇˇ '
+
ˇˇ( )
$num
ˇˇ* +
]
ˇˇ+ ,
=
ˇˇ- .
c
ˇˇ/ 0
;
ˇˇ0 1
tris
ÅÅ 
[
ÅÅ 
positionIndex
ÅÅ &
+
ÅÅ' (
$num
ÅÅ) *
]
ÅÅ* +
=
ÅÅ, -
positionIndex
ÅÅ. ;
+
ÅÅ< =
$num
ÅÅ> ?
;
ÅÅ? @
tris
ÇÇ 
[
ÇÇ 
positionIndex
ÇÇ &
+
ÇÇ' (
$num
ÇÇ) *
]
ÇÇ* +
=
ÇÇ, -
positionIndex
ÇÇ. ;
+
ÇÇ< =
$num
ÇÇ> ?
;
ÇÇ? @
	edgeIndex
ÑÑ 
++
ÑÑ 
;
ÑÑ  
}
ÖÖ 
}
ÜÜ 
Mesh
àà 
mesh
àà 
=
àà 
new
àà 
Mesh
àà  
(
àà  !
)
àà! "
;
àà" #
mesh
ââ 
.
ââ 
name
ââ 
=
ââ 
$str
ââ (
;
ââ( )
mesh
ää 
.
ää 
vertices
ää 
=
ää 
	positions
ää %
;
ää% &
mesh
ãã 
.
ãã 
colors32
ãã 
=
ãã 
color
ãã !
;
ãã! "
mesh
åå 
.
åå 
subMeshCount
åå 
=
åå 
$num
åå  !
;
åå! "
mesh
çç 
.
çç 

SetIndices
çç 
(
çç 
tris
çç  
,
çç  !
MeshTopology
çç" .
.
çç. /
Lines
çç/ 4
,
çç4 5
$num
çç6 7
)
çç7 8
;
çç8 9
return
èè 
mesh
èè 
;
èè 
}
êê 	
public
óó 
static
óó 
uint
óó 

DecodeRGBA
óó %
(
óó% &
Color32
óó& -
color
óó. 3
)
óó3 4
{
òò 	
uint
ôô 
r
ôô 
=
ôô 
(
ôô 
uint
ôô 
)
ôô 
color
ôô  
.
ôô  !
r
ôô! "
;
ôô" #
uint
öö 
g
öö 
=
öö 
(
öö 
uint
öö 
)
öö 
color
öö  
.
öö  !
g
öö! "
;
öö" #
uint
õõ 
b
õõ 
=
õõ 
(
õõ 
uint
õõ 
)
õõ 
color
õõ  
.
õõ  !
b
õõ! "
;
õõ" #
if
ùù 
(
ùù 
System
ùù 
.
ùù 
BitConverter
ùù #
.
ùù# $
IsLittleEndian
ùù$ 2
)
ùù2 3
return
ûû 
r
ûû 
<<
ûû 
$num
ûû 
|
ûû  
g
ûû! "
<<
ûû# %
$num
ûû& '
|
ûû( )
b
ûû* +
;
ûû+ ,
else
üü 
return
†† 
r
†† 
<<
†† 
$num
†† 
|
††  
g
††! "
<<
††# %
$num
††& (
|
††) *
b
††+ ,
<<
††- /
$num
††0 1
;
††1 2
}
°° 	
public
®® 
static
®® 
Color32
®® 

EncodeRGBA
®® (
(
®®( )
uint
®®) -
hash
®®. 2
)
®®2 3
{
©© 	
if
¨¨ 
(
¨¨ 
System
¨¨ 
.
¨¨ 
BitConverter
¨¨ #
.
¨¨# $
IsLittleEndian
¨¨$ 2
)
¨¨2 3
return
≠≠ 
new
≠≠ 
Color32
≠≠ "
(
≠≠" #
(
ÆÆ 
byte
ÆÆ 
)
ÆÆ 
(
ÆÆ 
hash
ÆÆ 
>>
ÆÆ  "
$num
ÆÆ# %
&
ÆÆ& '
$num
ÆÆ( ,
)
ÆÆ, -
,
ÆÆ- .
(
ØØ 
byte
ØØ 
)
ØØ 
(
ØØ 
hash
ØØ 
>>
ØØ  "
$num
ØØ$ %
&
ØØ& '
$num
ØØ( ,
)
ØØ, -
,
ØØ- .
(
∞∞ 
byte
∞∞ 
)
∞∞ 
(
∞∞ 
hash
∞∞ 
&
∞∞& '
$num
∞∞( ,
)
∞∞, -
,
∞∞- .
(
±± 
byte
±± 
)
±± 
(
±± 
$num
±± 
)
±± 
)
±±  
;
±±  !
else
≤≤ 
return
≥≥ 
new
≥≥ 
Color32
≥≥ "
(
≥≥" #
(
¥¥ 
byte
¥¥ 
)
¥¥ 
(
¥¥ 
hash
¥¥ 
>>
¥¥  "
$num
¥¥# %
&
¥¥& '
$num
¥¥( ,
)
¥¥, -
,
¥¥- .
(
µµ 
byte
µµ 
)
µµ 
(
µµ 
hash
µµ 
>>
µµ  "
$num
µµ# %
&
µµ& '
$num
µµ( ,
)
µµ, -
,
µµ- .
(
∂∂ 
byte
∂∂ 
)
∂∂ 
(
∂∂ 
hash
∂∂ 
>>
∂∂  "
$num
∂∂$ %
&
∂∂& '
$num
∂∂( ,
)
∂∂, -
,
∂∂- .
(
∑∑ 
byte
∑∑ 
)
∑∑ 
(
∑∑ 
$num
∑∑ 
)
∑∑ 
)
∑∑  
;
∑∑  !
}
∏∏ 	
static
∫∫ 
bool
∫∫ 
ShouldUseHDRP
∫∫ !
(
∫∫! "
)
∫∫" #
{
ªª 	
return
øø 
false
øø 
;
øø 
}
¡¡ 	
}
¬¬ 
}√√ ö
åD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Transform2D.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed 

class 
Transform2D 
{		 
public 
Vector2 
position  
;  !
public 
float 
rotation 
; 
public 
Vector2 
scale 
; 
public 
Transform2D 
( 
Vector2 "
position# +
,+ ,
float- 2
rotation3 ;
,; <
Vector2= D
scaleE J
)J K
{ 	
this 
. 
position 
= 
position &
;& '
this 
. 
rotation 
= 
rotation &
;& '
this 
. 
scale 
= 
scale #
;# $
} 	
public   
Vector2   
TransformPoint   %
(  % &
Vector2  & -
p  . /
)  / 0
{!! 	
p"" 
+="" 
position"" 
;"" 
p## 
.## 
RotateAroundPoint## 
(##  
p##  !
,##! "
rotation### +
)##+ ,
;##, -
p$$ 
.$$ 
ScaleAroundPoint$$ 
($$ 
p$$  
,$$  !
scale$$" '
)$$' (
;$$( )
return%% 
p%% 
;%% 
}&& 	
public(( 
override(( 
string(( 
ToString(( '
(((' (
)((( )
{)) 	
return** 
$str** 
+** 
position** #
+**$ %
$str**& -
+**. /
rotation**0 8
+**9 :
PreferenceKeys**; I
.**I J
DEGREE_SYMBOL**J W
+**X Y
$str**Z a
+**b c
scale**d i
;**i j
}++ 	
},, 
}-- ©
åD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\IHasDefault.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
	interface 
IHasDefault 
{		 
void 
SetDefaultValues 
( 
) 
;  
} 
} ãô
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SelectionPickerSettings.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[

 
EditorBrowsable

 
(

  
EditorBrowsableState

 )
.

) *
Never

* /
)

/ 0
]

0 1
public 

class 
SceneSelection 
:  !

IEquatable" ,
<, -
SceneSelection- ;
>; <
{ 
public 

GameObject 

gameObject $
;$ %
public 
ProBuilderMesh 
mesh "
;" #
List 
< 
int 
> 

m_Vertices 
; 
List 
< 
Edge 
> 
m_Edges 
; 
List 
< 
Face 
> 
m_Faces 
; 
public 
List 
< 
int 
> 
vertexes !
{ 	
get 
{ 
return 

m_Vertices #
;# $
}% &
set 
{ 

m_Vertices 
= 
value $
;$ %
}& '
} 	
public 
List 
< 
Edge 
> 
edges 
{ 	
get 
{ 
return 
m_Edges  
;  !
}" #
set 
{ 
m_Edges 
= 
value !
;! "
}# $
} 	
public   
List   
<   
Face   
>   
faces   
{!! 	
get"" 
{"" 
return"" 
m_Faces""  
;""  !
}""" #
set## 
{## 
m_Faces## 
=## 
value## !
;##! "
}### $
}$$ 	
[&& 	
Obsolete&&	 
(&& 
$str&& '
)&&' (
]&&( )
public'' 
int'' 
vertex'' 
;'' 
[)) 	
Obsolete))	 
()) 
$str)) %
)))% &
]))& '
public** 
Edge** 
edge** 
;** 
[,, 	
Obsolete,,	 
(,, 
$str,, %
),,% &
],,& '
public-- 
Face-- 
face-- 
;-- 
public// 
SceneSelection// 
(// 

GameObject// (

gameObject//) 3
=//4 5
null//6 :
)//: ;
{00 	
this11 
.11 

gameObject11 
=11 

gameObject11 (
;11( )

m_Vertices22 
=22 
new22 
List22 !
<22! "
int22" %
>22% &
(22& '
)22' (
;22( )
m_Edges33 
=33 
new33 
List33 
<33 
Edge33 #
>33# $
(33$ %
)33% &
;33& '
m_Faces44 
=44 
new44 
List44 
<44 
Face44 #
>44# $
(44$ %
)44% &
;44& '
}55 	
public77 
SceneSelection77 
(77 
ProBuilderMesh77 ,
mesh77- 1
,771 2
int773 6
vertex777 =
)77= >
:77? @
this77A E
(77E F
mesh77F J
,77J K
new77L O
List77P T
<77T U
int77U X
>77X Y
(77Y Z
)77Z [
{77\ ]
vertex77^ d
}77e f
)77f g
{77h i
}77j k
public99 
SceneSelection99 
(99 
ProBuilderMesh99 ,
mesh99- 1
,991 2
Edge993 7
edge998 <
)99< =
:99> ?
this99@ D
(99D E
mesh99E I
,99I J
new99K N
List99O S
<99S T
Edge99T X
>99X Y
(99Y Z
)99Z [
{99\ ]
edge99^ b
}99c d
)99d e
{99f g
}99h i
public;; 
SceneSelection;; 
(;; 
ProBuilderMesh;; ,
mesh;;- 1
,;;1 2
Face;;3 7
face;;8 <
);;< =
:;;> ?
this;;@ D
(;;D E
mesh;;E I
,;;I J
new;;K N
List;;O S
<;;S T
Face;;T X
>;;X Y
(;;Y Z
);;Z [
{;;\ ]
face;;^ b
};;c d
);;d e
{;;f g
};;h i
internal== 
SceneSelection== 
(==  
ProBuilderMesh==  .
mesh==/ 3
,==3 4
List==5 9
<==9 :
int==: =
>=== >
vertexes==? G
)==G H
:==I J
this==K O
(==O P
mesh==P T
!===U W
null==X \
?==] ^
mesh==_ c
.==c d

gameObject==d n
:==o p
null==q u
)==u v
{>> 	
this?? 
.?? 
mesh?? 
=?? 
mesh?? 
;?? 

m_Vertices@@ 
=@@ 
vertexes@@ !
;@@! "
m_EdgesAA 
=AA 
newAA 
ListAA 
<AA 
EdgeAA #
>AA# $
(AA$ %
)AA% &
;AA& '
m_FacesBB 
=BB 
newBB 
ListBB 
<BB 
FaceBB #
>BB# $
(BB$ %
)BB% &
;BB& '
}CC 	
internalEE 
SceneSelectionEE 
(EE  
ProBuilderMeshEE  .
meshEE/ 3
,EE3 4
ListEE5 9
<EE9 :
EdgeEE: >
>EE> ?
edgesEE@ E
)EEE F
:EEG H
thisEEI M
(EEM N
meshEEN R
!=EES U
nullEEV Z
?EE[ \
meshEE] a
.EEa b

gameObjectEEb l
:EEm n
nullEEo s
)EEs t
{FF 	
thisGG 
.GG 
meshGG 
=GG 
meshGG 
;GG 
vertexesHH 
=HH 
newHH 
ListHH 
<HH  
intHH  #
>HH# $
(HH$ %
)HH% &
;HH& '
thisII 
.II 
edgesII 
=II 
edgesII 
;II 
facesJJ 
=JJ 
newJJ 
ListJJ 
<JJ 
FaceJJ !
>JJ! "
(JJ" #
)JJ# $
;JJ$ %
}KK 	
internalMM 
SceneSelectionMM 
(MM  
ProBuilderMeshMM  .
meshMM/ 3
,MM3 4
ListMM5 9
<MM9 :
FaceMM: >
>MM> ?
facesMM@ E
)MME F
:MMG H
thisMMI M
(MMM N
meshMMN R
!=MMS U
nullMMV Z
?MM[ \
meshMM] a
.MMa b

gameObjectMMb l
:MMm n
nullMMo s
)MMs t
{NN 	
thisOO 
.OO 
meshOO 
=OO 
meshOO 
;OO 
vertexesPP 
=PP 
newPP 
ListPP 
<PP  
intPP  #
>PP# $
(PP$ %
)PP% &
;PP& '
edgesQQ 
=QQ 
newQQ 
ListQQ 
<QQ 
EdgeQQ !
>QQ! "
(QQ" #
)QQ# $
;QQ$ %
thisRR 
.RR 
facesRR 
=RR 
facesRR 
;RR 
}SS 	
publicUU 
voidUU 
SetSingleFaceUU !
(UU! "
FaceUU" &
faceUU' +
)UU+ ,
{VV 	
facesWW 
.WW 
ClearWW 
(WW 
)WW 
;WW 
facesXX 
.XX 
AddXX 
(XX 
faceXX 
)XX 
;XX 
}YY 	
public[[ 
void[[ 
SetSingleVertex[[ #
([[# $
int[[$ '
vertex[[( .
)[[. /
{\\ 	
vertexes]] 
.]] 
Clear]] 
(]] 
)]] 
;]] 
vertexes^^ 
.^^ 
Add^^ 
(^^ 
vertex^^ 
)^^  
;^^  !
}__ 	
publicaa 
voidaa 
SetSingleEdgeaa !
(aa! "
Edgeaa" &
edgeaa' +
)aa+ ,
{bb 	
edgescc 
.cc 
Clearcc 
(cc 
)cc 
;cc 
edgesdd 
.dd 
Adddd 
(dd 
edgedd 
)dd 
;dd 
}ee 	
publicgg 
voidgg 
Cleargg 
(gg 
)gg 
{hh 	

gameObjectii 
=ii 
nullii 
;ii 
meshjj 
=jj 
nulljj 
;jj 
faceskk 
.kk 
Clearkk 
(kk 
)kk 
;kk 
edgesll 
.ll 
Clearll 
(ll 
)ll 
;ll 
vertexesmm 
.mm 
Clearmm 
(mm 
)mm 
;mm 
}nn 	
publicpp 
voidpp 
CopyTopp 
(pp 
SceneSelectionpp )
dstpp* -
)pp- .
{qq 	
dstrr 
.rr 

gameObjectrr 
=rr 

gameObjectrr '
;rr' (
dstss 
.ss 
meshss 
=ss 
meshss 
;ss 
dsttt 
.tt 
facestt 
.tt 
Cleartt 
(tt 
)tt 
;tt 
dstuu 
.uu 
edgesuu 
.uu 
Clearuu 
(uu 
)uu 
;uu 
dstvv 
.vv 
vertexesvv 
.vv 
Clearvv 
(vv 
)vv  
;vv  !
foreachww 
(ww 
varww 
xww 
inww 
facesww #
)ww# $
dstxx 
.xx 
facesxx 
.xx 
Addxx 
(xx 
xxx 
)xx  
;xx  !
foreachyy 
(yy 
varyy 
xyy 
inyy 
edgesyy #
)yy# $
dstzz 
.zz 
edgeszz 
.zz 
Addzz 
(zz 
xzz 
)zz  
;zz  !
foreach{{ 
({{ 
var{{ 
x{{ 
in{{ 
vertexes{{ &
){{& '
dst|| 
.|| 
vertexes|| 
.|| 
Add||  
(||  !
x||! "
)||" #
;||# $
}}} 	
public 
override 
string 
ToString '
(' (
)( )
{
ÄÄ 	
var
ÅÅ 
sb
ÅÅ 
=
ÅÅ 
new
ÅÅ 
System
ÅÅ 
.
ÅÅ  
Text
ÅÅ  $
.
ÅÅ$ %
StringBuilder
ÅÅ% 2
(
ÅÅ2 3
)
ÅÅ3 4
;
ÅÅ4 5
sb
ÇÇ 
.
ÇÇ 

AppendLine
ÇÇ 
(
ÇÇ 
$str
ÇÇ (
+
ÇÇ) *
(
ÇÇ+ ,

gameObject
ÇÇ, 6
!=
ÇÇ7 9
null
ÇÇ: >
?
ÇÇ? @

gameObject
ÇÇA K
.
ÇÇK L
name
ÇÇL P
:
ÇÇQ R
null
ÇÇS W
)
ÇÇW X
)
ÇÇX Y
;
ÇÇY Z
sb
ÉÉ 
.
ÉÉ 

AppendLine
ÉÉ 
(
ÉÉ 
$str
ÉÉ ,
+
ÉÉ- .
(
ÉÉ/ 0
mesh
ÉÉ0 4
!=
ÉÉ5 7
null
ÉÉ8 <
?
ÉÉ= >
mesh
ÉÉ? C
.
ÉÉC D
name
ÉÉD H
:
ÉÉI J
null
ÉÉK O
)
ÉÉO P
)
ÉÉP Q
;
ÉÉQ R
sb
ÑÑ 
.
ÑÑ 

AppendLine
ÑÑ 
(
ÑÑ 
$str
ÑÑ "
+
ÑÑ# $
(
ÑÑ% &
faces
ÑÑ& +
!=
ÑÑ, .
null
ÑÑ/ 3
?
ÑÑ4 5
faces
ÑÑ6 ;
.
ÑÑ; <
ToString
ÑÑ< D
(
ÑÑD E
)
ÑÑE F
:
ÑÑG H
null
ÑÑI M
)
ÑÑM N
)
ÑÑN O
;
ÑÑO P
sb
ÖÖ 
.
ÖÖ 

AppendLine
ÖÖ 
(
ÖÖ 
$str
ÖÖ "
+
ÖÖ# $
edges
ÖÖ% *
.
ÖÖ* +
ToString
ÖÖ+ 3
(
ÖÖ3 4
)
ÖÖ4 5
)
ÖÖ5 6
;
ÖÖ6 7
sb
ÜÜ 
.
ÜÜ 

AppendLine
ÜÜ 
(
ÜÜ 
$str
ÜÜ $
+
ÜÜ% &
vertexes
ÜÜ' /
)
ÜÜ/ 0
;
ÜÜ0 1
return
áá 
sb
áá 
.
áá 
ToString
áá 
(
áá 
)
áá  
;
áá  !
}
àà 	
public
ää 
bool
ää 
Equals
ää 
(
ää 
SceneSelection
ää )
other
ää* /
)
ää/ 0
{
ãã 	
if
åå 
(
åå 
ReferenceEquals
åå 
(
åå  
null
åå  $
,
åå$ %
other
åå& +
)
åå+ ,
)
åå, -
return
åå. 4
false
åå5 :
;
åå: ;
if
çç 
(
çç 
ReferenceEquals
çç 
(
çç  
this
çç  $
,
çç$ %
other
çç& +
)
çç+ ,
)
çç, -
return
çç. 4
true
çç5 9
;
çç9 :
return
éé 
Equals
éé 
(
éé 

gameObject
éé $
,
éé$ %
other
éé& +
.
éé+ ,

gameObject
éé, 6
)
éé6 7
&&
èè 
Equals
èè 
(
èè 
mesh
èè 
,
èè 
other
èè  %
.
èè% &
mesh
èè& *
)
èè* +
&&
êê 

Enumerable
êê 
.
êê 
SequenceEqual
êê +
(
êê+ ,
vertexes
êê, 4
,
êê4 5
other
êê6 ;
.
êê; <
vertexes
êê< D
)
êêD E
&&
ëë 

Enumerable
ëë 
.
ëë 
SequenceEqual
ëë +
(
ëë+ ,
edges
ëë, 1
,
ëë1 2
other
ëë3 8
.
ëë8 9
edges
ëë9 >
)
ëë> ?
&&
íí 

Enumerable
íí 
.
íí 
SequenceEqual
íí +
(
íí+ ,
faces
íí, 1
,
íí1 2
other
íí3 8
.
íí8 9
faces
íí9 >
)
íí> ?
;
íí? @
}
ìì 	
public
ïï 
override
ïï 
bool
ïï 
Equals
ïï #
(
ïï# $
object
ïï$ *
obj
ïï+ .
)
ïï. /
{
ññ 	
if
óó 
(
óó 
ReferenceEquals
óó 
(
óó  
null
óó  $
,
óó$ %
obj
óó& )
)
óó) *
)
óó* +
return
óó, 2
false
óó3 8
;
óó8 9
if
òò 
(
òò 
ReferenceEquals
òò 
(
òò  
this
òò  $
,
òò$ %
obj
òò& )
)
òò) *
)
òò* +
return
òò, 2
true
òò3 7
;
òò7 8
if
ôô 
(
ôô 
obj
ôô 
.
ôô 
GetType
ôô 
(
ôô 
)
ôô 
!=
ôô  
this
ôô! %
.
ôô% &
GetType
ôô& -
(
ôô- .
)
ôô. /
)
ôô/ 0
return
ôô1 7
false
ôô8 =
;
ôô= >
return
öö 
Equals
öö 
(
öö 
(
öö 
SceneSelection
öö )
)
öö) *
obj
öö* -
)
öö- .
;
öö. /
}
õõ 	
public
ùù 
override
ùù 
int
ùù 
GetHashCode
ùù '
(
ùù' (
)
ùù( )
{
ûû 	
	unchecked
üü 
{
†† 
int
°° 
hashCode
°° 
=
°° 
(
°°  

gameObject
°°  *
!=
°°+ -
null
°°. 2
?
°°3 4

gameObject
°°5 ?
.
°°? @
GetHashCode
°°@ K
(
°°K L
)
°°L M
:
°°N O
$num
°°P Q
)
°°Q R
;
°°R S
hashCode
¢¢ 
=
¢¢ 
(
¢¢ 
hashCode
¢¢ $
*
¢¢% &
$num
¢¢' *
)
¢¢* +
^
¢¢, -
(
¢¢. /
mesh
¢¢/ 3
!=
¢¢4 6
null
¢¢7 ;
?
¢¢< =
mesh
¢¢> B
.
¢¢B C
GetHashCode
¢¢C N
(
¢¢N O
)
¢¢O P
:
¢¢Q R
$num
¢¢S T
)
¢¢T U
;
¢¢U V
hashCode
££ 
=
££ 
(
££ 
hashCode
££ $
*
££% &
$num
££' *
)
££* +
^
££, -
(
££. /
vertexes
££/ 7
!=
££8 :
null
££; ?
?
££@ A
vertexes
££B J
.
££J K
GetHashCode
££K V
(
££V W
)
££W X
:
££Y Z
$num
££[ \
)
££\ ]
;
££] ^
hashCode
§§ 
=
§§ 
(
§§ 
hashCode
§§ $
*
§§% &
$num
§§' *
)
§§* +
^
§§, -
(
§§. /
edges
§§/ 4
!=
§§5 7
null
§§8 <
?
§§= >
edges
§§? D
.
§§D E
GetHashCode
§§E P
(
§§P Q
)
§§Q R
:
§§S T
$num
§§U V
)
§§V W
;
§§W X
hashCode
•• 
=
•• 
(
•• 
hashCode
•• $
*
••% &
$num
••' *
)
••* +
^
••, -
(
••. /
faces
••/ 4
!=
••5 7
null
••8 <
?
••= >
faces
••? D
.
••D E
GetHashCode
••E P
(
••P Q
)
••Q R
:
••S T
$num
••U V
)
••V W
;
••W X
return
¶¶ 
hashCode
¶¶ 
;
¶¶  
}
ßß 
}
®® 	
public
™™ 
static
™™ 
bool
™™ 
operator
™™ #
==
™™# %
(
™™% &
SceneSelection
™™& 4
left
™™5 9
,
™™9 :
SceneSelection
™™; I
right
™™J O
)
™™O P
{
´´ 	
return
¨¨ 
Equals
¨¨ 
(
¨¨ 
left
¨¨ 
,
¨¨ 
right
¨¨  %
)
¨¨% &
;
¨¨& '
}
≠≠ 	
public
ØØ 
static
ØØ 
bool
ØØ 
operator
ØØ #
!=
ØØ# %
(
ØØ% &
SceneSelection
ØØ& 4
left
ØØ5 9
,
ØØ9 :
SceneSelection
ØØ; I
right
ØØJ O
)
ØØO P
{
∞∞ 	
return
±± 
!
±± 
Equals
±± 
(
±± 
left
±± 
,
±±  
right
±±! &
)
±±& '
;
±±' (
}
≤≤ 	
}
≥≥ 
struct
µµ 

VertexPickerEntry
µµ 
{
∂∂ 
public
∑∑ 
ProBuilderMesh
∑∑ 
mesh
∑∑ "
;
∑∑" #
public
∏∏ 
int
∏∏ 
vertex
∏∏ 
;
∏∏ 
public
ππ 
float
ππ 
screenDistance
ππ #
;
ππ# $
public
∫∫ 
Vector3
∫∫ 
worldPosition
∫∫ $
;
∫∫$ %
}
ªª 
}ºº ß)
âD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Triangle.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ 
Serializable 
] 
struct 

Triangle 
: 

IEquatable  
<  !
Triangle! )
>) *
{ 
[		 	
SerializeField			 
]		 
int

 
m_A

 
;

 
[ 	
SerializeField	 
] 
int 
m_B 
; 
[ 	
SerializeField	 
] 
int 
m_C 
; 
public 
int 
a 
{ 	
get 
{ 
return 
m_A 
; 
} 
} 	
public 
int 
b 
{ 	
get 
{ 
return 
m_B 
; 
} 
} 	
public 
int 
c 
{ 	
get 
{ 
return 
m_C 
; 
} 
} 	
public!! 
IEnumerable!! 
<!! 
int!! 
>!! 
indices!!  '
{"" 	
get## 
{## 
return## 
new## 
[## 
]## 
{##  
m_A##! $
,##$ %
m_B##& )
,##) *
m_C##+ .
}##/ 0
;##0 1
}##2 3
}$$ 	
public&& 
Triangle&& 
(&& 
int&& 
a&& 
,&& 
int&& "
b&&# $
,&&$ %
int&&& )
c&&* +
)&&+ ,
{'' 	
m_A(( 
=(( 
a(( 
;(( 
m_B)) 
=)) 
b)) 
;)) 
m_C** 
=** 
c** 
;** 
}++ 	
public-- 
bool-- 
Equals-- 
(-- 
Triangle-- #
other--$ )
)--) *
{.. 	
return// 
m_A// 
==// 
other// 
.//  
a//  !
&&//" $
m_B//% (
==//) +
other//, 1
.//1 2
b//2 3
&&//4 6
m_C//7 :
==//; =
other//> C
.//C D
c//D E
;//E F
}00 	
public22 
override22 
bool22 
Equals22 #
(22# $
object22$ *
obj22+ .
)22. /
{33 	
return44 
obj44 
is44 
Triangle44 "
other44# (
&&44) +
Equals44, 2
(442 3
other443 8
)448 9
;449 :
}55 	
public77 
override77 
int77 
GetHashCode77 '
(77' (
)77( )
{88 	
	unchecked99 
{:: 
var;; 
hashCode;; 
=;; 
m_A;; "
;;;" #
hashCode<< 
=<< 
(<< 
hashCode<< $
*<<% &
$num<<' *
)<<* +
^<<, -
m_B<<. 1
;<<1 2
hashCode== 
=== 
(== 
hashCode== $
*==% &
$num==' *
)==* +
^==, -
m_C==. 1
;==1 2
return>> 
hashCode>> 
;>>  
}?? 
}@@ 	
publicBB 
boolBB 

IsAdjacentBB 
(BB 
TriangleBB '
otherBB( -
)BB- .
{CC 	
returnDD 
otherDD 
.DD 
ContainsEdgeDD %
(DD% &
newDD& )
EdgeDD* .
(DD. /
aDD/ 0
,DD0 1
bDD2 3
)DD3 4
)DD4 5
||EE 
otherEE 
.EE 
ContainsEdgeEE %
(EE% &
newEE& )
EdgeEE* .
(EE. /
bEE/ 0
,EE0 1
cEE2 3
)EE3 4
)EE4 5
||FF 
otherFF 
.FF 
ContainsEdgeFF %
(FF% &
newFF& )
EdgeFF* .
(FF. /
cFF/ 0
,FF0 1
aFF2 3
)FF3 4
)FF4 5
;FF5 6
}GG 	
boolII 
ContainsEdgeII 
(II 
EdgeII 
edgeII #
)II# $
{JJ 	
ifKK 
(KK 
newKK 
EdgeKK 
(KK 
aKK 
,KK 
bKK 
)KK 
==KK !
edgeKK" &
)KK& '
returnLL 
trueLL 
;LL 
ifMM 
(MM 
newMM 
EdgeMM 
(MM 
bMM 
,MM 
cMM 
)MM 
==MM !
edgeMM" &
)MM& '
returnNN 
trueNN 
;NN 
returnOO 
newOO 
EdgeOO 
(OO 
cOO 
,OO 
aOO  
)OO  !
==OO" $
edgeOO% )
;OO) *
}PP 	
}QQ 
}RR €o
ûD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\UV\TextureStitching.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
static 

partial 
class 
	UVEditing "
{ 
public 
static 
bool 

AutoStitch %
(% &
ProBuilderMesh& 4
mesh5 9
,9 :
Face; ?
f1@ B
,B C
FaceD H
f2I K
,K L
intM P
channelQ X
)X Y
{ 	
var 
wings 
= 

WingedEdge "
." #
GetWingedEdges# 1
(1 2
mesh2 6
,6 7
new8 ;
[< =
]= >
{? @
f1A C
,C D
f2E G
}H I
)I J
;J K
var 

sharedEdge 
= 
wings "
." #
FirstOrDefault# 1
(1 2
x2 3
=>4 6
x7 8
.8 9
face9 =
==> @
f1A C
&&D F
xG H
.H I
oppositeI Q
!=R T
nullU Y
&&Z \
x] ^
.^ _
opposite_ g
.g h
faceh l
==m o
f2p r
)r s
;s t
if 
( 

sharedEdge 
== 
null "
)" #
return 
false 
; 
if 
( 
f1 
. 
manualUV 
) 
f2 
. 
manualUV 
= 
true "
;" #
f1 
. 
textureGroup 
= 
- 
$num  
;  !
f2 
. 
textureGroup 
= 
- 
$num  
;  !

Projection 
. 
PlanarProject $
($ %
mesh% )
,) *
f2+ -
)- .
;. /
if!! 
(!! 

AlignEdges!! 
(!! 
mesh!! 
,!!  
f2!!! #
,!!# $

sharedEdge!!% /
.!!/ 0
edge!!0 4
.!!4 5
local!!5 :
,!!: ;

sharedEdge!!< F
.!!F G
opposite!!G O
.!!O P
edge!!P T
.!!T U
local!!U Z
,!!Z [
channel!!\ c
)!!c d
)!!d e
{"" 
if## 
(## 
!## 
f2## 
.## 
manualUV##  
)##  !
{$$ ,
 SetAutoAndAlignUnwrapParamsToUVs%% 4
(%%4 5
mesh%%5 9
,%%9 :
new%%; >
[%%? @
]%%@ A
{%%B C
f2%%D F
}%%G H
)%%H I
;%%I J
}&& 
return(( 
true(( 
;(( 
})) 
return++ 
false++ 
;++ 
},, 	
static77 
bool77 

AlignEdges77 
(77 
ProBuilderMesh77 -
mesh77. 2
,772 3
Face774 8

faceToMove779 C
,77C D
Edge77E I
edgeToAlignTo77J W
,77W X
Edge77Y ]
edgeToBeAligned77^ m
,77m n
int77o r
channel77s z
)77z {
{88 	
Vector299 
[99 
]99 
uvs99 
=99 
GetUVs99 "
(99" #
mesh99# '
,99' (
channel99) 0
)990 1
;991 2
SharedVertex:: 
[:: 
]:: 
sharedIndexes:: (
=::) *
mesh::+ /
.::/ 0"
sharedVerticesInternal::0 F
;::F G
int== 
[== 
]== 
matchX== 
=== 
new== 
int== "
[==" #
$num==# $
]==$ %
{==& '
edgeToAlignTo==( 5
.==5 6
a==6 7
,==7 8
-==9 :
$num==: ;
}==< =
;=== >
int>> 
[>> 
]>> 
matchY>> 
=>> 
new>> 
int>> "
[>>" #
$num>># $
]>>$ %
{>>& '
edgeToAlignTo>>( 5
.>>5 6
b>>6 7
,>>7 8
->>9 :
$num>>: ;
}>>< =
;>>= >
int@@ 
siIndex@@ 
=@@ 
mesh@@ 
.@@ !
GetSharedVertexHandle@@ 4
(@@4 5
edgeToAlignTo@@5 B
.@@B C
a@@C D
)@@D E
;@@E F
ifBB 
(BB 
siIndexBB 
<BB 
$numBB 
)BB 
returnCC 
falseCC 
;CC 
ifEE 
(EE 
sharedIndexesEE 
[EE 
siIndexEE %
]EE% &
.EE& '
ContainsEE' /
(EE/ 0
edgeToBeAlignedEE0 ?
.EE? @
aEE@ A
)EEA B
)EEB C
{FF 
matchXGG 
[GG 
$numGG 
]GG 
=GG 
edgeToBeAlignedGG +
.GG+ ,
aGG, -
;GG- .
matchYHH 
[HH 
$numHH 
]HH 
=HH 
edgeToBeAlignedHH +
.HH+ ,
bHH, -
;HH- .
}II 
elseJJ 
{KK 
matchXLL 
[LL 
$numLL 
]LL 
=LL 
edgeToBeAlignedLL +
.LL+ ,
bLL, -
;LL- .
matchYMM 
[MM 
$numMM 
]MM 
=MM 
edgeToBeAlignedMM +
.MM+ ,
aMM, -
;MM- .
}NN 
floatQQ 
dist_e1QQ 
=QQ 
Vector2QQ #
.QQ# $
DistanceQQ$ ,
(QQ, -
uvsQQ- 0
[QQ0 1
edgeToAlignToQQ1 >
.QQ> ?
aQQ? @
]QQ@ A
,QQA B
uvsQQC F
[QQF G
edgeToAlignToQQG T
.QQT U
bQQU V
]QQV W
)QQW X
;QQX Y
floatRR 
dist_e2RR 
=RR 
Vector2RR #
.RR# $
DistanceRR$ ,
(RR, -
uvsRR- 0
[RR0 1
edgeToBeAlignedRR1 @
.RR@ A
aRRA B
]RRB C
,RRC D
uvsRRE H
[RRH I
edgeToBeAlignedRRI X
.RRX Y
bRRY Z
]RRZ [
)RR[ \
;RR\ ]
floatTT 
scaleTT 
=TT 
dist_e1TT !
/TT" #
dist_e2TT$ +
;TT+ ,
foreachWW 
(WW 
intWW 
iWW 
inWW 

faceToMoveWW (
.WW( )#
distinctIndexesInternalWW) @
)WW@ A
uvsXX 
[XX 
iXX 
]XX 
=XX 
uvsXX 
[XX 
iXX 
]XX 
.XX  
ScaleAroundPointXX  0
(XX0 1
Vector2XX1 8
.XX8 9
zeroXX9 =
,XX= >
Vector2XX? F
.XXF G
oneXXG J
*XXK L
scaleXXM R
)XXR S
;XXS T
Vector2]] 
	f1_center]] 
=]] 
(]]  !
uvs]]! $
[]]$ %
edgeToAlignTo]]% 2
.]]2 3
a]]3 4
]]]4 5
+]]6 7
uvs]]8 ;
[]]; <
edgeToAlignTo]]< I
.]]I J
b]]J K
]]]K L
)]]L M
/]]N O
$num]]P R
;]]R S
Vector2^^ 
	f2_center^^ 
=^^ 
(^^  !
uvs^^! $
[^^$ %
edgeToBeAligned^^% 4
.^^4 5
a^^5 6
]^^6 7
+^^8 9
uvs^^: =
[^^= >
edgeToBeAligned^^> M
.^^M N
b^^N O
]^^O P
)^^P Q
/^^R S
$num^^T V
;^^V W
Vector2`` 
diff`` 
=`` 
	f1_center`` $
-``% &
	f2_center``' 0
;``0 1
foreachee 
(ee 
intee 
iee 
inee 

faceToMoveee (
.ee( )#
distinctIndexesInternalee) @
)ee@ A
uvsff 
[ff 
iff 
]ff 
+=ff 
diffff 
;ff 
Vector2kk 
angle1kk 
=kk 
uvskk  
[kk  !
matchYkk! '
[kk' (
$numkk( )
]kk) *
]kk* +
-kk, -
uvskk. 1
[kk1 2
matchXkk2 8
[kk8 9
$numkk9 :
]kk: ;
]kk; <
;kk< =
Vector2ll 
angle2ll 
=ll 
uvsll  
[ll  !
matchYll! '
[ll' (
$numll( )
]ll) *
]ll* +
-ll, -
uvsll. 1
[ll1 2
matchXll2 8
[ll8 9
$numll9 :
]ll: ;
]ll; <
;ll< =
floatnn 
anglenn 
=nn 
Vector2nn !
.nn! "
Anglenn" '
(nn' (
angle1nn( .
,nn. /
angle2nn0 6
)nn6 7
;nn7 8
ifoo 
(oo 
Vector3oo 
.oo 
Crossoo 
(oo 
angle1oo $
,oo$ %
angle2oo& ,
)oo, -
.oo- .
zoo. /
<oo0 1
$numoo2 3
)oo3 4
anglepp 
=pp 
$numpp 
-pp 
anglepp $
;pp$ %
foreachrr 
(rr 
intrr 
irr 
inrr 

faceToMoverr (
.rr( )#
distinctIndexesInternalrr) @
)rr@ A
uvsss 
[ss 
iss 
]ss 
=ss 
Mathss 
.ss 
RotateAroundPointss /
(ss/ 0
uvsss0 3
[ss3 4
iss4 5
]ss5 6
,ss6 7
	f1_centerss8 A
,ssA B
anglessC H
)ssH I
;ssI J
floatuu 
erroruu 
=uu 
Mathfuu 
.uu  
Absuu  #
(uu# $
Vector2uu$ +
.uu+ ,
Distanceuu, 4
(uu4 5
uvsuu5 8
[uu8 9
matchXuu9 ?
[uu? @
$numuu@ A
]uuA B
]uuB C
,uuC D
uvsuuE H
[uuH I
matchXuuI O
[uuO P
$numuuP Q
]uuQ R
]uuR S
)uuS T
)uuT U
+uuV W
MathfuuX ]
.uu] ^
Absuu^ a
(uua b
Vector2uub i
.uui j
Distanceuuj r
(uur s
uvsuus v
[uuv w
matchYuuw }
[uu} ~
$numuu~ 
]	uu Ä
]
uuÄ Å
,
uuÅ Ç
uvs
uuÉ Ü
[
uuÜ á
matchY
uuá ç
[
uuç é
$num
uué è
]
uuè ê
]
uuê ë
)
uuë í
)
uuí ì
;
uuì î
ifxx 
(xx 
errorxx 
>xx 
$numxx 
)xx 
{yy 
foreach{{ 
({{ 
int{{ 
i{{ 
in{{ !

faceToMove{{" ,
.{{, -#
distinctIndexesInternal{{- D
){{D E
uvs|| 
[|| 
i|| 
]|| 
=|| 
Math|| !
.||! "
RotateAroundPoint||" 3
(||3 4
uvs||4 7
[||7 8
i||8 9
]||9 :
,||: ;
	f1_center||< E
,||E F
$num||G K
)||K L
;||L M
float~~ 
e2~~ 
=~~ 
Mathf~~  
.~~  !
Abs~~! $
(~~$ %
Vector2~~% ,
.~~, -
Distance~~- 5
(~~5 6
uvs~~6 9
[~~9 :
matchX~~: @
[~~@ A
$num~~A B
]~~B C
]~~C D
,~~D E
uvs~~F I
[~~I J
matchX~~J P
[~~P Q
$num~~Q R
]~~R S
]~~S T
)~~T U
)~~U V
+~~W X
Mathf~~Y ^
.~~^ _
Abs~~_ b
(~~b c
Vector2~~c j
.~~j k
Distance~~k s
(~~s t
uvs~~t w
[~~w x
matchY~~x ~
[~~~ 
$num	~~ Ä
]
~~Ä Å
]
~~Å Ç
,
~~Ç É
uvs
~~Ñ á
[
~~á à
matchY
~~à é
[
~~é è
$num
~~è ê
]
~~ê ë
]
~~ë í
)
~~í ì
)
~~ì î
;
~~î ï
if 
( 
e2 
< 
error 
) 
error
ÄÄ 
=
ÄÄ 
e2
ÄÄ 
;
ÄÄ 
else
ÅÅ 
{
ÇÇ 
foreach
ÑÑ 
(
ÑÑ 
int
ÑÑ  
i
ÑÑ! "
in
ÑÑ# %

faceToMove
ÑÑ& 0
.
ÑÑ0 1%
distinctIndexesInternal
ÑÑ1 H
)
ÑÑH I
uvs
ÖÖ 
[
ÖÖ 
i
ÖÖ 
]
ÖÖ 
=
ÖÖ  
Math
ÖÖ! %
.
ÖÖ% &
RotateAroundPoint
ÖÖ& 7
(
ÖÖ7 8
uvs
ÖÖ8 ;
[
ÖÖ; <
i
ÖÖ< =
]
ÖÖ= >
,
ÖÖ> ?
	f1_center
ÖÖ@ I
,
ÖÖI J
$num
ÖÖK O
)
ÖÖO P
;
ÖÖP Q
}
ÜÜ 
}
áá 
SplitUVs
ää 
(
ää 
mesh
ää 
,
ää 

faceToMove
ää %
.
ää% &%
distinctIndexesInternal
ää& =
)
ää= >
;
ää> ?
mesh
åå 
.
åå #
SetTexturesCoincident
åå &
(
åå& '
matchX
åå' -
)
åå- .
;
åå. /
mesh
çç 
.
çç #
SetTexturesCoincident
çç &
(
çç& '
matchY
çç' -
)
çç- .
;
çç. /
ApplyUVs
éé 
(
éé 
mesh
éé 
,
éé 
uvs
éé 
,
éé 
channel
éé  '
)
éé' (
;
éé( )
return
êê 
true
êê 
;
êê 
}
ëë 	
}
íí 
}ìì öb
åD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\EdgeUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static		 

class		 
EdgeUtility		 
{

 
public 
static 
IEnumerable !
<! "
Edge" &
>& '&
GetSharedVertexHandleEdges( B
(B C
thisC G
ProBuilderMeshH V
meshW [
,[ \
IEnumerable] h
<h i
Edgei m
>m n
edgeso t
)t u
{ 	
return 
edges 
. 
Select 
(  
x  !
=>" $%
GetSharedVertexHandleEdge% >
(> ?
mesh? C
,C D
xE F
)F G
)G H
;H I
} 	
public 
static 
Edge %
GetSharedVertexHandleEdge 4
(4 5
this5 9
ProBuilderMesh: H
meshI M
,M N
EdgeO S
edgeT X
)X Y
{ 	
return 
new 
Edge 
( 
mesh  
.  !
sharedVertexLookup! 3
[3 4
edge4 8
.8 9
a9 :
]: ;
,; <
mesh= A
.A B
sharedVertexLookupB T
[T U
edgeU Y
.Y Z
bZ [
][ \
)\ ]
;] ^
} 	
internal!! 
static!! 
Edge!! *
GetEdgeWithSharedVertexHandles!! ;
(!!; <
this!!< @
ProBuilderMesh!!A O
mesh!!P T
,!!T U
Edge!!V Z
edge!![ _
)!!_ `
{"" 	
return## 
new## 
Edge## 
(## 
mesh##  
.##  !"
sharedVerticesInternal##! 7
[##7 8
edge##8 <
.##< =
a##= >
]##> ?
[##? @
$num##@ A
]##A B
,##B C
mesh##D H
.##H I"
sharedVerticesInternal##I _
[##_ `
edge##` d
.##d e
b##e f
]##f g
[##g h
$num##h i
]##i j
)##j k
;##k l
}$$ 	
public// 
static// 
bool// 
ValidateEdge// '
(//' (
ProBuilderMesh//( 6
mesh//7 ;
,//; <
Edge//= A
edge//B F
,//F G
out//H K
SimpleTuple//L W
<//W X
Face//X \
,//\ ]
Edge//^ b
>//b c
	validEdge//d m
)//m n
{00 	
Face11 
[11 
]11 
faces11 
=11 
mesh11 
.11  
facesInternal11  -
;11- .
SharedVertex22 
[22 
]22 
sharedIndexes22 (
=22) *
mesh22+ /
.22/ 0"
sharedVerticesInternal220 F
;22F G
Edge44 
	universal44 
=44 %
GetSharedVertexHandleEdge44 6
(446 7
mesh447 ;
,44; <
edge44= A
)44A B
;44B C
for66 
(66 
int66 
i66 
=66 
$num66 
;66 
i66 
<66 
faces66  %
.66% &
Length66& ,
;66, -
i66. /
++66/ 1
)661 2
{77 
int88 
dist_x88 
=88 
-88 
$num88 
,88  
dist_y99 
=99 
-99 
$num99 
,99  
shared_x:: 
=:: 
-::  
$num::  !
,::! "
shared_y;; 
=;; 
-;;  
$num;;  !
;;;! "
if== 
(== 
faces== 
[== 
i== 
]== 
.== #
distinctIndexesInternal== 4
.==4 5
ContainsMatch==5 B
(==B C
sharedIndexes==C P
[==P Q
	universal==Q Z
.==Z [
a==[ \
]==\ ]
.==] ^
arrayInternal==^ k
,==k l
out==m p
dist_x==q w
,==w x
out==y |
shared_x	==} Ö
)
==Ö Ü
&&
==á â
faces>> 
[>> 
i>> 
]>> 
.>> #
distinctIndexesInternal>> 4
.>>4 5
ContainsMatch>>5 B
(>>B C
sharedIndexes>>C P
[>>P Q
	universal>>Q Z
.>>Z [
b>>[ \
]>>\ ]
.>>] ^
arrayInternal>>^ k
,>>k l
out>>m p
dist_y>>q w
,>>w x
out>>y |
shared_y	>>} Ö
)
>>Ö Ü
)
>>Ü á
{?? 
int@@ 
x@@ 
=@@ 
faces@@ !
[@@! "
i@@" #
]@@# $
.@@$ %#
distinctIndexesInternal@@% <
[@@< =
dist_x@@= C
]@@C D
;@@D E
intAA 
yAA 
=AA 
facesAA !
[AA! "
iAA" #
]AA# $
.AA$ %#
distinctIndexesInternalAA% <
[AA< =
dist_yAA= C
]AAC D
;AAD E
	validEdgeCC 
=CC 
newCC  #
SimpleTupleCC$ /
<CC/ 0
FaceCC0 4
,CC4 5
EdgeCC6 :
>CC: ;
(CC; <
facesCC< A
[CCA B
iCCB C
]CCC D
,CCD E
newCCF I
EdgeCCJ N
(CCN O
xCCO P
,CCP Q
yCCR S
)CCS T
)CCT U
;CCU V
returnDD 
trueDD 
;DD  
}EE 
}FF 
	validEdgeHH 
=HH 
newHH 
SimpleTupleHH '
<HH' (
FaceHH( ,
,HH, -
EdgeHH. 2
>HH2 3
(HH3 4
)HH4 5
;HH5 6
returnJJ 
falseJJ 
;JJ 
}KK 	
internalPP 
staticPP 
boolPP 
ContainsPP %
(PP% &
thisPP& *
EdgePP+ /
[PP/ 0
]PP0 1
edgesPP2 7
,PP7 8
EdgePP9 =
edgePP> B
)PPB C
{QQ 	
forRR 
(RR 
intRR 
iRR 
=RR 
$numRR 
;RR 
iRR 
<RR 
edgesRR  %
.RR% &
LengthRR& ,
;RR, -
iRR. /
++RR/ 1
)RR1 2
{SS 
ifTT 
(TT 
edgesTT 
[TT 
iTT 
]TT 
.TT 
EqualsTT #
(TT# $
edgeTT$ (
)TT( )
)TT) *
returnUU 
trueUU 
;UU  
}VV 
returnXX 
falseXX 
;XX 
}YY 	
internalbb 
staticbb 
boolbb 
Containsbb %
(bb% &
thisbb& *
Edgebb+ /
[bb/ 0
]bb0 1
edgesbb2 7
,bb7 8
intbb9 <
xbb= >
,bb> ?
intbb@ C
ybbD E
)bbE F
{cc 	
fordd 
(dd 
intdd 
idd 
=dd 
$numdd 
;dd 
idd 
<dd 
edgesdd  %
.dd% &
Lengthdd& ,
;dd, -
idd. /
++dd/ 1
)dd1 2
{ee 
ifff 
(ff 
(ff 
xff 
==ff 
edgesff 
[ff  
iff  !
]ff! "
.ff" #
aff# $
&&ff% '
yff( )
==ff* ,
edgesff- 2
[ff2 3
iff3 4
]ff4 5
.ff5 6
bff6 7
)ff7 8
||ff9 ;
(ff< =
xff= >
==ff? A
edgesffB G
[ffG H
iffH I
]ffI J
.ffJ K
bffK L
&&ffM O
yffP Q
==ffR T
edgesffU Z
[ffZ [
iff[ \
]ff\ ]
.ff] ^
aff^ _
)ff_ `
)ff` a
returngg 
truegg 
;gg  
}hh 
returnjj 
falsejj 
;jj 
}kk 	
internalmm 
staticmm 
intmm 
IndexOfmm #
(mm# $
thismm$ (
ProBuilderMeshmm) 7
meshmm8 <
,mm< =
IListmm> C
<mmC D
EdgemmD H
>mmH I
edgesmmJ O
,mmO P
EdgemmQ U
edgemmV Z
)mmZ [
{nn 	
foroo 
(oo 
intoo 
ioo 
=oo 
$numoo 
;oo 
ioo 
<oo 
edgesoo  %
.oo% &
Countoo& +
;oo+ ,
ioo- .
++oo. 0
)oo0 1
{pp 
ifqq 
(qq 
edgesqq 
[qq 
iqq 
]qq 
.qq 
Equalsqq #
(qq# $
edgeqq$ (
,qq( )
meshqq* .
.qq. /
sharedVertexLookupqq/ A
)qqA B
)qqB C
returnrr 
irr 
;rr 
}ss 
returnuu 
-uu 
$numuu 
;uu 
}vv 	
internalxx 
staticxx 
intxx 
[xx 
]xx 
AllTrianglesxx *
(xx* +
thisxx+ /
Edgexx0 4
[xx4 5
]xx5 6
edgesxx7 <
)xx< =
{yy 	
intzz 
[zz 
]zz 
arrzz 
=zz 
newzz 
intzz 
[zz  
edgeszz  %
.zz% &
Lengthzz& ,
*zz- .
$numzz/ 0
]zz0 1
;zz1 2
int{{ 
n{{ 
={{ 
$num{{ 
;{{ 
for}} 
(}} 
int}} 
i}} 
=}} 
$num}} 
;}} 
i}} 
<}} 
edges}}  %
.}}% &
Length}}& ,
;}}, -
i}}. /
++}}/ 1
)}}1 2
{~~ 
arr 
[ 
n 
++ 
] 
= 
edges  
[  !
i! "
]" #
.# $
a$ %
;% &
arr
ÄÄ 
[
ÄÄ 
n
ÄÄ 
++
ÄÄ 
]
ÄÄ 
=
ÄÄ 
edges
ÄÄ  
[
ÄÄ  !
i
ÄÄ! "
]
ÄÄ" #
.
ÄÄ# $
b
ÄÄ$ %
;
ÄÄ% &
}
ÅÅ 
return
ÇÇ 
arr
ÇÇ 
;
ÇÇ 
}
ÉÉ 	
internal
ÖÖ 
static
ÖÖ 
Face
ÖÖ 
GetFace
ÖÖ $
(
ÖÖ$ %
this
ÖÖ% )
ProBuilderMesh
ÖÖ* 8
mesh
ÖÖ9 =
,
ÖÖ= >
Edge
ÖÖ? C
edge
ÖÖD H
)
ÖÖH I
{
ÜÜ 	
Face
áá 
res
áá 
=
áá 
null
áá 
;
áá 
foreach
ââ 
(
ââ 
var
ââ 
face
ââ 
in
ââ  
mesh
ââ! %
.
ââ% &
facesInternal
ââ& 3
)
ââ3 4
{
ää 
var
ãã 
edges
ãã 
=
ãã 
face
ãã  
.
ãã  !
edgesInternal
ãã! .
;
ãã. /
for
çç 
(
çç 
int
çç 
i
çç 
=
çç 
$num
çç 
,
çç 
c
çç  !
=
çç" #
edges
çç$ )
.
çç) *
Length
çç* 0
;
çç0 1
i
çç2 3
<
çç4 5
c
çç6 7
;
çç7 8
i
çç9 :
++
çç: <
)
çç< =
{
éé 
if
èè 
(
èè 
edge
èè 
.
èè 
Equals
èè #
(
èè# $
edges
èè$ )
[
èè) *
i
èè* +
]
èè+ ,
)
èè, -
)
èè- .
return
êê 
face
êê #
;
êê# $
if
íí 
(
íí 
edges
íí 
.
íí 
Contains
íí &
(
íí& '
edges
íí' ,
[
íí, -
i
íí- .
]
íí. /
)
íí/ 0
)
íí0 1
res
ìì 
=
ìì 
face
ìì "
;
ìì" #
}
îî 
}
ïï 
return
óó 
res
óó 
;
óó 
}
òò 	
}
ôô 
}öö π`
ìD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\AutoUnwrapSettings.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[		 
System		 
.		 
Serializable		 
]		 
public

 

struct

 
AutoUnwrapSettings

 $
{ 
public 
static 
AutoUnwrapSettings (%
defaultAutoUnwrapSettings) B
{ 	
get 
{ 
var 
settings 
= 
new "
AutoUnwrapSettings# 5
(5 6
)6 7
;7 8
settings 
. 
Reset 
( 
)  
;  !
return 
settings 
;  
} 
} 	
public 
enum 
Anchor 
{ 	
	UpperLeft   
,   
UpperCenter$$ 
,$$ 

UpperRight(( 
,(( 

MiddleLeft,, 
,,, 
MiddleCenter00 
,00 
MiddleRight44 
,44 
	LowerLeft88 
,88 
LowerCenter<< 
,<< 

LowerRight@@ 
,@@ 
NoneDD 
}EE 	
publicJJ 
enumJJ 
FillJJ 
{KK 	
FitOO 
,OO 
TileSS 
,SS 
StretchWW 
}XX 	
[ZZ 	
SerializeFieldZZ	 
]ZZ 
[[[ 	 
FormerlySerializedAs[[	 
([[ 
$str[[ -
)[[- .
][[. /
bool\\ 
m_UseWorldSpace\\ 
;\\ 
[^^ 	
SerializeField^^	 
]^^ 
[__ 	 
FormerlySerializedAs__	 
(__ 
$str__ %
)__% &
]__& '
bool`` 
m_FlipU`` 
;`` 
[bb 	
SerializeFieldbb	 
]bb 
[cc 	 
FormerlySerializedAscc	 
(cc 
$strcc %
)cc% &
]cc& '
booldd 
m_FlipVdd 
;dd 
[ff 	
SerializeFieldff	 
]ff 
[gg 	 
FormerlySerializedAsgg	 
(gg 
$strgg &
)gg& '
]gg' (
boolhh 
m_SwapUVhh 
;hh 
[jj 	
SerializeFieldjj	 
]jj 
[kk 	 
FormerlySerializedAskk	 
(kk 
$strkk $
)kk$ %
]kk% &
Fillll 
m_Fillll 
;ll 
[nn 	
SerializeFieldnn	 
]nn 
[oo 	 
FormerlySerializedAsoo	 
(oo 
$stroo %
)oo% &
]oo& '
Vector2pp 
m_Scalepp 
;pp 
[rr 	
SerializeFieldrr	 
]rr 
[ss 	 
FormerlySerializedAsss	 
(ss 
$strss &
)ss& '
]ss' (
Vector2tt 
m_Offsettt 
;tt 
[vv 	
SerializeFieldvv	 
]vv 
[ww 	 
FormerlySerializedAsww	 
(ww 
$strww (
)ww( )
]ww) *
floatxx 

m_Rotationxx 
;xx 
[zz 	
SerializeFieldzz	 
]zz 
[{{ 	 
FormerlySerializedAs{{	 
({{ 
$str{{ &
){{& '
]{{' (
Anchor|| 
m_Anchor|| 
;|| 
public
ÅÅ 
bool
ÅÅ 
useWorldSpace
ÅÅ !
{
ÇÇ 	
get
ÉÉ 
{
ÉÉ 
return
ÉÉ 
m_UseWorldSpace
ÉÉ (
;
ÉÉ( )
}
ÉÉ* +
set
ÑÑ 
{
ÑÑ 
m_UseWorldSpace
ÑÑ !
=
ÑÑ" #
value
ÑÑ$ )
;
ÑÑ) *
}
ÑÑ+ ,
}
ÖÖ 	
public
ää 
bool
ää 
flipU
ää 
{
ãã 	
get
åå 
{
åå 
return
åå 
m_FlipU
åå  
;
åå  !
}
åå" #
set
çç 
{
çç 
m_FlipU
çç 
=
çç 
value
çç !
;
çç! "
}
çç# $
}
éé 	
public
ìì 
bool
ìì 
flipV
ìì 
{
îî 	
get
ïï 
{
ïï 
return
ïï 
m_FlipV
ïï  
;
ïï  !
}
ïï" #
set
ññ 
{
ññ 
m_FlipV
ññ 
=
ññ 
value
ññ !
;
ññ! "
}
ññ# $
}
óó 	
public
üü 
bool
üü 
swapUV
üü 
{
†† 	
get
°° 
{
°° 
return
°° 
m_SwapUV
°° !
;
°°! "
}
°°# $
set
¢¢ 
{
¢¢ 
m_SwapUV
¢¢ 
=
¢¢ 
value
¢¢ "
;
¢¢" #
}
¢¢$ %
}
££ 	
public
®® 
Fill
®® 
fill
®® 
{
©© 	
get
™™ 
{
™™ 
return
™™ 
m_Fill
™™ 
;
™™  
}
™™! "
set
´´ 
{
´´ 
m_Fill
´´ 
=
´´ 
value
´´  
;
´´  !
}
´´" #
}
¨¨ 	
public
±± 
Vector2
±± 
scale
±± 
{
≤≤ 	
get
≥≥ 
{
≥≥ 
return
≥≥ 
m_Scale
≥≥  
;
≥≥  !
}
≥≥" #
set
¥¥ 
{
¥¥ 
m_Scale
¥¥ 
=
¥¥ 
value
¥¥ !
;
¥¥! "
}
¥¥# $
}
µµ 	
public
∫∫ 
Vector2
∫∫ 
offset
∫∫ 
{
ªª 	
get
ºº 
{
ºº 
return
ºº 
m_Offset
ºº !
;
ºº! "
}
ºº# $
set
ΩΩ 
{
ΩΩ 
m_Offset
ΩΩ 
=
ΩΩ 
value
ΩΩ "
;
ΩΩ" #
}
ΩΩ$ %
}
ææ 	
public
√√ 
float
√√ 
rotation
√√ 
{
ƒƒ 	
get
≈≈ 
{
≈≈ 
return
≈≈ 

m_Rotation
≈≈ #
;
≈≈# $
}
≈≈% &
set
∆∆ 
{
∆∆ 

m_Rotation
∆∆ 
=
∆∆ 
value
∆∆ $
;
∆∆$ %
}
∆∆& '
}
«« 	
public
ÃÃ 
Anchor
ÃÃ 
anchor
ÃÃ 
{
ÕÕ 	
get
ŒŒ 
{
ŒŒ 
return
ŒŒ 
m_Anchor
ŒŒ !
;
ŒŒ! "
}
ŒŒ# $
set
œœ 
{
œœ 
m_Anchor
œœ 
=
œœ 
value
œœ "
;
œœ" #
}
œœ$ %
}
–– 	
public
÷÷  
AutoUnwrapSettings
÷÷ !
(
÷÷! " 
AutoUnwrapSettings
÷÷" 4
unwrapSettings
÷÷5 C
)
÷÷C D
{
◊◊ 	
m_UseWorldSpace
ÿÿ 
=
ÿÿ 
unwrapSettings
ÿÿ ,
.
ÿÿ, -
m_UseWorldSpace
ÿÿ- <
;
ÿÿ< =
m_FlipU
ŸŸ 
=
ŸŸ 
unwrapSettings
ŸŸ $
.
ŸŸ$ %
m_FlipU
ŸŸ% ,
;
ŸŸ, -
m_FlipV
⁄⁄ 
=
⁄⁄ 
unwrapSettings
⁄⁄ $
.
⁄⁄$ %
m_FlipV
⁄⁄% ,
;
⁄⁄, -
m_SwapUV
€€ 
=
€€ 
unwrapSettings
€€ %
.
€€% &
m_SwapUV
€€& .
;
€€. /
m_Fill
‹‹ 
=
‹‹ 
unwrapSettings
‹‹ #
.
‹‹# $
m_Fill
‹‹$ *
;
‹‹* +
m_Scale
›› 
=
›› 
unwrapSettings
›› $
.
››$ %
m_Scale
››% ,
;
››, -
m_Offset
ﬁﬁ 
=
ﬁﬁ 
unwrapSettings
ﬁﬁ %
.
ﬁﬁ% &
m_Offset
ﬁﬁ& .
;
ﬁﬁ. /

m_Rotation
ﬂﬂ 
=
ﬂﬂ 
unwrapSettings
ﬂﬂ '
.
ﬂﬂ' (

m_Rotation
ﬂﬂ( 2
;
ﬂﬂ2 3
m_Anchor
‡‡ 
=
‡‡ 
unwrapSettings
‡‡ %
.
‡‡% &
m_Anchor
‡‡& .
;
‡‡. /
}
·· 	
public
ÊÊ 
static
ÊÊ  
AutoUnwrapSettings
ÊÊ (
tile
ÊÊ) -
{
ÁÁ 	
get
ËË 
{
ÈÈ 
var
ÍÍ 
res
ÍÍ 
=
ÍÍ 
new
ÍÍ  
AutoUnwrapSettings
ÍÍ 0
(
ÍÍ0 1
)
ÍÍ1 2
;
ÍÍ2 3
res
ÎÎ 
.
ÎÎ 
Reset
ÎÎ 
(
ÎÎ 
)
ÎÎ 
;
ÎÎ 
return
ÏÏ 
res
ÏÏ 
;
ÏÏ 
}
ÌÌ 
}
ÓÓ 	
public
ÛÛ 
static
ÛÛ  
AutoUnwrapSettings
ÛÛ (
fit
ÛÛ) ,
{
ÙÙ 	
get
ıı 
{
ˆˆ 
var
˜˜ 
res
˜˜ 
=
˜˜ 
new
˜˜  
AutoUnwrapSettings
˜˜ 0
(
˜˜0 1
)
˜˜1 2
;
˜˜2 3
res
¯¯ 
.
¯¯ 
Reset
¯¯ 
(
¯¯ 
)
¯¯ 
;
¯¯ 
res
˘˘ 
.
˘˘ 
fill
˘˘ 
=
˘˘ 
Fill
˘˘ 
.
˘˘  
Fit
˘˘  #
;
˘˘# $
return
˙˙ 
res
˙˙ 
;
˙˙ 
}
˚˚ 
}
¸¸ 	
public
ÅÅ 
static
ÅÅ  
AutoUnwrapSettings
ÅÅ (
stretch
ÅÅ) 0
{
ÇÇ 	
get
ÉÉ 
{
ÑÑ 
var
ÖÖ 
res
ÖÖ 
=
ÖÖ 
new
ÖÖ  
AutoUnwrapSettings
ÖÖ 0
(
ÖÖ0 1
)
ÖÖ1 2
;
ÖÖ2 3
res
ÜÜ 
.
ÜÜ 
Reset
ÜÜ 
(
ÜÜ 
)
ÜÜ 
;
ÜÜ 
res
áá 
.
áá 
fill
áá 
=
áá 
Fill
áá 
.
áá  
Stretch
áá  '
;
áá' (
return
àà 
res
àà 
;
àà 
}
ââ 
}
ää 	
public
èè 
void
èè 
Reset
èè 
(
èè 
)
èè 
{
êê 	
m_UseWorldSpace
ëë 
=
ëë 
false
ëë #
;
ëë# $
m_FlipU
íí 
=
íí 
false
íí 
;
íí 
m_FlipV
ìì 
=
ìì 
false
ìì 
;
ìì 
m_SwapUV
îî 
=
îî 
false
îî 
;
îî 
m_Fill
ïï 
=
ïï 
Fill
ïï 
.
ïï 
Tile
ïï 
;
ïï 
m_Scale
ññ 
=
ññ 
new
ññ 
Vector2
ññ !
(
ññ! "
$num
ññ" $
,
ññ$ %
$num
ññ& (
)
ññ( )
;
ññ) *
m_Offset
óó 
=
óó 
new
óó 
Vector2
óó "
(
óó" #
$num
óó# %
,
óó% &
$num
óó' )
)
óó) *
;
óó* +

m_Rotation
òò 
=
òò 
$num
òò 
;
òò 
m_Anchor
ôô 
=
ôô 
Anchor
ôô 
.
ôô 
None
ôô "
;
ôô" #
}
öö 	
public
úú 
override
úú 
string
úú 
ToString
úú '
(
úú' (
)
úú( )
{
ùù 	
string
ûû 
str
ûû 
=
ûû 
$str
üü #
+
üü$ %
useWorldSpace
üü& 3
+
üü4 5
$str
üü6 :
+
üü; <
$str
†† 
+
†† 
flipU
†† "
+
††# $
$str
††% )
+
††* +
$str
°° 
+
°° 
flipV
°° "
+
°°# $
$str
°°% )
+
°°* +
$str
¢¢ 
+
¢¢ 
swapUV
¢¢ $
+
¢¢% &
$str
¢¢' +
+
¢¢, -
$str
££ 
+
££ 
fill
££  $
+
££% &
$str
££' +
+
££, -
$str
§§ 
+
§§ 
anchor
§§ #
+
§§$ %
$str
§§& *
+
§§+ ,
$str
•• 
+
•• 
scale
•• !
+
••" #
$str
••$ (
+
••) *
$str
¶¶ 
+
¶¶ 
offset
¶¶ #
+
¶¶$ %
$str
¶¶& *
+
¶¶+ ,
$str
ßß 
+
ßß 
rotation
ßß '
;
ßß' (
return
®® 
str
®® 
;
®® 
}
©© 	
}
™™ 
}´´ Ôc
åD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\BezierPoint.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
enum		 
BezierTangentMode			 
{

 
Free 
, 
Aligned 
, 
Mirrored 
} 
enum "
BezierTangentDirection	 
{ 
In 

,
 
Out 
} 
[ 
System 
. 
Serializable 
] 
struct 

BezierPoint 
{ 
public 
Vector3 
position 
;  
public 
Vector3 
	tangentIn  
;  !
public 
Vector3 

tangentOut !
;! "
public 

Quaternion 
rotation "
;" #
public!! 
BezierPoint!! 
(!! 
Vector3!! "
position!!# +
,!!+ ,
Vector3!!- 4
	tangentIn!!5 >
,!!> ?
Vector3!!@ G

tangentOut!!H R
,!!R S

Quaternion!!T ^
rotation!!_ g
)!!g h
{"" 	
this## 
.## 
position## 
=## 
position## $
;##$ %
this$$ 
.$$ 
	tangentIn$$ 
=$$ 
	tangentIn$$ &
;$$& '
this%% 
.%% 

tangentOut%% 
=%% 

tangentOut%% (
;%%( )
this&& 
.&& 
rotation&& 
=&& 
rotation&& $
;&&$ %
}'' 	
public)) 
void)) 
EnforceTangentMode)) &
())& '"
BezierTangentDirection))' =
master))> D
,))D E
BezierTangentMode))F W
mode))X \
)))\ ]
{** 	
if++ 
(++ 
mode++ 
==++ 
BezierTangentMode++ )
.++) *
Aligned++* 1
)++1 2
{,, 
if-- 
(-- 
master-- 
==-- "
BezierTangentDirection-- 4
.--4 5
In--5 7
)--7 8

tangentOut.. 
=..  
position..! )
+..* +
(.., -

tangentOut..- 7
-..8 9
position..: B
)..B C
...C D

normalized..D N
*..O P
(..Q R
	tangentIn..R [
-..\ ]
position..^ f
)..f g
...g h
	magnitude..h q
;..q r
else// 
	tangentIn00 
=00 
position00  (
+00) *
(00+ ,
	tangentIn00, 5
-006 7
position008 @
)00@ A
.00A B

normalized00B L
*00M N
(00O P

tangentOut00P Z
-00[ \
position00] e
)00e f
.00f g
	magnitude00g p
;00p q
}11 
else22 
if22 
(22 
mode22 
==22 
BezierTangentMode22 .
.22. /
Mirrored22/ 7
)227 8
{33 
if44 
(44 
master44 
==44 "
BezierTangentDirection44 4
.444 5
In445 7
)447 8

tangentOut55 
=55  
position55! )
-55* +
(55, -
	tangentIn55- 6
-557 8
position559 A
)55A B
;55B C
else66 
	tangentIn77 
=77 
position77  (
-77) *
(77+ ,

tangentOut77, 6
-777 8
position779 A
)77A B
;77B C
}88 
}99 	
public?? 
void?? 
SetPosition?? 
(??  
Vector3??  '
position??( 0
)??0 1
{@@ 	
Vector3AA 
deltaAA 
=AA 
positionAA $
-AA% &
thisAA' +
.AA+ ,
positionAA, 4
;AA4 5
thisBB 
.BB 
positionBB 
=BB 
positionBB $
;BB$ %
thisCC 
.CC 
	tangentInCC 
+=CC 
deltaCC #
;CC# $
thisDD 
.DD 

tangentOutDD 
+=DD 
deltaDD $
;DD$ %
}EE 	
publicGG 
voidGG 
SetTangentInGG  
(GG  !
Vector3GG! (
tangentGG) 0
,GG0 1
BezierTangentModeGG2 C
modeGGD H
)GGH I
{HH 	
thisII 
.II 
	tangentInII 
=II 
tangentII $
;II$ %
EnforceTangentModeJJ 
(JJ "
BezierTangentDirectionJJ 5
.JJ5 6
InJJ6 8
,JJ8 9
modeJJ: >
)JJ> ?
;JJ? @
}KK 	
publicMM 
voidMM 
SetTangentOutMM !
(MM! "
Vector3MM" )
tangentMM* 1
,MM1 2
BezierTangentModeMM3 D
modeMME I
)MMI J
{NN 	
thisOO 
.OO 

tangentOutOO 
=OO 
tangentOO %
;OO% &
EnforceTangentModePP 
(PP "
BezierTangentDirectionPP 5
.PP5 6
OutPP6 9
,PP9 :
modePP; ?
)PP? @
;PP@ A
}QQ 	
publicSS 
staticSS 
Vector3SS 
QuadraticPositionSS /
(SS/ 0
BezierPointSS0 ;
aSS< =
,SS= >
BezierPointSS? J
bSSK L
,SSL M
floatSSN S
tSST U
)SSU V
{TT 	
floatUU 
xUU 
=UU 
(UU 
$numUU 
-UU 
tUU 
)UU 
*UU  
(UU! "
$numUU" $
-UU% &
tUU' (
)UU( )
*UU* +
aUU, -
.UU- .
positionUU. 6
.UU6 7
xUU7 8
+UU9 :
$numUU; =
*UU> ?
(UU@ A
$numUUA C
-UUD E
tUUF G
)UUG H
*UUI J
tUUK L
*UUM N
aUUO P
.UUP Q

tangentOutUUQ [
.UU[ \
xUU\ ]
+UU^ _
tUU` a
*UUb c
tUUd e
*UUf g
bUUh i
.UUi j
positionUUj r
.UUr s
xUUs t
;UUt u
floatVV 
yVV 
=VV 
(VV 
$numVV 
-VV 
tVV 
)VV 
*VV  
(VV! "
$numVV" $
-VV% &
tVV' (
)VV( )
*VV* +
aVV, -
.VV- .
positionVV. 6
.VV6 7
yVV7 8
+VV9 :
$numVV; =
*VV> ?
(VV@ A
$numVVA C
-VVD E
tVVF G
)VVG H
*VVI J
tVVK L
*VVM N
aVVO P
.VVP Q

tangentOutVVQ [
.VV[ \
yVV\ ]
+VV^ _
tVV` a
*VVb c
tVVd e
*VVf g
bVVh i
.VVi j
positionVVj r
.VVr s
yVVs t
;VVt u
floatWW 
zWW 
=WW 
(WW 
$numWW 
-WW 
tWW 
)WW 
*WW  
(WW! "
$numWW" $
-WW% &
tWW' (
)WW( )
*WW* +
aWW, -
.WW- .
positionWW. 6
.WW6 7
zWW7 8
+WW9 :
$numWW; =
*WW> ?
(WW@ A
$numWWA C
-WWD E
tWWF G
)WWG H
*WWI J
tWWK L
*WWM N
aWWO P
.WWP Q

tangentOutWWQ [
.WW[ \
zWW\ ]
+WW^ _
tWW` a
*WWb c
tWWd e
*WWf g
bWWh i
.WWi j
positionWWj r
.WWr s
zWWs t
;WWt u
returnXX 
newXX 
Vector3XX 
(XX 
xXX  
,XX  !
yXX" #
,XX# $
zXX% &
)XX& '
;XX' (
}YY 	
public[[ 
static[[ 
Vector3[[ 
CubicPosition[[ +
([[+ ,
BezierPoint[[, 7
a[[8 9
,[[9 :
BezierPoint[[; F
b[[G H
,[[H I
float[[J O
t[[P Q
)[[Q R
{\\ 	
t]] 
=]] 
Mathf]] 
.]] 
Clamp01]] 
(]] 
t]] 
)]]  
;]]  !
float__ 
	oneMinusT__ 
=__ 
$num__  
-__! "
t__# $
;__$ %
returnaa 
	oneMinusTaa 
*aa 
	oneMinusTaa (
*aa) *
	oneMinusTaa+ 4
*aa5 6
aaa7 8
.aa8 9
positionaa9 A
+aaB C
$numbb 
*bb 
	oneMinusTbb 
*bb  
	oneMinusTbb! *
*bb+ ,
tbb- .
*bb/ 0
abb1 2
.bb2 3

tangentOutbb3 =
+bb> ?
$numcc 
*cc 
	oneMinusTcc 
*cc  
tcc! "
*cc# $
tcc% &
*cc' (
bcc) *
.cc* +
	tangentIncc+ 4
+cc5 6
tdd 
*dd 
tdd 
*dd 
tdd 
*dd 
bdd 
.dd 
positiondd &
;dd& '
}ee 	
publicgg 
staticgg 
Vector3gg 
GetLookDirectiongg .
(gg. /
IListgg/ 4
<gg4 5
BezierPointgg5 @
>gg@ A
pointsggB H
,ggH I
intggJ M
indexggN S
,ggS T
intggU X
previousggY a
,gga b
intggc f
nextggg k
)ggk l
{hh 	
ifii 
(ii 
previousii 
<ii 
$numii 
)ii 
{jj 
returnkk 
(kk 
pointskk 
[kk 
indexkk $
]kk$ %
.kk% &
positionkk& .
-kk/ 0
QuadraticPositionkk1 B
(kkB C
pointskkC I
[kkI J
indexkkJ O
]kkO P
,kkP Q
pointskkR X
[kkX Y
nextkkY ]
]kk] ^
,kk^ _
$numkk` c
)kkc d
)kkd e
.kke f

normalizedkkf p
;kkp q
}ll 
elsemm 
ifmm 
(mm 
nextmm 
<mm 
$nummm 
)mm 
{nn 
returnoo 
(oo 
QuadraticPositionoo )
(oo) *
pointsoo* 0
[oo0 1
indexoo1 6
]oo6 7
,oo7 8
pointsoo9 ?
[oo? @
previousoo@ H
]ooH I
,ooI J
$numooK N
)ooN O
-ooP Q
pointsooR X
[ooX Y
indexooY ^
]oo^ _
.oo_ `
positionoo` h
)ooh i
.ooi j

normalizedooj t
;oot u
}pp 
elseqq 
ifqq 
(qq 
nextqq 
>qq 
-qq 
$numqq 
&&qq !
previousqq" *
>qq+ ,
-qq- .
$numqq. /
)qq/ 0
{rr 
Vector3ss 
ass 
=ss 
(ss 
QuadraticPositionss .
(ss. /
pointsss/ 5
[ss5 6
indexss6 ;
]ss; <
,ss< =
pointsss> D
[ssD E
previousssE M
]ssM N
,ssN O
$numssP S
)ssS T
-ssU V
pointsssW ]
[ss] ^
indexss^ c
]ssc d
.ssd e
positionsse m
)ssm n
.ssn o

normalizedsso y
;ssy z
Vector3tt 
btt 
=tt 
(tt 
QuadraticPositiontt .
(tt. /
pointstt/ 5
[tt5 6
indextt6 ;
]tt; <
,tt< =
pointstt> D
[ttD E
nextttE I
]ttI J
,ttJ K
$numttL O
)ttO P
-ttQ R
pointsttS Y
[ttY Z
indexttZ _
]tt_ `
.tt` a
positiontta i
)tti j
.ttj k

normalizedttk u
;ttu v
returnuu 
(uu 
(uu 
auu 
+uu 
buu 
)uu 
*uu  !
$numuu" %
)uu% &
.uu& '

normalizeduu' 1
;uu1 2
}vv 
elseww 
{xx 
returnyy 
Vector3yy 
.yy 
forwardyy &
;yy& '
}zz 
}{{ 	
}|| 
}}} ı¥
áD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Vertex.cs
	namespace		 	
UnityEngine		
 
.		 

ProBuilder		  
{

 
[ 
Serializable 
] 
public 

sealed 
class 
Vertex 
:  

IEquatable! +
<+ ,
Vertex, 2
>2 3
{ 
[ 	
SerializeField	 
] 
Vector3 

m_Position 
; 
[ 	
SerializeField	 
] 
Color 
m_Color 
; 
[ 	
SerializeField	 
] 
Vector3 
m_Normal 
; 
[ 	
SerializeField	 
] 
Vector4 
	m_Tangent 
; 
[ 	
SerializeField	 
] 
Vector2   
m_UV0   
;   
["" 	
SerializeField""	 
]"" 
Vector2## 
m_UV2## 
;## 
[%% 	
SerializeField%%	 
]%% 
Vector4&& 
m_UV3&& 
;&& 
[(( 	
SerializeField((	 
](( 
Vector4)) 
m_UV4)) 
;)) 
[++ 	
SerializeField++	 
]++ 

MeshArrays,, 
m_Attributes,, 
;,,  
public22 
Vector322 
position22 
{33 	
get44 
{44 
return44 

m_Position44 #
;44# $
}44% &
set55 
{66 
hasPosition77 
=77 
true77 "
;77" #

m_Position88 
=88 
value88 "
;88" #
}99 
}:: 	
public@@ 
Color@@ 
color@@ 
{AA 	
getBB 
{BB 
returnBB 
m_ColorBB  
;BB  !
}BB" #
setCC 
{DD 
hasColorEE 
=EE 
trueEE 
;EE  
m_ColorFF 
=FF 
valueFF 
;FF  
}GG 
}HH 	
publicNN 
Vector3NN 
normalNN 
{OO 	
getPP 
{PP 
returnPP 
m_NormalPP !
;PP! "
}PP# $
setQQ 
{RR 
	hasNormalSS 
=SS 
trueSS  
;SS  !
m_NormalTT 
=TT 
valueTT  
;TT  !
}UU 
}VV 	
public\\ 
Vector4\\ 
tangent\\ 
{]] 	
get^^ 
{^^ 
return^^ 
	m_Tangent^^ "
;^^" #
}^^$ %
set__ 
{`` 

hasTangentaa 
=aa 
trueaa !
;aa! "
	m_Tangentbb 
=bb 
valuebb !
;bb! "
}cc 
}dd 	
publickk 
Vector2kk 
uv0kk 
{ll 	
getmm 
{mm 
returnmm 
m_UV0mm 
;mm 
}mm  !
setnn 
{oo 
hasUV0pp 
=pp 
truepp 
;pp 
m_UV0qq 
=qq 
valueqq 
;qq 
}rr 
}ss 	
publicyy 
Vector2yy 
uv2yy 
{zz 	
get{{ 
{{{ 
return{{ 
m_UV2{{ 
;{{ 
}{{  !
set|| 
{}} 
hasUV2~~ 
=~~ 
true~~ 
;~~ 
m_UV2 
= 
value 
; 
}
ÄÄ 
}
ÅÅ 	
public
áá 
Vector4
áá 
uv3
áá 
{
àà 	
get
ââ 
{
ââ 
return
ââ 
m_UV3
ââ 
;
ââ 
}
ââ  !
set
ää 
{
ãã 
hasUV3
åå 
=
åå 
true
åå 
;
åå 
m_UV3
çç 
=
çç 
value
çç 
;
çç 
}
éé 
}
èè 	
public
ïï 
Vector4
ïï 
uv4
ïï 
{
ññ 	
get
óó 
{
óó 
return
óó 
m_UV4
óó 
;
óó 
}
óó  !
set
òò 
{
ôô 
hasUV4
öö 
=
öö 
true
öö 
;
öö 
m_UV4
õõ 
=
õõ 
value
õõ 
;
õõ 
}
úú 
}
ùù 	
internal
üü 

MeshArrays
üü 

attributes
üü &
{
†† 	
get
°° 
{
°° 
return
°° 
m_Attributes
°° %
;
°°% &
}
°°' (
}
¢¢ 	
public
©© 
bool
©© 
	HasArrays
©© 
(
©© 

MeshArrays
©© (
	attribute
©©) 2
)
©©2 3
{
™™ 	
return
´´ 
(
´´ 
m_Attributes
´´  
&
´´! "
	attribute
´´# ,
)
´´, -
==
´´. 0
	attribute
´´1 :
;
´´: ;
}
¨¨ 	
bool
ÆÆ 
hasPosition
ÆÆ 
{
ØØ 	
get
∞∞ 
{
∞∞ 
return
∞∞ 
(
∞∞ 
m_Attributes
∞∞ &
&
∞∞' (

MeshArrays
∞∞) 3
.
∞∞3 4
Position
∞∞4 <
)
∞∞< =
==
∞∞> @

MeshArrays
∞∞A K
.
∞∞K L
Position
∞∞L T
;
∞∞T U
}
∞∞V W
set
±± 
{
±± 
m_Attributes
±± 
=
±±  
value
±±! &
?
±±' (
(
±±) *
m_Attributes
±±* 6
|
±±7 8

MeshArrays
±±9 C
.
±±C D
Position
±±D L
)
±±L M
:
±±N O
(
±±P Q
m_Attributes
±±Q ]
&
±±^ _
~
±±` a
(
±±a b

MeshArrays
±±b l
.
±±l m
Position
±±m u
)
±±u v
)
±±v w
;
±±w x
}
±±y z
}
≤≤ 	
bool
¥¥ 
hasColor
¥¥ 
{
µµ 	
get
∂∂ 
{
∂∂ 
return
∂∂ 
(
∂∂ 
m_Attributes
∂∂ &
&
∂∂' (

MeshArrays
∂∂) 3
.
∂∂3 4
Color
∂∂4 9
)
∂∂9 :
==
∂∂; =

MeshArrays
∂∂> H
.
∂∂H I
Color
∂∂I N
;
∂∂N O
}
∂∂P Q
set
∑∑ 
{
∑∑ 
m_Attributes
∑∑ 
=
∑∑  
value
∑∑! &
?
∑∑' (
(
∑∑) *
m_Attributes
∑∑* 6
|
∑∑7 8

MeshArrays
∑∑9 C
.
∑∑C D
Color
∑∑D I
)
∑∑I J
:
∑∑K L
(
∑∑M N
m_Attributes
∑∑N Z
&
∑∑[ \
~
∑∑] ^
(
∑∑^ _

MeshArrays
∑∑_ i
.
∑∑i j
Color
∑∑j o
)
∑∑o p
)
∑∑p q
;
∑∑q r
}
∑∑s t
}
∏∏ 	
bool
∫∫ 
	hasNormal
∫∫ 
{
ªª 	
get
ºº 
{
ºº 
return
ºº 
(
ºº 
m_Attributes
ºº &
&
ºº' (

MeshArrays
ºº) 3
.
ºº3 4
Normal
ºº4 :
)
ºº: ;
==
ºº< >

MeshArrays
ºº? I
.
ººI J
Normal
ººJ P
;
ººP Q
}
ººR S
set
ΩΩ 
{
ΩΩ 
m_Attributes
ΩΩ 
=
ΩΩ  
value
ΩΩ! &
?
ΩΩ' (
(
ΩΩ) *
m_Attributes
ΩΩ* 6
|
ΩΩ7 8

MeshArrays
ΩΩ9 C
.
ΩΩC D
Normal
ΩΩD J
)
ΩΩJ K
:
ΩΩL M
(
ΩΩN O
m_Attributes
ΩΩO [
&
ΩΩ\ ]
~
ΩΩ^ _
(
ΩΩ_ `

MeshArrays
ΩΩ` j
.
ΩΩj k
Normal
ΩΩk q
)
ΩΩq r
)
ΩΩr s
;
ΩΩs t
}
ΩΩu v
}
ææ 	
bool
¿¿ 

hasTangent
¿¿ 
{
¡¡ 	
get
¬¬ 
{
¬¬ 
return
¬¬ 
(
¬¬ 
m_Attributes
¬¬ &
&
¬¬' (

MeshArrays
¬¬) 3
.
¬¬3 4
Tangent
¬¬4 ;
)
¬¬; <
==
¬¬= ?

MeshArrays
¬¬@ J
.
¬¬J K
Tangent
¬¬K R
;
¬¬R S
}
¬¬T U
set
√√ 
{
√√ 
m_Attributes
√√ 
=
√√  
value
√√! &
?
√√' (
(
√√) *
m_Attributes
√√* 6
|
√√7 8

MeshArrays
√√9 C
.
√√C D
Tangent
√√D K
)
√√K L
:
√√M N
(
√√O P
m_Attributes
√√P \
&
√√] ^
~
√√_ `
(
√√` a

MeshArrays
√√a k
.
√√k l
Tangent
√√l s
)
√√s t
)
√√t u
;
√√u v
}
√√w x
}
ƒƒ 	
bool
∆∆ 
hasUV0
∆∆ 
{
«« 	
get
»» 
{
»» 
return
»» 
(
»» 
m_Attributes
»» &
&
»»' (

MeshArrays
»») 3
.
»»3 4
Texture0
»»4 <
)
»»< =
==
»»> @

MeshArrays
»»A K
.
»»K L
Texture0
»»L T
;
»»T U
}
»»V W
set
…… 
{
…… 
m_Attributes
…… 
=
……  
value
……! &
?
……' (
(
……) *
m_Attributes
……* 6
|
……7 8

MeshArrays
……9 C
.
……C D
Texture0
……D L
)
……L M
:
……N O
(
……P Q
m_Attributes
……Q ]
&
……^ _
~
……` a
(
……a b

MeshArrays
……b l
.
……l m
Texture0
……m u
)
……u v
)
……v w
;
……w x
}
……y z
}
   	
bool
ÃÃ 
hasUV2
ÃÃ 
{
ÕÕ 	
get
ŒŒ 
{
ŒŒ 
return
ŒŒ 
(
ŒŒ 
m_Attributes
ŒŒ &
&
ŒŒ' (

MeshArrays
ŒŒ) 3
.
ŒŒ3 4
Texture1
ŒŒ4 <
)
ŒŒ< =
==
ŒŒ> @

MeshArrays
ŒŒA K
.
ŒŒK L
Texture1
ŒŒL T
;
ŒŒT U
}
ŒŒV W
set
œœ 
{
œœ 
m_Attributes
œœ 
=
œœ  
value
œœ! &
?
œœ' (
(
œœ) *
m_Attributes
œœ* 6
|
œœ7 8

MeshArrays
œœ9 C
.
œœC D
Texture1
œœD L
)
œœL M
:
œœN O
(
œœP Q
m_Attributes
œœQ ]
&
œœ^ _
~
œœ` a
(
œœa b

MeshArrays
œœb l
.
œœl m
Texture1
œœm u
)
œœu v
)
œœv w
;
œœw x
}
œœy z
}
–– 	
bool
““ 
hasUV3
““ 
{
”” 	
get
‘‘ 
{
‘‘ 
return
‘‘ 
(
‘‘ 
m_Attributes
‘‘ &
&
‘‘' (

MeshArrays
‘‘) 3
.
‘‘3 4
Texture2
‘‘4 <
)
‘‘< =
==
‘‘> @

MeshArrays
‘‘A K
.
‘‘K L
Texture2
‘‘L T
;
‘‘T U
}
‘‘V W
set
’’ 
{
’’ 
m_Attributes
’’ 
=
’’  
value
’’! &
?
’’' (
(
’’) *
m_Attributes
’’* 6
|
’’7 8

MeshArrays
’’9 C
.
’’C D
Texture2
’’D L
)
’’L M
:
’’N O
(
’’P Q
m_Attributes
’’Q ]
&
’’^ _
~
’’` a
(
’’a b

MeshArrays
’’b l
.
’’l m
Texture2
’’m u
)
’’u v
)
’’v w
;
’’w x
}
’’y z
}
÷÷ 	
bool
ÿÿ 
hasUV4
ÿÿ 
{
ŸŸ 	
get
⁄⁄ 
{
⁄⁄ 
return
⁄⁄ 
(
⁄⁄ 
m_Attributes
⁄⁄ &
&
⁄⁄' (

MeshArrays
⁄⁄) 3
.
⁄⁄3 4
Texture3
⁄⁄4 <
)
⁄⁄< =
==
⁄⁄> @

MeshArrays
⁄⁄A K
.
⁄⁄K L
Texture3
⁄⁄L T
;
⁄⁄T U
}
⁄⁄V W
set
€€ 
{
€€ 
m_Attributes
€€ 
=
€€  
value
€€! &
?
€€' (
(
€€) *
m_Attributes
€€* 6
|
€€7 8

MeshArrays
€€9 C
.
€€C D
Texture3
€€D L
)
€€L M
:
€€N O
(
€€P Q
m_Attributes
€€Q ]
&
€€^ _
~
€€` a
(
€€a b

MeshArrays
€€b l
.
€€l m
Texture3
€€m u
)
€€u v
)
€€v w
;
€€w x
}
€€y z
}
‹‹ 	
public
·· 
Vertex
·· 
(
·· 
)
·· 
{
‚‚ 	
}
„„ 	
public
ÍÍ 
override
ÍÍ 
bool
ÍÍ 
Equals
ÍÍ #
(
ÍÍ# $
object
ÍÍ$ *
obj
ÍÍ+ .
)
ÍÍ. /
{
ÎÎ 	
return
ÏÏ 
obj
ÏÏ 
is
ÏÏ 
Vertex
ÏÏ  
&&
ÏÏ! #
Equals
ÏÏ$ *
(
ÏÏ* +
(
ÏÏ+ ,
Vertex
ÏÏ, 2
)
ÏÏ2 3
obj
ÏÏ3 6
)
ÏÏ6 7
;
ÏÏ7 8
}
ÌÌ 	
public
ÙÙ 
bool
ÙÙ 
Equals
ÙÙ 
(
ÙÙ 
Vertex
ÙÙ !
other
ÙÙ" '
)
ÙÙ' (
{
ıı 	
if
ˆˆ 
(
ˆˆ 
ReferenceEquals
ˆˆ 
(
ˆˆ  
other
ˆˆ  %
,
ˆˆ% &
null
ˆˆ' +
)
ˆˆ+ ,
)
ˆˆ, -
return
˜˜ 
false
˜˜ 
;
˜˜ 
return
˘˘ 
Math
˘˘ 
.
˘˘ 
Approx3
˘˘ 
(
˘˘  

m_Position
˘˘  *
,
˘˘* +
other
˘˘, 1
.
˘˘1 2

m_Position
˘˘2 <
)
˘˘< =
&&
˘˘> @
Math
˙˙ 
.
˙˙ 
ApproxC
˙˙ 
(
˙˙ 
m_Color
˙˙ $
,
˙˙$ %
other
˙˙& +
.
˙˙+ ,
m_Color
˙˙, 3
)
˙˙3 4
&&
˙˙5 7
Math
˚˚ 
.
˚˚ 
Approx3
˚˚ 
(
˚˚ 
m_Normal
˚˚ %
,
˚˚% &
other
˚˚' ,
.
˚˚, -
m_Normal
˚˚- 5
)
˚˚5 6
&&
˚˚7 9
Math
¸¸ 
.
¸¸ 
Approx4
¸¸ 
(
¸¸ 
	m_Tangent
¸¸ &
,
¸¸& '
other
¸¸( -
.
¸¸- .
	m_Tangent
¸¸. 7
)
¸¸7 8
&&
¸¸9 ;
Math
˝˝ 
.
˝˝ 
Approx2
˝˝ 
(
˝˝ 
m_UV0
˝˝ "
,
˝˝" #
other
˝˝$ )
.
˝˝) *
m_UV0
˝˝* /
)
˝˝/ 0
&&
˝˝1 3
Math
˛˛ 
.
˛˛ 
Approx2
˛˛ 
(
˛˛ 
m_UV2
˛˛ "
,
˛˛" #
other
˛˛$ )
.
˛˛) *
m_UV2
˛˛* /
)
˛˛/ 0
&&
˛˛1 3
Math
ˇˇ 
.
ˇˇ 
Approx4
ˇˇ 
(
ˇˇ 
m_UV3
ˇˇ "
,
ˇˇ" #
other
ˇˇ$ )
.
ˇˇ) *
m_UV3
ˇˇ* /
)
ˇˇ/ 0
&&
ˇˇ1 3
Math
ÄÄ 
.
ÄÄ 
Approx4
ÄÄ 
(
ÄÄ 
m_UV4
ÄÄ "
,
ÄÄ" #
other
ÄÄ$ )
.
ÄÄ) *
m_UV4
ÄÄ* /
)
ÄÄ/ 0
;
ÄÄ0 1
}
ÅÅ 	
public
ÉÉ 
bool
ÉÉ 
Equals
ÉÉ 
(
ÉÉ 
Vertex
ÉÉ !
other
ÉÉ" '
,
ÉÉ' (

MeshArrays
ÉÉ) 3
mask
ÉÉ4 8
)
ÉÉ8 9
{
ÑÑ 	
if
ÖÖ 
(
ÖÖ 
ReferenceEquals
ÖÖ 
(
ÖÖ  
other
ÖÖ  %
,
ÖÖ% &
null
ÖÖ' +
)
ÖÖ+ ,
)
ÖÖ, -
return
ÜÜ 
false
ÜÜ 
;
ÜÜ 
return
àà 
(
àà 
(
àà 
mask
àà 
&
àà 

MeshArrays
àà &
.
àà& '
Position
àà' /
)
àà/ 0
!=
àà1 3

MeshArrays
àà4 >
.
àà> ?
Position
àà? G
||
ààH J
Math
ààK O
.
ààO P
Approx3
ààP W
(
ààW X

m_Position
ààX b
,
ààb c
other
ààd i
.
àài j

m_Position
ààj t
)
ààt u
)
ààu v
&&
ààw y
(
ââ 
(
ââ 
mask
ââ 
&
ââ 

MeshArrays
ââ #
.
ââ# $
Color
ââ$ )
)
ââ) *
!=
ââ+ -

MeshArrays
ââ. 8
.
ââ8 9
Color
ââ9 >
||
ââ? A
Math
ââB F
.
ââF G
ApproxC
ââG N
(
ââN O
m_Color
ââO V
,
ââV W
other
ââX ]
.
ââ] ^
m_Color
ââ^ e
)
ââe f
)
ââf g
&&
ââh j
(
ää 
(
ää 
mask
ää 
&
ää 

MeshArrays
ää #
.
ää# $
Normal
ää$ *
)
ää* +
!=
ää, .

MeshArrays
ää/ 9
.
ää9 :
Normal
ää: @
||
ääA C
Math
ääD H
.
ääH I
Approx3
ääI P
(
ääP Q
m_Normal
ääQ Y
,
ääY Z
other
ää[ `
.
ää` a
m_Normal
ääa i
)
ääi j
)
ääj k
&&
ääl n
(
ãã 
(
ãã 
mask
ãã 
&
ãã 

MeshArrays
ãã #
.
ãã# $
Tangent
ãã$ +
)
ãã+ ,
!=
ãã- /

MeshArrays
ãã0 :
.
ãã: ;
Tangent
ãã; B
||
ããC E
Math
ããF J
.
ããJ K
Approx4
ããK R
(
ããR S
	m_Tangent
ããS \
,
ãã\ ]
other
ãã^ c
.
ããc d
	m_Tangent
ããd m
)
ããm n
)
ããn o
&&
ããp r
(
åå 
(
åå 
mask
åå 
&
åå 

MeshArrays
åå #
.
åå# $
Texture0
åå$ ,
)
åå, -
!=
åå. 0

MeshArrays
åå1 ;
.
åå; <
Texture0
åå< D
||
ååE G
Math
ååH L
.
ååL M
Approx2
ååM T
(
ååT U
m_UV0
ååU Z
,
ååZ [
other
åå\ a
.
ååa b
m_UV0
ååb g
)
ååg h
)
ååh i
&&
ååj l
(
çç 
(
çç 
mask
çç 
&
çç 

MeshArrays
çç #
.
çç# $
Texture1
çç$ ,
)
çç, -
!=
çç. 0

MeshArrays
çç1 ;
.
çç; <
Texture1
çç< D
||
ççE G
Math
ççH L
.
ççL M
Approx2
ççM T
(
ççT U
m_UV2
ççU Z
,
ççZ [
other
çç\ a
.
çça b
m_UV2
ççb g
)
ççg h
)
ççh i
&&
ççj l
(
éé 
(
éé 
mask
éé 
&
éé 

MeshArrays
éé #
.
éé# $
Texture2
éé$ ,
)
éé, -
!=
éé. 0

MeshArrays
éé1 ;
.
éé; <
Texture2
éé< D
||
ééE G
Math
ééH L
.
ééL M
Approx4
ééM T
(
ééT U
m_UV3
ééU Z
,
ééZ [
other
éé\ a
.
ééa b
m_UV3
ééb g
)
éég h
)
ééh i
&&
ééj l
(
èè 
(
èè 
mask
èè 
&
èè 

MeshArrays
èè #
.
èè# $
Texture3
èè$ ,
)
èè, -
!=
èè. 0

MeshArrays
èè1 ;
.
èè; <
Texture3
èè< D
||
èèE G
Math
èèH L
.
èèL M
Approx4
èèM T
(
èèT U
m_UV4
èèU Z
,
èèZ [
other
èè\ a
.
èèa b
m_UV4
èèb g
)
èèg h
)
èèh i
;
èèi j
}
êê 	
public
ññ 
override
ññ 
int
ññ 
GetHashCode
ññ '
(
ññ' (
)
ññ( )
{
óó 	
	unchecked
ôô 
{
öö 
int
õõ 
hash
õõ 
=
õõ 
$num
õõ 
+
õõ  

VectorHash
õõ! +
.
õõ+ ,
GetHashCode
õõ, 7
(
õõ7 8
position
õõ8 @
)
õõ@ A
;
õõA B
hash
úú 
=
úú 
hash
úú 
*
úú 
$num
úú  
+
úú! "

VectorHash
úú# -
.
úú- .
GetHashCode
úú. 9
(
úú9 :
uv0
úú: =
)
úú= >
;
úú> ?
hash
ùù 
=
ùù 
hash
ùù 
*
ùù 
$num
ùù  
+
ùù! "

VectorHash
ùù# -
.
ùù- .
GetHashCode
ùù. 9
(
ùù9 :
normal
ùù: @
)
ùù@ A
;
ùùA B
return
ûû 
hash
ûû 
;
ûû 
}
üü 
}
†† 	
public
¶¶ 
Vertex
¶¶ 
(
¶¶ 
Vertex
¶¶ 
vertex
¶¶ #
)
¶¶# $
{
ßß 	
if
®® 
(
®® 
vertex
®® 
==
®® 
null
®® 
)
®® 
throw
©© 
new
©© #
ArgumentNullException
©© /
(
©©/ 0
$str
©©0 8
)
©©8 9
;
©©9 :

m_Position
´´ 
=
´´ 
vertex
´´ 
.
´´  

m_Position
´´  *
;
´´* +
hasPosition
¨¨ 
=
¨¨ 
vertex
¨¨  
.
¨¨  !
hasPosition
¨¨! ,
;
¨¨, -
m_Color
≠≠ 
=
≠≠ 
vertex
≠≠ 
.
≠≠ 
m_Color
≠≠ $
;
≠≠$ %
hasColor
ÆÆ 
=
ÆÆ 
vertex
ÆÆ 
.
ÆÆ 
hasColor
ÆÆ &
;
ÆÆ& '
m_UV0
ØØ 
=
ØØ 
vertex
ØØ 
.
ØØ 
m_UV0
ØØ  
;
ØØ  !
hasUV0
∞∞ 
=
∞∞ 
vertex
∞∞ 
.
∞∞ 
hasUV0
∞∞ "
;
∞∞" #
m_Normal
±± 
=
±± 
vertex
±± 
.
±± 
m_Normal
±± &
;
±±& '
	hasNormal
≤≤ 
=
≤≤ 
vertex
≤≤ 
.
≤≤ 
	hasNormal
≤≤ (
;
≤≤( )
	m_Tangent
≥≥ 
=
≥≥ 
vertex
≥≥ 
.
≥≥ 
	m_Tangent
≥≥ (
;
≥≥( )

hasTangent
¥¥ 
=
¥¥ 
vertex
¥¥ 
.
¥¥  

hasTangent
¥¥  *
;
¥¥* +
m_UV2
µµ 
=
µµ 
vertex
µµ 
.
µµ 
m_UV2
µµ  
;
µµ  !
hasUV2
∂∂ 
=
∂∂ 
vertex
∂∂ 
.
∂∂ 
hasUV2
∂∂ "
;
∂∂" #
m_UV3
∑∑ 
=
∑∑ 
vertex
∑∑ 
.
∑∑ 
m_UV3
∑∑  
;
∑∑  !
hasUV3
∏∏ 
=
∏∏ 
vertex
∏∏ 
.
∏∏ 
hasUV3
∏∏ "
;
∏∏" #
m_UV4
ππ 
=
ππ 
vertex
ππ 
.
ππ 
m_UV4
ππ  
;
ππ  !
hasUV4
∫∫ 
=
∫∫ 
vertex
∫∫ 
.
∫∫ 
hasUV4
∫∫ "
;
∫∫" #
}
ªª 	
public
ææ 
static
ææ 
bool
ææ 
operator
ææ #
==
ææ# %
(
ææ% &
Vertex
ææ& ,
a
ææ- .
,
ææ. /
Vertex
ææ0 6
b
ææ7 8
)
ææ8 9
{
øø 	
if
¿¿ 
(
¿¿ 
ReferenceEquals
¿¿ 
(
¿¿  
a
¿¿  !
,
¿¿! "
b
¿¿# $
)
¿¿$ %
)
¿¿% &
return
¡¡ 
true
¡¡ 
;
¡¡ 
if
√√ 
(
√√ 
object
√√ 
.
√√ 
ReferenceEquals
√√ &
(
√√& '
a
√√' (
,
√√( )
null
√√* .
)
√√. /
||
√√0 2
object
√√3 9
.
√√9 :
ReferenceEquals
√√: I
(
√√I J
b
√√J K
,
√√K L
null
√√M Q
)
√√Q R
)
√√R S
return
ƒƒ 
false
ƒƒ 
;
ƒƒ 
return
∆∆ 
a
∆∆ 
.
∆∆ 
Equals
∆∆ 
(
∆∆ 
b
∆∆ 
)
∆∆ 
;
∆∆ 
}
«« 	
public
œœ 
static
œœ 
bool
œœ 
operator
œœ #
!=
œœ# %
(
œœ% &
Vertex
œœ& ,
a
œœ- .
,
œœ. /
Vertex
œœ0 6
b
œœ7 8
)
œœ8 9
{
–– 	
return
—— 
!
—— 
(
—— 
a
—— 
==
—— 
b
—— 
)
—— 
;
—— 
}
““ 	
public
›› 
static
›› 
Vertex
›› 
operator
›› %
+
››% &
(
››& '
Vertex
››' -
a
››. /
,
››/ 0
Vertex
››1 7
b
››8 9
)
››9 :
{
ﬁﬁ 	
return
ﬂﬂ 
Add
ﬂﬂ 
(
ﬂﬂ 
a
ﬂﬂ 
,
ﬂﬂ 
b
ﬂﬂ 
)
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 	
public
ÎÎ 
static
ÎÎ 
Vertex
ÎÎ 
Add
ÎÎ  
(
ÎÎ  !
Vertex
ÎÎ! '
a
ÎÎ( )
,
ÎÎ) *
Vertex
ÎÎ+ 1
b
ÎÎ2 3
)
ÎÎ3 4
{
ÏÏ 	
Vertex
ÌÌ 
v
ÌÌ 
=
ÌÌ 
new
ÌÌ 
Vertex
ÌÌ !
(
ÌÌ! "
a
ÌÌ" #
)
ÌÌ# $
;
ÌÌ$ %
v
ÓÓ 
.
ÓÓ 
Add
ÓÓ 
(
ÓÓ 
b
ÓÓ 
)
ÓÓ 
;
ÓÓ 
return
ÔÔ 
v
ÔÔ 
;
ÔÔ 
}
 	
public
˘˘ 
void
˘˘ 
Add
˘˘ 
(
˘˘ 
Vertex
˘˘ 
b
˘˘  
)
˘˘  !
{
˙˙ 	
if
˚˚ 
(
˚˚ 
b
˚˚ 
==
˚˚ 
null
˚˚ 
)
˚˚ 
throw
¸¸ 
new
¸¸ #
ArgumentNullException
¸¸ /
(
¸¸/ 0
$str
¸¸0 3
)
¸¸3 4
;
¸¸4 5

m_Position
˛˛ 
+=
˛˛ 
b
˛˛ 
.
˛˛ 

m_Position
˛˛ &
;
˛˛& '
m_Color
ˇˇ 
+=
ˇˇ 
b
ˇˇ 
.
ˇˇ 
m_Color
ˇˇ  
;
ˇˇ  !
m_Normal
ÄÄ 
+=
ÄÄ 
b
ÄÄ 
.
ÄÄ 
m_Normal
ÄÄ "
;
ÄÄ" #
	m_Tangent
ÅÅ 
+=
ÅÅ 
b
ÅÅ 
.
ÅÅ 
	m_Tangent
ÅÅ $
;
ÅÅ$ %
m_UV0
ÇÇ 
+=
ÇÇ 
b
ÇÇ 
.
ÇÇ 
m_UV0
ÇÇ 
;
ÇÇ 
m_UV2
ÉÉ 
+=
ÉÉ 
b
ÉÉ 
.
ÉÉ 
m_UV2
ÉÉ 
;
ÉÉ 
m_UV3
ÑÑ 
+=
ÑÑ 
b
ÑÑ 
.
ÑÑ 
m_UV3
ÑÑ 
;
ÑÑ 
m_UV4
ÖÖ 
+=
ÖÖ 
b
ÖÖ 
.
ÖÖ 
m_UV4
ÖÖ 
;
ÖÖ 
}
ÜÜ 	
public
ëë 
static
ëë 
Vertex
ëë 
operator
ëë %
-
ëë% &
(
ëë& '
Vertex
ëë' -
a
ëë. /
,
ëë/ 0
Vertex
ëë1 7
b
ëë8 9
)
ëë9 :
{
íí 	
return
ìì 
Subtract
ìì 
(
ìì 
a
ìì 
,
ìì 
b
ìì  
)
ìì  !
;
ìì! "
}
îî 	
public
üü 
static
üü 
Vertex
üü 
Subtract
üü %
(
üü% &
Vertex
üü& ,
a
üü- .
,
üü. /
Vertex
üü0 6
b
üü7 8
)
üü8 9
{
†† 	
var
°° 
c
°° 
=
°° 
new
°° 
Vertex
°° 
(
°° 
a
°°  
)
°°  !
;
°°! "
c
¢¢ 
.
¢¢ 
Subtract
¢¢ 
(
¢¢ 
b
¢¢ 
)
¢¢ 
;
¢¢ 
return
££ 
c
££ 
;
££ 
}
§§ 	
public
≠≠ 
void
≠≠ 
Subtract
≠≠ 
(
≠≠ 
Vertex
≠≠ #
b
≠≠$ %
)
≠≠% &
{
ÆÆ 	
if
ØØ 
(
ØØ 
b
ØØ 
==
ØØ 
null
ØØ 
)
ØØ 
throw
∞∞ 
new
∞∞ #
ArgumentNullException
∞∞ /
(
∞∞/ 0
$str
∞∞0 3
)
∞∞3 4
;
∞∞4 5

m_Position
≤≤ 
-=
≤≤ 
b
≤≤ 
.
≤≤ 

m_Position
≤≤ &
;
≤≤& '
m_Color
≥≥ 
-=
≥≥ 
b
≥≥ 
.
≥≥ 
m_Color
≥≥  
;
≥≥  !
m_Normal
¥¥ 
-=
¥¥ 
b
¥¥ 
.
¥¥ 
m_Normal
¥¥ "
;
¥¥" #
	m_Tangent
µµ 
-=
µµ 
b
µµ 
.
µµ 
	m_Tangent
µµ $
;
µµ$ %
m_UV0
∂∂ 
-=
∂∂ 
b
∂∂ 
.
∂∂ 
m_UV0
∂∂ 
;
∂∂ 
m_UV2
∑∑ 
-=
∑∑ 
b
∑∑ 
.
∑∑ 
m_UV2
∑∑ 
;
∑∑ 
m_UV3
∏∏ 
-=
∏∏ 
b
∏∏ 
.
∏∏ 
m_UV3
∏∏ 
;
∏∏ 
m_UV4
ππ 
-=
ππ 
b
ππ 
.
ππ 
m_UV4
ππ 
;
ππ 
}
∫∫ 	
public
≈≈ 
static
≈≈ 
Vertex
≈≈ 
operator
≈≈ %
*
≈≈% &
(
≈≈& '
Vertex
≈≈' -
a
≈≈. /
,
≈≈/ 0
float
≈≈1 6
value
≈≈7 <
)
≈≈< =
{
∆∆ 	
return
«« 
Multiply
«« 
(
«« 
a
«« 
,
«« 
value
«« $
)
««$ %
;
««% &
}
»» 	
public
–– 
static
–– 
Vertex
–– 
Multiply
–– %
(
––% &
Vertex
––& ,
a
––- .
,
––. /
float
––0 5
value
––6 ;
)
––; <
{
—— 	
Vertex
““ 
v
““ 
=
““ 
new
““ 
Vertex
““ !
(
““! "
a
““" #
)
““# $
;
““$ %
v
”” 
.
”” 
Multiply
”” 
(
”” 
value
”” 
)
”” 
;
”” 
return
‘‘ 
v
‘‘ 
;
‘‘ 
}
’’ 	
public
ﬁﬁ 
void
ﬁﬁ 
Multiply
ﬁﬁ 
(
ﬁﬁ 
float
ﬁﬁ "
value
ﬁﬁ# (
)
ﬁﬁ( )
{
ﬂﬂ 	

m_Position
‡‡ 
*=
‡‡ 
value
‡‡ 
;
‡‡  
m_Color
·· 
*=
·· 
value
·· 
;
·· 
m_Normal
‚‚ 
*=
‚‚ 
value
‚‚ 
;
‚‚ 
	m_Tangent
„„ 
*=
„„ 
value
„„ 
;
„„ 
m_UV0
‰‰ 
*=
‰‰ 
value
‰‰ 
;
‰‰ 
m_UV2
ÂÂ 
*=
ÂÂ 
value
ÂÂ 
;
ÂÂ 
m_UV3
ÊÊ 
*=
ÊÊ 
value
ÊÊ 
;
ÊÊ 
m_UV4
ÁÁ 
*=
ÁÁ 
value
ÁÁ 
;
ÁÁ 
}
ËË 	
public
ÛÛ 
static
ÛÛ 
Vertex
ÛÛ 
operator
ÛÛ %
/
ÛÛ% &
(
ÛÛ& '
Vertex
ÛÛ' -
a
ÛÛ. /
,
ÛÛ/ 0
float
ÛÛ1 6
value
ÛÛ7 <
)
ÛÛ< =
{
ÙÙ 	
return
ıı 
Divide
ıı 
(
ıı 
a
ıı 
,
ıı 
value
ıı "
)
ıı" #
;
ıı# $
}
ˆˆ 	
public
ÅÅ 
static
ÅÅ 
Vertex
ÅÅ 
Divide
ÅÅ #
(
ÅÅ# $
Vertex
ÅÅ$ *
a
ÅÅ+ ,
,
ÅÅ, -
float
ÅÅ. 3
value
ÅÅ4 9
)
ÅÅ9 :
{
ÇÇ 	
Vertex
ÉÉ 
v
ÉÉ 
=
ÉÉ 
new
ÉÉ 
Vertex
ÉÉ !
(
ÉÉ! "
a
ÉÉ" #
)
ÉÉ# $
;
ÉÉ$ %
v
ÑÑ 
.
ÑÑ 
Divide
ÑÑ 
(
ÑÑ 
value
ÑÑ 
)
ÑÑ 
;
ÑÑ 
return
ÖÖ 
v
ÖÖ 
;
ÖÖ 
}
ÜÜ 	
public
èè 
void
èè 
Divide
èè 
(
èè 
float
èè  
value
èè! &
)
èè& '
{
êê 	

m_Position
ëë 
/=
ëë 
value
ëë 
;
ëë  
m_Color
íí 
/=
íí 
value
íí 
;
íí 
m_Normal
ìì 
/=
ìì 
value
ìì 
;
ìì 
	m_Tangent
îî 
/=
îî 
value
îî 
;
îî 
m_UV0
ïï 
/=
ïï 
value
ïï 
;
ïï 
m_UV2
ññ 
/=
ññ 
value
ññ 
;
ññ 
m_UV3
óó 
/=
óó 
value
óó 
;
óó 
m_UV4
òò 
/=
òò 
value
òò 
;
òò 
}
ôô 	
public
ûû 
void
ûû 
	Normalize
ûû 
(
ûû 
)
ûû 
{
üü 	

m_Position
†† 
.
†† 
	Normalize
††  
(
††  !
)
††! "
;
††" #
Vector4
°° 
color4
°° 
=
°° 
m_Color
°° $
;
°°$ %
color4
¢¢ 
.
¢¢ 
	Normalize
¢¢ 
(
¢¢ 
)
¢¢ 
;
¢¢ 
m_Color
££ 
=
££ 
color4
££ 
;
££ 
m_Normal
§§ 
.
§§ 
	Normalize
§§ 
(
§§ 
)
§§  
;
§§  !
	m_Tangent
•• 
.
•• 
	Normalize
•• 
(
••  
)
••  !
;
••! "
m_UV0
¶¶ 
.
¶¶ 
	Normalize
¶¶ 
(
¶¶ 
)
¶¶ 
;
¶¶ 
m_UV2
ßß 
.
ßß 
	Normalize
ßß 
(
ßß 
)
ßß 
;
ßß 
m_UV3
®® 
.
®® 
	Normalize
®® 
(
®® 
)
®® 
;
®® 
m_UV4
©© 
.
©© 
	Normalize
©© 
(
©© 
)
©© 
;
©© 
}
™™ 	
public
±± 
string
±± 
ToString
±± 
(
±± 
string
±± %
args
±±& *
=
±±+ ,
null
±±- 1
)
±±1 2
{
≤≤ 	
StringBuilder
≥≥ 
sb
≥≥ 
=
≥≥ 
new
≥≥ "
StringBuilder
≥≥# 0
(
≥≥0 1
)
≥≥1 2
;
≥≥2 3
if
¥¥ 
(
¥¥ 
hasPosition
¥¥ 
)
¥¥ 
sb
¥¥ 
.
¥¥  

AppendLine
¥¥  *
(
¥¥* +
$str
¥¥+ 7
+
¥¥8 9

m_Position
¥¥: D
.
¥¥D E
ToString
¥¥E M
(
¥¥M N
args
¥¥N R
)
¥¥R S
)
¥¥S T
;
¥¥T U
if
µµ 
(
µµ 
hasColor
µµ 
)
µµ 
sb
µµ 
.
µµ 

AppendLine
µµ '
(
µµ' (
$str
µµ( 1
+
µµ2 3
m_Color
µµ4 ;
.
µµ; <
ToString
µµ< D
(
µµD E
args
µµE I
)
µµI J
)
µµJ K
;
µµK L
if
∂∂ 
(
∂∂ 
	hasNormal
∂∂ 
)
∂∂ 
sb
∂∂ 
.
∂∂ 

AppendLine
∂∂ (
(
∂∂( )
$str
∂∂) 3
+
∂∂4 5
m_Normal
∂∂6 >
.
∂∂> ?
ToString
∂∂? G
(
∂∂G H
args
∂∂H L
)
∂∂L M
)
∂∂M N
;
∂∂N O
if
∑∑ 
(
∑∑ 

hasTangent
∑∑ 
)
∑∑ 
sb
∑∑ 
.
∑∑ 

AppendLine
∑∑ )
(
∑∑) *
$str
∑∑* 5
+
∑∑6 7
	m_Tangent
∑∑8 A
.
∑∑A B
ToString
∑∑B J
(
∑∑J K
args
∑∑K O
)
∑∑O P
)
∑∑P Q
;
∑∑Q R
if
∏∏ 
(
∏∏ 
hasUV0
∏∏ 
)
∏∏ 
sb
∏∏ 
.
∏∏ 

AppendLine
∏∏ %
(
∏∏% &
$str
∏∏& -
+
∏∏. /
m_UV0
∏∏0 5
.
∏∏5 6
ToString
∏∏6 >
(
∏∏> ?
args
∏∏? C
)
∏∏C D
)
∏∏D E
;
∏∏E F
if
ππ 
(
ππ 
hasUV2
ππ 
)
ππ 
sb
ππ 
.
ππ 

AppendLine
ππ %
(
ππ% &
$str
ππ& -
+
ππ. /
m_UV2
ππ0 5
.
ππ5 6
ToString
ππ6 >
(
ππ> ?
args
ππ? C
)
ππC D
)
ππD E
;
ππE F
if
∫∫ 
(
∫∫ 
hasUV3
∫∫ 
)
∫∫ 
sb
∫∫ 
.
∫∫ 

AppendLine
∫∫ %
(
∫∫% &
$str
∫∫& -
+
∫∫. /
m_UV3
∫∫0 5
.
∫∫5 6
ToString
∫∫6 >
(
∫∫> ?
args
∫∫? C
)
∫∫C D
)
∫∫D E
;
∫∫E F
if
ªª 
(
ªª 
hasUV4
ªª 
)
ªª 
sb
ªª 
.
ªª 

AppendLine
ªª %
(
ªª% &
$str
ªª& -
+
ªª. /
m_UV4
ªª0 5
.
ªª5 6
ToString
ªª6 >
(
ªª> ?
args
ªª? C
)
ªªC D
)
ªªD E
;
ªªE F
return
ºº 
sb
ºº 
.
ºº 
ToString
ºº 
(
ºº 
)
ºº  
;
ºº  !
}
ΩΩ 	
public
œœ 
static
œœ 
void
œœ 
	GetArrays
œœ $
(
œœ$ %
IList
–– 
<
–– 
Vertex
–– 
>
–– 
vertices
–– "
,
––" #
out
—— 
Vector3
—— 
[
—— 
]
—— 
position
—— "
,
——" #
out
““ 
Color
““ 
[
““ 
]
““ 
color
““ 
,
““ 
out
”” 
Vector2
”” 
[
”” 
]
”” 
uv0
”” 
,
”” 
out
‘‘ 
Vector3
‘‘ 
[
‘‘ 
]
‘‘ 
normal
‘‘  
,
‘‘  !
out
’’ 
Vector4
’’ 
[
’’ 
]
’’ 
tangent
’’ !
,
’’! "
out
÷÷ 
Vector2
÷÷ 
[
÷÷ 
]
÷÷ 
uv2
÷÷ 
,
÷÷ 
out
◊◊ 
List
◊◊ 
<
◊◊ 
Vector4
◊◊ 
>
◊◊ 
uv3
◊◊ !
,
◊◊! "
out
ÿÿ 
List
ÿÿ 
<
ÿÿ 
Vector4
ÿÿ 
>
ÿÿ 
uv4
ÿÿ !
)
ÿÿ! "
{
ŸŸ 	
	GetArrays
⁄⁄ 
(
⁄⁄ 
vertices
⁄⁄ 
,
⁄⁄ 
out
⁄⁄  #
position
⁄⁄$ ,
,
⁄⁄, -
out
⁄⁄. 1
color
⁄⁄2 7
,
⁄⁄7 8
out
⁄⁄9 <
uv0
⁄⁄= @
,
⁄⁄@ A
out
⁄⁄B E
normal
⁄⁄F L
,
⁄⁄L M
out
⁄⁄N Q
tangent
⁄⁄R Y
,
⁄⁄Y Z
out
⁄⁄[ ^
uv2
⁄⁄_ b
,
⁄⁄b c
out
⁄⁄d g
uv3
⁄⁄h k
,
⁄⁄k l
out
⁄⁄m p
uv4
⁄⁄q t
,
⁄⁄t u

MeshArrays⁄⁄v Ä
.⁄⁄Ä Å
All⁄⁄Å Ñ
)⁄⁄Ñ Ö
;⁄⁄Ö Ü
}
€€ 	
public
ÔÔ 
static
ÔÔ 
void
ÔÔ 
	GetArrays
ÔÔ $
(
ÔÔ$ %
IList
 
<
 
Vertex
 
>
 
vertices
 "
,
" #
out
ÒÒ 
Vector3
ÒÒ 
[
ÒÒ 
]
ÒÒ 
position
ÒÒ "
,
ÒÒ" #
out
ÚÚ 
Color
ÚÚ 
[
ÚÚ 
]
ÚÚ 
color
ÚÚ 
,
ÚÚ 
out
ÛÛ 
Vector2
ÛÛ 
[
ÛÛ 
]
ÛÛ 
uv0
ÛÛ 
,
ÛÛ 
out
ÙÙ 
Vector3
ÙÙ 
[
ÙÙ 
]
ÙÙ 
normal
ÙÙ  
,
ÙÙ  !
out
ıı 
Vector4
ıı 
[
ıı 
]
ıı 
tangent
ıı !
,
ıı! "
out
ˆˆ 
Vector2
ˆˆ 
[
ˆˆ 
]
ˆˆ 
uv2
ˆˆ 
,
ˆˆ 
out
˜˜ 
List
˜˜ 
<
˜˜ 
Vector4
˜˜ 
>
˜˜ 
uv3
˜˜ !
,
˜˜! "
out
¯¯ 
List
¯¯ 
<
¯¯ 
Vector4
¯¯ 
>
¯¯ 
uv4
¯¯ !
,
¯¯! "

MeshArrays
˘˘ 

attributes
˘˘ !
)
˘˘! "
{
˙˙ 	
if
˚˚ 
(
˚˚ 
vertices
˚˚ 
==
˚˚ 
null
˚˚  
)
˚˚  !
throw
¸¸ 
new
¸¸ #
ArgumentNullException
¸¸ /
(
¸¸/ 0
$str
¸¸0 :
)
¸¸: ;
;
¸¸; <
int
˛˛ 
vc
˛˛ 
=
˛˛ 
vertices
˛˛ 
.
˛˛ 
Count
˛˛ #
;
˛˛# $
var
ˇˇ 
first
ˇˇ 
=
ˇˇ 
vc
ˇˇ 
<
ˇˇ 
$num
ˇˇ 
?
ˇˇ  
new
ˇˇ! $
Vertex
ˇˇ% +
(
ˇˇ+ ,
)
ˇˇ, -
:
ˇˇ. /
vertices
ˇˇ0 8
[
ˇˇ8 9
$num
ˇˇ9 :
]
ˇˇ: ;
;
ˇˇ; <
bool
ÅÅ 
hasPosition
ÅÅ 
=
ÅÅ 
(
ÅÅ  
(
ÅÅ  !

attributes
ÅÅ! +
&
ÅÅ, -

MeshArrays
ÅÅ. 8
.
ÅÅ8 9
Position
ÅÅ9 A
)
ÅÅA B
==
ÅÅC E

MeshArrays
ÅÅF P
.
ÅÅP Q
Position
ÅÅQ Y
)
ÅÅY Z
&&
ÅÅ[ ]
first
ÅÅ^ c
.
ÅÅc d
hasPosition
ÅÅd o
;
ÅÅo p
bool
ÇÇ 
hasColor
ÇÇ 
=
ÇÇ 
(
ÇÇ 
(
ÇÇ 

attributes
ÇÇ (
&
ÇÇ) *

MeshArrays
ÇÇ+ 5
.
ÇÇ5 6
Color
ÇÇ6 ;
)
ÇÇ; <
==
ÇÇ= ?

MeshArrays
ÇÇ@ J
.
ÇÇJ K
Color
ÇÇK P
)
ÇÇP Q
&&
ÇÇR T
first
ÇÇU Z
.
ÇÇZ [
hasColor
ÇÇ[ c
;
ÇÇc d
bool
ÉÉ 
hasUv0
ÉÉ 
=
ÉÉ 
(
ÉÉ 
(
ÉÉ 

attributes
ÉÉ &
&
ÉÉ' (

MeshArrays
ÉÉ) 3
.
ÉÉ3 4
Texture0
ÉÉ4 <
)
ÉÉ< =
==
ÉÉ> @

MeshArrays
ÉÉA K
.
ÉÉK L
Texture0
ÉÉL T
)
ÉÉT U
&&
ÉÉV X
first
ÉÉY ^
.
ÉÉ^ _
hasUV0
ÉÉ_ e
;
ÉÉe f
bool
ÑÑ 
	hasNormal
ÑÑ 
=
ÑÑ 
(
ÑÑ 
(
ÑÑ 

attributes
ÑÑ )
&
ÑÑ* +

MeshArrays
ÑÑ, 6
.
ÑÑ6 7
Normal
ÑÑ7 =
)
ÑÑ= >
==
ÑÑ? A

MeshArrays
ÑÑB L
.
ÑÑL M
Normal
ÑÑM S
)
ÑÑS T
&&
ÑÑU W
first
ÑÑX ]
.
ÑÑ] ^
	hasNormal
ÑÑ^ g
;
ÑÑg h
bool
ÖÖ 

hasTangent
ÖÖ 
=
ÖÖ 
(
ÖÖ 
(
ÖÖ  

attributes
ÖÖ  *
&
ÖÖ+ ,

MeshArrays
ÖÖ- 7
.
ÖÖ7 8
Tangent
ÖÖ8 ?
)
ÖÖ? @
==
ÖÖA C

MeshArrays
ÖÖD N
.
ÖÖN O
Tangent
ÖÖO V
)
ÖÖV W
&&
ÖÖX Z
first
ÖÖ[ `
.
ÖÖ` a

hasTangent
ÖÖa k
;
ÖÖk l
bool
ÜÜ 
hasUv2
ÜÜ 
=
ÜÜ 
(
ÜÜ 
(
ÜÜ 

attributes
ÜÜ &
&
ÜÜ' (

MeshArrays
ÜÜ) 3
.
ÜÜ3 4
Texture1
ÜÜ4 <
)
ÜÜ< =
==
ÜÜ> @

MeshArrays
ÜÜA K
.
ÜÜK L
Texture1
ÜÜL T
)
ÜÜT U
&&
ÜÜV X
first
ÜÜY ^
.
ÜÜ^ _
hasUV2
ÜÜ_ e
;
ÜÜe f
bool
áá 
hasUv3
áá 
=
áá 
(
áá 
(
áá 

attributes
áá &
&
áá' (

MeshArrays
áá) 3
.
áá3 4
Texture2
áá4 <
)
áá< =
==
áá> @

MeshArrays
ááA K
.
ááK L
Texture2
ááL T
)
ááT U
&&
ááV X
first
ááY ^
.
áá^ _
hasUV3
áá_ e
;
ááe f
bool
àà 
hasUv4
àà 
=
àà 
(
àà 
(
àà 

attributes
àà &
&
àà' (

MeshArrays
àà) 3
.
àà3 4
Texture3
àà4 <
)
àà< =
==
àà> @

MeshArrays
ààA K
.
ààK L
Texture3
ààL T
)
ààT U
&&
ààV X
first
ààY ^
.
àà^ _
hasUV4
àà_ e
;
ààe f
position
ää 
=
ää 
hasPosition
ää "
?
ää# $
new
ää% (
Vector3
ää) 0
[
ää0 1
vc
ää1 3
]
ää3 4
:
ää5 6
null
ää7 ;
;
ää; <
color
ãã 
=
ãã 
hasColor
ãã 
?
ãã 
new
ãã "
Color
ãã# (
[
ãã( )
vc
ãã) +
]
ãã+ ,
:
ãã- .
null
ãã/ 3
;
ãã3 4
uv0
åå 
=
åå 
hasUv0
åå 
?
åå 
new
åå 
Vector2
åå &
[
åå& '
vc
åå' )
]
åå) *
:
åå+ ,
null
åå- 1
;
åå1 2
normal
çç 
=
çç 
	hasNormal
çç 
?
çç  
new
çç! $
Vector3
çç% ,
[
çç, -
vc
çç- /
]
çç/ 0
:
çç1 2
null
çç3 7
;
çç7 8
tangent
éé 
=
éé 

hasTangent
éé  
?
éé! "
new
éé# &
Vector4
éé' .
[
éé. /
vc
éé/ 1
]
éé1 2
:
éé3 4
null
éé5 9
;
éé9 :
uv2
èè 
=
èè 
hasUv2
èè 
?
èè 
new
èè 
Vector2
èè &
[
èè& '
vc
èè' )
]
èè) *
:
èè+ ,
null
èè- 1
;
èè1 2
uv3
êê 
=
êê 
hasUv3
êê 
?
êê 
new
êê 
List
êê #
<
êê# $
Vector4
êê$ +
>
êê+ ,
(
êê, -
vc
êê- /
)
êê/ 0
:
êê1 2
null
êê3 7
;
êê7 8
uv4
ëë 
=
ëë 
hasUv4
ëë 
?
ëë 
new
ëë 
List
ëë #
<
ëë# $
Vector4
ëë$ +
>
ëë+ ,
(
ëë, -
vc
ëë- /
)
ëë/ 0
:
ëë1 2
null
ëë3 7
;
ëë7 8
for
ìì 
(
ìì 
int
ìì 
i
ìì 
=
ìì 
$num
ìì 
;
ìì 
i
ìì 
<
ìì 
vc
ìì  "
;
ìì" #
i
ìì$ %
++
ìì% '
)
ìì' (
{
îî 
if
ïï 
(
ïï 
hasPosition
ïï 
)
ïï  
position
ïï! )
[
ïï) *
i
ïï* +
]
ïï+ ,
=
ïï- .
vertices
ïï/ 7
[
ïï7 8
i
ïï8 9
]
ïï9 :
.
ïï: ;

m_Position
ïï; E
;
ïïE F
if
ññ 
(
ññ 
hasColor
ññ 
)
ññ 
color
ññ #
[
ññ# $
i
ññ$ %
]
ññ% &
=
ññ' (
vertices
ññ) 1
[
ññ1 2
i
ññ2 3
]
ññ3 4
.
ññ4 5
m_Color
ññ5 <
;
ññ< =
if
óó 
(
óó 
hasUv0
óó 
)
óó 
uv0
óó 
[
óó  
i
óó  !
]
óó! "
=
óó# $
vertices
óó% -
[
óó- .
i
óó. /
]
óó/ 0
.
óó0 1
m_UV0
óó1 6
;
óó6 7
if
òò 
(
òò 
	hasNormal
òò 
)
òò 
normal
òò %
[
òò% &
i
òò& '
]
òò' (
=
òò) *
vertices
òò+ 3
[
òò3 4
i
òò4 5
]
òò5 6
.
òò6 7
m_Normal
òò7 ?
;
òò? @
if
ôô 
(
ôô 

hasTangent
ôô 
)
ôô 
tangent
ôô  '
[
ôô' (
i
ôô( )
]
ôô) *
=
ôô+ ,
vertices
ôô- 5
[
ôô5 6
i
ôô6 7
]
ôô7 8
.
ôô8 9
	m_Tangent
ôô9 B
;
ôôB C
if
öö 
(
öö 
hasUv2
öö 
)
öö 
uv2
öö 
[
öö  
i
öö  !
]
öö! "
=
öö# $
vertices
öö% -
[
öö- .
i
öö. /
]
öö/ 0
.
öö0 1
m_UV2
öö1 6
;
öö6 7
if
õõ 
(
õõ 
hasUv3
õõ 
)
õõ 
uv3
õõ 
.
õõ  
Add
õõ  #
(
õõ# $
vertices
õõ$ ,
[
õõ, -
i
õõ- .
]
õõ. /
.
õõ/ 0
m_UV3
õõ0 5
)
õõ5 6
;
õõ6 7
if
úú 
(
úú 
hasUv4
úú 
)
úú 
uv4
úú 
.
úú  
Add
úú  #
(
úú# $
vertices
úú$ ,
[
úú, -
i
úú- .
]
úú. /
.
úú/ 0
m_UV4
úú0 5
)
úú5 6
;
úú6 7
}
ùù 
}
ûû 	
public
•• 
static
•• 
void
•• 
SetMesh
•• "
(
••" #
Mesh
••# '
mesh
••( ,
,
••, -
IList
••. 3
<
••3 4
Vertex
••4 :
>
••: ;
vertices
••< D
)
••D E
{
¶¶ 	
if
ßß 
(
ßß 
mesh
ßß 
==
ßß 
null
ßß 
)
ßß 
throw
®® 
new
®® #
ArgumentNullException
®® /
(
®®/ 0
$str
®®0 6
)
®®6 7
;
®®7 8
if
™™ 
(
™™ 
vertices
™™ 
==
™™ 
null
™™  
)
™™  !
throw
´´ 
new
´´ #
ArgumentNullException
´´ /
(
´´/ 0
$str
´´0 :
)
´´: ;
;
´´; <
Vector3
≠≠ 
[
≠≠ 
]
≠≠ 
	positions
≠≠ 
=
≠≠  !
null
≠≠" &
;
≠≠& '
Color
ÆÆ 
[
ÆÆ 
]
ÆÆ 
colors
ÆÆ 
=
ÆÆ 
null
ÆÆ !
;
ÆÆ! "
Vector2
ØØ 
[
ØØ 
]
ØØ 
uv0s
ØØ 
=
ØØ 
null
ØØ !
;
ØØ! "
Vector3
∞∞ 
[
∞∞ 
]
∞∞ 
normals
∞∞ 
=
∞∞ 
null
∞∞  $
;
∞∞$ %
Vector4
±± 
[
±± 
]
±± 
tangents
±± 
=
±±  
null
±±! %
;
±±% &
Vector2
≤≤ 
[
≤≤ 
]
≤≤ 
uv2s
≤≤ 
=
≤≤ 
null
≤≤ !
;
≤≤! "
List
≥≥ 
<
≥≥ 
Vector4
≥≥ 
>
≥≥ 
uv3s
≥≥ 
=
≥≥  
null
≥≥! %
;
≥≥% &
List
¥¥ 
<
¥¥ 
Vector4
¥¥ 
>
¥¥ 
uv4s
¥¥ 
=
¥¥  
null
¥¥! %
;
¥¥% &
	GetArrays
∂∂ 
(
∂∂ 
vertices
∂∂ 
,
∂∂ 
out
∂∂  #
	positions
∂∂$ -
,
∂∂- .
out
∑∑ 
colors
∑∑ 
,
∑∑ 
out
∏∏ 
uv0s
∏∏ 
,
∏∏ 
out
ππ 
normals
ππ 
,
ππ 
out
∫∫ 
tangents
∫∫ 
,
∫∫ 
out
ªª 
uv2s
ªª 
,
ªª 
out
ºº 
uv3s
ºº 
,
ºº 
out
ΩΩ 
uv4s
ΩΩ 
)
ΩΩ 
;
ΩΩ 
mesh
øø 
.
øø 
Clear
øø 
(
øø 
)
øø 
;
øø 
Vertex
¡¡ 
first
¡¡ 
=
¡¡ 
vertices
¡¡ #
[
¡¡# $
$num
¡¡$ %
]
¡¡% &
;
¡¡& '
if
√√ 
(
√√ 
first
√√ 
.
√√ 
hasPosition
√√ !
)
√√! "
mesh
√√# '
.
√√' (
vertices
√√( 0
=
√√1 2
	positions
√√3 <
;
√√< =
if
ƒƒ 
(
ƒƒ 
first
ƒƒ 
.
ƒƒ 
hasColor
ƒƒ 
)
ƒƒ 
mesh
ƒƒ  $
.
ƒƒ$ %
colors
ƒƒ% +
=
ƒƒ, -
colors
ƒƒ. 4
;
ƒƒ4 5
if
≈≈ 
(
≈≈ 
first
≈≈ 
.
≈≈ 
hasUV0
≈≈ 
)
≈≈ 
mesh
≈≈ "
.
≈≈" #
uv
≈≈# %
=
≈≈& '
uv0s
≈≈( ,
;
≈≈, -
if
∆∆ 
(
∆∆ 
first
∆∆ 
.
∆∆ 
	hasNormal
∆∆ 
)
∆∆  
mesh
∆∆! %
.
∆∆% &
normals
∆∆& -
=
∆∆. /
normals
∆∆0 7
;
∆∆7 8
if
«« 
(
«« 
first
«« 
.
«« 

hasTangent
««  
)
««  !
mesh
««" &
.
««& '
tangents
««' /
=
««0 1
tangents
««2 :
;
««: ;
if
»» 
(
»» 
first
»» 
.
»» 
hasUV2
»» 
)
»» 
mesh
»» "
.
»»" #
uv2
»»# &
=
»»' (
uv2s
»») -
;
»»- .
if
   
(
   
first
   
.
   
hasUV3
   
)
   
if
ÀÀ 
(
ÀÀ 
uv3s
ÀÀ 
!=
ÀÀ 
null
ÀÀ  
)
ÀÀ  !
mesh
ÃÃ 
.
ÃÃ 
SetUVs
ÃÃ 
(
ÃÃ  
$num
ÃÃ  !
,
ÃÃ! "
uv3s
ÃÃ# '
)
ÃÃ' (
;
ÃÃ( )
if
ÕÕ 
(
ÕÕ 
first
ÕÕ 
.
ÕÕ 
hasUV4
ÕÕ 
)
ÕÕ 
if
ŒŒ 
(
ŒŒ 
uv4s
ŒŒ 
!=
ŒŒ 
null
ŒŒ  
)
ŒŒ  !
mesh
œœ 
.
œœ 
SetUVs
œœ 
(
œœ  
$num
œœ  !
,
œœ! "
uv4s
œœ# '
)
œœ' (
;
œœ( )
}
—— 	
public
ŸŸ 
static
ŸŸ 
Vertex
ŸŸ 
Average
ŸŸ $
(
ŸŸ$ %
IList
ŸŸ% *
<
ŸŸ* +
Vertex
ŸŸ+ 1
>
ŸŸ1 2
vertices
ŸŸ3 ;
,
ŸŸ; <
IList
ŸŸ= B
<
ŸŸB C
int
ŸŸC F
>
ŸŸF G
indexes
ŸŸH O
=
ŸŸP Q
null
ŸŸR V
)
ŸŸV W
{
⁄⁄ 	
if
€€ 
(
€€ 
vertices
€€ 
==
€€ 
null
€€  
)
€€  !
throw
‹‹ 
new
‹‹ #
ArgumentNullException
‹‹ /
(
‹‹/ 0
$str
‹‹0 :
)
‹‹: ;
;
‹‹; <
Vertex
ﬁﬁ 
v
ﬁﬁ 
=
ﬁﬁ 
new
ﬁﬁ 
Vertex
ﬁﬁ !
(
ﬁﬁ! "
)
ﬁﬁ" #
;
ﬁﬁ# $
int
‡‡ 
vertexCount
‡‡ 
=
‡‡ 
indexes
‡‡ %
!=
‡‡& (
null
‡‡) -
?
‡‡. /
indexes
‡‡0 7
.
‡‡7 8
Count
‡‡8 =
:
‡‡> ?
vertices
‡‡@ H
.
‡‡H I
Count
‡‡I N
;
‡‡N O
int
‚‚ 
positionCount
‚‚ 
=
‚‚ 
$num
‚‚  !
,
‚‚! "

colorCount
„„ 
=
„„ 
$num
„„ 
,
„„ 
uv0Count
‰‰ 
=
‰‰ 
$num
‰‰ 
,
‰‰ 
normalCount
ÂÂ 
=
ÂÂ 
$num
ÂÂ 
,
ÂÂ  
tangentCount
ÊÊ 
=
ÊÊ 
$num
ÊÊ  
,
ÊÊ  !
uv2Count
ÁÁ 
=
ÁÁ 
$num
ÁÁ 
,
ÁÁ 
uv3Count
ËË 
=
ËË 
$num
ËË 
,
ËË 
uv4Count
ÈÈ 
=
ÈÈ 
$num
ÈÈ 
;
ÈÈ 
for
ÎÎ 
(
ÎÎ 
int
ÎÎ 
i
ÎÎ 
=
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
i
ÎÎ 
<
ÎÎ 
vertexCount
ÎÎ  +
;
ÎÎ+ ,
i
ÎÎ- .
++
ÎÎ. 0
)
ÎÎ0 1
{
ÏÏ 
int
ÌÌ 
index
ÌÌ 
=
ÌÌ 
indexes
ÌÌ #
==
ÌÌ$ &
null
ÌÌ' +
?
ÌÌ, -
i
ÌÌ. /
:
ÌÌ0 1
indexes
ÌÌ2 9
[
ÌÌ9 :
i
ÌÌ: ;
]
ÌÌ; <
;
ÌÌ< =
if
 
(
 
vertices
 
[
 
index
 "
]
" #
.
# $
hasPosition
$ /
)
/ 0
{
ÒÒ 
positionCount
ÚÚ !
++
ÚÚ! #
;
ÚÚ# $
v
ÛÛ 
.
ÛÛ 

m_Position
ÛÛ  
+=
ÛÛ! #
vertices
ÛÛ$ ,
[
ÛÛ, -
index
ÛÛ- 2
]
ÛÛ2 3
.
ÛÛ3 4

m_Position
ÛÛ4 >
;
ÛÛ> ?
}
ÙÙ 
if
ˆˆ 
(
ˆˆ 
vertices
ˆˆ 
[
ˆˆ 
index
ˆˆ "
]
ˆˆ" #
.
ˆˆ# $
hasColor
ˆˆ$ ,
)
ˆˆ, -
{
˜˜ 

colorCount
¯¯ 
++
¯¯  
;
¯¯  !
v
˘˘ 
.
˘˘ 
m_Color
˘˘ 
+=
˘˘  
vertices
˘˘! )
[
˘˘) *
index
˘˘* /
]
˘˘/ 0
.
˘˘0 1
m_Color
˘˘1 8
;
˘˘8 9
}
˙˙ 
if
¸¸ 
(
¸¸ 
vertices
¸¸ 
[
¸¸ 
index
¸¸ "
]
¸¸" #
.
¸¸# $
hasUV0
¸¸$ *
)
¸¸* +
{
˝˝ 
uv0Count
˛˛ 
++
˛˛ 
;
˛˛ 
v
ˇˇ 
.
ˇˇ 
m_UV0
ˇˇ 
+=
ˇˇ 
vertices
ˇˇ '
[
ˇˇ' (
index
ˇˇ( -
]
ˇˇ- .
.
ˇˇ. /
m_UV0
ˇˇ/ 4
;
ˇˇ4 5
}
ÄÄ 
if
ÇÇ 
(
ÇÇ 
vertices
ÇÇ 
[
ÇÇ 
index
ÇÇ "
]
ÇÇ" #
.
ÇÇ# $
	hasNormal
ÇÇ$ -
)
ÇÇ- .
{
ÉÉ 
normalCount
ÑÑ 
++
ÑÑ !
;
ÑÑ! "
v
ÖÖ 
.
ÖÖ 
m_Normal
ÖÖ 
+=
ÖÖ !
vertices
ÖÖ" *
[
ÖÖ* +
index
ÖÖ+ 0
]
ÖÖ0 1
.
ÖÖ1 2
m_Normal
ÖÖ2 :
;
ÖÖ: ;
}
ÜÜ 
if
àà 
(
àà 
vertices
àà 
[
àà 
index
àà "
]
àà" #
.
àà# $

hasTangent
àà$ .
)
àà. /
{
ââ 
tangentCount
ää  
++
ää  "
;
ää" #
v
ãã 
.
ãã 
	m_Tangent
ãã 
+=
ãã  "
vertices
ãã# +
[
ãã+ ,
index
ãã, 1
]
ãã1 2
.
ãã2 3
	m_Tangent
ãã3 <
;
ãã< =
}
åå 
if
éé 
(
éé 
vertices
éé 
[
éé 
index
éé "
]
éé" #
.
éé# $
hasUV2
éé$ *
)
éé* +
{
èè 
uv2Count
êê 
++
êê 
;
êê 
v
ëë 
.
ëë 
m_UV2
ëë 
+=
ëë 
vertices
ëë '
[
ëë' (
index
ëë( -
]
ëë- .
.
ëë. /
m_UV2
ëë/ 4
;
ëë4 5
}
íí 
if
îî 
(
îî 
vertices
îî 
[
îî 
index
îî "
]
îî" #
.
îî# $
hasUV3
îî$ *
)
îî* +
{
ïï 
uv3Count
ññ 
++
ññ 
;
ññ 
v
óó 
.
óó 
m_UV3
óó 
+=
óó 
vertices
óó '
[
óó' (
index
óó( -
]
óó- .
.
óó. /
m_UV3
óó/ 4
;
óó4 5
}
òò 
if
öö 
(
öö 
vertices
öö 
[
öö 
index
öö "
]
öö" #
.
öö# $
hasUV4
öö$ *
)
öö* +
{
õõ 
uv4Count
úú 
++
úú 
;
úú 
v
ùù 
.
ùù 
m_UV4
ùù 
+=
ùù 
vertices
ùù '
[
ùù' (
index
ùù( -
]
ùù- .
.
ùù. /
m_UV4
ùù/ 4
;
ùù4 5
}
ûû 
}
üü 
if
°° 
(
°° 
positionCount
°° 
>
°° 
$num
°°  !
)
°°! "
{
¢¢ 
v
££ 
.
££ 
hasPosition
££ 
=
££ 
true
££  $
;
££$ %
v
§§ 
.
§§ 

m_Position
§§ 
*=
§§ 
(
§§  !
$num
§§! #
/
§§$ %
positionCount
§§& 3
)
§§3 4
;
§§4 5
}
•• 
if
ßß 
(
ßß 

colorCount
ßß 
>
ßß 
$num
ßß 
)
ßß 
{
®® 
v
©© 
.
©© 
hasColor
©© 
=
©© 
true
©© !
;
©©! "
v
™™ 
.
™™ 
m_Color
™™ 
*=
™™ 
(
™™ 
$num
™™  
/
™™! "

colorCount
™™# -
)
™™- .
;
™™. /
}
´´ 
if
≠≠ 
(
≠≠ 
uv0Count
≠≠ 
>
≠≠ 
$num
≠≠ 
)
≠≠ 
{
ÆÆ 
v
ØØ 
.
ØØ 
hasUV0
ØØ 
=
ØØ 
true
ØØ 
;
ØØ  
v
∞∞ 
.
∞∞ 
m_UV0
∞∞ 
*=
∞∞ 
(
∞∞ 
$num
∞∞ 
/
∞∞  
uv0Count
∞∞! )
)
∞∞) *
;
∞∞* +
}
±± 
if
¥¥ 
(
¥¥ 
normalCount
¥¥ 
>
¥¥ 
$num
¥¥ 
)
¥¥  
{
µµ 
v
∂∂ 
.
∂∂ 
	hasNormal
∂∂ 
=
∂∂ 
true
∂∂ "
;
∂∂" #
v
∑∑ 
.
∑∑ 
m_Normal
∑∑ 
*=
∑∑ 
(
∑∑ 
$num
∑∑ !
/
∑∑" #
normalCount
∑∑$ /
)
∑∑/ 0
;
∑∑0 1
}
∏∏ 
if
∫∫ 
(
∫∫ 
tangentCount
∫∫ 
>
∫∫ 
$num
∫∫  
)
∫∫  !
{
ªª 
v
ºº 
.
ºº 

hasTangent
ºº 
=
ºº 
true
ºº #
;
ºº# $
v
ΩΩ 
.
ΩΩ 
	m_Tangent
ΩΩ 
*=
ΩΩ 
(
ΩΩ  
$num
ΩΩ  "
/
ΩΩ# $
tangentCount
ΩΩ% 1
)
ΩΩ1 2
;
ΩΩ2 3
}
ææ 
if
¿¿ 
(
¿¿ 
uv2Count
¿¿ 
>
¿¿ 
$num
¿¿ 
)
¿¿ 
{
¡¡ 
v
¬¬ 
.
¬¬ 
hasUV2
¬¬ 
=
¬¬ 
true
¬¬ 
;
¬¬  
v
√√ 
.
√√ 
m_UV2
√√ 
*=
√√ 
(
√√ 
$num
√√ 
/
√√  
uv2Count
√√! )
)
√√) *
;
√√* +
}
ƒƒ 
if
∆∆ 
(
∆∆ 
uv3Count
∆∆ 
>
∆∆ 
$num
∆∆ 
)
∆∆ 
{
«« 
v
»» 
.
»» 
hasUV3
»» 
=
»» 
true
»» 
;
»»  
v
…… 
.
…… 
m_UV3
…… 
*=
…… 
(
…… 
$num
…… 
/
……  
uv3Count
……! )
)
……) *
;
……* +
}
   
if
ÃÃ 
(
ÃÃ 
uv4Count
ÃÃ 
>
ÃÃ 
$num
ÃÃ 
)
ÃÃ 
{
ÕÕ 
v
ŒŒ 
.
ŒŒ 
hasUV4
ŒŒ 
=
ŒŒ 
true
ŒŒ 
;
ŒŒ  
v
œœ 
.
œœ 
m_UV4
œœ 
*=
œœ 
(
œœ 
$num
œœ 
/
œœ  
uv4Count
œœ! )
)
œœ) *
;
œœ* +
}
–– 
return
““ 
v
““ 
;
““ 
}
”” 	
public
‹‹ 
static
‹‹ 
Vertex
‹‹ 
Mix
‹‹  
(
‹‹  !
Vertex
‹‹! '
x
‹‹( )
,
‹‹) *
Vertex
‹‹+ 1
y
‹‹2 3
,
‹‹3 4
float
‹‹5 :
weight
‹‹; A
)
‹‹A B
{
›› 	
if
ﬁﬁ 
(
ﬁﬁ 
x
ﬁﬁ 
==
ﬁﬁ 
null
ﬁﬁ 
||
ﬁﬁ 
y
ﬁﬁ 
==
ﬁﬁ !
null
ﬁﬁ" &
)
ﬁﬁ& '
throw
ﬂﬂ 
new
ﬂﬂ #
ArgumentNullException
ﬂﬂ /
(
ﬂﬂ/ 0
$str
ﬂﬂ0 3
,
ﬂﬂ3 4
$str
ﬂﬂ5 U
)
ﬂﬂU V
;
ﬂﬂV W
float
·· 
i
·· 
=
·· 
$num
·· 
-
·· 
weight
·· !
;
··! "
Vertex
„„ 
v
„„ 
=
„„ 
new
„„ 
Vertex
„„ !
(
„„! "
)
„„" #
;
„„# $
v
ÂÂ 
.
ÂÂ 

m_Position
ÂÂ 
=
ÂÂ 
x
ÂÂ 
.
ÂÂ 

m_Position
ÂÂ '
*
ÂÂ( )
i
ÂÂ* +
+
ÂÂ, -
y
ÂÂ. /
.
ÂÂ/ 0

m_Position
ÂÂ0 :
*
ÂÂ; <
weight
ÂÂ= C
;
ÂÂC D
if
ÁÁ 
(
ÁÁ 
x
ÁÁ 
.
ÁÁ 
hasColor
ÁÁ 
&&
ÁÁ 
y
ÁÁ 
.
ÁÁ  
hasColor
ÁÁ  (
)
ÁÁ( )
v
ËË 
.
ËË 
m_Color
ËË 
=
ËË 
x
ËË 
.
ËË 
m_Color
ËË %
*
ËË& '
i
ËË( )
+
ËË* +
y
ËË, -
.
ËË- .
m_Color
ËË. 5
*
ËË6 7
weight
ËË8 >
;
ËË> ?
else
ÈÈ 
if
ÈÈ 
(
ÈÈ 
x
ÈÈ 
.
ÈÈ 
hasColor
ÈÈ 
)
ÈÈ  
v
ÍÍ 
.
ÍÍ 
m_Color
ÍÍ 
=
ÍÍ 
x
ÍÍ 
.
ÍÍ 
m_Color
ÍÍ %
;
ÍÍ% &
else
ÎÎ 
if
ÎÎ 
(
ÎÎ 
y
ÎÎ 
.
ÎÎ 
hasColor
ÎÎ 
)
ÎÎ  
v
ÏÏ 
.
ÏÏ 
m_Color
ÏÏ 
=
ÏÏ 
y
ÏÏ 
.
ÏÏ 
m_Color
ÏÏ %
;
ÏÏ% &
if
ÓÓ 
(
ÓÓ 
x
ÓÓ 
.
ÓÓ 
	hasNormal
ÓÓ 
&&
ÓÓ 
y
ÓÓ  
.
ÓÓ  !
	hasNormal
ÓÓ! *
)
ÓÓ* +
v
ÔÔ 
.
ÔÔ 
m_Normal
ÔÔ 
=
ÔÔ 
x
ÔÔ 
.
ÔÔ 
m_Normal
ÔÔ '
*
ÔÔ( )
i
ÔÔ* +
+
ÔÔ, -
y
ÔÔ. /
.
ÔÔ/ 0
m_Normal
ÔÔ0 8
*
ÔÔ9 :
weight
ÔÔ; A
;
ÔÔA B
else
 
if
 
(
 
x
 
.
 
	hasNormal
  
)
  !
v
ÒÒ 
.
ÒÒ 
m_Normal
ÒÒ 
=
ÒÒ 
x
ÒÒ 
.
ÒÒ 
m_Normal
ÒÒ '
;
ÒÒ' (
else
ÚÚ 
if
ÚÚ 
(
ÚÚ 
y
ÚÚ 
.
ÚÚ 
	hasNormal
ÚÚ  
)
ÚÚ  !
v
ÛÛ 
.
ÛÛ 
m_Normal
ÛÛ 
=
ÛÛ 
y
ÛÛ 
.
ÛÛ 
m_Normal
ÛÛ '
;
ÛÛ' (
if
ıı 
(
ıı 
x
ıı 
.
ıı 

hasTangent
ıı 
&&
ıı 
y
ıı  !
.
ıı! "

hasTangent
ıı" ,
)
ıı, -
v
ˆˆ 
.
ˆˆ 
	m_Tangent
ˆˆ 
=
ˆˆ 
x
ˆˆ 
.
ˆˆ  
	m_Tangent
ˆˆ  )
*
ˆˆ* +
i
ˆˆ, -
+
ˆˆ. /
y
ˆˆ0 1
.
ˆˆ1 2
	m_Tangent
ˆˆ2 ;
*
ˆˆ< =
weight
ˆˆ> D
;
ˆˆD E
else
˜˜ 
if
˜˜ 
(
˜˜ 
x
˜˜ 
.
˜˜ 

hasTangent
˜˜ !
)
˜˜! "
v
¯¯ 
.
¯¯ 
	m_Tangent
¯¯ 
=
¯¯ 
x
¯¯ 
.
¯¯  
	m_Tangent
¯¯  )
;
¯¯) *
else
˘˘ 
if
˘˘ 
(
˘˘ 
y
˘˘ 
.
˘˘ 

hasTangent
˘˘ !
)
˘˘! "
v
˙˙ 
.
˙˙ 
	m_Tangent
˙˙ 
=
˙˙ 
y
˙˙ 
.
˙˙  
	m_Tangent
˙˙  )
;
˙˙) *
if
¸¸ 
(
¸¸ 
x
¸¸ 
.
¸¸ 
hasUV0
¸¸ 
&&
¸¸ 
y
¸¸ 
.
¸¸ 
hasUV0
¸¸ $
)
¸¸$ %
v
˝˝ 
.
˝˝ 
m_UV0
˝˝ 
=
˝˝ 
x
˝˝ 
.
˝˝ 
m_UV0
˝˝ !
*
˝˝" #
i
˝˝$ %
+
˝˝& '
y
˝˝( )
.
˝˝) *
m_UV0
˝˝* /
*
˝˝0 1
weight
˝˝2 8
;
˝˝8 9
else
˛˛ 
if
˛˛ 
(
˛˛ 
x
˛˛ 
.
˛˛ 
hasUV0
˛˛ 
)
˛˛ 
v
ˇˇ 
.
ˇˇ 
m_UV0
ˇˇ 
=
ˇˇ 
x
ˇˇ 
.
ˇˇ 
m_UV0
ˇˇ !
;
ˇˇ! "
else
ÄÄ 
if
ÄÄ 
(
ÄÄ 
y
ÄÄ 
.
ÄÄ 
hasUV0
ÄÄ 
)
ÄÄ 
v
ÅÅ 
.
ÅÅ 
m_UV0
ÅÅ 
=
ÅÅ 
y
ÅÅ 
.
ÅÅ 
m_UV0
ÅÅ !
;
ÅÅ! "
if
ÉÉ 
(
ÉÉ 
x
ÉÉ 
.
ÉÉ 
hasUV2
ÉÉ 
&&
ÉÉ 
y
ÉÉ 
.
ÉÉ 
hasUV2
ÉÉ $
)
ÉÉ$ %
v
ÑÑ 
.
ÑÑ 
m_UV2
ÑÑ 
=
ÑÑ 
x
ÑÑ 
.
ÑÑ 
m_UV2
ÑÑ !
*
ÑÑ" #
i
ÑÑ$ %
+
ÑÑ& '
y
ÑÑ( )
.
ÑÑ) *
m_UV2
ÑÑ* /
*
ÑÑ0 1
weight
ÑÑ2 8
;
ÑÑ8 9
else
ÖÖ 
if
ÖÖ 
(
ÖÖ 
x
ÖÖ 
.
ÖÖ 
hasUV2
ÖÖ 
)
ÖÖ 
v
ÜÜ 
.
ÜÜ 
m_UV2
ÜÜ 
=
ÜÜ 
x
ÜÜ 
.
ÜÜ 
m_UV2
ÜÜ !
;
ÜÜ! "
else
áá 
if
áá 
(
áá 
y
áá 
.
áá 
hasUV2
áá 
)
áá 
v
àà 
.
àà 
m_UV2
àà 
=
àà 
y
àà 
.
àà 
m_UV2
àà !
;
àà! "
if
ää 
(
ää 
x
ää 
.
ää 
hasUV3
ää 
&&
ää 
y
ää 
.
ää 
hasUV3
ää $
)
ää$ %
v
ãã 
.
ãã 
m_UV3
ãã 
=
ãã 
x
ãã 
.
ãã 
m_UV3
ãã !
*
ãã" #
i
ãã$ %
+
ãã& '
y
ãã( )
.
ãã) *
m_UV3
ãã* /
*
ãã0 1
weight
ãã2 8
;
ãã8 9
else
åå 
if
åå 
(
åå 
x
åå 
.
åå 
hasUV3
åå 
)
åå 
v
çç 
.
çç 
m_UV3
çç 
=
çç 
x
çç 
.
çç 
m_UV3
çç !
;
çç! "
else
éé 
if
éé 
(
éé 
y
éé 
.
éé 
hasUV3
éé 
)
éé 
v
èè 
.
èè 
m_UV3
èè 
=
èè 
y
èè 
.
èè 
m_UV3
èè !
;
èè! "
if
ëë 
(
ëë 
x
ëë 
.
ëë 
hasUV4
ëë 
&&
ëë 
y
ëë 
.
ëë 
hasUV4
ëë $
)
ëë$ %
v
íí 
.
íí 
m_UV4
íí 
=
íí 
x
íí 
.
íí 
m_UV4
íí !
*
íí" #
i
íí$ %
+
íí& '
y
íí( )
.
íí) *
m_UV4
íí* /
*
íí0 1
weight
íí2 8
;
íí8 9
else
ìì 
if
ìì 
(
ìì 
x
ìì 
.
ìì 
hasUV4
ìì 
)
ìì 
v
îî 
.
îî 
m_UV4
îî 
=
îî 
x
îî 
.
îî 
m_UV4
îî !
;
îî! "
else
ïï 
if
ïï 
(
ïï 
y
ïï 
.
ïï 
hasUV4
ïï 
)
ïï 
v
ññ 
.
ññ 
m_UV4
ññ 
=
ññ 
y
ññ 
.
ññ 
m_UV4
ññ !
;
ññ! "
return
òò 
v
òò 
;
òò 
}
ôô 	
}
öö 
}õõ í›
àD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Normals.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

static 
class 
Normals 
{ 
static 
Vector3 
[ 
] 
s_SmoothAvg $
=% &
new' *
Vector3+ 2
[2 3
	Smoothing3 <
.< =
smoothRangeMax= K
]K L
;L M
static 
float 
[ 
] 
s_SmoothAvgCount '
=( )
new* -
float. 3
[3 4
	Smoothing4 =
.= >
smoothRangeMax> L
]L M
;M N
static		 
int		 
[		 
]		 
s_CachedIntArray		 %
=		& '
new		( +
int		, /
[		/ 0
ushort		0 6
.		6 7
MaxValue		7 ?
]		? @
;		@ A
static 
void 
ClearIntArray !
(! "
int" %
count& +
)+ ,
{ 	
if 
( 
count 
> 
s_CachedIntArray (
.( )
Length) /
)/ 0
Array 
. 
Resize 
( 
ref  
s_CachedIntArray! 1
,1 2
count3 8
)8 9
;9 :
for 
( 
int 
i 
= 
$num 
; 
i 
< 
count  %
;% &
i' (
++( *
)* +
s_CachedIntArray  
[  !
i! "
]" #
=$ %
$num& '
;' (
} 	
public 
static 
void 
CalculateTangents ,
(, -
ProBuilderMesh- ;
mesh< @
)@ A
{ 	
int 
vc 
= 
mesh 
. 
vertexCount %
;% &
if 
( 
! 
mesh 
. 
	HasArrays 
(  

MeshArrays  *
.* +
Tangent+ 2
)2 3
)3 4
mesh 
. 
tangentsInternal %
=& '
new( +
Vector4, 3
[3 4
vc4 6
]6 7
;7 8
if 
( 
! 
mesh 
. 
	HasArrays 
(  

MeshArrays  *
.* +
Position+ 3
)3 4
||5 7
!8 9
mesh9 =
.= >
	HasArrays> G
(G H

MeshArraysH R
.R S
Texture0S [
)[ \
)\ ]
return 
; 
Vector3 
[ 
] 
normals 
= 
mesh  $
.$ %

GetNormals% /
(/ 0
)0 1
;1 2
var!! 
	positions!! 
=!! 
mesh!!  
.!!  !
positionsInternal!!! 2
;!!2 3
var"" 
textures"" 
="" 
mesh"" 
.""  
texturesInternal""  0
;""0 1
var$$ 
tan1$$ 
=$$ 
new$$ 
Vector3$$ "
[$$" #
vc$$# %
]$$% &
;$$& '
var%% 
tan2%% 
=%% 
new%% 
Vector3%% "
[%%" #
vc%%# %
]%%% &
;%%& '
var'' 
tangents'' 
='' 
mesh'' 
.''  
tangentsInternal''  0
;''0 1
foreach)) 
()) 
var)) 
face)) 
in))  
mesh))! %
.))% &
facesInternal))& 3
)))3 4
{** 
int++ 
[++ 
]++ 
	triangles++ 
=++  !
face++" &
.++& '
indexesInternal++' 6
;++6 7
for-- 
(-- 
int-- 
a-- 
=-- 
$num-- 
,-- 
c--  !
=--" #
	triangles--$ -
.--- .
Length--. 4
;--4 5
a--6 7
<--8 9
c--: ;
;--; <
a--= >
+=--? A
$num--B C
)--C D
{.. 
long// 
i1// 
=// 
	triangles// '
[//' (
a//( )
+//* +
$num//, -
]//- .
;//. /
long00 
i200 
=00 
	triangles00 '
[00' (
a00( )
+00* +
$num00, -
]00- .
;00. /
long11 
i311 
=11 
	triangles11 '
[11' (
a11( )
+11* +
$num11, -
]11- .
;11. /
Vector333 
v133 
=33  
	positions33! *
[33* +
i133+ -
]33- .
;33. /
Vector344 
v244 
=44  
	positions44! *
[44* +
i244+ -
]44- .
;44. /
Vector355 
v355 
=55  
	positions55! *
[55* +
i355+ -
]55- .
;55. /
Vector277 
w177 
=77  
textures77! )
[77) *
i177* ,
]77, -
;77- .
Vector288 
w288 
=88  
textures88! )
[88) *
i288* ,
]88, -
;88- .
Vector299 
w399 
=99  
textures99! )
[99) *
i399* ,
]99, -
;99- .
float;; 
x1;; 
=;; 
v2;; !
.;;! "
x;;" #
-;;$ %
v1;;& (
.;;( )
x;;) *
;;;* +
float<< 
x2<< 
=<< 
v3<< !
.<<! "
x<<" #
-<<$ %
v1<<& (
.<<( )
x<<) *
;<<* +
float== 
y1== 
=== 
v2== !
.==! "
y==" #
-==$ %
v1==& (
.==( )
y==) *
;==* +
float>> 
y2>> 
=>> 
v3>> !
.>>! "
y>>" #
->>$ %
v1>>& (
.>>( )
y>>) *
;>>* +
float?? 
z1?? 
=?? 
v2?? !
.??! "
z??" #
-??$ %
v1??& (
.??( )
z??) *
;??* +
float@@ 
z2@@ 
=@@ 
v3@@ !
.@@! "
z@@" #
-@@$ %
v1@@& (
.@@( )
z@@) *
;@@* +
floatBB 
s1BB 
=BB 
w2BB !
.BB! "
xBB" #
-BB$ %
w1BB& (
.BB( )
xBB) *
;BB* +
floatCC 
s2CC 
=CC 
w3CC !
.CC! "
xCC" #
-CC$ %
w1CC& (
.CC( )
xCC) *
;CC* +
floatDD 
t1DD 
=DD 
w2DD !
.DD! "
yDD" #
-DD$ %
w1DD& (
.DD( )
yDD) *
;DD* +
floatEE 
t2EE 
=EE 
w3EE !
.EE! "
yEE" #
-EE$ %
w1EE& (
.EE( )
yEE) *
;EE* +
floatGG 
rGG 
=GG 
$numGG "
/GG# $
(GG% &
s1GG& (
*GG) *
t2GG+ -
-GG. /
s2GG0 2
*GG3 4
t1GG5 7
)GG7 8
;GG8 9
Vector3II 
sdirII  
=II! "
newII# &
Vector3II' .
(II. /
(II/ 0
t2II0 2
*II3 4
x1II5 7
-II8 9
t1II: <
*II= >
x2II? A
)IIA B
*IIC D
rIIE F
,IIF G
(IIH I
t2III K
*IIL M
y1IIN P
-IIQ R
t1IIS U
*IIV W
y2IIX Z
)IIZ [
*II\ ]
rII^ _
,II_ `
(IIa b
t2IIb d
*IIe f
z1IIg i
-IIj k
t1IIl n
*IIo p
z2IIq s
)IIs t
*IIu v
rIIw x
)IIx y
;IIy z
Vector3JJ 
tdirJJ  
=JJ! "
newJJ# &
Vector3JJ' .
(JJ. /
(JJ/ 0
s1JJ0 2
*JJ3 4
x2JJ5 7
-JJ8 9
s2JJ: <
*JJ= >
x1JJ? A
)JJA B
*JJC D
rJJE F
,JJF G
(JJH I
s1JJI K
*JJL M
y2JJN P
-JJQ R
s2JJS U
*JJV W
y1JJX Z
)JJZ [
*JJ\ ]
rJJ^ _
,JJ_ `
(JJa b
s1JJb d
*JJe f
z2JJg i
-JJj k
s2JJl n
*JJo p
z1JJq s
)JJs t
*JJu v
rJJw x
)JJx y
;JJy z
tan1LL 
[LL 
i1LL 
]LL 
+=LL 
sdirLL  $
;LL$ %
tan1MM 
[MM 
i2MM 
]MM 
+=MM 
sdirMM  $
;MM$ %
tan1NN 
[NN 
i3NN 
]NN 
+=NN 
sdirNN  $
;NN$ %
tan2PP 
[PP 
i1PP 
]PP 
+=PP 
tdirPP  $
;PP$ %
tan2QQ 
[QQ 
i2QQ 
]QQ 
+=QQ 
tdirQQ  $
;QQ$ %
tan2RR 
[RR 
i3RR 
]RR 
+=RR 
tdirRR  $
;RR$ %
}SS 
}TT 
forVV 
(VV 
longVV 
aVV 
=VV 
$numVV 
;VV 
aVV 
<VV  
vcVV! #
;VV# $
++VV% '
aVV' (
)VV( )
{WW 
Vector3XX 
nXX 
=XX 
normalsXX #
[XX# $
aXX$ %
]XX% &
;XX& '
Vector3YY 
tYY 
=YY 
tan1YY  
[YY  !
aYY! "
]YY" #
;YY# $
Vector3[[ 
.[[ 
OrthoNormalize[[ &
([[& '
ref[[' *
n[[+ ,
,[[, -
ref[[. 1
t[[2 3
)[[3 4
;[[4 5
tangents]] 
[]] 
a]] 
]]] 
.]] 
x]] 
=]] 
t]]  !
.]]! "
x]]" #
;]]# $
tangents^^ 
[^^ 
a^^ 
]^^ 
.^^ 
y^^ 
=^^ 
t^^  !
.^^! "
y^^" #
;^^# $
tangents__ 
[__ 
a__ 
]__ 
.__ 
z__ 
=__ 
t__  !
.__! "
z__" #
;__# $
tangents`` 
[`` 
a`` 
]`` 
.`` 
w`` 
=`` 
(``  !
Vector3``! (
.``( )
Dot``) ,
(``, -
Vector3``- 4
.``4 5
Cross``5 :
(``: ;
n``; <
,``< =
t``> ?
)``? @
,``@ A
tan2``B F
[``F G
a``G H
]``H I
)``I J
<``K L
$num``M Q
)``Q R
?``S T
-``U V
$num``V Z
:``[ \
$num``] a
;``a b
}aa 
}bb 	
staticii 
voidii  
CalculateHardNormalsii (
(ii( )
ProBuilderMeshii) 7
meshii8 <
)ii< =
{jj 	
varkk 
vertexCountkk 
=kk 
meshkk "
.kk" #
vertexCountkk# .
;kk. /
varll 
	positionsll 
=ll 
meshll  
.ll  !
positionsInternalll! 2
;ll2 3
varmm 
facesmm 
=mm 
meshmm 
.mm 
facesInternalmm *
;mm* +
ClearIntArrayoo 
(oo 
vertexCountoo %
)oo% &
;oo& '
ifqq 
(qq 
!qq 
meshqq 
.qq 
	HasArraysqq 
(qq  

MeshArraysqq  *
.qq* +
Normalqq+ 1
)qq1 2
)qq2 3
meshrr 
.rr 
normalsInternalrr $
=rr% &
newrr' *
Vector3rr+ 2
[rr2 3
vertexCountrr3 >
]rr> ?
;rr? @
vartt 
normalstt 
=tt 
meshtt 
.tt 
normalsInternaltt .
;tt. /
forvv 
(vv 
intvv 
ivv 
=vv 
$numvv 
;vv 
ivv 
<vv 
vertexCountvv  +
;vv+ ,
ivv- .
++vv. 0
)vv0 1
{ww 
normalsxx 
[xx 
ixx 
]xx 
.xx 
xxx 
=xx 
$numxx !
;xx! "
normalsyy 
[yy 
iyy 
]yy 
.yy 
yyy 
=yy 
$numyy !
;yy! "
normalszz 
[zz 
izz 
]zz 
.zz 
zzz 
=zz 
$numzz !
;zz! "
}{{ 
for}} 
(}} 
int}} 
	faceIndex}} 
=}}  
$num}}! "
,}}" #
fc}}$ &
=}}' (
faces}}) .
.}}. /
Length}}/ 5
;}}5 6
	faceIndex}}7 @
<}}A B
fc}}C E
;}}E F
	faceIndex}}G P
++}}P R
)}}R S
{~~ 
int 
[ 
] 
indexes 
= 
faces  %
[% &
	faceIndex& /
]/ 0
.0 1
indexesInternal1 @
;@ A
for
ÅÅ 
(
ÅÅ 
var
ÅÅ 
tri
ÅÅ 
=
ÅÅ 
$num
ÅÅ  
;
ÅÅ  !
tri
ÅÅ" %
<
ÅÅ& '
indexes
ÅÅ( /
.
ÅÅ/ 0
Length
ÅÅ0 6
;
ÅÅ6 7
tri
ÅÅ8 ;
+=
ÅÅ< >
$num
ÅÅ? @
)
ÅÅ@ A
{
ÇÇ 
int
ÉÉ 
a
ÉÉ 
=
ÉÉ 
indexes
ÉÉ #
[
ÉÉ# $
tri
ÉÉ$ '
]
ÉÉ' (
,
ÉÉ( )
b
ÉÉ* +
=
ÉÉ, -
indexes
ÉÉ. 5
[
ÉÉ5 6
tri
ÉÉ6 9
+
ÉÉ: ;
$num
ÉÉ< =
]
ÉÉ= >
,
ÉÉ> ?
c
ÉÉ@ A
=
ÉÉB C
indexes
ÉÉD K
[
ÉÉK L
tri
ÉÉL O
+
ÉÉP Q
$num
ÉÉR S
]
ÉÉS T
;
ÉÉT U
Vector3
ÖÖ 
cross
ÖÖ !
=
ÖÖ" #
Math
ÖÖ$ (
.
ÖÖ( )
Normal
ÖÖ) /
(
ÖÖ/ 0
	positions
ÖÖ0 9
[
ÖÖ9 :
a
ÖÖ: ;
]
ÖÖ; <
,
ÖÖ< =
	positions
ÖÖ> G
[
ÖÖG H
b
ÖÖH I
]
ÖÖI J
,
ÖÖJ K
	positions
ÖÖL U
[
ÖÖU V
c
ÖÖV W
]
ÖÖW X
)
ÖÖX Y
;
ÖÖY Z
cross
ÜÜ 
.
ÜÜ 
	Normalize
ÜÜ #
(
ÜÜ# $
)
ÜÜ$ %
;
ÜÜ% &
normals
àà 
[
àà 
a
àà 
]
àà 
.
àà 
x
àà  
+=
àà! #
cross
àà$ )
.
àà) *
x
àà* +
;
àà+ ,
normals
ââ 
[
ââ 
b
ââ 
]
ââ 
.
ââ 
x
ââ  
+=
ââ! #
cross
ââ$ )
.
ââ) *
x
ââ* +
;
ââ+ ,
normals
ää 
[
ää 
c
ää 
]
ää 
.
ää 
x
ää  
+=
ää! #
cross
ää$ )
.
ää) *
x
ää* +
;
ää+ ,
normals
åå 
[
åå 
a
åå 
]
åå 
.
åå 
y
åå  
+=
åå! #
cross
åå$ )
.
åå) *
y
åå* +
;
åå+ ,
normals
çç 
[
çç 
b
çç 
]
çç 
.
çç 
y
çç  
+=
çç! #
cross
çç$ )
.
çç) *
y
çç* +
;
çç+ ,
normals
éé 
[
éé 
c
éé 
]
éé 
.
éé 
y
éé  
+=
éé! #
cross
éé$ )
.
éé) *
y
éé* +
;
éé+ ,
normals
êê 
[
êê 
a
êê 
]
êê 
.
êê 
z
êê  
+=
êê! #
cross
êê$ )
.
êê) *
z
êê* +
;
êê+ ,
normals
ëë 
[
ëë 
b
ëë 
]
ëë 
.
ëë 
z
ëë  
+=
ëë! #
cross
ëë$ )
.
ëë) *
z
ëë* +
;
ëë+ ,
normals
íí 
[
íí 
c
íí 
]
íí 
.
íí 
z
íí  
+=
íí! #
cross
íí$ )
.
íí) *
z
íí* +
;
íí+ ,
s_CachedIntArray
îî $
[
îî$ %
a
îî% &
]
îî& '
++
îî' )
;
îî) *
s_CachedIntArray
ïï $
[
ïï$ %
b
ïï% &
]
ïï& '
++
ïï' )
;
ïï) *
s_CachedIntArray
ññ $
[
ññ$ %
c
ññ% &
]
ññ& '
++
ññ' )
;
ññ) *
}
óó 
}
òò 
for
öö 
(
öö 
var
öö 
i
öö 
=
öö 
$num
öö 
;
öö 
i
öö 
<
öö 
vertexCount
öö  +
;
öö+ ,
i
öö- .
++
öö. 0
)
öö0 1
{
õõ 
normals
úú 
[
úú 
i
úú 
]
úú 
.
úú 
x
úú 
=
úú 
normals
úú &
[
úú& '
i
úú' (
]
úú( )
.
úú) *
x
úú* +
/
úú, -
s_CachedIntArray
úú. >
[
úú> ?
i
úú? @
]
úú@ A
;
úúA B
normals
ùù 
[
ùù 
i
ùù 
]
ùù 
.
ùù 
y
ùù 
=
ùù 
normals
ùù &
[
ùù& '
i
ùù' (
]
ùù( )
.
ùù) *
y
ùù* +
/
ùù, -
s_CachedIntArray
ùù. >
[
ùù> ?
i
ùù? @
]
ùù@ A
;
ùùA B
normals
ûû 
[
ûû 
i
ûû 
]
ûû 
.
ûû 
z
ûû 
=
ûû 
normals
ûû &
[
ûû& '
i
ûû' (
]
ûû( )
.
ûû) *
z
ûû* +
/
ûû, -
s_CachedIntArray
ûû. >
[
ûû> ?
i
ûû? @
]
ûû@ A
;
ûûA B
}
üü 
}
†† 	
public
¶¶ 
static
¶¶ 
void
¶¶ 
CalculateNormals
¶¶ +
(
¶¶+ ,
ProBuilderMesh
¶¶, :
mesh
¶¶; ?
)
¶¶? @
{
ßß 	"
CalculateHardNormals
®®  
(
®®  !
mesh
®®! %
)
®®% &
;
®®& '
var
™™ 
sharedVertices
™™ 
=
™™  
mesh
™™! %
.
™™% &$
sharedVerticesInternal
™™& <
;
™™< =
var
´´ 
faces
´´ 
=
´´ 
mesh
´´ 
.
´´ 
facesInternal
´´ *
;
´´* +
var
≠≠ 
normals
≠≠ 
=
≠≠ 
mesh
≠≠ 
.
≠≠ 
normalsInternal
≠≠ .
;
≠≠. /
int
ÆÆ 
smoothGroupMax
ÆÆ 
=
ÆÆ  
$num
ÆÆ! #
;
ÆÆ# $
ClearIntArray
∞∞ 
(
∞∞ 
mesh
∞∞ 
.
∞∞ 
vertexCount
∞∞ *
)
∞∞* +
;
∞∞+ ,
for
≥≥ 
(
≥≥ 
int
≥≥ 
i
≥≥ 
=
≥≥ 
$num
≥≥ 
,
≥≥ 
c
≥≥ 
=
≥≥ 
mesh
≥≥  $
.
≥≥$ %
	faceCount
≥≥% .
;
≥≥. /
i
≥≥0 1
<
≥≥2 3
c
≥≥4 5
;
≥≥5 6
i
≥≥7 8
++
≥≥8 :
)
≥≥: ;
{
¥¥ 
var
µµ 
face
µµ 
=
µµ 
faces
µµ  
[
µµ  !
i
µµ! "
]
µµ" #
;
µµ# $
var
∂∂ 
indices
∂∂ 
=
∂∂ 
face
∂∂ "
.
∂∂" #%
distinctIndexesInternal
∂∂# :
;
∂∂: ;
for
∏∏ 
(
∏∏ 
int
∏∏ 
n
∏∏ 
=
∏∏ 
$num
∏∏ 
,
∏∏ 
d
∏∏  !
=
∏∏" #
indices
∏∏$ +
.
∏∏+ ,
Length
∏∏, 2
;
∏∏2 3
n
∏∏4 5
<
∏∏6 7
d
∏∏8 9
;
∏∏9 :
n
∏∏; <
++
∏∏< >
)
∏∏> ?
{
ππ 
s_CachedIntArray
∫∫ $
[
∫∫$ %
indices
∫∫% ,
[
∫∫, -
n
∫∫- .
]
∫∫. /
]
∫∫/ 0
=
∫∫1 2
face
∫∫3 7
.
∫∫7 8
smoothingGroup
∫∫8 F
;
∫∫F G
if
ºº 
(
ºº 
face
ºº 
.
ºº 
smoothingGroup
ºº +
>=
ºº, .
smoothGroupMax
ºº/ =
)
ºº= >
smoothGroupMax
ΩΩ &
=
ΩΩ' (
face
ΩΩ) -
.
ΩΩ- .
smoothingGroup
ΩΩ. <
+
ΩΩ= >
$num
ΩΩ? @
;
ΩΩ@ A
}
ææ 
}
øø 
if
¬¬ 
(
¬¬ 
smoothGroupMax
¬¬ 
>
¬¬  
s_SmoothAvg
¬¬! ,
.
¬¬, -
Length
¬¬- 3
)
¬¬3 4
{
√√ 
Array
ƒƒ 
.
ƒƒ 
Resize
ƒƒ 
(
ƒƒ 
ref
ƒƒ  
s_SmoothAvg
ƒƒ! ,
,
ƒƒ, -
smoothGroupMax
ƒƒ. <
)
ƒƒ< =
;
ƒƒ= >
Array
≈≈ 
.
≈≈ 
Resize
≈≈ 
(
≈≈ 
ref
≈≈  
s_SmoothAvgCount
≈≈! 1
,
≈≈1 2
smoothGroupMax
≈≈3 A
)
≈≈A B
;
≈≈B C
}
∆∆ 
for
   
(
   
var
   
i
   
=
   
$num
   
;
   
i
   
<
   
sharedVertices
    .
.
  . /
Length
  / 5
;
  5 6
i
  7 8
++
  8 :
)
  : ;
{
ÀÀ 
for
ÃÃ 
(
ÃÃ 
var
ÃÃ 
n
ÃÃ 
=
ÃÃ 
$num
ÃÃ 
;
ÃÃ 
n
ÃÃ  !
<
ÃÃ" #
smoothGroupMax
ÃÃ$ 2
;
ÃÃ2 3
n
ÃÃ4 5
++
ÃÃ5 7
)
ÃÃ7 8
{
ÕÕ 
s_SmoothAvg
ŒŒ 
[
ŒŒ  
n
ŒŒ  !
]
ŒŒ! "
.
ŒŒ" #
x
ŒŒ# $
=
ŒŒ% &
$num
ŒŒ' )
;
ŒŒ) *
s_SmoothAvg
œœ 
[
œœ  
n
œœ  !
]
œœ! "
.
œœ" #
y
œœ# $
=
œœ% &
$num
œœ' )
;
œœ) *
s_SmoothAvg
–– 
[
––  
n
––  !
]
––! "
.
––" #
z
––# $
=
––% &
$num
––' )
;
––) *
s_SmoothAvgCount
—— $
[
——$ %
n
——% &
]
——& '
=
——( )
$num
——* ,
;
——, -
}
““ 
for
‘‘ 
(
‘‘ 
var
‘‘ 
n
‘‘ 
=
‘‘ 
$num
‘‘ 
;
‘‘ 
n
‘‘  !
<
‘‘" #
sharedVertices
‘‘$ 2
[
‘‘2 3
i
‘‘3 4
]
‘‘4 5
.
‘‘5 6
Count
‘‘6 ;
;
‘‘; <
n
‘‘= >
++
‘‘> @
)
‘‘@ A
{
’’ 
int
÷÷ 
index
÷÷ 
=
÷÷ 
sharedVertices
÷÷  .
[
÷÷. /
i
÷÷/ 0
]
÷÷0 1
[
÷÷1 2
n
÷÷2 3
]
÷÷3 4
;
÷÷4 5
int
◊◊ 
group
◊◊ 
=
◊◊ 
s_CachedIntArray
◊◊  0
[
◊◊0 1
index
◊◊1 6
]
◊◊6 7
;
◊◊7 8
if
€€ 
(
€€ 
group
€€ 
<=
€€  
	Smoothing
€€! *
.
€€* + 
smoothingGroupNone
€€+ =
||
€€> @
(
‹‹ 
group
‹‹ 
>
‹‹  
	Smoothing
‹‹! *
.
‹‹* +
smoothRangeMax
‹‹+ 9
&&
‹‹: <
group
‹‹= B
<
‹‹C D
	Smoothing
‹‹E N
.
‹‹N O
hardRangeMax
‹‹O [
)
‹‹[ \
)
‹‹\ ]
continue
››  
;
››  !
s_SmoothAvg
ﬂﬂ 
[
ﬂﬂ  
group
ﬂﬂ  %
]
ﬂﬂ% &
.
ﬂﬂ& '
x
ﬂﬂ' (
+=
ﬂﬂ) +
normals
ﬂﬂ, 3
[
ﬂﬂ3 4
index
ﬂﬂ4 9
]
ﬂﬂ9 :
.
ﬂﬂ: ;
x
ﬂﬂ; <
;
ﬂﬂ< =
s_SmoothAvg
‡‡ 
[
‡‡  
group
‡‡  %
]
‡‡% &
.
‡‡& '
y
‡‡' (
+=
‡‡) +
normals
‡‡, 3
[
‡‡3 4
index
‡‡4 9
]
‡‡9 :
.
‡‡: ;
y
‡‡; <
;
‡‡< =
s_SmoothAvg
·· 
[
··  
group
··  %
]
··% &
.
··& '
z
··' (
+=
··) +
normals
··, 3
[
··3 4
index
··4 9
]
··9 :
.
··: ;
z
··; <
;
··< =
s_SmoothAvgCount
‚‚ $
[
‚‚$ %
group
‚‚% *
]
‚‚* +
+=
‚‚, .
$num
‚‚/ 1
;
‚‚1 2
}
„„ 
for
ÂÂ 
(
ÂÂ 
int
ÂÂ 
n
ÂÂ 
=
ÂÂ 
$num
ÂÂ 
;
ÂÂ 
n
ÂÂ  !
<
ÂÂ" #
sharedVertices
ÂÂ$ 2
[
ÂÂ2 3
i
ÂÂ3 4
]
ÂÂ4 5
.
ÂÂ5 6
Count
ÂÂ6 ;
;
ÂÂ; <
n
ÂÂ= >
++
ÂÂ> @
)
ÂÂ@ A
{
ÊÊ 
int
ÁÁ 
index
ÁÁ 
=
ÁÁ 
sharedVertices
ÁÁ  .
[
ÁÁ. /
i
ÁÁ/ 0
]
ÁÁ0 1
[
ÁÁ1 2
n
ÁÁ2 3
]
ÁÁ3 4
;
ÁÁ4 5
int
ËË 
group
ËË 
=
ËË 
s_CachedIntArray
ËË  0
[
ËË0 1
index
ËË1 6
]
ËË6 7
;
ËË7 8
if
ÍÍ 
(
ÍÍ 
group
ÍÍ 
<=
ÍÍ  
	Smoothing
ÍÍ! *
.
ÍÍ* + 
smoothingGroupNone
ÍÍ+ =
||
ÍÍ> @
(
ÎÎ 
group
ÎÎ 
>
ÎÎ  
	Smoothing
ÎÎ! *
.
ÎÎ* +
smoothRangeMax
ÎÎ+ 9
&&
ÎÎ: <
group
ÎÎ= B
<
ÎÎC D
	Smoothing
ÎÎE N
.
ÎÎN O
hardRangeMax
ÎÎO [
)
ÎÎ[ \
)
ÎÎ\ ]
continue
ÏÏ  
;
ÏÏ  !
normals
ÓÓ 
[
ÓÓ 
index
ÓÓ !
]
ÓÓ! "
.
ÓÓ" #
x
ÓÓ# $
=
ÓÓ% &
s_SmoothAvg
ÓÓ' 2
[
ÓÓ2 3
group
ÓÓ3 8
]
ÓÓ8 9
.
ÓÓ9 :
x
ÓÓ: ;
/
ÓÓ< =
s_SmoothAvgCount
ÓÓ> N
[
ÓÓN O
group
ÓÓO T
]
ÓÓT U
;
ÓÓU V
normals
ÔÔ 
[
ÔÔ 
index
ÔÔ !
]
ÔÔ! "
.
ÔÔ" #
y
ÔÔ# $
=
ÔÔ% &
s_SmoothAvg
ÔÔ' 2
[
ÔÔ2 3
group
ÔÔ3 8
]
ÔÔ8 9
.
ÔÔ9 :
y
ÔÔ: ;
/
ÔÔ< =
s_SmoothAvgCount
ÔÔ> N
[
ÔÔN O
group
ÔÔO T
]
ÔÔT U
;
ÔÔU V
normals
 
[
 
index
 !
]
! "
.
" #
z
# $
=
% &
s_SmoothAvg
' 2
[
2 3
group
3 8
]
8 9
.
9 :
z
: ;
/
< =
s_SmoothAvgCount
> N
[
N O
group
O T
]
T U
;
U V
normals
ÚÚ 
[
ÚÚ 
index
ÚÚ !
]
ÚÚ! "
.
ÚÚ" #
	Normalize
ÚÚ# ,
(
ÚÚ, -
)
ÚÚ- .
;
ÚÚ. /
}
ÛÛ 
}
ÙÙ 
}
ıı 	
}
ˆˆ 
}˜˜ ˛…
êD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\Bevel.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{		 
public 

static 
class 
Bevel 
{ 
public 
static 
List 
< 
Face 
>  

BevelEdges! +
(+ ,
ProBuilderMesh, :
mesh; ?
,? @
IListA F
<F G
EdgeG K
>K L
edgesM R
,R S
floatT Y
amountZ `
)` a
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new !
ArgumentNullException /
(/ 0
$str0 6
)6 7
;7 8

Dictionary 
< 
int 
, 
int 
>  
lookup! '
=( )
mesh* .
.. /
sharedVertexLookup/ A
;A B
List 
< 
Vertex 
> 
vertices !
=" #
new$ '
List( ,
<, -
Vertex- 3
>3 4
(4 5
mesh5 9
.9 :
GetVertices: E
(E F
)F G
)G H
;H I
List 
< 

EdgeLookup 
> 
m_edges $
=% &

EdgeLookup' 1
.1 2
GetEdgeLookup2 ?
(? @
edges@ E
,E F
lookupG M
)M N
.N O
DistinctO W
(W X
)X Y
.Y Z
ToListZ `
(` a
)a b
;b c
List 
< 

WingedEdge 
> 
wings "
=# $

WingedEdge% /
./ 0
GetWingedEdges0 >
(> ?
mesh? C
)C D
;D E
List 
< 
FaceRebuildData  
>  !
appendFaces" -
=. /
new0 3
List4 8
<8 9
FaceRebuildData9 H
>H I
(I J
)J K
;K L

Dictionary!! 
<!! 
Face!! 
,!! 
List!! !
<!!! "
int!!" %
>!!% &
>!!& '
ignore!!( .
=!!/ 0
new!!1 4

Dictionary!!5 ?
<!!? @
Face!!@ D
,!!D E
List!!F J
<!!J K
int!!K N
>!!N O
>!!O P
(!!P Q
)!!Q R
;!!R S
HashSet"" 
<"" 
int"" 
>"" 
slide"" 
=""  
new""! $
HashSet""% ,
<"", -
int""- 0
>""0 1
(""1 2
)""2 3
;""3 4
int## 
beveled## 
=## 
$num## 
;## 

Dictionary%% 
<%% 
int%% 
,%% 
List%%  
<%%  !
SimpleTuple%%! ,
<%%, -
FaceRebuildData%%- <
,%%< =
List%%> B
<%%B C
int%%C F
>%%F G
>%%G H
>%%H I
>%%I J
holes%%K P
=%%Q R
new%%S V

Dictionary%%W a
<%%a b
int%%b e
,%%e f
List%%g k
<%%k l
SimpleTuple%%l w
<%%w x
FaceRebuildData	%%x á
,
%%á à
List
%%â ç
<
%%ç é
int
%%é ë
>
%%ë í
>
%%í ì
>
%%ì î
>
%%î ï
(
%%ï ñ
)
%%ñ ó
;
%%ó ò

Dictionary)) 
<)) 
int)) 
,)) 
List))  
<))  !

WingedEdge))! +
>))+ ,
>)), -
spokes)). 4
=))5 6

WingedEdge))7 A
.))A B
	GetSpokes))B K
())K L
wings))L Q
)))Q R
;))R S
HashSet** 
<** 
int** 
>** 
tested_common** &
=**' (
new**) ,
HashSet**- 4
<**4 5
int**5 8
>**8 9
(**9 :
)**: ;
;**; <
foreach,, 
(,, 

EdgeLookup,, 
e,,  !
in,," $
m_edges,,% ,
),,, -
{-- 
if.. 
(.. 
tested_common.. !
...! "
Add.." %
(..% &
e..& '
...' (
common..( .
.... /
a../ 0
)..0 1
)..1 2
{// 
foreach00 
(00 

WingedEdge00 '
w00( )
in00* ,
spokes00- 3
[003 4
e004 5
.005 6
common006 <
.00< =
a00= >
]00> ?
)00? @
{11 
Edge22 
le22 
=22  !
w22" #
.22# $
edge22$ (
.22( )
local22) .
;22. /
amount33 
=33  
Mathf33! &
.33& '
Min33' *
(33* +
Vector333+ 2
.332 3
Distance333 ;
(33; <
vertices33< D
[33D E
le33E G
.33G H
a33H I
]33I J
.33J K
position33K S
,33S T
vertices33U ]
[33] ^
le33^ `
.33` a
b33a b
]33b c
.33c d
position33d l
)33l m
-33n o
$num33p u
,33u v
amount33w }
)33} ~
;33~ 
}44 
}55 
if77 
(77 
tested_common77 !
.77! "
Add77" %
(77% &
e77& '
.77' (
common77( .
.77. /
b77/ 0
)770 1
)771 2
{88 
foreach99 
(99 

WingedEdge99 '
w99( )
in99* ,
spokes99- 3
[993 4
e994 5
.995 6
common996 <
.99< =
b99= >
]99> ?
)99? @
{:: 
Edge;; 
le;; 
=;;  !
w;;" #
.;;# $
edge;;$ (
.;;( )
local;;) .
;;;. /
amount<< 
=<<  
Mathf<<! &
.<<& '
Min<<' *
(<<* +
Vector3<<+ 2
.<<2 3
Distance<<3 ;
(<<; <
vertices<<< D
[<<D E
le<<E G
.<<G H
a<<H I
]<<I J
.<<J K
position<<K S
,<<S T
vertices<<U ]
[<<] ^
le<<^ `
.<<` a
b<<a b
]<<b c
.<<c d
position<<d l
)<<l m
-<<n o
$num<<p u
,<<u v
amount<<w }
)<<} ~
;<<~ 
}== 
}>> 
}?? 
ifAA 
(AA 
amountAA 
<AA 
$numAA 
)AA 
{BB 
LogCC 
.CC 
InfoCC 
(CC 
$strCC =
)CC= >
;CC> ?
returnDD 
nullDD 
;DD 
}EE 
foreachII 
(II 

EdgeLookupII 
lupII  #
inII$ &
m_edgesII' .
)II. /
{JJ 

WingedEdgeKK 
weKK 
=KK 
wingsKK  %
.KK% &
FirstOrDefaultKK& 4
(KK4 5
xKK5 6
=>KK7 9
xKK: ;
.KK; <
edgeKK< @
.KK@ A
EqualsKKA G
(KKG H
lupKKH K
)KKK L
)KKL M
;KKM N
ifMM 
(MM 
weMM 
==MM 
nullMM 
||MM !
weMM" $
.MM$ %
oppositeMM% -
==MM. 0
nullMM1 5
)MM5 6
continueNN 
;NN 
beveledPP 
++PP 
;PP 
ignoreRR 
.RR 
AddOrAppendRR "
(RR" #
weRR# %
.RR% &
faceRR& *
,RR* +
weRR, .
.RR. /
edgeRR/ 3
.RR3 4
commonRR4 :
.RR: ;
aRR; <
)RR< =
;RR= >
ignoreSS 
.SS 
AddOrAppendSS "
(SS" #
weSS# %
.SS% &
faceSS& *
,SS* +
weSS, .
.SS. /
edgeSS/ 3
.SS3 4
commonSS4 :
.SS: ;
bSS; <
)SS< =
;SS= >
ignoreTT 
.TT 
AddOrAppendTT "
(TT" #
weTT# %
.TT% &
oppositeTT& .
.TT. /
faceTT/ 3
,TT3 4
weTT5 7
.TT7 8
edgeTT8 <
.TT< =
commonTT= C
.TTC D
aTTD E
)TTE F
;TTF G
ignoreUU 
.UU 
AddOrAppendUU "
(UU" #
weUU# %
.UU% &
oppositeUU& .
.UU. /
faceUU/ 3
,UU3 4
weUU5 7
.UU7 8
edgeUU8 <
.UU< =
commonUU= C
.UUC D
bUUD E
)UUE F
;UUF G
slideXX 
.XX 
AddXX 
(XX 
weXX 
.XX 
edgeXX !
.XX! "
commonXX" (
.XX( )
aXX) *
)XX* +
;XX+ ,
slideYY 
.YY 
AddYY 
(YY 
weYY 
.YY 
edgeYY !
.YY! "
commonYY" (
.YY( )
bYY) *
)YY* +
;YY+ ,
	SlideEdge[[ 
([[ 
vertices[[ "
,[[" #
we[[$ &
,[[& '
amount[[( .
)[[. /
;[[/ 0
	SlideEdge\\ 
(\\ 
vertices\\ "
,\\" #
we\\$ &
.\\& '
opposite\\' /
,\\/ 0
amount\\1 7
)\\7 8
;\\8 9
appendFaces^^ 
.^^ 
AddRange^^ $
(^^$ %
GetBridgeFaces^^% 3
(^^3 4
vertices^^4 <
,^^< =
we^^> @
,^^@ A
we^^B D
.^^D E
opposite^^E M
,^^M N
holes^^O T
)^^T U
)^^U V
;^^V W
}__ 
ifaa 
(aa 
beveledaa 
<aa 
$numaa 
)aa 
{bb 
Logcc 
.cc 
Infocc 
(cc 
$strcc 2
)cc2 3
;cc3 4
returndd 
nulldd 
;dd 
}ee 
varii 
createdFacesii 
=ii 
newii "
Listii# '
<ii' (
Faceii( ,
>ii, -
(ii- .
appendFacesii. 9
.ii9 :
Selectii: @
(ii@ A
xiiA B
=>iiC E
xiiF G
.iiG H
faceiiH L
)iiL M
)iiM N
;iiN O

Dictionarykk 
<kk 
Facekk 
,kk 
Listkk !
<kk! "
SimpleTuplekk" -
<kk- .

WingedEdgekk. 8
,kk8 9
intkk: =
>kk= >
>kk> ?
>kk? @
sortedkkA G
=kkH I
newkkJ M

DictionarykkN X
<kkX Y
FacekkY ]
,kk] ^
Listkk_ c
<kkc d
SimpleTuplekkd o
<kko p

WingedEdgekkp z
,kkz {
intkk| 
>	kk Ä
>
kkÄ Å
>
kkÅ Ç
(
kkÇ É
)
kkÉ Ñ
;
kkÑ Ö
foreachoo 
(oo 
intoo 
coo 
inoo 
slideoo #
)oo# $
{pp 
IEnumerableqq 
<qq 

WingedEdgeqq &
>qq& '
matchesqq( /
=qq0 1
wingsqq2 7
.qq7 8
Whereqq8 =
(qq= >
xqq> ?
=>qq@ B
xqqC D
.qqD E
edgeqqE I
.qqI J
commonqqJ P
.qqP Q
ContainsqqQ Y
(qqY Z
cqqZ [
)qq[ \
&&qq] _
!qq` a
(qqa b
ignoreqqb h
.qqh i
ContainsKeyqqi t
(qqt u
xqqu v
.qqv w
faceqqw {
)qq{ |
&&qq} 
ignore
qqÄ Ü
[
qqÜ á
x
qqá à
.
qqà â
face
qqâ ç
]
qqç é
.
qqé è
Contains
qqè ó
(
qqó ò
c
qqò ô
)
qqô ö
)
qqö õ
)
qqõ ú
;
qqú ù
HashSetss 
<ss 
Facess 
>ss 
usedss "
=ss# $
newss% (
HashSetss) 0
<ss0 1
Facess1 5
>ss5 6
(ss6 7
)ss7 8
;ss8 9
foreachuu 
(uu 

WingedEdgeuu #
matchuu$ )
inuu* ,
matchesuu- 4
)uu4 5
{vv 
ifww 
(ww 
!ww 
usedww 
.ww 
Addww !
(ww! "
matchww" '
.ww' (
faceww( ,
)ww, -
)ww- .
continuexx  
;xx  !
sortedzz 
.zz 
AddOrAppendzz &
(zz& '
matchzz' ,
.zz, -
facezz- 1
,zz1 2
newzz3 6
SimpleTuplezz7 B
<zzB C

WingedEdgezzC M
,zzM N
intzzO R
>zzR S
(zzS T
matchzzT Y
,zzY Z
czz[ \
)zz\ ]
)zz] ^
;zz^ _
}{{ 
}|| 
foreach 
( 
KeyValuePair !
<! "
Face" &
,& '
List( ,
<, -
SimpleTuple- 8
<8 9

WingedEdge9 C
,C D
intE H
>H I
>I J
>J K
kvpL O
inP R
sortedS Y
)Y Z
{
ÄÄ 

Dictionary
ÇÇ 
<
ÇÇ 
int
ÇÇ 
,
ÇÇ 
List
ÇÇ  $
<
ÇÇ$ %
int
ÇÇ% (
>
ÇÇ( )
>
ÇÇ) *
appended
ÇÇ+ 3
;
ÇÇ3 4
FaceRebuildData
ÑÑ 
f
ÑÑ  !
=
ÑÑ" #
VertexEditing
ÑÑ$ 1
.
ÑÑ1 2
ExplodeVertex
ÑÑ2 ?
(
ÑÑ? @
vertices
ÑÑ@ H
,
ÑÑH I
kvp
ÑÑJ M
.
ÑÑM N
Value
ÑÑN S
,
ÑÑS T
amount
ÑÑU [
,
ÑÑ[ \
out
ÑÑ] `
appended
ÑÑa i
)
ÑÑi j
;
ÑÑj k
if
ÜÜ 
(
ÜÜ 
f
ÜÜ 
==
ÜÜ 
null
ÜÜ 
)
ÜÜ 
continue
áá 
;
áá 
appendFaces
ââ 
.
ââ 
Add
ââ 
(
ââ  
f
ââ  !
)
ââ! "
;
ââ" #
foreach
ãã 
(
ãã 
var
ãã 
apv
ãã  
in
ãã! #
appended
ãã$ ,
)
ãã, -
{
åå 
holes
èè 
.
èè 
AddOrAppend
èè %
(
èè% &
apv
èè& )
.
èè) *
Key
èè* -
,
èè- .
new
èè/ 2
SimpleTuple
èè3 >
<
èè> ?
FaceRebuildData
èè? N
,
èèN O
List
èèP T
<
èèT U
int
èèU X
>
èèX Y
>
èèY Z
(
èèZ [
f
èè[ \
,
èè\ ]
apv
èè^ a
.
èèa b
Value
èèb g
)
èèg h
)
èèh i
;
èèi j
}
êê 
}
ëë 
FaceRebuildData
ìì 
.
ìì 
Apply
ìì !
(
ìì! "
appendFaces
ìì" -
,
ìì- .
mesh
ìì/ 3
,
ìì3 4
vertices
ìì5 =
)
ìì= >
;
ìì> ?
int
îî 
removed
îî 
=
îî 
mesh
îî 
.
îî 
DeleteFaces
îî *
(
îî* +
sorted
îî+ 1
.
îî1 2
Keys
îî2 6
)
îî6 7
.
îî7 8
Length
îî8 >
;
îî> ?
mesh
ïï 
.
ïï 
sharedTextures
ïï 
=
ïï  !
new
ïï" %
SharedVertex
ïï& 2
[
ïï2 3
$num
ïï3 4
]
ïï4 5
;
ïï5 6
mesh
ññ 
.
ññ 
sharedVertices
ññ 
=
ññ  !
SharedVertex
ññ" .
.
ññ. /,
GetSharedVerticesWithPositions
ññ/ M
(
ññM N
mesh
ññN R
.
ññR S
positionsInternal
ññS d
)
ññd e
;
ññe f
SharedVertex
ôô 
[
ôô 
]
ôô 
sharedIndexes
ôô (
=
ôô) *
mesh
ôô+ /
.
ôô/ 0$
sharedVerticesInternal
ôô0 F
;
ôôF G
lookup
öö 
=
öö 
mesh
öö 
.
öö  
sharedVertexLookup
öö ,
;
öö, -
List
õõ 
<
õõ 
HashSet
õõ 
<
õõ 
int
õõ 
>
õõ 
>
õõ  
holesCommonIndexes
õõ 1
=
õõ2 3
new
õõ4 7
List
õõ8 <
<
õõ< =
HashSet
õõ= D
<
õõD E
int
õõE H
>
õõH I
>
õõI J
(
õõJ K
)
õõK L
;
õõL M
foreach
ûû 
(
ûû 
KeyValuePair
ûû !
<
ûû! "
int
ûû" %
,
ûû% &
List
ûû' +
<
ûû+ ,
SimpleTuple
ûû, 7
<
ûû7 8
FaceRebuildData
ûû8 G
,
ûûG H
List
ûûI M
<
ûûM N
int
ûûN Q
>
ûûQ R
>
ûûR S
>
ûûS T
>
ûûT U
hole
ûûV Z
in
ûû[ ]
holes
ûû^ c
)
ûûc d
{
üü 
if
°° 
(
°° 
hole
°° 
.
°° 
Value
°° 
.
°° 
Sum
°° "
(
°°" #
x
°°# $
=>
°°% '
x
°°( )
.
°°) *
item2
°°* /
.
°°/ 0
Count
°°0 5
)
°°5 6
<
°°7 8
$num
°°9 :
)
°°: ;
continue
¢¢ 
;
¢¢ 
HashSet
§§ 
<
§§ 
int
§§ 
>
§§ 

holeCommon
§§ '
=
§§( )
new
§§* -
HashSet
§§. 5
<
§§5 6
int
§§6 9
>
§§9 :
(
§§: ;
)
§§; <
;
§§< =
foreach
¶¶ 
(
¶¶ 
SimpleTuple
¶¶ $
<
¶¶$ %
FaceRebuildData
¶¶% 4
,
¶¶4 5
List
¶¶6 :
<
¶¶: ;
int
¶¶; >
>
¶¶> ?
>
¶¶? @
path
¶¶A E
in
¶¶F H
hole
¶¶I M
.
¶¶M N
Value
¶¶N S
)
¶¶S T
{
ßß 
int
®® 
offset
®® 
=
®®  
path
®®! %
.
®®% &
item1
®®& +
.
®®+ ,
Offset
®®, 2
(
®®2 3
)
®®3 4
-
®®5 6
removed
®®7 >
;
®®> ?
for
™™ 
(
™™ 
int
™™ 
i
™™ 
=
™™  
$num
™™! "
;
™™" #
i
™™$ %
<
™™& '
path
™™( ,
.
™™, -
item2
™™- 2
.
™™2 3
Count
™™3 8
;
™™8 9
i
™™: ;
++
™™; =
)
™™= >

holeCommon
´´ "
.
´´" #
Add
´´# &
(
´´& '
lookup
´´' -
[
´´- .
path
´´. 2
.
´´2 3
item2
´´3 8
[
´´8 9
i
´´9 :
]
´´: ;
+
´´< =
offset
´´> D
]
´´D E
)
´´E F
;
´´F G
}
¨¨  
holesCommonIndexes
ÆÆ "
.
ÆÆ" #
Add
ÆÆ# &
(
ÆÆ& '

holeCommon
ÆÆ' 1
)
ÆÆ1 2
;
ÆÆ2 3
}
ØØ 
List
±± 
<
±± 

WingedEdge
±± 
>
±± 
modified
±± %
=
±±& '

WingedEdge
±±( 2
.
±±2 3
GetWingedEdges
±±3 A
(
±±A B
mesh
±±B F
,
±±F G
appendFaces
±±H S
.
±±S T
Select
±±T Z
(
±±Z [
x
±±[ \
=>
±±] _
x
±±` a
.
±±a b
face
±±b f
)
±±f g
)
±±g h
;
±±h i
vertices
¥¥ 
=
¥¥ 
new
¥¥ 
List
¥¥ 
<
¥¥  
Vertex
¥¥  &
>
¥¥& '
(
¥¥' (
mesh
¥¥( ,
.
¥¥, -
GetVertices
¥¥- 8
(
¥¥8 9
)
¥¥9 :
)
¥¥: ;
;
¥¥; <
List
∂∂ 
<
∂∂ 
FaceRebuildData
∂∂  
>
∂∂  !
	holeFaces
∂∂" +
=
∂∂, -
new
∂∂. 1
List
∂∂2 6
<
∂∂6 7
FaceRebuildData
∂∂7 F
>
∂∂F G
(
∂∂G H
)
∂∂H I
;
∂∂I J
foreach
∏∏ 
(
∏∏ 
HashSet
∏∏ 
<
∏∏ 
int
∏∏  
>
∏∏  !
h
∏∏" #
in
∏∏$ & 
holesCommonIndexes
∏∏' 9
)
∏∏9 :
{
ππ 
if
ºº 
(
ºº 
h
ºº 
.
ºº 
Count
ºº 
<
ºº 
$num
ºº 
)
ºº  
{
ΩΩ 
continue
ææ 
;
ææ 
}
øø 
if
¡¡ 
(
¡¡ 
h
¡¡ 
.
¡¡ 
Count
¡¡ 
<
¡¡ 
$num
¡¡ 
)
¡¡  
{
¬¬ 
List
√√ 
<
√√ 
Vertex
√√ 
>
√√  
v
√√! "
=
√√# $
new
√√% (
List
√√) -
<
√√- .
Vertex
√√. 4
>
√√4 5
(
√√5 6
mesh
√√6 :
.
√√: ;
GetVertices
√√; F
(
√√F G
h
√√G H
.
√√H I
Select
√√I O
(
√√O P
x
√√P Q
=>
√√R T
sharedIndexes
√√U b
[
√√b c
x
√√c d
]
√√d e
[
√√e f
$num
√√f g
]
√√g h
)
√√h i
.
√√i j
ToList
√√j p
(
√√p q
)
√√q r
)
√√r s
)
√√s t
;
√√t u
	holeFaces
ƒƒ 
.
ƒƒ 
Add
ƒƒ !
(
ƒƒ! "
AppendElements
ƒƒ" 0
.
ƒƒ0 1
FaceWithVertices
ƒƒ1 A
(
ƒƒA B
v
ƒƒB C
)
ƒƒC D
)
ƒƒD E
;
ƒƒE F
}
≈≈ 
else
«« 
{
»» 
List
…… 
<
…… 
int
…… 
>
…… 
holePath
…… &
=
……' (

WingedEdge
……) 3
.
……3 4*
SortCommonIndexesByAdjacency
……4 P
(
……P Q
modified
……Q Y
,
……Y Z
h
……[ \
)
……\ ]
;
……] ^
if
   
(
   
holePath
    
!=
  ! #
null
  $ (
)
  ( )
{
ÀÀ 
List
ÃÃ 
<
ÃÃ 
Vertex
ÃÃ #
>
ÃÃ# $
v
ÃÃ% &
=
ÃÃ' (
new
ÕÕ 
List
ÕÕ  $
<
ÕÕ$ %
Vertex
ÕÕ% +
>
ÕÕ+ ,
(
ÕÕ, -
mesh
ÕÕ- 1
.
ÕÕ1 2
GetVertices
ÕÕ2 =
(
ÕÕ= >
holePath
ÕÕ> F
.
ÕÕF G
Select
ÕÕG M
(
ÕÕM N
x
ÕÕN O
=>
ÕÕP R
sharedIndexes
ÕÕS `
[
ÕÕ` a
x
ÕÕa b
]
ÕÕb c
[
ÕÕc d
$num
ÕÕd e
]
ÕÕe f
)
ÕÕf g
.
ÕÕg h
ToList
ÕÕh n
(
ÕÕn o
)
ÕÕo p
)
ÕÕp q
)
ÕÕq r
;
ÕÕr s
	holeFaces
ŒŒ !
.
ŒŒ! "
AddRange
ŒŒ" *
(
ŒŒ* +
AppendElements
ŒŒ+ 9
.
ŒŒ9 :!
TentCapWithVertices
ŒŒ: M
(
ŒŒM N
v
ŒŒN O
)
ŒŒO P
)
ŒŒP Q
;
ŒŒQ R
}
œœ 
}
–– 
}
—— 
FaceRebuildData
”” 
.
”” 
Apply
”” !
(
””! "
	holeFaces
””" +
,
””+ ,
mesh
””- 1
,
””1 2
vertices
””3 ;
)
””; <
;
””< =
mesh
‘‘ 
.
‘‘ 
sharedVertices
‘‘ 
=
‘‘  !
SharedVertex
‘‘" .
.
‘‘. /,
GetSharedVerticesWithPositions
‘‘/ M
(
‘‘M N
mesh
‘‘N R
.
‘‘R S
positionsInternal
‘‘S d
)
‘‘d e
;
‘‘e f
HashSet
⁄⁄ 
<
⁄⁄ 
Face
⁄⁄ 
>
⁄⁄ 
newFaces
⁄⁄ "
=
⁄⁄# $
new
⁄⁄% (
HashSet
⁄⁄) 0
<
⁄⁄0 1
Face
⁄⁄1 5
>
⁄⁄5 6
(
⁄⁄6 7
	holeFaces
⁄⁄7 @
.
⁄⁄@ A
Select
⁄⁄A G
(
⁄⁄G H
x
⁄⁄H I
=>
⁄⁄J L
x
⁄⁄M N
.
⁄⁄N O
face
⁄⁄O S
)
⁄⁄S T
)
⁄⁄T U
;
⁄⁄U V
newFaces
€€ 
.
€€ 
	UnionWith
€€ 
(
€€ 
createdFaces
€€ +
)
€€+ ,
;
€€, -
appendFaces
›› 
.
›› 
AddRange
››  
(
››  !
	holeFaces
››! *
)
››* +
;
››+ ,
List
ﬂﬂ 
<
ﬂﬂ 

WingedEdge
ﬂﬂ 
>
ﬂﬂ 
allNewFaceEdges
ﬂﬂ ,
=
ﬂﬂ- .

WingedEdge
ﬂﬂ/ 9
.
ﬂﬂ9 :
GetWingedEdges
ﬂﬂ: H
(
ﬂﬂH I
mesh
ﬂﬂI M
,
ﬂﬂM N
appendFaces
ﬂﬂO Z
.
ﬂﬂZ [
Select
ﬂﬂ[ a
(
ﬂﬂa b
x
ﬂﬂb c
=>
ﬂﬂd f
x
ﬂﬂg h
.
ﬂﬂh i
face
ﬂﬂi m
)
ﬂﬂm n
)
ﬂﬂn o
;
ﬂﬂo p
for
·· 
(
·· 
int
·· 
i
·· 
=
·· 
$num
·· 
;
·· 
i
·· 
<
·· 
allNewFaceEdges
··  /
.
··/ 0
Count
··0 5
&&
··6 8
newFaces
··9 A
.
··A B
Count
··B G
>
··H I
$num
··J K
;
··K L
i
··M N
++
··N P
)
··P Q
{
‚‚ 

WingedEdge
„„ 
wing
„„ 
=
„„  !
allNewFaceEdges
„„" 1
[
„„1 2
i
„„2 3
]
„„3 4
;
„„4 5
if
ÂÂ 
(
ÂÂ 
newFaces
ÂÂ 
.
ÂÂ 
Contains
ÂÂ %
(
ÂÂ% &
wing
ÂÂ& *
.
ÂÂ* +
face
ÂÂ+ /
)
ÂÂ/ 0
)
ÂÂ0 1
{
ÊÊ 
newFaces
ÁÁ 
.
ÁÁ 
Remove
ÁÁ #
(
ÁÁ# $
wing
ÁÁ$ (
.
ÁÁ( )
face
ÁÁ) -
)
ÁÁ- .
;
ÁÁ. /
using
ÏÏ 
(
ÏÏ 
var
ÏÏ 
it
ÏÏ !
=
ÏÏ" #
new
ÏÏ$ '"
WingedEdgeEnumerator
ÏÏ( <
(
ÏÏ< =
wing
ÏÏ= A
)
ÏÏA B
)
ÏÏB C
{
ÌÌ 
while
ÓÓ 
(
ÓÓ 
it
ÓÓ !
.
ÓÓ! "
MoveNext
ÓÓ" *
(
ÓÓ* +
)
ÓÓ+ ,
)
ÓÓ, -
{
ÔÔ 
var
 
w
  !
=
" #
it
$ &
.
& '
Current
' .
;
. /
if
ÚÚ 
(
ÚÚ  
w
ÚÚ  !
.
ÚÚ! "
opposite
ÚÚ" *
!=
ÚÚ+ -
null
ÚÚ. 2
&&
ÚÚ3 5
!
ÚÚ6 7
newFaces
ÚÚ7 ?
.
ÚÚ? @
Contains
ÚÚ@ H
(
ÚÚH I
w
ÚÚI J
.
ÚÚJ K
opposite
ÚÚK S
.
ÚÚS T
face
ÚÚT X
)
ÚÚX Y
)
ÚÚY Z
{
ÛÛ 
w
ÙÙ  !
.
ÙÙ! "
face
ÙÙ" &
.
ÙÙ& '
submeshIndex
ÙÙ' 3
=
ÙÙ4 5
w
ÙÙ6 7
.
ÙÙ7 8
opposite
ÙÙ8 @
.
ÙÙ@ A
face
ÙÙA E
.
ÙÙE F
submeshIndex
ÙÙF R
;
ÙÙR S
w
ıı  !
.
ıı! "
face
ıı" &
.
ıı& '
uv
ıı' )
=
ıı* +
new
ıı, / 
AutoUnwrapSettings
ıı0 B
(
ııB C
w
ııC D
.
ııD E
opposite
ııE M
.
ııM N
face
ııN R
.
ııR S
uv
ııS U
)
ııU V
;
ııV W
SurfaceTopology
ˆˆ  /
.
ˆˆ/ 0#
ConformOppositeNormal
ˆˆ0 E
(
ˆˆE F
w
ˆˆF G
.
ˆˆG H
opposite
ˆˆH P
)
ˆˆP Q
;
ˆˆQ R
break
˜˜  %
;
˜˜% &
}
¯¯ 
}
˘˘ 
}
˙˙ 
}
˚˚ 
}
¸¸ 
mesh
˛˛ 
.
˛˛ 
ToMesh
˛˛ 
(
˛˛ 
)
˛˛ 
;
˛˛ 
return
ÄÄ 
createdFaces
ÄÄ 
;
ÄÄ  
}
ÅÅ 	
static
ÉÉ 
readonly
ÉÉ 
int
ÉÉ 
[
ÉÉ 
]
ÉÉ  
k_BridgeIndexesTri
ÉÉ 0
=
ÉÉ1 2
new
ÉÉ3 6
int
ÉÉ7 :
[
ÉÉ: ;
]
ÉÉ; <
{
ÉÉ= >
$num
ÉÉ? @
,
ÉÉ@ A
$num
ÉÉB C
,
ÉÉC D
$num
ÉÉE F
}
ÉÉG H
;
ÉÉH I
static
ÖÖ 
List
ÖÖ 
<
ÖÖ 
FaceRebuildData
ÖÖ #
>
ÖÖ# $
GetBridgeFaces
ÖÖ% 3
(
ÖÖ3 4
IList
ÜÜ 
<
ÜÜ 
Vertex
ÜÜ 
>
ÜÜ 
vertices
ÜÜ "
,
ÜÜ" #

WingedEdge
áá 
left
áá 
,
áá 

WingedEdge
àà 
right
àà 
,
àà 

Dictionary
ââ 
<
ââ 
int
ââ 
,
ââ 
List
ââ  
<
ââ  !
SimpleTuple
ââ! ,
<
ââ, -
FaceRebuildData
ââ- <
,
ââ< =
List
ââ> B
<
ââB C
int
ââC F
>
ââF G
>
ââG H
>
ââH I
>
ââI J
holes
ââK P
)
ââP Q
{
ää 	
List
ãã 
<
ãã 
FaceRebuildData
ãã  
>
ãã  !
faces
ãã" '
=
ãã( )
new
ãã* -
List
ãã. 2
<
ãã2 3
FaceRebuildData
ãã3 B
>
ããB C
(
ããC D
)
ããD E
;
ããE F
FaceRebuildData
çç 
rf
çç 
=
çç  
new
çç! $
FaceRebuildData
çç% 4
(
çç4 5
)
çç5 6
;
çç6 7

EdgeLookup
èè 
a
èè 
=
èè 
left
èè 
.
èè  
edge
èè  $
;
èè$ %

EdgeLookup
êê 
b
êê 
=
êê 
right
êê  
.
êê  !
edge
êê! %
;
êê% &
rf
íí 
.
íí 
vertices
íí 
=
íí 
new
íí 
List
íí "
<
íí" #
Vertex
íí# )
>
íí) *
(
íí* +
)
íí+ ,
{
ìì 
vertices
îî 
[
îî 
a
îî 
.
îî 
local
îî  
.
îî  !
a
îî! "
]
îî" #
,
îî# $
vertices
ïï 
[
ïï 
a
ïï 
.
ïï 
local
ïï  
.
ïï  !
b
ïï! "
]
ïï" #
,
ïï# $
vertices
ññ 
[
ññ 
a
ññ 
.
ññ 
common
ññ !
.
ññ! "
a
ññ" #
==
ññ$ &
b
ññ' (
.
ññ( )
common
ññ) /
.
ññ/ 0
a
ññ0 1
?
ññ2 3
b
ññ4 5
.
ññ5 6
local
ññ6 ;
.
ññ; <
a
ññ< =
:
ññ> ?
b
ññ@ A
.
ññA B
local
ññB G
.
ññG H
b
ññH I
]
ññI J
,
ññJ K
vertices
óó 
[
óó 
a
óó 
.
óó 
common
óó !
.
óó! "
a
óó" #
==
óó$ &
b
óó' (
.
óó( )
common
óó) /
.
óó/ 0
a
óó0 1
?
óó2 3
b
óó4 5
.
óó5 6
local
óó6 ;
.
óó; <
b
óó< =
:
óó> ?
b
óó@ A
.
óóA B
local
óóB G
.
óóG H
a
óóH I
]
óóI J
}
òò 
;
òò 
Vector3
öö 
an
öö 
=
öö 
Math
öö 
.
öö 
Normal
öö $
(
öö$ %
vertices
öö% -
,
öö- .
left
öö/ 3
.
öö3 4
face
öö4 8
.
öö8 9
indexesInternal
öö9 H
)
ööH I
;
ööI J
Vector3
õõ 
bn
õõ 
=
õõ 
Math
õõ 
.
õõ 
Normal
õõ $
(
õõ$ %
rf
õõ% '
.
õõ' (
vertices
õõ( 0
,
õõ0 1 
k_BridgeIndexesTri
õõ2 D
)
õõD E
;
õõE F
int
ùù 
[
ùù 
]
ùù 
	triangles
ùù 
=
ùù 
new
ùù !
int
ùù" %
[
ùù% &
]
ùù& '
{
ùù( )
$num
ùù* +
,
ùù+ ,
$num
ùù- .
,
ùù. /
$num
ùù0 1
,
ùù1 2
$num
ùù3 4
,
ùù4 5
$num
ùù6 7
,
ùù7 8
$num
ùù9 :
}
ùù; <
;
ùù< =
if
üü 
(
üü 
Vector3
üü 
.
üü 
Dot
üü 
(
üü 
an
üü 
,
üü 
bn
üü  "
)
üü" #
<
üü$ %
$num
üü& (
)
üü( )
System
†† 
.
†† 
Array
†† 
.
†† 
Reverse
†† $
(
††$ %
	triangles
††% .
)
††. /
;
††/ 0
rf
¢¢ 
.
¢¢ 
face
¢¢ 
=
¢¢ 
new
¢¢ 
Face
¢¢ 
(
¢¢ 
	triangles
££ 
,
££ 
left
§§ 
.
§§ 
face
§§ 
.
§§ 
submeshIndex
§§ *
,
§§* + 
AutoUnwrapSettings
•• &
.
••& '
tile
••' +
,
••+ ,
-
¶¶ 
$num
¶¶ 
,
¶¶ 
-
ßß 
$num
ßß 
,
ßß 
-
®® 
$num
®® 
,
®® 
false
©© 
)
©© 
;
©© 
faces
´´ 
.
´´ 
Add
´´ 
(
´´ 
rf
´´ 
)
´´ 
;
´´ 
holes
≠≠ 
.
≠≠ 
AddOrAppend
≠≠ 
(
≠≠ 
a
≠≠ 
.
≠≠  
common
≠≠  &
.
≠≠& '
a
≠≠' (
,
≠≠( )
new
≠≠* -
SimpleTuple
≠≠. 9
<
≠≠9 :
FaceRebuildData
≠≠: I
,
≠≠I J
List
≠≠K O
<
≠≠O P
int
≠≠P S
>
≠≠S T
>
≠≠T U
(
≠≠U V
rf
≠≠V X
,
≠≠X Y
new
≠≠Z ]
List
≠≠^ b
<
≠≠b c
int
≠≠c f
>
≠≠f g
(
≠≠g h
)
≠≠h i
{
≠≠j k
$num
≠≠l m
,
≠≠m n
$num
≠≠o p
}
≠≠q r
)
≠≠r s
)
≠≠s t
;
≠≠t u
holes
ÆÆ 
.
ÆÆ 
AddOrAppend
ÆÆ 
(
ÆÆ 
a
ÆÆ 
.
ÆÆ  
common
ÆÆ  &
.
ÆÆ& '
b
ÆÆ' (
,
ÆÆ( )
new
ÆÆ* -
SimpleTuple
ÆÆ. 9
<
ÆÆ9 :
FaceRebuildData
ÆÆ: I
,
ÆÆI J
List
ÆÆK O
<
ÆÆO P
int
ÆÆP S
>
ÆÆS T
>
ÆÆT U
(
ÆÆU V
rf
ÆÆV X
,
ÆÆX Y
new
ÆÆZ ]
List
ÆÆ^ b
<
ÆÆb c
int
ÆÆc f
>
ÆÆf g
(
ÆÆg h
)
ÆÆh i
{
ÆÆj k
$num
ÆÆl m
,
ÆÆm n
$num
ÆÆo p
}
ÆÆq r
)
ÆÆr s
)
ÆÆs t
;
ÆÆt u
return
∞∞ 
faces
∞∞ 
;
∞∞ 
}
±± 	
static
≥≥ 
void
≥≥ 
	SlideEdge
≥≥ 
(
≥≥ 
IList
≥≥ #
<
≥≥# $
Vertex
≥≥$ *
>
≥≥* +
vertices
≥≥, 4
,
≥≥4 5

WingedEdge
≥≥6 @
we
≥≥A C
,
≥≥C D
float
≥≥E J
amount
≥≥K Q
)
≥≥Q R
{
¥¥ 	
we
µµ 
.
µµ 
face
µµ 
.
µµ 
manualUV
µµ 
=
µµ 
true
µµ #
;
µµ# $
we
∂∂ 
.
∂∂ 
face
∂∂ 
.
∂∂ 
textureGroup
∂∂  
=
∂∂! "
-
∂∂# $
$num
∂∂$ %
;
∂∂% &
Edge
∏∏ 
slide_x
∏∏ 
=
∏∏ 
GetLeadingEdge
∏∏ )
(
∏∏) *
we
∏∏* ,
,
∏∏, -
we
∏∏. 0
.
∏∏0 1
edge
∏∏1 5
.
∏∏5 6
common
∏∏6 <
.
∏∏< =
a
∏∏= >
)
∏∏> ?
;
∏∏? @
Edge
ππ 
slide_y
ππ 
=
ππ 
GetLeadingEdge
ππ )
(
ππ) *
we
ππ* ,
,
ππ, -
we
ππ. 0
.
ππ0 1
edge
ππ1 5
.
ππ5 6
common
ππ6 <
.
ππ< =
b
ππ= >
)
ππ> ?
;
ππ? @
if
ªª 
(
ªª 
!
ªª 
slide_x
ªª 
.
ªª 
IsValid
ªª  
(
ªª  !
)
ªª! "
||
ªª# %
!
ªª& '
slide_y
ªª' .
.
ªª. /
IsValid
ªª/ 6
(
ªª6 7
)
ªª7 8
)
ªª8 9
return
ºº 
;
ºº 
Vertex
ææ 
x
ææ 
=
ææ 
(
ææ 
vertices
ææ  
[
ææ  !
slide_x
ææ! (
.
ææ( )
a
ææ) *
]
ææ* +
-
ææ, -
vertices
ææ. 6
[
ææ6 7
slide_x
ææ7 >
.
ææ> ?
b
ææ? @
]
ææ@ A
)
ææA B
;
ææB C
x
øø 
.
øø 
	Normalize
øø 
(
øø 
)
øø 
;
øø 
Vertex
¡¡ 
y
¡¡ 
=
¡¡ 
(
¡¡ 
vertices
¡¡  
[
¡¡  !
slide_y
¡¡! (
.
¡¡( )
a
¡¡) *
]
¡¡* +
-
¡¡, -
vertices
¡¡. 6
[
¡¡6 7
slide_y
¡¡7 >
.
¡¡> ?
b
¡¡? @
]
¡¡@ A
)
¡¡A B
;
¡¡B C
y
¬¬ 
.
¬¬ 
	Normalize
¬¬ 
(
¬¬ 
)
¬¬ 
;
¬¬ 
vertices
≈≈ 
[
≈≈ 
we
≈≈ 
.
≈≈ 
edge
≈≈ 
.
≈≈ 
local
≈≈ "
.
≈≈" #
a
≈≈# $
]
≈≈$ %
.
≈≈% &
Add
≈≈& )
(
≈≈) *
x
≈≈* +
*
≈≈, -
amount
≈≈. 4
)
≈≈4 5
;
≈≈5 6
vertices
∆∆ 
[
∆∆ 
we
∆∆ 
.
∆∆ 
edge
∆∆ 
.
∆∆ 
local
∆∆ "
.
∆∆" #
b
∆∆# $
]
∆∆$ %
.
∆∆% &
Add
∆∆& )
(
∆∆) *
y
∆∆* +
*
∆∆, -
amount
∆∆. 4
)
∆∆4 5
;
∆∆5 6
}
«« 	
static
…… 
Edge
…… 
GetLeadingEdge
…… "
(
……" #

WingedEdge
……# -
wing
……. 2
,
……2 3
int
……4 7
common
……8 >
)
……> ?
{
   	
if
ÀÀ 
(
ÀÀ 
wing
ÀÀ 
.
ÀÀ 
previous
ÀÀ 
.
ÀÀ 
edge
ÀÀ "
.
ÀÀ" #
common
ÀÀ# )
.
ÀÀ) *
a
ÀÀ* +
==
ÀÀ, .
common
ÀÀ/ 5
)
ÀÀ5 6
return
ÃÃ 
new
ÃÃ 
Edge
ÃÃ 
(
ÃÃ  
wing
ÃÃ  $
.
ÃÃ$ %
previous
ÃÃ% -
.
ÃÃ- .
edge
ÃÃ. 2
.
ÃÃ2 3
local
ÃÃ3 8
.
ÃÃ8 9
b
ÃÃ9 :
,
ÃÃ: ;
wing
ÃÃ< @
.
ÃÃ@ A
previous
ÃÃA I
.
ÃÃI J
edge
ÃÃJ N
.
ÃÃN O
local
ÃÃO T
.
ÃÃT U
a
ÃÃU V
)
ÃÃV W
;
ÃÃW X
else
ÕÕ 
if
ÕÕ 
(
ÕÕ 
wing
ÕÕ 
.
ÕÕ 
previous
ÕÕ "
.
ÕÕ" #
edge
ÕÕ# '
.
ÕÕ' (
common
ÕÕ( .
.
ÕÕ. /
b
ÕÕ/ 0
==
ÕÕ1 3
common
ÕÕ4 :
)
ÕÕ: ;
return
ŒŒ 
new
ŒŒ 
Edge
ŒŒ 
(
ŒŒ  
wing
ŒŒ  $
.
ŒŒ$ %
previous
ŒŒ% -
.
ŒŒ- .
edge
ŒŒ. 2
.
ŒŒ2 3
local
ŒŒ3 8
.
ŒŒ8 9
a
ŒŒ9 :
,
ŒŒ: ;
wing
ŒŒ< @
.
ŒŒ@ A
previous
ŒŒA I
.
ŒŒI J
edge
ŒŒJ N
.
ŒŒN O
local
ŒŒO T
.
ŒŒT U
b
ŒŒU V
)
ŒŒV W
;
ŒŒW X
else
œœ 
if
œœ 
(
œœ 
wing
œœ 
.
œœ 
next
œœ 
.
œœ 
edge
œœ #
.
œœ# $
common
œœ$ *
.
œœ* +
a
œœ+ ,
==
œœ- /
common
œœ0 6
)
œœ6 7
return
–– 
new
–– 
Edge
–– 
(
––  
wing
––  $
.
––$ %
next
––% )
.
––) *
edge
––* .
.
––. /
local
––/ 4
.
––4 5
b
––5 6
,
––6 7
wing
––8 <
.
––< =
next
––= A
.
––A B
edge
––B F
.
––F G
local
––G L
.
––L M
a
––M N
)
––N O
;
––O P
else
—— 
if
—— 
(
—— 
wing
—— 
.
—— 
next
—— 
.
—— 
edge
—— #
.
——# $
common
——$ *
.
——* +
b
——+ ,
==
——- /
common
——0 6
)
——6 7
return
““ 
new
““ 
Edge
““ 
(
““  
wing
““  $
.
““$ %
next
““% )
.
““) *
edge
““* .
.
““. /
local
““/ 4
.
““4 5
a
““5 6
,
““6 7
wing
““8 <
.
““< =
next
““= A
.
““A B
edge
““B F
.
““F G
local
““G L
.
““L M
b
““M N
)
““N O
;
““O P
return
‘‘ 
Edge
‘‘ 
.
‘‘ 
Empty
‘‘ 
;
‘‘ 
}
’’ 	
}
÷÷ 
}◊◊ Õ≈
öD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\ConnectElements.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
sealed 

class "
ConnectFaceRebuildData '
{ 
public 
FaceRebuildData 
faceRebuildData .
;. /
public 
List 
< 
int 
> 
newVertexIndexes )
;) *
public "
ConnectFaceRebuildData %
(% &
FaceRebuildData& 5
faceRebuildData6 E
,E F
ListG K
<K L
intL O
>O P
newVertexIndexesQ a
)a b
{ 	
this 
. 
faceRebuildData  
=! "
faceRebuildData# 2
;2 3
this 
. 
newVertexIndexes !
=" #
newVertexIndexes$ 4
;4 5
} 	
} 
public 

static 
class 
ConnectElements '
{ 
public"" 
static"" 
Face"" 
["" 
]"" 
Connect"" $
(""$ %
this""% )
ProBuilderMesh""* 8
mesh""9 =
,""= >
IEnumerable""? J
<""J K
Face""K O
>""O P
faces""Q V
)""V W
{## 	
var$$ 
split$$ 
=$$ 
MeshValidation$$ &
.$$& '7
+EnsureFacesAreComposedOfContiguousTriangles$$' R
($$R S
mesh$$S W
,$$W X
faces$$Y ^
)$$^ _
;$$_ `
HashSet%% 
<%% 
Face%% 
>%% 
mask%% 
=%%  
new%%! $
HashSet%%% ,
<%%, -
Face%%- 1
>%%1 2
(%%2 3
faces%%3 8
)%%8 9
;%%9 :
if&& 
(&& 
split&& 
.&& 
Count&& 
>&& 
$num&& 
)&&  
{'' 
foreach(( 
((( 
var(( 
face(( !
in((" $
split((% *
)((* +
mask)) 
.)) 
Add)) 
()) 
face)) !
)))! "
;))" #
}** 
IEnumerable++ 
<++ 
Edge++ 
>++ 
edges++ #
=++$ %
mask++& *
.++* +

SelectMany+++ 5
(++5 6
x++6 7
=>++8 :
x++; <
.++< =
edgesInternal++= J
)++J K
;++K L
Edge,, 
[,, 
],, 
empty,, 
;,, 
Face-- 
[-- 
]-- 
res-- 
;-- 
Connect.. 
(.. 
mesh.. 
,.. 
edges.. 
,..  
out..! $
res..% (
,..( )
out..* -
empty... 3
,..3 4
true..5 9
,..9 :
false..; @
,..@ A
mask..B F
)..F G
;..G H
return// 
res// 
;// 
}00 	
public88 
static88 
SimpleTuple88 !
<88! "
Face88" &
[88& '
]88' (
,88( )
Edge88* .
[88. /
]88/ 0
>880 1
Connect882 9
(889 :
this88: >
ProBuilderMesh88? M
mesh88N R
,88R S
IEnumerable88T _
<88_ `
Edge88` d
>88d e
edges88f k
)88k l
{99 	
Edge:: 
[:: 
]:: 
empty:: 
;:: 
Face;; 
[;; 
];; 
faces;; 
;;; 
Connect<< 
(<< 
mesh<< 
,<< 
edges<< 
,<<  
out<<! $
faces<<% *
,<<* +
out<<, /
empty<<0 5
,<<5 6
true<<7 ;
,<<; <
true<<= A
)<<A B
;<<B C
return== 
new== 
SimpleTuple== "
<==" #
Face==# '
[==' (
]==( )
,==) *
Edge==+ /
[==/ 0
]==0 1
>==1 2
(==2 3
faces==3 8
,==8 9
empty==: ?
)==? @
;==@ A
}>> 	
publicFF 
staticFF 
intFF 
[FF 
]FF 
ConnectFF #
(FF# $
thisFF$ (
ProBuilderMeshFF) 7
meshFF8 <
,FF< =
IListFF> C
<FFC D
intFFD G
>FFG H
indexesFFI P
)FFP Q
{GG 	
ifHH 
(HH 
meshHH 
==HH 
nullHH 
)HH 
throwII 
newII !
ArgumentNullExceptionII /
(II/ 0
$strII0 6
)II6 7
;II7 8
ifKK 
(KK 
indexesKK 
==KK 
nullKK 
)KK  
throwLL 
newLL !
ArgumentNullExceptionLL /
(LL/ 0
$strLL0 9
)LL9 :
;LL: ;
intNN 
sharedIndexOffsetNN !
=NN" #
meshNN$ (
.NN( )"
sharedVerticesInternalNN) ?
.NN? @
LengthNN@ F
;NNF G

DictionaryOO 
<OO 
intOO 
,OO 
intOO 
>OO  
lookupOO! '
=OO( )
meshOO* .
.OO. /
sharedVertexLookupOO/ A
;OOA B
HashSetQQ 
<QQ 
intQQ 
>QQ 
distinctQQ !
=QQ" #
newQQ$ '
HashSetQQ( /
<QQ/ 0
intQQ0 3
>QQ3 4
(QQ4 5
indexesQQ5 <
.QQ< =
SelectQQ= C
(QQC D
xQQD E
=>QQF H
lookupQQI O
[QQO P
xQQP Q
]QQQ R
)QQR S
)QQS T
;QQT U
HashSetRR 
<RR 
intRR 
>RR 
affectedRR !
=RR" #
newRR$ '
HashSetRR( /
<RR/ 0
intRR0 3
>RR3 4
(RR4 5
)RR5 6
;RR6 7
foreachTT 
(TT 
intTT 
iTT 
inTT 
distinctTT &
)TT& '
affectedUU 
.UU 
	UnionWithUU "
(UU" #
meshUU# '
.UU' ("
sharedVerticesInternalUU( >
[UU> ?
iUU? @
]UU@ A
.UUA B
arrayInternalUUB O
)UUO P
;UUP Q

DictionaryWW 
<WW 
FaceWW 
,WW 
ListWW !
<WW! "
intWW" %
>WW% &
>WW& '
splitsWW( .
=WW/ 0
newWW1 4

DictionaryWW5 ?
<WW? @
FaceWW@ D
,WWD E
ListWWF J
<WWJ K
intWWK N
>WWN O
>WWO P
(WWP Q
)WWQ R
;WWR S
ListXX 
<XX 
VertexXX 
>XX 
verticesXX !
=XX" #
newXX$ '
ListXX( ,
<XX, -
VertexXX- 3
>XX3 4
(XX4 5
meshXX5 9
.XX9 :
GetVerticesXX: E
(XXE F
)XXF G
)XXG H
;XXH I
foreachZZ 
(ZZ 
FaceZZ 
faceZZ 
inZZ !
meshZZ" &
.ZZ& '
facesInternalZZ' 4
)ZZ4 5
{[[ 
int\\ 
[\\ 
]\\ 
f\\ 
=\\ 
face\\ 
.\\ #
distinctIndexesInternal\\ 6
;\\6 7
for^^ 
(^^ 
int^^ 
i^^ 
=^^ 
$num^^ 
;^^ 
i^^  !
<^^" #
f^^$ %
.^^% &
Length^^& ,
;^^, -
i^^. /
++^^/ 1
)^^1 2
{__ 
if`` 
(`` 
affected``  
.``  !
Contains``! )
(``) *
f``* +
[``+ ,
i``, -
]``- .
)``. /
)``/ 0
splitsaa 
.aa 
AddOrAppendaa *
(aa* +
faceaa+ /
,aa/ 0
faa1 2
[aa2 3
iaa3 4
]aa4 5
)aa5 6
;aa6 7
}bb 
}cc 
Listee 
<ee "
ConnectFaceRebuildDataee '
>ee' (
appendFacesee) 4
=ee5 6
newee7 :
Listee; ?
<ee? @"
ConnectFaceRebuildDataee@ V
>eeV W
(eeW X
)eeX Y
;eeY Z
Listff 
<ff 
Faceff 
>ff 
successfulSplitsff '
=ff( )
newff* -
Listff. 2
<ff2 3
Faceff3 7
>ff7 8
(ff8 9
)ff9 :
;ff: ;
HashSetgg 
<gg 
intgg 
>gg 
usedTextureGroupsgg *
=gg+ ,
newgg- 0
HashSetgg1 8
<gg8 9
intgg9 <
>gg< =
(gg= >
meshgg> B
.ggB C
facesInternalggC P
.ggP Q
SelectggQ W
(ggW X
xggX Y
=>ggZ \
xgg] ^
.gg^ _
textureGroupgg_ k
)ggk l
)ggl m
;ggm n
inthh  
newTextureGroupIndexhh $
=hh% &
$numhh' (
;hh( )
foreachjj 
(jj 
KeyValuePairjj !
<jj! "
Facejj" &
,jj& '
Listjj( ,
<jj, -
intjj- 0
>jj0 1
>jj1 2
splitjj3 8
injj9 ;
splitsjj< B
)jjB C
{kk 
Facell 
facell 
=ll 
splitll !
.ll! "
Keyll" %
;ll% &
Listnn 
<nn "
ConnectFaceRebuildDatann +
>nn+ ,
resnn- 0
=nn1 2
splitnn3 8
.nn8 9
Valuenn9 >
.nn> ?
Countnn? D
==nnE G
$numnnH I
?nnJ K!
ConnectIndexesPerFaceoo )
(oo) *
faceoo* .
,oo. /
splitoo0 5
.oo5 6
Valueoo6 ;
[oo; <
$numoo< =
]oo= >
,oo> ?
splitoo@ E
.ooE F
ValueooF K
[ooK L
$numooL M
]ooM N
,ooN O
verticesooP X
,ooX Y
lookupooZ `
)oo` a
:oob c!
ConnectIndexesPerFacepp )
(pp) *
facepp* .
,pp. /
splitpp0 5
.pp5 6
Valuepp6 ;
,pp; <
verticespp= E
,ppE F
lookupppG M
,ppM N
sharedIndexOffsetppO `
++pp` b
)ppb c
;ppc d
ifrr 
(rr 
resrr 
==rr 
nullrr 
)rr  
continuess 
;ss 
ifuu 
(uu 
faceuu 
.uu 
textureGroupuu %
<uu& '
$numuu( )
)uu) *
{vv 
whileww 
(ww 
usedTextureGroupsww ,
.ww, -
Containsww- 5
(ww5 6 
newTextureGroupIndexww6 J
)wwJ K
)wwK L 
newTextureGroupIndexxx ,
++xx, .
;xx. /
usedTextureGroupszz %
.zz% &
Addzz& )
(zz) * 
newTextureGroupIndexzz* >
)zz> ?
;zz? @
}{{ 
foreach}} 
(}} "
ConnectFaceRebuildData}} /
c}}0 1
in}}2 4
res}}5 8
)}}8 9
{~~ 
c 
. 
faceRebuildData %
.% &
face& *
.* +
textureGroup+ 7
=< =
face> B
.B C
textureGroupC O
<P Q
$numR S
?T U 
newTextureGroupIndexV j
:k l
facem q
.q r
textureGroupr ~
;~ 
c
ÄÄ 
.
ÄÄ 
faceRebuildData
ÄÄ %
.
ÄÄ% &
face
ÄÄ& *
.
ÄÄ* +
uv
ÄÄ+ -
=
ÄÄ< =
new
ÄÄ> A 
AutoUnwrapSettings
ÄÄB T
(
ÄÄT U
face
ÄÄU Y
.
ÄÄY Z
uv
ÄÄZ \
)
ÄÄ\ ]
;
ÄÄ] ^
c
ÅÅ 
.
ÅÅ 
faceRebuildData
ÅÅ %
.
ÅÅ% &
face
ÅÅ& *
.
ÅÅ* +
smoothingGroup
ÅÅ+ 9
=
ÅÅ< =
face
ÅÅ> B
.
ÅÅB C
smoothingGroup
ÅÅC Q
;
ÅÅQ R
c
ÇÇ 
.
ÇÇ 
faceRebuildData
ÇÇ %
.
ÇÇ% &
face
ÇÇ& *
.
ÇÇ* +
manualUV
ÇÇ+ 3
=
ÇÇ< =
face
ÇÇ> B
.
ÇÇB C
manualUV
ÇÇC K
;
ÇÇK L
c
ÉÉ 
.
ÉÉ 
faceRebuildData
ÉÉ %
.
ÉÉ% &
face
ÉÉ& *
.
ÉÉ* +
submeshIndex
ÉÉ+ 7
=
ÉÉ< =
face
ÉÉ> B
.
ÉÉB C
submeshIndex
ÉÉC O
;
ÉÉO P
}
ÑÑ 
successfulSplits
ÜÜ  
.
ÜÜ  !
Add
ÜÜ! $
(
ÜÜ$ %
face
ÜÜ% )
)
ÜÜ) *
;
ÜÜ* +
appendFaces
áá 
.
áá 
AddRange
áá $
(
áá$ %
res
áá% (
)
áá( )
;
áá) *
}
àà 
FaceRebuildData
ää 
.
ää 
Apply
ää !
(
ää! "
appendFaces
ää" -
.
ää- .
Select
ää. 4
(
ää4 5
x
ää5 6
=>
ää7 9
x
ää: ;
.
ää; <
faceRebuildData
ää< K
)
ääK L
,
ääL M
mesh
ääN R
,
ääR S
vertices
ääT \
,
ää\ ]
null
ää^ b
)
ääb c
;
ääc d
int
ãã  
removedVertexCount
ãã "
=
ãã# $
mesh
ãã% )
.
ãã) *
DeleteFaces
ãã* 5
(
ãã5 6
successfulSplits
ãã6 F
)
ããF G
.
ããG H
Length
ããH N
;
ããN O
lookup
åå 
=
åå 
mesh
åå 
.
åå  
sharedVertexLookup
åå ,
;
åå, -
HashSet
éé 
<
éé 
int
éé 
>
éé 
newVertexIndexes
éé )
=
éé* +
new
éé, /
HashSet
éé0 7
<
éé7 8
int
éé8 ;
>
éé; <
(
éé< =
)
éé= >
;
éé> ?
for
êê 
(
êê 
int
êê 
i
êê 
=
êê 
$num
êê 
;
êê 
i
êê 
<
êê 
appendFaces
êê  +
.
êê+ ,
Count
êê, 1
;
êê1 2
i
êê3 4
++
êê4 6
)
êê6 7
for
ëë 
(
ëë 
int
ëë 
n
ëë 
=
ëë 
$num
ëë 
;
ëë 
n
ëë  !
<
ëë" #
appendFaces
ëë$ /
[
ëë/ 0
i
ëë0 1
]
ëë1 2
.
ëë2 3
newVertexIndexes
ëë3 C
.
ëëC D
Count
ëëD I
;
ëëI J
n
ëëK L
++
ëëL N
)
ëëN O
newVertexIndexes
íí $
.
íí$ %
Add
íí% (
(
íí( )
lookup
íí) /
[
íí/ 0
appendFaces
íí0 ;
[
íí; <
i
íí< =
]
íí= >
.
íí> ?
newVertexIndexes
íí? O
[
ííO P
n
ííP Q
]
ííQ R
+
ííS T
(
ííU V
appendFaces
ííV a
[
íía b
i
ííb c
]
ííc d
.
ííd e
faceRebuildData
ííe t
.
íít u
Offset
ííu {
(
íí{ |
)
íí| }
-
íí~ "
removedVertexCountííÄ í
)ííí ì
]ííì î
)ííî ï
;ííï ñ
mesh
îî 
.
îî 
ToMesh
îî 
(
îî 
)
îî 
;
îî 
return
ññ 
newVertexIndexes
ññ #
.
ññ# $
Select
ññ$ *
(
ññ* +
x
ññ+ ,
=>
ññ- /
mesh
ññ0 4
.
ññ4 5$
sharedVerticesInternal
ññ5 K
[
ññK L
x
ññL M
]
ññM N
[
ññN O
$num
ññO P
]
ññP Q
)
ññQ R
.
ññR S
ToArray
ññS Z
(
ññZ [
)
ññ[ \
;
ññ\ ]
}
óó 	
internal
§§ 
static
§§ 
ActionResult
§§ $
Connect
§§% ,
(
§§, -
this
•• 
ProBuilderMesh
•• 
mesh
••  $
,
••$ %
IEnumerable
¶¶ 
<
¶¶ 
Edge
¶¶ 
>
¶¶ 
edges
¶¶ #
,
¶¶# $
out
ßß 
Face
ßß 
[
ßß 
]
ßß 

addedFaces
ßß !
,
ßß! "
out
®® 
Edge
®® 
[
®® 
]
®® 
connections
®® "
,
®®" #
bool
©© 
returnFaces
©© 
=
©© 
false
©© $
,
©©$ %
bool
™™ 
returnEdges
™™ 
=
™™ 
false
™™ $
,
™™$ %
HashSet
´´ 
<
´´ 
Face
´´ 
>
´´ 
faceMask
´´ "
=
´´# $
null
´´% )
)
´´) *
{
¨¨ 	

Dictionary
≠≠ 
<
≠≠ 
int
≠≠ 
,
≠≠ 
int
≠≠ 
>
≠≠  
lookup
≠≠! '
=
≠≠( )
mesh
≠≠* .
.
≠≠. / 
sharedVertexLookup
≠≠/ A
;
≠≠A B

Dictionary
ÆÆ 
<
ÆÆ 
int
ÆÆ 
,
ÆÆ 
int
ÆÆ 
>
ÆÆ  
lookupUV
ÆÆ! )
=
ÆÆ* +
mesh
ÆÆ, 0
.
ÆÆ0 1!
sharedTextureLookup
ÆÆ1 D
;
ÆÆD E
HashSet
ØØ 
<
ØØ 

EdgeLookup
ØØ 
>
ØØ 
distinctEdges
ØØ  -
=
ØØ. /
new
ØØ0 3
HashSet
ØØ4 ;
<
ØØ; <

EdgeLookup
ØØ< F
>
ØØF G
(
ØØG H

EdgeLookup
ØØH R
.
ØØR S
GetEdgeLookup
ØØS `
(
ØØ` a
edges
ØØa f
,
ØØf g
lookup
ØØh n
)
ØØn o
)
ØØo p
;
ØØp q
List
∞∞ 
<
∞∞ 

WingedEdge
∞∞ 
>
∞∞ 
wings
∞∞ "
=
∞∞# $

WingedEdge
∞∞% /
.
∞∞/ 0
GetWingedEdges
∞∞0 >
(
∞∞> ?
mesh
∞∞? C
)
∞∞C D
;
∞∞D E

Dictionary
≥≥ 
<
≥≥ 
Face
≥≥ 
,
≥≥ 
List
≥≥ !
<
≥≥! "

WingedEdge
≥≥" ,
>
≥≥, -
>
≥≥- .
touched
≥≥/ 6
=
≥≥7 8
new
≥≥9 <

Dictionary
≥≥= G
<
≥≥G H
Face
≥≥H L
,
≥≥L M
List
≥≥N R
<
≥≥R S

WingedEdge
≥≥S ]
>
≥≥] ^
>
≥≥^ _
(
≥≥_ `
)
≥≥` a
;
≥≥a b
foreach
µµ 
(
µµ 

WingedEdge
µµ 
wing
µµ  $
in
µµ% '
wings
µµ( -
)
µµ- .
{
∂∂ 
if
∑∑ 
(
∑∑ 
distinctEdges
∑∑ !
.
∑∑! "
Contains
∑∑" *
(
∑∑* +
wing
∑∑+ /
.
∑∑/ 0
edge
∑∑0 4
)
∑∑4 5
)
∑∑5 6
{
∏∏ 
List
ππ 
<
ππ 

WingedEdge
ππ #
>
ππ# $
	faceEdges
ππ% .
;
ππ. /
if
∫∫ 
(
∫∫ 
touched
∫∫ 
.
∫∫  
TryGetValue
∫∫  +
(
∫∫+ ,
wing
∫∫, 0
.
∫∫0 1
face
∫∫1 5
,
∫∫5 6
out
∫∫7 :
	faceEdges
∫∫; D
)
∫∫D E
)
∫∫E F
	faceEdges
ªª !
.
ªª! "
Add
ªª" %
(
ªª% &
wing
ªª& *
)
ªª* +
;
ªª+ ,
else
ºº 
touched
ΩΩ 
.
ΩΩ  
Add
ΩΩ  #
(
ΩΩ# $
wing
ΩΩ$ (
.
ΩΩ( )
face
ΩΩ) -
,
ΩΩ- .
new
ΩΩ/ 2
List
ΩΩ3 7
<
ΩΩ7 8

WingedEdge
ΩΩ8 B
>
ΩΩB C
(
ΩΩC D
)
ΩΩD E
{
ΩΩF G
wing
ΩΩH L
}
ΩΩM N
)
ΩΩN O
;
ΩΩO P
}
ææ 
}
øø 

Dictionary
¡¡ 
<
¡¡ 
Face
¡¡ 
,
¡¡ 
List
¡¡ !
<
¡¡! "

WingedEdge
¡¡" ,
>
¡¡, -
>
¡¡- .
affected
¡¡/ 7
=
¡¡8 9
new
¡¡: =

Dictionary
¡¡> H
<
¡¡H I
Face
¡¡I M
,
¡¡M N
List
¡¡O S
<
¡¡S T

WingedEdge
¡¡T ^
>
¡¡^ _
>
¡¡_ `
(
¡¡` a
)
¡¡a b
;
¡¡b c
foreach
ƒƒ 
(
ƒƒ 
KeyValuePair
ƒƒ !
<
ƒƒ! "
Face
ƒƒ" &
,
ƒƒ& '
List
ƒƒ( ,
<
ƒƒ, -

WingedEdge
ƒƒ- 7
>
ƒƒ7 8
>
ƒƒ8 9
kvp
ƒƒ: =
in
ƒƒ> @
touched
ƒƒA H
)
ƒƒH I
{
≈≈ 
if
∆∆ 
(
∆∆ 
kvp
∆∆ 
.
∆∆ 
Value
∆∆ 
.
∆∆ 
Count
∆∆ #
<=
∆∆$ &
$num
∆∆' (
)
∆∆( )
{
«« 

WingedEdge
»» 
opp
»» "
=
»»# $
kvp
»»% (
.
»»( )
Value
»») .
[
»». /
$num
»»/ 0
]
»»0 1
.
»»1 2
opposite
»»2 :
;
»»: ;
if
   
(
   
opp
   
==
   
null
   #
)
  # $
continue
ÀÀ  
;
ÀÀ  !
List
ÕÕ 
<
ÕÕ 

WingedEdge
ÕÕ #
>
ÕÕ# $
opp_list
ÕÕ% -
;
ÕÕ- .
if
œœ 
(
œœ 
!
œœ 
touched
œœ  
.
œœ  !
TryGetValue
œœ! ,
(
œœ, -
opp
œœ- 0
.
œœ0 1
face
œœ1 5
,
œœ5 6
out
œœ7 :
opp_list
œœ; C
)
œœC D
)
œœD E
continue
––  
;
––  !
if
““ 
(
““ 
opp_list
““  
.
““  !
Count
““! &
<=
““' )
$num
““* +
)
““+ ,
continue
””  
;
””  !
}
‘‘ 
affected
÷÷ 
.
÷÷ 
Add
÷÷ 
(
÷÷ 
kvp
÷÷  
.
÷÷  !
Key
÷÷! $
,
÷÷$ %
kvp
÷÷& )
.
÷÷) *
Value
÷÷* /
)
÷÷/ 0
;
÷÷0 1
}
◊◊ 
List
ŸŸ 
<
ŸŸ 
Vertex
ŸŸ 
>
ŸŸ 
vertices
ŸŸ !
=
ŸŸ" #
new
ŸŸ$ '
List
ŸŸ( ,
<
ŸŸ, -
Vertex
ŸŸ- 3
>
ŸŸ3 4
(
ŸŸ4 5
mesh
ŸŸ5 9
.
ŸŸ9 :
GetVertices
ŸŸ: E
(
ŸŸE F
)
ŸŸF G
)
ŸŸG H
;
ŸŸH I
List
⁄⁄ 
<
⁄⁄ $
ConnectFaceRebuildData
⁄⁄ '
>
⁄⁄' (
results
⁄⁄) 0
=
⁄⁄1 2
new
⁄⁄3 6
List
⁄⁄7 ;
<
⁄⁄; <$
ConnectFaceRebuildData
⁄⁄< R
>
⁄⁄R S
(
⁄⁄S T
)
⁄⁄T U
;
⁄⁄U V
List
‹‹ 
<
‹‹ 
Face
‹‹ 
>
‹‹ 
connectedFaces
‹‹ %
=
‹‹& '
new
‹‹( +
List
‹‹, 0
<
‹‹0 1
Face
‹‹1 5
>
‹‹5 6
(
‹‹6 7
)
‹‹7 8
;
‹‹8 9
HashSet
ﬁﬁ 
<
ﬁﬁ 
int
ﬁﬁ 
>
ﬁﬁ 
usedTextureGroups
ﬁﬁ *
=
ﬁﬁ+ ,
new
ﬁﬁ- 0
HashSet
ﬁﬁ1 8
<
ﬁﬁ8 9
int
ﬁﬁ9 <
>
ﬁﬁ< =
(
ﬁﬁ= >
mesh
ﬁﬁ> B
.
ﬁﬁB C
facesInternal
ﬁﬁC P
.
ﬁﬁP Q
Select
ﬁﬁQ W
(
ﬁﬁW X
x
ﬁﬁX Y
=>
ﬁﬁZ \
x
ﬁﬁ] ^
.
ﬁﬁ^ _
textureGroup
ﬁﬁ_ k
)
ﬁﬁk l
)
ﬁﬁl m
;
ﬁﬁm n
int
ﬂﬂ "
newTextureGroupIndex
ﬂﬂ $
=
ﬂﬂ% &
$num
ﬂﬂ' (
;
ﬂﬂ( )
foreach
‚‚ 
(
‚‚ 
KeyValuePair
‚‚ !
<
‚‚! "
Face
‚‚" &
,
‚‚& '
List
‚‚( ,
<
‚‚, -

WingedEdge
‚‚- 7
>
‚‚7 8
>
‚‚8 9
split
‚‚: ?
in
‚‚@ B
affected
‚‚C K
)
‚‚K L
{
„„ 
Face
‰‰ 
face
‰‰ 
=
‰‰ 
split
‰‰ !
.
‰‰! "
Key
‰‰" %
;
‰‰% &
List
ÂÂ 
<
ÂÂ 

WingedEdge
ÂÂ 
>
ÂÂ  
targetEdges
ÂÂ! ,
=
ÂÂ- .
split
ÂÂ/ 4
.
ÂÂ4 5
Value
ÂÂ5 :
;
ÂÂ: ;
int
ÊÊ 
inserts
ÊÊ 
=
ÊÊ 
targetEdges
ÊÊ )
.
ÊÊ) *
Count
ÊÊ* /
;
ÊÊ/ 0
Vector3
ÁÁ 
nrm
ÁÁ 
=
ÁÁ 
Math
ÁÁ "
.
ÁÁ" #
Normal
ÁÁ# )
(
ÁÁ) *
vertices
ÁÁ* 2
,
ÁÁ2 3
face
ÁÁ4 8
.
ÁÁ8 9
indexesInternal
ÁÁ9 H
)
ÁÁH I
;
ÁÁI J
if
ÈÈ 
(
ÈÈ 
inserts
ÈÈ 
==
ÈÈ 
$num
ÈÈ  
||
ÈÈ! #
(
ÈÈ$ %
faceMask
ÈÈ% -
!=
ÈÈ. 0
null
ÈÈ1 5
&&
ÈÈ6 8
!
ÈÈ9 :
faceMask
ÈÈ: B
.
ÈÈB C
Contains
ÈÈC K
(
ÈÈK L
face
ÈÈL P
)
ÈÈP Q
)
ÈÈQ R
)
ÈÈR S
{
ÍÍ $
ConnectFaceRebuildData
ÎÎ *
c
ÎÎ+ ,
;
ÎÎ, -
if
ÌÌ 
(
ÌÌ 
InsertVertices
ÌÌ &
(
ÌÌ& '
face
ÌÌ' +
,
ÌÌ+ ,
targetEdges
ÌÌ- 8
,
ÌÌ8 9
vertices
ÌÌ: B
,
ÌÌB C
out
ÌÌD G
c
ÌÌH I
)
ÌÌI J
)
ÌÌJ K
{
ÓÓ 
Vector3
ÔÔ 
fn
ÔÔ  "
=
ÔÔ# $
Math
ÔÔ% )
.
ÔÔ) *
Normal
ÔÔ* 0
(
ÔÔ0 1
c
ÔÔ1 2
.
ÔÔ2 3
faceRebuildData
ÔÔ3 B
.
ÔÔB C
vertices
ÔÔC K
,
ÔÔK L
c
ÔÔM N
.
ÔÔN O
faceRebuildData
ÔÔO ^
.
ÔÔ^ _
face
ÔÔ_ c
.
ÔÔc d
indexesInternal
ÔÔd s
)
ÔÔs t
;
ÔÔt u
if
ÒÒ 
(
ÒÒ 
Vector3
ÒÒ #
.
ÒÒ# $
Dot
ÒÒ$ '
(
ÒÒ' (
nrm
ÒÒ( +
,
ÒÒ+ ,
fn
ÒÒ- /
)
ÒÒ/ 0
<
ÒÒ1 2
$num
ÒÒ3 4
)
ÒÒ4 5
c
ÚÚ 
.
ÚÚ 
faceRebuildData
ÚÚ -
.
ÚÚ- .
face
ÚÚ. 2
.
ÚÚ2 3
Reverse
ÚÚ3 :
(
ÚÚ: ;
)
ÚÚ; <
;
ÚÚ< =
results
ÙÙ 
.
ÙÙ  
Add
ÙÙ  #
(
ÙÙ# $
c
ÙÙ$ %
)
ÙÙ% &
;
ÙÙ& '
}
ıı 
}
ˆˆ 
else
˜˜ 
if
˜˜ 
(
˜˜ 
inserts
˜˜  
>
˜˜! "
$num
˜˜# $
)
˜˜$ %
{
¯¯ 
List
˘˘ 
<
˘˘ $
ConnectFaceRebuildData
˘˘ /
>
˘˘/ 0
res
˘˘1 4
=
˘˘5 6
inserts
˘˘7 >
==
˘˘? A
$num
˘˘B C
?
˘˘D E 
ConnectEdgesInFace
˙˙ *
(
˙˙* +
face
˙˙+ /
,
˙˙/ 0
targetEdges
˙˙1 <
[
˙˙< =
$num
˙˙= >
]
˙˙> ?
,
˙˙? @
targetEdges
˙˙A L
[
˙˙L M
$num
˙˙M N
]
˙˙N O
,
˙˙O P
vertices
˙˙Q Y
)
˙˙Y Z
:
˙˙[ \ 
ConnectEdgesInFace
˚˚ *
(
˚˚* +
face
˚˚+ /
,
˚˚/ 0
targetEdges
˚˚1 <
,
˚˚< =
vertices
˚˚> F
)
˚˚F G
;
˚˚G H
if
˝˝ 
(
˝˝ 
face
˝˝ 
.
˝˝ 
textureGroup
˝˝ )
<
˝˝* +
$num
˝˝, -
)
˝˝- .
{
˛˛ 
while
ˇˇ 
(
ˇˇ 
usedTextureGroups
ˇˇ 0
.
ˇˇ0 1
Contains
ˇˇ1 9
(
ˇˇ9 :"
newTextureGroupIndex
ˇˇ: N
)
ˇˇN O
)
ˇˇO P"
newTextureGroupIndex
ÄÄ 0
++
ÄÄ0 2
;
ÄÄ2 3
usedTextureGroups
ÇÇ )
.
ÇÇ) *
Add
ÇÇ* -
(
ÇÇ- ."
newTextureGroupIndex
ÇÇ. B
)
ÇÇB C
;
ÇÇC D
}
ÉÉ 
if
ÜÜ 
(
ÜÜ 
res
ÜÜ 
==
ÜÜ 
null
ÜÜ #
)
ÜÜ# $
{
áá 
connections
àà #
=
àà$ %
null
àà& *
;
àà* +

addedFaces
ââ "
=
ââ# $
null
ââ% )
;
ââ) *
return
ää 
new
ää "
ActionResult
ää# /
(
ää/ 0
ActionResult
ää0 <
.
ää< =
Status
ää= C
.
ääC D
Failure
ääD K
,
ääK L
$str
ääM f
)
ääf g
;
ääg h
}
ãã 
else
åå 
{
çç 
foreach
éé 
(
éé  !$
ConnectFaceRebuildData
éé! 7
c
éé8 9
in
éé: <
res
éé= @
)
éé@ A
{
èè 
connectedFaces
êê *
.
êê* +
Add
êê+ .
(
êê. /
c
êê/ 0
.
êê0 1
faceRebuildData
êê1 @
.
êê@ A
face
êêA E
)
êêE F
;
êêF G
Vector3
íí #
fn
íí$ &
=
íí' (
Math
íí) -
.
íí- .
Normal
íí. 4
(
íí4 5
c
íí5 6
.
íí6 7
faceRebuildData
íí7 F
.
ííF G
vertices
ííG O
,
ííO P
c
ìì  !
.
ìì! "
faceRebuildData
ìì" 1
.
ìì1 2
face
ìì2 6
.
ìì6 7
indexesInternal
ìì7 F
)
ììF G
;
ììG H
if
ïï 
(
ïï  
Vector3
ïï  '
.
ïï' (
Dot
ïï( +
(
ïï+ ,
nrm
ïï, /
,
ïï/ 0
fn
ïï1 3
)
ïï3 4
<
ïï5 6
$num
ïï7 8
)
ïï8 9
c
ññ  !
.
ññ! "
faceRebuildData
ññ" 1
.
ññ1 2
face
ññ2 6
.
ññ6 7
Reverse
ññ7 >
(
ññ> ?
)
ññ? @
;
ññ@ A
c
òò 
.
òò 
faceRebuildData
òò -
.
òò- .
face
òò. 2
.
òò2 3
textureGroup
òò3 ?
=
òò@ A
face
ôô  $
.
ôô$ %
textureGroup
ôô% 1
<
ôô2 3
$num
ôô4 5
?
ôô6 7"
newTextureGroupIndex
ôô8 L
:
ôôM N
face
ôôO S
.
ôôS T
textureGroup
ôôT `
;
ôô` a
c
öö 
.
öö 
faceRebuildData
öö -
.
öö- .
face
öö. 2
.
öö2 3
uv
öö3 5
=
öö6 7
new
öö8 ; 
AutoUnwrapSettings
öö< N
(
ööN O
face
ööO S
.
ööS T
uv
ööT V
)
ööV W
;
ööW X
c
õõ 
.
õõ 
faceRebuildData
õõ -
.
õõ- .
face
õõ. 2
.
õõ2 3
submeshIndex
õõ3 ?
=
õõ@ A
face
õõB F
.
õõF G
submeshIndex
õõG S
;
õõS T
c
úú 
.
úú 
faceRebuildData
úú -
.
úú- .
face
úú. 2
.
úú2 3
smoothingGroup
úú3 A
=
úúB C
face
úúD H
.
úúH I
smoothingGroup
úúI W
;
úúW X
c
ùù 
.
ùù 
faceRebuildData
ùù -
.
ùù- .
face
ùù. 2
.
ùù2 3
manualUV
ùù3 ;
=
ùù< =
face
ùù> B
.
ùùB C
manualUV
ùùC K
;
ùùK L
}
ûû 
results
†† 
.
††  
AddRange
††  (
(
††( )
res
††) ,
)
††, -
;
††- .
}
°° 
}
¢¢ 
}
££ 
FaceRebuildData
•• 
.
•• 
Apply
•• !
(
••! "
results
••" )
.
••) *
Select
••* 0
(
••0 1
x
••1 2
=>
••3 5
x
••6 7
.
••7 8
faceRebuildData
••8 G
)
••G H
,
••H I
mesh
••J N
,
••N O
vertices
••P X
,
••X Y
null
••Z ^
)
••^ _
;
••_ `
mesh
ßß 
.
ßß 
sharedTextures
ßß 
=
ßß  !
new
ßß" %
SharedVertex
ßß& 2
[
ßß2 3
$num
ßß3 4
]
ßß4 5
;
ßß5 6
int
®®  
removedVertexCount
®® "
=
®®# $
mesh
®®% )
.
®®) *
DeleteFaces
®®* 5
(
®®5 6
affected
®®6 >
.
®®> ?
Keys
®®? C
)
®®C D
.
®®D E
Length
®®E K
;
®®K L
mesh
©© 
.
©© 
sharedVertices
©© 
=
©©  !
SharedVertex
©©" .
.
©©. /,
GetSharedVerticesWithPositions
©©/ M
(
©©M N
mesh
©©N R
.
©©R S
positionsInternal
©©S d
)
©©d e
;
©©e f
mesh
™™ 
.
™™ 
ToMesh
™™ 
(
™™ 
)
™™ 
;
™™ 
if
≠≠ 
(
≠≠ 
returnEdges
≠≠ 
)
≠≠ 
{
ÆÆ 
var
∞∞ 
appended
∞∞ 
=
∞∞ 
new
∞∞ "
HashSet
∞∞# *
<
∞∞* +
int
∞∞+ .
>
∞∞. /
(
∞∞/ 0
)
∞∞0 1
;
∞∞1 2
for
≤≤ 
(
≤≤ 
int
≤≤ 
n
≤≤ 
=
≤≤ 
$num
≤≤ 
;
≤≤ 
n
≤≤  !
<
≤≤" #
results
≤≤$ +
.
≤≤+ ,
Count
≤≤, 1
;
≤≤1 2
n
≤≤3 4
++
≤≤4 6
)
≤≤6 7
for
≥≥ 
(
≥≥ 
int
≥≥ 
i
≥≥ 
=
≥≥  
$num
≥≥! "
;
≥≥" #
i
≥≥$ %
<
≥≥& '
results
≥≥( /
[
≥≥/ 0
n
≥≥0 1
]
≥≥1 2
.
≥≥2 3
newVertexIndexes
≥≥3 C
.
≥≥C D
Count
≥≥D I
;
≥≥I J
i
≥≥K L
++
≥≥L N
)
≥≥N O
appended
¥¥  
.
¥¥  !
Add
¥¥! $
(
¥¥$ %
(
¥¥% &
results
¥¥& -
[
¥¥- .
n
¥¥. /
]
¥¥/ 0
.
¥¥0 1
newVertexIndexes
¥¥1 A
[
¥¥A B
i
¥¥B C
]
¥¥C D
+
¥¥E F
results
¥¥G N
[
¥¥N O
n
¥¥O P
]
¥¥P Q
.
¥¥Q R
faceRebuildData
¥¥R a
.
¥¥a b
Offset
¥¥b h
(
¥¥h i
)
¥¥i j
)
¥¥j k
-
¥¥l m!
removedVertexCount¥¥n Ä
)¥¥Ä Å
;¥¥Å Ç

Dictionary
∂∂ 
<
∂∂ 
int
∂∂ 
,
∂∂ 
int
∂∂  #
>
∂∂# $
lup
∂∂% (
=
∂∂) *
mesh
∂∂+ /
.
∂∂/ 0 
sharedVertexLookup
∂∂0 B
;
∂∂B C
IEnumerable
∑∑ 
<
∑∑ 
Edge
∑∑  
>
∑∑  !
newEdges
∑∑" *
=
∑∑+ ,
results
∑∑- 4
.
∑∑4 5

SelectMany
∑∑5 ?
(
∑∑? @
x
∑∑@ A
=>
∑∑B D
x
∑∑E F
.
∑∑F G
faceRebuildData
∑∑G V
.
∑∑V W
face
∑∑W [
.
∑∑[ \
edgesInternal
∑∑\ i
)
∑∑i j
.
∑∑j k
Where
∑∑k p
(
∑∑p q
x
∑∑q r
=>
∑∑s u
appended
∑∑v ~
.
∑∑~ 
Contains∑∑ á
(∑∑á à
x∑∑à â
.∑∑â ä
a∑∑ä ã
)∑∑ã å
&&∑∑ç è
appended∑∑ê ò
.∑∑ò ô
Contains∑∑ô °
(∑∑° ¢
x∑∑¢ £
.∑∑£ §
b∑∑§ •
)∑∑• ¶
)∑∑¶ ß
;∑∑ß ®
IEnumerable
∏∏ 
<
∏∏ 

EdgeLookup
∏∏ &
>
∏∏& '
distNewEdges
∏∏( 4
=
∏∏5 6

EdgeLookup
∏∏7 A
.
∏∏A B
GetEdgeLookup
∏∏B O
(
∏∏O P
newEdges
∏∏P X
,
∏∏X Y
lup
∏∏Z ]
)
∏∏] ^
;
∏∏^ _
connections
∫∫ 
=
∫∫ 
distNewEdges
∫∫ *
.
∫∫* +
Distinct
∫∫+ 3
(
∫∫3 4
)
∫∫4 5
.
∫∫5 6
Select
∫∫6 <
(
∫∫< =
x
∫∫= >
=>
∫∫? A
x
∫∫B C
.
∫∫C D
local
∫∫D I
)
∫∫I J
.
∫∫J K
ToArray
∫∫K R
(
∫∫R S
)
∫∫S T
;
∫∫T U
}
ªª 
else
ºº 
{
ΩΩ 
connections
ææ 
=
ææ 
null
ææ "
;
ææ" #
}
øø 
if
¡¡ 
(
¡¡ 
returnFaces
¡¡ 
)
¡¡ 

addedFaces
¬¬ 
=
¬¬ 
connectedFaces
¬¬ +
.
¬¬+ ,
ToArray
¬¬, 3
(
¬¬3 4
)
¬¬4 5
;
¬¬5 6
else
√√ 

addedFaces
ƒƒ 
=
ƒƒ 
null
ƒƒ !
;
ƒƒ! "
return
∆∆ 
new
∆∆ 
ActionResult
∆∆ #
(
∆∆# $
ActionResult
∆∆$ 0
.
∆∆0 1
Status
∆∆1 7
.
∆∆7 8
Success
∆∆8 ?
,
∆∆? @
string
∆∆A G
.
∆∆G H
Format
∆∆H N
(
∆∆N O
$str
∆∆O d
,
∆∆d e
results
∆∆f m
.
∆∆m n
Count
∆∆n s
/
∆∆t u
$num
∆∆v w
)
∆∆w x
)
∆∆x y
;
∆∆y z
}
«« 	
static
—— 
List
—— 
<
—— $
ConnectFaceRebuildData
—— *
>
——* + 
ConnectEdgesInFace
——, >
(
——> ?
Face
““ 
face
““ 
,
““ 

WingedEdge
”” 
a
”” 
,
”” 

WingedEdge
‘‘ 
b
‘‘ 
,
‘‘ 
List
’’ 
<
’’ 
Vertex
’’ 
>
’’ 
vertices
’’ !
)
’’! "
{
÷÷ 	
List
◊◊ 
<
◊◊ 
Edge
◊◊ 
>
◊◊ 
	perimeter
◊◊  
=
◊◊! "

WingedEdge
◊◊# -
.
◊◊- ."
SortEdgesByAdjacency
◊◊. B
(
◊◊B C
face
◊◊C G
)
◊◊G H
;
◊◊H I
List
ŸŸ 
<
ŸŸ 
Vertex
ŸŸ 
>
ŸŸ 
[
ŸŸ 
]
ŸŸ 

n_vertices
ŸŸ %
=
ŸŸ& '
new
ŸŸ( +
List
ŸŸ, 0
<
ŸŸ0 1
Vertex
ŸŸ1 7
>
ŸŸ7 8
[
ŸŸ8 9
$num
ŸŸ9 :
]
ŸŸ: ;
{
⁄⁄ 
new
€€ 
List
€€ 
<
€€ 
Vertex
€€ 
>
€€  
(
€€  !
)
€€! "
,
€€" #
new
‹‹ 
List
‹‹ 
<
‹‹ 
Vertex
‹‹ 
>
‹‹  
(
‹‹  !
)
‹‹! "
}
›› 
;
›› 
List
ﬂﬂ 
<
ﬂﬂ 
int
ﬂﬂ 
>
ﬂﬂ 
[
ﬂﬂ 
]
ﬂﬂ 
	n_indexes
ﬂﬂ !
=
ﬂﬂ" #
new
ﬂﬂ$ '
List
ﬂﬂ( ,
<
ﬂﬂ, -
int
ﬂﬂ- 0
>
ﬂﬂ0 1
[
ﬂﬂ1 2
$num
ﬂﬂ2 3
]
ﬂﬂ3 4
{
‡‡ 
new
·· 
List
·· 
<
·· 
int
·· 
>
·· 
(
·· 
)
·· 
,
··  
new
‚‚ 
List
‚‚ 
<
‚‚ 
int
‚‚ 
>
‚‚ 
(
‚‚ 
)
‚‚ 
}
„„ 
;
„„ 
int
ÂÂ 
index
ÂÂ 
=
ÂÂ 
$num
ÂÂ 
;
ÂÂ 
for
ËË 
(
ËË 
int
ËË 
i
ËË 
=
ËË 
$num
ËË 
;
ËË 
i
ËË 
<
ËË 
	perimeter
ËË  )
.
ËË) *
Count
ËË* /
;
ËË/ 0
i
ËË1 2
++
ËË2 4
)
ËË4 5
{
ÈÈ 

n_vertices
ÍÍ 
[
ÍÍ 
index
ÍÍ  
%
ÍÍ! "
$num
ÍÍ# $
]
ÍÍ$ %
.
ÍÍ% &
Add
ÍÍ& )
(
ÍÍ) *
vertices
ÍÍ* 2
[
ÍÍ2 3
	perimeter
ÍÍ3 <
[
ÍÍ< =
i
ÍÍ= >
]
ÍÍ> ?
.
ÍÍ? @
a
ÍÍ@ A
]
ÍÍA B
)
ÍÍB C
;
ÍÍC D
if
ÏÏ 
(
ÏÏ 
	perimeter
ÏÏ 
[
ÏÏ 
i
ÏÏ 
]
ÏÏ  
.
ÏÏ  !
Equals
ÏÏ! '
(
ÏÏ' (
a
ÏÏ( )
.
ÏÏ) *
edge
ÏÏ* .
.
ÏÏ. /
local
ÏÏ/ 4
)
ÏÏ4 5
||
ÏÏ6 8
	perimeter
ÏÏ9 B
[
ÏÏB C
i
ÏÏC D
]
ÏÏD E
.
ÏÏE F
Equals
ÏÏF L
(
ÏÏL M
b
ÏÏM N
.
ÏÏN O
edge
ÏÏO S
.
ÏÏS T
local
ÏÏT Y
)
ÏÏY Z
)
ÏÏZ [
{
ÌÌ 
Vertex
ÓÓ 
mix
ÓÓ 
=
ÓÓ  
Vertex
ÓÓ! '
.
ÓÓ' (
Mix
ÓÓ( +
(
ÓÓ+ ,
vertices
ÓÓ, 4
[
ÓÓ4 5
	perimeter
ÓÓ5 >
[
ÓÓ> ?
i
ÓÓ? @
]
ÓÓ@ A
.
ÓÓA B
a
ÓÓB C
]
ÓÓC D
,
ÓÓD E
vertices
ÓÓF N
[
ÓÓN O
	perimeter
ÓÓO X
[
ÓÓX Y
i
ÓÓY Z
]
ÓÓZ [
.
ÓÓ[ \
b
ÓÓ\ ]
]
ÓÓ] ^
,
ÓÓ^ _
$num
ÓÓ` c
)
ÓÓc d
;
ÓÓd e
	n_indexes
 
[
 
index
 #
%
$ %
$num
& '
]
' (
.
( )
Add
) ,
(
, -

n_vertices
- 7
[
7 8
index
8 =
%
> ?
$num
@ A
]
A B
.
B C
Count
C H
)
H I
;
I J

n_vertices
ÒÒ 
[
ÒÒ 
index
ÒÒ $
%
ÒÒ% &
$num
ÒÒ' (
]
ÒÒ( )
.
ÒÒ) *
Add
ÒÒ* -
(
ÒÒ- .
mix
ÒÒ. 1
)
ÒÒ1 2
;
ÒÒ2 3
index
ÚÚ 
++
ÚÚ 
;
ÚÚ 
	n_indexes
ÛÛ 
[
ÛÛ 
index
ÛÛ #
%
ÛÛ$ %
$num
ÛÛ& '
]
ÛÛ' (
.
ÛÛ( )
Add
ÛÛ) ,
(
ÛÛ, -

n_vertices
ÛÛ- 7
[
ÛÛ7 8
index
ÛÛ8 =
%
ÛÛ> ?
$num
ÛÛ@ A
]
ÛÛA B
.
ÛÛB C
Count
ÛÛC H
)
ÛÛH I
;
ÛÛI J

n_vertices
ÙÙ 
[
ÙÙ 
index
ÙÙ $
%
ÙÙ% &
$num
ÙÙ' (
]
ÙÙ( )
.
ÙÙ) *
Add
ÙÙ* -
(
ÙÙ- .
mix
ÙÙ. 1
)
ÙÙ1 2
;
ÙÙ2 3
}
ıı 
}
ˆˆ 
List
¯¯ 
<
¯¯ $
ConnectFaceRebuildData
¯¯ '
>
¯¯' (
faces
¯¯) .
=
¯¯/ 0
new
¯¯1 4
List
¯¯5 9
<
¯¯9 :$
ConnectFaceRebuildData
¯¯: P
>
¯¯P Q
(
¯¯Q R
)
¯¯R S
;
¯¯S T
for
˙˙ 
(
˙˙ 
int
˙˙ 
i
˙˙ 
=
˙˙ 
$num
˙˙ 
;
˙˙ 
i
˙˙ 
<
˙˙ 

n_vertices
˙˙  *
.
˙˙* +
Length
˙˙+ 1
;
˙˙1 2
i
˙˙3 4
++
˙˙4 6
)
˙˙6 7
{
˚˚ 
FaceRebuildData
¸¸ 
f
¸¸  !
=
¸¸" #
AppendElements
¸¸$ 2
.
¸¸2 3
FaceWithVertices
¸¸3 C
(
¸¸C D

n_vertices
¸¸D N
[
¸¸N O
i
¸¸O P
]
¸¸P Q
,
¸¸Q R
false
¸¸S X
)
¸¸X Y
;
¸¸Y Z
faces
˝˝ 
.
˝˝ 
Add
˝˝ 
(
˝˝ 
new
˝˝ $
ConnectFaceRebuildData
˝˝ 4
(
˝˝4 5
f
˝˝5 6
,
˝˝6 7
	n_indexes
˝˝8 A
[
˝˝A B
i
˝˝B C
]
˝˝C D
)
˝˝D E
)
˝˝E F
;
˝˝F G
}
˛˛ 
return
ÄÄ 
faces
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
static
ää 
List
ää 
<
ää $
ConnectFaceRebuildData
ää *
>
ää* + 
ConnectEdgesInFace
ää, >
(
ää> ?
Face
ãã 
face
ãã 
,
ãã 
List
åå 
<
åå 

WingedEdge
åå 
>
åå 
edges
åå "
,
åå" #
List
çç 
<
çç 
Vertex
çç 
>
çç 
vertices
çç !
)
çç! "
{
éé 	
List
èè 
<
èè 
Edge
èè 
>
èè 
	perimeter
èè  
=
èè! "

WingedEdge
èè# -
.
èè- ."
SortEdgesByAdjacency
èè. B
(
èèB C
face
èèC G
)
èèG H
;
èèH I
int
êê 

splitCount
êê 
=
êê 
edges
êê "
.
êê" #
Count
êê# (
;
êê( )
Vertex
íí 
centroid
íí 
=
íí 
Vertex
íí $
.
íí$ %
Average
íí% ,
(
íí, -
vertices
íí- 5
,
íí5 6
face
íí7 ;
.
íí; <%
distinctIndexesInternal
íí< S
)
ííS T
;
ííT U
List
îî 
<
îî 
List
îî 
<
îî 
Vertex
îî 
>
îî 
>
îî 

n_vertices
îî )
=
îî* +
ArrayUtility
îî, 8
.
îî8 9
Fill
îî9 =
<
îî= >
List
îî> B
<
îîB C
Vertex
îîC I
>
îîI J
>
îîJ K
(
îîK L
x
îîL M
=>
îîN P
{
îîQ R
return
îîS Y
new
îîZ ]
List
îî^ b
<
îîb c
Vertex
îîc i
>
îîi j
(
îîj k
)
îîk l
;
îîl m
}
îîn o
,
îîo p

splitCount
îîq {
)
îî{ |
;
îî| }
List
ïï 
<
ïï 
List
ïï 
<
ïï 
int
ïï 
>
ïï 
>
ïï 
	n_indexes
ïï %
=
ïï& '
ArrayUtility
ïï( 4
.
ïï4 5
Fill
ïï5 9
<
ïï9 :
List
ïï: >
<
ïï> ?
int
ïï? B
>
ïïB C
>
ïïC D
(
ïïD E
x
ïïE F
=>
ïïG I
{
ïïJ K
return
ïïL R
new
ïïS V
List
ïïW [
<
ïï[ \
int
ïï\ _
>
ïï_ `
(
ïï` a
)
ïïa b
;
ïïb c
}
ïïd e
,
ïïe f

splitCount
ïïg q
)
ïïq r
;
ïïr s
HashSet
óó 
<
óó 
Edge
óó 
>
óó 
edgesToSplit
óó &
=
óó' (
new
óó) ,
HashSet
óó- 4
<
óó4 5
Edge
óó5 9
>
óó9 :
(
óó: ;
edges
óó; @
.
óó@ A
Select
óóA G
(
óóG H
x
óóH I
=>
óóJ L
x
óóM N
.
óóN O
edge
óóO S
.
óóS T
local
óóT Y
)
óóY Z
)
óóZ [
;
óó[ \
int
ôô 
index
ôô 
=
ôô 
$num
ôô 
;
ôô 
for
úú 
(
úú 
int
úú 
i
úú 
=
úú 
$num
úú 
;
úú 
i
úú 
<
úú 
	perimeter
úú  )
.
úú) *
Count
úú* /
;
úú/ 0
i
úú1 2
++
úú2 4
)
úú4 5
{
ùù 

n_vertices
ûû 
[
ûû 
index
ûû  
%
ûû! "

splitCount
ûû# -
]
ûû- .
.
ûû. /
Add
ûû/ 2
(
ûû2 3
vertices
ûû3 ;
[
ûû; <
	perimeter
ûû< E
[
ûûE F
i
ûûF G
]
ûûG H
.
ûûH I
a
ûûI J
]
ûûJ K
)
ûûK L
;
ûûL M
if
†† 
(
†† 
edgesToSplit
††  
.
††  !
Contains
††! )
(
††) *
	perimeter
††* 3
[
††3 4
i
††4 5
]
††5 6
)
††6 7
)
††7 8
{
°° 
Vertex
¢¢ 
mix
¢¢ 
=
¢¢  
Vertex
¢¢! '
.
¢¢' (
Mix
¢¢( +
(
¢¢+ ,
vertices
¢¢, 4
[
¢¢4 5
	perimeter
¢¢5 >
[
¢¢> ?
i
¢¢? @
]
¢¢@ A
.
¢¢A B
a
¢¢B C
]
¢¢C D
,
¢¢D E
vertices
¢¢F N
[
¢¢N O
	perimeter
¢¢O X
[
¢¢X Y
i
¢¢Y Z
]
¢¢Z [
.
¢¢[ \
b
¢¢\ ]
]
¢¢] ^
,
¢¢^ _
$num
¢¢` c
)
¢¢c d
;
¢¢d e
	n_indexes
•• 
[
•• 
index
•• #
]
••# $
.
••$ %
Add
••% (
(
••( )

n_vertices
••) 3
[
••3 4
index
••4 9
]
••9 :
.
••: ;
Count
••; @
)
••@ A
;
••A B

n_vertices
¶¶ 
[
¶¶ 
index
¶¶ $
]
¶¶$ %
.
¶¶% &
Add
¶¶& )
(
¶¶) *
mix
¶¶* -
)
¶¶- .
;
¶¶. /
	n_indexes
©© 
[
©© 
index
©© #
]
©©# $
.
©©$ %
Add
©©% (
(
©©( )

n_vertices
©©) 3
[
©©3 4
index
©©4 9
]
©©9 :
.
©©: ;
Count
©©; @
)
©©@ A
;
©©A B

n_vertices
™™ 
[
™™ 
index
™™ $
]
™™$ %
.
™™% &
Add
™™& )
(
™™) *
centroid
™™* 2
)
™™2 3
;
™™3 4
index
≠≠ 
=
≠≠ 
(
≠≠ 
index
≠≠ "
+
≠≠# $
$num
≠≠% &
)
≠≠& '
%
≠≠( )

splitCount
≠≠* 4
;
≠≠4 5

n_vertices
∞∞ 
[
∞∞ 
index
∞∞ $
]
∞∞$ %
.
∞∞% &
Add
∞∞& )
(
∞∞) *
mix
∞∞* -
)
∞∞- .
;
∞∞. /
}
±± 
}
≤≤ 
List
¥¥ 
<
¥¥ $
ConnectFaceRebuildData
¥¥ '
>
¥¥' (
faces
¥¥) .
=
¥¥/ 0
new
¥¥1 4
List
¥¥5 9
<
¥¥9 :$
ConnectFaceRebuildData
¥¥: P
>
¥¥P Q
(
¥¥Q R
)
¥¥R S
;
¥¥S T
for
∂∂ 
(
∂∂ 
int
∂∂ 
i
∂∂ 
=
∂∂ 
$num
∂∂ 
;
∂∂ 
i
∂∂ 
<
∂∂ 

n_vertices
∂∂  *
.
∂∂* +
Count
∂∂+ 0
;
∂∂0 1
i
∂∂2 3
++
∂∂3 5
)
∂∂5 6
{
∑∑ 
FaceRebuildData
∏∏ 
f
∏∏  !
=
∏∏" #
AppendElements
∏∏$ 2
.
∏∏2 3
FaceWithVertices
∏∏3 C
(
∏∏C D

n_vertices
∏∏D N
[
∏∏N O
i
∏∏O P
]
∏∏P Q
,
∏∏Q R
false
∏∏S X
)
∏∏X Y
;
∏∏Y Z
if
ππ 
(
ππ 
f
ππ 
==
ππ 
null
ππ 
)
ππ 
{
∫∫ 
faces
ªª 
.
ªª 
Clear
ªª 
(
ªª  
)
ªª  !
;
ªª! "
return
ºº 
null
ºº 
;
ºº  
}
ΩΩ 
faces
ææ 
.
ææ 
Add
ææ 
(
ææ 
new
ææ $
ConnectFaceRebuildData
ææ 4
(
ææ4 5
f
ææ5 6
,
ææ6 7
	n_indexes
ææ8 A
[
ææA B
i
ææB C
]
ææC D
)
ææD E
)
ææE F
;
ææF G
}
øø 
return
¡¡ 
faces
¡¡ 
;
¡¡ 
}
¬¬ 	
static
ƒƒ 
bool
ƒƒ 
InsertVertices
ƒƒ "
(
ƒƒ" #
Face
ƒƒ# '
face
ƒƒ( ,
,
ƒƒ, -
List
ƒƒ. 2
<
ƒƒ2 3

WingedEdge
ƒƒ3 =
>
ƒƒ= >
edges
ƒƒ? D
,
ƒƒD E
List
ƒƒF J
<
ƒƒJ K
Vertex
ƒƒK Q
>
ƒƒQ R
vertices
ƒƒS [
,
ƒƒ[ \
out
ƒƒ] `$
ConnectFaceRebuildData
ƒƒa w
data
ƒƒx |
)
ƒƒ| }
{
≈≈ 	
List
∆∆ 
<
∆∆ 
Edge
∆∆ 
>
∆∆ 
	perimeter
∆∆  
=
∆∆! "

WingedEdge
∆∆# -
.
∆∆- ."
SortEdgesByAdjacency
∆∆. B
(
∆∆B C
face
∆∆C G
)
∆∆G H
;
∆∆H I
List
«« 
<
«« 
Vertex
«« 
>
«« 

n_vertices
«« #
=
««$ %
new
««& )
List
««* .
<
««. /
Vertex
««/ 5
>
««5 6
(
««6 7
)
««7 8
;
««8 9
List
»» 
<
»» 
int
»» 
>
»» 
newVertexIndexes
»» &
=
»»' (
new
»») ,
List
»»- 1
<
»»1 2
int
»»2 5
>
»»5 6
(
»»6 7
)
»»7 8
;
»»8 9
HashSet
…… 
<
…… 
Edge
…… 
>
…… 
affected
…… "
=
……# $
new
……% (
HashSet
……) 0
<
……0 1
Edge
……1 5
>
……5 6
(
……6 7
edges
……7 <
.
……< =
Select
……= C
(
……C D
x
……D E
=>
……F H
x
……I J
.
……J K
edge
……K O
.
……O P
local
……P U
)
……U V
)
……V W
;
……W X
for
ÀÀ 
(
ÀÀ 
int
ÀÀ 
i
ÀÀ 
=
ÀÀ 
$num
ÀÀ 
;
ÀÀ 
i
ÀÀ 
<
ÀÀ 
	perimeter
ÀÀ  )
.
ÀÀ) *
Count
ÀÀ* /
;
ÀÀ/ 0
i
ÀÀ1 2
++
ÀÀ2 4
)
ÀÀ4 5
{
ÃÃ 

n_vertices
ÕÕ 
.
ÕÕ 
Add
ÕÕ 
(
ÕÕ 
vertices
ÕÕ '
[
ÕÕ' (
	perimeter
ÕÕ( 1
[
ÕÕ1 2
i
ÕÕ2 3
]
ÕÕ3 4
.
ÕÕ4 5
a
ÕÕ5 6
]
ÕÕ6 7
)
ÕÕ7 8
;
ÕÕ8 9
if
œœ 
(
œœ 
affected
œœ 
.
œœ 
Contains
œœ %
(
œœ% &
	perimeter
œœ& /
[
œœ/ 0
i
œœ0 1
]
œœ1 2
)
œœ2 3
)
œœ3 4
{
–– 
newVertexIndexes
—— $
.
——$ %
Add
——% (
(
——( )

n_vertices
——) 3
.
——3 4
Count
——4 9
)
——9 :
;
——: ;

n_vertices
““ 
.
““ 
Add
““ "
(
““" #
Vertex
““# )
.
““) *
Mix
““* -
(
““- .
vertices
““. 6
[
““6 7
	perimeter
““7 @
[
““@ A
i
““A B
]
““B C
.
““C D
a
““D E
]
““E F
,
““F G
vertices
““H P
[
““P Q
	perimeter
““Q Z
[
““Z [
i
““[ \
]
““\ ]
.
““] ^
b
““^ _
]
““_ `
,
““` a
$num
““b e
)
““e f
)
““f g
;
““g h
}
”” 
}
‘‘ 
FaceRebuildData
÷÷ 
res
÷÷ 
=
÷÷  !
AppendElements
÷÷" 0
.
÷÷0 1
FaceWithVertices
÷÷1 A
(
÷÷A B

n_vertices
÷÷B L
,
÷÷L M
false
÷÷N S
)
÷÷S T
;
÷÷T U
if
ÿÿ 
(
ÿÿ 
res
ÿÿ 
!=
ÿÿ 
null
ÿÿ 
)
ÿÿ 
{
ŸŸ 
res
⁄⁄ 
.
⁄⁄ 
face
⁄⁄ 
.
⁄⁄ 
textureGroup
⁄⁄ %
=
⁄⁄& '
face
⁄⁄( ,
.
⁄⁄, -
textureGroup
⁄⁄- 9
;
⁄⁄9 :
res
€€ 
.
€€ 
face
€€ 
.
€€ 
uv
€€ 
=
€€ 
new
€€ ! 
AutoUnwrapSettings
€€" 4
(
€€4 5
face
€€5 9
.
€€9 :
uv
€€: <
)
€€< =
;
€€= >
res
‹‹ 
.
‹‹ 
face
‹‹ 
.
‹‹ 
smoothingGroup
‹‹ '
=
‹‹( )
face
‹‹* .
.
‹‹. /
smoothingGroup
‹‹/ =
;
‹‹= >
res
›› 
.
›› 
face
›› 
.
›› 
manualUV
›› !
=
››" #
face
››$ (
.
››( )
manualUV
››) 1
;
››1 2
res
ﬁﬁ 
.
ﬁﬁ 
face
ﬁﬁ 
.
ﬁﬁ 
submeshIndex
ﬁﬁ %
=
ﬁﬁ& '
face
ﬁﬁ( ,
.
ﬁﬁ, -
submeshIndex
ﬁﬁ- 9
;
ﬁﬁ9 :
data
‡‡ 
=
‡‡ 
new
‡‡ $
ConnectFaceRebuildData
‡‡ 1
(
‡‡1 2
res
‡‡2 5
,
‡‡5 6
newVertexIndexes
‡‡7 G
)
‡‡G H
;
‡‡H I
return
·· 
true
·· 
;
·· 
}
‚‚ 
data
‰‰ 
=
‰‰ 
null
‰‰ 
;
‰‰ 
return
ÊÊ 
false
ÊÊ 
;
ÊÊ 
}
ÁÁ 	
static
ÈÈ 
List
ÈÈ 
<
ÈÈ $
ConnectFaceRebuildData
ÈÈ *
>
ÈÈ* +#
ConnectIndexesPerFace
ÈÈ, A
(
ÈÈA B
Face
ÍÍ 
face
ÍÍ 
,
ÍÍ 
int
ÎÎ 
a
ÎÎ 
,
ÎÎ 
int
ÏÏ 
b
ÏÏ 
,
ÏÏ 
List
ÌÌ 
<
ÌÌ 
Vertex
ÌÌ 
>
ÌÌ 
vertices
ÌÌ !
,
ÌÌ! "

Dictionary
ÓÓ 
<
ÓÓ 
int
ÓÓ 
,
ÓÓ 
int
ÓÓ 
>
ÓÓ  
lookup
ÓÓ! '
)
ÓÓ' (
{
ÔÔ 	
List
 
<
 
Edge
 
>
 
	perimeter
  
=
! "

WingedEdge
# -
.
- ."
SortEdgesByAdjacency
. B
(
B C
face
C G
)
G H
;
H I
List
ÚÚ 
<
ÚÚ 
Vertex
ÚÚ 
>
ÚÚ 
[
ÚÚ 
]
ÚÚ 

n_vertices
ÚÚ %
=
ÚÚ& '
new
ÚÚ( +
List
ÚÚ, 0
<
ÚÚ0 1
Vertex
ÚÚ1 7
>
ÚÚ7 8
[
ÚÚ8 9
]
ÚÚ9 :
{
ÚÚ; <
new
ÛÛ 
List
ÛÛ 
<
ÛÛ 
Vertex
ÛÛ 
>
ÛÛ  
(
ÛÛ  !
)
ÛÛ! "
,
ÛÛ" #
new
ÙÙ 
List
ÙÙ 
<
ÙÙ 
Vertex
ÙÙ 
>
ÙÙ  
(
ÙÙ  !
)
ÙÙ! "
}
ıı 
;
ıı 
List
˜˜ 
<
˜˜ 
int
˜˜ 
>
˜˜ 
[
˜˜ 
]
˜˜ 
n_sharedIndexes
˜˜ '
=
˜˜( )
new
˜˜* -
List
˜˜. 2
<
˜˜2 3
int
˜˜3 6
>
˜˜6 7
[
˜˜7 8
]
˜˜8 9
{
˜˜: ;
new
¯¯ 
List
¯¯ 
<
¯¯ 
int
¯¯ 
>
¯¯ 
(
¯¯ 
)
¯¯ 
,
¯¯  
new
˘˘ 
List
˘˘ 
<
˘˘ 
int
˘˘ 
>
˘˘ 
(
˘˘ 
)
˘˘ 
}
˙˙ 
;
˙˙ 
List
¸¸ 
<
¸¸ 
int
¸¸ 
>
¸¸ 
[
¸¸ 
]
¸¸ 
	n_indexes
¸¸ !
=
¸¸" #
new
¸¸$ '
List
¸¸( ,
<
¸¸, -
int
¸¸- 0
>
¸¸0 1
[
¸¸1 2
]
¸¸2 3
{
¸¸4 5
new
˝˝ 
List
˝˝ 
<
˝˝ 
int
˝˝ 
>
˝˝ 
(
˝˝ 
)
˝˝ 
,
˝˝  
new
˛˛ 
List
˛˛ 
<
˛˛ 
int
˛˛ 
>
˛˛ 
(
˛˛ 
)
˛˛ 
}
ˇˇ 
;
ˇˇ 
int
ÅÅ 
index
ÅÅ 
=
ÅÅ 
$num
ÅÅ 
;
ÅÅ 
for
ÉÉ 
(
ÉÉ 
int
ÉÉ 
i
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
;
ÉÉ 
i
ÉÉ 
<
ÉÉ 
	perimeter
ÉÉ  )
.
ÉÉ) *
Count
ÉÉ* /
;
ÉÉ/ 0
i
ÉÉ1 2
++
ÉÉ2 4
)
ÉÉ4 5
{
ÑÑ 
if
ÜÜ 
(
ÜÜ 
	perimeter
ÜÜ 
[
ÜÜ 
i
ÜÜ 
]
ÜÜ  
.
ÜÜ  !
Contains
ÜÜ! )
(
ÜÜ) *
a
ÜÜ* +
)
ÜÜ+ ,
&&
ÜÜ- /
	perimeter
ÜÜ0 9
[
ÜÜ9 :
i
ÜÜ: ;
]
ÜÜ; <
.
ÜÜ< =
Contains
ÜÜ= E
(
ÜÜE F
b
ÜÜF G
)
ÜÜG H
)
ÜÜH I
return
áá 
null
áá 
;
áá  
int
ââ 
cur
ââ 
=
ââ 
	perimeter
ââ #
[
ââ# $
i
ââ$ %
]
ââ% &
.
ââ& '
a
ââ' (
;
ââ( )

n_vertices
ãã 
[
ãã 
index
ãã  
]
ãã  !
.
ãã! "
Add
ãã" %
(
ãã% &
vertices
ãã& .
[
ãã. /
cur
ãã/ 2
]
ãã2 3
)
ãã3 4
;
ãã4 5
n_sharedIndexes
åå 
[
åå  
index
åå  %
]
åå% &
.
åå& '
Add
åå' *
(
åå* +
lookup
åå+ 1
[
åå1 2
cur
åå2 5
]
åå5 6
)
åå6 7
;
åå7 8
if
éé 
(
éé 
cur
éé 
==
éé 
a
éé 
||
éé 
cur
éé  #
==
éé$ &
b
éé' (
)
éé( )
{
èè 
index
êê 
=
êê 
(
êê 
index
êê "
+
êê# $
$num
êê% &
)
êê& '
%
êê( )
$num
êê* +
;
êê+ ,
	n_indexes
íí 
[
íí 
index
íí #
]
íí# $
.
íí$ %
Add
íí% (
(
íí( )

n_vertices
íí) 3
[
íí3 4
index
íí4 9
]
íí9 :
.
íí: ;
Count
íí; @
)
íí@ A
;
ííA B

n_vertices
ìì 
[
ìì 
index
ìì $
]
ìì$ %
.
ìì% &
Add
ìì& )
(
ìì) *
vertices
ìì* 2
[
ìì2 3
cur
ìì3 6
]
ìì6 7
)
ìì7 8
;
ìì8 9
n_sharedIndexes
îî #
[
îî# $
index
îî$ )
]
îî) *
.
îî* +
Add
îî+ .
(
îî. /
lookup
îî/ 5
[
îî5 6
cur
îî6 9
]
îî9 :
)
îî: ;
;
îî; <
}
ïï 
}
ññ 
List
òò 
<
òò $
ConnectFaceRebuildData
òò '
>
òò' (
faces
òò) .
=
òò/ 0
new
òò1 4
List
òò5 9
<
òò9 :$
ConnectFaceRebuildData
òò: P
>
òòP Q
(
òòQ R
)
òòR S
;
òòS T
Vector3
ôô 
nrm
ôô 
=
ôô 
Math
ôô 
.
ôô 
Normal
ôô %
(
ôô% &
vertices
ôô& .
,
ôô. /
face
ôô0 4
.
ôô4 5
indexesInternal
ôô5 D
)
ôôD E
;
ôôE F
for
õõ 
(
õõ 
int
õõ 
i
õõ 
=
õõ 
$num
õõ 
;
õõ 
i
õõ 
<
õõ 

n_vertices
õõ  *
.
õõ* +
Length
õõ+ 1
;
õõ1 2
i
õõ3 4
++
õõ4 6
)
õõ6 7
{
úú 
FaceRebuildData
ùù 
f
ùù  !
=
ùù" #
AppendElements
ùù$ 2
.
ùù2 3
FaceWithVertices
ùù3 C
(
ùùC D

n_vertices
ùùD N
[
ùùN O
i
ùùO P
]
ùùP Q
,
ùùQ R
false
ùùS X
)
ùùX Y
;
ùùY Z
f
ûû 
.
ûû 
sharedIndexes
ûû 
=
ûû  !
n_sharedIndexes
ûû" 1
[
ûû1 2
i
ûû2 3
]
ûû3 4
;
ûû4 5
Vector3
†† 
fn
†† 
=
†† 
Math
†† !
.
††! "
Normal
††" (
(
††( )

n_vertices
††) 3
[
††3 4
i
††4 5
]
††5 6
,
††6 7
f
††8 9
.
††9 :
face
††: >
.
††> ?
indexesInternal
††? N
)
††N O
;
††O P
if
¢¢ 
(
¢¢ 
Vector3
¢¢ 
.
¢¢ 
Dot
¢¢ 
(
¢¢  
nrm
¢¢  #
,
¢¢# $
fn
¢¢% '
)
¢¢' (
<
¢¢) *
$num
¢¢+ ,
)
¢¢, -
f
££ 
.
££ 
face
££ 
.
££ 
Reverse
££ "
(
££" #
)
££# $
;
££$ %
faces
•• 
.
•• 
Add
•• 
(
•• 
new
•• $
ConnectFaceRebuildData
•• 4
(
••4 5
f
••5 6
,
••6 7
	n_indexes
••8 A
[
••A B
i
••B C
]
••C D
)
••D E
)
••E F
;
••F G
}
¶¶ 
return
®® 
faces
®® 
;
®® 
}
©© 	
static
´´ 
List
´´ 
<
´´ $
ConnectFaceRebuildData
´´ *
>
´´* +#
ConnectIndexesPerFace
´´, A
(
´´A B
Face
¨¨ 
face
¨¨ 
,
¨¨ 
List
≠≠ 
<
≠≠ 
int
≠≠ 
>
≠≠ 
indexes
≠≠ 
,
≠≠ 
List
ÆÆ 
<
ÆÆ 
Vertex
ÆÆ 
>
ÆÆ 
vertices
ÆÆ !
,
ÆÆ! "

Dictionary
ØØ 
<
ØØ 
int
ØØ 
,
ØØ 
int
ØØ 
>
ØØ  
lookup
ØØ! '
,
ØØ' (
int
∞∞ 
sharedIndexOffset
∞∞ !
)
∞∞! "
{
±± 	
if
≤≤ 
(
≤≤ 
indexes
≤≤ 
.
≤≤ 
Count
≤≤ 
<
≤≤ 
$num
≤≤  !
)
≤≤! "
return
≥≥ 
null
≥≥ 
;
≥≥ 
List
µµ 
<
µµ 
Edge
µµ 
>
µµ 
	perimeter
µµ  
=
µµ! "

WingedEdge
µµ# -
.
µµ- ."
SortEdgesByAdjacency
µµ. B
(
µµB C
face
µµC G
)
µµG H
;
µµH I
int
∑∑ 

splitCount
∑∑ 
=
∑∑ 
indexes
∑∑ $
.
∑∑$ %
Count
∑∑% *
;
∑∑* +
List
ππ 
<
ππ 
List
ππ 
<
ππ 
Vertex
ππ 
>
ππ 
>
ππ 

n_vertices
ππ )
=
ππ* +
ArrayUtility
ππ, 8
.
ππ8 9
Fill
ππ9 =
<
ππ= >
List
ππ> B
<
ππB C
Vertex
ππC I
>
ππI J
>
ππJ K
(
ππK L
x
ππL M
=>
ππN P
{
ππQ R
return
ππS Y
new
ππZ ]
List
ππ^ b
<
ππb c
Vertex
ππc i
>
ππi j
(
ππj k
)
ππk l
;
ππl m
}
ππn o
,
ππo p

splitCount
ππq {
)
ππ{ |
;
ππ| }
List
∫∫ 
<
∫∫ 
List
∫∫ 
<
∫∫ 
int
∫∫ 
>
∫∫ 
>
∫∫ 
n_sharedIndexes
∫∫ +
=
∫∫, -
ArrayUtility
∫∫. :
.
∫∫: ;
Fill
∫∫; ?
<
∫∫? @
List
∫∫@ D
<
∫∫D E
int
∫∫E H
>
∫∫H I
>
∫∫I J
(
∫∫J K
x
∫∫K L
=>
∫∫M O
{
∫∫P Q
return
∫∫R X
new
∫∫Y \
List
∫∫] a
<
∫∫a b
int
∫∫b e
>
∫∫e f
(
∫∫f g
)
∫∫g h
;
∫∫h i
}
∫∫j k
,
∫∫k l

splitCount
∫∫m w
)
∫∫w x
;
∫∫x y
List
ªª 
<
ªª 
List
ªª 
<
ªª 
int
ªª 
>
ªª 
>
ªª 
	n_indexes
ªª %
=
ªª& '
ArrayUtility
ªª( 4
.
ªª4 5
Fill
ªª5 9
<
ªª9 :
List
ªª: >
<
ªª> ?
int
ªª? B
>
ªªB C
>
ªªC D
(
ªªD E
x
ªªE F
=>
ªªG I
{
ªªJ K
return
ªªL R
new
ªªS V
List
ªªW [
<
ªª[ \
int
ªª\ _
>
ªª_ `
(
ªª` a
)
ªªa b
;
ªªb c
}
ªªd e
,
ªªe f

splitCount
ªªg q
)
ªªq r
;
ªªr s
Vertex
ΩΩ 
center
ΩΩ 
=
ΩΩ 
Vertex
ΩΩ "
.
ΩΩ" #
Average
ΩΩ# *
(
ΩΩ* +
vertices
ΩΩ+ 3
,
ΩΩ3 4
indexes
ΩΩ5 <
)
ΩΩ< =
;
ΩΩ= >
Vector3
ææ 
nrm
ææ 
=
ææ 
Math
ææ 
.
ææ 
Normal
ææ %
(
ææ% &
vertices
ææ& .
,
ææ. /
face
ææ0 4
.
ææ4 5
indexesInternal
ææ5 D
)
ææD E
;
ææE F
int
¿¿ 
index
¿¿ 
=
¿¿ 
$num
¿¿ 
;
¿¿ 
for
¬¬ 
(
¬¬ 
int
¬¬ 
i
¬¬ 
=
¬¬ 
$num
¬¬ 
;
¬¬ 
i
¬¬ 
<
¬¬ 
	perimeter
¬¬  )
.
¬¬) *
Count
¬¬* /
;
¬¬/ 0
i
¬¬1 2
++
¬¬2 4
)
¬¬4 5
{
√√ 
int
ƒƒ 
cur
ƒƒ 
=
ƒƒ 
	perimeter
ƒƒ #
[
ƒƒ# $
i
ƒƒ$ %
]
ƒƒ% &
.
ƒƒ& '
a
ƒƒ' (
;
ƒƒ( )

n_vertices
∆∆ 
[
∆∆ 
index
∆∆  
]
∆∆  !
.
∆∆! "
Add
∆∆" %
(
∆∆% &
vertices
∆∆& .
[
∆∆. /
cur
∆∆/ 2
]
∆∆2 3
)
∆∆3 4
;
∆∆4 5
n_sharedIndexes
«« 
[
««  
index
««  %
]
««% &
.
««& '
Add
««' *
(
««* +
lookup
««+ 1
[
««1 2
cur
««2 5
]
««5 6
)
««6 7
;
««7 8
if
…… 
(
…… 
indexes
…… 
.
…… 
Contains
…… $
(
……$ %
cur
……% (
)
……( )
)
……) *
{
   
	n_indexes
ÀÀ 
[
ÀÀ 
index
ÀÀ #
]
ÀÀ# $
.
ÀÀ$ %
Add
ÀÀ% (
(
ÀÀ( )

n_vertices
ÀÀ) 3
[
ÀÀ3 4
index
ÀÀ4 9
]
ÀÀ9 :
.
ÀÀ: ;
Count
ÀÀ; @
)
ÀÀ@ A
;
ÀÀA B

n_vertices
ÃÃ 
[
ÃÃ 
index
ÃÃ $
]
ÃÃ$ %
.
ÃÃ% &
Add
ÃÃ& )
(
ÃÃ) *
center
ÃÃ* 0
)
ÃÃ0 1
;
ÃÃ1 2
n_sharedIndexes
ÕÕ #
[
ÕÕ# $
index
ÕÕ$ )
]
ÕÕ) *
.
ÕÕ* +
Add
ÕÕ+ .
(
ÕÕ. /
sharedIndexOffset
ÕÕ/ @
)
ÕÕ@ A
;
ÕÕA B
index
œœ 
=
œœ 
(
œœ 
index
œœ "
+
œœ# $
$num
œœ% &
)
œœ& '
%
œœ( )

splitCount
œœ* 4
;
œœ4 5
	n_indexes
—— 
[
—— 
index
—— #
]
——# $
.
——$ %
Add
——% (
(
——( )

n_vertices
——) 3
[
——3 4
index
——4 9
]
——9 :
.
——: ;
Count
——; @
)
——@ A
;
——A B

n_vertices
““ 
[
““ 
index
““ $
]
““$ %
.
““% &
Add
““& )
(
““) *
vertices
““* 2
[
““2 3
cur
““3 6
]
““6 7
)
““7 8
;
““8 9
n_sharedIndexes
”” #
[
””# $
index
””$ )
]
””) *
.
””* +
Add
””+ .
(
””. /
lookup
””/ 5
[
””5 6
cur
””6 9
]
””9 :
)
””: ;
;
””; <
}
‘‘ 
}
’’ 
List
◊◊ 
<
◊◊ $
ConnectFaceRebuildData
◊◊ '
>
◊◊' (
faces
◊◊) .
=
◊◊/ 0
new
◊◊1 4
List
◊◊5 9
<
◊◊9 :$
ConnectFaceRebuildData
◊◊: P
>
◊◊P Q
(
◊◊Q R
)
◊◊R S
;
◊◊S T
for
ŸŸ 
(
ŸŸ 
int
ŸŸ 
i
ŸŸ 
=
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
i
ŸŸ 
<
ŸŸ 

n_vertices
ŸŸ  *
.
ŸŸ* +
Count
ŸŸ+ 0
;
ŸŸ0 1
i
ŸŸ2 3
++
ŸŸ3 5
)
ŸŸ5 6
{
⁄⁄ 
if
€€ 
(
€€ 

n_vertices
€€ 
[
€€ 
i
€€  
]
€€  !
.
€€! "
Count
€€" '
<
€€( )
$num
€€* +
)
€€+ ,
continue
‹‹ 
;
‹‹ 
FaceRebuildData
ﬁﬁ 
f
ﬁﬁ  !
=
ﬁﬁ" #
AppendElements
ﬁﬁ$ 2
.
ﬁﬁ2 3
FaceWithVertices
ﬁﬁ3 C
(
ﬁﬁC D

n_vertices
ﬁﬁD N
[
ﬁﬁN O
i
ﬁﬁO P
]
ﬁﬁP Q
,
ﬁﬁQ R
false
ﬁﬁS X
)
ﬁﬁX Y
;
ﬁﬁY Z
f
ﬂﬂ 
.
ﬂﬂ 
sharedIndexes
ﬂﬂ 
=
ﬂﬂ  !
n_sharedIndexes
ﬂﬂ" 1
[
ﬂﬂ1 2
i
ﬂﬂ2 3
]
ﬂﬂ3 4
;
ﬂﬂ4 5
Vector3
·· 
fn
·· 
=
·· 
Math
·· !
.
··! "
Normal
··" (
(
··( )

n_vertices
··) 3
[
··3 4
i
··4 5
]
··5 6
,
··6 7
f
··8 9
.
··9 :
face
··: >
.
··> ?
indexesInternal
··? N
)
··N O
;
··O P
if
„„ 
(
„„ 
Vector3
„„ 
.
„„ 
Dot
„„ 
(
„„  
nrm
„„  #
,
„„# $
fn
„„% '
)
„„' (
<
„„) *
$num
„„+ ,
)
„„, -
f
‰‰ 
.
‰‰ 
face
‰‰ 
.
‰‰ 
Reverse
‰‰ "
(
‰‰" #
)
‰‰# $
;
‰‰$ %
faces
ÊÊ 
.
ÊÊ 
Add
ÊÊ 
(
ÊÊ 
new
ÊÊ $
ConnectFaceRebuildData
ÊÊ 4
(
ÊÊ4 5
f
ÊÊ5 6
,
ÊÊ6 7
	n_indexes
ÊÊ8 A
[
ÊÊA B
i
ÊÊB C
]
ÊÊC D
)
ÊÊD E
)
ÊÊE F
;
ÊÊF G
}
ÁÁ 
return
ÈÈ 
faces
ÈÈ 
;
ÈÈ 
}
ÍÍ 	
}
ÎÎ 
}ÏÏ ‘
ãD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\VectorHash.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static

 

class

 

VectorHash

 
{ 
public 
const 
float  
FltCompareResolution /
=0 1
$num2 7
;7 8
static 
int 
	HashFloat 
( 
float "
f# $
)$ %
{ 	
ulong 
u 
= 
( 
ulong 
) 
( 
f 
*  ! 
FltCompareResolution" 6
)6 7
;7 8
return 
( 
int 
) 
( 
u 
% 
int  
.  !
MaxValue! )
)) *
;* +
} 	
public 
static 
int 
GetHashCode %
(% &
Vector2& -
v. /
)/ 0
{ 	
int 
hash 
= 
$num 
; 
	unchecked 
{ 
hash   
=   
hash   
*   
$num    
+  ! "
	HashFloat  # ,
(  , -
v  - .
.  . /
x  / 0
)  0 1
;  1 2
hash!! 
=!! 
hash!! 
*!! 
$num!!  
+!!! "
	HashFloat!!# ,
(!!, -
v!!- .
.!!. /
y!!/ 0
)!!0 1
;!!1 2
}"" 
return$$ 
hash$$ 
;$$ 
}%% 	
public,, 
static,, 
int,, 
GetHashCode,, %
(,,% &
Vector3,,& -
v,,. /
),,/ 0
{-- 	
int// 
hash// 
=// 
$num// 
;// 
	unchecked11 
{22 
hash33 
=33 
hash33 
*33 
$num33  
+33! "
	HashFloat33# ,
(33, -
v33- .
.33. /
x33/ 0
)330 1
;331 2
hash44 
=44 
hash44 
*44 
$num44  
+44! "
	HashFloat44# ,
(44, -
v44- .
.44. /
y44/ 0
)440 1
;441 2
hash55 
=55 
hash55 
*55 
$num55  
+55! "
	HashFloat55# ,
(55, -
v55- .
.55. /
z55/ 0
)550 1
;551 2
}66 
return88 
hash88 
;88 
}99 	
public@@ 
static@@ 
int@@ 
GetHashCode@@ %
(@@% &
Vector4@@& -
v@@. /
)@@/ 0
{AA 	
intCC 
hashCC 
=CC 
$numCC 
;CC 
	uncheckedEE 
{FF 
hashGG 
=GG 
hashGG 
*GG 
$numGG  
+GG! "
	HashFloatGG# ,
(GG, -
vGG- .
.GG. /
xGG/ 0
)GG0 1
;GG1 2
hashHH 
=HH 
hashHH 
*HH 
$numHH  
+HH! "
	HashFloatHH# ,
(HH, -
vHH- .
.HH. /
yHH/ 0
)HH0 1
;HH1 2
hashII 
=II 
hashII 
*II 
$numII  
+II! "
	HashFloatII# ,
(II, -
vII- .
.II. /
zII/ 0
)II0 1
;II1 2
hashJJ 
=JJ 
hashJJ 
*JJ 
$numJJ  
+JJ! "
	HashFloatJJ# ,
(JJ, -
vJJ- .
.JJ. /
wJJ/ 0
)JJ0 1
;JJ1 2
}KK 
returnMM 
hashMM 
;MM 
}NN 	
}OO 
}PP É~
ûD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\UV\AutoUvConversion.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
static 
partial 
class 
	UVEditing 
{ 
internal 

static 
void 
	SetAutoUV  
(  !
ProBuilderMesh! /
mesh0 4
,4 5
Face6 :
[: ;
]; <
faces= B
,B C
boolD H
autoI M
)M N
{ 
if 
( 
auto 
) 
{ ,
 SetAutoAndAlignUnwrapParamsToUVs $
($ %
mesh% )
,) *
faces+ 0
.0 1
Where1 6
(6 7
x7 8
=>9 ;
x< =
.= >
manualUV> F
)F G
)G H
;H I
} 
else 
{ 
foreach 
( 
Face 
f 
in 
faces 
) 
{ 
f 
. 
textureGroup 
= 
- 
$num 
; 
f 
. 
manualUV 
= 
true 
; 
} 
} 
} 
internal'' 

static'' 
void'' ,
 SetAutoAndAlignUnwrapParamsToUVs'' 7
(''7 8
ProBuilderMesh''8 F
mesh''G K
,''K L
IEnumerable''M X
<''X Y
Face''Y ]
>''] ^
facesToConvert''_ m
)''m n
{(( 
var)) 
destinationTextures)) 
=)) 
mesh)) !
.))! "
textures))" *
.))* +
ToArray))+ 2
())2 3
)))3 4
;))4 5
var** 
faces** 
=** 
facesToConvert** 
as**  
Face**! %
[**% &
]**& '
??**( *
facesToConvert**+ 9
.**9 :
ToArray**: A
(**A B
)**B C
;**C D
foreach,, 

(,, 
var,, 
face,, 
in,, 
faces,, 
),, 
{-- 
face.. 
... 	
uv..	 
=.. 
AutoUnwrapSettings..  
...  !%
defaultAutoUnwrapSettings..! :
;..: ;
face// 
.// 	
elementGroup//	 
=// 
-// 
$num// 
;// 
face00 
.00 	
textureGroup00	 
=00 
-00 
$num00 
;00 
face11 
.11 	
manualUV11	 
=11 
false11 
;11 
}22 
mesh44 
.44 
	RefreshUV44 
(44 
faces44 
)44 
;44 
var55  
unmodifiedProjection55 
=55 
mesh55 "
.55" #
texturesInternal55# 3
;553 4
foreach77 

(77 
var77 
face77 
in77 
faces77 
)77 
{88 
var99 
trs99 
=99 
CalculateDelta99 
(99  
unmodifiedProjection99 1
,991 2
face993 7
.997 8
indexesInternal998 G
,99G H
destinationTextures99I \
,99\ ]
face99^ b
.99b c
indexesInternal99c r
)99r s
;99s t
var:: 
uv:: 

=:: 
face:: 
.:: 
uv:: 
;:: 
uv?? 
.?? 
offset?? 
=?? 
-?? 
trs?? 
.?? 
translation??  
;??  !
uv@@ 
.@@ 
rotation@@ 
=@@ 
trs@@ 
.@@ 
rotation@@ 
;@@ 
uvAA 
.AA 
scaleAA 
=AA 
trsAA 
.AA 
scaleAA 
;AA 
faceBB 
.BB 	
uvBB	 
=BB 
uvBB 
;BB 
}CC 
meshEE 
.EE 
	RefreshUVEE 
(EE 
facesEE 
)EE 
;EE 
}FF 
internalHH 

structHH 
UVTransformHH 
{II 
publicJJ 	
Vector2JJ
 
translationJJ 
;JJ 
publicKK 	
floatKK
 
rotationKK 
;KK 
publicLL 	
Vector2LL
 
scaleLL 
;LL 
publicNN 	
overrideNN
 
stringNN 
ToStringNN "
(NN" #
)NN# $
{OO 
returnPP 

translationPP 
.PP 
ToStringPP 
(PP  
$strPP  $
)PP$ %
+PP& '
$strPP( ,
+PP- .
rotationPP/ 7
+PP8 9
$strPP: >
+PP? @
scalePPA F
.PPF G
ToStringPPG O
(PPO P
$strPPP T
)PPT U
;PPU V
}QQ 
}RR 
staticTT 
ListTT	 
<TT 
Vector2TT 
>TT )
s_UVTransformProjectionBufferTT 4
=TT5 6
newTT7 :
ListTT; ?
<TT? @
Vector2TT@ G
>TTG H
(TTH I
$numTTI J
)TTJ K
;TTK L
internal\\ 
static\\ 
AutoUnwrapSettings\\ *!
GetAutoUnwrapSettings\\+ @
(\\@ A
ProBuilderMesh\\A O
mesh\\P T
,\\T U
Face\\V Z
face\\[ _
)\\_ `
{]] 	
if^^ 
(^^ 
!^^ 
face^^ 
.^^ 
manualUV^^ 
)^^ 
return__ 
new__ 
AutoUnwrapSettings__ -
(__- .
face__. 2
.__2 3
uv__3 5
)__5 6
;__6 7
varaa 
trsaa 
=aa 
GetUVTransformaa $
(aa$ %
meshaa% )
,aa) *
faceaa+ /
)aa/ 0
;aa0 1
varbb 

uvSettingsbb 
=bb 
AutoUnwrapSettingsbb /
.bb/ 0%
defaultAutoUnwrapSettingsbb0 I
;bbI J

uvSettingscc 
.cc 
offsetcc 
=cc 
trscc  #
.cc# $
translationcc$ /
;cc/ 0

uvSettingsdd 
.dd 
rotationdd 
=dd  !
$numdd" %
-dd& '
trsdd( +
.dd+ ,
rotationdd, 4
;dd4 5

uvSettingsee 
.ee 
scaleee 
=ee 

uvSettingsee )
.ee) *
scaleee* /
/ee/ 0
trsee0 3
.ee3 4
scaleee4 9
;ee9 :
returngg 

uvSettingsgg 
;gg 
}hh 	
internalqq 
staticqq 
UVTransformqq #
GetUVTransformqq$ 2
(qq2 3
ProBuilderMeshqq3 A
meshqqB F
,qqF G
FaceqqH L
faceqqM Q
)qqQ R
{rr 

Projectionss 
.ss 
PlanarProjectss 
(ss 
meshss  
.ss  !
positionsInternalss! 2
,ss2 3
facess4 8
.ss8 9
indexesInternalss9 H
,ssH I
MathssJ N
.ssN O
NormalssO U
(ssU V
meshssV Z
,ssZ [
facess\ `
)ss` a
,ssa b*
s_UVTransformProjectionBuffer	ssc Ä
)
ssÄ Å
;
ssÅ Ç
returntt 	
CalculateDeltatt
 
(tt 
meshtt 
.tt 
texturesInternaltt .
,tt. /
facett0 4
.tt4 5
indexesInternaltt5 D
,ttD E)
s_UVTransformProjectionBufferttF c
,ttc d
nulltte i
)tti j
;ttj k
}uu 
staticyy 
intyy	 
GetIndexyy 
(yy 
IListyy 
<yy 
intyy 
>yy  

collectionyy! +
,yy+ ,
intyy- 0
indexyy1 6
)yy6 7
{zz 
return{{ 	

collection{{
 
=={{ 
null{{ 
?{{ 
index{{ $
:{{% &

collection{{' 1
[{{1 2
index{{2 7
]{{7 8
;{{8 9
}|| 
internal
ÄÄ 

static
ÄÄ 
UVTransform
ÄÄ 
CalculateDelta
ÄÄ ,
(
ÄÄ, -
IList
ÄÄ- 2
<
ÄÄ2 3
Vector2
ÄÄ3 :
>
ÄÄ: ;
src
ÄÄ< ?
,
ÄÄ? @
IList
ÄÄA F
<
ÄÄF G
int
ÄÄG J
>
ÄÄJ K

srcIndices
ÄÄL V
,
ÄÄV W
IList
ÄÄX ]
<
ÄÄ] ^
Vector2
ÄÄ^ e
>
ÄÄe f
dst
ÄÄg j
,
ÄÄj k
IList
ÄÄl q
<
ÄÄq r
int
ÄÄr u
>
ÄÄu v

dstIndicesÄÄw Å
)ÄÄÅ Ç
{
ÅÅ 	
Vector2
ÉÉ	 
dstAngle
ÉÉ 
=
ÉÉ 
dst
ÉÉ 
[
ÉÉ  
GetIndex
ÉÉ  (
(
ÉÉ( )

dstIndices
ÉÉ) 3
,
ÉÉ3 4
$num
ÉÉ5 6
)
ÉÉ6 7
]
ÉÉ7 8
-
ÉÉ9 :
dst
ÉÉ; >
[
ÉÉ> ?
GetIndex
ÉÉ? G
(
ÉÉG H

dstIndices
ÉÉH R
,
ÉÉR S
$num
ÉÉT U
)
ÉÉU V
]
ÉÉV W
;
ÉÉW X
Vector2
ÑÑ	 
srcAngle
ÑÑ 
=
ÑÑ 
src
ÑÑ 
[
ÑÑ  
GetIndex
ÑÑ  (
(
ÑÑ( )

srcIndices
ÑÑ) 3
,
ÑÑ3 4
$num
ÑÑ5 6
)
ÑÑ6 7
]
ÑÑ7 8
-
ÑÑ9 :
src
ÑÑ; >
[
ÑÑ> ?
GetIndex
ÑÑ? G
(
ÑÑG H

srcIndices
ÑÑH R
,
ÑÑR S
$num
ÑÑT U
)
ÑÑU V
]
ÑÑV W
;
ÑÑW X
float
ÜÜ	 
rotation
ÜÜ 
=
ÜÜ 
Vector2
ÜÜ !
.
ÜÜ! "
Angle
ÜÜ" '
(
ÜÜ' (
dstAngle
ÜÜ( 0
,
ÜÜ0 1
srcAngle
ÜÜ2 :
)
ÜÜ: ;
;
ÜÜ; <
if
àà	 
(
àà 
Vector2
àà 
.
àà 
Dot
àà 
(
àà 
Vector2
àà  
.
àà  !
Perpendicular
àà! .
(
àà. /
dstAngle
àà/ 7
)
àà7 8
,
àà8 9
srcAngle
àà: B
)
ààB C
<
ààD E
$num
ààF G
)
ààG H
rotation
ââ
 
=
ââ 
$num
ââ 
-
ââ 
rotation
ââ $
;
ââ$ %
Vector2
ãã	 
	dstCenter
ãã 
=
ãã 

dstIndices
ãã '
==
ãã( *
null
ãã+ /
?
ãã0 1
Bounds2D
ãã2 :
.
ãã: ;
Center
ãã; A
(
ããA B
dst
ããB E
)
ããE F
:
ããG H
Bounds2D
ããI Q
.
ããQ R
Center
ããR X
(
ããX Y
dst
ããY \
,
ãã\ ]

dstIndices
ãã^ h
)
ããh i
;
ããi j
Vector2
éé	 
dstSize
éé 
=
éé 
GetRotatedSize
éé )
(
éé) *
dst
éé* -
,
éé- .

dstIndices
éé/ 9
,
éé9 :
	dstCenter
éé; D
,
ééD E
-
ééF G
rotation
ééG O
)
ééO P
;
ééP Q
var
êê	 
	srcBounds
êê 
=
êê 

srcIndices
êê #
==
êê$ &
null
êê' +
?
êê, -
new
êê. 1
Bounds2D
êê2 :
(
êê: ;
src
êê; >
)
êê> ?
:
êê@ A
new
êêB E
Bounds2D
êêF N
(
êêN O
src
êêO R
,
êêR S

srcIndices
êêT ^
)
êê^ _
;
êê_ `
return
íí 	
new
íí
 
UVTransform
íí 
(
íí 
)
íí 
{
ìì 
translation
îî 
=
îî 
	dstCenter
îî 
-
îî 
	srcBounds
îî '
.
îî' (
center
îî( .
,
îî. /
rotation
ïï 
=
ïï 
rotation
ïï 
,
ïï 
scale
ññ 	
=
ññ
 
dstSize
ññ 
.
ññ 
DivideBy
ññ 
(
ññ 
	srcBounds
ññ &
.
ññ& '
size
ññ' +
)
ññ+ ,
}
óó 
;
óó 
}
òò 	
static
öö 
Vector2
öö 
GetRotatedSize
öö %
(
öö% &
IList
öö& +
<
öö+ ,
Vector2
öö, 3
>
öö3 4
points
öö5 ;
,
öö; <
IList
öö= B
<
ööB C
int
ööC F
>
ööF G
indices
ööH O
,
ööO P
Vector2
ööQ X
center
ööY _
,
öö_ `
float
ööa f
rotation
öög o
)
ööo p
{
õõ 	
int
úú	 
size
úú 
=
úú 
indices
úú 
==
úú 
null
úú #
?
úú$ %
points
úú& ,
.
úú, -
Count
úú- 2
:
úú3 4
indices
úú5 <
.
úú< =
Count
úú= B
;
úúB C
Vector2
ûû	 
point
ûû 
=
ûû 
points
ûû 
[
ûû  
GetIndex
ûû  (
(
ûû( )
indices
ûû) 0
,
ûû0 1
$num
ûû2 3
)
ûû3 4
]
ûû4 5
.
ûû5 6
RotateAroundPoint
ûû6 G
(
ûûG H
center
ûûH N
,
ûûN O
rotation
ûûP X
)
ûûX Y
;
ûûY Z
float
††	 
xMin
†† 
=
†† 
point
†† 
.
†† 
x
†† 
;
†† 
float
°°	 
yMin
°° 
=
°° 
point
°° 
.
°° 
y
°° 
;
°° 
float
¢¢	 
xMax
¢¢ 
=
¢¢ 
xMin
¢¢ 
;
¢¢ 
float
££	 
yMax
££ 
=
££ 
yMin
££ 
;
££ 
for
••	 
(
•• 
int
•• 
i
•• 
=
•• 
$num
•• 
;
•• 
i
•• 
<
•• 
size
•• !
;
••! "
i
••# $
++
••$ &
)
••& '
{
¶¶	 

point
ßß
 
=
ßß 
points
ßß 
[
ßß 
GetIndex
ßß !
(
ßß! "
indices
ßß" )
,
ßß) *
i
ßß+ ,
)
ßß, -
]
ßß- .
.
ßß. /
RotateAroundPoint
ßß/ @
(
ßß@ A
center
ßßA G
,
ßßG H
rotation
ßßI Q
)
ßßQ R
;
ßßR S
float
©©
 
x
©© 
=
©© 
point
©© 
.
©© 
x
©© 
;
©© 
float
™™
 
y
™™ 
=
™™ 
point
™™ 
.
™™ 
y
™™ 
;
™™ 
if
¨¨
 
(
¨¨ 
x
¨¨ 
<
¨¨ 
xMin
¨¨ 
)
¨¨ 
xMin
¨¨ 
=
¨¨ 
x
¨¨  
;
¨¨  !
if
≠≠
 
(
≠≠ 
x
≠≠ 
>
≠≠ 
xMax
≠≠ 
)
≠≠ 
xMax
≠≠ 
=
≠≠ 
x
≠≠  
;
≠≠  !
if
ØØ
 
(
ØØ 
y
ØØ 
<
ØØ 
yMin
ØØ 
)
ØØ 
yMin
ØØ 
=
ØØ 
y
ØØ  
;
ØØ  !
if
∞∞
 
(
∞∞ 
y
∞∞ 
>
∞∞ 
yMax
∞∞ 
)
∞∞ 
yMax
∞∞ 
=
∞∞ 
y
∞∞  
;
∞∞  !
}
±±	 

return
≥≥	 
new
≥≥ 
Vector2
≥≥ 
(
≥≥ 
xMax
≥≥  
-
≥≥! "
xMin
≥≥# '
,
≥≥' (
yMax
≥≥) -
-
≥≥. /
yMin
≥≥0 4
)
≥≥4 5
;
≥≥5 6
}
¥¥ 	
}
µµ 
}∂∂ ˆ∆
èD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\PreferenceKeys.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static		 

class		 
PreferenceKeys		 
{

 
public 
const 
string 
pluginTitle '
=( )
$str* 6
;6 7
internal 
const 
float )
k_MaxPointDistanceFromControl :
=; <
$num= @
;@ A
internal 
const 
char 
DEGREE_SYMBOL )
=, -
(. /
char/ 3
)3 4
$num4 7
;7 8
internal 
const 
char 
	CMD_SUPER %
=, -
$char. 6
;6 7
internal 
const 
char 
	CMD_SHIFT %
=, -
$char. 6
;6 7
internal 
const 
char 

CMD_OPTION &
=, -
$char. 6
;6 7
internal 
const 
char 
CMD_ALT #
=, -
$char. 6
;6 7
internal 
const 
char 

CMD_DELETE &
=, -
$char. 6
;6 7
internal 
static 
readonly  
Color! &
proBuilderBlue' 5
=6 7
new8 ;
Color< A
(A B
$numB D
,D E
$numF K
,K L
$numM R
,R S
$numT V
)V W
;W X
internal 
static 
readonly  
Color! &
proBuilderLightGray' :
=; <
new= @
ColorA F
(F G
$numG K
,K L
$numM Q
,Q R
$numS W
,W X
$numY \
)\ ]
;] ^
internal 
static 
readonly  
Color! &
proBuilderDarkGray' 9
=: ;
new< ?
Color@ E
(E F
$numF I
,I J
$numK N
,N O
$numP S
,S T
$numU X
)X Y
;Y Z
public 
const 
int 

menuEditor #
=$ %
$num& )
;) *
public$$ 
const$$ 
int$$ 
menuSelection$$ &
=$$' (
$num$$) ,
;$$, -
public)) 
const)) 
int)) 
menuGeometry)) %
=))& '
$num))( +
;))+ ,
public.. 
const.. 
int.. 
menuActions.. $
=..% &
$num..' *
;..* +
public33 
const33 
int33 
menuMaterialColors33 +
=33, -
$num33. 1
;331 2
public88 
const88 
int88 
menuVertexColors88 )
=88* +
$num88, /
;88/ 0
public== 
const== 
int== 

menuRepair== #
===$ %
$num==& )
;==) *
publicBB 
constBB 
intBB 
menuMiscBB !
=BB" #
$numBB$ '
;BB' (
publicGG 
constGG 
intGG 

menuExportGG #
=GG$ %
$numGG& )
;GG) *
[II 	
ObsoleteII	 
(II 
$strII ;
)II; <
]II< =
internalJJ 
constJJ 
stringJJ 
pbDefaultEditLevelJJ 0
=JJ1 2
$strJJ3 G
;JJG H
[KK 	
ObsoleteKK	 
(KK 
$strKK ;
)KK; <
]KK< =
internalLL 
constLL 
stringLL "
pbDefaultSelectionModeLL 4
=LL5 6
$strLL7 O
;LLO P
[MM 	
ObsoleteMM	 
(MM 
$strMM ;
)MM; <
]MM< =
internalNN 
constNN 
stringNN 
pbHandleAlignmentNN /
=NN0 1
$strNN2 E
;NNE F
[OO 	
ObsoleteOO	 
(OO 
$strOO ;
)OO; <
]OO< =
internalPP 
constPP 
stringPP 
pbVertexColorToolPP /
=PP0 1
$strPP2 E
;PPE F
[QQ 	
ObsoleteQQ	 
(QQ 
$strQQ ;
)QQ; <
]QQ< =
internalRR 
constRR 
stringRR 
pbToolbarLocationRR /
=RR0 1
$strRR2 E
;RRE F
[SS 	
ObsoleteSS	 
(SS 
$strSS ;
)SS; <
]SS< =
internalTT 
constTT 
stringTT 
pbDefaultEntityTT -
=TT. /
$strTT0 A
;TTA B
[UU 	
ObsoleteUU	 
(UU 
$strUU ;
)UU; <
]UU< =
internalVV 
constVV 
stringVV 
pbExtrudeMethodVV -
=VV. /
$strVV0 A
;VVA B
[WW 	
ObsoleteWW	 
(WW 
$strWW ;
)WW; <
]WW< =
internalXX 
constXX 
stringXX  
pbDefaultStaticFlagsXX 2
=XX3 4
$strXX5 K
;XXK L
[YY 	
ObsoleteYY	 
(YY 
$strYY ;
)YY; <
]YY< =
internalZZ 
constZZ 
stringZZ 
pbSelectedFaceColorZZ 1
=ZZ2 3
$strZZ4 H
;ZZH I
[[[ 	
Obsolete[[	 
([[ 
$str[[ ;
)[[; <
][[< =
internal\\ 
const\\ 
string\\ 
pbWireframeColor\\ .
=\\/ 0
$str\\1 E
;\\E F
[]] 	
Obsolete]]	 
(]] 
$str]] ;
)]]; <
]]]< =
internal^^ 
const^^ 
string^^ !
pbUnselectedEdgeColor^^ 3
=^^4 5
$str^^6 M
;^^M N
[__ 	
Obsolete__	 
(__ 
$str__ ;
)__; <
]__< =
internal`` 
const`` 
string`` 
pbSelectedEdgeColor`` 1
=``2 3
$str``4 I
;``I J
[aa 	
Obsoleteaa	 
(aa 
$straa ;
)aa; <
]aa< =
internalbb 
constbb 
stringbb !
pbSelectedVertexColorbb 3
=bb4 5
$strbb6 T
;bbT U
[cc 	
Obsoletecc	 
(cc 
$strcc ;
)cc; <
]cc< =
internaldd 
constdd 
stringdd #
pbUnselectedVertexColordd 5
=dd6 7
$strdd8 N
;ddN O
[ee 	
Obsoleteee	 
(ee 
$stree ;
)ee; <
]ee< =
internalff 
constff 
stringff 
pbPreselectionColorff 1
=ff2 3
$strff4 I
;ffI J
[gg 	
Obsoletegg	 
(gg 
$strgg ;
)gg; <
]gg< =
internalhh 
consthh 
stringhh )
pbDefaultOpenInDockableWindowhh ;
=hh< =
$strhh> ]
;hh] ^
[ii 	
Obsoleteii	 
(ii 
$strii ;
)ii; <
]ii< =
internaljj 
constjj 
stringjj 
pbEditorPrefVersionjj 1
=jj2 3
$strjj4 I
;jjI J
[kk 	
Obsoletekk	 
(kk 
$strkk ;
)kk; <
]kk< =
internalll 
constll 
stringll $
pbEditorShortcutsVersionll 6
=ll7 8
$strll9 S
;llS T
[mm 	
Obsoletemm	 
(mm 
$strmm ;
)mm; <
]mm< =
internalnn 
constnn 
stringnn 
pbDefaultCollidernn /
=nn0 1
$strnn2 E
;nnE F
[oo 	
Obsoleteoo	 
(oo 
$stroo ;
)oo; <
]oo< =
internalpp 
constpp 
stringpp 
pbForceConvexpp +
=pp, -
$strpp. =
;pp= >
[qq 	
Obsoleteqq	 
(qq 
$strqq ;
)qq; <
]qq< =
internalrr 
constrr 
stringrr 
pbVertexColorPrefsrr 0
=rr1 2
$strrr3 G
;rrG H
[ss 	
Obsoletess	 
(ss 
$strss ;
)ss; <
]ss< =
internaltt 
consttt 
stringtt %
pbShowEditorNotificationstt 7
=tt8 9
$strtt: U
;ttU V
[uu 	
Obsoleteuu	 
(uu 
$struu ;
)uu; <
]uu< =
internalvv 
constvv 
stringvv 
pbDragCheckLimitvv .
=vv/ 0
$strvv1 C
;vvC D
[ww 	
Obsoleteww	 
(ww 
$strww ;
)ww; <
]ww< =
internalxx 
constxx 
stringxx 
pbForceVertexPivotxx 0
=xx1 2
$strxx3 G
;xxG H
[yy 	
Obsoleteyy	 
(yy 
$stryy ;
)yy; <
]yy< =
internalzz 
constzz 
stringzz 
pbForceGridPivotzz .
=zz/ 0
$strzz1 C
;zzC D
[{{ 	
Obsolete{{	 
({{ 
$str{{ ;
){{; <
]{{< =
internal|| 
const|| 
string|| #
pbManifoldEdgeExtrusion|| 5
=||6 7
$str||8 Q
;||Q R
[}} 	
Obsolete}}	 
(}} 
$str}} ;
)}}; <
]}}< =
internal~~ 
const~~ 
string~~ %
pbPerimeterEdgeBridgeOnly~~ 7
=~~8 9
$str~~: U
;~~U V
[ 	
Obsolete	 
( 
$str ;
); <
]< =
internal
ÄÄ 
const
ÄÄ 
string
ÄÄ  
pbPBOSelectionOnly
ÄÄ 0
=
ÄÄ1 2
$str
ÄÄ3 G
;
ÄÄG H
[
ÅÅ 	
Obsolete
ÅÅ	 
(
ÅÅ 
$str
ÅÅ ;
)
ÅÅ; <
]
ÅÅ< =
internal
ÇÇ 
const
ÇÇ 
string
ÇÇ  
pbCloseShapeWindow
ÇÇ 0
=
ÇÇ1 2
$str
ÇÇ3 G
;
ÇÇG H
[
ÉÉ 	
Obsolete
ÉÉ	 
(
ÉÉ 
$str
ÉÉ ;
)
ÉÉ; <
]
ÉÉ< =
internal
ÑÑ 
const
ÑÑ 
string
ÑÑ  
pbUVEditorFloating
ÑÑ 0
=
ÑÑ1 2
$str
ÑÑ3 G
;
ÑÑG H
[
ÖÖ 	
Obsolete
ÖÖ	 
(
ÖÖ 
$str
ÖÖ ;
)
ÖÖ; <
]
ÖÖ< =
internal
ÜÜ 
const
ÜÜ 
string
ÜÜ !
pbUVMaterialPreview
ÜÜ 1
=
ÜÜ2 3
$str
ÜÜ4 I
;
ÜÜI J
[
áá 	
Obsolete
áá	 
(
áá 
$str
áá ;
)
áá; <
]
áá< =
internal
àà 
const
àà 
string
àà  
pbShowSceneToolbar
àà 0
=
àà1 2
$str
àà3 G
;
ààG H
[
ââ 	
Obsolete
ââ	 
(
ââ 
$str
ââ ;
)
ââ; <
]
ââ< =
internal
ää 
const
ää 
string
ää .
 pbNormalizeUVsOnPlanarProjection
ää >
=
ää? @
$str
ääA c
;
ääc d
[
ãã 	
Obsolete
ãã	 
(
ãã 
$str
ãã ;
)
ãã; <
]
ãã< =
internal
åå 
const
åå 
string
åå &
pbStripProBuilderOnBuild
åå 6
=
åå7 8
$str
åå9 S
;
ååS T
[
çç 	
Obsolete
çç	 
(
çç 
$str
çç ;
)
çç; <
]
çç< =
internal
éé 
const
éé 
string
éé (
pbDisableAutoUV2Generation
éé 8
=
éé9 :
$str
éé; W
;
ééW X
[
èè 	
Obsolete
èè	 
(
èè 
$str
èè ;
)
èè; <
]
èè< =
internal
êê 
const
êê 
string
êê 
pbShowSceneInfo
êê -
=
êê. /
$str
êê0 A
;
êêA B
[
ëë 	
Obsolete
ëë	 
(
ëë 
$str
ëë ;
)
ëë; <
]
ëë< =
internal
íí 
const
íí 
string
íí '
pbEnableBackfaceSelection
íí 7
=
íí8 9
$str
íí: U
;
ííU V
[
ìì 	
Obsolete
ìì	 
(
ìì 
$str
ìì ;
)
ìì; <
]
ìì< =
internal
îî 
const
îî 
string
îî %
pbVertexPaletteDockable
îî 5
=
îî6 7
$str
îî8 Q
;
îîQ R
[
ïï 	
Obsolete
ïï	 
(
ïï 
$str
ïï ;
)
ïï; <
]
ïï< =
internal
ññ 
const
ññ 
string
ññ 
pbExtrudeAsGroup
ññ .
=
ññ/ 0
$str
ññ1 C
;
ññC D
[
óó 	
Obsolete
óó	 
(
óó 
$str
óó ;
)
óó; <
]
óó< =
internal
òò 
const
òò 
string
òò #
pbUniqueModeShortcuts
òò 3
=
òò4 5
$str
òò6 M
;
òòM N
[
ôô 	
Obsolete
ôô	 
(
ôô 
$str
ôô ;
)
ôô; <
]
ôô< =
internal
öö 
const
öö 
string
öö &
pbMaterialEditorFloating
öö 6
=
öö7 8
$str
öö9 S
;
ööS T
[
õõ 	
Obsolete
õõ	 
(
õõ 
$str
õõ ;
)
õõ; <
]
õõ< =
internal
úú 
const
úú 
string
úú #
pbShapeWindowFloating
úú 3
=
úú4 5
$str
úú6 M
;
úúM N
[
ùù 	
Obsolete
ùù	 
(
ùù 
$str
ùù ;
)
ùù; <
]
ùù< =
internal
ûû 
const
ûû 
string
ûû 
	pbIconGUI
ûû '
=
ûû( )
$str
ûû* 5
;
ûû5 6
[
üü 	
Obsolete
üü	 
(
üü 
$str
üü ;
)
üü; <
]
üü< =
internal
†† 
const
†† 
string
†† !
pbShiftOnlyTooltips
†† 1
=
††2 3
$str
††4 I
;
††I J
[
°° 	
Obsolete
°°	 
(
°° 
$str
°° ;
)
°°; <
]
°°< =
internal
¢¢ 
const
¢¢ 
string
¢¢ 
pbDrawAxisLines
¢¢ -
=
¢¢. /
$str
¢¢0 A
;
¢¢A B
[
££ 	
Obsolete
££	 
(
££ 
$str
££ ;
)
££; <
]
££< =
internal
§§ 
const
§§ 
string
§§ %
pbCollapseVertexToFirst
§§ 5
=
§§6 7
$str
§§8 Q
;
§§Q R
[
•• 	
Obsolete
••	 
(
•• 
$str
•• ;
)
••; <
]
••< =
internal
¶¶ 
const
¶¶ 
string
¶¶ 
pbMeshesAreAssets
¶¶ /
=
¶¶0 1
$str
¶¶2 E
;
¶¶E F
[
ßß 	
Obsolete
ßß	 
(
ßß 
$str
ßß ;
)
ßß; <
]
ßß< =
internal
®® 
const
®® 
string
®® (
pbElementSelectIsHamFisted
®® 8
=
®®9 :
$str
®®; W
;
®®W X
[
©© 	
Obsolete
©©	 
(
©© 
$str
©© ;
)
©©; <
]
©©< =
internal
™™ 
const
™™ 
string
™™ )
pbFillHoleSelectsEntirePath
™™ 9
=
™™: ;
$str
™™< Y
;
™™Y Z
[
´´ 	
Obsolete
´´	 
(
´´ 
$str
´´ ;
)
´´; <
]
´´< =
internal
¨¨ 
const
¨¨ 
string
¨¨ !
pbDetachToNewObject
¨¨ 1
=
¨¨2 3
$str
¨¨4 I
;
¨¨I J
[
≠≠ 	
Obsolete
≠≠	 
(
≠≠ 
$str
≠≠ ;
)
≠≠; <
]
≠≠< =
internal
ÆÆ 
const
ÆÆ 
string
ÆÆ 
pbPreserveFaces
ÆÆ -
=
ÆÆ. /
$str
ÆÆ0 A
;
ÆÆA B
[
ØØ 	
Obsolete
ØØ	 
(
ØØ 
$str
ØØ ;
)
ØØ; <
]
ØØ< =
internal
∞∞ 
const
∞∞ 
string
∞∞ &
pbDragSelectWholeElement
∞∞ 6
=
∞∞7 8
$str
∞∞9 S
;
∞∞S T
[
±± 	
Obsolete
±±	 
(
±± 
$str
±± ;
)
±±; <
]
±±< =
internal
≤≤ 
const
≤≤ 
string
≤≤ )
pbShowPreselectionHighlight
≤≤ 9
=
≤≤: ;
$str
≤≤< Y
;
≤≤Y Z
[
≥≥ 	
Obsolete
≥≥	 
(
≥≥ 
$str
≥≥ ;
)
≥≥; <
]
≥≥< =
internal
¥¥ 
const
¥¥ 
string
¥¥ 
pbRectSelectMode
¥¥ .
=
¥¥/ 0
$str
¥¥1 C
;
¥¥C D
[
µµ 	
Obsolete
µµ	 
(
µµ 
$str
µµ ;
)
µµ; <
]
µµ< =
internal
∂∂ 
const
∂∂ 
string
∂∂ 
pbDragSelectMode
∂∂ .
=
∂∂/ 0
$str
∂∂1 C
;
∂∂C D
[
∑∑ 	
Obsolete
∑∑	 
(
∑∑ 
$str
∑∑ ;
)
∑∑; <
]
∑∑< =
internal
∏∏ 
const
∏∏ 
string
∏∏ !
pbShadowCastingMode
∏∏ 1
=
∏∏2 3
$str
∏∏4 I
;
∏∏I J
[
ππ 	
Obsolete
ππ	 
(
ππ 
$str
ππ ;
)
ππ; <
]
ππ< =
internal
∫∫ 
const
∫∫ 
string
∫∫ "
pbEnableExperimental
∫∫ 2
=
∫∫3 4
$str
∫∫5 K
;
∫∫K L
[
ªª 	
Obsolete
ªª	 
(
ªª 
$str
ªª ;
)
ªª; <
]
ªª< =
internal
ºº 
const
ºº 
string
ºº )
pbCheckForProBuilderUpdates
ºº 9
=
ºº: ;
$str
ºº< Y
;
ººY Z
[
ΩΩ 	
Obsolete
ΩΩ	 
(
ΩΩ 
$str
ΩΩ ;
)
ΩΩ; <
]
ΩΩ< =
internal
ææ 
const
ææ 
string
ææ ,
pbManageLightmappingStaticFlag
ææ <
=
ææ= >
$str
ææ? _
;
ææ_ `
[
øø 	
Obsolete
øø	 
(
øø 
$str
øø ;
)
øø; <
]
øø< =
internal
¿¿ 
const
¿¿ 
string
¿¿ ,
pbShowMissingLightmapUvWarning
¿¿ <
=
¿¿= >
$str
¿¿? n
;
¿¿n o
[
¡¡ 	
Obsolete
¡¡	 
(
¡¡ 
$str
¡¡ ;
)
¡¡; <
]
¡¡< =
internal
¬¬ 
const
¬¬ 
string
¬¬ "
pbSelectedFaceDither
¬¬ 2
=
¬¬3 4
$str
¬¬5 K
;
¬¬K L
[
√√ 	
Obsolete
√√	 
(
√√ 
$str
√√ ;
)
√√; <
]
√√< =
internal
ƒƒ 
const
ƒƒ 
string
ƒƒ 
pbUseUnityColors
ƒƒ .
=
ƒƒ/ 0
$str
ƒƒ1 C
;
ƒƒC D
[
≈≈ 	
Obsolete
≈≈	 
(
≈≈ 
$str
≈≈ ;
)
≈≈; <
]
≈≈< =
internal
∆∆ 
const
∆∆ 
string
∆∆  
pbVertexHandleSize
∆∆ 0
=
∆∆1 2
$str
∆∆3 G
;
∆∆G H
[
«« 	
Obsolete
««	 
(
«« 
$str
«« ;
)
««; <
]
««< =
internal
»» 
const
»» 
string
»» 
pbUVGridSnapValue
»» /
=
»»0 1
$str
»»2 E
;
»»E F
[
…… 	
Obsolete
……	 
(
…… 
$str
…… ;
)
……; <
]
……< =
internal
   
const
   
string
   
pbUVWeldDistance
   .
=
  / 0
$str
  1 C
;
  C D
[
ÀÀ 	
Obsolete
ÀÀ	 
(
ÀÀ 
$str
ÀÀ ;
)
ÀÀ; <
]
ÀÀ< =
internal
ÃÃ 
const
ÃÃ 
string
ÃÃ 
pbLineHandleSize
ÃÃ .
=
ÃÃ/ 0
$str
ÃÃ1 C
;
ÃÃC D
[
ÕÕ 	
Obsolete
ÕÕ	 
(
ÕÕ 
$str
ÕÕ ;
)
ÕÕ; <
]
ÕÕ< =
internal
ŒŒ 
const
ŒŒ 
string
ŒŒ 
pbWireframeSize
ŒŒ -
=
ŒŒ. /
$str
ŒŒ0 A
;
ŒŒA B
[
œœ 	
Obsolete
œœ	 
(
œœ 
$str
œœ ;
)
œœ; <
]
œœ< =
internal
–– 
const
–– 
string
–– 
pbWeldDistance
–– ,
=
––- .
$str
––/ ?
;
––? @
[
—— 	
Obsolete
——	 
(
—— 
$str
—— ;
)
——; <
]
——< =
internal
““ 
const
““ 
string
““ 
pbExtrudeDistance
““ /
=
““0 1
$str
““2 E
;
““E F
[
”” 	
Obsolete
””	 
(
”” 
$str
”” ;
)
””; <
]
””< =
internal
‘‘ 
const
‘‘ 
string
‘‘ 
pbBevelAmount
‘‘ +
=
‘‘, -
$str
‘‘. =
;
‘‘= >
[
’’ 	
Obsolete
’’	 
(
’’ 
$str
’’ ;
)
’’; <
]
’’< =
internal
÷÷ 
const
÷÷ 
string
÷÷  
pbEdgeSubdivisions
÷÷ 0
=
÷÷1 2
$str
÷÷3 G
;
÷÷G H
[
◊◊ 	
Obsolete
◊◊	 
(
◊◊ 
$str
◊◊ ;
)
◊◊; <
]
◊◊< =
internal
ÿÿ 
const
ÿÿ 
string
ÿÿ  
pbDefaultShortcuts
ÿÿ 0
=
ÿÿ1 2
$str
ÿÿ3 G
;
ÿÿG H
[
ŸŸ 	
Obsolete
ŸŸ	 
(
ŸŸ 
$str
ŸŸ ;
)
ŸŸ; <
]
ŸŸ< =
internal
⁄⁄ 
const
⁄⁄ 
string
⁄⁄ 
pbDefaultMaterial
⁄⁄ /
=
⁄⁄0 1
$str
⁄⁄2 E
;
⁄⁄E F
[
€€ 	
Obsolete
€€	 
(
€€ 
$str
€€ ;
)
€€; <
]
€€< =
internal
‹‹ 
const
‹‹ 
string
‹‹ &
pbCurrentMaterialPalette
‹‹ 6
=
‹‹7 8
$str
‹‹9 S
;
‹‹S T
[
›› 	
Obsolete
››	 
(
›› 
$str
›› ;
)
››; <
]
››< =
internal
ﬁﬁ 
const
ﬁﬁ 
string
ﬁﬁ '
pbGrowSelectionUsingAngle
ﬁﬁ 7
=
ﬁﬁ8 9
$str
ﬁﬁ: U
;
ﬁﬁU V
[
ﬂﬂ 	
Obsolete
ﬂﬂ	 
(
ﬂﬂ 
$str
ﬂﬂ ;
)
ﬂﬂ; <
]
ﬂﬂ< =
internal
‡‡ 
const
‡‡ 
string
‡‡ "
pbGrowSelectionAngle
‡‡ 2
=
‡‡3 4
$str
‡‡5 K
;
‡‡K L
[
·· 	
Obsolete
··	 
(
·· 
$str
·· ;
)
··; <
]
··< =
internal
‚‚ 
const
‚‚ 
string
‚‚ +
pbGrowSelectionAngleIterative
‚‚ ;
=
‚‚< =
$str
‚‚> ]
;
‚‚] ^
[
„„ 	
Obsolete
„„	 
(
„„ 
$str
„„ ;
)
„„; <
]
„„< =
internal
‰‰ 
const
‰‰ 
string
‰‰ 
pbShowDetail
‰‰ *
=
‰‰+ ,
$str
‰‰- ;
;
‰‰; <
[
ÂÂ 	
Obsolete
ÂÂ	 
(
ÂÂ 
$str
ÂÂ ;
)
ÂÂ; <
]
ÂÂ< =
internal
ÊÊ 
const
ÊÊ 
string
ÊÊ 
pbShowOccluder
ÊÊ ,
=
ÊÊ- .
$str
ÊÊ/ ?
;
ÊÊ? @
[
ÁÁ 	
Obsolete
ÁÁ	 
(
ÁÁ 
$str
ÁÁ ;
)
ÁÁ; <
]
ÁÁ< =
internal
ËË 
const
ËË 
string
ËË 
pbShowMover
ËË )
=
ËË* +
$str
ËË, 9
;
ËË9 :
[
ÈÈ 	
Obsolete
ÈÈ	 
(
ÈÈ 
$str
ÈÈ ;
)
ÈÈ; <
]
ÈÈ< =
internal
ÍÍ 
const
ÍÍ 
string
ÍÍ 
pbShowCollider
ÍÍ ,
=
ÍÍ- .
$str
ÍÍ/ ?
;
ÍÍ? @
[
ÎÎ 	
Obsolete
ÎÎ	 
(
ÎÎ 
$str
ÎÎ ;
)
ÎÎ; <
]
ÎÎ< =
internal
ÏÏ 
const
ÏÏ 
string
ÏÏ 
pbShowTrigger
ÏÏ +
=
ÏÏ, -
$str
ÏÏ. =
;
ÏÏ= >
[
ÌÌ 	
Obsolete
ÌÌ	 
(
ÌÌ 
$str
ÌÌ ;
)
ÌÌ; <
]
ÌÌ< =
internal
ÓÓ 
const
ÓÓ 
string
ÓÓ 
pbShowNoDraw
ÓÓ *
=
ÓÓ+ ,
$str
ÓÓ- ;
;
ÓÓ; <
[
ÔÔ 	
Obsolete
ÔÔ	 
(
ÔÔ 
$str
ÔÔ ;
)
ÔÔ; <
]
ÔÔ< =
internal
 
const
 
string
 %
defaultUnwrapParameters
 5
=
6 7
$str
8 S
;
S T
}
ÒÒ 
}ÚÚ Ñ	
ìD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ProGridsIgnoreSnap.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ 
AttributeUsage 
( 
AttributeTargets $
.$ %
Class% *
,* +
AllowMultiple, 9
=: ;
false< A
,A B
	InheritedC L
=M N
trueO S
)S T
]T U
sealed 

class #
ProGridsNoSnapAttribute (
:) *
	Attribute+ 4
{ 
} 
[ 
AttributeUsage 
( 
AttributeTargets $
.$ %
Class% *
,* +
AllowMultiple, 9
=: ;
false< A
,A B
	InheritedC L
=M N
trueO S
)S T
]T U
sealed 

class ,
 ProGridsConditionalSnapAttribute 1
:2 3
	Attribute4 =
{ 
} 
} Û?
èD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ProBuilderEnum.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[

 
System

 
.

 
Flags

 
]

 
public 

enum 

SelectMode 
{ 
None 
= 
$num 
<< 
$num 
, 
Object 
= 
$num 
<< 
$num 
, 
Vertex 
= 
$num 
<< 
$num 
, 
Edge 
= 
$num 
<< 
$num 
, 
Face$$ 
=$$ 
$num$$ 
<<$$ 
$num$$ 
,$$ 
TextureFace)) 
=)) 
$num)) 
<<)) 
$num)) 
,)) 
TextureEdge.. 
=.. 
$num.. 
<<.. 
$num.. 
,.. 
TextureVertex33 
=33 
$num33 
<<33 
$num33 
,33 
	InputTool88 
=88 
$num88 
<<88 
$num88 
,88 
Any== 
=== 
$num== 
}>> 
enumCC 
ComponentModeCC	 
{DD 
VertexHH 
=HH 
$numHH 
,HH 
EdgeLL 
=LL 
$numLL 
,LL 
FacePP 
=PP 
$numPP 
}QQ 
internalVV 
enumVV 
	EditLevelVV 
{WW 
Top[[ 
=[[ 
$num[[ 
,[[ 
Geometry__ 
=__ 
$num__ 
,__ 
Texturecc 
=cc 
$numcc 
,cc 
Plugingg 
=gg 
$numgg 
}hh 
enummm 

EntityTypemm	 
{nn 
Detailoo 
,oo 
Occluderpp 
,pp 
Triggerqq 
,qq 
Colliderrr 
,rr 
Moverss 
}tt 
enumvv 
ColliderTypevv	 
{ww 
Nonexx 
,xx 
BoxCollideryy 
,yy 
MeshColliderzz 
}{{ 
public
ÄÄ 

enum
ÄÄ 
ProjectionAxis
ÄÄ 
{
ÅÅ 
X
ÖÖ 	
,
ÖÖ	 

Y
ââ 	
,
ââ	 

Z
çç 	
,
çç	 

	XNegative
ëë 
,
ëë 
	YNegative
ïï 
,
ïï 
	ZNegative
ôô 
}
öö 
enum
úú 

HandleAxis
úú	 
{
ùù 
X
ûû 	
=
ûû
 
$num
ûû 
<<
ûû 
$num
ûû 
,
ûû 
Y
üü 	
=
üü
 
$num
üü 
<<
üü 
$num
üü 
,
üü 
Z
†† 	
=
††
 
$num
†† 
<<
†† 
$num
†† 
,
†† 
Free
°° 
=
°° 
$num
°° 
<<
°° 
$num
°° 
}
¢¢ 
[
ßß 
System
ßß 
.
ßß 
Obsolete
ßß 
(
ßß 
$str
ßß '
)
ßß' (
]
ßß( )
enum
®® 
Shape
®®	 
{
©© 
Cube
™™ 
,
™™ 
Stair
´´ 
,
´´ 
Prism
¨¨ 
,
¨¨ 
Cylinder
≠≠ 
,
≠≠ 
Plane
ÆÆ 
,
ÆÆ 
Door
ØØ 
,
ØØ 
Pipe
∞∞ 
,
∞∞ 
Cone
±± 
,
±± 
Sprite
≤≤ 
,
≤≤ 
Arch
≥≥ 
,
≥≥ 
Icosahedron
¥¥ 
,
¥¥ 
Torus
µµ 
,
µµ 
Custom
∂∂ 
}
∑∑ 
public
ºº 

enum
ºº 
Axis
ºº 
{
ΩΩ 
Right
¡¡ 
,
¡¡ 
Left
≈≈ 
,
≈≈ 
Up
…… 

,
……
 
Down
ÕÕ 
,
ÕÕ 
Forward
—— 
,
—— 
Backward
’’ 
}
÷÷ 
public
€€ 

enum
€€ 
WindingOrder
€€ 
{
‹‹ 
Unknown
‡‡ 
,
‡‡ 
	Clockwise
‰‰ 
,
‰‰ 
CounterClockwise
ËË 
}
ÈÈ 
public
ÓÓ 

enum
ÓÓ 

SortMethod
ÓÓ 
{
ÔÔ 
	Clockwise
ÛÛ 
,
ÛÛ 
CounterClockwise
˜˜ 
}
¯¯ 
;
¯¯ 
[
˝˝ 
System
˝˝ 
.
˝˝ 
Flags
˝˝ 
]
˝˝ 
public
˛˛ 

enum
˛˛ 
CullingMode
˛˛ 
{
ˇˇ 
None
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
<<
ÉÉ 
$num
ÉÉ 
,
ÉÉ 
Back
áá 
=
áá 
$num
áá 
<<
áá 
$num
áá 
,
áá 
Front
ãã 
=
ãã 
$num
ãã 
<<
ãã 
$num
ãã 
,
ãã 
	FrontBack
èè 
=
èè 
Front
èè 
|
èè 
Back
èè  
,
èè  !
}
êê 
public
ïï 

enum
ïï 
RectSelectMode
ïï 
{
ññ 
Partial
öö 
,
öö 
Complete
ûû 
}
üü 
public
§§ 

enum
§§ 
MeshSyncState
§§ 
{
•• 
Null
©© 
,
©©  
InstanceIDMismatch
ÆÆ 
,
ÆÆ 
Lightmap
≥≥ 
,
≥≥ 
InSync
∑∑ 
}
∏∏ 
[
ΩΩ 
System
ΩΩ 
.
ΩΩ 
Flags
ΩΩ 
]
ΩΩ 
public
ææ 

enum
ææ 

MeshArrays
ææ 
{
øø 
Position
√√ 
=
√√ 
$num
√√ 
,
√√ 
Texture0
«« 
=
«« 
$num
«« 
,
«« 
Texture1
ÀÀ 
=
ÀÀ 
$num
ÀÀ 
,
ÀÀ 
Lightmap
œœ 
=
œœ 
$num
œœ 
,
œœ 
Texture2
”” 
=
”” 
$num
”” 
,
”” 
Texture3
◊◊ 
=
◊◊ 
$num
◊◊ 
,
◊◊ 
Color
€€ 
=
€€ 
$num
€€ 
,
€€ 
Normal
ﬂﬂ 
=
ﬂﬂ 
$num
ﬂﬂ 
,
ﬂﬂ 
Tangent
„„ 
=
„„ 
$num
„„ 
,
„„ 
All
ÁÁ 
=
ÁÁ 
$num
ÁÁ 
}
ËË 
;
ËË 
enum
ÍÍ 
IndexFormat
ÍÍ	 
{
ÎÎ 
Local
ÏÏ 
=
ÏÏ 
$num
ÏÏ 
,
ÏÏ 
Common
ÌÌ 
=
ÌÌ 
$num
ÌÌ 
,
ÌÌ 
Both
ÓÓ 
=
ÓÓ 
$num
ÓÓ 
}
ÔÔ 
;
ÔÔ 
[
ıı 
System
ıı 
.
ıı 
Flags
ıı 
]
ıı 
public
ˆˆ 

enum
ˆˆ 
RefreshMask
ˆˆ 
{
˜˜ 
UV
˚˚ 

=
˚˚ 
$num
˚˚ 
,
˚˚ 
Colors
ˇˇ 
=
ˇˇ 
$num
ˇˇ 
,
ˇˇ 
Normals
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
,
ÉÉ 
Tangents
áá 
=
áá 
$num
áá 
,
áá 

Collisions
ãã 
=
ãã 
$num
ãã 
,
ãã 
All
èè 
=
èè 
UV
èè 
|
èè 
Colors
èè 
|
èè 
Normals
èè #
|
èè$ %
Tangents
èè& .
|
èè/ 0

Collisions
èè1 ;
}
êê 
;
êê 
public
ïï 

enum
ïï 
ExtrudeMethod
ïï 
{
ññ 
IndividualFaces
öö 
=
öö 
$num
öö 
,
öö 
VertexNormal
ûû 
=
ûû 
$num
ûû 
,
ûû 

FaceNormal
¢¢ 
=
¢¢ 
$num
¢¢ 
}
££ 
}§§ –T
òD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\MergeElements.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
static 

class 
MergeElements 
{ 
public 
static 
List 
< 
Face 
>  

MergePairs! +
(+ ,
ProBuilderMesh, :
target; A
,A B
IEnumerableC N
<N O
SimpleTupleO Z
<Z [
Face[ _
,_ `
Facea e
>e f
>f g
pairsh m
,m n
boolo s'
collapseCoincidentVertices	t é
=
è ê
true
ë ï
)
ï ñ
{ 	
HashSet 
< 
Face 
> 
remove  
=! "
new# &
HashSet' .
<. /
Face/ 3
>3 4
(4 5
)5 6
;6 7
List 
< 
Face 
> 
add 
= 
new  
List! %
<% &
Face& *
>* +
(+ ,
), -
;- .
foreach 
( 
SimpleTuple  
<  !
Face! %
,% &
Face' +
>+ ,
pair- 1
in2 4
pairs5 :
): ;
{ 
Face 
left 
= 
pair  
.  !
item1! &
;& '
Face 
right 
= 
pair !
.! "
item2" '
;' (
int 

leftLength 
=  
left! %
.% &
indexesInternal& 5
.5 6
Length6 <
;< =
int 
rightLength 
=  !
right" '
.' (
indexesInternal( 7
.7 8
Length8 >
;> ?
int 
[ 
] 
indexes 
= 
new  #
int$ '
[' (

leftLength( 2
+3 4
rightLength5 @
]@ A
;A B
System   
.   
Array   
.   
Copy   !
(  ! "
left  " &
.  & '
indexesInternal  ' 6
,  6 7
$num  8 9
,  9 :
indexes  ; B
,  B C
$num  D E
,  E F

leftLength  G Q
)  Q R
;  R S
System!! 
.!! 
Array!! 
.!! 
Copy!! !
(!!! "
right!!" '
.!!' (
indexesInternal!!( 7
,!!7 8
$num!!9 :
,!!: ;
indexes!!< C
,!!C D

leftLength!!E O
,!!O P
rightLength!!Q \
)!!\ ]
;!!] ^
add"" 
."" 
Add"" 
("" 
new"" 
Face""  
(""  !
indexes""! (
,""( )
left## 
.## 
submeshIndex## )
,##) *
left$$ 
.$$ 
uv$$ 
,$$  
left%% 
.%% 
smoothingGroup%% +
,%%+ ,
left&& 
.&& 
textureGroup&& )
,&&) *
left'' 
.'' 
elementGroup'' )
,'') *
left(( 
.(( 
manualUV(( %
)((% &
)((& '
;((' (
remove)) 
.)) 
Add)) 
()) 
left)) 
)))  
;))  !
remove** 
.** 
Add** 
(** 
right**  
)**  !
;**! "
}++ 
List-- 
<-- 
Face-- 
>-- 
faces-- 
=-- 
target-- %
.--% &
facesInternal--& 3
.--3 4
Where--4 9
(--9 :
x--: ;
=>--< >
!--? @
remove--@ F
.--F G
Contains--G O
(--O P
x--P Q
)--Q R
)--R S
.--S T
ToList--T Z
(--Z [
)--[ \
;--\ ]
faces.. 
... 
AddRange.. 
(.. 
add.. 
).. 
;..  
target// 
.// 
faces// 
=// 
faces//  
;//  !
if11 
(11 &
collapseCoincidentVertices11 *
)11* +&
CollapseCoincidentVertices22 *
(22* +
target22+ 1
,221 2
add223 6
)226 7
;227 8
return44 
add44 
;44 
}55 	
publicAA 
staticAA 
FaceAA 
MergeAA  
(AA  !
ProBuilderMeshAA! /
targetAA0 6
,AA6 7
IEnumerableAA8 C
<AAC D
FaceAAD H
>AAH I
facesAAJ O
)AAO P
{BB 	
intCC 
mergedCountCC 
=CC 
facesCC #
!=CC$ &
nullCC' +
?CC, -
facesCC. 3
.CC3 4
CountCC4 9
(CC9 :
)CC: ;
:CC< =
$numCC> ?
;CC? @
ifEE 
(EE 
mergedCountEE 
<EE 
$numEE 
)EE  
returnFF 
nullFF 
;FF 
FaceHH 
firstHH 
=HH 
facesHH 
.HH 
FirstHH $
(HH$ %
)HH% &
;HH& '
FaceJJ 

mergedFaceJJ 
=JJ 
newJJ !
FaceJJ" &
(JJ& '
facesJJ' ,
.JJ, -

SelectManyJJ- 7
(JJ7 8
xJJ8 9
=>JJ: <
xJJ= >
.JJ> ?
indexesInternalJJ? N
)JJN O
.JJO P
ToArrayJJP W
(JJW X
)JJX Y
,JJY Z
firstKK 
.KK 
submeshIndexKK &
,KK& '
firstLL 
.LL 
uvLL 
,LL 
firstMM 
.MM 
smoothingGroupMM (
,MM( )
firstNN 
.NN 
textureGroupNN &
,NN& '
firstOO 
.OO 
elementGroupOO &
,OO& '
firstPP 
.PP 
manualUVPP "
)PP" #
;PP# $
FaceRR 
[RR 
]RR 
rebuiltFacesRR 
=RR  !
newRR" %
FaceRR& *
[RR* +
targetRR+ 1
.RR1 2
facesInternalRR2 ?
.RR? @
LengthRR@ F
-RRG H
mergedCountRRI T
+RRU V
$numRRW X
]RRX Y
;RRY Z
intTT 
nTT 
=TT 
$numTT 
;TT 
HashSetVV 
<VV 
FaceVV 
>VV 
skipVV 
=VV  
newVV! $
HashSetVV% ,
<VV, -
FaceVV- 1
>VV1 2
(VV2 3
facesVV3 8
)VV8 9
;VV9 :
foreachXX 
(XX 
FaceXX 
fXX 
inXX 
targetXX %
.XX% &
facesInternalXX& 3
)XX3 4
{YY 
ifZZ 
(ZZ 
!ZZ 
skipZZ 
.ZZ 
ContainsZZ "
(ZZ" #
fZZ# $
)ZZ$ %
)ZZ% &
rebuiltFaces[[  
[[[  !
n[[! "
++[[" $
][[$ %
=[[& '
f[[( )
;[[) *
}\\ 
rebuiltFaces^^ 
[^^ 
n^^ 
]^^ 
=^^ 

mergedFace^^ (
;^^( )
target`` 
.`` 
faces`` 
=`` 
rebuiltFaces`` '
;``' (&
CollapseCoincidentVerticesbb &
(bb& '
targetbb' -
,bb- .
newbb/ 2
Facebb3 7
[bb7 8
]bb8 9
{bb: ;

mergedFacebb< F
}bbG H
)bbH I
;bbI J
returndd 

mergedFacedd 
;dd 
}ee 	
internalmm 
staticmm 
voidmm &
CollapseCoincidentVerticesmm 7
(mm7 8
ProBuilderMeshmm8 F
meshmmG K
,mmK L
IEnumerablemmM X
<mmX Y
FacemmY ]
>mm] ^
facesmm_ d
)mmd e
{nn 	

Dictionaryoo 
<oo 
intoo 
,oo 
intoo 
>oo  
lookupoo! '
=oo( )
meshoo* .
.oo. /
sharedVertexLookupoo/ A
;ooA B

Dictionarypp 
<pp 
intpp 
,pp 
intpp 
>pp  
matchespp! (
=pp) *
newpp+ .

Dictionarypp/ 9
<pp9 :
intpp: =
,pp= >
intpp? B
>ppB C
(ppC D
)ppD E
;ppE F
foreachrr 
(rr 
Facerr 
facerr 
inrr !
facesrr" '
)rr' (
{ss 
matchestt 
.tt 
Cleartt 
(tt 
)tt 
;tt  
forvv 
(vv 
intvv 
ivv 
=vv 
$numvv 
;vv 
ivv  !
<vv" #
facevv$ (
.vv( )
indexesInternalvv) 8
.vv8 9
Lengthvv9 ?
;vv? @
ivvA B
++vvB D
)vvD E
{ww 
intxx 
commonxx 
=xx  
lookupxx! '
[xx' (
facexx( ,
.xx, -
indexesInternalxx- <
[xx< =
ixx= >
]xx> ?
]xx? @
;xx@ A
ifzz 
(zz 
matcheszz 
.zz  
ContainsKeyzz  +
(zz+ ,
commonzz, 2
)zz2 3
)zz3 4
face{{ 
.{{ 
indexesInternal{{ ,
[{{, -
i{{- .
]{{. /
={{0 1
matches{{2 9
[{{9 :
common{{: @
]{{@ A
;{{A B
else|| 
matches}} 
.}}  
Add}}  #
(}}# $
common}}$ *
,}}* +
face}}, 0
.}}0 1
indexesInternal}}1 @
[}}@ A
i}}A B
]}}B C
)}}C D
;}}D E
}~~ 
face
ÄÄ 
.
ÄÄ 
InvalidateCache
ÄÄ $
(
ÄÄ$ %
)
ÄÄ% &
;
ÄÄ& '
}
ÅÅ 
MeshValidation
ÉÉ 
.
ÉÉ "
RemoveUnusedVertices
ÉÉ /
(
ÉÉ/ 0
mesh
ÉÉ0 4
)
ÉÉ4 5
;
ÉÉ5 6
}
ÑÑ 	
}
ÖÖ 
}ÜÜ ©
óD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\AssemblyInfo.cs
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> W
)W X
]X Y
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> V
)V W
]W X
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> ]
)] ^
]^ _™‚
ôD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\AppendElements.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{		 
public 

static 
class 
AppendElements &
{ 
internal 
static 
Face 

AppendFace '
(' (
this( ,
ProBuilderMesh- ;
mesh< @
,@ A
Vector3B I
[I J
]J K
	positionsL U
,U V
ColorW \
[\ ]
]] ^
colors_ e
,e f
Vector2g n
[n o
]o p
uvsq t
,t u
Facev z
face{ 
,	 Ä
int
Å Ñ
[
Ñ Ö
]
Ö Ü
common
á ç
)
ç é
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new !
ArgumentNullException /
(/ 0
$str0 6
)6 7
;7 8
if 
( 
	positions 
== 
null !
)! "
throw 
new !
ArgumentNullException /
(/ 0
$str0 ;
); <
;< =
if!! 
(!! 
face!! 
==!! 
null!! 
)!! 
throw"" 
new"" !
ArgumentNullException"" /
(""/ 0
$str""0 6
)""6 7
;""7 8
int$$ 
faceVertexCount$$ 
=$$  !
	positions$$" +
.$$+ ,
Length$$, 2
;$$2 3
if&& 
(&& 
common&& 
==&& 
null&& 
)&& 
{'' 
common(( 
=(( 
new(( 
int((  
[((  !
faceVertexCount((! 0
]((0 1
;((1 2
for)) 
()) 
int)) 
i)) 
=)) 
$num)) 
;)) 
i))  !
<))" #
faceVertexCount))$ 3
;))3 4
i))5 6
++))6 8
)))8 9
common** 
[** 
i** 
]** 
=** 
-**  !
$num**! "
;**" #
}++ 
int-- 
vertexCount-- 
=-- 
mesh-- "
.--" #
vertexCount--# .
;--. /
var// 
mc// 
=// 
mesh// 
.// 
	HasArrays// #
(//# $

MeshArrays//$ .
.//. /
Color/// 4
)//4 5
;//5 6
var00 
fc00 
=00 
colors00 
!=00 
null00 #
;00# $
var11 
mt11 
=11 
mesh11 
.11 
	HasArrays11 #
(11# $

MeshArrays11$ .
.11. /
Texture011/ 7
)117 8
;118 9
var22 
ft22 
=22 
uvs22 
!=22 
null22  
;22  !
Vector344 
[44 
]44 
newPositions44 "
=44# $
new44% (
Vector344) 0
[440 1
vertexCount441 <
+44= >
faceVertexCount44? N
]44N O
;44O P
Color55 
[55 
]55 
	newColors55 
=55 
(55  !
mc55! #
||55$ &
fc55' )
)55) *
?55+ ,
new55- 0
Color551 6
[556 7
vertexCount557 B
+55C D
faceVertexCount55E T
]55T U
:55V W
null55X \
;55\ ]
Vector266 
[66 
]66 
newTextures66 !
=66" #
(66$ %
mt66% '
||66( *
ft66+ -
)66- .
?66/ 0
new661 4
Vector2665 <
[66< =
vertexCount66= H
+66I J
faceVertexCount66K Z
]66Z [
:66\ ]
null66^ b
;66b c
List88 
<88 
Face88 
>88 
faces88 
=88 
new88 "
List88# '
<88' (
Face88( ,
>88, -
(88- .
mesh88. 2
.882 3
facesInternal883 @
)88@ A
;88A B
Array99 
.99 
Copy99 
(99 
mesh99 
.99 
positionsInternal99 -
,99- .
$num99/ 0
,990 1
newPositions992 >
,99> ?
$num99@ A
,99A B
vertexCount99C N
)99N O
;99O P
Array:: 
.:: 
Copy:: 
(:: 
	positions::  
,::  !
$num::" #
,::# $
newPositions::% 1
,::1 2
vertexCount::3 >
,::> ?
faceVertexCount::@ O
)::O P
;::P Q
if<< 
(<< 
mc<< 
||<< 
fc<< 
)<< 
{== 
Array>> 
.>> 
Copy>> 
(>> 
mc>> 
?>> 
mesh>>  $
.>>$ %
colorsInternal>>% 3
:>>4 5
ArrayUtility>>6 B
.>>B C
Fill>>C G
(>>G H
Color>>H M
.>>M N
white>>N S
,>>S T
vertexCount>>U `
)>>` a
,>>a b
$num>>c d
,>>d e
	newColors>>f o
,>>o p
$num>>q r
,>>r s
vertexCount>>t 
)	>> Ä
;
>>Ä Å
Array?? 
.?? 
Copy?? 
(?? 
fc?? 
??? 
colors??  &
:??' (
ArrayUtility??) 5
.??5 6
Fill??6 :
(??: ;
Color??; @
.??@ A
white??A F
,??F G
faceVertexCount??H W
)??W X
,??X Y
$num??Z [
,??[ \
	newColors??] f
,??f g
vertexCount??h s
,??s t
colors??u {
.??{ |
Length	??| Ç
)
??Ç É
;
??É Ñ
}@@ 
ifBB 
(BB 
mtBB 
||BB 
ftBB 
)BB 
{CC 
ArrayDD 
.DD 
CopyDD 
(DD 
mtDD 
?DD 
meshDD  $
.DD$ %
texturesInternalDD% 5
:DD6 7
ArrayUtilityDD8 D
.DDD E
FillDDE I
(DDI J
Vector2DDJ Q
.DDQ R
zeroDDR V
,DDV W
vertexCountDDX c
)DDc d
,DDd e
$numDDf g
,DDg h
newTexturesDDi t
,DDt u
$numDDv w
,DDw x
vertexCount	DDy Ñ
)
DDÑ Ö
;
DDÖ Ü
ArrayEE 
.EE 
CopyEE 
(EE 
ftEE 
?EE 
uvsEE  #
:EE$ %
ArrayUtilityEE& 2
.EE2 3
FillEE3 7
(EE7 8
Vector2EE8 ?
.EE? @
zeroEE@ D
,EED E
faceVertexCountEEF U
)EEU V
,EEV W
$numEEX Y
,EEY Z
newTexturesEE[ f
,EEf g
meshEEh l
.EEl m
texturesInternalEEm }
.EE} ~
Length	EE~ Ñ
,
EEÑ Ö
faceVertexCount
EEÜ ï
)
EEï ñ
;
EEñ ó
}FF 
faceHH 
.HH 
ShiftIndexesToZeroHH #
(HH# $
)HH$ %
;HH% &
faceII 
.II 
ShiftIndexesII 
(II 
vertexCountII )
)II) *
;II* +
facesKK 
.KK 
AddKK 
(KK 
faceKK 
)KK 
;KK 
forMM 
(MM 
intMM 
iMM 
=MM 
$numMM 
;MM 
iMM 
<MM 
commonMM  &
.MM& '
LengthMM' -
;MM- .
iMM/ 0
++MM0 2
)MM2 3
{NN 
ifOO 
(OO 
commonOO 
[OO 
iOO 
]OO 
<OO 
$numOO  !
)OO! "
meshPP 
.PP 
AddSharedVertexPP (
(PP( )
newPP) ,
SharedVertexPP- 9
(PP9 :
newPP: =
intPP> A
[PPA B
]PPB C
{PPD E
iPPF G
+PPH I
vertexCountPPJ U
}PPV W
)PPW X
)PPX Y
;PPY Z
elseQQ 
meshRR 
.RR 
AddToSharedVertexRR *
(RR* +
commonRR+ 1
[RR1 2
iRR2 3
]RR3 4
,RR4 5
iRR6 7
+RR8 9
vertexCountRR: E
)RRE F
;RRF G
}SS 
meshUU 
.UU 
	positionsUU 
=UU 
newPositionsUU )
;UU) *
meshVV 
.VV 
colorsVV 
=VV 
	newColorsVV #
;VV# $
meshWW 
.WW 
texturesWW 
=WW 
newTexturesWW '
;WW' (
meshXX 
.XX 
facesXX 
=XX 
facesXX 
;XX 
returnZZ 
faceZZ 
;ZZ 
}[[ 	
publicgg 
staticgg 
Facegg 
[gg 
]gg 
AppendFacesgg (
(gg( )
thishh 
ProBuilderMeshhh 
meshhh  $
,hh$ %
Vector3ii 
[ii 
]ii 
[ii 
]ii 
	positionsii !
,ii! "
Colorjj 
[jj 
]jj 
[jj 
]jj 
colorsjj 
,jj 
Vector2kk 
[kk 
]kk 
[kk 
]kk 
uvskk 
,kk 
Facell 
[ll 
]ll 
facesll 
,ll 
intmm 
[mm 
]mm 
[mm 
]mm 
sharedmm 
)mm 
{nn 	
ifoo 
(oo 
meshoo 
==oo 
nulloo 
)oo 
throwpp 
newpp !
ArgumentNullExceptionpp /
(pp/ 0
$strpp0 6
)pp6 7
;pp7 8
ifrr 
(rr 
	positionsrr 
==rr 
nullrr !
)rr! "
throwss 
newss !
ArgumentNullExceptionss /
(ss/ 0
$strss0 ;
)ss; <
;ss< =
ifuu 
(uu 
colorsuu 
==uu 
nulluu 
)uu 
throwvv 
newvv !
ArgumentNullExceptionvv /
(vv/ 0
$strvv0 8
)vv8 9
;vv9 :
ifxx 
(xx 
uvsxx 
==xx 
nullxx 
)xx 
throwyy 
newyy !
ArgumentNullExceptionyy /
(yy/ 0
$stryy0 5
)yy5 6
;yy6 7
if{{ 
({{ 
faces{{ 
=={{ 
null{{ 
){{ 
throw|| 
new|| !
ArgumentNullException|| /
(||/ 0
$str||0 7
)||7 8
;||8 9
var~~ 
newPositions~~ 
=~~ 
new~~ "
List~~# '
<~~' (
Vector3~~( /
>~~/ 0
(~~0 1
mesh~~1 5
.~~5 6
positionsInternal~~6 G
)~~G H
;~~H I
var 
	newColors 
= 
new 
List  $
<$ %
Color% *
>* +
(+ ,
mesh, 0
.0 1
colorsInternal1 ?
)? @
;@ A
var
ÄÄ 
newTextures
ÄÄ 
=
ÄÄ 
new
ÄÄ !
List
ÄÄ" &
<
ÄÄ& '
Vector2
ÄÄ' .
>
ÄÄ. /
(
ÄÄ/ 0
mesh
ÄÄ0 4
.
ÄÄ4 5
texturesInternal
ÄÄ5 E
)
ÄÄE F
;
ÄÄF G
var
ÅÅ 
newFaces
ÅÅ 
=
ÅÅ 
new
ÅÅ 
List
ÅÅ #
<
ÅÅ# $
Face
ÅÅ$ (
>
ÅÅ( )
(
ÅÅ) *
mesh
ÅÅ* .
.
ÅÅ. /
facesInternal
ÅÅ/ <
)
ÅÅ< =
;
ÅÅ= >
var
ÇÇ 
lookup
ÇÇ 
=
ÇÇ 
mesh
ÇÇ 
.
ÇÇ  
sharedVertexLookup
ÇÇ 0
;
ÇÇ0 1
int
ÑÑ 
vc
ÑÑ 
=
ÑÑ 
mesh
ÑÑ 
.
ÑÑ 
vertexCount
ÑÑ %
;
ÑÑ% &
for
ÜÜ 
(
ÜÜ 
int
ÜÜ 
i
ÜÜ 
=
ÜÜ 
$num
ÜÜ 
;
ÜÜ 
i
ÜÜ 
<
ÜÜ 
faces
ÜÜ  %
.
ÜÜ% &
Length
ÜÜ& ,
;
ÜÜ, -
i
ÜÜ. /
++
ÜÜ/ 1
)
ÜÜ1 2
{
áá 
newPositions
àà 
.
àà 
AddRange
àà %
(
àà% &
	positions
àà& /
[
àà/ 0
i
àà0 1
]
àà1 2
)
àà2 3
;
àà3 4
	newColors
ââ 
.
ââ 
AddRange
ââ "
(
ââ" #
colors
ââ# )
[
ââ) *
i
ââ* +
]
ââ+ ,
)
ââ, -
;
ââ- .
newTextures
ää 
.
ää 
AddRange
ää $
(
ää$ %
uvs
ää% (
[
ää( )
i
ää) *
]
ää* +
)
ää+ ,
;
ää, -
faces
åå 
[
åå 
i
åå 
]
åå 
.
åå  
ShiftIndexesToZero
åå +
(
åå+ ,
)
åå, -
;
åå- .
faces
çç 
[
çç 
i
çç 
]
çç 
.
çç 
ShiftIndexes
çç %
(
çç% &
vc
çç& (
)
çç( )
;
çç) *
newFaces
éé 
.
éé 
Add
éé 
(
éé 
faces
éé "
[
éé" #
i
éé# $
]
éé$ %
)
éé% &
;
éé& '
if
êê 
(
êê 
shared
êê 
!=
êê 
null
êê "
&&
êê# %
	positions
êê& /
[
êê/ 0
i
êê0 1
]
êê1 2
.
êê2 3
Length
êê3 9
!=
êê: <
shared
êê= C
[
êêC D
i
êêD E
]
êêE F
.
êêF G
Length
êêG M
)
êêM N
{
ëë 
Debug
íí 
.
íí 
LogError
íí "
(
íí" #
$str
íí# m
)
íím n
;
íín o
return
ìì 
null
ìì 
;
ìì  
}
îî 
var
ññ 
	hasCommon
ññ 
=
ññ 
shared
ññ  &
!=
ññ' )
null
ññ* .
;
ññ. /
for
òò 
(
òò 
int
òò 
j
òò 
=
òò 
$num
òò 
;
òò 
j
òò  !
<
òò" #
shared
òò$ *
[
òò* +
i
òò+ ,
]
òò, -
.
òò- .
Length
òò. 4
;
òò4 5
j
òò6 7
++
òò7 9
)
òò9 :
lookup
ôô 
.
ôô 
Add
ôô 
(
ôô 
j
ôô  
+
ôô! "
vc
ôô# %
,
ôô% &
	hasCommon
ôô' 0
?
ôô1 2
shared
ôô3 9
[
ôô9 :
i
ôô: ;
]
ôô; <
[
ôô< =
j
ôô= >
]
ôô> ?
:
ôô@ A
-
ôôB C
$num
ôôC D
)
ôôD E
;
ôôE F
vc
õõ 
=
õõ 
newPositions
õõ !
.
õõ! "
Count
õõ" '
;
õõ' (
}
úú 
mesh
ûû 
.
ûû 
	positions
ûû 
=
ûû 
newPositions
ûû )
;
ûû) *
mesh
üü 
.
üü 
colors
üü 
=
üü 
	newColors
üü #
;
üü# $
mesh
†† 
.
†† 
textures
†† 
=
†† 
newTextures
†† '
;
††' (
mesh
°° 
.
°° 
faces
°° 
=
°° 
newFaces
°° !
;
°°! "
mesh
¢¢ 
.
¢¢ 
SetSharedVertices
¢¢ "
(
¢¢" #
lookup
¢¢# )
)
¢¢) *
;
¢¢* +
return
§§ 
faces
§§ 
;
§§ 
}
•• 	
public
ÆÆ 
static
ÆÆ 
Face
ÆÆ 
CreatePolygon
ÆÆ (
(
ÆÆ( )
this
ÆÆ) -
ProBuilderMesh
ÆÆ. <
mesh
ÆÆ= A
,
ÆÆA B
IList
ÆÆC H
<
ÆÆH I
int
ÆÆI L
>
ÆÆL M
indexes
ÆÆN U
,
ÆÆU V
bool
ÆÆW [
	unordered
ÆÆ\ e
)
ÆÆe f
{
ØØ 	
if
∞∞ 
(
∞∞ 
mesh
∞∞ 
==
∞∞ 
null
∞∞ 
)
∞∞ 
throw
±± 
new
±± #
ArgumentNullException
±± /
(
±±/ 0
$str
±±0 6
)
±±6 7
;
±±7 8
SharedVertex
≥≥ 
[
≥≥ 
]
≥≥ 
sharedIndexes
≥≥ (
=
≥≥) *
mesh
≥≥+ /
.
≥≥/ 0$
sharedVerticesInternal
≥≥0 F
;
≥≥F G

Dictionary
¥¥ 
<
¥¥ 
int
¥¥ 
,
¥¥ 
int
¥¥ 
>
¥¥  
lookup
¥¥! '
=
¥¥( )
mesh
¥¥* .
.
¥¥. / 
sharedVertexLookup
¥¥/ A
;
¥¥A B
HashSet
µµ 
<
µµ 
int
µµ 
>
µµ 
common
µµ 
=
µµ  !
mesh
µµ" &
.
µµ& '$
GetSharedVertexHandles
µµ' =
(
µµ= >
indexes
µµ> E
)
µµE F
;
µµF G
List
∂∂ 
<
∂∂ 
Vertex
∂∂ 
>
∂∂ 
vertices
∂∂ !
=
∂∂" #
new
∂∂$ '
List
∂∂( ,
<
∂∂, -
Vertex
∂∂- 3
>
∂∂3 4
(
∂∂4 5
mesh
∂∂5 9
.
∂∂9 :
GetVertices
∂∂: E
(
∂∂E F
)
∂∂F G
)
∂∂G H
;
∂∂H I
List
∑∑ 
<
∑∑ 
Vertex
∑∑ 
>
∑∑ 
appendVertices
∑∑ '
=
∑∑( )
new
∑∑* -
List
∑∑. 2
<
∑∑2 3
Vertex
∑∑3 9
>
∑∑9 :
(
∑∑: ;
)
∑∑; <
;
∑∑< =
foreach
ππ 
(
ππ 
int
ππ 
i
ππ 
in
ππ 
common
ππ $
)
ππ$ %
{
∫∫ 
int
ªª 
index
ªª 
=
ªª 
sharedIndexes
ªª )
[
ªª) *
i
ªª* +
]
ªª+ ,
[
ªª, -
$num
ªª- .
]
ªª. /
;
ªª/ 0
appendVertices
ºº 
.
ºº 
Add
ºº "
(
ºº" #
new
ºº# &
Vertex
ºº' -
(
ºº- .
vertices
ºº. 6
[
ºº6 7
index
ºº7 <
]
ºº< =
)
ºº= >
)
ºº> ?
;
ºº? @
}
ΩΩ 
FaceRebuildData
øø 
data
øø  
=
øø! "
FaceWithVertices
øø# 3
(
øø3 4
appendVertices
øø4 B
,
øøB C
	unordered
øøD M
)
øøM N
;
øøN O
if
¡¡ 
(
¡¡ 
data
¡¡ 
!=
¡¡ 
null
¡¡ 
)
¡¡ 
{
¬¬ 
data
√√ 
.
√√ 
sharedIndexes
√√ "
=
√√# $
common
√√% +
.
√√+ ,
ToList
√√, 2
(
√√2 3
)
√√3 4
;
√√4 5
List
ƒƒ 
<
ƒƒ 
Face
ƒƒ 
>
ƒƒ 
faces
ƒƒ  
=
ƒƒ! "
new
ƒƒ# &
List
ƒƒ' +
<
ƒƒ+ ,
Face
ƒƒ, 0
>
ƒƒ0 1
(
ƒƒ1 2
mesh
ƒƒ2 6
.
ƒƒ6 7
facesInternal
ƒƒ7 D
)
ƒƒD E
;
ƒƒE F
FaceRebuildData
≈≈ 
.
≈≈  
Apply
≈≈  %
(
≈≈% &
new
≈≈& )
FaceRebuildData
≈≈* 9
[
≈≈9 :
]
≈≈: ;
{
≈≈< =
data
≈≈> B
}
≈≈C D
,
≈≈D E
vertices
≈≈F N
,
≈≈N O
faces
≈≈P U
,
≈≈U V
lookup
≈≈W ]
,
≈≈] ^
null
≈≈_ c
)
≈≈c d
;
≈≈d e
mesh
∆∆ 
.
∆∆ 
SetVertices
∆∆  
(
∆∆  !
vertices
∆∆! )
)
∆∆) *
;
∆∆* +
mesh
«« 
.
«« 
faces
«« 
=
«« 
faces
«« "
;
««" #
mesh
»» 
.
»» 
SetSharedVertices
»» &
(
»»& '
lookup
»»' -
)
»»- .
;
»». /
return
   
data
   
.
   
face
    
;
    !
}
ÀÀ 
const
ÕÕ 
string
ÕÕ  
insufficientPoints
ÕÕ +
=
ÕÕ, -
$str
ÕÕ. N
;
ÕÕN O
const
ŒŒ 
string
ŒŒ 

badWinding
ŒŒ #
=
ŒŒ$ %
$str
ŒŒ& D
;
ŒŒD E
Log
–– 
.
–– 
Info
–– 
(
–– 
	unordered
–– 
?
––   
insufficientPoints
––! 3
:
––4 5

badWinding
––6 @
)
––@ A
;
––A B
return
““ 
null
““ 
;
““ 
}
”” 	
public
⁄⁄ 
static
⁄⁄ 
ActionResult
⁄⁄ "$
CreateShapeFromPolygon
⁄⁄# 9
(
⁄⁄9 :
this
⁄⁄: >
	PolyShape
⁄⁄? H
poly
⁄⁄I M
)
⁄⁄M N
{
€€ 	
return
‹‹ 
poly
‹‹ 
.
‹‹ 
mesh
‹‹ 
.
‹‹ $
CreateShapeFromPolygon
‹‹ 3
(
‹‹3 4
poly
‹‹4 8
.
‹‹8 9
m_Points
‹‹9 A
,
‹‹A B
poly
‹‹C G
.
‹‹G H
extrude
‹‹H O
,
‹‹O P
poly
‹‹Q U
.
‹‹U V
flipNormals
‹‹V a
)
‹‹a b
;
‹‹b c
}
›› 	
internal
„„ 
static
„„ 
void
„„ !
ClearAndRefreshMesh
„„ 0
(
„„0 1
this
„„1 5
ProBuilderMesh
„„6 D
mesh
„„E I
)
„„I J
{
‰‰ 	
mesh
ÂÂ 
.
ÂÂ 
Clear
ÂÂ 
(
ÂÂ 
)
ÂÂ 
;
ÂÂ 
mesh
ÊÊ 
.
ÊÊ 
ToMesh
ÊÊ 
(
ÊÊ 
)
ÊÊ 
;
ÊÊ 
mesh
ÁÁ 
.
ÁÁ 
Refresh
ÁÁ 
(
ÁÁ 
)
ÁÁ 
;
ÁÁ 
}
ËË 	
public
ÚÚ 
static
ÚÚ 
ActionResult
ÚÚ "$
CreateShapeFromPolygon
ÚÚ# 9
(
ÚÚ9 :
this
ÚÚ: >
ProBuilderMesh
ÚÚ? M
mesh
ÚÚN R
,
ÚÚR S
IList
ÚÚT Y
<
ÚÚY Z
Vector3
ÚÚZ a
>
ÚÚa b
points
ÚÚc i
,
ÚÚi j
float
ÚÚk p
extrude
ÚÚq x
,
ÚÚx y
bool
ÚÚz ~
flipNormalsÚÚ ä
)ÚÚä ã
{
ÛÛ 	
return
ÙÙ $
CreateShapeFromPolygon
ÙÙ )
(
ÙÙ) *
mesh
ÙÙ* .
,
ÙÙ. /
points
ÙÙ0 6
,
ÙÙ6 7
extrude
ÙÙ8 ?
,
ÙÙ? @
flipNormals
ÙÙA L
,
ÙÙL M
null
ÙÙN R
)
ÙÙR S
;
ÙÙS T
}
ıı 	
[
ÅÅ 	
Obsolete
ÅÅ	 
(
ÅÅ 
$str
ÅÅ g
)
ÅÅg h
]
ÅÅh i
public
ÇÇ 
static
ÇÇ 
ActionResult
ÇÇ "$
CreateShapeFromPolygon
ÇÇ# 9
(
ÇÇ9 :
this
ÇÇ: >
ProBuilderMesh
ÇÇ? M
mesh
ÇÇN R
,
ÇÇR S
IList
ÇÇT Y
<
ÇÇY Z
Vector3
ÇÇZ a
>
ÇÇa b
points
ÇÇc i
,
ÇÇi j
float
ÇÇk p
extrude
ÇÇq x
,
ÇÇx y
bool
ÇÇz ~
flipNormalsÇÇ ä
,ÇÇä ã
Vector3ÇÇå ì
cameraLookAtÇÇî †
,ÇÇ† °
IListÇÇ¢ ß
<ÇÇß ®
IListÇÇ® ≠
<ÇÇ≠ Æ
Vector3ÇÇÆ µ
>ÇÇµ ∂
>ÇÇ∂ ∑

holePointsÇÇ∏ ¬
=ÇÇ√ ƒ
nullÇÇ≈ …
)ÇÇ…  
{
ÉÉ 	
return
ÑÑ $
CreateShapeFromPolygon
ÑÑ )
(
ÑÑ) *
mesh
ÑÑ* .
,
ÑÑ. /
points
ÑÑ0 6
,
ÑÑ6 7
extrude
ÑÑ8 ?
,
ÑÑ? @
flipNormals
ÑÑA L
,
ÑÑL M
null
ÑÑN R
)
ÑÑR S
;
ÑÑS T
}
ÖÖ 	
public
êê 
static
êê 
ActionResult
êê "$
CreateShapeFromPolygon
êê# 9
(
êê9 :
this
êê: >
ProBuilderMesh
êê? M
mesh
êêN R
,
êêR S
IList
êêT Y
<
êêY Z
Vector3
êêZ a
>
êêa b
points
êêc i
,
êêi j
float
êêk p
extrude
êêq x
,
êêx y
bool
êêz ~
flipNormalsêê ä
,êêä ã
IListêêå ë
<êêë í
IListêêí ó
<êêó ò
Vector3êêò ü
>êêü †
>êê† °

holePointsêê¢ ¨
)êê¨ ≠
{
ëë 	
if
íí 
(
íí 
mesh
íí 
==
íí 
null
íí 
)
íí 
throw
ìì 
new
ìì #
ArgumentNullException
ìì /
(
ìì/ 0
$str
ìì0 6
)
ìì6 7
;
ìì7 8
if
ïï 
(
ïï 
points
ïï 
==
ïï 
null
ïï 
||
ïï !
points
ïï" (
.
ïï( )
Count
ïï) .
<
ïï/ 0
$num
ïï1 2
)
ïï2 3
{
ññ !
ClearAndRefreshMesh
óó #
(
óó# $
mesh
óó$ (
)
óó( )
;
óó) *
return
òò 
new
òò 
ActionResult
òò '
(
òò' (
ActionResult
òò( 4
.
òò4 5
Status
òò5 ;
.
òò; <
NoChange
òò< D
,
òòD E
$str
òòF V
)
òòV W
;
òòW X
}
ôô 
Vector3
õõ 
[
õõ 
]
õõ 
vertices
õõ 
=
õõ  
points
õõ! '
.
õõ' (
ToArray
õõ( /
(
õõ/ 0
)
õõ0 1
;
õõ1 2
Vector3
ùù 
[
ùù 
]
ùù 
[
ùù 
]
ùù 
holeVertices
ùù $
=
ùù% &
null
ùù' +
;
ùù+ ,
if
ûû 
(
ûû 

holePoints
ûû 
!=
ûû 
null
ûû "
&&
ûû# %

holePoints
ûû& 0
.
ûû0 1
Count
ûû1 6
>
ûû7 8
$num
ûû9 :
)
ûû: ;
{
üü 
holeVertices
†† 
=
†† 
new
†† "
Vector3
††# *
[
††* +

holePoints
††+ 5
.
††5 6
Count
††6 ;
]
††; <
[
††< =
]
††= >
;
††> ?
for
°° 
(
°° 
int
°° 
i
°° 
=
°° 
$num
°° 
;
°° 
i
°°  !
<
°°" #

holePoints
°°$ .
.
°°. /
Count
°°/ 4
;
°°4 5
i
°°6 7
++
°°7 9
)
°°9 :
{
¢¢ 
if
££ 
(
££ 

holePoints
££ !
[
££! "
i
££" #
]
££# $
==
££% '
null
££( ,
||
££- /

holePoints
££0 :
[
££: ;
i
££; <
]
££< =
.
££= >
Count
££> C
<
££D E
$num
££F G
)
££G H
{
§§ !
ClearAndRefreshMesh
•• +
(
••+ ,
mesh
••, 0
)
••0 1
;
••1 2
return
¶¶ 
new
¶¶ "
ActionResult
¶¶# /
(
¶¶/ 0
ActionResult
¶¶0 <
.
¶¶< =
Status
¶¶= C
.
¶¶C D
NoChange
¶¶D L
,
¶¶L M
$str
¶¶N g
+
¶¶h i
i
¶¶j k
)
¶¶k l
;
¶¶l m
}
ßß 
holeVertices
®®  
[
®®  !
i
®®! "
]
®®" #
=
®®$ %

holePoints
®®& 0
[
®®0 1
i
®®1 2
]
®®2 3
.
®®3 4
ToArray
®®4 ;
(
®®; <
)
®®< =
;
®®= >
}
©© 
}
™™ 
List
¨¨ 
<
¨¨ 
int
¨¨ 
>
¨¨ 
	triangles
¨¨ 
;
¨¨  
Log
ÆÆ 
.
ÆÆ 
PushLogLevel
ÆÆ 
(
ÆÆ 
LogLevel
ÆÆ %
.
ÆÆ% &
Error
ÆÆ& +
)
ÆÆ+ ,
;
ÆÆ, -
if
∞∞ 
(
∞∞ 
Triangulation
∞∞ 
.
∞∞ !
TriangulateVertices
∞∞ 1
(
∞∞1 2
vertices
∞∞2 :
,
∞∞: ;
out
∞∞< ?
	triangles
∞∞@ I
,
∞∞I J
holeVertices
∞∞K W
)
∞∞W X
)
∞∞X Y
{
±± 
Vector3
≤≤ 
[
≤≤ 
]
≤≤ 
combinedVertices
≤≤ *
=
≤≤+ ,
null
≤≤- 1
;
≤≤1 2
if
≥≥ 
(
≥≥ 
holeVertices
≥≥  
!=
≥≥! #
null
≥≥$ (
)
≥≥( )
{
¥¥ 
combinedVertices
µµ $
=
µµ% &
new
µµ' *
Vector3
µµ+ 2
[
µµ2 3
vertices
µµ3 ;
.
µµ; <
Length
µµ< B
+
µµC D
holeVertices
µµE Q
.
µµQ R
Sum
µµR U
(
µµU V
arr
µµV Y
=>
µµZ \
arr
µµ] `
.
µµ` a
Length
µµa g
)
µµg h
]
µµh i
;
µµi j
Array
∂∂ 
.
∂∂ 
Copy
∂∂ 
(
∂∂ 
vertices
∂∂ '
,
∂∂' (
combinedVertices
∂∂) 9
,
∂∂9 :
vertices
∂∂; C
.
∂∂C D
Length
∂∂D J
)
∂∂J K
;
∂∂K L
int
∑∑ 
destinationIndex
∑∑ (
=
∑∑) *
vertices
∑∑+ 3
.
∑∑3 4
Length
∑∑4 :
;
∑∑: ;
foreach
∏∏ 
(
∏∏ 
var
∏∏  
hole
∏∏! %
in
∏∏& (
holeVertices
∏∏) 5
)
∏∏5 6
{
ππ 
Array
∫∫ 
.
∫∫ 
ConstrainedCopy
∫∫ -
(
∫∫- .
hole
∫∫. 2
,
∫∫2 3
$num
∫∫4 5
,
∫∫5 6
combinedVertices
∫∫7 G
,
∫∫G H
destinationIndex
∫∫I Y
,
∫∫Y Z
hole
∫∫[ _
.
∫∫_ `
Length
∫∫` f
)
∫∫f g
;
∫∫g h
destinationIndex
ªª (
+=
ªª) +
hole
ªª, 0
.
ªª0 1
Length
ªª1 7
;
ªª7 8
}
ºº 
}
ΩΩ 
else
ææ 
{
øø 
combinedVertices
¿¿ $
=
¿¿% &
vertices
¿¿' /
;
¿¿/ 0
}
¡¡ 
int
¬¬ 
[
¬¬ 
]
¬¬ 
indexes
¬¬ 
=
¬¬ 
	triangles
¬¬  )
.
¬¬) *
ToArray
¬¬* 1
(
¬¬1 2
)
¬¬2 3
;
¬¬3 4
if
ƒƒ 
(
ƒƒ 
Math
ƒƒ 
.
ƒƒ 
PolygonArea
ƒƒ $
(
ƒƒ$ %
combinedVertices
ƒƒ% 5
,
ƒƒ5 6
indexes
ƒƒ7 >
)
ƒƒ> ?
<
ƒƒ@ A
Mathf
ƒƒB G
.
ƒƒG H
Epsilon
ƒƒH O
)
ƒƒO P
{
≈≈ !
ClearAndRefreshMesh
∆∆ '
(
∆∆' (
mesh
∆∆( ,
)
∆∆, -
;
∆∆- .
Log
«« 
.
«« 
PopLogLevel
«« #
(
««# $
)
««$ %
;
««% &
return
»» 
new
»» 
ActionResult
»» +
(
»»+ ,
ActionResult
»», 8
.
»»8 9
Status
»»9 ?
.
»»? @
Failure
»»@ G
,
»»G H
$str
»»I a
)
»»a b
;
»»b c
}
…… 
mesh
ÀÀ 
.
ÀÀ 
Clear
ÀÀ 
(
ÀÀ 
)
ÀÀ 
;
ÀÀ 
mesh
ÕÕ 
.
ÕÕ 
positionsInternal
ÕÕ &
=
ÕÕ' (
combinedVertices
ÕÕ) 9
;
ÕÕ9 :
var
ŒŒ 
newFace
ŒŒ 
=
ŒŒ 
new
ŒŒ !
Face
ŒŒ" &
(
ŒŒ& '
indexes
ŒŒ' .
)
ŒŒ. /
;
ŒŒ/ 0
mesh
œœ 
.
œœ 
facesInternal
œœ "
=
œœ# $
new
œœ% (
[
œœ( )
]
œœ) *
{
œœ+ ,
newFace
œœ- 4
}
œœ5 6
;
œœ6 7
mesh
–– 
.
–– $
sharedVerticesInternal
–– +
=
––, -
SharedVertex
––. :
.
––: ;,
GetSharedVerticesWithPositions
––; Y
(
––Y Z
combinedVertices
––Z j
)
––j k
;
––k l
mesh
—— 
.
—— 
InvalidateCaches
—— %
(
——% &
)
——& '
;
——' (
if
‘‘ 
(
‘‘ 
newFace
‘‘ 
.
‘‘ %
distinctIndexesInternal
‘‘ 3
.
‘‘3 4
Length
‘‘4 :
!=
‘‘; =
combinedVertices
‘‘> N
.
‘‘N O
Length
‘‘O U
)
‘‘U V
{
’’ !
ClearAndRefreshMesh
÷÷ '
(
÷÷' (
mesh
÷÷( ,
)
÷÷, -
;
÷÷- .
Log
◊◊ 
.
◊◊ 
PopLogLevel
◊◊ #
(
◊◊# $
)
◊◊$ %
;
◊◊% &
return
ÿÿ 
new
ÿÿ 
ActionResult
ÿÿ +
(
ÿÿ+ ,
ActionResult
ÿÿ, 8
.
ÿÿ8 9
Status
ÿÿ9 ?
.
ÿÿ? @
Failure
ÿÿ@ G
,
ÿÿG H
$str
ÿÿI g
)
ÿÿg h
;
ÿÿh i
}
ŸŸ 
Vector3
€€ 
nrm
€€ 
=
€€ 
Math
€€ "
.
€€" #
Normal
€€# )
(
€€) *
mesh
€€* .
,
€€. /
mesh
€€0 4
.
€€4 5
facesInternal
€€5 B
[
€€B C
$num
€€C D
]
€€D E
)
€€E F
;
€€F G
nrm
‹‹ 
=
‹‹ 
mesh
‹‹ 
.
‹‹ 

gameObject
‹‹ %
.
‹‹% &
	transform
‹‹& /
.
‹‹/ 0 
TransformDirection
‹‹0 B
(
‹‹B C
nrm
‹‹C F
)
‹‹F G
;
‹‹G H
if
›› 
(
›› 
(
›› 
flipNormals
››  
?
››! "
Vector3
››# *
.
››* +
Dot
››+ .
(
››. /
mesh
››/ 3
.
››3 4

gameObject
››4 >
.
››> ?
	transform
››? H
.
››H I
up
››I K
,
››K L
nrm
››M P
)
››P Q
>
››R S
$num
››T V
:
››W X
Vector3
››Y `
.
››` a
Dot
››a d
(
››d e
mesh
››e i
.
››i j

gameObject
››j t
.
››t u
	transform
››u ~
.
››~ 
up›› Å
,››Å Ç
nrm››É Ü
)››Ü á
<››à â
$num››ä å
)››å ç
)››ç é
{
ﬁﬁ 
mesh
ﬂﬂ 
.
ﬂﬂ 
facesInternal
ﬂﬂ &
[
ﬂﬂ& '
$num
ﬂﬂ' (
]
ﬂﬂ( )
.
ﬂﬂ) *
Reverse
ﬂﬂ* 1
(
ﬂﬂ1 2
)
ﬂﬂ2 3
;
ﬂﬂ3 4
}
‡‡ 
if
‚‚ 
(
‚‚ 
extrude
‚‚ 
!=
‚‚ 
$num
‚‚ #
)
‚‚# $
{
„„ 
mesh
‰‰ 
.
‰‰ 
DuplicateAndFlip
‰‰ )
(
‰‰) *
mesh
‰‰* .
.
‰‰. /
facesInternal
‰‰/ <
)
‰‰< =
;
‰‰= >
mesh
ÊÊ 
.
ÊÊ 
Extrude
ÊÊ  
(
ÊÊ  !
new
ÊÊ! $
Face
ÊÊ% )
[
ÊÊ) *
]
ÊÊ* +
{
ÊÊ, -
(
ÊÊ. /
flipNormals
ÊÊ/ :
?
ÊÊ; <
mesh
ÊÊ= A
.
ÊÊA B
facesInternal
ÊÊB O
[
ÊÊO P
$num
ÊÊP Q
]
ÊÊQ R
:
ÊÊS T
mesh
ÊÊU Y
.
ÊÊY Z
facesInternal
ÊÊZ g
[
ÊÊg h
$num
ÊÊh i
]
ÊÊi j
)
ÊÊj k
}
ÊÊl m
,
ÊÊm n
ExtrudeMethod
ÊÊo |
.
ÊÊ| }
IndividualFacesÊÊ} å
,ÊÊå ç
extrudeÊÊé ï
)ÊÊï ñ
;ÊÊñ ó
if
ËË 
(
ËË 
(
ËË 
extrude
ËË  
<
ËË! "
$num
ËË# %
&&
ËË& (
!
ËË) *
flipNormals
ËË* 5
)
ËË5 6
||
ËË7 9
(
ËË: ;
extrude
ËË; B
>
ËËC D
$num
ËËE G
&&
ËËH J
flipNormals
ËËK V
)
ËËV W
)
ËËW X
{
ÈÈ 
foreach
ÍÍ 
(
ÍÍ  !
var
ÍÍ! $
face
ÍÍ% )
in
ÍÍ* ,
mesh
ÍÍ- 1
.
ÍÍ1 2
facesInternal
ÍÍ2 ?
)
ÍÍ? @
face
ÎÎ  
.
ÎÎ  !
Reverse
ÎÎ! (
(
ÎÎ( )
)
ÎÎ) *
;
ÎÎ* +
}
ÏÏ 
}
ÌÌ 
mesh
ÔÔ 
.
ÔÔ 
ToMesh
ÔÔ 
(
ÔÔ 
)
ÔÔ 
;
ÔÔ 
mesh
 
.
 
Refresh
 
(
 
)
 
;
 
}
ÒÒ 
else
ÚÚ 
{
ÛÛ !
ClearAndRefreshMesh
ıı #
(
ıı# $
mesh
ıı$ (
)
ıı( )
;
ıı) *
Log
ˆˆ 
.
ˆˆ 
PopLogLevel
ˆˆ 
(
ˆˆ  
)
ˆˆ  !
;
ˆˆ! "
return
˜˜ 
new
˜˜ 
ActionResult
˜˜ '
(
˜˜' (
ActionResult
˜˜( 4
.
˜˜4 5
Status
˜˜5 ;
.
˜˜; <
Failure
˜˜< C
,
˜˜C D
$str
˜˜E b
)
˜˜b c
;
˜˜c d
}
¯¯ 
Log
˙˙ 
.
˙˙ 
PopLogLevel
˙˙ 
(
˙˙ 
)
˙˙ 
;
˙˙ 
return
¸¸ 
new
¸¸ 
ActionResult
¸¸ #
(
¸¸# $
ActionResult
¸¸$ 0
.
¸¸0 1
Status
¸¸1 7
.
¸¸7 8
Success
¸¸8 ?
,
¸¸? @
$str
¸¸A W
)
¸¸W X
;
¸¸X Y
}
˝˝ 	
internal
ÖÖ 
static
ÖÖ 
FaceRebuildData
ÖÖ '
FaceWithVertices
ÖÖ( 8
(
ÖÖ8 9
List
ÖÖ9 =
<
ÖÖ= >
Vertex
ÖÖ> D
>
ÖÖD E
vertices
ÖÖF N
,
ÖÖN O
bool
ÖÖP T
	unordered
ÖÖU ^
=
ÖÖ_ `
true
ÖÖa e
)
ÖÖe f
{
ÜÜ 	
List
áá 
<
áá 
int
áá 
>
áá 
	triangles
áá 
;
áá  
if
ââ 
(
ââ 
Triangulation
ââ 
.
ââ !
TriangulateVertices
ââ 1
(
ââ1 2
vertices
ââ2 :
,
ââ: ;
out
ââ< ?
	triangles
ââ@ I
,
ââI J
	unordered
ââK T
)
ââT U
)
ââU V
{
ää 
FaceRebuildData
ãã 
data
ãã  $
=
ãã% &
new
ãã' *
FaceRebuildData
ãã+ :
(
ãã: ;
)
ãã; <
;
ãã< =
data
åå 
.
åå 
vertices
åå 
=
åå 
vertices
åå  (
;
åå( )
data
çç 
.
çç 
face
çç 
=
çç 
new
çç 
Face
çç  $
(
çç$ %
	triangles
çç% .
)
çç. /
;
çç/ 0
return
éé 
data
éé 
;
éé 
}
èè 
return
ëë 
null
ëë 
;
ëë 
}
íí 	
internal
ôô 
static
ôô 
List
ôô 
<
ôô 
FaceRebuildData
ôô ,
>
ôô, -!
TentCapWithVertices
ôô. A
(
ôôA B
List
ôôB F
<
ôôF G
Vertex
ôôG M
>
ôôM N
path
ôôO S
)
ôôS T
{
öö 	
int
õõ 
count
õõ 
=
õõ 
path
õõ 
.
õõ 
Count
õõ "
;
õõ" #
Vertex
úú 
center
úú 
=
úú 
Vertex
úú "
.
úú" #
Average
úú# *
(
úú* +
path
úú+ /
)
úú/ 0
;
úú0 1
List
ùù 
<
ùù 
FaceRebuildData
ùù  
>
ùù  !
faces
ùù" '
=
ùù( )
new
ùù* -
List
ùù. 2
<
ùù2 3
FaceRebuildData
ùù3 B
>
ùùB C
(
ùùC D
)
ùùD E
;
ùùE F
for
üü 
(
üü 
int
üü 
i
üü 
=
üü 
$num
üü 
;
üü 
i
üü 
<
üü 
count
üü  %
;
üü% &
i
üü' (
++
üü( *
)
üü* +
{
†† 
List
°° 
<
°° 
Vertex
°° 
>
°° 
vertices
°° %
=
°°& '
new
°°( +
List
°°, 0
<
°°0 1
Vertex
°°1 7
>
°°7 8
(
°°8 9
)
°°9 :
{
¢¢ 
path
££ 
[
££ 
i
££ 
]
££ 
,
££ 
center
§§ 
,
§§ 
path
•• 
[
•• 
(
•• 
i
•• 
+
•• 
$num
•• 
)
••  
%
••! "
count
••# (
]
••( )
}
¶¶ 
;
¶¶ 
FaceRebuildData
®® 
data
®®  $
=
®®% &
new
®®' *
FaceRebuildData
®®+ :
(
®®: ;
)
®®; <
;
®®< =
data
©© 
.
©© 
vertices
©© 
=
©© 
vertices
©©  (
;
©©( )
data
™™ 
.
™™ 
face
™™ 
=
™™ 
new
™™ 
Face
™™  $
(
™™$ %
new
™™% (
int
™™) ,
[
™™, -
]
™™- .
{
™™/ 0
$num
™™0 1
,
™™2 3
$num
™™4 5
,
™™5 6
$num
™™7 8
}
™™8 9
)
™™9 :
;
™™: ;
faces
¨¨ 
.
¨¨ 
Add
¨¨ 
(
¨¨ 
data
¨¨ 
)
¨¨ 
;
¨¨  
}
≠≠ 
return
ØØ 
faces
ØØ 
;
ØØ 
}
∞∞ 	
public
∑∑ 
static
∑∑ 
void
∑∑ 
DuplicateAndFlip
∑∑ +
(
∑∑+ ,
this
∑∑, 0
ProBuilderMesh
∑∑1 ?
mesh
∑∑@ D
,
∑∑D E
Face
∑∑F J
[
∑∑J K
]
∑∑K L
faces
∑∑M R
)
∑∑R S
{
∏∏ 	
if
ππ 
(
ππ 
mesh
ππ 
==
ππ 
null
ππ 
)
ππ 
throw
∫∫ 
new
∫∫ #
ArgumentNullException
∫∫ /
(
∫∫/ 0
$str
∫∫0 6
)
∫∫6 7
;
∫∫7 8
if
ºº 
(
ºº 
faces
ºº 
==
ºº 
null
ºº 
)
ºº 
throw
ΩΩ 
new
ΩΩ #
ArgumentNullException
ΩΩ /
(
ΩΩ/ 0
$str
ΩΩ0 7
)
ΩΩ7 8
;
ΩΩ8 9
List
øø 
<
øø 
FaceRebuildData
øø  
>
øø  !
rebuild
øø" )
=
øø* +
new
øø, /
List
øø0 4
<
øø4 5
FaceRebuildData
øø5 D
>
øøD E
(
øøE F
)
øøF G
;
øøG H
List
¿¿ 
<
¿¿ 
Vertex
¿¿ 
>
¿¿ 
vertices
¿¿ !
=
¿¿" #
new
¿¿$ '
List
¿¿( ,
<
¿¿, -
Vertex
¿¿- 3
>
¿¿3 4
(
¿¿4 5
mesh
¿¿5 9
.
¿¿9 :
GetVertices
¿¿: E
(
¿¿E F
)
¿¿F G
)
¿¿G H
;
¿¿H I

Dictionary
¡¡ 
<
¡¡ 
int
¡¡ 
,
¡¡ 
int
¡¡ 
>
¡¡  
lookup
¡¡! '
=
¡¡( )
mesh
¡¡* .
.
¡¡. / 
sharedVertexLookup
¡¡/ A
;
¡¡A B
foreach
√√ 
(
√√ 
Face
√√ 
face
√√ 
in
√√ !
faces
√√" '
)
√√' (
{
ƒƒ 
FaceRebuildData
≈≈ 
data
≈≈  $
=
≈≈% &
new
≈≈' *
FaceRebuildData
≈≈+ :
(
≈≈: ;
)
≈≈; <
;
≈≈< =
data
«« 
.
«« 
vertices
«« 
=
«« 
new
««  #
List
««$ (
<
««( )
Vertex
««) /
>
««/ 0
(
««0 1
)
««1 2
;
««2 3
data
»» 
.
»» 
face
»» 
=
»» 
new
»» 
Face
»»  $
(
»»$ %
face
»»% )
)
»») *
;
»»* +
data
…… 
.
…… 
sharedIndexes
…… "
=
……# $
new
……% (
List
……) -
<
……- .
int
……. 1
>
……1 2
(
……2 3
)
……3 4
;
……4 5

Dictionary
ÀÀ 
<
ÀÀ 
int
ÀÀ 
,
ÀÀ 
int
ÀÀ  #
>
ÀÀ# $
map
ÀÀ% (
=
ÀÀ) *
new
ÀÀ+ .

Dictionary
ÀÀ/ 9
<
ÀÀ9 :
int
ÀÀ: =
,
ÀÀ= >
int
ÀÀ? B
>
ÀÀB C
(
ÀÀC D
)
ÀÀD E
;
ÀÀE F
int
ÃÃ 
len
ÃÃ 
=
ÃÃ 
data
ÃÃ 
.
ÃÃ 
face
ÃÃ #
.
ÃÃ# $
indexesInternal
ÃÃ$ 3
.
ÃÃ3 4
Length
ÃÃ4 :
;
ÃÃ: ;
for
ŒŒ 
(
ŒŒ 
int
ŒŒ 
i
ŒŒ 
=
ŒŒ 
$num
ŒŒ 
;
ŒŒ 
i
ŒŒ  !
<
ŒŒ" #
len
ŒŒ$ '
;
ŒŒ' (
i
ŒŒ) *
++
ŒŒ* ,
)
ŒŒ, -
{
œœ 
if
–– 
(
–– 
map
–– 
.
–– 
ContainsKey
–– '
(
––' (
face
––( ,
.
––, -
indexesInternal
––- <
[
––< =
i
––= >
]
––> ?
)
––? @
)
––@ A
continue
——  
;
——  !
map
”” 
.
”” 
Add
”” 
(
”” 
face
””  
.
””  !
indexesInternal
””! 0
[
””0 1
i
””1 2
]
””2 3
,
””3 4
map
””5 8
.
””8 9
Count
””9 >
)
””> ?
;
””? @
data
‘‘ 
.
‘‘ 
vertices
‘‘ !
.
‘‘! "
Add
‘‘" %
(
‘‘% &
vertices
‘‘& .
[
‘‘. /
face
‘‘/ 3
.
‘‘3 4
indexesInternal
‘‘4 C
[
‘‘C D
i
‘‘D E
]
‘‘E F
]
‘‘F G
)
‘‘G H
;
‘‘H I
data
’’ 
.
’’ 
sharedIndexes
’’ &
.
’’& '
Add
’’' *
(
’’* +
lookup
’’+ 1
[
’’1 2
face
’’2 6
.
’’6 7
indexesInternal
’’7 F
[
’’F G
i
’’G H
]
’’H I
]
’’I J
)
’’J K
;
’’K L
}
÷÷ 
int
ÿÿ 
[
ÿÿ 
]
ÿÿ 
tris
ÿÿ 
=
ÿÿ 
new
ÿÿ  
int
ÿÿ! $
[
ÿÿ$ %
len
ÿÿ% (
]
ÿÿ( )
;
ÿÿ) *
for
⁄⁄ 
(
⁄⁄ 
var
⁄⁄ 
i
⁄⁄ 
=
⁄⁄ 
$num
⁄⁄ 
;
⁄⁄ 
i
⁄⁄  !
<
⁄⁄" #
len
⁄⁄$ '
;
⁄⁄' (
i
⁄⁄) *
++
⁄⁄* ,
)
⁄⁄, -
tris
€€ 
[
€€ 
len
€€ 
-
€€ 
(
€€  
i
€€  !
+
€€" #
$num
€€$ %
)
€€% &
]
€€& '
=
€€( )
map
€€* -
[
€€- .
data
€€. 2
.
€€2 3
face
€€3 7
[
€€7 8
i
€€8 9
]
€€9 :
]
€€: ;
;
€€; <
data
›› 
.
›› 
face
›› 
.
›› 

SetIndexes
›› $
(
››$ %
tris
››% )
)
››) *
;
››* +
rebuild
ﬂﬂ 
.
ﬂﬂ 
Add
ﬂﬂ 
(
ﬂﬂ 
data
ﬂﬂ  
)
ﬂﬂ  !
;
ﬂﬂ! "
}
‡‡ 
FaceRebuildData
‚‚ 
.
‚‚ 
Apply
‚‚ !
(
‚‚! "
rebuild
‚‚" )
,
‚‚) *
mesh
‚‚+ /
,
‚‚/ 0
vertices
‚‚1 9
)
‚‚9 :
;
‚‚: ;
}
„„ 	
public
ÌÌ 
static
ÌÌ 
Face
ÌÌ 
Bridge
ÌÌ !
(
ÌÌ! "
this
ÌÌ" &
ProBuilderMesh
ÌÌ' 5
mesh
ÌÌ6 :
,
ÌÌ: ;
Edge
ÌÌ< @
a
ÌÌA B
,
ÌÌB C
Edge
ÌÌD H
b
ÌÌI J
,
ÌÌJ K
bool
ÌÌL P&
allowNonManifoldGeometry
ÌÌQ i
=
ÌÌj k
false
ÌÌl q
)
ÌÌq r
{
ÓÓ 	
if
ÔÔ 
(
ÔÔ 
mesh
ÔÔ 
==
ÔÔ 
null
ÔÔ 
)
ÔÔ 
throw
 
new
 #
ArgumentNullException
 /
(
/ 0
$str
0 6
)
6 7
;
7 8
SharedVertex
ÚÚ 
[
ÚÚ 
]
ÚÚ 
sharedVertices
ÚÚ )
=
ÚÚ* +
mesh
ÚÚ, 0
.
ÚÚ0 1$
sharedVerticesInternal
ÚÚ1 G
;
ÚÚG H

Dictionary
ÛÛ 
<
ÛÛ 
int
ÛÛ 
,
ÛÛ 
int
ÛÛ 
>
ÛÛ  
lookup
ÛÛ! '
=
ÛÛ( )
mesh
ÛÛ* .
.
ÛÛ. / 
sharedVertexLookup
ÛÛ/ A
;
ÛÛA B
if
ˆˆ 
(
ˆˆ 
!
ˆˆ &
allowNonManifoldGeometry
ˆˆ )
)
ˆˆ) *
{
˜˜ 
if
¯¯ 
(
¯¯ 
ElementSelection
¯¯ $
.
¯¯$ %
GetNeighborFaces
¯¯% 5
(
¯¯5 6
mesh
¯¯6 :
,
¯¯: ;
a
¯¯< =
)
¯¯= >
.
¯¯> ?
Count
¯¯? D
>
¯¯E F
$num
¯¯G H
||
¯¯I K
ElementSelection
¯¯L \
.
¯¯\ ]
GetNeighborFaces
¯¯] m
(
¯¯m n
mesh
¯¯n r
,
¯¯r s
b
¯¯t u
)
¯¯u v
.
¯¯v w
Count
¯¯w |
>
¯¯} ~
$num¯¯ Ä
)¯¯Ä Å
{
˘˘ 
return
˙˙ 
null
˙˙ 
;
˙˙  
}
˚˚ 
}
¸¸ 
foreach
˛˛ 
(
˛˛ 
Face
˛˛ 
face
˛˛ 
in
˛˛ !
mesh
˛˛" &
.
˛˛& '
facesInternal
˛˛' 4
)
˛˛4 5
{
ˇˇ 
if
ÄÄ 
(
ÄÄ 
mesh
ÄÄ 
.
ÄÄ 
IndexOf
ÄÄ  
(
ÄÄ  !
face
ÄÄ! %
.
ÄÄ% &
edgesInternal
ÄÄ& 3
,
ÄÄ3 4
a
ÄÄ5 6
)
ÄÄ6 7
>=
ÄÄ8 :
$num
ÄÄ; <
&&
ÄÄ= ?
mesh
ÄÄ@ D
.
ÄÄD E
IndexOf
ÄÄE L
(
ÄÄL M
face
ÄÄM Q
.
ÄÄQ R
edgesInternal
ÄÄR _
,
ÄÄ_ `
b
ÄÄa b
)
ÄÄb c
>=
ÄÄd f
$num
ÄÄg h
)
ÄÄh i
{
ÅÅ 
Log
ÇÇ 
.
ÇÇ 
Warning
ÇÇ 
(
ÇÇ  
$str
ÇÇ  N
)
ÇÇN O
;
ÇÇO P
return
ÉÉ 
null
ÉÉ 
;
ÉÉ  
}
ÑÑ 
}
ÖÖ 
Vector3
áá 
[
áá 
]
áá 
	positions
áá 
=
áá  !
mesh
áá" &
.
áá& '
positionsInternal
áá' 8
;
áá8 9
bool
àà 
	hasColors
àà 
=
àà 
mesh
àà !
.
àà! "
	HasArrays
àà" +
(
àà+ ,

MeshArrays
àà, 6
.
àà6 7
Color
àà7 <
)
àà< =
;
àà= >
Color
ââ 
[
ââ 
]
ââ 
colors
ââ 
=
ââ 
	hasColors
ââ &
?
ââ' (
mesh
ââ) -
.
ââ- .
colorsInternal
ââ. <
:
ââ= >
null
ââ? C
;
ââC D
Vector3
ãã 
[
ãã 
]
ãã 
v
ãã 
;
ãã 
Color
åå 
[
åå 
]
åå 
c
åå 
;
åå 
int
çç 
[
çç 
]
çç 
s
çç 
;
çç  
AutoUnwrapSettings
éé 
uvs
éé "
=
éé# $ 
AutoUnwrapSettings
éé% 7
.
éé7 8
tile
éé8 <
;
éé< =
int
èè 
submeshIndex
èè 
=
èè 
$num
èè  
;
èè  !
SimpleTuple
íí 
<
íí 
Face
íí 
,
íí 
Edge
íí "
>
íí" #
faceAndEdge
íí$ /
;
íí/ 0
if
îî 
(
îî 
EdgeUtility
îî 
.
îî 
ValidateEdge
îî (
(
îî( )
mesh
îî) -
,
îî- .
a
îî/ 0
,
îî0 1
out
îî2 5
faceAndEdge
îî6 A
)
îîA B
||
îîC E
EdgeUtility
îîF Q
.
îîQ R
ValidateEdge
îîR ^
(
îî^ _
mesh
îî_ c
,
îîc d
b
îîe f
,
îîf g
out
îîh k
faceAndEdge
îîl w
)
îîw x
)
îîx y
{
ïï 
uvs
ññ 
=
ññ 
new
ññ  
AutoUnwrapSettings
ññ ,
(
ññ, -
faceAndEdge
ññ- 8
.
ññ8 9
item1
ññ9 >
.
ññ> ?
uv
ññ? A
)
ññA B
;
ññB C
submeshIndex
óó 
=
óó 
faceAndEdge
óó *
.
óó* +
item1
óó+ 0
.
óó0 1
submeshIndex
óó1 =
;
óó= >
}
òò 
if
õõ 
(
õõ 
a
õõ 
.
õõ 
Contains
õõ 
(
õõ 
b
õõ 
.
õõ 
a
õõ 
,
õõ 
lookup
õõ  &
)
õõ& '
||
õõ( *
a
õõ+ ,
.
õõ, -
Contains
õõ- 5
(
õõ5 6
b
õõ6 7
.
õõ7 8
b
õõ8 9
,
õõ9 :
lookup
õõ; A
)
õõA B
)
õõB C
{
úú 
v
ùù 
=
ùù 
new
ùù 
Vector3
ùù 
[
ùù  
$num
ùù  !
]
ùù! "
;
ùù" #
c
ûû 
=
ûû 
new
ûû 
Color
ûû 
[
ûû 
$num
ûû 
]
ûû  
;
ûû  !
s
üü 
=
üü 
new
üü 
int
üü 
[
üü 
$num
üü 
]
üü 
;
üü 
bool
°° 
axbx
°° 
=
°° 
Array
°° !
.
°°! "
IndexOf
°°" )
(
°°) *
sharedVertices
°°* 8
[
°°8 9
mesh
°°9 =
.
°°= >#
GetSharedVertexHandle
°°> S
(
°°S T
a
°°T U
.
°°U V
a
°°V W
)
°°W X
]
°°X Y
.
°°Y Z
arrayInternal
°°Z g
,
°°g h
b
°°i j
.
°°j k
a
°°k l
)
°°l m
>
°°n o
-
°°p q
$num
°°q r
;
°°r s
bool
¢¢ 
axby
¢¢ 
=
¢¢ 
Array
¢¢ !
.
¢¢! "
IndexOf
¢¢" )
(
¢¢) *
sharedVertices
¢¢* 8
[
¢¢8 9
mesh
¢¢9 =
.
¢¢= >#
GetSharedVertexHandle
¢¢> S
(
¢¢S T
a
¢¢T U
.
¢¢U V
a
¢¢V W
)
¢¢W X
]
¢¢X Y
.
¢¢Y Z
arrayInternal
¢¢Z g
,
¢¢g h
b
¢¢i j
.
¢¢j k
b
¢¢k l
)
¢¢l m
>
¢¢n o
-
¢¢p q
$num
¢¢q r
;
¢¢r s
bool
§§ 
aybx
§§ 
=
§§ 
Array
§§ !
.
§§! "
IndexOf
§§" )
(
§§) *
sharedVertices
§§* 8
[
§§8 9
mesh
§§9 =
.
§§= >#
GetSharedVertexHandle
§§> S
(
§§S T
a
§§T U
.
§§U V
b
§§V W
)
§§W X
]
§§X Y
.
§§Y Z
arrayInternal
§§Z g
,
§§g h
b
§§i j
.
§§j k
a
§§k l
)
§§l m
>
§§n o
-
§§p q
$num
§§q r
;
§§r s
bool
•• 
ayby
•• 
=
•• 
Array
•• !
.
••! "
IndexOf
••" )
(
••) *
sharedVertices
••* 8
[
••8 9
mesh
••9 =
.
••= >#
GetSharedVertexHandle
••> S
(
••S T
a
••T U
.
••U V
b
••V W
)
••W X
]
••X Y
.
••Y Z
arrayInternal
••Z g
,
••g h
b
••i j
.
••j k
b
••k l
)
••l m
>
••n o
-
••p q
$num
••q r
;
••r s
if
ßß 
(
ßß 
axbx
ßß 
)
ßß 
{
®® 
v
©© 
[
©© 
$num
©© 
]
©© 
=
©© 
	positions
©© $
[
©©$ %
a
©©% &
.
©©& '
a
©©' (
]
©©( )
;
©©) *
if
™™ 
(
™™ 
	hasColors
™™ !
)
™™! "
c
™™# $
[
™™$ %
$num
™™% &
]
™™& '
=
™™( )
colors
™™* 0
[
™™0 1
a
™™1 2
.
™™2 3
a
™™3 4
]
™™4 5
;
™™5 6
s
´´ 
[
´´ 
$num
´´ 
]
´´ 
=
´´ 
mesh
´´ 
.
´´  #
GetSharedVertexHandle
´´  5
(
´´5 6
a
´´6 7
.
´´7 8
a
´´8 9
)
´´9 :
;
´´: ;
v
¨¨ 
[
¨¨ 
$num
¨¨ 
]
¨¨ 
=
¨¨ 
	positions
¨¨ $
[
¨¨$ %
a
¨¨% &
.
¨¨& '
b
¨¨' (
]
¨¨( )
;
¨¨) *
if
≠≠ 
(
≠≠ 
	hasColors
≠≠ !
)
≠≠! "
c
≠≠# $
[
≠≠$ %
$num
≠≠% &
]
≠≠& '
=
≠≠( )
colors
≠≠* 0
[
≠≠0 1
a
≠≠1 2
.
≠≠2 3
b
≠≠3 4
]
≠≠4 5
;
≠≠5 6
s
ÆÆ 
[
ÆÆ 
$num
ÆÆ 
]
ÆÆ 
=
ÆÆ 
mesh
ÆÆ 
.
ÆÆ  #
GetSharedVertexHandle
ÆÆ  5
(
ÆÆ5 6
a
ÆÆ6 7
.
ÆÆ7 8
b
ÆÆ8 9
)
ÆÆ9 :
;
ÆÆ: ;
v
ØØ 
[
ØØ 
$num
ØØ 
]
ØØ 
=
ØØ 
	positions
ØØ $
[
ØØ$ %
b
ØØ% &
.
ØØ& '
b
ØØ' (
]
ØØ( )
;
ØØ) *
if
∞∞ 
(
∞∞ 
	hasColors
∞∞ !
)
∞∞! "
c
∞∞# $
[
∞∞$ %
$num
∞∞% &
]
∞∞& '
=
∞∞( )
colors
∞∞* 0
[
∞∞0 1
b
∞∞1 2
.
∞∞2 3
b
∞∞3 4
]
∞∞4 5
;
∞∞5 6
s
±± 
[
±± 
$num
±± 
]
±± 
=
±± 
mesh
±± 
.
±±  #
GetSharedVertexHandle
±±  5
(
±±5 6
b
±±6 7
.
±±7 8
b
±±8 9
)
±±9 :
;
±±: ;
}
≤≤ 
else
≥≥ 
if
≥≥ 
(
≥≥ 
axby
≥≥ 
)
≥≥ 
{
¥¥ 
v
µµ 
[
µµ 
$num
µµ 
]
µµ 
=
µµ 
	positions
µµ $
[
µµ$ %
a
µµ% &
.
µµ& '
a
µµ' (
]
µµ( )
;
µµ) *
if
∂∂ 
(
∂∂ 
	hasColors
∂∂ !
)
∂∂! "
c
∂∂# $
[
∂∂$ %
$num
∂∂% &
]
∂∂& '
=
∂∂( )
colors
∂∂* 0
[
∂∂0 1
a
∂∂1 2
.
∂∂2 3
a
∂∂3 4
]
∂∂4 5
;
∂∂5 6
s
∑∑ 
[
∑∑ 
$num
∑∑ 
]
∑∑ 
=
∑∑ 
mesh
∑∑ 
.
∑∑  #
GetSharedVertexHandle
∑∑  5
(
∑∑5 6
a
∑∑6 7
.
∑∑7 8
a
∑∑8 9
)
∑∑9 :
;
∑∑: ;
v
∏∏ 
[
∏∏ 
$num
∏∏ 
]
∏∏ 
=
∏∏ 
	positions
∏∏ $
[
∏∏$ %
a
∏∏% &
.
∏∏& '
b
∏∏' (
]
∏∏( )
;
∏∏) *
if
ππ 
(
ππ 
	hasColors
ππ !
)
ππ! "
c
ππ# $
[
ππ$ %
$num
ππ% &
]
ππ& '
=
ππ( )
colors
ππ* 0
[
ππ0 1
a
ππ1 2
.
ππ2 3
b
ππ3 4
]
ππ4 5
;
ππ5 6
s
∫∫ 
[
∫∫ 
$num
∫∫ 
]
∫∫ 
=
∫∫ 
mesh
∫∫ 
.
∫∫  #
GetSharedVertexHandle
∫∫  5
(
∫∫5 6
a
∫∫6 7
.
∫∫7 8
b
∫∫8 9
)
∫∫9 :
;
∫∫: ;
v
ªª 
[
ªª 
$num
ªª 
]
ªª 
=
ªª 
	positions
ªª $
[
ªª$ %
b
ªª% &
.
ªª& '
a
ªª' (
]
ªª( )
;
ªª) *
if
ºº 
(
ºº 
	hasColors
ºº !
)
ºº! "
c
ºº# $
[
ºº$ %
$num
ºº% &
]
ºº& '
=
ºº( )
colors
ºº* 0
[
ºº0 1
b
ºº1 2
.
ºº2 3
a
ºº3 4
]
ºº4 5
;
ºº5 6
s
ΩΩ 
[
ΩΩ 
$num
ΩΩ 
]
ΩΩ 
=
ΩΩ 
mesh
ΩΩ 
.
ΩΩ  #
GetSharedVertexHandle
ΩΩ  5
(
ΩΩ5 6
b
ΩΩ6 7
.
ΩΩ7 8
a
ΩΩ8 9
)
ΩΩ9 :
;
ΩΩ: ;
}
ææ 
else
øø 
if
øø 
(
øø 
aybx
øø 
)
øø 
{
¿¿ 
v
¡¡ 
[
¡¡ 
$num
¡¡ 
]
¡¡ 
=
¡¡ 
	positions
¡¡ $
[
¡¡$ %
a
¡¡% &
.
¡¡& '
b
¡¡' (
]
¡¡( )
;
¡¡) *
if
¬¬ 
(
¬¬ 
	hasColors
¬¬ !
)
¬¬! "
c
¬¬# $
[
¬¬$ %
$num
¬¬% &
]
¬¬& '
=
¬¬( )
colors
¬¬* 0
[
¬¬0 1
a
¬¬1 2
.
¬¬2 3
b
¬¬3 4
]
¬¬4 5
;
¬¬5 6
s
√√ 
[
√√ 
$num
√√ 
]
√√ 
=
√√ 
mesh
√√ 
.
√√  #
GetSharedVertexHandle
√√  5
(
√√5 6
a
√√6 7
.
√√7 8
b
√√8 9
)
√√9 :
;
√√: ;
v
ƒƒ 
[
ƒƒ 
$num
ƒƒ 
]
ƒƒ 
=
ƒƒ 
	positions
ƒƒ $
[
ƒƒ$ %
a
ƒƒ% &
.
ƒƒ& '
a
ƒƒ' (
]
ƒƒ( )
;
ƒƒ) *
if
≈≈ 
(
≈≈ 
	hasColors
≈≈ !
)
≈≈! "
c
≈≈# $
[
≈≈$ %
$num
≈≈% &
]
≈≈& '
=
≈≈( )
colors
≈≈* 0
[
≈≈0 1
a
≈≈1 2
.
≈≈2 3
a
≈≈3 4
]
≈≈4 5
;
≈≈5 6
s
∆∆ 
[
∆∆ 
$num
∆∆ 
]
∆∆ 
=
∆∆ 
mesh
∆∆ 
.
∆∆  #
GetSharedVertexHandle
∆∆  5
(
∆∆5 6
a
∆∆6 7
.
∆∆7 8
a
∆∆8 9
)
∆∆9 :
;
∆∆: ;
v
«« 
[
«« 
$num
«« 
]
«« 
=
«« 
	positions
«« $
[
««$ %
b
««% &
.
««& '
b
««' (
]
««( )
;
««) *
if
»» 
(
»» 
	hasColors
»» !
)
»»! "
c
»»# $
[
»»$ %
$num
»»% &
]
»»& '
=
»»( )
colors
»»* 0
[
»»0 1
b
»»1 2
.
»»2 3
b
»»3 4
]
»»4 5
;
»»5 6
s
…… 
[
…… 
$num
…… 
]
…… 
=
…… 
mesh
…… 
.
……  #
GetSharedVertexHandle
……  5
(
……5 6
b
……6 7
.
……7 8
b
……8 9
)
……9 :
;
……: ;
}
   
else
ÀÀ 
if
ÀÀ 
(
ÀÀ 
ayby
ÀÀ 
)
ÀÀ 
{
ÃÃ 
v
ÕÕ 
[
ÕÕ 
$num
ÕÕ 
]
ÕÕ 
=
ÕÕ 
	positions
ÕÕ $
[
ÕÕ$ %
a
ÕÕ% &
.
ÕÕ& '
b
ÕÕ' (
]
ÕÕ( )
;
ÕÕ) *
if
ŒŒ 
(
ŒŒ 
	hasColors
ŒŒ !
)
ŒŒ! "
c
ŒŒ# $
[
ŒŒ$ %
$num
ŒŒ% &
]
ŒŒ& '
=
ŒŒ( )
colors
ŒŒ* 0
[
ŒŒ0 1
a
ŒŒ1 2
.
ŒŒ2 3
b
ŒŒ3 4
]
ŒŒ4 5
;
ŒŒ5 6
s
œœ 
[
œœ 
$num
œœ 
]
œœ 
=
œœ 
mesh
œœ 
.
œœ  #
GetSharedVertexHandle
œœ  5
(
œœ5 6
a
œœ6 7
.
œœ7 8
b
œœ8 9
)
œœ9 :
;
œœ: ;
v
–– 
[
–– 
$num
–– 
]
–– 
=
–– 
	positions
–– $
[
––$ %
a
––% &
.
––& '
a
––' (
]
––( )
;
––) *
if
—— 
(
—— 
	hasColors
—— !
)
——! "
c
——# $
[
——$ %
$num
——% &
]
——& '
=
——( )
colors
——* 0
[
——0 1
a
——1 2
.
——2 3
a
——3 4
]
——4 5
;
——5 6
s
““ 
[
““ 
$num
““ 
]
““ 
=
““ 
mesh
““ 
.
““  #
GetSharedVertexHandle
““  5
(
““5 6
a
““6 7
.
““7 8
a
““8 9
)
““9 :
;
““: ;
v
”” 
[
”” 
$num
”” 
]
”” 
=
”” 
	positions
”” $
[
””$ %
b
””% &
.
””& '
a
””' (
]
””( )
;
””) *
if
‘‘ 
(
‘‘ 
	hasColors
‘‘ !
)
‘‘! "
c
‘‘# $
[
‘‘$ %
$num
‘‘% &
]
‘‘& '
=
‘‘( )
colors
‘‘* 0
[
‘‘0 1
b
‘‘1 2
.
‘‘2 3
a
‘‘3 4
]
‘‘4 5
;
‘‘5 6
s
’’ 
[
’’ 
$num
’’ 
]
’’ 
=
’’ 
mesh
’’ 
.
’’  #
GetSharedVertexHandle
’’  5
(
’’5 6
b
’’6 7
.
’’7 8
a
’’8 9
)
’’9 :
;
’’: ;
}
÷÷ 
return
ÿÿ 
mesh
ÿÿ 
.
ÿÿ 

AppendFace
ÿÿ &
(
ÿÿ& '
v
ŸŸ 
,
ŸŸ 
	hasColors
⁄⁄ 
?
⁄⁄ 
c
⁄⁄  !
:
⁄⁄" #
null
⁄⁄$ (
,
⁄⁄( )
new
€€ 
Vector2
€€ 
[
€€  
v
€€  !
.
€€! "
Length
€€" (
]
€€( )
,
€€) *
new
‹‹ 
Face
‹‹ 
(
‹‹ 
axbx
‹‹ !
||
‹‹" $
axby
‹‹% )
?
‹‹* +
new
‹‹, /
int
‹‹0 3
[
‹‹3 4
$num
‹‹4 5
]
‹‹5 6
{
‹‹7 8
$num
‹‹8 9
,
‹‹9 :
$num
‹‹; <
,
‹‹< =
$num
‹‹> ?
}
‹‹? @
:
‹‹A B
new
‹‹C F
int
‹‹G J
[
‹‹J K
$num
‹‹K L
]
‹‹L M
{
‹‹N O
$num
‹‹O P
,
‹‹P Q
$num
‹‹R S
,
‹‹S T
$num
‹‹U V
}
‹‹V W
,
‹‹W X
submeshIndex
‹‹Y e
,
‹‹e f
uvs
‹‹g j
,
‹‹j k
$num
‹‹l m
,
‹‹m n
-
‹‹o p
$num
‹‹p q
,
‹‹q r
-
‹‹s t
$num
‹‹t u
,
‹‹u v
false
‹‹w |
)
‹‹| }
,
‹‹} ~
s
›› 
)
›› 
;
›› 
}
ﬁﬁ 
v
‚‚ 
=
‚‚ 
new
‚‚ 
Vector3
‚‚ 
[
‚‚ 
$num
‚‚ 
]
‚‚ 
;
‚‚ 
c
„„ 
=
„„ 
new
„„ 
Color
„„ 
[
„„ 
$num
„„ 
]
„„ 
;
„„ 
s
‰‰ 
=
‰‰ 
new
‰‰ 
int
‰‰ 
[
‰‰ 
$num
‰‰ 
]
‰‰ 
;
‰‰ 
v
ÊÊ 
[
ÊÊ 
$num
ÊÊ 
]
ÊÊ 
=
ÊÊ 
	positions
ÊÊ 
[
ÊÊ 
a
ÊÊ 
.
ÊÊ 
a
ÊÊ  
]
ÊÊ  !
;
ÊÊ! "
if
ÁÁ 
(
ÁÁ 
	hasColors
ÁÁ 
)
ÁÁ 
c
ËË 
[
ËË 
$num
ËË 
]
ËË 
=
ËË 
mesh
ËË 
.
ËË 
colorsInternal
ËË *
[
ËË* +
a
ËË+ ,
.
ËË, -
a
ËË- .
]
ËË. /
;
ËË/ 0
s
ÈÈ 
[
ÈÈ 
$num
ÈÈ 
]
ÈÈ 
=
ÈÈ 
mesh
ÈÈ 
.
ÈÈ #
GetSharedVertexHandle
ÈÈ -
(
ÈÈ- .
a
ÈÈ. /
.
ÈÈ/ 0
a
ÈÈ0 1
)
ÈÈ1 2
;
ÈÈ2 3
v
ÍÍ 
[
ÍÍ 
$num
ÍÍ 
]
ÍÍ 
=
ÍÍ 
	positions
ÍÍ 
[
ÍÍ 
a
ÍÍ 
.
ÍÍ 
b
ÍÍ  
]
ÍÍ  !
;
ÍÍ! "
if
ÎÎ 
(
ÎÎ 
	hasColors
ÎÎ 
)
ÎÎ 
c
ÏÏ 
[
ÏÏ 
$num
ÏÏ 
]
ÏÏ 
=
ÏÏ 
mesh
ÏÏ 
.
ÏÏ 
colorsInternal
ÏÏ *
[
ÏÏ* +
a
ÏÏ+ ,
.
ÏÏ, -
b
ÏÏ- .
]
ÏÏ. /
;
ÏÏ/ 0
s
ÌÌ 
[
ÌÌ 
$num
ÌÌ 
]
ÌÌ 
=
ÌÌ 
mesh
ÌÌ 
.
ÌÌ #
GetSharedVertexHandle
ÌÌ -
(
ÌÌ- .
a
ÌÌ. /
.
ÌÌ/ 0
b
ÌÌ0 1
)
ÌÌ1 2
;
ÌÌ2 3
Vector3
ÔÔ 
nrm
ÔÔ 
=
ÔÔ 
Vector3
ÔÔ !
.
ÔÔ! "
Cross
ÔÔ" '
(
ÔÔ' (
	positions
ÔÔ( 1
[
ÔÔ1 2
b
ÔÔ2 3
.
ÔÔ3 4
a
ÔÔ4 5
]
ÔÔ5 6
-
ÔÔ7 8
	positions
ÔÔ9 B
[
ÔÔB C
a
ÔÔC D
.
ÔÔD E
a
ÔÔE F
]
ÔÔF G
,
ÔÔG H
	positions
ÔÔI R
[
ÔÔR S
a
ÔÔS T
.
ÔÔT U
b
ÔÔU V
]
ÔÔV W
-
ÔÔX Y
	positions
ÔÔZ c
[
ÔÔc d
a
ÔÔd e
.
ÔÔe f
a
ÔÔf g
]
ÔÔg h
)
ÔÔh i
.
ÔÔi j

normalized
ÔÔj t
;
ÔÔt u
Vector2
 
[
 
]
 
planed
 
=
 

Projection
 )
.
) *
PlanarProject
* 7
(
7 8
new
8 ;
Vector3
< C
[
C D
$num
D E
]
E F
{
G H
	positions
I R
[
R S
a
S T
.
T U
a
U V
]
V W
,
W X
	positions
Y b
[
b c
a
c d
.
d e
b
e f
]
f g
,
g h
	positions
i r
[
r s
b
s t
.
t u
a
u v
]
v w
,
w x
	positionsy Ç
[Ç É
bÉ Ñ
.Ñ Ö
bÖ Ü
]Ü á
}à â
,â ä
nullã è
,è ê
nrmë î
)î ï
;ï ñ
Vector2
ÚÚ 
ipoint
ÚÚ 
=
ÚÚ 
Vector2
ÚÚ $
.
ÚÚ$ %
zero
ÚÚ% )
;
ÚÚ) *
bool
ÛÛ 

intersects
ÛÛ 
=
ÛÛ 
Math
ÛÛ "
.
ÛÛ" #%
GetLineSegmentIntersect
ÛÛ# :
(
ÛÛ: ;
planed
ÛÛ; A
[
ÛÛA B
$num
ÛÛB C
]
ÛÛC D
,
ÛÛD E
planed
ÛÛF L
[
ÛÛL M
$num
ÛÛM N
]
ÛÛN O
,
ÛÛO P
planed
ÛÛQ W
[
ÛÛW X
$num
ÛÛX Y
]
ÛÛY Z
,
ÛÛZ [
planed
ÛÛ\ b
[
ÛÛb c
$num
ÛÛc d
]
ÛÛd e
,
ÛÛe f
ref
ÛÛg j
ipoint
ÛÛk q
)
ÛÛq r
;
ÛÛr s
if
ıı 
(
ıı 
!
ıı 

intersects
ıı 
)
ıı 
{
ˆˆ 
v
˜˜ 
[
˜˜ 
$num
˜˜ 
]
˜˜ 
=
˜˜ 
	positions
˜˜  
[
˜˜  !
b
˜˜! "
.
˜˜" #
a
˜˜# $
]
˜˜$ %
;
˜˜% &
if
¯¯ 
(
¯¯ 
	hasColors
¯¯ 
)
¯¯ 
c
˘˘ 
[
˘˘ 
$num
˘˘ 
]
˘˘ 
=
˘˘ 
mesh
˘˘ 
.
˘˘  
colorsInternal
˘˘  .
[
˘˘. /
b
˘˘/ 0
.
˘˘0 1
a
˘˘1 2
]
˘˘2 3
;
˘˘3 4
s
˙˙ 
[
˙˙ 
$num
˙˙ 
]
˙˙ 
=
˙˙ 
mesh
˙˙ 
.
˙˙ #
GetSharedVertexHandle
˙˙ 1
(
˙˙1 2
b
˙˙2 3
.
˙˙3 4
a
˙˙4 5
)
˙˙5 6
;
˙˙6 7
v
˚˚ 
[
˚˚ 
$num
˚˚ 
]
˚˚ 
=
˚˚ 
	positions
˚˚  
[
˚˚  !
b
˚˚! "
.
˚˚" #
b
˚˚# $
]
˚˚$ %
;
˚˚% &
if
¸¸ 
(
¸¸ 
	hasColors
¸¸ 
)
¸¸ 
c
˝˝ 
[
˝˝ 
$num
˝˝ 
]
˝˝ 
=
˝˝ 
mesh
˝˝ 
.
˝˝  
colorsInternal
˝˝  .
[
˝˝. /
b
˝˝/ 0
.
˝˝0 1
b
˝˝1 2
]
˝˝2 3
;
˝˝3 4
s
˛˛ 
[
˛˛ 
$num
˛˛ 
]
˛˛ 
=
˛˛ 
mesh
˛˛ 
.
˛˛ #
GetSharedVertexHandle
˛˛ 1
(
˛˛1 2
b
˛˛2 3
.
˛˛3 4
b
˛˛4 5
)
˛˛5 6
;
˛˛6 7
}
ˇˇ 
else
ÄÄ 
{
ÅÅ 
v
ÇÇ 
[
ÇÇ 
$num
ÇÇ 
]
ÇÇ 
=
ÇÇ 
	positions
ÇÇ  
[
ÇÇ  !
b
ÇÇ! "
.
ÇÇ" #
b
ÇÇ# $
]
ÇÇ$ %
;
ÇÇ% &
if
ÉÉ 
(
ÉÉ 
	hasColors
ÉÉ 
)
ÉÉ 
c
ÑÑ 
[
ÑÑ 
$num
ÑÑ 
]
ÑÑ 
=
ÑÑ 
mesh
ÑÑ 
.
ÑÑ  
colorsInternal
ÑÑ  .
[
ÑÑ. /
b
ÑÑ/ 0
.
ÑÑ0 1
b
ÑÑ1 2
]
ÑÑ2 3
;
ÑÑ3 4
s
ÖÖ 
[
ÖÖ 
$num
ÖÖ 
]
ÖÖ 
=
ÖÖ 
mesh
ÖÖ 
.
ÖÖ #
GetSharedVertexHandle
ÖÖ 1
(
ÖÖ1 2
b
ÖÖ2 3
.
ÖÖ3 4
b
ÖÖ4 5
)
ÖÖ5 6
;
ÖÖ6 7
v
ÜÜ 
[
ÜÜ 
$num
ÜÜ 
]
ÜÜ 
=
ÜÜ 
	positions
ÜÜ  
[
ÜÜ  !
b
ÜÜ! "
.
ÜÜ" #
a
ÜÜ# $
]
ÜÜ$ %
;
ÜÜ% &
if
áá 
(
áá 
	hasColors
áá 
)
áá 
c
àà 
[
àà 
$num
àà 
]
àà 
=
àà 
mesh
àà 
.
àà  
colorsInternal
àà  .
[
àà. /
b
àà/ 0
.
àà0 1
a
àà1 2
]
àà2 3
;
àà3 4
s
ââ 
[
ââ 
$num
ââ 
]
ââ 
=
ââ 
mesh
ââ 
.
ââ #
GetSharedVertexHandle
ââ 1
(
ââ1 2
b
ââ2 3
.
ââ3 4
a
ââ4 5
)
ââ5 6
;
ââ6 7
}
ää 
return
åå 
mesh
åå 
.
åå 

AppendFace
åå "
(
åå" #
v
çç 
,
çç 
	hasColors
éé 
?
éé 
c
éé 
:
éé 
null
éé  $
,
éé$ %
new
èè 
Vector2
èè 
[
èè 
v
èè 
.
èè 
Length
èè $
]
èè$ %
,
èè% &
new
êê 
Face
êê 
(
êê 
new
êê 
int
êê  
[
êê  !
$num
êê! "
]
êê" #
{
êê$ %
$num
êê% &
,
êê& '
$num
êê( )
,
êê) *
$num
êê+ ,
,
êê, -
$num
êê. /
,
êê/ 0
$num
êê1 2
,
êê2 3
$num
êê4 5
}
êê6 7
,
êê7 8
submeshIndex
êê9 E
,
êêE F
uvs
êêG J
,
êêJ K
$num
êêL M
,
êêM N
-
êêO P
$num
êêP Q
,
êêQ R
-
êêS T
$num
êêT U
,
êêU V
false
êêW \
)
êê\ ]
,
êê] ^
s
ëë 
)
ëë 
;
ëë 
}
íí 	
public
õõ 
static
õõ 
Face
õõ "
AppendVerticesToFace
õõ /
(
õõ/ 0
this
õõ0 4
ProBuilderMesh
õõ5 C
mesh
õõD H
,
õõH I
Face
õõJ N
face
õõO S
,
õõS T
Vector3
õõU \
[
õõ\ ]
]
õõ] ^
points
õõ_ e
)
õõe f
{
úú 	
if
ùù 
(
ùù 
mesh
ùù 
==
ùù 
null
ùù 
)
ùù 
throw
ûû 
new
ûû #
ArgumentNullException
ûû /
(
ûû/ 0
$str
ûû0 6
)
ûû6 7
;
ûû7 8
if
†† 
(
†† 
face
†† 
==
†† 
null
†† 
)
†† 
throw
°° 
new
°° #
ArgumentNullException
°° /
(
°°/ 0
$str
°°0 6
)
°°6 7
;
°°7 8
if
££ 
(
££ 
points
££ 
==
££ 
null
££ 
)
££ 
throw
§§ 
new
§§ #
ArgumentNullException
§§ /
(
§§/ 0
$str
§§0 8
)
§§8 9
;
§§9 :
List
¶¶ 
<
¶¶ 
Vertex
¶¶ 
>
¶¶ 
vertices
¶¶ !
=
¶¶" #
mesh
¶¶$ (
.
¶¶( )
GetVertices
¶¶) 4
(
¶¶4 5
)
¶¶5 6
.
¶¶6 7
ToList
¶¶7 =
(
¶¶= >
)
¶¶> ?
;
¶¶? @
List
ßß 
<
ßß 
Face
ßß 
>
ßß 
faces
ßß 
=
ßß 
new
ßß "
List
ßß# '
<
ßß' (
Face
ßß( ,
>
ßß, -
(
ßß- .
mesh
ßß. 2
.
ßß2 3
facesInternal
ßß3 @
)
ßß@ A
;
ßßA B

Dictionary
®® 
<
®® 
int
®® 
,
®® 
int
®® 
>
®®  
lookup
®®! '
=
®®( )
mesh
®®* .
.
®®. / 
sharedVertexLookup
®®/ A
;
®®A B

Dictionary
©© 
<
©© 
int
©© 
,
©© 
int
©© 
>
©©  
lookupUV
©©! )
=
©©* +
null
©©, 0
;
©©0 1
if
´´ 
(
´´ 
mesh
´´ 
.
´´ 
sharedTextures
´´ #
!=
´´$ &
null
´´' +
)
´´+ ,
{
¨¨ 
lookupUV
≠≠ 
=
≠≠ 
new
≠≠ 

Dictionary
≠≠ )
<
≠≠) *
int
≠≠* -
,
≠≠- .
int
≠≠/ 2
>
≠≠2 3
(
≠≠3 4
)
≠≠4 5
;
≠≠5 6
SharedVertex
ÆÆ 
.
ÆÆ #
GetSharedVertexLookup
ÆÆ 2
(
ÆÆ2 3
mesh
ÆÆ3 7
.
ÆÆ7 8
sharedTextures
ÆÆ8 F
,
ÆÆF G
lookupUV
ÆÆH P
)
ÆÆP Q
;
ÆÆQ R
}
ØØ 
List
±± 
<
±± 
Edge
±± 
>
±± 
wound
±± 
=
±± 

WingedEdge
±± )
.
±±) *"
SortEdgesByAdjacency
±±* >
(
±±> ?
face
±±? C
)
±±C D
;
±±D E
List
≥≥ 
<
≥≥ 
Vertex
≥≥ 
>
≥≥ 

n_vertices
≥≥ #
=
≥≥$ %
new
≥≥& )
List
≥≥* .
<
≥≥. /
Vertex
≥≥/ 5
>
≥≥5 6
(
≥≥6 7
)
≥≥7 8
;
≥≥8 9
List
¥¥ 
<
¥¥ 
int
¥¥ 
>
¥¥ 
n_shared
¥¥ 
=
¥¥  
new
¥¥! $
List
¥¥% )
<
¥¥) *
int
¥¥* -
>
¥¥- .
(
¥¥. /
)
¥¥/ 0
;
¥¥0 1
List
µµ 
<
µµ 
int
µµ 
>
µµ 

n_sharedUV
µµ  
=
µµ! "
lookupUV
µµ# +
!=
µµ, .
null
µµ/ 3
?
µµ4 5
new
µµ6 9
List
µµ: >
<
µµ> ?
int
µµ? B
>
µµB C
(
µµC D
)
µµD E
:
µµF G
null
µµH L
;
µµL M
for
∑∑ 
(
∑∑ 
int
∑∑ 
i
∑∑ 
=
∑∑ 
$num
∑∑ 
;
∑∑ 
i
∑∑ 
<
∑∑ 
wound
∑∑  %
.
∑∑% &
Count
∑∑& +
;
∑∑+ ,
i
∑∑- .
++
∑∑. 0
)
∑∑0 1
{
∏∏ 

n_vertices
ππ 
.
ππ 
Add
ππ 
(
ππ 
vertices
ππ '
[
ππ' (
wound
ππ( -
[
ππ- .
i
ππ. /
]
ππ/ 0
.
ππ0 1
a
ππ1 2
]
ππ2 3
)
ππ3 4
;
ππ4 5
n_shared
∫∫ 
.
∫∫ 
Add
∫∫ 
(
∫∫ 
lookup
∫∫ #
[
∫∫# $
wound
∫∫$ )
[
∫∫) *
i
∫∫* +
]
∫∫+ ,
.
∫∫, -
a
∫∫- .
]
∫∫. /
)
∫∫/ 0
;
∫∫0 1
if
ºº 
(
ºº 
lookupUV
ºº 
!=
ºº 
null
ºº  $
)
ºº$ %
{
ΩΩ 
int
ææ 
uv
ææ 
;
ææ 
if
¿¿ 
(
¿¿ 
lookupUV
¿¿  
.
¿¿  !
TryGetValue
¿¿! ,
(
¿¿, -
wound
¿¿- 2
[
¿¿2 3
i
¿¿3 4
]
¿¿4 5
.
¿¿5 6
a
¿¿6 7
,
¿¿7 8
out
¿¿9 <
uv
¿¿= ?
)
¿¿? @
)
¿¿@ A

n_sharedUV
¡¡ "
.
¡¡" #
Add
¡¡# &
(
¡¡& '
uv
¡¡' )
)
¡¡) *
;
¡¡* +
else
¬¬ 

n_sharedUV
√√ "
.
√√" #
Add
√√# &
(
√√& '
-
√√' (
$num
√√( )
)
√√) *
;
√√* +
}
ƒƒ 
}
≈≈ 
for
»» 
(
»» 
int
»» 
i
»» 
=
»» 
$num
»» 
;
»» 
i
»» 
<
»» 
points
»»  &
.
»»& '
Length
»»' -
;
»»- .
i
»»/ 0
++
»»0 2
)
»»2 3
{
…… 
int
   
index
   
=
   
-
   
$num
   
;
   
float
ÀÀ 
best
ÀÀ 
=
ÀÀ 
Mathf
ÀÀ "
.
ÀÀ" #
Infinity
ÀÀ# +
;
ÀÀ+ ,
Vector3
ÃÃ 
p
ÃÃ 
=
ÃÃ 
points
ÃÃ "
[
ÃÃ" #
i
ÃÃ# $
]
ÃÃ$ %
;
ÃÃ% &
int
ÕÕ 
vc
ÕÕ 
=
ÕÕ 

n_vertices
ÕÕ #
.
ÕÕ# $
Count
ÕÕ$ )
;
ÕÕ) *
for
œœ 
(
œœ 
int
œœ 
n
œœ 
=
œœ 
$num
œœ 
;
œœ 
n
œœ  !
<
œœ" #
vc
œœ$ &
;
œœ& '
n
œœ( )
++
œœ) +
)
œœ+ ,
{
–– 
Vector3
—— 
v
—— 
=
—— 

n_vertices
——  *
[
——* +
n
——+ ,
]
——, -
.
——- .
position
——. 6
;
——6 7
Vector3
““ 
w
““ 
=
““ 

n_vertices
““  *
[
““* +
(
““+ ,
n
““, -
+
““. /
$num
““0 1
)
““1 2
%
““3 4
vc
““5 7
]
““7 8
.
““8 9
position
““9 A
;
““A B
float
‘‘ 
dist
‘‘ 
=
‘‘  
Math
‘‘! %
.
‘‘% &&
DistancePointLineSegment
‘‘& >
(
‘‘> ?
p
‘‘? @
,
‘‘@ A
v
‘‘B C
,
‘‘C D
w
‘‘E F
)
‘‘F G
;
‘‘G H
if
÷÷ 
(
÷÷ 
dist
÷÷ 
<
÷÷ 
best
÷÷ #
)
÷÷# $
{
◊◊ 
best
ÿÿ 
=
ÿÿ 
dist
ÿÿ #
;
ÿÿ# $
index
ŸŸ 
=
ŸŸ 
n
ŸŸ  !
;
ŸŸ! "
}
⁄⁄ 
}
€€ 
Vertex
›› 
left
›› 
=
›› 

n_vertices
›› (
[
››( )
index
››) .
]
››. /
,
››/ 0
right
››1 6
=
››7 8

n_vertices
››9 C
[
››C D
(
››D E
index
››E J
+
››K L
$num
››M N
)
››N O
%
››P Q
vc
››R T
]
››T U
;
››U V
float
ﬂﬂ 
x
ﬂﬂ 
=
ﬂﬂ 
(
ﬂﬂ 
p
ﬂﬂ 
-
ﬂﬂ 
left
ﬂﬂ #
.
ﬂﬂ# $
position
ﬂﬂ$ ,
)
ﬂﬂ, -
.
ﬂﬂ- .
sqrMagnitude
ﬂﬂ. :
;
ﬂﬂ: ;
float
‡‡ 
y
‡‡ 
=
‡‡ 
(
‡‡ 
p
‡‡ 
-
‡‡ 
right
‡‡ $
.
‡‡$ %
position
‡‡% -
)
‡‡- .
.
‡‡. /
sqrMagnitude
‡‡/ ;
;
‡‡; <
Vertex
‚‚ 
insert
‚‚ 
=
‚‚ 
Vertex
‚‚  &
.
‚‚& '
Mix
‚‚' *
(
‚‚* +
left
‚‚+ /
,
‚‚/ 0
right
‚‚1 6
,
‚‚6 7
x
‚‚8 9
/
‚‚: ;
(
‚‚< =
x
‚‚= >
+
‚‚? @
y
‚‚A B
)
‚‚B C
)
‚‚C D
;
‚‚D E

n_vertices
‰‰ 
.
‰‰ 
Insert
‰‰ !
(
‰‰! "
(
‰‰" #
index
‰‰# (
+
‰‰) *
$num
‰‰+ ,
)
‰‰, -
%
‰‰. /
vc
‰‰0 2
,
‰‰2 3
insert
‰‰4 :
)
‰‰: ;
;
‰‰; <
n_shared
ÂÂ 
.
ÂÂ 
Insert
ÂÂ 
(
ÂÂ  
(
ÂÂ  !
index
ÂÂ! &
+
ÂÂ' (
$num
ÂÂ) *
)
ÂÂ* +
%
ÂÂ, -
vc
ÂÂ. 0
,
ÂÂ0 1
-
ÂÂ2 3
$num
ÂÂ3 4
)
ÂÂ4 5
;
ÂÂ5 6
if
ÊÊ 
(
ÊÊ 

n_sharedUV
ÊÊ 
!=
ÊÊ !
null
ÊÊ" &
)
ÊÊ& '

n_sharedUV
ÊÊ( 2
.
ÊÊ2 3
Insert
ÊÊ3 9
(
ÊÊ9 :
(
ÊÊ: ;
index
ÊÊ; @
+
ÊÊA B
$num
ÊÊC D
)
ÊÊD E
%
ÊÊF G
vc
ÊÊH J
,
ÊÊJ K
-
ÊÊL M
$num
ÊÊM N
)
ÊÊN O
;
ÊÊO P
}
ÁÁ 
List
ÈÈ 
<
ÈÈ 
int
ÈÈ 
>
ÈÈ 
	triangles
ÈÈ 
;
ÈÈ  
try
ÎÎ 
{
ÏÏ 
Triangulation
ÌÌ 
.
ÌÌ !
TriangulateVertices
ÌÌ 1
(
ÌÌ1 2

n_vertices
ÌÌ2 <
,
ÌÌ< =
out
ÌÌ> A
	triangles
ÌÌB K
,
ÌÌK L
false
ÌÌM R
)
ÌÌR S
;
ÌÌS T
}
ÓÓ 
catch
ÔÔ 
{
 
Debug
ÒÒ 
.
ÒÒ 
Log
ÒÒ 
(
ÒÒ 
$str
ÒÒ O
)
ÒÒO P
;
ÒÒP Q
return
ÚÚ 
null
ÚÚ 
;
ÚÚ 
}
ÛÛ 
FaceRebuildData
ıı 
data
ıı  
=
ıı! "
new
ıı# &
FaceRebuildData
ıı' 6
(
ıı6 7
)
ıı7 8
;
ıı8 9
data
˜˜ 
.
˜˜ 
face
˜˜ 
=
˜˜ 
new
˜˜ 
Face
˜˜  
(
˜˜  !
	triangles
˜˜! *
.
˜˜* +
ToArray
˜˜+ 2
(
˜˜2 3
)
˜˜3 4
,
˜˜4 5
face
˜˜6 :
.
˜˜: ;
submeshIndex
˜˜; G
,
˜˜G H
new
˜˜I L 
AutoUnwrapSettings
˜˜M _
(
˜˜_ `
face
˜˜` d
.
˜˜d e
uv
˜˜e g
)
˜˜g h
,
˜˜h i
face
˜˜j n
.
˜˜n o
smoothingGroup
˜˜o }
,
˜˜} ~
face˜˜ É
.˜˜É Ñ
textureGroup˜˜Ñ ê
,˜˜ê ë
-˜˜í ì
$num˜˜ì î
,˜˜î ï
face˜˜ñ ö
.˜˜ö õ
manualUV˜˜õ £
)˜˜£ §
;˜˜§ •
data
¯¯ 
.
¯¯ 
vertices
¯¯ 
=
¯¯$ %

n_vertices
¯¯& 0
;
¯¯0 1
data
˘˘ 
.
˘˘ 
sharedIndexes
˘˘ 
=
˘˘$ %
n_shared
˘˘& .
;
˘˘. /
data
˙˙ 
.
˙˙ 
sharedIndexesUV
˙˙  
=
˙˙$ %

n_sharedUV
˙˙& 0
;
˙˙0 1
FaceRebuildData
¸¸ 
.
¸¸ 
Apply
¸¸ !
(
¸¸! "
new
¸¸" %
List
¸¸& *
<
¸¸* +
FaceRebuildData
¸¸+ :
>
¸¸: ;
(
¸¸; <
)
¸¸< =
{
¸¸> ?
data
¸¸@ D
}
¸¸E F
,
¸¸F G
vertices
˝˝ 
,
˝˝ 
faces
˛˛ 
,
˛˛ 
lookup
ˇˇ 
,
ˇˇ 
lookupUV
ÄÄ 
)
ÄÄ 
;
ÄÄ 
var
ÇÇ 
newFace
ÇÇ 
=
ÇÇ 
data
ÇÇ 
.
ÇÇ 
face
ÇÇ #
;
ÇÇ# $
mesh
ÑÑ 
.
ÑÑ 
SetVertices
ÑÑ 
(
ÑÑ 
vertices
ÑÑ %
)
ÑÑ% &
;
ÑÑ& '
mesh
ÖÖ 
.
ÖÖ 
faces
ÖÖ 
=
ÖÖ 
faces
ÖÖ 
;
ÖÖ 
mesh
ÜÜ 
.
ÜÜ 
SetSharedVertices
ÜÜ "
(
ÜÜ" #
lookup
ÜÜ# )
)
ÜÜ) *
;
ÜÜ* +
mesh
áá 
.
áá 
SetSharedTextures
áá "
(
áá" #
lookupUV
áá# +
)
áá+ ,
;
áá, -
Vector3
ää 
oldNrm
ää 
=
ää 
Math
ää !
.
ää! "
Normal
ää" (
(
ää( )
mesh
ää) -
,
ää- .
face
ää/ 3
)
ää3 4
;
ää4 5
Vector3
ãã 
newNrm
ãã 
=
ãã 
Math
ãã !
.
ãã! "
Normal
ãã" (
(
ãã( )
mesh
ãã) -
,
ãã- .
newFace
ãã/ 6
)
ãã6 7
;
ãã7 8
if
çç 
(
çç 
Vector3
çç 
.
çç 
Dot
çç 
(
çç 
oldNrm
çç "
,
çç" #
newNrm
çç$ *
)
çç* +
<
çç, -
$num
çç. /
)
çç/ 0
newFace
éé 
.
éé 
Reverse
éé 
(
éé  
)
éé  !
;
éé! "
mesh
êê 
.
êê 

DeleteFace
êê 
(
êê 
face
êê  
)
êê  !
;
êê! "
return
íí 
newFace
íí 
;
íí 
}
ìì 	
public
úú 
static
úú 
List
úú 
<
úú 
Edge
úú 
>
úú  "
AppendVerticesToEdge
úú! 5
(
úú5 6
this
úú6 :
ProBuilderMesh
úú; I
mesh
úúJ N
,
úúN O
Edge
úúP T
edge
úúU Y
,
úúY Z
int
úú[ ^
count
úú_ d
)
úúd e
{
ùù 	
return
ûû "
AppendVerticesToEdge
ûû '
(
ûû' (
mesh
ûû( ,
,
ûû, -
new
ûû. 1
Edge
ûû2 6
[
ûû6 7
]
ûû7 8
{
ûû9 :
edge
ûû; ?
}
ûû@ A
,
ûûA B
count
ûûC H
)
ûûH I
;
ûûI J
}
üü 	
public
®® 
static
®® 
List
®® 
<
®® 
Edge
®® 
>
®®  "
AppendVerticesToEdge
®®! 5
(
®®5 6
this
®®6 :
ProBuilderMesh
®®; I
mesh
®®J N
,
®®N O
IList
®®P U
<
®®U V
Edge
®®V Z
>
®®Z [
edges
®®\ a
,
®®a b
int
®®c f
count
®®g l
)
®®l m
{
©© 	
if
™™ 
(
™™ 
mesh
™™ 
==
™™ 
null
™™ 
)
™™ 
throw
´´ 
new
´´ #
ArgumentNullException
´´ /
(
´´/ 0
$str
´´0 6
)
´´6 7
;
´´7 8
if
≠≠ 
(
≠≠ 
edges
≠≠ 
==
≠≠ 
null
≠≠ 
)
≠≠ 
throw
ÆÆ 
new
ÆÆ #
ArgumentNullException
ÆÆ /
(
ÆÆ/ 0
$str
ÆÆ0 7
)
ÆÆ7 8
;
ÆÆ8 9
if
∞∞ 
(
∞∞ 
count
∞∞ 
<
∞∞ 
$num
∞∞ 
||
∞∞ 
count
∞∞ "
>
∞∞# $
$num
∞∞% (
)
∞∞( )
{
±± 
Log
≤≤ 
.
≤≤ 
Error
≤≤ 
(
≤≤ 
$str
≤≤ U
)
≤≤U V
;
≤≤V W
return
≥≥ 
null
≥≥ 
;
≥≥ 
}
¥¥ 
List
∂∂ 
<
∂∂ 
Vertex
∂∂ 
>
∂∂ 
vertices
∂∂ !
=
∂∂" #
new
∂∂$ '
List
∂∂( ,
<
∂∂, -
Vertex
∂∂- 3
>
∂∂3 4
(
∂∂4 5
mesh
∂∂5 9
.
∂∂9 :
GetVertices
∂∂: E
(
∂∂E F
)
∂∂F G
)
∂∂G H
;
∂∂H I

Dictionary
∑∑ 
<
∑∑ 
int
∑∑ 
,
∑∑ 
int
∑∑ 
>
∑∑  
lookup
∑∑! '
=
∑∑( )
mesh
∑∑* .
.
∑∑. / 
sharedVertexLookup
∑∑/ A
;
∑∑A B

Dictionary
∏∏ 
<
∏∏ 
int
∏∏ 
,
∏∏ 
int
∏∏ 
>
∏∏  
lookupUV
∏∏! )
=
∏∏* +
mesh
∏∏, 0
.
∏∏0 1!
sharedTextureLookup
∏∏1 D
;
∏∏D E
List
ππ 
<
ππ 
int
ππ 
>
ππ 
indexesToDelete
ππ %
=
ππ& '
new
ππ( +
List
ππ, 0
<
ππ0 1
int
ππ1 4
>
ππ4 5
(
ππ5 6
)
ππ6 7
;
ππ7 8
IEnumerable
∫∫ 
<
∫∫ 
Edge
∫∫ 
>
∫∫ 
commonEdges
∫∫ )
=
∫∫* +
EdgeUtility
∫∫, 7
.
∫∫7 8(
GetSharedVertexHandleEdges
∫∫8 R
(
∫∫R S
mesh
∫∫S W
,
∫∫W X
edges
∫∫Y ^
)
∫∫^ _
;
∫∫_ `
List
ªª 
<
ªª 
Edge
ªª 
>
ªª 
distinctEdges
ªª $
=
ªª% &
commonEdges
ªª' 2
.
ªª2 3
Distinct
ªª3 ;
(
ªª; <
)
ªª< =
.
ªª= >
ToList
ªª> D
(
ªªD E
)
ªªE F
;
ªªF G

Dictionary
ΩΩ 
<
ΩΩ 
Face
ΩΩ 
,
ΩΩ 
FaceRebuildData
ΩΩ ,
>
ΩΩ, -
modifiedFaces
ΩΩ. ;
=
ΩΩ< =
new
ΩΩ> A

Dictionary
ΩΩB L
<
ΩΩL M
Face
ΩΩM Q
,
ΩΩQ R
FaceRebuildData
ΩΩS b
>
ΩΩb c
(
ΩΩc d
)
ΩΩd e
;
ΩΩe f
int
øø (
originalSharedIndexesCount
øø *
=
øø+ ,
lookup
øø- 3
.
øø3 4
Count
øø4 9
(
øø9 :
)
øø: ;
;
øø; <
int
¿¿  
sharedIndexesCount
¿¿ "
=
¿¿# $(
originalSharedIndexesCount
¿¿% ?
;
¿¿? @
foreach
¬¬ 
(
¬¬ 
Edge
¬¬ 
edge
¬¬ 
in
¬¬ !
distinctEdges
¬¬" /
)
¬¬/ 0
{
√√ 
Edge
ƒƒ 
	localEdge
ƒƒ 
=
ƒƒ  
EdgeUtility
ƒƒ! ,
.
ƒƒ, -,
GetEdgeWithSharedVertexHandles
ƒƒ- K
(
ƒƒK L
mesh
ƒƒL P
,
ƒƒP Q
edge
ƒƒR V
)
ƒƒV W
;
ƒƒW X
List
«« 
<
«« 
Vertex
«« 
>
«« 
verticesToAppend
«« -
=
««. /
new
««0 3
List
««4 8
<
««8 9
Vertex
««9 ?
>
««? @
(
««@ A
count
««A F
)
««F G
;
««G H
for
…… 
(
…… 
int
…… 
i
…… 
=
…… 
$num
…… 
;
…… 
i
……  !
<
……" #
count
……$ )
;
……) *
i
……+ ,
++
……, .
)
……. /
verticesToAppend
   $
.
  $ %
Add
  % (
(
  ( )
Vertex
  ) /
.
  / 0
Mix
  0 3
(
  3 4
vertices
  4 <
[
  < =
	localEdge
  = F
.
  F G
a
  G H
]
  H I
,
  I J
vertices
  K S
[
  S T
	localEdge
  T ]
.
  ] ^
b
  ^ _
]
  _ `
,
  ` a
(
  b c
i
  c d
+
  e f
$num
  g h
)
  h i
/
  j k
(
  l m
(
  m n
float
  n s
)
  s t
count
  t y
+
  z {
$num
  | }
)
  } ~
)
  ~ 
)   Ä
;  Ä Å
List
ÃÃ 
<
ÃÃ 
SimpleTuple
ÃÃ  
<
ÃÃ  !
Face
ÃÃ! %
,
ÃÃ% &
Edge
ÃÃ' +
>
ÃÃ+ ,
>
ÃÃ, -
adjacentFaces
ÃÃ. ;
=
ÃÃ< =
ElementSelection
ÃÃ> N
.
ÃÃN O
GetNeighborFaces
ÃÃO _
(
ÃÃ_ `
mesh
ÃÃ` d
,
ÃÃd e
	localEdge
ÃÃf o
)
ÃÃo p
;
ÃÃp q
foreach
œœ 
(
œœ 
SimpleTuple
œœ $
<
œœ$ %
Face
œœ% )
,
œœ) *
Edge
œœ+ /
>
œœ/ 0
tup
œœ1 4
in
œœ5 7
adjacentFaces
œœ8 E
)
œœE F
{
–– 
Face
—— 
face
—— 
=
—— 
tup
——  #
.
——# $
item1
——$ )
;
——) *
FaceRebuildData
”” #
data
””$ (
;
””( )
if
’’ 
(
’’ 
!
’’ 
modifiedFaces
’’ &
.
’’& '
TryGetValue
’’' 2
(
’’2 3
face
’’3 7
,
’’7 8
out
’’9 <
data
’’= A
)
’’A B
)
’’B C
{
÷÷ 
data
◊◊ 
=
◊◊ 
new
◊◊ "
FaceRebuildData
◊◊# 2
(
◊◊2 3
)
◊◊3 4
;
◊◊4 5
data
ÿÿ 
.
ÿÿ 
face
ÿÿ !
=
ÿÿ" #
new
ÿÿ$ '
Face
ÿÿ( ,
(
ÿÿ, -
new
ÿÿ- 0
int
ÿÿ1 4
[
ÿÿ4 5
$num
ÿÿ5 6
]
ÿÿ6 7
,
ÿÿ7 8
face
ÿÿ9 =
.
ÿÿ= >
submeshIndex
ÿÿ> J
,
ÿÿJ K
new
ÿÿL O 
AutoUnwrapSettings
ÿÿP b
(
ÿÿb c
face
ÿÿc g
.
ÿÿg h
uv
ÿÿh j
)
ÿÿj k
,
ÿÿk l
face
ÿÿm q
.
ÿÿq r
smoothingGroupÿÿr Ä
,ÿÿÄ Å
faceÿÿÇ Ü
.ÿÿÜ á
textureGroupÿÿá ì
,ÿÿì î
-ÿÿï ñ
$numÿÿñ ó
,ÿÿó ò
faceÿÿô ù
.ÿÿù û
manualUVÿÿû ¶
)ÿÿ¶ ß
;ÿÿß ®
data
ŸŸ 
.
ŸŸ 
vertices
ŸŸ %
=
ŸŸ& '
new
ŸŸ( +
List
ŸŸ, 0
<
ŸŸ0 1
Vertex
ŸŸ1 7
>
ŸŸ7 8
(
ŸŸ8 9
ArrayUtility
ŸŸ9 E
.
ŸŸE F
ValuesWithIndexes
ŸŸF W
(
ŸŸW X
vertices
ŸŸX `
,
ŸŸ` a
face
ŸŸb f
.
ŸŸf g%
distinctIndexesInternal
ŸŸg ~
)
ŸŸ~ 
)ŸŸ Ä
;ŸŸÄ Å
data
⁄⁄ 
.
⁄⁄ 
sharedIndexes
⁄⁄ *
=
⁄⁄+ ,
new
⁄⁄- 0
List
⁄⁄1 5
<
⁄⁄5 6
int
⁄⁄6 9
>
⁄⁄9 :
(
⁄⁄: ;
)
⁄⁄; <
;
⁄⁄< =
data
€€ 
.
€€ 
sharedIndexesUV
€€ ,
=
€€- .
new
€€/ 2
List
€€3 7
<
€€7 8
int
€€8 ;
>
€€; <
(
€€< =
)
€€= >
;
€€> ?
foreach
›› 
(
››  !
int
››! $
i
››% &
in
››' )
face
››* .
.
››. /%
distinctIndexesInternal
››/ F
)
››F G
{
ﬁﬁ 
int
ﬂﬂ 
shared
ﬂﬂ  &
;
ﬂﬂ& '
if
·· 
(
··  
lookup
··  &
.
··& '
TryGetValue
··' 2
(
··2 3
i
··3 4
,
··4 5
out
··6 9
shared
··: @
)
··@ A
)
··A B
data
‚‚  $
.
‚‚$ %
sharedIndexes
‚‚% 2
.
‚‚2 3
Add
‚‚3 6
(
‚‚6 7
shared
‚‚7 =
)
‚‚= >
;
‚‚> ?
if
‰‰ 
(
‰‰  
lookupUV
‰‰  (
.
‰‰( )
TryGetValue
‰‰) 4
(
‰‰4 5
i
‰‰5 6
,
‰‰6 7
out
‰‰8 ;
shared
‰‰< B
)
‰‰B C
)
‰‰C D
data
ÂÂ  $
.
ÂÂ$ %
sharedIndexesUV
ÂÂ% 4
.
ÂÂ4 5
Add
ÂÂ5 8
(
ÂÂ8 9
shared
ÂÂ9 ?
)
ÂÂ? @
;
ÂÂ@ A
}
ÊÊ 
indexesToDelete
ËË '
.
ËË' (
AddRange
ËË( 0
(
ËË0 1
face
ËË1 5
.
ËË5 6%
distinctIndexesInternal
ËË6 M
)
ËËM N
;
ËËN O
modifiedFaces
ÍÍ %
.
ÍÍ% &
Add
ÍÍ& )
(
ÍÍ) *
face
ÍÍ* .
,
ÍÍ. /
data
ÍÍ0 4
)
ÍÍ4 5
;
ÍÍ5 6
}
ÎÎ 
data
ÌÌ 
.
ÌÌ 
vertices
ÌÌ !
.
ÌÌ! "
AddRange
ÌÌ" *
(
ÌÌ* +
verticesToAppend
ÌÌ+ ;
)
ÌÌ; <
;
ÌÌ< =
for
ÔÔ 
(
ÔÔ 
int
ÔÔ 
i
ÔÔ 
=
ÔÔ  
$num
ÔÔ! "
;
ÔÔ" #
i
ÔÔ$ %
<
ÔÔ& '
count
ÔÔ( -
;
ÔÔ- .
i
ÔÔ/ 0
++
ÔÔ0 2
)
ÔÔ2 3
{
 
data
ÒÒ 
.
ÒÒ 
sharedIndexes
ÒÒ *
.
ÒÒ* +
Add
ÒÒ+ .
(
ÒÒ. / 
sharedIndexesCount
ÒÒ/ A
+
ÒÒB C
i
ÒÒD E
)
ÒÒE F
;
ÒÒF G
data
ÚÚ 
.
ÚÚ 
sharedIndexesUV
ÚÚ ,
.
ÚÚ, -
Add
ÚÚ- 0
(
ÚÚ0 1
-
ÚÚ1 2
$num
ÚÚ2 3
)
ÚÚ3 4
;
ÚÚ4 5
}
ÛÛ 
}
ÙÙ  
sharedIndexesCount
ˆˆ "
+=
ˆˆ# %
count
ˆˆ& +
;
ˆˆ+ ,
}
˜˜ 
List
˙˙ 
<
˙˙ 
Face
˙˙ 
>
˙˙ 
dic_face
˙˙ 
=
˙˙  !
modifiedFaces
˙˙" /
.
˙˙/ 0
Keys
˙˙0 4
.
˙˙4 5
ToList
˙˙5 ;
(
˙˙; <
)
˙˙< =
;
˙˙= >
List
˚˚ 
<
˚˚ 
FaceRebuildData
˚˚  
>
˚˚  !
dic_data
˚˚" *
=
˚˚+ ,
modifiedFaces
˚˚- :
.
˚˚: ;
Values
˚˚; A
.
˚˚A B
ToList
˚˚B H
(
˚˚H I
)
˚˚I J
;
˚˚J K
List
¸¸ 
<
¸¸ 

EdgeLookup
¸¸ 
>
¸¸ 
appendedEdges
¸¸ *
=
¸¸+ ,
new
¸¸- 0
List
¸¸1 5
<
¸¸5 6

EdgeLookup
¸¸6 @
>
¸¸@ A
(
¸¸A B
)
¸¸B C
;
¸¸C D
for
˛˛ 
(
˛˛ 
int
˛˛ 
i
˛˛ 
=
˛˛ 
$num
˛˛ 
;
˛˛ 
i
˛˛ 
<
˛˛ 
dic_face
˛˛  (
.
˛˛( )
Count
˛˛) .
;
˛˛. /
i
˛˛0 1
++
˛˛1 3
)
˛˛3 4
{
ˇˇ 
Face
ÄÄ 
face
ÄÄ 
=
ÄÄ 
dic_face
ÄÄ $
[
ÄÄ$ %
i
ÄÄ% &
]
ÄÄ& '
;
ÄÄ' (
FaceRebuildData
ÅÅ 
data
ÅÅ  $
=
ÅÅ% &
dic_data
ÅÅ' /
[
ÅÅ/ 0
i
ÅÅ0 1
]
ÅÅ1 2
;
ÅÅ2 3
Vector3
ÉÉ 
nrm
ÉÉ 
=
ÉÉ 
Math
ÉÉ "
.
ÉÉ" #
Normal
ÉÉ# )
(
ÉÉ) *
mesh
ÉÉ* .
,
ÉÉ. /
face
ÉÉ0 4
)
ÉÉ4 5
;
ÉÉ5 6
Vector2
ÑÑ 
[
ÑÑ 
]
ÑÑ 

projection
ÑÑ $
=
ÑÑ% &

Projection
ÑÑ' 1
.
ÑÑ1 2
PlanarProject
ÑÑ2 ?
(
ÑÑ? @
data
ÑÑ@ D
.
ÑÑD E
vertices
ÑÑE M
.
ÑÑM N
Select
ÑÑN T
(
ÑÑT U
x
ÑÑU V
=>
ÑÑW Y
x
ÑÑZ [
.
ÑÑ[ \
position
ÑÑ\ d
)
ÑÑd e
.
ÑÑe f
ToArray
ÑÑf m
(
ÑÑm n
)
ÑÑn o
,
ÑÑo p
null
ÑÑq u
,
ÑÑu v
nrm
ÑÑw z
)
ÑÑz {
;
ÑÑ{ |
int
ÜÜ 
vertexCount
ÜÜ 
=
ÜÜ  !
vertices
ÜÜ" *
.
ÜÜ* +
Count
ÜÜ+ 0
;
ÜÜ0 1
List
ââ 
<
ââ 
int
ââ 
>
ââ 
indexes
ââ !
;
ââ! "
if
ãã 
(
ãã 
Triangulation
ãã !
.
ãã! " 
SortAndTriangulate
ãã" 4
(
ãã4 5

projection
ãã5 ?
,
ãã? @
out
ããA D
indexes
ããE L
)
ããL M
)
ããM N
data
åå 
.
åå 
face
åå 
.
åå 
indexesInternal
åå -
=
åå. /
indexes
åå0 7
.
åå7 8
ToArray
åå8 ?
(
åå? @
)
åå@ A
;
ååA B
else
çç 
continue
éé 
;
éé 
data
êê 
.
êê 
face
êê 
.
êê 
ShiftIndexes
êê &
(
êê& '
vertexCount
êê' 2
)
êê2 3
;
êê3 4
face
ëë 
.
ëë 
CopyFrom
ëë 
(
ëë 
data
ëë "
.
ëë" #
face
ëë# '
)
ëë' (
;
ëë( )
for
ìì 
(
ìì 
int
ìì 
n
ìì 
=
ìì 
$num
ìì 
;
ìì 
n
ìì  !
<
ìì" #
data
ìì$ (
.
ìì( )
vertices
ìì) 1
.
ìì1 2
Count
ìì2 7
;
ìì7 8
n
ìì9 :
++
ìì: <
)
ìì< =
lookup
îî 
.
îî 
Add
îî 
(
îî 
vertexCount
îî *
+
îî+ ,
n
îî- .
,
îî. /
data
îî0 4
.
îî4 5
sharedIndexes
îî5 B
[
îîB C
n
îîC D
]
îîD E
)
îîE F
;
îîF G
if
ññ 
(
ññ 
data
ññ 
.
ññ 
sharedIndexesUV
ññ (
.
ññ( )
Count
ññ) .
==
ññ/ 1
data
ññ2 6
.
ññ6 7
vertices
ññ7 ?
.
ññ? @
Count
ññ@ E
)
ññE F
{
óó 
for
òò 
(
òò 
int
òò 
n
òò 
=
òò  
$num
òò! "
;
òò" #
n
òò$ %
<
òò& '
data
òò( ,
.
òò, -
vertices
òò- 5
.
òò5 6
Count
òò6 ;
;
òò; <
n
òò= >
++
òò> @
)
òò@ A
lookupUV
ôô  
.
ôô  !
Add
ôô! $
(
ôô$ %
vertexCount
ôô% 0
+
ôô1 2
n
ôô3 4
,
ôô4 5
data
ôô6 :
.
ôô: ;
sharedIndexesUV
ôô; J
[
ôôJ K
n
ôôK L
]
ôôL M
)
ôôM N
;
ôôN O
}
öö 
vertices
úú 
.
úú 
AddRange
úú !
(
úú! "
data
úú" &
.
úú& '
vertices
úú' /
)
úú/ 0
;
úú0 1
foreach
ûû 
(
ûû 
Edge
ûû 
e
ûû 
in
ûû  "
face
ûû# '
.
ûû' (
edgesInternal
ûû( 5
)
ûû5 6
{
üü 

EdgeLookup
†† 
el
†† !
=
††" #
new
††$ '

EdgeLookup
††( 2
(
††2 3
new
††3 6
Edge
††7 ;
(
††; <
lookup
††< B
[
††B C
e
††C D
.
††D E
a
††E F
]
††F G
,
††G H
lookup
††I O
[
††O P
e
††P Q
.
††Q R
b
††R S
]
††S T
)
††T U
,
††U V
e
††W X
)
††X Y
;
††Y Z
if
¢¢ 
(
¢¢ 
el
¢¢ 
.
¢¢ 
common
¢¢ !
.
¢¢! "
a
¢¢" #
>=
¢¢$ &(
originalSharedIndexesCount
¢¢' A
||
¢¢B D
el
¢¢E G
.
¢¢G H
common
¢¢H N
.
¢¢N O
b
¢¢O P
>=
¢¢Q S(
originalSharedIndexesCount
¢¢T n
)
¢¢n o
appendedEdges
££ %
.
££% &
Add
££& )
(
££) *
el
££* ,
)
££, -
;
££- .
}
§§ 
}
•• 
indexesToDelete
ßß 
=
ßß 
indexesToDelete
ßß -
.
ßß- .
Distinct
ßß. 6
(
ßß6 7
)
ßß7 8
.
ßß8 9
ToList
ßß9 ?
(
ßß? @
)
ßß@ A
;
ßßA B
int
®® 
delCount
®® 
=
®® 
indexesToDelete
®® *
.
®®* +
Count
®®+ 0
;
®®0 1
var
™™ 
newEdges
™™ 
=
™™ 
appendedEdges
™™ (
.
™™( )
Distinct
™™) 1
(
™™1 2
)
™™2 3
.
™™3 4
Select
™™4 :
(
™™: ;
x
™™; <
=>
™™= ?
x
™™@ A
.
™™A B
local
™™B G
-
™™H I
delCount
™™J R
)
™™R S
.
™™S T
ToList
™™T Z
(
™™Z [
)
™™[ \
;
™™\ ]
mesh
¨¨ 
.
¨¨ 
SetVertices
¨¨ 
(
¨¨ 
vertices
¨¨ %
)
¨¨% &
;
¨¨& '
mesh
≠≠ 
.
≠≠ 
SetSharedVertices
≠≠ "
(
≠≠" #
lookup
≠≠# )
)
≠≠) *
;
≠≠* +
mesh
ÆÆ 
.
ÆÆ 
SetSharedTextures
ÆÆ "
(
ÆÆ" #
lookupUV
ÆÆ# +
)
ÆÆ+ ,
;
ÆÆ, -
mesh
ØØ 
.
ØØ 
DeleteVertices
ØØ 
(
ØØ  
indexesToDelete
ØØ  /
)
ØØ/ 0
;
ØØ0 1
return
±± 
newEdges
±± 
;
±± 
}
≤≤ 	
}
≥≥ 
}¥¥ ’
õD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SelectionModifierBehaviour.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 
enum %
SelectionModifierBehavior &
{ 
Add 
, 
Subtract 

,
 

Difference 
} 
} À
úD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SelectionPickerRendererHDRP.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
internal 
partial 
class #
SelectionPickerRenderer 2
{ 
internal 
class '
SelectionPickerRendererHDRP 2
:3 4$
ISelectionPickerRenderer5 M
{ 	
public

 
	Texture2D

 
RenderLookupTexture

 0
(

0 1
Camera 
camera 
, 
Shader 
shader 
, 
string 
tag 
, 
int 
width 
= 
- 
$num 
, 
int 
height 
= 
- 
$num 
)  
{ 
returnII 
nullII 
;II 
}KK 
}cc 
}dd 
}ee ‹
ãD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\MeshHandle.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed 

class 

MeshHandle 
{ 
	Transform 
m_Transform 
; 
Mesh		 
m_Mesh		 
;		 
public 
Mesh 
mesh 
{ 	
get 
{ 
return 
m_Mesh 
;  
}! "
} 	
public 

MeshHandle 
( 
	Transform #
	transform$ -
,- .
Mesh/ 3
mesh4 8
)8 9
{ 	
m_Transform 
= 
	transform #
;# $
m_Mesh 
= 
mesh 
; 
} 	
public 
void 
DrawMeshNow 
(  
int  #
submeshIndex$ 0
)0 1
{ 	
if 
( 
m_Transform 
== 
null #
||$ &
m_Mesh' -
==. 0
null1 5
)5 6
return 
; 
Graphics 
. 
DrawMeshNow  
(  !
m_Mesh! '
,' (
m_Transform) 4
.4 5
localToWorldMatrix5 G
,G H
submeshIndexI U
)U V
;V W
} 	
} 
} çz
ôD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\DeleteElements.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
public 

static 
class 
DeleteElements &
{ 
public 
static 
void 
DeleteVertices )
() *
this* .
ProBuilderMesh/ =
mesh> B
,B C
IEnumerableD O
<O P
intP S
>S T
distinctIndexesU d
)d e
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new !
ArgumentNullException /
(/ 0
$str0 6
)6 7
;7 8
if 
( 
distinctIndexes 
==  "
null# '
||( *
!+ ,
distinctIndexes, ;
.; <
Any< ?
(? @
)@ A
)A B
return 
; 
Vertex 
[ 
] 
vertices 
= 
mesh  $
.$ %
GetVertices% 0
(0 1
)1 2
;2 3
int 
originalVertexCount #
=$ %
vertices& .
.. /
Length/ 5
;5 6
int 
[ 
] 
offset 
= 
new 
int "
[" #
originalVertexCount# 6
]6 7
;7 8
List!! 
<!! 
int!! 
>!! 
sorted!! 
=!! 
new!! "
List!!# '
<!!' (
int!!( +
>!!+ ,
(!!, -
distinctIndexes!!- <
)!!< =
;!!= >
sorted## 
.## 
Sort## 
(## 
)## 
;## 
vertices%% 
=%% 
vertices%% 
.%%  
SortedRemoveAt%%  .
(%%. /
sorted%%/ 5
)%%5 6
;%%6 7
for(( 
((( 
int(( 
i(( 
=(( 
$num(( 
;(( 
i(( 
<(( 
originalVertexCount((  3
;((3 4
i((5 6
++((6 8
)((8 9
offset)) 
[)) 
i)) 
])) 
=)) 
ArrayUtility)) (
.))( )$
NearestIndexPriorToValue))) A
())A B
sorted))B H
,))H I
i))J K
)))K L
+))M N
$num))O P
;))P Q
foreach++ 
(++ 
Face++ 
face++ 
in++ !
mesh++" &
.++& '
facesInternal++' 4
)++4 5
{,, 
int-- 
[-- 
]-- 
indexes-- 
=-- 
face--  $
.--$ %
indexesInternal--% 4
;--4 5
for// 
(// 
int// 
i// 
=// 
$num// 
;// 
i//  !
<//" #
indexes//$ +
.//+ ,
Length//, 2
;//2 3
i//4 5
++//5 7
)//7 8
indexes00 
[00 
i00 
]00 
-=00 !
offset00" (
[00( )
indexes00) 0
[000 1
i001 2
]002 3
]003 4
;004 5
face22 
.22 
InvalidateCache22 $
(22$ %
)22% &
;22& '
}33 
var66 
common66 
=66 
mesh66 
.66 
sharedVertexLookup66 0
.660 1
Where661 6
(666 7
x667 8
=>669 ;
sorted66< B
.66B C
BinarySearch66C O
(66O P
x66P Q
.66Q R
Key66R U
)66U V
<66W X
$num66Y Z
)66Z [
.66[ \
Select66\ b
(66b c
y66c d
=>66e g
new66h k
KeyValuePair66l x
<66x y
int66y |
,66| }
int	66~ Å
>
66Å Ç
(
66Ç É
y
66É Ñ
.
66Ñ Ö
Key
66Ö à
-
66â ä
offset
66ã ë
[
66ë í
y
66í ì
.
66ì î
Key
66î ó
]
66ó ò
,
66ò ô
y
66ö õ
.
66õ ú
Value
66ú °
)
66° ¢
)
66¢ £
;
66£ §
var77 
commonUV77 
=77 
mesh77 
.77  
sharedTextureLookup77  3
.773 4
Where774 9
(779 :
x77: ;
=>77< >
sorted77? E
.77E F
BinarySearch77F R
(77R S
x77S T
.77T U
Key77U X
)77X Y
<77Z [
$num77\ ]
)77] ^
.77^ _
Select77_ e
(77e f
y77f g
=>77h j
new77k n
KeyValuePair77o {
<77{ |
int77| 
,	77 Ä
int
77Å Ñ
>
77Ñ Ö
(
77Ö Ü
y
77Ü á
.
77á à
Key
77à ã
-
77å ç
offset
77é î
[
77î ï
y
77ï ñ
.
77ñ ó
Key
77ó ö
]
77ö õ
,
77õ ú
y
77ù û
.
77û ü
Value
77ü §
)
77§ •
)
77• ¶
;
77¶ ß
mesh99 
.99 
SetVertices99 
(99 
vertices99 %
)99% &
;99& '
mesh:: 
.:: 
SetSharedVertices:: "
(::" #
common::# )
)::) *
;::* +
mesh;; 
.;; 
SetSharedTextures;; "
(;;" #
commonUV;;# +
);;+ ,
;;;, -
}<< 	
publicDD 
staticDD 
intDD 
[DD 
]DD 

DeleteFaceDD &
(DD& '
thisDD' +
ProBuilderMeshDD, :
meshDD; ?
,DD? @
FaceDDA E
faceDDF J
)DDJ K
{EE 	
returnFF 
DeleteFacesFF 
(FF 
meshFF #
,FF# $
newFF% (
FaceFF) -
[FF- .
]FF. /
{FF0 1
faceFF2 6
}FF7 8
)FF8 9
;FF9 :
}GG 	
publicOO 
staticOO 
intOO 
[OO 
]OO 
DeleteFacesOO '
(OO' (
thisOO( ,
ProBuilderMeshOO- ;
meshOO< @
,OO@ A
IEnumerableOOB M
<OOM N
FaceOON R
>OOR S
facesOOT Y
)OOY Z
{PP 	
returnQQ 
DeleteFacesQQ 
(QQ 
meshQQ #
,QQ# $
facesQQ% *
.QQ* +
SelectQQ+ 1
(QQ1 2
xQQ2 3
=>QQ4 6
SystemQQ7 =
.QQ= >
ArrayQQ> C
.QQC D
IndexOfQQD K
(QQK L
meshQQL P
.QQP Q
facesInternalQQQ ^
,QQ^ _
xQQ` a
)QQa b
)QQb c
.QQc d
ToListQQd j
(QQj k
)QQk l
)QQl m
;QQm n
}RR 	
publicZZ 
staticZZ 
intZZ 
[ZZ 
]ZZ 
DeleteFacesZZ '
(ZZ' (
thisZZ( ,
ProBuilderMeshZZ- ;
meshZZ< @
,ZZ@ A
IListZZB G
<ZZG H
intZZH K
>ZZK L
faceIndexesZZM X
)ZZX Y
{[[ 	
if\\ 
(\\ 
mesh\\ 
==\\ 
null\\ 
)\\ 
throw]] 
new]] !
ArgumentNullException]] /
(]]/ 0
$str]]0 6
)]]6 7
;]]7 8
if__ 
(__ 
faceIndexes__ 
==__ 
null__ #
)__# $
throw`` 
new`` !
ArgumentNullException`` /
(``/ 0
$str``0 =
)``= >
;``> ?
Facebb 
[bb 
]bb 
facesbb 
=bb 
newbb 
Facebb #
[bb# $
faceIndexesbb$ /
.bb/ 0
Countbb0 5
]bb5 6
;bb6 7
fordd 
(dd 
intdd 
idd 
=dd 
$numdd 
;dd 
idd 
<dd 
facesdd  %
.dd% &
Lengthdd& ,
;dd, -
idd. /
++dd/ 1
)dd1 2
facesee 
[ee 
iee 
]ee 
=ee 
meshee 
.ee  
facesInternalee  -
[ee- .
faceIndexesee. 9
[ee9 :
iee: ;
]ee; <
]ee< =
;ee= >
Listgg 
<gg 
intgg 
>gg 
indexesToRemovegg %
=gg& '
facesgg( -
.gg- .

SelectManygg. 8
(gg8 9
xgg9 :
=>gg; =
xgg> ?
.gg? @#
distinctIndexesInternalgg@ W
)ggW X
.ggX Y
DistinctggY a
(gga b
)ggb c
.ggc d
ToListggd j
(ggj k
)ggk l
;ggl m
indexesToRemovehh 
.hh 
Sorthh  
(hh  !
)hh! "
;hh" #
intjj 
vertexCountjj 
=jj 
meshjj "
.jj" #
positionsInternaljj# 4
.jj4 5
Lengthjj5 ;
;jj; <
Facell 
[ll 
]ll 
nFacesll 
=ll 
meshll  
.ll  !
facesInternalll! .
.ll. /
RemoveAtll/ 7
(ll7 8
faceIndexesll8 C
)llC D
;llD E
varmm 
verticesmm 
=mm 
meshmm 
.mm  
GetVerticesmm  +
(mm+ ,
)mm, -
.mm- .
SortedRemoveAtmm. <
(mm< =
indexesToRemovemm= L
)mmL M
;mmM N

Dictionaryoo 
<oo 
intoo 
,oo 
intoo 
>oo  
shiftmapoo! )
=oo* +
newoo, /

Dictionaryoo0 :
<oo: ;
intoo; >
,oo> ?
intoo@ C
>ooC D
(ooD E
)ooE F
;ooF G
forqq 
(qq 
varqq 
iqq 
=qq 
$numqq 
;qq 
iqq 
<qq 
vertexCountqq  +
;qq+ ,
iqq- .
++qq. 0
)qq0 1
shiftmaprr 
.rr 
Addrr 
(rr 
irr 
,rr 
ArrayUtilityrr  ,
.rr, -$
NearestIndexPriorToValuerr- E
<rrE F
intrrF I
>rrI J
(rrJ K
indexesToRemoverrK Z
,rrZ [
irr\ ]
)rr] ^
+rr_ `
$numrra b
)rrb c
;rrc d
foruu 
(uu 
varuu 
iuu 
=uu 
$numuu 
;uu 
iuu 
<uu 
nFacesuu  &
.uu& '
Lengthuu' -
;uu- .
iuu/ 0
++uu0 2
)uu2 3
{vv 
intww 
[ww 
]ww 
trisww 
=ww 
nFacesww #
[ww# $
iww$ %
]ww% &
.ww& '
indexesInternalww' 6
;ww6 7
foryy 
(yy 
varyy 
nyy 
=yy 
$numyy 
;yy 
nyy  !
<yy" #
trisyy$ (
.yy( )
Lengthyy) /
;yy/ 0
nyy1 2
++yy2 4
)yy4 5
triszz 
[zz 
nzz 
]zz 
-=zz 
shiftmapzz '
[zz' (
triszz( ,
[zz, -
nzz- .
]zz. /
]zz/ 0
;zz0 1
nFaces|| 
[|| 
i|| 
]|| 
.|| 
indexesInternal|| )
=||* +
tris||, 0
;||0 1
}}} 
mesh 
. 
SetVertices 
( 
vertices %
)% &
;& '
mesh
ÄÄ 
.
ÄÄ $
sharedVerticesInternal
ÄÄ '
=
ÄÄ( )
SharedVertex
ÄÄ* 6
.
ÄÄ6 7"
SortedRemoveAndShift
ÄÄ7 K
(
ÄÄK L
mesh
ÄÄL P
.
ÄÄP Q 
sharedVertexLookup
ÄÄQ c
,
ÄÄc d
indexesToRemove
ÄÄe t
)
ÄÄt u
;
ÄÄu v
mesh
ÅÅ 
.
ÅÅ 
sharedTextures
ÅÅ 
=
ÅÅ  !
SharedVertex
ÅÅ" .
.
ÅÅ. /"
SortedRemoveAndShift
ÅÅ/ C
(
ÅÅC D
mesh
ÅÅD H
.
ÅÅH I!
sharedTextureLookup
ÅÅI \
,
ÅÅ\ ]
indexesToRemove
ÅÅ^ m
)
ÅÅm n
;
ÅÅn o
mesh
ÇÇ 
.
ÇÇ 
facesInternal
ÇÇ 
=
ÇÇ  
nFaces
ÇÇ! '
;
ÇÇ' (
int
ÉÉ 
[
ÉÉ 
]
ÉÉ 
array
ÉÉ 
=
ÉÉ 
indexesToRemove
ÉÉ )
.
ÉÉ) *
ToArray
ÉÉ* 1
(
ÉÉ1 2
)
ÉÉ2 3
;
ÉÉ3 4
return
ÖÖ 
array
ÖÖ 
;
ÖÖ 
}
ÜÜ 	
[
àà 	
Obsolete
àà	 
(
àà 
$str
àà @
)
àà@ A
]
ààA B
[
ââ 	
EditorBrowsable
ââ	 
(
ââ "
EditorBrowsableState
ââ -
.
ââ- .
Never
ââ. 3
)
ââ3 4
]
ââ4 5
public
ää 
static
ää 
int
ää 
[
ää 
]
ää '
RemoveDegenerateTriangles
ää 5
(
ää5 6
this
ää6 :
ProBuilderMesh
ää; I
mesh
ääJ N
)
ääN O
{
ãã 	
List
åå 
<
åå 
int
åå 
>
åå 
removed
åå 
=
åå 
new
åå  #
List
åå$ (
<
åå( )
int
åå) ,
>
åå, -
(
åå- .
)
åå. /
;
åå/ 0
MeshValidation
çç 
.
çç '
RemoveDegenerateTriangles
çç 4
(
çç4 5
mesh
çç5 9
,
çç9 :
removed
çç; B
)
ççB C
;
ççC D
return
éé 
removed
éé 
.
éé 
ToArray
éé "
(
éé" #
)
éé# $
;
éé$ %
}
èè 	
[
ëë 	
Obsolete
ëë	 
(
ëë 
$str
ëë ;
)
ëë; <
]
ëë< =
[
íí 	
EditorBrowsable
íí	 
(
íí "
EditorBrowsableState
íí -
.
íí- .
Never
íí. 3
)
íí3 4
]
íí4 5
public
ìì 
static
ìì 
int
ìì 
[
ìì 
]
ìì "
RemoveUnusedVertices
ìì 0
(
ìì0 1
this
ìì1 5
ProBuilderMesh
ìì6 D
mesh
ììE I
)
ììI J
{
îî 	
List
ïï 
<
ïï 
int
ïï 
>
ïï 
removed
ïï 
=
ïï 
new
ïï  #
List
ïï$ (
<
ïï( )
int
ïï) ,
>
ïï, -
(
ïï- .
)
ïï. /
;
ïï/ 0
MeshValidation
ññ 
.
ññ "
RemoveUnusedVertices
ññ /
(
ññ/ 0
mesh
ññ0 4
,
ññ4 5
removed
ññ6 =
)
ññ= >
;
ññ> ?
return
óó 
removed
óó 
.
óó 
ToArray
óó "
(
óó" #
)
óó# $
;
óó$ %
}
òò 	
}
ôô 
}öö Ç
ñD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\Subdivision.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
static		 

class		 
Subdivision		 
{

 
public 
static 
ActionResult "
	Subdivide# ,
(, -
this- 1
ProBuilderMesh2 @
pbA C
)C D
{ 	
return 
pb 
. 
	Subdivide 
(  
pb  "
." #
facesInternal# 0
)0 1
!=2 4
null5 9
?: ;
new< ?
ActionResult@ L
(L M
ActionResultM Y
.Y Z
StatusZ `
.` a
Successa h
,h i
$strj u
)u v
:w x
newy |
ActionResult	} â
(
â ä
ActionResult
ä ñ
.
ñ ó
Status
ó ù
.
ù û
Failure
û •
,
• ¶
$str
ß π
)
π ∫
;
∫ ª
} 	
public 
static 
Face 
[ 
] 
	Subdivide &
(& '
this' +
ProBuilderMesh, :
pb; =
,= >
IList? D
<D E
FaceE I
>I J
facesK P
)P Q
{ 	
return 
ConnectElements "
." #
Connect# *
(* +
pb+ -
,- .
faces/ 4
)4 5
;5 6
} 	
}   
}!! 