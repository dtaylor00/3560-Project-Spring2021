Á
—D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ProBuilderMeshFunction.cs
	namespace		 	
UnityEngine		
 
.		 

ProBuilder		  
{

 
public 

sealed 
partial 
class 
ProBuilderMesh  .
:/ 0*
ISerializationCallbackReceiver1 O
{ 
static 
HashSet 
< 
int 
> 
s_CachedHashSet +
=, -
new. 1
HashSet2 9
<9 :
int: =
>= >
(> ?
)? @
;@ A
public 
void 
OnBeforeSerialize %
(% &
)& '
{( )
}) *
public 
void 
OnAfterDeserialize &
(& '
)' (
{ 	
InvalidateCaches 
( 
) 
; 
} 	
void:: 
Awake:: 
(:: 
):: 
{;; 	&
EnsureMeshFilterIsAssigned<< &
(<<& '
)<<' (
;<<( )(
EnsureMeshColliderIsAssigned== (
(==( )
)==) *
;==* +
if?? 
(?? 
vertexCount?? 
>?? 
$num?? 
&&@@ 
	faceCount@@ 
>@@ 
$num@@  
&&AA 
meshSyncStateAA  
==AA! #
MeshSyncStateAA$ 1
.AA1 2
NullAA2 6
)AA6 7
RebuildBB 
(BB 
)BB 
;BB 
}CC 	
voidEE 
ResetEE 
(EE 
)EE 
{FF 	
ifGG 
(GG 
meshSyncStateGG 
!=GG  
MeshSyncStateGG! .
.GG. /
NullGG/ 3
&&GG4 6
meshSyncStateGG7 D
!=GGE G
MeshSyncStateGGH U
.GGU V
InstanceIDMismatchGGV h
)GGh i
{HH 
RebuildII 
(II 
)II 
;II 
ifJJ 
(JJ !
componentHasBeenResetJJ )
!=JJ* ,
nullJJ- 1
)JJ1 2!
componentHasBeenResetKK )
(KK) *
thisKK* .
)KK. /
;KK/ 0
}LL 
}MM 	
voidOO 
	OnDestroyOO 
(OO 
)OO 
{PP 	
ifRR 
(RR 
m_MeshFilterRR 
!=RR 
nullRR  $
||RR% '
thisRR( ,
.RR, -
TryGetComponentRR- <
(RR< =
outRR= @
m_MeshFilterRRA M
)RRM N
)RRN O
m_MeshFilterSS 
.SS 
	hideFlagsSS &
=SS' (
	HideFlagsSS) 2
.SS2 3
NoneSS3 7
;SS7 8
ifUU 
(UU $
componentWillBeDestroyedUU (
!=UU) +
nullUU, 0
)UU0 1$
componentWillBeDestroyedVV (
(VV( )
thisVV) -
)VV- .
;VV. /
ifZZ 
(ZZ 
!ZZ &
preserveMeshAssetOnDestroyZZ +
&&ZZ, .
Application[[ 
.[[ 
isEditor[[ $
&&[[% '
!\\ 
Application\\ 
.\\ 
	isPlaying\\ &
&&\\' )
Time]] 
.]] 

frameCount]] 
>]]  !
$num]]" #
)]]# $
{^^ 
if__ 
(__ 
meshWillBeDestroyed__ '
!=__( *
null__+ /
)__/ 0
meshWillBeDestroyed`` '
(``' (
this``( ,
)``, -
;``- .
elseaa 
DestroyImmediatebb $
(bb$ %

gameObjectbb% /
.bb/ 0
GetComponentbb0 <
<bb< =

MeshFilterbb= G
>bbG H
(bbH I
)bbI J
.bbJ K

sharedMeshbbK U
,bbU V
truebbW [
)bb[ \
;bb\ ]
}cc 
}dd 	
publicii 
voidii 
Clearii 
(ii 
)ii 
{jj 	
m_Facesmm 
=mm 
newmm 
Facemm 
[mm 
$nummm  
]mm  !
;mm! "
m_Positionsnn 
=nn 
newnn 
Vector3nn %
[nn% &
$numnn& '
]nn' (
;nn( )
m_Textures0oo 
=oo 
newoo 
Vector2oo %
[oo% &
$numoo& '
]oo' (
;oo( )
m_Textures2pp 
=pp 
nullpp 
;pp 
m_Textures3qq 
=qq 
nullqq 
;qq 

m_Tangentsrr 
=rr 
nullrr 
;rr 
m_SharedVerticesss 
=ss 
newss "
SharedVertexss# /
[ss/ 0
$numss0 1
]ss1 2
;ss2 3
m_SharedTexturestt 
=tt 
newtt "
SharedVertextt# /
[tt/ 0
$numtt0 1
]tt1 2
;tt2 3(
InvalidateSharedVertexLookupuu (
(uu( )
)uu) *
;uu* +)
InvalidateSharedTextureLookupvv )
(vv) *
)vv* +
;vv+ ,
m_Colorsww 
=ww 
nullww 
;ww 
ClearSelectionxx 
(xx 
)xx 
;xx 
}yy 	
internal{{ 
void{{ &
EnsureMeshFilterIsAssigned{{ 0
({{0 1
){{1 2
{|| 	
if}} 
(}} 
filter}} 
==}} 
null}} 
)}} 
m_MeshFilter~~ 
=~~ 

gameObject~~ )
.~~) *
AddComponent~~* 6
<~~6 7

MeshFilter~~7 A
>~~A B
(~~B C
)~~C D
;~~D E
m_MeshFilter
 
.
 
	hideFlags
 "
=
# $#
k_MeshFilterHideFlags
% :
;
: ;
if
„„ 
(
„„ 
!
„„ 
renderer
„„ 
.
„„ !
isPartOfStaticBatch
„„ -
&&
„„. 0
filter
„„1 7
.
„„7 8

sharedMesh
„„8 B
!=
„„C E
m_Mesh
„„F L
)
„„L M
filter
…… 
.
…… 

sharedMesh
…… !
=
……" #
m_Mesh
……$ *
;
……* +
}
†† 	
internal
ˆˆ 
static
ˆˆ 
ProBuilderMesh
ˆˆ &&
CreateInstanceWithPoints
ˆˆ' ?
(
ˆˆ? @
Vector3
ˆˆ@ G
[
ˆˆG H
]
ˆˆH I
	positions
ˆˆJ S
)
ˆˆS T
{
‰‰ 	
if
ŠŠ 
(
ŠŠ 
	positions
ŠŠ 
.
ŠŠ 
Length
ŠŠ  
%
ŠŠ! "
$num
ŠŠ# $
!=
ŠŠ% '
$num
ŠŠ( )
)
ŠŠ) *
{
‹‹ 
Log
ŒŒ 
.
ŒŒ 
Warning
ŒŒ 
(
ŒŒ 
$str
ŒŒ ]
)
ŒŒ] ^
;
ŒŒ^ _
return
 
null
 
;
 
}
 

GameObject
 
go
 
=
 
new
 

GameObject
  *
(
* +
)
+ ,
;
, -
go
‘‘ 
.
‘‘ 
name
‘‘ 
=
‘‘ 
$str
‘‘ '
;
‘‘' (
ProBuilderMesh
’’ 
pb
’’ 
=
’’ 
go
’’  "
.
’’" #
AddComponent
’’# /
<
’’/ 0
ProBuilderMesh
’’0 >
>
’’> ?
(
’’? @
)
’’@ A
;
’’A B
pb
““ 
.
““ !
m_MeshFormatVersion
““ "
=
““# $!
k_MeshFormatVersion
““% 8
;
““8 9
pb
”” 
.
””  
GeometryWithPoints
”” !
(
””! "
	positions
””" +
)
””+ ,
;
””, -
return
–– 
pb
–– 
;
–– 
}
—— 	
public
 
static
 
ProBuilderMesh
 $
Create
% +
(
+ ,
)
, -
{
ŸŸ 	
var
   
go
   
=
   
new
   

GameObject
   #
(
  # $
)
  $ %
;
  % &
var
¡¡ 
pb
¡¡ 
=
¡¡ 
go
¡¡ 
.
¡¡ 
AddComponent
¡¡ $
<
¡¡$ %
ProBuilderMesh
¡¡% 3
>
¡¡3 4
(
¡¡4 5
)
¡¡5 6
;
¡¡6 7
pb
¢¢ 
.
¢¢ !
m_MeshFormatVersion
¢¢ "
=
¢¢# $!
k_MeshFormatVersion
¢¢% 8
;
¢¢8 9
pb
££ 
.
££ 
Clear
££ 
(
££ 
)
££ 
;
££ 
return
¤¤ 
pb
¤¤ 
;
¤¤ 
}
¥¥ 	
public
­­ 
static
­­ 
ProBuilderMesh
­­ $
Create
­­% +
(
­­+ ,
IEnumerable
­­, 7
<
­­7 8
Vector3
­­8 ?
>
­­? @
	positions
­­A J
,
­­J K
IEnumerable
­­L W
<
­­W X
Face
­­X \
>
­­\ ]
faces
­­^ c
)
­­c d
{
®® 	

GameObject
¯¯ 
go
¯¯ 
=
¯¯ 
new
¯¯ 

GameObject
¯¯  *
(
¯¯* +
)
¯¯+ ,
;
¯¯, -
ProBuilderMesh
°° 
pb
°° 
=
°° 
go
°°  "
.
°°" #
AddComponent
°°# /
<
°°/ 0
ProBuilderMesh
°°0 >
>
°°> ?
(
°°? @
)
°°@ A
;
°°A B
go
±± 
.
±± 
name
±± 
=
±± 
$str
±± '
;
±±' (
pb
²² 
.
²² !
m_MeshFormatVersion
²² "
=
²²# $!
k_MeshFormatVersion
²²% 8
;
²²8 9
pb
³³ 
.
³³ *
RebuildWithPositionsAndFaces
³³ +
(
³³+ ,
	positions
³³, 5
,
³³5 6
faces
³³7 <
)
³³< =
;
³³= >
return
´´ 
pb
´´ 
;
´´ 
}
µµ 	
public
ÀÀ 
static
ÀÀ 
ProBuilderMesh
ÀÀ $
Create
ÀÀ% +
(
ÀÀ+ ,
IList
ÁÁ 
<
ÁÁ 
Vertex
ÁÁ 
>
ÁÁ 
vertices
ÁÁ "
,
ÁÁ" #
IList
ÂÂ 
<
ÂÂ 
Face
ÂÂ 
>
ÂÂ 
faces
ÂÂ 
,
ÂÂ 
IList
ÃÃ 
<
ÃÃ 
SharedVertex
ÃÃ 
>
ÃÃ 
sharedVertices
ÃÃ  .
=
ÃÃ/ 0
null
ÃÃ1 5
,
ÃÃ5 6
IList
ÄÄ 
<
ÄÄ 
SharedVertex
ÄÄ 
>
ÄÄ 
sharedTextures
ÄÄ  .
=
ÄÄ/ 0
null
ÄÄ1 5
,
ÄÄ5 6
IList
ÅÅ 
<
ÅÅ 
Material
ÅÅ 
>
ÅÅ 
	materials
ÅÅ %
=
ÅÅ& '
null
ÅÅ( ,
)
ÅÅ, -
{
ÆÆ 	
var
ÇÇ 
go
ÇÇ 
=
ÇÇ 
new
ÇÇ 

GameObject
ÇÇ #
(
ÇÇ# $
)
ÇÇ$ %
;
ÇÇ% &
go
ÈÈ 
.
ÈÈ 
name
ÈÈ 
=
ÈÈ 
$str
ÈÈ '
;
ÈÈ' (
var
ÉÉ 
mesh
ÉÉ 
=
ÉÉ 
go
ÉÉ 
.
ÉÉ 
AddComponent
ÉÉ &
<
ÉÉ& '
ProBuilderMesh
ÉÉ' 5
>
ÉÉ5 6
(
ÉÉ6 7
)
ÉÉ7 8
;
ÉÉ8 9
if
ÊÊ 
(
ÊÊ 
	materials
ÊÊ 
!=
ÊÊ 
null
ÊÊ !
)
ÊÊ! "
mesh
ËË 
.
ËË 
renderer
ËË 
.
ËË 
sharedMaterials
ËË -
=
ËË. /
	materials
ËË0 9
.
ËË9 :
ToArray
ËË: A
(
ËËA B
)
ËËB C
;
ËËC D
mesh
ÌÌ 
.
ÌÌ !
m_MeshFormatVersion
ÌÌ $
=
ÌÌ% &!
k_MeshFormatVersion
ÌÌ' :
;
ÌÌ: ;
mesh
ÍÍ 
.
ÍÍ 
SetVertices
ÍÍ 
(
ÍÍ 
vertices
ÍÍ %
)
ÍÍ% &
;
ÍÍ& '
mesh
ÎÎ 
.
ÎÎ 
faces
ÎÎ 
=
ÎÎ 
faces
ÎÎ 
;
ÎÎ 
mesh
ÏÏ 
.
ÏÏ 
sharedVertices
ÏÏ 
=
ÏÏ  !
sharedVertices
ÏÏ" 0
;
ÏÏ0 1
mesh
ĞĞ 
.
ĞĞ 
sharedTextures
ĞĞ 
=
ĞĞ  !
sharedTextures
ĞĞ" 0
!=
ĞĞ1 3
null
ĞĞ4 8
?
ĞĞ9 :
sharedTextures
ĞĞ; I
.
ĞĞI J
ToArray
ĞĞJ Q
(
ĞĞQ R
)
ĞĞR S
:
ĞĞT U
null
ĞĞV Z
;
ĞĞZ [
mesh
ÑÑ 
.
ÑÑ 
ToMesh
ÑÑ 
(
ÑÑ 
)
ÑÑ 
;
ÑÑ 
mesh
ÒÒ 
.
ÒÒ 
Refresh
ÒÒ 
(
ÒÒ 
)
ÒÒ 
;
ÒÒ 
return
ÓÓ 
mesh
ÓÓ 
;
ÓÓ 
}
ÔÔ 	
void
ÖÖ  
GeometryWithPoints
ÖÖ 
(
ÖÖ  
Vector3
ÖÖ  '
[
ÖÖ' (
]
ÖÖ( )
points
ÖÖ* 0
)
ÖÖ0 1
{
×× 	
Face
ÙÙ 
[
ÙÙ 
]
ÙÙ 
f
ÙÙ 
=
ÙÙ 
new
ÙÙ 
Face
ÙÙ 
[
ÙÙ  
points
ÙÙ  &
.
ÙÙ& '
Length
ÙÙ' -
/
ÙÙ. /
$num
ÙÙ0 1
]
ÙÙ1 2
;
ÙÙ2 3
for
ÛÛ 
(
ÛÛ 
int
ÛÛ 
i
ÛÛ 
=
ÛÛ 
$num
ÛÛ 
;
ÛÛ 
i
ÛÛ 
<
ÛÛ 
points
ÛÛ  &
.
ÛÛ& '
Length
ÛÛ' -
;
ÛÛ- .
i
ÛÛ/ 0
+=
ÛÛ1 3
$num
ÛÛ4 5
)
ÛÛ5 6
{
ÜÜ 
f
İİ 
[
İİ 
i
İİ 
/
İİ 
$num
İİ 
]
İİ 
=
İİ 
new
İİ 
Face
İİ #
(
İİ# $
new
İİ$ '
int
İİ( +
[
İİ+ ,
$num
İİ, -
]
İİ- .
{
ŞŞ 
i
ßß 
+
ßß 
$num
ßß 
,
ßß 
i
ßß 
+
ßß 
$num
ßß  
,
ßß  !
i
ßß" #
+
ßß$ %
$num
ßß& '
,
ßß' (
i
àà 
+
àà 
$num
àà 
,
àà 
i
àà 
+
àà 
$num
àà  
,
àà  !
i
àà" #
+
àà$ %
$num
àà& '
}
áá 
,
áá 
$num
ââ 
,
ââ  
AutoUnwrapSettings
ãã *
.
ãã* +
tile
ãã+ /
,
ãã/ 0
$num
ää 
,
ää 
-
åå 
$num
åå 
,
åå 
-
ææ 
$num
ææ 
,
ææ 
false
çç 
)
çç 
;
çç 
}
èè 
Clear
êê 
(
êê 
)
êê 
;
êê 
	positions
ëë 
=
ëë 
points
ëë 
;
ëë 
m_Faces
ìì 
=
ìì 
f
ìì 
;
ìì 
m_SharedVertices
íí 
=
íí 
SharedVertex
íí +
.
íí+ ,,
GetSharedVerticesWithPositions
íí, J
(
ííJ K
points
ííK Q
)
ííQ R
;
ííR S*
InvalidateSharedVertexLookup
îî (
(
îî( )
)
îî) *
;
îî* +
ToMesh
ïï 
(
ïï 
)
ïï 
;
ïï 
Refresh
ğğ 
(
ğğ 
)
ğğ 
;
ğğ 
}
ññ 	
public
øø 
void
øø *
RebuildWithPositionsAndFaces
øø 0
(
øø0 1
IEnumerable
øø1 <
<
øø< =
Vector3
øø= D
>
øøD E
vertices
øøF N
,
øøN O
IEnumerable
øøP [
<
øø[ \
Face
øø\ `
>
øø` a
faces
øøb g
)
øøg h
{
ùù 	
if
úú 
(
úú 
vertices
úú 
==
úú 
null
úú  
)
úú  !
throw
ûû 
new
ûû #
ArgumentNullException
ûû /
(
ûû/ 0
$str
ûû0 :
)
ûû: ;
;
ûû; <
Clear
ıı 
(
ıı 
)
ıı 
;
ıı 
m_Positions
şş 
=
şş 
vertices
şş "
.
şş" #
ToArray
şş# *
(
şş* +
)
şş+ ,
;
şş, -
m_Faces
ÿÿ 
=
ÿÿ 
faces
ÿÿ 
.
ÿÿ 
ToArray
ÿÿ #
(
ÿÿ# $
)
ÿÿ$ %
;
ÿÿ% &
m_SharedVertices
€€ 
=
€€ 
SharedVertex
€€ +
.
€€+ ,,
GetSharedVerticesWithPositions
€€, J
(
€€J K
m_Positions
€€K V
)
€€V W
;
€€W X*
InvalidateSharedVertexLookup
 (
(
( )
)
) *
;
* ++
InvalidateSharedTextureLookup
‚‚ )
(
‚‚) *
)
‚‚* +
;
‚‚+ ,
ToMesh
ƒƒ 
(
ƒƒ 
)
ƒƒ 
;
ƒƒ 
Refresh
„„ 
(
„„ 
)
„„ 
;
„„ 
}
…… 	
internal
ŠŠ 
void
ŠŠ 
Rebuild
ŠŠ 
(
ŠŠ 
)
ŠŠ 
{
‹‹ 	
ToMesh
ŒŒ 
(
ŒŒ 
)
ŒŒ 
;
ŒŒ 
Refresh
 
(
 
)
 
;
 
}
 	
public
”” 
void
”” 
ToMesh
”” 
(
”” 
MeshTopology
”” '
preferredTopology
””( 9
=
””: ;
MeshTopology
””< H
.
””H I
	Triangles
””I R
)
””R S
{
•• 	
if
—— 
(
—— 
mesh
—— 
==
—— 
null
—— 
)
—— 
{
˜˜ 
mesh
œœ 
=
œœ 
new
œœ 
Mesh
œœ 
(
œœ  
)
œœ  !
;
œœ! "
}
 
else
 
if
 
(
 
mesh
 
.
 
vertexCount
 %
!=
& (
vertexCount
) 4
)
4 5
{
ŸŸ 
mesh
   
.
   
Clear
   
(
   
)
   
;
   
}
¡¡ 
mesh
££ 
.
££ 
indexFormat
££ 
=
££ 
vertexCount
££ *
>
££+ ,
ushort
££- 3
.
££3 4
MaxValue
££4 <
?
££= >
	Rendering
££? H
.
££H I
IndexFormat
££I T
.
££T U
UInt32
££U [
:
££\ ]
	Rendering
££^ g
.
££g h
IndexFormat
££h s
.
££s t
UInt16
££t z
;
££z {
mesh
¤¤ 
.
¤¤ 
vertices
¤¤ 
=
¤¤ 
m_Positions
¤¤ '
;
¤¤' (
mesh
¥¥ 
.
¥¥ 
uv2
¥¥ 
=
¥¥ 
null
¥¥ 
;
¥¥ 
if
§§ 
(
§§ !
m_MeshFormatVersion
§§ #
<
§§$ %!
k_MeshFormatVersion
§§& 9
)
§§9 :
{
¨¨ 
if
©© 
(
©© !
m_MeshFormatVersion
©© '
<
©©( )8
*k_MeshFormatVersionSubmeshMaterialRefactor
©©* T
)
©©T U
Submesh
ªª 
.
ªª ,
MapFaceMaterialsToSubmeshIndex
ªª :
(
ªª: ;
this
ªª; ?
)
ªª? @
;
ªª@ A!
m_MeshFormatVersion
¬¬ #
=
¬¬$ %!
k_MeshFormatVersion
¬¬& 9
;
¬¬9 :
}
­­ !
m_MeshFormatVersion
¯¯ 
=
¯¯  !!
k_MeshFormatVersion
¯¯" 5
;
¯¯5 6
int
±± 
materialCount
±± 
=
±± 
MaterialUtility
±±  /
.
±±/ 0
GetMaterialCount
±±0 @
(
±±@ A
renderer
±±A I
)
±±I J
;
±±J K
Submesh
³³ 
[
³³ 
]
³³ 
	submeshes
³³ 
=
³³  !
Submesh
³³" )
.
³³) *
GetSubmeshes
³³* 6
(
³³6 7
facesInternal
³³7 D
,
³³D E
materialCount
³³F S
,
³³S T
preferredTopology
³³U f
)
³³f g
;
³³g h
mesh
µµ 
.
µµ 
subMeshCount
µµ 
=
µµ 
materialCount
µµ  -
;
µµ- .
for
·· 
(
·· 
int
·· 
i
·· 
=
·· 
$num
·· 
;
·· 
i
·· 
<
·· 
mesh
··  $
.
··$ %
subMeshCount
··% 1
;
··1 2
i
··3 4
++
··4 6
)
··6 7
{
¸¸ 
mesh
¿¿ 
.
¿¿ 

SetIndices
¿¿ 
(
¿¿  
	submeshes
¿¿  )
[
¿¿) *
i
¿¿* +
]
¿¿+ ,
.
¿¿, -
	m_Indexes
¿¿- 6
,
¿¿6 7
	submeshes
¿¿8 A
[
¿¿A B
i
¿¿B C
]
¿¿C D
.
¿¿D E

m_Topology
¿¿E O
,
¿¿O P
i
¿¿Q R
,
¿¿R S
false
¿¿T Y
)
¿¿Y Z
;
¿¿Z [
}
ÀÀ 
mesh
ÂÂ 
.
ÂÂ 
name
ÂÂ 
=
ÂÂ 
string
ÂÂ 
.
ÂÂ 
Format
ÂÂ %
(
ÂÂ% &
$str
ÂÂ& 2
,
ÂÂ2 3
id
ÂÂ4 6
)
ÂÂ6 7
;
ÂÂ7 8(
EnsureMeshFilterIsAssigned
ÄÄ &
(
ÄÄ& '
)
ÄÄ' (
;
ÄÄ( )
}
ÅÅ 	
internal
ÊÊ 
void
ÊÊ 

MakeUnique
ÊÊ  
(
ÊÊ  !
)
ÊÊ! "
{
ËË 	
mesh
ÍÍ 
=
ÍÍ 
new
ÍÍ 
Mesh
ÍÍ 
(
ÍÍ 
)
ÍÍ 
;
ÍÍ 
ToMesh
ÎÎ 
(
ÎÎ 
)
ÎÎ 
;
ÎÎ 
Refresh
ÏÏ 
(
ÏÏ 
)
ÏÏ 
;
ÏÏ 
}
ĞĞ 	
public
ÖÖ 
void
ÖÖ 
CopyFrom
ÖÖ 
(
ÖÖ 
ProBuilderMesh
ÖÖ +
other
ÖÖ, 1
)
ÖÖ1 2
{
×× 	
if
ØØ 
(
ØØ 
other
ØØ 
==
ØØ 
null
ØØ 
)
ØØ 
throw
ÙÙ 
new
ÙÙ #
ArgumentNullException
ÙÙ /
(
ÙÙ/ 0
$str
ÙÙ0 7
)
ÙÙ7 8
;
ÙÙ8 9
Clear
ÛÛ 
(
ÛÛ 
)
ÛÛ 
;
ÛÛ 
	positions
ÜÜ 
=
ÜÜ 
other
ÜÜ 
.
ÜÜ 
	positions
ÜÜ '
;
ÜÜ' (
sharedVertices
İİ 
=
İİ 
other
İİ "
.
İİ" #$
sharedVerticesInternal
İİ# 9
;
İİ9 :
SetSharedTextures
ŞŞ 
(
ŞŞ 
other
ŞŞ #
.
ŞŞ# $!
sharedTextureLookup
ŞŞ$ 7
)
ŞŞ7 8
;
ŞŞ8 9
facesInternal
ßß 
=
ßß 
other
ßß !
.
ßß! "
faces
ßß" '
.
ßß' (
Select
ßß( .
(
ßß. /
x
ßß/ 0
=>
ßß1 3
new
ßß4 7
Face
ßß8 <
(
ßß< =
x
ßß= >
)
ßß> ?
)
ßß? @
.
ßß@ A
ToArray
ßßA H
(
ßßH I
)
ßßI J
;
ßßJ K
List
áá 
<
áá 
Vector4
áá 
>
áá 
uvs
áá 
=
áá 
new
áá  #
List
áá$ (
<
áá( )
Vector4
áá) 0
>
áá0 1
(
áá1 2
)
áá2 3
;
áá3 4
for
ãã 
(
ãã 
var
ãã 
i
ãã 
=
ãã 
$num
ãã 
;
ãã 
i
ãã 
<
ãã 
k_UVChannelCount
ãã  0
;
ãã0 1
i
ãã2 3
++
ãã3 5
)
ãã5 6
{
ää 
other
åå 
.
åå 
GetUVs
åå 
(
åå 
i
åå 
,
åå 
uvs
åå  #
)
åå# $
;
åå$ %
SetUVs
ææ 
(
ææ 
i
ææ 
,
ææ 
uvs
ææ 
)
ææ 
;
ææ 
}
çç 
tangents
éé 
=
éé 
other
éé 
.
éé 
tangents
éé %
;
éé% &
colors
êê 
=
êê 
other
êê 
.
êê 
colors
êê !
;
êê! "
userCollisions
ëë 
=
ëë 
other
ëë "
.
ëë" #
userCollisions
ëë# 1
;
ëë1 2

selectable
ìì 
=
ìì 
other
ìì 
.
ìì 

selectable
ìì )
;
ìì) *
unwrapParameters
íí 
=
íí 
new
íí "
UnwrapParameters
íí# 3
(
íí3 4
other
íí4 9
.
íí9 :
unwrapParameters
íí: J
)
ííJ K
;
ííK L
}
îî 	
public
öö 
void
öö 
Refresh
öö 
(
öö 
RefreshMask
öö '
mask
öö( ,
=
öö- .
RefreshMask
öö/ :
.
öö: ;
All
öö; >
)
öö> ?
{
÷÷ 	
if
ùù 
(
ùù 
(
ùù 
mask
ùù 
&
ùù 
RefreshMask
ùù #
.
ùù# $
UV
ùù$ &
)
ùù& '
>
ùù( )
$num
ùù* +
)
ùù+ ,
	RefreshUV
úú 
(
úú 
facesInternal
úú '
)
úú' (
;
úú( )
if
üü 
(
üü 
(
üü 
mask
üü 
&
üü 
RefreshMask
üü #
.
üü# $
Colors
üü$ *
)
üü* +
>
üü, -
$num
üü. /
)
üü/ 0
RefreshColors
ıı 
(
ıı 
)
ıı 
;
ıı  
if
ÿÿ 
(
ÿÿ 
(
ÿÿ 
mask
ÿÿ 
&
ÿÿ 
RefreshMask
ÿÿ #
.
ÿÿ# $
Normals
ÿÿ$ +
)
ÿÿ+ ,
>
ÿÿ- .
$num
ÿÿ/ 0
)
ÿÿ0 1
RefreshNormals
€€ 
(
€€ 
)
€€  
;
€€  !
if
‚‚ 
(
‚‚ 
(
‚‚ 
mask
‚‚ 
&
‚‚ 
RefreshMask
‚‚ #
.
‚‚# $
Tangents
‚‚$ ,
)
‚‚, -
>
‚‚. /
$num
‚‚0 1
)
‚‚1 2
RefreshTangents
ƒƒ 
(
ƒƒ  
)
ƒƒ  !
;
ƒƒ! "
if
…… 
(
…… 
(
…… 
mask
…… 
&
…… 
RefreshMask
…… #
.
……# $

Collisions
……$ .
)
……. /
>
……0 1
$num
……2 3
)
……3 4*
EnsureMeshColliderIsAssigned
†† ,
(
††, -
)
††- .
;
††. /
}
‡‡ 	
internal
‰‰ 
void
‰‰ *
EnsureMeshColliderIsAssigned
‰‰ 2
(
‰‰2 3
)
‰‰3 4
{
ŠŠ 	
if
‹‹ 
(
‹‹ 

gameObject
‹‹ 
.
‹‹ 
TryGetComponent
‹‹ )
<
‹‹) *
MeshCollider
‹‹* 6
>
‹‹6 7
(
‹‹7 8
out
‹‹8 ;
MeshCollider
‹‹< H
collider
‹‹I Q
)
‹‹Q R
)
‹‹R S
{
ŒŒ 
if
 
(
 
collider
 
.
 

sharedMesh
 '
!=
( *
mesh
+ /
)
/ 0
{
‘‘ 
collider
’’ 
.
’’ 

sharedMesh
’’ '
=
’’( )
null
’’* .
;
’’. /
collider
““ 
.
““ 

sharedMesh
““ '
=
““( )
mesh
““* .
;
““. /
}
”” 
}
•• 
}
–– 	
internal
 
int
 #
GetUnusedTextureGroup
 *
(
* +
int
+ .
i
/ 0
=
1 2
$num
3 4
)
4 5
{
ŸŸ 	
while
   
(
   
Array
   
.
   
Exists
   
(
    
facesInternal
    -
,
  - .
element
  / 6
=>
  7 9
element
  : A
.
  A B
textureGroup
  B N
==
  O Q
i
  R S
)
  S T
)
  T U
i
¡¡ 
++
¡¡ 
;
¡¡ 
return
££ 
i
££ 
;
££ 
}
¤¤ 	
static
¦¦ 
bool
¦¦ !
IsValidTextureGroup
¦¦ '
(
¦¦' (
int
¦¦( +
group
¦¦, 1
)
¦¦1 2
{
§§ 	
return
¨¨ 
group
¨¨ 
>
¨¨ 
$num
¨¨ 
;
¨¨ 
}
©© 	
internal
±± 
int
±±  
UnusedElementGroup
±± '
(
±±' (
int
±±( +
i
±±, -
=
±±. /
$num
±±0 1
)
±±1 2
{
²² 	
while
³³ 
(
³³ 
Array
³³ 
.
³³ 
Exists
³³ 
(
³³  
facesInternal
³³  -
,
³³- .
element
³³/ 6
=>
³³7 9
element
³³: A
.
³³A B
elementGroup
³³B N
==
³³O Q
i
³³R S
)
³³S T
)
³³T U
i
´´ 
++
´´ 
;
´´ 
return
¶¶ 
i
¶¶ 
;
¶¶ 
}
·· 	
public
¹¹ 
void
¹¹ 
	RefreshUV
¹¹ 
(
¹¹ 
IEnumerable
¹¹ )
<
¹¹) *
Face
¹¹* .
>
¹¹. /
facesToRefresh
¹¹0 >
)
¹¹> ?
{
ºº 	
if
½½ 
(
½½ 
!
½½ 
	HasArrays
½½ 
(
½½ 

MeshArrays
½½ %
.
½½% &
Texture0
½½& .
)
½½. /
)
½½/ 0
{
¾¾ 
m_Textures0
¿¿ 
=
¿¿ 
new
¿¿ !
Vector2
¿¿" )
[
¿¿) *
vertexCount
¿¿* 5
]
¿¿5 6
;
¿¿6 7
foreach
ÀÀ 
(
ÀÀ 
Face
ÀÀ 
f
ÀÀ 
in
ÀÀ  "
facesInternal
ÀÀ# 0
)
ÀÀ0 1
f
ÁÁ 
.
ÁÁ 
manualUV
ÁÁ 
=
ÁÁ  
false
ÁÁ! &
;
ÁÁ& '
facesToRefresh
ÂÂ 
=
ÂÂ  
facesInternal
ÂÂ! .
;
ÂÂ. /
}
ÃÃ 
s_CachedHashSet
ÅÅ 
.
ÅÅ 
Clear
ÅÅ !
(
ÅÅ! "
)
ÅÅ" #
;
ÅÅ# $
foreach
ÇÇ 
(
ÇÇ 
var
ÇÇ 
face
ÇÇ 
in
ÇÇ  
facesToRefresh
ÇÇ! /
)
ÇÇ/ 0
{
ÈÈ 
if
ÉÉ 
(
ÉÉ 
face
ÉÉ 
.
ÉÉ 
manualUV
ÉÉ !
||
ÉÉ" $
face
ÉÉ% )
.
ÉÉ) *
indexesInternal
ÉÉ* 9
?
ÉÉ9 :
.
ÉÉ: ;
Length
ÉÉ; A
<
ÉÉB C
$num
ÉÉD E
)
ÉÉE F
continue
ÊÊ 
;
ÊÊ 
int
ÌÌ 
textureGroup
ÌÌ  
=
ÌÌ! "
face
ÌÌ# '
.
ÌÌ' (
textureGroup
ÌÌ( 4
;
ÌÌ4 5
if
ÎÎ 
(
ÎÎ 
!
ÎÎ !
IsValidTextureGroup
ÎÎ (
(
ÎÎ( )
textureGroup
ÎÎ) 5
)
ÎÎ5 6
)
ÎÎ6 7
UvUnwrapping
ÏÏ  
.
ÏÏ  !
Unwrap
ÏÏ! '
(
ÏÏ' (
this
ÏÏ( ,
,
ÏÏ, -
face
ÏÏ. 2
)
ÏÏ2 3
;
ÏÏ3 4
else
ĞĞ 
if
ĞĞ 
(
ĞĞ 
s_CachedHashSet
ĞĞ (
.
ĞĞ( )
Add
ĞĞ) ,
(
ĞĞ, -
textureGroup
ĞĞ- 9
)
ĞĞ9 :
)
ĞĞ: ;
UvUnwrapping
ÑÑ  
.
ÑÑ  !!
ProjectTextureGroup
ÑÑ! 4
(
ÑÑ4 5
this
ÑÑ5 9
,
ÑÑ9 :
textureGroup
ÑÑ; G
,
ÑÑG H
face
ÑÑI M
.
ÑÑM N
uv
ÑÑN P
)
ÑÑP Q
;
ÑÑQ R
}
ÒÒ 
mesh
ÔÔ 
.
ÔÔ 
uv
ÔÔ 
=
ÔÔ 
m_Textures0
ÔÔ !
;
ÔÔ! "
if
ÖÖ 
(
ÖÖ 
	HasArrays
ÖÖ 
(
ÖÖ 

MeshArrays
ÖÖ $
.
ÖÖ$ %
Texture2
ÖÖ% -
)
ÖÖ- .
)
ÖÖ. /
mesh
×× 
.
×× 
SetUVs
×× 
(
×× 
$num
×× 
,
×× 
m_Textures2
×× *
)
××* +
;
××+ ,
if
ØØ 
(
ØØ 
	HasArrays
ØØ 
(
ØØ 

MeshArrays
ØØ $
.
ØØ$ %
Texture3
ØØ% -
)
ØØ- .
)
ØØ. /
mesh
ÙÙ 
.
ÙÙ 
SetUVs
ÙÙ 
(
ÙÙ 
$num
ÙÙ 
,
ÙÙ 
m_Textures3
ÙÙ *
)
ÙÙ* +
;
ÙÙ+ ,
}
ÚÚ 	
internal
ÜÜ 
void
ÜÜ 

SetGroupUV
ÜÜ  
(
ÜÜ  ! 
AutoUnwrapSettings
ÜÜ! 3
settings
ÜÜ4 <
,
ÜÜ< =
int
ÜÜ> A
group
ÜÜB G
)
ÜÜG H
{
İİ 	
if
ŞŞ 
(
ŞŞ 
!
ŞŞ !
IsValidTextureGroup
ŞŞ $
(
ŞŞ$ %
group
ŞŞ% *
)
ŞŞ* +
)
ŞŞ+ ,
return
ßß 
;
ßß 
foreach
áá 
(
áá 
var
áá 
face
áá 
in
áá  
facesInternal
áá! .
)
áá. /
{
ââ 
if
ãã 
(
ãã 
face
ãã 
.
ãã 
textureGroup
ãã %
!=
ãã& (
group
ãã) .
)
ãã. /
continue
ää 
;
ää 
face
ææ 
.
ææ 
uv
ææ 
=
ææ 
settings
ææ "
;
ææ" #
}
çç 
}
èè 	
void
êê 
RefreshColors
êê 
(
êê 
)
êê 
{
ëë 	
Mesh
ìì 
m
ìì 
=
ìì 
filter
ìì 
.
ìì 

sharedMesh
ìì &
;
ìì& '
m
íí 
.
íí 
colors
íí 
=
íí 
m_Colors
íí 
;
íí  
}
îî 	
public
õõ 
void
õõ 
SetFaceColor
õõ  
(
õõ  !
Face
õõ! %
face
õõ& *
,
õõ* +
Color
õõ, 1
color
õõ2 7
)
õõ7 8
{
öö 	
if
÷÷ 
(
÷÷ 
face
÷÷ 
==
÷÷ 
null
÷÷ 
)
÷÷ 
throw
øø 
new
øø #
ArgumentNullException
øø /
(
øø/ 0
$str
øø0 6
)
øø6 7
;
øø7 8
if
úú 
(
úú 
!
úú 
	HasArrays
úú 
(
úú 

MeshArrays
úú %
.
úú% &
Color
úú& +
)
úú+ ,
)
úú, -
m_Colors
ûû 
=
ûû 
ArrayUtility
ûû '
.
ûû' (
Fill
ûû( ,
(
ûû, -
Color
ûû- 2
.
ûû2 3
white
ûû3 8
,
ûû8 9
vertexCount
ûû: E
)
ûûE F
;
ûûF G
foreach
ıı 
(
ıı 
int
ıı 
i
ıı 
in
ıı 
face
ıı "
.
ıı" #
distinctIndexes
ıı# 2
)
ıı2 3
m_Colors
şş 
[
şş 
i
şş 
]
şş 
=
şş 
color
şş #
;
şş# $
}
ÿÿ 	
public
‰‰ 
void
‰‰ 
SetMaterial
‰‰ 
(
‰‰  
IEnumerable
‰‰  +
<
‰‰+ ,
Face
‰‰, 0
>
‰‰0 1
faces
‰‰2 7
,
‰‰7 8
Material
‰‰9 A
material
‰‰B J
)
‰‰J K
{
ŠŠ 	
var
‹‹ 
	materials
‹‹ 
=
‹‹ 
renderer
‹‹ $
.
‹‹$ %
sharedMaterials
‹‹% 4
;
‹‹4 5
var
ŒŒ 
submeshCount
ŒŒ 
=
ŒŒ 
	materials
ŒŒ (
.
ŒŒ( )
Length
ŒŒ) /
;
ŒŒ/ 0
var
 
index
 
=
 
-
 
$num
 
;
 
for
 
(
 
int
 
i
 
=
 
$num
 
;
 
i
 
<
 
submeshCount
  ,
&&
- /
index
0 5
<
6 7
$num
8 9
;
9 :
i
; <
++
< >
)
> ?
{
 
if
‘‘ 
(
‘‘ 
	materials
‘‘ 
[
‘‘ 
i
‘‘ 
]
‘‘  
==
‘‘! #
material
‘‘$ ,
)
‘‘, -
index
’’ 
=
’’ 
i
’’ 
;
’’ 
}
““ 
if
•• 
(
•• 
index
•• 
<
•• 
$num
•• 
)
•• 
{
–– 
var
™™ 
submeshIndexes
™™ "
=
™™# $
new
™™% (
bool
™™) -
[
™™- .
submeshCount
™™. :
]
™™: ;
;
™™; <
foreach
›› 
(
›› 
var
›› 
face
›› !
in
››" $
m_Faces
››% ,
)
››, -
submeshIndexes
œœ "
[
œœ" #
Math
œœ# '
.
œœ' (
Clamp
œœ( -
(
œœ- .
face
œœ. 2
.
œœ2 3
submeshIndex
œœ3 ?
,
œœ? @
$num
œœA B
,
œœB C
submeshCount
œœD P
-
œœQ R
$num
œœS T
)
œœT U
]
œœU V
=
œœW X
true
œœY ]
;
œœ] ^
index
 
=
 
Array
 
.
 
IndexOf
 %
(
% &
submeshIndexes
& 4
,
4 5
false
6 ;
)
; <
;
< =
if
¡¡ 
(
¡¡ 
index
¡¡ 
>
¡¡ 
-
¡¡ 
$num
¡¡ 
)
¡¡ 
{
¢¢ 
	materials
££ 
[
££ 
index
££ #
]
££# $
=
££% &
material
££' /
;
££/ 0
renderer
¤¤ 
.
¤¤ 
sharedMaterials
¤¤ ,
=
¤¤- .
	materials
¤¤/ 8
;
¤¤8 9
}
¥¥ 
else
¦¦ 
{
§§ 
index
©© 
=
©© 
	materials
©© %
.
©©% &
Length
©©& ,
;
©©, -
var
ªª 
copy
ªª 
=
ªª 
new
ªª "
Material
ªª# +
[
ªª+ ,
index
ªª, 1
+
ªª2 3
$num
ªª4 5
]
ªª5 6
;
ªª6 7
Array
«« 
.
«« 
Copy
«« 
(
«« 
	materials
«« (
,
««( )
copy
««* .
,
««. /
index
««0 5
)
««5 6
;
««6 7
copy
¬¬ 
[
¬¬ 
index
¬¬ 
]
¬¬ 
=
¬¬  !
material
¬¬" *
;
¬¬* +
renderer
­­ 
.
­­ 
sharedMaterials
­­ ,
=
­­- .
copy
­­/ 3
;
­­3 4
}
®® 
}
¯¯ 
foreach
±± 
(
±± 
var
±± 
face
±± 
in
±±  
faces
±±! &
)
±±& '
face
²² 
.
²² 
submeshIndex
²² !
=
²²" #
index
²²$ )
;
²²) *
}
³³ 	
void
µµ 
RefreshNormals
µµ 
(
µµ 
)
µµ 
{
¶¶ 	
Normals
·· 
.
·· 
CalculateNormals
·· $
(
··$ %
this
··% )
)
··) *
;
··* +
mesh
¸¸ 
.
¸¸ 
normals
¸¸ 
=
¸¸ 
	m_Normals
¸¸ $
;
¸¸$ %
}
¹¹ 	
void
»» 
RefreshTangents
»» 
(
»» 
)
»» 
{
¼¼ 	
Normals
½½ 
.
½½ 
CalculateTangents
½½ %
(
½½% &
this
½½& *
)
½½* +
;
½½+ ,
mesh
¾¾ 
.
¾¾ 
tangents
¾¾ 
=
¾¾ 

m_Tangents
¾¾ &
;
¾¾& '
}
¿¿ 	
internal
ÆÆ 
int
ÆÆ #
GetSharedVertexHandle
ÆÆ *
(
ÆÆ* +
int
ÆÆ+ .
vertex
ÆÆ/ 5
)
ÆÆ5 6
{
ÇÇ 	
int
ÈÈ 
res
ÈÈ 
;
ÈÈ 
if
ÊÊ 
(
ÊÊ "
m_SharedVertexLookup
ÊÊ $
.
ÊÊ$ %
TryGetValue
ÊÊ% 0
(
ÊÊ0 1
vertex
ÊÊ1 7
,
ÊÊ7 8
out
ÊÊ9 <
res
ÊÊ= @
)
ÊÊ@ A
)
ÊÊA B
return
ËË 
res
ËË 
;
ËË 
for
ÍÍ 
(
ÍÍ 
int
ÍÍ 
i
ÍÍ 
=
ÍÍ 
$num
ÍÍ 
;
ÍÍ 
i
ÍÍ 
<
ÍÍ 
m_SharedVertices
ÍÍ  0
.
ÍÍ0 1
Length
ÍÍ1 7
;
ÍÍ7 8
i
ÍÍ9 :
++
ÍÍ: <
)
ÍÍ< =
{
ÎÎ 
for
ÏÏ 
(
ÏÏ 
int
ÏÏ 
n
ÏÏ 
=
ÏÏ 
$num
ÏÏ 
,
ÏÏ 
c
ÏÏ  !
=
ÏÏ" #
m_SharedVertices
ÏÏ$ 4
[
ÏÏ4 5
i
ÏÏ5 6
]
ÏÏ6 7
.
ÏÏ7 8
Count
ÏÏ8 =
;
ÏÏ= >
n
ÏÏ? @
<
ÏÏA B
c
ÏÏC D
;
ÏÏD E
n
ÏÏF G
++
ÏÏG I
)
ÏÏI J
if
ĞĞ 
(
ĞĞ 
m_SharedVertices
ĞĞ (
[
ĞĞ( )
i
ĞĞ) *
]
ĞĞ* +
[
ĞĞ+ ,
n
ĞĞ, -
]
ĞĞ- .
==
ĞĞ/ 1
vertex
ĞĞ2 8
)
ĞĞ8 9
return
ÑÑ 
i
ÑÑ  
;
ÑÑ  !
}
ÒÒ 
throw
ÔÔ 
new
ÔÔ )
ArgumentOutOfRangeException
ÔÔ 1
(
ÔÔ1 2
$str
ÔÔ2 :
)
ÔÔ: ;
;
ÔÔ; <
}
ÕÕ 	
internal
×× 
HashSet
×× 
<
×× 
int
×× 
>
×× $
GetSharedVertexHandles
×× 4
(
××4 5
IEnumerable
××5 @
<
××@ A
int
××A D
>
××D E
vertices
××F N
)
××N O
{
ØØ 	
var
ÙÙ 
lookup
ÙÙ 
=
ÙÙ  
sharedVertexLookup
ÙÙ +
;
ÙÙ+ ,
HashSet
ÚÚ 
<
ÚÚ 
int
ÚÚ 
>
ÚÚ 
common
ÚÚ 
=
ÚÚ  !
new
ÚÚ" %
HashSet
ÚÚ& -
<
ÚÚ- .
int
ÚÚ. 1
>
ÚÚ1 2
(
ÚÚ2 3
)
ÚÚ3 4
;
ÚÚ4 5
foreach
ÛÛ 
(
ÛÛ 
var
ÛÛ 
i
ÛÛ 
in
ÛÛ 
vertices
ÛÛ &
)
ÛÛ& '
common
ÜÜ 
.
ÜÜ 
Add
ÜÜ 
(
ÜÜ 
lookup
ÜÜ !
[
ÜÜ! "
i
ÜÜ" #
]
ÜÜ# $
)
ÜÜ$ %
;
ÜÜ% &
return
İİ 
common
İİ 
;
İİ 
}
ŞŞ 	
public
ææ 
List
ææ 
<
ææ 
int
ææ 
>
ææ #
GetCoincidentVertices
ææ .
(
ææ. /
IEnumerable
ææ/ :
<
ææ: ;
int
ææ; >
>
ææ> ?
vertices
ææ@ H
)
ææH I
{
çç 	
if
èè 
(
èè 
vertices
èè 
==
èè 
null
èè  
)
èè  !
throw
éé 
new
éé #
ArgumentNullException
éé /
(
éé/ 0
$str
éé0 :
)
éé: ;
;
éé; <
List
ëë 
<
ëë 
int
ëë 
>
ëë 
shared
ëë 
=
ëë 
new
ëë "
List
ëë# '
<
ëë' (
int
ëë( +
>
ëë+ ,
(
ëë, -
)
ëë- .
;
ëë. /#
GetCoincidentVertices
ìì !
(
ìì! "
vertices
ìì" *
,
ìì* +
shared
ìì, 2
)
ìì2 3
;
ìì3 4
return
íí 
shared
íí 
;
íí 
}
îî 	
public
öö 
void
öö #
GetCoincidentVertices
öö )
(
öö) *
IEnumerable
öö* 5
<
öö5 6
Face
öö6 :
>
öö: ;
faces
öö< A
,
ööA B
List
ööC G
<
ööG H
int
ööH K
>
ööK L

coincident
ööM W
)
ööW X
{
÷÷ 	
if
øø 
(
øø 
faces
øø 
==
øø 
null
øø 
)
øø 
throw
ùù 
new
ùù #
ArgumentNullException
ùù /
(
ùù/ 0
$str
ùù0 7
)
ùù7 8
;
ùù8 9
if
ûû 
(
ûû 

coincident
ûû 
==
ûû 
null
ûû "
)
ûû" #
throw
üü 
new
üü #
ArgumentNullException
üü /
(
üü/ 0
$str
üü0 <
)
üü< =
;
üü= >

coincident
şş 
.
şş 
Clear
şş 
(
şş 
)
şş 
;
şş 
s_CachedHashSet
ÿÿ 
.
ÿÿ 
Clear
ÿÿ !
(
ÿÿ! "
)
ÿÿ" #
;
ÿÿ# $
var
€€ 
lookup
€€ 
=
€€  
sharedVertexLookup
€€ +
;
€€+ ,
foreach
‚‚ 
(
‚‚ 
var
‚‚ 
face
‚‚ 
in
‚‚  
faces
‚‚! &
)
‚‚& '
{
ƒƒ 
foreach
„„ 
(
„„ 
var
„„ 
v
„„ 
in
„„ !
face
„„" &
.
„„& '%
distinctIndexesInternal
„„' >
)
„„> ?
{
…… 
var
†† 
common
†† 
=
††  
lookup
††! '
[
††' (
v
††( )
]
††) *
;
††* +
if
ˆˆ 
(
ˆˆ 
s_CachedHashSet
ˆˆ '
.
ˆˆ' (
Add
ˆˆ( +
(
ˆˆ+ ,
common
ˆˆ, 2
)
ˆˆ2 3
)
ˆˆ3 4
{
‰‰ 
var
ŠŠ 
indices
ŠŠ #
=
ŠŠ$ %
m_SharedVertices
ŠŠ& 6
[
ŠŠ6 7
common
ŠŠ7 =
]
ŠŠ= >
;
ŠŠ> ?
for
ŒŒ 
(
ŒŒ 
int
ŒŒ  
i
ŒŒ! "
=
ŒŒ# $
$num
ŒŒ% &
,
ŒŒ& '
c
ŒŒ( )
=
ŒŒ* +
indices
ŒŒ, 3
.
ŒŒ3 4
Count
ŒŒ4 9
;
ŒŒ9 :
i
ŒŒ; <
<
ŒŒ= >
c
ŒŒ? @
;
ŒŒ@ A
i
ŒŒB C
++
ŒŒC E
)
ŒŒE F

coincident
 &
.
& '
Add
' *
(
* +
indices
+ 2
[
2 3
i
3 4
]
4 5
)
5 6
;
6 7
}
 
}
 
}
 
}
‘‘ 	
public
™™ 
void
™™ #
GetCoincidentVertices
™™ )
(
™™) *
IEnumerable
™™* 5
<
™™5 6
Edge
™™6 :
>
™™: ;
edges
™™< A
,
™™A B
List
™™C G
<
™™G H
int
™™H K
>
™™K L

coincident
™™M W
)
™™W X
{
šš 	
if
›› 
(
›› 
faces
›› 
==
›› 
null
›› 
)
›› 
throw
œœ 
new
œœ #
ArgumentNullException
œœ /
(
œœ/ 0
$str
œœ0 7
)
œœ7 8
;
œœ8 9
if
 
(
 

coincident
 
==
 
null
 "
)
" #
throw
ŸŸ 
new
ŸŸ #
ArgumentNullException
ŸŸ /
(
ŸŸ/ 0
$str
ŸŸ0 <
)
ŸŸ< =
;
ŸŸ= >

coincident
¡¡ 
.
¡¡ 
Clear
¡¡ 
(
¡¡ 
)
¡¡ 
;
¡¡ 
s_CachedHashSet
¢¢ 
.
¢¢ 
Clear
¢¢ !
(
¢¢! "
)
¢¢" #
;
¢¢# $
var
££ 
lookup
££ 
=
££  
sharedVertexLookup
££ +
;
££+ ,
foreach
¥¥ 
(
¥¥ 
var
¥¥ 
edge
¥¥ 
in
¥¥  
edges
¥¥! &
)
¥¥& '
{
¦¦ 
var
§§ 
common
§§ 
=
§§ 
lookup
§§ #
[
§§# $
edge
§§$ (
.
§§( )
a
§§) *
]
§§* +
;
§§+ ,
if
©© 
(
©© 
s_CachedHashSet
©© #
.
©©# $
Add
©©$ '
(
©©' (
common
©©( .
)
©©. /
)
©©/ 0
{
ªª 
var
«« 
indices
«« 
=
««  !
m_SharedVertices
««" 2
[
««2 3
common
««3 9
]
««9 :
;
««: ;
for
­­ 
(
­­ 
int
­­ 
i
­­ 
=
­­  
$num
­­! "
,
­­" #
c
­­$ %
=
­­& '
indices
­­( /
.
­­/ 0
Count
­­0 5
;
­­5 6
i
­­7 8
<
­­9 :
c
­­; <
;
­­< =
i
­­> ?
++
­­? A
)
­­A B

coincident
®® "
.
®®" #
Add
®®# &
(
®®& '
indices
®®' .
[
®®. /
i
®®/ 0
]
®®0 1
)
®®1 2
;
®®2 3
}
¯¯ 
common
±± 
=
±± 
lookup
±± 
[
±±  
edge
±±  $
.
±±$ %
b
±±% &
]
±±& '
;
±±' (
if
³³ 
(
³³ 
s_CachedHashSet
³³ #
.
³³# $
Add
³³$ '
(
³³' (
common
³³( .
)
³³. /
)
³³/ 0
{
´´ 
var
µµ 
indices
µµ 
=
µµ  !
m_SharedVertices
µµ" 2
[
µµ2 3
common
µµ3 9
]
µµ9 :
;
µµ: ;
for
·· 
(
·· 
int
·· 
i
·· 
=
··  
$num
··! "
,
··" #
c
··$ %
=
··& '
indices
··( /
.
··/ 0
Count
··0 5
;
··5 6
i
··7 8
<
··9 :
c
··; <
;
··< =
i
··> ?
++
··? A
)
··A B

coincident
¸¸ "
.
¸¸" #
Add
¸¸# &
(
¸¸& '
indices
¸¸' .
[
¸¸. /
i
¸¸/ 0
]
¸¸0 1
)
¸¸1 2
;
¸¸2 3
}
¹¹ 
}
ºº 
}
»» 	
public
ÃÃ 
void
ÃÃ #
GetCoincidentVertices
ÃÃ )
(
ÃÃ) *
IEnumerable
ÃÃ* 5
<
ÃÃ5 6
int
ÃÃ6 9
>
ÃÃ9 :
vertices
ÃÃ; C
,
ÃÃC D
List
ÃÃE I
<
ÃÃI J
int
ÃÃJ M
>
ÃÃM N

coincident
ÃÃO Y
)
ÃÃY Z
{
ÄÄ 	
if
ÅÅ 
(
ÅÅ 
vertices
ÅÅ 
==
ÅÅ 
null
ÅÅ  
)
ÅÅ  !
throw
ÆÆ 
new
ÆÆ #
ArgumentNullException
ÆÆ /
(
ÆÆ/ 0
$str
ÆÆ0 :
)
ÆÆ: ;
;
ÆÆ; <
if
ÈÈ 
(
ÈÈ 

coincident
ÈÈ 
==
ÈÈ 
null
ÈÈ "
)
ÈÈ" #
throw
ÉÉ 
new
ÉÉ #
ArgumentNullException
ÉÉ /
(
ÉÉ/ 0
$str
ÉÉ0 <
)
ÉÉ< =
;
ÉÉ= >

coincident
ËË 
.
ËË 
Clear
ËË 
(
ËË 
)
ËË 
;
ËË 
s_CachedHashSet
ÌÌ 
.
ÌÌ 
Clear
ÌÌ !
(
ÌÌ! "
)
ÌÌ" #
;
ÌÌ# $
var
ÍÍ 
lookup
ÍÍ 
=
ÍÍ  
sharedVertexLookup
ÍÍ +
;
ÍÍ+ ,
foreach
ÏÏ 
(
ÏÏ 
var
ÏÏ 
v
ÏÏ 
in
ÏÏ 
vertices
ÏÏ &
)
ÏÏ& '
{
ĞĞ 
var
ÑÑ 
common
ÑÑ 
=
ÑÑ 
lookup
ÑÑ #
[
ÑÑ# $
v
ÑÑ$ %
]
ÑÑ% &
;
ÑÑ& '
if
ÓÓ 
(
ÓÓ 
s_CachedHashSet
ÓÓ #
.
ÓÓ# $
Add
ÓÓ$ '
(
ÓÓ' (
common
ÓÓ( .
)
ÓÓ. /
)
ÓÓ/ 0
{
ÔÔ 
var
ÕÕ 
indices
ÕÕ 
=
ÕÕ  !
m_SharedVertices
ÕÕ" 2
[
ÕÕ2 3
common
ÕÕ3 9
]
ÕÕ9 :
;
ÕÕ: ;
for
×× 
(
×× 
int
×× 
i
×× 
=
××  
$num
××! "
,
××" #
c
××$ %
=
××& '
indices
××( /
.
××/ 0
Count
××0 5
;
××5 6
i
××7 8
<
××9 :
c
××; <
;
××< =
i
××> ?
++
××? A
)
××A B

coincident
ØØ "
.
ØØ" #
Add
ØØ# &
(
ØØ& '
indices
ØØ' .
[
ØØ. /
i
ØØ/ 0
]
ØØ0 1
)
ØØ1 2
;
ØØ2 3
}
ÙÙ 
}
ÚÚ 
}
ÛÛ 	
public
ää 
void
ää #
GetCoincidentVertices
ää )
(
ää) *
int
ää* -
vertex
ää. 4
,
ää4 5
List
ää6 :
<
ää: ;
int
ää; >
>
ää> ?

coincident
ää@ J
)
ääJ K
{
åå 	
if
ææ 
(
ææ 

coincident
ææ 
==
ææ 
null
ææ "
)
ææ" #
throw
çç 
new
çç #
ArgumentNullException
çç /
(
çç/ 0
$str
çç0 <
)
çç< =
;
çç= >
int
éé 
common
éé 
;
éé 
if
ëë 
(
ëë 
!
ëë  
sharedVertexLookup
ëë #
.
ëë# $
TryGetValue
ëë$ /
(
ëë/ 0
vertex
ëë0 6
,
ëë6 7
out
ëë8 ;
common
ëë< B
)
ëëB C
)
ëëC D
throw
ìì 
new
ìì )
ArgumentOutOfRangeException
ìì 5
(
ìì5 6
$str
ìì6 >
)
ìì> ?
;
ìì? @
var
îî 
indices
îî 
=
îî 
m_SharedVertices
îî *
[
îî* +
common
îî+ 1
]
îî1 2
;
îî2 3
for
ğğ 
(
ğğ 
int
ğğ 
i
ğğ 
=
ğğ 
$num
ğğ 
,
ğğ 
c
ğğ 
=
ğğ 
indices
ğğ  '
.
ğğ' (
Count
ğğ( -
;
ğğ- .
i
ğğ/ 0
<
ğğ1 2
c
ğğ3 4
;
ğğ4 5
i
ğğ6 7
++
ğğ7 9
)
ğğ9 :

coincident
ññ 
.
ññ 
Add
ññ 
(
ññ 
indices
ññ &
[
ññ& '
i
ññ' (
]
ññ( )
)
ññ) *
;
ññ* +
}
òò 	
public
ûû 
void
ûû #
SetVerticesCoincident
ûû )
(
ûû) *
IEnumerable
ûû* 5
<
ûû5 6
int
ûû6 9
>
ûû9 :
vertices
ûû; C
)
ûûC D
{
üü 	
var
ıı 
lookup
ıı 
=
ıı  
sharedVertexLookup
ıı +
;
ıı+ ,
List
şş 
<
şş 
int
şş 
>
şş 

coincident
şş  
=
şş! "
new
şş# &
List
şş' +
<
şş+ ,
int
şş, /
>
şş/ 0
(
şş0 1
)
şş1 2
;
şş2 3#
GetCoincidentVertices
ÿÿ !
(
ÿÿ! "
vertices
ÿÿ" *
,
ÿÿ* +

coincident
ÿÿ, 6
)
ÿÿ6 7
;
ÿÿ7 8
SharedVertex
€€ 
.
€€ 
SetCoincident
€€ &
(
€€& '
ref
€€' *
lookup
€€+ 1
,
€€1 2

coincident
€€3 =
)
€€= >
;
€€> ?
SetSharedVertices
 
(
 
lookup
 $
)
$ %
;
% &
}
‚‚ 	
internal
„„ 
void
„„ #
SetTexturesCoincident
„„ +
(
„„+ ,
IEnumerable
„„, 7
<
„„7 8
int
„„8 ;
>
„„; <
vertices
„„= E
)
„„E F
{
…… 	
var
†† 
lookup
†† 
=
†† !
sharedTextureLookup
†† ,
;
††, -
SharedVertex
‡‡ 
.
‡‡ 
SetCoincident
‡‡ &
(
‡‡& '
ref
‡‡' *
lookup
‡‡+ 1
,
‡‡1 2
vertices
‡‡3 ;
)
‡‡; <
;
‡‡< =
SetSharedTextures
ˆˆ 
(
ˆˆ 
lookup
ˆˆ $
)
ˆˆ$ %
;
ˆˆ% &
}
‰‰ 	
internal
‹‹ 
void
‹‹ 
AddToSharedVertex
‹‹ '
(
‹‹' (
int
‹‹( + 
sharedVertexHandle
‹‹, >
,
‹‹> ?
int
‹‹@ C
vertex
‹‹D J
)
‹‹J K
{
ŒŒ 	
if
 
(
  
sharedVertexHandle
 "
<
# $
$num
% &
||
' ) 
sharedVertexHandle
* <
>=
= ?
m_SharedVertices
@ P
.
P Q
Length
Q W
)
W X
throw
 
new
 )
ArgumentOutOfRangeException
 5
(
5 6
$str
6 J
)
J K
;
K L
m_SharedVertices
 
[
  
sharedVertexHandle
 /
]
/ 0
.
0 1
Add
1 4
(
4 5
vertex
5 ;
)
; <
;
< =*
InvalidateSharedVertexLookup
‘‘ (
(
‘‘( )
)
‘‘) *
;
‘‘* +
}
’’ 	
internal
”” 
void
”” 
AddSharedVertex
”” %
(
””% &
SharedVertex
””& 2
vertex
””3 9
)
””9 :
{
•• 	
if
–– 
(
–– 
vertex
–– 
==
–– 
null
–– 
)
–– 
throw
—— 
new
—— #
ArgumentNullException
—— /
(
——/ 0
$str
——0 8
)
——8 9
;
——9 :
m_SharedVertices
™™ 
=
™™ 
m_SharedVertices
™™ /
.
™™/ 0
Add
™™0 3
(
™™3 4
vertex
™™4 :
)
™™: ;
;
™™; <*
InvalidateSharedVertexLookup
šš (
(
šš( )
)
šš) *
;
šš* +
}
›› 	
}
œœ 
} áY
“D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ProBuilderSnapping.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static		 

class		 
ProBuilderSnapping		 #
{

 
const 
float  
k_MaxRaySnapDistance (
=) *
Mathf+ 0
.0 1
Infinity1 9
;9 :
public 
static 
Vector3 
	SnapValue '
(' (
Vector3( /
vertex0 6
,6 7
float8 =
snpVal> D
)D E
{ 	
return 
new 
Vector3 
( 
snpVal 
* 
Mathf 
. 
Round $
($ %
vertex% +
.+ ,
x, -
/. /
snpVal0 6
)6 7
,7 8
snpVal 
* 
Mathf 
. 
Round $
($ %
vertex% +
.+ ,
y, -
/. /
snpVal0 6
)6 7
,7 8
snpVal 
* 
Mathf 
. 
Round $
($ %
vertex% +
.+ ,
z, -
/. /
snpVal0 6
)6 7
)7 8
;8 9
} 	
public"" 
static"" 
float"" 
	SnapValue"" %
(""% &
float""& +
val"", /
,""/ 0
float""1 6
snpVal""7 =
)""= >
{## 	
if$$ 
($$ 
snpVal$$ 
<$$ 
Mathf$$ 
.$$ 
Epsilon$$ &
)$$& '
return%% 
val%% 
;%% 
return&& 
snpVal&& 
*&& 
Mathf&& !
.&&! "
Round&&" '
(&&' (
val&&( +
/&&, -
snpVal&&. 4
)&&4 5
;&&5 6
}'' 	
public00 
static00 
Vector300 
	SnapValue00 '
(00' (
Vector300( /
vertex000 6
,006 7
Vector3008 ?
snap00@ D
)00D E
{11 	
float22 
x22 
=22 
vertex22 
.22 
x22 
,22 
y22  !
=22" #
vertex22$ *
.22* +
y22+ ,
,22, -
z22. /
=220 1
vertex222 8
.228 9
z229 :
;22: ;
Vector333 
v33 
=33 
new33 
Vector333 #
(33# $
(44 
Mathf44 
.44 
Abs44 
(44 
snap44 #
.44# $
x44$ %
)44% &
<44' (
$num44) 0
?441 2
x443 4
:445 6
snap447 ;
.44; <
x44< =
*44> ?
Mathf44@ E
.44E F
Round44F K
(44K L
x44L M
/44N O
snap44P T
.44T U
x44U V
)44V W
)44W X
,44X Y
(55 
Mathf55 
.55 
Abs55 
(55 
snap55 #
.55# $
y55$ %
)55% &
<55' (
$num55) 0
?551 2
y553 4
:555 6
snap557 ;
.55; <
y55< =
*55> ?
Mathf55@ E
.55E F
Round55F K
(55K L
y55L M
/55N O
snap55P T
.55T U
y55U V
)55V W
)55W X
,55X Y
(66 
Mathf66 
.66 
Abs66 
(66 
snap66 #
.66# $
z66$ %
)66% &
<66' (
$num66) 0
?661 2
z663 4
:665 6
snap667 ;
.66; <
z66< =
*66> ?
Mathf66@ E
.66E F
Round66F K
(66K L
z66L M
/66N O
snap66P T
.66T U
z66U V
)66V W
)66W X
)77 
;77 
return88 
v88 
;88 
}99 	
publicAA 
staticAA 
voidAA 
SnapVerticesAA '
(AA' (
ProBuilderMeshAA( 6
meshAA7 ;
,AA; <
IEnumerableAA= H
<AAH I
intAAI L
>AAL M
indexesAAN U
,AAU V
Vector3AAW ^
snapAA_ c
)AAc d
{BB 	
Vector3CC 
[CC 
]CC 
vertsCC 
=CC 
meshCC "
.CC" #
positionsInternalCC# 4
;CC4 5
foreachEE 
(EE 
varEE 
vEE 
inEE 
indexesEE %
)EE% &
vertsFF 
[FF 
vFF 
]FF 
=FF 
meshFF 
.FF  
	transformFF  )
.FF) *!
InverseTransformPointFF* ?
(FF? @
	SnapValueFF@ I
(FFI J
meshFFJ N
.FFN O
	transformFFO X
.FFX Y
TransformPointFFY g
(FFg h
vertsFFh m
[FFm n
vFFn o
]FFo p
)FFp q
,FFq r
snapFFs w
)FFw x
)FFx y
;FFy z
}GG 	
internalII 
staticII 
Vector3II .
"GetSnappingMaskBasedOnNormalVectorII  B
(IIB C
Vector3IIC J
normalIIK Q
)IIQ R
{JJ 	
returnKK 
newKK 
Vector3KK 
(KK 
(LL 
MathfLL 
.LL 
ApproximatelyLL $
(LL$ %
MathfLL% *
.LL* +
AbsLL+ .
(LL. /
normalLL/ 5
.LL5 6
xLL6 7
)LL7 8
,LL8 9
$numLL: <
)LL< =
)LL= >
?LL? @
$numLLA C
:LLD E
$numLLF H
,LLH I
(MM 
MathfMM 
.MM 
ApproximatelyMM $
(MM$ %
MathfMM% *
.MM* +
AbsMM+ .
(MM. /
normalMM/ 5
.MM5 6
yMM6 7
)MM7 8
,MM8 9
$numMM: <
)MM< =
)MM= >
?MM? @
$numMMA C
:MMD E
$numMMF H
,MMH I
(NN 
MathfNN 
.NN 
ApproximatelyNN $
(NN$ %
MathfNN% *
.NN* +
AbsNN+ .
(NN. /
normalNN/ 5
.NN5 6
zNN6 7
)NN7 8
,NN8 9
$numNN: <
)NN< =
)NN= >
?NN? @
$numNNA C
:NND E
$numNNF H
)NNH I
;NNI J
}OO 	
internalQQ 
staticQQ 
Vector3QQ 
SnapValueOnRayQQ  .
(QQ. /
RayQQ/ 2
rayQQ3 6
,QQ6 7
floatQQ8 =
distanceQQ> F
,QQF G
floatQQH M
snapQQN R
,QQR S
Vector3MaskQQT _
maskQQ` d
)QQd e
{RR 	
varSS 
nearestSS 
=SS  
k_MaxRaySnapDistanceSS .
;SS. /
varUU 

forwardRayUU 
=UU 
newUU  
RayUU! $
(UU$ %
rayUU% (
.UU( )
originUU) /
,UU/ 0
rayUU1 4
.UU4 5
	directionUU5 >
)UU> ?
;UU? @
varVV 
backwardsRayVV 
=VV 
newVV "
RayVV# &
(VV& '
rayVV' *
.VV* +
originVV+ 1
,VV1 2
-VV3 4
rayVV4 7
.VV7 8
	directionVV8 A
)VVA B
;VVB C
forXX 
(XX 
intXX 
iXX 
=XX 
$numXX 
;XX 
iXX 
<XX 
$numXX  !
;XX! "
iXX# $
++XX$ &
)XX& '
{YY 
ifZZ 
(ZZ 
maskZZ 
[ZZ 
iZZ 
]ZZ 
>ZZ 
$numZZ  
)ZZ  !
{[[ 
var\\ 
dir\\ 
=\\ 
new\\ !
Vector3Mask\\" -
(\\- .
new\\. 1
Vector3Mask\\2 =
(\\= >
(\\> ?
byte\\? C
)\\C D
(\\E F
$num\\F G
<<\\H J
i\\K L
)\\L M
)\\M N
)\\N O
;\\O P
var^^ 
prj^^ 
=^^ 
Vector3^^ %
.^^% &
Project^^& -
(^^- .
ray__ 
.__ 
	direction__ %
*__& '
Math__( ,
.__, -
MakeNonZero__- 8
(__8 9
distance__9 A
)__A B
,__B C
dir`` 
*`` 
Mathf`` #
.``# $
Sign``$ (
(``( )
ray``) ,
.``, -
	direction``- 6
[``6 7
i``7 8
]``8 9
)``9 :
)``: ;
;``; <
varbb 
pntbb 
=bb 
raybb !
.bb! "
originbb" (
+bb) *
prjbb+ .
;bb. /
varcc 
planecc 
=cc 
newcc  #
Planecc$ )
(cc) *
dircc* -
,cc- .
	SnapValuecc/ 8
(cc8 9
pntcc9 <
,cc< =
dircc> A
*ccB C
snapccD H
)ccH I
)ccI J
;ccJ K
ifee 
(ee 
Mathfee 
.ee 
Absee  
(ee  !
planeee! &
.ee& '
GetDistanceToPointee' 9
(ee9 :
rayee: =
.ee= >
originee> D
)eeD E
)eeE F
<eeG H
$numeeI O
)eeO P
{ff 
nearestgg 
=gg  !
$numgg" $
;gg$ %
continuehh  
;hh  !
}ii 
floatkk 
dkk 
;kk 
ifmm 
(mm 
planemm 
.mm 
Raycastmm %
(mm% &

forwardRaymm& 0
,mm0 1
outmm2 5
dmm6 7
)mm7 8
&&mm9 ;
Mathfmm< A
.mmA B
AbsmmB E
(mmE F
dmmF G
)mmG H
<mmI J
MathfmmK P
.mmP Q
AbsmmQ T
(mmT U
nearestmmU \
)mm\ ]
)mm] ^
nearestnn 
=nn  !
dnn" #
;nn# $
ifoo 
(oo 
planeoo 
.oo 
Raycastoo %
(oo% &
backwardsRayoo& 2
,oo2 3
outoo4 7
doo8 9
)oo9 :
&&oo; =
Mathfoo> C
.ooC D
AbsooD G
(ooG H
dooH I
)ooI J
<ooK L
MathfooM R
.ooR S
AbsooS V
(ooV W
nearestooW ^
)oo^ _
)oo_ `
nearestpp 
=pp  !
-pp" #
dpp# $
;pp$ %
}qq 
}rr 
returntt 
raytt 
.tt 
origintt 
+tt 
raytt  #
.tt# $
	directiontt$ -
*tt. /
(tt0 1
Mathftt1 6
.tt6 7
Abstt7 :
(tt: ;
nearesttt; B
)ttB C
>=ttD F 
k_MaxRaySnapDistancettG [
?tt\ ]
distancett^ f
:ttg h
nearesttti p
)ttp q
;ttq r
}uu 	
}vv 
}ww Û—
ŒD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\MeshUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{		 
public 

static 
class 
MeshUtility #
{ 
internal 
static 
Vertex 
[ 
]  #
GeneratePerTriangleMesh! 8
(8 9
Mesh9 =
mesh> B
)B C
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new !
ArgumentNullException /
(/ 0
$str0 6
)6 7
;7 8
Vertex 
[ 
] 
vertices 
= 
mesh  $
.$ %
GetVertices% 0
(0 1
)1 2
;2 3
int 
smc 
= 
mesh 
. 
subMeshCount '
;' (
Vertex 
[ 
] 
tv 
= 
new 
Vertex $
[$ %
mesh% )
.) *
	triangles* 3
.3 4
Length4 :
]: ;
;; <
int 
[ 
] 
[ 
] 
	triangles 
= 
new  #
int$ '
[' (
smc( +
]+ ,
[, -
]- .
;. /
int 
triIndex 
= 
$num 
; 
for 
( 
int 
s 
= 
$num 
; 
s 
< 
smc  #
;# $
s% &
++& (
)( )
{   
	triangles!! 
[!! 
s!! 
]!! 
=!! 
mesh!! #
.!!# $
GetTriangles!!$ 0
(!!0 1
s!!1 2
)!!2 3
;!!3 4
int"" 
tl"" 
="" 
	triangles"" "
[""" #
s""# $
]""$ %
.""% &
Length""& ,
;"", -
for$$ 
($$ 
int$$ 
i$$ 
=$$ 
$num$$ 
;$$ 
i$$  !
<$$" #
tl$$$ &
;$$& '
i$$( )
++$$) +
)$$+ ,
{%% 
tv&& 
[&& 
triIndex&& 
++&& !
]&&! "
=&&# $
new&&% (
Vertex&&) /
(&&/ 0
vertices&&0 8
[&&8 9
	triangles&&9 B
[&&B C
s&&C D
]&&D E
[&&E F
i&&F G
]&&G H
]&&H I
)&&I J
;&&J K
	triangles'' 
['' 
s'' 
]''  
[''  !
i''! "
]''" #
=''$ %
triIndex''& .
-''/ 0
$num''1 2
;''2 3
}(( 
})) 
Vertex++ 
.++ 
SetMesh++ 
(++ 
mesh++ 
,++  
tv++! #
)++# $
;++$ %
mesh-- 
.-- 
subMeshCount-- 
=-- 
smc--  #
;--# $
for// 
(// 
int// 
s// 
=// 
$num// 
;// 
s// 
<// 
smc//  #
;//# $
s//% &
++//& (
)//( )
mesh00 
.00 
SetTriangles00 !
(00! "
	triangles00" +
[00+ ,
s00, -
]00- .
,00. /
s000 1
)001 2
;002 3
return22 
tv22 
;22 
}33 	
public99 
static99 
void99 
GenerateTangent99 *
(99* +
Mesh99+ /
mesh990 4
)994 5
{:: 	
if;; 
(;; 
mesh;; 
==;; 
null;; 
);; 
throw<< 
new<< 
System<<  
.<<  !!
ArgumentNullException<<! 6
(<<6 7
$str<<7 =
)<<= >
;<<> ?
intAA 
[AA 
]AA 
	trianglesAA 
=AA 
meshAA "
.AA" #
	trianglesAA# ,
;AA, -
Vector3BB 
[BB 
]BB 
verticesBB 
=BB  
meshBB! %
.BB% &
verticesBB& .
;BB. /
Vector2CC 
[CC 
]CC 
uvCC 
=CC 
meshCC 
.CC  
uvCC  "
;CC" #
Vector3DD 
[DD 
]DD 
normalsDD 
=DD 
meshDD  $
.DD$ %
normalsDD% ,
;DD, -
intGG 
triangleCountGG 
=GG 
	trianglesGG  )
.GG) *
LengthGG* 0
;GG0 1
intHH 
vertexCountHH 
=HH 
verticesHH &
.HH& '
LengthHH' -
;HH- .
Vector3JJ 
[JJ 
]JJ 
tan1JJ 
=JJ 
newJJ  
Vector3JJ! (
[JJ( )
vertexCountJJ) 4
]JJ4 5
;JJ5 6
Vector3KK 
[KK 
]KK 
tan2KK 
=KK 
newKK  
Vector3KK! (
[KK( )
vertexCountKK) 4
]KK4 5
;KK5 6
Vector4MM 
[MM 
]MM 
tangentsMM 
=MM  
newMM! $
Vector4MM% ,
[MM, -
vertexCountMM- 8
]MM8 9
;MM9 :
forOO 
(OO 
longOO 
aOO 
=OO 
$numOO 
;OO 
aOO 
<OO  
triangleCountOO! .
;OO. /
aOO0 1
+=OO2 4
$numOO5 6
)OO6 7
{PP 
longQQ 
i1QQ 
=QQ 
	trianglesQQ #
[QQ# $
aQQ$ %
+QQ& '
$numQQ( )
]QQ) *
;QQ* +
longRR 
i2RR 
=RR 
	trianglesRR #
[RR# $
aRR$ %
+RR& '
$numRR( )
]RR) *
;RR* +
longSS 
i3SS 
=SS 
	trianglesSS #
[SS# $
aSS$ %
+SS& '
$numSS( )
]SS) *
;SS* +
Vector3UU 
v1UU 
=UU 
verticesUU %
[UU% &
i1UU& (
]UU( )
;UU) *
Vector3VV 
v2VV 
=VV 
verticesVV %
[VV% &
i2VV& (
]VV( )
;VV) *
Vector3WW 
v3WW 
=WW 
verticesWW %
[WW% &
i3WW& (
]WW( )
;WW) *
Vector2YY 
w1YY 
=YY 
uvYY 
[YY  
i1YY  "
]YY" #
;YY# $
Vector2ZZ 
w2ZZ 
=ZZ 
uvZZ 
[ZZ  
i2ZZ  "
]ZZ" #
;ZZ# $
Vector2[[ 
w3[[ 
=[[ 
uv[[ 
[[[  
i3[[  "
][[" #
;[[# $
float]] 
x1]] 
=]] 
v2]] 
.]] 
x]] 
-]]  !
v1]]" $
.]]$ %
x]]% &
;]]& '
float^^ 
x2^^ 
=^^ 
v3^^ 
.^^ 
x^^ 
-^^  !
v1^^" $
.^^$ %
x^^% &
;^^& '
float__ 
y1__ 
=__ 
v2__ 
.__ 
y__ 
-__  !
v1__" $
.__$ %
y__% &
;__& '
float`` 
y2`` 
=`` 
v3`` 
.`` 
y`` 
-``  !
v1``" $
.``$ %
y``% &
;``& '
floataa 
z1aa 
=aa 
v2aa 
.aa 
zaa 
-aa  !
v1aa" $
.aa$ %
zaa% &
;aa& '
floatbb 
z2bb 
=bb 
v3bb 
.bb 
zbb 
-bb  !
v1bb" $
.bb$ %
zbb% &
;bb& '
floatdd 
s1dd 
=dd 
w2dd 
.dd 
xdd 
-dd  !
w1dd" $
.dd$ %
xdd% &
;dd& '
floatee 
s2ee 
=ee 
w3ee 
.ee 
xee 
-ee  !
w1ee" $
.ee$ %
xee% &
;ee& '
floatff 
t1ff 
=ff 
w2ff 
.ff 
yff 
-ff  !
w1ff" $
.ff$ %
yff% &
;ff& '
floatgg 
t2gg 
=gg 
w3gg 
.gg 
ygg 
-gg  !
w1gg" $
.gg$ %
ygg% &
;gg& '
floatii 
rii 
=ii 
$numii 
/ii  
(ii! "
s1ii" $
*ii% &
t2ii' )
-ii* +
s2ii, .
*ii/ 0
t1ii1 3
)ii3 4
;ii4 5
Vector3kk 
sdirkk 
=kk 
newkk "
Vector3kk# *
(kk* +
(kk+ ,
t2kk, .
*kk/ 0
x1kk1 3
-kk4 5
t1kk6 8
*kk9 :
x2kk; =
)kk= >
*kk? @
rkkA B
,kkB C
(kkD E
t2kkE G
*kkH I
y1kkJ L
-kkM N
t1kkO Q
*kkR S
y2kkT V
)kkV W
*kkX Y
rkkZ [
,kk[ \
(kk] ^
t2kk^ `
*kka b
z1kkc e
-kkf g
t1kkh j
*kkk l
z2kkm o
)kko p
*kkq r
rkks t
)kkt u
;kku v
Vector3ll 
tdirll 
=ll 
newll "
Vector3ll# *
(ll* +
(ll+ ,
s1ll, .
*ll/ 0
x2ll1 3
-ll4 5
s2ll6 8
*ll9 :
x1ll; =
)ll= >
*ll? @
rllA B
,llB C
(llD E
s1llE G
*llH I
y2llJ L
-llM N
s2llO Q
*llR S
y1llT V
)llV W
*llX Y
rllZ [
,ll[ \
(ll] ^
s1ll^ `
*lla b
z2llc e
-llf g
s2llh j
*llk l
z1llm o
)llo p
*llq r
rlls t
)llt u
;llu v
tan1nn 
[nn 
i1nn 
]nn 
+=nn 
sdirnn  
;nn  !
tan1oo 
[oo 
i2oo 
]oo 
+=oo 
sdiroo  
;oo  !
tan1pp 
[pp 
i3pp 
]pp 
+=pp 
sdirpp  
;pp  !
tan2rr 
[rr 
i1rr 
]rr 
+=rr 
tdirrr  
;rr  !
tan2ss 
[ss 
i2ss 
]ss 
+=ss 
tdirss  
;ss  !
tan2tt 
[tt 
i3tt 
]tt 
+=tt 
tdirtt  
;tt  !
}uu 
forxx 
(xx 
longxx 
axx 
=xx 
$numxx 
;xx 
axx 
<xx  
vertexCountxx! ,
;xx, -
++xx. 0
axx0 1
)xx1 2
{yy 
Vector3zz 
nzz 
=zz 
normalszz #
[zz# $
azz$ %
]zz% &
;zz& '
Vector3{{ 
t{{ 
={{ 
tan1{{  
[{{  !
a{{! "
]{{" #
;{{# $
Vector3}} 
.}} 
OrthoNormalize}} &
(}}& '
ref}}' *
n}}+ ,
,}}, -
ref}}. 1
t}}2 3
)}}3 4
;}}4 5
tangents~~ 
[~~ 
a~~ 
]~~ 
.~~ 
x~~ 
=~~ 
t~~  !
.~~! "
x~~" #
;~~# $
tangents 
[ 
a 
] 
. 
y 
= 
t  !
.! "
y" #
;# $
tangents
€€ 
[
€€ 
a
€€ 
]
€€ 
.
€€ 
z
€€ 
=
€€ 
t
€€  !
.
€€! "
z
€€" #
;
€€# $
tangents
‚‚ 
[
‚‚ 
a
‚‚ 
]
‚‚ 
.
‚‚ 
w
‚‚ 
=
‚‚ 
(
‚‚  !
Vector3
‚‚! (
.
‚‚( )
Dot
‚‚) ,
(
‚‚, -
Vector3
‚‚- 4
.
‚‚4 5
Cross
‚‚5 :
(
‚‚: ;
n
‚‚; <
,
‚‚< =
t
‚‚> ?
)
‚‚? @
,
‚‚@ A
tan2
‚‚B F
[
‚‚F G
a
‚‚G H
]
‚‚H I
)
‚‚I J
<
‚‚K L
$num
‚‚M Q
)
‚‚Q R
?
‚‚S T
-
‚‚U V
$num
‚‚V Z
:
‚‚[ \
$num
‚‚] a
;
‚‚a b
}
ƒƒ 
mesh
…… 
.
…… 
tangents
…… 
=
…… 
tangents
…… $
;
……$ %
}
†† 	
public
 
static
 
Mesh
 
DeepCopy
 #
(
# $
Mesh
$ (
source
) /
)
/ 0
{
 	
Mesh
 
m
 
=
 
new
 
Mesh
 
(
 
)
 
;
  
CopyTo
 
(
 
source
 
,
 
m
 
)
 
;
 
return
‘‘ 
m
‘‘ 
;
‘‘ 
}
’’ 	
public
šš 
static
šš 
void
šš 
CopyTo
šš !
(
šš! "
Mesh
šš" &
source
šš' -
,
šš- .
Mesh
šš/ 3
destination
šš4 ?
)
šš? @
{
›› 	
if
œœ 
(
œœ 
source
œœ 
==
œœ 
null
œœ 
)
œœ 
throw
 
new
 
System
  
.
  !#
ArgumentNullException
! 6
(
6 7
$str
7 ?
)
? @
;
@ A
if
ŸŸ 
(
ŸŸ 
destination
ŸŸ 
==
ŸŸ 
null
ŸŸ #
)
ŸŸ# $
throw
   
new
   
System
    
.
    !#
ArgumentNullException
  ! 6
(
  6 7
$str
  7 D
)
  D E
;
  E F
Vector3
¢¢ 
[
¢¢ 
]
¢¢ 
v
¢¢ 
=
¢¢ 
new
¢¢ 
Vector3
¢¢ %
[
¢¢% &
source
¢¢& ,
.
¢¢, -
vertices
¢¢- 5
.
¢¢5 6
Length
¢¢6 <
]
¢¢< =
;
¢¢= >
int
££ 
[
££ 
]
££ 
[
££ 
]
££ 
t
££ 
=
££ 
new
££ 
int
££ 
[
££  
source
££  &
.
££& '
subMeshCount
££' 3
]
££3 4
[
££4 5
]
££5 6
;
££6 7
Vector2
¤¤ 
[
¤¤ 
]
¤¤ 
u
¤¤ 
=
¤¤ 
new
¤¤ 
Vector2
¤¤ %
[
¤¤% &
source
¤¤& ,
.
¤¤, -
uv
¤¤- /
.
¤¤/ 0
Length
¤¤0 6
]
¤¤6 7
;
¤¤7 8
Vector2
¥¥ 
[
¥¥ 
]
¥¥ 
u2
¥¥ 
=
¥¥ 
new
¥¥ 
Vector2
¥¥ &
[
¥¥& '
source
¥¥' -
.
¥¥- .
uv2
¥¥. 1
.
¥¥1 2
Length
¥¥2 8
]
¥¥8 9
;
¥¥9 :
Vector4
¦¦ 
[
¦¦ 
]
¦¦ 
tan
¦¦ 
=
¦¦ 
new
¦¦ 
Vector4
¦¦  '
[
¦¦' (
source
¦¦( .
.
¦¦. /
tangents
¦¦/ 7
.
¦¦7 8
Length
¦¦8 >
]
¦¦> ?
;
¦¦? @
Vector3
§§ 
[
§§ 
]
§§ 
n
§§ 
=
§§ 
new
§§ 
Vector3
§§ %
[
§§% &
source
§§& ,
.
§§, -
normals
§§- 4
.
§§4 5
Length
§§5 ;
]
§§; <
;
§§< =
Color32
¨¨ 
[
¨¨ 
]
¨¨ 
c
¨¨ 
=
¨¨ 
new
¨¨ 
Color32
¨¨ %
[
¨¨% &
source
¨¨& ,
.
¨¨, -
colors32
¨¨- 5
.
¨¨5 6
Length
¨¨6 <
]
¨¨< =
;
¨¨= >
System
ªª 
.
ªª 
Array
ªª 
.
ªª 
Copy
ªª 
(
ªª 
source
ªª $
.
ªª$ %
vertices
ªª% -
,
ªª- .
v
ªª/ 0
,
ªª0 1
v
ªª2 3
.
ªª3 4
Length
ªª4 :
)
ªª: ;
;
ªª; <
for
¬¬ 
(
¬¬ 
int
¬¬ 
i
¬¬ 
=
¬¬ 
$num
¬¬ 
;
¬¬ 
i
¬¬ 
<
¬¬ 
t
¬¬  !
.
¬¬! "
Length
¬¬" (
;
¬¬( )
i
¬¬* +
++
¬¬+ -
)
¬¬- .
t
­­ 
[
­­ 
i
­­ 
]
­­ 
=
­­ 
source
­­ 
.
­­ 
GetTriangles
­­ *
(
­­* +
i
­­+ ,
)
­­, -
;
­­- .
System
¯¯ 
.
¯¯ 
Array
¯¯ 
.
¯¯ 
Copy
¯¯ 
(
¯¯ 
source
¯¯ $
.
¯¯$ %
uv
¯¯% '
,
¯¯' (
u
¯¯) *
,
¯¯* +
u
¯¯, -
.
¯¯- .
Length
¯¯. 4
)
¯¯4 5
;
¯¯5 6
System
°° 
.
°° 
Array
°° 
.
°° 
Copy
°° 
(
°° 
source
°° $
.
°°$ %
uv2
°°% (
,
°°( )
u2
°°* ,
,
°°, -
u2
°°. 0
.
°°0 1
Length
°°1 7
)
°°7 8
;
°°8 9
System
±± 
.
±± 
Array
±± 
.
±± 
Copy
±± 
(
±± 
source
±± $
.
±±$ %
normals
±±% ,
,
±±, -
n
±±. /
,
±±/ 0
n
±±1 2
.
±±2 3
Length
±±3 9
)
±±9 :
;
±±: ;
System
²² 
.
²² 
Array
²² 
.
²² 
Copy
²² 
(
²² 
source
²² $
.
²²$ %
tangents
²²% -
,
²²- .
tan
²²/ 2
,
²²2 3
tan
²²4 7
.
²²7 8
Length
²²8 >
)
²²> ?
;
²²? @
System
³³ 
.
³³ 
Array
³³ 
.
³³ 
Copy
³³ 
(
³³ 
source
³³ $
.
³³$ %
colors32
³³% -
,
³³- .
c
³³/ 0
,
³³0 1
c
³³2 3
.
³³3 4
Length
³³4 :
)
³³: ;
;
³³; <
destination
µµ 
.
µµ 
Clear
µµ 
(
µµ 
)
µµ 
;
µµ  
destination
¶¶ 
.
¶¶ 
name
¶¶ 
=
¶¶ 
source
¶¶ %
.
¶¶% &
name
¶¶& *
;
¶¶* +
destination
¸¸ 
.
¸¸ 
vertices
¸¸  
=
¸¸! "
v
¸¸# $
;
¸¸$ %
destination
ºº 
.
ºº 
subMeshCount
ºº $
=
ºº% &
t
ºº' (
.
ºº( )
Length
ºº) /
;
ºº/ 0
for
¼¼ 
(
¼¼ 
int
¼¼ 
i
¼¼ 
=
¼¼ 
$num
¼¼ 
;
¼¼ 
i
¼¼ 
<
¼¼ 
t
¼¼  !
.
¼¼! "
Length
¼¼" (
;
¼¼( )
i
¼¼* +
++
¼¼+ -
)
¼¼- .
destination
½½ 
.
½½ 
SetTriangles
½½ (
(
½½( )
t
½½) *
[
½½* +
i
½½+ ,
]
½½, -
,
½½- .
i
½½/ 0
)
½½0 1
;
½½1 2
destination
¿¿ 
.
¿¿ 
uv
¿¿ 
=
¿¿ 
u
¿¿ 
;
¿¿ 
destination
ÀÀ 
.
ÀÀ 
uv2
ÀÀ 
=
ÀÀ 
u2
ÀÀ  
;
ÀÀ  !
destination
ÁÁ 
.
ÁÁ 
tangents
ÁÁ  
=
ÁÁ! "
tan
ÁÁ# &
;
ÁÁ& '
destination
ÂÂ 
.
ÂÂ 
normals
ÂÂ 
=
ÂÂ  !
n
ÂÂ" #
;
ÂÂ# $
destination
ÃÃ 
.
ÃÃ 
colors32
ÃÃ  
=
ÃÃ! "
c
ÃÃ# $
;
ÃÃ$ %
}
ÄÄ 	
internal
ÍÍ 
static
ÍÍ 
T
ÍÍ 
GetMeshChannel
ÍÍ (
<
ÍÍ( )
T
ÍÍ) *
>
ÍÍ* +
(
ÍÍ+ ,

GameObject
ÍÍ, 6

gameObject
ÍÍ7 A
,
ÍÍA B
Func
ÍÍC G
<
ÍÍG H
Mesh
ÍÍH L
,
ÍÍL M
T
ÍÍN O
>
ÍÍO P
attributeGetter
ÍÍQ `
)
ÍÍ` a
where
ÍÍb g
T
ÍÍh i
:
ÍÍj k
IList
ÍÍl q
{
ÎÎ 	
if
ÏÏ 
(
ÏÏ 

gameObject
ÏÏ 
==
ÏÏ 
null
ÏÏ "
)
ÏÏ" #
throw
ĞĞ 
new
ĞĞ 
System
ĞĞ  
.
ĞĞ  !#
ArgumentNullException
ĞĞ! 6
(
ĞĞ6 7
$str
ĞĞ7 C
)
ĞĞC D
;
ĞĞD E
if
ÒÒ 
(
ÒÒ 
attributeGetter
ÒÒ 
==
ÒÒ  "
null
ÒÒ# '
)
ÒÒ' (
throw
ÓÓ 
new
ÓÓ 
System
ÓÓ  
.
ÓÓ  !#
ArgumentNullException
ÓÓ! 6
(
ÓÓ6 7
$str
ÓÓ7 H
)
ÓÓH I
;
ÓÓI J

MeshFilter
ÕÕ 
mf
ÕÕ 
=
ÕÕ 

gameObject
ÕÕ &
.
ÕÕ& '
GetComponent
ÕÕ' 3
<
ÕÕ3 4

MeshFilter
ÕÕ4 >
>
ÕÕ> ?
(
ÕÕ? @
)
ÕÕ@ A
;
ÕÕA B
Mesh
ÖÖ 
mesh
ÖÖ 
=
ÖÖ 
mf
ÖÖ 
!=
ÖÖ 
null
ÖÖ "
?
ÖÖ# $
mf
ÖÖ% '
.
ÖÖ' (

sharedMesh
ÖÖ( 2
:
ÖÖ3 4
null
ÖÖ5 9
;
ÖÖ9 :
T
×× 
res
×× 
=
×× 
default
×× 
(
×× 
T
×× 
)
×× 
;
×× 
if
ÙÙ 
(
ÙÙ 
mesh
ÙÙ 
==
ÙÙ 
null
ÙÙ 
)
ÙÙ 
return
ÚÚ 
res
ÚÚ 
;
ÚÚ 
int
ÜÜ 
vertexCount
ÜÜ 
=
ÜÜ 
mesh
ÜÜ "
.
ÜÜ" #
vertexCount
ÜÜ# .
;
ÜÜ. /
MeshRenderer
ßß 
renderer
ßß !
=
ßß" #

gameObject
ßß$ .
.
ßß. /
GetComponent
ßß/ ;
<
ßß; <
MeshRenderer
ßß< H
>
ßßH I
(
ßßI J
)
ßßJ K
;
ßßK L
Mesh
àà 
vertexStream
àà 
=
àà 
renderer
àà  (
!=
àà) +
null
àà, 0
?
àà1 2
renderer
àà3 ;
.
àà; <%
additionalVertexStreams
àà< S
:
ààT U
null
ààV Z
;
ààZ [
if
ââ 
(
ââ 
vertexStream
ââ 
!=
ââ 
null
ââ  $
)
ââ$ %
{
ãã 
res
ää 
=
ää 
attributeGetter
ää %
(
ää% &
vertexStream
ää& 2
)
ää2 3
;
ää3 4
if
ææ 
(
ææ 
res
ææ 
!=
ææ 
null
ææ 
&&
ææ  "
res
ææ# &
.
ææ& '
Count
ææ' ,
==
ææ- /
vertexCount
ææ0 ;
)
ææ; <
return
çç 
res
çç 
;
çç 
}
èè 
res
êê 
=
êê 
attributeGetter
êê !
(
êê! "
mesh
êê" &
)
êê& '
;
êê' (
return
ìì 
res
ìì 
!=
ìì 
null
ìì 
&&
ìì !
res
ìì" %
.
ìì% &
Count
ìì& +
==
ìì, .
vertexCount
ìì/ :
?
ìì; <
res
ìì= @
:
ììA B
default
ììC J
(
ììJ K
T
ììK L
)
ììL M
;
ììM N
}
íí 	
public
ôô 
static
ôô 
string
ôô 
Print
ôô "
(
ôô" #
Mesh
ôô# '
mesh
ôô( ,
)
ôô, -
{
õõ 	
if
öö 
(
öö 
mesh
öö 
==
öö 
null
öö 
)
öö 
throw
÷÷ 
new
÷÷ #
ArgumentNullException
÷÷ /
(
÷÷/ 0
$str
÷÷0 6
)
÷÷6 7
;
÷÷7 8
System
ùù 
.
ùù 
Text
ùù 
.
ùù 
StringBuilder
ùù %
sb
ùù& (
=
ùù) *
new
ùù+ .
System
ùù/ 5
.
ùù5 6
Text
ùù6 :
.
ùù: ;
StringBuilder
ùù; H
(
ùùH I
)
ùùI J
;
ùùJ K
sb
ûû 
.
ûû 

AppendLine
ûû 
(
ûû 
string
ûû  
.
ûû  !
Format
ûû! '
(
ûû' (
$str
ûû( W
,
ûûW X
mesh
ûûY ]
.
ûû] ^
vertexCount
ûû^ i
,
ûûi j
mesh
ûûk o
.
ûûo p
	triangles
ûûp y
.
ûûy z
Lengthûûz €
,ûû€ 
meshûû‚ †
.ûû† ‡
subMeshCountûû‡ “
)ûû“ ”
)ûû” •
;ûû• –
sb
ıı 
.
ıı 

AppendLine
ıı 
(
ıı 
string
ıı  
.
ıı  !
Format
ıı! '
(
ıı' (
$str
ıı( g
,
ııg h
$str
şş 
,
şş  
$str
ÿÿ 
,
ÿÿ 
$str
€€ 
,
€€ 
$str
 
,
 
$str
‚‚ 
,
‚‚ 
$str
ƒƒ 
,
ƒƒ 
$str
„„ 
,
„„ 
$str
…… 
)
…… 
)
…… 
;
…… 
Vector3
‡‡ 
[
‡‡ 
]
‡‡ 
	positions
‡‡ 
=
‡‡  !
mesh
‡‡" &
.
‡‡& '
vertices
‡‡' /
;
‡‡/ 0
Vector3
ˆˆ 
[
ˆˆ 
]
ˆˆ 
normals
ˆˆ 
=
ˆˆ 
mesh
ˆˆ  $
.
ˆˆ$ %
normals
ˆˆ% ,
;
ˆˆ, -
Color
‰‰ 
[
‰‰ 
]
‰‰ 
colors
‰‰ 
=
‰‰ 
mesh
‰‰ !
.
‰‰! "
colors
‰‰" (
;
‰‰( )
Vector4
ŠŠ 
[
ŠŠ 
]
ŠŠ 
tangents
ŠŠ 
=
ŠŠ  
mesh
ŠŠ! %
.
ŠŠ% &
tangents
ŠŠ& .
;
ŠŠ. /
List
ŒŒ 
<
ŒŒ 
Vector4
ŒŒ 
>
ŒŒ 
uv0
ŒŒ 
=
ŒŒ 
new
ŒŒ  #
List
ŒŒ$ (
<
ŒŒ( )
Vector4
ŒŒ) 0
>
ŒŒ0 1
(
ŒŒ1 2
)
ŒŒ2 3
;
ŒŒ3 4
Vector2
 
[
 
]
 
uv2
 
=
 
mesh
  
.
  !
uv2
! $
;
$ %
List
 
<
 
Vector4
 
>
 
uv3
 
=
 
new
  #
List
$ (
<
( )
Vector4
) 0
>
0 1
(
1 2
)
2 3
;
3 4
List
 
<
 
Vector4
 
>
 
uv4
 
=
 
new
  #
List
$ (
<
( )
Vector4
) 0
>
0 1
(
1 2
)
2 3
;
3 4
mesh
‘‘ 
.
‘‘ 
GetUVs
‘‘ 
(
‘‘ 
$num
‘‘ 
,
‘‘ 
uv0
‘‘ 
)
‘‘ 
;
‘‘  
mesh
’’ 
.
’’ 
GetUVs
’’ 
(
’’ 
$num
’’ 
,
’’ 
uv3
’’ 
)
’’ 
;
’’  
mesh
““ 
.
““ 
GetUVs
““ 
(
““ 
$num
““ 
,
““ 
uv4
““ 
)
““ 
;
““  
if
•• 
(
•• 
	positions
•• 
!=
•• 
null
•• !
&&
••" $
	positions
••% .
.
••. /
Count
••/ 4
(
••4 5
)
••5 6
!=
••7 9
mesh
••: >
.
••> ?
vertexCount
••? J
)
••J K
	positions
–– 
=
–– 
null
––  
;
––  !
if
—— 
(
—— 
normals
—— 
!=
—— 
null
—— 
&&
——  "
normals
——# *
.
——* +
Count
——+ 0
(
——0 1
)
——1 2
!=
——3 5
mesh
——6 :
.
——: ;
vertexCount
——; F
)
——F G
normals
˜˜ 
=
˜˜ 
null
˜˜ 
;
˜˜ 
if
™™ 
(
™™ 
colors
™™ 
!=
™™ 
null
™™ 
&&
™™ !
colors
™™" (
.
™™( )
Count
™™) .
(
™™. /
)
™™/ 0
!=
™™1 3
mesh
™™4 8
.
™™8 9
vertexCount
™™9 D
)
™™D E
colors
šš 
=
šš 
null
šš 
;
šš 
if
›› 
(
›› 
tangents
›› 
!=
›› 
null
››  
&&
››! #
tangents
››$ ,
.
››, -
Count
››- 2
(
››2 3
)
››3 4
!=
››5 7
mesh
››8 <
.
››< =
vertexCount
››= H
)
››H I
tangents
œœ 
=
œœ 
null
œœ 
;
œœ  
if
 
(
 
uv0
 
.
 
Count
 
(
 
)
 
!=
 
mesh
 #
.
# $
vertexCount
$ /
)
/ 0
uv0
 
=
 
null
 
;
 
if
ŸŸ 
(
ŸŸ 
uv2
ŸŸ 
.
ŸŸ 
Count
ŸŸ 
(
ŸŸ 
)
ŸŸ 
!=
ŸŸ 
mesh
ŸŸ #
.
ŸŸ# $
vertexCount
ŸŸ$ /
)
ŸŸ/ 0
uv2
   
=
   
null
   
;
   
if
¡¡ 
(
¡¡ 
uv3
¡¡ 
.
¡¡ 
Count
¡¡ 
(
¡¡ 
)
¡¡ 
!=
¡¡ 
mesh
¡¡ #
.
¡¡# $
vertexCount
¡¡$ /
)
¡¡/ 0
uv3
¢¢ 
=
¢¢ 
null
¢¢ 
;
¢¢ 
if
££ 
(
££ 
uv4
££ 
.
££ 
Count
££ 
(
££ 
)
££ 
!=
££ 
mesh
££ #
.
££# $
vertexCount
££$ /
)
££/ 0
uv4
¤¤ 
=
¤¤ 
null
¤¤ 
;
¤¤ 
sb
¦¦ 
.
¦¦ 

AppendLine
¦¦ 
(
¦¦ 
$str
¦¦ (
)
¦¦( )
;
¦¦) *
for
¨¨ 
(
¨¨ 
int
¨¨ 
i
¨¨ 
=
¨¨ 
$num
¨¨ 
,
¨¨ 
c
¨¨ 
=
¨¨ 
mesh
¨¨  $
.
¨¨$ %
vertexCount
¨¨% 0
;
¨¨0 1
i
¨¨2 3
<
¨¨4 5
c
¨¨6 7
;
¨¨7 8
i
¨¨9 :
++
¨¨: <
)
¨¨< =
{
©© 
sb
ªª 
.
ªª 

AppendLine
ªª 
(
ªª 
string
ªª $
.
ªª$ %
Format
ªª% +
(
ªª+ ,
$str
ªª, n
,
ªªn o
	positions
«« !
==
««" $
null
««% )
?
««, -
$str
««. 4
:
««5 6
string
««7 =
.
««= >
Format
««> D
(
««D E
$str
««E ]
,
««] ^
	positions
««_ h
[
««h i
i
««i j
]
««j k
.
««k l
x
««l m
,
««m n
	positions
««o x
[
««x y
i
««y z
]
««z {
.
««{ |
y
««| }
,
««} ~
	positions«« ˆ
[««ˆ ‰
i««‰ Š
]««Š ‹
.««‹ Œ
z««Œ 
)«« 
,«« 
normals
¬¬ 
==
¬¬  "
null
¬¬# '
?
¬¬, -
$str
¬¬. 4
:
¬¬5 6
string
¬¬7 =
.
¬¬= >
Format
¬¬> D
(
¬¬D E
$str
¬¬E ]
,
¬¬] ^
normals
¬¬_ f
[
¬¬f g
i
¬¬g h
]
¬¬h i
.
¬¬i j
x
¬¬j k
,
¬¬k l
normals
¬¬m t
[
¬¬t u
i
¬¬u v
]
¬¬v w
.
¬¬w x
y
¬¬x y
,
¬¬y z
normals¬¬{ ‚
[¬¬‚ ƒ
i¬¬ƒ „
]¬¬„ …
.¬¬… †
z¬¬† ‡
)¬¬‡ ˆ
,¬¬ˆ ‰
colors
­­ 
==
­­ !
null
­­" &
?
­­, -
$str
­­. 4
:
­­5 6
string
­­7 =
.
­­= >
Format
­­> D
(
­­D E
$str
­­E e
,
­­e f
colors
­­g m
[
­­m n
i
­­n o
]
­­o p
.
­­p q
r
­­q r
,
­­r s
colors
­­t z
[
­­z {
i
­­{ |
]
­­| }
.
­­} ~
g
­­~ 
,­­ €
colors­­ ‡
[­­‡ ˆ
i­­ˆ ‰
]­­‰ Š
.­­Š ‹
b­­‹ Œ
,­­Œ 
colors­­ ”
[­­” •
i­­• –
]­­– —
.­­— ˜
a­­˜ ™
)­­™ š
,­­š ›
tangents
®®  
==
®®! #
null
®®$ (
?
®®, -
$str
®®. 4
:
®®5 6
string
®®7 =
.
®®= >
Format
®®> D
(
®®D E
$str
®®E e
,
®®e f
tangents
®®g o
[
®®o p
i
®®p q
]
®®q r
.
®®r s
x
®®s t
,
®®t u
tangents
®®v ~
[
®®~ 
i®® €
]®®€ 
.®® ‚
y®®‚ ƒ
,®®ƒ „
tangents®®… 
[®® 
i®® 
]®® 
.®® ‘
z®®‘ ’
,®®’ “
tangents®®” œ
[®®œ 
i®® 
]®® Ÿ
.®®Ÿ  
w®®  ¡
)®®¡ ¢
,®®¢ £
uv0
¯¯ 
==
¯¯ 
null
¯¯ #
?
¯¯, -
$str
¯¯. 4
:
¯¯5 6
string
¯¯7 =
.
¯¯= >
Format
¯¯> D
(
¯¯D E
$str
¯¯E e
,
¯¯e f
uv0
¯¯g j
[
¯¯j k
i
¯¯k l
]
¯¯l m
.
¯¯m n
x
¯¯n o
,
¯¯o p
uv0
¯¯q t
[
¯¯t u
i
¯¯u v
]
¯¯v w
.
¯¯w x
y
¯¯x y
,
¯¯y z
uv0
¯¯{ ~
[
¯¯~ 
i¯¯ €
]¯¯€ 
.¯¯ ‚
z¯¯‚ ƒ
,¯¯ƒ „
uv0¯¯… ˆ
[¯¯ˆ ‰
i¯¯‰ Š
]¯¯Š ‹
.¯¯‹ Œ
w¯¯Œ 
)¯¯ 
,¯¯ 
uv2
°° 
==
°° 
null
°° #
?
°°, -
$str
°°. 4
:
°°5 6
string
°°7 =
.
°°= >
Format
°°> D
(
°°D E
$str
°°E U
,
°°U V
uv2
°°W Z
[
°°Z [
i
°°[ \
]
°°\ ]
.
°°] ^
x
°°^ _
,
°°_ `
uv2
°°a d
[
°°d e
i
°°e f
]
°°f g
.
°°g h
y
°°h i
)
°°i j
,
°°j k
uv3
±± 
==
±± 
null
±± #
?
±±, -
$str
±±. 4
:
±±5 6
string
±±7 =
.
±±= >
Format
±±> D
(
±±D E
$str
±±E e
,
±±e f
uv3
±±g j
[
±±j k
i
±±k l
]
±±l m
.
±±m n
x
±±n o
,
±±o p
uv3
±±q t
[
±±t u
i
±±u v
]
±±v w
.
±±w x
y
±±x y
,
±±y z
uv3
±±{ ~
[
±±~ 
i±± €
]±±€ 
.±± ‚
z±±‚ ƒ
,±±ƒ „
uv3±±… ˆ
[±±ˆ ‰
i±±‰ Š
]±±Š ‹
.±±‹ Œ
w±±Œ 
)±± 
,±± 
uv4
²² 
==
²² 
null
²² #
?
²², -
$str
²². 4
:
²²5 6
string
²²7 =
.
²²= >
Format
²²> D
(
²²D E
$str
²²E e
,
²²e f
uv4
²²g j
[
²²j k
i
²²k l
]
²²l m
.
²²m n
x
²²n o
,
²²o p
uv4
²²q t
[
²²t u
i
²²u v
]
²²v w
.
²²w x
y
²²x y
,
²²y z
uv4
²²{ ~
[
²²~ 
i²² €
]²²€ 
.²² ‚
z²²‚ ƒ
,²²ƒ „
uv4²²… ˆ
[²²ˆ ‰
i²²‰ Š
]²²Š ‹
.²²‹ Œ
w²²Œ 
)²² 
,²² 
i
³³ 
)
³³ 
)
³³ 
;
³³ 
}
´´ 
sb
¶¶ 
.
¶¶ 

AppendLine
¶¶ 
(
¶¶ 
$str
¶¶ &
)
¶¶& '
;
¶¶' (
for
¸¸ 
(
¸¸ 
int
¸¸ 
i
¸¸ 
=
¸¸ 
$num
¸¸ 
;
¸¸ 
i
¸¸ 
<
¸¸ 
mesh
¸¸  $
.
¸¸$ %
subMeshCount
¸¸% 1
;
¸¸1 2
i
¸¸3 4
++
¸¸4 6
)
¸¸6 7
{
¹¹ 
var
ºº 
topo
ºº 
=
ºº 
mesh
ºº 
.
ºº  
GetTopology
ºº  +
(
ºº+ ,
i
ºº, -
)
ºº- .
;
ºº. /
var
»» 
submesh
»» 
=
»» 
mesh
»» "
.
»»" #

GetIndices
»»# -
(
»»- .
i
»». /
)
»»/ 0
;
»»0 1
sb
¼¼ 
.
¼¼ 

AppendLine
¼¼ 
(
¼¼ 
$"
¼¼  

  Submesh[
¼¼  *
{
¼¼* +
i
¼¼+ ,
}
¼¼, -
] (
¼¼- 0
{
¼¼0 1
topo
¼¼1 5
}
¼¼5 6
)
¼¼6 7
"
¼¼7 8
)
¼¼8 9
;
¼¼9 :
switch
¾¾ 
(
¾¾ 
topo
¾¾ 
)
¾¾ 
{
¿¿ 
case
ÀÀ 
MeshTopology
ÀÀ %
.
ÀÀ% &
Points
ÀÀ& ,
:
ÀÀ, -
for
ÁÁ 
(
ÁÁ 
int
ÁÁ  
n
ÁÁ! "
=
ÁÁ# $
$num
ÁÁ% &
;
ÁÁ& '
n
ÁÁ( )
<
ÁÁ* +
submesh
ÁÁ, 3
.
ÁÁ3 4
Length
ÁÁ4 :
;
ÁÁ: ;
n
ÁÁ< =
+=
ÁÁ> @
$num
ÁÁA B
)
ÁÁB C
sb
ÂÂ 
.
ÂÂ 

AppendLine
ÂÂ )
(
ÂÂ) *
string
ÂÂ* 0
.
ÂÂ0 1
Format
ÂÂ1 7
(
ÂÂ7 8
$str
ÂÂ8 ?
,
ÂÂ? @
submesh
ÂÂA H
[
ÂÂH I
n
ÂÂI J
]
ÂÂJ K
)
ÂÂK L
)
ÂÂL M
;
ÂÂM N
break
ÃÃ 
;
ÃÃ 
case
ÄÄ 
MeshTopology
ÄÄ %
.
ÄÄ% &
Lines
ÄÄ& +
:
ÄÄ+ ,
for
ÅÅ 
(
ÅÅ 
int
ÅÅ  
n
ÅÅ! "
=
ÅÅ# $
$num
ÅÅ% &
;
ÅÅ& '
n
ÅÅ( )
<
ÅÅ* +
submesh
ÅÅ, 3
.
ÅÅ3 4
Length
ÅÅ4 :
;
ÅÅ: ;
n
ÅÅ< =
+=
ÅÅ> @
$num
ÅÅA B
)
ÅÅB C
sb
ÆÆ 
.
ÆÆ 

AppendLine
ÆÆ )
(
ÆÆ) *
string
ÆÆ* 0
.
ÆÆ0 1
Format
ÆÆ1 7
(
ÆÆ7 8
$str
ÆÆ8 D
,
ÆÆD E
submesh
ÆÆF M
[
ÆÆM N
n
ÆÆN O
]
ÆÆO P
,
ÆÆP Q
submesh
ÆÆR Y
[
ÆÆY Z
n
ÆÆZ [
+
ÆÆ\ ]
$num
ÆÆ^ _
]
ÆÆ_ `
)
ÆÆ` a
)
ÆÆa b
;
ÆÆb c
break
ÇÇ 
;
ÇÇ 
case
ÈÈ 
MeshTopology
ÈÈ %
.
ÈÈ% &
	Triangles
ÈÈ& /
:
ÈÈ/ 0
for
ÉÉ 
(
ÉÉ 
int
ÉÉ  
n
ÉÉ! "
=
ÉÉ# $
$num
ÉÉ% &
;
ÉÉ& '
n
ÉÉ( )
<
ÉÉ* +
submesh
ÉÉ, 3
.
ÉÉ3 4
Length
ÉÉ4 :
;
ÉÉ: ;
n
ÉÉ< =
+=
ÉÉ> @
$num
ÉÉA B
)
ÉÉB C
sb
ÊÊ 
.
ÊÊ 

AppendLine
ÊÊ )
(
ÊÊ) *
string
ÊÊ* 0
.
ÊÊ0 1
Format
ÊÊ1 7
(
ÊÊ7 8
$str
ÊÊ8 I
,
ÊÊI J
submesh
ÊÊK R
[
ÊÊR S
n
ÊÊS T
]
ÊÊT U
,
ÊÊU V
submesh
ÊÊW ^
[
ÊÊ^ _
n
ÊÊ_ `
+
ÊÊa b
$num
ÊÊc d
]
ÊÊd e
,
ÊÊe f
submesh
ÊÊg n
[
ÊÊn o
n
ÊÊo p
+
ÊÊq r
$num
ÊÊs t
]
ÊÊt u
)
ÊÊu v
)
ÊÊv w
;
ÊÊw x
break
ËË 
;
ËË 
case
ÌÌ 
MeshTopology
ÌÌ %
.
ÌÌ% &
Quads
ÌÌ& +
:
ÌÌ+ ,
for
ÍÍ 
(
ÍÍ 
int
ÍÍ  
n
ÍÍ! "
=
ÍÍ# $
$num
ÍÍ% &
;
ÍÍ& '
n
ÍÍ( )
<
ÍÍ* +
submesh
ÍÍ, 3
.
ÍÍ3 4
Length
ÍÍ4 :
;
ÍÍ: ;
n
ÍÍ< =
+=
ÍÍ> @
$num
ÍÍA B
)
ÍÍB C
sb
ÎÎ 
.
ÎÎ 

AppendLine
ÎÎ )
(
ÎÎ) *
string
ÎÎ* 0
.
ÎÎ0 1
Format
ÎÎ1 7
(
ÎÎ7 8
$str
ÎÎ8 N
,
ÎÎN O
submesh
ÎÎP W
[
ÎÎW X
n
ÎÎX Y
]
ÎÎY Z
,
ÎÎZ [
submesh
ÎÎ\ c
[
ÎÎc d
n
ÎÎd e
+
ÎÎf g
$num
ÎÎh i
]
ÎÎi j
,
ÎÎj k
submesh
ÎÎl s
[
ÎÎs t
n
ÎÎt u
+
ÎÎv w
$num
ÎÎx y
]
ÎÎy z
,
ÎÎz {
submeshÎÎ| ƒ
[ÎÎƒ „
nÎÎ„ …
+ÎÎ† ‡
$numÎÎˆ ‰
]ÎÎ‰ Š
)ÎÎŠ ‹
)ÎÎ‹ Œ
;ÎÎŒ 
break
ÏÏ 
;
ÏÏ 
}
ĞĞ 
}
ÑÑ 
return
ÓÓ 
sb
ÓÓ 
.
ÓÓ 
ToString
ÓÓ 
(
ÓÓ 
)
ÓÓ  
;
ÓÓ  !
}
ÔÔ 	
public
ÛÛ 
static
ÛÛ 
uint
ÛÛ 
GetIndexCount
ÛÛ (
(
ÛÛ( )
Mesh
ÛÛ) -
mesh
ÛÛ. 2
)
ÛÛ2 3
{
ÜÜ 	
uint
İİ 
sum
İİ 
=
İİ 
$num
İİ 
;
İİ 
if
ßß 
(
ßß 
mesh
ßß 
==
ßß 
null
ßß 
)
ßß 
return
àà 
sum
àà 
;
àà 
for
ââ 
(
ââ 
int
ââ 
i
ââ 
=
ââ 
$num
ââ 
,
ââ 
c
ââ 
=
ââ 
mesh
ââ  $
.
ââ$ %
subMeshCount
ââ% 1
;
ââ1 2
i
ââ3 4
<
ââ5 6
c
ââ7 8
;
ââ8 9
i
ââ: ;
++
ââ; =
)
ââ= >
sum
ãã 
+=
ãã 
mesh
ãã 
.
ãã 
GetIndexCount
ãã )
(
ãã) *
i
ãã* +
)
ãã+ ,
;
ãã, -
return
åå 
sum
åå 
;
åå 
}
ææ 	
public
íí 
static
íí 
uint
íí 
GetPrimitiveCount
íí ,
(
íí, -
Mesh
íí- 1
mesh
íí2 6
)
íí6 7
{
îî 	
uint
ïï 
sum
ïï 
=
ïï 
$num
ïï 
;
ïï 
if
ññ 
(
ññ 
mesh
ññ 
==
ññ 
null
ññ 
)
ññ 
return
òò 
sum
òò 
;
òò 
for
ôô 
(
ôô 
int
ôô 
i
ôô 
=
ôô 
$num
ôô 
,
ôô 
c
ôô 
=
ôô 
mesh
ôô  $
.
ôô$ %
subMeshCount
ôô% 1
;
ôô1 2
i
ôô3 4
<
ôô5 6
c
ôô7 8
;
ôô8 9
i
ôô: ;
++
ôô; =
)
ôô= >
{
õõ 
if
öö 
(
öö 
mesh
öö 
.
öö 
GetTopology
öö $
(
öö$ %
i
öö% &
)
öö& '
==
öö( *
MeshTopology
öö+ 7
.
öö7 8
	Triangles
öö8 A
)
ööA B
sum
÷÷ 
+=
÷÷ 
mesh
÷÷ 
.
÷÷  
GetIndexCount
÷÷  -
(
÷÷- .
i
÷÷. /
)
÷÷/ 0
/
÷÷1 2
$num
÷÷3 4
;
÷÷4 5
else
øø 
if
øø 
(
øø 
mesh
øø 
.
øø 
GetTopology
øø )
(
øø) *
i
øø* +
)
øø+ ,
==
øø- /
MeshTopology
øø0 <
.
øø< =
Quads
øø= B
)
øøB C
sum
ùù 
+=
ùù 
mesh
ùù 
.
ùù  
GetIndexCount
ùù  -
(
ùù- .
i
ùù. /
)
ùù/ 0
/
ùù1 2
$num
ùù3 4
;
ùù4 5
}
úú 
return
üü 
sum
üü 
;
üü 
}
ıı 	
public
†† 
static
†† 
void
†† 
Compile
†† "
(
††" #
ProBuilderMesh
††# 1
probuilderMesh
††2 @
,
††@ A
Mesh
††B F

targetMesh
††G Q
,
††Q R
MeshTopology
††S _
preferredTopology
††` q
=
††r s
MeshTopology††t €
.††€ 
	Triangles†† Š
)††Š ‹
{
‡‡ 	
if
ˆˆ 
(
ˆˆ 
probuilderMesh
ˆˆ 
==
ˆˆ !
null
ˆˆ" &
)
ˆˆ& '
throw
‰‰ 
new
‰‰ #
ArgumentNullException
‰‰ /
(
‰‰/ 0
$str
‰‰0 @
)
‰‰@ A
;
‰‰A B
if
‹‹ 
(
‹‹ 

targetMesh
‹‹ 
==
‹‹ 
null
‹‹ "
)
‹‹" #
throw
ŒŒ 
new
ŒŒ #
ArgumentNullException
ŒŒ /
(
ŒŒ/ 0
$str
ŒŒ0 <
)
ŒŒ< =
;
ŒŒ= >

targetMesh
 
.
 
Clear
 
(
 
)
 
;
 

targetMesh
 
.
 
vertices
 
=
  !
probuilderMesh
" 0
.
0 1
positionsInternal
1 B
;
B C

targetMesh
‘‘ 
.
‘‘ 
uv
‘‘ 
=
‘‘ 
probuilderMesh
‘‘ *
.
‘‘* +
texturesInternal
‘‘+ ;
;
‘‘; <
if
““ 
(
““ 
probuilderMesh
““ 
.
““ 
	HasArrays
““ (
(
““( )

MeshArrays
““) 3
.
““3 4
Texture2
““4 <
)
““< =
)
““= >
{
”” 
List
•• 
<
•• 
Vector4
•• 
>
•• 
	uvChannel
•• '
=
••( )
new
••* -
List
••. 2
<
••2 3
Vector4
••3 :
>
••: ;
(
••; <
)
••< =
;
••= >
probuilderMesh
–– 
.
–– 
GetUVs
–– %
(
––% &
$num
––& '
,
––' (
	uvChannel
––) 2
)
––2 3
;
––3 4

targetMesh
—— 
.
—— 
SetUVs
—— !
(
——! "
$num
——" #
,
——# $
	uvChannel
——% .
)
——. /
;
——/ 0
}
˜˜ 
if
šš 
(
šš 
probuilderMesh
šš 
.
šš 
	HasArrays
šš (
(
šš( )

MeshArrays
šš) 3
.
šš3 4
Texture3
šš4 <
)
šš< =
)
šš= >
{
›› 
List
œœ 
<
œœ 
Vector4
œœ 
>
œœ 
	uvChannel
œœ '
=
œœ( )
new
œœ* -
List
œœ. 2
<
œœ2 3
Vector4
œœ3 :
>
œœ: ;
(
œœ; <
)
œœ< =
;
œœ= >
probuilderMesh
 
.
 
GetUVs
 %
(
% &
$num
& '
,
' (
	uvChannel
) 2
)
2 3
;
3 4

targetMesh
 
.
 
SetUVs
 !
(
! "
$num
" #
,
# $
	uvChannel
% .
)
. /
;
/ 0
}
ŸŸ 

targetMesh
¡¡ 
.
¡¡ 
normals
¡¡ 
=
¡¡  
probuilderMesh
¡¡! /
.
¡¡/ 0

GetNormals
¡¡0 :
(
¡¡: ;
)
¡¡; <
;
¡¡< =

targetMesh
¢¢ 
.
¢¢ 
tangents
¢¢ 
=
¢¢  !
probuilderMesh
¢¢" 0
.
¢¢0 1
GetTangents
¢¢1 <
(
¢¢< =
)
¢¢= >
;
¢¢> ?
if
¤¤ 
(
¤¤ 
probuilderMesh
¤¤ 
.
¤¤ 
	HasArrays
¤¤ (
(
¤¤( )

MeshArrays
¤¤) 3
.
¤¤3 4
Color
¤¤4 9
)
¤¤9 :
)
¤¤: ;

targetMesh
¥¥ 
.
¥¥ 
colors
¥¥ !
=
¥¥" #
probuilderMesh
¥¥$ 2
.
¥¥2 3
colorsInternal
¥¥3 A
;
¥¥A B
var
§§ 
materialCount
§§ 
=
§§ 
probuilderMesh
§§  .
.
§§. /
GetComponent
§§/ ;
<
§§; <
Renderer
§§< D
>
§§D E
(
§§E F
)
§§F G
.
§§G H
sharedMaterials
§§H W
.
§§W X
Length
§§X ^
;
§§^ _
var
¨¨ 
	submeshes
¨¨ 
=
¨¨ 
Submesh
¨¨ #
.
¨¨# $
GetSubmeshes
¨¨$ 0
(
¨¨0 1
probuilderMesh
¨¨1 ?
.
¨¨? @
facesInternal
¨¨@ M
,
¨¨M N
materialCount
¨¨O \
,
¨¨\ ]
preferredTopology
¨¨^ o
)
¨¨o p
;
¨¨p q

targetMesh
©© 
.
©© 
subMeshCount
©© #
=
©©$ %
	submeshes
©©& /
.
©©/ 0
Length
©©0 6
;
©©6 7
for
«« 
(
«« 
int
«« 
i
«« 
=
«« 
$num
«« 
;
«« 
i
«« 
<
«« 

targetMesh
««  *
.
««* +
subMeshCount
««+ 7
;
««7 8
i
««9 :
++
««: <
)
««< =

targetMesh
¬¬ 
.
¬¬ 

SetIndices
¬¬ %
(
¬¬% &
	submeshes
¬¬& /
[
¬¬/ 0
i
¬¬0 1
]
¬¬1 2
.
¬¬2 3
	m_Indexes
¬¬3 <
,
¬¬< =
	submeshes
¬¬> G
[
¬¬G H
i
¬¬H I
]
¬¬I J
.
¬¬J K

m_Topology
¬¬K U
,
¬¬U V
i
¬¬W X
,
¬¬X Y
false
¬¬Z _
)
¬¬_ `
;
¬¬` a

targetMesh
®® 
.
®® 
name
®® 
=
®® 
string
®® $
.
®®$ %
Format
®®% +
(
®®+ ,
$str
®®, 8
,
®®8 9
probuilderMesh
®®: H
.
®®H I
id
®®I K
)
®®K L
;
®®L M
}
¯¯ 	
public
¶¶ 
static
¶¶ 
Vertex
¶¶ 
[
¶¶ 
]
¶¶ 
GetVertices
¶¶ *
(
¶¶* +
this
¶¶+ /
Mesh
¶¶0 4
mesh
¶¶5 9
)
¶¶9 :
{
·· 	
if
¸¸ 
(
¸¸ 
mesh
¸¸ 
==
¸¸ 
null
¸¸ 
)
¸¸ 
return
¹¹ 
null
¹¹ 
;
¹¹ 
int
»» 
vertexCount
»» 
=
»» 
mesh
»» "
.
»»" #
vertexCount
»»# .
;
»». /
Vertex
¼¼ 
[
¼¼ 
]
¼¼ 
v
¼¼ 
=
¼¼ 
new
¼¼ 
Vertex
¼¼ #
[
¼¼# $
vertexCount
¼¼$ /
]
¼¼/ 0
;
¼¼0 1
Vector3
¾¾ 
[
¾¾ 
]
¾¾ 
	positions
¾¾ 
=
¾¾  !
mesh
¾¾" &
.
¾¾& '
vertices
¾¾' /
;
¾¾/ 0
Color
¿¿ 
[
¿¿ 
]
¿¿ 
colors
¿¿ 
=
¿¿ 
mesh
¿¿ !
.
¿¿! "
colors
¿¿" (
;
¿¿( )
Vector3
ÀÀ 
[
ÀÀ 
]
ÀÀ 
normals
ÀÀ 
=
ÀÀ 
mesh
ÀÀ  $
.
ÀÀ$ %
normals
ÀÀ% ,
;
ÀÀ, -
Vector4
ÁÁ 
[
ÁÁ 
]
ÁÁ 
tangents
ÁÁ 
=
ÁÁ  
mesh
ÁÁ! %
.
ÁÁ% &
tangents
ÁÁ& .
;
ÁÁ. /
Vector2
ÂÂ 
[
ÂÂ 
]
ÂÂ 
uv0s
ÂÂ 
=
ÂÂ 
mesh
ÂÂ !
.
ÂÂ! "
uv
ÂÂ" $
;
ÂÂ$ %
Vector2
ÃÃ 
[
ÃÃ 
]
ÃÃ 
uv2s
ÃÃ 
=
ÃÃ 
mesh
ÃÃ !
.
ÃÃ! "
uv2
ÃÃ" %
;
ÃÃ% &
List
ÄÄ 
<
ÄÄ 
Vector4
ÄÄ 
>
ÄÄ 
uv3s
ÄÄ 
=
ÄÄ  
new
ÄÄ! $
List
ÄÄ% )
<
ÄÄ) *
Vector4
ÄÄ* 1
>
ÄÄ1 2
(
ÄÄ2 3
)
ÄÄ3 4
;
ÄÄ4 5
List
ÅÅ 
<
ÅÅ 
Vector4
ÅÅ 
>
ÅÅ 
uv4s
ÅÅ 
=
ÅÅ  
new
ÅÅ! $
List
ÅÅ% )
<
ÅÅ) *
Vector4
ÅÅ* 1
>
ÅÅ1 2
(
ÅÅ2 3
)
ÅÅ3 4
;
ÅÅ4 5
mesh
ÆÆ 
.
ÆÆ 
GetUVs
ÆÆ 
(
ÆÆ 
$num
ÆÆ 
,
ÆÆ 
uv3s
ÆÆ 
)
ÆÆ  
;
ÆÆ  !
mesh
ÇÇ 
.
ÇÇ 
GetUVs
ÇÇ 
(
ÇÇ 
$num
ÇÇ 
,
ÇÇ 
uv4s
ÇÇ 
)
ÇÇ  
;
ÇÇ  !
bool
ÉÉ 
_hasPositions
ÉÉ 
=
ÉÉ  
	positions
ÉÉ! *
!=
ÉÉ+ -
null
ÉÉ. 2
&&
ÉÉ3 5
	positions
ÉÉ6 ?
.
ÉÉ? @
Count
ÉÉ@ E
(
ÉÉE F
)
ÉÉF G
==
ÉÉH J
vertexCount
ÉÉK V
;
ÉÉV W
bool
ÊÊ 

_hasColors
ÊÊ 
=
ÊÊ 
colors
ÊÊ $
!=
ÊÊ% '
null
ÊÊ( ,
&&
ÊÊ- /
colors
ÊÊ0 6
.
ÊÊ6 7
Count
ÊÊ7 <
(
ÊÊ< =
)
ÊÊ= >
==
ÊÊ? A
vertexCount
ÊÊB M
;
ÊÊM N
bool
ËË 
_hasNormals
ËË 
=
ËË 
normals
ËË &
!=
ËË' )
null
ËË* .
&&
ËË/ 1
normals
ËË2 9
.
ËË9 :
Count
ËË: ?
(
ËË? @
)
ËË@ A
==
ËËB D
vertexCount
ËËE P
;
ËËP Q
bool
ÌÌ 
_hasTangents
ÌÌ 
=
ÌÌ 
tangents
ÌÌ  (
!=
ÌÌ) +
null
ÌÌ, 0
&&
ÌÌ1 3
tangents
ÌÌ4 <
.
ÌÌ< =
Count
ÌÌ= B
(
ÌÌB C
)
ÌÌC D
==
ÌÌE G
vertexCount
ÌÌH S
;
ÌÌS T
bool
ÍÍ 
_hasUv0
ÍÍ 
=
ÍÍ 
uv0s
ÍÍ 
!=
ÍÍ  "
null
ÍÍ# '
&&
ÍÍ( *
uv0s
ÍÍ+ /
.
ÍÍ/ 0
Count
ÍÍ0 5
(
ÍÍ5 6
)
ÍÍ6 7
==
ÍÍ8 :
vertexCount
ÍÍ; F
;
ÍÍF G
bool
ÎÎ 
_hasUv2
ÎÎ 
=
ÎÎ 
uv2s
ÎÎ 
!=
ÎÎ  "
null
ÎÎ# '
&&
ÎÎ( *
uv2s
ÎÎ+ /
.
ÎÎ/ 0
Count
ÎÎ0 5
(
ÎÎ5 6
)
ÎÎ6 7
==
ÎÎ8 :
vertexCount
ÎÎ; F
;
ÎÎF G
bool
ÏÏ 
_hasUv3
ÏÏ 
=
ÏÏ 
uv3s
ÏÏ 
.
ÏÏ  
Count
ÏÏ  %
(
ÏÏ% &
)
ÏÏ& '
==
ÏÏ( *
vertexCount
ÏÏ+ 6
;
ÏÏ6 7
bool
ĞĞ 
_hasUv4
ĞĞ 
=
ĞĞ 
uv4s
ĞĞ 
.
ĞĞ  
Count
ĞĞ  %
(
ĞĞ% &
)
ĞĞ& '
==
ĞĞ( *
vertexCount
ĞĞ+ 6
;
ĞĞ6 7
for
ÒÒ 
(
ÒÒ 
int
ÒÒ 
i
ÒÒ 
=
ÒÒ 
$num
ÒÒ 
;
ÒÒ 
i
ÒÒ 
<
ÒÒ 
vertexCount
ÒÒ  +
;
ÒÒ+ ,
i
ÒÒ- .
++
ÒÒ. 0
)
ÒÒ0 1
{
ÓÓ 
v
ÔÔ 
[
ÔÔ 
i
ÔÔ 
]
ÔÔ 
=
ÔÔ 
new
ÔÔ 
Vertex
ÔÔ !
(
ÔÔ! "
)
ÔÔ" #
;
ÔÔ# $
if
ÖÖ 
(
ÖÖ 
_hasPositions
ÖÖ !
)
ÖÖ! "
v
×× 
[
×× 
i
×× 
]
×× 
.
×× 
position
×× !
=
××" #
	positions
××$ -
[
××- .
i
××. /
]
××/ 0
;
××0 1
if
ÙÙ 
(
ÙÙ 

_hasColors
ÙÙ 
)
ÙÙ 
v
ÚÚ 
[
ÚÚ 
i
ÚÚ 
]
ÚÚ 
.
ÚÚ 
color
ÚÚ 
=
ÚÚ  
colors
ÚÚ! '
[
ÚÚ' (
i
ÚÚ( )
]
ÚÚ) *
;
ÚÚ* +
if
ÜÜ 
(
ÜÜ 
_hasNormals
ÜÜ 
)
ÜÜ  
v
İİ 
[
İİ 
i
İİ 
]
İİ 
.
İİ 
normal
İİ 
=
İİ  !
normals
İİ" )
[
İİ) *
i
İİ* +
]
İİ+ ,
;
İİ, -
if
ßß 
(
ßß 
_hasTangents
ßß  
)
ßß  !
v
àà 
[
àà 
i
àà 
]
àà 
.
àà 
tangent
àà  
=
àà! "
tangents
àà# +
[
àà+ ,
i
àà, -
]
àà- .
;
àà. /
if
ââ 
(
ââ 
_hasUv0
ââ 
)
ââ 
v
ãã 
[
ãã 
i
ãã 
]
ãã 
.
ãã 
uv0
ãã 
=
ãã 
uv0s
ãã #
[
ãã# $
i
ãã$ %
]
ãã% &
;
ãã& '
if
åå 
(
åå 
_hasUv2
åå 
)
åå 
v
ææ 
[
ææ 
i
ææ 
]
ææ 
.
ææ 
uv2
ææ 
=
ææ 
uv2s
ææ #
[
ææ# $
i
ææ$ %
]
ææ% &
;
ææ& '
if
èè 
(
èè 
_hasUv3
èè 
)
èè 
v
éé 
[
éé 
i
éé 
]
éé 
.
éé 
uv3
éé 
=
éé 
uv3s
éé #
[
éé# $
i
éé$ %
]
éé% &
;
éé& '
if
ëë 
(
ëë 
_hasUv4
ëë 
)
ëë 
v
ìì 
[
ìì 
i
ìì 
]
ìì 
.
ìì 
uv4
ìì 
=
ìì 
uv4s
ìì #
[
ìì# $
i
ìì$ %
]
ìì% &
;
ìì& '
}
íí 
return
ïï 
v
ïï 
;
ïï 
}
ğğ 	
public
üü 
static
üü 
void
üü $
CollapseSharedVertices
üü 1
(
üü1 2
Mesh
üü2 6
mesh
üü7 ;
,
üü; <
Vertex
üü= C
[
üüC D
]
üüD E
vertices
üüF N
=
üüO P
null
üüQ U
)
üüU V
{
ıı 	
if
şş 
(
şş 
mesh
şş 
==
şş 
null
şş 
)
şş 
throw
ÿÿ 
new
ÿÿ 
System
ÿÿ  
.
ÿÿ  !#
ArgumentNullException
ÿÿ! 6
(
ÿÿ6 7
$str
ÿÿ7 =
)
ÿÿ= >
;
ÿÿ> ?
if
 
(
 
vertices
 
==
 
null
  
)
  !
vertices
‚‚ 
=
‚‚ 
mesh
‚‚ 
.
‚‚  
GetVertices
‚‚  +
(
‚‚+ ,
)
‚‚, -
;
‚‚- .
int
„„ 
smc
„„ 
=
„„ 
mesh
„„ 
.
„„ 
subMeshCount
„„ '
;
„„' (
List
…… 
<
…… 

Dictionary
…… 
<
…… 
Vertex
…… "
,
……" #
int
……$ '
>
……' (
>
……( )
subVertices
……* 5
=
……6 7
new
……8 ;
List
……< @
<
……@ A

Dictionary
……A K
<
……K L
Vertex
……L R
,
……R S
int
……T W
>
……W X
>
……X Y
(
……Y Z
)
……Z [
;
……[ \
int
†† 
[
†† 
]
†† 
[
†† 
]
†† 
tris
†† 
=
†† 
new
†† 
int
†† "
[
††" #
smc
††# &
]
††& '
[
††' (
]
††( )
;
††) *
int
‡‡ 
subIndex
‡‡ 
=
‡‡ 
$num
‡‡ 
;
‡‡ 
for
‰‰ 
(
‰‰ 
int
‰‰ 
i
‰‰ 
=
‰‰ 
$num
‰‰ 
;
‰‰ 
i
‰‰ 
<
‰‰ 
smc
‰‰  #
;
‰‰# $
++
‰‰% '
i
‰‰' (
)
‰‰( )
{
ŠŠ 
tris
‹‹ 
[
‹‹ 
i
‹‹ 
]
‹‹ 
=
‹‹ 
mesh
‹‹ 
.
‹‹ 
GetTriangles
‹‹ +
(
‹‹+ ,
i
‹‹, -
)
‹‹- .
;
‹‹. /

Dictionary
ŒŒ 
<
ŒŒ 
Vertex
ŒŒ !
,
ŒŒ! "
int
ŒŒ# &
>
ŒŒ& '
newVertices
ŒŒ( 3
=
ŒŒ4 5
new
ŒŒ6 9

Dictionary
ŒŒ: D
<
ŒŒD E
Vertex
ŒŒE K
,
ŒŒK L
int
ŒŒM P
>
ŒŒP Q
(
ŒŒQ R
)
ŒŒR S
;
ŒŒS T
for
 
(
 
int
 
n
 
=
 
$num
 
;
 
n
  !
<
" #
tris
$ (
[
( )
i
) *
]
* +
.
+ ,
Length
, 2
;
2 3
n
4 5
++
5 7
)
7 8
{
 
Vertex
 
v
 
=
 
vertices
 '
[
' (
tris
( ,
[
, -
i
- .
]
. /
[
/ 0
n
0 1
]
1 2
]
2 3
;
3 4
int
‘‘ 
index
‘‘ 
;
‘‘ 
if
““ 
(
““ 
newVertices
““ #
.
““# $
TryGetValue
““$ /
(
““/ 0
v
““0 1
,
““1 2
out
““3 6
index
““7 <
)
““< =
)
““= >
{
”” 
tris
•• 
[
•• 
i
•• 
]
•• 
[
••  
n
••  !
]
••! "
=
••# $
index
••% *
;
••* +
}
–– 
else
—— 
{
˜˜ 
tris
™™ 
[
™™ 
i
™™ 
]
™™ 
[
™™  
n
™™  !
]
™™! "
=
™™# $
subIndex
™™% -
;
™™- .
newVertices
šš #
.
šš# $
Add
šš$ '
(
šš' (
v
šš( )
,
šš) *
subIndex
šš+ 3
)
šš3 4
;
šš4 5
subIndex
››  
++
››  "
;
››" #
}
œœ 
}
 
subVertices
ŸŸ 
.
ŸŸ 
Add
ŸŸ 
(
ŸŸ  
newVertices
ŸŸ  +
)
ŸŸ+ ,
;
ŸŸ, -
}
   
Vertex
¢¢ 
[
¢¢ 
]
¢¢ 
	collapsed
¢¢ 
=
¢¢  
subVertices
¢¢! ,
.
¢¢, -

SelectMany
¢¢- 7
(
¢¢7 8
x
¢¢8 9
=>
¢¢: <
x
¢¢= >
.
¢¢> ?
Keys
¢¢? C
)
¢¢C D
.
¢¢D E
ToArray
¢¢E L
(
¢¢L M
)
¢¢M N
;
¢¢N O
Vertex
££ 
.
££ 
SetMesh
££ 
(
££ 
mesh
££ 
,
££  
	collapsed
££! *
)
££* +
;
££+ ,
mesh
¤¤ 
.
¤¤ 
subMeshCount
¤¤ 
=
¤¤ 
smc
¤¤  #
;
¤¤# $
for
¥¥ 
(
¥¥ 
int
¥¥ 
i
¥¥ 
=
¥¥ 
$num
¥¥ 
;
¥¥ 
i
¥¥ 
<
¥¥ 
smc
¥¥  #
;
¥¥# $
i
¥¥% &
++
¥¥& (
)
¥¥( )
mesh
¦¦ 
.
¦¦ 
SetTriangles
¦¦ !
(
¦¦! "
tris
¦¦" &
[
¦¦& '
i
¦¦' (
]
¦¦( )
,
¦¦) *
i
¦¦+ ,
)
¦¦, -
;
¦¦- .
}
§§ 	
internal
©© 
static
©© 
string
©© 
SanityCheck
©© *
(
©©* +
ProBuilderMesh
©©+ 9
mesh
©©: >
)
©©> ?
{
ªª 	
return
«« 
SanityCheck
«« 
(
«« 
mesh
«« #
.
««# $
GetVertices
««$ /
(
««/ 0
)
««0 1
)
««1 2
;
««2 3
}
¬¬ 	
internal
³³ 
static
³³ 
string
³³ 
SanityCheck
³³ *
(
³³* +
Mesh
³³+ /
mesh
³³0 4
)
³³4 5
{
´´ 	
return
µµ 
SanityCheck
µµ 
(
µµ 
mesh
µµ #
.
µµ# $
GetVertices
µµ$ /
(
µµ/ 0
)
µµ0 1
)
µµ1 2
;
µµ2 3
}
¶¶ 	
internal
¼¼ 
static
¼¼ 
string
¼¼ 
SanityCheck
¼¼ *
(
¼¼* +
IList
¼¼+ 0
<
¼¼0 1
Vertex
¼¼1 7
>
¼¼7 8
vertices
¼¼9 A
)
¼¼A B
{
½½ 	
var
¾¾ 
sb
¾¾ 
=
¾¾ 
new
¾¾ 
StringBuilder
¾¾ &
(
¾¾& '
)
¾¾' (
;
¾¾( )
for
ÀÀ 
(
ÀÀ 
int
ÀÀ 
i
ÀÀ 
=
ÀÀ 
$num
ÀÀ 
,
ÀÀ 
c
ÀÀ 
=
ÀÀ 
vertices
ÀÀ  (
.
ÀÀ( )
Count
ÀÀ) .
;
ÀÀ. /
i
ÀÀ0 1
<
ÀÀ2 3
c
ÀÀ4 5
;
ÀÀ5 6
i
ÀÀ7 8
++
ÀÀ8 :
)
ÀÀ: ;
{
ÁÁ 
var
ÂÂ 
vertex
ÂÂ 
=
ÂÂ 
vertices
ÂÂ %
[
ÂÂ% &
i
ÂÂ& '
]
ÂÂ' (
;
ÂÂ( )
if
ÄÄ 
(
ÄÄ 
Math
ÄÄ 
.
ÄÄ 
IsNumber
ÄÄ !
(
ÄÄ! "
vertex
ÄÄ" (
.
ÄÄ( )
position
ÄÄ) 1
)
ÄÄ1 2
&&
ÅÅ 
Math
ÅÅ 
.
ÅÅ 
IsNumber
ÅÅ $
(
ÅÅ$ %
vertex
ÅÅ% +
.
ÅÅ+ ,
color
ÅÅ, 1
)
ÅÅ1 2
&&
ÆÆ 
Math
ÆÆ 
.
ÆÆ 
IsNumber
ÆÆ $
(
ÆÆ$ %
vertex
ÆÆ% +
.
ÆÆ+ ,
uv0
ÆÆ, /
)
ÆÆ/ 0
&&
ÇÇ 
Math
ÇÇ 
.
ÇÇ 
IsNumber
ÇÇ $
(
ÇÇ$ %
vertex
ÇÇ% +
.
ÇÇ+ ,
normal
ÇÇ, 2
)
ÇÇ2 3
&&
ÈÈ 
Math
ÈÈ 
.
ÈÈ 
IsNumber
ÈÈ $
(
ÈÈ$ %
vertex
ÈÈ% +
.
ÈÈ+ ,
tangent
ÈÈ, 3
)
ÈÈ3 4
&&
ÉÉ 
Math
ÉÉ 
.
ÉÉ 
IsNumber
ÉÉ $
(
ÉÉ$ %
vertex
ÉÉ% +
.
ÉÉ+ ,
uv2
ÉÉ, /
)
ÉÉ/ 0
&&
ÊÊ 
Math
ÊÊ 
.
ÊÊ 
IsNumber
ÊÊ $
(
ÊÊ$ %
vertex
ÊÊ% +
.
ÊÊ+ ,
uv3
ÊÊ, /
)
ÊÊ/ 0
&&
ËË 
Math
ËË 
.
ËË 
IsNumber
ËË $
(
ËË$ %
vertex
ËË% +
.
ËË+ ,
uv4
ËË, /
)
ËË/ 0
)
ËË0 1
continue
ÌÌ 
;
ÌÌ 
sb
ÎÎ 
.
ÎÎ 
AppendFormat
ÎÎ 
(
ÎÎ  
$str
ÎÎ  N
,
ÎÎN O
i
ÎÎP Q
,
ÎÎQ R
vertex
ÎÎS Y
.
ÎÎY Z
ToString
ÎÎZ b
(
ÎÎb c
)
ÎÎc d
)
ÎÎd e
;
ÎÎe f
}
ÏÏ 
return
ÑÑ 
sb
ÑÑ 
.
ÑÑ 
ToString
ÑÑ 
(
ÑÑ 
)
ÑÑ  
;
ÑÑ  !
}
ÒÒ 	
}
ÓÓ 
}ÔÔ Èˆ
ˆD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Submesh.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ 
Serializable 
] 
public 

sealed 
class 
Submesh 
{ 
[ 	
SerializeField	 
] 
internal 
int 
[ 
] 
	m_Indexes  
;  !
[ 	
SerializeField	 
] 
internal 
MeshTopology 

m_Topology (
;( )
[ 	
SerializeField	 
] 
internal 
int 
m_SubmeshIndex #
;# $
public 
IEnumerable 
< 
int 
> 
indexes  '
{ 	
get 
{ 
return 
new 
ReadOnlyCollection /
</ 0
int0 3
>3 4
(4 5
	m_Indexes5 >
)> ?
;? @
}A B
set 
{ 
	m_Indexes 
= 
value #
.# $
ToArray$ +
(+ ,
), -
;- .
}/ 0
} 	
public$$ 
MeshTopology$$ 
topology$$ $
{%% 	
get&& 
{&& 
return&& 

m_Topology&& #
;&&# $
}&&% &
set'' 
{'' 

m_Topology'' 
='' 
value'' $
;''$ %
}''& '
}(( 	
public-- 
int-- 
submeshIndex-- 
{.. 	
get// 
{// 
return// 
m_SubmeshIndex// '
;//' (
}//) *
set00 
{00 
m_SubmeshIndex00  
=00! "
value00# (
;00( )
}00* +
}11 	
public99 
Submesh99 
(99 
int99 
submeshIndex99 '
,99' (
MeshTopology99) 5
topology996 >
,99> ?
IEnumerable99@ K
<99K L
int99L O
>99O P
indexes99Q X
)99X Y
{:: 	
if;; 
(;; 
indexes;; 
==;; 
null;; 
);;  
throw<< 
new<< !
ArgumentNullException<< /
(<</ 0
$str<<0 9
)<<9 :
;<<: ;
	m_Indexes>> 
=>> 
indexes>> 
.>>  
ToArray>>  '
(>>' (
)>>( )
;>>) *

m_Topology?? 
=?? 
topology?? !
;??! "
m_SubmeshIndex@@ 
=@@ 
submeshIndex@@ )
;@@) *
}AA 	
publicHH 
SubmeshHH 
(HH 
MeshHH 
meshHH  
,HH  !
intHH" %
subMeshIndexHH& 2
)HH2 3
{II 	
ifJJ 
(JJ 
meshJJ 
==JJ 
nullJJ 
)JJ 
throwKK 
newKK !
ArgumentNullExceptionKK /
(KK/ 0
$strKK0 6
)KK6 7
;KK7 8
	m_IndexesMM 
=MM 
meshMM 
.MM 

GetIndicesMM '
(MM' (
subMeshIndexMM( 4
)MM4 5
;MM5 6

m_TopologyNN 
=NN 
meshNN 
.NN 
GetTopologyNN )
(NN) *
subMeshIndexNN* 6
)NN6 7
;NN7 8
m_SubmeshIndexOO 
=OO 
subMeshIndexOO )
;OO) *
}PP 	
publicRR 
overrideRR 
stringRR 
ToStringRR '
(RR' (
)RR( )
{SS 	
returnTT 
stringTT 
.TT 
FormatTT  
(TT  !
$strTT! 0
,TT0 1
m_SubmeshIndexTT2 @
,TT@ A

m_TopologyTTB L
.TTL M
ToStringTTM U
(TTU V
)TTV W
,TTW X
	m_IndexesTTY b
!=TTc e
nullTTf j
?TTk l
	m_IndexesTTm v
.TTv w
LengthTTw }
.TT} ~
ToString	TT~ †
(
TT† ‡
)
TT‡ ˆ
:
TT‰ Š
$str
TT‹ 
)
TT 
;
TT 
}UU 	
internalWW 
staticWW 
intWW 
GetSubmeshCountWW +
(WW+ ,
ProBuilderMeshWW, :
meshWW; ?
)WW? @
{XX 	
intYY 
countYY 
=YY 
$numYY 
;YY 
foreachZZ 
(ZZ 
varZZ 
faceZZ 
inZZ  
meshZZ! %
.ZZ% &
facesInternalZZ& 3
)ZZ3 4
count[[ 
=[[ 
Math[[ 
.[[ 
Max[[  
([[  !
count[[! &
,[[& '
face[[( ,
.[[, -
submeshIndex[[- 9
)[[9 :
;[[: ;
return\\ 
count\\ 
+\\ 
$num\\ 
;\\ 
}]] 	
publicgg 
staticgg 
Submeshgg 
[gg 
]gg 
GetSubmeshesgg  ,
(gg, -
IEnumerablegg- 8
<gg8 9
Facegg9 =
>gg= >
facesgg? D
,ggD E
intggF I
submeshCountggJ V
,ggV W
MeshTopologyggX d
preferredTopologygge v
=ggw x
MeshTopology	ggy …
.
gg… †
	Triangles
gg† 
)
gg 
{hh 	
ifii 
(ii 
preferredTopologyii !
!=ii" $
MeshTopologyii% 1
.ii1 2
	Trianglesii2 ;
&&ii< >
preferredTopologyii? P
!=iiQ S
MeshTopologyiiT `
.ii` a
Quadsiia f
)iif g
throwjj 
newjj 
Systemjj  
.jj  !#
NotImplementedExceptionjj! 8
(jj8 9
$strjj9 l
)jjl m
;jjm n
ifll 
(ll 
facesll 
==ll 
nullll 
)ll 
throwmm 
newmm !
ArgumentNullExceptionmm /
(mm/ 0
$strmm0 7
)mm7 8
;mm8 9
booloo 

wantsQuadsoo 
=oo 
preferredTopologyoo /
==oo0 2
MeshTopologyoo3 ?
.oo? @
Quadsoo@ E
;ooE F
Listqq 
<qq 
intqq 
>qq 
[qq 
]qq 
quadsqq 
=qq 

wantsQuadsqq  *
?qq+ ,
newqq- 0
Listqq1 5
<qq5 6
intqq6 9
>qq9 :
[qq: ;
submeshCountqq; G
]qqG H
:qqI J
nullqqK O
;qqO P
Listrr 
<rr 
intrr 
>rr 
[rr 
]rr 
trisrr 
=rr 
newrr "
Listrr# '
<rr' (
intrr( +
>rr+ ,
[rr, -
submeshCountrr- 9
]rr9 :
;rr: ;
intss 
maxSubmeshIndexss 
=ss  !
submeshCountss" .
-ss/ 0
$numss1 2
;ss2 3
foruu 
(uu 
intuu 
iuu 
=uu 
$numuu 
;uu 
iuu 
<uu 
submeshCountuu  ,
;uu, -
iuu. /
++uu/ 1
)uu1 2
{vv 
ifww 
(ww 

wantsQuadsww 
)ww 
quadsxx 
[xx 
ixx 
]xx 
=xx 
newxx "
Listxx# '
<xx' (
intxx( +
>xx+ ,
(xx, -
)xx- .
;xx. /
triszz 
[zz 
izz 
]zz 
=zz 
newzz 
Listzz "
<zz" #
intzz# &
>zz& '
(zz' (
)zz( )
;zz) *
}{{ 
foreach}} 
(}} 
var}} 
face}} 
in}}  
faces}}! &
)}}& '
{~~ 
if 
( 
face 
. 
indexesInternal (
==) +
null, 0
||1 3
face4 8
.8 9
indexesInternal9 H
.H I
LengthI O
<P Q
$numR S
)S T
continue
€€ 
;
€€ 
int
‚‚ 
submeshIndex
‚‚  
=
‚‚! "
Math
‚‚# '
.
‚‚' (
Clamp
‚‚( -
(
‚‚- .
face
‚‚. 2
.
‚‚2 3
submeshIndex
‚‚3 ?
,
‚‚? @
$num
‚‚A B
,
‚‚B C
maxSubmeshIndex
‚‚D S
)
‚‚S T
;
‚‚T U
if
„„ 
(
„„ 

wantsQuads
„„ 
&&
„„ !
face
„„" &
.
„„& '
IsQuad
„„' -
(
„„- .
)
„„. /
)
„„/ 0
quads
…… 
[
…… 
submeshIndex
…… &
]
……& '
.
……' (
AddRange
……( 0
(
……0 1
face
……1 5
.
……5 6
ToQuad
……6 <
(
……< =
)
……= >
)
……> ?
;
……? @
else
†† 
tris
‡‡ 
[
‡‡ 
submeshIndex
‡‡ %
]
‡‡% &
.
‡‡& '
AddRange
‡‡' /
(
‡‡/ 0
face
‡‡0 4
.
‡‡4 5
indexesInternal
‡‡5 D
)
‡‡D E
;
‡‡E F
}
ˆˆ 
var
ŠŠ 
	submeshes
ŠŠ 
=
ŠŠ 
new
ŠŠ 
Submesh
ŠŠ  '
[
ŠŠ' (
submeshCount
ŠŠ( 4
]
ŠŠ4 5
;
ŠŠ5 6
switch
ŒŒ 
(
ŒŒ 
preferredTopology
ŒŒ %
)
ŒŒ% &
{
 
case
 
MeshTopology
 !
.
! "
	Triangles
" +
:
+ ,
{
 
for
 
(
 
int
 
submeshIndex
 )
=
* +
$num
, -
;
- .
submeshIndex
/ ;
<
< =
submeshCount
> J
;
J K
submeshIndex
L X
++
X Z
)
Z [
	submeshes
‘‘ !
[
‘‘! "
submeshIndex
‘‘" .
]
‘‘. /
=
‘‘0 1
new
‘‘2 5
Submesh
‘‘6 =
(
‘‘= >
submeshIndex
‘‘> J
,
‘‘J K
MeshTopology
‘‘L X
.
‘‘X Y
	Triangles
‘‘Y b
,
‘‘b c
tris
‘‘d h
[
‘‘h i
submeshIndex
‘‘i u
]
‘‘u v
)
‘‘v w
;
‘‘w x
break
’’ 
;
’’ 
}
““ 
case
•• 
MeshTopology
•• !
.
••! "
Quads
••" '
:
••' (
{
–– 
for
—— 
(
—— 
int
—— 
submeshIndex
—— )
=
——* +
$num
——, -
;
——- .
submeshIndex
——/ ;
<
——< =
submeshCount
——> J
;
——J K
submeshIndex
——L X
++
——X Z
)
——Z [
{
˜˜ 
if
šš 
(
šš 
tris
šš  
[
šš  !
submeshIndex
šš! -
]
šš- .
.
šš. /
Count
šš/ 4
>
šš5 6
$num
šš7 8
)
šš8 9
{
›› 
var
œœ 
tri
œœ  #
=
œœ$ %
tris
œœ& *
[
œœ* +
submeshIndex
œœ+ 7
]
œœ7 8
;
œœ8 9
var
 
quad
  $
=
% &
quads
' ,
[
, -
submeshIndex
- 9
]
9 :
;
: ;
int
ŸŸ 
triCount
ŸŸ  (
=
ŸŸ) *
tri
ŸŸ+ .
.
ŸŸ. /
Count
ŸŸ/ 4
;
ŸŸ4 5
int
   
	quadCount
    )
=
  * +
quad
  , 0
.
  0 1
Count
  1 6
;
  6 7
int
¢¢ 
[
¢¢  
]
¢¢  !
	triangles
¢¢" +
=
¢¢, -
new
¢¢. 1
int
¢¢2 5
[
¢¢5 6
triCount
¢¢6 >
+
¢¢? @
(
¢¢A B
(
¢¢B C
	quadCount
¢¢C L
/
¢¢M N
$num
¢¢O P
)
¢¢P Q
*
¢¢R S
$num
¢¢T U
)
¢¢U V
]
¢¢V W
;
¢¢W X
for
¤¤ 
(
¤¤  !
int
¤¤! $
i
¤¤% &
=
¤¤' (
$num
¤¤) *
;
¤¤* +
i
¤¤, -
<
¤¤. /
triCount
¤¤0 8
;
¤¤8 9
i
¤¤: ;
++
¤¤; =
)
¤¤= >
	triangles
¥¥  )
[
¥¥) *
i
¥¥* +
]
¥¥+ ,
=
¥¥- .
tri
¥¥/ 2
[
¥¥2 3
i
¥¥3 4
]
¥¥4 5
;
¥¥5 6
for
§§ 
(
§§  !
int
§§! $
i
§§% &
=
§§' (
$num
§§) *
,
§§* +
n
§§, -
=
§§. /
triCount
§§0 8
;
§§8 9
i
§§: ;
<
§§< =
	quadCount
§§> G
;
§§G H
i
§§I J
+=
§§K M
$num
§§N O
,
§§O P
n
§§Q R
+=
§§S U
$num
§§V W
)
§§W X
{
¨¨ 
	triangles
©©  )
[
©©) *
n
©©* +
+
©©, -
$num
©©. /
]
©©/ 0
=
©©1 2
quad
©©3 7
[
©©7 8
i
©©8 9
+
©©: ;
$num
©©< =
]
©©= >
;
©©> ?
	triangles
ªª  )
[
ªª) *
n
ªª* +
+
ªª, -
$num
ªª. /
]
ªª/ 0
=
ªª1 2
quad
ªª3 7
[
ªª7 8
i
ªª8 9
+
ªª: ;
$num
ªª< =
]
ªª= >
;
ªª> ?
	triangles
««  )
[
««) *
n
««* +
+
««, -
$num
««. /
]
««/ 0
=
««1 2
quad
««3 7
[
««7 8
i
««8 9
+
««: ;
$num
««< =
]
««= >
;
««> ?
	triangles
­­  )
[
­­) *
n
­­* +
+
­­, -
$num
­­. /
]
­­/ 0
=
­­1 2
quad
­­3 7
[
­­7 8
i
­­8 9
+
­­: ;
$num
­­< =
]
­­= >
;
­­> ?
	triangles
®®  )
[
®®) *
n
®®* +
+
®®, -
$num
®®. /
]
®®/ 0
=
®®1 2
quad
®®3 7
[
®®7 8
i
®®8 9
+
®®: ;
$num
®®< =
]
®®= >
;
®®> ?
	triangles
¯¯  )
[
¯¯) *
n
¯¯* +
+
¯¯, -
$num
¯¯. /
]
¯¯/ 0
=
¯¯1 2
quad
¯¯3 7
[
¯¯7 8
i
¯¯8 9
+
¯¯: ;
$num
¯¯< =
]
¯¯= >
;
¯¯> ?
}
°° 
	submeshes
²² %
[
²²% &
submeshIndex
²²& 2
]
²²2 3
=
²²4 5
new
²²6 9
Submesh
²²: A
(
²²A B
submeshIndex
²²B N
,
²²N O
MeshTopology
²²P \
.
²²\ ]
	Triangles
²²] f
,
²²f g
	triangles
²²h q
)
²²q r
;
²²r s
}
³³ 
else
´´ 
{
µµ 
	submeshes
¶¶ %
[
¶¶% &
submeshIndex
¶¶& 2
]
¶¶2 3
=
¶¶4 5
new
¶¶6 9
Submesh
¶¶: A
(
¶¶A B
submeshIndex
¶¶B N
,
¶¶N O
MeshTopology
¶¶P \
.
¶¶\ ]
Quads
¶¶] b
,
¶¶b c
quads
¶¶d i
[
¶¶i j
submeshIndex
¶¶j v
]
¶¶v w
)
¶¶w x
;
¶¶x y
}
·· 
}
¸¸ 
break
¹¹ 
;
¹¹ 
}
ºº 
}
»» 
return
½½ 
	submeshes
½½ 
;
½½ 
}
¾¾ 	
internal
ÀÀ 
static
ÀÀ 
void
ÀÀ ,
MapFaceMaterialsToSubmeshIndex
ÀÀ ;
(
ÀÀ; <
ProBuilderMesh
ÀÀ< J
mesh
ÀÀK O
)
ÀÀO P
{
ÁÁ 	
var
ÂÂ 
	materials
ÂÂ 
=
ÂÂ 
mesh
ÂÂ  
.
ÂÂ  !
renderer
ÂÂ! )
.
ÂÂ) *
sharedMaterials
ÂÂ* 9
;
ÂÂ9 :
var
ÃÃ 
submeshCount
ÃÃ 
=
ÃÃ 
	materials
ÃÃ (
.
ÃÃ( )
Length
ÃÃ) /
;
ÃÃ/ 0
foreach
ÅÅ 
(
ÅÅ 
var
ÅÅ 
face
ÅÅ 
in
ÅÅ  
mesh
ÅÅ! %
.
ÅÅ% &
facesInternal
ÅÅ& 3
)
ÅÅ3 4
{
ÆÆ 
if
ÈÈ 
(
ÈÈ 
face
ÈÈ 
.
ÈÈ 
material
ÈÈ !
==
ÈÈ" $
null
ÈÈ% )
)
ÈÈ) *
continue
ÉÉ 
;
ÉÉ 
var
ÊÊ 
index
ÊÊ 
=
ÊÊ 
Array
ÊÊ !
.
ÊÊ! "
IndexOf
ÊÊ" )
(
ÊÊ) *
	materials
ÊÊ* 3
,
ÊÊ3 4
face
ÊÊ5 9
.
ÊÊ9 :
material
ÊÊ: B
)
ÊÊB C
;
ÊÊC D
face
ËË 
.
ËË 
submeshIndex
ËË !
=
ËË" #
Math
ËË$ (
.
ËË( )
Clamp
ËË) .
(
ËË. /
index
ËË/ 4
,
ËË4 5
$num
ËË6 7
,
ËË7 8
submeshCount
ËË9 E
-
ËËF G
$num
ËËH I
)
ËËI J
;
ËËJ K
face
ÌÌ 
.
ÌÌ 
material
ÌÌ 
=
ÌÌ 
null
ÌÌ  $
;
ÌÌ$ %
}
ÎÎ 
}
ÏÏ 	
}
ĞĞ 
}ÑÑ ê/
ˆD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\IntVec3.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
struct 

IntVec3 
: 
System 
. 

IEquatable &
<& '
IntVec3' .
>. /
{		 
public

 
Vector3

 
value

 
;

 
public 
float 
x 
{ 
get 
{ 
return %
value& +
.+ ,
x, -
;- .
}/ 0
}1 2
public 
float 
y 
{ 
get 
{ 
return %
value& +
.+ ,
y, -
;- .
}/ 0
}1 2
public 
float 
z 
{ 
get 
{ 
return %
value& +
.+ ,
z, -
;- .
}/ 0
}1 2
public 
IntVec3 
( 
Vector3 
vector %
)% &
{ 	
this 
. 
value 
= 
vector 
;  
} 	
public 
override 
string 
ToString '
(' (
)( )
{ 	
return 
string 
. 
Format  
(  !
$str! ;
,; <
x= >
,> ?
y@ A
,A B
zC D
)D E
;E F
} 	
public 
static 
bool 
operator #
==# %
(% &
IntVec3& -
a. /
,/ 0
IntVec31 8
b9 :
): ;
{ 	
return 
a 
. 
Equals 
( 
b 
) 
; 
} 	
public 
static 
bool 
operator #
!=# %
(% &
IntVec3& -
a. /
,/ 0
IntVec31 8
b9 :
): ;
{   	
return!! 
!!! 
(!! 
a!! 
==!! 
b!! 
)!! 
;!! 
}"" 	
public$$ 
bool$$ 
Equals$$ 
($$ 
IntVec3$$ "
p$$# $
)$$$ %
{%% 	
return&& 
round&& 
(&& 
x&& 
)&& 
==&& 
round&& $
(&&$ %
p&&% &
.&&& '
x&&' (
)&&( )
&&&&* ,
round'' 
('' 
y'' 
)'' 
=='' 
round'' !
(''! "
p''" #
.''# $
y''$ %
)''% &
&&''' )
round(( 
((( 
z(( 
)(( 
==(( 
round(( !
(((! "
p((" #
.((# $
z(($ %
)((% &
;((& '
})) 	
public++ 
bool++ 
Equals++ 
(++ 
Vector3++ "
p++# $
)++$ %
{,, 	
return-- 
round-- 
(-- 
x-- 
)-- 
==-- 
round-- $
(--$ %
p--% &
.--& '
x--' (
)--( )
&&--* ,
round.. 
(.. 
y.. 
).. 
==.. 
round.. !
(..! "
p.." #
...# $
y..$ %
)..% &
&&..' )
round// 
(// 
z// 
)// 
==// 
round// !
(//! "
p//" #
.//# $
z//$ %
)//% &
;//& '
}00 	
public22 
override22 
bool22 
Equals22 #
(22# $
System22$ *
.22* +
Object22+ 1
b222 3
)223 4
{33 	
return44 
(44 
b44 
is44 
IntVec344  
&&44! #
(44$ %
this44% )
.44) *
Equals44* 0
(440 1
(441 2
IntVec3442 9
)449 :
b44: ;
)44; <
)44< =
)44= >
||44? A
(55 
b55 
is55 
Vector355 
&&55  
this55! %
.55% &
Equals55& ,
(55, -
(55- .
Vector355. 5
)555 6
b556 7
)557 8
)558 9
;559 :
}66 	
public88 
override88 
int88 
GetHashCode88 '
(88' (
)88( )
{99 	
return:: 

VectorHash:: 
.:: 
GetHashCode:: )
(::) *
value::* /
)::/ 0
;::0 1
};; 	
private== 
static== 
int== 
round==  
(==  !
float==! &
v==' (
)==( )
{>> 	
return?? 
System?? 
.?? 
Convert?? !
.??! "
ToInt32??" )
(??) *
v??* +
*??, -

VectorHash??. 8
.??8 9 
FltCompareResolution??9 M
)??M N
;??N O
}@@ 	
publicBB 
staticBB 
implicitBB 
operatorBB '
Vector3BB( /
(BB/ 0
IntVec3BB0 7
pBB8 9
)BB9 :
{CC 	
returnDD 
pDD 
.DD 
valueDD 
;DD 
}EE 	
publicGG 
staticGG 
implicitGG 
operatorGG '
IntVec3GG( /
(GG/ 0
Vector3GG0 7
pGG8 9
)GG9 :
{HH 	
returnII 
newII 
IntVec3II 
(II 
pII  
)II  !
;II! "
}JJ 	
}KK 
}LL õé
…D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Math.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public		 

static		 
class		 
Math		 
{

 
public 
const 
float 
phi 
=  
$num! 3
;3 4
const 
float 
k_FltEpsilon  
=! "
float# (
.( )
Epsilon) 0
;0 1
const 
float 
k_FltCompareEpsilon '
=( )
$num* 0
;0 1
internal 
const 
float 
handleEpsilon *
=+ ,
$num- 3
;3 4
internal&& 
static&& 
Vector2&&  
PointInCircumference&&  4
(&&4 5
float&&5 :
radius&&; A
,&&A B
float&&C H
angleInDegrees&&I W
,&&W X
Vector2&&Y `
origin&&a g
)&&g h
{'' 	
float)) 
x)) 
=)) 
()) 
float)) 
))) 
()) 
radius)) $
*))% &
Mathf))' ,
.)), -
Cos))- 0
())0 1
Mathf))1 6
.))6 7
Deg2Rad))7 >
*))? @
angleInDegrees))A O
)))O P
)))P Q
+))R S
origin))T Z
.))Z [
x))[ \
;))\ ]
float** 
y** 
=** 
(** 
float** 
)** 
(** 
radius** $
***% &
Mathf**' ,
.**, -
Sin**- 0
(**0 1
Mathf**1 6
.**6 7
Deg2Rad**7 >
***? @
angleInDegrees**A O
)**O P
)**P Q
+**R S
origin**T Z
.**Z [
y**[ \
;**\ ]
return,, 
new,, 
Vector2,, 
(,, 
x,,  
,,,  !
y,," #
),,# $
;,,$ %
}-- 	
internal66 
static66 
Vector366 
PointInSphere66  -
(66- .
float66. 3
radius664 :
,66: ;
float66< A
latitudeAngle66B O
,66O P
float66Q V
longitudeAngle66W e
)66e f
{77 	
float88 
x88 
=88 
(88 
radius88 
*88 
Mathf88  %
.88% &
Cos88& )
(88) *
Mathf88* /
.88/ 0
Deg2Rad880 7
*888 9
latitudeAngle88: G
)88G H
*88I J
Mathf88K P
.88P Q
Sin88Q T
(88T U
Mathf88U Z
.88Z [
Deg2Rad88[ b
*88c d
longitudeAngle88e s
)88s t
)88t u
;88u v
float99 
y99 
=99 
(99 
radius99 
*99 
Mathf99  %
.99% &
Sin99& )
(99) *
Mathf99* /
.99/ 0
Deg2Rad990 7
*998 9
latitudeAngle99: G
)99G H
*99I J
Mathf99K P
.99P Q
Sin99Q T
(99T U
Mathf99U Z
.99Z [
Deg2Rad99[ b
*99c d
longitudeAngle99e s
)99s t
)99t u
;99u v
float:: 
z:: 
=:: 
(:: 
radius:: 
*:: 
Mathf::  %
.::% &
Cos::& )
(::) *
Mathf::* /
.::/ 0
Deg2Rad::0 7
*::8 9
longitudeAngle::: H
)::H I
)::I J
;::J K
return<< 
new<< 
Vector3<< 
(<< 
x<<  
,<<  !
y<<" #
,<<# $
z<<% &
)<<& '
;<<' (
}== 	
internalEE 
staticEE 
floatEE 
SignedAngleEE )
(EE) *
Vector2EE* 1
aEE2 3
,EE3 4
Vector2EE5 <
bEE= >
)EE> ?
{FF 	
floatGG 
tGG 
=GG 
Vector2GG 
.GG 
AngleGG #
(GG# $
aGG$ %
,GG% &
bGG' (
)GG( )
;GG) *
ifHH 
(HH 
bHH 
.HH 
xHH 
-HH 
aHH 
.HH 
xHH 
<HH 
$numHH 
)HH 
tII 
=II 
$numII 
-II 
tII 
;II 
returnJJ 
tJJ 
;JJ 
}KK 	
publicSS 
staticSS 
floatSS 
SqrDistanceSS '
(SS' (
Vector3SS( /
aSS0 1
,SS1 2
Vector3SS3 :
bSS; <
)SS< =
{TT 	
floatUU 
dxUU 
=UU 
bUU 
.UU 
xUU 
-UU 
aUU 
.UU 
xUU  
,UU  !
dyVV 
=VV 
bVV 
.VV 
yVV 
-VV 
aVV 
.VV 
yVV  
,VV  !
dzWW 
=WW 
bWW 
.WW 
zWW 
-WW 
aWW 
.WW 
zWW  
;WW  !
returnXX 
dxXX 
*XX 
dxXX 
+XX 
dyXX 
*XX  !
dyXX" $
+XX% &
dzXX' )
*XX* +
dzXX, .
;XX. /
}YY 	
publiccc 
staticcc 
floatcc 
TriangleAreacc (
(cc( )
Vector3cc) 0
xcc1 2
,cc2 3
Vector3cc4 ;
ycc< =
,cc= >
Vector3cc? F
zccG H
)ccH I
{dd 	
floatee 
aee 
=ee 
SqrDistanceee #
(ee# $
xee$ %
,ee% &
yee' (
)ee( )
,ee) *
bff 
=ff 
SqrDistanceff #
(ff# $
yff$ %
,ff% &
zff' (
)ff( )
,ff) *
cgg 
=gg 
SqrDistancegg #
(gg# $
zgg$ %
,gg% &
xgg' (
)gg( )
;gg) *
returnii 
Mathfii 
.ii 
Sqrtii 
(ii 
(ii 
$numii !
*ii" #
aii$ %
*ii& '
bii( )
+ii* +
$numii, .
*ii/ 0
bii1 2
*ii3 4
cii5 6
+ii7 8
$numii9 ;
*ii< =
cii> ?
*ii@ A
aiiB C
-iiD E
aiiF G
*iiH I
aiiJ K
-iiL M
biiN O
*iiP Q
biiR S
-iiT U
ciiV W
*iiX Y
ciiZ [
)ii[ \
/ii] ^
$numii_ b
)iib c
;iic d
}jj 	
internalrr 
staticrr 
floatrr 
PolygonArearr )
(rr) *
Vector3rr* 1
[rr1 2
]rr2 3
verticesrr4 <
,rr< =
intrr> A
[rrA B
]rrB C
indexesrrD K
)rrK L
{ss 	
floattt 
areatt 
=tt 
$numtt 
;tt 
forvv 
(vv 
intvv 
ivv 
=vv 
$numvv 
;vv 
ivv 
<vv 
indexesvv  '
.vv' (
Lengthvv( .
;vv. /
ivv0 1
+=vv2 4
$numvv5 6
)vv6 7
areaww 
+=ww 
TriangleAreaww $
(ww$ %
verticesww% -
[ww- .
indexesww. 5
[ww5 6
iww6 7
]ww7 8
]ww8 9
,ww9 :
verticesww; C
[wwC D
indexeswwD K
[wwK L
iwwL M
+wwN O
$numwwP Q
]wwQ R
]wwR S
,wwS T
verticeswwU ]
[ww] ^
indexesww^ e
[wwe f
iwwf g
+wwh i
$numwwj k
]wwk l
]wwl m
)wwm n
;wwn o
returnyy 
areayy 
;yy 
}zz 	
internal
ƒƒ 
static
ƒƒ 
Vector2
ƒƒ 
RotateAroundPoint
ƒƒ  1
(
ƒƒ1 2
this
ƒƒ2 6
Vector2
ƒƒ7 >
v
ƒƒ? @
,
ƒƒ@ A
Vector2
ƒƒB I
origin
ƒƒJ P
,
ƒƒP Q
float
ƒƒR W
theta
ƒƒX ]
)
ƒƒ] ^
{
„„ 	
float
…… 
cx
…… 
=
…… 
origin
…… 
.
…… 
x
…… 
,
……  
cy
……! #
=
……$ %
origin
……& ,
.
……, -
y
……- .
;
……. /
float
†† 
px
†† 
=
†† 
v
†† 
.
†† 
x
†† 
,
†† 
py
†† 
=
††  
v
††! "
.
††" #
y
††# $
;
††$ %
float
ˆˆ 
s
ˆˆ 
=
ˆˆ 
Mathf
ˆˆ 
.
ˆˆ 
Sin
ˆˆ 
(
ˆˆ  
theta
ˆˆ  %
*
ˆˆ& '
Mathf
ˆˆ( -
.
ˆˆ- .
Deg2Rad
ˆˆ. 5
)
ˆˆ5 6
;
ˆˆ6 7
float
‰‰ 
c
‰‰ 
=
‰‰ 
Mathf
‰‰ 
.
‰‰ 
Cos
‰‰ 
(
‰‰  
theta
‰‰  %
*
‰‰& '
Mathf
‰‰( -
.
‰‰- .
Deg2Rad
‰‰. 5
)
‰‰5 6
;
‰‰6 7
px
ŒŒ 
-=
ŒŒ 
cx
ŒŒ 
;
ŒŒ 
py
 
-=
 
cy
 
;
 
float
 
xnew
 
=
 
px
 
*
 
c
 
+
  !
py
" $
*
% &
s
' (
;
( )
float
‘‘ 
ynew
‘‘ 
=
‘‘ 
-
‘‘ 
px
‘‘ 
*
‘‘ 
s
‘‘  
+
‘‘! "
py
‘‘# %
*
‘‘& '
c
‘‘( )
;
‘‘) *
px
”” 
=
”” 
xnew
”” 
+
”” 
cx
”” 
;
”” 
py
•• 
=
•• 
ynew
•• 
+
•• 
cy
•• 
;
•• 
return
—— 
new
—— 
Vector2
—— 
(
—— 
px
—— !
,
——! "
py
——# %
)
——% &
;
——& '
}
˜˜ 	
public
¡¡ 
static
¡¡ 
Vector2
¡¡ 
ScaleAroundPoint
¡¡ .
(
¡¡. /
this
¡¡/ 3
Vector2
¡¡4 ;
v
¡¡< =
,
¡¡= >
Vector2
¡¡? F
origin
¡¡G M
,
¡¡M N
Vector2
¡¡O V
scale
¡¡W \
)
¡¡\ ]
{
¢¢ 	
Vector2
££ 
tp
££ 
=
££ 
v
££ 
-
££ 
origin
££ #
;
££# $
tp
¤¤ 
=
¤¤ 
Vector2
¤¤ 
.
¤¤ 
Scale
¤¤ 
(
¤¤ 
tp
¤¤ !
,
¤¤! "
scale
¤¤# (
)
¤¤( )
;
¤¤) *
tp
¥¥ 
+=
¥¥ 
origin
¥¥ 
;
¥¥ 
return
§§ 
tp
§§ 
;
§§ 
}
¨¨ 	
internal
ªª 
static
ªª 
Vector2
ªª 
Perpendicular
ªª  -
(
ªª- .
Vector2
ªª. 5
value
ªª6 ;
)
ªª; <
{
«« 	
return
¬¬ 
new
¬¬ 
Vector2
¬¬ 
(
¬¬ 
-
¬¬  
value
¬¬  %
.
¬¬% &
y
¬¬& '
,
¬¬' (
value
¬¬) .
.
¬¬. /
x
¬¬/ 0
)
¬¬0 1
;
¬¬1 2
}
­­ 	
public
¶¶ 
static
¶¶ 
Vector2
¶¶ 
ReflectPoint
¶¶ *
(
¶¶* +
Vector2
¶¶+ 2
point
¶¶3 8
,
¶¶8 9
Vector2
¶¶: A
	lineStart
¶¶B K
,
¶¶K L
Vector2
¶¶M T
lineEnd
¶¶U \
)
¶¶\ ]
{
·· 	
Vector2
¸¸ 
line
¸¸ 
=
¸¸ 
lineEnd
¸¸ "
-
¸¸# $
	lineStart
¸¸% .
;
¸¸. /
Vector2
¹¹ 
perp
¹¹ 
=
¹¹ 
new
¹¹ 
Vector2
¹¹ &
(
¹¹& '
-
¹¹' (
line
¹¹( ,
.
¹¹, -
y
¹¹- .
,
¹¹. /
line
¹¹0 4
.
¹¹4 5
x
¹¹5 6
)
¹¹6 7
;
¹¹7 8
float
»» 
dist
»» 
=
»» 
Mathf
»» 
.
»» 
Sin
»» "
(
»»" #
Vector2
»»# *
.
»»* +
Angle
»»+ 0
(
»»0 1
line
»»1 5
,
»»5 6
point
»»7 <
-
»»= >
	lineStart
»»? H
)
»»H I
*
»»J K
Mathf
»»L Q
.
»»Q R
Deg2Rad
»»R Y
)
»»Y Z
*
»»[ \
Vector2
»»] d
.
»»d e
Distance
»»e m
(
»»m n
point
»»n s
,
»»s t
	lineStart
»»u ~
)
»»~ 
;»» €
return
½½ 
point
½½ 
+
½½ 
perp
½½ 
*
½½  !
(
½½" #
dist
½½# '
*
½½( )
$num
½½* ,
)
½½, -
*
½½. /
(
½½0 1
Vector2
½½1 8
.
½½8 9
Dot
½½9 <
(
½½< =
point
½½= B
-
½½C D
	lineStart
½½E N
,
½½N O
perp
½½P T
)
½½T U
>
½½V W
$num
½½X Y
?
½½Z [
-
½½\ ]
$num
½½] _
:
½½` a
$num
½½b d
)
½½d e
;
½½e f
}
¾¾ 	
internal
ÀÀ 
static
ÀÀ 
float
ÀÀ !
SqrDistanceRayPoint
ÀÀ 1
(
ÀÀ1 2
Ray
ÀÀ2 5
ray
ÀÀ6 9
,
ÀÀ9 :
Vector3
ÀÀ; B
point
ÀÀC H
)
ÀÀH I
{
ÁÁ 	
return
ÂÂ 
Vector3
ÂÂ 
.
ÂÂ 
Cross
ÂÂ  
(
ÂÂ  !
ray
ÂÂ! $
.
ÂÂ$ %
	direction
ÂÂ% .
,
ÂÂ. /
point
ÂÂ0 5
-
ÂÂ6 7
ray
ÂÂ8 ;
.
ÂÂ; <
origin
ÂÂ< B
)
ÂÂB C
.
ÂÂC D
sqrMagnitude
ÂÂD P
;
ÂÂP Q
}
ÃÃ 	
public
ÍÍ 
static
ÍÍ 
float
ÍÍ &
DistancePointLineSegment
ÍÍ 4
(
ÍÍ4 5
Vector2
ÍÍ5 <
point
ÍÍ= B
,
ÍÍB C
Vector2
ÍÍD K
	lineStart
ÍÍL U
,
ÍÍU V
Vector2
ÍÍW ^
lineEnd
ÍÍ_ f
)
ÍÍf g
{
ÎÎ 	
float
ĞĞ 
l2
ĞĞ 
=
ĞĞ 
(
ĞĞ 
(
ĞĞ 
	lineStart
ĞĞ "
.
ĞĞ" #
x
ĞĞ# $
-
ĞĞ% &
lineEnd
ĞĞ' .
.
ĞĞ. /
x
ĞĞ/ 0
)
ĞĞ0 1
*
ĞĞ2 3
(
ĞĞ4 5
	lineStart
ĞĞ5 >
.
ĞĞ> ?
x
ĞĞ? @
-
ĞĞA B
lineEnd
ĞĞC J
.
ĞĞJ K
x
ĞĞK L
)
ĞĞL M
)
ĞĞM N
+
ĞĞO P
(
ĞĞQ R
(
ĞĞR S
	lineStart
ĞĞS \
.
ĞĞ\ ]
y
ĞĞ] ^
-
ĞĞ_ `
lineEnd
ĞĞa h
.
ĞĞh i
y
ĞĞi j
)
ĞĞj k
*
ĞĞl m
(
ĞĞn o
	lineStart
ĞĞo x
.
ĞĞx y
y
ĞĞy z
-
ĞĞ{ |
lineEndĞĞ} „
.ĞĞ„ …
yĞĞ… †
)ĞĞ† ‡
)ĞĞ‡ ˆ
;ĞĞˆ ‰
if
ÒÒ 
(
ÒÒ 
l2
ÒÒ 
==
ÒÒ 
$num
ÒÒ 
)
ÒÒ 
return
ÒÒ "
Vector2
ÒÒ# *
.
ÒÒ* +
Distance
ÒÒ+ 3
(
ÒÒ3 4
point
ÒÒ4 9
,
ÒÒ9 :
	lineStart
ÒÒ; D
)
ÒÒD E
;
ÒÒE F
float
×× 
t
×× 
=
×× 
Vector2
×× 
.
×× 
Dot
×× !
(
××! "
point
××" '
-
××( )
	lineStart
××* 3
,
××3 4
lineEnd
××5 <
-
××= >
	lineStart
××? H
)
××H I
/
××J K
l2
××L N
;
××N O
if
ÙÙ 
(
ÙÙ 
t
ÙÙ 
<
ÙÙ 
$num
ÙÙ 
)
ÙÙ 
return
ÚÚ 
Vector2
ÚÚ 
.
ÚÚ 
Distance
ÚÚ '
(
ÚÚ' (
point
ÚÚ( -
,
ÚÚ- .
	lineStart
ÚÚ/ 8
)
ÚÚ8 9
;
ÚÚ9 :
else
ÛÛ 
if
ÛÛ 
(
ÛÛ 
t
ÛÛ 
>
ÛÛ 
$num
ÛÛ 
)
ÛÛ 
return
ÜÜ 
Vector2
ÜÜ 
.
ÜÜ 
Distance
ÜÜ '
(
ÜÜ' (
point
ÜÜ( -
,
ÜÜ- .
lineEnd
ÜÜ/ 6
)
ÜÜ6 7
;
ÜÜ7 8
Vector2
ŞŞ 

projection
ŞŞ 
=
ŞŞ  
	lineStart
ŞŞ! *
+
ŞŞ+ ,
t
ŞŞ- .
*
ŞŞ/ 0
(
ŞŞ1 2
lineEnd
ŞŞ2 9
-
ŞŞ: ;
	lineStart
ŞŞ< E
)
ŞŞE F
;
ŞŞF G
return
àà 
Vector2
àà 
.
àà 
Distance
àà #
(
àà# $
point
àà$ )
,
àà) *

projection
àà+ 5
)
àà5 6
;
àà6 7
}
áá 	
public
ëë 
static
ëë 
float
ëë &
DistancePointLineSegment
ëë 4
(
ëë4 5
Vector3
ëë5 <
point
ëë= B
,
ëëB C
Vector3
ëëD K
	lineStart
ëëL U
,
ëëU V
Vector3
ëëW ^
lineEnd
ëë_ f
)
ëëf g
{
ìì 	
float
îî 
l2
îî 
=
îî 
(
îî 
(
îî 
	lineStart
îî "
.
îî" #
x
îî# $
-
îî% &
lineEnd
îî' .
.
îî. /
x
îî/ 0
)
îî0 1
*
îî2 3
(
îî4 5
	lineStart
îî5 >
.
îî> ?
x
îî? @
-
îîA B
lineEnd
îîC J
.
îîJ K
x
îîK L
)
îîL M
)
îîM N
+
îîO P
(
îîQ R
(
îîR S
	lineStart
îîS \
.
îî\ ]
y
îî] ^
-
îî_ `
lineEnd
îîa h
.
îîh i
y
îîi j
)
îîj k
*
îîl m
(
îîn o
	lineStart
îîo x
.
îîx y
y
îîy z
-
îî{ |
lineEndîî} „
.îî„ …
yîî… †
)îî† ‡
)îî‡ ˆ
+îî‰ Š
(îî‹ Œ
(îîŒ 
	lineStartîî –
.îî– —
zîî— ˜
-îî™ š
lineEndîî› ¢
.îî¢ £
zîî£ ¤
)îî¤ ¥
*îî¦ §
(îî¨ ©
	lineStartîî© ²
.îî² ³
zîî³ ´
-îîµ ¶
lineEndîî· ¾
.îî¾ ¿
zîî¿ À
)îîÀ Á
)îîÁ Â
;îîÂ Ã
if
ğğ 
(
ğğ 
l2
ğğ 
==
ğğ 
$num
ğğ 
)
ğğ 
return
ğğ "
Vector3
ğğ# *
.
ğğ* +
Distance
ğğ+ 3
(
ğğ3 4
point
ğğ4 9
,
ğğ9 :
	lineStart
ğğ; D
)
ğğD E
;
ğğE F
float
õõ 
t
õõ 
=
õõ 
Vector3
õõ 
.
õõ 
Dot
õõ !
(
õõ! "
point
õõ" '
-
õõ( )
	lineStart
õõ* 3
,
õõ3 4
lineEnd
õõ5 <
-
õõ= >
	lineStart
õõ? H
)
õõH I
/
õõJ K
l2
õõL N
;
õõN O
if
÷÷ 
(
÷÷ 
t
÷÷ 
<
÷÷ 
$num
÷÷ 
)
÷÷ 
return
øø 
Vector3
øø 
.
øø 
Distance
øø '
(
øø' (
point
øø( -
,
øø- .
	lineStart
øø/ 8
)
øø8 9
;
øø9 :
else
ùù 
if
ùù 
(
ùù 
t
ùù 
>
ùù 
$num
ùù 
)
ùù 
return
úú 
Vector3
úú 
.
úú 
Distance
úú '
(
úú' (
point
úú( -
,
úú- .
lineEnd
úú/ 6
)
úú6 7
;
úú7 8
Vector3
üü 

projection
üü 
=
üü  
	lineStart
üü! *
+
üü+ ,
t
üü- .
*
üü/ 0
(
üü1 2
lineEnd
üü2 9
-
üü: ;
	lineStart
üü< E
)
üüE F
;
üüF G
return
şş 
Vector3
şş 
.
şş 
Distance
şş #
(
şş# $
point
şş$ )
,
şş) *

projection
şş+ 5
)
şş5 6
;
şş6 7
}
ÿÿ 	
public
‡‡ 
static
‡‡ 
Vector3
‡‡ #
GetNearestPointRayRay
‡‡ 3
(
‡‡3 4
Ray
‡‡4 7
a
‡‡8 9
,
‡‡9 :
Ray
‡‡; >
b
‡‡? @
)
‡‡@ A
{
ˆˆ 	
return
‰‰ #
GetNearestPointRayRay
‰‰ (
(
‰‰( )
a
‰‰) *
.
‰‰* +
origin
‰‰+ 1
,
‰‰1 2
a
‰‰3 4
.
‰‰4 5
	direction
‰‰5 >
,
‰‰> ?
b
‰‰@ A
.
‰‰A B
origin
‰‰B H
,
‰‰H I
b
‰‰J K
.
‰‰K L
	direction
‰‰L U
)
‰‰U V
;
‰‰V W
}
ŠŠ 	
internal
ŒŒ 
static
ŒŒ 
Vector3
ŒŒ #
GetNearestPointRayRay
ŒŒ  5
(
ŒŒ5 6
Vector3
ŒŒ6 =
ao
ŒŒ> @
,
ŒŒ@ A
Vector3
ŒŒB I
ad
ŒŒJ L
,
ŒŒL M
Vector3
ŒŒN U
bo
ŒŒV X
,
ŒŒX Y
Vector3
ŒŒZ a
bd
ŒŒb d
)
ŒŒd e
{
 	
float
 
dot
 
=
 
Vector3
 
.
  
Dot
  #
(
# $
ad
$ &
,
& '
bd
( *
)
* +
;
+ ,
float
 
abs
 
=
 
Mathf
 
.
 
Abs
 !
(
! "
dot
" %
)
% &
;
& '
if
’’ 
(
’’ 
(
’’ 
abs
’’ 
-
’’ 
$num
’’ 
)
’’ 
>
’’ 
Mathf
’’ "
.
’’" #
Epsilon
’’# *
||
’’+ -
abs
’’. 1
<
’’2 3
Mathf
’’4 9
.
’’9 :
Epsilon
’’: A
)
’’A B
return
““ 
ao
““ 
;
““ 
Vector3
•• 
c
•• 
=
•• 
bo
•• 
-
•• 
ao
•• 
;
••  
float
—— 
n
—— 
=
—— 
-
—— 
dot
—— 
*
—— 
Vector3
—— $
.
——$ %
Dot
——% (
(
——( )
bd
——) +
,
——+ ,
c
——- .
)
——. /
+
——0 1
Vector3
——2 9
.
——9 :
Dot
——: =
(
——= >
ad
——> @
,
——@ A
c
——B C
)
——C D
*
——E F
Vector3
——G N
.
——N O
Dot
——O R
(
——R S
bd
——S U
,
——U V
bd
——W Y
)
——Y Z
;
——Z [
float
˜˜ 
d
˜˜ 
=
˜˜ 
Vector3
˜˜ 
.
˜˜ 
Dot
˜˜ !
(
˜˜! "
ad
˜˜" $
,
˜˜$ %
ad
˜˜& (
)
˜˜( )
*
˜˜* +
Vector3
˜˜, 3
.
˜˜3 4
Dot
˜˜4 7
(
˜˜7 8
bd
˜˜8 :
,
˜˜: ;
bd
˜˜< >
)
˜˜> ?
-
˜˜@ A
dot
˜˜B E
*
˜˜F G
dot
˜˜H K
;
˜˜K L
return
šš 
ao
šš 
+
šš 
ad
šš 
*
šš 
(
šš 
n
šš 
/
šš  !
d
šš" #
)
šš# $
;
šš$ %
}
›› 	
internal
   
static
   
bool
   %
GetLineSegmentIntersect
   4
(
  4 5
Vector2
  5 <
p0
  = ?
,
  ? @
Vector2
  A H
p1
  I K
,
  K L
Vector2
  M T
p2
  U W
,
  W X
Vector2
  Y `
p3
  a c
,
  c d
ref
  e h
Vector2
  i p
	intersect
  q z
)
  z {
{
¡¡ 	
	intersect
¢¢ 
=
¢¢ 
Vector2
¢¢ 
.
¢¢  
zero
¢¢  $
;
¢¢$ %
Vector2
££ 
s1
££ 
,
££ 
s2
££ 
;
££ 
s1
¤¤ 
.
¤¤ 
x
¤¤ 
=
¤¤ 
p1
¤¤ 
.
¤¤ 
x
¤¤ 
-
¤¤ 
p0
¤¤ 
.
¤¤ 
x
¤¤ 
;
¤¤ 
s1
¤¤$ &
.
¤¤& '
y
¤¤' (
=
¤¤) *
p1
¤¤+ -
.
¤¤- .
y
¤¤. /
-
¤¤0 1
p0
¤¤2 4
.
¤¤4 5
y
¤¤5 6
;
¤¤6 7
s2
¥¥ 
.
¥¥ 
x
¥¥ 
=
¥¥ 
p3
¥¥ 
.
¥¥ 
x
¥¥ 
-
¥¥ 
p2
¥¥ 
.
¥¥ 
x
¥¥ 
;
¥¥ 
s2
¥¥$ &
.
¥¥& '
y
¥¥' (
=
¥¥) *
p3
¥¥+ -
.
¥¥- .
y
¥¥. /
-
¥¥0 1
p2
¥¥2 4
.
¥¥4 5
y
¥¥5 6
;
¥¥6 7
float
§§ 
s
§§ 
,
§§ 
t
§§ 
;
§§ 
s
¨¨ 
=
¨¨ 
(
¨¨ 
-
¨¨ 
s1
¨¨ 
.
¨¨ 
y
¨¨ 
*
¨¨ 
(
¨¨ 
p0
¨¨ 
.
¨¨ 
x
¨¨ 
-
¨¨  
p2
¨¨! #
.
¨¨# $
x
¨¨$ %
)
¨¨% &
+
¨¨' (
s1
¨¨) +
.
¨¨+ ,
x
¨¨, -
*
¨¨. /
(
¨¨0 1
p0
¨¨1 3
.
¨¨3 4
y
¨¨4 5
-
¨¨6 7
p2
¨¨8 :
.
¨¨: ;
y
¨¨; <
)
¨¨< =
)
¨¨= >
/
¨¨? @
(
¨¨A B
-
¨¨B C
s2
¨¨C E
.
¨¨E F
x
¨¨F G
*
¨¨H I
s1
¨¨J L
.
¨¨L M
y
¨¨M N
+
¨¨O P
s1
¨¨Q S
.
¨¨S T
x
¨¨T U
*
¨¨V W
s2
¨¨X Z
.
¨¨Z [
y
¨¨[ \
)
¨¨\ ]
;
¨¨] ^
t
©© 
=
©© 
(
©© 
s2
©© 
.
©© 
x
©© 
*
©© 
(
©© 
p0
©© 
.
©© 
y
©© 
-
©© 
p2
©©  "
.
©©" #
y
©©# $
)
©©$ %
-
©©& '
s2
©©( *
.
©©* +
y
©©+ ,
*
©©- .
(
©©/ 0
p0
©©0 2
.
©©2 3
x
©©3 4
-
©©5 6
p2
©©7 9
.
©©9 :
x
©©: ;
)
©©; <
)
©©< =
/
©©> ?
(
©©@ A
-
©©A B
s2
©©B D
.
©©D E
x
©©E F
*
©©G H
s1
©©I K
.
©©K L
y
©©L M
+
©©N O
s1
©©P R
.
©©R S
x
©©S T
*
©©U V
s2
©©W Y
.
©©Y Z
y
©©Z [
)
©©[ \
;
©©\ ]
if
«« 
(
«« 
s
«« 
>=
«« 
$num
«« 
&&
«« 
s
«« 
<=
«« 
$num
««  
&&
««! #
t
««$ %
>=
««& (
$num
««) *
&&
««+ -
t
««. /
<=
««0 2
$num
««3 4
)
««4 5
{
¬¬ 
	intersect
®® 
.
®® 
x
®® 
=
®® 
p0
®®  
.
®®  !
x
®®! "
+
®®# $
(
®®% &
t
®®& '
*
®®( )
s1
®®* ,
.
®®, -
x
®®- .
)
®®. /
;
®®/ 0
	intersect
¯¯ 
.
¯¯ 
y
¯¯ 
=
¯¯ 
p0
¯¯  
.
¯¯  !
y
¯¯! "
+
¯¯# $
(
¯¯% &
t
¯¯& '
*
¯¯( )
s1
¯¯* ,
.
¯¯, -
y
¯¯- .
)
¯¯. /
;
¯¯/ 0
return
°° 
true
°° 
;
°° 
}
±± 
return
³³ 
false
³³ 
;
³³ 
}
´´ 	
internal
¾¾ 
static
¾¾ 
bool
¾¾ %
GetLineSegmentIntersect
¾¾ 4
(
¾¾4 5
Vector2
¾¾5 <
p0
¾¾= ?
,
¾¾? @
Vector2
¾¾A H
p1
¾¾I K
,
¾¾K L
Vector2
¾¾M T
p2
¾¾U W
,
¾¾W X
Vector2
¾¾Y `
p3
¾¾a c
)
¾¾c d
{
¿¿ 	
Vector2
ÀÀ 
s1
ÀÀ 
,
ÀÀ 
s2
ÀÀ 
;
ÀÀ 
s1
ÁÁ 
.
ÁÁ 
x
ÁÁ 
=
ÁÁ 
p1
ÁÁ 
.
ÁÁ 
x
ÁÁ 
-
ÁÁ 
p0
ÁÁ 
.
ÁÁ 
x
ÁÁ 
;
ÁÁ 
s1
ÁÁ$ &
.
ÁÁ& '
y
ÁÁ' (
=
ÁÁ) *
p1
ÁÁ+ -
.
ÁÁ- .
y
ÁÁ. /
-
ÁÁ0 1
p0
ÁÁ2 4
.
ÁÁ4 5
y
ÁÁ5 6
;
ÁÁ6 7
s2
ÂÂ 
.
ÂÂ 
x
ÂÂ 
=
ÂÂ 
p3
ÂÂ 
.
ÂÂ 
x
ÂÂ 
-
ÂÂ 
p2
ÂÂ 
.
ÂÂ 
x
ÂÂ 
;
ÂÂ 
s2
ÂÂ$ &
.
ÂÂ& '
y
ÂÂ' (
=
ÂÂ) *
p3
ÂÂ+ -
.
ÂÂ- .
y
ÂÂ. /
-
ÂÂ0 1
p2
ÂÂ2 4
.
ÂÂ4 5
y
ÂÂ5 6
;
ÂÂ6 7
float
ÄÄ 
s
ÄÄ 
,
ÄÄ 
t
ÄÄ 
;
ÄÄ 
s
ÅÅ 
=
ÅÅ 
(
ÅÅ 
-
ÅÅ 
s1
ÅÅ 
.
ÅÅ 
y
ÅÅ 
*
ÅÅ 
(
ÅÅ 
p0
ÅÅ 
.
ÅÅ 
x
ÅÅ 
-
ÅÅ  
p2
ÅÅ! #
.
ÅÅ# $
x
ÅÅ$ %
)
ÅÅ% &
+
ÅÅ' (
s1
ÅÅ) +
.
ÅÅ+ ,
x
ÅÅ, -
*
ÅÅ. /
(
ÅÅ0 1
p0
ÅÅ1 3
.
ÅÅ3 4
y
ÅÅ4 5
-
ÅÅ6 7
p2
ÅÅ8 :
.
ÅÅ: ;
y
ÅÅ; <
)
ÅÅ< =
)
ÅÅ= >
/
ÅÅ? @
(
ÅÅA B
-
ÅÅB C
s2
ÅÅC E
.
ÅÅE F
x
ÅÅF G
*
ÅÅH I
s1
ÅÅJ L
.
ÅÅL M
y
ÅÅM N
+
ÅÅO P
s1
ÅÅQ S
.
ÅÅS T
x
ÅÅT U
*
ÅÅV W
s2
ÅÅX Z
.
ÅÅZ [
y
ÅÅ[ \
)
ÅÅ\ ]
;
ÅÅ] ^
t
ÆÆ 
=
ÆÆ 
(
ÆÆ 
s2
ÆÆ 
.
ÆÆ 
x
ÆÆ 
*
ÆÆ 
(
ÆÆ 
p0
ÆÆ 
.
ÆÆ 
y
ÆÆ 
-
ÆÆ 
p2
ÆÆ  "
.
ÆÆ" #
y
ÆÆ# $
)
ÆÆ$ %
-
ÆÆ& '
s2
ÆÆ( *
.
ÆÆ* +
y
ÆÆ+ ,
*
ÆÆ- .
(
ÆÆ/ 0
p0
ÆÆ0 2
.
ÆÆ2 3
x
ÆÆ3 4
-
ÆÆ5 6
p2
ÆÆ7 9
.
ÆÆ9 :
x
ÆÆ: ;
)
ÆÆ; <
)
ÆÆ< =
/
ÆÆ> ?
(
ÆÆ@ A
-
ÆÆA B
s2
ÆÆB D
.
ÆÆD E
x
ÆÆE F
*
ÆÆG H
s1
ÆÆI K
.
ÆÆK L
y
ÆÆL M
+
ÆÆN O
s1
ÆÆP R
.
ÆÆR S
x
ÆÆS T
*
ÆÆU V
s2
ÆÆW Y
.
ÆÆY Z
y
ÆÆZ [
)
ÆÆ[ \
;
ÆÆ\ ]
return
ÈÈ 
(
ÈÈ 
s
ÈÈ 
>=
ÈÈ 
$num
ÈÈ 
&&
ÈÈ 
s
ÈÈ 
<=
ÈÈ  "
$num
ÈÈ# $
&&
ÈÈ% '
t
ÈÈ( )
>=
ÈÈ* ,
$num
ÈÈ- .
&&
ÈÈ/ 1
t
ÈÈ2 3
<=
ÈÈ4 6
$num
ÈÈ7 8
)
ÈÈ8 9
;
ÈÈ9 :
}
ÉÉ 	
internal
ÒÒ 
static
ÒÒ 
bool
ÒÒ 
PointInPolygon
ÒÒ +
(
ÒÒ+ ,
Vector2
ÒÒ, 3
[
ÒÒ3 4
]
ÒÒ4 5
polygon
ÒÒ6 =
,
ÒÒ= >
Vector2
ÒÒ? F
point
ÒÒG L
,
ÒÒL M
int
ÒÒN Q
[
ÒÒQ R
]
ÒÒR S
indexes
ÒÒT [
=
ÒÒ\ ]
null
ÒÒ^ b
)
ÒÒb c
{
ÓÓ 	
int
ÔÔ 
len
ÔÔ 
=
ÔÔ 
indexes
ÔÔ 
!=
ÔÔ  
null
ÔÔ! %
?
ÔÔ& '
indexes
ÔÔ( /
.
ÔÔ/ 0
Length
ÔÔ0 6
:
ÔÔ7 8
polygon
ÔÔ9 @
.
ÔÔ@ A
Length
ÔÔA G
;
ÔÔG H
if
ÖÖ 
(
ÖÖ 
len
ÖÖ 
%
ÖÖ 
$num
ÖÖ 
!=
ÖÖ 
$num
ÖÖ 
)
ÖÖ 
{
×× 
Debug
ØØ 
.
ØØ 
LogError
ØØ 
(
ØØ 
$str
ØØ [
)
ØØ[ \
;
ØØ\ ]
return
ÙÙ 
false
ÙÙ 
;
ÙÙ 
}
ÚÚ 
Bounds2D
ÜÜ 
bounds
ÜÜ 
=
ÜÜ 
new
ÜÜ !
Bounds2D
ÜÜ" *
(
ÜÜ* +
polygon
ÜÜ+ 2
,
ÜÜ2 3
indexes
ÜÜ4 ;
)
ÜÜ; <
;
ÜÜ< =
if
ŞŞ 
(
ŞŞ 
bounds
ŞŞ 
.
ŞŞ 
ContainsPoint
ŞŞ $
(
ŞŞ$ %
point
ŞŞ% *
)
ŞŞ* +
)
ŞŞ+ ,
{
ßß 
Vector2
áá 
p1
áá 
=
áá 
polygon
áá $
[
áá$ %
indexes
áá% ,
!=
áá- /
null
áá0 4
?
áá5 6
indexes
áá7 >
[
áá> ?
$num
áá? @
]
áá@ A
:
ááB C
$num
ááD E
]
ááE F
;
ááF G
Vector2
ââ 
p2
ââ 
=
ââ 
polygon
ââ $
[
ââ$ %
indexes
ââ% ,
!=
ââ- /
null
ââ0 4
?
ââ5 6
indexes
ââ7 >
[
ââ> ?
$num
ââ? @
]
ââ@ A
:
ââB C
$num
ââD E
]
ââE F
;
ââF G
Vector2
ãã 
center
ãã 
=
ãã  
p1
ãã! #
+
ãã$ %
(
ãã& '
p2
ãã' )
-
ãã* +
p1
ãã, .
)
ãã. /
*
ãã0 1
$num
ãã2 6
;
ãã6 7
Vector2
ää 
dir
ää 
=
ää 
center
ää $
-
ää% &
bounds
ää' -
.
ää- .
center
ää. 4
;
ää4 5
Vector2
ææ 
rayStart
ææ  
=
ææ! "
bounds
ææ# )
.
ææ) *
center
ææ* 0
+
ææ1 2
dir
ææ3 6
*
ææ7 8
(
ææ9 :
bounds
ææ: @
.
ææ@ A
size
ææA E
.
ææE F
y
ææF G
+
ææH I
bounds
ææJ P
.
ææP Q
size
ææQ U
.
ææU V
x
ææV W
+
ææX Y
$num
ææZ \
)
ææ\ ]
;
ææ] ^
int
çç 

collisions
çç 
=
çç  
$num
çç! "
;
çç" #
for
éé 
(
éé 
int
éé 
i
éé 
=
éé 
$num
éé 
;
éé 
i
éé  !
<
éé" #
len
éé$ '
;
éé' (
i
éé) *
+=
éé+ -
$num
éé. /
)
éé/ 0
{
êê 
int
ëë 
a
ëë 
=
ëë 
indexes
ëë #
!=
ëë$ &
null
ëë' +
?
ëë, -
indexes
ëë. 5
[
ëë5 6
i
ëë6 7
]
ëë7 8
:
ëë9 :
i
ëë; <
;
ëë< =
int
ìì 
b
ìì 
=
ìì 
indexes
ìì #
!=
ìì$ &
null
ìì' +
?
ìì, -
indexes
ìì. 5
[
ìì5 6
i
ìì6 7
+
ìì8 9
$num
ìì: ;
]
ìì; <
:
ìì= >
i
ìì? @
+
ììA B
$num
ììC D
;
ììD E
if
îî 
(
îî %
GetLineSegmentIntersect
îî /
(
îî/ 0
rayStart
îî0 8
,
îî8 9
point
îî: ?
,
îî? @
polygon
îîA H
[
îîH I
a
îîI J
]
îîJ K
,
îîK L
polygon
îîM T
[
îîT U
b
îîU V
]
îîV W
)
îîW X
)
îîX Y

collisions
ïï "
++
ïï" $
;
ïï$ %
}
ğğ 
return
òò 

collisions
òò !
%
òò" #
$num
òò$ %
!=
òò& (
$num
òò) *
;
òò* +
}
óó 
else
ôô 
return
õõ 
false
õõ 
;
õõ 
}
öö 	
internal
ƒƒ 
static
ƒƒ 
bool
ƒƒ 
PointInPolygon
ƒƒ +
(
ƒƒ+ ,
Vector2
ƒƒ, 3
[
ƒƒ3 4
]
ƒƒ4 5
	positions
ƒƒ6 ?
,
ƒƒ? @
Bounds2D
ƒƒA I

polyBounds
ƒƒJ T
,
ƒƒT U
Edge
ƒƒV Z
[
ƒƒZ [
]
ƒƒ[ \
edges
ƒƒ] b
,
ƒƒb c
Vector2
ƒƒd k
point
ƒƒl q
)
ƒƒq r
{
„„ 	
int
…… 
len
…… 
=
…… 
edges
…… 
.
…… 
Length
…… "
*
……# $
$num
……% &
;
……& '
Vector2
‡‡ 
rayStart
‡‡ 
=
‡‡ 

polyBounds
‡‡ )
.
‡‡) *
center
‡‡* 0
+
‡‡1 2
Vector2
‡‡3 :
.
‡‡: ;
up
‡‡; =
*
‡‡> ?
(
‡‡@ A

polyBounds
‡‡A K
.
‡‡K L
size
‡‡L P
.
‡‡P Q
y
‡‡Q R
+
‡‡S T
$num
‡‡U W
)
‡‡W X
;
‡‡X Y
int
‰‰ 

collisions
‰‰ 
=
‰‰ 
$num
‰‰ 
;
‰‰ 
for
‹‹ 
(
‹‹ 
int
‹‹ 
i
‹‹ 
=
‹‹ 
$num
‹‹ 
;
‹‹ 
i
‹‹ 
<
‹‹ 
len
‹‹  #
;
‹‹# $
i
‹‹% &
+=
‹‹' )
$num
‹‹* +
)
‹‹+ ,
{
ŒŒ 
if
 
(
 %
GetLineSegmentIntersect
 +
(
+ ,
rayStart
, 4
,
4 5
point
6 ;
,
; <
	positions
= F
[
F G
i
G H
]
H I
,
I J
	positions
K T
[
T U
i
U V
+
W X
$num
Y Z
]
Z [
)
[ \
)
\ ]

collisions
 
++
  
;
  !
}
 
return
‘‘ 

collisions
‘‘ 
%
‘‘ 
$num
‘‘  !
!=
‘‘" $
$num
‘‘% &
;
‘‘& '
}
’’ 	
internal
ŸŸ 
static
ŸŸ 
bool
ŸŸ 
PointInPolygon
ŸŸ +
(
ŸŸ+ ,
Vector3
ŸŸ, 3
[
ŸŸ3 4
]
ŸŸ4 5
	positions
ŸŸ6 ?
,
ŸŸ? @
Bounds2D
ŸŸA I

polyBounds
ŸŸJ T
,
ŸŸT U
Edge
ŸŸV Z
[
ŸŸZ [
]
ŸŸ[ \
edges
ŸŸ] b
,
ŸŸb c
Vector2
ŸŸd k
point
ŸŸl q
)
ŸŸq r
{
   	
int
¡¡ 
len
¡¡ 
=
¡¡ 
edges
¡¡ 
.
¡¡ 
Length
¡¡ "
*
¡¡# $
$num
¡¡% &
;
¡¡& '
Vector2
££ 
rayStart
££ 
=
££ 

polyBounds
££ )
.
££) *
center
££* 0
+
££1 2
Vector2
££3 :
.
££: ;
up
££; =
*
££> ?
(
££@ A

polyBounds
££A K
.
££K L
size
££L P
.
££P Q
y
££Q R
+
££S T
$num
££U W
)
££W X
;
££X Y
int
¥¥ 

collisions
¥¥ 
=
¥¥ 
$num
¥¥ 
;
¥¥ 
for
§§ 
(
§§ 
int
§§ 
i
§§ 
=
§§ 
$num
§§ 
;
§§ 
i
§§ 
<
§§ 
len
§§  #
;
§§# $
i
§§% &
+=
§§' )
$num
§§* +
)
§§+ ,
{
¨¨ 
if
©© 
(
©© %
GetLineSegmentIntersect
©© +
(
©©+ ,
rayStart
©©, 4
,
©©4 5
point
©©6 ;
,
©©; <
	positions
©©= F
[
©©F G
i
©©G H
]
©©H I
,
©©I J
	positions
©©K T
[
©©T U
i
©©U V
+
©©W X
$num
©©Y Z
]
©©Z [
)
©©[ \
)
©©\ ]

collisions
ªª 
++
ªª  
;
ªª  !
}
«« 
return
­­ 

collisions
­­ 
%
­­ 
$num
­­  !
!=
­­" $
$num
­­% &
;
­­& '
}
®® 	
internal
°° 
static
°° 
bool
°° '
RectIntersectsLineSegment
°° 6
(
°°6 7
Rect
°°7 ;
rect
°°< @
,
°°@ A
Vector2
°°B I
a
°°J K
,
°°K L
Vector2
°°M T
b
°°U V
)
°°V W
{
±± 	
return
²² 
Clipping
²² 
.
²² %
RectContainsLineSegment
²² 3
(
²²3 4
rect
²²4 8
,
²²8 9
a
²²: ;
.
²²; <
x
²²< =
,
²²= >
a
²²? @
.
²²@ A
y
²²A B
,
²²B C
b
²²D E
.
²²E F
x
²²F G
,
²²G H
b
²²I J
.
²²J K
y
²²K L
)
²²L M
;
²²M N
}
³³ 	
internal
µµ 
static
µµ 
bool
µµ '
RectIntersectsLineSegment
µµ 6
(
µµ6 7
Rect
µµ7 ;
rect
µµ< @
,
µµ@ A
Vector3
µµB I
a
µµJ K
,
µµK L
Vector3
µµM T
b
µµU V
)
µµV W
{
¶¶ 	
return
·· 
Clipping
·· 
.
·· %
RectContainsLineSegment
·· 3
(
··3 4
rect
··4 8
,
··8 9
a
··: ;
.
··; <
x
··< =
,
··= >
a
··? @
.
··@ A
y
··A B
,
··B C
b
··D E
.
··E F
x
··F G
,
··G H
b
··I J
.
··J K
y
··K L
)
··L M
;
··M N
}
¸¸ 	
public
ÈÈ 
static
ÈÈ 
bool
ÈÈ #
RayIntersectsTriangle
ÈÈ 0
(
ÈÈ0 1
Ray
ÈÈ1 4
InRay
ÈÈ5 :
,
ÈÈ: ;
Vector3
ÈÈ< C
InTriangleA
ÈÈD O
,
ÈÈO P
Vector3
ÈÈQ X
InTriangleB
ÈÈY d
,
ÈÈd e
Vector3
ÈÈf m
InTriangleC
ÈÈn y
,
ÈÈy z
out
ÉÉ 
float
ÉÉ 
OutDistance
ÉÉ !
,
ÉÉ! "
out
ÉÉ# &
Vector3
ÉÉ' .
OutPoint
ÉÉ/ 7
)
ÉÉ7 8
{
ÊÊ 	
OutDistance
ËË 
=
ËË 
$num
ËË 
;
ËË 
OutPoint
ÌÌ 
=
ÌÌ 
Vector3
ÌÌ 
.
ÌÌ 
zero
ÌÌ #
;
ÌÌ# $
Vector3
ÏÏ 
e1
ÏÏ 
=
ÏÏ 
InTriangleB
ÏÏ $
-
ÏÏ% &
InTriangleA
ÏÏ' 2
;
ÏÏ2 3
Vector3
ĞĞ 
e2
ĞĞ 
=
ĞĞ 
InTriangleC
ĞĞ $
-
ĞĞ% &
InTriangleA
ĞĞ' 2
;
ĞĞ2 3
Vector3
ÓÓ 
P
ÓÓ 
=
ÓÓ 
Vector3
ÓÓ 
.
ÓÓ  
Cross
ÓÓ  %
(
ÓÓ% &
InRay
ÓÓ& +
.
ÓÓ+ ,
	direction
ÓÓ, 5
,
ÓÓ5 6
e2
ÓÓ7 9
)
ÓÓ9 :
;
ÓÓ: ;
float
ÖÖ 
det
ÖÖ 
=
ÖÖ 
Vector3
ÖÖ 
.
ÖÖ  
Dot
ÖÖ  #
(
ÖÖ# $
e1
ÖÖ$ &
,
ÖÖ& '
P
ÖÖ( )
)
ÖÖ) *
;
ÖÖ* +
if
ÚÚ 
(
ÚÚ 
det
ÚÚ 
>
ÚÚ 
-
ÚÚ 
Mathf
ÚÚ 
.
ÚÚ 
Epsilon
ÚÚ $
&&
ÚÚ% '
det
ÚÚ( +
<
ÚÚ, -
Mathf
ÚÚ. 3
.
ÚÚ3 4
Epsilon
ÚÚ4 ;
)
ÚÚ; <
return
ÛÛ 
false
ÛÛ 
;
ÛÛ 
float
İİ 
inv_det
İİ 
=
İİ 
$num
İİ 
/
İİ  
det
İİ! $
;
İİ$ %
Vector3
àà 
T
àà 
=
àà 
InRay
àà 
.
àà 
origin
àà $
-
àà% &
InTriangleA
àà' 2
;
àà2 3
float
ãã 
u
ãã 
=
ãã 
Vector3
ãã 
.
ãã 
Dot
ãã !
(
ãã! "
T
ãã" #
,
ãã# $
P
ãã% &
)
ãã& '
*
ãã( )
inv_det
ãã* 1
;
ãã1 2
if
ææ 
(
ææ 
u
ææ 
<
ææ 
$num
ææ 
||
ææ 
u
ææ 
>
ææ 
$num
ææ  
)
ææ  !
return
çç 
false
çç 
;
çç 
Vector3
êê 
Q
êê 
=
êê 
Vector3
êê 
.
êê  
Cross
êê  %
(
êê% &
T
êê& '
,
êê' (
e1
êê) +
)
êê+ ,
;
êê, -
float
íí 
v
íí 
=
íí 
Vector3
íí 
.
íí 
Dot
íí !
(
íí! "
InRay
íí" '
.
íí' (
	direction
íí( 1
,
íí1 2
Q
íí3 4
)
íí4 5
*
íí6 7
inv_det
íí8 ?
;
íí? @
if
ğğ 
(
ğğ 
v
ğğ 
<
ğğ 
$num
ğğ 
||
ğğ 
u
ğğ 
+
ğğ 
v
ğğ 
>
ğğ! "
$num
ğğ# %
)
ğğ% &
return
ññ 
false
ññ 
;
ññ 
float
óó 
t
óó 
=
óó 
Vector3
óó 
.
óó 
Dot
óó !
(
óó! "
e2
óó" $
,
óó$ %
Q
óó& '
)
óó' (
*
óó) *
inv_det
óó+ 2
;
óó2 3
if
öö 
(
öö 
t
öö 
>
öö 
Mathf
öö 
.
öö 
Epsilon
öö !
)
öö! "
{
÷÷ 
OutDistance
ùù 
=
ùù 
t
ùù 
;
ùù  
OutPoint
ûû 
.
ûû 
x
ûû 
=
ûû 
(
ûû 
u
ûû 
*
ûû  !
InTriangleB
ûû" -
.
ûû- .
x
ûû. /
+
ûû0 1
v
ûû2 3
*
ûû4 5
InTriangleC
ûû6 A
.
ûûA B
x
ûûB C
+
ûûD E
(
ûûF G
$num
ûûG H
-
ûûI J
(
ûûK L
u
ûûL M
+
ûûN O
v
ûûP Q
)
ûûQ R
)
ûûR S
*
ûûT U
InTriangleA
ûûV a
.
ûûa b
x
ûûb c
)
ûûc d
;
ûûd e
OutPoint
üü 
.
üü 
y
üü 
=
üü 
(
üü 
u
üü 
*
üü  !
InTriangleB
üü" -
.
üü- .
y
üü. /
+
üü0 1
v
üü2 3
*
üü4 5
InTriangleC
üü6 A
.
üüA B
y
üüB C
+
üüD E
(
üüF G
$num
üüG H
-
üüI J
(
üüK L
u
üüL M
+
üüN O
v
üüP Q
)
üüQ R
)
üüR S
*
üüT U
InTriangleA
üüV a
.
üüa b
y
üüb c
)
üüc d
;
üüd e
OutPoint
ıı 
.
ıı 
z
ıı 
=
ıı 
(
ıı 
u
ıı 
*
ıı  !
InTriangleB
ıı" -
.
ıı- .
z
ıı. /
+
ıı0 1
v
ıı2 3
*
ıı4 5
InTriangleC
ıı6 A
.
ııA B
z
ııB C
+
ııD E
(
ııF G
$num
ııG H
-
ııI J
(
ııK L
u
ııL M
+
ııN O
v
ııP Q
)
ııQ R
)
ııR S
*
ııT U
InTriangleA
ııV a
.
ııa b
z
ııb c
)
ııc d
;
ııd e
return
ÿÿ 
true
ÿÿ 
;
ÿÿ 
}
€€ 
return
‚‚ 
false
‚‚ 
;
‚‚ 
}
ƒƒ 	
static
†† 
Vector3
†† 
tv1
†† 
,
†† 
tv2
†† 
,
††  
tv3
††! $
,
††$ %
tv4
††& )
;
††) *
internal
““ 
static
““ 
bool
““ $
RayIntersectsTriangle2
““ 3
(
““3 4
Vector3
““4 ;
origin
““< B
,
““B C
Vector3
”” 
dir
”” 
,
”” 
Vector3
•• 
vert0
•• 
,
•• 
Vector3
–– 
vert1
–– 
,
–– 
Vector3
—— 
vert2
—— 
,
—— 
ref
˜˜ 
float
˜˜ 
distance
˜˜ 
,
˜˜ 
ref
™™ 
Vector3
™™ 
normal
™™ 
)
™™ 
{
šš 	
Math
›› 
.
›› 
Subtract
›› 
(
›› 
vert0
›› 
,
››  
vert1
››! &
,
››& '
ref
››( +
tv1
››, /
)
››/ 0
;
››0 1
Math
œœ 
.
œœ 
Subtract
œœ 
(
œœ 
vert0
œœ 
,
œœ  
vert2
œœ! &
,
œœ& '
ref
œœ( +
tv2
œœ, /
)
œœ/ 0
;
œœ0 1
Math
 
.
 
Cross
 
(
 
dir
 
,
 
tv2
 
,
  
ref
! $
tv4
% (
)
( )
;
) *
float
ŸŸ 
det
ŸŸ 
=
ŸŸ 
Vector3
ŸŸ 
.
ŸŸ  
Dot
ŸŸ  #
(
ŸŸ# $
tv1
ŸŸ$ '
,
ŸŸ' (
tv4
ŸŸ) ,
)
ŸŸ, -
;
ŸŸ- .
if
¡¡ 
(
¡¡ 
det
¡¡ 
<
¡¡ 
Mathf
¡¡ 
.
¡¡ 
Epsilon
¡¡ #
)
¡¡# $
return
¢¢ 
false
¢¢ 
;
¢¢ 
Math
¤¤ 
.
¤¤ 
Subtract
¤¤ 
(
¤¤ 
vert0
¤¤ 
,
¤¤  
origin
¤¤! '
,
¤¤' (
ref
¤¤) ,
tv3
¤¤- 0
)
¤¤0 1
;
¤¤1 2
float
¦¦ 
u
¦¦ 
=
¦¦ 
Vector3
¦¦ 
.
¦¦ 
Dot
¦¦ !
(
¦¦! "
tv3
¦¦" %
,
¦¦% &
tv4
¦¦' *
)
¦¦* +
;
¦¦+ ,
if
¨¨ 
(
¨¨ 
u
¨¨ 
<
¨¨ 
$num
¨¨ 
||
¨¨ 
u
¨¨ 
>
¨¨ 
det
¨¨ !
)
¨¨! "
return
©© 
false
©© 
;
©© 
Math
«« 
.
«« 
Cross
«« 
(
«« 
tv3
«« 
,
«« 
tv1
«« 
,
««  
ref
««! $
tv4
««% (
)
««( )
;
««) *
float
­­ 
v
­­ 
=
­­ 
Vector3
­­ 
.
­­ 
Dot
­­ !
(
­­! "
dir
­­" %
,
­­% &
tv4
­­' *
)
­­* +
;
­­+ ,
if
¯¯ 
(
¯¯ 
v
¯¯ 
<
¯¯ 
$num
¯¯ 
||
¯¯ 
u
¯¯ 
+
¯¯ 
v
¯¯ 
>
¯¯  !
det
¯¯" %
)
¯¯% &
return
°° 
false
°° 
;
°° 
distance
²² 
=
²² 
Vector3
²² 
.
²² 
Dot
²² "
(
²²" #
tv2
²²# &
,
²²& '
tv4
²²( +
)
²²+ ,
*
²²- .
(
²²/ 0
$num
²²0 2
/
²²3 4
det
²²5 8
)
²²8 9
;
²²9 :
Math
³³ 
.
³³ 
Cross
³³ 
(
³³ 
tv1
³³ 
,
³³ 
tv2
³³ 
,
³³  
ref
³³! $
normal
³³% +
)
³³+ ,
;
³³, -
return
µµ 
true
µµ 
;
µµ 
}
¶¶ 	
public
¾¾ 
static
¾¾ 
float
¾¾ 
Secant
¾¾ "
(
¾¾" #
float
¾¾# (
x
¾¾) *
)
¾¾* +
{
¿¿ 	
return
ÀÀ 
$num
ÀÀ 
/
ÀÀ 
Mathf
ÀÀ 
.
ÀÀ 
Cos
ÀÀ !
(
ÀÀ! "
x
ÀÀ" #
)
ÀÀ# $
;
ÀÀ$ %
}
ÁÁ 	
public
ÌÌ 
static
ÌÌ 
Vector3
ÌÌ 
Normal
ÌÌ $
(
ÌÌ$ %
Vector3
ÌÌ% ,
p0
ÌÌ- /
,
ÌÌ/ 0
Vector3
ÌÌ1 8
p1
ÌÌ9 ;
,
ÌÌ; <
Vector3
ÌÌ= D
p2
ÌÌE G
)
ÌÌG H
{
ÍÍ 	
float
ÎÎ 
ax
ÎÎ 
=
ÎÎ 
p1
ÎÎ 
.
ÎÎ 
x
ÎÎ 
-
ÎÎ 
p0
ÎÎ  "
.
ÎÎ" #
x
ÎÎ# $
,
ÎÎ$ %
ay
ÏÏ 
=
ÏÏ 
p1
ÏÏ 
.
ÏÏ 
y
ÏÏ 
-
ÏÏ 
p0
ÏÏ  "
.
ÏÏ" #
y
ÏÏ# $
,
ÏÏ$ %
az
ĞĞ 
=
ĞĞ 
p1
ĞĞ 
.
ĞĞ 
z
ĞĞ 
-
ĞĞ 
p0
ĞĞ  "
.
ĞĞ" #
z
ĞĞ# $
,
ĞĞ$ %
bx
ÑÑ 
=
ÑÑ 
p2
ÑÑ 
.
ÑÑ 
x
ÑÑ 
-
ÑÑ 
p0
ÑÑ  "
.
ÑÑ" #
x
ÑÑ# $
,
ÑÑ$ %
by
ÒÒ 
=
ÒÒ 
p2
ÒÒ 
.
ÒÒ 
y
ÒÒ 
-
ÒÒ 
p0
ÒÒ  "
.
ÒÒ" #
y
ÒÒ# $
,
ÒÒ$ %
bz
ÓÓ 
=
ÓÓ 
p2
ÓÓ 
.
ÓÓ 
z
ÓÓ 
-
ÓÓ 
p0
ÓÓ  "
.
ÓÓ" #
z
ÓÓ# $
;
ÓÓ$ %
Vector3
ÕÕ 
cross
ÕÕ 
=
ÕÕ 
Vector3
ÕÕ #
.
ÕÕ# $
zero
ÕÕ$ (
;
ÕÕ( )
Cross
×× 
(
×× 
ax
×× 
,
×× 
ay
×× 
,
×× 
az
×× 
,
×× 
bx
××  
,
××  !
by
××" $
,
××$ %
bz
××& (
,
××( )
ref
××* -
cross
××. 3
.
××3 4
x
××4 5
,
××5 6
ref
××7 :
cross
××; @
.
××@ A
y
××A B
,
××B C
ref
××D G
cross
××H M
.
××M N
z
××N O
)
××O P
;
××P Q
if
ÙÙ 
(
ÙÙ 
cross
ÙÙ 
.
ÙÙ 
	magnitude
ÙÙ 
<
ÙÙ  !
Mathf
ÙÙ" '
.
ÙÙ' (
Epsilon
ÙÙ( /
)
ÙÙ/ 0
{
ÚÚ 
return
ÛÛ 
new
ÛÛ 
Vector3
ÛÛ "
(
ÛÛ" #
$num
ÛÛ# %
,
ÛÛ% &
$num
ÛÛ' )
,
ÛÛ) *
$num
ÛÛ+ -
)
ÛÛ- .
;
ÛÛ. /
}
ÜÜ 
else
İİ 
{
ŞŞ 
cross
ßß 
.
ßß 
	Normalize
ßß 
(
ßß  
)
ßß  !
;
ßß! "
return
àà 
cross
àà 
;
àà 
}
áá 
}
ââ 	
internal
êê 
static
êê 
Vector3
êê 
Normal
êê  &
(
êê& '
IList
êê' ,
<
êê, -
Vertex
êê- 3
>
êê3 4
vertices
êê5 =
,
êê= >
IList
êê? D
<
êêD E
int
êêE H
>
êêH I
indexes
êêJ Q
=
êêR S
null
êêT X
)
êêX Y
{
ëë 	
if
ìì 
(
ìì 
indexes
ìì 
==
ìì 
null
ìì 
||
ìì  "
indexes
ìì# *
.
ìì* +
Count
ìì+ 0
%
ìì1 2
$num
ìì3 4
!=
ìì5 7
$num
ìì8 9
)
ìì9 :
{
íí 
Vector3
îî 
cross
îî 
=
îî 
Vector3
îî  '
.
îî' (
Cross
îî( -
(
îî- .
vertices
îî. 6
[
îî6 7
$num
îî7 8
]
îî8 9
.
îî9 :
position
îî: B
-
îîC D
vertices
îîE M
[
îîM N
$num
îîN O
]
îîO P
.
îîP Q
position
îîQ Y
,
îîY Z
vertices
îî[ c
[
îîc d
$num
îîd e
]
îîe f
.
îîf g
position
îîg o
-
îîp q
vertices
îîr z
[
îîz {
$num
îî{ |
]
îî| }
.
îî} ~
positionîî~ †
)îî† ‡
;îî‡ ˆ
cross
ïï 
.
ïï 
	Normalize
ïï 
(
ïï  
)
ïï  !
;
ïï! "
return
ğğ 
cross
ğğ 
;
ğğ 
}
ññ 
else
òò 
{
óó 
int
ôô 
len
ôô 
=
ôô 
indexes
ôô !
.
ôô! "
Count
ôô" '
;
ôô' (
Vector3
õõ 
nrm
õõ 
=
õõ 
Vector3
õõ %
.
õõ% &
zero
õõ& *
;
õõ* +
for
÷÷ 
(
÷÷ 
int
÷÷ 
i
÷÷ 
=
÷÷ 
$num
÷÷ 
;
÷÷ 
i
÷÷  !
<
÷÷" #
len
÷÷$ '
;
÷÷' (
i
÷÷) *
+=
÷÷+ -
$num
÷÷. /
)
÷÷/ 0
nrm
øø 
+=
øø 
Normal
øø !
(
øø! "
vertices
øø" *
[
øø* +
indexes
øø+ 2
[
øø2 3
i
øø3 4
]
øø4 5
]
øø5 6
.
øø6 7
position
øø7 ?
,
øø? @
vertices
øøA I
[
øøI J
indexes
øøJ Q
[
øøQ R
i
øøR S
+
øøT U
$num
øøV W
]
øøW X
]
øøX Y
.
øøY Z
position
øøZ b
,
øøb c
vertices
øød l
[
øøl m
indexes
øøm t
[
øøt u
i
øøu v
+
øøw x
$num
øøy z
]
øøz {
]
øø{ |
.
øø| }
positionøø} …
)øø… †
;øø† ‡
nrm
úú 
/=
úú 
(
úú 
len
úú 
/
úú 
$num
úú  
)
úú  !
;
úú! "
nrm
ûû 
.
ûû 
	Normalize
ûû 
(
ûû 
)
ûû 
;
ûû  
return
ıı 
nrm
ıı 
;
ıı 
}
şş 
}
ÿÿ 	
public
‡‡ 
static
‡‡ 
Vector3
‡‡ 
Normal
‡‡ $
(
‡‡$ %
ProBuilderMesh
‡‡% 3
mesh
‡‡4 8
,
‡‡8 9
Face
‡‡: >
face
‡‡? C
)
‡‡C D
{
ˆˆ 	
if
‰‰ 
(
‰‰ 
mesh
‰‰ 
==
‰‰ 
null
‰‰ 
||
‰‰ 
face
‰‰  $
==
‰‰% '
null
‰‰( ,
)
‰‰, -
throw
ŠŠ 
new
ŠŠ #
ArgumentNullException
ŠŠ /
(
ŠŠ/ 0
$str
ŠŠ0 6
)
ŠŠ6 7
;
ŠŠ7 8
var
ŒŒ 
	positions
ŒŒ 
=
ŒŒ 
mesh
ŒŒ  
.
ŒŒ  !
positionsInternal
ŒŒ! 2
;
ŒŒ2 3
Vector3
’’ 
nrm
’’ 
=
’’ 
Normal
’’  
(
’’  !
	positions
““ 
[
““ 
face
““ "
.
““" #
indexesInternal
““# 2
[
““2 3
$num
““3 4
]
““4 5
]
““5 6
,
““6 7
	positions
”” 
[
”” 
face
”” "
.
””" #
indexesInternal
””# 2
[
””2 3
$num
””3 4
]
””4 5
]
””5 6
,
””6 7
	positions
•• 
[
•• 
face
•• "
.
••" #
indexesInternal
••# 2
[
••2 3
$num
••3 4
]
••4 5
]
••5 6
)
••6 7
;
••7 8
if
—— 
(
—— 
face
—— 
.
—— 
indexesInternal
—— $
.
——$ %
Length
——% +
>
——, -
$num
——. /
)
——/ 0
{
˜˜ 
Vector3
™™ 
prj
™™ 
=
™™ 

Projection
™™ (
.
™™( )
FindBestPlane
™™) 6
(
™™6 7
	positions
™™7 @
,
™™@ A
face
™™B F
.
™™F G%
distinctIndexesInternal
™™G ^
)
™™^ _
.
™™_ `
normal
™™` f
;
™™f g
if
›› 
(
›› 
Vector3
›› 
.
›› 
Dot
›› 
(
››  
nrm
››  #
,
››# $
prj
››% (
)
››( )
<
››* +
$num
››, .
)
››. /
{
œœ 
nrm
 
.
 
x
 
=
 
-
 
prj
  
.
  !
x
! "
;
" #
nrm
 
.
 
y
 
=
 
-
 
prj
  
.
  !
y
! "
;
" #
nrm
ŸŸ 
.
ŸŸ 
z
ŸŸ 
=
ŸŸ 
-
ŸŸ 
prj
ŸŸ  
.
ŸŸ  !
z
ŸŸ! "
;
ŸŸ" #
}
   
else
¡¡ 
{
¢¢ 
nrm
££ 
.
££ 
x
££ 
=
££ 
prj
££ 
.
££  
x
££  !
;
££! "
nrm
¤¤ 
.
¤¤ 
y
¤¤ 
=
¤¤ 
prj
¤¤ 
.
¤¤  
y
¤¤  !
;
¤¤! "
nrm
¥¥ 
.
¥¥ 
z
¥¥ 
=
¥¥ 
prj
¥¥ 
.
¥¥  
z
¥¥  !
;
¥¥! "
}
¦¦ 
}
§§ 
return
©© 
nrm
©© 
;
©© 
}
ªª 	
internal
²² 
static
²² 
Vector3
²² 
Normal
²²  &
(
²²& '
IList
²²' ,
<
²², -
Vector3
²²- 4
>
²²4 5
p
²²6 7
)
²²7 8
{
³³ 	
if
´´ 
(
´´ 
p
´´ 
==
´´ 
null
´´ 
||
´´ 
p
´´ 
.
´´ 
Count
´´ $
<
´´% &
$num
´´' (
)
´´( )
return
µµ 
Vector3
µµ 
.
µµ 
zero
µµ #
;
µµ# $
int
·· 
c
·· 
=
·· 
p
·· 
.
·· 
Count
·· 
;
·· 
if
¹¹ 
(
¹¹ 
c
¹¹ 
%
¹¹ 
$num
¹¹ 
==
¹¹ 
$num
¹¹ 
)
¹¹ 
{
ºº 
Vector3
»» 
nrm
»» 
=
»» 
Vector3
»» %
.
»»% &
zero
»»& *
;
»»* +
for
¼¼ 
(
¼¼ 
int
¼¼ 
i
¼¼ 
=
¼¼ 
$num
¼¼ 
;
¼¼ 
i
¼¼  !
<
¼¼" #
c
¼¼$ %
;
¼¼% &
i
¼¼' (
+=
¼¼) +
$num
¼¼, -
)
¼¼- .
nrm
½½ 
+=
½½ 
Normal
½½ !
(
½½! "
p
½½" #
[
½½# $
i
½½$ %
+
½½& '
$num
½½( )
]
½½) *
,
½½* +
p
½½, -
[
½½- .
i
½½. /
+
½½0 1
$num
½½2 3
]
½½3 4
,
½½4 5
p
½½6 7
[
½½7 8
i
½½8 9
+
½½: ;
$num
½½< =
]
½½= >
)
½½> ?
;
½½? @
nrm
¾¾ 
/=
¾¾ 
(
¾¾ 
c
¾¾ 
/
¾¾ 
$num
¾¾ 
)
¾¾ 
;
¾¾  
nrm
¿¿ 
.
¿¿ 
	Normalize
¿¿ 
(
¿¿ 
)
¿¿ 
;
¿¿  
return
ÀÀ 
nrm
ÀÀ 
;
ÀÀ 
}
ÁÁ 
Vector3
ÂÂ 
cross
ÂÂ 
=
ÂÂ 
Vector3
ÂÂ #
.
ÂÂ# $
Cross
ÂÂ$ )
(
ÂÂ) *
p
ÂÂ* +
[
ÂÂ+ ,
$num
ÂÂ, -
]
ÂÂ- .
-
ÂÂ/ 0
p
ÂÂ1 2
[
ÂÂ2 3
$num
ÂÂ3 4
]
ÂÂ4 5
,
ÂÂ5 6
p
ÂÂ7 8
[
ÂÂ8 9
$num
ÂÂ9 :
]
ÂÂ: ;
-
ÂÂ< =
p
ÂÂ> ?
[
ÂÂ? @
$num
ÂÂ@ A
]
ÂÂA B
)
ÂÂB C
;
ÂÂC D
if
ÄÄ 
(
ÄÄ 
cross
ÄÄ 
.
ÄÄ 
	magnitude
ÄÄ 
<
ÄÄ  !
Mathf
ÄÄ" '
.
ÄÄ' (
Epsilon
ÄÄ( /
)
ÄÄ/ 0
return
ÅÅ 
new
ÅÅ 
Vector3
ÅÅ "
(
ÅÅ" #
$num
ÅÅ# %
,
ÅÅ% &
$num
ÅÅ' )
,
ÅÅ) *
$num
ÅÅ+ -
)
ÅÅ- .
;
ÅÅ. /
return
ÇÇ 
cross
ÇÇ 
.
ÇÇ 

normalized
ÇÇ #
;
ÇÇ# $
}
ÈÈ 	
public
ĞĞ 
static
ĞĞ 
Normal
ĞĞ $
NormalTangentBitangent
ĞĞ 3
(
ĞĞ3 4
ProBuilderMesh
ĞĞ4 B
mesh
ĞĞC G
,
ĞĞG H
Face
ĞĞI M
face
ĞĞN R
)
ĞĞR S
{
ÑÑ 	
if
ÒÒ 
(
ÒÒ 
mesh
ÒÒ 
==
ÒÒ 
null
ÒÒ 
||
ÒÒ 
face
ÒÒ  $
==
ÒÒ% '
null
ÒÒ( ,
||
ÒÒ- /
face
ÒÒ0 4
.
ÒÒ4 5
indexesInternal
ÒÒ5 D
.
ÒÒD E
Length
ÒÒE K
<
ÒÒL M
$num
ÒÒN O
)
ÒÒO P
throw
ÓÓ 
new
ÓÓ 
System
ÓÓ  
.
ÓÓ  !#
ArgumentNullException
ÓÓ! 6
(
ÓÓ6 7
$str
ÓÓ7 =
,
ÓÓ= >
$strÓÓ? —
)ÓÓ— ˜
;ÓÓ˜ ™
if
ÕÕ 
(
ÕÕ 
mesh
ÕÕ 
.
ÕÕ 
texturesInternal
ÕÕ %
==
ÕÕ& (
null
ÕÕ) -
||
ÕÕ. 0
mesh
ÕÕ1 5
.
ÕÕ5 6
texturesInternal
ÕÕ6 F
.
ÕÕF G
Length
ÕÕG M
!=
ÕÕN P
mesh
ÕÕQ U
.
ÕÕU V
vertexCount
ÕÕV a
)
ÕÕa b
throw
ÖÖ 
new
ÖÖ 
ArgumentException
ÖÖ +
(
ÖÖ+ ,
$str
ÖÖ, q
)
ÖÖq r
;
ÖÖr s
var
ØØ 
nrm
ØØ 
=
ØØ 
Math
ØØ 
.
ØØ 
Normal
ØØ !
(
ØØ! "
mesh
ØØ" &
,
ØØ& '
face
ØØ( ,
)
ØØ, -
;
ØØ- .
Vector3
ÚÚ 
tan1
ÚÚ 
=
ÚÚ 
Vector3
ÚÚ "
.
ÚÚ" #
zero
ÚÚ# '
;
ÚÚ' (
Vector3
ÛÛ 
tan2
ÛÛ 
=
ÛÛ 
Vector3
ÛÛ "
.
ÛÛ" #
zero
ÛÛ# '
;
ÛÛ' (
Vector4
ÜÜ 
tan
ÜÜ 
=
ÜÜ 
new
ÜÜ 
Vector4
ÜÜ %
(
ÜÜ% &
$num
ÜÜ& (
,
ÜÜ( )
$num
ÜÜ* ,
,
ÜÜ, -
$num
ÜÜ. 0
,
ÜÜ0 1
$num
ÜÜ2 4
)
ÜÜ4 5
;
ÜÜ5 6
long
ŞŞ 
i1
ŞŞ 
=
ŞŞ 
face
ŞŞ 
.
ŞŞ 
indexesInternal
ŞŞ *
[
ŞŞ* +
$num
ŞŞ+ ,
]
ŞŞ, -
;
ŞŞ- .
long
ßß 
i2
ßß 
=
ßß 
face
ßß 
.
ßß 
indexesInternal
ßß *
[
ßß* +
$num
ßß+ ,
]
ßß, -
;
ßß- .
long
àà 
i3
àà 
=
àà 
face
àà 
.
àà 
indexesInternal
àà *
[
àà* +
$num
àà+ ,
]
àà, -
;
àà- .
Vector3
ââ 
v1
ââ 
=
ââ 
mesh
ââ 
.
ââ 
positionsInternal
ââ /
[
ââ/ 0
i1
ââ0 2
]
ââ2 3
;
ââ3 4
Vector3
ãã 
v2
ãã 
=
ãã 
mesh
ãã 
.
ãã 
positionsInternal
ãã /
[
ãã/ 0
i2
ãã0 2
]
ãã2 3
;
ãã3 4
Vector3
ää 
v3
ää 
=
ää 
mesh
ää 
.
ää 
positionsInternal
ää /
[
ää/ 0
i3
ää0 2
]
ää2 3
;
ää3 4
Vector2
ææ 
w1
ææ 
=
ææ 
mesh
ææ 
.
ææ 
texturesInternal
ææ .
[
ææ. /
i1
ææ/ 1
]
ææ1 2
;
ææ2 3
Vector2
çç 
w2
çç 
=
çç 
mesh
çç 
.
çç 
texturesInternal
çç .
[
çç. /
i2
çç/ 1
]
çç1 2
;
çç2 3
Vector2
èè 
w3
èè 
=
èè 
mesh
èè 
.
èè 
texturesInternal
èè .
[
èè. /
i3
èè/ 1
]
èè1 2
;
èè2 3
float
êê 
x1
êê 
=
êê 
v2
êê 
.
êê 
x
êê 
-
êê 
v1
êê  
.
êê  !
x
êê! "
;
êê" #
float
ëë 
x2
ëë 
=
ëë 
v3
ëë 
.
ëë 
x
ëë 
-
ëë 
v1
ëë  
.
ëë  !
x
ëë! "
;
ëë" #
float
ìì 
y1
ìì 
=
ìì 
v2
ìì 
.
ìì 
y
ìì 
-
ìì 
v1
ìì  
.
ìì  !
y
ìì! "
;
ìì" #
float
íí 
y2
íí 
=
íí 
v3
íí 
.
íí 
y
íí 
-
íí 
v1
íí  
.
íí  !
y
íí! "
;
íí" #
float
îî 
z1
îî 
=
îî 
v2
îî 
.
îî 
z
îî 
-
îî 
v1
îî  
.
îî  !
z
îî! "
;
îî" #
float
ïï 
z2
ïï 
=
ïï 
v3
ïï 
.
ïï 
z
ïï 
-
ïï 
v1
ïï  
.
ïï  !
z
ïï! "
;
ïï" #
float
ññ 
s1
ññ 
=
ññ 
w2
ññ 
.
ññ 
x
ññ 
-
ññ 
w1
ññ  
.
ññ  !
x
ññ! "
;
ññ" #
float
òò 
s2
òò 
=
òò 
w3
òò 
.
òò 
x
òò 
-
òò 
w1
òò  
.
òò  !
x
òò! "
;
òò" #
float
óó 
t1
óó 
=
óó 
w2
óó 
.
óó 
y
óó 
-
óó 
w1
óó  
.
óó  !
y
óó! "
;
óó" #
float
ôô 
t2
ôô 
=
ôô 
w3
ôô 
.
ôô 
y
ôô 
-
ôô 
w1
ôô  
.
ôô  !
y
ôô! "
;
ôô" #
float
öö 
r
öö 
=
öö 
$num
öö 
/
öö 
(
öö 
s1
öö  
*
öö! "
t2
öö# %
-
öö& '
s2
öö( *
*
öö+ ,
t1
öö- /
)
öö/ 0
;
öö0 1
Vector3
øø 
sdir
øø 
=
øø 
new
øø 
Vector3
øø &
(
øø& '
(
øø' (
t2
øø( *
*
øø+ ,
x1
øø- /
-
øø0 1
t1
øø2 4
*
øø5 6
x2
øø7 9
)
øø9 :
*
øø; <
r
øø= >
,
øø> ?
(
øø@ A
t2
øøA C
*
øøD E
y1
øøF H
-
øøI J
t1
øøK M
*
øøN O
y2
øøP R
)
øøR S
*
øøT U
r
øøV W
,
øøW X
(
øøY Z
t2
øøZ \
*
øø] ^
z1
øø_ a
-
øøb c
t1
øød f
*
øøg h
z2
øøi k
)
øøk l
*
øøm n
r
øøo p
)
øøp q
;
øøq r
Vector3
ùù 
tdir
ùù 
=
ùù 
new
ùù 
Vector3
ùù &
(
ùù& '
(
ùù' (
s1
ùù( *
*
ùù+ ,
x2
ùù- /
-
ùù0 1
s2
ùù2 4
*
ùù5 6
x1
ùù7 9
)
ùù9 :
*
ùù; <
r
ùù= >
,
ùù> ?
(
ùù@ A
s1
ùùA C
*
ùùD E
y2
ùùF H
-
ùùI J
s2
ùùK M
*
ùùN O
y1
ùùP R
)
ùùR S
*
ùùT U
r
ùùV W
,
ùùW X
(
ùùY Z
s1
ùùZ \
*
ùù] ^
z2
ùù_ a
-
ùùb c
s2
ùùd f
*
ùùg h
z1
ùùi k
)
ùùk l
*
ùùm n
r
ùùo p
)
ùùp q
;
ùùq r
tan1
ûû 
+=
ûû 
sdir
ûû 
;
ûû 
tan2
üü 
+=
üü 
tdir
üü 
;
üü 
Vector3
şş 
n
şş 
=
şş 
nrm
şş 
;
şş 
Vector3
ÿÿ 
.
ÿÿ 
OrthoNormalize
ÿÿ "
(
ÿÿ" #
ref
ÿÿ# &
n
ÿÿ' (
,
ÿÿ( )
ref
ÿÿ* -
tan1
ÿÿ. 2
)
ÿÿ2 3
;
ÿÿ3 4
tan
 
.
 
x
 
=
 
tan1
 
.
 
x
 
;
 
tan
‚‚ 
.
‚‚ 
y
‚‚ 
=
‚‚ 
tan1
‚‚ 
.
‚‚ 
y
‚‚ 
;
‚‚ 
tan
ƒƒ 
.
ƒƒ 
z
ƒƒ 
=
ƒƒ 
tan1
ƒƒ 
.
ƒƒ 
z
ƒƒ 
;
ƒƒ 
tan
…… 
.
…… 
w
…… 
=
…… 
(
…… 
Vector3
…… 
.
…… 
Dot
……  
(
……  !
Vector3
……! (
.
……( )
Cross
……) .
(
……. /
n
……/ 0
,
……0 1
tan1
……2 6
)
……6 7
,
……7 8
tan2
……9 =
)
……= >
<
……? @
$num
……A E
)
……E F
?
……G H
-
……I J
$num
……J N
:
……O P
$num
……Q U
;
……U V
return
‡‡ 
new
‡‡ 
Normal
‡‡ 
(
‡‡ 
)
‡‡ 
{
ˆˆ 
normal
‰‰ 
=
‰‰ 
nrm
‰‰ 
,
‰‰ 
tangent
ŠŠ 
=
ŠŠ 
tan
ŠŠ 
,
ŠŠ 
	bitangent
‹‹ 
=
‹‹ 
Vector3
‹‹ #
.
‹‹# $
Cross
‹‹$ )
(
‹‹) *
nrm
‹‹* -
,
‹‹- .
(
‹‹/ 0
(
‹‹0 1
Vector3
‹‹1 8
)
‹‹8 9
tan
‹‹9 <
)
‹‹< =
*
‹‹> ?
tan
‹‹@ C
.
‹‹C D
w
‹‹D E
)
‹‹E F
}
ŒŒ 
;
ŒŒ 
}
 	
internal
•• 
static
•• 
bool
•• 
IsCardinalAxis
•• +
(
••+ ,
Vector3
••, 3
v
••4 5
,
••5 6
float
••7 <
epsilon
••= D
=
••E F
k_FltEpsilon
••G S
)
••S T
{
–– 	
if
—— 
(
—— 
v
—— 
==
—— 
Vector3
—— 
.
—— 
zero
—— !
)
——! "
return
˜˜ 
false
˜˜ 
;
˜˜ 
v
šš 
.
šš 
	Normalize
šš 
(
šš 
)
šš 
;
šš 
return
œœ 
(
œœ 
$num
œœ 
-
œœ 
Mathf
œœ 
.
œœ 
Abs
œœ "
(
œœ" #
Vector3
œœ# *
.
œœ* +
Dot
œœ+ .
(
œœ. /
Vector3
œœ/ 6
.
œœ6 7
up
œœ7 9
,
œœ9 :
v
œœ; <
)
œœ< =
)
œœ= >
)
œœ> ?
<
œœ@ A
epsilon
œœB I
||
œœJ L
(
 
$num
 
-
 
Mathf
 
.
 
Abs
 
(
  
Vector3
  '
.
' (
Dot
( +
(
+ ,
Vector3
, 3
.
3 4
forward
4 ;
,
; <
v
= >
)
> ?
)
? @
)
@ A
<
B C
epsilon
D K
||
L N
(
 
$num
 
-
 
Mathf
 
.
 
Abs
 
(
  
Vector3
  '
.
' (
Dot
( +
(
+ ,
Vector3
, 3
.
3 4
right
4 9
,
9 :
v
; <
)
< =
)
= >
)
> ?
<
@ A
epsilon
B I
;
I J
}
ŸŸ 	
internal
§§ 
static
§§ 
Vector2
§§ 
DivideBy
§§  (
(
§§( )
this
§§) -
Vector2
§§. 5
v
§§6 7
,
§§7 8
Vector2
§§9 @
o
§§A B
)
§§B C
{
¨¨ 	
return
©© 
new
©© 
Vector2
©© 
(
©© 
v
©©  
.
©©  !
x
©©! "
/
©©# $
o
©©% &
.
©©& '
x
©©' (
,
©©( )
v
©©* +
.
©©+ ,
y
©©, -
/
©©. /
o
©©0 1
.
©©1 2
y
©©2 3
)
©©3 4
;
©©4 5
}
ªª 	
internal
²² 
static
²² 
Vector3
²² 
DivideBy
²²  (
(
²²( )
this
²²) -
Vector3
²². 5
v
²²6 7
,
²²7 8
Vector3
²²9 @
o
²²A B
)
²²B C
{
³³ 	
return
´´ 
new
´´ 
Vector3
´´ 
(
´´ 
v
´´  
.
´´  !
x
´´! "
/
´´# $
o
´´% &
.
´´& '
x
´´' (
,
´´( )
v
´´* +
.
´´+ ,
y
´´, -
/
´´. /
o
´´0 1
.
´´1 2
y
´´2 3
,
´´3 4
v
´´5 6
.
´´6 7
z
´´7 8
/
´´9 :
o
´´; <
.
´´< =
z
´´= >
)
´´> ?
;
´´? @
}
µµ 	
internal
½½ 
static
½½ 
T
½½ 
Max
½½ 
<
½½ 
T
½½ 
>
½½  
(
½½  !
T
½½! "
[
½½" #
]
½½# $
array
½½% *
)
½½* +
where
½½, 1
T
½½2 3
:
½½4 5
System
½½6 <
.
½½< =
IComparable
½½= H
<
½½H I
T
½½I J
>
½½J K
{
¾¾ 	
if
¿¿ 
(
¿¿ 
array
¿¿ 
==
¿¿ 
null
¿¿ 
||
¿¿  
array
¿¿! &
.
¿¿& '
Length
¿¿' -
<
¿¿. /
$num
¿¿0 1
)
¿¿1 2
return
ÀÀ 
default
ÀÀ 
(
ÀÀ 
T
ÀÀ  
)
ÀÀ  !
;
ÀÀ! "
T
ÂÂ 
max
ÂÂ 
=
ÂÂ 
array
ÂÂ 
[
ÂÂ 
$num
ÂÂ 
]
ÂÂ 
;
ÂÂ 
for
ÃÃ 
(
ÃÃ 
int
ÃÃ 
i
ÃÃ 
=
ÃÃ 
$num
ÃÃ 
;
ÃÃ 
i
ÃÃ 
<
ÃÃ 
array
ÃÃ  %
.
ÃÃ% &
Length
ÃÃ& ,
;
ÃÃ, -
i
ÃÃ. /
++
ÃÃ/ 1
)
ÃÃ1 2
if
ÄÄ 
(
ÄÄ 
array
ÄÄ 
[
ÄÄ 
i
ÄÄ 
]
ÄÄ 
.
ÄÄ 
	CompareTo
ÄÄ &
(
ÄÄ& '
max
ÄÄ' *
)
ÄÄ* +
>=
ÄÄ, .
$num
ÄÄ/ 0
)
ÄÄ0 1
max
ÅÅ 
=
ÅÅ 
array
ÅÅ 
[
ÅÅ  
i
ÅÅ  !
]
ÅÅ! "
;
ÅÅ" #
return
ÆÆ 
max
ÆÆ 
;
ÆÆ 
}
ÇÇ 	
internal
ÏÏ 
static
ÏÏ 
T
ÏÏ 
Min
ÏÏ 
<
ÏÏ 
T
ÏÏ 
>
ÏÏ  
(
ÏÏ  !
T
ÏÏ! "
[
ÏÏ" #
]
ÏÏ# $
array
ÏÏ% *
)
ÏÏ* +
where
ÏÏ, 1
T
ÏÏ2 3
:
ÏÏ4 5
System
ÏÏ6 <
.
ÏÏ< =
IComparable
ÏÏ= H
<
ÏÏH I
T
ÏÏI J
>
ÏÏJ K
{
ĞĞ 	
if
ÑÑ 
(
ÑÑ 
array
ÑÑ 
==
ÑÑ 
null
ÑÑ 
||
ÑÑ  
array
ÑÑ! &
.
ÑÑ& '
Length
ÑÑ' -
<
ÑÑ. /
$num
ÑÑ0 1
)
ÑÑ1 2
return
ÒÒ 
default
ÒÒ 
(
ÒÒ 
T
ÒÒ  
)
ÒÒ  !
;
ÒÒ! "
T
ÔÔ 
min
ÔÔ 
=
ÔÔ 
array
ÔÔ 
[
ÔÔ 
$num
ÔÔ 
]
ÔÔ 
;
ÔÔ 
for
ÕÕ 
(
ÕÕ 
int
ÕÕ 
i
ÕÕ 
=
ÕÕ 
$num
ÕÕ 
;
ÕÕ 
i
ÕÕ 
<
ÕÕ 
array
ÕÕ  %
.
ÕÕ% &
Length
ÕÕ& ,
;
ÕÕ, -
i
ÕÕ. /
++
ÕÕ/ 1
)
ÕÕ1 2
if
ÖÖ 
(
ÖÖ 
array
ÖÖ 
[
ÖÖ 
i
ÖÖ 
]
ÖÖ 
.
ÖÖ 
	CompareTo
ÖÖ &
(
ÖÖ& '
min
ÖÖ' *
)
ÖÖ* +
<
ÖÖ, -
$num
ÖÖ. /
)
ÖÖ/ 0
min
×× 
=
×× 
array
×× 
[
××  
i
××  !
]
××! "
;
××" #
return
ØØ 
min
ØØ 
;
ØØ 
}
ÙÙ 	
internal
àà 
static
àà 
float
àà 
LargestValue
àà *
(
àà* +
Vector3
àà+ 2
v
àà3 4
)
àà4 5
{
áá 	
if
ââ 
(
ââ 
v
ââ 
.
ââ 
x
ââ 
>
ââ 
v
ââ 
.
ââ 
y
ââ 
&&
ââ 
v
ââ 
.
ââ 
x
ââ  
>
ââ! "
v
ââ# $
.
ââ$ %
z
ââ% &
)
ââ& '
return
ââ( .
v
ââ/ 0
.
ââ0 1
x
ââ1 2
;
ââ2 3
if
ãã 
(
ãã 
v
ãã 
.
ãã 
y
ãã 
>
ãã 
v
ãã 
.
ãã 
x
ãã 
&&
ãã 
v
ãã 
.
ãã 
y
ãã  
>
ãã! "
v
ãã# $
.
ãã$ %
z
ãã% &
)
ãã& '
return
ãã( .
v
ãã/ 0
.
ãã0 1
y
ãã1 2
;
ãã2 3
return
ää 
v
ää 
.
ää 
z
ää 
;
ää 
}
åå 	
internal
ìì 
static
ìì 
float
ìì 
LargestValue
ìì *
(
ìì* +
Vector2
ìì+ 2
v
ìì3 4
)
ìì4 5
{
íí 	
return
îî 
(
îî 
v
îî 
.
îî 
x
îî 
>
îî 
v
îî 
.
îî 
y
îî 
)
îî 
?
îî  
v
îî! "
.
îî" #
x
îî# $
:
îî% &
v
îî' (
.
îî( )
y
îî) *
;
îî* +
}
ïï 	
internal
öö 
static
öö 
Vector2
öö 
SmallestVector2
öö  /
(
öö/ 0
Vector2
öö0 7
[
öö7 8
]
öö8 9
v
öö: ;
)
öö; <
{
÷÷ 	
int
øø 
len
øø 
=
øø 
v
øø 
.
øø 
Length
øø 
;
øø 
Vector2
ùù 
l
ùù 
=
ùù 
v
ùù 
[
ùù 
$num
ùù 
]
ùù 
;
ùù 
for
úú 
(
úú 
int
úú 
i
úú 
=
úú 
$num
úú 
;
úú 
i
úú 
<
úú 
len
úú  #
;
úú# $
i
úú% &
++
úú& (
)
úú( )
{
ûû 
if
üü 
(
üü 
v
üü 
[
üü 
i
üü 
]
üü 
.
üü 
x
üü 
<
üü 
l
üü 
.
üü 
x
üü  
)
üü  !
l
üü" #
.
üü# $
x
üü$ %
=
üü& '
v
üü( )
[
üü) *
i
üü* +
]
üü+ ,
.
üü, -
x
üü- .
;
üü. /
if
ıı 
(
ıı 
v
ıı 
[
ıı 
i
ıı 
]
ıı 
.
ıı 
y
ıı 
<
ıı 
l
ıı 
.
ıı 
y
ıı  
)
ıı  !
l
ıı" #
.
ıı# $
y
ıı$ %
=
ıı& '
v
ıı( )
[
ıı) *
i
ıı* +
]
ıı+ ,
.
ıı, -
y
ıı- .
;
ıı. /
}
şş 
return
ÿÿ 
l
ÿÿ 
;
ÿÿ 
}
€€ 	
internal
ˆˆ 
static
ˆˆ 
Vector2
ˆˆ 
SmallestVector2
ˆˆ  /
(
ˆˆ/ 0
Vector2
ˆˆ0 7
[
ˆˆ7 8
]
ˆˆ8 9
v
ˆˆ: ;
,
ˆˆ; <
int
ˆˆ= @
[
ˆˆ@ A
]
ˆˆA B
indexes
ˆˆC J
)
ˆˆJ K
{
‰‰ 	
int
ŠŠ 
len
ŠŠ 
=
ŠŠ 
indexes
ŠŠ 
.
ŠŠ 
Length
ŠŠ $
;
ŠŠ$ %
Vector2
‹‹ 
l
‹‹ 
=
‹‹ 
v
‹‹ 
[
‹‹ 
indexes
‹‹ !
[
‹‹! "
$num
‹‹" #
]
‹‹# $
]
‹‹$ %
;
‹‹% &
for
ŒŒ 
(
ŒŒ 
int
ŒŒ 
i
ŒŒ 
=
ŒŒ 
$num
ŒŒ 
;
ŒŒ 
i
ŒŒ 
<
ŒŒ 
len
ŒŒ  #
;
ŒŒ# $
i
ŒŒ% &
++
ŒŒ& (
)
ŒŒ( )
{
 
if
 
(
 
v
 
[
 
indexes
 
[
 
i
 
]
  
]
  !
.
! "
x
" #
<
$ %
l
& '
.
' (
x
( )
)
) *
l
+ ,
.
, -
x
- .
=
/ 0
v
1 2
[
2 3
indexes
3 :
[
: ;
i
; <
]
< =
]
= >
.
> ?
x
? @
;
@ A
if
 
(
 
v
 
[
 
indexes
 
[
 
i
 
]
  
]
  !
.
! "
y
" #
<
$ %
l
& '
.
' (
y
( )
)
) *
l
+ ,
.
, -
y
- .
=
/ 0
v
1 2
[
2 3
indexes
3 :
[
: ;
i
; <
]
< =
]
= >
.
> ?
y
? @
;
@ A
}
 
return
‘‘ 
l
‘‘ 
;
‘‘ 
}
’’ 	
internal
”” 
static
”” 
Vector2
”” 
SmallestVector2
””  /
(
””/ 0
Vector2
””0 7
[
””7 8
]
””8 9
v
””: ;
,
””; <
IList
””= B
<
””B C
int
””C F
>
””F G
indexes
””H O
)
””O P
{
•• 	
int
–– 
len
–– 
=
–– 
indexes
–– 
.
–– 
Count
–– #
;
––# $
Vector2
—— 
l
—— 
=
—— 
v
—— 
[
—— 
indexes
—— !
[
——! "
$num
——" #
]
——# $
]
——$ %
;
——% &
for
˜˜ 
(
˜˜ 
int
˜˜ 
i
˜˜ 
=
˜˜ 
$num
˜˜ 
;
˜˜ 
i
˜˜ 
<
˜˜ 
len
˜˜  #
;
˜˜# $
i
˜˜% &
++
˜˜& (
)
˜˜( )
{
™™ 
if
šš 
(
šš 
v
šš 
[
šš 
indexes
šš 
[
šš 
i
šš 
]
šš  
]
šš  !
.
šš! "
x
šš" #
<
šš$ %
l
šš& '
.
šš' (
x
šš( )
)
šš) *
l
šš+ ,
.
šš, -
x
šš- .
=
šš/ 0
v
šš1 2
[
šš2 3
indexes
šš3 :
[
šš: ;
i
šš; <
]
šš< =
]
šš= >
.
šš> ?
x
šš? @
;
šš@ A
if
›› 
(
›› 
v
›› 
[
›› 
indexes
›› 
[
›› 
i
›› 
]
››  
]
››  !
.
››! "
y
››" #
<
››$ %
l
››& '
.
››' (
y
››( )
)
››) *
l
››+ ,
.
››, -
y
››- .
=
››/ 0
v
››1 2
[
››2 3
indexes
››3 :
[
››: ;
i
››; <
]
››< =
]
››= >
.
››> ?
y
››? @
;
››@ A
}
œœ 
return
 
l
 
;
 
}
 	
internal
¥¥ 
static
¥¥ 
Vector2
¥¥ 
LargestVector2
¥¥  .
(
¥¥. /
Vector2
¥¥/ 6
[
¥¥6 7
]
¥¥7 8
v
¥¥9 :
)
¥¥: ;
{
¦¦ 	
int
§§ 
len
§§ 
=
§§ 
v
§§ 
.
§§ 
Length
§§ 
;
§§ 
Vector2
¨¨ 
l
¨¨ 
=
¨¨ 
v
¨¨ 
[
¨¨ 
$num
¨¨ 
]
¨¨ 
;
¨¨ 
for
©© 
(
©© 
int
©© 
i
©© 
=
©© 
$num
©© 
;
©© 
i
©© 
<
©© 
len
©©  #
;
©©# $
i
©©% &
++
©©& (
)
©©( )
{
ªª 
if
«« 
(
«« 
v
«« 
[
«« 
i
«« 
]
«« 
.
«« 
x
«« 
>
«« 
l
«« 
.
«« 
x
««  
)
««  !
l
««" #
.
««# $
x
««$ %
=
««& '
v
««( )
[
««) *
i
««* +
]
««+ ,
.
««, -
x
««- .
;
««. /
if
¬¬ 
(
¬¬ 
v
¬¬ 
[
¬¬ 
i
¬¬ 
]
¬¬ 
.
¬¬ 
y
¬¬ 
>
¬¬ 
l
¬¬ 
.
¬¬ 
y
¬¬  
)
¬¬  !
l
¬¬" #
.
¬¬# $
y
¬¬$ %
=
¬¬& '
v
¬¬( )
[
¬¬) *
i
¬¬* +
]
¬¬+ ,
.
¬¬, -
y
¬¬- .
;
¬¬. /
}
­­ 
return
®® 
l
®® 
;
®® 
}
¯¯ 	
internal
±± 
static
±± 
Vector2
±± 
LargestVector2
±±  .
(
±±. /
Vector2
±±/ 6
[
±±6 7
]
±±7 8
v
±±9 :
,
±±: ;
int
±±< ?
[
±±? @
]
±±@ A
indexes
±±B I
)
±±I J
{
²² 	
int
³³ 
len
³³ 
=
³³ 
indexes
³³ 
.
³³ 
Length
³³ $
;
³³$ %
Vector2
´´ 
l
´´ 
=
´´ 
v
´´ 
[
´´ 
indexes
´´ !
[
´´! "
$num
´´" #
]
´´# $
]
´´$ %
;
´´% &
for
µµ 
(
µµ 
int
µµ 
i
µµ 
=
µµ 
$num
µµ 
;
µµ 
i
µµ 
<
µµ 
len
µµ  #
;
µµ# $
i
µµ% &
++
µµ& (
)
µµ( )
{
¶¶ 
if
·· 
(
·· 
v
·· 
[
·· 
indexes
·· 
[
·· 
i
·· 
]
··  
]
··  !
.
··! "
x
··" #
>
··$ %
l
··& '
.
··' (
x
··( )
)
··) *
l
··+ ,
.
··, -
x
··- .
=
··/ 0
v
··1 2
[
··2 3
indexes
··3 :
[
··: ;
i
··; <
]
··< =
]
··= >
.
··> ?
x
··? @
;
··@ A
if
¸¸ 
(
¸¸ 
v
¸¸ 
[
¸¸ 
indexes
¸¸ 
[
¸¸ 
i
¸¸ 
]
¸¸  
]
¸¸  !
.
¸¸! "
y
¸¸" #
>
¸¸$ %
l
¸¸& '
.
¸¸' (
y
¸¸( )
)
¸¸) *
l
¸¸+ ,
.
¸¸, -
y
¸¸- .
=
¸¸/ 0
v
¸¸1 2
[
¸¸2 3
indexes
¸¸3 :
[
¸¸: ;
i
¸¸; <
]
¸¸< =
]
¸¸= >
.
¸¸> ?
y
¸¸? @
;
¸¸@ A
}
¹¹ 
return
ºº 
l
ºº 
;
ºº 
}
»» 	
internal
½½ 
static
½½ 
Vector2
½½ 
LargestVector2
½½  .
(
½½. /
Vector2
½½/ 6
[
½½6 7
]
½½7 8
v
½½9 :
,
½½: ;
IList
½½< A
<
½½A B
int
½½B E
>
½½E F
indexes
½½G N
)
½½N O
{
¾¾ 	
int
¿¿ 
len
¿¿ 
=
¿¿ 
indexes
¿¿ 
.
¿¿ 
Count
¿¿ #
;
¿¿# $
Vector2
ÀÀ 
l
ÀÀ 
=
ÀÀ 
v
ÀÀ 
[
ÀÀ 
indexes
ÀÀ !
[
ÀÀ! "
$num
ÀÀ" #
]
ÀÀ# $
]
ÀÀ$ %
;
ÀÀ% &
for
ÁÁ 
(
ÁÁ 
int
ÁÁ 
i
ÁÁ 
=
ÁÁ 
$num
ÁÁ 
;
ÁÁ 
i
ÁÁ 
<
ÁÁ 
len
ÁÁ  #
;
ÁÁ# $
i
ÁÁ% &
++
ÁÁ& (
)
ÁÁ( )
{
ÂÂ 
if
ÃÃ 
(
ÃÃ 
v
ÃÃ 
[
ÃÃ 
indexes
ÃÃ 
[
ÃÃ 
i
ÃÃ 
]
ÃÃ  
]
ÃÃ  !
.
ÃÃ! "
x
ÃÃ" #
>
ÃÃ$ %
l
ÃÃ& '
.
ÃÃ' (
x
ÃÃ( )
)
ÃÃ) *
l
ÃÃ+ ,
.
ÃÃ, -
x
ÃÃ- .
=
ÃÃ/ 0
v
ÃÃ1 2
[
ÃÃ2 3
indexes
ÃÃ3 :
[
ÃÃ: ;
i
ÃÃ; <
]
ÃÃ< =
]
ÃÃ= >
.
ÃÃ> ?
x
ÃÃ? @
;
ÃÃ@ A
if
ÄÄ 
(
ÄÄ 
v
ÄÄ 
[
ÄÄ 
indexes
ÄÄ 
[
ÄÄ 
i
ÄÄ 
]
ÄÄ  
]
ÄÄ  !
.
ÄÄ! "
y
ÄÄ" #
>
ÄÄ$ %
l
ÄÄ& '
.
ÄÄ' (
y
ÄÄ( )
)
ÄÄ) *
l
ÄÄ+ ,
.
ÄÄ, -
y
ÄÄ- .
=
ÄÄ/ 0
v
ÄÄ1 2
[
ÄÄ2 3
indexes
ÄÄ3 :
[
ÄÄ: ;
i
ÄÄ; <
]
ÄÄ< =
]
ÄÄ= >
.
ÄÄ> ?
y
ÄÄ? @
;
ÄÄ@ A
}
ÅÅ 
return
ÆÆ 
l
ÆÆ 
;
ÆÆ 
}
ÇÇ 	
internal
ÎÎ 
static
ÎÎ 
Bounds
ÎÎ 
	GetBounds
ÎÎ (
(
ÎÎ( )
Vector3
ÎÎ) 0
[
ÎÎ0 1
]
ÎÎ1 2
	positions
ÎÎ3 <
,
ÎÎ< =
IList
ÎÎ> C
<
ÎÎC D
int
ÎÎD G
>
ÎÎG H
indices
ÎÎI P
=
ÎÎQ R
null
ÎÎS W
)
ÎÎW X
{
ÏÏ 	
bool
ĞĞ 

hasIndices
ĞĞ 
=
ĞĞ 
indices
ĞĞ %
!=
ĞĞ& (
null
ĞĞ) -
;
ĞĞ- .
if
ÒÒ 
(
ÒÒ 
(
ÒÒ 

hasIndices
ÒÒ 
&&
ÒÒ 
indices
ÒÒ &
.
ÒÒ& '
Count
ÒÒ' ,
<
ÒÒ- .
$num
ÒÒ/ 0
)
ÒÒ0 1
||
ÒÒ2 4
	positions
ÒÒ5 >
.
ÒÒ> ?
Length
ÒÒ? E
<
ÒÒF G
$num
ÒÒH I
)
ÒÒI J
return
ÓÓ 
default
ÓÓ 
(
ÓÓ 
Bounds
ÓÓ %
)
ÓÓ% &
;
ÓÓ& '
Vector3
ÕÕ 
min
ÕÕ 
=
ÕÕ 
	positions
ÕÕ #
[
ÕÕ# $

hasIndices
ÕÕ$ .
?
ÕÕ/ 0
indices
ÕÕ1 8
[
ÕÕ8 9
$num
ÕÕ9 :
]
ÕÕ: ;
:
ÕÕ< =
$num
ÕÕ> ?
]
ÕÕ? @
;
ÕÕ@ A
Vector3
ÖÖ 
max
ÖÖ 
=
ÖÖ 
min
ÖÖ 
;
ÖÖ 
if
ØØ 
(
ØØ 

hasIndices
ØØ 
)
ØØ 
{
ÙÙ 
for
ÚÚ 
(
ÚÚ 
int
ÚÚ 
i
ÚÚ 
=
ÚÚ 
$num
ÚÚ 
,
ÚÚ 
c
ÚÚ  !
=
ÚÚ" #
indices
ÚÚ$ +
.
ÚÚ+ ,
Count
ÚÚ, 1
;
ÚÚ1 2
i
ÚÚ3 4
<
ÚÚ5 6
c
ÚÚ7 8
;
ÚÚ8 9
i
ÚÚ: ;
++
ÚÚ; =
)
ÚÚ= >
{
ÛÛ 
min
ÜÜ 
.
ÜÜ 
x
ÜÜ 
=
ÜÜ 
Mathf
ÜÜ !
.
ÜÜ! "
Min
ÜÜ" %
(
ÜÜ% &
	positions
ÜÜ& /
[
ÜÜ/ 0
indices
ÜÜ0 7
[
ÜÜ7 8
i
ÜÜ8 9
]
ÜÜ9 :
]
ÜÜ: ;
.
ÜÜ; <
x
ÜÜ< =
,
ÜÜ= >
min
ÜÜ? B
.
ÜÜB C
x
ÜÜC D
)
ÜÜD E
;
ÜÜE F
max
İİ 
.
İİ 
x
İİ 
=
İİ 
Mathf
İİ !
.
İİ! "
Max
İİ" %
(
İİ% &
	positions
İİ& /
[
İİ/ 0
indices
İİ0 7
[
İİ7 8
i
İİ8 9
]
İİ9 :
]
İİ: ;
.
İİ; <
x
İİ< =
,
İİ= >
max
İİ? B
.
İİB C
x
İİC D
)
İİD E
;
İİE F
min
ßß 
.
ßß 
y
ßß 
=
ßß 
Mathf
ßß !
.
ßß! "
Min
ßß" %
(
ßß% &
	positions
ßß& /
[
ßß/ 0
indices
ßß0 7
[
ßß7 8
i
ßß8 9
]
ßß9 :
]
ßß: ;
.
ßß; <
y
ßß< =
,
ßß= >
min
ßß? B
.
ßßB C
y
ßßC D
)
ßßD E
;
ßßE F
max
àà 
.
àà 
y
àà 
=
àà 
Mathf
àà !
.
àà! "
Max
àà" %
(
àà% &
	positions
àà& /
[
àà/ 0
indices
àà0 7
[
àà7 8
i
àà8 9
]
àà9 :
]
àà: ;
.
àà; <
y
àà< =
,
àà= >
max
àà? B
.
ààB C
y
ààC D
)
ààD E
;
ààE F
min
ââ 
.
ââ 
z
ââ 
=
ââ 
Mathf
ââ !
.
ââ! "
Min
ââ" %
(
ââ% &
	positions
ââ& /
[
ââ/ 0
indices
ââ0 7
[
ââ7 8
i
ââ8 9
]
ââ9 :
]
ââ: ;
.
ââ; <
z
ââ< =
,
ââ= >
min
ââ? B
.
ââB C
z
ââC D
)
ââD E
;
ââE F
max
ãã 
.
ãã 
z
ãã 
=
ãã 
Mathf
ãã !
.
ãã! "
Max
ãã" %
(
ãã% &
	positions
ãã& /
[
ãã/ 0
indices
ãã0 7
[
ãã7 8
i
ãã8 9
]
ãã9 :
]
ãã: ;
.
ãã; <
z
ãã< =
,
ãã= >
max
ãã? B
.
ããB C
z
ããC D
)
ããD E
;
ããE F
}
ää 
}
åå 
else
ææ 
{
çç 
for
èè 
(
èè 
int
èè 
i
èè 
=
èè 
$num
èè 
,
èè 
c
èè  !
=
èè" #
	positions
èè$ -
.
èè- .
Length
èè. 4
;
èè4 5
i
èè6 7
<
èè8 9
c
èè: ;
;
èè; <
i
èè= >
++
èè> @
)
èè@ A
{
éé 
min
êê 
.
êê 
x
êê 
=
êê 
Mathf
êê !
.
êê! "
Min
êê" %
(
êê% &
	positions
êê& /
[
êê/ 0
i
êê0 1
]
êê1 2
.
êê2 3
x
êê3 4
,
êê4 5
min
êê6 9
.
êê9 :
x
êê: ;
)
êê; <
;
êê< =
max
ëë 
.
ëë 
x
ëë 
=
ëë 
Mathf
ëë !
.
ëë! "
Max
ëë" %
(
ëë% &
	positions
ëë& /
[
ëë/ 0
i
ëë0 1
]
ëë1 2
.
ëë2 3
x
ëë3 4
,
ëë4 5
max
ëë6 9
.
ëë9 :
x
ëë: ;
)
ëë; <
;
ëë< =
min
íí 
.
íí 
y
íí 
=
íí 
Mathf
íí !
.
íí! "
Min
íí" %
(
íí% &
	positions
íí& /
[
íí/ 0
i
íí0 1
]
íí1 2
.
íí2 3
y
íí3 4
,
íí4 5
min
íí6 9
.
íí9 :
y
íí: ;
)
íí; <
;
íí< =
max
îî 
.
îî 
y
îî 
=
îî 
Mathf
îî !
.
îî! "
Max
îî" %
(
îî% &
	positions
îî& /
[
îî/ 0
i
îî0 1
]
îî1 2
.
îî2 3
y
îî3 4
,
îî4 5
max
îî6 9
.
îî9 :
y
îî: ;
)
îî; <
;
îî< =
min
ğğ 
.
ğğ 
z
ğğ 
=
ğğ 
Mathf
ğğ !
.
ğğ! "
Min
ğğ" %
(
ğğ% &
	positions
ğğ& /
[
ğğ/ 0
i
ğğ0 1
]
ğğ1 2
.
ğğ2 3
z
ğğ3 4
,
ğğ4 5
min
ğğ6 9
.
ğğ9 :
z
ğğ: ;
)
ğğ; <
;
ğğ< =
max
ññ 
.
ññ 
z
ññ 
=
ññ 
Mathf
ññ !
.
ññ! "
Max
ññ" %
(
ññ% &
	positions
ññ& /
[
ññ/ 0
i
ññ0 1
]
ññ1 2
.
ññ2 3
z
ññ3 4
,
ññ4 5
max
ññ6 9
.
ññ9 :
z
ññ: ;
)
ññ; <
;
ññ< =
}
òò 
}
óó 
return
õõ 
new
õõ 
Bounds
õõ 
(
õõ 
(
õõ 
min
õõ "
+
õõ# $
max
õõ% (
)
õõ( )
*
õõ* +
$num
õõ, /
,
õõ/ 0
max
õõ1 4
-
õõ5 6
min
õõ7 :
)
õõ: ;
;
õõ; <
}
öö 	
internal
ıı 
static
ıı 
Bounds
ıı 
	GetBounds
ıı (
(
ıı( )
Vector3
ıı) 0
[
ıı0 1
]
ıı1 2
	positions
ıı3 <
,
ıı< =
IEnumerable
ıı> I
<
ııI J
Face
ııJ N
>
ııN O
faces
ııP U
)
ııU V
{
şş 	
bool
ÿÿ 
initialized
ÿÿ 
=
ÿÿ 
false
ÿÿ $
;
ÿÿ$ %
Vector3
 
min
 
=
 
Vector3
 !
.
! "
zero
" &
;
& '
Vector3
‚‚ 
max
‚‚ 
=
‚‚ 
min
‚‚ 
;
‚‚ 
foreach
„„ 
(
„„ 
var
„„ 
face
„„ 
in
„„  
faces
„„! &
)
„„& '
{
…… 
var
†† 
indices
†† 
=
†† 
face
†† "
.
††" #%
distinctIndexesInternal
††# :
;
††: ;
if
ˆˆ 
(
ˆˆ 
!
ˆˆ 
initialized
ˆˆ  
)
ˆˆ  !
{
‰‰ 
initialized
ŠŠ 
=
ŠŠ  !
true
ŠŠ" &
;
ŠŠ& '
min
‹‹ 
=
‹‹ 
	positions
‹‹ #
[
‹‹# $
indices
‹‹$ +
[
‹‹+ ,
$num
‹‹, -
]
‹‹- .
]
‹‹. /
;
‹‹/ 0
max
ŒŒ 
=
ŒŒ 
	positions
ŒŒ #
[
ŒŒ# $
indices
ŒŒ$ +
[
ŒŒ+ ,
$num
ŒŒ, -
]
ŒŒ- .
]
ŒŒ. /
;
ŒŒ/ 0
}
 
for
 
(
 
int
 
i
 
=
 
$num
 
,
 
c
  !
=
" #
indices
$ +
.
+ ,
Length
, 2
;
2 3
i
4 5
<
6 7
c
8 9
;
9 :
i
; <
++
< >
)
> ?
{
 
min
‘‘ 
.
‘‘ 
x
‘‘ 
=
‘‘ 
Mathf
‘‘ !
.
‘‘! "
Min
‘‘" %
(
‘‘% &
	positions
‘‘& /
[
‘‘/ 0
indices
‘‘0 7
[
‘‘7 8
i
‘‘8 9
]
‘‘9 :
]
‘‘: ;
.
‘‘; <
x
‘‘< =
,
‘‘= >
min
‘‘? B
.
‘‘B C
x
‘‘C D
)
‘‘D E
;
‘‘E F
max
’’ 
.
’’ 
x
’’ 
=
’’ 
Mathf
’’ !
.
’’! "
Max
’’" %
(
’’% &
	positions
’’& /
[
’’/ 0
indices
’’0 7
[
’’7 8
i
’’8 9
]
’’9 :
]
’’: ;
.
’’; <
x
’’< =
,
’’= >
max
’’? B
.
’’B C
x
’’C D
)
’’D E
;
’’E F
min
”” 
.
”” 
y
”” 
=
”” 
Mathf
”” !
.
””! "
Min
””" %
(
””% &
	positions
””& /
[
””/ 0
indices
””0 7
[
””7 8
i
””8 9
]
””9 :
]
””: ;
.
””; <
y
””< =
,
””= >
min
””? B
.
””B C
y
””C D
)
””D E
;
””E F
max
•• 
.
•• 
y
•• 
=
•• 
Mathf
•• !
.
••! "
Max
••" %
(
••% &
	positions
••& /
[
••/ 0
indices
••0 7
[
••7 8
i
••8 9
]
••9 :
]
••: ;
.
••; <
y
••< =
,
••= >
max
••? B
.
••B C
y
••C D
)
••D E
;
••E F
min
—— 
.
—— 
z
—— 
=
—— 
Mathf
—— !
.
——! "
Min
——" %
(
——% &
	positions
——& /
[
——/ 0
indices
——0 7
[
——7 8
i
——8 9
]
——9 :
]
——: ;
.
——; <
z
——< =
,
——= >
min
——? B
.
——B C
z
——C D
)
——D E
;
——E F
max
˜˜ 
.
˜˜ 
z
˜˜ 
=
˜˜ 
Mathf
˜˜ !
.
˜˜! "
Max
˜˜" %
(
˜˜% &
	positions
˜˜& /
[
˜˜/ 0
indices
˜˜0 7
[
˜˜7 8
i
˜˜8 9
]
˜˜9 :
]
˜˜: ;
.
˜˜; <
z
˜˜< =
,
˜˜= >
max
˜˜? B
.
˜˜B C
z
˜˜C D
)
˜˜D E
;
˜˜E F
}
™™ 
}
šš 
return
œœ 
new
œœ 
Bounds
œœ 
(
œœ 
(
œœ 
min
œœ "
+
œœ# $
max
œœ% (
)
œœ( )
*
œœ* +
$num
œœ, /
,
œœ/ 0
max
œœ1 4
-
œœ5 6
min
œœ7 :
)
œœ: ;
;
œœ; <
}
 	
static
ŸŸ 
Vector3
ŸŸ 
ComponentMin
ŸŸ #
(
ŸŸ# $
Vector3
ŸŸ$ +
a
ŸŸ, -
,
ŸŸ- .
Vector3
ŸŸ/ 6
b
ŸŸ7 8
)
ŸŸ8 9
{
   	
return
¡¡ 
new
¡¡ 
Vector3
¡¡ 
(
¡¡ 
Mathf
¡¡ $
.
¡¡$ %
Min
¡¡% (
(
¡¡( )
a
¡¡) *
.
¡¡* +
x
¡¡+ ,
,
¡¡, -
b
¡¡. /
.
¡¡/ 0
x
¡¡0 1
)
¡¡1 2
,
¡¡2 3
Mathf
¡¡4 9
.
¡¡9 :
Min
¡¡: =
(
¡¡= >
a
¡¡> ?
.
¡¡? @
y
¡¡@ A
,
¡¡A B
b
¡¡C D
.
¡¡D E
y
¡¡E F
)
¡¡F G
,
¡¡G H
Mathf
¡¡I N
.
¡¡N O
Min
¡¡O R
(
¡¡R S
a
¡¡S T
.
¡¡T U
z
¡¡U V
,
¡¡V W
b
¡¡X Y
.
¡¡Y Z
z
¡¡Z [
)
¡¡[ \
)
¡¡\ ]
;
¡¡] ^
}
¢¢ 	
static
¤¤ 
Vector3
¤¤ 
ComponentMax
¤¤ #
(
¤¤# $
Vector3
¤¤$ +
a
¤¤, -
,
¤¤- .
Vector3
¤¤/ 6
b
¤¤7 8
)
¤¤8 9
{
¥¥ 	
return
¦¦ 
new
¦¦ 
Vector3
¦¦ 
(
¦¦ 
Mathf
¦¦ $
.
¦¦$ %
Max
¦¦% (
(
¦¦( )
a
¦¦) *
.
¦¦* +
x
¦¦+ ,
,
¦¦, -
b
¦¦. /
.
¦¦/ 0
x
¦¦0 1
)
¦¦1 2
,
¦¦2 3
Mathf
¦¦4 9
.
¦¦9 :
Max
¦¦: =
(
¦¦= >
a
¦¦> ?
.
¦¦? @
y
¦¦@ A
,
¦¦A B
b
¦¦C D
.
¦¦D E
y
¦¦E F
)
¦¦F G
,
¦¦G H
Mathf
¦¦I N
.
¦¦N O
Max
¦¦O R
(
¦¦R S
a
¦¦S T
.
¦¦T U
z
¦¦U V
,
¦¦V W
b
¦¦X Y
.
¦¦Y Z
z
¦¦Z [
)
¦¦[ \
)
¦¦\ ]
;
¦¦] ^
}
§§ 	
internal
®® 
static
®® 
Bounds
®® 
	GetBounds
®® (
(
®®( )
Vector3
®®) 0
[
®®0 1
]
®®1 2
	positions
®®3 <
,
®®< =
IEnumerable
®®> I
<
®®I J
Edge
®®J N
>
®®N O
edges
®®P U
)
®®U V
{
¯¯ 	
bool
°° 
initialized
°° 
=
°° 
false
°° $
;
°°$ %
Vector3
²² 
min
²² 
=
²² 
Vector3
²² !
.
²²! "
zero
²²" &
;
²²& '
Vector3
³³ 
max
³³ 
=
³³ 
min
³³ 
;
³³ 
foreach
µµ 
(
µµ 
var
µµ 
edge
µµ 
in
µµ  
edges
µµ! &
)
µµ& '
{
¶¶ 
if
·· 
(
·· 
!
·· 
initialized
··  
)
··  !
{
¸¸ 
initialized
¹¹ 
=
¹¹  !
true
¹¹" &
;
¹¹& '
min
ºº 
=
ºº 
	positions
ºº #
[
ºº# $
edge
ºº$ (
.
ºº( )
a
ºº) *
]
ºº* +
;
ºº+ ,
max
»» 
=
»» 
	positions
»» #
[
»»# $
edge
»»$ (
.
»»( )
a
»») *
]
»»* +
;
»»+ ,
}
¼¼ 
min
¾¾ 
=
¾¾ 
ComponentMin
¾¾ "
(
¾¾" #
	positions
¾¾# ,
[
¾¾, -
edge
¾¾- 1
.
¾¾1 2
a
¾¾2 3
]
¾¾3 4
,
¾¾4 5
min
¾¾6 9
)
¾¾9 :
;
¾¾: ;
max
¿¿ 
=
¿¿ 
ComponentMax
¿¿ "
(
¿¿" #
	positions
¿¿# ,
[
¿¿, -
edge
¿¿- 1
.
¿¿1 2
a
¿¿2 3
]
¿¿3 4
,
¿¿4 5
max
¿¿6 9
)
¿¿9 :
;
¿¿: ;
min
ÁÁ 
=
ÁÁ 
ComponentMin
ÁÁ "
(
ÁÁ" #
	positions
ÁÁ# ,
[
ÁÁ, -
edge
ÁÁ- 1
.
ÁÁ1 2
b
ÁÁ2 3
]
ÁÁ3 4
,
ÁÁ4 5
min
ÁÁ6 9
)
ÁÁ9 :
;
ÁÁ: ;
max
ÂÂ 
=
ÂÂ 
ComponentMax
ÂÂ "
(
ÂÂ" #
	positions
ÂÂ# ,
[
ÂÂ, -
edge
ÂÂ- 1
.
ÂÂ1 2
b
ÂÂ2 3
]
ÂÂ3 4
,
ÂÂ4 5
max
ÂÂ6 9
)
ÂÂ9 :
;
ÂÂ: ;
}
ÃÃ 
return
ÅÅ 
new
ÅÅ 
Bounds
ÅÅ 
(
ÅÅ 
(
ÅÅ 
min
ÅÅ "
+
ÅÅ# $
max
ÅÅ% (
)
ÅÅ( )
*
ÅÅ* +
$num
ÅÅ, /
,
ÅÅ/ 0
max
ÅÅ1 4
-
ÅÅ5 6
min
ÅÅ7 :
)
ÅÅ: ;
;
ÅÅ; <
}
ÆÆ 	
public
ÎÎ 
static
ÎÎ 
Vector2
ÎÎ 
Average
ÎÎ %
(
ÎÎ% &
IList
ÎÎ& +
<
ÎÎ+ ,
Vector2
ÎÎ, 3
>
ÎÎ3 4
array
ÎÎ5 :
,
ÎÎ: ;
IList
ÎÎ< A
<
ÎÎA B
int
ÎÎB E
>
ÎÎE F
indexes
ÎÎG N
=
ÎÎO P
null
ÎÎQ U
)
ÎÎU V
{
ÏÏ 	
if
ĞĞ 
(
ĞĞ 
array
ĞĞ 
==
ĞĞ 
null
ĞĞ 
)
ĞĞ 
throw
ÑÑ 
new
ÑÑ #
ArgumentNullException
ÑÑ /
(
ÑÑ/ 0
$str
ÑÑ0 7
)
ÑÑ7 8
;
ÑÑ8 9
Vector2
ÓÓ 
sum
ÓÓ 
=
ÓÓ 
Vector2
ÓÓ !
.
ÓÓ! "
zero
ÓÓ" &
;
ÓÓ& '
float
ÔÔ 
len
ÔÔ 
=
ÔÔ 
indexes
ÔÔ 
==
ÔÔ  "
null
ÔÔ# '
?
ÔÔ( )
array
ÔÔ* /
.
ÔÔ/ 0
Count
ÔÔ0 5
:
ÔÔ6 7
indexes
ÔÔ8 ?
.
ÔÔ? @
Count
ÔÔ@ E
;
ÔÔE F
if
ÖÖ 
(
ÖÖ 
indexes
ÖÖ 
==
ÖÖ 
null
ÖÖ 
)
ÖÖ  
for
×× 
(
×× 
int
×× 
i
×× 
=
×× 
$num
×× 
;
×× 
i
××  !
<
××" #
len
××$ '
;
××' (
i
××) *
++
××* ,
)
××, -
sum
××. 1
+=
××2 4
array
××5 :
[
××: ;
i
××; <
]
××< =
;
××= >
else
ØØ 
for
ÙÙ 
(
ÙÙ 
int
ÙÙ 
i
ÙÙ 
=
ÙÙ 
$num
ÙÙ 
;
ÙÙ 
i
ÙÙ  !
<
ÙÙ" #
len
ÙÙ$ '
;
ÙÙ' (
i
ÙÙ) *
++
ÙÙ* ,
)
ÙÙ, -
sum
ÙÙ. 1
+=
ÙÙ2 4
array
ÙÙ5 :
[
ÙÙ: ;
indexes
ÙÙ; B
[
ÙÙB C
i
ÙÙC D
]
ÙÙD E
]
ÙÙE F
;
ÙÙF G
return
ÛÛ 
sum
ÛÛ 
/
ÛÛ 
len
ÛÛ 
;
ÛÛ 
}
ÜÜ 	
public
ää 
static
ää 
Vector3
ää 
Average
ää %
(
ää% &
IList
ää& +
<
ää+ ,
Vector3
ää, 3
>
ää3 4
array
ää5 :
,
ää: ;
IList
ää< A
<
ääA B
int
ääB E
>
ääE F
indexes
ääG N
=
ääO P
null
ääQ U
)
ääU V
{
åå 	
if
ææ 
(
ææ 
array
ææ 
==
ææ 
null
ææ 
)
ææ 
throw
çç 
new
çç #
ArgumentNullException
çç /
(
çç/ 0
$str
çç0 7
)
çç7 8
;
çç8 9
Vector3
éé 
sum
éé 
=
éé 
Vector3
éé !
.
éé! "
zero
éé" &
;
éé& '
float
ëë 
len
ëë 
=
ëë 
indexes
ëë 
==
ëë  "
null
ëë# '
?
ëë( )
array
ëë* /
.
ëë/ 0
Count
ëë0 5
:
ëë6 7
indexes
ëë8 ?
.
ëë? @
Count
ëë@ E
;
ëëE F
if
íí 
(
íí 
indexes
íí 
==
íí 
null
íí 
)
íí  
{
îî 
for
ïï 
(
ïï 
int
ïï 
i
ïï 
=
ïï 
$num
ïï 
;
ïï 
i
ïï  !
<
ïï" #
len
ïï$ '
;
ïï' (
i
ïï) *
++
ïï* ,
)
ïï, -
{
ğğ 
sum
ññ 
.
ññ 
x
ññ 
+=
ññ 
array
ññ "
[
ññ" #
i
ññ# $
]
ññ$ %
.
ññ% &
x
ññ& '
;
ññ' (
sum
òò 
.
òò 
y
òò 
+=
òò 
array
òò "
[
òò" #
i
òò# $
]
òò$ %
.
òò% &
y
òò& '
;
òò' (
sum
óó 
.
óó 
z
óó 
+=
óó 
array
óó "
[
óó" #
i
óó# $
]
óó$ %
.
óó% &
z
óó& '
;
óó' (
}
ôô 
}
õõ 
else
öö 
{
÷÷ 
for
øø 
(
øø 
int
øø 
i
øø 
=
øø 
$num
øø 
;
øø 
i
øø  !
<
øø" #
len
øø$ '
;
øø' (
i
øø) *
++
øø* ,
)
øø, -
{
ùù 
sum
úú 
.
úú 
x
úú 
+=
úú 
array
úú "
[
úú" #
indexes
úú# *
[
úú* +
i
úú+ ,
]
úú, -
]
úú- .
.
úú. /
x
úú/ 0
;
úú0 1
sum
ûû 
.
ûû 
y
ûû 
+=
ûû 
array
ûû "
[
ûû" #
indexes
ûû# *
[
ûû* +
i
ûû+ ,
]
ûû, -
]
ûû- .
.
ûû. /
y
ûû/ 0
;
ûû0 1
sum
üü 
.
üü 
z
üü 
+=
üü 
array
üü "
[
üü" #
indexes
üü# *
[
üü* +
i
üü+ ,
]
üü, -
]
üü- .
.
üü. /
z
üü/ 0
;
üü0 1
}
ıı 
}
şş 
return
€	€	 
sum
€	€	 
/
€	€	 
len
€	€	 
;
€	€	 
}
		 	
internal
‹	‹	 
static
‹	‹	 
Vector3
‹	‹	 
Average
‹	‹	  '
<
‹	‹	' (
T
‹	‹	( )
>
‹	‹	) *
(
‹	‹	* +
this
‹	‹	+ /
IList
‹	‹	0 5
<
‹	‹	5 6
T
‹	‹	6 7
>
‹	‹	7 8
list
‹	‹	9 =
,
‹	‹	= >
Func
‹	‹	? C
<
‹	‹	C D
T
‹	‹	D E
,
‹	‹	E F
Vector3
‹	‹	G N
>
‹	‹	N O
selector
‹	‹	P X
,
‹	‹	X Y
IList
‹	‹	Z _
<
‹	‹	_ `
int
‹	‹	` c
>
‹	‹	c d
indexes
‹	‹	e l
=
‹	‹	m n
null
‹	‹	o s
)
‹	‹	s t
{
Œ	Œ	 	
if
		 
(
		 
list
		 
==
		 
null
		 
)
		 
throw
		 
new
		 #
ArgumentNullException
		 /
(
		/ 0
$str
		0 6
)
		6 7
;
		7 8
if
		 
(
		 
selector
		 
==
		 
null
		  
)
		  !
throw
‘	‘	 
new
‘	‘	 #
ArgumentNullException
‘	‘	 /
(
‘	‘	/ 0
$str
‘	‘	0 :
)
‘	‘	: ;
;
‘	‘	; <
Vector3
“	“	 
sum
“	“	 
=
“	“	 
Vector3
“	“	 !
.
“	“	! "
zero
“	“	" &
;
“	“	& '
float
”	”	 
len
”	”	 
=
”	”	 
indexes
”	”	 
==
”	”	  "
null
”	”	# '
?
”	”	( )
list
”	”	* .
.
”	”	. /
Count
”	”	/ 4
:
”	”	5 6
indexes
”	”	7 >
.
”	”	> ?
Count
”	”	? D
;
”	”	D E
if
–	–	 
(
–	–	 
indexes
–	–	 
==
–	–	 
null
–	–	 
)
–	–	  
{
—	—	 
for
˜	˜	 
(
˜	˜	 
int
˜	˜	 
i
˜	˜	 
=
˜	˜	 
$num
˜	˜	 
;
˜	˜	 
i
˜	˜	  !
<
˜	˜	" #
len
˜	˜	$ '
;
˜	˜	' (
i
˜	˜	) *
++
˜	˜	* ,
)
˜	˜	, -
sum
™	™	 
+=
™	™	 
selector
™	™	 #
(
™	™	# $
list
™	™	$ (
[
™	™	( )
i
™	™	) *
]
™	™	* +
)
™	™	+ ,
;
™	™	, -
}
š	š	 
else
›	›	 
{
œ	œ	 
for
		 
(
		 
int
		 
i
		 
=
		 
$num
		 
;
		 
i
		  !
<
		" #
len
		$ '
;
		' (
i
		) *
++
		* ,
)
		, -
sum
		 
+=
		 
selector
		 #
(
		# $
list
		$ (
[
		( )
indexes
		) 0
[
		0 1
i
		1 2
]
		2 3
]
		3 4
)
		4 5
;
		5 6
}
Ÿ	Ÿ	 
return
¡	¡	 
sum
¡	¡	 
/
¡	¡	 
len
¡	¡	 
;
¡	¡	 
}
¢	¢	 	
public
¤	¤	 
static
¤	¤	 
Vector4
¤	¤	 
Average
¤	¤	 %
(
¤	¤	% &
IList
¤	¤	& +
<
¤	¤	+ ,
Vector4
¤	¤	, 3
>
¤	¤	3 4
v
¤	¤	5 6
,
¤	¤	6 7
IList
¤	¤	8 =
<
¤	¤	= >
int
¤	¤	> A
>
¤	¤	A B
indexes
¤	¤	C J
=
¤	¤	K L
null
¤	¤	M Q
)
¤	¤	Q R
{
¥	¥	 	
Vector4
¦	¦	 
sum
¦	¦	 
=
¦	¦	 
Vector4
¦	¦	 !
.
¦	¦	! "
zero
¦	¦	" &
;
¦	¦	& '
float
§	§	 
len
§	§	 
=
§	§	 
indexes
§	§	 
==
§	§	  "
null
§	§	# '
?
§	§	( )
v
§	§	* +
.
§	§	+ ,
Count
§	§	, 1
:
§	§	2 3
indexes
§	§	4 ;
.
§	§	; <
Count
§	§	< A
;
§	§	A B
if
¨	¨	 
(
¨	¨	 
indexes
¨	¨	 
==
¨	¨	 
null
¨	¨	 
)
¨	¨	  
for
©	©	 
(
©	©	 
int
©	©	 
i
©	©	 
=
©	©	 
$num
©	©	 
;
©	©	 
i
©	©	  !
<
©	©	" #
len
©	©	$ '
;
©	©	' (
i
©	©	) *
++
©	©	* ,
)
©	©	, -
sum
©	©	. 1
+=
©	©	2 4
v
©	©	5 6
[
©	©	6 7
i
©	©	7 8
]
©	©	8 9
;
©	©	9 :
else
ª	ª	 
for
«	«	 
(
«	«	 
int
«	«	 
i
«	«	 
=
«	«	 
$num
«	«	 
;
«	«	 
i
«	«	  !
<
«	«	" #
len
«	«	$ '
;
«	«	' (
i
«	«	) *
++
«	«	* ,
)
«	«	, -
sum
«	«	. 1
+=
«	«	2 4
v
«	«	5 6
[
«	«	6 7
indexes
«	«	7 >
[
«	«	> ?
i
«	«	? @
]
«	«	@ A
]
«	«	A B
;
«	«	B C
return
¬	¬	 
sum
¬	¬	 
/
¬	¬	 
len
¬	¬	 
;
¬	¬	 
}
­	­	 	
internal
¯	¯	 
static
¯	¯	 
Color
¯	¯	 
Average
¯	¯	 %
(
¯	¯	% &
IList
¯	¯	& +
<
¯	¯	+ ,
Color
¯	¯	, 1
>
¯	¯	1 2
c
¯	¯	3 4
,
¯	¯	4 5
IList
¯	¯	6 ;
<
¯	¯	; <
int
¯	¯	< ?
>
¯	¯	? @
indexes
¯	¯	A H
=
¯	¯	I J
null
¯	¯	K O
)
¯	¯	O P
{
°	°	 	
Color
±	±	 
sum
±	±	 
=
±	±	 
c
±	±	 
[
±	±	 
$num
±	±	 
]
±	±	 
;
±	±	 
float
²	²	 
len
²	²	 
=
²	²	 
indexes
²	²	 
==
²	²	  "
null
²	²	# '
?
²	²	( )
c
²	²	* +
.
²	²	+ ,
Count
²	²	, 1
:
²	²	2 3
indexes
²	²	4 ;
.
²	²	; <
Count
²	²	< A
;
²	²	A B
if
³	³	 
(
³	³	 
indexes
³	³	 
==
³	³	 
null
³	³	 
)
³	³	  
for
´	´	 
(
´	´	 
int
´	´	 
i
´	´	 
=
´	´	 
$num
´	´	 
;
´	´	 
i
´	´	  !
<
´	´	" #
len
´	´	$ '
;
´	´	' (
i
´	´	) *
++
´	´	* ,
)
´	´	, -
sum
´	´	. 1
+=
´	´	2 4
c
´	´	5 6
[
´	´	6 7
i
´	´	7 8
]
´	´	8 9
;
´	´	9 :
else
µ	µ	 
for
¶	¶	 
(
¶	¶	 
int
¶	¶	 
i
¶	¶	 
=
¶	¶	 
$num
¶	¶	 
;
¶	¶	 
i
¶	¶	  !
<
¶	¶	" #
len
¶	¶	$ '
;
¶	¶	' (
i
¶	¶	) *
++
¶	¶	* ,
)
¶	¶	, -
sum
¶	¶	. 1
+=
¶	¶	2 4
c
¶	¶	5 6
[
¶	¶	6 7
indexes
¶	¶	7 >
[
¶	¶	> ?
i
¶	¶	? @
]
¶	¶	@ A
]
¶	¶	A B
;
¶	¶	B C
return
·	·	 
sum
·	·	 
/
·	·	 
len
·	·	 
;
·	·	 
}
¸	¸	 	
internal
Á	Á	 
static
Á	Á	 
bool
Á	Á	 
Approx2
Á	Á	 $
(
Á	Á	$ %
this
Á	Á	% )
Vector2
Á	Á	* 1
a
Á	Á	2 3
,
Á	Á	3 4
Vector2
Á	Á	5 <
b
Á	Á	= >
,
Á	Á	> ?
float
Á	Á	@ E
delta
Á	Á	F K
=
Á	Á	L M!
k_FltCompareEpsilon
Á	Á	N a
)
Á	Á	a b
{
Â	Â	 	
return
Ã	Ã	 
Mathf
Ä	Ä	 
.
Ä	Ä	 
Abs
Ä	Ä	 
(
Ä	Ä	 
a
Ä	Ä	 
.
Ä	Ä	 
x
Ä	Ä	 
-
Ä	Ä	 
b
Ä	Ä	  !
.
Ä	Ä	! "
x
Ä	Ä	" #
)
Ä	Ä	# $
<
Ä	Ä	% &
delta
Ä	Ä	' ,
&&
Ä	Ä	- /
Mathf
Å	Å	 
.
Å	Å	 
Abs
Å	Å	 
(
Å	Å	 
a
Å	Å	 
.
Å	Å	 
y
Å	Å	 
-
Å	Å	 
b
Å	Å	  !
.
Å	Å	! "
y
Å	Å	" #
)
Å	Å	# $
<
Å	Å	% &
delta
Å	Å	' ,
;
Å	Å	, -
}
Æ	Æ	 	
internal
Ï	Ï	 
static
Ï	Ï	 
bool
Ï	Ï	 
Approx3
Ï	Ï	 $
(
Ï	Ï	$ %
this
Ï	Ï	% )
Vector3
Ï	Ï	* 1
a
Ï	Ï	2 3
,
Ï	Ï	3 4
Vector3
Ï	Ï	5 <
b
Ï	Ï	= >
,
Ï	Ï	> ?
float
Ï	Ï	@ E
delta
Ï	Ï	F K
=
Ï	Ï	L M!
k_FltCompareEpsilon
Ï	Ï	N a
)
Ï	Ï	a b
{
Ğ	Ğ	 	
return
Ñ	Ñ	 
Mathf
Ò	Ò	 
.
Ò	Ò	 
Abs
Ò	Ò	 
(
Ò	Ò	 
a
Ò	Ò	 
.
Ò	Ò	 
x
Ò	Ò	 
-
Ò	Ò	 
b
Ò	Ò	  !
.
Ò	Ò	! "
x
Ò	Ò	" #
)
Ò	Ò	# $
<
Ò	Ò	% &
delta
Ò	Ò	' ,
&&
Ò	Ò	- /
Mathf
Ó	Ó	 
.
Ó	Ó	 
Abs
Ó	Ó	 
(
Ó	Ó	 
a
Ó	Ó	 
.
Ó	Ó	 
y
Ó	Ó	 
-
Ó	Ó	 
b
Ó	Ó	  !
.
Ó	Ó	! "
y
Ó	Ó	" #
)
Ó	Ó	# $
<
Ó	Ó	% &
delta
Ó	Ó	' ,
&&
Ó	Ó	- /
Mathf
Ô	Ô	 
.
Ô	Ô	 
Abs
Ô	Ô	 
(
Ô	Ô	 
a
Ô	Ô	 
.
Ô	Ô	 
z
Ô	Ô	 
-
Ô	Ô	 
b
Ô	Ô	  !
.
Ô	Ô	! "
z
Ô	Ô	" #
)
Ô	Ô	# $
<
Ô	Ô	% &
delta
Ô	Ô	' ,
;
Ô	Ô	, -
}
Õ	Õ	 	
internal
ß	ß	 
static
ß	ß	 
bool
ß	ß	 
Approx4
ß	ß	 $
(
ß	ß	$ %
this
ß	ß	% )
Vector4
ß	ß	* 1
a
ß	ß	2 3
,
ß	ß	3 4
Vector4
ß	ß	5 <
b
ß	ß	= >
,
ß	ß	> ?
float
ß	ß	@ E
delta
ß	ß	F K
=
ß	ß	L M!
k_FltCompareEpsilon
ß	ß	N a
)
ß	ß	a b
{
à	à	 	
return
á	á	 
Mathf
â	â	 
.
â	â	 
Abs
â	â	 
(
â	â	 
a
â	â	 
.
â	â	 
x
â	â	 
-
â	â	 
b
â	â	  !
.
â	â	! "
x
â	â	" #
)
â	â	# $
<
â	â	% &
delta
â	â	' ,
&&
â	â	- /
Mathf
ã	ã	 
.
ã	ã	 
Abs
ã	ã	 
(
ã	ã	 
a
ã	ã	 
.
ã	ã	 
y
ã	ã	 
-
ã	ã	 
b
ã	ã	  !
.
ã	ã	! "
y
ã	ã	" #
)
ã	ã	# $
<
ã	ã	% &
delta
ã	ã	' ,
&&
ã	ã	- /
Mathf
ä	ä	 
.
ä	ä	 
Abs
ä	ä	 
(
ä	ä	 
a
ä	ä	 
.
ä	ä	 
z
ä	ä	 
-
ä	ä	 
b
ä	ä	  !
.
ä	ä	! "
z
ä	ä	" #
)
ä	ä	# $
<
ä	ä	% &
delta
ä	ä	' ,
&&
ä	ä	- /
Mathf
å	å	 
.
å	å	 
Abs
å	å	 
(
å	å	 
a
å	å	 
.
å	å	 
w
å	å	 
-
å	å	 
b
å	å	  !
.
å	å	! "
w
å	å	" #
)
å	å	# $
<
å	å	% &
delta
å	å	' ,
;
å	å	, -
}
æ	æ	 	
internal
ï	ï	 
static
ï	ï	 
bool
ï	ï	 
ApproxC
ï	ï	 $
(
ï	ï	$ %
this
ï	ï	% )
Color
ï	ï	* /
a
ï	ï	0 1
,
ï	ï	1 2
Color
ï	ï	3 8
b
ï	ï	9 :
,
ï	ï	: ;
float
ï	ï	< A
delta
ï	ï	B G
=
ï	ï	H I!
k_FltCompareEpsilon
ï	ï	J ]
)
ï	ï	] ^
{
ğ	ğ	 	
return
ñ	ñ	 
Mathf
ñ	ñ	 
.
ñ	ñ	 
Abs
ñ	ñ	 
(
ñ	ñ	 
a
ñ	ñ	 
.
ñ	ñ	 
r
ñ	ñ	  
-
ñ	ñ	! "
b
ñ	ñ	# $
.
ñ	ñ	$ %
r
ñ	ñ	% &
)
ñ	ñ	& '
<
ñ	ñ	( )
delta
ñ	ñ	* /
&&
ñ	ñ	0 2
Mathf
ò	ò	 
.
ò	ò	 
Abs
ò	ò	 
(
ò	ò	 
a
ò	ò	 
.
ò	ò	 
g
ò	ò	 
-
ò	ò	 
b
ò	ò	  !
.
ò	ò	! "
g
ò	ò	" #
)
ò	ò	# $
<
ò	ò	% &
delta
ò	ò	' ,
&&
ò	ò	- /
Mathf
ó	ó	 
.
ó	ó	 
Abs
ó	ó	 
(
ó	ó	 
a
ó	ó	 
.
ó	ó	 
b
ó	ó	 
-
ó	ó	 
b
ó	ó	  !
.
ó	ó	! "
b
ó	ó	" #
)
ó	ó	# $
<
ó	ó	% &
delta
ó	ó	' ,
&&
ó	ó	- /
Mathf
ô	ô	 
.
ô	ô	 
Abs
ô	ô	 
(
ô	ô	 
a
ô	ô	 
.
ô	ô	 
a
ô	ô	 
-
ô	ô	 
b
ô	ô	  !
.
ô	ô	! "
a
ô	ô	" #
)
ô	ô	# $
<
ô	ô	% &
delta
ô	ô	' ,
;
ô	ô	, -
}
õ	õ	 	
internal
ÿ	ÿ	 
static
ÿ	ÿ	 
bool
ÿ	ÿ	 
Approx
ÿ	ÿ	 #
(
ÿ	ÿ	# $
this
ÿ	ÿ	$ (
float
ÿ	ÿ	) .
a
ÿ	ÿ	/ 0
,
ÿ	ÿ	0 1
float
ÿ	ÿ	2 7
b
ÿ	ÿ	8 9
,
ÿ	ÿ	9 :
float
ÿ	ÿ	; @
delta
ÿ	ÿ	A F
=
ÿ	ÿ	G H!
k_FltCompareEpsilon
ÿ	ÿ	I \
)
ÿ	ÿ	\ ]
{
€
€
 	
return


 
Mathf


 
.


 
Abs


 
(


 
b


 
-


  
a


! "
)


" #
<


$ %
Mathf


& +
.


+ ,
Abs


, /
(


/ 0
delta


0 5
)


5 6
;


6 7
}
‚
‚
 	
internal


 
static


 
int


 
Wrap


  
(


  !
int


! $
value


% *
,


* +
int


, /

lowerBound


0 :
,


: ;
int


< ?

upperBound


@ J
)


J K
{


 	
int


 

range_size


 
=


 

upperBound


 '
-


( )

lowerBound


* 4
+


5 6
$num


7 8
;


8 9
if
’
’
 
(
’
’
 
value
’
’
 
<
’
’
 

lowerBound
’
’
 "
)
’
’
" #
value
“
“
 
+=
“
“
 

range_size
“
“
 #
*
“
“
$ %
(
“
“
& '
(
“
“
' (

lowerBound
“
“
( 2
-
“
“
3 4
value
“
“
5 :
)
“
“
: ;
/
“
“
< =

range_size
“
“
> H
+
“
“
I J
$num
“
“
K L
)
“
“
L M
;
“
“
M N
return
•
•
 

lowerBound
•
•
 
+
•
•
 
(
•
•
  !
value
•
•
! &
-
•
•
' (

lowerBound
•
•
) 3
)
•
•
3 4
%
•
•
5 6

range_size
•
•
7 A
;
•
•
A B
}
–
–
 	
public
Ÿ
Ÿ
 
static
Ÿ
Ÿ
 
int
Ÿ
Ÿ
 
Clamp
Ÿ
Ÿ
 
(
Ÿ
Ÿ
  
int
Ÿ
Ÿ
  #
value
Ÿ
Ÿ
$ )
,
Ÿ
Ÿ
) *
int
Ÿ
Ÿ
+ .

lowerBound
Ÿ
Ÿ
/ 9
,
Ÿ
Ÿ
9 :
int
Ÿ
Ÿ
; >

upperBound
Ÿ
Ÿ
? I
)
Ÿ
Ÿ
I J
{
 
 
 	
return
¡
¡
 
value
¡
¡
 
<
¡
¡
 

lowerBound
¡
¡
 %
?
¢
¢
 

lowerBound
¢
¢
 
:
£
£
 
value
£
£
 
>
£
£
 

upperBound
£
£
 $
?
¤
¤
 

upperBound
¤
¤
  
:
¥
¥
 
value
¥
¥
 
;
¥
¥
 
}
¦
¦
 	
internal
¨
¨
 
static
¨
¨
 
Vector3
¨
¨
 
Clamp
¨
¨
  %
(
¨
¨
% &
Vector3
¨
¨
& -
value
¨
¨
. 3
,
¨
¨
3 4
Vector3
¨
¨
5 <

lowerBound
¨
¨
= G
,
¨
¨
G H
Vector3
¨
¨
I P

upperBound
¨
¨
Q [
)
¨
¨
[ \
{
©
©
 	
return
ª
ª
 
Vector3
ª
ª
 
.
ª
ª
 
Max
ª
ª
 
(
ª
ª
 
Vector3
ª
ª
 &
.
ª
ª
& '
Min
ª
ª
' *
(
ª
ª
* +
value
ª
ª
+ 0
,
ª
ª
0 1

upperBound
ª
ª
2 <
)
ª
ª
< =
,
ª
ª
= >

lowerBound
ª
ª
? I
)
ª
ª
I J
;
ª
ª
J K
}
«
«
 	
internal
­
­
 
static
­
­
 
Vector3
­
­
 
ToSignedMask
­
­
  ,
(
­
­
, -
this
­
­
- 1
Vector3
­
­
2 9
vec
­
­
: =
,
­
­
= >
float
­
­
? D
delta
­
­
E J
=
­
­
K L
k_FltEpsilon
­
­
M Y
)
­
­
Y Z
{
®
®
 	
return
¯
¯
 
new
¯
¯
 
Vector3
¯
¯
 
(
¯
¯
 
Mathf
°
°
 
.
°
°
 
Abs
°
°
 
(
°
°
 
vec
°
°
 
.
°
°
 
x
°
°
 
)
°
°
  
>
°
°
! "
delta
°
°
# (
?
°
°
) *
vec
°
°
+ .
.
°
°
. /
x
°
°
/ 0
/
°
°
1 2
Mathf
°
°
3 8
.
°
°
8 9
Abs
°
°
9 <
(
°
°
< =
vec
°
°
= @
.
°
°
@ A
x
°
°
A B
)
°
°
B C
:
°
°
D E
$num
°
°
F H
,
°
°
H I
Mathf
±
±
 
.
±
±
 
Abs
±
±
 
(
±
±
 
vec
±
±
 
.
±
±
 
y
±
±
 
)
±
±
  
>
±
±
! "
delta
±
±
# (
?
±
±
) *
vec
±
±
+ .
.
±
±
. /
y
±
±
/ 0
/
±
±
1 2
Mathf
±
±
3 8
.
±
±
8 9
Abs
±
±
9 <
(
±
±
< =
vec
±
±
= @
.
±
±
@ A
y
±
±
A B
)
±
±
B C
:
±
±
D E
$num
±
±
F H
,
±
±
H I
Mathf
²
²
 
.
²
²
 
Abs
²
²
 
(
²
²
 
vec
²
²
 
.
²
²
 
z
²
²
 
)
²
²
  
>
²
²
! "
delta
²
²
# (
?
²
²
) *
vec
²
²
+ .
.
²
²
. /
z
²
²
/ 0
/
²
²
1 2
Mathf
²
²
3 8
.
²
²
8 9
Abs
²
²
9 <
(
²
²
< =
vec
²
²
= @
.
²
²
@ A
z
²
²
A B
)
²
²
B C
:
²
²
D E
$num
²
²
F H
)
³
³
 
;
³
³
 
}
´
´
 	
internal
¶
¶
 
static
¶
¶
 
Vector3
¶
¶
 
Abs
¶
¶
  #
(
¶
¶
# $
this
¶
¶
$ (
Vector3
¶
¶
) 0
v
¶
¶
1 2
)
¶
¶
2 3
{
·
·
 	
return
¸
¸
 
new
¸
¸
 
Vector3
¸
¸
 
(
¸
¸
 
Mathf
¸
¸
 $
.
¸
¸
$ %
Abs
¸
¸
% (
(
¸
¸
( )
v
¸
¸
) *
.
¸
¸
* +
x
¸
¸
+ ,
)
¸
¸
, -
,
¸
¸
- .
Mathf
¸
¸
/ 4
.
¸
¸
4 5
Abs
¸
¸
5 8
(
¸
¸
8 9
v
¸
¸
9 :
.
¸
¸
: ;
y
¸
¸
; <
)
¸
¸
< =
,
¸
¸
= >
Mathf
¸
¸
? D
.
¸
¸
D E
Abs
¸
¸
E H
(
¸
¸
H I
v
¸
¸
I J
.
¸
¸
J K
z
¸
¸
K L
)
¸
¸
L M
)
¸
¸
M N
;
¸
¸
N O
}
¹
¹
 	
internal
»
»
 
static
»
»
 
int
»
»
 
IntSum
»
»
 "
(
»
»
" #
this
»
»
# '
Vector3
»
»
( /
mask
»
»
0 4
)
»
»
4 5
{
¼
¼
 	
return
½
½
 
(
½
½
 
int
½
½
 
)
½
½
 
Mathf
½
½
 
.
½
½
 
Abs
½
½
 !
(
½
½
! "
mask
½
½
" &
.
½
½
& '
x
½
½
' (
)
½
½
( )
+
½
½
* +
(
½
½
, -
int
½
½
- 0
)
½
½
0 1
Mathf
½
½
1 6
.
½
½
6 7
Abs
½
½
7 :
(
½
½
: ;
mask
½
½
; ?
.
½
½
? @
y
½
½
@ A
)
½
½
A B
+
½
½
C D
(
½
½
E F
int
½
½
F I
)
½
½
I J
Mathf
½
½
J O
.
½
½
O P
Abs
½
½
P S
(
½
½
S T
mask
½
½
T X
.
½
½
X Y
z
½
½
Y Z
)
½
½
Z [
;
½
½
[ \
}
¾
¾
 	
internal
À
À
 
static
À
À
 
float
À
À
 
Sum
À
À
 !
(
À
À
! "
this
À
À
" &
Vector3
À
À
' .
v
À
À
/ 0
)
À
À
0 1
{
Á
Á
 	
return
Â
Â
 
Mathf
Â
Â
 
.
Â
Â
 
Abs
Â
Â
 
(
Â
Â
 
v
Â
Â
 
.
Â
Â
 
x
Â
Â
  
)
Â
Â
  !
+
Â
Â
" #
Mathf
Â
Â
$ )
.
Â
Â
) *
Abs
Â
Â
* -
(
Â
Â
- .
v
Â
Â
. /
.
Â
Â
/ 0
y
Â
Â
0 1
)
Â
Â
1 2
+
Â
Â
3 4
Mathf
Â
Â
5 :
.
Â
Â
: ;
Abs
Â
Â
; >
(
Â
Â
> ?
v
Â
Â
? @
.
Â
Â
@ A
z
Â
Â
A B
)
Â
Â
B C
;
Â
Â
C D
}
Ã
Ã
 	
internal
Ğ
Ğ
 
static
Ğ
Ğ
 
void
Ğ
Ğ
 
Cross
Ğ
Ğ
 "
(
Ğ
Ğ
" #
Vector3
Ğ
Ğ
# *
a
Ğ
Ğ
+ ,
,
Ğ
Ğ
, -
Vector3
Ğ
Ğ
. 5
b
Ğ
Ğ
6 7
,
Ğ
Ğ
7 8
ref
Ğ
Ğ
9 <
float
Ğ
Ğ
= B
x
Ğ
Ğ
C D
,
Ğ
Ğ
D E
ref
Ğ
Ğ
F I
float
Ğ
Ğ
J O
y
Ğ
Ğ
P Q
,
Ğ
Ğ
Q R
ref
Ğ
Ğ
S V
float
Ğ
Ğ
W \
z
Ğ
Ğ
] ^
)
Ğ
Ğ
^ _
{
Ñ
Ñ
 	
x
Ò
Ò
 
=
Ò
Ò
 
a
Ò
Ò
 
.
Ò
Ò
 
y
Ò
Ò
 
*
Ò
Ò
 
b
Ò
Ò
 
.
Ò
Ò
 
z
Ò
Ò
 
-
Ò
Ò
 
a
Ò
Ò
 
.
Ò
Ò
 
z
Ò
Ò
 
*
Ò
Ò
  !
b
Ò
Ò
" #
.
Ò
Ò
# $
y
Ò
Ò
$ %
;
Ò
Ò
% &
y
Ó
Ó
 
=
Ó
Ó
 
a
Ó
Ó
 
.
Ó
Ó
 
z
Ó
Ó
 
*
Ó
Ó
 
b
Ó
Ó
 
.
Ó
Ó
 
x
Ó
Ó
 
-
Ó
Ó
 
a
Ó
Ó
 
.
Ó
Ó
 
x
Ó
Ó
 
*
Ó
Ó
  !
b
Ó
Ó
" #
.
Ó
Ó
# $
z
Ó
Ó
$ %
;
Ó
Ó
% &
z
Ô
Ô
 
=
Ô
Ô
 
a
Ô
Ô
 
.
Ô
Ô
 
x
Ô
Ô
 
*
Ô
Ô
 
b
Ô
Ô
 
.
Ô
Ô
 
y
Ô
Ô
 
-
Ô
Ô
 
a
Ô
Ô
 
.
Ô
Ô
 
y
Ô
Ô
 
*
Ô
Ô
  !
b
Ô
Ô
" #
.
Ô
Ô
# $
x
Ô
Ô
$ %
;
Ô
Ô
% &
}
Õ
Õ
 	
internal
İ
İ
 
static
İ
İ
 
void
İ
İ
 
Cross
İ
İ
 "
(
İ
İ
" #
Vector3
İ
İ
# *
a
İ
İ
+ ,
,
İ
İ
, -
Vector3
İ
İ
. 5
b
İ
İ
6 7
,
İ
İ
7 8
ref
İ
İ
9 <
Vector3
İ
İ
= D
res
İ
İ
E H
)
İ
İ
H I
{
Ş
Ş
 	
res
ß
ß
 
.
ß
ß
 
x
ß
ß
 
=
ß
ß
 
a
ß
ß
 
.
ß
ß
 
y
ß
ß
 
*
ß
ß
 
b
ß
ß
 
.
ß
ß
 
z
ß
ß
 
-
ß
ß
 
a
ß
ß
  !
.
ß
ß
! "
z
ß
ß
" #
*
ß
ß
$ %
b
ß
ß
& '
.
ß
ß
' (
y
ß
ß
( )
;
ß
ß
) *
res
à
à
 
.
à
à
 
y
à
à
 
=
à
à
 
a
à
à
 
.
à
à
 
z
à
à
 
*
à
à
 
b
à
à
 
.
à
à
 
x
à
à
 
-
à
à
 
a
à
à
  !
.
à
à
! "
x
à
à
" #
*
à
à
$ %
b
à
à
& '
.
à
à
' (
z
à
à
( )
;
à
à
) *
res
á
á
 
.
á
á
 
z
á
á
 
=
á
á
 
a
á
á
 
.
á
á
 
x
á
á
 
*
á
á
 
b
á
á
 
.
á
á
 
y
á
á
 
-
á
á
 
a
á
á
  !
.
á
á
! "
y
á
á
" #
*
á
á
$ %
b
á
á
& '
.
á
á
' (
x
á
á
( )
;
á
á
) *
}
â
â
 	
internal
ğ
ğ
 
static
ğ
ğ
 
void
ğ
ğ
 
Cross
ğ
ğ
 "
(
ğ
ğ
" #
float
ğ
ğ
# (
ax
ğ
ğ
) +
,
ğ
ğ
+ ,
float
ğ
ğ
- 2
ay
ğ
ğ
3 5
,
ğ
ğ
5 6
float
ğ
ğ
7 <
az
ğ
ğ
= ?
,
ğ
ğ
? @
float
ğ
ğ
A F
bx
ğ
ğ
G I
,
ğ
ğ
I J
float
ğ
ğ
K P
by
ğ
ğ
Q S
,
ğ
ğ
S T
float
ğ
ğ
U Z
bz
ğ
ğ
[ ]
,
ğ
ğ
] ^
ref
ğ
ğ
_ b
float
ğ
ğ
c h
x
ğ
ğ
i j
,
ğ
ğ
j k
ref
ğ
ğ
l o
float
ğ
ğ
p u
y
ğ
ğ
v w
,
ğ
ğ
w x
ref
ğ
ğ
y |
floatğ
ğ
} ‚
zğ
ğ
ƒ „
)ğ
ğ
„ …
{
ñ
ñ
 	
x
ò
ò
 
=
ò
ò
 
ay
ò
ò
 
*
ò
ò
 
bz
ò
ò
 
-
ò
ò
 
az
ò
ò
 
*
ò
ò
 
by
ò
ò
 !
;
ò
ò
! "
y
ó
ó
 
=
ó
ó
 
az
ó
ó
 
*
ó
ó
 
bx
ó
ó
 
-
ó
ó
 
ax
ó
ó
 
*
ó
ó
 
bz
ó
ó
 !
;
ó
ó
! "
z
ô
ô
 
=
ô
ô
 
ax
ô
ô
 
*
ô
ô
 
by
ô
ô
 
-
ô
ô
 
ay
ô
ô
 
*
ô
ô
 
bx
ô
ô
 !
;
ô
ô
! "
}
õ
õ
 	
internal
ı
ı
 
static
ı
ı
 
void
ı
ı
 
Subtract
ı
ı
 %
(
ı
ı
% &
Vector3
ı
ı
& -
a
ı
ı
. /
,
ı
ı
/ 0
Vector3
ı
ı
1 8
b
ı
ı
9 :
,
ı
ı
: ;
ref
ı
ı
< ?
Vector3
ı
ı
@ G
res
ı
ı
H K
)
ı
ı
K L
{
ş
ş
 	
res
ÿ
ÿ
 
.
ÿ
ÿ
 
x
ÿ
ÿ
 
=
ÿ
ÿ
 
b
ÿ
ÿ
 
.
ÿ
ÿ
 
x
ÿ
ÿ
 
-
ÿ
ÿ
 
a
ÿ
ÿ
 
.
ÿ
ÿ
 
x
ÿ
ÿ
 
;
ÿ
ÿ
 
res
€€ 
.
€€ 
y
€€ 
=
€€ 
b
€€ 
.
€€ 
y
€€ 
-
€€ 
a
€€ 
.
€€ 
y
€€ 
;
€€ 
res
 
.
 
z
 
=
 
b
 
.
 
z
 
-
 
a
 
.
 
z
 
;
 
}
‚‚ 	
internal
„„ 
static
„„ 
int
„„ 
Min
„„ 
(
„„  
int
„„  #
a
„„$ %
,
„„% &
int
„„' *
b
„„+ ,
)
„„, -
{
…… 	
return
†† 
a
†† 
<
†† 
b
†† 
?
†† 
a
†† 
:
†† 
b
††  
;
††  !
}
‡‡ 	
internal
‰‰ 
static
‰‰ 
int
‰‰ 
Max
‰‰ 
(
‰‰  
int
‰‰  #
a
‰‰$ %
,
‰‰% &
int
‰‰' *
b
‰‰+ ,
)
‰‰, -
{
ŠŠ 	
return
‹‹ 
a
‹‹ 
>
‹‹ 
b
‹‹ 
?
‹‹ 
a
‹‹ 
:
‹‹ 
b
‹‹  
;
‹‹  !
}
ŒŒ 	
internal
 
static
 
bool
 
IsNumber
 %
(
% &
float
& +
value
, 1
)
1 2
{
 	
return
 
!
 
(
 
float
 
.
 

IsInfinity
 %
(
% &
value
& +
)
+ ,
||
- /
float
0 5
.
5 6
IsNaN
6 ;
(
; <
value
< A
)
A B
)
B C
;
C D
}
‘‘ 	
internal
““ 
static
““ 
bool
““ 
IsNumber
““ %
(
““% &
Vector2
““& -
value
““. 3
)
““3 4
{
”” 	
return
•• 
IsNumber
•• 
(
•• 
value
•• !
.
••! "
x
••" #
)
••# $
&&
••% '
IsNumber
••( 0
(
••0 1
value
••1 6
.
••6 7
y
••7 8
)
••8 9
;
••9 :
}
–– 	
internal
˜˜ 
static
˜˜ 
bool
˜˜ 
IsNumber
˜˜ %
(
˜˜% &
Vector3
˜˜& -
value
˜˜. 3
)
˜˜3 4
{
™™ 	
return
šš 
IsNumber
šš 
(
šš 
value
šš !
.
šš! "
x
šš" #
)
šš# $
&&
šš% '
IsNumber
šš( 0
(
šš0 1
value
šš1 6
.
šš6 7
y
šš7 8
)
šš8 9
&&
šš: <
IsNumber
šš= E
(
ššE F
value
ššF K
.
ššK L
z
ššL M
)
ššM N
;
ššN O
}
›› 	
internal
 
static
 
bool
 
IsNumber
 %
(
% &
Vector4
& -
value
. 3
)
3 4
{
 	
return
ŸŸ 
IsNumber
ŸŸ 
(
ŸŸ 
value
ŸŸ !
.
ŸŸ! "
x
ŸŸ" #
)
ŸŸ# $
&&
ŸŸ% '
IsNumber
ŸŸ( 0
(
ŸŸ0 1
value
ŸŸ1 6
.
ŸŸ6 7
y
ŸŸ7 8
)
ŸŸ8 9
&&
ŸŸ: <
IsNumber
ŸŸ= E
(
ŸŸE F
value
ŸŸF K
.
ŸŸK L
z
ŸŸL M
)
ŸŸM N
&&
ŸŸO Q
IsNumber
ŸŸR Z
(
ŸŸZ [
value
ŸŸ[ `
.
ŸŸ` a
w
ŸŸa b
)
ŸŸb c
;
ŸŸc d
}
   	
internal
¢¢ 
static
¢¢ 
float
¢¢ 
MakeNonZero
¢¢ )
(
¢¢) *
float
¢¢* /
value
¢¢0 5
,
¢¢5 6
float
¢¢7 <
min
¢¢= @
=
¢¢A B
$num
¢¢C I
)
¢¢I J
{
££ 	
if
¤¤ 
(
¤¤ 
float
¤¤ 
.
¤¤ 
IsNaN
¤¤ 
(
¤¤ 
value
¤¤ !
)
¤¤! "
||
¤¤# %
float
¤¤& +
.
¤¤+ ,

IsInfinity
¤¤, 6
(
¤¤6 7
value
¤¤7 <
)
¤¤< =
||
¤¤> @
Mathf
¤¤A F
.
¤¤F G
Abs
¤¤G J
(
¤¤J K
value
¤¤K P
)
¤¤P Q
<
¤¤R S
min
¤¤T W
)
¤¤W X
return
¥¥ 
min
¥¥ 
*
¥¥ 
Mathf
¥¥ "
.
¥¥" #
Sign
¥¥# '
(
¥¥' (
value
¥¥( -
)
¥¥- .
;
¥¥. /
return
¦¦ 
value
¦¦ 
;
¦¦ 
}
§§ 	
}
¨¨ 
}©© û“
…D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Face.cs
	namespace		 	
UnityEngine		
 
.		 

ProBuilder		  
{

 
[ 
Serializable 
] 
public 

sealed 
class 
Face 
{ 
[ 	 
FormerlySerializedAs	 
( 
$str (
)( )
]) *
[ 	
SerializeField	 
] 
int 
[ 
] 
	m_Indexes 
; 
[ 	
SerializeField	 
] 
[ 	 
FormerlySerializedAs	 
( 
$str /
)/ 0
]0 1
int 
m_SmoothingGroup 
; 
[## 	
SerializeField##	 
]## 
[$$ 	 
FormerlySerializedAs$$	 
($$ 
$str$$ #
)$$# $
]$$$ %
AutoUnwrapSettings%% 
m_Uv%% 
;%%  
[** 	
SerializeField**	 
]** 
[++ 	 
FormerlySerializedAs++	 
(++ 
$str++ $
)++$ %
]++% &
Material,, 

m_Material,, 
;,, 
[.. 	
SerializeField..	 
].. 
int// 
m_SubmeshIndex// 
;// 
[22 	
SerializeField22	 
]22 
[33 	 
FormerlySerializedAs33	 
(33 
$str33 (
)33( )
]33) *
bool44 

m_ManualUV44 
;44 
public99 
bool99 
manualUV99 
{:: 	
get;; 
{;; 
return;; 

m_ManualUV;; #
;;;# $
};;% &
set<< 
{<< 

m_ManualUV<< 
=<< 
value<< $
;<<$ %
}<<& '
}== 	
[BB 	
SerializeFieldBB	 
]BB 
internalCC 
intCC 
elementGroupCC !
;CC! "
[FF 	
SerializeFieldFF	 
]FF 
intGG 
m_TextureGroupGG 
;GG 
publicLL 
intLL 
textureGroupLL 
{MM 	
getNN 
{NN 
returnNN 
m_TextureGroupNN '
;NN' (
}NN( )
setOO 
{OO 
m_TextureGroupOO  
=OO! "
valueOO# (
;OO( )
}OO* +
}PP 	
internalUU 
intUU 
[UU 
]UU 
indexesInternalUU &
{VV 	
getWW 
{WW 
returnWW 
	m_IndexesWW "
;WW" #
}WW$ %
setXX 
{YY 
ifZZ 
(ZZ 
	m_IndexesZZ 
==ZZ  
nullZZ! %
)ZZ% &
throw[[ 
new[[ !
ArgumentNullException[[ 3
([[3 4
$str[[4 ;
)[[; <
;[[< =
if\\ 
(\\ 
	m_Indexes\\ 
.\\ 
Length\\ $
%\\% &
$num\\' (
!=\\) +
$num\\, -
)\\- .
throw]] 
new]] 
ArgumentException]] /
(]]/ 0
$str]]0 W
)]]W X
;]]X Y
	m_Indexes^^ 
=^^ 
value^^ !
;^^! "
InvalidateCache__ 
(__  
)__  !
;__! "
}`` 
}aa 	
publicff 
ReadOnlyCollectionff !
<ff! "
intff" %
>ff% &
indexesff' .
{gg 	
gethh 
{hh 
returnhh 
newhh 
ReadOnlyCollectionhh /
<hh/ 0
inthh0 3
>hh3 4
(hh4 5
	m_Indexeshh5 >
)hh> ?
;hh? @
}hhA B
}ii 	
publicoo 
voidoo 

SetIndexesoo 
(oo 
IEnumerableoo *
<oo* +
intoo+ .
>oo. /
indicesoo0 7
)oo7 8
{pp 	
ifqq 
(qq 
indicesqq 
==qq 
nullqq 
)qq  
throwrr 
newrr !
ArgumentNullExceptionrr /
(rr/ 0
$strrr0 9
)rr9 :
;rr: ;
varss 
arrayss 
=ss 
indicesss 
.ss  
ToArrayss  '
(ss' (
)ss( )
;ss) *
inttt 
lentt 
=tt 
arraytt 
.tt 
Lengthtt "
;tt" #
ifuu 
(uu 
lenuu 
%uu 
$numuu 
!=uu 
$numuu 
)uu 
throwvv 
newvv 
ArgumentExceptionvv +
(vv+ ,
$strvv, S
)vvS T
;vvT U
	m_Indexesww 
=ww 
arrayww 
;ww 
InvalidateCachexx 
(xx 
)xx 
;xx 
}yy 	
[{{ 	
NonSerialized{{	 
]{{ 
int|| 
[|| 
]|| 
m_DistinctIndexes|| 
;||  
[~~ 	
NonSerialized~~	 
]~~ 
Edge 
[ 
] 
m_Edges 
; 
internal
„„ 
int
„„ 
[
„„ 
]
„„ %
distinctIndexesInternal
„„ .
{
…… 	
get
†† 
{
†† 
return
†† 
m_DistinctIndexes
†† *
==
††+ -
null
††. 2
?
††3 4"
CacheDistinctIndexes
††5 I
(
††I J
)
††J K
:
††L M
m_DistinctIndexes
††N _
;
††_ `
}
††a b
}
‡‡ 	
public
ŒŒ  
ReadOnlyCollection
ŒŒ !
<
ŒŒ! "
int
ŒŒ" %
>
ŒŒ% &
distinctIndexes
ŒŒ' 6
{
 	
get
 
{
 
return
 
new
  
ReadOnlyCollection
 /
<
/ 0
int
0 3
>
3 4
(
4 5%
distinctIndexesInternal
5 L
)
L M
;
M N
}
O P
}
 	
internal
‘‘ 
Edge
‘‘ 
[
‘‘ 
]
‘‘ 
edgesInternal
‘‘ %
{
’’ 	
get
““ 
{
““ 
return
““ 
m_Edges
““  
==
““! #
null
““$ (
?
““) *

CacheEdges
““+ 5
(
““5 6
)
““6 7
:
““8 9
m_Edges
““: A
;
““A B
}
““C D
}
”” 	
public
™™  
ReadOnlyCollection
™™ !
<
™™! "
Edge
™™" &
>
™™& '
edges
™™( -
{
šš 	
get
›› 
{
›› 
return
›› 
new
››  
ReadOnlyCollection
›› /
<
››/ 0
Edge
››0 4
>
››4 5
(
››5 6
edgesInternal
››6 C
)
››C D
;
››D E
}
››F G
}
œœ 	
public
¡¡ 
int
¡¡ 
smoothingGroup
¡¡ !
{
¢¢ 	
get
££ 
{
££ 
return
££ 
m_SmoothingGroup
££ )
;
££) *
}
££+ ,
set
¤¤ 
{
¤¤ 
m_SmoothingGroup
¤¤ "
=
¤¤# $
value
¤¤% *
;
¤¤* +
}
¤¤, -
}
¥¥ 	
[
ªª 	
Obsolete
ªª	 
(
ªª 
$str
ªª Q
)
ªªQ R
]
ªªR S
public
«« 
Material
«« 
material
««  
{
¬¬ 	
get
­­ 
{
­­ 
return
­­ 

m_Material
­­ #
;
­­# $
}
­­% &
set
®® 
{
®® 

m_Material
®® 
=
®® 
value
®® $
;
®®$ %
}
®®& '
}
¯¯ 	
public
±± 
int
±± 
submeshIndex
±± 
{
²² 	
get
³³ 
{
³³ 
return
³³ 
m_SubmeshIndex
³³ '
;
³³' (
}
³³) *
set
´´ 
{
´´ 
m_SubmeshIndex
´´  
=
´´! "
value
´´# (
;
´´( )
}
´´* +
}
µµ 	
public
ºº  
AutoUnwrapSettings
ºº !
uv
ºº" $
{
»» 	
get
¼¼ 
{
¼¼ 
return
¼¼ 
m_Uv
¼¼ 
;
¼¼ 
}
¼¼  
set
½½ 
{
½½ 
m_Uv
½½ 
=
½½ 
value
½½ 
;
½½ 
}
½½  !
}
¾¾ 	
public
ÄÄ 
int
ÄÄ 
this
ÄÄ 
[
ÄÄ 
int
ÄÄ 
i
ÄÄ 
]
ÄÄ 
{
ÅÅ 	
get
ÆÆ 
{
ÆÆ 
return
ÆÆ 
indexesInternal
ÆÆ (
[
ÆÆ( )
i
ÆÆ) *
]
ÆÆ* +
;
ÆÆ+ ,
}
ÆÆ- .
}
ÇÇ 	
public
ÌÌ 
Face
ÌÌ 
(
ÌÌ 
)
ÌÌ 
{
ÍÍ 	
m_SubmeshIndex
ÎÎ 
=
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
}
ÏÏ 	
public
ÕÕ 
Face
ÕÕ 
(
ÕÕ 
IEnumerable
ÕÕ 
<
ÕÕ  
int
ÕÕ  #
>
ÕÕ# $
indices
ÕÕ% ,
)
ÕÕ, -
{
ÖÖ 	

SetIndexes
×× 
(
×× 
indices
×× 
)
×× 
;
××  
m_Uv
ØØ 
=
ØØ  
AutoUnwrapSettings
ØØ %
.
ØØ% &
tile
ØØ& *
;
ØØ* +

m_Material
ÙÙ 
=
ÙÙ 
BuiltinMaterials
ÙÙ )
.
ÙÙ) *
defaultMaterial
ÙÙ* 9
;
ÙÙ9 :
m_SmoothingGroup
ÚÚ 
=
ÚÚ 
	Smoothing
ÚÚ (
.
ÚÚ( ) 
smoothingGroupNone
ÚÚ) ;
;
ÚÚ; <
m_SubmeshIndex
ÛÛ 
=
ÛÛ 
$num
ÛÛ 
;
ÛÛ 
textureGroup
ÜÜ 
=
ÜÜ 
-
ÜÜ 
$num
ÜÜ 
;
ÜÜ 
elementGroup
İİ 
=
İİ 
$num
İİ 
;
İİ 
}
ŞŞ 	
[
àà 	
Obsolete
àà	 
(
àà 
$str
àà U
)
ààU V
]
ààV W
internal
áá 
Face
áá 
(
áá 
int
áá 
[
áá 
]
áá 
	triangles
áá %
,
áá% &
Material
áá' /
m
áá0 1
,
áá1 2 
AutoUnwrapSettings
áá3 E
u
ááF G
,
ááG H
int
ááI L
	smoothing
ááM V
,
ááV W
int
ááX [
texture
áá\ c
,
áác d
int
ááe h
element
áái p
,
ááp q
bool
áár v
	manualUVsááw €
)áá€ 
{
ââ 	

SetIndexes
ãã 
(
ãã 
	triangles
ãã  
)
ãã  !
;
ãã! "
m_Uv
ää 
=
ää 
new
ää  
AutoUnwrapSettings
ää )
(
ää) *
u
ää* +
)
ää+ ,
;
ää, -

m_Material
åå 
=
åå 
m
åå 
;
åå 
m_SmoothingGroup
ææ 
=
ææ 
	smoothing
ææ (
;
ææ( )
textureGroup
çç 
=
çç 
texture
çç "
;
çç" #
elementGroup
èè 
=
èè 
element
èè "
;
èè" #
manualUV
éé 
=
éé 
	manualUVs
éé  
;
éé  !
m_SubmeshIndex
êê 
=
êê 
$num
êê 
;
êê 
}
ëë 	
internal
íí 
Face
íí 
(
íí 
IEnumerable
íí !
<
íí! "
int
íí" %
>
íí% &
	triangles
íí' 0
,
íí0 1
int
íí2 5
submeshIndex
íí6 B
,
ííB C 
AutoUnwrapSettings
ííD V
u
ííW X
,
ííX Y
int
ííZ ]
	smoothing
íí^ g
,
ííg h
int
ííi l
texture
íím t
,
íít u
int
íív y
elementííz 
,íí ‚
boolííƒ ‡
	manualUVsííˆ ‘
)íí‘ ’
{
îî 	

SetIndexes
ïï 
(
ïï 
	triangles
ïï  
)
ïï  !
;
ïï! "
m_Uv
ğğ 
=
ğğ 
new
ğğ  
AutoUnwrapSettings
ğğ )
(
ğğ) *
u
ğğ* +
)
ğğ+ ,
;
ğğ, -
m_SmoothingGroup
ññ 
=
ññ 
	smoothing
ññ (
;
ññ( )
textureGroup
òò 
=
òò 
texture
òò "
;
òò" #
elementGroup
óó 
=
óó 
element
óó "
;
óó" #
manualUV
ôô 
=
ôô 
	manualUVs
ôô  
;
ôô  !
m_SubmeshIndex
õõ 
=
õõ 
submeshIndex
õõ )
;
õõ) *
}
öö 	
public
üü 
Face
üü 
(
üü 
Face
üü 
other
üü 
)
üü 
{
ıı 	
CopyFrom
şş 
(
şş 
other
şş 
)
şş 
;
şş 
}
ÿÿ 	
public
…… 
void
…… 
CopyFrom
…… 
(
…… 
Face
…… !
other
……" '
)
……' (
{
†† 	
if
‡‡ 
(
‡‡ 
other
‡‡ 
==
‡‡ 
null
‡‡ 
)
‡‡ 
throw
ˆˆ 
new
ˆˆ #
ArgumentNullException
ˆˆ /
(
ˆˆ/ 0
$str
ˆˆ0 7
)
ˆˆ7 8
;
ˆˆ8 9
int
ŠŠ 
len
ŠŠ 
=
ŠŠ 
other
ŠŠ 
.
ŠŠ 
indexesInternal
ŠŠ +
.
ŠŠ+ ,
Length
ŠŠ, 2
;
ŠŠ2 3
	m_Indexes
‹‹ 
=
‹‹ 
new
‹‹ 
int
‹‹ 
[
‹‹  
len
‹‹  #
]
‹‹# $
;
‹‹$ %
Array
ŒŒ 
.
ŒŒ 
Copy
ŒŒ 
(
ŒŒ 
other
ŒŒ 
.
ŒŒ 
indexesInternal
ŒŒ ,
,
ŒŒ, -
	m_Indexes
ŒŒ. 7
,
ŒŒ7 8
len
ŒŒ9 <
)
ŒŒ< =
;
ŒŒ= >
m_SmoothingGroup
 
=
 
other
 $
.
$ %
smoothingGroup
% 3
;
3 4
m_Uv
 
=
 
new
  
AutoUnwrapSettings
 )
(
) *
other
* /
.
/ 0
uv
0 2
)
2 3
;
3 4

m_Material
‘‘ 
=
‘‘ 
other
‘‘ 
.
‘‘ 
material
‘‘ '
;
‘‘' (
manualUV
““ 
=
““ 
other
““ 
.
““ 
manualUV
““ %
;
““% &
m_TextureGroup
”” 
=
”” 
other
”” "
.
””" #
textureGroup
””# /
;
””/ 0
elementGroup
•• 
=
•• 
other
••  
.
••  !
elementGroup
••! -
;
••- .
m_SubmeshIndex
–– 
=
–– 
other
–– "
.
––" #
m_SubmeshIndex
––# 1
;
––1 2
InvalidateCache
—— 
(
—— 
)
—— 
;
—— 
}
˜˜ 	
internal
šš 
void
šš 
InvalidateCache
šš %
(
šš% &
)
šš& '
{
›› 	
m_Edges
œœ 
=
œœ 
null
œœ 
;
œœ 
m_DistinctIndexes
 
=
 
null
  $
;
$ %
}
 	
Edge
   
[
   
]
   

CacheEdges
   
(
   
)
   
{
¡¡ 	
if
¢¢ 
(
¢¢ 
	m_Indexes
¢¢ 
==
¢¢ 
null
¢¢ !
)
¢¢! "
return
££ 
null
££ 
;
££ 
HashSet
¥¥ 
<
¥¥ 
Edge
¥¥ 
>
¥¥ 
dist
¥¥ 
=
¥¥  
new
¥¥! $
HashSet
¥¥% ,
<
¥¥, -
Edge
¥¥- 1
>
¥¥1 2
(
¥¥2 3
)
¥¥3 4
;
¥¥4 5
List
¦¦ 
<
¦¦ 
Edge
¦¦ 
>
¦¦ 
dup
¦¦ 
=
¦¦ 
new
¦¦  
List
¦¦! %
<
¦¦% &
Edge
¦¦& *
>
¦¦* +
(
¦¦+ ,
)
¦¦, -
;
¦¦- .
for
¨¨ 
(
¨¨ 
int
¨¨ 
i
¨¨ 
=
¨¨ 
$num
¨¨ 
;
¨¨ 
i
¨¨ 
<
¨¨ 
indexesInternal
¨¨  /
.
¨¨/ 0
Length
¨¨0 6
;
¨¨6 7
i
¨¨8 9
+=
¨¨: <
$num
¨¨= >
)
¨¨> ?
{
©© 
Edge
ªª 
a
ªª 
=
ªª 
new
ªª 
Edge
ªª !
(
ªª! "
indexesInternal
ªª" 1
[
ªª1 2
i
ªª2 3
+
ªª4 5
$num
ªª6 7
]
ªª7 8
,
ªª8 9
indexesInternal
ªª: I
[
ªªI J
i
ªªJ K
+
ªªL M
$num
ªªN O
]
ªªO P
)
ªªP Q
;
ªªQ R
Edge
«« 
b
«« 
=
«« 
new
«« 
Edge
«« !
(
««! "
indexesInternal
««" 1
[
««1 2
i
««2 3
+
««4 5
$num
««6 7
]
««7 8
,
««8 9
indexesInternal
««: I
[
««I J
i
««J K
+
««L M
$num
««N O
]
««O P
)
««P Q
;
««Q R
Edge
¬¬ 
c
¬¬ 
=
¬¬ 
new
¬¬ 
Edge
¬¬ !
(
¬¬! "
indexesInternal
¬¬" 1
[
¬¬1 2
i
¬¬2 3
+
¬¬4 5
$num
¬¬6 7
]
¬¬7 8
,
¬¬8 9
indexesInternal
¬¬: I
[
¬¬I J
i
¬¬J K
+
¬¬L M
$num
¬¬N O
]
¬¬O P
)
¬¬P Q
;
¬¬Q R
if
®® 
(
®® 
!
®® 
dist
®® 
.
®® 
Add
®® 
(
®® 
a
®® 
)
®®  
)
®®  !
dup
®®" %
.
®®% &
Add
®®& )
(
®®) *
a
®®* +
)
®®+ ,
;
®®, -
if
¯¯ 
(
¯¯ 
!
¯¯ 
dist
¯¯ 
.
¯¯ 
Add
¯¯ 
(
¯¯ 
b
¯¯ 
)
¯¯  
)
¯¯  !
dup
¯¯" %
.
¯¯% &
Add
¯¯& )
(
¯¯) *
b
¯¯* +
)
¯¯+ ,
;
¯¯, -
if
°° 
(
°° 
!
°° 
dist
°° 
.
°° 
Add
°° 
(
°° 
c
°° 
)
°°  
)
°°  !
dup
°°" %
.
°°% &
Add
°°& )
(
°°) *
c
°°* +
)
°°+ ,
;
°°, -
}
±± 
dist
³³ 
.
³³ 

ExceptWith
³³ 
(
³³ 
dup
³³ 
)
³³  
;
³³  !
m_Edges
´´ 
=
´´ 
dist
´´ 
.
´´ 
ToArray
´´ "
(
´´" #
)
´´# $
;
´´$ %
return
µµ 
m_Edges
µµ 
;
µµ 
}
¶¶ 	
int
¸¸ 
[
¸¸ 
]
¸¸ "
CacheDistinctIndexes
¸¸ "
(
¸¸" #
)
¸¸# $
{
¹¹ 	
if
ºº 
(
ºº 
	m_Indexes
ºº 
==
ºº 
null
ºº !
)
ºº! "
return
»» 
null
»» 
;
»» 
m_DistinctIndexes
¼¼ 
=
¼¼ 
	m_Indexes
¼¼  )
.
¼¼) *
Distinct
¼¼* 2
(
¼¼2 3
)
¼¼3 4
.
¼¼4 5
ToArray
¼¼5 <
(
¼¼< =
)
¼¼= >
;
¼¼> ?
return
½½ %
distinctIndexesInternal
½½ *
;
½½* +
}
¾¾ 	
public
ÇÇ 
bool
ÇÇ 
Contains
ÇÇ 
(
ÇÇ 
int
ÇÇ  
a
ÇÇ! "
,
ÇÇ" #
int
ÇÇ$ '
b
ÇÇ( )
,
ÇÇ) *
int
ÇÇ+ .
c
ÇÇ/ 0
)
ÇÇ0 1
{
ÈÈ 	
for
ÉÉ 
(
ÉÉ 
int
ÉÉ 
i
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
,
ÉÉ 
cnt
ÉÉ 
=
ÉÉ  !
indexesInternal
ÉÉ" 1
.
ÉÉ1 2
Length
ÉÉ2 8
;
ÉÉ8 9
i
ÉÉ: ;
<
ÉÉ< =
cnt
ÉÉ> A
;
ÉÉA B
i
ÉÉC D
+=
ÉÉE G
$num
ÉÉH I
)
ÉÉI J
{
ÊÊ 
if
ËË 
(
ËË 
a
ËË 
==
ËË 
indexesInternal
ËË (
[
ËË( )
i
ËË) *
+
ËË+ ,
$num
ËË- .
]
ËË. /
&&
ÌÌ 
b
ÌÌ 
==
ÌÌ 
indexesInternal
ÌÌ +
[
ÌÌ+ ,
i
ÌÌ, -
+
ÌÌ. /
$num
ÌÌ0 1
]
ÌÌ1 2
&&
ÍÍ 
c
ÍÍ 
==
ÍÍ 
indexesInternal
ÍÍ +
[
ÍÍ+ ,
i
ÍÍ, -
+
ÍÍ. /
$num
ÍÍ0 1
]
ÍÍ1 2
)
ÍÍ2 3
return
ÎÎ 
true
ÎÎ 
;
ÎÎ  
}
ÏÏ 
return
ÑÑ 
false
ÑÑ 
;
ÑÑ 
}
ÒÒ 	
public
ØØ 
bool
ØØ 
IsQuad
ØØ 
(
ØØ 
)
ØØ 
{
ÙÙ 	
return
ÚÚ 
edgesInternal
ÚÚ  
!=
ÚÚ! #
null
ÚÚ$ (
&&
ÚÚ) +
edgesInternal
ÚÚ, 9
.
ÚÚ9 :
Length
ÚÚ: @
==
ÚÚA C
$num
ÚÚD E
;
ÚÚE F
}
ÛÛ 	
public
áá 
int
áá 
[
áá 
]
áá 
ToQuad
áá 
(
áá 
)
áá 
{
ââ 	
if
ãã 
(
ãã 
!
ãã 
IsQuad
ãã 
(
ãã 
)
ãã 
)
ãã 
throw
ää 
new
ää '
InvalidOperationException
ää 3
(
ää3 4
$strää4 
)ää ‚
;ää‚ ƒ
int
ææ 
[
ææ 
]
ææ 
quad
ææ 
=
ææ 
new
ææ 
int
ææ  
[
ææ  !
$num
ææ! "
]
ææ" #
{
ææ$ %
edgesInternal
ææ& 3
[
ææ3 4
$num
ææ4 5
]
ææ5 6
.
ææ6 7
a
ææ7 8
,
ææ8 9
edgesInternal
ææ: G
[
ææG H
$num
ææH I
]
ææI J
.
ææJ K
b
ææK L
,
ææL M
-
ææN O
$num
ææO P
,
ææP Q
-
ææR S
$num
ææS T
}
ææU V
;
ææV W
if
èè 
(
èè 
edgesInternal
èè 
[
èè 
$num
èè 
]
èè  
.
èè  !
a
èè! "
==
èè# %
quad
èè& *
[
èè* +
$num
èè+ ,
]
èè, -
)
èè- .
quad
éé 
[
éé 
$num
éé 
]
éé 
=
éé 
edgesInternal
éé '
[
éé' (
$num
éé( )
]
éé) *
.
éé* +
b
éé+ ,
;
éé, -
else
êê 
if
êê 
(
êê 
edgesInternal
êê "
[
êê" #
$num
êê# $
]
êê$ %
.
êê% &
a
êê& '
==
êê( *
quad
êê+ /
[
êê/ 0
$num
êê0 1
]
êê1 2
)
êê2 3
quad
ëë 
[
ëë 
$num
ëë 
]
ëë 
=
ëë 
edgesInternal
ëë '
[
ëë' (
$num
ëë( )
]
ëë) *
.
ëë* +
b
ëë+ ,
;
ëë, -
else
ìì 
if
ìì 
(
ìì 
edgesInternal
ìì "
[
ìì" #
$num
ìì# $
]
ìì$ %
.
ìì% &
a
ìì& '
==
ìì( *
quad
ìì+ /
[
ìì/ 0
$num
ìì0 1
]
ìì1 2
)
ìì2 3
quad
íí 
[
íí 
$num
íí 
]
íí 
=
íí 
edgesInternal
íí '
[
íí' (
$num
íí( )
]
íí) *
.
íí* +
b
íí+ ,
;
íí, -
if
ïï 
(
ïï 
edgesInternal
ïï 
[
ïï 
$num
ïï 
]
ïï  
.
ïï  !
a
ïï! "
==
ïï# %
quad
ïï& *
[
ïï* +
$num
ïï+ ,
]
ïï, -
)
ïï- .
quad
ğğ 
[
ğğ 
$num
ğğ 
]
ğğ 
=
ğğ 
edgesInternal
ğğ '
[
ğğ' (
$num
ğğ( )
]
ğğ) *
.
ğğ* +
b
ğğ+ ,
;
ğğ, -
else
ññ 
if
ññ 
(
ññ 
edgesInternal
ññ "
[
ññ" #
$num
ññ# $
]
ññ$ %
.
ññ% &
a
ññ& '
==
ññ( *
quad
ññ+ /
[
ññ/ 0
$num
ññ0 1
]
ññ1 2
)
ññ2 3
quad
òò 
[
òò 
$num
òò 
]
òò 
=
òò 
edgesInternal
òò '
[
òò' (
$num
òò( )
]
òò) *
.
òò* +
b
òò+ ,
;
òò, -
else
óó 
if
óó 
(
óó 
edgesInternal
óó "
[
óó" #
$num
óó# $
]
óó$ %
.
óó% &
a
óó& '
==
óó( *
quad
óó+ /
[
óó/ 0
$num
óó0 1
]
óó1 2
)
óó2 3
quad
ôô 
[
ôô 
$num
ôô 
]
ôô 
=
ôô 
edgesInternal
ôô '
[
ôô' (
$num
ôô( )
]
ôô) *
.
ôô* +
b
ôô+ ,
;
ôô, -
return
öö 
quad
öö 
;
öö 
}
÷÷ 	
public
ùù 
override
ùù 
string
ùù 
ToString
ùù '
(
ùù' (
)
ùù( )
{
úú 	
System
ûû 
.
ûû 
Text
ûû 
.
ûû 
StringBuilder
ûû %
sb
ûû& (
=
ûû) *
new
ûû+ .
System
ûû/ 5
.
ûû5 6
Text
ûû6 :
.
ûû: ;
StringBuilder
ûû; H
(
ûûH I
)
ûûI J
;
ûûJ K
for
ıı 
(
ıı 
int
ıı 
i
ıı 
=
ıı 
$num
ıı 
;
ıı 
i
ıı 
<
ıı 
indexesInternal
ıı  /
.
ıı/ 0
Length
ıı0 6
;
ıı6 7
i
ıı8 9
+=
ıı: <
$num
ıı= >
)
ıı> ?
{
şş 
sb
ÿÿ 
.
ÿÿ 
Append
ÿÿ 
(
ÿÿ 
$str
ÿÿ 
)
ÿÿ 
;
ÿÿ 
sb
€€ 
.
€€ 
Append
€€ 
(
€€ 
indexesInternal
€€ )
[
€€) *
i
€€* +
]
€€+ ,
)
€€, -
;
€€- .
sb
 
.
 
Append
 
(
 
$str
 
)
 
;
  
sb
‚‚ 
.
‚‚ 
Append
‚‚ 
(
‚‚ 
indexesInternal
‚‚ )
[
‚‚) *
i
‚‚* +
+
‚‚, -
$num
‚‚. /
]
‚‚/ 0
)
‚‚0 1
;
‚‚1 2
sb
ƒƒ 
.
ƒƒ 
Append
ƒƒ 
(
ƒƒ 
$str
ƒƒ 
)
ƒƒ 
;
ƒƒ  
sb
„„ 
.
„„ 
Append
„„ 
(
„„ 
indexesInternal
„„ )
[
„„) *
i
„„* +
+
„„, -
$num
„„. /
]
„„/ 0
)
„„0 1
;
„„1 2
sb
…… 
.
…… 
Append
…… 
(
…… 
$str
…… 
)
…… 
;
…… 
if
‡‡ 
(
‡‡ 
i
‡‡ 
<
‡‡ 
indexesInternal
‡‡ '
.
‡‡' (
Length
‡‡( .
-
‡‡/ 0
$num
‡‡1 2
)
‡‡2 3
sb
ˆˆ 
.
ˆˆ 
Append
ˆˆ 
(
ˆˆ 
$str
ˆˆ "
)
ˆˆ" #
;
ˆˆ# $
}
‰‰ 
return
‹‹ 
sb
‹‹ 
.
‹‹ 
ToString
‹‹ 
(
‹‹ 
)
‹‹  
;
‹‹  !
}
ŒŒ 	
public
’’ 
void
’’ 
ShiftIndexes
’’  
(
’’  !
int
’’! $
offset
’’% +
)
’’+ ,
{
““ 	
for
”” 
(
”” 
int
”” 
i
”” 
=
”” 
$num
”” 
,
”” 
c
”” 
=
”” 
	m_Indexes
””  )
.
””) *
Length
””* 0
;
””0 1
i
””2 3
<
””4 5
c
””6 7
;
””7 8
i
””9 :
++
””: <
)
””< =
	m_Indexes
•• 
[
•• 
i
•• 
]
•• 
+=
•• 
offset
••  &
;
••& '
InvalidateCache
—— 
(
—— 
)
—— 
;
—— 
}
˜˜ 	
int
  
SmallestIndexValue
 
(
 
)
  
{
ŸŸ 	
int
   
smallest
   
=
   
	m_Indexes
   $
[
  $ %
$num
  % &
]
  & '
;
  ' (
for
¢¢ 
(
¢¢ 
int
¢¢ 
i
¢¢ 
=
¢¢ 
$num
¢¢ 
;
¢¢ 
i
¢¢ 
<
¢¢ 
	m_Indexes
¢¢  )
.
¢¢) *
Length
¢¢* 0
;
¢¢0 1
i
¢¢2 3
++
¢¢3 5
)
¢¢5 6
{
££ 
if
¤¤ 
(
¤¤ 
	m_Indexes
¤¤ 
[
¤¤ 
i
¤¤ 
]
¤¤  
<
¤¤! "
smallest
¤¤# +
)
¤¤+ ,
smallest
¥¥ 
=
¥¥ 
	m_Indexes
¥¥ (
[
¥¥( )
i
¥¥) *
]
¥¥* +
;
¥¥+ ,
}
¦¦ 
return
¨¨ 
smallest
¨¨ 
;
¨¨ 
}
©© 	
public
´´ 
void
´´  
ShiftIndexesToZero
´´ &
(
´´& '
)
´´' (
{
µµ 	
int
¶¶ 
offset
¶¶ 
=
¶¶  
SmallestIndexValue
¶¶ +
(
¶¶+ ,
)
¶¶, -
;
¶¶- .
for
¸¸ 
(
¸¸ 
int
¸¸ 
i
¸¸ 
=
¸¸ 
$num
¸¸ 
;
¸¸ 
i
¸¸ 
<
¸¸ 
	m_Indexes
¸¸  )
.
¸¸) *
Length
¸¸* 0
;
¸¸0 1
i
¸¸2 3
++
¸¸3 5
)
¸¸5 6
	m_Indexes
¹¹ 
[
¹¹ 
i
¹¹ 
]
¹¹ 
-=
¹¹ 
offset
¹¹  &
;
¹¹& '
InvalidateCache
»» 
(
»» 
)
»» 
;
»» 
}
¼¼ 	
public
ÁÁ 
void
ÁÁ 
Reverse
ÁÁ 
(
ÁÁ 
)
ÁÁ 
{
ÂÂ 	
Array
ÃÃ 
.
ÃÃ 
Reverse
ÃÃ 
(
ÃÃ 
	m_Indexes
ÃÃ #
)
ÃÃ# $
;
ÃÃ$ %
InvalidateCache
ÄÄ 
(
ÄÄ 
)
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
internal
ÇÇ 
static
ÇÇ 
void
ÇÇ 

GetIndices
ÇÇ '
(
ÇÇ' (
IEnumerable
ÇÇ( 3
<
ÇÇ3 4
Face
ÇÇ4 8
>
ÇÇ8 9
faces
ÇÇ: ?
,
ÇÇ? @
List
ÇÇA E
<
ÇÇE F
int
ÇÇF I
>
ÇÇI J
indices
ÇÇK R
)
ÇÇR S
{
ÈÈ 	
indices
ÉÉ 
.
ÉÉ 
Clear
ÉÉ 
(
ÉÉ 
)
ÉÉ 
;
ÉÉ 
foreach
ËË 
(
ËË 
var
ËË 
face
ËË 
in
ËË  
faces
ËË! &
)
ËË& '
{
ÌÌ 
for
ÍÍ 
(
ÍÍ 
int
ÍÍ 
i
ÍÍ 
=
ÍÍ 
$num
ÍÍ 
,
ÍÍ 
c
ÍÍ  !
=
ÍÍ" #
face
ÍÍ$ (
.
ÍÍ( )
indexesInternal
ÍÍ) 8
.
ÍÍ8 9
Length
ÍÍ9 ?
;
ÍÍ? @
i
ÍÍA B
<
ÍÍC D
c
ÍÍE F
;
ÍÍF G
++
ÍÍH J
i
ÍÍJ K
)
ÍÍK L
indices
ÎÎ 
.
ÎÎ 
Add
ÎÎ 
(
ÎÎ  
face
ÎÎ  $
.
ÎÎ$ %
indexesInternal
ÎÎ% 4
[
ÎÎ4 5
i
ÎÎ5 6
]
ÎÎ6 7
)
ÎÎ7 8
;
ÎÎ8 9
}
ÏÏ 
}
ĞĞ 	
internal
ÒÒ 
static
ÒÒ 
void
ÒÒ  
GetDistinctIndices
ÒÒ /
(
ÒÒ/ 0
IEnumerable
ÒÒ0 ;
<
ÒÒ; <
Face
ÒÒ< @
>
ÒÒ@ A
faces
ÒÒB G
,
ÒÒG H
List
ÒÒI M
<
ÒÒM N
int
ÒÒN Q
>
ÒÒQ R
indices
ÒÒS Z
)
ÒÒZ [
{
ÓÓ 	
indices
ÔÔ 
.
ÔÔ 
Clear
ÔÔ 
(
ÔÔ 
)
ÔÔ 
;
ÔÔ 
foreach
ÖÖ 
(
ÖÖ 
var
ÖÖ 
face
ÖÖ 
in
ÖÖ  
faces
ÖÖ! &
)
ÖÖ& '
{
×× 
for
ØØ 
(
ØØ 
int
ØØ 
i
ØØ 
=
ØØ 
$num
ØØ 
,
ØØ 
c
ØØ  !
=
ØØ" #
face
ØØ$ (
.
ØØ( )%
distinctIndexesInternal
ØØ) @
.
ØØ@ A
Length
ØØA G
;
ØØG H
i
ØØI J
<
ØØK L
c
ØØM N
;
ØØN O
++
ØØP R
i
ØØR S
)
ØØS T
indices
ÙÙ 
.
ÙÙ 
Add
ÙÙ 
(
ÙÙ  
face
ÙÙ  $
.
ÙÙ$ %%
distinctIndexesInternal
ÙÙ% <
[
ÙÙ< =
i
ÙÙ= >
]
ÙÙ> ?
)
ÙÙ? @
;
ÙÙ@ A
}
ÚÚ 
}
ÛÛ 	
internal
àà 
bool
àà 
TryGetNextEdge
àà $
(
àà$ %
Edge
àà% )
source
àà* 0
,
àà0 1
int
àà2 5
index
àà6 ;
,
àà; <
ref
àà= @
Edge
ààA E
nextEdge
ààF N
,
ààN O
ref
ààP S
int
ààT W
	nextIndex
ààX a
)
ààa b
{
áá 	
for
ââ 
(
ââ 
int
ââ 
i
ââ 
=
ââ 
$num
ââ 
,
ââ 
c
ââ 
=
ââ 
edgesInternal
ââ  -
.
ââ- .
Length
ââ. 4
;
ââ4 5
i
ââ6 7
<
ââ8 9
c
ââ: ;
;
ââ; <
i
ââ= >
++
ââ> @
)
ââ@ A
{
ãã 
if
ää 
(
ää 
edgesInternal
ää !
[
ää! "
i
ää" #
]
ää# $
==
ää% '
source
ää( .
)
ää. /
continue
åå 
;
åå 
nextEdge
çç 
=
çç 
edgesInternal
çç (
[
çç( )
i
çç) *
]
çç* +
;
çç+ ,
if
éé 
(
éé 
nextEdge
éé 
.
éé 
Contains
éé %
(
éé% &
index
éé& +
)
éé+ ,
)
éé, -
{
êê 
	nextIndex
ëë 
=
ëë 
nextEdge
ëë  (
.
ëë( )
a
ëë) *
==
ëë+ -
index
ëë. 3
?
ëë4 5
nextEdge
ëë6 >
.
ëë> ?
b
ëë? @
:
ëëA B
nextEdge
ëëC K
.
ëëK L
a
ëëL M
;
ëëM N
return
ìì 
true
ìì 
;
ìì  
}
íí 
}
îî 
return
ğğ 
false
ğğ 
;
ğğ 
}
ññ 	
}
òò 
}óó û´
˜D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\Triangulation.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{		 
static 

class 
Triangulation 
{ 
static  
TriangulationContext #"
s_TriangulationContext$ :
;: ;
static  
TriangulationContext # 
triangulationContext$ 8
{ 	
get 
{ 
if 
( "
s_TriangulationContext )
==* ,
null- 1
)1 2"
s_TriangulationContext *
=+ ,
new- 0
DTSweepContext1 ?
(? @
)@ A
;A B
return "
s_TriangulationContext -
;- .
} 
} 	
public## 
static## 
bool## 
SortAndTriangulate## -
(##- .
IList##. 3
<##3 4
Vector2##4 ;
>##; <
points##= C
,##C D
out##E H
List##I M
<##M N
int##N Q
>##Q R
indexes##S Z
,##Z [
bool##\ `
convex##a g
=##h i
false##j o
)##o p
{$$ 	
IList%% 
<%% 
Vector2%% 
>%% 
sorted%% !
=%%" #

Projection%%$ .
.%%. /
Sort%%/ 3
(%%3 4
points%%4 :
,%%: ;

SortMethod%%< F
.%%F G
CounterClockwise%%G W
)%%W X
;%%X Y

Dictionary'' 
<'' 
int'' 
,'' 
int'' 
>''  
map''! $
=''% &
new''' *

Dictionary''+ 5
<''5 6
int''6 9
,''9 :
int''; >
>''> ?
(''? @
)''@ A
;''A B
for)) 
()) 
int)) 
i)) 
=)) 
$num)) 
;)) 
i)) 
<)) 
sorted))  &
.))& '
Count))' ,
;)), -
i)). /
++))/ 1
)))1 2
map** 
.** 
Add** 
(** 
i** 
,** 
points** !
.**! "
IndexOf**" )
(**) *
sorted*** 0
[**0 1
i**1 2
]**2 3
)**3 4
)**4 5
;**5 6
if,, 
(,, 
!,, 
Triangulate,, 
(,, 
sorted,, #
,,,# $
out,,% (
indexes,,) 0
,,,0 1
convex,,2 8
),,8 9
),,9 :
return-- 
false-- 
;-- 
for// 
(// 
int// 
i// 
=// 
$num// 
;// 
i// 
<// 
indexes//  '
.//' (
Count//( -
;//- .
i/// 0
++//0 2
)//2 3
indexes00 
[00 
i00 
]00 
=00 
map00  
[00  !
indexes00! (
[00( )
i00) *
]00* +
]00+ ,
;00, -
return22 
true22 
;22 
}33 	
public== 
static== 
bool== 
TriangulateVertices== .
(==. /
IList==/ 4
<==4 5
Vertex==5 ;
>==; <
vertices=== E
,==E F
out==G J
List==K O
<==O P
int==P S
>==S T
	triangles==U ^
,==^ _
bool==` d
	unordered==e n
===o p
true==q u
,==u v
bool==w {
convex	==| ‚
=
==ƒ „
false
==… Š
)
==Š ‹
{>> 	
Vector3?? 
[?? 
]?? 

facePoints??  
=??! "
new??# &
Vector3??' .
[??. /
vertices??/ 7
.??7 8
Count??8 =
]??= >
;??> ?
forAA 
(AA 
intAA 
iAA 
=AA 
$numAA 
;AA 
iAA 
<AA 
verticesAA  (
.AA( )
CountAA) .
;AA. /
++AA0 2
iAA2 3
)AA3 4

facePointsBB 
[BB 
iBB 
]BB 
=BB 
verticesBB  (
[BB( )
iBB) *
]BB* +
.BB+ ,
positionBB, 4
;BB4 5
returnDD 
TriangulateVerticesDD &
(DD& '

facePointsDD' 1
,DD1 2
outDD3 6
	trianglesDD7 @
,DD@ A
	unorderedDDB K
,DDK L
convexDDM S
)DDS T
;DDT U
}EE 	
publicPP 
staticPP 
boolPP 
TriangulateVerticesPP .
(PP. /
Vector3PP/ 6
[PP6 7
]PP7 8
verticesPP9 A
,PPA B
outPPC F
ListPPG K
<PPK L
intPPL O
>PPO P
	trianglesPPQ Z
,PPZ [
Vector3PP\ c
[PPc d
]PPd e
[PPe f
]PPf g
holesPPh m
=PPn o
nullPPp t
)PPt u
{QQ 	
	trianglesRR 
=RR 
nullRR 
;RR 
intSS 
vertexCountSS 
=SS 
verticesSS &
==SS' )
nullSS* .
?SS/ 0
$numSS1 2
:SS3 4
verticesSS5 =
.SS= >
LengthSS> D
;SSD E
ifUU 
(UU 
vertexCountUU 
<UU 
$numUU 
)UU  
returnVV 
falseVV 
;VV 
varXX 
normalXX 
=XX 

ProjectionXX #
.XX# $
FindBestPlaneXX$ 1
(XX1 2
verticesXX2 :
)XX: ;
.XX; <
normalXX< B
;XXB C
Vector2YY 
[YY 
]YY 
points2dYY 
=YY  

ProjectionYY! +
.YY+ ,
PlanarProjectYY, 9
(YY9 :
verticesYY: B
,YYB C
nullYYD H
,YYH I
normalYYJ P
)YYP Q
;YYQ R
Vector2ZZ 
[ZZ 
]ZZ 
[ZZ 
]ZZ 
holes2dZZ 
=ZZ  !
nullZZ" &
;ZZ& '
if[[ 
([[ 
holes[[ 
!=[[ 
null[[ 
)[[ 
{\\ 
holes2d]] 
=]] 
new]] 
Vector2]] %
[]]% &
holes]]& +
.]]+ ,
Length]], 2
]]]2 3
[]]3 4
]]]4 5
;]]5 6
for^^ 
(^^ 
int^^ 
i^^ 
=^^ 
$num^^ 
;^^ 
i^^  !
<^^" #
holes^^$ )
.^^) *
Length^^* 0
;^^0 1
i^^2 3
++^^3 5
)^^5 6
{__ 
if`` 
(`` 
holes`` 
[`` 
i`` 
]`` 
.``  
Length``  &
<``' (
$num``) *
)``* +
returnaa 
falseaa $
;aa$ %
holes2dcc 
[cc 
icc 
]cc 
=cc  

Projectioncc! +
.cc+ ,
PlanarProjectcc, 9
(cc9 :
holescc: ?
[cc? @
icc@ A
]ccA B
,ccB C
nullccD H
,ccH I
normalccJ P
)ccP Q
;ccQ R
}dd 
}ee 
returngg 
Triangulategg 
(gg 
points2dgg '
,gg' (
holes2dgg) 0
,gg0 1
outgg2 5
	trianglesgg6 ?
)gg? @
;gg@ A
}hh 	
publicjj 
staticjj 
booljj 
TriangulateVerticesjj .
(jj. /
Vector3jj/ 6
[jj6 7
]jj7 8
verticesjj9 A
,jjA B
outjjC F
ListjjG K
<jjK L
intjjL O
>jjO P
	trianglesjjQ Z
,jjZ [
booljj\ `
	unorderedjja j
=jjk l
truejjm q
,jjq r
booljjs w
convexjjx ~
=	jj €
false
jj †
)
jj† ‡
{kk 	
	trianglesll 
=ll 
nullll 
;ll 
intmm 
vertexCountmm 
=mm 
verticesmm &
==mm' )
nullmm* .
?mm/ 0
$nummm1 2
:mm3 4
verticesmm5 =
.mm= >
Lengthmm> D
;mmD E
ifoo 
(oo 
vertexCountoo 
<oo 
$numoo 
)oo  
returnpp 
falsepp 
;pp 
ifrr 
(rr 
vertexCountrr 
==rr 
$numrr  
)rr  !
{ss 
	trianglestt 
=tt 
newtt 
Listtt  $
<tt$ %
inttt% (
>tt( )
(tt) *
)tt* +
{tt, -
$numtt. /
,tt/ 0
$numtt1 2
,tt2 3
$numtt4 5
}tt6 7
;tt7 8
returnuu 
trueuu 
;uu 
}vv 
Vector2xx 
[xx 
]xx 
points2dxx 
=xx  

Projectionxx! +
.xx+ ,
PlanarProjectxx, 9
(xx9 :
verticesxx: B
)xxB C
;xxC D
ifzz 
(zz 
	unorderedzz 
)zz 
return{{ 
SortAndTriangulate{{ )
({{) *
points2d{{* 2
,{{2 3
out{{4 7
	triangles{{8 A
,{{A B
convex{{C I
){{I J
;{{J K
return}} 
Triangulate}} 
(}} 
points2d}} '
,}}' (
out}}) ,
	triangles}}- 6
,}}6 7
convex}}8 >
)}}> ?
;}}? @
}~~ 	
public
‡‡ 
static
‡‡ 
bool
‡‡ 
Triangulate
‡‡ &
(
‡‡& '
IList
‡‡' ,
<
‡‡, -
Vector2
‡‡- 4
>
‡‡4 5
points
‡‡6 <
,
‡‡< =
out
‡‡> A
List
‡‡B F
<
‡‡F G
int
‡‡G J
>
‡‡J K
indexes
‡‡L S
,
‡‡S T
bool
‡‡U Y
convex
‡‡Z `
=
‡‡a b
false
‡‡c h
)
‡‡h i
{
ˆˆ 	
indexes
‰‰ 
=
‰‰ 
new
‰‰ 
List
‰‰ 
<
‰‰ 
int
‰‰ "
>
‰‰" #
(
‰‰# $
)
‰‰$ %
;
‰‰% &
int
‹‹ 
index
‹‹ 
=
‹‹ 
$num
‹‹ 
;
‹‹ 
Triangulatable
 
soup
 
=
  !
convex
" (
?
 
new
 
PointSet
 
(
 
points
 %
.
% &
Select
& ,
(
, -
x
- .
=>
/ 1
new
2 5 
TriangulationPoint
6 H
(
H I
x
I J
.
J K
x
K L
,
L M
x
N O
.
O P
y
P Q
,
Q R
index
S X
++
X Z
)
Z [
)
[ \
.
\ ]
ToList
] c
(
c d
)
d e
)
e f
:
 
(
 
Triangulatable
 !
)
! "
new
# &
Polygon
' .
(
. /
points
/ 5
.
5 6
Select
6 <
(
< =
x
= >
=>
? A
new
B E
PolygonPoint
F R
(
R S
x
S T
.
T U
x
U V
,
V W
x
X Y
.
Y Z
y
Z [
,
[ \
index
] b
++
b d
)
d e
)
e f
)
f g
;
g h
try
‘‘ 
{
’’ "
triangulationContext
““ $
.
““$ %
Clear
““% *
(
““* +
)
““+ ,
;
““, -"
triangulationContext
”” $
.
””$ %"
PrepareTriangulation
””% 9
(
””9 :
soup
””: >
)
””> ?
;
””? @
DTSweep
•• 
.
•• 
Triangulate
•• #
(
••# $
(
••$ %
DTSweepContext
••% 3
)
••3 4"
triangulationContext
••4 H
)
••H I
;
••I J
}
–– 
catch
—— 
(
—— 
System
—— 
.
—— 
	Exception
—— #
e
——$ %
)
——% &
{
˜˜ 
Log
™™ 
.
™™ 
Info
™™ 
(
™™ 
$str
™™ 1
+
™™2 3
e
™™4 5
.
™™5 6
ToString
™™6 >
(
™™> ?
)
™™? @
)
™™@ A
;
™™A B
return
šš 
false
šš 
;
šš 
}
›› 
foreach
 
(
 
DelaunayTriangle
 %
d
& '
in
( *
soup
+ /
.
/ 0
	Triangles
0 9
)
9 :
{
 
if
ŸŸ 
(
ŸŸ 
d
ŸŸ 
.
ŸŸ 
Points
ŸŸ 
[
ŸŸ 
$num
ŸŸ 
]
ŸŸ 
.
ŸŸ  
Index
ŸŸ  %
<
ŸŸ& '
$num
ŸŸ( )
||
ŸŸ* ,
d
ŸŸ- .
.
ŸŸ. /
Points
ŸŸ/ 5
[
ŸŸ5 6
$num
ŸŸ6 7
]
ŸŸ7 8
.
ŸŸ8 9
Index
ŸŸ9 >
<
ŸŸ? @
$num
ŸŸA B
||
ŸŸC E
d
ŸŸF G
.
ŸŸG H
Points
ŸŸH N
[
ŸŸN O
$num
ŸŸO P
]
ŸŸP Q
.
ŸŸQ R
Index
ŸŸR W
<
ŸŸX Y
$num
ŸŸZ [
)
ŸŸ[ \
{
   
Log
¡¡ 
.
¡¡ 
Info
¡¡ 
(
¡¡ 
$str
¡¡ W
)
¡¡W X
;
¡¡X Y
return
¢¢ 
false
¢¢  
;
¢¢  !
}
££ 
indexes
¥¥ 
.
¥¥ 
Add
¥¥ 
(
¥¥ 
d
¥¥ 
.
¥¥ 
Points
¥¥ $
[
¥¥$ %
$num
¥¥% &
]
¥¥& '
.
¥¥' (
Index
¥¥( -
)
¥¥- .
;
¥¥. /
indexes
¦¦ 
.
¦¦ 
Add
¦¦ 
(
¦¦ 
d
¦¦ 
.
¦¦ 
Points
¦¦ $
[
¦¦$ %
$num
¦¦% &
]
¦¦& '
.
¦¦' (
Index
¦¦( -
)
¦¦- .
;
¦¦. /
indexes
§§ 
.
§§ 
Add
§§ 
(
§§ 
d
§§ 
.
§§ 
Points
§§ $
[
§§$ %
$num
§§% &
]
§§& '
.
§§' (
Index
§§( -
)
§§- .
;
§§. /
}
¨¨ 
WindingOrder
ªª 
originalWinding
ªª (
=
ªª) *
SurfaceTopology
ªª+ :
.
ªª: ;
GetWindingOrder
ªª; J
(
ªªJ K
points
ªªK Q
)
ªªQ R
;
ªªR S
if
¯¯ 
(
¯¯ 
SurfaceTopology
¯¯ 
.
¯¯  
GetWindingOrder
¯¯  /
(
¯¯/ 0
new
¯¯0 3
Vector2
¯¯4 ;
[
¯¯; <
$num
¯¯< =
]
¯¯= >
{
°° 
points
±± 
[
±± 
indexes
±± 
[
±± 
$num
±±  
]
±±  !
]
±±! "
,
±±" #
points
²² 
[
²² 
indexes
²² 
[
²² 
$num
²²  
]
²²  !
]
²²! "
,
²²" #
points
³³ 
[
³³ 
indexes
³³ 
[
³³ 
$num
³³  
]
³³  !
]
³³! "
,
³³" #
}
µµ 
)
µµ 
!=
µµ 
originalWinding
µµ !
)
µµ! "
indexes
¶¶ 
.
¶¶ 
Reverse
¶¶ 
(
¶¶  
)
¶¶  !
;
¶¶! "
return
¸¸ 
true
¸¸ 
;
¸¸ 
}
¹¹ 	
public
ÃÃ 
static
ÃÃ 
bool
ÃÃ 
Triangulate
ÃÃ &
(
ÃÃ& '
IList
ÃÃ' ,
<
ÃÃ, -
Vector2
ÃÃ- 4
>
ÃÃ4 5
points
ÃÃ6 <
,
ÃÃ< =
IList
ÃÃ> C
<
ÃÃC D
IList
ÃÃD I
<
ÃÃI J
Vector2
ÃÃJ Q
>
ÃÃQ R
>
ÃÃR S
holes
ÃÃT Y
,
ÃÃY Z
out
ÃÃ[ ^
List
ÃÃ_ c
<
ÃÃc d
int
ÃÃd g
>
ÃÃg h
indexes
ÃÃi p
)
ÃÃp q
{
ÄÄ 	
indexes
ÅÅ 
=
ÅÅ 
new
ÅÅ 
List
ÅÅ 
<
ÅÅ 
int
ÅÅ "
>
ÅÅ" #
(
ÅÅ# $
)
ÅÅ$ %
;
ÅÅ% &
int
ÇÇ 
index
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
;
ÇÇ 
var
ÉÉ 
	allPoints
ÉÉ 
=
ÉÉ 
new
ÉÉ 
List
ÉÉ  $
<
ÉÉ$ %
Vector2
ÉÉ% ,
>
ÉÉ, -
(
ÉÉ- .
points
ÉÉ. 4
)
ÉÉ4 5
;
ÉÉ5 6
Polygon
ËË 
polygon
ËË 
=
ËË 
new
ËË !
Polygon
ËË" )
(
ËË) *
points
ËË* 0
.
ËË0 1
Select
ËË1 7
(
ËË7 8
x
ËË8 9
=>
ËË: <
new
ËË= @
PolygonPoint
ËËA M
(
ËËM N
x
ËËN O
.
ËËO P
x
ËËP Q
,
ËËQ R
x
ËËS T
.
ËËT U
y
ËËU V
,
ËËV W
index
ËËX ]
++
ËË] _
)
ËË_ `
)
ËË` a
)
ËËa b
;
ËËb c
if
ÌÌ 
(
ÌÌ 
holes
ÌÌ 
!=
ÌÌ 
null
ÌÌ 
)
ÌÌ 
{
ÍÍ 
for
ÎÎ 
(
ÎÎ 
int
ÎÎ 
i
ÎÎ 
=
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
i
ÎÎ  !
<
ÎÎ" #
holes
ÎÎ$ )
.
ÎÎ) *
Count
ÎÎ* /
;
ÎÎ/ 0
i
ÎÎ1 2
++
ÎÎ2 4
)
ÎÎ4 5
{
ÏÏ 
	allPoints
ĞĞ 
.
ĞĞ 
AddRange
ĞĞ &
(
ĞĞ& '
holes
ĞĞ' ,
[
ĞĞ, -
i
ĞĞ- .
]
ĞĞ. /
)
ĞĞ/ 0
;
ĞĞ0 1
var
ÑÑ 
holePolgyon
ÑÑ #
=
ÑÑ$ %
new
ÑÑ& )
Polygon
ÑÑ* 1
(
ÑÑ1 2
holes
ÑÑ2 7
[
ÑÑ7 8
i
ÑÑ8 9
]
ÑÑ9 :
.
ÑÑ: ;
Select
ÑÑ; A
(
ÑÑA B
x
ÑÑB C
=>
ÑÑD F
new
ÑÑG J
PolygonPoint
ÑÑK W
(
ÑÑW X
x
ÑÑX Y
.
ÑÑY Z
x
ÑÑZ [
,
ÑÑ[ \
x
ÑÑ] ^
.
ÑÑ^ _
y
ÑÑ_ `
,
ÑÑ` a
index
ÑÑb g
++
ÑÑg i
)
ÑÑi j
)
ÑÑj k
)
ÑÑk l
;
ÑÑl m
polygon
ÒÒ 
.
ÒÒ 
AddHole
ÒÒ #
(
ÒÒ# $
holePolgyon
ÒÒ$ /
)
ÒÒ/ 0
;
ÒÒ0 1
}
ÓÓ 
}
ÔÔ 
try
ÖÖ 
{
×× "
triangulationContext
ØØ $
.
ØØ$ %
Clear
ØØ% *
(
ØØ* +
)
ØØ+ ,
;
ØØ, -"
triangulationContext
ÙÙ $
.
ÙÙ$ %"
PrepareTriangulation
ÙÙ% 9
(
ÙÙ9 :
polygon
ÙÙ: A
)
ÙÙA B
;
ÙÙB C
DTSweep
ÚÚ 
.
ÚÚ 
Triangulate
ÚÚ #
(
ÚÚ# $
(
ÚÚ$ %
DTSweepContext
ÚÚ% 3
)
ÚÚ3 4"
triangulationContext
ÚÚ4 H
)
ÚÚH I
;
ÚÚI J
}
ÛÛ 
catch
ÜÜ 
(
ÜÜ 
System
ÜÜ 
.
ÜÜ 
	Exception
ÜÜ #
e
ÜÜ$ %
)
ÜÜ% &
{
İİ 
Log
ŞŞ 
.
ŞŞ 
Info
ŞŞ 
(
ŞŞ 
$str
ŞŞ 1
+
ŞŞ2 3
e
ŞŞ4 5
.
ŞŞ5 6
ToString
ŞŞ6 >
(
ŞŞ> ?
)
ŞŞ? @
)
ŞŞ@ A
;
ŞŞA B
return
ßß 
false
ßß 
;
ßß 
}
àà 
foreach
ââ 
(
ââ 
DelaunayTriangle
ââ %
d
ââ& '
in
ââ( *
polygon
ââ+ 2
.
ââ2 3
	Triangles
ââ3 <
)
ââ< =
{
ãã 
if
ää 
(
ää 
d
ää 
.
ää 
Points
ää 
[
ää 
$num
ää 
]
ää 
.
ää  
Index
ää  %
<
ää& '
$num
ää( )
||
ää* ,
d
ää- .
.
ää. /
Points
ää/ 5
[
ää5 6
$num
ää6 7
]
ää7 8
.
ää8 9
Index
ää9 >
<
ää? @
$num
ääA B
||
ääC E
d
ääF G
.
ääG H
Points
ääH N
[
ääN O
$num
ääO P
]
ääP Q
.
ääQ R
Index
ääR W
<
ääX Y
$num
ääZ [
)
ää[ \
{
åå 
Log
ææ 
.
ææ 
Info
ææ 
(
ææ 
$str
ææ W
)
ææW X
;
ææX Y
return
çç 
false
çç  
;
çç  !
}
èè 
indexes
êê 
.
êê 
Add
êê 
(
êê 
d
êê 
.
êê 
Points
êê $
[
êê$ %
$num
êê% &
]
êê& '
.
êê' (
Index
êê( -
)
êê- .
;
êê. /
indexes
ëë 
.
ëë 
Add
ëë 
(
ëë 
d
ëë 
.
ëë 
Points
ëë $
[
ëë$ %
$num
ëë% &
]
ëë& '
.
ëë' (
Index
ëë( -
)
ëë- .
;
ëë. /
indexes
ìì 
.
ìì 
Add
ìì 
(
ìì 
d
ìì 
.
ìì 
Points
ìì $
[
ìì$ %
$num
ìì% &
]
ìì& '
.
ìì' (
Index
ìì( -
)
ìì- .
;
ìì. /
}
íí 
WindingOrder
ïï 
originalWinding
ïï (
=
ïï) *
SurfaceTopology
ïï+ :
.
ïï: ;
GetWindingOrder
ïï; J
(
ïïJ K
points
ïïK Q
)
ïïQ R
;
ïïR S
if
ôô 
(
ôô 
SurfaceTopology
ôô 
.
ôô  
GetWindingOrder
ôô  /
(
ôô/ 0
new
ôô0 3
Vector2
ôô4 ;
[
ôô; <
$num
ôô< =
]
ôô= >
{
õõ 
	allPoints
öö 
[
öö 
indexes
öö !
[
öö! "
$num
öö" #
]
öö# $
]
öö$ %
,
öö% &
	allPoints
÷÷ 
[
÷÷ 
indexes
÷÷ !
[
÷÷! "
$num
÷÷" #
]
÷÷# $
]
÷÷$ %
,
÷÷% &
	allPoints
øø 
[
øø 
indexes
øø !
[
øø! "
$num
øø" #
]
øø# $
]
øø$ %
,
øø% &
}
úú 
)
úú 
!=
úú 
originalWinding
úú !
)
úú! "
indexes
ûû 
.
ûû 
Reverse
ûû 
(
ûû  
)
ûû  !
;
ûû! "
return
ıı 
true
ıı 
;
ıı 
}
şş 	
}
ÿÿ 
}€€ …¦
™D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\MeshValidation.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
public

 
static

 
class

 
MeshValidation

 #
{ 
public 
static 
bool '
ContainsDegenerateTriangles 6
(6 7
this7 ;
ProBuilderMesh< J
meshK O
)O P
{ 	
return '
ContainsDegenerateTriangles .
(. /
mesh/ 3
,3 4
mesh5 9
.9 :
facesInternal: G
)G H
;H I
} 	
public 
static 
bool '
ContainsDegenerateTriangles 6
(6 7
this7 ;
ProBuilderMesh< J
meshK O
,O P
IListQ V
<V W
FaceW [
>[ \
faces] b
)b c
{ 	
var   
	positions   
=   
mesh    
.    !
positionsInternal  ! 2
;  2 3
foreach"" 
("" 
var"" 
face"" 
in""  
faces""! &
)""& '
{## 
var$$ 
indices$$ 
=$$ 
face$$ "
.$$" #
indexesInternal$$# 2
;$$2 3
for&& 
(&& 
int&& 
i&& 
=&& 
$num&& 
;&& 
i&&  !
<&&" #
indices&&$ +
.&&+ ,
Length&&, 2
;&&2 3
i&&4 5
+=&&6 8
$num&&9 :
)&&: ;
{'' 
float(( 
area(( 
=((  
Math((! %
.((% &
TriangleArea((& 2
(((2 3
	positions)) !
[))! "
indices))" )
[))) *
i))* +
+)), -
$num)). /
]))/ 0
]))0 1
,))1 2
	positions** !
[**! "
indices**" )
[**) *
i*** +
+**, -
$num**. /
]**/ 0
]**0 1
,**1 2
	positions++ !
[++! "
indices++" )
[++) *
i++* +
+++, -
$num++. /
]++/ 0
]++0 1
)++1 2
;++2 3
if-- 
(-- 
area-- 
<=-- 
Mathf--  %
.--% &
Epsilon--& -
)--- .
return.. 
true.. #
;..# $
}// 
}00 
return22 
false22 
;22 
}33 	
public<< 
static<< 
bool<< '
ContainsDegenerateTriangles<< 6
(<<6 7
this<<7 ;
ProBuilderMesh<<< J
mesh<<K O
,<<O P
Face<<Q U
face<<V Z
)<<Z [
{== 	
var>> 
	positions>> 
=>> 
mesh>>  
.>>  !
positionsInternal>>! 2
;>>2 3
var?? 
indices?? 
=?? 
face?? 
.?? 
indexesInternal?? .
;??. /
forAA 
(AA 
intAA 
iAA 
=AA 
$numAA 
;AA 
iAA 
<AA 
indicesAA  '
.AA' (
LengthAA( .
;AA. /
iAA0 1
+=AA2 4
$numAA5 6
)AA6 7
{BB 
floatCC 
areaCC 
=CC 
MathCC !
.CC! "
TriangleAreaCC" .
(CC. /
	positionsDD 
[DD 
indicesDD %
[DD% &
iDD& '
+DD( )
$numDD* +
]DD+ ,
]DD, -
,DD- .
	positionsEE 
[EE 
indicesEE %
[EE% &
iEE& '
+EE( )
$numEE* +
]EE+ ,
]EE, -
,EE- .
	positionsFF 
[FF 
indicesFF %
[FF% &
iFF& '
+FF( )
$numFF* +
]FF+ ,
]FF, -
)FF- .
;FF. /
ifHH 
(HH 
areaHH 
<=HH 
MathfHH !
.HH! "
EpsilonHH" )
)HH) *
returnII 
trueII 
;II  
}JJ 
returnLL 
falseLL 
;LL 
}MM 	
publicUU 
staticUU 
boolUU *
ContainsNonContiguousTrianglesUU 9
(UU9 :
thisUU: >
ProBuilderMeshUU? M
meshUUN R
,UUR S
FaceUUT X
faceUUY ]
)UU] ^
{VV 	
EdgeWW 
currentWW 
=WW 
faceWW 
.WW  
edgesInternalWW  -
[WW- .
$numWW. /
]WW/ 0
,WW0 1
startWW2 7
=WW8 9
currentWW: A
;WWA B
intXX 
indexXX 
=XX 
currentXX 
.XX  
aXX  !
;XX! "
intYY 
countYY 
=YY 
$numYY 
;YY 
while[[ 
([[ 
face[[ 
.[[ 
TryGetNextEdge[[ &
([[& '
current[[' .
,[[. /
current[[0 7
.[[7 8
b[[8 9
,[[9 :
ref[[; >
current[[? F
,[[F G
ref[[H K
index[[L Q
)[[Q R
&&\\ 
current\\ 
!=\\ 
start\\ #
&&]] 
count]] 
<]] 
face]] 
.]]  
edgesInternal]]  -
.]]- .
Length]]. 4
)]]4 5
{^^ 
count__ 
++__ 
;__ 
}`` 
returnbb 
countbb 
!=bb 
facebb  
.bb  !
edgesInternalbb! .
.bb. /
Lengthbb/ 5
;bb5 6
}cc 	
publicpp 
staticpp 
Listpp 
<pp 
Facepp 
>pp  7
+EnsureFacesAreComposedOfContiguousTrianglespp! L
(ppL M
thisppM Q
ProBuilderMeshppR `
meshppa e
,ppe f
IEnumerableppg r
<ppr s
Facepps w
>ppw x
facesppy ~
)pp~ 
{qq 	
varrr 
appendedrr 
=rr 
newrr 
Listrr #
<rr# $
Facerr$ (
>rr( )
(rr) *
)rr* +
;rr+ ,
foreachtt 
(tt 
vartt 
facett 
intt  
facestt! &
)tt& '
{uu 
ifvv 
(vv *
ContainsNonContiguousTrianglesvv 2
(vv2 3
meshvv3 7
,vv7 8
facevv9 =
)vv= >
)vv> ?
{ww 
varxx 
groupsxx 
=xx  
CollectFaceGroupsxx! 2
(xx2 3
meshxx3 7
,xx7 8
facexx9 =
)xx= >
;xx> ?
ifzz 
(zz 
groupszz 
.zz 
Countzz $
(zz$ %
)zz% &
<zz' (
$numzz) *
)zz* +
continue{{  
;{{  !
face}} 
.}} 

SetIndexes}} #
(}}# $
groups}}$ *
[}}* +
$num}}+ ,
]}}, -
.}}- .

SelectMany}}. 8
(}}8 9
x}}9 :
=>}}: <
x}}< =
.}}= >
indices}}> E
)}}E F
)}}F G
;}}G H
for 
( 
int 
i 
=  
$num! "
;" #
i$ %
<& '
groups( .
.. /
Count/ 4
;4 5
i6 7
++7 9
)9 :
{
€€ 
var
 
	duplicate
 %
=
& '
new
( +
Face
, 0
(
0 1
face
1 5
)
5 6
;
6 7
	duplicate
‚‚ !
.
‚‚! "

SetIndexes
‚‚" ,
(
‚‚, -
groups
‚‚- 3
[
‚‚3 4
i
‚‚4 5
]
‚‚5 6
.
‚‚6 7

SelectMany
‚‚7 A
(
‚‚A B
x
‚‚B C
=>
‚‚D F
x
‚‚G H
.
‚‚H I
indices
‚‚I P
)
‚‚P Q
)
‚‚Q R
;
‚‚R S
appended
ƒƒ  
.
ƒƒ  !
Add
ƒƒ! $
(
ƒƒ$ %
	duplicate
ƒƒ% .
)
ƒƒ. /
;
ƒƒ/ 0
}
„„ 
}
…… 
}
†† 
var
ˆˆ 
rebuilt
ˆˆ 
=
ˆˆ 
new
ˆˆ 
List
ˆˆ "
<
ˆˆ" #
Face
ˆˆ# '
>
ˆˆ' (
(
ˆˆ( )
mesh
ˆˆ) -
.
ˆˆ- .
facesInternal
ˆˆ. ;
)
ˆˆ; <
;
ˆˆ< =
rebuilt
ŠŠ 
.
ŠŠ 
AddRange
ŠŠ 
(
ŠŠ 
appended
ŠŠ %
)
ŠŠ% &
;
ŠŠ& '
mesh
ŒŒ 
.
ŒŒ 
faces
ŒŒ 
=
ŒŒ 
rebuilt
ŒŒ  
;
ŒŒ  !
return
 
appended
 
;
 
}
 	
internal
‘‘ 
static
‘‘ 
List
‘‘ 
<
‘‘ 
List
‘‘ !
<
‘‘! "
Triangle
‘‘" *
>
‘‘* +
>
‘‘+ ,
CollectFaceGroups
‘‘- >
(
‘‘> ?
this
‘‘? C
ProBuilderMesh
‘‘D R
mesh
‘‘S W
,
‘‘W X
Face
‘‘Y ]
face
‘‘^ b
)
‘‘b c
{
’’ 	
var
““ 
groups
““ 
=
““ 
new
““ 
List
““ !
<
““! "
List
““" &
<
““& '
Triangle
““' /
>
““/ 0
>
““0 1
(
““1 2
)
““2 3
;
““3 4
var
”” 
indices
”” 
=
”” 
face
”” 
.
”” 
indexesInternal
”” .
;
””. /
for
–– 
(
–– 
int
–– 
i
–– 
=
–– 
$num
–– 
;
–– 
i
–– 
<
–– 
indices
––  '
.
––' (
Length
––( .
;
––. /
i
––0 1
+=
––2 4
$num
––5 6
)
––6 7
{
—— 
var
˜˜ 
triangle
˜˜ 
=
˜˜ 
new
˜˜ "
Triangle
˜˜# +
(
˜˜+ ,
indices
˜˜, 3
[
˜˜3 4
i
˜˜4 5
]
˜˜5 6
,
˜˜6 7
indices
˜˜8 ?
[
˜˜? @
i
˜˜@ A
+
˜˜A B
$num
˜˜B C
]
˜˜C D
,
˜˜D E
indices
˜˜F M
[
˜˜M N
i
˜˜N O
+
˜˜O P
$num
˜˜P Q
]
˜˜Q R
)
˜˜R S
;
˜˜S T
var
™™ 
matched
™™ 
=
™™ 
false
™™ #
;
™™# $
for
›› 
(
›› 
int
›› 
n
›› 
=
›› 
$num
›› 
;
›› 
n
››  
<
››! "
groups
››# )
.
››) *
Count
››* /
;
››/ 0
n
››1 2
++
››2 4
)
››4 5
{
œœ 
if
 
(
 
groups
 
[
 
n
  
]
  !
.
! "
Any
" %
(
% &
x
& '
=>
( *
x
+ ,
.
, -

IsAdjacent
- 7
(
7 8
triangle
8 @
)
@ A
)
A B
)
B C
{
ŸŸ 
groups
   
[
   
n
    
]
    !
.
  ! "
Add
  " %
(
  % &
triangle
  & .
)
  . /
;
  / 0
matched
¡¡ 
=
¡¡  !
true
¡¡" &
;
¡¡& '
break
¢¢ 
;
¢¢ 
}
££ 
}
¤¤ 
if
¦¦ 
(
¦¦ 
!
¦¦ 
matched
¦¦ 
)
¦¦ 
groups
§§ 
.
§§ 
Add
§§ 
(
§§ 
new
§§ "
List
§§# '
<
§§' (
Triangle
§§( 0
>
§§0 1
(
§§1 2
)
§§2 3
{
§§4 5
triangle
§§6 >
}
§§? @
)
§§@ A
;
§§A B
}
¨¨ 
return
ªª 
groups
ªª 
;
ªª 
}
«« 	
public
µµ 
static
µµ 
bool
µµ '
RemoveDegenerateTriangles
µµ 4
(
µµ4 5
ProBuilderMesh
µµ5 C
mesh
µµD H
,
µµH I
List
µµJ N
<
µµN O
int
µµO R
>
µµR S
removed
µµT [
=
µµ\ ]
null
µµ^ b
)
µµb c
{
¶¶ 	
if
·· 
(
·· 
mesh
·· 
==
·· 
null
·· 
)
·· 
throw
¸¸ 
new
¸¸ #
ArgumentNullException
¸¸ /
(
¸¸/ 0
$str
¸¸0 6
)
¸¸6 7
;
¸¸7 8

Dictionary
ºº 
<
ºº 
int
ºº 
,
ºº 
int
ºº 
>
ºº  
m_Lookup
ºº! )
=
ºº* +
mesh
ºº, 0
.
ºº0 1 
sharedVertexLookup
ºº1 C
;
ººC D

Dictionary
»» 
<
»» 
int
»» 
,
»» 
int
»» 
>
»»  

m_LookupUV
»»! +
=
»», -
mesh
»». 2
.
»»2 3!
sharedTextureLookup
»»3 F
;
»»F G
Vector3
¼¼ 
[
¼¼ 
]
¼¼ 
m_Positions
¼¼ !
=
¼¼" #
mesh
¼¼$ (
.
¼¼( )
positionsInternal
¼¼) :
;
¼¼: ;

Dictionary
½½ 
<
½½ 
int
½½ 
,
½½ 
int
½½ 
>
½½  
m_RebuiltLookup
½½! 0
=
½½1 2
new
½½3 6

Dictionary
½½7 A
<
½½A B
int
½½B E
,
½½E F
int
½½G J
>
½½J K
(
½½K L
m_Lookup
½½L T
.
½½T U
Count
½½U Z
)
½½Z [
;
½½[ \

Dictionary
¾¾ 
<
¾¾ 
int
¾¾ 
,
¾¾ 
int
¾¾ 
>
¾¾  
m_RebuiltLookupUV
¾¾! 2
=
¾¾3 4
new
¾¾5 8

Dictionary
¾¾9 C
<
¾¾C D
int
¾¾D G
,
¾¾G H
int
¾¾I L
>
¾¾L M
(
¾¾M N

m_LookupUV
¾¾N X
.
¾¾X Y
Count
¾¾Y ^
)
¾¾^ _
;
¾¾_ `
List
¿¿ 
<
¿¿ 
Face
¿¿ 
>
¿¿ 
m_RebuiltFaces
¿¿ %
=
¿¿& '
new
¿¿( +
List
¿¿, 0
<
¿¿0 1
Face
¿¿1 5
>
¿¿5 6
(
¿¿6 7
mesh
¿¿7 ;
.
¿¿; <
	faceCount
¿¿< E
)
¿¿E F
;
¿¿F G

Dictionary
ÀÀ 
<
ÀÀ 
int
ÀÀ 
,
ÀÀ 
int
ÀÀ 
>
ÀÀ  $
m_DuplicateIndexFilter
ÀÀ! 7
=
ÀÀ8 9
new
ÀÀ: =

Dictionary
ÀÀ> H
<
ÀÀH I
int
ÀÀI L
,
ÀÀL M
int
ÀÀN Q
>
ÀÀQ R
(
ÀÀR S
$num
ÀÀS T
)
ÀÀT U
;
ÀÀU V
foreach
ÂÂ 
(
ÂÂ 
Face
ÂÂ 
face
ÂÂ 
in
ÂÂ !
mesh
ÂÂ" &
.
ÂÂ& '
facesInternal
ÂÂ' 4
)
ÂÂ4 5
{
ÃÃ $
m_DuplicateIndexFilter
ÄÄ &
.
ÄÄ& '
Clear
ÄÄ' ,
(
ÄÄ, -
)
ÄÄ- .
;
ÄÄ. /
List
ÅÅ 
<
ÅÅ 
int
ÅÅ 
>
ÅÅ 
tris
ÅÅ 
=
ÅÅ  
new
ÅÅ! $
List
ÅÅ% )
<
ÅÅ) *
int
ÅÅ* -
>
ÅÅ- .
(
ÅÅ. /
)
ÅÅ/ 0
;
ÅÅ0 1
int
ÆÆ 
[
ÆÆ 
]
ÆÆ 
ind
ÆÆ 
=
ÆÆ 
face
ÆÆ  
.
ÆÆ  !
indexesInternal
ÆÆ! 0
;
ÆÆ0 1
for
ÈÈ 
(
ÈÈ 
int
ÈÈ 
i
ÈÈ 
=
ÈÈ 
$num
ÈÈ 
;
ÈÈ 
i
ÈÈ  !
<
ÈÈ" #
ind
ÈÈ$ '
.
ÈÈ' (
Length
ÈÈ( .
;
ÈÈ. /
i
ÈÈ0 1
+=
ÈÈ2 4
$num
ÈÈ5 6
)
ÈÈ6 7
{
ÉÉ 
float
ÊÊ 
area
ÊÊ 
=
ÊÊ  
Math
ÊÊ! %
.
ÊÊ% &
TriangleArea
ÊÊ& 2
(
ÊÊ2 3
m_Positions
ÊÊ3 >
[
ÊÊ> ?
ind
ÊÊ? B
[
ÊÊB C
i
ÊÊC D
+
ÊÊE F
$num
ÊÊG H
]
ÊÊH I
]
ÊÊI J
,
ÊÊJ K
m_Positions
ÊÊL W
[
ÊÊW X
ind
ÊÊX [
[
ÊÊ[ \
i
ÊÊ\ ]
+
ÊÊ^ _
$num
ÊÊ` a
]
ÊÊa b
]
ÊÊb c
,
ÊÊc d
m_Positions
ÊÊe p
[
ÊÊp q
ind
ÊÊq t
[
ÊÊt u
i
ÊÊu v
+
ÊÊw x
$num
ÊÊy z
]
ÊÊz {
]
ÊÊ{ |
)
ÊÊ| }
;
ÊÊ} ~
if
ÌÌ 
(
ÌÌ 
area
ÌÌ 
>
ÌÌ 
Mathf
ÌÌ $
.
ÌÌ$ %
Epsilon
ÌÌ% ,
)
ÌÌ, -
{
ÍÍ 
int
ÏÏ 
triangleIndexA
ÏÏ *
=
ÏÏ+ ,
ind
ÏÏ- 0
[
ÏÏ0 1
i
ÏÏ1 2
]
ÏÏ2 3
,
ÏÏ3 4
triangleIndexB
ĞĞ *
=
ĞĞ+ ,
ind
ĞĞ- 0
[
ĞĞ0 1
i
ĞĞ1 2
+
ĞĞ2 3
$num
ĞĞ3 4
]
ĞĞ4 5
,
ĞĞ5 6
triangleIndexC
ÑÑ *
=
ÑÑ+ ,
ind
ÑÑ- 0
[
ÑÑ0 1
i
ÑÑ1 2
+
ÑÑ2 3
$num
ÑÑ3 4
]
ÑÑ4 5
;
ÑÑ5 6
int
ÔÔ 
sharedIndexA
ÔÔ (
=
ÔÔ) *
m_Lookup
ÔÔ+ 3
[
ÔÔ3 4
triangleIndexA
ÔÔ4 B
]
ÔÔB C
,
ÔÔC D
sharedIndexB
ÕÕ (
=
ÕÕ) *
m_Lookup
ÕÕ+ 3
[
ÕÕ3 4
triangleIndexB
ÕÕ4 B
]
ÕÕB C
,
ÕÕC D
sharedIndexC
ÖÖ (
=
ÖÖ) *
m_Lookup
ÖÖ+ 3
[
ÖÖ3 4
triangleIndexC
ÖÖ4 B
]
ÖÖB C
;
ÖÖC D
if
ÙÙ 
(
ÙÙ 
!
ÙÙ 
(
ÙÙ 
sharedIndexA
ÙÙ *
==
ÙÙ+ -
sharedIndexB
ÙÙ. :
||
ÙÙ; =
sharedIndexA
ÙÙ> J
==
ÙÙK M
sharedIndexC
ÙÙN Z
||
ÙÙ[ ]
sharedIndexB
ÙÙ^ j
==
ÙÙk m
sharedIndexC
ÙÙn z
)
ÙÙz {
)
ÙÙ{ |
{
ÚÚ 
int
ÛÛ 
index
ÛÛ  %
;
ÛÛ% &
if
ŞŞ 
(
ŞŞ  
!
ŞŞ  !$
m_DuplicateIndexFilter
ŞŞ! 7
.
ŞŞ7 8
TryGetValue
ŞŞ8 C
(
ŞŞC D
sharedIndexA
ŞŞD P
,
ŞŞP Q
out
ŞŞR U
index
ŞŞV [
)
ŞŞ[ \
)
ŞŞ\ ]$
m_DuplicateIndexFilter
ßß  6
.
ßß6 7
Add
ßß7 :
(
ßß: ;
sharedIndexA
ßß; G
,
ßßG H
triangleIndexA
ßßI W
)
ßßW X
;
ßßX Y
else
àà  
triangleIndexA
áá  .
=
áá/ 0
index
áá1 6
;
áá6 7
if
ãã 
(
ãã  
!
ãã  !$
m_DuplicateIndexFilter
ãã! 7
.
ãã7 8
TryGetValue
ãã8 C
(
ããC D
sharedIndexB
ããD P
,
ããP Q
out
ããR U
index
ããV [
)
ãã[ \
)
ãã\ ]$
m_DuplicateIndexFilter
ää  6
.
ää6 7
Add
ää7 :
(
ää: ;
sharedIndexB
ää; G
,
ääG H
triangleIndexB
ääI W
)
ääW X
;
ääX Y
else
åå  
triangleIndexB
ææ  .
=
ææ/ 0
index
ææ1 6
;
ææ6 7
if
èè 
(
èè  
!
èè  !$
m_DuplicateIndexFilter
èè! 7
.
èè7 8
TryGetValue
èè8 C
(
èèC D
sharedIndexC
èèD P
,
èèP Q
out
èèR U
index
èèV [
)
èè[ \
)
èè\ ]$
m_DuplicateIndexFilter
éé  6
.
éé6 7
Add
éé7 :
(
éé: ;
sharedIndexC
éé; G
,
ééG H
triangleIndexC
ééI W
)
ééW X
;
ééX Y
else
êê  
triangleIndexC
ëë  .
=
ëë/ 0
index
ëë1 6
;
ëë6 7
tris
íí  
.
íí  !
Add
íí! $
(
íí$ %
triangleIndexA
íí% 3
)
íí3 4
;
íí4 5
tris
îî  
.
îî  !
Add
îî! $
(
îî$ %
triangleIndexB
îî% 3
)
îî3 4
;
îî4 5
tris
ïï  
.
ïï  !
Add
ïï! $
(
ïï$ %
triangleIndexC
ïï% 3
)
ïï3 4
;
ïï4 5
if
ññ 
(
ññ  
!
ññ  !
m_RebuiltLookup
ññ! 0
.
ññ0 1
ContainsKey
ññ1 <
(
ññ< =
triangleIndexA
ññ= K
)
ññK L
)
ññL M
m_RebuiltLookup
òò  /
.
òò/ 0
Add
òò0 3
(
òò3 4
triangleIndexA
òò4 B
,
òòB C
sharedIndexA
òòD P
)
òòP Q
;
òòQ R
if
óó 
(
óó  
!
óó  !
m_RebuiltLookup
óó! 0
.
óó0 1
ContainsKey
óó1 <
(
óó< =
triangleIndexB
óó= K
)
óóK L
)
óóL M
m_RebuiltLookup
ôô  /
.
ôô/ 0
Add
ôô0 3
(
ôô3 4
triangleIndexB
ôô4 B
,
ôôB C
sharedIndexB
ôôD P
)
ôôP Q
;
ôôQ R
if
õõ 
(
õõ  
!
õõ  !
m_RebuiltLookup
õõ! 0
.
õõ0 1
ContainsKey
õõ1 <
(
õõ< =
triangleIndexC
õõ= K
)
õõK L
)
õõL M
m_RebuiltLookup
öö  /
.
öö/ 0
Add
öö0 3
(
öö3 4
triangleIndexC
öö4 B
,
ööB C
sharedIndexC
ööD P
)
ööP Q
;
ööQ R
if
øø 
(
øø  

m_LookupUV
øø  *
.
øø* +
ContainsKey
øø+ 6
(
øø6 7
triangleIndexA
øø7 E
)
øøE F
&&
øøG I
!
øøJ K
m_RebuiltLookupUV
øøK \
.
øø\ ]
ContainsKey
øø] h
(
øøh i
triangleIndexA
øøi w
)
øøw x
)
øøx y
m_RebuiltLookupUV
ùù  1
.
ùù1 2
Add
ùù2 5
(
ùù5 6
triangleIndexA
ùù6 D
,
ùùD E

m_LookupUV
ùùF P
[
ùùP Q
triangleIndexA
ùùQ _
]
ùù_ `
)
ùù` a
;
ùùa b
if
úú 
(
úú  

m_LookupUV
úú  *
.
úú* +
ContainsKey
úú+ 6
(
úú6 7
triangleIndexB
úú7 E
)
úúE F
&&
úúG I
!
úúJ K
m_RebuiltLookupUV
úúK \
.
úú\ ]
ContainsKey
úú] h
(
úúh i
triangleIndexB
úúi w
)
úúw x
)
úúx y
m_RebuiltLookupUV
ûû  1
.
ûû1 2
Add
ûû2 5
(
ûû5 6
triangleIndexB
ûû6 D
,
ûûD E

m_LookupUV
ûûF P
[
ûûP Q
triangleIndexB
ûûQ _
]
ûû_ `
)
ûû` a
;
ûûa b
if
üü 
(
üü  

m_LookupUV
üü  *
.
üü* +
ContainsKey
üü+ 6
(
üü6 7
triangleIndexC
üü7 E
)
üüE F
&&
üüG I
!
üüJ K
m_RebuiltLookupUV
üüK \
.
üü\ ]
ContainsKey
üü] h
(
üüh i
triangleIndexC
üüi w
)
üüw x
)
üüx y
m_RebuiltLookupUV
ıı  1
.
ıı1 2
Add
ıı2 5
(
ıı5 6
triangleIndexC
ıı6 D
,
ııD E

m_LookupUV
ııF P
[
ııP Q
triangleIndexC
ııQ _
]
ıı_ `
)
ıı` a
;
ııa b
}
şş 
}
ÿÿ 
}
€€ 
if
‚‚ 
(
‚‚ 
tris
‚‚ 
.
‚‚ 
Count
‚‚ 
>
‚‚  
$num
‚‚! "
)
‚‚" #
{
ƒƒ 
face
„„ 
.
„„ 
indexesInternal
„„ (
=
„„) *
tris
„„+ /
.
„„/ 0
ToArray
„„0 7
(
„„7 8
)
„„8 9
;
„„9 :
m_RebuiltFaces
…… "
.
……" #
Add
……# &
(
……& '
face
……' +
)
……+ ,
;
……, -
}
†† 
}
‡‡ 
mesh
‰‰ 
.
‰‰ 
faces
‰‰ 
=
‰‰ 
m_RebuiltFaces
‰‰ '
;
‰‰' (
mesh
ŠŠ 
.
ŠŠ 
SetSharedVertices
ŠŠ "
(
ŠŠ" #
m_RebuiltLookup
ŠŠ# 2
)
ŠŠ2 3
;
ŠŠ3 4
mesh
‹‹ 
.
‹‹ 
SetSharedTextures
‹‹ "
(
‹‹" #
m_RebuiltLookupUV
‹‹# 4
)
‹‹4 5
;
‹‹5 6
return
 "
RemoveUnusedVertices
 '
(
' (
mesh
( ,
,
, -
removed
. 5
)
5 6
;
6 7
}
 	
public
–– 
static
–– 
bool
–– "
RemoveUnusedVertices
–– /
(
––/ 0
ProBuilderMesh
––0 >
mesh
––? C
,
––C D
List
––E I
<
––I J
int
––J M
>
––M N
removed
––O V
=
––W X
null
––Y ]
)
––] ^
{
—— 	
if
˜˜ 
(
˜˜ 
mesh
˜˜ 
==
˜˜ 
null
˜˜ 
)
˜˜ 
throw
™™ 
new
™™ #
ArgumentNullException
™™ /
(
™™/ 0
$str
™™0 6
)
™™6 7
;
™™7 8
bool
›› 
saveRemoved
›› 
=
›› 
removed
›› &
!=
››' )
null
››* .
;
››. /
if
 
(
 
saveRemoved
 
)
 
removed
 
.
 
Clear
 
(
 
)
 
;
  
var
   
del
   
=
   
saveRemoved
   !
?
  " #
removed
  $ +
:
  , -
new
  . 1
List
  2 6
<
  6 7
int
  7 :
>
  : ;
(
  ; <
)
  < =
;
  = >
var
¢¢ 
tris
¢¢ 
=
¢¢ 
new
¢¢ 
HashSet
¢¢ "
<
¢¢" #
int
¢¢# &
>
¢¢& '
(
¢¢' (
mesh
¢¢( ,
.
¢¢, -
facesInternal
¢¢- :
.
¢¢: ;

SelectMany
¢¢; E
(
¢¢E F
x
¢¢F G
=>
¢¢H J
x
¢¢K L
.
¢¢L M
indexes
¢¢M T
)
¢¢T U
)
¢¢U V
;
¢¢V W
for
¤¤ 
(
¤¤ 
int
¤¤ 
i
¤¤ 
=
¤¤ 
$num
¤¤ 
;
¤¤ 
i
¤¤ 
<
¤¤ 
mesh
¤¤  $
.
¤¤$ %
positionsInternal
¤¤% 6
.
¤¤6 7
Length
¤¤7 =
;
¤¤= >
i
¤¤? @
++
¤¤@ B
)
¤¤B C
if
¥¥ 
(
¥¥ 
!
¥¥ 
tris
¥¥ 
.
¥¥ 
Contains
¥¥ "
(
¥¥" #
i
¥¥# $
)
¥¥$ %
)
¥¥% &
del
¦¦ 
.
¦¦ 
Add
¦¦ 
(
¦¦ 
i
¦¦ 
)
¦¦ 
;
¦¦ 
mesh
¨¨ 
.
¨¨ 
DeleteVertices
¨¨ 
(
¨¨  
del
¨¨  #
)
¨¨# $
;
¨¨$ %
return
ªª 
del
ªª 
.
ªª 
Any
ªª 
(
ªª 
)
ªª 
;
ªª 
}
«« 	
internal
³³ 
static
³³ 
List
³³ 
<
³³ 
int
³³  
>
³³  !
RebuildIndexes
³³" 0
(
³³0 1
IEnumerable
³³1 <
<
³³< =
int
³³= @
>
³³@ A
indices
³³B I
,
³³I J
List
³³K O
<
³³O P
int
³³P S
>
³³S T
removed
³³U \
)
³³\ ]
{
´´ 	
var
µµ 
res
µµ 
=
µµ 
new
µµ 
List
µµ 
<
µµ 
int
µµ "
>
µµ" #
(
µµ# $
)
µµ$ %
;
µµ% &
var
¶¶ 
rmc
¶¶ 
=
¶¶ 
removed
¶¶ 
.
¶¶ 
Count
¶¶ #
;
¶¶# $
foreach
¸¸ 
(
¸¸ 
var
¸¸ 
index
¸¸ 
in
¸¸ !
indices
¸¸" )
)
¸¸) *
{
¹¹ 
var
ºº 
nearestIndex
ºº  
=
ºº! "
ArrayUtility
ºº# /
.
ºº/ 0&
NearestIndexPriorToValue
ºº0 H
(
ººH I
removed
ººI P
,
ººP Q
index
ººR W
)
ººW X
+
ººY Z
$num
ºº[ \
;
ºº\ ]
if
½½ 
(
½½ 
nearestIndex
½½  
>
½½! "
-
½½# $
$num
½½$ %
&&
½½& (
nearestIndex
½½) 5
<
½½6 7
rmc
½½8 ;
&&
½½< >
removed
½½? F
[
½½F G
nearestIndex
½½G S
]
½½S T
==
½½U W
index
½½X ]
)
½½] ^
continue
¾¾ 
;
¾¾ 
res
ÀÀ 
.
ÀÀ 
Add
ÀÀ 
(
ÀÀ 
index
ÀÀ 
-
ÀÀ 
nearestIndex
ÀÀ  ,
)
ÀÀ, -
;
ÀÀ- .
}
ÁÁ 
return
ÃÃ 
res
ÃÃ 
;
ÃÃ 
}
ÄÄ 	
internal
ÌÌ 
static
ÌÌ 
List
ÌÌ 
<
ÌÌ 
Edge
ÌÌ !
>
ÌÌ! "
RebuildEdges
ÌÌ# /
(
ÌÌ/ 0
IEnumerable
ÌÌ0 ;
<
ÌÌ; <
Edge
ÌÌ< @
>
ÌÌ@ A
edges
ÌÌB G
,
ÌÌG H
List
ÌÌI M
<
ÌÌM N
int
ÌÌN Q
>
ÌÌQ R
removed
ÌÌS Z
)
ÌÌZ [
{
ÍÍ 	
var
ÎÎ 
res
ÎÎ 
=
ÎÎ 
new
ÎÎ 
List
ÎÎ 
<
ÎÎ 
Edge
ÎÎ #
>
ÎÎ# $
(
ÎÎ$ %
)
ÎÎ% &
;
ÎÎ& '
var
ÏÏ 
rmc
ÏÏ 
=
ÏÏ 
removed
ÏÏ 
.
ÏÏ 
Count
ÏÏ #
;
ÏÏ# $
foreach
ÑÑ 
(
ÑÑ 
var
ÑÑ 
edge
ÑÑ 
in
ÑÑ  
edges
ÑÑ! &
)
ÑÑ& '
{
ÒÒ 
var
ÓÓ 
nearestIndexA
ÓÓ !
=
ÓÓ" #
ArrayUtility
ÓÓ$ 0
.
ÓÓ0 1&
NearestIndexPriorToValue
ÓÓ1 I
(
ÓÓI J
removed
ÓÓJ Q
,
ÓÓQ R
edge
ÓÓS W
.
ÓÓW X
a
ÓÓX Y
)
ÓÓY Z
+
ÓÓ[ \
$num
ÓÓ] ^
;
ÓÓ^ _
var
ÔÔ 
nearestIndexB
ÔÔ !
=
ÔÔ" #
ArrayUtility
ÔÔ$ 0
.
ÔÔ0 1&
NearestIndexPriorToValue
ÔÔ1 I
(
ÔÔI J
removed
ÔÔJ Q
,
ÔÔQ R
edge
ÔÔS W
.
ÔÔW X
b
ÔÔX Y
)
ÔÔY Z
+
ÔÔ[ \
$num
ÔÔ] ^
;
ÔÔ^ _
if
×× 
(
×× 
(
×× 
nearestIndexA
×× "
>
××# $
-
××% &
$num
××& '
&&
××( *
nearestIndexA
××+ 8
<
××9 :
rmc
××; >
&&
××? A
removed
××B I
[
××I J
nearestIndexA
××J W
]
××W X
==
××Y [
edge
××\ `
.
××` a
a
××a b
)
××b c
||
××d f
(
ØØ 
nearestIndexB
ØØ "
>
ØØ# $
-
ØØ% &
$num
ØØ& '
&&
ØØ( *
nearestIndexB
ØØ+ 8
<
ØØ9 :
rmc
ØØ; >
&&
ØØ? A
removed
ØØB I
[
ØØI J
nearestIndexB
ØØJ W
]
ØØW X
==
ØØY [
edge
ØØ\ `
.
ØØ` a
b
ØØa b
)
ØØb c
)
ØØc d
continue
ÙÙ 
;
ÙÙ 
res
ÛÛ 
.
ÛÛ 
Add
ÛÛ 
(
ÛÛ 
new
ÛÛ 
Edge
ÛÛ  
(
ÛÛ  !
edge
ÛÛ! %
.
ÛÛ% &
a
ÛÛ& '
-
ÛÛ( )
nearestIndexA
ÛÛ* 7
,
ÛÛ7 8
edge
ÛÛ9 =
.
ÛÛ= >
b
ÛÛ> ?
-
ÛÛ@ A
nearestIndexB
ÛÛB O
)
ÛÛO P
)
ÛÛP Q
;
ÛÛQ R
}
ÜÜ 
return
ŞŞ 
res
ŞŞ 
;
ŞŞ 
}
ßß 	
internal
áá 
static
áá 
void
áá %
RebuildSelectionIndexes
áá 4
(
áá4 5
ProBuilderMesh
áá5 C
mesh
ááD H
,
ááH I
ref
ááJ M
Face
ááN R
[
ááR S
]
ááS T
faces
ááU Z
,
ááZ [
ref
áá\ _
Edge
áá` d
[
áád e
]
ááe f
edges
áág l
,
áál m
ref
áán q
int
áár u
[
ááu v
]
ááv w
indices
ááx 
,áá €
IEnumerableáá Œ
<ááŒ 
intáá 
>áá ‘
removedáá’ ™
)áá™ š
{
ââ 	
var
ãã 
rm
ãã 
=
ãã 
removed
ãã 
.
ãã 
ToList
ãã #
(
ãã# $
)
ãã$ %
;
ãã% &
rm
ää 
.
ää 
Sort
ää 
(
ää 
)
ää 
;
ää 
if
ææ 
(
ææ 
faces
ææ 
!=
ææ 
null
ææ 
&&
ææ  
faces
ææ! &
.
ææ& '
Length
ææ' -
>
ææ. /
$num
ææ0 1
)
ææ1 2
faces
çç 
=
çç 
faces
çç 
.
çç 
Where
çç #
(
çç# $
x
çç$ %
=>
çç& (
mesh
çç) -
.
çç- .
facesInternal
çç. ;
.
çç; <
Contains
çç< D
(
ççD E
x
ççE F
)
ççF G
)
ççG H
.
ççH I
ToArray
ççI P
(
ççP Q
)
ççQ R
;
ççR S
if
éé 
(
éé 
edges
éé 
!=
éé 
null
éé 
&&
éé 
edges
éé  %
.
éé% &
Length
éé& ,
>
éé- .
$num
éé/ 0
)
éé0 1
edges
êê 
=
êê 
RebuildEdges
êê $
(
êê$ %
edges
êê% *
,
êê* +
rm
êê, .
)
êê. /
.
êê/ 0
ToArray
êê0 7
(
êê7 8
)
êê8 9
;
êê9 :
if
ìì 
(
ìì 
indices
ìì 
!=
ìì 
null
ìì 
&&
ìì !
indices
ìì" )
.
ìì) *
Length
ìì* 0
>
ìì1 2
$num
ìì3 4
)
ìì4 5
indices
íí 
=
íí 
RebuildIndexes
íí (
(
íí( )
indices
íí) 0
,
íí0 1
rm
íí2 4
)
íí4 5
.
íí5 6
ToArray
íí6 =
(
íí= >
)
íí> ?
;
íí? @
}
îî 	
internal
öö 
static
öö 
bool
öö 
EnsureMeshIsValid
öö .
(
öö. /
ProBuilderMesh
öö/ =
mesh
öö> B
,
ööB C
out
ööD G
int
ööH K
removedVertices
ööL [
)
öö[ \
{
÷÷ 	
removedVertices
øø 
=
øø 
$num
øø 
;
øø  
if
úú 
(
úú )
ContainsDegenerateTriangles
úú +
(
úú+ ,
mesh
úú, 0
)
úú0 1
)
úú1 2
{
ûû 
var
üü 
faces
üü 
=
üü 
mesh
üü  
.
üü  !#
selectedFacesInternal
üü! 6
;
üü6 7
var
ıı 
edges
ıı 
=
ıı 
mesh
ıı  
.
ıı  !#
selectedEdgesInternal
ıı! 6
;
ıı6 7
var
şş 
indices
şş 
=
şş 
mesh
şş "
.
şş" #%
selectedIndexesInternal
şş# :
;
şş: ;
List
€€ 
<
€€ 
int
€€ 
>
€€ 
removed
€€ !
=
€€" #
new
€€$ '
List
€€( ,
<
€€, -
int
€€- 0
>
€€0 1
(
€€1 2
)
€€2 3
;
€€3 4
if
‚‚ 
(
‚‚ '
RemoveDegenerateTriangles
‚‚ -
(
‚‚- .
mesh
‚‚. 2
,
‚‚2 3
removed
‚‚4 ;
)
‚‚; <
)
‚‚< =
{
ƒƒ 
mesh
„„ 
.
„„ 
sharedVertices
„„ '
=
„„( )
SharedVertex
„„* 6
.
„„6 7,
GetSharedVerticesWithPositions
„„7 U
(
„„U V
mesh
„„V Z
.
„„Z [
positionsInternal
„„[ l
)
„„l m
;
„„m n%
RebuildSelectionIndexes
†† +
(
††+ ,
mesh
††, 0
,
††0 1
ref
††2 5
faces
††6 ;
,
††; <
ref
††= @
edges
††A F
,
††F G
ref
††H K
indices
††L S
,
††S T
removed
††U \
)
††\ ]
;
††] ^
mesh
‡‡ 
.
‡‡ #
selectedFacesInternal
‡‡ .
=
‡‡/ 0
faces
‡‡1 6
;
‡‡6 7
mesh
ˆˆ 
.
ˆˆ #
selectedEdgesInternal
ˆˆ .
=
ˆˆ/ 0
edges
ˆˆ1 6
;
ˆˆ6 7
mesh
‰‰ 
.
‰‰ %
selectedIndexesInternal
‰‰ 0
=
‰‰1 2
indices
‰‰3 :
;
‰‰: ;
removedVertices
ŠŠ #
=
ŠŠ$ %
removed
ŠŠ& -
.
ŠŠ- .
Count
ŠŠ. 3
;
ŠŠ3 4
return
‹‹ 
false
‹‹  
;
‹‹  !
}
ŒŒ 
}
 
return
 
true
 
;
 
}
 	
}
‘‘ 
}’’ õ'
‹D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ObjectPool.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed 

class 

ObjectPool 
< 
T 
> 
:  
IDisposable! ,
{ 
bool 
m_IsDisposed 
; 
Queue 
< 
T 
> 
m_Pool 
= 
new 
Queue #
<# $
T$ %
>% &
(& '
)' (
;( )
public 
int 
desiredSize 
; 
public 
Func 
< 
T 
> 
constructor "
;" #
public 
Action 
< 
T 
> 

destructor #
;# $
public 

ObjectPool 
( 
int 
initialSize )
,) *
int+ .
desiredSize/ :
,: ;
Func< @
<@ A
TA B
>B C
constructorD O
,O P
ActionQ W
<W X
TX Y
>Y Z

destructor[ e
,e f
boolg k
lazyInitializationl ~
=	 €
false
 †
)
† ‡
{ 	
if 
( 
constructor 
== 
null #
)# $
throw 
new !
ArgumentNullException /
(/ 0
$str0 =
)= >
;> ?
if 
( 

destructor 
== 
null "
)" #
throw 
new !
ArgumentNullException /
(/ 0
$str0 <
)< =
;= >
this 
. 
constructor 
= 
constructor *
;* +
this 
. 

destructor 
= 

destructor (
;( )
this 
. 
desiredSize 
= 
desiredSize *
;* +
for   
(   
int   
i   
=   
$num   
;   
i   
<   
initialSize    +
&&  , .
i  / 0
<  1 2
desiredSize  3 >
&&  ? A
!  B C
lazyInitialization  C U
;  U V
i  W X
++  X Z
)  Z [
m_Pool!! 
.!! 
Enqueue!! 
(!! 
constructor!! *
(!!* +
)!!+ ,
)!!, -
;!!- .
}"" 	
public$$ 
T$$ 
Dequeue$$ 
($$ 
)$$ 
{%% 	
if&& 
(&& 
m_Pool&& 
.&& 
Count&& 
>&& 
$num&&  
)&&  !
return'' 
m_Pool'' 
.'' 
Dequeue'' %
(''% &
)''& '
;''' (
return(( 
constructor(( 
((( 
)((  
;((  !
})) 	
public++ 
void++ 
Enqueue++ 
(++ 
T++ 
obj++ !
)++! "
{,, 	
if-- 
(-- 
m_Pool-- 
.-- 
Count-- 
<-- 
desiredSize-- *
)--* +
m_Pool.. 
... 
Enqueue.. 
(.. 
obj.. "
).." #
;..# $
else// 

destructor00 
(00 
obj00 
)00 
;00  
}11 	
public33 
void33 
Empty33 
(33 
)33 
{44 	
int55 
count55 
=55 
m_Pool55 
.55 
Count55 $
;55$ %
for77 
(77 
int77 
i77 
=77 
$num77 
;77 
i77 
<77 
count77  %
;77% &
i77' (
++77( *
)77* +

destructor88 
(88 
m_Pool88 !
.88! "
Dequeue88" )
(88) *
)88* +
)88+ ,
;88, -
}99 	
public;; 
void;; 
Dispose;; 
(;; 
);; 
{<< 	
Dispose== 
(== 
true== 
)== 
;== 
}>> 	
void@@ 
Dispose@@ 
(@@ 
bool@@ 
	disposing@@ #
)@@# $
{AA 	
ifBB 
(BB 
	disposingBB 
&&BB 
!BB 
m_IsDisposedBB *
)BB* +
{CC 
EmptyDD 
(DD 
)DD 
;DD 
m_IsDisposedEE 
=EE 
trueEE #
;EE# $
}FF 
}GG 	
}HH 
}II ²3
ŠD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Changelog.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{		 
[

 
Serializable

 
]

 
class 	
ChangelogEntry
 
{ 
[ 	
SerializeField	 
] 
SemVer 
m_VersionInfo 
; 
[ 	
SerializeField	 
] 
string 
m_ReleaseNotes 
; 
public 
SemVer 
versionInfo !
{ 	
get 
{ 
return 
m_VersionInfo &
;& '
}( )
} 	
public 
string 
releaseNotes "
{ 	
get 
{ 
return 
m_ReleaseNotes '
;' (
}) *
} 	
public 
ChangelogEntry 
( 
SemVer $
version% ,
,, -
string. 4
releaseNotes5 A
)A B
{ 	
m_VersionInfo 
= 
version #
;# $
m_ReleaseNotes   
=   
releaseNotes   )
;  ) *
}!! 	
public## 
override## 
string## 
ToString## '
(##' (
)##( )
{$$ 	
return%% 
m_VersionInfo%%  
.%%  !
ToString%%! )
(%%) *
)%%* +
+%%, -
$str%%. 4
+%%5 6
m_ReleaseNotes%%7 E
;%%E F
}&& 	
}'' 
[)) 
Serializable)) 
])) 
class** 	
	Changelog**
 
{++ 
const,, 
string,, #
k_ChangelogEntryPattern,, ,
=,,- .
$str,,/ k
;,,k l
const-- 
string--  
k_VersionInfoPattern-- )
=--* +
$str--, B
;--B C
const.. 
string..  
k_VersionDatePattern.. )
=..* +
$str.., J
;..J K
[00 	
SerializeField00	 
]00 
List11 
<11 
ChangelogEntry11 
>11 
	m_Entries11 &
;11& '
public33 
ReadOnlyCollection33 !
<33! "
ChangelogEntry33" 0
>330 1
entries332 9
{44 	
get55 
{55 
return55 
new55 
ReadOnlyCollection55 /
<55/ 0
ChangelogEntry550 >
>55> ?
(55? @
	m_Entries55@ I
)55I J
;55J K
}55L M
}66 	
public88 
	Changelog88 
(88 
string88 
log88  #
)88# $
{99 	
string:: 
version:: 
=:: 
string:: #
.::# $
Empty::$ )
;::) *
StringBuilder;; 
contents;; "
=;;# $
null;;% )
;;;) *
	m_Entries<< 
=<< 
new<< 
List<<  
<<<  !
ChangelogEntry<<! /
><</ 0
(<<0 1
)<<1 2
;<<2 3
ChangelogEntry== 
entry==  
;==  !
foreach?? 
(?? 
var?? 
line?? 
in??  
log??! $
.??$ %
Split??% *
(??* +
$char??+ /
)??/ 0
)??0 1
{@@ 
ifAA 
(AA 
RegexAA 
.AA 
MatchAA 
(AA  
lineAA  $
,AA$ %#
k_ChangelogEntryPatternAA& =
)AA= >
.AA> ?
SuccessAA? F
)AAF G
{BB 
ifCC 
(CC 
(CC 
entryCC 
=CC  
CreateEntryCC! ,
(CC, -
versionCC- 4
,CC4 5
contentsCC6 >
!=CC? A
nullCCB F
?CCG H
contentsCCI Q
.CCQ R
ToStringCCR Z
(CCZ [
)CC[ \
:CC] ^
$strCC_ a
)CCa b
)CCb c
!=CCd f
nullCCg k
)CCk l
	m_EntriesDD !
.DD! "
AddDD" %
(DD% &
entryDD& +
)DD+ ,
;DD, -
versionFF 
=FF 
lineFF "
;FF" #
contentsGG 
=GG 
newGG "
StringBuilderGG# 0
(GG0 1
)GG1 2
;GG2 3
}HH 
elseII 
{JJ 
ifKK 
(KK 
contentsKK  
!=KK! #
nullKK$ (
)KK( )
contentsLL  
.LL  !

AppendLineLL! +
(LL+ ,
lineLL, 0
)LL0 1
;LL1 2
}MM 
}NN 
ifPP 
(PP 
(PP 
entryPP 
=PP 
CreateEntryPP $
(PP$ %
versionPP% ,
,PP, -
contentsPP. 6
.PP6 7
ToStringPP7 ?
(PP? @
)PP@ A
)PPA B
)PPB C
!=PPD F
nullPPG K
)PPK L
	m_EntriesQQ 
.QQ 
AddQQ 
(QQ 
entryQQ #
)QQ# $
;QQ$ %
}RR 	
ChangelogEntryTT 
CreateEntryTT "
(TT" #
stringTT# )
versionTT* 1
,TT1 2
stringTT3 9
contentsTT: B
)TTB C
{UU 	
varVV 
markVV 
=VV 
RegexVV 
.VV 
MatchVV "
(VV" #
versionVV# *
,VV* + 
k_VersionInfoPatternVV, @
)VV@ A
;VVA B
varWW 
dateWW 
=WW 
RegexWW 
.WW 
MatchWW "
(WW" #
versionWW# *
,WW* + 
k_VersionDatePatternWW, @
)WW@ A
;WWA B
ifYY 
(YY 
markYY 
.YY 
SuccessYY 
)YY 
returnZZ 
newZZ 
ChangelogEntryZZ )
(ZZ) *
newZZ* -
SemVerZZ. 4
(ZZ4 5
markZZ5 9
.ZZ9 :
ValueZZ: ?
,ZZ? @
dateZZA E
.ZZE F
ValueZZF K
)ZZK L
,ZZL M
contentsZZN V
.ZZV W
TrimZZW [
(ZZ[ \
)ZZ\ ]
)ZZ] ^
;ZZ^ _
return\\ 
null\\ 
;\\ 
}]] 	
}^^ 
}__ Ê'
“D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\HandleConstraint2D.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed		 

class		 
HandleConstraint2D		 #
{

 
public 
int 
x 
, 
y 
; 
public 
HandleConstraint2D !
(! "
int" %
x& '
,' (
int) ,
y- .
). /
{ 	
this 
. 
x 
= 
x 
; 
this 
. 
y 
= 
y 
; 
} 	
public 
HandleConstraint2D !
Inverse" )
() *
)* +
{ 	
return 
new 
HandleConstraint2D )
() *
x* +
==, .
$num/ 0
?1 2
$num3 4
:5 6
$num7 8
,8 9
y: ;
==< >
$num? @
?A B
$numC D
:E F
$numG H
)H I
;I J
} 	
public 
Vector2 
Mask 
( 
Vector2 #
v$ %
)% &
{ 	
v 
. 
x 
*= 
this 
. 
x 
; 
v 
. 
y 
*= 
this 
. 
y 
; 
return 
v 
; 
} 	
public 
Vector2 
InverseMask "
(" #
Vector2# *
v+ ,
), -
{   	
v!! 
.!! 
x!! 
*=!! 
this!! 
.!! 
x!! 
==!! 
$num!! 
?!!  
$num!!! #
:!!$ %
$num!!& (
;!!( )
v"" 
."" 
y"" 
*="" 
this"" 
."" 
y"" 
=="" 
$num"" 
?""  
$num""! #
:""$ %
$num""& (
;""( )
return## 
v## 
;## 
}$$ 	
public&& 
static&& 
readonly&& 
HandleConstraint2D&& 1
None&&2 6
=&&7 8
new&&9 <
HandleConstraint2D&&= O
(&&O P
$num&&P Q
,&&Q R
$num&&S T
)&&T U
;&&U V
public(( 
static(( 
bool(( 
operator(( #
==((# %
(((% &
HandleConstraint2D((& 8
a((9 :
,((: ;
HandleConstraint2D((< N
b((O P
)((P Q
{)) 	
return** 
a** 
.** 
x** 
==** 
b** 
.** 
x** 
&&**  
a**! "
.**" #
y**# $
==**% '
b**( )
.**) *
y*** +
;**+ ,
}++ 	
public-- 
static-- 
bool-- 
operator-- #
!=--# %
(--% &
HandleConstraint2D--& 8
a--9 :
,--: ;
HandleConstraint2D--< N
b--O P
)--P Q
{.. 	
return// 
a// 
.// 
x// 
!=// 
b// 
.// 
x// 
||//  
a//! "
.//" #
y//# $
!=//% '
b//( )
.//) *
y//* +
;//+ ,
}00 	
public22 
override22 
int22 
GetHashCode22 '
(22' (
)22( )
{33 	
return44 
base44 
.44 
GetHashCode44 #
(44# $
)44$ %
;44% &
}55 	
public77 
override77 
bool77 
Equals77 #
(77# $
object77$ *
o77+ ,
)77, -
{88 	
return99 
o99 
is99 
HandleConstraint2D99 *
&&99+ -
(99. /
(99/ 0
HandleConstraint2D990 B
)99B C
o99C D
)99D E
.99E F
x99F G
==99H J
this99K O
.99O P
x99P Q
&&99R T
(99U V
(99V W
HandleConstraint2D99W i
)99i j
o99j k
)99k l
.99l m
y99m n
==99o q
this99r v
.99v w
y99w x
;99x y
}:: 	
public<< 
override<< 
string<< 
ToString<< '
(<<' (
)<<( )
{== 	
return>> 
$str>> 
+>> 
x>> 
+>> 
$str>> !
+>>" #
y>>$ %
+>>& '
$str>>( +
;>>+ ,
}?? 	
}@@ 
}AA Øõ
‡D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SemVer.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ 
Serializable 
] 
sealed 

class 
SemVer 
: 

IEquatable $
<$ %
SemVer% +
>+ ,
,, -
IComparable. 9
<9 :
SemVer: @
>@ A
,A B
IComparableC N
{ 
[ 	
SerializeField	 
] 
int 
m_Major 
= 
- 
$num 
; 
[ 	
SerializeField	 
] 
int 
m_Minor 
= 
- 
$num 
; 
[ 	
SerializeField	 
] 
int 
m_Patch 
= 
- 
$num 
; 
[ 	
SerializeField	 
] 
int 
m_Build 
= 
- 
$num 
; 
[ 	
SerializeField	 
] 
string 
m_Type 
; 
[ 	
SerializeField	 
] 
string 

m_Metadata 
; 
[   	
SerializeField  	 
]   
string!! 
m_Date!! 
;!! 
public## 
int## 
major## 
{## 
get## 
{##  
return##! '
m_Major##( /
;##/ 0
}##1 2
}##3 4
public$$ 
int$$ 
minor$$ 
{$$ 
get$$ 
{$$  
return$$! '
m_Minor$$( /
;$$/ 0
}$$1 2
}$$3 4
public%% 
int%% 
patch%% 
{%% 
get%% 
{%%  
return%%! '
m_Patch%%( /
;%%/ 0
}%%1 2
}%%3 4
public&& 
int&& 
build&& 
{&& 
get&& 
{&&  
return&&! '
m_Build&&( /
;&&/ 0
}&&1 2
}&&3 4
public'' 
string'' 
type'' 
{'' 
get''  
{''! "
return''# )
m_Type''* 0
!=''1 3
null''4 8
?''9 :
m_Type''; A
:''B C
$str''D F
;''F G
}''H I
}''J K
public(( 
string(( 
metadata(( 
{((  
get((! $
{((% &
return((' -

m_Metadata((. 8
!=((9 ;
null((< @
?((A B

m_Metadata((C M
:((N O
$str((P R
;((R S
}((T U
}((V W
public)) 
string)) 
date)) 
{)) 
get))  
{))! "
return))# )
m_Date))* 0
!=))1 3
null))4 8
?))9 :
m_Date)); A
:))B C
$str))D F
;))F G
}))H I
}))J K
public.. 
SemVer.. 
MajorMinorPatch.. %
{// 	
get00 
{00 
return00 
new00 
SemVer00 #
(00# $
major00$ )
,00) *
minor00+ 0
,000 1
patch002 7
)007 8
;008 9
}00: ;
}11 	
public33 
const33 
string33 
DefaultStringFormat33 /
=330 1
$str332 =
;33= >
public55 
SemVer55 
(55 
)55 
{66 	
m_Major77 
=77 
$num77 
;77 
m_Minor88 
=88 
$num88 
;88 
m_Patch99 
=99 
$num99 
;99 
m_Build:: 
=:: 
-:: 
$num:: 
;:: 
m_Type;; 
=;; 
null;; 
;;; 
m_Date<< 
=<< 
null<< 
;<< 

m_Metadata== 
=== 
null== 
;== 
}>> 	
public@@ 
SemVer@@ 
(@@ 
string@@ 
	formatted@@ &
,@@& '
string@@( .
date@@/ 3
=@@4 5
null@@6 :
)@@: ;
{AA 	
SemVerBB 
parsedBB 
;BB 

m_MetadataDD 
=DD 
	formattedDD "
;DD" #
m_DateEE 
=EE 
dateEE 
;EE 
ifGG 
(GG 
TryGetVersionInfoGG !
(GG! "
	formattedGG" +
,GG+ ,
outGG- 0
parsedGG1 7
)GG7 8
)GG8 9
{HH 
m_MajorII 
=II 
parsedII  
.II  !
m_MajorII! (
;II( )
m_MinorJJ 
=JJ 
parsedJJ  
.JJ  !
m_MinorJJ! (
;JJ( )
m_PatchKK 
=KK 
parsedKK  
.KK  !
m_PatchKK! (
;KK( )
m_BuildLL 
=LL 
parsedLL  
.LL  !
m_BuildLL! (
;LL( )
m_TypeMM 
=MM 
parsedMM 
.MM  
m_TypeMM  &
;MM& '

m_MetadataNN 
=NN 
parsedNN #
.NN# $
metadataNN$ ,
;NN, -
}OO 
}VV 	
publicXX 
SemVerXX 
(XX 
intXX 
majorXX 
,XX  
intXX! $
minorXX% *
,XX* +
intXX, /
patchXX0 5
,XX5 6
intXX7 :
buildXX; @
=XXA B
-XXC D
$numXXD E
,XXE F
stringXXG M
typeXXN R
=XXS T
nullXXU Y
,XXY Z
stringXX[ a
dateXXb f
=XXg h
nullXXi m
,XXm n
stringXXo u
metadataXXv ~
=	XX €
null
XX …
)
XX… †
{YY 	
m_MajorZZ 
=ZZ 
majorZZ 
;ZZ 
m_Minor[[ 
=[[ 
minor[[ 
;[[ 
m_Patch\\ 
=\\ 
patch\\ 
;\\ 
m_Build]] 
=]] 
build]] 
;]] 
m_Type^^ 
=^^ 
type^^ 
;^^ 

m_Metadata__ 
=__ 
metadata__ !
;__! "
m_Date`` 
=`` 
date`` 
;`` 
}aa 	
publiccc 
boolcc 
IsValidcc 
(cc 
)cc 
{dd 	
returnee 
majoree 
!=ee 
-ee 
$numee 
&&ee !
minorff 
!=ff 
-ff 
$numff 
&&ff 
patchgg 
!=gg 
-gg 
$numgg 
;gg 
}hh 	
publicjj 
overridejj 
booljj 
Equalsjj #
(jj# $
objectjj$ *
ojj+ ,
)jj, -
{kk 	
returnll 
oll 
isll 
SemVerll 
&&ll !
Equalsll" (
(ll( )
(ll) *
SemVerll* 0
)ll0 1
oll1 2
)ll2 3
;ll3 4
}mm 	
publicoo 
overrideoo 
intoo 
GetHashCodeoo '
(oo' (
)oo( )
{pp 	
intqq 
hashqq 
=qq 
$numqq 
;qq 
	uncheckedss 
{tt 
ifuu 
(uu 
IsValiduu 
(uu 
)uu 
)uu 
{vv 
hashww 
=ww 
(ww 
hashww  
*ww! "
$numww# $
)ww$ %
+ww& '
majorww( -
.ww- .
GetHashCodeww. 9
(ww9 :
)ww: ;
;ww; <
hashxx 
=xx 
(xx 
hashxx  
*xx! "
$numxx# $
)xx$ %
+xx& '
minorxx( -
.xx- .
GetHashCodexx. 9
(xx9 :
)xx: ;
;xx; <
hashyy 
=yy 
(yy 
hashyy  
*yy! "
$numyy# $
)yy$ %
+yy& '
patchyy( -
.yy- .
GetHashCodeyy. 9
(yy9 :
)yy: ;
;yy; <
hashzz 
=zz 
(zz 
hashzz  
*zz! "
$numzz# $
)zz$ %
+zz& '
buildzz( -
.zz- .
GetHashCodezz. 9
(zz9 :
)zz: ;
;zz; <
hash{{ 
={{ 
({{ 
hash{{  
*{{! "
$num{{# $
){{$ %
+{{& '
type{{( ,
.{{, -
GetHashCode{{- 8
({{8 9
){{9 :
;{{: ;
}|| 
else}} 
{~~ 
return 
string !
.! "
IsNullOrEmpty" /
(/ 0
metadata0 8
)8 9
?: ;
metadata< D
.D E
GetHashCodeE P
(P Q
)Q R
:S T
baseU Y
.Y Z
GetHashCodeZ e
(e f
)f g
;g h
}
€€ 
}
 
return
ƒƒ 
hash
ƒƒ 
;
ƒƒ 
}
„„ 	
public
†† 
bool
†† 
Equals
†† 
(
†† 
SemVer
†† !
version
††" )
)
††) *
{
‡‡ 	
if
ˆˆ 
(
ˆˆ 
object
ˆˆ 
.
ˆˆ 
ReferenceEquals
ˆˆ &
(
ˆˆ& '
version
ˆˆ' .
,
ˆˆ. /
null
ˆˆ0 4
)
ˆˆ4 5
)
ˆˆ5 6
return
‰‰ 
false
‰‰ 
;
‰‰ 
if
‹‹ 
(
‹‹ 
IsValid
‹‹ 
(
‹‹ 
)
‹‹ 
!=
‹‹ 
version
‹‹ $
.
‹‹$ %
IsValid
‹‹% ,
(
‹‹, -
)
‹‹- .
)
‹‹. /
return
ŒŒ 
false
ŒŒ 
;
ŒŒ 
if
 
(
 
IsValid
 
(
 
)
 
)
 
{
 
return
 
major
 
==
 
version
  '
.
' (
major
( -
&&
. 0
minor
‘‘ 
==
‘‘ 
version
‘‘ $
.
‘‘$ %
minor
‘‘% *
&&
‘‘+ -
patch
’’ 
==
’’ 
version
’’ $
.
’’$ %
patch
’’% *
&&
’’+ -
type
““ 
.
““ 
Equals
““ 
(
““  
version
““  '
.
““' (
type
““( ,
)
““, -
&&
““. 0
build
”” 
.
”” 
Equals
””  
(
””  !
version
””! (
.
””( )
build
””) .
)
””. /
;
””/ 0
}
•• 
else
–– 
{
—— 
if
˜˜ 
(
˜˜ 
string
˜˜ 
.
˜˜ 
IsNullOrEmpty
˜˜ (
(
˜˜( )
metadata
˜˜) 1
)
˜˜1 2
||
˜˜3 5
string
˜˜6 <
.
˜˜< =
IsNullOrEmpty
˜˜= J
(
˜˜J K
version
˜˜K R
.
˜˜R S
metadata
˜˜S [
)
˜˜[ \
)
˜˜\ ]
return
™™ 
false
™™  
;
™™  !
return
›› 
metadata
›› 
.
››  
Equals
››  &
(
››& '
version
››' .
.
››. /
metadata
››/ 7
)
››7 8
;
››8 9
}
œœ 
}
 	
public
ŸŸ 
int
ŸŸ 
	CompareTo
ŸŸ 
(
ŸŸ 
object
ŸŸ #
obj
ŸŸ$ '
)
ŸŸ' (
{
   	
return
¡¡ 
	CompareTo
¡¡ 
(
¡¡ 
obj
¡¡  
as
¡¡! #
SemVer
¡¡$ *
)
¡¡* +
;
¡¡+ ,
}
¢¢ 	
static
¤¤ 
int
¤¤ 
WrapNoValue
¤¤ 
(
¤¤ 
int
¤¤ "
value
¤¤# (
)
¤¤( )
{
¥¥ 	
return
¦¦ 
value
¦¦ 
<
¦¦ 
$num
¦¦ 
?
¦¦ 
int
¦¦ "
.
¦¦" #
MaxValue
¦¦# +
:
¦¦, -
value
¦¦. 3
;
¦¦3 4
}
§§ 	
public
©© 
int
©© 
	CompareTo
©© 
(
©© 
SemVer
©© #
version
©©$ +
)
©©+ ,
{
ªª 	
const
«« 
int
«« 
GREATER
«« 
=
«« 
$num
««  !
;
««! "
const
¬¬ 
int
¬¬ 
EVEN
¬¬ 
=
¬¬ 
$num
¬¬ 
;
¬¬ 
const
­­ 
int
­­ 
LESS
­­ 
=
­­ 
-
­­ 
$num
­­ 
;
­­  
if
¯¯ 
(
¯¯ 
object
¯¯ 
.
¯¯ 
ReferenceEquals
¯¯ &
(
¯¯& '
version
¯¯' .
,
¯¯. /
null
¯¯0 4
)
¯¯4 5
)
¯¯5 6
return
°° 
GREATER
°° 
;
°° 
if
²² 
(
²² 
Equals
²² 
(
²² 
version
²² 
)
²² 
)
²²  
return
³³ 
EVEN
³³ 
;
³³ 
if
µµ 
(
µµ 
major
µµ 
>
µµ 
version
µµ 
.
µµ  
major
µµ  %
)
µµ% &
return
¶¶ 
GREATER
¶¶ 
;
¶¶ 
if
·· 
(
·· 
major
·· 
<
·· 
version
·· 
.
··  
major
··  %
)
··% &
return
¸¸ 
LESS
¸¸ 
;
¸¸ 
if
¹¹ 
(
¹¹ 
minor
¹¹ 
>
¹¹ 
version
¹¹ 
.
¹¹  
minor
¹¹  %
)
¹¹% &
return
ºº 
GREATER
ºº 
;
ºº 
if
»» 
(
»» 
minor
»» 
<
»» 
version
»» 
.
»»  
minor
»»  %
)
»»% &
return
¼¼ 
LESS
¼¼ 
;
¼¼ 
if
ÀÀ 
(
ÀÀ 
WrapNoValue
ÀÀ 
(
ÀÀ 
patch
ÀÀ !
)
ÀÀ! "
>
ÀÀ# $
WrapNoValue
ÀÀ% 0
(
ÀÀ0 1
version
ÀÀ1 8
.
ÀÀ8 9
patch
ÀÀ9 >
)
ÀÀ> ?
)
ÀÀ? @
return
ÁÁ 
GREATER
ÁÁ 
;
ÁÁ 
if
ÂÂ 
(
ÂÂ 
WrapNoValue
ÂÂ 
(
ÂÂ 
patch
ÂÂ !
)
ÂÂ! "
<
ÂÂ# $
WrapNoValue
ÂÂ% 0
(
ÂÂ0 1
version
ÂÂ1 8
.
ÂÂ8 9
patch
ÂÂ9 >
)
ÂÂ> ?
)
ÂÂ? @
return
ÃÃ 
LESS
ÃÃ 
;
ÃÃ 
if
ÄÄ 
(
ÄÄ 
string
ÄÄ 
.
ÄÄ 
IsNullOrEmpty
ÄÄ $
(
ÄÄ$ %
type
ÄÄ% )
)
ÄÄ) *
&&
ÄÄ+ -
!
ÄÄ. /
string
ÄÄ/ 5
.
ÄÄ5 6
IsNullOrEmpty
ÄÄ6 C
(
ÄÄC D
version
ÄÄD K
.
ÄÄK L
type
ÄÄL P
)
ÄÄP Q
)
ÄÄQ R
return
ÅÅ 
GREATER
ÅÅ 
;
ÅÅ 
if
ÆÆ 
(
ÆÆ 
!
ÆÆ 
string
ÆÆ 
.
ÆÆ 
IsNullOrEmpty
ÆÆ %
(
ÆÆ% &
type
ÆÆ& *
)
ÆÆ* +
&&
ÆÆ, .
string
ÆÆ/ 5
.
ÆÆ5 6
IsNullOrEmpty
ÆÆ6 C
(
ÆÆC D
version
ÆÆD K
.
ÆÆK L
type
ÆÆL P
)
ÆÆP Q
)
ÆÆQ R
return
ÇÇ 
LESS
ÇÇ 
;
ÇÇ 
if
ÈÈ 
(
ÈÈ 
WrapNoValue
ÈÈ 
(
ÈÈ 
build
ÈÈ !
)
ÈÈ! "
>
ÈÈ# $
WrapNoValue
ÈÈ% 0
(
ÈÈ0 1
version
ÈÈ1 8
.
ÈÈ8 9
build
ÈÈ9 >
)
ÈÈ> ?
)
ÈÈ? @
return
ÉÉ 
GREATER
ÉÉ 
;
ÉÉ 
if
ÊÊ 
(
ÊÊ 
WrapNoValue
ÊÊ 
(
ÊÊ 
build
ÊÊ !
)
ÊÊ! "
<
ÊÊ# $
WrapNoValue
ÊÊ% 0
(
ÊÊ0 1
version
ÊÊ1 8
.
ÊÊ8 9
build
ÊÊ9 >
)
ÊÊ> ?
)
ÊÊ? @
return
ËË 
LESS
ËË 
;
ËË 
return
ÍÍ 
EVEN
ÍÍ 
;
ÍÍ 
}
ÎÎ 	
public
ĞĞ 
static
ĞĞ 
bool
ĞĞ 
operator
ĞĞ #
==
ĞĞ# %
(
ĞĞ% &
SemVer
ĞĞ& ,
left
ĞĞ- 1
,
ĞĞ1 2
SemVer
ĞĞ3 9
right
ĞĞ: ?
)
ĞĞ? @
{
ÑÑ 	
if
ÒÒ 
(
ÒÒ 
object
ÒÒ 
.
ÒÒ 
ReferenceEquals
ÒÒ &
(
ÒÒ& '
left
ÒÒ' +
,
ÒÒ+ ,
null
ÒÒ- 1
)
ÒÒ1 2
)
ÒÒ2 3
return
ÓÓ 
object
ÓÓ 
.
ÓÓ 
ReferenceEquals
ÓÓ -
(
ÓÓ- .
right
ÓÓ. 3
,
ÓÓ3 4
null
ÓÓ5 9
)
ÓÓ9 :
;
ÓÓ: ;
return
ÕÕ 
left
ÕÕ 
.
ÕÕ 
Equals
ÕÕ 
(
ÕÕ 
right
ÕÕ $
)
ÕÕ$ %
;
ÕÕ% &
}
ÖÖ 	
public
ØØ 
static
ØØ 
bool
ØØ 
operator
ØØ #
!=
ØØ# %
(
ØØ% &
SemVer
ØØ& ,
left
ØØ- 1
,
ØØ1 2
SemVer
ØØ3 9
right
ØØ: ?
)
ØØ? @
{
ÙÙ 	
return
ÚÚ 
!
ÚÚ 
(
ÚÚ 
left
ÚÚ 
==
ÚÚ 
right
ÚÚ "
)
ÚÚ" #
;
ÚÚ# $
}
ÛÛ 	
public
İİ 
static
İİ 
bool
İİ 
operator
İİ #
<
İİ# $
(
İİ$ %
SemVer
İİ% +
left
İİ, 0
,
İİ0 1
SemVer
İİ2 8
right
İİ9 >
)
İİ> ?
{
ŞŞ 	
if
ßß 
(
ßß 
object
ßß 
.
ßß 
ReferenceEquals
ßß &
(
ßß& '
left
ßß' +
,
ßß+ ,
null
ßß- 1
)
ßß1 2
)
ßß2 3
return
àà 
!
àà 
object
àà 
.
àà 
ReferenceEquals
àà .
(
àà. /
right
àà/ 4
,
àà4 5
null
àà6 :
)
àà: ;
;
àà; <
return
ââ 
left
ââ 
.
ââ 
	CompareTo
ââ !
(
ââ! "
right
ââ" '
)
ââ' (
<
ââ) *
$num
ââ+ ,
;
ââ, -
}
ãã 	
public
åå 
static
åå 
bool
åå 
operator
åå #
>
åå# $
(
åå$ %
SemVer
åå% +
left
åå, 0
,
åå0 1
SemVer
åå2 8
right
åå9 >
)
åå> ?
{
ææ 	
if
èè 
(
èè 
object
èè 
.
èè 
ReferenceEquals
èè &
(
èè& '
left
èè' +
,
èè+ ,
null
èè- 1
)
èè1 2
)
èè2 3
return
éé 
false
éé 
;
éé 
return
ëë 
left
ëë 
.
ëë 
	CompareTo
ëë !
(
ëë! "
right
ëë" '
)
ëë' (
>
ëë) *
$num
ëë+ ,
;
ëë, -
}
ìì 	
public
îî 
static
îî 
bool
îî 
operator
îî #
<=
îî$ &
(
îî& '
SemVer
îî' -
left
îî. 2
,
îî2 3
SemVer
îî4 :
right
îî; @
)
îî@ A
{
ïï 	
return
ğğ 
left
ğğ 
==
ğğ 
right
ğğ  
||
ğğ! #
left
ğğ$ (
<
ğğ) *
right
ğğ+ 0
;
ğğ0 1
}
ññ 	
public
óó 
static
óó 
bool
óó 
operator
óó #
>=
óó# %
(
óó% &
SemVer
óó& ,
left
óó- 1
,
óó1 2
SemVer
óó3 9
right
óó: ?
)
óó? @
{
ôô 	
return
õõ 
left
õõ 
==
õõ 
right
õõ  
||
õõ! #
left
õõ$ (
>
õõ) *
right
õõ+ 0
;
õõ0 1
}
öö 	
public
ˆˆ 
string
ˆˆ 
ToString
ˆˆ 
(
ˆˆ 
string
ˆˆ %
format
ˆˆ& ,
)
ˆˆ, -
{
‰‰ 	
var
ŠŠ 
sb
ŠŠ 
=
ŠŠ 
new
ŠŠ 
StringBuilder
ŠŠ &
(
ŠŠ& '
)
ŠŠ' (
;
ŠŠ( )
bool
‹‹ 
skip
‹‹ 
=
‹‹ 
false
‹‹ 
;
‹‹ 
foreach
 
(
 
char
 
c
 
in
 
format
 %
.
% &
ToCharArray
& 1
(
1 2
)
2 3
)
3 4
{
 
if
 
(
 
skip
 
)
 
{
 
sb
‘‘ 
.
‘‘ 
Append
‘‘ 
(
‘‘ 
c
‘‘ 
)
‘‘  
;
‘‘  !
skip
’’ 
=
’’ 
false
’’  
;
’’  !
continue
““ 
;
““ 
}
”” 
if
–– 
(
–– 
c
–– 
==
–– 
$char
–– 
)
–– 
skip
—— 
=
—— 
true
—— 
;
——  
else
˜˜ 
if
˜˜ 
(
˜˜ 
c
˜˜ 
==
˜˜ 
$char
˜˜ !
)
˜˜! "
sb
™™ 
.
™™ 
Append
™™ 
(
™™ 
major
™™ #
)
™™# $
;
™™$ %
else
šš 
if
šš 
(
šš 
c
šš 
==
šš 
$char
šš !
)
šš! "
sb
›› 
.
›› 
Append
›› 
(
›› 
minor
›› #
)
››# $
;
››$ %
else
œœ 
if
œœ 
(
œœ 
c
œœ 
==
œœ 
$char
œœ !
)
œœ! "
sb
 
.
 
Append
 
(
 
patch
 #
)
# $
;
$ %
else
 
if
 
(
 
c
 
==
 
$char
 !
)
! "
sb
ŸŸ 
.
ŸŸ 
Append
ŸŸ 
(
ŸŸ 
build
ŸŸ #
)
ŸŸ# $
;
ŸŸ$ %
else
   
if
   
(
   
c
   
==
   
$char
   !
||
  " $
c
  % &
==
  ' )
$char
  * -
)
  - .
sb
¡¡ 
.
¡¡ 
Append
¡¡ 
(
¡¡ 
type
¡¡ "
)
¡¡" #
;
¡¡# $
else
¢¢ 
if
¢¢ 
(
¢¢ 
c
¢¢ 
==
¢¢ 
$char
¢¢ !
)
¢¢! "
sb
££ 
.
££ 
Append
££ 
(
££ 
date
££ "
)
££" #
;
££# $
else
¤¤ 
if
¤¤ 
(
¤¤ 
c
¤¤ 
==
¤¤ 
$char
¤¤ !
)
¤¤! "
sb
¥¥ 
.
¥¥ 
Append
¥¥ 
(
¥¥ 
metadata
¥¥ &
)
¥¥& '
;
¥¥' (
else
¦¦ 
sb
§§ 
.
§§ 
Append
§§ 
(
§§ 
c
§§ 
)
§§  
;
§§  !
}
¨¨ 
return
ªª 
sb
ªª 
.
ªª 
ToString
ªª 
(
ªª 
)
ªª  
;
ªª  !
}
«« 	
public
±± 
override
±± 
string
±± 
ToString
±± '
(
±±' (
)
±±( )
{
²² 	
var
³³ 
sb
³³ 
=
³³ 
new
³³ 
StringBuilder
³³ &
(
³³& '
)
³³' (
;
³³( )
sb
µµ 
.
µµ 
Append
µµ 
(
µµ 
ToString
µµ 
(
µµ 
$str
µµ &
)
µµ& '
)
µµ' (
;
µµ( )
if
·· 
(
·· 
!
·· 
string
·· 
.
·· 
IsNullOrEmpty
·· %
(
··% &
type
··& *
)
··* +
)
··+ ,
{
¸¸ 
sb
¹¹ 
.
¹¹ 
Append
¹¹ 
(
¹¹ 
$str
¹¹ 
)
¹¹ 
;
¹¹ 
sb
ºº 
.
ºº 
Append
ºº 
(
ºº 
type
ºº 
)
ºº 
;
ºº  
if
¼¼ 
(
¼¼ 
build
¼¼ 
>
¼¼ 
-
¼¼ 
$num
¼¼ 
)
¼¼ 
{
½½ 
sb
¾¾ 
.
¾¾ 
Append
¾¾ 
(
¾¾ 
$str
¾¾ !
)
¾¾! "
;
¾¾" #
sb
¿¿ 
.
¿¿ 
Append
¿¿ 
(
¿¿ 
build
¿¿ #
.
¿¿# $
ToString
¿¿$ ,
(
¿¿, -
)
¿¿- .
)
¿¿. /
;
¿¿/ 0
}
ÀÀ 
}
ÁÁ 
if
ÃÃ 
(
ÃÃ 
!
ÃÃ 
string
ÃÃ 
.
ÃÃ 
IsNullOrEmpty
ÃÃ %
(
ÃÃ% &
date
ÃÃ& *
)
ÃÃ* +
)
ÃÃ+ ,
{
ÄÄ 
sb
ÅÅ 
.
ÅÅ 
Append
ÅÅ 
(
ÅÅ 
$str
ÅÅ 
)
ÅÅ 
;
ÅÅ 
sb
ÆÆ 
.
ÆÆ 
Append
ÆÆ 
(
ÆÆ 
date
ÆÆ 
)
ÆÆ 
;
ÆÆ  
}
ÇÇ 
return
ÉÉ 
sb
ÉÉ 
.
ÉÉ 
ToString
ÉÉ 
(
ÉÉ 
)
ÉÉ  
;
ÉÉ  !
}
ÊÊ 	
public
ÔÔ 
static
ÔÔ 
bool
ÔÔ 
TryGetVersionInfo
ÔÔ ,
(
ÔÔ, -
string
ÔÔ- 3
input
ÔÔ4 9
,
ÔÔ9 :
out
ÔÔ; >
SemVer
ÔÔ? E
version
ÔÔF M
)
ÔÔM N
{
ÕÕ 	
version
ÖÖ 
=
ÖÖ 
new
ÖÖ 
SemVer
ÖÖ  
(
ÖÖ  !
)
ÖÖ! "
;
ÖÖ" #
bool
×× 
ret
×× 
=
×× 
false
×× 
;
×× 
const
ÙÙ 
string
ÙÙ $
k_MajorMinorPatchRegex
ÙÙ /
=
ÙÙ0 1
$str
ÙÙ2 O
;
ÙÙO P
const
ÚÚ 
string
ÚÚ #
k_VersionReleaseRegex
ÚÚ .
=
ÚÚ/ 0
$str
ÚÚ1 K
;
ÚÚK L
const
ÛÛ 
string
ÛÛ !
k_VersionBuildRegex
ÛÛ ,
=
ÛÛ- .
$str
ÛÛ/ R
;
ÛÛR S
const
ÜÜ 
string
ÜÜ 
k_MetadataRegex
ÜÜ (
=
ÜÜ) *
$str
ÜÜ+ 7
;
ÜÜ7 8
try
ŞŞ 
{
ßß 
var
àà 
mmp
àà 
=
àà 
Regex
àà 
.
àà  
Match
àà  %
(
àà% &
input
àà& +
,
àà+ ,$
k_MajorMinorPatchRegex
àà- C
)
ààC D
;
ààD E
if
ââ 
(
ââ 
!
ââ 
mmp
ââ 
.
ââ 
Success
ââ  
)
ââ  !
return
ãã 
false
ãã  
;
ãã  !
string
åå 
[
åå 
]
åå 
mmpSplit
åå !
=
åå" #
mmp
åå$ '
.
åå' (
Value
åå( -
.
åå- .
Split
åå. 3
(
åå3 4
$char
åå4 7
)
åå7 8
;
åå8 9
int
çç 
.
çç 
TryParse
çç 
(
çç 
mmpSplit
çç %
[
çç% &
$num
çç& '
]
çç' (
,
çç( )
out
çç* -
version
çç. 5
.
çç5 6
m_Major
çç6 =
)
çç= >
;
çç> ?
int
èè 
.
èè 
TryParse
èè 
(
èè 
mmpSplit
èè %
[
èè% &
$num
èè& '
]
èè' (
,
èè( )
out
èè* -
version
èè. 5
.
èè5 6
m_Minor
èè6 =
)
èè= >
;
èè> ?
int
éé 
.
éé 
TryParse
éé 
(
éé 
mmpSplit
éé %
[
éé% &
$num
éé& '
]
éé' (
,
éé( )
out
éé* -
version
éé. 5
.
éé5 6
m_Patch
éé6 =
)
éé= >
;
éé> ?
ret
ëë 
=
ëë 
true
ëë 
;
ëë 
var
îî 
preReleaseVersion
îî %
=
îî& '
Regex
îî( -
.
îî- .
Match
îî. 3
(
îî3 4
input
îî4 9
,
îî9 :#
k_VersionReleaseRegex
îî; P
)
îîP Q
;
îîQ R
if
ğğ 
(
ğğ 
preReleaseVersion
ğğ %
.
ğğ% &
Success
ğğ& -
)
ğğ- .
version
ññ 
.
ññ 
m_Type
ññ "
=
ññ# $
preReleaseVersion
ññ% 6
.
ññ6 7
Value
ññ7 <
;
ññ< =
var
óó 
preReleaseBuild
óó #
=
óó$ %
Regex
óó& +
.
óó+ ,
Match
óó, 1
(
óó1 2
input
óó2 7
,
óó7 8!
k_VersionBuildRegex
óó9 L
)
óóL M
;
óóM N
version
ôô 
.
ôô 
m_Build
ôô 
=
ôô  !
preReleaseBuild
ôô" 1
.
ôô1 2
Success
ôô2 9
?
ôô: ;
GetBuildNumber
ôô< J
(
ôôJ K
preReleaseBuild
ôôK Z
.
ôôZ [
Value
ôô[ `
)
ôô` a
:
ôôb c
-
ôôd e
$num
ôôe f
;
ôôf g
var
öö 
meta
öö 
=
öö 
Regex
öö  
.
öö  !
Match
öö! &
(
öö& '
input
öö' ,
,
öö, -
k_MetadataRegex
öö. =
)
öö= >
;
öö> ?
if
øø 
(
øø 
meta
øø 
.
øø 
Success
øø  
)
øø  !
version
ùù 
.
ùù 

m_Metadata
ùù &
=
ùù' (
meta
ùù) -
.
ùù- .
Value
ùù. 3
;
ùù3 4
}
úú 
catch
ûû 
{
üü 
ret
ıı 
=
ıı 
false
ıı 
;
ıı 
}
şş 
return
€€ 
ret
€€ 
;
€€ 
}
 	
static
ƒƒ 
int
ƒƒ 
GetBuildNumber
ƒƒ !
(
ƒƒ! "
string
ƒƒ" (
input
ƒƒ) .
)
ƒƒ. /
{
„„ 	
var
…… 
number
…… 
=
…… 
Regex
…… 
.
…… 
Match
…… $
(
……$ %
input
……% *
,
……* +
$str
……, 4
)
……4 5
;
……5 6
int
‡‡ 
buildNo
‡‡ 
=
‡‡ 
$num
‡‡ 
;
‡‡ 
if
‰‰ 
(
‰‰ 
number
‰‰ 
.
‰‰ 
Success
‰‰ 
&&
‰‰ !
int
‰‰" %
.
‰‰% &
TryParse
‰‰& .
(
‰‰. /
number
‰‰/ 5
.
‰‰5 6
Value
‰‰6 ;
,
‰‰; <
out
‰‰= @
buildNo
‰‰A H
)
‰‰H I
)
‰‰I J
return
ŠŠ 
buildNo
ŠŠ 
;
ŠŠ 
return
ŒŒ 
-
ŒŒ 
$num
ŒŒ 
;
ŒŒ 
}
 	
}
 
} ¢/
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ColorPalette.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{		 
[ 
Serializable 
] 
sealed 

class 
ColorPalette 
: 
ScriptableObject  0
,0 1
IHasDefault2 =
{ 
public 
Color 
current 
{ 
get "
;" #
set$ '
;' (
}) *
[ 	 
FormerlySerializedAs	 
( 
$str &
)& '
]' (
[ 	
SerializeField	 
] 
List 
< 
Color 
> 
m_Colors 
; 
public 
ReadOnlyCollection !
<! "
Color" '
>' (
colors) /
{ 	
get   
{   
return   
new   
ReadOnlyCollection   /
<  / 0
Color  0 5
>  5 6
(  6 7
m_Colors  7 ?
)  ? @
;  @ A
}  B C
}!! 	
public(( 
void(( 
	SetColors(( 
((( 
IEnumerable(( )
<(() *
Color((* /
>((/ 0
colors((1 7
)((7 8
{)) 	
if** 
(** 
colors** 
==** 
null** 
)** 
throw++ 
new++ !
ArgumentNullException++ /
(++/ 0
$str++0 8
)++8 9
;++9 :
m_Colors-- 
=-- 
colors-- 
.-- 
ToList-- $
(--$ %
)--% &
;--& '
}.. 	
public44 
void44 
SetDefaultValues44 $
(44$ %
)44% &
{55 	
m_Colors66 
=66 
new66 
List66 
<66  
Color66  %
>66% &
(66& '
)66' (
{77 
new88 
Color88 
(88 
$num88  
,88  !
$num88" (
,88( )
$num88* 0
,880 1
$num882 4
)884 5
,885 6
new99 
Color99 
(99 
$num99  
,99  !
$num99" (
,99( )
$num99* 0
,990 1
$num992 4
)994 5
,995 6
new:: 
Color:: 
(:: 
$num::  
,::  !
$num::" (
,::( )
$num::* 0
,::0 1
$num::2 4
)::4 5
,::5 6
new;; 
Color;; 
(;; 
$num;;  
,;;  !
$num;;" (
,;;( )
$num;;* 0
,;;0 1
$num;;2 4
);;4 5
,;;5 6
new<< 
Color<< 
(<< 
$num<<  
,<<  !
$num<<" (
,<<( )
$num<<* 0
,<<0 1
$num<<2 4
)<<4 5
,<<5 6
new== 
Color== 
(== 
$num==  
,==  !
$num==" (
,==( )
$num==* 0
,==0 1
$num==2 4
)==4 5
,==5 6
new>> 
Color>> 
(>> 
$num>>  
,>>  !
$num>>" (
,>>( )
$num>>* 0
,>>0 1
$num>>2 4
)>>4 5
,>>5 6
new?? 
Color?? 
(?? 
$num??  
,??  !
$num??" (
,??( )
$num??* 0
,??0 1
$num??2 4
)??4 5
,??5 6
new@@ 
Color@@ 
(@@ 
$num@@  
,@@  !
$num@@" (
,@@( )
$num@@* 0
,@@0 1
$num@@2 4
)@@4 5
,@@5 6
newAA 
ColorAA 
(AA 
$numAA  
,AA  !
$numAA" (
,AA( )
$numAA* 0
,AA0 1
$numAA2 4
)AA4 5
,AA5 6
newBB 
ColorBB 
(BB 
$numBB  
,BB  !
$numBB" (
,BB( )
$numBB* 0
,BB0 1
$numBB2 4
)BB4 5
,BB5 6
newCC 
ColorCC 
(CC 
$numCC  
,CC  !
$numCC" (
,CC( )
$numCC* 0
,CC0 1
$numCC2 4
)CC4 5
,CC5 6
newDD 
ColorDD 
(DD 
$numDD  
,DD  !
$numDD" (
,DD( )
$numDD* 0
,DD0 1
$numDD2 4
)DD4 5
,DD5 6
newEE 
ColorEE 
(EE 
$numEE  
,EE  !
$numEE" (
,EE( )
$numEE* 0
,EE0 1
$numEE2 4
)EE4 5
,EE5 6
newFF 
ColorFF 
(FF 
$numFF  
,FF  !
$numFF" (
,FF( )
$numFF* 0
,FF0 1
$numFF2 4
)FF4 5
,FF5 6
newGG 
ColorGG 
(GG 
$numGG  
,GG  !
$numGG" (
,GG( )
$numGG* 0
,GG0 1
$numGG2 4
)GG4 5
}HH 
;HH 
}II 	
publicQQ 
ColorQQ 
thisQQ 
[QQ 
intQQ 
iQQ 
]QQ  
{RR 	
getSS 
{SS 
returnSS 
m_ColorsSS !
[SS! "
iSS" #
]SS# $
;SS$ %
}SS& '
setTT 
{TT 
m_ColorsTT 
[TT 
iTT 
]TT 
=TT 
valueTT  %
;TT% &
}TT' (
}UU 	
publicZZ 
intZZ 
CountZZ 
{[[ 	
get\\ 
{\\ 
return\\ 
m_Colors\\ !
.\\! "
Count\\" '
;\\' (
}\\) *
}]] 	
}^^ 
}__ ²§
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SharedVertex.cs
	namespace		 	
UnityEngine		
 
.		 

ProBuilder		  
{

 
[ 
Serializable 
] 
public 

sealed 
class 
SharedVertex $
:% &
ICollection' 2
<2 3
int3 6
>6 7
{ 
[ 	
SerializeField	 
] 
[ 	 
FormerlySerializedAs	 
( 
$str %
)% &
]& '
[ 	 
FormerlySerializedAs	 
( 
$str *
)* +
]+ ,
int 
[ 
] 

m_Vertices 
; 
internal 
int 
[ 
] 
arrayInternal $
{ 	
get 
{ 
return 

m_Vertices #
;# $
}% &
} 	
public%% 
SharedVertex%% 
(%% 
IEnumerable%% '
<%%' (
int%%( +
>%%+ ,
indexes%%- 4
)%%4 5
{&& 	
if'' 
('' 
indexes'' 
=='' 
null'' 
)''  
throw(( 
new(( !
ArgumentNullException(( /
(((/ 0
$str((0 9
)((9 :
;((: ;

m_Vertices)) 
=)) 
indexes))  
.))  !
ToArray))! (
())( )
)))) *
;))* +
}** 	
public00 
SharedVertex00 
(00 
SharedVertex00 (
sharedVertex00) 5
)005 6
{11 	
if22 
(22 
sharedVertex22 
==22 
null22  $
)22$ %
throw33 
new33 !
ArgumentNullException33 /
(33/ 0
$str330 >
)33> ?
;33? @

m_Vertices44 
=44 
new44 
int44  
[44  !
sharedVertex44! -
.44- .
Count44. 3
]443 4
;444 5
Array55 
.55 
Copy55 
(55 
sharedVertex55 #
.55# $

m_Vertices55$ .
,55. /

m_Vertices550 :
,55: ;

m_Vertices55< F
.55F G
Length55G M
)55M N
;55N O
}66 	
public<< 
int<< 
this<< 
[<< 
int<< 
i<< 
]<< 
{== 	
get>> 
{>> 
return>> 

m_Vertices>> #
[>># $
i>>$ %
]>>% &
;>>& '
}>>( )
set?? 
{?? 

m_Vertices?? 
[?? 
i?? 
]?? 
=??  !
value??" '
;??' (
}??) *
}@@ 	
publicCC 
IEnumeratorCC 
<CC 
intCC 
>CC 
GetEnumeratorCC  -
(CC- .
)CC. /
{DD 	
returnEE 
(EE 
(EE 
IEnumerableEE  
<EE  !
intEE! $
>EE$ %
)EE% &

m_VerticesEE& 0
)EE0 1
.EE1 2
GetEnumeratorEE2 ?
(EE? @
)EE@ A
;EEA B
}FF 	
publicII 
overrideII 
stringII 
ToStringII '
(II' (
)II( )
{JJ 	
returnKK 

m_VerticesKK 
.KK 
ToStringKK &
(KK& '
$strKK' *
)KK* +
;KK+ ,
}LL 	
IEnumeratorOO 
IEnumerableOO 
.OO  
GetEnumeratorOO  -
(OO- .
)OO. /
{PP 	
returnQQ 
GetEnumeratorQQ  
(QQ  !
)QQ! "
;QQ" #
}RR 	
publicUU 
voidUU 
AddUU 
(UU 
intUU 
itemUU  
)UU  !
{VV 	

m_VerticesWW 
=WW 
ArrayUtilityWW %
.WW% &
AddWW& )
(WW) *

m_VerticesWW* 4
,WW4 5
itemWW6 :
)WW: ;
;WW; <
}XX 	
public[[ 
void[[ 
Clear[[ 
([[ 
)[[ 
{\\ 	

m_Vertices]] 
=]] 
new]] 
int]]  
[]]  !
$num]]! "
]]]" #
;]]# $
}^^ 	
publicaa 
boolaa 
Containsaa 
(aa 
intaa  
itemaa! %
)aa% &
{bb 	
returncc 
Arraycc 
.cc 
IndexOfcc  
(cc  !

m_Verticescc! +
,cc+ ,
itemcc- 1
)cc1 2
>cc3 4
-cc5 6
$numcc6 7
;cc7 8
}dd 	
publicgg 
voidgg 
CopyTogg 
(gg 
intgg 
[gg 
]gg  
arraygg! &
,gg& '
intgg( +

arrayIndexgg, 6
)gg6 7
{hh 	

m_Verticesii 
.ii 
CopyToii 
(ii 
arrayii #
,ii# $

arrayIndexii% /
)ii/ 0
;ii0 1
}jj 	
publicmm 
boolmm 
Removemm 
(mm 
intmm 
itemmm #
)mm# $
{nn 	
intoo 
indoo 
=oo 
Arrayoo 
.oo 
IndexOfoo #
(oo# $

m_Verticesoo$ .
,oo. /
itemoo0 4
)oo4 5
;oo5 6
ifpp 
(pp 
indpp 
<pp 
$numpp 
)pp 
returnqq 
falseqq 
;qq 

m_Verticesrr 
=rr 

m_Verticesrr #
.rr# $
RemoveAtrr$ ,
(rr, -
itemrr- 1
)rr1 2
;rr2 3
returnss 
truess 
;ss 
}tt 	
publicww 
intww 
Countww 
{xx 	
getyy 
{yy 
returnyy 

m_Verticesyy #
.yy# $
Lengthyy$ *
;yy* +
}yy, -
}zz 	
public}} 
bool}} 

IsReadOnly}} 
{~~ 	
get 
{ 
return 

m_Vertices #
.# $

IsReadOnly$ .
;. /
}0 1
}
€€ 	
public
 
static
 
void
 #
GetSharedVertexLookup
 0
(
0 1
IList
1 6
<
6 7
SharedVertex
7 C
>
C D
sharedVertices
E S
,
S T

Dictionary
U _
<
_ `
int
` c
,
c d
int
e h
>
h i
lookup
j p
)
p q
{
 	
lookup
 
.
 
Clear
 
(
 
)
 
;
 
for
’’ 
(
’’ 
int
’’ 
i
’’ 
=
’’ 
$num
’’ 
,
’’ 
c
’’ 
=
’’ 
sharedVertices
’’ -
.
’’- .
Count
’’. 3
;
’’3 4
i
’’5 6
<
’’7 8
c
’’9 :
;
’’: ;
i
’’< =
++
’’= ?
)
’’? @
{
““ 
foreach
”” 
(
”” 
var
”” 
index
”” "
in
””# %
sharedVertices
””& 4
[
””4 5
i
””5 6
]
””6 7
)
””7 8
{
•• 
if
–– 
(
–– 
!
–– 
lookup
–– 
.
––  
ContainsKey
––  +
(
––+ ,
index
––, 1
)
––1 2
)
––2 3
lookup
—— 
.
—— 
Add
—— "
(
——" #
index
——# (
,
——( )
i
——* +
)
——+ ,
;
——, -
}
˜˜ 
}
™™ 
}
šš 	
internal
œœ 
void
œœ 
ShiftIndexes
œœ "
(
œœ" #
int
œœ# &
offset
œœ' -
)
œœ- .
{
 	
for
 
(
 
int
 
i
 
=
 
$num
 
,
 
c
 
=
 
Count
  %
;
% &
i
' (
<
) *
c
+ ,
;
, -
i
. /
++
/ 1
)
1 2

m_Vertices
ŸŸ 
[
ŸŸ 
i
ŸŸ 
]
ŸŸ 
+=
ŸŸ  
offset
ŸŸ! '
;
ŸŸ' (
}
   	
internal
§§ 
static
§§ 
SharedVertex
§§ $
[
§§$ %
]
§§% &
ToSharedVertices
§§' 7
(
§§7 8
IEnumerable
§§8 C
<
§§C D
KeyValuePair
§§D P
<
§§P Q
int
§§Q T
,
§§T U
int
§§V Y
>
§§Y Z
>
§§Z [
lookup
§§\ b
)
§§b c
{
¨¨ 	
if
©© 
(
©© 
lookup
©© 
==
©© 
null
©© 
)
©© 
return
ªª 
new
ªª 
SharedVertex
ªª '
[
ªª' (
$num
ªª( )
]
ªª) *
;
ªª* +

Dictionary
¬¬ 
<
¬¬ 
int
¬¬ 
,
¬¬ 
int
¬¬ 
>
¬¬  
map
¬¬! $
=
¬¬% &
new
¬¬' *

Dictionary
¬¬+ 5
<
¬¬5 6
int
¬¬6 9
,
¬¬9 :
int
¬¬; >
>
¬¬> ?
(
¬¬? @
)
¬¬@ A
;
¬¬A B
List
­­ 
<
­­ 
List
­­ 
<
­­ 
int
­­ 
>
­­ 
>
­­ 
shared
­­ "
=
­­# $
new
­­% (
List
­­) -
<
­­- .
List
­­. 2
<
­­2 3
int
­­3 6
>
­­6 7
>
­­7 8
(
­­8 9
)
­­9 :
;
­­: ;
foreach
¯¯ 
(
¯¯ 
var
¯¯ 
kvp
¯¯ 
in
¯¯ 
lookup
¯¯  &
)
¯¯& '
{
°° 
if
±± 
(
±± 
kvp
±± 
.
±± 
Value
±± 
<
±± 
$num
±±  !
)
±±! "
{
²² 
shared
³³ 
.
³³ 
Add
³³ 
(
³³ 
new
³³ "
List
³³# '
<
³³' (
int
³³( +
>
³³+ ,
(
³³, -
)
³³- .
{
³³/ 0
kvp
³³1 4
.
³³4 5
Key
³³5 8
}
³³9 :
)
³³: ;
;
³³; <
}
´´ 
else
µµ 
{
¶¶ 
int
·· 
index
·· 
=
·· 
-
··  !
$num
··! "
;
··" #
if
¹¹ 
(
¹¹ 
map
¹¹ 
.
¹¹ 
TryGetValue
¹¹ '
(
¹¹' (
kvp
¹¹( +
.
¹¹+ ,
Value
¹¹, 1
,
¹¹1 2
out
¹¹3 6
index
¹¹7 <
)
¹¹< =
)
¹¹= >
{
ºº 
shared
»» 
[
»» 
index
»» $
]
»»$ %
.
»»% &
Add
»»& )
(
»») *
kvp
»»* -
.
»»- .
Key
»». 1
)
»»1 2
;
»»2 3
}
¼¼ 
else
½½ 
{
¾¾ 
map
¿¿ 
.
¿¿ 
Add
¿¿ 
(
¿¿  
kvp
¿¿  #
.
¿¿# $
Value
¿¿$ )
,
¿¿) *
shared
¿¿+ 1
.
¿¿1 2
Count
¿¿2 7
)
¿¿7 8
;
¿¿8 9
shared
ÀÀ 
.
ÀÀ 
Add
ÀÀ "
(
ÀÀ" #
new
ÀÀ# &
List
ÀÀ' +
<
ÀÀ+ ,
int
ÀÀ, /
>
ÀÀ/ 0
(
ÀÀ0 1
)
ÀÀ1 2
{
ÀÀ3 4
kvp
ÀÀ5 8
.
ÀÀ8 9
Key
ÀÀ9 <
}
ÀÀ= >
)
ÀÀ> ?
;
ÀÀ? @
}
ÁÁ 
}
ÂÂ 
}
ÃÃ 
return
ÅÅ 
ToSharedVertices
ÅÅ #
(
ÅÅ# $
shared
ÅÅ$ *
)
ÅÅ* +
;
ÅÅ+ ,
}
ÆÆ 	
static
ÈÈ 
SharedVertex
ÈÈ 
[
ÈÈ 
]
ÈÈ 
ToSharedVertices
ÈÈ .
(
ÈÈ. /
List
ÈÈ/ 3
<
ÈÈ3 4
List
ÈÈ4 8
<
ÈÈ8 9
int
ÈÈ9 <
>
ÈÈ< =
>
ÈÈ= >
list
ÈÈ? C
)
ÈÈC D
{
ÉÉ 	
if
ÊÊ 
(
ÊÊ 
list
ÊÊ 
==
ÊÊ 
null
ÊÊ 
)
ÊÊ 
throw
ËË 
new
ËË #
ArgumentNullException
ËË /
(
ËË/ 0
$str
ËË0 6
)
ËË6 7
;
ËË7 8
SharedVertex
ÌÌ 
[
ÌÌ 
]
ÌÌ 
arr
ÌÌ 
=
ÌÌ  
new
ÌÌ! $
SharedVertex
ÌÌ% 1
[
ÌÌ1 2
list
ÌÌ2 6
.
ÌÌ6 7
Count
ÌÌ7 <
]
ÌÌ< =
;
ÌÌ= >
for
ÍÍ 
(
ÍÍ 
int
ÍÍ 
i
ÍÍ 
=
ÍÍ 
$num
ÍÍ 
;
ÍÍ 
i
ÍÍ 
<
ÍÍ 
arr
ÍÍ  #
.
ÍÍ# $
Length
ÍÍ$ *
;
ÍÍ* +
i
ÍÍ, -
++
ÍÍ- /
)
ÍÍ/ 0
arr
ÎÎ 
[
ÎÎ 
i
ÎÎ 
]
ÎÎ 
=
ÎÎ 
new
ÎÎ 
SharedVertex
ÎÎ )
(
ÎÎ) *
list
ÎÎ* .
[
ÎÎ. /
i
ÎÎ/ 0
]
ÎÎ0 1
)
ÎÎ1 2
;
ÎÎ2 3
return
ÏÏ 
arr
ÏÏ 
;
ÏÏ 
}
ĞĞ 	
public
ßß 
static
ßß 
SharedVertex
ßß "
[
ßß" #
]
ßß# $,
GetSharedVerticesWithPositions
ßß% C
(
ßßC D
IList
ßßD I
<
ßßI J
Vector3
ßßJ Q
>
ßßQ R
	positions
ßßS \
)
ßß\ ]
{
àà 	
if
áá 
(
áá 
	positions
áá 
==
áá 
null
áá !
)
áá! "
throw
ââ 
new
ââ #
ArgumentNullException
ââ /
(
ââ/ 0
$str
ââ0 ;
)
ââ; <
;
ââ< =

Dictionary
ää 
<
ää 
IntVec3
ää 
,
ää 
List
ää  $
<
ää$ %
int
ää% (
>
ää( )
>
ää) *
sorted
ää+ 1
=
ää2 3
new
ää4 7

Dictionary
ää8 B
<
ääB C
IntVec3
ääC J
,
ääJ K
List
ääL P
<
ääP Q
int
ääQ T
>
ääT U
>
ääU V
(
ääV W
)
ääW X
;
ääX Y
for
ææ 
(
ææ 
int
ææ 
i
ææ 
=
ææ 
$num
ææ 
;
ææ 
i
ææ 
<
ææ 
	positions
ææ  )
.
ææ) *
Count
ææ* /
;
ææ/ 0
i
ææ1 2
++
ææ2 4
)
ææ4 5
{
çç 
List
èè 
<
èè 
int
èè 
>
èè 
ind
èè 
;
èè 
if
éé 
(
éé 
sorted
éé 
.
éé 
TryGetValue
éé &
(
éé& '
	positions
éé' 0
[
éé0 1
i
éé1 2
]
éé2 3
,
éé3 4
out
éé5 8
ind
éé9 <
)
éé< =
)
éé= >
ind
êê 
.
êê 
Add
êê 
(
êê 
i
êê 
)
êê 
;
êê 
else
ëë 
sorted
ìì 
.
ìì 
Add
ìì 
(
ìì 
new
ìì "
IntVec3
ìì# *
(
ìì* +
	positions
ìì+ 4
[
ìì4 5
i
ìì5 6
]
ìì6 7
)
ìì7 8
,
ìì8 9
new
ìì: =
List
ìì> B
<
ììB C
int
ììC F
>
ììF G
(
ììG H
)
ììH I
{
ììJ K
i
ììL M
}
ììN O
)
ììO P
;
ììP Q
}
íí 
SharedVertex
ïï 
[
ïï 
]
ïï 
share
ïï  
=
ïï! "
new
ïï# &
SharedVertex
ïï' 3
[
ïï3 4
sorted
ïï4 :
.
ïï: ;
Count
ïï; @
]
ïï@ A
;
ïïA B
int
ññ 
t
ññ 
=
ññ 
$num
ññ 
;
ññ 
foreach
òò 
(
òò 
KeyValuePair
òò !
<
òò! "
IntVec3
òò" )
,
òò) *
List
òò+ /
<
òò/ 0
int
òò0 3
>
òò3 4
>
òò4 5
kvp
òò6 9
in
òò: <
sorted
òò= C
)
òòC D
share
óó 
[
óó 
t
óó 
++
óó 
]
óó 
=
óó 
new
óó  
SharedVertex
óó! -
(
óó- .
kvp
óó. 1
.
óó1 2
Value
óó2 7
.
óó7 8
ToArray
óó8 ?
(
óó? @
)
óó@ A
)
óóA B
;
óóB C
return
õõ 
share
õõ 
;
õõ 
}
öö 	
internal
øø 
static
øø 
SharedVertex
øø $
[
øø$ %
]
øø% &
RemoveAndShift
øø' 5
(
øø5 6

Dictionary
øø6 @
<
øø@ A
int
øøA D
,
øøD E
int
øøF I
>
øøI J
lookup
øøK Q
,
øøQ R
IEnumerable
øøS ^
<
øø^ _
int
øø_ b
>
øøb c
remove
øød j
)
øøj k
{
ùù 	
var
úú 
removedVertices
úú 
=
úú  !
new
úú" %
List
úú& *
<
úú* +
int
úú+ .
>
úú. /
(
úú/ 0
remove
úú0 6
)
úú6 7
;
úú7 8
removedVertices
ûû 
.
ûû 
Sort
ûû  
(
ûû  !
)
ûû! "
;
ûû" #
return
üü "
SortedRemoveAndShift
üü '
(
üü' (
lookup
üü( .
,
üü. /
removedVertices
üü0 ?
)
üü? @
;
üü@ A
}
ıı 	
internal
ÿÿ 
static
ÿÿ 
SharedVertex
ÿÿ $
[
ÿÿ$ %
]
ÿÿ% &"
SortedRemoveAndShift
ÿÿ' ;
(
ÿÿ; <

Dictionary
ÿÿ< F
<
ÿÿF G
int
ÿÿG J
,
ÿÿJ K
int
ÿÿL O
>
ÿÿO P
lookup
ÿÿQ W
,
ÿÿW X
List
ÿÿY ]
<
ÿÿ] ^
int
ÿÿ^ a
>
ÿÿa b
remove
ÿÿc i
)
ÿÿi j
{
€€ 	
foreach
 
(
 
int
 
i
 
in
 
remove
 $
)
$ %
lookup
‚‚ 
[
‚‚ 
i
‚‚ 
]
‚‚ 
=
‚‚ 
-
‚‚ 
$num
‚‚ 
;
‚‚ 
var
„„ 
shared
„„ 
=
„„ 
ToSharedVertices
„„ )
(
„„) *
lookup
„„* 0
.
„„0 1
Where
„„1 6
(
„„6 7
x
„„7 8
=>
„„9 ;
x
„„< =
.
„„= >
Value
„„> C
>
„„D E
-
„„F G
$num
„„G H
)
„„H I
)
„„I J
;
„„J K
for
†† 
(
†† 
int
†† 
i
†† 
=
†† 
$num
†† 
,
†† 
c
†† 
=
†† 
shared
††  &
.
††& '
Length
††' -
;
††- .
i
††/ 0
<
††1 2
c
††3 4
;
††4 5
i
††6 7
++
††7 9
)
††9 :
{
‡‡ 
for
ˆˆ 
(
ˆˆ 
int
ˆˆ 
n
ˆˆ 
=
ˆˆ 
$num
ˆˆ 
,
ˆˆ 
l
ˆˆ  !
=
ˆˆ" #
shared
ˆˆ$ *
[
ˆˆ* +
i
ˆˆ+ ,
]
ˆˆ, -
.
ˆˆ- .
Count
ˆˆ. 3
;
ˆˆ3 4
n
ˆˆ5 6
<
ˆˆ7 8
l
ˆˆ9 :
;
ˆˆ: ;
n
ˆˆ< =
++
ˆˆ= ?
)
ˆˆ? @
{
‰‰ 
int
ŠŠ 
index
ŠŠ 
=
ŠŠ 
ArrayUtility
ŠŠ  ,
.
ŠŠ, -&
NearestIndexPriorToValue
ŠŠ- E
(
ŠŠE F
remove
ŠŠF L
,
ŠŠL M
shared
ŠŠN T
[
ŠŠT U
i
ŠŠU V
]
ŠŠV W
[
ŠŠW X
n
ŠŠX Y
]
ŠŠY Z
)
ŠŠZ [
;
ŠŠ[ \
shared
ŒŒ 
[
ŒŒ 
i
ŒŒ 
]
ŒŒ 
[
ŒŒ 
n
ŒŒ 
]
ŒŒ  
-=
ŒŒ! #
index
ŒŒ$ )
+
ŒŒ* +
$num
ŒŒ, -
;
ŒŒ- .
}
 
}
 
return
 
shared
 
;
 
}
‘‘ 	
internal
““ 
static
““ 
void
““ 
SetCoincident
““ *
(
““* +
ref
““+ .

Dictionary
““/ 9
<
““9 :
int
““: =
,
““= >
int
““? B
>
““B C
lookup
““D J
,
““J K
IEnumerable
““L W
<
““W X
int
““X [
>
““[ \
vertices
““] e
)
““e f
{
”” 	
int
•• 
index
•• 
=
•• 
lookup
•• 
.
•• 
Count
•• $
;
••$ %
foreach
–– 
(
–– 
var
–– 
v
–– 
in
–– 
vertices
–– &
)
––& '
lookup
—— 
[
—— 
v
—— 
]
—— 
=
—— 
index
—— !
;
——! "
}
˜˜ 	
}
™™ 
}šš ú×
›D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\ElementSelection.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
public 

static 
class 
ElementSelection (
{ 
const		 
int		 
k_MaxHoleIterations		 %
=		& '
$num		( ,
;		, -
internal 
static 
List 
< 
SimpleTuple (
<( )
Face) -
,- .
Edge/ 3
>3 4
>4 5
GetNeighborFaces6 F
(F G
ProBuilderMeshG U
meshV Z
,Z [
Edge\ `
edgea e
)e f
{ 	
List 
< 
SimpleTuple 
< 
Face !
,! "
Edge# '
>' (
>( )
faces* /
=0 1
new2 5
List6 :
<: ;
SimpleTuple; F
<F G
FaceG K
,K L
EdgeM Q
>Q R
>R S
(S T
)T U
;U V
var 
lookup 
= 
mesh 
. 
sharedVertexLookup 0
;0 1
Edge 
uni 
= 
new 
Edge 
(  
lookup  &
[& '
edge' +
.+ ,
a, -
]- .
,. /
lookup0 6
[6 7
edge7 ;
.; <
b< =
]= >
)> ?
;? @
Edge 
e 
= 
new 
Edge 
( 
$num 
,  
$num! "
)" #
;# $
for 
( 
int 
i 
= 
$num 
; 
i 
< 
mesh  $
.$ %
facesInternal% 2
.2 3
Length3 9
;9 :
i; <
++< >
)> ?
{ 
Edge 
[ 
] 
edges 
= 
mesh #
.# $
facesInternal$ 1
[1 2
i2 3
]3 4
.4 5
edgesInternal5 B
;B C
for 
( 
int 
n 
= 
$num 
; 
n  !
<" #
edges$ )
.) *
Length* 0
;0 1
n2 3
++3 5
)5 6
{ 
e 
. 
a 
= 
edges 
[  
n  !
]! "
." #
a# $
;$ %
e 
. 
b 
= 
edges 
[  
n  !
]! "
." #
b# $
;$ %
if!! 
(!! 
(!! 
uni!! 
.!! 
a!! 
==!! !
lookup!!" (
[!!( )
e!!) *
.!!* +
a!!+ ,
]!!, -
&&!!. 0
uni!!1 4
.!!4 5
b!!5 6
==!!7 9
lookup!!: @
[!!@ A
e!!A B
.!!B C
b!!C D
]!!D E
)!!E F
||!!G I
("" 
uni"" 
."" 
a"" 
=="" !
lookup""" (
[""( )
e"") *
.""* +
b""+ ,
]"", -
&&"". 0
uni""1 4
.""4 5
b""5 6
==""7 9
lookup"": @
[""@ A
e""A B
.""B C
a""C D
]""D E
)""E F
)""F G
{## 
faces$$ 
.$$ 
Add$$ !
($$! "
new$$" %
SimpleTuple$$& 1
<$$1 2
Face$$2 6
,$$6 7
Edge$$8 <
>$$< =
($$= >
mesh$$> B
.$$B C
facesInternal$$C P
[$$P Q
i$$Q R
]$$R S
,$$S T
edges$$U Z
[$$Z [
n$$[ \
]$$\ ]
)$$] ^
)$$^ _
;$$_ `
break%% 
;%% 
}&& 
}'' 
}(( 
return)) 
faces)) 
;)) 
}** 	
internal22 
static22 
List22 
<22 
Face22 !
>22! "
GetNeighborFaces22# 3
(223 4
ProBuilderMesh224 B
mesh22C G
,22G H
int22I L
[22L M
]22M N
indexes22O V
)22V W
{33 	
var44 
lookup44 
=44 
mesh44 
.44 
sharedVertexLookup44 0
;440 1
List55 
<55 
Face55 
>55 
neighboring55 "
=55# $
new55% (
List55) -
<55- .
Face55. 2
>552 3
(553 4
)554 5
;555 6
HashSet66 
<66 
int66 
>66 
shared66 
=66  !
new66" %
HashSet66& -
<66- .
int66. 1
>661 2
(662 3
)663 4
;664 5
foreach88 
(88 
int88 
tri88 
in88 
indexes88  '
)88' (
shared99 
.99 
Add99 
(99 
lookup99 !
[99! "
tri99" %
]99% &
)99& '
;99' (
for;; 
(;; 
int;; 
i;; 
=;; 
$num;; 
;;; 
i;; 
<;; 
mesh;;  $
.;;$ %
facesInternal;;% 2
.;;2 3
Length;;3 9
;;;9 :
i;;; <
++;;< >
);;> ?
{<< 
int== 
[== 
]== 
dist== 
=== 
mesh== !
.==! "
facesInternal==" /
[==/ 0
i==0 1
]==1 2
.==2 3#
distinctIndexesInternal==3 J
;==J K
for?? 
(?? 
int?? 
n?? 
=?? 
$num?? 
;?? 
n??  !
<??" #
dist??$ (
.??( )
Length??) /
;??/ 0
n??1 2
++??2 4
)??4 5
{@@ 
ifAA 
(AA 
sharedAA 
.AA 
ContainsAA '
(AA' (
lookupAA( .
[AA. /
distAA/ 3
[AA3 4
nAA4 5
]AA5 6
]AA6 7
)AA7 8
)AA8 9
{BB 
neighboringCC #
.CC# $
AddCC$ '
(CC' (
meshCC( ,
.CC, -
facesInternalCC- :
[CC: ;
iCC; <
]CC< =
)CC= >
;CC> ?
breakDD 
;DD 
}EE 
}FF 
}GG 
returnII 
neighboringII 
;II 
}JJ 	
internalRR 
staticRR 
EdgeRR 
[RR 
]RR 
GetConnectedEdgesRR 0
(RR0 1
ProBuilderMeshRR1 ?
meshRR@ D
,RRD E
intRRF I
[RRI J
]RRJ K
indexesRRL S
)RRS T
{SS 	
varTT 
lookupTT 
=TT 
meshTT 
.TT 
sharedVertexLookupTT 0
;TT0 1
ListVV 
<VV 
EdgeVV 
>VV 
connectedEdgesVV %
=VV& '
newVV( +
ListVV, 0
<VV0 1
EdgeVV1 5
>VV5 6
(VV6 7
)VV7 8
;VV8 9
HashSetXX 
<XX 
intXX 
>XX 
sharedXX 
=XX  !
newXX" %
HashSetXX& -
<XX- .
intXX. 1
>XX1 2
(XX2 3
)XX3 4
;XX4 5
forZZ 
(ZZ 
intZZ 
iZZ 
=ZZ 
$numZZ 
;ZZ 
iZZ 
<ZZ 
indexesZZ  '
.ZZ' (
LengthZZ( .
;ZZ. /
iZZ0 1
++ZZ1 3
)ZZ3 4
shared[[ 
.[[ 
Add[[ 
([[ 
lookup[[ !
[[[! "
indexes[[" )
[[[) *
i[[* +
][[+ ,
][[, -
)[[- .
;[[. /
HashSet]] 
<]] 
Edge]] 
>]] 
used]] 
=]]  
new]]! $
HashSet]]% ,
<]], -
Edge]]- 1
>]]1 2
(]]2 3
)]]3 4
;]]4 5
Edge__ 
uni__ 
=__ 
new__ 
Edge__ 
(__  
$num__  !
,__! "
$num__# $
)__$ %
;__% &
foreachaa 
(aa 
varaa 
faceaa 
inaa  
meshaa! %
.aa% &
facesInternalaa& 3
)aa3 4
{bb 
foreachcc 
(cc 
varcc 
edgecc !
incc" $
facecc% )
.cc) *
edgescc* /
)cc/ 0
{dd 
Edgeee 
keyee 
=ee 
newee "
Edgeee# '
(ee' (
lookupee( .
[ee. /
edgeee/ 3
.ee3 4
aee4 5
]ee5 6
,ee6 7
lookupee8 >
[ee> ?
edgeee? C
.eeC D
beeD E
]eeE F
)eeF G
;eeG H
ifgg 
(gg 
sharedgg 
.gg 
Containsgg '
(gg' (
keygg( +
.gg+ ,
agg, -
)gg- .
||gg/ 1
sharedgg2 8
.gg8 9
Containsgg9 A
(ggA B
keyggB E
.ggE F
bggF G
)ggG H
&&ggI K
!ggL M
usedggM Q
.ggQ R
ContainsggR Z
(ggZ [
unigg[ ^
)gg^ _
)gg_ `
{hh 
connectedEdgesii &
.ii& '
Addii' *
(ii* +
edgeii+ /
)ii/ 0
;ii0 1
usedjj 
.jj 
Addjj  
(jj  !
keyjj! $
)jj$ %
;jj% &
}kk 
}ll 
}mm 
returnoo 
connectedEdgesoo !
.oo! "
ToArrayoo" )
(oo) *
)oo* +
;oo+ ,
}pp 	
publicxx 
staticxx 
IEnumerablexx !
<xx! "
Edgexx" &
>xx& '
GetPerimeterEdgesxx( 9
(xx9 :
thisxx: >
ProBuilderMeshxx? M
meshxxN R
,xxR S
IEnumerablexxT _
<xx_ `
Facexx` d
>xxd e
facesxxf k
)xxk l
{yy 	
ifzz 
(zz 
meshzz 
==zz 
nullzz 
)zz 
throw{{ 
new{{ !
ArgumentNullException{{ /
({{/ 0
$str{{0 6
){{6 7
;{{7 8
if}} 
(}} 
faces}} 
==}} 
null}} 
)}} 
throw~~ 
new~~ !
ArgumentNullException~~ /
(~~/ 0
$str~~0 7
)~~7 8
;~~8 9
List
€€ 
<
€€ 
Edge
€€ 
>
€€ 
	faceEdges
€€  
=
€€! "
faces
€€# (
.
€€( )

SelectMany
€€) 3
(
€€3 4
x
€€4 5
=>
€€6 8
x
€€9 :
.
€€: ;
edgesInternal
€€; H
)
€€H I
.
€€I J
ToList
€€J P
(
€€P Q
)
€€Q R
;
€€R S
var
 %
sharedIndexesDictionary
 '
=
( )
mesh
* .
.
. / 
sharedVertexLookup
/ A
;
A B
int
‚‚ 
	edgeCount
‚‚ 
=
‚‚ 
	faceEdges
‚‚ %
.
‚‚% &
Count
‚‚& +
;
‚‚+ ,

Dictionary
…… 
<
…… 
Edge
…… 
,
…… 
List
…… !
<
……! "
Edge
……" &
>
……& '
>
……' (
dup
……) ,
=
……- .
new
……/ 2

Dictionary
……3 =
<
……= >
Edge
……> B
,
……B C
List
……D H
<
……H I
Edge
……I M
>
……M N
>
……N O
(
……O P
)
……P Q
;
……Q R
List
†† 
<
†† 
Edge
†† 
>
†† 
list
†† 
;
†† 
for
ˆˆ 
(
ˆˆ 
int
ˆˆ 
i
ˆˆ 
=
ˆˆ 
$num
ˆˆ 
;
ˆˆ 
i
ˆˆ 
<
ˆˆ 
	edgeCount
ˆˆ  )
;
ˆˆ) *
i
ˆˆ+ ,
++
ˆˆ, .
)
ˆˆ. /
{
‰‰ 
Edge
ŠŠ 
uni
ŠŠ 
=
ŠŠ 
new
ŠŠ 
Edge
ŠŠ #
(
ŠŠ# $%
sharedIndexesDictionary
ŠŠ$ ;
[
ŠŠ; <
	faceEdges
ŠŠ< E
[
ŠŠE F
i
ŠŠF G
]
ŠŠG H
.
ŠŠH I
a
ŠŠI J
]
ŠŠJ K
,
ŠŠK L%
sharedIndexesDictionary
ŠŠM d
[
ŠŠd e
	faceEdges
ŠŠe n
[
ŠŠn o
i
ŠŠo p
]
ŠŠp q
.
ŠŠq r
b
ŠŠr s
]
ŠŠs t
)
ŠŠt u
;
ŠŠu v
if
ŒŒ 
(
ŒŒ 
dup
ŒŒ 
.
ŒŒ 
TryGetValue
ŒŒ #
(
ŒŒ# $
uni
ŒŒ$ '
,
ŒŒ' (
out
ŒŒ) ,
list
ŒŒ- 1
)
ŒŒ1 2
)
ŒŒ2 3
list
 
.
 
Add
 
(
 
	faceEdges
 &
[
& '
i
' (
]
( )
)
) *
;
* +
else
 
dup
 
.
 
Add
 
(
 
uni
 
,
  
new
! $
List
% )
<
) *
Edge
* .
>
. /
(
/ 0
)
0 1
{
2 3
	faceEdges
4 =
[
= >
i
> ?
]
? @
}
A B
)
B C
;
C D
}
 
return
’’ 
dup
’’ 
.
’’ 
Where
’’ 
(
’’ 
x
’’ 
=>
’’ !
x
’’" #
.
’’# $
Value
’’$ )
.
’’) *
Count
’’* /
<
’’0 1
$num
’’2 3
)
’’3 4
.
’’4 5
Select
’’5 ;
(
’’; <
x
’’< =
=>
’’> @
x
’’A B
.
’’B C
Value
’’C H
[
’’H I
$num
’’I J
]
’’J K
)
’’K L
;
’’L M
}
““ 	
internal
›› 
static
›› 
int
›› 
[
›› 
]
›› 
GetPerimeterEdges
›› /
(
››/ 0
ProBuilderMesh
››0 >
mesh
››? C
,
››C D
IList
››E J
<
››J K
Edge
››K O
>
››O P
edges
››Q V
)
››V W
{
œœ 	
int
 
	edgeCount
 
=
 
edges
 !
!=
" $
null
% )
?
* +
edges
, 1
.
1 2
Count
2 7
:
8 9
$num
: ;
;
; <
var
   
	universal
   
=
   
mesh
    
.
    !(
GetSharedVertexHandleEdges
  ! ;
(
  ; <
edges
  < A
)
  A B
.
  B C
ToArray
  C J
(
  J K
)
  K L
;
  L M
int
¢¢ 
[
¢¢ 
]
¢¢ 
connections
¢¢ 
=
¢¢ 
new
¢¢  #
int
¢¢$ '
[
¢¢' (
	universal
¢¢( 1
.
¢¢1 2
Length
¢¢2 8
]
¢¢8 9
;
¢¢9 :
for
¤¤ 
(
¤¤ 
int
¤¤ 
i
¤¤ 
=
¤¤ 
$num
¤¤ 
;
¤¤ 
i
¤¤ 
<
¤¤ 
	universal
¤¤  )
.
¤¤) *
Length
¤¤* 0
-
¤¤1 2
$num
¤¤3 4
;
¤¤4 5
i
¤¤6 7
++
¤¤7 9
)
¤¤9 :
{
¥¥ 
for
¦¦ 
(
¦¦ 
int
¦¦ 
n
¦¦ 
=
¦¦ 
i
¦¦ 
+
¦¦  
$num
¦¦! "
;
¦¦" #
n
¦¦$ %
<
¦¦& '
	universal
¦¦( 1
.
¦¦1 2
Length
¦¦2 8
;
¦¦8 9
n
¦¦: ;
++
¦¦; =
)
¦¦= >
{
§§ 
if
¨¨ 
(
¨¨ 
	universal
¨¨ !
[
¨¨! "
i
¨¨" #
]
¨¨# $
.
¨¨$ %
a
¨¨% &
==
¨¨' )
	universal
¨¨* 3
[
¨¨3 4
n
¨¨4 5
]
¨¨5 6
.
¨¨6 7
a
¨¨7 8
||
¨¨9 ;
	universal
¨¨< E
[
¨¨E F
i
¨¨F G
]
¨¨G H
.
¨¨H I
a
¨¨I J
==
¨¨K M
	universal
¨¨N W
[
¨¨W X
n
¨¨X Y
]
¨¨Y Z
.
¨¨Z [
b
¨¨[ \
||
¨¨] _
	universal
©© !
[
©©! "
i
©©" #
]
©©# $
.
©©$ %
b
©©% &
==
©©' )
	universal
©©* 3
[
©©3 4
n
©©4 5
]
©©5 6
.
©©6 7
a
©©7 8
||
©©9 ;
	universal
©©< E
[
©©E F
i
©©F G
]
©©G H
.
©©H I
b
©©I J
==
©©K M
	universal
©©N W
[
©©W X
n
©©X Y
]
©©Y Z
.
©©Z [
b
©©[ \
)
©©\ ]
{
ªª 
connections
«« #
[
««# $
i
««$ %
]
««% &
++
««& (
;
««( )
connections
¬¬ #
[
¬¬# $
n
¬¬$ %
]
¬¬% &
++
¬¬& (
;
¬¬( )
}
­­ 
}
®® 
}
¯¯ 
int
±± 
min
±± 
=
±± 
Math
±± 
.
±± 
Min
±± 
(
±± 
connections
±± *
)
±±* +
;
±±+ ,
List
²² 
<
²² 
int
²² 
>
²² 
	perimeter
²² 
=
²²  !
new
²²" %
List
²²& *
<
²²* +
int
²²+ .
>
²². /
(
²²/ 0
)
²²0 1
;
²²1 2
for
´´ 
(
´´ 
int
´´ 
i
´´ 
=
´´ 
$num
´´ 
;
´´ 
i
´´ 
<
´´ 
connections
´´  +
.
´´+ ,
Length
´´, 2
;
´´2 3
i
´´4 5
++
´´5 7
)
´´7 8
{
µµ 
if
¶¶ 
(
¶¶ 
connections
¶¶ 
[
¶¶  
i
¶¶  !
]
¶¶! "
<=
¶¶# %
min
¶¶& )
)
¶¶) *
	perimeter
·· 
.
·· 
Add
·· !
(
··! "
i
··" #
)
··# $
;
··$ %
}
¸¸ 
return
ºº 
	perimeter
ºº 
.
ºº 
Count
ºº "
!=
ºº# %
	edgeCount
ºº& /
?
ºº0 1
	perimeter
ºº2 ;
.
ºº; <
ToArray
ºº< C
(
ººC D
)
ººD E
:
ººF G
new
ººH K
int
ººL O
[
ººO P
]
ººP Q
{
ººR S
}
ººS T
;
ººT U
}
»» 	
internal
ÃÃ 
static
ÃÃ 
IEnumerable
ÃÃ #
<
ÃÃ# $
Face
ÃÃ$ (
>
ÃÃ( )
GetPerimeterFaces
ÃÃ* ;
(
ÃÃ; <
ProBuilderMesh
ÃÃ< J
mesh
ÃÃK O
,
ÃÃO P
IEnumerable
ÃÃQ \
<
ÃÃ\ ]
Face
ÃÃ] a
>
ÃÃa b
faces
ÃÃc h
)
ÃÃh i
{
ÄÄ 	
var
ÅÅ 
lookup
ÅÅ 
=
ÅÅ 
mesh
ÅÅ 
.
ÅÅ  
sharedVertexLookup
ÅÅ 0
;
ÅÅ0 1

Dictionary
ÆÆ 
<
ÆÆ 
Edge
ÆÆ 
,
ÆÆ 
List
ÆÆ !
<
ÆÆ! "
Face
ÆÆ" &
>
ÆÆ& '
>
ÆÆ' (
sharedEdges
ÆÆ) 4
=
ÆÆ5 6
new
ÆÆ7 :

Dictionary
ÆÆ; E
<
ÆÆE F
Edge
ÆÆF J
,
ÆÆJ K
List
ÆÆL P
<
ÆÆP Q
Face
ÆÆQ U
>
ÆÆU V
>
ÆÆV W
(
ÆÆW X
)
ÆÆX Y
;
ÆÆY Z
foreach
ÍÍ 
(
ÍÍ 
Face
ÍÍ 
face
ÍÍ 
in
ÍÍ !
faces
ÍÍ" '
)
ÍÍ' (
{
ÎÎ 
foreach
ÏÏ 
(
ÏÏ 
Edge
ÏÏ 
e
ÏÏ 
in
ÏÏ  "
face
ÏÏ# '
.
ÏÏ' (
edgesInternal
ÏÏ( 5
)
ÏÏ5 6
{
ĞĞ 
Edge
ÑÑ 
edge
ÑÑ 
=
ÑÑ 
new
ÑÑ  #
Edge
ÑÑ$ (
(
ÑÑ( )
lookup
ÑÑ) /
[
ÑÑ/ 0
e
ÑÑ0 1
.
ÑÑ1 2
a
ÑÑ2 3
]
ÑÑ3 4
,
ÑÑ4 5
lookup
ÑÑ6 <
[
ÑÑ< =
e
ÑÑ= >
.
ÑÑ> ?
b
ÑÑ? @
]
ÑÑ@ A
)
ÑÑA B
;
ÑÑB C
if
ÓÓ 
(
ÓÓ 
sharedEdges
ÓÓ #
.
ÓÓ# $
ContainsKey
ÓÓ$ /
(
ÓÓ/ 0
edge
ÓÓ0 4
)
ÓÓ4 5
)
ÓÓ5 6
sharedEdges
ÔÔ #
[
ÔÔ# $
edge
ÔÔ$ (
]
ÔÔ( )
.
ÔÔ) *
Add
ÔÔ* -
(
ÔÔ- .
face
ÔÔ. 2
)
ÔÔ2 3
;
ÔÔ3 4
else
ÕÕ 
sharedEdges
ÖÖ #
.
ÖÖ# $
Add
ÖÖ$ '
(
ÖÖ' (
edge
ÖÖ( ,
,
ÖÖ, -
new
ÖÖ. 1
List
ÖÖ2 6
<
ÖÖ6 7
Face
ÖÖ7 ;
>
ÖÖ; <
(
ÖÖ< =
)
ÖÖ= >
{
ÖÖ? @
face
ÖÖA E
}
ÖÖF G
)
ÖÖG H
;
ÖÖH I
}
×× 
}
ØØ 
return
ÚÚ 
sharedEdges
ÚÚ 
.
ÚÚ 
Where
ÚÚ $
(
ÚÚ$ %
x
ÚÚ% &
=>
ÚÚ' )
x
ÚÚ* +
.
ÚÚ+ ,
Value
ÚÚ, 1
.
ÚÚ1 2
Count
ÚÚ2 7
<
ÚÚ8 9
$num
ÚÚ: ;
)
ÚÚ; <
.
ÚÚ< =
Select
ÚÚ= C
(
ÚÚC D
x
ÚÚD E
=>
ÚÚF H
x
ÚÚI J
.
ÚÚJ K
Value
ÚÚK P
[
ÚÚP Q
$num
ÚÚQ R
]
ÚÚR S
)
ÚÚS T
.
ÚÚT U
Distinct
ÚÚU ]
(
ÚÚ] ^
)
ÚÚ^ _
;
ÚÚ_ `
}
ÛÛ 	
internal
İİ 
static
İİ 
int
İİ 
[
İİ 
]
İİ "
GetPerimeterVertices
İİ 2
(
İİ2 3
ProBuilderMesh
İİ3 A
mesh
İİB F
,
İİF G
int
İİH K
[
İİK L
]
İİL M
indexes
İİN U
,
İİU V
Edge
İİW [
[
İİ[ \
]
İİ\ ]!
universal_edges_all
İİ^ q
)
İİq r
{
ŞŞ 	
int
ßß 
len
ßß 
=
ßß 
indexes
ßß 
.
ßß 
Length
ßß $
;
ßß$ %
SharedVertex
àà 
[
àà 
]
àà 
sharedIndexes
àà (
=
àà) *
mesh
àà+ /
.
àà/ 0$
sharedVerticesInternal
àà0 F
;
ààF G
int
áá 
[
áá 
]
áá 
	universal
áá 
=
áá 
new
áá !
int
áá" %
[
áá% &
len
áá& )
]
áá) *
;
áá* +
for
ãã 
(
ãã 
int
ãã 
i
ãã 
=
ãã 
$num
ãã 
;
ãã 
i
ãã 
<
ãã 
len
ãã  #
;
ãã# $
i
ãã% &
++
ãã& (
)
ãã( )
	universal
ää 
[
ää 
i
ää 
]
ää 
=
ää 
mesh
ää #
.
ää# $#
GetSharedVertexHandle
ää$ 9
(
ää9 :
indexes
ää: A
[
ääA B
i
ääB C
]
ääC D
)
ääD E
;
ääE F
int
ææ 
[
ææ 
]
ææ 
connections
ææ 
=
ææ 
new
ææ  #
int
ææ$ '
[
ææ' (
indexes
ææ( /
.
ææ/ 0
Length
ææ0 6
]
ææ6 7
;
ææ7 8
for
èè 
(
èè 
int
èè 
i
èè 
=
èè 
$num
èè 
;
èè 
i
èè 
<
èè 
indexes
èè  '
.
èè' (
Length
èè( .
-
èè/ 0
$num
èè1 2
;
èè2 3
i
èè4 5
++
èè5 7
)
èè7 8
{
éé 
for
êê 
(
êê 
int
êê 
n
êê 
=
êê 
i
êê 
+
êê  
$num
êê! "
;
êê" #
n
êê$ %
<
êê& '
indexes
êê( /
.
êê/ 0
Length
êê0 6
;
êê6 7
n
êê8 9
++
êê9 ;
)
êê; <
{
ëë 
if
ìì 
(
ìì !
universal_edges_all
ìì +
.
ìì+ ,
Contains
ìì, 4
(
ìì4 5
	universal
ìì5 >
[
ìì> ?
i
ìì? @
]
ìì@ A
,
ììA B
	universal
ììC L
[
ììL M
n
ììM N
]
ììN O
)
ììO P
)
ììP Q
{
íí 
connections
îî #
[
îî# $
i
îî$ %
]
îî% &
++
îî& (
;
îî( )
connections
ïï #
[
ïï# $
n
ïï$ %
]
ïï% &
++
ïï& (
;
ïï( )
}
ğğ 
}
ññ 
}
òò 
int
ôô 
min
ôô 
=
ôô 
Math
ôô 
.
ôô 
Min
ôô 
(
ôô 
connections
ôô *
)
ôô* +
;
ôô+ ,
List
õõ 
<
õõ 
int
õõ 
>
õõ 
	perimeter
õõ 
=
õõ  !
new
õõ" %
List
õõ& *
<
õõ* +
int
õõ+ .
>
õõ. /
(
õõ/ 0
)
õõ0 1
;
õõ1 2
for
öö 
(
öö 
int
öö 
i
öö 
=
öö 
$num
öö 
;
öö 
i
öö 
<
öö 
len
öö  #
;
öö# $
i
öö% &
++
öö& (
)
öö( )
{
÷÷ 
if
øø 
(
øø 
connections
øø 
[
øø  
i
øø  !
]
øø! "
<=
øø# %
min
øø& )
)
øø) *
	perimeter
ùù 
.
ùù 
Add
ùù !
(
ùù! "
i
ùù" #
)
ùù# $
;
ùù$ %
}
úú 
return
üü 
	perimeter
üü 
.
üü 
Count
üü "
<
üü# $
len
üü% (
?
üü) *
	perimeter
üü+ 4
.
üü4 5
ToArray
üü5 <
(
üü< =
)
üü= >
:
üü? @
new
üüA D
int
üüE H
[
üüH I
]
üüI J
{
üüK L
}
üüL M
;
üüM N
}
ıı 	
static
ÿÿ 

WingedEdge
ÿÿ 
EdgeRingNext
ÿÿ &
(
ÿÿ& '

WingedEdge
ÿÿ' 1
edge
ÿÿ2 6
)
ÿÿ6 7
{
€€ 	
if
 
(
 
edge
 
==
 
null
 
)
 
return
‚‚ 
null
‚‚ 
;
‚‚ 

WingedEdge
„„ 
next
„„ 
=
„„ 
edge
„„ "
.
„„" #
next
„„# '
,
„„' (
prev
„„) -
=
„„. /
edge
„„0 4
.
„„4 5
previous
„„5 =
;
„„= >
int
…… 
i
…… 
=
…… 
$num
…… 
;
…… 
while
‡‡ 
(
‡‡ 
next
‡‡ 
!=
‡‡ 
prev
‡‡ 
&&
‡‡  "
next
‡‡# '
!=
‡‡( *
edge
‡‡+ /
)
‡‡/ 0
{
ˆˆ 
next
‰‰ 
=
‰‰ 
next
‰‰ 
.
‰‰ 
next
‰‰  
;
‰‰  !
if
‹‹ 
(
‹‹ 
next
‹‹ 
==
‹‹ 
prev
‹‹  
)
‹‹  !
return
ŒŒ 
null
ŒŒ 
;
ŒŒ  
prev
 
=
 
prev
 
.
 
previous
 $
;
$ %
i
 
++
 
;
 
}
‘‘ 
if
““ 
(
““ 
i
““ 
%
““ 
$num
““ 
==
““ 
$num
““ 
||
““ 
next
““ "
==
““# %
edge
““& *
)
““* +
next
”” 
=
”” 
null
”” 
;
”” 
return
–– 
next
–– 
;
–– 
}
—— 	
internal
ŸŸ 
static
ŸŸ 
IEnumerable
ŸŸ #
<
ŸŸ# $
Edge
ŸŸ$ (
>
ŸŸ( )
GetEdgeRing
ŸŸ* 5
(
ŸŸ5 6
ProBuilderMesh
ŸŸ6 D
pb
ŸŸE G
,
ŸŸG H
IEnumerable
ŸŸI T
<
ŸŸT U
Edge
ŸŸU Y
>
ŸŸY Z
edges
ŸŸ[ `
)
ŸŸ` a
{
   	
List
¡¡ 
<
¡¡ 

WingedEdge
¡¡ 
>
¡¡ 
wings
¡¡ "
=
¡¡# $

WingedEdge
¡¡% /
.
¡¡/ 0
GetWingedEdges
¡¡0 >
(
¡¡> ?
pb
¡¡? A
)
¡¡A B
;
¡¡B C
List
¢¢ 
<
¢¢ 

EdgeLookup
¢¢ 
>
¢¢ 

edgeLookup
¢¢ '
=
¢¢( )

EdgeLookup
¢¢* 4
.
¢¢4 5
GetEdgeLookup
¢¢5 B
(
¢¢B C
edges
¢¢C H
,
¢¢H I
pb
¢¢J L
.
¢¢L M 
sharedVertexLookup
¢¢M _
)
¢¢_ `
.
¢¢` a
ToList
¢¢a g
(
¢¢g h
)
¢¢h i
;
¢¢i j

edgeLookup
££ 
=
££ 

edgeLookup
££ #
.
££# $
Distinct
££$ ,
(
££, -
)
££- .
.
££. /
ToList
££/ 5
(
££5 6
)
££6 7
;
££7 8

Dictionary
¥¥ 
<
¥¥ 
Edge
¥¥ 
,
¥¥ 

WingedEdge
¥¥ '
>
¥¥' (
	wings_dic
¥¥) 2
=
¥¥3 4
new
¥¥5 8

Dictionary
¥¥9 C
<
¥¥C D
Edge
¥¥D H
,
¥¥H I

WingedEdge
¥¥J T
>
¥¥T U
(
¥¥U V
)
¥¥V W
;
¥¥W X
for
§§ 
(
§§ 
int
§§ 
i
§§ 
=
§§ 
$num
§§ 
;
§§ 
i
§§ 
<
§§ 
wings
§§  %
.
§§% &
Count
§§& +
;
§§+ ,
i
§§- .
++
§§. 0
)
§§0 1
if
¨¨ 
(
¨¨ 
!
¨¨ 
	wings_dic
¨¨ 
.
¨¨ 
ContainsKey
¨¨ *
(
¨¨* +
wings
¨¨+ 0
[
¨¨0 1
i
¨¨1 2
]
¨¨2 3
.
¨¨3 4
edge
¨¨4 8
.
¨¨8 9
common
¨¨9 ?
)
¨¨? @
)
¨¨@ A
	wings_dic
©© 
.
©© 
Add
©© !
(
©©! "
wings
©©" '
[
©©' (
i
©©( )
]
©©) *
.
©©* +
edge
©©+ /
.
©©/ 0
common
©©0 6
,
©©6 7
wings
©©8 =
[
©©= >
i
©©> ?
]
©©? @
)
©©@ A
;
©©A B
HashSet
«« 
<
«« 

EdgeLookup
«« 
>
«« 
used
««  $
=
««% &
new
««' *
HashSet
««+ 2
<
««2 3

EdgeLookup
««3 =
>
««= >
(
««> ?
)
««? @
;
««@ A
for
­­ 
(
­­ 
int
­­ 
i
­­ 
=
­­ 
$num
­­ 
,
­­ 
c
­­ 
=
­­ 

edgeLookup
­­  *
.
­­* +
Count
­­+ 0
;
­­0 1
i
­­2 3
<
­­4 5
c
­­6 7
;
­­7 8
i
­­9 :
++
­­: <
)
­­< =
{
®® 

WingedEdge
¯¯ 
we
¯¯ 
;
¯¯ 
if
±± 
(
±± 
!
±± 
	wings_dic
±± 
.
±± 
TryGetValue
±± *
(
±±* +

edgeLookup
±±+ 5
[
±±5 6
i
±±6 7
]
±±7 8
.
±±8 9
common
±±9 ?
,
±±? @
out
±±A D
we
±±E G
)
±±G H
||
±±I K
used
±±L P
.
±±P Q
Contains
±±Q Y
(
±±Y Z
we
±±Z \
.
±±\ ]
edge
±±] a
)
±±a b
)
±±b c
continue
²² 
;
²² 

WingedEdge
´´ 
cur
´´ 
=
´´  
we
´´! #
;
´´# $
while
¶¶ 
(
¶¶ 
cur
¶¶ 
!=
¶¶ 
null
¶¶ "
)
¶¶" #
{
·· 
if
¸¸ 
(
¸¸ 
!
¸¸ 
used
¸¸ 
.
¸¸ 
Add
¸¸ !
(
¸¸! "
cur
¸¸" %
.
¸¸% &
edge
¸¸& *
)
¸¸* +
)
¸¸+ ,
break
¸¸- 2
;
¸¸2 3
cur
¹¹ 
=
¹¹ 
EdgeRingNext
¹¹ &
(
¹¹& '
cur
¹¹' *
)
¹¹* +
;
¹¹+ ,
if
ºº 
(
ºº 
cur
ºº 
!=
ºº 
null
ºº #
&&
ºº$ &
cur
ºº' *
.
ºº* +
opposite
ºº+ 3
!=
ºº4 6
null
ºº7 ;
)
ºº; <
cur
ºº= @
=
ººA B
cur
ººC F
.
ººF G
opposite
ººG O
;
ººO P
}
»» 
cur
½½ 
=
½½ 
EdgeRingNext
½½ "
(
½½" #
we
½½# %
.
½½% &
opposite
½½& .
)
½½. /
;
½½/ 0
if
¾¾ 
(
¾¾ 
cur
¾¾ 
!=
¾¾ 
null
¾¾ 
&&
¾¾  "
cur
¾¾# &
.
¾¾& '
opposite
¾¾' /
!=
¾¾0 2
null
¾¾3 7
)
¾¾7 8
cur
¾¾9 <
=
¾¾= >
cur
¾¾? B
.
¾¾B C
opposite
¾¾C K
;
¾¾K L
while
ÁÁ 
(
ÁÁ 
cur
ÁÁ 
!=
ÁÁ 
null
ÁÁ "
)
ÁÁ" #
{
ÂÂ 
if
ÃÃ 
(
ÃÃ 
!
ÃÃ 
used
ÃÃ 
.
ÃÃ 
Add
ÃÃ !
(
ÃÃ! "
cur
ÃÃ" %
.
ÃÃ% &
edge
ÃÃ& *
)
ÃÃ* +
)
ÃÃ+ ,
break
ÃÃ- 2
;
ÃÃ2 3
cur
ÄÄ 
=
ÄÄ 
EdgeRingNext
ÄÄ &
(
ÄÄ& '
cur
ÄÄ' *
)
ÄÄ* +
;
ÄÄ+ ,
if
ÅÅ 
(
ÅÅ 
cur
ÅÅ 
!=
ÅÅ 
null
ÅÅ #
&&
ÅÅ$ &
cur
ÅÅ' *
.
ÅÅ* +
opposite
ÅÅ+ 3
!=
ÅÅ4 6
null
ÅÅ7 ;
)
ÅÅ; <
cur
ÅÅ= @
=
ÅÅA B
cur
ÅÅC F
.
ÅÅF G
opposite
ÅÅG O
;
ÅÅO P
}
ÆÆ 
}
ÇÇ 
return
ÉÉ 
used
ÉÉ 
.
ÉÉ 
Select
ÉÉ 
(
ÉÉ 
x
ÉÉ  
=>
ÉÉ! #
x
ÉÉ$ %
.
ÉÉ% &
local
ÉÉ& +
)
ÉÉ+ ,
;
ÉÉ, -
}
ÊÊ 	
internal
ÒÒ 
static
ÒÒ 
IEnumerable
ÒÒ #
<
ÒÒ# $
Edge
ÒÒ$ (
>
ÒÒ( )"
GetEdgeRingIterative
ÒÒ* >
(
ÒÒ> ?
ProBuilderMesh
ÒÒ? M
pb
ÒÒN P
,
ÒÒP Q
IEnumerable
ÒÒR ]
<
ÒÒ] ^
Edge
ÒÒ^ b
>
ÒÒb c
edges
ÒÒd i
)
ÒÒi j
{
ÓÓ 	
List
ÔÔ 
<
ÔÔ 

WingedEdge
ÔÔ 
>
ÔÔ 
wings
ÔÔ "
=
ÔÔ# $

WingedEdge
ÔÔ% /
.
ÔÔ/ 0
GetWingedEdges
ÔÔ0 >
(
ÔÔ> ?
pb
ÔÔ? A
)
ÔÔA B
;
ÔÔB C
List
ÕÕ 
<
ÕÕ 

EdgeLookup
ÕÕ 
>
ÕÕ 

edgeLookup
ÕÕ '
=
ÕÕ( )

EdgeLookup
ÕÕ* 4
.
ÕÕ4 5
GetEdgeLookup
ÕÕ5 B
(
ÕÕB C
edges
ÕÕC H
,
ÕÕH I
pb
ÕÕJ L
.
ÕÕL M 
sharedVertexLookup
ÕÕM _
)
ÕÕ_ `
.
ÕÕ` a
ToList
ÕÕa g
(
ÕÕg h
)
ÕÕh i
;
ÕÕi j

edgeLookup
ÖÖ 
=
ÖÖ 

edgeLookup
ÖÖ #
.
ÖÖ# $
Distinct
ÖÖ$ ,
(
ÖÖ, -
)
ÖÖ- .
.
ÖÖ. /
ToList
ÖÖ/ 5
(
ÖÖ5 6
)
ÖÖ6 7
;
ÖÖ7 8

Dictionary
ØØ 
<
ØØ 
Edge
ØØ 
,
ØØ 

WingedEdge
ØØ '
>
ØØ' (
	wings_dic
ØØ) 2
=
ØØ3 4
new
ØØ5 8

Dictionary
ØØ9 C
<
ØØC D
Edge
ØØD H
,
ØØH I

WingedEdge
ØØJ T
>
ØØT U
(
ØØU V
)
ØØV W
;
ØØW X
for
ÚÚ 
(
ÚÚ 
int
ÚÚ 
i
ÚÚ 
=
ÚÚ 
$num
ÚÚ 
;
ÚÚ 
i
ÚÚ 
<
ÚÚ 
wings
ÚÚ  %
.
ÚÚ% &
Count
ÚÚ& +
;
ÚÚ+ ,
i
ÚÚ- .
++
ÚÚ. 0
)
ÚÚ0 1
if
ÛÛ 
(
ÛÛ 
!
ÛÛ 
	wings_dic
ÛÛ 
.
ÛÛ 
ContainsKey
ÛÛ *
(
ÛÛ* +
wings
ÛÛ+ 0
[
ÛÛ0 1
i
ÛÛ1 2
]
ÛÛ2 3
.
ÛÛ3 4
edge
ÛÛ4 8
.
ÛÛ8 9
common
ÛÛ9 ?
)
ÛÛ? @
)
ÛÛ@ A
	wings_dic
ÜÜ 
.
ÜÜ 
Add
ÜÜ !
(
ÜÜ! "
wings
ÜÜ" '
[
ÜÜ' (
i
ÜÜ( )
]
ÜÜ) *
.
ÜÜ* +
edge
ÜÜ+ /
.
ÜÜ/ 0
common
ÜÜ0 6
,
ÜÜ6 7
wings
ÜÜ8 =
[
ÜÜ= >
i
ÜÜ> ?
]
ÜÜ? @
)
ÜÜ@ A
;
ÜÜA B
HashSet
ŞŞ 
<
ŞŞ 

EdgeLookup
ŞŞ 
>
ŞŞ 
used
ŞŞ  $
=
ŞŞ% &
new
ŞŞ' *
HashSet
ŞŞ+ 2
<
ŞŞ2 3

EdgeLookup
ŞŞ3 =
>
ŞŞ= >
(
ŞŞ> ?
)
ŞŞ? @
;
ŞŞ@ A
for
àà 
(
àà 
int
àà 
i
àà 
=
àà 
$num
àà 
,
àà 
c
àà 
=
àà 

edgeLookup
àà  *
.
àà* +
Count
àà+ 0
;
àà0 1
i
àà2 3
<
àà4 5
c
àà6 7
;
àà7 8
i
àà9 :
++
àà: <
)
àà< =
{
áá 

WingedEdge
ââ 
we
ââ 
;
ââ 
if
ää 
(
ää 
!
ää 
	wings_dic
ää 
.
ää 
TryGetValue
ää *
(
ää* +

edgeLookup
ää+ 5
[
ää5 6
i
ää6 7
]
ää7 8
.
ää8 9
common
ää9 ?
,
ää? @
out
ääA D
we
ääE G
)
ääG H
)
ääH I
continue
åå 
;
åå 

WingedEdge
çç 
cur
çç 
=
çç  
we
çç! #
;
çç# $
if
éé 
(
éé 
!
éé 
used
éé 
.
éé 
Contains
éé "
(
éé" #
cur
éé# &
.
éé& '
edge
éé' +
)
éé+ ,
)
éé, -
used
êê 
.
êê 
Add
êê 
(
êê 
cur
êê  
.
êê  !
edge
êê! %
)
êê% &
;
êê& '
var
ëë 
next
ëë 
=
ëë 
EdgeRingNext
ëë '
(
ëë' (
cur
ëë( +
)
ëë+ ,
;
ëë, -
if
ìì 
(
ìì 
next
ìì 
!=
ìì 
null
ìì  
&&
ìì! #
next
ìì$ (
.
ìì( )
opposite
ìì) 1
!=
ìì2 4
null
ìì5 9
&&
ìì: <
!
ìì= >
used
ìì> B
.
ììB C
Contains
ììC K
(
ììK L
next
ììL P
.
ììP Q
edge
ììQ U
)
ììU V
)
ììV W
used
íí 
.
íí 
Add
íí 
(
íí 
next
íí !
.
íí! "
edge
íí" &
)
íí& '
;
íí' (
var
îî 
prev
îî 
=
îî 
EdgeRingNext
îî '
(
îî' (
cur
îî( +
.
îî+ ,
opposite
îî, 4
)
îî4 5
;
îî5 6
if
ïï 
(
ïï 
prev
ïï 
!=
ïï 
null
ïï  
&&
ïï! #
prev
ïï$ (
.
ïï( )
opposite
ïï) 1
!=
ïï2 4
null
ïï5 9
&&
ïï: <
!
ïï= >
used
ïï> B
.
ïïB C
Contains
ïïC K
(
ïïK L
prev
ïïL P
.
ïïP Q
edge
ïïQ U
)
ïïU V
)
ïïV W
used
ğğ 
.
ğğ 
Add
ğğ 
(
ğğ 
prev
ğğ !
.
ğğ! "
edge
ğğ" &
)
ğğ& '
;
ğğ' (
}
ññ 
return
óó 
used
óó 
.
óó 
Select
óó 
(
óó 
x
óó  
=>
óó! #
x
óó$ %
.
óó% &
local
óó& +
)
óó+ ,
;
óó, -
}
ôô 	
internal
ƒƒ 
static
ƒƒ 
bool
ƒƒ 
GetEdgeLoop
ƒƒ (
(
ƒƒ( )
ProBuilderMesh
ƒƒ) 7
mesh
ƒƒ8 <
,
ƒƒ< =
IEnumerable
ƒƒ> I
<
ƒƒI J
Edge
ƒƒJ N
>
ƒƒN O
edges
ƒƒP U
,
ƒƒU V
out
ƒƒW Z
Edge
ƒƒ[ _
[
ƒƒ_ `
]
ƒƒ` a
loop
ƒƒb f
)
ƒƒf g
{
„„ 	
List
…… 
<
…… 

WingedEdge
…… 
>
…… 
wings
…… "
=
……# $

WingedEdge
……% /
.
……/ 0
GetWingedEdges
……0 >
(
……> ?
mesh
……? C
)
……C D
;
……D E
IEnumerable
†† 
<
†† 

EdgeLookup
†† "
>
††" #
m_edgeLookup
††$ 0
=
††1 2

EdgeLookup
††3 =
.
††= >
GetEdgeLookup
††> K
(
††K L
edges
††L Q
,
††Q R
mesh
††S W
.
††W X 
sharedVertexLookup
††X j
)
††j k
;
††k l
HashSet
‡‡ 
<
‡‡ 

EdgeLookup
‡‡ 
>
‡‡ 
sources
‡‡  '
=
‡‡( )
new
‡‡* -
HashSet
‡‡. 5
<
‡‡5 6

EdgeLookup
‡‡6 @
>
‡‡@ A
(
‡‡A B
m_edgeLookup
‡‡B N
)
‡‡N O
;
‡‡O P
HashSet
ˆˆ 
<
ˆˆ 

EdgeLookup
ˆˆ 
>
ˆˆ 
used
ˆˆ  $
=
ˆˆ% &
new
ˆˆ' *
HashSet
ˆˆ+ 2
<
ˆˆ2 3

EdgeLookup
ˆˆ3 =
>
ˆˆ= >
(
ˆˆ> ?
)
ˆˆ? @
;
ˆˆ@ A
for
ŠŠ 
(
ŠŠ 
int
ŠŠ 
i
ŠŠ 
=
ŠŠ 
$num
ŠŠ 
;
ŠŠ 
i
ŠŠ 
<
ŠŠ 
wings
ŠŠ  %
.
ŠŠ% &
Count
ŠŠ& +
;
ŠŠ+ ,
i
ŠŠ- .
++
ŠŠ. 0
)
ŠŠ0 1
{
‹‹ 
if
ŒŒ 
(
ŒŒ 
used
ŒŒ 
.
ŒŒ 
Contains
ŒŒ !
(
ŒŒ! "
wings
ŒŒ" '
[
ŒŒ' (
i
ŒŒ( )
]
ŒŒ) *
.
ŒŒ* +
edge
ŒŒ+ /
)
ŒŒ/ 0
||
ŒŒ1 3
!
ŒŒ4 5
sources
ŒŒ5 <
.
ŒŒ< =
Contains
ŒŒ= E
(
ŒŒE F
wings
ŒŒF K
[
ŒŒK L
i
ŒŒL M
]
ŒŒM N
.
ŒŒN O
edge
ŒŒO S
)
ŒŒS T
)
ŒŒT U
continue
 
;
 
bool
 
completeLoop
 !
=
" #!
GetEdgeLoopInternal
$ 7
(
7 8
wings
8 =
[
= >
i
> ?
]
? @
,
@ A
wings
B G
[
G H
i
H I
]
I J
.
J K
edge
K O
.
O P
common
P V
.
V W
b
W X
,
X Y
used
Z ^
)
^ _
;
_ `
if
’’ 
(
’’ 
!
’’ 
completeLoop
’’ !
)
’’! "!
GetEdgeLoopInternal
““ '
(
““' (
wings
““( -
[
““- .
i
““. /
]
““/ 0
,
““0 1
wings
““2 7
[
““7 8
i
““8 9
]
““9 :
.
““: ;
edge
““; ?
.
““? @
common
““@ F
.
““F G
a
““G H
,
““H I
used
““J N
)
““N O
;
““O P
}
”” 
loop
–– 
=
–– 
used
–– 
.
–– 
Select
–– 
(
–– 
x
––  
=>
––! #
x
––$ %
.
––% &
local
––& +
)
––+ ,
.
––, -
ToArray
––- 4
(
––4 5
)
––5 6
;
––6 7
return
˜˜ 
true
˜˜ 
;
˜˜ 
}
™™ 	
internal
¤¤ 
static
¤¤ 
bool
¤¤ "
GetEdgeLoopIterative
¤¤ 1
(
¤¤1 2
ProBuilderMesh
¤¤2 @
mesh
¤¤A E
,
¤¤E F
IEnumerable
¤¤G R
<
¤¤R S
Edge
¤¤S W
>
¤¤W X
edges
¤¤Y ^
,
¤¤^ _
out
¤¤` c
Edge
¤¤d h
[
¤¤h i
]
¤¤i j
loop
¤¤k o
)
¤¤o p
{
¥¥ 	
List
¦¦ 
<
¦¦ 

WingedEdge
¦¦ 
>
¦¦ 
wings
¦¦ "
=
¦¦# $

WingedEdge
¦¦% /
.
¦¦/ 0
GetWingedEdges
¦¦0 >
(
¦¦> ?
mesh
¦¦? C
)
¦¦C D
;
¦¦D E
IEnumerable
§§ 
<
§§ 

EdgeLookup
§§ "
>
§§" #
m_edgeLookup
§§$ 0
=
§§1 2

EdgeLookup
§§3 =
.
§§= >
GetEdgeLookup
§§> K
(
§§K L
edges
§§L Q
,
§§Q R
mesh
§§S W
.
§§W X 
sharedVertexLookup
§§X j
)
§§j k
;
§§k l
HashSet
¨¨ 
<
¨¨ 

EdgeLookup
¨¨ 
>
¨¨ 
sources
¨¨  '
=
¨¨( )
new
¨¨* -
HashSet
¨¨. 5
<
¨¨5 6

EdgeLookup
¨¨6 @
>
¨¨@ A
(
¨¨A B
m_edgeLookup
¨¨B N
)
¨¨N O
;
¨¨O P
HashSet
©© 
<
©© 

EdgeLookup
©© 
>
©© 
used
©©  $
=
©©% &
new
©©' *
HashSet
©©+ 2
<
©©2 3

EdgeLookup
©©3 =
>
©©= >
(
©©> ?
)
©©? @
;
©©@ A
for
«« 
(
«« 
int
«« 
i
«« 
=
«« 
$num
«« 
;
«« 
i
«« 
<
«« 
wings
««  %
.
««% &
Count
««& +
;
««+ ,
i
««- .
++
««. 0
)
««0 1
{
¬¬ 
if
­­ 
(
­­ 
!
­­ 
sources
­­ 
.
­­ 
Contains
­­ %
(
­­% &
wings
­­& +
[
­­+ ,
i
­­, -
]
­­- .
.
­­. /
edge
­­/ 3
)
­­3 4
)
­­4 5
continue
®® 
;
®® *
GetEdgeLoopInternalIterative
°° ,
(
°°, -
wings
°°- 2
[
°°2 3
i
°°3 4
]
°°4 5
,
°°5 6
wings
°°7 <
[
°°< =
i
°°= >
]
°°> ?
.
°°? @
edge
°°@ D
.
°°D E
common
°°E K
,
°°K L
used
°°M Q
)
°°Q R
;
°°R S
}
±± 
loop
³³ 
=
³³ 
used
³³ 
.
³³ 
Select
³³ 
(
³³ 
x
³³  
=>
³³! #
x
³³$ %
.
³³% &
local
³³& +
)
³³+ ,
.
³³, -
ToArray
³³- 4
(
³³4 5
)
³³5 6
;
³³6 7
return
µµ 
true
µµ 
;
µµ 
}
¶¶ 	
static
¸¸ 
bool
¸¸ !
GetEdgeLoopInternal
¸¸ '
(
¸¸' (

WingedEdge
¸¸( 2
start
¸¸3 8
,
¸¸8 9
int
¸¸: =

startIndex
¸¸> H
,
¸¸H I
HashSet
¸¸J Q
<
¸¸Q R

EdgeLookup
¸¸R \
>
¸¸\ ]
used
¸¸^ b
)
¸¸b c
{
¹¹ 	
int
ºº 
ind
ºº 
=
ºº 

startIndex
ºº  
;
ºº  !

WingedEdge
»» 
cur
»» 
=
»» 
start
»» "
;
»»" #
do
½½ 
{
¾¾ 
used
¿¿ 
.
¿¿ 
Add
¿¿ 
(
¿¿ 
cur
¿¿ 
.
¿¿ 
edge
¿¿ !
)
¿¿! "
;
¿¿" #
List
ÁÁ 
<
ÁÁ 

WingedEdge
ÁÁ 
>
ÁÁ  
spokes
ÁÁ! '
=
ÁÁ( )
	GetSpokes
ÁÁ* 3
(
ÁÁ3 4
cur
ÁÁ4 7
,
ÁÁ7 8
ind
ÁÁ9 <
,
ÁÁ< =
true
ÁÁ> B
)
ÁÁB C
.
ÁÁC D

DistinctBy
ÁÁD N
(
ÁÁN O
x
ÁÁO P
=>
ÁÁQ S
x
ÁÁT U
.
ÁÁU V
edge
ÁÁV Z
.
ÁÁZ [
common
ÁÁ[ a
)
ÁÁa b
.
ÁÁb c
ToList
ÁÁc i
(
ÁÁi j
)
ÁÁj k
;
ÁÁk l
cur
ÃÃ 
=
ÃÃ 
null
ÃÃ 
;
ÃÃ 
if
ÅÅ 
(
ÅÅ 
spokes
ÅÅ 
.
ÅÅ 
Count
ÅÅ  
==
ÅÅ! #
$num
ÅÅ$ %
)
ÅÅ% &
{
ÆÆ 
cur
ÇÇ 
=
ÇÇ 
spokes
ÇÇ  
[
ÇÇ  !
$num
ÇÇ! "
]
ÇÇ" #
;
ÇÇ# $
ind
ÈÈ 
=
ÈÈ 
cur
ÈÈ 
.
ÈÈ 
edge
ÈÈ "
.
ÈÈ" #
common
ÈÈ# )
.
ÈÈ) *
a
ÈÈ* +
==
ÈÈ, .
ind
ÈÈ/ 2
?
ÈÈ3 4
cur
ÈÈ5 8
.
ÈÈ8 9
edge
ÈÈ9 =
.
ÈÈ= >
common
ÈÈ> D
.
ÈÈD E
b
ÈÈE F
:
ÈÈG H
cur
ÈÈI L
.
ÈÈL M
edge
ÈÈM Q
.
ÈÈQ R
common
ÈÈR X
.
ÈÈX Y
a
ÈÈY Z
;
ÈÈZ [
}
ÉÉ 
}
ÊÊ 
while
ËË 
(
ËË 
cur
ËË 
!=
ËË 
null
ËË 
&&
ËË !
!
ËË" #
used
ËË# '
.
ËË' (
Contains
ËË( 0
(
ËË0 1
cur
ËË1 4
.
ËË4 5
edge
ËË5 9
)
ËË9 :
)
ËË: ;
;
ËË; <
return
ÍÍ 
cur
ÍÍ 
!=
ÍÍ 
null
ÍÍ 
;
ÍÍ 
}
ÎÎ 	
static
ĞĞ 
void
ĞĞ *
GetEdgeLoopInternalIterative
ĞĞ 0
(
ĞĞ0 1

WingedEdge
ĞĞ1 ;
start
ĞĞ< A
,
ĞĞA B
Edge
ĞĞC G
edge
ĞĞH L
,
ĞĞL M
HashSet
ĞĞN U
<
ĞĞU V

EdgeLookup
ĞĞV `
>
ĞĞ` a
used
ĞĞb f
)
ĞĞf g
{
ÑÑ 	
int
ÒÒ 
indA
ÒÒ 
=
ÒÒ 
edge
ÒÒ 
.
ÒÒ 
a
ÒÒ 
;
ÒÒ 
int
ÓÓ 
indB
ÓÓ 
=
ÓÓ 
edge
ÓÓ 
.
ÓÓ 
b
ÓÓ 
;
ÓÓ 

WingedEdge
ÔÔ 
cur
ÔÔ 
=
ÔÔ 
start
ÔÔ "
;
ÔÔ" #
if
ÖÖ 
(
ÖÖ 
!
ÖÖ 
used
ÖÖ 
.
ÖÖ 
Contains
ÖÖ 
(
ÖÖ 
cur
ÖÖ "
.
ÖÖ" #
edge
ÖÖ# '
)
ÖÖ' (
)
ÖÖ( )
used
×× 
.
×× 
Add
×× 
(
×× 
cur
×× 
.
×× 
edge
×× !
)
××! "
;
××" #
List
ÙÙ 
<
ÙÙ 

WingedEdge
ÙÙ 
>
ÙÙ 
spokesA
ÙÙ $
=
ÙÙ% &
	GetSpokes
ÙÙ' 0
(
ÙÙ0 1
cur
ÙÙ1 4
,
ÙÙ4 5
indA
ÙÙ6 :
,
ÙÙ: ;
true
ÙÙ< @
)
ÙÙ@ A
.
ÙÙA B

DistinctBy
ÙÙB L
(
ÙÙL M
x
ÙÙM N
=>
ÙÙO Q
x
ÙÙR S
.
ÙÙS T
edge
ÙÙT X
.
ÙÙX Y
common
ÙÙY _
)
ÙÙ_ `
.
ÙÙ` a
ToList
ÙÙa g
(
ÙÙg h
)
ÙÙh i
;
ÙÙi j
List
ÚÚ 
<
ÚÚ 

WingedEdge
ÚÚ 
>
ÚÚ 
spokesB
ÚÚ $
=
ÚÚ% &
	GetSpokes
ÚÚ' 0
(
ÚÚ0 1
cur
ÚÚ1 4
,
ÚÚ4 5
indB
ÚÚ6 :
,
ÚÚ: ;
true
ÚÚ< @
)
ÚÚ@ A
.
ÚÚA B

DistinctBy
ÚÚB L
(
ÚÚL M
x
ÚÚM N
=>
ÚÚO Q
x
ÚÚR S
.
ÚÚS T
edge
ÚÚT X
.
ÚÚX Y
common
ÚÚY _
)
ÚÚ_ `
.
ÚÚ` a
ToList
ÚÚa g
(
ÚÚg h
)
ÚÚh i
;
ÚÚi j
if
ÜÜ 
(
ÜÜ 
spokesA
ÜÜ 
.
ÜÜ 
Count
ÜÜ 
==
ÜÜ  
$num
ÜÜ! "
)
ÜÜ" #
{
İİ 
cur
ŞŞ 
=
ŞŞ 
spokesA
ŞŞ 
[
ŞŞ 
$num
ŞŞ 
]
ŞŞ  
;
ŞŞ  !
if
àà 
(
àà 
!
àà 
used
àà 
.
àà 
Contains
àà "
(
àà" #
cur
àà# &
.
àà& '
edge
àà' +
)
àà+ ,
)
àà, -
used
áá 
.
áá 
Add
áá 
(
áá 
cur
áá  
.
áá  !
edge
áá! %
)
áá% &
;
áá& '
}
ââ 
if
ãã 
(
ãã 
spokesB
ãã 
.
ãã 
Count
ãã 
==
ãã  
$num
ãã! "
)
ãã" #
{
ää 
cur
åå 
=
åå 
spokesB
åå 
[
åå 
$num
åå 
]
åå  
;
åå  !
if
çç 
(
çç 
!
çç 
used
çç 
.
çç 
Contains
çç "
(
çç" #
cur
çç# &
.
çç& '
edge
çç' +
)
çç+ ,
)
çç, -
used
èè 
.
èè 
Add
èè 
(
èè 
cur
èè  
.
èè  !
edge
èè! %
)
èè% &
;
èè& '
}
éé 
}
êê 	
static
ìì 

WingedEdge
ìì 
	NextSpoke
ìì #
(
ìì# $

WingedEdge
ìì$ .
wing
ìì/ 3
,
ìì3 4
int
ìì5 8
pivot
ìì9 >
,
ìì> ?
bool
ìì@ D
opp
ììE H
)
ììH I
{
íí 	
if
îî 
(
îî 
opp
îî 
)
îî 
return
ïï 
wing
ïï 
.
ïï 
opposite
ïï $
;
ïï$ %
if
ğğ 
(
ğğ 
wing
ğğ 
.
ğğ 
next
ğğ 
.
ğğ 
edge
ğğ 
.
ğğ 
common
ğğ %
.
ğğ% &
Contains
ğğ& .
(
ğğ. /
pivot
ğğ/ 4
)
ğğ4 5
)
ğğ5 6
return
ññ 
wing
ññ 
.
ññ 
next
ññ  
;
ññ  !
if
òò 
(
òò 
wing
òò 
.
òò 
previous
òò 
.
òò 
edge
òò "
.
òò" #
common
òò# )
.
òò) *
Contains
òò* 2
(
òò2 3
pivot
òò3 8
)
òò8 9
)
òò9 :
return
óó 
wing
óó 
.
óó 
previous
óó $
;
óó$ %
return
ôô 
null
ôô 
;
ôô 
}
õõ 	
internal
şş 
static
şş 
List
şş 
<
şş 

WingedEdge
şş '
>
şş' (
	GetSpokes
şş) 2
(
şş2 3

WingedEdge
şş3 =
wing
şş> B
,
şşB C
int
şşD G
sharedIndex
şşH S
,
şşS T
bool
şşU Y

allowHoles
şşZ d
=
şşe f
false
şşg l
)
şşl m
{
ÿÿ 	
List
€€ 
<
€€ 

WingedEdge
€€ 
>
€€ 
spokes
€€ #
=
€€$ %
new
€€& )
List
€€* .
<
€€. /

WingedEdge
€€/ 9
>
€€9 :
(
€€: ;
)
€€; <
;
€€< =

WingedEdge
 
cur
 
=
 
wing
 !
;
! "
bool
‚‚ 
opp
‚‚ 
=
‚‚ 
false
‚‚ 
;
‚‚ 
do
„„ 
{
…… 
if
‡‡ 
(
‡‡ 
spokes
‡‡ 
.
‡‡ 
Contains
‡‡ #
(
‡‡# $
cur
‡‡$ '
)
‡‡' (
)
‡‡( )
return
ˆˆ 
spokes
ˆˆ !
;
ˆˆ! "
spokes
ŠŠ 
.
ŠŠ 
Add
ŠŠ 
(
ŠŠ 
cur
ŠŠ 
)
ŠŠ 
;
ŠŠ  
cur
‹‹ 
=
‹‹ 
	NextSpoke
‹‹ 
(
‹‹  
cur
‹‹  #
,
‹‹# $
sharedIndex
‹‹% 0
,
‹‹0 1
opp
‹‹2 5
)
‹‹5 6
;
‹‹6 7
opp
ŒŒ 
=
ŒŒ 
!
ŒŒ 
opp
ŒŒ 
;
ŒŒ 
if
 
(
 
cur
 
!=
 
null
 
&&
  "
cur
# &
.
& '
edge
' +
.
+ ,
common
, 2
.
2 3
Equals
3 9
(
9 :
wing
: >
.
> ?
edge
? C
.
C D
common
D J
)
J K
)
K L
return
 
spokes
 !
;
! "
}
‘‘ 
while
’’ 
(
’’ 
cur
’’ 
!=
’’ 
null
’’ 
)
’’ 
;
’’  
if
”” 
(
”” 
!
”” 

allowHoles
”” 
)
”” 
return
•• 
null
•• 
;
•• 
cur
™™ 
=
™™ 
wing
™™ 
.
™™ 
opposite
™™ 
;
™™  
opp
šš 
=
šš 
false
šš 
;
šš 
List
›› 
<
›› 

WingedEdge
›› 
>
›› 
fragment
›› %
=
››& '
new
››( +
List
››, 0
<
››0 1

WingedEdge
››1 ;
>
››; <
(
››< =
)
››= >
;
››> ?
while
 
(
 
cur
 
!=
 
null
 
&&
 !
!
" #
cur
# &
.
& '
edge
' +
.
+ ,
common
, 2
.
2 3
Equals
3 9
(
9 :
wing
: >
.
> ?
edge
? C
.
C D
common
D J
)
J K
)
K L
{
ŸŸ 
fragment
   
.
   
Add
   
(
   
cur
    
)
    !
;
  ! "
cur
¡¡ 
=
¡¡ 
	NextSpoke
¡¡ 
(
¡¡  
cur
¡¡  #
,
¡¡# $
sharedIndex
¡¡% 0
,
¡¡0 1
opp
¡¡2 5
)
¡¡5 6
;
¡¡6 7
opp
¢¢ 
=
¢¢ 
!
¢¢ 
opp
¢¢ 
;
¢¢ 
}
££ 
fragment
¥¥ 
.
¥¥ 
Reverse
¥¥ 
(
¥¥ 
)
¥¥ 
;
¥¥ 
spokes
¦¦ 
.
¦¦ 
AddRange
¦¦ 
(
¦¦ 
fragment
¦¦ $
)
¦¦$ %
;
¦¦% &
return
¨¨ 
spokes
¨¨ 
;
¨¨ 
}
©© 	
public
²² 
static
²² 
HashSet
²² 
<
²² 
Face
²² "
>
²²" #
GrowSelection
²²$ 1
(
²²1 2
ProBuilderMesh
²²2 @
mesh
²²A E
,
²²E F
IEnumerable
²²G R
<
²²R S
Face
²²S W
>
²²W X
faces
²²Y ^
,
²²^ _
float
²²` e
maxAngleDiff
²²f r
=
²²s t
-
²²u v
$num
²²v x
)
²²x y
{
³³ 	
List
´´ 
<
´´ 

WingedEdge
´´ 
>
´´ 
wings
´´ "
=
´´# $

WingedEdge
´´% /
.
´´/ 0
GetWingedEdges
´´0 >
(
´´> ?
mesh
´´? C
,
´´C D
true
´´E I
)
´´I J
;
´´J K
HashSet
µµ 
<
µµ 
Face
µµ 
>
µµ 
source
µµ  
=
µµ! "
new
µµ# &
HashSet
µµ' .
<
µµ. /
Face
µµ/ 3
>
µµ3 4
(
µµ4 5
faces
µµ5 :
)
µµ: ;
;
µµ; <
HashSet
¶¶ 
<
¶¶ 
Face
¶¶ 
>
¶¶ 
neighboring
¶¶ %
=
¶¶& '
new
¶¶( +
HashSet
¶¶, 3
<
¶¶3 4
Face
¶¶4 8
>
¶¶8 9
(
¶¶9 :
)
¶¶: ;
;
¶¶; <
Vector3
¸¸ 
	srcNormal
¸¸ 
=
¸¸ 
Vector3
¸¸  '
.
¸¸' (
zero
¸¸( ,
;
¸¸, -
bool
¹¹ 

checkAngle
¹¹ 
=
¹¹ 
maxAngleDiff
¹¹ *
>
¹¹+ ,
$num
¹¹- /
;
¹¹/ 0
for
»» 
(
»» 
int
»» 
i
»» 
=
»» 
$num
»» 
;
»» 
i
»» 
<
»» 
wings
»»  %
.
»»% &
Count
»»& +
;
»»+ ,
i
»»- .
++
»». 0
)
»»0 1
{
¼¼ 
if
½½ 
(
½½ 
!
½½ 
source
½½ 
.
½½ 
Contains
½½ $
(
½½$ %
wings
½½% *
[
½½* +
i
½½+ ,
]
½½, -
.
½½- .
face
½½. 2
)
½½2 3
)
½½3 4
continue
¾¾ 
;
¾¾ 
if
ÀÀ 
(
ÀÀ 

checkAngle
ÀÀ 
)
ÀÀ 
	srcNormal
ÁÁ 
=
ÁÁ 
Math
ÁÁ  $
.
ÁÁ$ %
Normal
ÁÁ% +
(
ÁÁ+ ,
mesh
ÁÁ, 0
,
ÁÁ0 1
wings
ÁÁ2 7
[
ÁÁ7 8
i
ÁÁ8 9
]
ÁÁ9 :
.
ÁÁ: ;
face
ÁÁ; ?
)
ÁÁ? @
;
ÁÁ@ A
using
ÃÃ 
(
ÃÃ 
var
ÃÃ 
it
ÃÃ 
=
ÃÃ 
new
ÃÃ  #"
WingedEdgeEnumerator
ÃÃ$ 8
(
ÃÃ8 9
wings
ÃÃ9 >
[
ÃÃ> ?
i
ÃÃ? @
]
ÃÃ@ A
)
ÃÃA B
)
ÃÃB C
{
ÄÄ 
while
ÅÅ 
(
ÅÅ 
it
ÅÅ 
.
ÅÅ 
MoveNext
ÅÅ &
(
ÅÅ& '
)
ÅÅ' (
)
ÅÅ( )
{
ÆÆ 
var
ÇÇ 
w
ÇÇ 
=
ÇÇ 
it
ÇÇ  "
.
ÇÇ" #
Current
ÇÇ# *
;
ÇÇ* +
if
ÉÉ 
(
ÉÉ 
w
ÉÉ 
.
ÉÉ 
opposite
ÉÉ &
!=
ÉÉ' )
null
ÉÉ* .
&&
ÉÉ/ 1
!
ÉÉ2 3
source
ÉÉ3 9
.
ÉÉ9 :
Contains
ÉÉ: B
(
ÉÉB C
w
ÉÉC D
.
ÉÉD E
opposite
ÉÉE M
.
ÉÉM N
face
ÉÉN R
)
ÉÉR S
)
ÉÉS T
{
ÊÊ 
if
ËË 
(
ËË  

checkAngle
ËË  *
)
ËË* +
{
ÌÌ 
Vector3
ÍÍ  '
	oppNormal
ÍÍ( 1
=
ÍÍ2 3
Math
ÍÍ4 8
.
ÍÍ8 9
Normal
ÍÍ9 ?
(
ÍÍ? @
mesh
ÍÍ@ D
,
ÍÍD E
w
ÍÍF G
.
ÍÍG H
opposite
ÍÍH P
.
ÍÍP Q
face
ÍÍQ U
)
ÍÍU V
;
ÍÍV W
if
ÏÏ  "
(
ÏÏ# $
Vector3
ÏÏ$ +
.
ÏÏ+ ,
Angle
ÏÏ, 1
(
ÏÏ1 2
	srcNormal
ÏÏ2 ;
,
ÏÏ; <
	oppNormal
ÏÏ= F
)
ÏÏF G
<
ÏÏH I
maxAngleDiff
ÏÏJ V
)
ÏÏV W
neighboring
ĞĞ$ /
.
ĞĞ/ 0
Add
ĞĞ0 3
(
ĞĞ3 4
w
ĞĞ4 5
.
ĞĞ5 6
opposite
ĞĞ6 >
.
ĞĞ> ?
face
ĞĞ? C
)
ĞĞC D
;
ĞĞD E
}
ÑÑ 
else
ÒÒ  
{
ÓÓ 
neighboring
ÔÔ  +
.
ÔÔ+ ,
Add
ÔÔ, /
(
ÔÔ/ 0
w
ÔÔ0 1
.
ÔÔ1 2
opposite
ÔÔ2 :
.
ÔÔ: ;
face
ÔÔ; ?
)
ÔÔ? @
;
ÔÔ@ A
}
ÕÕ 
}
ÖÖ 
}
×× 
}
ØØ 
}
ÙÙ 
return
ÛÛ 
neighboring
ÛÛ 
;
ÛÛ 
}
ÜÜ 	
static
ŞŞ 
readonly
ŞŞ 
Vector3
ŞŞ 
Vector3_Zero
ŞŞ  ,
=
ŞŞ- .
new
ŞŞ/ 2
Vector3
ŞŞ3 :
(
ŞŞ: ;
$num
ŞŞ; =
,
ŞŞ= >
$num
ŞŞ? A
,
ŞŞA B
$num
ŞŞC E
)
ŞŞE F
;
ŞŞF G
internal
àà 
static
àà 
void
àà 
Flood
àà "
(
àà" #

WingedEdge
àà# -
wing
àà. 2
,
àà2 3
HashSet
àà4 ;
<
àà; <
Face
àà< @
>
àà@ A
	selection
ààB K
)
ààK L
{
áá 	
Flood
ââ 
(
ââ 
null
ââ 
,
ââ 
wing
ââ 
,
ââ 
Vector3_Zero
ââ *
,
ââ* +
-
ââ, -
$num
ââ- /
,
ââ/ 0
	selection
ââ1 :
)
ââ: ;
;
ââ; <
}
ãã 	
internal
åå 
static
åå 
void
åå 
Flood
åå "
(
åå" #
ProBuilderMesh
åå# 1
pb
åå2 4
,
åå4 5

WingedEdge
åå6 @
wing
ååA E
,
ååE F
Vector3
ååG N
wingNrm
ååO V
,
ååV W
float
ååX ]
maxAngle
åå^ f
,
ååf g
HashSet
ååh o
<
ååo p
Face
ååp t
>
ååt u
	selection
ååv 
)åå €
{
ææ 	

WingedEdge
çç 
next
çç 
=
çç 
wing
çç "
;
çç" #
do
éé 
{
êê 

WingedEdge
ëë 
opp
ëë 
=
ëë  
next
ëë! %
.
ëë% &
opposite
ëë& .
;
ëë. /
if
íí 
(
íí 
opp
íí 
!=
íí 
null
íí 
&&
íí  "
!
íí# $
	selection
íí$ -
.
íí- .
Contains
íí. 6
(
íí6 7
opp
íí7 :
.
íí: ;
face
íí; ?
)
íí? @
)
íí@ A
{
îî 
if
ïï 
(
ïï 
maxAngle
ïï  
>
ïï! "
$num
ïï# %
)
ïï% &
{
ğğ 
Vector3
ññ 
	oppNormal
ññ  )
=
ññ* +
Math
ññ, 0
.
ññ0 1
Normal
ññ1 7
(
ññ7 8
pb
ññ8 :
,
ññ: ;
opp
ññ< ?
.
ññ? @
face
ññ@ D
)
ññD E
;
ññE F
if
óó 
(
óó 
Vector3
óó #
.
óó# $
Angle
óó$ )
(
óó) *
wingNrm
óó* 1
,
óó1 2
	oppNormal
óó3 <
)
óó< =
<
óó> ?
maxAngle
óó@ H
)
óóH I
{
ôô 
if
õõ 
(
õõ  
	selection
õõ  )
.
õõ) *
Add
õõ* -
(
õõ- .
opp
õõ. 1
.
õõ1 2
face
õõ2 6
)
õõ6 7
)
õõ7 8
Flood
öö  %
(
öö% &
pb
öö& (
,
öö( )
opp
öö* -
,
öö- .
	oppNormal
öö/ 8
,
öö8 9
maxAngle
öö: B
,
ööB C
	selection
ööD M
)
ööM N
;
ööN O
}
÷÷ 
}
øø 
else
ùù 
{
úú 
if
ûû 
(
ûû 
	selection
ûû %
.
ûû% &
Add
ûû& )
(
ûû) *
opp
ûû* -
.
ûû- .
face
ûû. 2
)
ûû2 3
)
ûû3 4
Flood
üü !
(
üü! "
pb
üü" $
,
üü$ %
opp
üü& )
,
üü) *
wingNrm
üü+ 2
,
üü2 3
maxAngle
üü4 <
,
üü< =
	selection
üü> G
)
üüG H
;
üüH I
}
ıı 
}
şş 
next
€€ 
=
€€ 
next
€€ 
.
€€ 
next
€€  
;
€€  !
}
 
while
‚‚ 
(
‚‚ 
next
‚‚ 
!=
‚‚ 
wing
‚‚ 
)
‚‚  
;
‚‚  !
}
ƒƒ 	
public
ŒŒ 
static
ŒŒ 
HashSet
ŒŒ 
<
ŒŒ 
Face
ŒŒ "
>
ŒŒ" #
FloodSelection
ŒŒ$ 2
(
ŒŒ2 3
ProBuilderMesh
ŒŒ3 A
mesh
ŒŒB F
,
ŒŒF G
IList
ŒŒH M
<
ŒŒM N
Face
ŒŒN R
>
ŒŒR S
faces
ŒŒT Y
,
ŒŒY Z
float
ŒŒ[ `
maxAngleDiff
ŒŒa m
)
ŒŒm n
{
 	
List
 
<
 

WingedEdge
 
>
 
wings
 "
=
# $

WingedEdge
% /
.
/ 0
GetWingedEdges
0 >
(
> ?
mesh
? C
,
C D
true
E I
)
I J
;
J K
HashSet
 
<
 
Face
 
>
 
source
  
=
! "
new
# &
HashSet
' .
<
. /
Face
/ 3
>
3 4
(
4 5
faces
5 :
)
: ;
;
; <
HashSet
 
<
 
Face
 
>
 
flood
 
=
  !
new
" %
HashSet
& -
<
- .
Face
. 2
>
2 3
(
3 4
)
4 5
;
5 6
for
’’ 
(
’’ 
int
’’ 
i
’’ 
=
’’ 
$num
’’ 
;
’’ 
i
’’ 
<
’’ 
wings
’’  %
.
’’% &
Count
’’& +
;
’’+ ,
i
’’- .
++
’’. 0
)
’’0 1
{
““ 
if
”” 
(
”” 
!
”” 
flood
”” 
.
”” 
Contains
”” #
(
””# $
wings
””$ )
[
””) *
i
””* +
]
””+ ,
.
””, -
face
””- 1
)
””1 2
&&
””3 5
source
””6 <
.
””< =
Contains
””= E
(
””E F
wings
””F K
[
””K L
i
””L M
]
””M N
.
””N O
face
””O S
)
””S T
)
””T U
{
•• 
flood
–– 
.
–– 
Add
–– 
(
–– 
wings
–– #
[
––# $
i
––$ %
]
––% &
.
––& '
face
––' +
)
––+ ,
;
––, -
Flood
—— 
(
—— 
mesh
—— 
,
—— 
wings
——  %
[
——% &
i
——& '
]
——' (
,
——( )
maxAngleDiff
——* 6
>
——7 8
$num
——9 ;
?
——< =
Math
——> B
.
——B C
Normal
——C I
(
——I J
mesh
——J N
,
——N O
wings
——P U
[
——U V
i
——V W
]
——W X
.
——X Y
face
——Y ]
)
——] ^
:
——_ `
Vector3_Zero
——a m
,
——m n
maxAngleDiff
——o {
,
——{ |
flood——} ‚
)——‚ ƒ
;——ƒ „
}
˜˜ 
}
™™ 
return
šš 
flood
šš 
;
šš 
}
›› 	
public
¤¤ 
static
¤¤ 
HashSet
¤¤ 
<
¤¤ 
Face
¤¤ "
>
¤¤" #
GetFaceLoop
¤¤$ /
(
¤¤/ 0
ProBuilderMesh
¤¤0 >
mesh
¤¤? C
,
¤¤C D
Face
¤¤E I
[
¤¤I J
]
¤¤J K
faces
¤¤L Q
,
¤¤Q R
bool
¤¤S W
ring
¤¤X \
=
¤¤] ^
false
¤¤_ d
)
¤¤d e
{
¥¥ 	
if
¦¦ 
(
¦¦ 
mesh
¦¦ 
==
¦¦ 
null
¦¦ 
)
¦¦ 
throw
§§ 
new
§§ #
ArgumentNullException
§§ /
(
§§/ 0
$str
§§0 6
)
§§6 7
;
§§7 8
if
©© 
(
©© 
faces
©© 
==
©© 
null
©© 
)
©© 
throw
ªª 
new
ªª #
ArgumentNullException
ªª /
(
ªª/ 0
$str
ªª0 7
)
ªª7 8
;
ªª8 9
HashSet
¬¬ 
<
¬¬ 
Face
¬¬ 
>
¬¬ 
loops
¬¬ 
=
¬¬  !
new
¬¬" %
HashSet
¬¬& -
<
¬¬- .
Face
¬¬. 2
>
¬¬2 3
(
¬¬3 4
)
¬¬4 5
;
¬¬5 6
List
­­ 
<
­­ 

WingedEdge
­­ 
>
­­ 
wings
­­ "
=
­­# $

WingedEdge
­­% /
.
­­/ 0
GetWingedEdges
­­0 >
(
­­> ?
mesh
­­? C
)
­­C D
;
­­D E
foreach
¯¯ 
(
¯¯ 
Face
¯¯ 
face
¯¯ 
in
¯¯ !
faces
¯¯" '
)
¯¯' (
loops
°° 
.
°° 
	UnionWith
°° 
(
°°  
GetFaceLoop
°°  +
(
°°+ ,
wings
°°, 1
,
°°1 2
face
°°3 7
,
°°7 8
ring
°°9 =
)
°°= >
)
°°> ?
;
°°? @
return
²² 
loops
²² 
;
²² 
}
³³ 	
public
»» 
static
»» 
HashSet
»» 
<
»» 
Face
»» "
>
»»" # 
GetFaceRingAndLoop
»»$ 6
(
»»6 7
ProBuilderMesh
»»7 E
mesh
»»F J
,
»»J K
Face
»»L P
[
»»P Q
]
»»Q R
faces
»»S X
)
»»X Y
{
¼¼ 	
if
½½ 
(
½½ 
mesh
½½ 
==
½½ 
null
½½ 
)
½½ 
throw
¾¾ 
new
¾¾ #
ArgumentNullException
¾¾ /
(
¾¾/ 0
$str
¾¾0 6
)
¾¾6 7
;
¾¾7 8
if
ÀÀ 
(
ÀÀ 
faces
ÀÀ 
==
ÀÀ 
null
ÀÀ 
)
ÀÀ 
throw
ÁÁ 
new
ÁÁ #
ArgumentNullException
ÁÁ /
(
ÁÁ/ 0
$str
ÁÁ0 7
)
ÁÁ7 8
;
ÁÁ8 9
HashSet
ÃÃ 
<
ÃÃ 
Face
ÃÃ 
>
ÃÃ 
loops
ÃÃ 
=
ÃÃ  !
new
ÃÃ" %
HashSet
ÃÃ& -
<
ÃÃ- .
Face
ÃÃ. 2
>
ÃÃ2 3
(
ÃÃ3 4
)
ÃÃ4 5
;
ÃÃ5 6
List
ÄÄ 
<
ÄÄ 

WingedEdge
ÄÄ 
>
ÄÄ 
wings
ÄÄ "
=
ÄÄ# $

WingedEdge
ÄÄ% /
.
ÄÄ/ 0
GetWingedEdges
ÄÄ0 >
(
ÄÄ> ?
mesh
ÄÄ? C
)
ÄÄC D
;
ÄÄD E
foreach
ÆÆ 
(
ÆÆ 
Face
ÆÆ 
face
ÆÆ 
in
ÆÆ !
faces
ÆÆ" '
)
ÆÆ' (
{
ÇÇ 
loops
ÈÈ 
.
ÈÈ 
	UnionWith
ÈÈ 
(
ÈÈ  
GetFaceLoop
ÈÈ  +
(
ÈÈ+ ,
wings
ÈÈ, 1
,
ÈÈ1 2
face
ÈÈ3 7
,
ÈÈ7 8
true
ÈÈ9 =
)
ÈÈ= >
)
ÈÈ> ?
;
ÈÈ? @
loops
ÉÉ 
.
ÉÉ 
	UnionWith
ÉÉ 
(
ÉÉ  
GetFaceLoop
ÉÉ  +
(
ÉÉ+ ,
wings
ÉÉ, 1
,
ÉÉ1 2
face
ÉÉ3 7
,
ÉÉ7 8
false
ÉÉ9 >
)
ÉÉ> ?
)
ÉÉ? @
;
ÉÉ@ A
}
ÊÊ 
return
ÌÌ 
loops
ÌÌ 
;
ÌÌ 
}
ÍÍ 	
static
ÖÖ 
HashSet
ÖÖ 
<
ÖÖ 
Face
ÖÖ 
>
ÖÖ 
GetFaceLoop
ÖÖ (
(
ÖÖ( )
List
ÖÖ) -
<
ÖÖ- .

WingedEdge
ÖÖ. 8
>
ÖÖ8 9
wings
ÖÖ: ?
,
ÖÖ? @
Face
ÖÖA E
face
ÖÖF J
,
ÖÖJ K
bool
ÖÖL P
ring
ÖÖQ U
)
ÖÖU V
{
×× 	
HashSet
ØØ 
<
ØØ 
Face
ØØ 
>
ØØ 
loop
ØØ 
=
ØØ  
new
ØØ! $
HashSet
ØØ% ,
<
ØØ, -
Face
ØØ- 1
>
ØØ1 2
(
ØØ2 3
)
ØØ3 4
;
ØØ4 5
if
ÚÚ 
(
ÚÚ 
face
ÚÚ 
==
ÚÚ 
null
ÚÚ 
)
ÚÚ 
return
ÛÛ 
loop
ÛÛ 
;
ÛÛ 

WingedEdge
İİ 
start
İİ 
=
İİ 
wings
İİ $
.
İİ$ %
FirstOrDefault
İİ% 3
(
İİ3 4
x
İİ4 5
=>
İİ6 8
x
İİ9 :
.
İİ: ;
face
İİ; ?
==
İİ@ B
face
İİC G
)
İİG H
;
İİH I
if
ßß 
(
ßß 
start
ßß 
==
ßß 
null
ßß 
)
ßß 
return
àà 
loop
àà 
;
àà 
if
ââ 
(
ââ 
ring
ââ 
)
ââ 
start
ãã 
=
ãã 
start
ãã 
.
ãã 
next
ãã "
??
ãã# %
start
ãã& +
.
ãã+ ,
previous
ãã, 4
;
ãã4 5
for
åå 
(
åå 
int
åå 
i
åå 
=
åå 
$num
åå 
;
åå 
i
åå 
<
åå 
$num
åå  !
;
åå! "
i
åå# $
++
åå$ &
)
åå& '
{
ææ 

WingedEdge
çç 
cur
çç 
=
çç  
start
çç! &
;
çç& '
if
éé 
(
éé 
i
éé 
==
éé 
$num
éé 
)
éé 
{
êê 
if
ëë 
(
ëë 
start
ëë 
.
ëë 
opposite
ëë &
!=
ëë' )
null
ëë* .
&&
ëë/ 1
start
ëë2 7
.
ëë7 8
opposite
ëë8 @
.
ëë@ A
face
ëëA E
!=
ëëF H
null
ëëI M
)
ëëM N
cur
ìì 
=
ìì 
start
ìì #
.
ìì# $
opposite
ìì$ ,
;
ìì, -
else
íí 
break
îî 
;
îî 
}
ïï 
do
ññ 
{
òò 
if
óó 
(
óó 
!
óó 
loop
óó 
.
óó 
Add
óó !
(
óó! "
cur
óó" %
.
óó% &
face
óó& *
)
óó* +
)
óó+ ,
break
ôô 
;
ôô 
if
öö 
(
öö 
cur
öö 
.
öö 
Count
öö !
(
öö! "
)
öö" #
!=
öö$ &
$num
öö' (
)
öö( )
break
÷÷ 
;
÷÷ 
cur
úú 
=
úú 
cur
úú 
.
úú 
next
úú "
.
úú" #
next
úú# '
.
úú' (
opposite
úú( 0
;
úú0 1
}
ûû 
while
üü 
(
üü 
cur
üü 
!=
üü 
null
üü "
&&
üü# %
cur
üü& )
.
üü) *
face
üü* .
!=
üü/ 1
null
üü2 6
)
üü6 7
;
üü7 8
}
ıı 
return
ÿÿ 
loop
ÿÿ 
;
ÿÿ 
}
€€ 	
internal
ˆˆ 
static
ˆˆ 
List
ˆˆ 
<
ˆˆ 
List
ˆˆ !
<
ˆˆ! "
Edge
ˆˆ" &
>
ˆˆ& '
>
ˆˆ' (
	FindHoles
ˆˆ) 2
(
ˆˆ2 3
ProBuilderMesh
ˆˆ3 A
mesh
ˆˆB F
,
ˆˆF G
IEnumerable
ˆˆH S
<
ˆˆS T
int
ˆˆT W
>
ˆˆW X
indexes
ˆˆY `
)
ˆˆ` a
{
‰‰ 	
HashSet
ŠŠ 
<
ŠŠ 
int
ŠŠ 
>
ŠŠ 
common
ŠŠ 
=
ŠŠ  !
mesh
ŠŠ" &
.
ŠŠ& '$
GetSharedVertexHandles
ŠŠ' =
(
ŠŠ= >
indexes
ŠŠ> E
)
ŠŠE F
;
ŠŠF G
List
‹‹ 
<
‹‹ 
List
‹‹ 
<
‹‹ 
Edge
‹‹ 
>
‹‹ 
>
‹‹ 
holes
‹‹ "
=
‹‹# $
new
‹‹% (
List
‹‹) -
<
‹‹- .
List
‹‹. 2
<
‹‹2 3
Edge
‹‹3 7
>
‹‹7 8
>
‹‹8 9
(
‹‹9 :
)
‹‹: ;
;
‹‹; <
List
ŒŒ 
<
ŒŒ 

WingedEdge
ŒŒ 
>
ŒŒ 
wings
ŒŒ "
=
ŒŒ# $

WingedEdge
ŒŒ% /
.
ŒŒ/ 0
GetWingedEdges
ŒŒ0 >
(
ŒŒ> ?
mesh
ŒŒ? C
)
ŒŒC D
;
ŒŒD E
foreach
 
(
 
List
 
<
 

WingedEdge
 $
>
$ %
hole
& *
in
+ -
	FindHoles
. 7
(
7 8
wings
8 =
,
= >
common
? E
)
E F
)
F G
holes
 
.
 
Add
 
(
 
hole
 
.
 
Select
 %
(
% &
x
& '
=>
( *
x
+ ,
.
, -
edge
- 1
.
1 2
local
2 7
)
7 8
.
8 9
ToList
9 ?
(
? @
)
@ A
)
A B
;
B C
return
‘‘ 
holes
‘‘ 
;
‘‘ 
}
’’ 	
internal
šš 
static
šš 
List
šš 
<
šš 
List
šš !
<
šš! "

WingedEdge
šš" ,
>
šš, -
>
šš- .
	FindHoles
šš/ 8
(
šš8 9
List
šš9 =
<
šš= >

WingedEdge
šš> H
>
ššH I
wings
ššJ O
,
ššO P
HashSet
ššQ X
<
ššX Y
int
ššY \
>
šš\ ]
common
šš^ d
)
ššd e
{
›› 	
HashSet
œœ 
<
œœ 

WingedEdge
œœ 
>
œœ 
used
œœ  $
=
œœ% &
new
œœ' *
HashSet
œœ+ 2
<
œœ2 3

WingedEdge
œœ3 =
>
œœ= >
(
œœ> ?
)
œœ? @
;
œœ@ A
List
 
<
 
List
 
<
 

WingedEdge
  
>
  !
>
! "
holes
# (
=
) *
new
+ .
List
/ 3
<
3 4
List
4 8
<
8 9

WingedEdge
9 C
>
C D
>
D E
(
E F
)
F G
;
G H
for
ŸŸ 
(
ŸŸ 
int
ŸŸ 
i
ŸŸ 
=
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
i
ŸŸ 
<
ŸŸ 
wings
ŸŸ  %
.
ŸŸ% &
Count
ŸŸ& +
;
ŸŸ+ ,
i
ŸŸ- .
++
ŸŸ. 0
)
ŸŸ0 1
{
   

WingedEdge
¡¡ 
c
¡¡ 
=
¡¡ 
wings
¡¡ $
[
¡¡$ %
i
¡¡% &
]
¡¡& '
;
¡¡' (
if
¥¥ 
(
¥¥ 
c
¥¥ 
.
¥¥ 
opposite
¥¥ 
!=
¥¥ !
null
¥¥" &
||
¥¥' )
used
¥¥* .
.
¥¥. /
Contains
¥¥/ 7
(
¥¥7 8
c
¥¥8 9
)
¥¥9 :
||
¥¥; =
!
¥¥> ?
(
¥¥? @
common
¥¥@ F
.
¥¥F G
Contains
¥¥G O
(
¥¥O P
c
¥¥P Q
.
¥¥Q R
edge
¥¥R V
.
¥¥V W
common
¥¥W ]
.
¥¥] ^
a
¥¥^ _
)
¥¥_ `
||
¥¥a c
common
¥¥d j
.
¥¥j k
Contains
¥¥k s
(
¥¥s t
c
¥¥t u
.
¥¥u v
edge
¥¥v z
.
¥¥z {
common¥¥{ 
.¥¥ ‚
b¥¥‚ ƒ
)¥¥ƒ „
)¥¥„ …
)¥¥… †
continue
¦¦ 
;
¦¦ 
List
¨¨ 
<
¨¨ 

WingedEdge
¨¨ 
>
¨¨  
hole
¨¨! %
=
¨¨& '
new
¨¨( +
List
¨¨, 0
<
¨¨0 1

WingedEdge
¨¨1 ;
>
¨¨; <
(
¨¨< =
)
¨¨= >
;
¨¨> ?

WingedEdge
©© 
it
©© 
=
©© 
c
©©  !
;
©©! "
int
ªª 
ind
ªª 
=
ªª 
it
ªª 
.
ªª 
edge
ªª !
.
ªª! "
common
ªª" (
.
ªª( )
a
ªª) *
;
ªª* +
int
¬¬ 
counter
¬¬ 
=
¬¬ 
$num
¬¬ 
;
¬¬  
while
®® 
(
®® 
it
®® 
!=
®® 
null
®® !
&&
®®" $
counter
®®% ,
++
®®, .
<
®®/ 0!
k_MaxHoleIterations
®®1 D
)
®®D E
{
¯¯ 
used
°° 
.
°° 
Add
°° 
(
°° 
it
°° 
)
°°  
;
°°  !
hole
±± 
.
±± 
Add
±± 
(
±± 
it
±± 
)
±±  
;
±±  !
ind
³³ 
=
³³ 
it
³³ 
.
³³ 
edge
³³ !
.
³³! "
common
³³" (
.
³³( )
a
³³) *
==
³³+ -
ind
³³. 1
?
³³2 3
it
³³4 6
.
³³6 7
edge
³³7 ;
.
³³; <
common
³³< B
.
³³B C
b
³³C D
:
³³E F
it
³³G I
.
³³I J
edge
³³J N
.
³³N O
common
³³O U
.
³³U V
a
³³V W
;
³³W X
it
´´ 
=
´´  
FindNextEdgeInHole
´´ +
(
´´+ ,
it
´´, .
,
´´. /
ind
´´0 3
)
´´3 4
;
´´4 5
if
¶¶ 
(
¶¶ 
it
¶¶ 
==
¶¶ 
c
¶¶ 
)
¶¶  
break
·· 
;
·· 
}
¸¸ 
List
ºº 
<
ºº 
SimpleTuple
ºº  
<
ºº  !
int
ºº! $
,
ºº$ %
int
ºº& )
>
ºº) *
>
ºº* +
splits
ºº, 2
=
ºº3 4
new
ºº5 8
List
ºº9 =
<
ºº= >
SimpleTuple
ºº> I
<
ººI J
int
ººJ M
,
ººM N
int
ººO R
>
ººR S
>
ººS T
(
ººT U
)
ººU V
;
ººV W
for
½½ 
(
½½ 
int
½½ 
n
½½ 
=
½½ 
$num
½½ 
;
½½ 
n
½½  !
<
½½" #
hole
½½$ (
.
½½( )
Count
½½) .
;
½½. /
n
½½0 1
++
½½1 3
)
½½3 4
{
¾¾ 

WingedEdge
¿¿ 
wing
¿¿ #
=
¿¿$ %
hole
¿¿& *
[
¿¿* +
n
¿¿+ ,
]
¿¿, -
;
¿¿- .
for
ÁÁ 
(
ÁÁ 
int
ÁÁ 
p
ÁÁ 
=
ÁÁ  
n
ÁÁ! "
-
ÁÁ# $
$num
ÁÁ% &
;
ÁÁ& '
p
ÁÁ( )
>
ÁÁ* +
-
ÁÁ, -
$num
ÁÁ- .
;
ÁÁ. /
p
ÁÁ0 1
--
ÁÁ1 3
)
ÁÁ3 4
{
ÂÂ 
if
ÃÃ 
(
ÃÃ 
wing
ÃÃ  
.
ÃÃ  !
edge
ÃÃ! %
.
ÃÃ% &
common
ÃÃ& ,
.
ÃÃ, -
b
ÃÃ- .
==
ÃÃ/ 1
hole
ÃÃ2 6
[
ÃÃ6 7
p
ÃÃ7 8
]
ÃÃ8 9
.
ÃÃ9 :
edge
ÃÃ: >
.
ÃÃ> ?
common
ÃÃ? E
.
ÃÃE F
a
ÃÃF G
)
ÃÃG H
{
ÄÄ 
splits
ÅÅ "
.
ÅÅ" #
Add
ÅÅ# &
(
ÅÅ& '
new
ÅÅ' *
SimpleTuple
ÅÅ+ 6
<
ÅÅ6 7
int
ÅÅ7 :
,
ÅÅ: ;
int
ÅÅ< ?
>
ÅÅ? @
(
ÅÅ@ A
p
ÅÅA B
,
ÅÅB C
n
ÅÅD E
)
ÅÅE F
)
ÅÅF G
;
ÅÅG H
break
ÆÆ !
;
ÆÆ! "
}
ÇÇ 
}
ÈÈ 
}
ÉÉ 
int
áá 

splitCount
áá 
=
áá  
splits
áá! '
.
áá' (
Count
áá( -
;
áá- .
splits
ãã 
.
ãã 
Sort
ãã 
(
ãã 
(
ãã 
x
ãã 
,
ãã 
y
ãã  !
)
ãã! "
=>
ãã# %
x
ãã& '
.
ãã' (
item1
ãã( -
.
ãã- .
	CompareTo
ãã. 7
(
ãã7 8
y
ãã8 9
.
ãã9 :
item1
ãã: ?
)
ãã? @
)
ãã@ A
;
ããA B
int
åå 
[
åå 
]
åå 
shift
åå 
=
åå 
new
åå !
int
åå" %
[
åå% &

splitCount
åå& 0
]
åå0 1
;
åå1 2
for
éé 
(
éé 
int
éé 
n
éé 
=
éé 

splitCount
éé '
-
éé( )
$num
éé* +
;
éé+ ,
n
éé- .
>
éé/ 0
-
éé1 2
$num
éé2 3
;
éé3 4
n
éé5 6
--
éé6 8
)
éé8 9
{
êê 
int
ëë 
x
ëë 
=
ëë 
splits
ëë "
[
ëë" #
n
ëë# $
]
ëë$ %
.
ëë% &
item1
ëë& +
,
ëë+ ,
y
ëë- .
=
ëë/ 0
splits
ëë1 7
[
ëë7 8
n
ëë8 9
]
ëë9 :
.
ëë: ;
item2
ëë; @
-
ëëA B
shift
ëëC H
[
ëëH I
n
ëëI J
]
ëëJ K
;
ëëK L
int
ìì 
range
ìì 
=
ìì 
(
ìì  !
y
ìì! "
-
ìì# $
x
ìì% &
)
ìì& '
+
ìì( )
$num
ìì* +
;
ìì+ ,
List
îî 
<
îî 

WingedEdge
îî #
>
îî# $
section
îî% ,
=
îî- .
hole
îî/ 3
.
îî3 4
GetRange
îî4 <
(
îî< =
x
îî= >
,
îî> ?
range
îî@ E
)
îîE F
;
îîF G
hole
ğğ 
.
ğğ 
RemoveRange
ğğ $
(
ğğ$ %
x
ğğ% &
,
ğğ& '
range
ğğ( -
)
ğğ- .
;
ğğ. /
for
òò 
(
òò 
int
òò 
m
òò 
=
òò  
n
òò! "
-
òò# $
$num
òò% &
;
òò& '
m
òò( )
>
òò* +
-
òò, -
$num
òò- .
;
òò. /
m
òò0 1
--
òò1 3
)
òò3 4
if
óó 
(
óó 
splits
óó "
[
óó" #
m
óó# $
]
óó$ %
.
óó% &
item2
óó& +
>
óó, -
splits
óó. 4
[
óó4 5
n
óó5 6
]
óó6 7
.
óó7 8
item2
óó8 =
)
óó= >
shift
ôô !
[
ôô! "
m
ôô" #
]
ôô# $
+=
ôô% '
range
ôô( -
;
ôô- .
if
÷÷ 
(
÷÷ 

splitCount
÷÷ "
<
÷÷# $
$num
÷÷% &
||
÷÷' )
section
÷÷* 1
.
÷÷1 2
Any
÷÷2 5
(
÷÷5 6
w
÷÷6 7
=>
÷÷8 :
common
÷÷; A
.
÷÷A B
Contains
÷÷B J
(
÷÷J K
w
÷÷K L
.
÷÷L M
edge
÷÷M Q
.
÷÷Q R
common
÷÷R X
.
÷÷X Y
a
÷÷Y Z
)
÷÷Z [
)
÷÷[ \
||
÷÷] _
section
÷÷` g
.
÷÷g h
Any
÷÷h k
(
÷÷k l
w
÷÷l m
=>
÷÷n p
common
÷÷q w
.
÷÷w x
Contains÷÷x €
(÷÷€ 
w÷÷ ‚
.÷÷‚ ƒ
edge÷÷ƒ ‡
.÷÷‡ ˆ
common÷÷ˆ 
.÷÷ 
b÷÷ 
)÷÷ ‘
)÷÷‘ ’
)÷÷’ “
holes
øø 
.
øø 
Add
øø !
(
øø! "
section
øø" )
)
øø) *
;
øø* +
}
ùù 
}
úú 
return
üü 
holes
üü 
;
üü 
}
ıı 	
static
ÿÿ 

WingedEdge
ÿÿ  
FindNextEdgeInHole
ÿÿ ,
(
ÿÿ, -

WingedEdge
ÿÿ- 7
wing
ÿÿ8 <
,
ÿÿ< =
int
ÿÿ> A
common
ÿÿB H
)
ÿÿH I
{
€€ 	

WingedEdge
 
next
 
=
 
wing
 "
.
" #,
GetAdjacentEdgeWithCommonIndex
# A
(
A B
common
B H
)
H I
;
I J
int
‚‚ 
counter
‚‚ 
=
‚‚ 
$num
‚‚ 
;
‚‚ 
while
ƒƒ 
(
ƒƒ 
next
ƒƒ 
!=
ƒƒ 
null
ƒƒ 
&&
ƒƒ  "
next
ƒƒ# '
!=
ƒƒ( *
wing
ƒƒ+ /
&&
ƒƒ0 2
counter
ƒƒ3 :
++
ƒƒ: <
<
ƒƒ= >!
k_MaxHoleIterations
ƒƒ? R
)
ƒƒR S
{
„„ 
if
…… 
(
…… 
next
…… 
.
…… 
opposite
…… !
==
……" $
null
……% )
)
……) *
return
†† 
next
†† 
;
††  
next
ˆˆ 
=
ˆˆ 
next
ˆˆ 
.
ˆˆ 
opposite
ˆˆ $
.
ˆˆ$ %,
GetAdjacentEdgeWithCommonIndex
ˆˆ% C
(
ˆˆC D
common
ˆˆD J
)
ˆˆJ K
;
ˆˆK L
}
‰‰ 
return
‹‹ 
null
‹‹ 
;
‹‹ 
}
ŒŒ 	
}
 
} €
•D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\WingedEdgeEnumerator.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

sealed 
class  
WingedEdgeEnumerator ,
:- .
IEnumerator/ :
<: ;

WingedEdge; E
>E F
{ 

WingedEdge 
m_Start 
= 
null !
;! "

WingedEdge 
	m_Current 
= 
null #
;# $
public  
WingedEdgeEnumerator #
(# $

WingedEdge$ .
start/ 4
)4 5
{ 	
m_Start 
= 
start 
; 
	m_Current 
= 
null 
; 
} 	
public 
bool 
MoveNext 
( 
) 
{ 	
if   
(   
ReferenceEquals   
(    
	m_Current    )
,  ) *
null  + /
)  / 0
)  0 1
{!! 
	m_Current"" 
="" 
m_Start"" #
;""# $
return## 
!## 
ReferenceEquals## '
(##' (
	m_Current##( 1
,##1 2
null##3 7
)##7 8
;##8 9
}$$ 
	m_Current&& 
=&& 
	m_Current&& !
.&&! "
next&&" &
;&&& '
return(( 
!(( 
ReferenceEquals(( #
(((# $
	m_Current(($ -
,((- .
null((/ 3
)((3 4
&&((5 7
!((8 9
ReferenceEquals((9 H
(((H I
	m_Current((I R
,((R S
m_Start((T [
)(([ \
;((\ ]
})) 	
public,, 
void,, 
Reset,, 
(,, 
),, 
{-- 	
	m_Current.. 
=.. 
null.. 
;.. 
}// 	
public22 

WingedEdge22 
Current22 !
{33 	
get44 
{55 
try66 
{77 
return88 
	m_Current88 $
;88$ %
}99 
catch:: 
(:: $
IndexOutOfRangeException:: /
)::/ 0
{;; 
throw<< 
new<< %
InvalidOperationException<< 7
(<<7 8
)<<8 9
;<<9 :
}== 
}>> 
}?? 	
objectBB 
IEnumeratorBB 
.BB 
CurrentBB "
{CC 	
getDD 
{DD 
returnDD 
CurrentDD  
;DD  !
}DD" #
}EE 	
publicHH 
voidHH 
DisposeHH 
(HH 
)HH 
{HH 
}HH  
}II 
}JJ ú9
˜D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\MeshTransform.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
public 

static 
class 
MeshTransform %
{ 
internal 
static 
void 
SetPivot %
(% &
this& *
ProBuilderMesh+ 9
mesh: >
,> ?
PivotLocation@ M
	pivotTypeN W
,W X
intY \
firstVertexIndex] m
=n o
$nump q
)q r
{		 	
switch

 
(

 
	pivotType

 
)

 
{ 
case 
PivotLocation "
." #
Center# )
:) *
mesh 
. 
CenterPivot $
($ %
null% )
)) *
;* +
break 
; 
case 
PivotLocation "
." #
FirstVertex# .
:. /
mesh 
. 
CenterPivot $
($ %
new% (
int) ,
[, -
$num- .
]. /
{0 1
firstVertexIndex2 B
}C D
)D E
;E F
break 
; 
} 
} 	
public 
static 
void 
CenterPivot &
(& '
this' +
ProBuilderMesh, :
mesh; ?
,? @
intA D
[D E
]E F
indexesG N
)N O
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new 
System  
.  !!
ArgumentNullException! 6
(6 7
$str7 =
)= >
;> ?
Vector3   
center   
=   
Vector3   $
.  $ %
zero  % )
;  ) *
if"" 
("" 
indexes"" 
!="" 
null"" 
&&""  "
indexes""# *
.""* +
Length""+ 1
>""2 3
$num""4 5
)""5 6
{## 
Vector3$$ 
[$$ 
]$$ 
	positions$$ #
=$$$ %
mesh$$& *
.$$* +
positionsInternal$$+ <
;$$< =
if&& 
(&& 
	positions&& 
==&&  
null&&! %
||&&& (
	positions&&) 2
.&&2 3
Length&&3 9
<&&: ;
$num&&< =
)&&= >
return'' 
;'' 
foreach)) 
()) 
int)) 
i)) 
in)) !
indexes))" )
)))) *
center** 
+=** 
	positions** '
[**' (
i**( )
]**) *
;*** +
center,, 
=,, 
mesh,, 
.,, 
	transform,, '
.,,' (
TransformPoint,,( 6
(,,6 7
center,,7 =
/,,> ?
(,,@ A
float,,A F
),,F G
indexes,,G N
.,,N O
Length,,O U
),,U V
;,,V W
}-- 
else.. 
{// 
center00 
=00 
mesh00 
.00 
	transform00 '
.00' (
TransformPoint00( 6
(006 7
mesh007 ;
.00; <
mesh00< @
.00@ A
bounds00A G
.00G H
center00H N
)00N O
;00O P
}11 
Vector333 
dir33 
=33 
(33 
mesh33 
.33  
	transform33  )
.33) *
position33* 2
-333 4
center335 ;
)33; <
;33< =
mesh55 
.55 
	transform55 
.55 
position55 #
=55$ %
center55& ,
;55, -
mesh77 
.77 
ToMesh77 
(77 
)77 
;77 
mesh88 
.88 )
TranslateVerticesInWorldSpace88 .
(88. /
mesh88/ 3
.883 4
mesh884 8
.888 9
	triangles889 B
,88B C
dir88D G
)88G H
;88H I
mesh99 
.99 
Refresh99 
(99 
)99 
;99 
}:: 	
publicAA 
staticAA 
voidAA 
SetPivotAA #
(AA# $
thisAA$ (
ProBuilderMeshAA) 7
meshAA8 <
,AA< =
Vector3AA> E
worldPositionAAF S
)AAS T
{BB 	
ifCC 
(CC 
meshCC 
==CC 
nullCC 
)CC 
throwDD 
newDD 
SystemDD  
.DD  !!
ArgumentNullExceptionDD! 6
(DD6 7
$strDD7 =
)DD= >
;DD> ?
Vector3FF 
offsetFF 
=FF 
meshFF !
.FF! "
	transformFF" +
.FF+ ,
positionFF, 4
-FF5 6
worldPositionFF7 D
;FFD E
meshGG 
.GG 
	transformGG 
.GG 
positionGG #
=GG$ %
worldPositionGG& 3
;GG3 4
meshHH 
.HH 
ToMeshHH 
(HH 
)HH 
;HH 
meshII 
.II )
TranslateVerticesInWorldSpaceII .
(II. /
meshII/ 3
.II3 4
meshII4 8
.II8 9
	trianglesII9 B
,IIB C
offsetIID J
)IIJ K
;IIK L
meshJJ 
.JJ 
RefreshJJ 
(JJ 
)JJ 
;JJ 
}KK 	
publicQQ 
staticQQ 
voidQQ  
FreezeScaleTransformQQ /
(QQ/ 0
thisQQ0 4
ProBuilderMeshQQ5 C
meshQQD H
)QQH I
{RR 	
ifSS 
(SS 
meshSS 
==SS 
nullSS 
)SS 
throwTT 
newTT 
SystemTT  
.TT  !!
ArgumentNullExceptionTT! 6
(TT6 7
$strTT7 =
)TT= >
;TT> ?
Vector3VV 
[VV 
]VV 
vVV 
=VV 
meshVV 
.VV 
positionsInternalVV 0
;VV0 1
forXX 
(XX 
varXX 
iXX 
=XX 
$numXX 
;XX 
iXX 
<XX 
vXX  !
.XX! "
LengthXX" (
;XX( )
iXX* +
++XX+ -
)XX- .
vYY 
[YY 
iYY 
]YY 
=YY 
Vector3YY 
.YY 
ScaleYY $
(YY$ %
vYY% &
[YY& '
iYY' (
]YY( )
,YY) *
meshYY+ /
.YY/ 0
	transformYY0 9
.YY9 :

localScaleYY: D
)YYD E
;YYE F
mesh[[ 
.[[ 
	transform[[ 
.[[ 

localScale[[ %
=[[& '
new[[( +
Vector3[[, 3
([[3 4
$num[[4 6
,[[6 7
$num[[8 :
,[[: ;
$num[[< >
)[[> ?
;[[? @
}\\ 	
}]] 
}^^ ¼é
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ColorUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed		 

class		 
HSVColor		 
{

 
public 
float 
h 
, 
s 
, 
v 
; 
public 
HSVColor 
( 
float 
h 
,  
float! &
s' (
,( )
float* /
v0 1
)1 2
{ 	
this 
. 
h 
= 
h 
; 
this 
. 
s 
= 
s 
; 
this 
. 
v 
= 
v 
; 
} 	
public 
HSVColor 
( 
float 
h 
,  
float! &
s' (
,( )
float* /
v0 1
,1 2
float3 8
sv_modifier9 D
)D E
{ 	
this 
. 
h 
= 
h 
; 
this 
. 
s 
= 
s 
* 
sv_modifier $
;$ %
this 
. 
v 
= 
v 
* 
sv_modifier $
;$ %
} 	
public 
static 
HSVColor 
FromRGB &
(& '
Color' ,
col- 0
)0 1
{   	
return!! 
ColorUtility!! 
.!!  
RGBtoHSV!!  (
(!!( )
col!!) ,
)!!, -
;!!- .
}"" 	
public$$ 
override$$ 
string$$ 
ToString$$ '
($$' (
)$$( )
{%% 	
return&& 
string&& 
.&& 
Format&&  
(&&  !
$str&&! 4
,&&4 5
h&&6 7
,&&7 8
s&&9 :
,&&: ;
v&&< =
)&&= >
;&&> ?
}'' 	
public)) 
float)) 
SqrDistance))  
())  !
HSVColor))! )
InColor))* 1
)))1 2
{** 	
return++ 
(++ 
InColor++ 
.++ 
h++ 
/++ 
$num++  $
-++% &
this++' +
.+++ ,
h++, -
/++. /
$num++0 4
)++4 5
+++6 7
(++8 9
InColor++9 @
.++@ A
s++A B
-++C D
this++E I
.++I J
s++J K
)++K L
+++M N
(++O P
InColor++P W
.++W X
v++X Y
-++Z [
this++\ `
.++` a
v++a b
)++b c
;++c d
},, 	
}-- 
sealed33 

class33 
XYZColor33 
{44 
public55 
float55 
x55 
,55 
y55 
,55 
z55 
;55 
public77 
XYZColor77 
(77 
float77 
x77 
,77  
float77! &
y77' (
,77( )
float77* /
z770 1
)771 2
{88 	
this99 
.99 
x99 
=99 
x99 
;99 
this:: 
.:: 
y:: 
=:: 
y:: 
;:: 
this;; 
.;; 
z;; 
=;; 
z;; 
;;; 
}<< 	
public>> 
static>> 
XYZColor>> 
FromRGB>> &
(>>& '
Color>>' ,
col>>- 0
)>>0 1
{?? 	
return@@ 
ColorUtility@@ 
.@@  
RGBToXYZ@@  (
(@@( )
col@@) ,
)@@, -
;@@- .
}AA 	
publicCC 
staticCC 
XYZColorCC 
FromRGBCC &
(CC& '
floatCC' ,
RCC- .
,CC. /
floatCC0 5
GCC6 7
,CC7 8
floatCC9 >
BCC? @
)CC@ A
{DD 	
returnEE 
ColorUtilityEE 
.EE  
RGBToXYZEE  (
(EE( )
REE) *
,EE* +
GEE, -
,EE- .
BEE/ 0
)EE0 1
;EE1 2
}FF 	
publicHH 
overrideHH 
stringHH 
ToStringHH '
(HH' (
)HH( )
{II 	
returnJJ 
stringJJ 
.JJ 
FormatJJ  
(JJ  !
$strJJ! 4
,JJ4 5
xJJ6 7
,JJ7 8
yJJ9 :
,JJ: ;
zJJ< =
)JJ= >
;JJ> ?
}KK 	
}LL 
sealedQQ 

classQQ 
CIELabColorQQ 
{RR 
publicSS 
floatSS 
LSS 
,SS 
aSS 
,SS 
bSS 
;SS 
publicUU 
CIELabColorUU 
(UU 
floatUU  
LUU! "
,UU" #
floatUU$ )
aUU* +
,UU+ ,
floatUU- 2
bUU3 4
)UU4 5
{VV 	
thisWW 
.WW 
LWW 
=WW 
LWW 
;WW 
thisXX 
.XX 
aXX 
=XX 
aXX 
;XX 
thisYY 
.YY 
bYY 
=YY 
bYY 
;YY 
}ZZ 	
public\\ 
static\\ 
CIELabColor\\ !
FromXYZ\\" )
(\\) *
XYZColor\\* 2
xyz\\3 6
)\\6 7
{]] 	
return^^ 
ColorUtility^^ 
.^^  
XYZToCIE_Lab^^  ,
(^^, -
xyz^^- 0
)^^0 1
;^^1 2
}__ 	
publicaa 
staticaa 
CIELabColoraa !
FromRGBaa" )
(aa) *
Coloraa* /
colaa0 3
)aa3 4
{bb 	
XYZColorcc 
xyzcc 
=cc 
XYZColorcc #
.cc# $
FromRGBcc$ +
(cc+ ,
colcc, /
)cc/ 0
;cc0 1
returnee 
ColorUtilityee 
.ee  
XYZToCIE_Labee  ,
(ee, -
xyzee- 0
)ee0 1
;ee1 2
}ff 	
publichh 
overridehh 
stringhh 
ToStringhh '
(hh' (
)hh( )
{ii 	
returnjj 
stringjj 
.jj 
Formatjj  
(jj  !
$strjj! 4
,jj4 5
Ljj6 7
,jj7 8
ajj9 :
,jj: ;
bjj< =
)jj= >
;jj> ?
}kk 	
}ll 
staticqq 

classqq 
ColorUtilityqq 
{rr 
staticyy 
boolyy 
approxyy 
(yy 
floatyy  
lhsyy! $
,yy$ %
floatyy& +
rhsyy, /
)yy/ 0
{zz 	
return{{ 
Mathf{{ 
.{{ 
Abs{{ 
({{ 
lhs{{  
-{{! "
rhs{{# &
){{& '
<{{( )
Mathf{{* /
.{{/ 0
Epsilon{{0 7
;{{7 8
}|| 	
public~~ 
static~~ 
Color~~ 
GetColor~~ $
(~~$ %
Vector3~~% ,
vec~~- 0
)~~0 1
{ 	
vec
€€ 
.
€€ 
	Normalize
€€ 
(
€€ 
)
€€ 
;
€€ 
return
 
new
 
Color
 
(
 
Mathf
 "
.
" #
Abs
# &
(
& '
vec
' *
.
* +
x
+ ,
)
, -
,
- .
Mathf
/ 4
.
4 5
Abs
5 8
(
8 9
vec
9 <
.
< =
y
= >
)
> ?
,
? @
Mathf
A F
.
F G
Abs
G J
(
J K
vec
K N
.
N O
z
O P
)
P Q
,
Q R
$num
S U
)
U V
;
V W
}
‚‚ 	
public
‰‰ 
static
‰‰ 
XYZColor
‰‰ 
RGBToXYZ
‰‰ '
(
‰‰' (
Color
‰‰( -
col
‰‰. 1
)
‰‰1 2
{
ŠŠ 	
return
‹‹ 
RGBToXYZ
‹‹ 
(
‹‹ 
col
‹‹ 
.
‹‹  
r
‹‹  !
,
‹‹! "
col
‹‹# &
.
‹‹& '
g
‹‹' (
,
‹‹( )
col
‹‹* -
.
‹‹- .
b
‹‹. /
)
‹‹/ 0
;
‹‹0 1
}
ŒŒ 	
public
 
static
 
XYZColor
 
RGBToXYZ
 '
(
' (
float
( -
r
. /
,
/ 0
float
1 6
g
7 8
,
8 9
float
: ?
b
@ A
)
A B
{
 	
if
 
(
 
r
 
>
 
$num
 
)
 
r
‘‘ 
=
‘‘ 
Mathf
‘‘ 
.
‘‘ 
Pow
‘‘ 
(
‘‘ 
(
‘‘ 
(
‘‘  
r
‘‘  !
+
‘‘" #
$num
‘‘$ *
)
‘‘* +
/
‘‘, -
$num
‘‘. 4
)
‘‘4 5
,
‘‘5 6
$num
‘‘7 ;
)
‘‘; <
;
‘‘< =
else
’’ 
r
““ 
=
““ 
r
““ 
/
““ 
$num
““ 
;
““ 
if
•• 
(
•• 
g
•• 
>
•• 
$num
•• 
)
•• 
g
–– 
=
–– 
Mathf
–– 
.
–– 
Pow
–– 
(
–– 
(
–– 
(
––  
g
––  !
+
––" #
$num
––$ *
)
––* +
/
––, -
$num
––. 4
)
––4 5
,
––5 6
$num
––7 ;
)
––; <
;
––< =
else
—— 
g
˜˜ 
=
˜˜ 
g
˜˜ 
/
˜˜ 
$num
˜˜ 
;
˜˜ 
if
šš 
(
šš 
b
šš 
>
šš 
$num
šš 
)
šš 
b
›› 
=
›› 
Mathf
›› 
.
›› 
Pow
›› 
(
›› 
(
›› 
(
››  
b
››  !
+
››" #
$num
››$ *
)
››* +
/
››, -
$num
››. 4
)
››4 5
,
››5 6
$num
››7 ;
)
››; <
;
››< =
else
œœ 
b
 
=
 
b
 
/
 
$num
 
;
 
r
ŸŸ 
=
ŸŸ 
r
ŸŸ 
*
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
g
   
=
   
g
   
*
   
$num
   
;
   
b
¡¡ 
=
¡¡ 
b
¡¡ 
*
¡¡ 
$num
¡¡ 
;
¡¡ 
float
¤¤ 
x
¤¤ 
=
¤¤ 
r
¤¤ 
*
¤¤ 
$num
¤¤ !
+
¤¤" #
g
¤¤$ %
*
¤¤& '
$num
¤¤( /
+
¤¤0 1
b
¤¤2 3
*
¤¤4 5
$num
¤¤6 =
;
¤¤= >
float
¥¥ 
y
¥¥ 
=
¥¥ 
r
¥¥ 
*
¥¥ 
$num
¥¥ !
+
¥¥" #
g
¥¥$ %
*
¥¥& '
$num
¥¥( /
+
¥¥0 1
b
¥¥2 3
*
¥¥4 5
$num
¥¥6 =
;
¥¥= >
float
¦¦ 
z
¦¦ 
=
¦¦ 
r
¦¦ 
*
¦¦ 
$num
¦¦ !
+
¦¦" #
g
¦¦$ %
*
¦¦& '
$num
¦¦( /
+
¦¦0 1
b
¦¦2 3
*
¦¦4 5
$num
¦¦6 =
;
¦¦= >
return
¨¨ 
new
¨¨ 
XYZColor
¨¨ 
(
¨¨  
x
¨¨  !
,
¨¨! "
y
¨¨# $
,
¨¨$ %
z
¨¨& '
)
¨¨' (
;
¨¨( )
}
©© 	
public
°° 
static
°° 
CIELabColor
°° !
XYZToCIE_Lab
°°" .
(
°°. /
XYZColor
°°/ 7
xyz
°°8 ;
)
°°; <
{
±± 	
float
²² 
var_X
²² 
=
²² 
xyz
²² 
.
²² 
x
²² 
/
²²  !
$num
²²" )
;
²²) *
float
³³ 
var_Y
³³ 
=
³³ 
xyz
³³ 
.
³³ 
y
³³ 
/
³³  !
$num
³³" *
;
³³* +
float
´´ 
var_Z
´´ 
=
´´ 
xyz
´´ 
.
´´ 
z
´´ 
/
´´  !
$num
´´" *
;
´´* +
if
¶¶ 
(
¶¶ 
var_X
¶¶ 
>
¶¶ 
$num
¶¶ !
)
¶¶! "
var_X
·· 
=
·· 
Mathf
·· 
.
·· 
Pow
·· !
(
··! "
var_X
··" '
,
··' (
(
··) *
$num
··* +
/
··, -
$num
··. 0
)
··0 1
)
··1 2
;
··2 3
else
¸¸ 
var_X
¹¹ 
=
¹¹ 
(
¹¹ 
$num
¹¹ 
*
¹¹  !
var_X
¹¹" '
)
¹¹' (
+
¹¹) *
(
¹¹+ ,
$num
¹¹, /
/
¹¹0 1
$num
¹¹2 6
)
¹¹6 7
;
¹¹7 8
if
»» 
(
»» 
var_Y
»» 
>
»» 
$num
»» !
)
»»! "
var_Y
¼¼ 
=
¼¼ 
Mathf
¼¼ 
.
¼¼ 
Pow
¼¼ !
(
¼¼! "
var_Y
¼¼" '
,
¼¼' (
(
¼¼) *
$num
¼¼* +
/
¼¼, -
$num
¼¼. 0
)
¼¼0 1
)
¼¼1 2
;
¼¼2 3
else
½½ 
var_Y
¾¾ 
=
¾¾ 
(
¾¾ 
$num
¾¾ 
*
¾¾  !
var_Y
¾¾" '
)
¾¾' (
+
¾¾) *
(
¾¾+ ,
$num
¾¾, /
/
¾¾0 1
$num
¾¾2 6
)
¾¾6 7
;
¾¾7 8
if
ÀÀ 
(
ÀÀ 
var_Z
ÀÀ 
>
ÀÀ 
$num
ÀÀ !
)
ÀÀ! "
var_Z
ÁÁ 
=
ÁÁ 
Mathf
ÁÁ 
.
ÁÁ 
Pow
ÁÁ !
(
ÁÁ! "
var_Z
ÁÁ" '
,
ÁÁ' (
(
ÁÁ) *
$num
ÁÁ* +
/
ÁÁ, -
$num
ÁÁ. 0
)
ÁÁ0 1
)
ÁÁ1 2
;
ÁÁ2 3
else
ÂÂ 
var_Z
ÃÃ 
=
ÃÃ 
(
ÃÃ 
$num
ÃÃ 
*
ÃÃ  !
var_Z
ÃÃ" '
)
ÃÃ' (
+
ÃÃ) *
(
ÃÃ+ ,
$num
ÃÃ, /
/
ÃÃ0 1
$num
ÃÃ2 6
)
ÃÃ6 7
;
ÃÃ7 8
float
ÅÅ 
L
ÅÅ 
=
ÅÅ 
(
ÅÅ 
$num
ÅÅ 
*
ÅÅ 
var_Y
ÅÅ #
)
ÅÅ# $
-
ÅÅ% &
$num
ÅÅ' *
;
ÅÅ* +
float
ÆÆ 
a
ÆÆ 
=
ÆÆ 
$num
ÆÆ 
*
ÆÆ 
(
ÆÆ 
var_X
ÆÆ #
-
ÆÆ$ %
var_Y
ÆÆ& +
)
ÆÆ+ ,
;
ÆÆ, -
float
ÇÇ 
b
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
*
ÇÇ 
(
ÇÇ 
var_Y
ÇÇ #
-
ÇÇ$ %
var_Z
ÇÇ& +
)
ÇÇ+ ,
;
ÇÇ, -
return
ÉÉ 
new
ÉÉ 
CIELabColor
ÉÉ "
(
ÉÉ" #
L
ÉÉ# $
,
ÉÉ$ %
a
ÉÉ& '
,
ÉÉ' (
b
ÉÉ) *
)
ÉÉ* +
;
ÉÉ+ ,
}
ÊÊ 	
public
ÓÓ 
static
ÓÓ 
float
ÓÓ 
DeltaE
ÓÓ "
(
ÓÓ" #
CIELabColor
ÓÓ# .
lhs
ÓÓ/ 2
,
ÓÓ2 3
CIELabColor
ÓÓ4 ?
rhs
ÓÓ@ C
)
ÓÓC D
{
ÔÔ 	
return
ÕÕ 
Mathf
ÕÕ 
.
ÕÕ 
Sqrt
ÕÕ 
(
ÕÕ 
Mathf
ÖÖ 
.
ÖÖ 
Pow
ÖÖ 
(
ÖÖ 
(
ÖÖ 
lhs
ÖÖ 
.
ÖÖ 
L
ÖÖ  
-
ÖÖ! "
rhs
ÖÖ# &
.
ÖÖ& '
L
ÖÖ' (
)
ÖÖ( )
,
ÖÖ) *
$num
ÖÖ+ ,
)
ÖÖ, -
+
ÖÖ. /
Mathf
×× 
.
×× 
Pow
×× 
(
×× 
(
×× 
lhs
×× 
.
×× 
a
××  
-
××! "
rhs
××# &
.
××& '
a
××' (
)
××( )
,
××) *
$num
××+ ,
)
××, -
+
××. /
Mathf
ØØ 
.
ØØ 
Pow
ØØ 
(
ØØ 
(
ØØ 
lhs
ØØ 
.
ØØ 
b
ØØ  
-
ØØ! "
rhs
ØØ# &
.
ØØ& '
b
ØØ' (
)
ØØ( )
,
ØØ) *
$num
ØØ+ ,
)
ØØ, -
)
ØØ- .
;
ØØ. /
}
ÙÙ 	
public
ää 
static
ää 
Color
ää 
HSVtoRGB
ää $
(
ää$ %
HSVColor
ää% -
hsv
ää. 1
)
ää1 2
{
åå 	
return
ææ 
HSVtoRGB
ææ 
(
ææ 
hsv
ææ 
.
ææ  
h
ææ  !
,
ææ! "
hsv
ææ# &
.
ææ& '
s
ææ' (
,
ææ( )
hsv
ææ* -
.
ææ- .
v
ææ. /
)
ææ/ 0
;
ææ0 1
}
çç 	
public
ğğ 
static
ğğ 
Color
ğğ 
HSVtoRGB
ğğ $
(
ğğ$ %
float
ğğ% *
h
ğğ+ ,
,
ğğ, -
float
ğğ. 3
s
ğğ4 5
,
ğğ5 6
float
ğğ7 <
v
ğğ= >
)
ğğ> ?
{
ññ 	
float
òò 
r
òò 
,
òò 
g
òò 
,
òò 
b
òò 
;
òò 
int
óó 
i
óó 
;
óó 
float
ôô 
f
ôô 
,
ôô 
p
ôô 
,
ôô 
q
ôô 
,
ôô 
t
ôô 
;
ôô 
if
õõ 
(
õõ 
s
õõ 
==
õõ 
$num
õõ 
)
õõ 
{
öö 
return
øø 
new
øø 
Color
øø  
(
øø  !
v
øø! "
,
øø" #
v
øø$ %
,
øø% &
v
øø' (
,
øø( )
$num
øø* ,
)
øø, -
;
øø- .
}
ùù 
h
úú 
/=
úú 
$num
úú 
;
úú 
i
ûû 
=
ûû 
(
ûû 
int
ûû 
)
ûû 
Mathf
ûû 
.
ûû 
Floor
ûû  
(
ûû  !
h
ûû! "
)
ûû" #
;
ûû# $
f
üü 
=
üü 
h
üü 
-
üü 
i
üü 
;
üü 
p
ıı 
=
ıı 
v
ıı 
*
ıı 
(
ıı 
$num
ıı 
-
ıı 
s
ıı 
)
ıı 
;
ıı 
q
şş 
=
şş 
v
şş 
*
şş 
(
şş 
$num
şş 
-
şş 
s
şş 
*
şş 
f
şş 
)
şş 
;
şş  
t
ÿÿ 
=
ÿÿ 
v
ÿÿ 
*
ÿÿ 
(
ÿÿ 
$num
ÿÿ 
-
ÿÿ 
s
ÿÿ 
*
ÿÿ 
(
ÿÿ 
$num
ÿÿ 
-
ÿÿ  !
f
ÿÿ" #
)
ÿÿ# $
)
ÿÿ$ %
;
ÿÿ% &
switch
 
(
 
i
 
)
 
{
‚‚ 
case
ƒƒ 
$num
ƒƒ 
:
ƒƒ 
r
„„ 
=
„„ 
v
„„ 
;
„„ 
g
…… 
=
…… 
t
…… 
;
…… 
b
†† 
=
†† 
p
†† 
;
†† 
break
‡‡ 
;
‡‡ 
case
ˆˆ 
$num
ˆˆ 
:
ˆˆ 
r
‰‰ 
=
‰‰ 
q
‰‰ 
;
‰‰ 
g
ŠŠ 
=
ŠŠ 
v
ŠŠ 
;
ŠŠ 
b
‹‹ 
=
‹‹ 
p
‹‹ 
;
‹‹ 
break
ŒŒ 
;
ŒŒ 
case
 
$num
 
:
 
r
 
=
 
p
 
;
 
g
 
=
 
v
 
;
 
b
 
=
 
t
 
;
 
break
‘‘ 
;
‘‘ 
case
’’ 
$num
’’ 
:
’’ 
r
““ 
=
““ 
p
““ 
;
““ 
g
”” 
=
”” 
q
”” 
;
”” 
b
•• 
=
•• 
v
•• 
;
•• 
break
–– 
;
–– 
case
—— 
$num
—— 
:
—— 
r
˜˜ 
=
˜˜ 
t
˜˜ 
;
˜˜ 
g
™™ 
=
™™ 
p
™™ 
;
™™ 
b
šš 
=
šš 
v
šš 
;
šš 
break
›› 
;
›› 
default
œœ 
:
œœ 
r
 
=
 
v
 
;
 
g
 
=
 
p
 
;
 
b
ŸŸ 
=
ŸŸ 
q
ŸŸ 
;
ŸŸ 
break
   
;
   
}
¡¡ 
return
££ 
new
££ 
Color
££ 
(
££ 
r
££ 
,
££ 
g
££  !
,
££! "
b
££# $
,
££$ %
$num
££& (
)
££( )
;
££) *
}
¤¤ 	
public
®® 
static
®® 
HSVColor
®® 
RGBtoHSV
®® '
(
®®' (
Color
®®( -
color
®®. 3
)
®®3 4
{
¯¯ 	
float
°° 
h
°° 
,
°° 
s
°° 
,
°° 
v
°° 
;
°° 
float
±± 
r
±± 
=
±± 
color
±± 
.
±± 
r
±± 
,
±± 
b
±±  
=
±±! "
color
±±# (
.
±±( )
b
±±) *
,
±±* +
g
±±, -
=
±±. /
color
±±0 5
.
±±5 6
g
±±6 7
;
±±7 8
float
³³ 
min
³³ 
,
³³ 
max
³³ 
,
³³ 
delta
³³ !
;
³³! "
min
´´ 
=
´´ 
Mathf
´´ 
.
´´ 
Min
´´ 
(
´´ 
Mathf
´´ !
.
´´! "
Min
´´" %
(
´´% &
r
´´& '
,
´´' (
g
´´) *
)
´´* +
,
´´+ ,
b
´´- .
)
´´. /
;
´´/ 0
max
µµ 
=
µµ 
Mathf
µµ 
.
µµ 
Max
µµ 
(
µµ 
Mathf
µµ !
.
µµ! "
Max
µµ" %
(
µµ% &
r
µµ& '
,
µµ' (
g
µµ) *
)
µµ* +
,
µµ+ ,
b
µµ- .
)
µµ. /
;
µµ/ 0
v
·· 
=
·· 
max
·· 
;
·· 
delta
¹¹ 
=
¹¹ 
max
¹¹ 
-
¹¹ 
min
¹¹ 
;
¹¹ 
if
»» 
(
»» 
max
»» 
!=
»» 
$num
»» 
)
»» 
{
¼¼ 
s
½½ 
=
½½ 
delta
½½ 
/
½½ 
max
½½ 
;
½½  
}
¾¾ 
else
¿¿ 
{
ÀÀ 
s
ÂÂ 
=
ÂÂ 
$num
ÂÂ 
;
ÂÂ 
h
ÃÃ 
=
ÃÃ 
$num
ÃÃ 
;
ÃÃ 
return
ÄÄ 
new
ÄÄ 
HSVColor
ÄÄ #
(
ÄÄ# $
h
ÄÄ$ %
,
ÄÄ% &
s
ÄÄ' (
,
ÄÄ( )
v
ÄÄ* +
)
ÄÄ+ ,
;
ÄÄ, -
}
ÅÅ 
if
ÇÇ 
(
ÇÇ 
approx
ÇÇ 
(
ÇÇ 
r
ÇÇ 
,
ÇÇ 
max
ÇÇ 
)
ÇÇ 
)
ÇÇ 
{
ÈÈ 
h
ÉÉ 
=
ÉÉ 
(
ÉÉ 
g
ÉÉ 
-
ÉÉ 
b
ÉÉ 
)
ÉÉ 
/
ÉÉ 
delta
ÉÉ #
;
ÉÉ# $
if
ÊÊ 
(
ÊÊ 
float
ÊÊ 
.
ÊÊ 
IsNaN
ÊÊ 
(
ÊÊ  
h
ÊÊ  !
)
ÊÊ! "
)
ÊÊ" #
h
ËË 
=
ËË 
$num
ËË 
;
ËË 
}
ÌÌ 
else
ÍÍ 
if
ÍÍ 
(
ÍÍ 
approx
ÍÍ 
(
ÍÍ 
g
ÍÍ 
,
ÍÍ 
max
ÍÍ "
)
ÍÍ" #
)
ÍÍ# $
{
ÎÎ 
h
ÏÏ 
=
ÏÏ 
$num
ÏÏ 
+
ÏÏ 
(
ÏÏ 
b
ÏÏ 
-
ÏÏ 
r
ÏÏ 
)
ÏÏ  
/
ÏÏ! "
delta
ÏÏ# (
;
ÏÏ( )
}
ĞĞ 
else
ÑÑ 
{
ÒÒ 
h
ÓÓ 
=
ÓÓ 
$num
ÓÓ 
+
ÓÓ 
(
ÓÓ 
r
ÓÓ 
-
ÓÓ 
g
ÓÓ 
)
ÓÓ  
/
ÓÓ! "
delta
ÓÓ# (
;
ÓÓ( )
}
ÔÔ 
h
ÖÖ 
*=
ÖÖ 
$num
ÖÖ 
;
ÖÖ 
if
ØØ 
(
ØØ 
h
ØØ 
<
ØØ 
$num
ØØ 
)
ØØ 
h
ÙÙ 
+=
ÙÙ 
$num
ÙÙ 
;
ÙÙ 
return
ÛÛ 
new
ÛÛ 
HSVColor
ÛÛ 
(
ÛÛ  
h
ÛÛ  !
,
ÛÛ! "
s
ÛÛ# $
,
ÛÛ$ %
v
ÛÛ& '
)
ÛÛ' (
;
ÛÛ( )
}
ÜÜ 	
public
ãã 
static
ãã 
string
ãã 
GetColorName
ãã )
(
ãã) *
Color
ãã* /
InColor
ãã0 7
)
ãã7 8
{
ää 	
CIELabColor
åå 
lab
åå 
=
åå 
CIELabColor
åå )
.
åå) *
FromRGB
åå* 1
(
åå1 2
InColor
åå2 9
)
åå9 :
;
åå: ;
string
çç 
name
çç 
=
çç 
$str
çç #
;
çç# $
float
èè 
diff
èè 
=
èè 
Mathf
èè 
.
èè 
Infinity
èè '
;
èè' (
foreach
êê 
(
êê 
KeyValuePair
êê !
<
êê! "
string
êê" (
,
êê( )
CIELabColor
êê* 5
>
êê5 6
kvp
êê7 :
in
êê; =
ColorNameLookup
êê> M
)
êêM N
{
ëë 
float
ìì 
dist
ìì 
=
ìì 
Mathf
ìì "
.
ìì" #
Abs
ìì# &
(
ìì& '
DeltaE
ìì' -
(
ìì- .
lab
ìì. 1
,
ìì1 2
kvp
ìì3 6
.
ìì6 7
Value
ìì7 <
)
ìì< =
)
ìì= >
;
ìì> ?
if
îî 
(
îî 
dist
îî 
<
îî 
diff
îî 
)
îî  
{
ïï 
diff
ğğ 
=
ğğ 
dist
ğğ 
;
ğğ  
name
ññ 
=
ññ 
kvp
ññ 
.
ññ 
Key
ññ "
;
ññ" #
}
òò 
}
óó 
return
õõ 
name
õõ 
;
õõ 
}
öö 	
static
øø 
CIELabColor
øø 
CIELabFromRGB
øø (
(
øø( )
float
øø) .
R
øø/ 0
,
øø0 1
float
øø2 7
G
øø8 9
,
øø9 :
float
øø; @
B
øøA B
,
øøB C
float
øøD I
Scale
øøJ O
)
øøO P
{
ùù 	
float
úú 
	inv_scale
úú 
=
úú 
$num
úú  
/
úú! "
Scale
úú# (
;
úú( )
XYZColor
ûû 
xyz
ûû 
=
ûû 
XYZColor
ûû #
.
ûû# $
FromRGB
ûû$ +
(
ûû+ ,
R
ûû, -
*
ûû. /
	inv_scale
ûû0 9
,
ûû9 :
G
ûû; <
*
ûû= >
	inv_scale
ûû? H
,
ûûH I
B
ûûJ K
*
ûûL M
	inv_scale
ûûN W
)
ûûW X
;
ûûX Y
return
ıı 
CIELabColor
ıı 
.
ıı 
FromXYZ
ıı &
(
ıı& '
xyz
ıı' *
)
ıı* +
;
ıı+ ,
}
şş 	
static
ƒƒ 
readonly
ƒƒ 

Dictionary
ƒƒ "
<
ƒƒ" #
string
ƒƒ# )
,
ƒƒ) *
CIELabColor
ƒƒ+ 6
>
ƒƒ6 7
ColorNameLookup
ƒƒ8 G
=
ƒƒH I
new
ƒƒJ M

Dictionary
ƒƒN X
<
ƒƒX Y
string
ƒƒY _
,
ƒƒ_ `
CIELabColor
ƒƒa l
>
ƒƒl m
(
ƒƒm n
)
ƒƒn o
{
„„ 	
{
…… 
$str
…… 
,
…… 
CIELabFromRGB
……< I
(
……I J
$num
……J M
,
……M N
$num
……O R
,
……R S
$num
……T W
,
……W X
$num
……Y ]
)
……] ^
}
……d e
,
……e f
{
†† 
$str
†† 
,
†† 
CIELabFromRGB
††< I
(
††I J
$num
††J M
,
††M N
$num
††O R
,
††R S
$num
††T W
,
††W X
$num
††Y ]
)
††] ^
}
††d e
,
††e f
{
‡‡ 
$str
‡‡ 
,
‡‡ 
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J M
,
‡‡M N
$num
‡‡O S
,
‡‡S T
$num
‡‡U X
,
‡‡X Y
$num
‡‡Z ^
)
‡‡^ _
}
‡‡d e
,
‡‡e f
{
ˆˆ 
$str
ˆˆ 
,
ˆˆ 
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ M
,
ˆˆM N
$num
ˆˆO R
,
ˆˆR S
$num
ˆˆT W
,
ˆˆW X
$num
ˆˆY ]
)
ˆˆ] ^
}
ˆˆd e
,
ˆˆe f
{
‰‰ 
$str
‰‰ $
,
‰‰$ %
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J M
,
‰‰M N
$num
‰‰O R
,
‰‰R S
$num
‰‰T W
,
‰‰W X
$num
‰‰Y ]
)
‰‰] ^
}
‰‰d e
,
‰‰e f
{
ŠŠ 
$str
ŠŠ %
,
ŠŠ% &
CIELabFromRGB
ŠŠ< I
(
ŠŠI J
$num
ŠŠJ L
,
ŠŠL M
$num
ŠŠN Q
,
ŠŠQ R
$num
ŠŠS V
,
ŠŠV W
$num
ŠŠX \
)
ŠŠ\ ]
}
ŠŠd e
,
ŠŠe f
{
‹‹ 
$str
‹‹ $
,
‹‹$ %
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J M
,
‹‹M N
$num
‹‹O R
,
‹‹R S
$num
‹‹T W
,
‹‹W X
$num
‹‹Y ]
)
‹‹] ^
}
‹‹d e
,
‹‹e f
{
ŒŒ 
$str
ŒŒ 
,
ŒŒ  
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ M
,
ŒŒM N
$num
ŒŒO Q
,
ŒŒQ R
$num
ŒŒS V
,
ŒŒV W
$num
ŒŒX \
)
ŒŒ\ ]
}
ŒŒd e
,
ŒŒe f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T X
,
X Y
$num
Z ^
)
^ _
}
d e
,
e f
{
 
$str
  
,
  !
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T V
,
V W
$num
X \
)
\ ]
}
d e
,
e f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
‘‘ 
$str
‘‘ 
,
‘‘ 
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J M
,
‘‘M N
$num
‘‘O R
,
‘‘R S
$num
‘‘T W
,
‘‘W X
$num
‘‘Y ]
)
‘‘] ^
}
‘‘d e
,
‘‘e f
{
’’ 
$str
’’ $
,
’’$ %
CIELabFromRGB
’’< I
(
’’I J
$num
’’J M
,
’’M N
$num
’’O R
,
’’R S
$num
’’T W
,
’’W X
$num
’’Y ]
)
’’] ^
}
’’d e
,
’’e f
{
““ 
$str
““ 
,
““ 
CIELabFromRGB
““< I
(
““I J
$num
““J M
,
““M N
$num
““O R
,
““R S
$num
““T W
,
““W X
$num
““Y ]
)
““] ^
}
““d e
,
““e f
{
”” 
$str
”” 
,
””  
CIELabFromRGB
””< I
(
””I J
$num
””J M
,
””M N
$num
””O R
,
””R S
$num
””T W
,
””W X
$num
””Y ]
)
””] ^
}
””d e
,
””e f
{
•• 
$str
•• 
,
•• 
CIELabFromRGB
••< I
(
••I J
$num
••J M
,
••M N
$num
••O R
,
••R S
$num
••T W
,
••W X
$num
••Y ]
)
••] ^
}
••d e
,
••e f
{
–– 
$str
–– 
,
–– 
CIELabFromRGB
––< I
(
––I J
$num
––J M
,
––M N
$num
––O R
,
––R S
$num
––T W
,
––W X
$num
––Y ]
)
––] ^
}
––d e
,
––e f
{
—— 
$str
—— 
,
—— 
CIELabFromRGB
——< I
(
——I J
$num
——J N
,
——N O
$num
——P S
,
——S T
$num
——U W
,
——W X
$num
——Y ]
)
——] ^
}
——d e
,
——e f
{
˜˜ 
$str
˜˜ 
,
˜˜  
CIELabFromRGB
˜˜< I
(
˜˜I J
$num
˜˜J N
,
˜˜N O
$num
˜˜P S
,
˜˜S T
$num
˜˜U W
,
˜˜W X
$num
˜˜Y ]
)
˜˜] ^
}
˜˜d e
,
˜˜e f
{
™™ 
$str
™™ 
,
™™ 
CIELabFromRGB
™™< I
(
™™I J
$num
™™J N
,
™™N O
$num
™™P R
,
™™R S
$num
™™T W
,
™™W X
$num
™™Y ]
)
™™] ^
}
™™d e
,
™™e f
{
šš 
$str
šš 
,
šš 
CIELabFromRGB
šš< I
(
ššI J
$num
ššJ M
,
ššM N
$num
ššO R
,
ššR S
$num
ššT W
,
ššW X
$num
ššY ]
)
šš] ^
}
ššd e
,
šše f
{
›› 
$str
›› 
,
›› 
CIELabFromRGB
››< I
(
››I J
$num
››J M
,
››M N
$num
››O R
,
››R S
$num
››T W
,
››W X
$num
››Y ]
)
››] ^
}
››d e
,
››e f
{
œœ 
$str
œœ  
,
œœ  !
CIELabFromRGB
œœ< I
(
œœI J
$num
œœJ M
,
œœM N
$num
œœO R
,
œœR S
$num
œœT W
,
œœW X
$num
œœY ]
)
œœ] ^
}
œœd e
,
œœe f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
ŸŸ 
$str
ŸŸ 
,
ŸŸ  
CIELabFromRGB
ŸŸ< I
(
ŸŸI J
$num
ŸŸJ M
,
ŸŸM N
$num
ŸŸO R
,
ŸŸR S
$num
ŸŸT W
,
ŸŸW X
$num
ŸŸY ]
)
ŸŸ] ^
}
ŸŸd e
,
ŸŸe f
{
   
$str
   
,
   
CIELabFromRGB
  < I
(
  I J
$num
  J M
,
  M N
$num
  O R
,
  R S
$num
  T W
,
  W X
$num
  Y ]
)
  ] ^
}
  d e
,
  e f
{
¡¡ 
$str
¡¡ 
,
¡¡ 
CIELabFromRGB
¡¡< I
(
¡¡I J
$num
¡¡J M
,
¡¡M N
$num
¡¡O R
,
¡¡R S
$num
¡¡T W
,
¡¡W X
$num
¡¡Y ]
)
¡¡] ^
}
¡¡d e
,
¡¡e f
{
¢¢ 
$str
¢¢ 
,
¢¢ 
CIELabFromRGB
¢¢< I
(
¢¢I J
$num
¢¢J L
,
¢¢L M
$num
¢¢N Q
,
¢¢Q R
$num
¢¢S U
,
¢¢U V
$num
¢¢W [
)
¢¢[ \
}
¢¢d e
,
¢¢e f
{
££ 
$str
££ 
,
££ 
CIELabFromRGB
££< I
(
££I J
$num
££J M
,
££M N
$num
££O R
,
££R S
$num
££T V
,
££V W
$num
££X \
)
££\ ]
}
££d e
,
££e f
{
¤¤ 
$str
¤¤ 
,
¤¤ 
CIELabFromRGB
¤¤< I
(
¤¤I J
$num
¤¤J M
,
¤¤M N
$num
¤¤O R
,
¤¤R S
$num
¤¤T W
,
¤¤W X
$num
¤¤Y ]
)
¤¤] ^
}
¤¤d e
,
¤¤e f
{
¥¥ 
$str
¥¥ 
,
¥¥ 
CIELabFromRGB
¥¥< I
(
¥¥I J
$num
¥¥J L
,
¥¥L M
$num
¥¥N R
,
¥¥R S
$num
¥¥T X
,
¥¥X Y
$num
¥¥Z ^
)
¥¥^ _
}
¥¥d e
,
¥¥e f
{
¦¦ 
$str
¦¦ 
,
¦¦ 
CIELabFromRGB
¦¦< I
(
¦¦I J
$num
¦¦J M
,
¦¦M N
$num
¦¦O S
,
¦¦S T
$num
¦¦U X
,
¦¦X Y
$num
¦¦Z ^
)
¦¦^ _
}
¦¦d e
,
¦¦e f
{
§§ 
$str
§§ 
,
§§ 
CIELabFromRGB
§§< I
(
§§I J
$num
§§J M
,
§§M N
$num
§§O R
,
§§R S
$num
§§T W
,
§§W X
$num
§§Y ]
)
§§] ^
}
§§d e
,
§§e f
{
¨¨ 
$str
¨¨ 
,
¨¨ 
CIELabFromRGB
¨¨< I
(
¨¨I J
$num
¨¨J M
,
¨¨M N
$num
¨¨O R
,
¨¨R S
$num
¨¨T W
,
¨¨W X
$num
¨¨Y ]
)
¨¨] ^
}
¨¨d e
,
¨¨e f
{
©© 
$str
©© 
,
©© 
CIELabFromRGB
©©< I
(
©©I J
$num
©©J M
,
©©M N
$num
©©O R
,
©©R S
$num
©©T W
,
©©W X
$num
©©Y ]
)
©©] ^
}
©©d e
,
©©e f
{
ªª 
$str
ªª 
,
ªª 
CIELabFromRGB
ªª< I
(
ªªI J
$num
ªªJ M
,
ªªM N
$num
ªªO R
,
ªªR S
$num
ªªT W
,
ªªW X
$num
ªªY ]
)
ªª] ^
}
ªªd e
,
ªªe f
{
«« 
$str
«« 
,
«« 
CIELabFromRGB
««< I
(
««I J
$num
««J M
,
««M N
$num
««O R
,
««R S
$num
««T W
,
««W X
$num
««Y ]
)
««] ^
}
««d e
,
««e f
{
¬¬ 
$str
¬¬ 
,
¬¬ 
CIELabFromRGB
¬¬< I
(
¬¬I J
$num
¬¬J M
,
¬¬M N
$num
¬¬O R
,
¬¬R S
$num
¬¬T W
,
¬¬W X
$num
¬¬Y ]
)
¬¬] ^
}
¬¬d e
,
¬¬e f
{
­­ 
$str
­­  
,
­­  !
CIELabFromRGB
­­< I
(
­­I J
$num
­­J N
,
­­N O
$num
­­P S
,
­­S T
$num
­­U X
,
­­X Y
$num
­­Z ^
)
­­^ _
}
­­d e
,
­­e f
{
®® 
$str
®® 
,
®® 
CIELabFromRGB
®®< I
(
®®I J
$num
®®J M
,
®®M N
$num
®®O R
,
®®R S
$num
®®T W
,
®®W X
$num
®®Y ]
)
®®] ^
}
®®d e
,
®®e f
{
¯¯ 
$str
¯¯ 
,
¯¯ 
CIELabFromRGB
¯¯< I
(
¯¯I J
$num
¯¯J M
,
¯¯M N
$num
¯¯O R
,
¯¯R S
$num
¯¯T V
,
¯¯V W
$num
¯¯X \
)
¯¯\ ]
}
¯¯d e
,
¯¯e f
{
°° 
$str
°° 
,
°°  
CIELabFromRGB
°°< I
(
°°I J
$num
°°J M
,
°°M N
$num
°°O R
,
°°R S
$num
°°T W
,
°°W X
$num
°°Y ]
)
°°] ^
}
°°d e
,
°°e f
{
±± 
$str
±± 
,
±± 
CIELabFromRGB
±±< I
(
±±I J
$num
±±J M
,
±±M N
$num
±±O R
,
±±R S
$num
±±T V
,
±±V W
$num
±±X \
)
±±\ ]
}
±±d e
,
±±e f
{
²² 
$str
²² 
,
²² 
CIELabFromRGB
²²< I
(
²²I J
$num
²²J L
,
²²L M
$num
²²N Q
,
²²Q R
$num
²²S W
,
²²W X
$num
²²Y ]
)
²²] ^
}
²²d e
,
²²e f
{
³³ 
$str
³³ !
,
³³! "
CIELabFromRGB
³³< I
(
³³I J
$num
³³J M
,
³³M N
$num
³³O S
,
³³S T
$num
³³U Y
,
³³Y Z
$num
³³[ _
)
³³_ `
}
³³d e
,
³³e f
{
´´ 
$str
´´ 
,
´´ 
CIELabFromRGB
´´< I
(
´´I J
$num
´´J M
,
´´M N
$num
´´O S
,
´´S T
$num
´´U Y
,
´´Y Z
$num
´´[ _
)
´´_ `
}
´´d e
,
´´e f
{
µµ 
$str
µµ 
,
µµ 
CIELabFromRGB
µµ< I
(
µµI J
$num
µµJ M
,
µµM N
$num
µµO R
,
µµR S
$num
µµT W
,
µµW X
$num
µµY ]
)
µµ] ^
}
µµd e
,
µµe f
{
¶¶ 
$str
¶¶ 
,
¶¶ 
CIELabFromRGB
¶¶< I
(
¶¶I J
$num
¶¶J M
,
¶¶M N
$num
¶¶O R
,
¶¶R S
$num
¶¶T W
,
¶¶W X
$num
¶¶Y ]
)
¶¶] ^
}
¶¶d e
,
¶¶e f
{
·· 
$str
·· 
,
·· 
CIELabFromRGB
··< I
(
··I J
$num
··J M
,
··M N
$num
··O R
,
··R S
$num
··T W
,
··W X
$num
··Y ]
)
··] ^
}
··d e
,
··e f
{
¸¸ 
$str
¸¸ 
,
¸¸ 
CIELabFromRGB
¸¸< I
(
¸¸I J
$num
¸¸J M
,
¸¸M N
$num
¸¸O R
,
¸¸R S
$num
¸¸T W
,
¸¸W X
$num
¸¸Y ]
)
¸¸] ^
}
¸¸d e
,
¸¸e f
{
¹¹ 
$str
¹¹ 
,
¹¹ 
CIELabFromRGB
¹¹< I
(
¹¹I J
$num
¹¹J N
,
¹¹N O
$num
¹¹P T
,
¹¹T U
$num
¹¹V Y
,
¹¹Y Z
$num
¹¹[ _
)
¹¹_ `
}
¹¹d e
,
¹¹e f
{
ºº 
$str
ºº !
,
ºº! "
CIELabFromRGB
ºº< I
(
ººI J
$num
ººJ N
,
ººN O
$num
ººP S
,
ººS T
$num
ººU X
,
ººX Y
$num
ººZ ^
)
ºº^ _
}
ººd e
,
ººe f
{
»» 
$str
»» 
,
»» 
CIELabFromRGB
»»< I
(
»»I J
$num
»»J M
,
»»M N
$num
»»O R
,
»»R S
$num
»»T W
,
»»W X
$num
»»Y ]
)
»»] ^
}
»»d e
,
»»e f
{
¼¼ 
$str
¼¼ 
,
¼¼ 
CIELabFromRGB
¼¼< I
(
¼¼I J
$num
¼¼J M
,
¼¼M N
$num
¼¼O R
,
¼¼R S
$num
¼¼T W
,
¼¼W X
$num
¼¼Y ]
)
¼¼] ^
}
¼¼d e
,
¼¼e f
{
½½ 
$str
½½ 
,
½½ 
CIELabFromRGB
½½< I
(
½½I J
$num
½½J N
,
½½N O
$num
½½P S
,
½½S T
$num
½½U X
,
½½X Y
$num
½½Z ^
)
½½^ _
}
½½d e
,
½½e f
{
¾¾ 
$str
¾¾  
,
¾¾  !
CIELabFromRGB
¾¾< I
(
¾¾I J
$num
¾¾J L
,
¾¾L M
$num
¾¾N Q
,
¾¾Q R
$num
¾¾S V
,
¾¾V W
$num
¾¾X \
)
¾¾\ ]
}
¾¾d e
,
¾¾e f
{
¿¿ 
$str
¿¿ 
,
¿¿ 
CIELabFromRGB
¿¿< I
(
¿¿I J
$num
¿¿J M
,
¿¿M N
$num
¿¿O R
,
¿¿R S
$num
¿¿T W
,
¿¿W X
$num
¿¿Y ]
)
¿¿] ^
}
¿¿d e
,
¿¿e f
{
ÀÀ 
$str
ÀÀ 
,
ÀÀ 
CIELabFromRGB
ÀÀ< I
(
ÀÀI J
$num
ÀÀJ M
,
ÀÀM N
$num
ÀÀO Q
,
ÀÀQ R
$num
ÀÀS U
,
ÀÀU V
$num
ÀÀW [
)
ÀÀ[ \
}
ÀÀd e
,
ÀÀe f
{
ÁÁ 
$str
ÁÁ 
,
ÁÁ  
CIELabFromRGB
ÁÁ< I
(
ÁÁI J
$num
ÁÁJ M
,
ÁÁM N
$num
ÁÁO R
,
ÁÁR S
$num
ÁÁT W
,
ÁÁW X
$num
ÁÁY ]
)
ÁÁ] ^
}
ÁÁd e
,
ÁÁe f
{
ÂÂ 
$str
ÂÂ 
,
ÂÂ 
CIELabFromRGB
ÂÂ< I
(
ÂÂI J
$num
ÂÂJ M
,
ÂÂM N
$num
ÂÂO R
,
ÂÂR S
$num
ÂÂT W
,
ÂÂW X
$num
ÂÂY ]
)
ÂÂ] ^
}
ÂÂd e
,
ÂÂe f
{
ÃÃ 
$str
ÃÃ 
,
ÃÃ 
CIELabFromRGB
ÃÃ< I
(
ÃÃI J
$num
ÃÃJ M
,
ÃÃM N
$num
ÃÃO R
,
ÃÃR S
$num
ÃÃT W
,
ÃÃW X
$num
ÃÃY ]
)
ÃÃ] ^
}
ÃÃd e
,
ÃÃe f
{
ÄÄ 
$str
ÄÄ 
,
ÄÄ 
CIELabFromRGB
ÄÄ< I
(
ÄÄI J
$num
ÄÄJ M
,
ÄÄM N
$num
ÄÄO R
,
ÄÄR S
$num
ÄÄT W
,
ÄÄW X
$num
ÄÄY ]
)
ÄÄ] ^
}
ÄÄd e
,
ÄÄe f
{
ÅÅ 
$str
ÅÅ 
,
ÅÅ 
CIELabFromRGB
ÅÅ< I
(
ÅÅI J
$num
ÅÅJ M
,
ÅÅM N
$num
ÅÅO R
,
ÅÅR S
$num
ÅÅT W
,
ÅÅW X
$num
ÅÅY ]
)
ÅÅ] ^
}
ÅÅd e
,
ÅÅe f
{
ÆÆ 
$str
ÆÆ 
,
ÆÆ 
CIELabFromRGB
ÆÆ< I
(
ÆÆI J
$num
ÆÆJ M
,
ÆÆM N
$num
ÆÆO R
,
ÆÆR S
$num
ÆÆT W
,
ÆÆW X
$num
ÆÆY ]
)
ÆÆ] ^
}
ÆÆd e
,
ÆÆe f
{
ÇÇ 
$str
ÇÇ 
,
ÇÇ 
CIELabFromRGB
ÇÇ< I
(
ÇÇI J
$num
ÇÇJ M
,
ÇÇM N
$num
ÇÇO R
,
ÇÇR S
$num
ÇÇT W
,
ÇÇW X
$num
ÇÇY ]
)
ÇÇ] ^
}
ÇÇd e
,
ÇÇe f
{
ÈÈ 
$str
ÈÈ 
,
ÈÈ 
CIELabFromRGB
ÈÈ< I
(
ÈÈI J
$num
ÈÈJ N
,
ÈÈN O
$num
ÈÈP S
,
ÈÈS T
$num
ÈÈU X
,
ÈÈX Y
$num
ÈÈZ ^
)
ÈÈ^ _
}
ÈÈd e
,
ÈÈe f
{
ÉÉ 
$str
ÉÉ 
,
ÉÉ 
CIELabFromRGB
ÉÉ< I
(
ÉÉI J
$num
ÉÉJ M
,
ÉÉM N
$num
ÉÉO R
,
ÉÉR S
$num
ÉÉT W
,
ÉÉW X
$num
ÉÉY ]
)
ÉÉ] ^
}
ÉÉd e
,
ÉÉe f
{
ÊÊ 
$str
ÊÊ 
,
ÊÊ 
CIELabFromRGB
ÊÊ< I
(
ÊÊI J
$num
ÊÊJ M
,
ÊÊM N
$num
ÊÊO R
,
ÊÊR S
$num
ÊÊT V
,
ÊÊV W
$num
ÊÊX \
)
ÊÊ\ ]
}
ÊÊd e
,
ÊÊe f
{
ËË 
$str
ËË 
,
ËË 
CIELabFromRGB
ËË< I
(
ËËI J
$num
ËËJ M
,
ËËM N
$num
ËËO R
,
ËËR S
$num
ËËT V
,
ËËV W
$num
ËËX \
)
ËË\ ]
}
ËËd e
,
ËËe f
{
ÌÌ 
$str
ÌÌ 
,
ÌÌ 
CIELabFromRGB
ÌÌ< I
(
ÌÌI J
$num
ÌÌJ M
,
ÌÌM N
$num
ÌÌO S
,
ÌÌS T
$num
ÌÌU W
,
ÌÌW X
$num
ÌÌY ]
)
ÌÌ] ^
}
ÌÌd e
,
ÌÌe f
{
ÍÍ 
$str
ÍÍ 
,
ÍÍ 
CIELabFromRGB
ÍÍ< I
(
ÍÍI J
$num
ÍÍJ N
,
ÍÍN O
$num
ÍÍP S
,
ÍÍS T
$num
ÍÍU X
,
ÍÍX Y
$num
ÍÍZ ^
)
ÍÍ^ _
}
ÍÍd e
,
ÍÍe f
{
ÎÎ 
$str
ÎÎ #
,
ÎÎ# $
CIELabFromRGB
ÎÎ< I
(
ÎÎI J
$num
ÎÎJ M
,
ÎÎM N
$num
ÎÎO R
,
ÎÎR S
$num
ÎÎT W
,
ÎÎW X
$num
ÎÎY ]
)
ÎÎ] ^
}
ÎÎd e
,
ÎÎe f
{
ÏÏ 
$str
ÏÏ 
,
ÏÏ 
CIELabFromRGB
ÏÏ< I
(
ÏÏI J
$num
ÏÏJ L
,
ÏÏL M
$num
ÏÏN P
,
ÏÏP Q
$num
ÏÏR T
,
ÏÏT U
$num
ÏÏV Z
)
ÏÏZ [
}
ÏÏd e
,
ÏÏe f
{
ĞĞ 
$str
ĞĞ 
,
ĞĞ 
CIELabFromRGB
ĞĞ< I
(
ĞĞI J
$num
ĞĞJ M
,
ĞĞM N
$num
ĞĞO Q
,
ĞĞQ R
$num
ĞĞS U
,
ĞĞU V
$num
ĞĞW [
)
ĞĞ[ \
}
ĞĞd e
,
ĞĞe f
{
ÑÑ 
$str
ÑÑ $
,
ÑÑ$ %
CIELabFromRGB
ÑÑ< I
(
ÑÑI J
$num
ÑÑJ M
,
ÑÑM N
$num
ÑÑO R
,
ÑÑR S
$num
ÑÑT W
,
ÑÑW X
$num
ÑÑY ]
)
ÑÑ] ^
}
ÑÑd e
,
ÑÑe f
{
ÒÒ 
$str
ÒÒ 
,
ÒÒ 
CIELabFromRGB
ÒÒ< I
(
ÒÒI J
$num
ÒÒJ M
,
ÒÒM N
$num
ÒÒO R
,
ÒÒR S
$num
ÒÒT W
,
ÒÒW X
$num
ÒÒY ]
)
ÒÒ] ^
}
ÒÒd e
,
ÒÒe f
{
ÓÓ 
$str
ÓÓ 
,
ÓÓ  
CIELabFromRGB
ÓÓ< I
(
ÓÓI J
$num
ÓÓJ N
,
ÓÓN O
$num
ÓÓP S
,
ÓÓS T
$num
ÓÓU X
,
ÓÓX Y
$num
ÓÓZ ^
)
ÓÓ^ _
}
ÓÓd e
,
ÓÓe f
{
ÔÔ 
$str
ÔÔ  
,
ÔÔ  !
CIELabFromRGB
ÔÔ< I
(
ÔÔI J
$num
ÔÔJ M
,
ÔÔM N
$num
ÔÔO R
,
ÔÔR S
$num
ÔÔT W
,
ÔÔW X
$num
ÔÔY ]
)
ÔÔ] ^
}
ÔÔd e
,
ÔÔe f
{
ÕÕ 
$str
ÕÕ 
,
ÕÕ 
CIELabFromRGB
ÕÕ< I
(
ÕÕI J
$num
ÕÕJ M
,
ÕÕM N
$num
ÕÕO R
,
ÕÕR S
$num
ÕÕT W
,
ÕÕW X
$num
ÕÕY ]
)
ÕÕ] ^
}
ÕÕd e
,
ÕÕe f
{
ÖÖ 
$str
ÖÖ 
,
ÖÖ 
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ M
,
ÖÖM N
$num
ÖÖO R
,
ÖÖR S
$num
ÖÖT W
,
ÖÖW X
$num
ÖÖY ]
)
ÖÖ] ^
}
ÖÖd e
,
ÖÖe f
{
×× 
$str
×× 
,
×× 
CIELabFromRGB
××< I
(
××I J
$num
××J M
,
××M N
$num
××O R
,
××R S
$num
××T W
,
××W X
$num
××Y ]
)
××] ^
}
××d e
,
××e f
{
ØØ 
$str
ØØ 
,
ØØ 
CIELabFromRGB
ØØ< I
(
ØØI J
$num
ØØJ L
,
ØØL M
$num
ØØN P
,
ØØP Q
$num
ØØR V
,
ØØV W
$num
ØØX \
)
ØØ\ ]
}
ØØd e
,
ØØe f
{
ÙÙ 
$str
ÙÙ 
,
ÙÙ 
CIELabFromRGB
ÙÙ< I
(
ÙÙI J
$num
ÙÙJ M
,
ÙÙM N
$num
ÙÙO R
,
ÙÙR S
$num
ÙÙT X
,
ÙÙX Y
$num
ÙÙZ ^
)
ÙÙ^ _
}
ÙÙd e
,
ÙÙe f
{
ÚÚ 
$str
ÚÚ 
,
ÚÚ 
CIELabFromRGB
ÚÚ< I
(
ÚÚI J
$num
ÚÚJ L
,
ÚÚL M
$num
ÚÚN Q
,
ÚÚQ R
$num
ÚÚS V
,
ÚÚV W
$num
ÚÚX \
)
ÚÚ\ ]
}
ÚÚd e
,
ÚÚe f
{
ÛÛ 
$str
ÛÛ 
,
ÛÛ 
CIELabFromRGB
ÛÛ< I
(
ÛÛI J
$num
ÛÛJ L
,
ÛÛL M
$num
ÛÛN Q
,
ÛÛQ R
$num
ÛÛS V
,
ÛÛV W
$num
ÛÛX \
)
ÛÛ\ ]
}
ÛÛd e
,
ÛÛe f
{
ÜÜ 
$str
ÜÜ 
,
ÜÜ 
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ L
,
ÜÜL M
$num
ÜÜN P
,
ÜÜP Q
$num
ÜÜR U
,
ÜÜU V
$num
ÜÜW [
)
ÜÜ[ \
}
ÜÜd e
,
ÜÜe f
{
İİ 
$str
İİ 
,
İİ 
CIELabFromRGB
İİ< I
(
İİI J
$num
İİJ M
,
İİM N
$num
İİO R
,
İİR S
$num
İİT W
,
İİW X
$num
İİY ]
)
İİ] ^
}
İİd e
,
İİe f
{
ŞŞ 
$str
ŞŞ 
,
ŞŞ 
CIELabFromRGB
ŞŞ< I
(
ŞŞI J
$num
ŞŞJ L
,
ŞŞL M
$num
ŞŞN Q
,
ŞŞQ R
$num
ŞŞS W
,
ŞŞW X
$num
ŞŞY ]
)
ŞŞ] ^
}
ŞŞd e
,
ŞŞe f
{
ßß 
$str
ßß 
,
ßß 
CIELabFromRGB
ßß< I
(
ßßI J
$num
ßßJ M
,
ßßM N
$num
ßßO R
,
ßßR S
$num
ßßT W
,
ßßW X
$num
ßßY ]
)
ßß] ^
}
ßßd e
,
ßße f
{
àà 
$str
àà 
,
àà 
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ M
,
ààM N
$num
ààO R
,
ààR S
$num
ààT W
,
ààW X
$num
ààY ]
)
àà] ^
}
ààd e
,
ààe f
{
áá 
$str
áá 
,
áá 
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ L
,
ááL M
$num
ááN Q
,
ááQ R
$num
ááS V
,
ááV W
$num
ááX \
)
áá\ ]
}
áád e
,
ááe f
{
ââ 
$str
ââ 
,
ââ 
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ M
,
ââM N
$num
ââO R
,
ââR S
$num
ââT W
,
ââW X
$num
ââY ]
)
ââ] ^
}
ââd e
,
ââe f
{
ãã 
$str
ãã #
,
ãã# $
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ M
,
ããM N
$num
ããO R
,
ããR S
$num
ããT W
,
ããW X
$num
ããY ]
)
ãã] ^
}
ããd e
,
ããe f
{
ää 
$str
ää 
,
ää 
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ L
,
ääL M
$num
ääN Q
,
ääQ R
$num
ääS V
,
ääV W
$num
ääX \
)
ää\ ]
}
ääd e
,
ääe f
{
åå 
$str
åå 
,
åå 
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ M
,
ååM N
$num
ååO R
,
ååR S
$num
ååT W
,
ååW X
$num
ååY ]
)
åå] ^
}
ååd e
,
ååe f
{
ææ 
$str
ææ 
,
ææ 
CIELabFromRGB
ææ< I
(
ææI J
$num
ææJ M
,
ææM N
$num
ææO R
,
ææR S
$num
ææT W
,
ææW X
$num
ææY ]
)
ææ] ^
}
ææd e
,
ææe f
{
çç 
$str
çç 
,
çç 
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ M
,
ççM N
$num
ççO R
,
ççR S
$num
ççT W
,
ççW X
$num
ççY ]
)
çç] ^
}
ççd e
,
ççe f
{
èè 
$str
èè 
,
èè 
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ M
,
èèM N
$num
èèO R
,
èèR S
$num
èèT W
,
èèW X
$num
èèY ]
)
èè] ^
}
èèd e
,
èèe f
{
éé 
$str
éé 
,
éé 
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ M
,
ééM N
$num
ééO R
,
ééR S
$num
ééT W
,
ééW X
$num
ééY ]
)
éé] ^
}
ééd e
,
éée f
{
êê 
$str
êê 
,
êê 
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ M
,
êêM N
$num
êêO R
,
êêR S
$num
êêT W
,
êêW X
$num
êêY ]
)
êê] ^
}
êêd e
,
êêe f
{
ëë 
$str
ëë 
,
ëë 
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ L
,
ëëL M
$num
ëëN Q
,
ëëQ R
$num
ëëS V
,
ëëV W
$num
ëëX \
)
ëë\ ]
}
ëëd e
,
ëëe f
{
ìì 
$str
ìì 
,
ìì 
CIELabFromRGB
ìì< I
(
ììI J
$num
ììJ M
,
ììM N
$num
ììO R
,
ììR S
$num
ììT W
,
ììW X
$num
ììY ]
)
ìì] ^
}
ììd e
,
ììe f
{
íí 
$str
íí %
,
íí% &
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ M
,
ííM N
$num
ííO Q
,
ííQ R
$num
ííS U
,
ííU V
$num
ííW [
)
íí[ \
}
ííd e
,
ííe f
{
îî 
$str
îî 
,
îî 
CIELabFromRGB
îî< I
(
îîI J
$num
îîJ L
,
îîL M
$num
îîN Q
,
îîQ R
$num
îîS V
,
îîV W
$num
îîX \
)
îî\ ]
}
îîd e
,
îîe f
{
ïï 
$str
ïï 
,
ïï 
CIELabFromRGB
ïï< I
(
ïïI J
$num
ïïJ M
,
ïïM N
$num
ïïO R
,
ïïR S
$num
ïïT W
,
ïïW X
$num
ïïY ]
)
ïï] ^
}
ïïd e
,
ïïe f
{
ğğ 
$str
ğğ 
,
ğğ 
CIELabFromRGB
ğğ< I
(
ğğI J
$num
ğğJ L
,
ğğL M
$num
ğğN Q
,
ğğQ R
$num
ğğS W
,
ğğW X
$num
ğğY ]
)
ğğ] ^
}
ğğd e
,
ğğe f
{
ññ 
$str
ññ 
,
ññ 
CIELabFromRGB
ññ< I
(
ññI J
$num
ññJ M
,
ññM N
$num
ññO R
,
ññR S
$num
ññT W
,
ññW X
$num
ññY ]
)
ññ] ^
}
ññd e
,
ññe f
{
òò 
$str
òò 
,
òò 
CIELabFromRGB
òò< I
(
òòI J
$num
òòJ M
,
òòM N
$num
òòO R
,
òòR S
$num
òòT W
,
òòW X
$num
òòY ]
)
òò] ^
}
òòd e
,
òòe f
{
óó 
$str
óó 
,
óó  
CIELabFromRGB
óó< I
(
óóI J
$num
óóJ M
,
óóM N
$num
óóO R
,
óóR S
$num
óóT W
,
óóW X
$num
óóY ]
)
óó] ^
}
óód e
,
óóe f
{
ôô 
$str
ôô 
,
ôô 
CIELabFromRGB
ôô< I
(
ôôI J
$num
ôôJ M
,
ôôM N
$num
ôôO S
,
ôôS T
$num
ôôU W
,
ôôW X
$num
ôôY ]
)
ôô] ^
}
ôôd e
,
ôôe f
{
õõ 
$str
õõ 
,
õõ  
CIELabFromRGB
õõ< I
(
õõI J
$num
õõJ M
,
õõM N
$num
õõO R
,
õõR S
$num
õõT W
,
õõW X
$num
õõY ]
)
õõ] ^
}
õõd e
,
õõe f
{
öö 
$str
öö 
,
öö 
CIELabFromRGB
öö< I
(
ööI J
$num
ööJ M
,
ööM N
$num
ööO R
,
ööR S
$num
ööT W
,
ööW X
$num
ööY ]
)
öö] ^
}
ööd e
,
ööe f
{
÷÷ 
$str
÷÷ 
,
÷÷ 
CIELabFromRGB
÷÷< I
(
÷÷I J
$num
÷÷J M
,
÷÷M N
$num
÷÷O R
,
÷÷R S
$num
÷÷T W
,
÷÷W X
$num
÷÷Y ]
)
÷÷] ^
}
÷÷d e
,
÷÷e f
{
øø 
$str
øø  
,
øø  !
CIELabFromRGB
øø< I
(
øøI J
$num
øøJ M
,
øøM N
$num
øøO R
,
øøR S
$num
øøT W
,
øøW X
$num
øøY ]
)
øø] ^
}
øød e
,
øøe f
{
ùù 
$str
ùù 
,
ùù 
CIELabFromRGB
ùù< I
(
ùùI J
$num
ùùJ N
,
ùùN O
$num
ùùP R
,
ùùR S
$num
ùùT W
,
ùùW X
$num
ùùY ]
)
ùù] ^
}
ùùd e
,
ùùe f
{
úú 
$str
úú  
,
úú  !
CIELabFromRGB
úú< I
(
úúI J
$num
úúJ L
,
úúL M
$num
úúN Q
,
úúQ R
$num
úúS V
,
úúV W
$num
úúX \
)
úú\ ]
}
úúd e
,
úúe f
{
ûû 
$str
ûû 
,
ûû 
CIELabFromRGB
ûû< I
(
ûûI J
$num
ûûJ M
,
ûûM N
$num
ûûO R
,
ûûR S
$num
ûûT W
,
ûûW X
$num
ûûY ]
)
ûû] ^
}
ûûd e
,
ûûe f
{
üü 
$str
üü 
,
üü  
CIELabFromRGB
üü< I
(
üüI J
$num
üüJ M
,
üüM N
$num
üüO R
,
üüR S
$num
üüT X
,
üüX Y
$num
üüZ ^
)
üü^ _
}
üüd e
,
üüe f
{
ıı 
$str
ıı "
,
ıı" #
CIELabFromRGB
ıı< I
(
ııI J
$num
ııJ M
,
ııM N
$num
ııO R
,
ııR S
$num
ııT X
,
ııX Y
$num
ııZ ^
)
ıı^ _
}
ııd e
,
ııe f
{
şş 
$str
şş 
,
şş 
CIELabFromRGB
şş< I
(
şşI J
$num
şşJ N
,
şşN O
$num
şşP S
,
şşS T
$num
şşU X
,
şşX Y
$num
şşZ ^
)
şş^ _
}
şşd e
,
şşe f
{
ÿÿ 
$str
ÿÿ 
,
ÿÿ 
CIELabFromRGB
ÿÿ< I
(
ÿÿI J
$num
ÿÿJ M
,
ÿÿM N
$num
ÿÿO R
,
ÿÿR S
$num
ÿÿT W
,
ÿÿW X
$num
ÿÿY ]
)
ÿÿ] ^
}
ÿÿd e
,
ÿÿe f
{
€€ 
$str
€€ $
,
€€$ %
CIELabFromRGB
€€< I
(
€€I J
$num
€€J L
,
€€L M
$num
€€N Q
,
€€Q R
$num
€€S V
,
€€V W
$num
€€X \
)
€€\ ]
}
€€d e
,
€€e f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
‚‚ 
$str
‚‚ 
,
‚‚ 
CIELabFromRGB
‚‚< I
(
‚‚I J
$num
‚‚J M
,
‚‚M N
$num
‚‚O R
,
‚‚R S
$num
‚‚T V
,
‚‚V W
$num
‚‚X \
)
‚‚\ ]
}
‚‚d e
,
‚‚e f
{
ƒƒ 
$str
ƒƒ #
,
ƒƒ# $
CIELabFromRGB
ƒƒ< I
(
ƒƒI J
$num
ƒƒJ M
,
ƒƒM N
$num
ƒƒO R
,
ƒƒR S
$num
ƒƒT V
,
ƒƒV W
$num
ƒƒX \
)
ƒƒ\ ]
}
ƒƒd e
,
ƒƒe f
{
„„ 
$str
„„ 
,
„„ 
CIELabFromRGB
„„< I
(
„„I J
$num
„„J M
,
„„M N
$num
„„O R
,
„„R S
$num
„„T W
,
„„W X
$num
„„Y ]
)
„„] ^
}
„„d e
,
„„e f
{
…… 
$str
…… 
,
…… 
CIELabFromRGB
……< I
(
……I J
$num
……J M
,
……M N
$num
……O R
,
……R S
$num
……T W
,
……W X
$num
……Y ]
)
……] ^
}
……d e
,
……e f
{
†† 
$str
†† 
,
†† 
CIELabFromRGB
††< I
(
††I J
$num
††J M
,
††M N
$num
††O R
,
††R S
$num
††T W
,
††W X
$num
††Y ]
)
††] ^
}
††d e
,
††e f
{
‡‡ 
$str
‡‡ 
,
‡‡  
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J M
,
‡‡M N
$num
‡‡O R
,
‡‡R S
$num
‡‡T W
,
‡‡W X
$num
‡‡Y ]
)
‡‡] ^
}
‡‡d e
,
‡‡e f
{
ˆˆ 
$str
ˆˆ 
,
ˆˆ 
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ N
,
ˆˆN O
$num
ˆˆP S
,
ˆˆS T
$num
ˆˆU X
,
ˆˆX Y
$num
ˆˆZ ^
)
ˆˆ^ _
}
ˆˆd e
,
ˆˆe f
{
‰‰ 
$str
‰‰ 
,
‰‰ 
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J M
,
‰‰M N
$num
‰‰O S
,
‰‰S T
$num
‰‰U Y
,
‰‰Y Z
$num
‰‰[ _
)
‰‰_ `
}
‰‰d e
,
‰‰e f
{
ŠŠ 
$str
ŠŠ 
,
ŠŠ 
CIELabFromRGB
ŠŠ< I
(
ŠŠI J
$num
ŠŠJ M
,
ŠŠM N
$num
ŠŠO R
,
ŠŠR S
$num
ŠŠT W
,
ŠŠW X
$num
ŠŠY ]
)
ŠŠ] ^
}
ŠŠd e
,
ŠŠe f
{
‹‹ 
$str
‹‹ 
,
‹‹ 
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J M
,
‹‹M N
$num
‹‹O R
,
‹‹R S
$num
‹‹T W
,
‹‹W X
$num
‹‹Y ]
)
‹‹] ^
}
‹‹d e
,
‹‹e f
{
ŒŒ 
$str
ŒŒ 
,
ŒŒ 
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ M
,
ŒŒM N
$num
ŒŒO Q
,
ŒŒQ R
$num
ŒŒS U
,
ŒŒU V
$num
ŒŒW [
)
ŒŒ[ \
}
ŒŒd e
,
ŒŒe f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O Q
,
Q R
$num
S V
,
V W
$num
X \
)
\ ]
}
d e
,
e f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T V
,
V W
$num
X \
)
\ ]
}
d e
,
e f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
‘‘ 
$str
‘‘ 
,
‘‘ 
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J M
,
‘‘M N
$num
‘‘O R
,
‘‘R S
$num
‘‘T W
,
‘‘W X
$num
‘‘Y ]
)
‘‘] ^
}
‘‘d e
,
‘‘e f
{
’’ 
$str
’’ 
,
’’ 
CIELabFromRGB
’’< I
(
’’I J
$num
’’J M
,
’’M N
$num
’’O R
,
’’R S
$num
’’T W
,
’’W X
$num
’’Y ]
)
’’] ^
}
’’d e
,
’’e f
{
““ 
$str
““ 
,
““ 
CIELabFromRGB
““< I
(
““I J
$num
““J M
,
““M N
$num
““O R
,
““R S
$num
““T W
,
““W X
$num
““Y ]
)
““] ^
}
““d e
,
““e f
{
”” 
$str
”” 
,
”” 
CIELabFromRGB
””< I
(
””I J
$num
””J M
,
””M N
$num
””O R
,
””R S
$num
””T W
,
””W X
$num
””Y ]
)
””] ^
}
””d e
,
””e f
{
•• 
$str
•• 
,
•• 
CIELabFromRGB
••< I
(
••I J
$num
••J M
,
••M N
$num
••O R
,
••R S
$num
••T W
,
••W X
$num
••Y ]
)
••] ^
}
••d e
,
••e f
{
–– 
$str
–– 
,
–– 
CIELabFromRGB
––< I
(
––I J
$num
––J M
,
––M N
$num
––O R
,
––R S
$num
––T W
,
––W X
$num
––Y ]
)
––] ^
}
––d e
,
––e f
{
—— 
$str
—— 
,
—— 
CIELabFromRGB
——< I
(
——I J
$num
——J L
,
——L M
$num
——N Q
,
——Q R
$num
——S V
,
——V W
$num
——X \
)
——\ ]
}
——d e
,
——e f
{
˜˜ 
$str
˜˜ 
,
˜˜ 
CIELabFromRGB
˜˜< I
(
˜˜I J
$num
˜˜J M
,
˜˜M N
$num
˜˜O R
,
˜˜R S
$num
˜˜T W
,
˜˜W X
$num
˜˜Y ]
)
˜˜] ^
}
˜˜d e
,
˜˜e f
{
™™ 
$str
™™ 
,
™™ 
CIELabFromRGB
™™< I
(
™™I J
$num
™™J M
,
™™M N
$num
™™O Q
,
™™Q R
$num
™™S V
,
™™V W
$num
™™X \
)
™™\ ]
}
™™d e
,
™™e f
{
šš 
$str
šš 
,
šš 
CIELabFromRGB
šš< I
(
ššI J
$num
ššJ N
,
ššN O
$num
ššP S
,
ššS T
$num
ššU W
,
ššW X
$num
ššY ]
)
šš] ^
}
ššd e
,
šše f
{
›› 
$str
›› 
,
›› 
CIELabFromRGB
››< I
(
››I J
$num
››J M
,
››M N
$num
››O R
,
››R S
$num
››T W
,
››W X
$num
››Y ]
)
››] ^
}
››d e
,
››e f
{
œœ 
$str
œœ 
,
œœ 
CIELabFromRGB
œœ< I
(
œœI J
$num
œœJ M
,
œœM N
$num
œœO R
,
œœR S
$num
œœT W
,
œœW X
$num
œœY ]
)
œœ] ^
}
œœd e
,
œœe f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
ŸŸ 
$str
ŸŸ 
,
ŸŸ 
CIELabFromRGB
ŸŸ< I
(
ŸŸI J
$num
ŸŸJ M
,
ŸŸM N
$num
ŸŸO R
,
ŸŸR S
$num
ŸŸT W
,
ŸŸW X
$num
ŸŸY ]
)
ŸŸ] ^
}
ŸŸd e
,
ŸŸe f
{
   
$str
   
,
   
CIELabFromRGB
  < I
(
  I J
$num
  J M
,
  M N
$num
  O R
,
  R S
$num
  T W
,
  W X
$num
  Y ]
)
  ] ^
}
  d e
,
  e f
{
¡¡ 
$str
¡¡  
,
¡¡  !
CIELabFromRGB
¡¡< I
(
¡¡I J
$num
¡¡J M
,
¡¡M N
$num
¡¡O R
,
¡¡R S
$num
¡¡T W
,
¡¡W X
$num
¡¡Y ]
)
¡¡] ^
}
¡¡d e
,
¡¡e f
{
¢¢ 
$str
¢¢ 
,
¢¢ 
CIELabFromRGB
¢¢< I
(
¢¢I J
$num
¢¢J N
,
¢¢N O
$num
¢¢P S
,
¢¢S T
$num
¢¢U W
,
¢¢W X
$num
¢¢Y ]
)
¢¢] ^
}
¢¢d e
,
¢¢e f
{
££ 
$str
££ 
,
££  
CIELabFromRGB
££< I
(
££I J
$num
££J N
,
££N O
$num
££P R
,
££R S
$num
££T V
,
££V W
$num
££X \
)
££\ ]
}
££d e
,
££e f
{
¤¤ 
$str
¤¤ 
,
¤¤ 
CIELabFromRGB
¤¤< I
(
¤¤I J
$num
¤¤J M
,
¤¤M N
$num
¤¤O R
,
¤¤R S
$num
¤¤T W
,
¤¤W X
$num
¤¤Y ]
)
¤¤] ^
}
¤¤d e
,
¤¤e f
{
¥¥ 
$str
¥¥ 
,
¥¥ 
CIELabFromRGB
¥¥< I
(
¥¥I J
$num
¥¥J L
,
¥¥L M
$num
¥¥N Q
,
¥¥Q R
$num
¥¥S W
,
¥¥W X
$num
¥¥Y ]
)
¥¥] ^
}
¥¥d e
,
¥¥e f
{
¦¦ 
$str
¦¦ 
,
¦¦ 
CIELabFromRGB
¦¦< I
(
¦¦I J
$num
¦¦J M
,
¦¦M N
$num
¦¦O R
,
¦¦R S
$num
¦¦T W
,
¦¦W X
$num
¦¦Y ]
)
¦¦] ^
}
¦¦d e
,
¦¦e f
{
§§ 
$str
§§ 
,
§§ 
CIELabFromRGB
§§< I
(
§§I J
$num
§§J M
,
§§M N
$num
§§O R
,
§§R S
$num
§§T W
,
§§W X
$num
§§Y ]
)
§§] ^
}
§§d e
,
§§e f
{
¨¨ 
$str
¨¨ 
,
¨¨  
CIELabFromRGB
¨¨< I
(
¨¨I J
$num
¨¨J L
,
¨¨L M
$num
¨¨N Q
,
¨¨Q R
$num
¨¨S V
,
¨¨V W
$num
¨¨X \
)
¨¨\ ]
}
¨¨d e
,
¨¨e f
{
©© 
$str
©© 
,
©© 
CIELabFromRGB
©©< I
(
©©I J
$num
©©J M
,
©©M N
$num
©©O Q
,
©©Q R
$num
©©S U
,
©©U V
$num
©©W [
)
©©[ \
}
©©d e
,
©©e f
{
ªª 
$str
ªª 
,
ªª 
CIELabFromRGB
ªª< I
(
ªªI J
$num
ªªJ M
,
ªªM N
$num
ªªO Q
,
ªªQ R
$num
ªªS V
,
ªªV W
$num
ªªX \
)
ªª\ ]
}
ªªd e
,
ªªe f
{
«« 
$str
«« 
,
«« 
CIELabFromRGB
««< I
(
««I J
$num
««J M
,
««M N
$num
««O R
,
««R S
$num
««T W
,
««W X
$num
««Y ]
)
««] ^
}
««d e
,
««e f
{
¬¬ 
$str
¬¬ 
,
¬¬ 
CIELabFromRGB
¬¬< I
(
¬¬I J
$num
¬¬J N
,
¬¬N O
$num
¬¬P R
,
¬¬R S
$num
¬¬T W
,
¬¬W X
$num
¬¬Y ]
)
¬¬] ^
}
¬¬d e
,
¬¬e f
{
­­ 
$str
­­ 
,
­­ 
CIELabFromRGB
­­< I
(
­­I J
$num
­­J N
,
­­N O
$num
­­P S
,
­­S T
$num
­­U X
,
­­X Y
$num
­­Z ^
)
­­^ _
}
­­d e
,
­­e f
{
®® 
$str
®® 
,
®® 
CIELabFromRGB
®®< I
(
®®I J
$num
®®J M
,
®®M N
$num
®®O R
,
®®R S
$num
®®T W
,
®®W X
$num
®®Y ]
)
®®] ^
}
®®d e
,
®®e f
{
¯¯ 
$str
¯¯ 
,
¯¯ 
CIELabFromRGB
¯¯< I
(
¯¯I J
$num
¯¯J M
,
¯¯M N
$num
¯¯O R
,
¯¯R S
$num
¯¯T W
,
¯¯W X
$num
¯¯Y ]
)
¯¯] ^
}
¯¯d e
,
¯¯e f
{
°° 
$str
°° 
,
°° 
CIELabFromRGB
°°< I
(
°°I J
$num
°°J M
,
°°M N
$num
°°O R
,
°°R S
$num
°°T W
,
°°W X
$num
°°Y ]
)
°°] ^
}
°°d e
,
°°e f
{
±± 
$str
±± 
,
±±  
CIELabFromRGB
±±< I
(
±±I J
$num
±±J L
,
±±L M
$num
±±N Q
,
±±Q R
$num
±±S V
,
±±V W
$num
±±X \
)
±±\ ]
}
±±d e
,
±±e f
{
²² 
$str
²² 
,
²² 
CIELabFromRGB
²²< I
(
²²I J
$num
²²J L
,
²²L M
$num
²²N Q
,
²²Q R
$num
²²S V
,
²²V W
$num
²²X \
)
²²\ ]
}
²²d e
,
²²e f
{
³³ 
$str
³³ 
,
³³ 
CIELabFromRGB
³³< I
(
³³I J
$num
³³J M
,
³³M N
$num
³³O R
,
³³R S
$num
³³T W
,
³³W X
$num
³³Y ]
)
³³] ^
}
³³d e
,
³³e f
{
´´ 
$str
´´ 
,
´´ 
CIELabFromRGB
´´< I
(
´´I J
$num
´´J M
,
´´M N
$num
´´O R
,
´´R S
$num
´´T W
,
´´W X
$num
´´Y ]
)
´´] ^
}
´´d e
,
´´e f
{
µµ 
$str
µµ 
,
µµ 
CIELabFromRGB
µµ< I
(
µµI J
$num
µµJ M
,
µµM N
$num
µµO R
,
µµR S
$num
µµT W
,
µµW X
$num
µµY ]
)
µµ] ^
}
µµd e
,
µµe f
{
¶¶ 
$str
¶¶ 
,
¶¶ 
CIELabFromRGB
¶¶< I
(
¶¶I J
$num
¶¶J M
,
¶¶M N
$num
¶¶O R
,
¶¶R S
$num
¶¶T W
,
¶¶W X
$num
¶¶Y ]
)
¶¶] ^
}
¶¶d e
,
¶¶e f
{
·· 
$str
·· 
,
·· 
CIELabFromRGB
··< I
(
··I J
$num
··J L
,
··L M
$num
··N Q
,
··Q R
$num
··S V
,
··V W
$num
··X \
)
··\ ]
}
··d e
,
··e f
{
¸¸ 
$str
¸¸ 
,
¸¸ 
CIELabFromRGB
¸¸< I
(
¸¸I J
$num
¸¸J M
,
¸¸M N
$num
¸¸O R
,
¸¸R S
$num
¸¸T W
,
¸¸W X
$num
¸¸Y ]
)
¸¸] ^
}
¸¸d e
,
¸¸e f
{
¹¹ 
$str
¹¹ 
,
¹¹ 
CIELabFromRGB
¹¹< I
(
¹¹I J
$num
¹¹J M
,
¹¹M N
$num
¹¹O S
,
¹¹S T
$num
¹¹U Y
,
¹¹Y Z
$num
¹¹[ _
)
¹¹_ `
}
¹¹d e
,
¹¹e f
{
ºº 
$str
ºº 
,
ºº 
CIELabFromRGB
ºº< I
(
ººI J
$num
ººJ M
,
ººM N
$num
ººO R
,
ººR S
$num
ººT W
,
ººW X
$num
ººY ]
)
ºº] ^
}
ººd e
,
ººe f
{
»» 
$str
»» 
,
»» 
CIELabFromRGB
»»< I
(
»»I J
$num
»»J M
,
»»M N
$num
»»O R
,
»»R S
$num
»»T W
,
»»W X
$num
»»Y ]
)
»»] ^
}
»»d e
,
»»e f
{
¼¼ 
$str
¼¼ 
,
¼¼ 
CIELabFromRGB
¼¼< I
(
¼¼I J
$num
¼¼J M
,
¼¼M N
$num
¼¼O R
,
¼¼R S
$num
¼¼T W
,
¼¼W X
$num
¼¼Y ]
)
¼¼] ^
}
¼¼d e
,
¼¼e f
{
½½ 
$str
½½ 
,
½½ 
CIELabFromRGB
½½< I
(
½½I J
$num
½½J L
,
½½L M
$num
½½N Q
,
½½Q R
$num
½½S V
,
½½V W
$num
½½X \
)
½½\ ]
}
½½d e
,
½½e f
{
¾¾ 
$str
¾¾ 
,
¾¾ 
CIELabFromRGB
¾¾< I
(
¾¾I J
$num
¾¾J M
,
¾¾M N
$num
¾¾O R
,
¾¾R S
$num
¾¾T W
,
¾¾W X
$num
¾¾Y ]
)
¾¾] ^
}
¾¾d e
,
¾¾e f
{
¿¿ 
$str
¿¿ 
,
¿¿ 
CIELabFromRGB
¿¿< I
(
¿¿I J
$num
¿¿J M
,
¿¿M N
$num
¿¿O R
,
¿¿R S
$num
¿¿T W
,
¿¿W X
$num
¿¿Y ]
)
¿¿] ^
}
¿¿d e
,
¿¿e f
{
ÀÀ 
$str
ÀÀ 
,
ÀÀ 
CIELabFromRGB
ÀÀ< I
(
ÀÀI J
$num
ÀÀJ L
,
ÀÀL M
$num
ÀÀN Q
,
ÀÀQ R
$num
ÀÀS V
,
ÀÀV W
$num
ÀÀX \
)
ÀÀ\ ]
}
ÀÀd e
,
ÀÀe f
{
ÁÁ 
$str
ÁÁ 
,
ÁÁ 
CIELabFromRGB
ÁÁ< I
(
ÁÁI J
$num
ÁÁJ M
,
ÁÁM N
$num
ÁÁO R
,
ÁÁR S
$num
ÁÁT W
,
ÁÁW X
$num
ÁÁY ]
)
ÁÁ] ^
}
ÁÁd e
,
ÁÁe f
{
ÂÂ 
$str
ÂÂ 
,
ÂÂ 
CIELabFromRGB
ÂÂ< I
(
ÂÂI J
$num
ÂÂJ M
,
ÂÂM N
$num
ÂÂO R
,
ÂÂR S
$num
ÂÂT W
,
ÂÂW X
$num
ÂÂY ]
)
ÂÂ] ^
}
ÂÂd e
,
ÂÂe f
{
ÃÃ 
$str
ÃÃ 
,
ÃÃ 
CIELabFromRGB
ÃÃ< I
(
ÃÃI J
$num
ÃÃJ M
,
ÃÃM N
$num
ÃÃO R
,
ÃÃR S
$num
ÃÃT W
,
ÃÃW X
$num
ÃÃY ]
)
ÃÃ] ^
}
ÃÃd e
,
ÃÃe f
{
ÄÄ 
$str
ÄÄ 
,
ÄÄ 
CIELabFromRGB
ÄÄ< I
(
ÄÄI J
$num
ÄÄJ M
,
ÄÄM N
$num
ÄÄO R
,
ÄÄR S
$num
ÄÄT W
,
ÄÄW X
$num
ÄÄY ]
)
ÄÄ] ^
}
ÄÄd e
,
ÄÄe f
{
ÅÅ 
$str
ÅÅ  
,
ÅÅ  !
CIELabFromRGB
ÅÅ< I
(
ÅÅI J
$num
ÅÅJ M
,
ÅÅM N
$num
ÅÅO R
,
ÅÅR S
$num
ÅÅT W
,
ÅÅW X
$num
ÅÅY ]
)
ÅÅ] ^
}
ÅÅd e
,
ÅÅe f
{
ÆÆ 
$str
ÆÆ 
,
ÆÆ 
CIELabFromRGB
ÆÆ< I
(
ÆÆI J
$num
ÆÆJ M
,
ÆÆM N
$num
ÆÆO R
,
ÆÆR S
$num
ÆÆT W
,
ÆÆW X
$num
ÆÆY ]
)
ÆÆ] ^
}
ÆÆd e
,
ÆÆe f
{
ÇÇ 
$str
ÇÇ (
,
ÇÇ( )
CIELabFromRGB
ÇÇ< I
(
ÇÇI J
$num
ÇÇJ M
,
ÇÇM N
$num
ÇÇO S
,
ÇÇS T
$num
ÇÇU W
,
ÇÇW X
$num
ÇÇY ]
)
ÇÇ] ^
}
ÇÇd e
,
ÇÇe f
{
ÈÈ 
$str
ÈÈ  
,
ÈÈ  !
CIELabFromRGB
ÈÈ< I
(
ÈÈI J
$num
ÈÈJ M
,
ÈÈM N
$num
ÈÈO S
,
ÈÈS T
$num
ÈÈU W
,
ÈÈW X
$num
ÈÈY ]
)
ÈÈ] ^
}
ÈÈd e
,
ÈÈe f
{
ÉÉ 
$str
ÉÉ 
,
ÉÉ 
CIELabFromRGB
ÉÉ< I
(
ÉÉI J
$num
ÉÉJ M
,
ÉÉM N
$num
ÉÉO R
,
ÉÉR S
$num
ÉÉT W
,
ÉÉW X
$num
ÉÉY ]
)
ÉÉ] ^
}
ÉÉd e
,
ÉÉe f
{
ÊÊ 
$str
ÊÊ #
,
ÊÊ# $
CIELabFromRGB
ÊÊ< I
(
ÊÊI J
$num
ÊÊJ N
,
ÊÊN O
$num
ÊÊP S
,
ÊÊS T
$num
ÊÊU X
,
ÊÊX Y
$num
ÊÊZ ^
)
ÊÊ^ _
}
ÊÊd e
,
ÊÊe f
{
ËË 
$str
ËË 
,
ËË 
CIELabFromRGB
ËË< I
(
ËËI J
$num
ËËJ M
,
ËËM N
$num
ËËO R
,
ËËR S
$num
ËËT W
,
ËËW X
$num
ËËY ]
)
ËË] ^
}
ËËd e
,
ËËe f
{
ÌÌ 
$str
ÌÌ 
,
ÌÌ 
CIELabFromRGB
ÌÌ< I
(
ÌÌI J
$num
ÌÌJ M
,
ÌÌM N
$num
ÌÌO R
,
ÌÌR S
$num
ÌÌT W
,
ÌÌW X
$num
ÌÌY ]
)
ÌÌ] ^
}
ÌÌd e
,
ÌÌe f
{
ÍÍ 
$str
ÍÍ 
,
ÍÍ 
CIELabFromRGB
ÍÍ< I
(
ÍÍI J
$num
ÍÍJ M
,
ÍÍM N
$num
ÍÍO R
,
ÍÍR S
$num
ÍÍT W
,
ÍÍW X
$num
ÍÍY ]
)
ÍÍ] ^
}
ÍÍd e
,
ÍÍe f
{
ÎÎ 
$str
ÎÎ 
,
ÎÎ 
CIELabFromRGB
ÎÎ< I
(
ÎÎI J
$num
ÎÎJ M
,
ÎÎM N
$num
ÎÎO R
,
ÎÎR S
$num
ÎÎT W
,
ÎÎW X
$num
ÎÎY ]
)
ÎÎ] ^
}
ÎÎd e
,
ÎÎe f
{
ÏÏ 
$str
ÏÏ 
,
ÏÏ 
CIELabFromRGB
ÏÏ< I
(
ÏÏI J
$num
ÏÏJ M
,
ÏÏM N
$num
ÏÏO R
,
ÏÏR S
$num
ÏÏT W
,
ÏÏW X
$num
ÏÏY ]
)
ÏÏ] ^
}
ÏÏd e
,
ÏÏe f
{
ĞĞ 
$str
ĞĞ '
,
ĞĞ' (
CIELabFromRGB
ĞĞ< I
(
ĞĞI J
$num
ĞĞJ M
,
ĞĞM N
$num
ĞĞO R
,
ĞĞR S
$num
ĞĞT V
,
ĞĞV W
$num
ĞĞX \
)
ĞĞ\ ]
}
ĞĞd e
,
ĞĞe f
{
ÑÑ 
$str
ÑÑ 
,
ÑÑ  
CIELabFromRGB
ÑÑ< I
(
ÑÑI J
$num
ÑÑJ M
,
ÑÑM N
$num
ÑÑO R
,
ÑÑR S
$num
ÑÑT W
,
ÑÑW X
$num
ÑÑY ]
)
ÑÑ] ^
}
ÑÑd e
,
ÑÑe f
{
ÒÒ 
$str
ÒÒ 
,
ÒÒ 
CIELabFromRGB
ÒÒ< I
(
ÒÒI J
$num
ÒÒJ N
,
ÒÒN O
$num
ÒÒP S
,
ÒÒS T
$num
ÒÒU W
,
ÒÒW X
$num
ÒÒY ]
)
ÒÒ] ^
}
ÒÒd e
,
ÒÒe f
{
ÓÓ 
$str
ÓÓ 
,
ÓÓ 
CIELabFromRGB
ÓÓ< I
(
ÓÓI J
$num
ÓÓJ M
,
ÓÓM N
$num
ÓÓO R
,
ÓÓR S
$num
ÓÓT W
,
ÓÓW X
$num
ÓÓY ]
)
ÓÓ] ^
}
ÓÓd e
,
ÓÓe f
{
ÔÔ 
$str
ÔÔ 
,
ÔÔ 
CIELabFromRGB
ÔÔ< I
(
ÔÔI J
$num
ÔÔJ M
,
ÔÔM N
$num
ÔÔO R
,
ÔÔR S
$num
ÔÔT W
,
ÔÔW X
$num
ÔÔY ]
)
ÔÔ] ^
}
ÔÔd e
,
ÔÔe f
{
ÕÕ 
$str
ÕÕ 
,
ÕÕ 
CIELabFromRGB
ÕÕ< I
(
ÕÕI J
$num
ÕÕJ M
,
ÕÕM N
$num
ÕÕO R
,
ÕÕR S
$num
ÕÕT W
,
ÕÕW X
$num
ÕÕY ]
)
ÕÕ] ^
}
ÕÕd e
,
ÕÕe f
{
ÖÖ 
$str
ÖÖ 
,
ÖÖ 
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ M
,
ÖÖM N
$num
ÖÖO R
,
ÖÖR S
$num
ÖÖT V
,
ÖÖV W
$num
ÖÖX \
)
ÖÖ\ ]
}
ÖÖd e
,
ÖÖe f
{
×× 
$str
×× 
,
×× 
CIELabFromRGB
××< I
(
××I J
$num
××J M
,
××M N
$num
××O R
,
××R S
$num
××T W
,
××W X
$num
××Y ]
)
××] ^
}
××d e
,
××e f
{
ØØ 
$str
ØØ 
,
ØØ 
CIELabFromRGB
ØØ< I
(
ØØI J
$num
ØØJ M
,
ØØM N
$num
ØØO Q
,
ØØQ R
$num
ØØS V
,
ØØV W
$num
ØØX \
)
ØØ\ ]
}
ØØd e
,
ØØe f
{
ÙÙ 
$str
ÙÙ 
,
ÙÙ 
CIELabFromRGB
ÙÙ< I
(
ÙÙI J
$num
ÙÙJ M
,
ÙÙM N
$num
ÙÙO R
,
ÙÙR S
$num
ÙÙT W
,
ÙÙW X
$num
ÙÙY ]
)
ÙÙ] ^
}
ÙÙd e
,
ÙÙe f
{
ÚÚ 
$str
ÚÚ 
,
ÚÚ 
CIELabFromRGB
ÚÚ< I
(
ÚÚI J
$num
ÚÚJ L
,
ÚÚL M
$num
ÚÚN Q
,
ÚÚQ R
$num
ÚÚS V
,
ÚÚV W
$num
ÚÚX \
)
ÚÚ\ ]
}
ÚÚd e
,
ÚÚe f
{
ÛÛ 
$str
ÛÛ 
,
ÛÛ 
CIELabFromRGB
ÛÛ< I
(
ÛÛI J
$num
ÛÛJ M
,
ÛÛM N
$num
ÛÛO R
,
ÛÛR S
$num
ÛÛT W
,
ÛÛW X
$num
ÛÛY ]
)
ÛÛ] ^
}
ÛÛd e
,
ÛÛe f
{
ÜÜ 
$str
ÜÜ 
,
ÜÜ 
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ M
,
ÜÜM N
$num
ÜÜO R
,
ÜÜR S
$num
ÜÜT W
,
ÜÜW X
$num
ÜÜY ]
)
ÜÜ] ^
}
ÜÜd e
,
ÜÜe f
{
İİ 
$str
İİ 
,
İİ 
CIELabFromRGB
İİ< I
(
İİI J
$num
İİJ M
,
İİM N
$num
İİO R
,
İİR S
$num
İİT W
,
İİW X
$num
İİY ]
)
İİ] ^
}
İİd e
,
İİe f
{
ŞŞ 
$str
ŞŞ 
,
ŞŞ 
CIELabFromRGB
ŞŞ< I
(
ŞŞI J
$num
ŞŞJ M
,
ŞŞM N
$num
ŞŞO R
,
ŞŞR S
$num
ŞŞT W
,
ŞŞW X
$num
ŞŞY ]
)
ŞŞ] ^
}
ŞŞd e
,
ŞŞe f
{
ßß 
$str
ßß 
,
ßß 
CIELabFromRGB
ßß< I
(
ßßI J
$num
ßßJ M
,
ßßM N
$num
ßßO R
,
ßßR S
$num
ßßT W
,
ßßW X
$num
ßßY ]
)
ßß] ^
}
ßßd e
,
ßße f
{
àà 
$str
àà 
,
àà 
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ L
,
ààL M
$num
ààN Q
,
ààQ R
$num
ààS V
,
ààV W
$num
ààX \
)
àà\ ]
}
ààd e
,
ààe f
{
áá 
$str
áá 
,
áá 
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ M
,
ááM N
$num
ááO R
,
ááR S
$num
ááT W
,
ááW X
$num
ááY ]
)
áá] ^
}
áád e
,
ááe f
{
ââ 
$str
ââ 
,
ââ 
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ M
,
ââM N
$num
ââO R
,
ââR S
$num
ââT W
,
ââW X
$num
ââY ]
)
ââ] ^
}
ââd e
,
ââe f
{
ãã 
$str
ãã  
,
ãã  !
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ M
,
ããM N
$num
ããO R
,
ããR S
$num
ããT W
,
ããW X
$num
ããY ]
)
ãã] ^
}
ããd e
,
ããe f
{
ää 
$str
ää 
,
ää 
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ M
,
ääM N
$num
ääO R
,
ääR S
$num
ääT W
,
ääW X
$num
ääY ]
)
ää] ^
}
ääd e
,
ääe f
{
åå 
$str
åå 
,
åå 
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ M
,
ååM N
$num
ååO R
,
ååR S
$num
ååT W
,
ååW X
$num
ååY ]
)
åå] ^
}
ååd e
,
ååe f
{
ææ 
$str
ææ 
,
ææ 
CIELabFromRGB
ææ< I
(
ææI J
$num
ææJ M
,
ææM N
$num
ææO R
,
ææR S
$num
ææT W
,
ææW X
$num
ææY ]
)
ææ] ^
}
ææd e
,
ææe f
{
çç 
$str
çç 
,
çç 
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ N
,
ççN O
$num
ççP S
,
ççS T
$num
ççU W
,
ççW X
$num
ççY ]
)
çç] ^
}
ççd e
,
ççe f
{
èè 
$str
èè 
,
èè 
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ N
,
èèN O
$num
èèP S
,
èèS T
$num
èèU X
,
èèX Y
$num
èèZ ^
)
èè^ _
}
èèd e
,
èèe f
{
éé 
$str
éé 
,
éé 
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ M
,
ééM N
$num
ééO R
,
ééR S
$num
ééT W
,
ééW X
$num
ééY ]
)
éé] ^
}
ééd e
,
éée f
{
êê 
$str
êê 
,
êê 
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ N
,
êêN O
$num
êêP S
,
êêS T
$num
êêU X
,
êêX Y
$num
êêZ ^
)
êê^ _
}
êêd e
,
êêe f
{
ëë 
$str
ëë 
,
ëë 
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ M
,
ëëM N
$num
ëëO R
,
ëëR S
$num
ëëT W
,
ëëW X
$num
ëëY ]
)
ëë] ^
}
ëëd e
,
ëëe f
{
ìì 
$str
ìì 
,
ìì 
CIELabFromRGB
ìì< I
(
ììI J
$num
ììJ M
,
ììM N
$num
ììO R
,
ììR S
$num
ììT W
,
ììW X
$num
ììY ]
)
ìì] ^
}
ììd e
,
ììe f
{
íí 
$str
íí 
,
íí 
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ M
,
ííM N
$num
ííO R
,
ííR S
$num
ííT W
,
ííW X
$num
ííY ]
)
íí] ^
}
ííd e
,
ííe f
{
îî 
$str
îî 
,
îî  
CIELabFromRGB
îî< I
(
îîI J
$num
îîJ M
,
îîM N
$num
îîO R
,
îîR S
$num
îîT W
,
îîW X
$num
îîY ]
)
îî] ^
}
îîd e
,
îîe f
{
ïï 
$str
ïï 
,
ïï 
CIELabFromRGB
ïï< I
(
ïïI J
$num
ïïJ N
,
ïïN O
$num
ïïP S
,
ïïS T
$num
ïïU X
,
ïïX Y
$num
ïïZ ^
)
ïï^ _
}
ïïd e
,
ïïe f
{
ğğ 
$str
ğğ 
,
ğğ 
CIELabFromRGB
ğğ< I
(
ğğI J
$num
ğğJ N
,
ğğN O
$num
ğğP S
,
ğğS T
$num
ğğU X
,
ğğX Y
$num
ğğZ ^
)
ğğ^ _
}
ğğd e
,
ğğe f
{
ññ 
$str
ññ 
,
ññ 
CIELabFromRGB
ññ< I
(
ññI J
$num
ññJ M
,
ññM N
$num
ññO R
,
ññR S
$num
ññT W
,
ññW X
$num
ññY ]
)
ññ] ^
}
ññd e
,
ññe f
{
òò 
$str
òò 
,
òò 
CIELabFromRGB
òò< I
(
òòI J
$num
òòJ N
,
òòN O
$num
òòP S
,
òòS T
$num
òòU X
,
òòX Y
$num
òòZ ^
)
òò^ _
}
òòd e
,
òòe f
{
óó 
$str
óó 
,
óó 
CIELabFromRGB
óó< I
(
óóI J
$num
óóJ N
,
óóN O
$num
óóP S
,
óóS T
$num
óóU X
,
óóX Y
$num
óóZ ^
)
óó^ _
}
óód e
,
óóe f
{
ôô 
$str
ôô 
,
ôô 
CIELabFromRGB
ôô< I
(
ôôI J
$num
ôôJ M
,
ôôM N
$num
ôôO Q
,
ôôQ R
$num
ôôS V
,
ôôV W
$num
ôôX \
)
ôô\ ]
}
ôôd e
,
ôôe f
{
õõ 
$str
õõ 
,
õõ 
CIELabFromRGB
õõ< I
(
õõI J
$num
õõJ M
,
õõM N
$num
õõO Q
,
õõQ R
$num
õõS V
,
õõV W
$num
õõX \
)
õõ\ ]
}
õõd e
,
õõe f
{
öö 
$str
öö 
,
öö 
CIELabFromRGB
öö< I
(
ööI J
$num
ööJ M
,
ööM N
$num
ööO Q
,
ööQ R
$num
ööS U
,
ööU V
$num
ööW [
)
öö[ \
}
ööd e
,
ööe f
{
÷÷ 
$str
÷÷ 
,
÷÷ 
CIELabFromRGB
÷÷< I
(
÷÷I J
$num
÷÷J L
,
÷÷L M
$num
÷÷N R
,
÷÷R S
$num
÷÷T X
,
÷÷X Y
$num
÷÷Z ^
)
÷÷^ _
}
÷÷d e
,
÷÷e f
{
øø 
$str
øø 
,
øø 
CIELabFromRGB
øø< I
(
øøI J
$num
øøJ M
,
øøM N
$num
øøO R
,
øøR S
$num
øøT W
,
øøW X
$num
øøY ]
)
øø] ^
}
øød e
,
øøe f
{
ùù 
$str
ùù 
,
ùù  
CIELabFromRGB
ùù< I
(
ùùI J
$num
ùùJ M
,
ùùM N
$num
ùùO R
,
ùùR S
$num
ùùT W
,
ùùW X
$num
ùùY ]
)
ùù] ^
}
ùùd e
,
ùùe f
{
úú 
$str
úú  
,
úú  !
CIELabFromRGB
úú< I
(
úúI J
$num
úúJ M
,
úúM N
$num
úúO R
,
úúR S
$num
úúT W
,
úúW X
$num
úúY ]
)
úú] ^
}
úúd e
,
úúe f
{
ûû 
$str
ûû $
,
ûû$ %
CIELabFromRGB
ûû< I
(
ûûI J
$num
ûûJ L
,
ûûL M
$num
ûûN Q
,
ûûQ R
$num
ûûS V
,
ûûV W
$num
ûûX \
)
ûû\ ]
}
ûûd e
,
ûûe f
{
üü 
$str
üü 
,
üü 
CIELabFromRGB
üü< I
(
üüI J
$num
üüJ L
,
üüL M
$num
üüN Q
,
üüQ R
$num
üüS V
,
üüV W
$num
üüX \
)
üü\ ]
}
üüd e
,
üüe f
{
ıı 
$str
ıı 
,
ıı 
CIELabFromRGB
ıı< I
(
ııI J
$num
ııJ M
,
ııM N
$num
ııO R
,
ııR S
$num
ııT W
,
ııW X
$num
ııY ]
)
ıı] ^
}
ııd e
,
ııe f
{
şş 
$str
şş 
,
şş 
CIELabFromRGB
şş< I
(
şşI J
$num
şşJ N
,
şşN O
$num
şşP S
,
şşS T
$num
şşU W
,
şşW X
$num
şşY ]
)
şş] ^
}
şşd e
,
şşe f
{
ÿÿ 
$str
ÿÿ 
,
ÿÿ 
CIELabFromRGB
ÿÿ< I
(
ÿÿI J
$num
ÿÿJ N
,
ÿÿN O
$num
ÿÿP T
,
ÿÿT U
$num
ÿÿV Y
,
ÿÿY Z
$num
ÿÿ[ _
)
ÿÿ_ `
}
ÿÿd e
,
ÿÿe f
{
€€ 
$str
€€ 
,
€€ 
CIELabFromRGB
€€< I
(
€€I J
$num
€€J M
,
€€M N
$num
€€O R
,
€€R S
$num
€€T W
,
€€W X
$num
€€Y ]
)
€€] ^
}
€€d e
,
€€e f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J L
,
L M
$num
N P
,
P Q
$num
R U
,
U V
$num
W [
)
[ \
}
d e
,
e f
{
‚‚ 
$str
‚‚ 
,
‚‚ 
CIELabFromRGB
‚‚< I
(
‚‚I J
$num
‚‚J M
,
‚‚M N
$num
‚‚O R
,
‚‚R S
$num
‚‚T W
,
‚‚W X
$num
‚‚Y ]
)
‚‚] ^
}
‚‚d e
,
‚‚e f
{
ƒƒ 
$str
ƒƒ 
,
ƒƒ 
CIELabFromRGB
ƒƒ< I
(
ƒƒI J
$num
ƒƒJ M
,
ƒƒM N
$num
ƒƒO R
,
ƒƒR S
$num
ƒƒT W
,
ƒƒW X
$num
ƒƒY ]
)
ƒƒ] ^
}
ƒƒd e
,
ƒƒe f
{
„„ 
$str
„„ "
,
„„" #
CIELabFromRGB
„„< I
(
„„I J
$num
„„J M
,
„„M N
$num
„„O R
,
„„R S
$num
„„T W
,
„„W X
$num
„„Y ]
)
„„] ^
}
„„d e
,
„„e f
{
…… 
$str
…… 
,
…… 
CIELabFromRGB
……< I
(
……I J
$num
……J M
,
……M N
$num
……O R
,
……R S
$num
……T W
,
……W X
$num
……Y ]
)
……] ^
}
……d e
,
……e f
{
†† 
$str
†† $
,
††$ %
CIELabFromRGB
††< I
(
††I J
$num
††J M
,
††M N
$num
††O Q
,
††Q R
$num
††S U
,
††U V
$num
††W [
)
††[ \
}
††d e
,
††e f
{
‡‡ 
$str
‡‡ 
,
‡‡ 
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J L
,
‡‡L M
$num
‡‡N Q
,
‡‡Q R
$num
‡‡S V
,
‡‡V W
$num
‡‡X \
)
‡‡\ ]
}
‡‡d e
,
‡‡e f
{
ˆˆ 
$str
ˆˆ 
,
ˆˆ 
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ M
,
ˆˆM N
$num
ˆˆO R
,
ˆˆR S
$num
ˆˆT W
,
ˆˆW X
$num
ˆˆY ]
)
ˆˆ] ^
}
ˆˆd e
,
ˆˆe f
{
‰‰ 
$str
‰‰ 
,
‰‰ 
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J M
,
‰‰M N
$num
‰‰O R
,
‰‰R S
$num
‰‰T W
,
‰‰W X
$num
‰‰Y ]
)
‰‰] ^
}
‰‰d e
,
‰‰e f
{
ŠŠ 
$str
ŠŠ 
,
ŠŠ 
CIELabFromRGB
ŠŠ< I
(
ŠŠI J
$num
ŠŠJ L
,
ŠŠL M
$num
ŠŠN Q
,
ŠŠQ R
$num
ŠŠS V
,
ŠŠV W
$num
ŠŠX \
)
ŠŠ\ ]
}
ŠŠd e
,
ŠŠe f
{
‹‹ 
$str
‹‹ "
,
‹‹" #
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J M
,
‹‹M N
$num
‹‹O R
,
‹‹R S
$num
‹‹T W
,
‹‹W X
$num
‹‹Y ]
)
‹‹] ^
}
‹‹d e
,
‹‹e f
{
ŒŒ 
$str
ŒŒ 
,
ŒŒ 
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ M
,
ŒŒM N
$num
ŒŒO R
,
ŒŒR S
$num
ŒŒT V
,
ŒŒV W
$num
ŒŒX \
)
ŒŒ\ ]
}
ŒŒd e
,
ŒŒe f
{
 
$str
 
,
  
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J L
,
L M
$num
N Q
,
Q R
$num
S V
,
V W
$num
X \
)
\ ]
}
d e
,
e f
{
 
$str
  
,
  !
CIELabFromRGB
< I
(
I J
$num
J L
,
L M
$num
N Q
,
Q R
$num
S U
,
U V
$num
W [
)
[ \
}
d e
,
e f
{
 
$str
 "
,
" #
CIELabFromRGB
< I
(
I J
$num
J L
,
L M
$num
N Q
,
Q R
$num
S V
,
V W
$num
X \
)
\ ]
}
d e
,
e f
{
‘‘ 
$str
‘‘ %
,
‘‘% &
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J L
,
‘‘L M
$num
‘‘N P
,
‘‘P Q
$num
‘‘R U
,
‘‘U V
$num
‘‘W [
)
‘‘[ \
}
‘‘d e
,
‘‘e f
{
’’ 
$str
’’ !
,
’’! "
CIELabFromRGB
’’< I
(
’’I J
$num
’’J M
,
’’M N
$num
’’O R
,
’’R S
$num
’’T W
,
’’W X
$num
’’Y ]
)
’’] ^
}
’’d e
,
’’e f
{
““ 
$str
““ 
,
““ 
CIELabFromRGB
““< I
(
““I J
$num
““J M
,
““M N
$num
““O R
,
““R S
$num
““T W
,
““W X
$num
““Y ]
)
““] ^
}
““d e
,
““e f
{
”” 
$str
”” 
,
”” 
CIELabFromRGB
””< I
(
””I J
$num
””J M
,
””M N
$num
””O R
,
””R S
$num
””T W
,
””W X
$num
””Y ]
)
””] ^
}
””d e
,
””e f
{
•• 
$str
•• 
,
•• 
CIELabFromRGB
••< I
(
••I J
$num
••J M
,
••M N
$num
••O R
,
••R S
$num
••T W
,
••W X
$num
••Y ]
)
••] ^
}
••d e
,
••e f
{
–– 
$str
–– 
,
–– 
CIELabFromRGB
––< I
(
––I J
$num
––J M
,
––M N
$num
––O R
,
––R S
$num
––T W
,
––W X
$num
––Y ]
)
––] ^
}
––d e
,
––e f
{
—— 
$str
—— #
,
——# $
CIELabFromRGB
——< I
(
——I J
$num
——J M
,
——M N
$num
——O R
,
——R S
$num
——T W
,
——W X
$num
——Y ]
)
——] ^
}
——d e
,
——e f
{
˜˜ 
$str
˜˜ 
,
˜˜ 
CIELabFromRGB
˜˜< I
(
˜˜I J
$num
˜˜J M
,
˜˜M N
$num
˜˜O Q
,
˜˜Q R
$num
˜˜S V
,
˜˜V W
$num
˜˜X \
)
˜˜\ ]
}
˜˜d e
,
˜˜e f
{
™™ 
$str
™™  
,
™™  !
CIELabFromRGB
™™< I
(
™™I J
$num
™™J M
,
™™M N
$num
™™O R
,
™™R S
$num
™™T W
,
™™W X
$num
™™Y ]
)
™™] ^
}
™™d e
,
™™e f
{
šš 
$str
šš "
,
šš" #
CIELabFromRGB
šš< I
(
ššI J
$num
ššJ L
,
ššL M
$num
ššN Q
,
ššQ R
$num
ššS V
,
ššV W
$num
ššX \
)
šš\ ]
}
ššd e
,
šše f
{
›› 
$str
›› 
,
››  
CIELabFromRGB
››< I
(
››I J
$num
››J M
,
››M N
$num
››O R
,
››R S
$num
››T W
,
››W X
$num
››Y ]
)
››] ^
}
››d e
,
››e f
{
œœ 
$str
œœ  
,
œœ  !
CIELabFromRGB
œœ< I
(
œœI J
$num
œœJ M
,
œœM N
$num
œœO R
,
œœR S
$num
œœT W
,
œœW X
$num
œœY ]
)
œœ] ^
}
œœd e
,
œœe f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J N
,
N O
$num
P S
,
S T
$num
U W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
ŸŸ 
$str
ŸŸ  
,
ŸŸ  !
CIELabFromRGB
ŸŸ< I
(
ŸŸI J
$num
ŸŸJ M
,
ŸŸM N
$num
ŸŸO R
,
ŸŸR S
$num
ŸŸT W
,
ŸŸW X
$num
ŸŸY ]
)
ŸŸ] ^
}
ŸŸd e
,
ŸŸe f
{
   
$str
   !
,
  ! "
CIELabFromRGB
  < I
(
  I J
$num
  J L
,
  L M
$num
  N Q
,
  Q R
$num
  S V
,
  V W
$num
  X \
)
  \ ]
}
  d e
,
  e f
{
¡¡ 
$str
¡¡ "
,
¡¡" #
CIELabFromRGB
¡¡< I
(
¡¡I J
$num
¡¡J M
,
¡¡M N
$num
¡¡O R
,
¡¡R S
$num
¡¡T W
,
¡¡W X
$num
¡¡Y ]
)
¡¡] ^
}
¡¡d e
,
¡¡e f
{
¢¢ 
$str
¢¢ 
,
¢¢  
CIELabFromRGB
¢¢< I
(
¢¢I J
$num
¢¢J M
,
¢¢M N
$num
¢¢O R
,
¢¢R S
$num
¢¢T W
,
¢¢W X
$num
¢¢Y ]
)
¢¢] ^
}
¢¢d e
,
¢¢e f
{
££ 
$str
££ 
,
££ 
CIELabFromRGB
££< I
(
££I J
$num
££J M
,
££M N
$num
££O R
,
££R S
$num
££T W
,
££W X
$num
££Y ]
)
££] ^
}
££d e
,
££e f
{
¤¤ 
$str
¤¤  
,
¤¤  !
CIELabFromRGB
¤¤< I
(
¤¤I J
$num
¤¤J L
,
¤¤L M
$num
¤¤N Q
,
¤¤Q R
$num
¤¤S V
,
¤¤V W
$num
¤¤X \
)
¤¤\ ]
}
¤¤d e
,
¤¤e f
{
¥¥ 
$str
¥¥ 
,
¥¥ 
CIELabFromRGB
¥¥< I
(
¥¥I J
$num
¥¥J M
,
¥¥M N
$num
¥¥O R
,
¥¥R S
$num
¥¥T W
,
¥¥W X
$num
¥¥Y ]
)
¥¥] ^
}
¥¥d e
,
¥¥e f
{
¦¦ 
$str
¦¦ 
,
¦¦ 
CIELabFromRGB
¦¦< I
(
¦¦I J
$num
¦¦J M
,
¦¦M N
$num
¦¦O R
,
¦¦R S
$num
¦¦T W
,
¦¦W X
$num
¦¦Y ]
)
¦¦] ^
}
¦¦d e
,
¦¦e f
{
§§ 
$str
§§ 
,
§§ 
CIELabFromRGB
§§< I
(
§§I J
$num
§§J M
,
§§M N
$num
§§O R
,
§§R S
$num
§§T W
,
§§W X
$num
§§Y ]
)
§§] ^
}
§§d e
,
§§e f
{
¨¨ 
$str
¨¨ 
,
¨¨ 
CIELabFromRGB
¨¨< I
(
¨¨I J
$num
¨¨J M
,
¨¨M N
$num
¨¨O Q
,
¨¨Q R
$num
¨¨S U
,
¨¨U V
$num
¨¨W [
)
¨¨[ \
}
¨¨d e
,
¨¨e f
{
©© 
$str
©© 
,
©© 
CIELabFromRGB
©©< I
(
©©I J
$num
©©J M
,
©©M N
$num
©©O R
,
©©R S
$num
©©T W
,
©©W X
$num
©©Y ]
)
©©] ^
}
©©d e
,
©©e f
{
ªª 
$str
ªª 
,
ªª 
CIELabFromRGB
ªª< I
(
ªªI J
$num
ªªJ M
,
ªªM N
$num
ªªO Q
,
ªªQ R
$num
ªªS V
,
ªªV W
$num
ªªX \
)
ªª\ ]
}
ªªd e
,
ªªe f
{
«« 
$str
«« 
,
«« 
CIELabFromRGB
««< I
(
««I J
$num
««J M
,
««M N
$num
««O R
,
««R S
$num
««T W
,
««W X
$num
««Y ]
)
««] ^
}
««d e
,
««e f
{
¬¬ 
$str
¬¬ 
,
¬¬ 
CIELabFromRGB
¬¬< I
(
¬¬I J
$num
¬¬J M
,
¬¬M N
$num
¬¬O Q
,
¬¬Q R
$num
¬¬S U
,
¬¬U V
$num
¬¬W [
)
¬¬[ \
}
¬¬d e
,
¬¬e f
{
­­ 
$str
­­ 
,
­­ 
CIELabFromRGB
­­< I
(
­­I J
$num
­­J M
,
­­M N
$num
­­O R
,
­­R S
$num
­­T W
,
­­W X
$num
­­Y ]
)
­­] ^
}
­­d e
,
­­e f
{
®® 
$str
®® 
,
®®  
CIELabFromRGB
®®< I
(
®®I J
$num
®®J M
,
®®M N
$num
®®O R
,
®®R S
$num
®®T W
,
®®W X
$num
®®Y ]
)
®®] ^
}
®®d e
,
®®e f
{
¯¯ 
$str
¯¯ 
,
¯¯  
CIELabFromRGB
¯¯< I
(
¯¯I J
$num
¯¯J M
,
¯¯M N
$num
¯¯O R
,
¯¯R S
$num
¯¯T W
,
¯¯W X
$num
¯¯Y ]
)
¯¯] ^
}
¯¯d e
,
¯¯e f
{
°° 
$str
°° !
,
°°! "
CIELabFromRGB
°°< I
(
°°I J
$num
°°J L
,
°°L M
$num
°°N Q
,
°°Q R
$num
°°S V
,
°°V W
$num
°°X \
)
°°\ ]
}
°°d e
,
°°e f
{
±± 
$str
±± 
,
±± 
CIELabFromRGB
±±< I
(
±±I J
$num
±±J M
,
±±M N
$num
±±O R
,
±±R S
$num
±±T W
,
±±W X
$num
±±Y ]
)
±±] ^
}
±±d e
,
±±e f
{
²² 
$str
²² 
,
²² 
CIELabFromRGB
²²< I
(
²²I J
$num
²²J N
,
²²N O
$num
²²P S
,
²²S T
$num
²²U W
,
²²W X
$num
²²Y ]
)
²²] ^
}
²²d e
,
²²e f
{
³³ 
$str
³³ 
,
³³ 
CIELabFromRGB
³³< I
(
³³I J
$num
³³J M
,
³³M N
$num
³³O R
,
³³R S
$num
³³T W
,
³³W X
$num
³³Y ]
)
³³] ^
}
³³d e
,
³³e f
{
´´ 
$str
´´  
,
´´  !
CIELabFromRGB
´´< I
(
´´I J
$num
´´J M
,
´´M N
$num
´´O R
,
´´R S
$num
´´T W
,
´´W X
$num
´´Y ]
)
´´] ^
}
´´d e
,
´´e f
{
µµ 
$str
µµ 
,
µµ 
CIELabFromRGB
µµ< I
(
µµI J
$num
µµJ L
,
µµL M
$num
µµN Q
,
µµQ R
$num
µµS V
,
µµV W
$num
µµX \
)
µµ\ ]
}
µµd e
,
µµe f
{
¶¶ 
$str
¶¶ 
,
¶¶ 
CIELabFromRGB
¶¶< I
(
¶¶I J
$num
¶¶J M
,
¶¶M N
$num
¶¶O R
,
¶¶R S
$num
¶¶T W
,
¶¶W X
$num
¶¶Y ]
)
¶¶] ^
}
¶¶d e
,
¶¶e f
{
·· 
$str
·· 
,
·· 
CIELabFromRGB
··< I
(
··I J
$num
··J M
,
··M N
$num
··O Q
,
··Q R
$num
··S V
,
··V W
$num
··X \
)
··\ ]
}
··d e
,
··e f
{
¸¸ 
$str
¸¸ 
,
¸¸ 
CIELabFromRGB
¸¸< I
(
¸¸I J
$num
¸¸J M
,
¸¸M N
$num
¸¸O R
,
¸¸R S
$num
¸¸T V
,
¸¸V W
$num
¸¸X \
)
¸¸\ ]
}
¸¸d e
,
¸¸e f
{
¹¹ 
$str
¹¹ 
,
¹¹  
CIELabFromRGB
¹¹< I
(
¹¹I J
$num
¹¹J L
,
¹¹L M
$num
¹¹N Q
,
¹¹Q R
$num
¹¹S V
,
¹¹V W
$num
¹¹X \
)
¹¹\ ]
}
¹¹d e
,
¹¹e f
{
ºº 
$str
ºº 
,
ºº 
CIELabFromRGB
ºº< I
(
ººI J
$num
ººJ M
,
ººM N
$num
ººO R
,
ººR S
$num
ººT W
,
ººW X
$num
ººY ]
)
ºº] ^
}
ººd e
,
ººe f
{
»» 
$str
»» 
,
»» 
CIELabFromRGB
»»< I
(
»»I J
$num
»»J M
,
»»M N
$num
»»O Q
,
»»Q R
$num
»»S V
,
»»V W
$num
»»X \
)
»»\ ]
}
»»d e
,
»»e f
{
¼¼ 
$str
¼¼ 
,
¼¼  
CIELabFromRGB
¼¼< I
(
¼¼I J
$num
¼¼J M
,
¼¼M N
$num
¼¼O R
,
¼¼R S
$num
¼¼T W
,
¼¼W X
$num
¼¼Y ]
)
¼¼] ^
}
¼¼d e
,
¼¼e f
{
½½ 
$str
½½ 
,
½½ 
CIELabFromRGB
½½< I
(
½½I J
$num
½½J M
,
½½M N
$num
½½O R
,
½½R S
$num
½½T W
,
½½W X
$num
½½Y ]
)
½½] ^
}
½½d e
,
½½e f
{
¾¾ 
$str
¾¾ !
,
¾¾! "
CIELabFromRGB
¾¾< I
(
¾¾I J
$num
¾¾J M
,
¾¾M N
$num
¾¾O R
,
¾¾R S
$num
¾¾T W
,
¾¾W X
$num
¾¾Y ]
)
¾¾] ^
}
¾¾d e
,
¾¾e f
{
¿¿ 
$str
¿¿ "
,
¿¿" #
CIELabFromRGB
¿¿< I
(
¿¿I J
$num
¿¿J M
,
¿¿M N
$num
¿¿O R
,
¿¿R S
$num
¿¿T W
,
¿¿W X
$num
¿¿Y ]
)
¿¿] ^
}
¿¿d e
,
¿¿e f
{
ÀÀ 
$str
ÀÀ 
,
ÀÀ 
CIELabFromRGB
ÀÀ< I
(
ÀÀI J
$num
ÀÀJ M
,
ÀÀM N
$num
ÀÀO R
,
ÀÀR S
$num
ÀÀT W
,
ÀÀW X
$num
ÀÀY ]
)
ÀÀ] ^
}
ÀÀd e
,
ÀÀe f
{
ÁÁ 
$str
ÁÁ 
,
ÁÁ 
CIELabFromRGB
ÁÁ< I
(
ÁÁI J
$num
ÁÁJ M
,
ÁÁM N
$num
ÁÁO R
,
ÁÁR S
$num
ÁÁT W
,
ÁÁW X
$num
ÁÁY ]
)
ÁÁ] ^
}
ÁÁd e
,
ÁÁe f
{
ÂÂ 
$str
ÂÂ 
,
ÂÂ 
CIELabFromRGB
ÂÂ< I
(
ÂÂI J
$num
ÂÂJ M
,
ÂÂM N
$num
ÂÂO R
,
ÂÂR S
$num
ÂÂT W
,
ÂÂW X
$num
ÂÂY ]
)
ÂÂ] ^
}
ÂÂd e
,
ÂÂe f
{
ÃÃ 
$str
ÃÃ 
,
ÃÃ 
CIELabFromRGB
ÃÃ< I
(
ÃÃI J
$num
ÃÃJ M
,
ÃÃM N
$num
ÃÃO R
,
ÃÃR S
$num
ÃÃT W
,
ÃÃW X
$num
ÃÃY ]
)
ÃÃ] ^
}
ÃÃd e
,
ÃÃe f
{
ÄÄ 
$str
ÄÄ 
,
ÄÄ 
CIELabFromRGB
ÄÄ< I
(
ÄÄI J
$num
ÄÄJ M
,
ÄÄM N
$num
ÄÄO R
,
ÄÄR S
$num
ÄÄT W
,
ÄÄW X
$num
ÄÄY ]
)
ÄÄ] ^
}
ÄÄd e
,
ÄÄe f
{
ÅÅ 
$str
ÅÅ 
,
ÅÅ 
CIELabFromRGB
ÅÅ< I
(
ÅÅI J
$num
ÅÅJ L
,
ÅÅL M
$num
ÅÅN Q
,
ÅÅQ R
$num
ÅÅS U
,
ÅÅU V
$num
ÅÅW [
)
ÅÅ[ \
}
ÅÅd e
,
ÅÅe f
{
ÆÆ 
$str
ÆÆ )
,
ÆÆ) *
CIELabFromRGB
ÆÆ< I
(
ÆÆI J
$num
ÆÆJ L
,
ÆÆL M
$num
ÆÆN Q
,
ÆÆQ R
$num
ÆÆS V
,
ÆÆV W
$num
ÆÆX \
)
ÆÆ\ ]
}
ÆÆd e
,
ÆÆe f
{
ÇÇ 
$str
ÇÇ !
,
ÇÇ! "
CIELabFromRGB
ÇÇ< I
(
ÇÇI J
$num
ÇÇJ L
,
ÇÇL M
$num
ÇÇN Q
,
ÇÇQ R
$num
ÇÇS V
,
ÇÇV W
$num
ÇÇX \
)
ÇÇ\ ]
}
ÇÇd e
,
ÇÇe f
{
ÈÈ 
$str
ÈÈ 
,
ÈÈ 
CIELabFromRGB
ÈÈ< I
(
ÈÈI J
$num
ÈÈJ M
,
ÈÈM N
$num
ÈÈO R
,
ÈÈR S
$num
ÈÈT W
,
ÈÈW X
$num
ÈÈY ]
)
ÈÈ] ^
}
ÈÈd e
,
ÈÈe f
{
ÉÉ 
$str
ÉÉ 
,
ÉÉ 
CIELabFromRGB
ÉÉ< I
(
ÉÉI J
$num
ÉÉJ M
,
ÉÉM N
$num
ÉÉO R
,
ÉÉR S
$num
ÉÉT W
,
ÉÉW X
$num
ÉÉY ]
)
ÉÉ] ^
}
ÉÉd e
,
ÉÉe f
{
ÊÊ 
$str
ÊÊ 
,
ÊÊ 
CIELabFromRGB
ÊÊ< I
(
ÊÊI J
$num
ÊÊJ M
,
ÊÊM N
$num
ÊÊO R
,
ÊÊR S
$num
ÊÊT W
,
ÊÊW X
$num
ÊÊY ]
)
ÊÊ] ^
}
ÊÊd e
,
ÊÊe f
{
ËË 
$str
ËË 
,
ËË 
CIELabFromRGB
ËË< I
(
ËËI J
$num
ËËJ M
,
ËËM N
$num
ËËO Q
,
ËËQ R
$num
ËËS V
,
ËËV W
$num
ËËX \
)
ËË\ ]
}
ËËd e
,
ËËe f
{
ÌÌ 
$str
ÌÌ 
,
ÌÌ 
CIELabFromRGB
ÌÌ< I
(
ÌÌI J
$num
ÌÌJ M
,
ÌÌM N
$num
ÌÌO Q
,
ÌÌQ R
$num
ÌÌS U
,
ÌÌU V
$num
ÌÌW [
)
ÌÌ[ \
}
ÌÌd e
,
ÌÌe f
{
ÍÍ 
$str
ÍÍ 
,
ÍÍ 
CIELabFromRGB
ÍÍ< I
(
ÍÍI J
$num
ÍÍJ M
,
ÍÍM N
$num
ÍÍO R
,
ÍÍR S
$num
ÍÍT W
,
ÍÍW X
$num
ÍÍY ]
)
ÍÍ] ^
}
ÍÍd e
,
ÍÍe f
{
ÎÎ 
$str
ÎÎ 
,
ÎÎ  
CIELabFromRGB
ÎÎ< I
(
ÎÎI J
$num
ÎÎJ M
,
ÎÎM N
$num
ÎÎO R
,
ÎÎR S
$num
ÎÎT W
,
ÎÎW X
$num
ÎÎY ]
)
ÎÎ] ^
}
ÎÎd e
,
ÎÎe f
{
ÏÏ 
$str
ÏÏ 
,
ÏÏ 
CIELabFromRGB
ÏÏ< I
(
ÏÏI J
$num
ÏÏJ N
,
ÏÏN O
$num
ÏÏP S
,
ÏÏS T
$num
ÏÏU X
,
ÏÏX Y
$num
ÏÏZ ^
)
ÏÏ^ _
}
ÏÏd e
,
ÏÏe f
{
ĞĞ 
$str
ĞĞ 
,
ĞĞ 
CIELabFromRGB
ĞĞ< I
(
ĞĞI J
$num
ĞĞJ N
,
ĞĞN O
$num
ĞĞP R
,
ĞĞR S
$num
ĞĞT W
,
ĞĞW X
$num
ĞĞY ]
)
ĞĞ] ^
}
ĞĞd e
,
ĞĞe f
{
ÑÑ 
$str
ÑÑ 
,
ÑÑ 
CIELabFromRGB
ÑÑ< I
(
ÑÑI J
$num
ÑÑJ M
,
ÑÑM N
$num
ÑÑO R
,
ÑÑR S
$num
ÑÑT W
,
ÑÑW X
$num
ÑÑY ]
)
ÑÑ] ^
}
ÑÑd e
,
ÑÑe f
{
ÒÒ 
$str
ÒÒ 
,
ÒÒ 
CIELabFromRGB
ÒÒ< I
(
ÒÒI J
$num
ÒÒJ M
,
ÒÒM N
$num
ÒÒO Q
,
ÒÒQ R
$num
ÒÒS U
,
ÒÒU V
$num
ÒÒW [
)
ÒÒ[ \
}
ÒÒd e
,
ÒÒe f
{
ÓÓ 
$str
ÓÓ 
,
ÓÓ 
CIELabFromRGB
ÓÓ< I
(
ÓÓI J
$num
ÓÓJ M
,
ÓÓM N
$num
ÓÓO R
,
ÓÓR S
$num
ÓÓT W
,
ÓÓW X
$num
ÓÓY ]
)
ÓÓ] ^
}
ÓÓd e
,
ÓÓe f
{
ÔÔ 
$str
ÔÔ 
,
ÔÔ 
CIELabFromRGB
ÔÔ< I
(
ÔÔI J
$num
ÔÔJ N
,
ÔÔN O
$num
ÔÔP S
,
ÔÔS T
$num
ÔÔU X
,
ÔÔX Y
$num
ÔÔZ ^
)
ÔÔ^ _
}
ÔÔd e
,
ÔÔe f
{
ÕÕ 
$str
ÕÕ 
,
ÕÕ 
CIELabFromRGB
ÕÕ< I
(
ÕÕI J
$num
ÕÕJ L
,
ÕÕL M
$num
ÕÕN Q
,
ÕÕQ R
$num
ÕÕS W
,
ÕÕW X
$num
ÕÕY ]
)
ÕÕ] ^
}
ÕÕd e
,
ÕÕe f
{
ÖÖ 
$str
ÖÖ "
,
ÖÖ" #
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ M
,
ÖÖM N
$num
ÖÖO R
,
ÖÖR S
$num
ÖÖT W
,
ÖÖW X
$num
ÖÖY ]
)
ÖÖ] ^
}
ÖÖd e
,
ÖÖe f
{
×× 
$str
×× 
,
××  
CIELabFromRGB
××< I
(
××I J
$num
××J M
,
××M N
$num
××O R
,
××R S
$num
××T W
,
××W X
$num
××Y ]
)
××] ^
}
××d e
,
××e f
{
ØØ 
$str
ØØ 
,
ØØ 
CIELabFromRGB
ØØ< I
(
ØØI J
$num
ØØJ M
,
ØØM N
$num
ØØO R
,
ØØR S
$num
ØØT W
,
ØØW X
$num
ØØY ]
)
ØØ] ^
}
ØØd e
,
ØØe f
{
ÙÙ 
$str
ÙÙ 
,
ÙÙ  
CIELabFromRGB
ÙÙ< I
(
ÙÙI J
$num
ÙÙJ M
,
ÙÙM N
$num
ÙÙO R
,
ÙÙR S
$num
ÙÙT W
,
ÙÙW X
$num
ÙÙY ]
)
ÙÙ] ^
}
ÙÙd e
,
ÙÙe f
{
ÚÚ 
$str
ÚÚ 
,
ÚÚ 
CIELabFromRGB
ÚÚ< I
(
ÚÚI J
$num
ÚÚJ M
,
ÚÚM N
$num
ÚÚO Q
,
ÚÚQ R
$num
ÚÚS V
,
ÚÚV W
$num
ÚÚX \
)
ÚÚ\ ]
}
ÚÚd e
,
ÚÚe f
{
ÛÛ 
$str
ÛÛ 
,
ÛÛ 
CIELabFromRGB
ÛÛ< I
(
ÛÛI J
$num
ÛÛJ M
,
ÛÛM N
$num
ÛÛO R
,
ÛÛR S
$num
ÛÛT W
,
ÛÛW X
$num
ÛÛY ]
)
ÛÛ] ^
}
ÛÛd e
,
ÛÛe f
{
ÜÜ 
$str
ÜÜ 
,
ÜÜ 
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ L
,
ÜÜL M
$num
ÜÜN Q
,
ÜÜQ R
$num
ÜÜS V
,
ÜÜV W
$num
ÜÜX \
)
ÜÜ\ ]
}
ÜÜd e
,
ÜÜe f
{
İİ 
$str
İİ  
,
İİ  !
CIELabFromRGB
İİ< I
(
İİI J
$num
İİJ M
,
İİM N
$num
İİO R
,
İİR S
$num
İİT W
,
İİW X
$num
İİY ]
)
İİ] ^
}
İİd e
,
İİe f
{
ŞŞ 
$str
ŞŞ 
,
ŞŞ 
CIELabFromRGB
ŞŞ< I
(
ŞŞI J
$num
ŞŞJ M
,
ŞŞM N
$num
ŞŞO R
,
ŞŞR S
$num
ŞŞT W
,
ŞŞW X
$num
ŞŞY ]
)
ŞŞ] ^
}
ŞŞd e
,
ŞŞe f
{
ßß 
$str
ßß 
,
ßß 
CIELabFromRGB
ßß< I
(
ßßI J
$num
ßßJ M
,
ßßM N
$num
ßßO R
,
ßßR S
$num
ßßT W
,
ßßW X
$num
ßßY ]
)
ßß] ^
}
ßßd e
,
ßße f
{
àà 
$str
àà 
,
àà 
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ M
,
ààM N
$num
ààO R
,
ààR S
$num
ààT W
,
ààW X
$num
ààY ]
)
àà] ^
}
ààd e
,
ààe f
{
áá 
$str
áá 
,
áá 
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ M
,
ááM N
$num
ááO R
,
ááR S
$num
ááT X
,
ááX Y
$num
ááZ ^
)
áá^ _
}
áád e
,
ááe f
{
ââ 
$str
ââ 
,
ââ 
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ M
,
ââM N
$num
ââO R
,
ââR S
$num
ââT W
,
ââW X
$num
ââY ]
)
ââ] ^
}
ââd e
,
ââe f
{
ãã 
$str
ãã 
,
ãã 
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ M
,
ããM N
$num
ããO R
,
ããR S
$num
ããT W
,
ããW X
$num
ããY ]
)
ãã] ^
}
ããd e
,
ããe f
{
ää 
$str
ää 
,
ää 
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ M
,
ääM N
$num
ääO R
,
ääR S
$num
ääT X
,
ääX Y
$num
ääZ ^
)
ää^ _
}
ääd e
,
ääe f
{
åå 
$str
åå 
,
åå 
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ M
,
ååM N
$num
ååO Q
,
ååQ R
$num
ååS V
,
ååV W
$num
ååX \
)
åå\ ]
}
ååd e
,
ååe f
{
ææ 
$str
ææ 
,
ææ 
CIELabFromRGB
ææ< I
(
ææI J
$num
ææJ M
,
ææM N
$num
ææO R
,
ææR S
$num
ææT W
,
ææW X
$num
ææY ]
)
ææ] ^
}
ææd e
,
ææe f
{
çç 
$str
çç 
,
çç 
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ M
,
ççM N
$num
ççO R
,
ççR S
$num
ççT W
,
ççW X
$num
ççY ]
)
çç] ^
}
ççd e
,
ççe f
{
èè 
$str
èè 
,
èè 
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ M
,
èèM N
$num
èèO R
,
èèR S
$num
èèT V
,
èèV W
$num
èèX \
)
èè\ ]
}
èèd e
,
èèe f
{
éé 
$str
éé 
,
éé 
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ L
,
ééL M
$num
ééN P
,
ééP Q
$num
ééR U
,
ééU V
$num
ééW [
)
éé[ \
}
ééd e
,
éée f
{
êê 
$str
êê 
,
êê 
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ M
,
êêM N
$num
êêO R
,
êêR S
$num
êêT W
,
êêW X
$num
êêY ]
)
êê] ^
}
êêd e
,
êêe f
{
ëë 
$str
ëë 
,
ëë 
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ M
,
ëëM N
$num
ëëO R
,
ëëR S
$num
ëëT W
,
ëëW X
$num
ëëY ]
)
ëë] ^
}
ëëd e
,
ëëe f
{
ìì 
$str
ìì 
,
ìì 
CIELabFromRGB
ìì< I
(
ììI J
$num
ììJ M
,
ììM N
$num
ììO R
,
ììR S
$num
ììT W
,
ììW X
$num
ììY ]
)
ìì] ^
}
ììd e
,
ììe f
{
íí 
$str
íí 
,
íí 
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ M
,
ííM N
$num
ííO R
,
ííR S
$num
ííT W
,
ííW X
$num
ííY ]
)
íí] ^
}
ííd e
,
ííe f
{
îî 
$str
îî 
,
îî 
CIELabFromRGB
îî< I
(
îîI J
$num
îîJ M
,
îîM N
$num
îîO R
,
îîR S
$num
îîT W
,
îîW X
$num
îîY ]
)
îî] ^
}
îîd e
,
îîe f
{
ïï 
$str
ïï 
,
ïï 
CIELabFromRGB
ïï< I
(
ïïI J
$num
ïïJ M
,
ïïM N
$num
ïïO R
,
ïïR S
$num
ïïT W
,
ïïW X
$num
ïïY ]
)
ïï] ^
}
ïïd e
,
ïïe f
{
ğğ 
$str
ğğ 
,
ğğ 
CIELabFromRGB
ğğ< I
(
ğğI J
$num
ğğJ M
,
ğğM N
$num
ğğO R
,
ğğR S
$num
ğğT W
,
ğğW X
$num
ğğY ]
)
ğğ] ^
}
ğğd e
,
ğğe f
{
ññ 
$str
ññ 
,
ññ 
CIELabFromRGB
ññ< I
(
ññI J
$num
ññJ M
,
ññM N
$num
ññO R
,
ññR S
$num
ññT W
,
ññW X
$num
ññY ]
)
ññ] ^
}
ññd e
,
ññe f
{
òò 
$str
òò 
,
òò 
CIELabFromRGB
òò< I
(
òòI J
$num
òòJ L
,
òòL M
$num
òòN Q
,
òòQ R
$num
òòS V
,
òòV W
$num
òòX \
)
òò\ ]
}
òòd e
,
òòe f
{
óó 
$str
óó 
,
óó 
CIELabFromRGB
óó< I
(
óóI J
$num
óóJ M
,
óóM N
$num
óóO R
,
óóR S
$num
óóT X
,
óóX Y
$num
óóZ ^
)
óó^ _
}
óód e
,
óóe f
{
ôô 
$str
ôô  
,
ôô  !
CIELabFromRGB
ôô< I
(
ôôI J
$num
ôôJ N
,
ôôN O
$num
ôôP R
,
ôôR S
$num
ôôT W
,
ôôW X
$num
ôôY ]
)
ôô] ^
}
ôôd e
,
ôôe f
{
õõ 
$str
õõ 
,
õõ 
CIELabFromRGB
õõ< I
(
õõI J
$num
õõJ L
,
õõL M
$num
õõN R
,
õõR S
$num
õõT X
,
õõX Y
$num
õõZ ^
)
õõ^ _
}
õõd e
,
õõe f
{
öö 
$str
öö 
,
öö 
CIELabFromRGB
öö< I
(
ööI J
$num
ööJ L
,
ööL M
$num
ööN R
,
ööR S
$num
ööT V
,
ööV W
$num
ööX \
)
öö\ ]
}
ööd e
,
ööe f
{
÷÷ 
$str
÷÷ 
,
÷÷  
CIELabFromRGB
÷÷< I
(
÷÷I J
$num
÷÷J M
,
÷÷M N
$num
÷÷O Q
,
÷÷Q R
$num
÷÷S W
,
÷÷W X
$num
÷÷Y ]
)
÷÷] ^
}
÷÷d e
,
÷÷e f
{
øø 
$str
øø !
,
øø! "
CIELabFromRGB
øø< I
(
øøI J
$num
øøJ M
,
øøM N
$num
øøO R
,
øøR S
$num
øøT X
,
øøX Y
$num
øøZ ^
)
øø^ _
}
øød e
,
øøe f
{
ùù 
$str
ùù 
,
ùù 
CIELabFromRGB
ùù< I
(
ùùI J
$num
ùùJ M
,
ùùM N
$num
ùùO S
,
ùùS T
$num
ùùU W
,
ùùW X
$num
ùùY ]
)
ùù] ^
}
ùùd e
,
ùùe f
{
úú 
$str
úú 
,
úú  
CIELabFromRGB
úú< I
(
úúI J
$num
úúJ M
,
úúM N
$num
úúO Q
,
úúQ R
$num
úúS W
,
úúW X
$num
úúY ]
)
úú] ^
}
úúd e
,
úúe f
{
ûû 
$str
ûû $
,
ûû$ %
CIELabFromRGB
ûû< I
(
ûûI J
$num
ûûJ M
,
ûûM N
$num
ûûO Q
,
ûûQ R
$num
ûûS W
,
ûûW X
$num
ûûY ]
)
ûû] ^
}
ûûd e
,
ûûe f
{
üü 
$str
üü 
,
üü  
CIELabFromRGB
üü< I
(
üüI J
$num
üüJ M
,
üüM N
$num
üüO Q
,
üüQ R
$num
üüS W
,
üüW X
$num
üüY ]
)
üü] ^
}
üüd e
,
üüe f
{
ıı 
$str
ıı 
,
ıı  
CIELabFromRGB
ıı< I
(
ııI J
$num
ııJ N
,
ııN O
$num
ııP T
,
ııT U
$num
ııV Y
,
ııY Z
$num
ıı[ _
)
ıı_ `
}
ııd e
,
ııe f
{
şş 
$str
şş 
,
şş 
CIELabFromRGB
şş< I
(
şşI J
$num
şşJ M
,
şşM N
$num
şşO R
,
şşR S
$num
şşT W
,
şşW X
$num
şşY ]
)
şş] ^
}
şşd e
,
şşe f
{
ÿÿ 
$str
ÿÿ 
,
ÿÿ 
CIELabFromRGB
ÿÿ< I
(
ÿÿI J
$num
ÿÿJ M
,
ÿÿM N
$num
ÿÿO R
,
ÿÿR S
$num
ÿÿT W
,
ÿÿW X
$num
ÿÿY ]
)
ÿÿ] ^
}
ÿÿd e
,
ÿÿe f
{
€€ 
$str
€€ 
,
€€ 
CIELabFromRGB
€€< I
(
€€I J
$num
€€J M
,
€€M N
$num
€€O R
,
€€R S
$num
€€T W
,
€€W X
$num
€€Y ]
)
€€] ^
}
€€d e
,
€€e f
{
 
$str
  
,
  !
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
‚‚ 
$str
‚‚ 
,
‚‚ 
CIELabFromRGB
‚‚< I
(
‚‚I J
$num
‚‚J M
,
‚‚M N
$num
‚‚O R
,
‚‚R S
$num
‚‚T W
,
‚‚W X
$num
‚‚Y ]
)
‚‚] ^
}
‚‚d e
,
‚‚e f
{
ƒƒ 
$str
ƒƒ 
,
ƒƒ 
CIELabFromRGB
ƒƒ< I
(
ƒƒI J
$num
ƒƒJ M
,
ƒƒM N
$num
ƒƒO R
,
ƒƒR S
$num
ƒƒT W
,
ƒƒW X
$num
ƒƒY ]
)
ƒƒ] ^
}
ƒƒd e
,
ƒƒe f
{
„„ 
$str
„„ 
,
„„ 
CIELabFromRGB
„„< I
(
„„I J
$num
„„J M
,
„„M N
$num
„„O R
,
„„R S
$num
„„T W
,
„„W X
$num
„„Y ]
)
„„] ^
}
„„d e
,
„„e f
{
…… 
$str
…… 
,
…… 
CIELabFromRGB
……< I
(
……I J
$num
……J M
,
……M N
$num
……O R
,
……R S
$num
……T W
,
……W X
$num
……Y ]
)
……] ^
}
……d e
,
……e f
{
†† 
$str
†† 
,
†† 
CIELabFromRGB
††< I
(
††I J
$num
††J M
,
††M N
$num
††O R
,
††R S
$num
††T W
,
††W X
$num
††Y ]
)
††] ^
}
††d e
,
††e f
{
‡‡ 
$str
‡‡ 
,
‡‡ 
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J M
,
‡‡M N
$num
‡‡O Q
,
‡‡Q R
$num
‡‡S U
,
‡‡U V
$num
‡‡W [
)
‡‡[ \
}
‡‡d e
,
‡‡e f
{
ˆˆ 
$str
ˆˆ 
,
ˆˆ 
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ M
,
ˆˆM N
$num
ˆˆO R
,
ˆˆR S
$num
ˆˆT W
,
ˆˆW X
$num
ˆˆY ]
)
ˆˆ] ^
}
ˆˆd e
,
ˆˆe f
{
‰‰ 
$str
‰‰ 
,
‰‰ 
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J M
,
‰‰M N
$num
‰‰O R
,
‰‰R S
$num
‰‰T W
,
‰‰W X
$num
‰‰Y ]
)
‰‰] ^
}
‰‰d e
,
‰‰e f
{
ŠŠ 
$str
ŠŠ 
,
ŠŠ  
CIELabFromRGB
ŠŠ< I
(
ŠŠI J
$num
ŠŠJ M
,
ŠŠM N
$num
ŠŠO Q
,
ŠŠQ R
$num
ŠŠS V
,
ŠŠV W
$num
ŠŠX \
)
ŠŠ\ ]
}
ŠŠd e
,
ŠŠe f
{
‹‹ 
$str
‹‹ 
,
‹‹ 
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J M
,
‹‹M N
$num
‹‹O R
,
‹‹R S
$num
‹‹T W
,
‹‹W X
$num
‹‹Y ]
)
‹‹] ^
}
‹‹d e
,
‹‹e f
{
ŒŒ 
$str
ŒŒ 
,
ŒŒ 
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ M
,
ŒŒM N
$num
ŒŒO R
,
ŒŒR S
$num
ŒŒT W
,
ŒŒW X
$num
ŒŒY ]
)
ŒŒ] ^
}
ŒŒd e
,
ŒŒe f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J N
,
N O
$num
P S
,
S T
$num
U W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
‘‘ 
$str
‘‘ 
,
‘‘ 
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J M
,
‘‘M N
$num
‘‘O R
,
‘‘R S
$num
‘‘T W
,
‘‘W X
$num
‘‘Y ]
)
‘‘] ^
}
‘‘d e
,
‘‘e f
{
’’ 
$str
’’ 
,
’’  
CIELabFromRGB
’’< I
(
’’I J
$num
’’J M
,
’’M N
$num
’’O R
,
’’R S
$num
’’T W
,
’’W X
$num
’’Y ]
)
’’] ^
}
’’d e
,
’’e f
{
““ 
$str
““ 
,
““ 
CIELabFromRGB
““< I
(
““I J
$num
““J M
,
““M N
$num
““O R
,
““R S
$num
““T W
,
““W X
$num
““Y ]
)
““] ^
}
““d e
,
““e f
{
”” 
$str
”” 
,
”” 
CIELabFromRGB
””< I
(
””I J
$num
””J M
,
””M N
$num
””O R
,
””R S
$num
””T W
,
””W X
$num
””Y ]
)
””] ^
}
””d e
,
””e f
{
•• 
$str
•• 
,
•• 
CIELabFromRGB
••< I
(
••I J
$num
••J M
,
••M N
$num
••O R
,
••R S
$num
••T W
,
••W X
$num
••Y ]
)
••] ^
}
••d e
,
••e f
{
–– 
$str
–– 
,
–– 
CIELabFromRGB
––< I
(
––I J
$num
––J M
,
––M N
$num
––O R
,
––R S
$num
––T W
,
––W X
$num
––Y ]
)
––] ^
}
––d e
,
––e f
{
—— 
$str
—— 
,
—— 
CIELabFromRGB
——< I
(
——I J
$num
——J M
,
——M N
$num
——O R
,
——R S
$num
——T W
,
——W X
$num
——Y ]
)
——] ^
}
——d e
,
——e f
{
˜˜ 
$str
˜˜ 
,
˜˜ 
CIELabFromRGB
˜˜< I
(
˜˜I J
$num
˜˜J M
,
˜˜M N
$num
˜˜O Q
,
˜˜Q R
$num
˜˜S V
,
˜˜V W
$num
˜˜X \
)
˜˜\ ]
}
˜˜d e
,
˜˜e f
{
™™ 
$str
™™ 
,
™™ 
CIELabFromRGB
™™< I
(
™™I J
$num
™™J N
,
™™N O
$num
™™P S
,
™™S T
$num
™™U X
,
™™X Y
$num
™™Z ^
)
™™^ _
}
™™d e
,
™™e f
{
šš 
$str
šš "
,
šš" #
CIELabFromRGB
šš< I
(
ššI J
$num
ššJ N
,
ššN O
$num
ššP S
,
ššS T
$num
ššU W
,
ššW X
$num
ššY ]
)
šš] ^
}
ššd e
,
šše f
{
›› 
$str
››  
,
››  !
CIELabFromRGB
››< I
(
››I J
$num
››J N
,
››N O
$num
››P R
,
››R S
$num
››T W
,
››W X
$num
››Y ]
)
››] ^
}
››d e
,
››e f
{
œœ 
$str
œœ "
,
œœ" #
CIELabFromRGB
œœ< I
(
œœI J
$num
œœJ M
,
œœM N
$num
œœO S
,
œœS T
$num
œœU W
,
œœW X
$num
œœY ]
)
œœ] ^
}
œœd e
,
œœe f
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J N
,
N O
$num
P R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
d e
,
e f
{
 
$str
 *
,
* +
CIELabFromRGB
< I
(
I J
$num
J L
,
L M
$num
N Q
,
Q R
$num
S V
,
V W
$num
X \
)
\ ]
}
d e
,
e f
{
ŸŸ 
$str
ŸŸ "
,
ŸŸ" #
CIELabFromRGB
ŸŸ< I
(
ŸŸI J
$num
ŸŸJ M
,
ŸŸM N
$num
ŸŸO R
,
ŸŸR S
$num
ŸŸT W
,
ŸŸW X
$num
ŸŸY ]
)
ŸŸ] ^
}
ŸŸd e
,
ŸŸe f
{
   
$str
   
,
   
CIELabFromRGB
  < I
(
  I J
$num
  J M
,
  M N
$num
  O R
,
  R S
$num
  T W
,
  W X
$num
  Y ]
)
  ] ^
}
  d e
,
  e f
{
¡¡ 
$str
¡¡ 
,
¡¡ 
CIELabFromRGB
¡¡< I
(
¡¡I J
$num
¡¡J M
,
¡¡M N
$num
¡¡O R
,
¡¡R S
$num
¡¡T W
,
¡¡W X
$num
¡¡Y ]
)
¡¡] ^
}
¡¡d e
,
¡¡e f
{
¢¢ 
$str
¢¢ 
,
¢¢ 
CIELabFromRGB
¢¢< I
(
¢¢I J
$num
¢¢J L
,
¢¢L M
$num
¢¢N Q
,
¢¢Q R
$num
¢¢S V
,
¢¢V W
$num
¢¢X \
)
¢¢\ ]
}
¢¢d e
,
¢¢e f
{
££ 
$str
££ 
,
££ 
CIELabFromRGB
££< I
(
££I J
$num
££J M
,
££M N
$num
££O R
,
££R S
$num
££T W
,
££W X
$num
££Y ]
)
££] ^
}
££d e
,
££e f
{
¤¤ 
$str
¤¤ 
,
¤¤ 
CIELabFromRGB
¤¤< I
(
¤¤I J
$num
¤¤J M
,
¤¤M N
$num
¤¤O R
,
¤¤R S
$num
¤¤T W
,
¤¤W X
$num
¤¤Y ]
)
¤¤] ^
}
¤¤d e
,
¤¤e f
{
¥¥ 
$str
¥¥ 
,
¥¥ 
CIELabFromRGB
¥¥< I
(
¥¥I J
$num
¥¥J M
,
¥¥M N
$num
¥¥O R
,
¥¥R S
$num
¥¥T W
,
¥¥W X
$num
¥¥Y ]
)
¥¥] ^
}
¥¥d e
,
¥¥e f
{
¦¦ 
$str
¦¦ 
,
¦¦ 
CIELabFromRGB
¦¦< I
(
¦¦I J
$num
¦¦J M
,
¦¦M N
$num
¦¦O R
,
¦¦R S
$num
¦¦T W
,
¦¦W X
$num
¦¦Y ]
)
¦¦] ^
}
¦¦d e
,
¦¦e f
{
§§ 
$str
§§ 
,
§§ 
CIELabFromRGB
§§< I
(
§§I J
$num
§§J M
,
§§M N
$num
§§O R
,
§§R S
$num
§§T W
,
§§W X
$num
§§Y ]
)
§§] ^
}
§§d e
,
§§e f
{
¨¨ 
$str
¨¨ 
,
¨¨ 
CIELabFromRGB
¨¨< I
(
¨¨I J
$num
¨¨J M
,
¨¨M N
$num
¨¨O Q
,
¨¨Q R
$num
¨¨S V
,
¨¨V W
$num
¨¨X \
)
¨¨\ ]
}
¨¨d e
,
¨¨e f
{
©© 
$str
©© 
,
©© 
CIELabFromRGB
©©< I
(
©©I J
$num
©©J M
,
©©M N
$num
©©O Q
,
©©Q R
$num
©©S U
,
©©U V
$num
©©W [
)
©©[ \
}
©©d e
,
©©e f
{
ªª 
$str
ªª  
,
ªª  !
CIELabFromRGB
ªª< I
(
ªªI J
$num
ªªJ M
,
ªªM N
$num
ªªO R
,
ªªR S
$num
ªªT W
,
ªªW X
$num
ªªY ]
)
ªª] ^
}
ªªd e
,
ªªe f
{
«« 
$str
«« 
,
«« 
CIELabFromRGB
««< I
(
««I J
$num
««J M
,
««M N
$num
««O R
,
««R S
$num
««T W
,
««W X
$num
««Y ]
)
««] ^
}
««d e
,
««e f
{
¬¬ 
$str
¬¬ 
,
¬¬  
CIELabFromRGB
¬¬< I
(
¬¬I J
$num
¬¬J M
,
¬¬M N
$num
¬¬O R
,
¬¬R S
$num
¬¬T X
,
¬¬X Y
$num
¬¬Z ^
)
¬¬^ _
}
¬¬d e
,
¬¬e f
{
­­ 
$str
­­ 
,
­­ 
CIELabFromRGB
­­< I
(
­­I J
$num
­­J M
,
­­M N
$num
­­O Q
,
­­Q R
$num
­­S V
,
­­V W
$num
­­X \
)
­­\ ]
}
­­d e
,
­­e f
{
®® 
$str
®® 
,
®® 
CIELabFromRGB
®®< I
(
®®I J
$num
®®J M
,
®®M N
$num
®®O R
,
®®R S
$num
®®T W
,
®®W X
$num
®®Y ]
)
®®] ^
}
®®d e
,
®®e f
{
¯¯ 
$str
¯¯ 
,
¯¯ 
CIELabFromRGB
¯¯< I
(
¯¯I J
$num
¯¯J M
,
¯¯M N
$num
¯¯O R
,
¯¯R S
$num
¯¯T X
,
¯¯X Y
$num
¯¯Z ^
)
¯¯^ _
}
¯¯d e
,
¯¯e f
{
°° 
$str
°° 
,
°° 
CIELabFromRGB
°°< I
(
°°I J
$num
°°J N
,
°°N O
$num
°°P R
,
°°R S
$num
°°T X
,
°°X Y
$num
°°Z ^
)
°°^ _
}
°°d e
,
°°e f
{
±± 
$str
±± !
,
±±! "
CIELabFromRGB
±±< I
(
±±I J
$num
±±J M
,
±±M N
$num
±±O R
,
±±R S
$num
±±T W
,
±±W X
$num
±±Y ]
)
±±] ^
}
±±d e
,
±±e f
{
²² 
$str
²² 
,
²² 
CIELabFromRGB
²²< I
(
²²I J
$num
²²J N
,
²²N O
$num
²²P S
,
²²S T
$num
²²U Y
,
²²Y Z
$num
²²[ _
)
²²_ `
}
²²d e
,
²²e f
{
³³ 
$str
³³ 
,
³³ 
CIELabFromRGB
³³< I
(
³³I J
$num
³³J M
,
³³M N
$num
³³O R
,
³³R S
$num
³³T W
,
³³W X
$num
³³Y ]
)
³³] ^
}
³³d e
,
³³e f
{
´´ 
$str
´´ 
,
´´ 
CIELabFromRGB
´´< I
(
´´I J
$num
´´J M
,
´´M N
$num
´´O R
,
´´R S
$num
´´T W
,
´´W X
$num
´´Y ]
)
´´] ^
}
´´d e
,
´´e f
{
µµ 
$str
µµ 
,
µµ 
CIELabFromRGB
µµ< I
(
µµI J
$num
µµJ M
,
µµM N
$num
µµO R
,
µµR S
$num
µµT V
,
µµV W
$num
µµX \
)
µµ\ ]
}
µµd e
,
µµe f
{
¶¶ 
$str
¶¶ 
,
¶¶ 
CIELabFromRGB
¶¶< I
(
¶¶I J
$num
¶¶J M
,
¶¶M N
$num
¶¶O R
,
¶¶R S
$num
¶¶T W
,
¶¶W X
$num
¶¶Y ]
)
¶¶] ^
}
¶¶d e
,
¶¶e f
{
·· 
$str
·· 
,
·· 
CIELabFromRGB
··< I
(
··I J
$num
··J M
,
··M N
$num
··O R
,
··R S
$num
··T W
,
··W X
$num
··Y ]
)
··] ^
}
··_ `
,
··` a
{
¸¸ 
$str
¸¸ 
,
¸¸ 
CIELabFromRGB
¸¸< I
(
¸¸I J
$num
¸¸J M
,
¸¸M N
$num
¸¸O R
,
¸¸R S
$num
¸¸T V
,
¸¸V W
$num
¸¸X \
)
¸¸\ ]
}
¸¸^ _
,
¸¸_ `
{
¹¹ 
$str
¹¹ &
,
¹¹& '
CIELabFromRGB
¹¹< I
(
¹¹I J
$num
¹¹J M
,
¹¹M N
$num
¹¹O R
,
¹¹R S
$num
¹¹T V
,
¹¹V W
$num
¹¹X \
)
¹¹\ ]
}
¹¹^ _
,
¹¹_ `
{
ºº 
$str
ºº  
,
ºº  !
CIELabFromRGB
ºº< I
(
ººI J
$num
ººJ L
,
ººL M
$num
ººN Q
,
ººQ R
$num
ººS V
,
ººV W
$num
ººX \
)
ºº\ ]
}
ºº^ _
,
ºº_ `
{
»» 
$str
»» 
,
»» 
CIELabFromRGB
»»< I
(
»»I J
$num
»»J M
,
»»M N
$num
»»O R
,
»»R S
$num
»»T X
,
»»X Y
$num
»»Z ^
)
»»^ _
}
»»` a
,
»»a b
{
¼¼ 
$str
¼¼ 
,
¼¼ 
CIELabFromRGB
¼¼< I
(
¼¼I J
$num
¼¼J N
,
¼¼N O
$num
¼¼P S
,
¼¼S T
$num
¼¼U X
,
¼¼X Y
$num
¼¼Z ^
)
¼¼^ _
}
¼¼` a
,
¼¼a b
{
½½ 
$str
½½ 
,
½½ 
CIELabFromRGB
½½< I
(
½½I J
$num
½½J M
,
½½M N
$num
½½O R
,
½½R S
$num
½½T V
,
½½V W
$num
½½X \
)
½½\ ]
}
½½^ _
,
½½_ `
{
¾¾ 
$str
¾¾ 
,
¾¾ 
CIELabFromRGB
¾¾< I
(
¾¾I J
$num
¾¾J M
,
¾¾M N
$num
¾¾O R
,
¾¾R S
$num
¾¾T W
,
¾¾W X
$num
¾¾Y ]
)
¾¾] ^
}
¾¾_ `
,
¾¾` a
{
¿¿ 
$str
¿¿ 
,
¿¿ 
CIELabFromRGB
¿¿< I
(
¿¿I J
$num
¿¿J M
,
¿¿M N
$num
¿¿O R
,
¿¿R S
$num
¿¿T W
,
¿¿W X
$num
¿¿Y ]
)
¿¿] ^
}
¿¿_ `
,
¿¿` a
{
ÀÀ 
$str
ÀÀ 
,
ÀÀ 
CIELabFromRGB
ÀÀ< I
(
ÀÀI J
$num
ÀÀJ L
,
ÀÀL M
$num
ÀÀN Q
,
ÀÀQ R
$num
ÀÀS V
,
ÀÀV W
$num
ÀÀX \
)
ÀÀ\ ]
}
ÀÀ^ _
,
ÀÀ_ `
{
ÁÁ 
$str
ÁÁ 
,
ÁÁ  
CIELabFromRGB
ÁÁ< I
(
ÁÁI J
$num
ÁÁJ M
,
ÁÁM N
$num
ÁÁO R
,
ÁÁR S
$num
ÁÁT W
,
ÁÁW X
$num
ÁÁY ]
)
ÁÁ] ^
}
ÁÁ_ `
,
ÁÁ` a
{
ÂÂ 
$str
ÂÂ #
,
ÂÂ# $
CIELabFromRGB
ÂÂ< I
(
ÂÂI J
$num
ÂÂJ N
,
ÂÂN O
$num
ÂÂP S
,
ÂÂS T
$num
ÂÂU W
,
ÂÂW X
$num
ÂÂY ]
)
ÂÂ] ^
}
ÂÂ_ `
,
ÂÂ` a
{
ÃÃ 
$str
ÃÃ 
,
ÃÃ 
CIELabFromRGB
ÃÃ< I
(
ÃÃI J
$num
ÃÃJ M
,
ÃÃM N
$num
ÃÃO R
,
ÃÃR S
$num
ÃÃT W
,
ÃÃW X
$num
ÃÃY ]
)
ÃÃ] ^
}
ÃÃ_ `
,
ÃÃ` a
{
ÄÄ 
$str
ÄÄ 
,
ÄÄ 
CIELabFromRGB
ÄÄ< I
(
ÄÄI J
$num
ÄÄJ M
,
ÄÄM N
$num
ÄÄO R
,
ÄÄR S
$num
ÄÄT V
,
ÄÄV W
$num
ÄÄX \
)
ÄÄ\ ]
}
ÄÄ^ _
,
ÄÄ_ `
{
ÅÅ 
$str
ÅÅ 
,
ÅÅ 
CIELabFromRGB
ÅÅ< I
(
ÅÅI J
$num
ÅÅJ M
,
ÅÅM N
$num
ÅÅO R
,
ÅÅR S
$num
ÅÅT V
,
ÅÅV W
$num
ÅÅX \
)
ÅÅ\ ]
}
ÅÅ^ _
,
ÅÅ_ `
{
ÆÆ 
$str
ÆÆ 
,
ÆÆ 
CIELabFromRGB
ÆÆ< I
(
ÆÆI J
$num
ÆÆJ N
,
ÆÆN O
$num
ÆÆP S
,
ÆÆS T
$num
ÆÆU W
,
ÆÆW X
$num
ÆÆY ]
)
ÆÆ] ^
}
ÆÆ_ `
,
ÆÆ` a
{
ÇÇ 
$str
ÇÇ 
,
ÇÇ 
CIELabFromRGB
ÇÇ< I
(
ÇÇI J
$num
ÇÇJ M
,
ÇÇM N
$num
ÇÇO R
,
ÇÇR S
$num
ÇÇT W
,
ÇÇW X
$num
ÇÇY ]
)
ÇÇ] ^
}
ÇÇ_ `
,
ÇÇ` a
{
ÈÈ 
$str
ÈÈ "
,
ÈÈ" #
CIELabFromRGB
ÈÈ< I
(
ÈÈI J
$num
ÈÈJ M
,
ÈÈM N
$num
ÈÈO R
,
ÈÈR S
$num
ÈÈT W
,
ÈÈW X
$num
ÈÈY ]
)
ÈÈ] ^
}
ÈÈ_ `
,
ÈÈ` a
{
ÉÉ 
$str
ÉÉ 
,
ÉÉ 
CIELabFromRGB
ÉÉ< I
(
ÉÉI J
$num
ÉÉJ M
,
ÉÉM N
$num
ÉÉO R
,
ÉÉR S
$num
ÉÉT W
,
ÉÉW X
$num
ÉÉY ]
)
ÉÉ] ^
}
ÉÉ_ `
,
ÉÉ` a
{
ÊÊ 
$str
ÊÊ 
,
ÊÊ 
CIELabFromRGB
ÊÊ< I
(
ÊÊI J
$num
ÊÊJ M
,
ÊÊM N
$num
ÊÊO R
,
ÊÊR S
$num
ÊÊT W
,
ÊÊW X
$num
ÊÊY ]
)
ÊÊ] ^
}
ÊÊ_ `
,
ÊÊ` a
{
ËË 
$str
ËË $
,
ËË$ %
CIELabFromRGB
ËË< I
(
ËËI J
$num
ËËJ M
,
ËËM N
$num
ËËO R
,
ËËR S
$num
ËËT W
,
ËËW X
$num
ËËY ]
)
ËË] ^
}
ËË_ `
,
ËË` a
{
ÌÌ 
$str
ÌÌ 
,
ÌÌ  
CIELabFromRGB
ÌÌ< I
(
ÌÌI J
$num
ÌÌJ M
,
ÌÌM N
$num
ÌÌO R
,
ÌÌR S
$num
ÌÌT W
,
ÌÌW X
$num
ÌÌY ]
)
ÌÌ] ^
}
ÌÌ_ `
,
ÌÌ` a
{
ÍÍ 
$str
ÍÍ 
,
ÍÍ 
CIELabFromRGB
ÍÍ< I
(
ÍÍI J
$num
ÍÍJ M
,
ÍÍM N
$num
ÍÍO R
,
ÍÍR S
$num
ÍÍT W
,
ÍÍW X
$num
ÍÍY ]
)
ÍÍ] ^
}
ÍÍ_ `
,
ÍÍ` a
{
ÎÎ 
$str
ÎÎ 
,
ÎÎ 
CIELabFromRGB
ÎÎ< I
(
ÎÎI J
$num
ÎÎJ M
,
ÎÎM N
$num
ÎÎO R
,
ÎÎR S
$num
ÎÎT W
,
ÎÎW X
$num
ÎÎY ]
)
ÎÎ] ^
}
ÎÎ_ `
,
ÎÎ` a
{
ÏÏ 
$str
ÏÏ /
,
ÏÏ/ 0
CIELabFromRGB
ÏÏ< I
(
ÏÏI J
$num
ÏÏJ L
,
ÏÏL M
$num
ÏÏN R
,
ÏÏR S
$num
ÏÏT V
,
ÏÏV W
$num
ÏÏX \
)
ÏÏ\ ]
}
ÏÏ^ _
,
ÏÏ_ `
{
ĞĞ 
$str
ĞĞ 
,
ĞĞ  
CIELabFromRGB
ĞĞ< I
(
ĞĞI J
$num
ĞĞJ M
,
ĞĞM N
$num
ĞĞO R
,
ĞĞR S
$num
ĞĞT W
,
ĞĞW X
$num
ĞĞY ]
)
ĞĞ] ^
}
ĞĞ_ `
,
ĞĞ` a
{
ÑÑ 
$str
ÑÑ &
,
ÑÑ& '
CIELabFromRGB
ÑÑ< I
(
ÑÑI J
$num
ÑÑJ L
,
ÑÑL M
$num
ÑÑN Q
,
ÑÑQ R
$num
ÑÑS U
,
ÑÑU V
$num
ÑÑW [
)
ÑÑ[ \
}
ÑÑ] ^
,
ÑÑ^ _
{
ÒÒ 
$str
ÒÒ 
,
ÒÒ  
CIELabFromRGB
ÒÒ< I
(
ÒÒI J
$num
ÒÒJ L
,
ÒÒL M
$num
ÒÒN Q
,
ÒÒQ R
$num
ÒÒS V
,
ÒÒV W
$num
ÒÒX \
)
ÒÒ\ ]
}
ÒÒ^ _
,
ÒÒ_ `
{
ÓÓ 
$str
ÓÓ 
,
ÓÓ 
CIELabFromRGB
ÓÓ< I
(
ÓÓI J
$num
ÓÓJ L
,
ÓÓL M
$num
ÓÓN Q
,
ÓÓQ R
$num
ÓÓS V
,
ÓÓV W
$num
ÓÓX \
)
ÓÓ\ ]
}
ÓÓ^ _
,
ÓÓ_ `
{
ÔÔ 
$str
ÔÔ 
,
ÔÔ  
CIELabFromRGB
ÔÔ< I
(
ÔÔI J
$num
ÔÔJ L
,
ÔÔL M
$num
ÔÔN Q
,
ÔÔQ R
$num
ÔÔS V
,
ÔÔV W
$num
ÔÔX \
)
ÔÔ\ ]
}
ÔÔ^ _
,
ÔÔ_ `
{
ÕÕ 
$str
ÕÕ 
,
ÕÕ  
CIELabFromRGB
ÕÕ< I
(
ÕÕI J
$num
ÕÕJ L
,
ÕÕL M
$num
ÕÕN Q
,
ÕÕQ R
$num
ÕÕS V
,
ÕÕV W
$num
ÕÕX \
)
ÕÕ\ ]
}
ÕÕ^ _
,
ÕÕ_ `
{
ÖÖ 
$str
ÖÖ 
,
ÖÖ 
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ M
,
ÖÖM N
$num
ÖÖO R
,
ÖÖR S
$num
ÖÖT W
,
ÖÖW X
$num
ÖÖY ]
)
ÖÖ] ^
}
ÖÖ_ `
,
ÖÖ` a
{
×× 
$str
×× 
,
×× 
CIELabFromRGB
××< I
(
××I J
$num
××J L
,
××L M
$num
××N Q
,
××Q R
$num
××S V
,
××V W
$num
××X \
)
××\ ]
}
××^ _
,
××_ `
{
ØØ 
$str
ØØ 
,
ØØ 
CIELabFromRGB
ØØ< I
(
ØØI J
$num
ØØJ L
,
ØØL M
$num
ØØN Q
,
ØØQ R
$num
ØØS V
,
ØØV W
$num
ØØX \
)
ØØ\ ]
}
ØØ^ _
,
ØØ_ `
{
ÙÙ 
$str
ÙÙ 
,
ÙÙ 
CIELabFromRGB
ÙÙ< I
(
ÙÙI J
$num
ÙÙJ M
,
ÙÙM N
$num
ÙÙO S
,
ÙÙS T
$num
ÙÙU X
,
ÙÙX Y
$num
ÙÙZ ^
)
ÙÙ^ _
}
ÙÙ` a
,
ÙÙa b
{
ÚÚ 
$str
ÚÚ 
,
ÚÚ 
CIELabFromRGB
ÚÚ< I
(
ÚÚI J
$num
ÚÚJ M
,
ÚÚM N
$num
ÚÚO R
,
ÚÚR S
$num
ÚÚT V
,
ÚÚV W
$num
ÚÚX \
)
ÚÚ\ ]
}
ÚÚ^ _
,
ÚÚ_ `
{
ÛÛ 
$str
ÛÛ 
,
ÛÛ 
CIELabFromRGB
ÛÛ< I
(
ÛÛI J
$num
ÛÛJ M
,
ÛÛM N
$num
ÛÛO R
,
ÛÛR S
$num
ÛÛT W
,
ÛÛW X
$num
ÛÛY ]
)
ÛÛ] ^
}
ÛÛ_ `
,
ÛÛ` a
{
ÜÜ 
$str
ÜÜ 
,
ÜÜ 
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ L
,
ÜÜL M
$num
ÜÜN R
,
ÜÜR S
$num
ÜÜT W
,
ÜÜW X
$num
ÜÜY ]
)
ÜÜ] ^
}
ÜÜ_ `
,
ÜÜ` a
{
İİ 
$str
İİ 
,
İİ 
CIELabFromRGB
İİ< I
(
İİI J
$num
İİJ M
,
İİM N
$num
İİO R
,
İİR S
$num
İİT W
,
İİW X
$num
İİY ]
)
İİ] ^
}
İİ_ `
,
İİ` a
{
ŞŞ 
$str
ŞŞ 
,
ŞŞ 
CIELabFromRGB
ŞŞ< I
(
ŞŞI J
$num
ŞŞJ M
,
ŞŞM N
$num
ŞŞO R
,
ŞŞR S
$num
ŞŞT W
,
ŞŞW X
$num
ŞŞY ]
)
ŞŞ] ^
}
ŞŞ_ `
,
ŞŞ` a
{
ßß 
$str
ßß 
,
ßß 
CIELabFromRGB
ßß< I
(
ßßI J
$num
ßßJ M
,
ßßM N
$num
ßßO Q
,
ßßQ R
$num
ßßS V
,
ßßV W
$num
ßßX \
)
ßß\ ]
}
ßß^ _
,
ßß_ `
{
àà 
$str
àà 
,
àà 
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ M
,
ààM N
$num
ààO R
,
ààR S
$num
ààT W
,
ààW X
$num
ààY ]
)
àà] ^
}
àà_ `
,
àà` a
{
áá 
$str
áá 
,
áá 
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ M
,
ááM N
$num
ááO S
,
ááS T
$num
ááU W
,
ááW X
$num
ááY ]
)
áá] ^
}
áá_ `
,
áá` a
{
ââ 
$str
ââ 
,
ââ  
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ M
,
ââM N
$num
ââO R
,
ââR S
$num
ââT V
,
ââV W
$num
ââX \
)
ââ\ ]
}
ââ^ _
,
ââ_ `
{
ãã 
$str
ãã 
,
ãã  
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ M
,
ããM N
$num
ããO Q
,
ããQ R
$num
ããS U
,
ããU V
$num
ããW [
)
ãã[ \
}
ãã] ^
,
ãã^ _
{
ää 
$str
ää 
,
ää 
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ M
,
ääM N
$num
ääO R
,
ääR S
$num
ääT V
,
ääV W
$num
ääX \
)
ää\ ]
}
ää^ _
,
ää_ `
{
åå 
$str
åå 
,
åå 
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ M
,
ååM N
$num
ååO R
,
ååR S
$num
ååT V
,
ååV W
$num
ååX \
)
åå\ ]
}
åå^ _
,
åå_ `
{
ææ 
$str
ææ 
,
ææ 
CIELabFromRGB
ææ< I
(
ææI J
$num
ææJ M
,
ææM N
$num
ææO R
,
ææR S
$num
ææT X
,
ææX Y
$num
ææZ ^
)
ææ^ _
}
ææ` a
,
ææa b
{
çç 
$str
çç 
,
çç  
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ M
,
ççM N
$num
ççO R
,
ççR S
$num
ççT W
,
ççW X
$num
ççY ]
)
çç] ^
}
çç_ `
,
çç` a
{
èè 
$str
èè "
,
èè" #
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ M
,
èèM N
$num
èèO Q
,
èèQ R
$num
èèS V
,
èèV W
$num
èèX \
)
èè\ ]
}
èè^ _
,
èè_ `
{
éé 
$str
éé  
,
éé  !
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ M
,
ééM N
$num
ééO Q
,
ééQ R
$num
ééS V
,
ééV W
$num
ééX \
)
éé\ ]
}
éé^ _
,
éé_ `
{
êê 
$str
êê 
,
êê 
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ M
,
êêM N
$num
êêO S
,
êêS T
$num
êêU X
,
êêX Y
$num
êêZ ^
)
êê^ _
}
êê` a
,
êêa b
{
ëë 
$str
ëë 
,
ëë 
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ L
,
ëëL M
$num
ëëN Q
,
ëëQ R
$num
ëëS V
,
ëëV W
$num
ëëX \
)
ëë\ ]
}
ëë^ _
,
ëë_ `
{
ìì 
$str
ìì 
,
ìì 
CIELabFromRGB
ìì< I
(
ììI J
$num
ììJ M
,
ììM N
$num
ììO R
,
ììR S
$num
ììT W
,
ììW X
$num
ììY ]
)
ìì] ^
}
ìì_ `
,
ìì` a
{
íí 
$str
íí 
,
íí 
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ N
,
ííN O
$num
ííP S
,
ííS T
$num
ííU X
,
ííX Y
$num
ííZ ^
)
íí^ _
}
íí` a
,
íía b
{
îî 
$str
îî 
,
îî 
CIELabFromRGB
îî< I
(
îîI J
$num
îîJ N
,
îîN O
$num
îîP S
,
îîS T
$num
îîU X
,
îîX Y
$num
îîZ ^
)
îî^ _
}
îî` a
,
îîa b
{
ïï 
$str
ïï 
,
ïï 
CIELabFromRGB
ïï< I
(
ïïI J
$num
ïïJ M
,
ïïM N
$num
ïïO R
,
ïïR S
$num
ïïT W
,
ïïW X
$num
ïïY ]
)
ïï] ^
}
ïï_ `
,
ïï` a
{
ğğ 
$str
ğğ 
,
ğğ 
CIELabFromRGB
ğğ< I
(
ğğI J
$num
ğğJ M
,
ğğM N
$num
ğğO R
,
ğğR S
$num
ğğT W
,
ğğW X
$num
ğğY ]
)
ğğ] ^
}
ğğ_ `
,
ğğ` a
{
ññ 
$str
ññ 
,
ññ 
CIELabFromRGB
ññ< I
(
ññI J
$num
ññJ M
,
ññM N
$num
ññO R
,
ññR S
$num
ññT W
,
ññW X
$num
ññY ]
)
ññ] ^
}
ññ_ `
,
ññ` a
{
òò 
$str
òò $
,
òò$ %
CIELabFromRGB
òò< I
(
òòI J
$num
òòJ M
,
òòM N
$num
òòO R
,
òòR S
$num
òòT W
,
òòW X
$num
òòY ]
)
òò] ^
}
òò_ `
,
òò` a
{
óó 
$str
óó 
,
óó 
CIELabFromRGB
óó< I
(
óóI J
$num
óóJ M
,
óóM N
$num
óóO R
,
óóR S
$num
óóT W
,
óóW X
$num
óóY ]
)
óó] ^
}
óó_ `
,
óó` a
{
ôô 
$str
ôô 
,
ôô 
CIELabFromRGB
ôô< I
(
ôôI J
$num
ôôJ L
,
ôôL M
$num
ôôN Q
,
ôôQ R
$num
ôôS V
,
ôôV W
$num
ôôX \
)
ôô\ ]
}
ôô^ _
,
ôô_ `
{
õõ 
$str
õõ 
,
õõ  
CIELabFromRGB
õõ< I
(
õõI J
$num
õõJ M
,
õõM N
$num
õõO Q
,
õõQ R
$num
õõS V
,
õõV W
$num
õõX \
)
õõ\ ]
}
õõ^ _
,
õõ_ `
{
öö 
$str
öö 
,
öö 
CIELabFromRGB
öö< I
(
ööI J
$num
ööJ M
,
ööM N
$num
ööO R
,
ööR S
$num
ööT W
,
ööW X
$num
ööY ]
)
öö] ^
}
öö_ `
,
öö` a
{
÷÷ 
$str
÷÷ 
,
÷÷ 
CIELabFromRGB
÷÷< I
(
÷÷I J
$num
÷÷J M
,
÷÷M N
$num
÷÷O R
,
÷÷R S
$num
÷÷T W
,
÷÷W X
$num
÷÷Y ]
)
÷÷] ^
}
÷÷_ `
,
÷÷` a
{
øø 
$str
øø 
,
øø 
CIELabFromRGB
øø< I
(
øøI J
$num
øøJ M
,
øøM N
$num
øøO R
,
øøR S
$num
øøT W
,
øøW X
$num
øøY ]
)
øø] ^
}
øø_ `
,
øø` a
{
ùù 
$str
ùù 
,
ùù 
CIELabFromRGB
ùù< I
(
ùùI J
$num
ùùJ L
,
ùùL M
$num
ùùN Q
,
ùùQ R
$num
ùùS U
,
ùùU V
$num
ùùW [
)
ùù[ \
}
ùù] ^
,
ùù^ _
{
úú 
$str
úú 
,
úú 
CIELabFromRGB
úú< I
(
úúI J
$num
úúJ M
,
úúM N
$num
úúO R
,
úúR S
$num
úúT W
,
úúW X
$num
úúY ]
)
úú] ^
}
úú_ `
,
úú` a
{
ûû 
$str
ûû 
,
ûû 
CIELabFromRGB
ûû< I
(
ûûI J
$num
ûûJ M
,
ûûM N
$num
ûûO R
,
ûûR S
$num
ûûT W
,
ûûW X
$num
ûûY ]
)
ûû] ^
}
ûû_ `
,
ûû` a
{
üü 
$str
üü 
,
üü 
CIELabFromRGB
üü< I
(
üüI J
$num
üüJ M
,
üüM N
$num
üüO Q
,
üüQ R
$num
üüS W
,
üüW X
$num
üüY ]
)
üü] ^
}
üü_ `
,
üü` a
{
ıı 
$str
ıı 
,
ıı 
CIELabFromRGB
ıı< I
(
ııI J
$num
ııJ L
,
ııL M
$num
ııN Q
,
ııQ R
$num
ııS V
,
ııV W
$num
ııX \
)
ıı\ ]
}
ıı^ _
,
ıı_ `
{
şş 
$str
şş 
,
şş 
CIELabFromRGB
şş< I
(
şşI J
$num
şşJ M
,
şşM N
$num
şşO Q
,
şşQ R
$num
şşS V
,
şşV W
$num
şşX \
)
şş\ ]
}
şş^ _
,
şş_ `
{
ÿÿ 
$str
ÿÿ (
,
ÿÿ( )
CIELabFromRGB
ÿÿ< I
(
ÿÿI J
$num
ÿÿJ L
,
ÿÿL M
$num
ÿÿN Q
,
ÿÿQ R
$num
ÿÿS V
,
ÿÿV W
$num
ÿÿX \
)
ÿÿ\ ]
}
ÿÿ^ _
,
ÿÿ_ `
{
€€ 
$str
€€ 0
,
€€0 1
CIELabFromRGB
€€< I
(
€€I J
$num
€€J N
,
€€N O
$num
€€P S
,
€€S T
$num
€€U W
,
€€W X
$num
€€Y ]
)
€€] ^
}
€€_ `
,
€€` a
{
 
$str
 2
,
2 3
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O Q
,
Q R
$num
S U
,
U V
$num
W [
)
[ \
}
] ^
,
^ _
{
‚‚ 
$str
‚‚ 9
,
‚‚9 :
CIELabFromRGB
‚‚< I
(
‚‚I J
$num
‚‚J M
,
‚‚M N
$num
‚‚O R
,
‚‚R S
$num
‚‚T W
,
‚‚W X
$num
‚‚Y ]
)
‚‚] ^
}
‚‚_ `
,
‚‚` a
{
ƒƒ 
$str
ƒƒ 
,
ƒƒ 
CIELabFromRGB
ƒƒ< I
(
ƒƒI J
$num
ƒƒJ M
,
ƒƒM N
$num
ƒƒO R
,
ƒƒR S
$num
ƒƒT W
,
ƒƒW X
$num
ƒƒY ]
)
ƒƒ] ^
}
ƒƒ_ `
,
ƒƒ` a
{
„„ 
$str
„„ 
,
„„ 
CIELabFromRGB
„„< I
(
„„I J
$num
„„J M
,
„„M N
$num
„„O R
,
„„R S
$num
„„T W
,
„„W X
$num
„„Y ]
)
„„] ^
}
„„_ `
,
„„` a
{
…… 
$str
…… 
,
…… 
CIELabFromRGB
……< I
(
……I J
$num
……J M
,
……M N
$num
……O R
,
……R S
$num
……T W
,
……W X
$num
……Y ]
)
……] ^
}
……_ `
,
……` a
{
†† 
$str
†† 
,
†† 
CIELabFromRGB
††< I
(
††I J
$num
††J L
,
††L M
$num
††N Q
,
††Q R
$num
††S U
,
††U V
$num
††W [
)
††[ \
}
††] ^
,
††^ _
{
‡‡ 
$str
‡‡  
,
‡‡  !
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J M
,
‡‡M N
$num
‡‡O S
,
‡‡S T
$num
‡‡U Y
,
‡‡Y Z
$num
‡‡[ _
)
‡‡_ `
}
‡‡a b
,
‡‡b c
{
ˆˆ 
$str
ˆˆ 
,
ˆˆ 
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ N
,
ˆˆN O
$num
ˆˆP T
,
ˆˆT U
$num
ˆˆV Y
,
ˆˆY Z
$num
ˆˆ[ _
)
ˆˆ_ `
}
ˆˆa b
,
ˆˆb c
{
‰‰ 
$str
‰‰ 
,
‰‰ 
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J L
,
‰‰L M
$num
‰‰N Q
,
‰‰Q R
$num
‰‰S V
,
‰‰V W
$num
‰‰X \
)
‰‰\ ]
}
‰‰^ _
,
‰‰_ `
{
ŠŠ 
$str
ŠŠ  
,
ŠŠ  !
CIELabFromRGB
ŠŠ< I
(
ŠŠI J
$num
ŠŠJ M
,
ŠŠM N
$num
ŠŠO R
,
ŠŠR S
$num
ŠŠT W
,
ŠŠW X
$num
ŠŠY ]
)
ŠŠ] ^
}
ŠŠ_ `
,
ŠŠ` a
{
‹‹ 
$str
‹‹ 
,
‹‹  
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J M
,
‹‹M N
$num
‹‹O R
,
‹‹R S
$num
‹‹T W
,
‹‹W X
$num
‹‹Y ]
)
‹‹] ^
}
‹‹_ `
,
‹‹` a
{
ŒŒ 
$str
ŒŒ 
,
ŒŒ  
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ M
,
ŒŒM N
$num
ŒŒO R
,
ŒŒR S
$num
ŒŒT W
,
ŒŒW X
$num
ŒŒY ]
)
ŒŒ] ^
}
ŒŒ_ `
,
ŒŒ` a
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O Q
,
Q R
$num
S V
,
V W
$num
X \
)
\ ]
}
^ _
,
_ `
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
‘‘ 
$str
‘‘ 
,
‘‘ 
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J M
,
‘‘M N
$num
‘‘O R
,
‘‘R S
$num
‘‘T W
,
‘‘W X
$num
‘‘Y ]
)
‘‘] ^
}
‘‘_ `
,
‘‘` a
{
’’ 
$str
’’ 
,
’’ 
CIELabFromRGB
’’< I
(
’’I J
$num
’’J M
,
’’M N
$num
’’O R
,
’’R S
$num
’’T V
,
’’V W
$num
’’X \
)
’’\ ]
}
’’^ _
,
’’_ `
{
““ 
$str
““ 
,
““ 
CIELabFromRGB
““< I
(
““I J
$num
““J M
,
““M N
$num
““O R
,
““R S
$num
““T W
,
““W X
$num
““Y ]
)
““] ^
}
““_ `
,
““` a
{
”” 
$str
”” 
,
”” 
CIELabFromRGB
””< I
(
””I J
$num
””J M
,
””M N
$num
””O R
,
””R S
$num
””T W
,
””W X
$num
””Y ]
)
””] ^
}
””_ `
,
””` a
{
•• 
$str
•• 
,
•• 
CIELabFromRGB
••< I
(
••I J
$num
••J M
,
••M N
$num
••O R
,
••R S
$num
••T W
,
••W X
$num
••Y ]
)
••] ^
}
••_ `
,
••` a
{
–– 
$str
–– 
,
–– 
CIELabFromRGB
––< I
(
––I J
$num
––J M
,
––M N
$num
––O R
,
––R S
$num
––T V
,
––V W
$num
––X \
)
––\ ]
}
––^ _
,
––_ `
{
—— 
$str
—— 
,
—— 
CIELabFromRGB
——< I
(
——I J
$num
——J M
,
——M N
$num
——O R
,
——R S
$num
——T V
,
——V W
$num
——X \
)
——\ ]
}
——^ _
,
——_ `
{
˜˜ 
$str
˜˜ 
,
˜˜ 
CIELabFromRGB
˜˜< I
(
˜˜I J
$num
˜˜J M
,
˜˜M N
$num
˜˜O R
,
˜˜R S
$num
˜˜T W
,
˜˜W X
$num
˜˜Y ]
)
˜˜] ^
}
˜˜_ `
,
˜˜` a
{
™™ 
$str
™™ 6
,
™™6 7
CIELabFromRGB
™™< I
(
™™I J
$num
™™J M
,
™™M N
$num
™™O R
,
™™R S
$num
™™T W
,
™™W X
$num
™™Y ]
)
™™] ^
}
™™_ `
,
™™` a
{
šš 
$str
šš )
,
šš) *
CIELabFromRGB
šš< I
(
ššI J
$num
ššJ M
,
ššM N
$num
ššO R
,
ššR S
$num
ššT W
,
ššW X
$num
ššY ]
)
šš] ^
}
šš_ `
,
šš` a
{
›› 
$str
›› 
,
›› 
CIELabFromRGB
››< I
(
››I J
$num
››J M
,
››M N
$num
››O R
,
››R S
$num
››T V
,
››V W
$num
››X \
)
››\ ]
}
››^ _
,
››_ `
{
œœ 
$str
œœ 
,
œœ 
CIELabFromRGB
œœ< I
(
œœI J
$num
œœJ M
,
œœM N
$num
œœO R
,
œœR S
$num
œœT W
,
œœW X
$num
œœY ]
)
œœ] ^
}
œœ_ `
,
œœ` a
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O Q
,
Q R
$num
S U
,
U V
$num
W [
)
[ \
}
] ^
,
^ _
{
ŸŸ 
$str
ŸŸ 
,
ŸŸ 
CIELabFromRGB
ŸŸ< I
(
ŸŸI J
$num
ŸŸJ L
,
ŸŸL M
$num
ŸŸN Q
,
ŸŸQ R
$num
ŸŸS V
,
ŸŸV W
$num
ŸŸX \
)
ŸŸ\ ]
}
ŸŸ^ _
,
ŸŸ_ `
{
   
$str
    
,
    !
CIELabFromRGB
  < I
(
  I J
$num
  J M
,
  M N
$num
  O R
,
  R S
$num
  T W
,
  W X
$num
  Y ]
)
  ] ^
}
  _ `
,
  ` a
{
¡¡ 
$str
¡¡ 
,
¡¡ 
CIELabFromRGB
¡¡< I
(
¡¡I J
$num
¡¡J M
,
¡¡M N
$num
¡¡O R
,
¡¡R S
$num
¡¡T W
,
¡¡W X
$num
¡¡Y ]
)
¡¡] ^
}
¡¡_ `
,
¡¡` a
{
¢¢ 
$str
¢¢ 
,
¢¢ 
CIELabFromRGB
¢¢< I
(
¢¢I J
$num
¢¢J N
,
¢¢N O
$num
¢¢P T
,
¢¢T U
$num
¢¢V Y
,
¢¢Y Z
$num
¢¢[ _
)
¢¢_ `
}
¢¢a b
,
¢¢b c
{
££ 
$str
££ 
,
££ 
CIELabFromRGB
££< I
(
££I J
$num
££J M
,
££M N
$num
££O R
,
££R S
$num
££T W
,
££W X
$num
££Y ]
)
££] ^
}
££_ `
,
££` a
{
¤¤ 
$str
¤¤ 
,
¤¤ 
CIELabFromRGB
¤¤< I
(
¤¤I J
$num
¤¤J M
,
¤¤M N
$num
¤¤O Q
,
¤¤Q R
$num
¤¤S V
,
¤¤V W
$num
¤¤X \
)
¤¤\ ]
}
¤¤^ _
,
¤¤_ `
{
¥¥ 
$str
¥¥ !
,
¥¥! "
CIELabFromRGB
¥¥< I
(
¥¥I J
$num
¥¥J M
,
¥¥M N
$num
¥¥O R
,
¥¥R S
$num
¥¥T W
,
¥¥W X
$num
¥¥Y ]
)
¥¥] ^
}
¥¥_ `
,
¥¥` a
{
¦¦ 
$str
¦¦ 
,
¦¦ 
CIELabFromRGB
¦¦< I
(
¦¦I J
$num
¦¦J M
,
¦¦M N
$num
¦¦O R
,
¦¦R S
$num
¦¦T W
,
¦¦W X
$num
¦¦Y ]
)
¦¦] ^
}
¦¦_ `
,
¦¦` a
{
§§ 
$str
§§ 
,
§§ 
CIELabFromRGB
§§< I
(
§§I J
$num
§§J M
,
§§M N
$num
§§O R
,
§§R S
$num
§§T X
,
§§X Y
$num
§§Z ^
)
§§^ _
}
§§` a
,
§§a b
{
¨¨ 
$str
¨¨ 
,
¨¨ 
CIELabFromRGB
¨¨< I
(
¨¨I J
$num
¨¨J N
,
¨¨N O
$num
¨¨P S
,
¨¨S T
$num
¨¨U X
,
¨¨X Y
$num
¨¨Z ^
)
¨¨^ _
}
¨¨` a
,
¨¨a b
{
©© 
$str
©© 
,
©© 
CIELabFromRGB
©©< I
(
©©I J
$num
©©J M
,
©©M N
$num
©©O R
,
©©R S
$num
©©T W
,
©©W X
$num
©©Y ]
)
©©] ^
}
©©_ `
,
©©` a
{
ªª 
$str
ªª 
,
ªª  
CIELabFromRGB
ªª< I
(
ªªI J
$num
ªªJ M
,
ªªM N
$num
ªªO R
,
ªªR S
$num
ªªT W
,
ªªW X
$num
ªªY ]
)
ªª] ^
}
ªª_ `
,
ªª` a
{
«« 
$str
««  
,
««  !
CIELabFromRGB
««< I
(
««I J
$num
««J M
,
««M N
$num
««O R
,
««R S
$num
««T W
,
««W X
$num
««Y ]
)
««] ^
}
««_ `
,
««` a
{
¬¬ 
$str
¬¬ 
,
¬¬ 
CIELabFromRGB
¬¬< I
(
¬¬I J
$num
¬¬J M
,
¬¬M N
$num
¬¬O R
,
¬¬R S
$num
¬¬T W
,
¬¬W X
$num
¬¬Y ]
)
¬¬] ^
}
¬¬_ `
,
¬¬` a
{
­­ 
$str
­­ 
,
­­ 
CIELabFromRGB
­­< I
(
­­I J
$num
­­J M
,
­­M N
$num
­­O R
,
­­R S
$num
­­T W
,
­­W X
$num
­­Y ]
)
­­] ^
}
­­_ `
,
­­` a
{
®® 
$str
®® 
,
®®  
CIELabFromRGB
®®< I
(
®®I J
$num
®®J M
,
®®M N
$num
®®O R
,
®®R S
$num
®®T W
,
®®W X
$num
®®Y ]
)
®®] ^
}
®®_ `
,
®®` a
{
¯¯ 
$str
¯¯ 
,
¯¯ 
CIELabFromRGB
¯¯< I
(
¯¯I J
$num
¯¯J M
,
¯¯M N
$num
¯¯O R
,
¯¯R S
$num
¯¯T W
,
¯¯W X
$num
¯¯Y ]
)
¯¯] ^
}
¯¯_ `
,
¯¯` a
{
°° 
$str
°° 
,
°° 
CIELabFromRGB
°°< I
(
°°I J
$num
°°J M
,
°°M N
$num
°°O R
,
°°R S
$num
°°T V
,
°°V W
$num
°°X \
)
°°\ ]
}
°°^ _
,
°°_ `
{
±± 
$str
±± 
,
±± 
CIELabFromRGB
±±< I
(
±±I J
$num
±±J N
,
±±N O
$num
±±P S
,
±±S T
$num
±±U W
,
±±W X
$num
±±Y ]
)
±±] ^
}
±±_ `
,
±±` a
{
²² 
$str
²² 
,
²² 
CIELabFromRGB
²²< I
(
²²I J
$num
²²J N
,
²²N O
$num
²²P S
,
²²S T
$num
²²U X
,
²²X Y
$num
²²Z ^
)
²²^ _
}
²²` a
,
²²a b
{
³³ 
$str
³³ 
,
³³ 
CIELabFromRGB
³³< I
(
³³I J
$num
³³J M
,
³³M N
$num
³³O R
,
³³R S
$num
³³T W
,
³³W X
$num
³³Y ]
)
³³] ^
}
³³_ `
,
³³` a
{
´´ 
$str
´´ 
,
´´ 
CIELabFromRGB
´´< I
(
´´I J
$num
´´J M
,
´´M N
$num
´´O S
,
´´S T
$num
´´U W
,
´´W X
$num
´´Y ]
)
´´] ^
}
´´_ `
,
´´` a
{
µµ 
$str
µµ 
,
µµ 
CIELabFromRGB
µµ< I
(
µµI J
$num
µµJ M
,
µµM N
$num
µµO S
,
µµS T
$num
µµU W
,
µµW X
$num
µµY ]
)
µµ] ^
}
µµ_ `
,
µµ` a
{
¶¶ 
$str
¶¶ 
,
¶¶ 
CIELabFromRGB
¶¶< I
(
¶¶I J
$num
¶¶J M
,
¶¶M N
$num
¶¶O R
,
¶¶R S
$num
¶¶T W
,
¶¶W X
$num
¶¶Y ]
)
¶¶] ^
}
¶¶_ `
,
¶¶` a
{
·· 
$str
·· 
,
·· 
CIELabFromRGB
··< I
(
··I J
$num
··J N
,
··N O
$num
··P S
,
··S T
$num
··U X
,
··X Y
$num
··Z ^
)
··^ _
}
··` a
,
··a b
{
¸¸ 
$str
¸¸ 
,
¸¸ 
CIELabFromRGB
¸¸< I
(
¸¸I J
$num
¸¸J M
,
¸¸M N
$num
¸¸O R
,
¸¸R S
$num
¸¸T W
,
¸¸W X
$num
¸¸Y ]
)
¸¸] ^
}
¸¸_ `
,
¸¸` a
{
¹¹ 
$str
¹¹ 
,
¹¹ 
CIELabFromRGB
¹¹< I
(
¹¹I J
$num
¹¹J M
,
¹¹M N
$num
¹¹O Q
,
¹¹Q R
$num
¹¹S U
,
¹¹U V
$num
¹¹W [
)
¹¹[ \
}
¹¹] ^
,
¹¹^ _
{
ºº 
$str
ºº 
,
ºº 
CIELabFromRGB
ºº< I
(
ººI J
$num
ººJ M
,
ººM N
$num
ººO R
,
ººR S
$num
ººT W
,
ººW X
$num
ººY ]
)
ºº] ^
}
ºº_ `
,
ºº` a
{
»» 
$str
»» 
,
»» 
CIELabFromRGB
»»< I
(
»»I J
$num
»»J M
,
»»M N
$num
»»O R
,
»»R S
$num
»»T W
,
»»W X
$num
»»Y ]
)
»»] ^
}
»»_ `
,
»»` a
{
¼¼ 
$str
¼¼ 
,
¼¼ 
CIELabFromRGB
¼¼< I
(
¼¼I J
$num
¼¼J M
,
¼¼M N
$num
¼¼O R
,
¼¼R S
$num
¼¼T W
,
¼¼W X
$num
¼¼Y ]
)
¼¼] ^
}
¼¼_ `
,
¼¼` a
{
½½ 
$str
½½ #
,
½½# $
CIELabFromRGB
½½< I
(
½½I J
$num
½½J N
,
½½N O
$num
½½P S
,
½½S T
$num
½½U X
,
½½X Y
$num
½½Z ^
)
½½^ _
}
½½` a
,
½½a b
{
¾¾ 
$str
¾¾ 
,
¾¾ 
CIELabFromRGB
¾¾< I
(
¾¾I J
$num
¾¾J M
,
¾¾M N
$num
¾¾O R
,
¾¾R S
$num
¾¾T W
,
¾¾W X
$num
¾¾Y ]
)
¾¾] ^
}
¾¾_ `
,
¾¾` a
{
¿¿ 
$str
¿¿ "
,
¿¿" #
CIELabFromRGB
¿¿< I
(
¿¿I J
$num
¿¿J M
,
¿¿M N
$num
¿¿O R
,
¿¿R S
$num
¿¿T W
,
¿¿W X
$num
¿¿Y ]
)
¿¿] ^
}
¿¿_ `
,
¿¿` a
{
ÀÀ 
$str
ÀÀ !
,
ÀÀ! "
CIELabFromRGB
ÀÀ< I
(
ÀÀI J
$num
ÀÀJ M
,
ÀÀM N
$num
ÀÀO R
,
ÀÀR S
$num
ÀÀT W
,
ÀÀW X
$num
ÀÀY ]
)
ÀÀ] ^
}
ÀÀ_ `
,
ÀÀ` a
{
ÁÁ 
$str
ÁÁ 
,
ÁÁ 
CIELabFromRGB
ÁÁ< I
(
ÁÁI J
$num
ÁÁJ M
,
ÁÁM N
$num
ÁÁO R
,
ÁÁR S
$num
ÁÁT W
,
ÁÁW X
$num
ÁÁY ]
)
ÁÁ] ^
}
ÁÁ_ `
,
ÁÁ` a
{
ÂÂ 
$str
ÂÂ %
,
ÂÂ% &
CIELabFromRGB
ÂÂ< I
(
ÂÂI J
$num
ÂÂJ M
,
ÂÂM N
$num
ÂÂO R
,
ÂÂR S
$num
ÂÂT W
,
ÂÂW X
$num
ÂÂY ]
)
ÂÂ] ^
}
ÂÂ_ `
,
ÂÂ` a
{
ÃÃ 
$str
ÃÃ 
,
ÃÃ 
CIELabFromRGB
ÃÃ< I
(
ÃÃI J
$num
ÃÃJ M
,
ÃÃM N
$num
ÃÃO R
,
ÃÃR S
$num
ÃÃT W
,
ÃÃW X
$num
ÃÃY ]
)
ÃÃ] ^
}
ÃÃ_ `
,
ÃÃ` a
{
ÄÄ 
$str
ÄÄ 
,
ÄÄ 
CIELabFromRGB
ÄÄ< I
(
ÄÄI J
$num
ÄÄJ M
,
ÄÄM N
$num
ÄÄO S
,
ÄÄS T
$num
ÄÄU Y
,
ÄÄY Z
$num
ÄÄ[ _
)
ÄÄ_ `
}
ÄÄa b
,
ÄÄb c
{
ÅÅ 
$str
ÅÅ 
,
ÅÅ  
CIELabFromRGB
ÅÅ< I
(
ÅÅI J
$num
ÅÅJ N
,
ÅÅN O
$num
ÅÅP S
,
ÅÅS T
$num
ÅÅU X
,
ÅÅX Y
$num
ÅÅZ ^
)
ÅÅ^ _
}
ÅÅ` a
,
ÅÅa b
{
ÆÆ 
$str
ÆÆ "
,
ÆÆ" #
CIELabFromRGB
ÆÆ< I
(
ÆÆI J
$num
ÆÆJ M
,
ÆÆM N
$num
ÆÆO R
,
ÆÆR S
$num
ÆÆT W
,
ÆÆW X
$num
ÆÆY ]
)
ÆÆ] ^
}
ÆÆ_ `
,
ÆÆ` a
{
ÇÇ 
$str
ÇÇ "
,
ÇÇ" #
CIELabFromRGB
ÇÇ< I
(
ÇÇI J
$num
ÇÇJ M
,
ÇÇM N
$num
ÇÇO R
,
ÇÇR S
$num
ÇÇT W
,
ÇÇW X
$num
ÇÇY ]
)
ÇÇ] ^
}
ÇÇ_ `
,
ÇÇ` a
{
ÈÈ 
$str
ÈÈ &
,
ÈÈ& '
CIELabFromRGB
ÈÈ< I
(
ÈÈI J
$num
ÈÈJ M
,
ÈÈM N
$num
ÈÈO R
,
ÈÈR S
$num
ÈÈT W
,
ÈÈW X
$num
ÈÈY ]
)
ÈÈ] ^
}
ÈÈ_ `
,
ÈÈ` a
{
ÉÉ 
$str
ÉÉ 
,
ÉÉ 
CIELabFromRGB
ÉÉ< I
(
ÉÉI J
$num
ÉÉJ M
,
ÉÉM N
$num
ÉÉO R
,
ÉÉR S
$num
ÉÉT W
,
ÉÉW X
$num
ÉÉY ]
)
ÉÉ] ^
}
ÉÉ_ `
,
ÉÉ` a
{
ÊÊ 
$str
ÊÊ %
,
ÊÊ% &
CIELabFromRGB
ÊÊ< I
(
ÊÊI J
$num
ÊÊJ M
,
ÊÊM N
$num
ÊÊO R
,
ÊÊR S
$num
ÊÊT W
,
ÊÊW X
$num
ÊÊY ]
)
ÊÊ] ^
}
ÊÊ_ `
,
ÊÊ` a
{
ËË 
$str
ËË 
,
ËË 
CIELabFromRGB
ËË< I
(
ËËI J
$num
ËËJ M
,
ËËM N
$num
ËËO R
,
ËËR S
$num
ËËT W
,
ËËW X
$num
ËËY ]
)
ËË] ^
}
ËË_ `
,
ËË` a
{
ÌÌ 
$str
ÌÌ 
,
ÌÌ 
CIELabFromRGB
ÌÌ< I
(
ÌÌI J
$num
ÌÌJ N
,
ÌÌN O
$num
ÌÌP S
,
ÌÌS T
$num
ÌÌU X
,
ÌÌX Y
$num
ÌÌZ ^
)
ÌÌ^ _
}
ÌÌ` a
,
ÌÌa b
{
ÍÍ 
$str
ÍÍ 
,
ÍÍ 
CIELabFromRGB
ÍÍ< I
(
ÍÍI J
$num
ÍÍJ M
,
ÍÍM N
$num
ÍÍO R
,
ÍÍR S
$num
ÍÍT W
,
ÍÍW X
$num
ÍÍY ]
)
ÍÍ] ^
}
ÍÍ_ `
,
ÍÍ` a
{
ÎÎ 
$str
ÎÎ #
,
ÎÎ# $
CIELabFromRGB
ÎÎ< I
(
ÎÎI J
$num
ÎÎJ M
,
ÎÎM N
$num
ÎÎO R
,
ÎÎR S
$num
ÎÎT W
,
ÎÎW X
$num
ÎÎY ]
)
ÎÎ] ^
}
ÎÎ_ `
,
ÎÎ` a
{
ÏÏ 
$str
ÏÏ  
,
ÏÏ  !
CIELabFromRGB
ÏÏ< I
(
ÏÏI J
$num
ÏÏJ M
,
ÏÏM N
$num
ÏÏO R
,
ÏÏR S
$num
ÏÏT W
,
ÏÏW X
$num
ÏÏY ]
)
ÏÏ] ^
}
ÏÏ_ `
,
ÏÏ` a
{
ĞĞ 
$str
ĞĞ 
,
ĞĞ 
CIELabFromRGB
ĞĞ< I
(
ĞĞI J
$num
ĞĞJ M
,
ĞĞM N
$num
ĞĞO R
,
ĞĞR S
$num
ĞĞT W
,
ĞĞW X
$num
ĞĞY ]
)
ĞĞ] ^
}
ĞĞ_ `
,
ĞĞ` a
{
ÑÑ 
$str
ÑÑ #
,
ÑÑ# $
CIELabFromRGB
ÑÑ< I
(
ÑÑI J
$num
ÑÑJ M
,
ÑÑM N
$num
ÑÑO R
,
ÑÑR S
$num
ÑÑT W
,
ÑÑW X
$num
ÑÑY ]
)
ÑÑ] ^
}
ÑÑ_ `
,
ÑÑ` a
{
ÒÒ 
$str
ÒÒ 
,
ÒÒ 
CIELabFromRGB
ÒÒ< I
(
ÒÒI J
$num
ÒÒJ N
,
ÒÒN O
$num
ÒÒP S
,
ÒÒS T
$num
ÒÒU X
,
ÒÒX Y
$num
ÒÒZ ^
)
ÒÒ^ _
}
ÒÒ` a
,
ÒÒa b
{
ÓÓ 
$str
ÓÓ 
,
ÓÓ  
CIELabFromRGB
ÓÓ< I
(
ÓÓI J
$num
ÓÓJ M
,
ÓÓM N
$num
ÓÓO R
,
ÓÓR S
$num
ÓÓT W
,
ÓÓW X
$num
ÓÓY ]
)
ÓÓ] ^
}
ÓÓ_ `
,
ÓÓ` a
{
ÔÔ 
$str
ÔÔ 
,
ÔÔ 
CIELabFromRGB
ÔÔ< I
(
ÔÔI J
$num
ÔÔJ N
,
ÔÔN O
$num
ÔÔP S
,
ÔÔS T
$num
ÔÔU X
,
ÔÔX Y
$num
ÔÔZ ^
)
ÔÔ^ _
}
ÔÔ` a
,
ÔÔa b
{
ÕÕ 
$str
ÕÕ !
,
ÕÕ! "
CIELabFromRGB
ÕÕ< I
(
ÕÕI J
$num
ÕÕJ N
,
ÕÕN O
$num
ÕÕP S
,
ÕÕS T
$num
ÕÕU X
,
ÕÕX Y
$num
ÕÕZ ^
)
ÕÕ^ _
}
ÕÕ` a
,
ÕÕa b
{
ÖÖ 
$str
ÖÖ 
,
ÖÖ  
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ M
,
ÖÖM N
$num
ÖÖO R
,
ÖÖR S
$num
ÖÖT W
,
ÖÖW X
$num
ÖÖY ]
)
ÖÖ] ^
}
ÖÖ_ `
,
ÖÖ` a
{
×× 
$str
×× 
,
×× 
CIELabFromRGB
××< I
(
××I J
$num
××J M
,
××M N
$num
××O R
,
××R S
$num
××T W
,
××W X
$num
××Y ]
)
××] ^
}
××_ `
,
××` a
{
ØØ 
$str
ØØ  
,
ØØ  !
CIELabFromRGB
ØØ< I
(
ØØI J
$num
ØØJ M
,
ØØM N
$num
ØØO R
,
ØØR S
$num
ØØT W
,
ØØW X
$num
ØØY ]
)
ØØ] ^
}
ØØ_ `
,
ØØ` a
{
ÙÙ 
$str
ÙÙ  
,
ÙÙ  !
CIELabFromRGB
ÙÙ< I
(
ÙÙI J
$num
ÙÙJ M
,
ÙÙM N
$num
ÙÙO R
,
ÙÙR S
$num
ÙÙT W
,
ÙÙW X
$num
ÙÙY ]
)
ÙÙ] ^
}
ÙÙ_ `
,
ÙÙ` a
{
ÚÚ 
$str
ÚÚ 
,
ÚÚ 
CIELabFromRGB
ÚÚ< I
(
ÚÚI J
$num
ÚÚJ M
,
ÚÚM N
$num
ÚÚO R
,
ÚÚR S
$num
ÚÚT W
,
ÚÚW X
$num
ÚÚY ]
)
ÚÚ] ^
}
ÚÚ_ `
,
ÚÚ` a
{
ÛÛ 
$str
ÛÛ "
,
ÛÛ" #
CIELabFromRGB
ÛÛ< I
(
ÛÛI J
$num
ÛÛJ M
,
ÛÛM N
$num
ÛÛO R
,
ÛÛR S
$num
ÛÛT W
,
ÛÛW X
$num
ÛÛY ]
)
ÛÛ] ^
}
ÛÛ_ `
,
ÛÛ` a
{
ÜÜ 
$str
ÜÜ 
,
ÜÜ 
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ N
,
ÜÜN O
$num
ÜÜP T
,
ÜÜT U
$num
ÜÜV Y
,
ÜÜY Z
$num
ÜÜ[ _
)
ÜÜ_ `
}
ÜÜa b
,
ÜÜb c
{
İİ 
$str
İİ 
,
İİ 
CIELabFromRGB
İİ< I
(
İİI J
$num
İİJ M
,
İİM N
$num
İİO R
,
İİR S
$num
İİT W
,
İİW X
$num
İİY ]
)
İİ] ^
}
İİ_ `
,
İİ` a
{
ŞŞ 
$str
ŞŞ "
,
ŞŞ" #
CIELabFromRGB
ŞŞ< I
(
ŞŞI J
$num
ŞŞJ M
,
ŞŞM N
$num
ŞŞO S
,
ŞŞS T
$num
ŞŞU W
,
ŞŞW X
$num
ŞŞY ]
)
ŞŞ] ^
}
ŞŞ_ `
,
ŞŞ` a
{
ßß 
$str
ßß &
,
ßß& '
CIELabFromRGB
ßß< I
(
ßßI J
$num
ßßJ L
,
ßßL M
$num
ßßN R
,
ßßR S
$num
ßßT V
,
ßßV W
$num
ßßX \
)
ßß\ ]
}
ßß^ _
,
ßß_ `
{
àà 
$str
àà 
,
àà 
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ M
,
ààM N
$num
ààO R
,
ààR S
$num
ààT W
,
ààW X
$num
ààY ]
)
àà] ^
}
àà_ `
,
àà` a
{
áá 
$str
áá 
,
áá 
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ M
,
ááM N
$num
ááO R
,
ááR S
$num
ááT V
,
ááV W
$num
ááX \
)
áá\ ]
}
áá^ _
,
áá_ `
{
ââ 
$str
ââ 
,
ââ 
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ M
,
ââM N
$num
ââO R
,
ââR S
$num
ââT V
,
ââV W
$num
ââX \
)
ââ\ ]
}
ââ^ _
,
ââ_ `
{
ãã 
$str
ãã 
,
ãã 
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ M
,
ããM N
$num
ããO R
,
ããR S
$num
ããT W
,
ããW X
$num
ããY ]
)
ãã] ^
}
ãã_ `
,
ãã` a
{
ää 
$str
ää 
,
ää 
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ M
,
ääM N
$num
ääO R
,
ääR S
$num
ääT W
,
ääW X
$num
ääY ]
)
ää] ^
}
ää_ `
,
ää` a
{
åå 
$str
åå 
,
åå 
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ M
,
ååM N
$num
ååO R
,
ååR S
$num
ååT W
,
ååW X
$num
ååY ]
)
åå] ^
}
åå_ `
,
åå` a
{
ææ 
$str
ææ 
,
ææ  
CIELabFromRGB
ææ< I
(
ææI J
$num
ææJ M
,
ææM N
$num
ææO R
,
ææR S
$num
ææT W
,
ææW X
$num
ææY ]
)
ææ] ^
}
ææ_ `
,
ææ` a
{
çç 
$str
çç 
,
çç 
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ M
,
ççM N
$num
ççO R
,
ççR S
$num
ççT W
,
ççW X
$num
ççY ]
)
çç] ^
}
çç_ `
,
çç` a
{
èè 
$str
èè 
,
èè 
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ M
,
èèM N
$num
èèO R
,
èèR S
$num
èèT W
,
èèW X
$num
èèY ]
)
èè] ^
}
èè_ `
,
èè` a
{
éé 
$str
éé 
,
éé 
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ M
,
ééM N
$num
ééO R
,
ééR S
$num
ééT W
,
ééW X
$num
ééY ]
)
éé] ^
}
éé_ `
,
éé` a
{
êê 
$str
êê 
,
êê 
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ M
,
êêM N
$num
êêO R
,
êêR S
$num
êêT W
,
êêW X
$num
êêY ]
)
êê] ^
}
êê_ `
,
êê` a
{
ëë 
$str
ëë 
,
ëë 
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ M
,
ëëM N
$num
ëëO R
,
ëëR S
$num
ëëT W
,
ëëW X
$num
ëëY ]
)
ëë] ^
}
ëë_ `
,
ëë` a
{
ìì 
$str
ìì 
,
ìì 
CIELabFromRGB
ìì< I
(
ììI J
$num
ììJ N
,
ììN O
$num
ììP S
,
ììS T
$num
ììU X
,
ììX Y
$num
ììZ ^
)
ìì^ _
}
ìì` a
,
ììa b
{
íí 
$str
íí 
,
íí 
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ M
,
ííM N
$num
ííO R
,
ííR S
$num
ííT W
,
ííW X
$num
ííY ]
)
íí] ^
}
íí_ `
,
íí` a
{
îî 
$str
îî 
,
îî 
CIELabFromRGB
îî< I
(
îîI J
$num
îîJ N
,
îîN O
$num
îîP R
,
îîR S
$num
îîT X
,
îîX Y
$num
îîZ ^
)
îî^ _
}
îî` a
,
îîa b
{
ïï 
$str
ïï !
,
ïï! "
CIELabFromRGB
ïï< I
(
ïïI J
$num
ïïJ N
,
ïïN O
$num
ïïP S
,
ïïS T
$num
ïïU X
,
ïïX Y
$num
ïïZ ^
)
ïï^ _
}
ïï` a
,
ïïa b
{
ğğ 
$str
ğğ 
,
ğğ 
CIELabFromRGB
ğğ< I
(
ğğI J
$num
ğğJ M
,
ğğM N
$num
ğğO R
,
ğğR S
$num
ğğT W
,
ğğW X
$num
ğğY ]
)
ğğ] ^
}
ğğ_ `
,
ğğ` a
{
ññ 
$str
ññ !
,
ññ! "
CIELabFromRGB
ññ< I
(
ññI J
$num
ññJ M
,
ññM N
$num
ññO R
,
ññR S
$num
ññT W
,
ññW X
$num
ññY ]
)
ññ] ^
}
ññ_ `
,
ññ` a
{
òò 
$str
òò !
,
òò! "
CIELabFromRGB
òò< I
(
òòI J
$num
òòJ N
,
òòN O
$num
òòP R
,
òòR S
$num
òòT W
,
òòW X
$num
òòY ]
)
òò] ^
}
òò_ `
,
òò` a
{
óó 
$str
óó 
,
óó 
CIELabFromRGB
óó< I
(
óóI J
$num
óóJ M
,
óóM N
$num
óóO R
,
óóR S
$num
óóT W
,
óóW X
$num
óóY ]
)
óó] ^
}
óó_ `
,
óó` a
{
ôô 
$str
ôô 
,
ôô 
CIELabFromRGB
ôô< I
(
ôôI J
$num
ôôJ M
,
ôôM N
$num
ôôO R
,
ôôR S
$num
ôôT W
,
ôôW X
$num
ôôY ]
)
ôô] ^
}
ôô_ `
,
ôô` a
{
õõ 
$str
õõ 
,
õõ 
CIELabFromRGB
õõ< I
(
õõI J
$num
õõJ M
,
õõM N
$num
õõO R
,
õõR S
$num
õõT W
,
õõW X
$num
õõY ]
)
õõ] ^
}
õõ_ `
,
õõ` a
{
öö 
$str
öö 
,
öö 
CIELabFromRGB
öö< I
(
ööI J
$num
ööJ M
,
ööM N
$num
ööO R
,
ööR S
$num
ööT X
,
ööX Y
$num
ööZ ^
)
öö^ _
}
öö` a
,
ööa b
{
÷÷ 
$str
÷÷ 
,
÷÷ 
CIELabFromRGB
÷÷< I
(
÷÷I J
$num
÷÷J M
,
÷÷M N
$num
÷÷O R
,
÷÷R S
$num
÷÷T V
,
÷÷V W
$num
÷÷X \
)
÷÷\ ]
}
÷÷^ _
,
÷÷_ `
{
øø 
$str
øø 
,
øø 
CIELabFromRGB
øø< I
(
øøI J
$num
øøJ M
,
øøM N
$num
øøO R
,
øøR S
$num
øøT W
,
øøW X
$num
øøY ]
)
øø] ^
}
øø_ `
,
øø` a
{
ùù 
$str
ùù 
,
ùù 
CIELabFromRGB
ùù< I
(
ùùI J
$num
ùùJ M
,
ùùM N
$num
ùùO R
,
ùùR S
$num
ùùT W
,
ùùW X
$num
ùùY ]
)
ùù] ^
}
ùù_ `
,
ùù` a
{
úú 
$str
úú 
,
úú 
CIELabFromRGB
úú< I
(
úúI J
$num
úúJ L
,
úúL M
$num
úúN Q
,
úúQ R
$num
úúS V
,
úúV W
$num
úúX \
)
úú\ ]
}
úú^ _
,
úú_ `
{
ûû 
$str
ûû 
,
ûû 
CIELabFromRGB
ûû< I
(
ûûI J
$num
ûûJ M
,
ûûM N
$num
ûûO R
,
ûûR S
$num
ûûT W
,
ûûW X
$num
ûûY ]
)
ûû] ^
}
ûû_ `
,
ûû` a
{
üü 
$str
üü 
,
üü 
CIELabFromRGB
üü< I
(
üüI J
$num
üüJ N
,
üüN O
$num
üüP S
,
üüS T
$num
üüU X
,
üüX Y
$num
üüZ ^
)
üü^ _
}
üü` a
,
üüa b
{
ıı 
$str
ıı 
,
ıı 
CIELabFromRGB
ıı< I
(
ııI J
$num
ııJ M
,
ııM N
$num
ııO R
,
ııR S
$num
ııT W
,
ııW X
$num
ııY ]
)
ıı] ^
}
ıı_ `
,
ıı` a
{
şş 
$str
şş 
,
şş 
CIELabFromRGB
şş< I
(
şşI J
$num
şşJ M
,
şşM N
$num
şşO Q
,
şşQ R
$num
şşS V
,
şşV W
$num
şşX \
)
şş\ ]
}
şş^ _
,
şş_ `
{
ÿÿ 
$str
ÿÿ 
,
ÿÿ 
CIELabFromRGB
ÿÿ< I
(
ÿÿI J
$num
ÿÿJ M
,
ÿÿM N
$num
ÿÿO R
,
ÿÿR S
$num
ÿÿT W
,
ÿÿW X
$num
ÿÿY ]
)
ÿÿ] ^
}
ÿÿ_ `
,
ÿÿ` a
{
€€ 
$str
€€  
,
€€  !
CIELabFromRGB
€€< I
(
€€I J
$num
€€J M
,
€€M N
$num
€€O R
,
€€R S
$num
€€T W
,
€€W X
$num
€€Y ]
)
€€] ^
}
€€_ `
,
€€` a
{
 
$str
 !
,
! "
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O Q
,
Q R
$num
S U
,
U V
$num
W [
)
[ \
}
] ^
,
^ _
{
‚‚ 
$str
‚‚ 
,
‚‚ 
CIELabFromRGB
‚‚< I
(
‚‚I J
$num
‚‚J M
,
‚‚M N
$num
‚‚O R
,
‚‚R S
$num
‚‚T W
,
‚‚W X
$num
‚‚Y ]
)
‚‚] ^
}
‚‚_ `
,
‚‚` a
{
ƒƒ 
$str
ƒƒ 
,
ƒƒ 
CIELabFromRGB
ƒƒ< I
(
ƒƒI J
$num
ƒƒJ M
,
ƒƒM N
$num
ƒƒO R
,
ƒƒR S
$num
ƒƒT X
,
ƒƒX Y
$num
ƒƒZ ^
)
ƒƒ^ _
}
ƒƒ` a
,
ƒƒa b
{
„„ 
$str
„„ 
,
„„ 
CIELabFromRGB
„„< I
(
„„I J
$num
„„J M
,
„„M N
$num
„„O R
,
„„R S
$num
„„T W
,
„„W X
$num
„„Y ]
)
„„] ^
}
„„_ `
,
„„` a
{
…… 
$str
…… 
,
…… 
CIELabFromRGB
……< I
(
……I J
$num
……J M
,
……M N
$num
……O R
,
……R S
$num
……T W
,
……W X
$num
……Y ]
)
……] ^
}
……_ `
,
……` a
{
†† 
$str
†† 
,
†† 
CIELabFromRGB
††< I
(
††I J
$num
††J M
,
††M N
$num
††O R
,
††R S
$num
††T W
,
††W X
$num
††Y ]
)
††] ^
}
††_ `
,
††` a
{
‡‡ 
$str
‡‡ 
,
‡‡ 
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J M
,
‡‡M N
$num
‡‡O R
,
‡‡R S
$num
‡‡T W
,
‡‡W X
$num
‡‡Y ]
)
‡‡] ^
}
‡‡_ `
,
‡‡` a
{
ˆˆ 
$str
ˆˆ 
,
ˆˆ 
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ M
,
ˆˆM N
$num
ˆˆO R
,
ˆˆR S
$num
ˆˆT W
,
ˆˆW X
$num
ˆˆY ]
)
ˆˆ] ^
}
ˆˆ_ `
,
ˆˆ` a
{
‰‰ 
$str
‰‰ !
,
‰‰! "
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J M
,
‰‰M N
$num
‰‰O R
,
‰‰R S
$num
‰‰T W
,
‰‰W X
$num
‰‰Y ]
)
‰‰] ^
}
‰‰_ `
,
‰‰` a
{
ŠŠ 
$str
ŠŠ 
,
ŠŠ 
CIELabFromRGB
ŠŠ< I
(
ŠŠI J
$num
ŠŠJ L
,
ŠŠL M
$num
ŠŠN P
,
ŠŠP Q
$num
ŠŠR U
,
ŠŠU V
$num
ŠŠW [
)
ŠŠ[ \
}
ŠŠ] ^
,
ŠŠ^ _
{
‹‹ 
$str
‹‹ &
,
‹‹& '
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J M
,
‹‹M N
$num
‹‹O Q
,
‹‹Q R
$num
‹‹S V
,
‹‹V W
$num
‹‹X \
)
‹‹\ ]
}
‹‹^ _
,
‹‹_ `
{
ŒŒ 
$str
ŒŒ 
,
ŒŒ 
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ M
,
ŒŒM N
$num
ŒŒO R
,
ŒŒR S
$num
ŒŒT W
,
ŒŒW X
$num
ŒŒY ]
)
ŒŒ] ^
}
ŒŒ_ `
,
ŒŒ` a
{
 
$str
  
,
  !
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
 
$str
 $
,
$ %
CIELabFromRGB
< I
(
I J
$num
J L
,
L M
$num
N Q
,
Q R
$num
S V
,
V W
$num
X \
)
\ ]
}
^ _
,
_ `
{
 
$str
 #
,
# $
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
 
$str
 '
,
' (
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
‘‘ 
$str
‘‘ 
,
‘‘ 
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J M
,
‘‘M N
$num
‘‘O R
,
‘‘R S
$num
‘‘T W
,
‘‘W X
$num
‘‘Y ]
)
‘‘] ^
}
‘‘_ `
,
‘‘` a
{
’’ 
$str
’’ #
,
’’# $
CIELabFromRGB
’’< I
(
’’I J
$num
’’J L
,
’’L M
$num
’’N Q
,
’’Q R
$num
’’S V
,
’’V W
$num
’’X \
)
’’\ ]
}
’’^ _
,
’’_ `
{
““ 
$str
““ 
,
““ 
CIELabFromRGB
““< I
(
““I J
$num
““J M
,
““M N
$num
““O R
,
““R S
$num
““T W
,
““W X
$num
““Y ]
)
““] ^
}
““_ `
,
““` a
{
”” 
$str
”” !
,
””! "
CIELabFromRGB
””< I
(
””I J
$num
””J M
,
””M N
$num
””O R
,
””R S
$num
””T W
,
””W X
$num
””Y ]
)
””] ^
}
””_ `
,
””` a
{
•• 
$str
•• 
,
•• 
CIELabFromRGB
••< I
(
••I J
$num
••J M
,
••M N
$num
••O R
,
••R S
$num
••T W
,
••W X
$num
••Y ]
)
••] ^
}
••_ `
,
••` a
{
–– 
$str
––  
,
––  !
CIELabFromRGB
––< I
(
––I J
$num
––J M
,
––M N
$num
––O R
,
––R S
$num
––T W
,
––W X
$num
––Y ]
)
––] ^
}
––_ `
,
––` a
{
—— 
$str
—— 
,
——  
CIELabFromRGB
——< I
(
——I J
$num
——J M
,
——M N
$num
——O R
,
——R S
$num
——T W
,
——W X
$num
——Y ]
)
——] ^
}
——_ `
,
——` a
{
˜˜ 
$str
˜˜ !
,
˜˜! "
CIELabFromRGB
˜˜< I
(
˜˜I J
$num
˜˜J M
,
˜˜M N
$num
˜˜O R
,
˜˜R S
$num
˜˜T W
,
˜˜W X
$num
˜˜Y ]
)
˜˜] ^
}
˜˜_ `
,
˜˜` a
{
™™ 
$str
™™ !
,
™™! "
CIELabFromRGB
™™< I
(
™™I J
$num
™™J M
,
™™M N
$num
™™O R
,
™™R S
$num
™™T W
,
™™W X
$num
™™Y ]
)
™™] ^
}
™™_ `
,
™™` a
{
šš 
$str
šš #
,
šš# $
CIELabFromRGB
šš< I
(
ššI J
$num
ššJ L
,
ššL M
$num
ššN Q
,
ššQ R
$num
ššS V
,
ššV W
$num
ššX \
)
šš\ ]
}
šš^ _
,
šš_ `
{
›› 
$str
›› 
,
›› 
CIELabFromRGB
››< I
(
››I J
$num
››J M
,
››M N
$num
››O R
,
››R S
$num
››T W
,
››W X
$num
››Y ]
)
››] ^
}
››_ `
,
››` a
{
œœ 
$str
œœ  
,
œœ  !
CIELabFromRGB
œœ< I
(
œœI J
$num
œœJ M
,
œœM N
$num
œœO R
,
œœR S
$num
œœT W
,
œœW X
$num
œœY ]
)
œœ] ^
}
œœ_ `
,
œœ` a
{
 
$str
 !
,
! "
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
 
$str
  
,
  !
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
ŸŸ 
$str
ŸŸ !
,
ŸŸ! "
CIELabFromRGB
ŸŸ< I
(
ŸŸI J
$num
ŸŸJ M
,
ŸŸM N
$num
ŸŸO Q
,
ŸŸQ R
$num
ŸŸS V
,
ŸŸV W
$num
ŸŸX \
)
ŸŸ\ ]
}
ŸŸ^ _
,
ŸŸ_ `
{
   
$str
   
,
   
CIELabFromRGB
  < I
(
  I J
$num
  J M
,
  M N
$num
  O R
,
  R S
$num
  T W
,
  W X
$num
  Y ]
)
  ] ^
}
  _ `
,
  ` a
{
¡¡ 
$str
¡¡ 
,
¡¡ 
CIELabFromRGB
¡¡< I
(
¡¡I J
$num
¡¡J M
,
¡¡M N
$num
¡¡O R
,
¡¡R S
$num
¡¡T W
,
¡¡W X
$num
¡¡Y ]
)
¡¡] ^
}
¡¡_ `
,
¡¡` a
{
¢¢ 
$str
¢¢ 
,
¢¢ 
CIELabFromRGB
¢¢< I
(
¢¢I J
$num
¢¢J M
,
¢¢M N
$num
¢¢O R
,
¢¢R S
$num
¢¢T W
,
¢¢W X
$num
¢¢Y ]
)
¢¢] ^
}
¢¢_ `
,
¢¢` a
{
££ 
$str
££  
,
££  !
CIELabFromRGB
££< I
(
££I J
$num
££J L
,
££L M
$num
££N Q
,
££Q R
$num
££S V
,
££V W
$num
££X \
)
££\ ]
}
££^ _
,
££_ `
{
¤¤ 
$str
¤¤ !
,
¤¤! "
CIELabFromRGB
¤¤< I
(
¤¤I J
$num
¤¤J M
,
¤¤M N
$num
¤¤O R
,
¤¤R S
$num
¤¤T W
,
¤¤W X
$num
¤¤Y ]
)
¤¤] ^
}
¤¤_ `
,
¤¤` a
{
¥¥ 
$str
¥¥ 
,
¥¥ 
CIELabFromRGB
¥¥< I
(
¥¥I J
$num
¥¥J M
,
¥¥M N
$num
¥¥O Q
,
¥¥Q R
$num
¥¥S V
,
¥¥V W
$num
¥¥X \
)
¥¥\ ]
}
¥¥^ _
,
¥¥_ `
{
¦¦ 
$str
¦¦ 
,
¦¦ 
CIELabFromRGB
¦¦< I
(
¦¦I J
$num
¦¦J M
,
¦¦M N
$num
¦¦O R
,
¦¦R S
$num
¦¦T W
,
¦¦W X
$num
¦¦Y ]
)
¦¦] ^
}
¦¦_ `
,
¦¦` a
{
§§ 
$str
§§ ,
,
§§, -
CIELabFromRGB
§§< I
(
§§I J
$num
§§J L
,
§§L M
$num
§§N Q
,
§§Q R
$num
§§S V
,
§§V W
$num
§§X \
)
§§\ ]
}
§§^ _
,
§§_ `
{
¨¨ 
$str
¨¨ 
,
¨¨ 
CIELabFromRGB
¨¨< I
(
¨¨I J
$num
¨¨J N
,
¨¨N O
$num
¨¨P S
,
¨¨S T
$num
¨¨U W
,
¨¨W X
$num
¨¨Y ]
)
¨¨] ^
}
¨¨_ `
,
¨¨` a
{
©© 
$str
©© 
,
©© 
CIELabFromRGB
©©< I
(
©©I J
$num
©©J M
,
©©M N
$num
©©O R
,
©©R S
$num
©©T W
,
©©W X
$num
©©Y ]
)
©©] ^
}
©©_ `
,
©©` a
{
ªª 
$str
ªª 
,
ªª 
CIELabFromRGB
ªª< I
(
ªªI J
$num
ªªJ M
,
ªªM N
$num
ªªO R
,
ªªR S
$num
ªªT W
,
ªªW X
$num
ªªY ]
)
ªª] ^
}
ªª_ `
,
ªª` a
{
«« 
$str
«« 
,
«« 
CIELabFromRGB
««< I
(
««I J
$num
««J M
,
««M N
$num
««O R
,
««R S
$num
««T W
,
««W X
$num
««Y ]
)
««] ^
}
««_ `
,
««` a
{
¬¬ 
$str
¬¬ 
,
¬¬ 
CIELabFromRGB
¬¬< I
(
¬¬I J
$num
¬¬J M
,
¬¬M N
$num
¬¬O S
,
¬¬S T
$num
¬¬U X
,
¬¬X Y
$num
¬¬Z ^
)
¬¬^ _
}
¬¬` a
,
¬¬a b
{
­­ 
$str
­­ 
,
­­ 
CIELabFromRGB
­­< I
(
­­I J
$num
­­J M
,
­­M N
$num
­­O S
,
­­S T
$num
­­U X
,
­­X Y
$num
­­Z ^
)
­­^ _
}
­­` a
,
­­a b
{
®® 
$str
®® 
,
®® 
CIELabFromRGB
®®< I
(
®®I J
$num
®®J N
,
®®N O
$num
®®P S
,
®®S T
$num
®®U X
,
®®X Y
$num
®®Z ^
)
®®^ _
}
®®` a
,
®®a b
{
¯¯ 
$str
¯¯ 
,
¯¯ 
CIELabFromRGB
¯¯< I
(
¯¯I J
$num
¯¯J M
,
¯¯M N
$num
¯¯O R
,
¯¯R S
$num
¯¯T W
,
¯¯W X
$num
¯¯Y ]
)
¯¯] ^
}
¯¯_ `
,
¯¯` a
{
°° 
$str
°° 
,
°° 
CIELabFromRGB
°°< I
(
°°I J
$num
°°J M
,
°°M N
$num
°°O R
,
°°R S
$num
°°T V
,
°°V W
$num
°°X \
)
°°\ ]
}
°°^ _
,
°°_ `
{
±± 
$str
±± 
,
±± 
CIELabFromRGB
±±< I
(
±±I J
$num
±±J M
,
±±M N
$num
±±O R
,
±±R S
$num
±±T W
,
±±W X
$num
±±Y ]
)
±±] ^
}
±±_ `
,
±±` a
{
²² 
$str
²² 
,
²² 
CIELabFromRGB
²²< I
(
²²I J
$num
²²J M
,
²²M N
$num
²²O Q
,
²²Q R
$num
²²S U
,
²²U V
$num
²²W [
)
²²[ \
}
²²] ^
,
²²^ _
{
³³ 
$str
³³ 
,
³³ 
CIELabFromRGB
³³< I
(
³³I J
$num
³³J M
,
³³M N
$num
³³O R
,
³³R S
$num
³³T W
,
³³W X
$num
³³Y ]
)
³³] ^
}
³³_ `
,
³³` a
{
´´ 
$str
´´ 
,
´´  
CIELabFromRGB
´´< I
(
´´I J
$num
´´J M
,
´´M N
$num
´´O R
,
´´R S
$num
´´T W
,
´´W X
$num
´´Y ]
)
´´] ^
}
´´_ `
,
´´` a
{
µµ 
$str
µµ  
,
µµ  !
CIELabFromRGB
µµ< I
(
µµI J
$num
µµJ M
,
µµM N
$num
µµO R
,
µµR S
$num
µµT W
,
µµW X
$num
µµY ]
)
µµ] ^
}
µµ_ `
,
µµ` a
{
¶¶ 
$str
¶¶ 
,
¶¶ 
CIELabFromRGB
¶¶< I
(
¶¶I J
$num
¶¶J L
,
¶¶L M
$num
¶¶N Q
,
¶¶Q R
$num
¶¶S V
,
¶¶V W
$num
¶¶X \
)
¶¶\ ]
}
¶¶^ _
,
¶¶_ `
{
·· 
$str
·· 
,
·· 
CIELabFromRGB
··< I
(
··I J
$num
··J M
,
··M N
$num
··O R
,
··R S
$num
··T W
,
··W X
$num
··Y ]
)
··] ^
}
··_ `
,
··` a
{
¸¸ 
$str
¸¸ 
,
¸¸ 
CIELabFromRGB
¸¸< I
(
¸¸I J
$num
¸¸J M
,
¸¸M N
$num
¸¸O R
,
¸¸R S
$num
¸¸T W
,
¸¸W X
$num
¸¸Y ]
)
¸¸] ^
}
¸¸_ `
,
¸¸` a
{
¹¹ 
$str
¹¹ 
,
¹¹ 
CIELabFromRGB
¹¹< I
(
¹¹I J
$num
¹¹J N
,
¹¹N O
$num
¹¹P S
,
¹¹S T
$num
¹¹U X
,
¹¹X Y
$num
¹¹Z ^
)
¹¹^ _
}
¹¹` a
,
¹¹a b
{
ºº 
$str
ºº 
,
ºº 
CIELabFromRGB
ºº< I
(
ººI J
$num
ººJ M
,
ººM N
$num
ººO R
,
ººR S
$num
ººT W
,
ººW X
$num
ººY ]
)
ºº] ^
}
ºº_ `
,
ºº` a
{
»» 
$str
»» 
,
»» 
CIELabFromRGB
»»< I
(
»»I J
$num
»»J M
,
»»M N
$num
»»O R
,
»»R S
$num
»»T W
,
»»W X
$num
»»Y ]
)
»»] ^
}
»»_ `
,
»»` a
{
¼¼ 
$str
¼¼ 
,
¼¼ 
CIELabFromRGB
¼¼< I
(
¼¼I J
$num
¼¼J M
,
¼¼M N
$num
¼¼O R
,
¼¼R S
$num
¼¼T V
,
¼¼V W
$num
¼¼X \
)
¼¼\ ]
}
¼¼^ _
,
¼¼_ `
{
½½ 
$str
½½ 
,
½½ 
CIELabFromRGB
½½< I
(
½½I J
$num
½½J M
,
½½M N
$num
½½O R
,
½½R S
$num
½½T W
,
½½W X
$num
½½Y ]
)
½½] ^
}
½½_ `
,
½½` a
{
¾¾ 
$str
¾¾ 
,
¾¾ 
CIELabFromRGB
¾¾< I
(
¾¾I J
$num
¾¾J N
,
¾¾N O
$num
¾¾P S
,
¾¾S T
$num
¾¾U X
,
¾¾X Y
$num
¾¾Z ^
)
¾¾^ _
}
¾¾` a
,
¾¾a b
{
¿¿ 
$str
¿¿ 
,
¿¿ 
CIELabFromRGB
¿¿< I
(
¿¿I J
$num
¿¿J L
,
¿¿L M
$num
¿¿N P
,
¿¿P Q
$num
¿¿R U
,
¿¿U V
$num
¿¿W [
)
¿¿[ \
}
¿¿] ^
,
¿¿^ _
{
ÀÀ 
$str
ÀÀ 
,
ÀÀ 
CIELabFromRGB
ÀÀ< I
(
ÀÀI J
$num
ÀÀJ M
,
ÀÀM N
$num
ÀÀO R
,
ÀÀR S
$num
ÀÀT W
,
ÀÀW X
$num
ÀÀY ]
)
ÀÀ] ^
}
ÀÀ_ `
,
ÀÀ` a
{
ÁÁ 
$str
ÁÁ 
,
ÁÁ 
CIELabFromRGB
ÁÁ< I
(
ÁÁI J
$num
ÁÁJ N
,
ÁÁN O
$num
ÁÁP S
,
ÁÁS T
$num
ÁÁU X
,
ÁÁX Y
$num
ÁÁZ ^
)
ÁÁ^ _
}
ÁÁ` a
,
ÁÁa b
{
ÂÂ 
$str
ÂÂ 
,
ÂÂ 
CIELabFromRGB
ÂÂ< I
(
ÂÂI J
$num
ÂÂJ N
,
ÂÂN O
$num
ÂÂP S
,
ÂÂS T
$num
ÂÂU X
,
ÂÂX Y
$num
ÂÂZ ^
)
ÂÂ^ _
}
ÂÂ` a
,
ÂÂa b
{
ÃÃ 
$str
ÃÃ 
,
ÃÃ 
CIELabFromRGB
ÃÃ< I
(
ÃÃI J
$num
ÃÃJ M
,
ÃÃM N
$num
ÃÃO S
,
ÃÃS T
$num
ÃÃU W
,
ÃÃW X
$num
ÃÃY ]
)
ÃÃ] ^
}
ÃÃ_ `
,
ÃÃ` a
{
ÄÄ 
$str
ÄÄ 
,
ÄÄ 
CIELabFromRGB
ÄÄ< I
(
ÄÄI J
$num
ÄÄJ M
,
ÄÄM N
$num
ÄÄO R
,
ÄÄR S
$num
ÄÄT W
,
ÄÄW X
$num
ÄÄY ]
)
ÄÄ] ^
}
ÄÄ_ `
,
ÄÄ` a
{
ÅÅ 
$str
ÅÅ 
,
ÅÅ 
CIELabFromRGB
ÅÅ< I
(
ÅÅI J
$num
ÅÅJ M
,
ÅÅM N
$num
ÅÅO R
,
ÅÅR S
$num
ÅÅT W
,
ÅÅW X
$num
ÅÅY ]
)
ÅÅ] ^
}
ÅÅ_ `
,
ÅÅ` a
{
ÆÆ 
$str
ÆÆ 
,
ÆÆ 
CIELabFromRGB
ÆÆ< I
(
ÆÆI J
$num
ÆÆJ M
,
ÆÆM N
$num
ÆÆO R
,
ÆÆR S
$num
ÆÆT W
,
ÆÆW X
$num
ÆÆY ]
)
ÆÆ] ^
}
ÆÆ_ `
,
ÆÆ` a
{
ÇÇ 
$str
ÇÇ !
,
ÇÇ! "
CIELabFromRGB
ÇÇ< I
(
ÇÇI J
$num
ÇÇJ L
,
ÇÇL M
$num
ÇÇN Q
,
ÇÇQ R
$num
ÇÇS V
,
ÇÇV W
$num
ÇÇX \
)
ÇÇ\ ]
}
ÇÇ^ _
,
ÇÇ_ `
{
ÈÈ 
$str
ÈÈ 
,
ÈÈ 
CIELabFromRGB
ÈÈ< I
(
ÈÈI J
$num
ÈÈJ M
,
ÈÈM N
$num
ÈÈO S
,
ÈÈS T
$num
ÈÈU X
,
ÈÈX Y
$num
ÈÈZ ^
)
ÈÈ^ _
}
ÈÈ` a
,
ÈÈa b
{
ÉÉ 
$str
ÉÉ 
,
ÉÉ  
CIELabFromRGB
ÉÉ< I
(
ÉÉI J
$num
ÉÉJ L
,
ÉÉL M
$num
ÉÉN Q
,
ÉÉQ R
$num
ÉÉS V
,
ÉÉV W
$num
ÉÉX \
)
ÉÉ\ ]
}
ÉÉ^ _
,
ÉÉ_ `
{
ÊÊ 
$str
ÊÊ 
,
ÊÊ 
CIELabFromRGB
ÊÊ< I
(
ÊÊI J
$num
ÊÊJ M
,
ÊÊM N
$num
ÊÊO R
,
ÊÊR S
$num
ÊÊT W
,
ÊÊW X
$num
ÊÊY ]
)
ÊÊ] ^
}
ÊÊ_ `
,
ÊÊ` a
{
ËË 
$str
ËË 
,
ËË 
CIELabFromRGB
ËË< I
(
ËËI J
$num
ËËJ L
,
ËËL M
$num
ËËN Q
,
ËËQ R
$num
ËËS U
,
ËËU V
$num
ËËW [
)
ËË[ \
}
ËË] ^
,
ËË^ _
{
ÌÌ 
$str
ÌÌ 
,
ÌÌ 
CIELabFromRGB
ÌÌ< I
(
ÌÌI J
$num
ÌÌJ M
,
ÌÌM N
$num
ÌÌO R
,
ÌÌR S
$num
ÌÌT W
,
ÌÌW X
$num
ÌÌY ]
)
ÌÌ] ^
}
ÌÌ_ `
,
ÌÌ` a
{
ÍÍ 
$str
ÍÍ 
,
ÍÍ 
CIELabFromRGB
ÍÍ< I
(
ÍÍI J
$num
ÍÍJ M
,
ÍÍM N
$num
ÍÍO R
,
ÍÍR S
$num
ÍÍT W
,
ÍÍW X
$num
ÍÍY ]
)
ÍÍ] ^
}
ÍÍ_ `
,
ÍÍ` a
{
ÎÎ 
$str
ÎÎ 
,
ÎÎ 
CIELabFromRGB
ÎÎ< I
(
ÎÎI J
$num
ÎÎJ M
,
ÎÎM N
$num
ÎÎO R
,
ÎÎR S
$num
ÎÎT W
,
ÎÎW X
$num
ÎÎY ]
)
ÎÎ] ^
}
ÎÎ_ `
,
ÎÎ` a
{
ÏÏ 
$str
ÏÏ 
,
ÏÏ 
CIELabFromRGB
ÏÏ< I
(
ÏÏI J
$num
ÏÏJ M
,
ÏÏM N
$num
ÏÏO R
,
ÏÏR S
$num
ÏÏT W
,
ÏÏW X
$num
ÏÏY ]
)
ÏÏ] ^
}
ÏÏ_ `
,
ÏÏ` a
{
ĞĞ 
$str
ĞĞ 
,
ĞĞ 
CIELabFromRGB
ĞĞ< I
(
ĞĞI J
$num
ĞĞJ M
,
ĞĞM N
$num
ĞĞO R
,
ĞĞR S
$num
ĞĞT W
,
ĞĞW X
$num
ĞĞY ]
)
ĞĞ] ^
}
ĞĞ_ `
,
ĞĞ` a
{
ÑÑ 
$str
ÑÑ 
,
ÑÑ 
CIELabFromRGB
ÑÑ< I
(
ÑÑI J
$num
ÑÑJ M
,
ÑÑM N
$num
ÑÑO R
,
ÑÑR S
$num
ÑÑT W
,
ÑÑW X
$num
ÑÑY ]
)
ÑÑ] ^
}
ÑÑ_ `
,
ÑÑ` a
{
ÒÒ 
$str
ÒÒ 
,
ÒÒ 
CIELabFromRGB
ÒÒ< I
(
ÒÒI J
$num
ÒÒJ M
,
ÒÒM N
$num
ÒÒO R
,
ÒÒR S
$num
ÒÒT W
,
ÒÒW X
$num
ÒÒY ]
)
ÒÒ] ^
}
ÒÒ_ `
,
ÒÒ` a
{
ÓÓ 
$str
ÓÓ 
,
ÓÓ 
CIELabFromRGB
ÓÓ< I
(
ÓÓI J
$num
ÓÓJ M
,
ÓÓM N
$num
ÓÓO R
,
ÓÓR S
$num
ÓÓT W
,
ÓÓW X
$num
ÓÓY ]
)
ÓÓ] ^
}
ÓÓ_ `
,
ÓÓ` a
{
ÔÔ 
$str
ÔÔ 
,
ÔÔ 
CIELabFromRGB
ÔÔ< I
(
ÔÔI J
$num
ÔÔJ M
,
ÔÔM N
$num
ÔÔO R
,
ÔÔR S
$num
ÔÔT W
,
ÔÔW X
$num
ÔÔY ]
)
ÔÔ] ^
}
ÔÔ_ `
,
ÔÔ` a
{
ÕÕ 
$str
ÕÕ 
,
ÕÕ 
CIELabFromRGB
ÕÕ< I
(
ÕÕI J
$num
ÕÕJ M
,
ÕÕM N
$num
ÕÕO R
,
ÕÕR S
$num
ÕÕT V
,
ÕÕV W
$num
ÕÕX \
)
ÕÕ\ ]
}
ÕÕ^ _
,
ÕÕ_ `
{
ÖÖ 
$str
ÖÖ 
,
ÖÖ 
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ M
,
ÖÖM N
$num
ÖÖO R
,
ÖÖR S
$num
ÖÖT W
,
ÖÖW X
$num
ÖÖY ]
)
ÖÖ] ^
}
ÖÖ_ `
,
ÖÖ` a
{
×× 
$str
×× 
,
×× 
CIELabFromRGB
××< I
(
××I J
$num
××J M
,
××M N
$num
××O R
,
××R S
$num
××T W
,
××W X
$num
××Y ]
)
××] ^
}
××_ `
,
××` a
{
ØØ 
$str
ØØ 
,
ØØ 
CIELabFromRGB
ØØ< I
(
ØØI J
$num
ØØJ M
,
ØØM N
$num
ØØO R
,
ØØR S
$num
ØØT W
,
ØØW X
$num
ØØY ]
)
ØØ] ^
}
ØØ_ `
,
ØØ` a
{
ÙÙ 
$str
ÙÙ 
,
ÙÙ 
CIELabFromRGB
ÙÙ< I
(
ÙÙI J
$num
ÙÙJ M
,
ÙÙM N
$num
ÙÙO R
,
ÙÙR S
$num
ÙÙT W
,
ÙÙW X
$num
ÙÙY ]
)
ÙÙ] ^
}
ÙÙ_ `
,
ÙÙ` a
{
ÚÚ 
$str
ÚÚ $
,
ÚÚ$ %
CIELabFromRGB
ÚÚ< I
(
ÚÚI J
$num
ÚÚJ N
,
ÚÚN O
$num
ÚÚP S
,
ÚÚS T
$num
ÚÚU W
,
ÚÚW X
$num
ÚÚY ]
)
ÚÚ] ^
}
ÚÚ_ `
,
ÚÚ` a
{
ÛÛ 
$str
ÛÛ  
,
ÛÛ  !
CIELabFromRGB
ÛÛ< I
(
ÛÛI J
$num
ÛÛJ N
,
ÛÛN O
$num
ÛÛP S
,
ÛÛS T
$num
ÛÛU X
,
ÛÛX Y
$num
ÛÛZ ^
)
ÛÛ^ _
}
ÛÛ` a
,
ÛÛa b
{
ÜÜ 
$str
ÜÜ  
,
ÜÜ  !
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ N
,
ÜÜN O
$num
ÜÜP S
,
ÜÜS T
$num
ÜÜU W
,
ÜÜW X
$num
ÜÜY ]
)
ÜÜ] ^
}
ÜÜ_ `
,
ÜÜ` a
{
İİ 
$str
İİ 
,
İİ 
CIELabFromRGB
İİ< I
(
İİI J
$num
İİJ M
,
İİM N
$num
İİO R
,
İİR S
$num
İİT V
,
İİV W
$num
İİX \
)
İİ\ ]
}
İİ^ _
,
İİ_ `
{
ŞŞ 
$str
ŞŞ 
,
ŞŞ 
CIELabFromRGB
ŞŞ< I
(
ŞŞI J
$num
ŞŞJ N
,
ŞŞN O
$num
ŞŞP S
,
ŞŞS T
$num
ŞŞU W
,
ŞŞW X
$num
ŞŞY ]
)
ŞŞ] ^
}
ŞŞ_ `
,
ŞŞ` a
{
ßß 
$str
ßß 
,
ßß 
CIELabFromRGB
ßß< I
(
ßßI J
$num
ßßJ N
,
ßßN O
$num
ßßP S
,
ßßS T
$num
ßßU W
,
ßßW X
$num
ßßY ]
)
ßß] ^
}
ßß_ `
,
ßß` a
{
àà 
$str
àà 
,
àà 
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ N
,
ààN O
$num
ààP S
,
ààS T
$num
ààU W
,
ààW X
$num
ààY ]
)
àà] ^
}
àà_ `
,
àà` a
{
áá 
$str
áá 
,
áá 
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ M
,
ááM N
$num
ááO R
,
ááR S
$num
ááT W
,
ááW X
$num
ááY ]
)
áá] ^
}
áá_ `
,
áá` a
{
ââ 
$str
ââ 
,
ââ 
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ M
,
ââM N
$num
ââO R
,
ââR S
$num
ââT W
,
ââW X
$num
ââY ]
)
ââ] ^
}
ââ_ `
,
ââ` a
{
ãã 
$str
ãã 
,
ãã 
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ M
,
ããM N
$num
ããO R
,
ããR S
$num
ããT W
,
ããW X
$num
ããY ]
)
ãã] ^
}
ãã_ `
,
ãã` a
{
ää 
$str
ää 
,
ää 
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ M
,
ääM N
$num
ääO R
,
ääR S
$num
ääT V
,
ääV W
$num
ääX \
)
ää\ ]
}
ää^ _
,
ää_ `
{
åå 
$str
åå 
,
åå 
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ M
,
ååM N
$num
ååO R
,
ååR S
$num
ååT W
,
ååW X
$num
ååY ]
)
åå] ^
}
åå_ `
,
åå` a
{
ææ 
$str
ææ 
,
ææ 
CIELabFromRGB
ææ< I
(
ææI J
$num
ææJ M
,
ææM N
$num
ææO R
,
ææR S
$num
ææT W
,
ææW X
$num
ææY ]
)
ææ] ^
}
ææ_ `
,
ææ` a
{
çç 
$str
çç !
,
çç! "
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ N
,
ççN O
$num
ççP S
,
ççS T
$num
ççU X
,
ççX Y
$num
ççZ ^
)
çç^ _
}
çç` a
,
çça b
{
èè 
$str
èè 
,
èè 
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ L
,
èèL M
$num
èèN Q
,
èèQ R
$num
èèS V
,
èèV W
$num
èèX \
)
èè\ ]
}
èè^ _
,
èè_ `
{
éé 
$str
éé 
,
éé 
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ M
,
ééM N
$num
ééO Q
,
ééQ R
$num
ééS U
,
ééU V
$num
ééW [
)
éé[ \
}
éé] ^
,
éé^ _
{
êê 
$str
êê 
,
êê 
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ L
,
êêL M
$num
êêN Q
,
êêQ R
$num
êêS U
,
êêU V
$num
êêW [
)
êê[ \
}
êê] ^
,
êê^ _
{
ëë 
$str
ëë 
,
ëë  
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ M
,
ëëM N
$num
ëëO R
,
ëëR S
$num
ëëT W
,
ëëW X
$num
ëëY ]
)
ëë] ^
}
ëë_ `
,
ëë` a
{
ìì 
$str
ìì !
,
ìì! "
CIELabFromRGB
ìì< I
(
ììI J
$num
ììJ M
,
ììM N
$num
ììO R
,
ììR S
$num
ììT W
,
ììW X
$num
ììY ]
)
ìì] ^
}
ìì_ `
,
ìì` a
{
íí 
$str
íí 
,
íí 
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ M
,
ííM N
$num
ííO R
,
ííR S
$num
ííT W
,
ííW X
$num
ííY ]
)
íí] ^
}
íí_ `
,
íí` a
{
îî 
$str
îî 
,
îî 
CIELabFromRGB
îî< I
(
îîI J
$num
îîJ M
,
îîM N
$num
îîO R
,
îîR S
$num
îîT W
,
îîW X
$num
îîY ]
)
îî] ^
}
îî_ `
,
îî` a
{
ïï 
$str
ïï 
,
ïï 
CIELabFromRGB
ïï< I
(
ïïI J
$num
ïïJ M
,
ïïM N
$num
ïïO R
,
ïïR S
$num
ïïT W
,
ïïW X
$num
ïïY ]
)
ïï] ^
}
ïï_ `
,
ïï` a
{
ğğ 
$str
ğğ 
,
ğğ 
CIELabFromRGB
ğğ< I
(
ğğI J
$num
ğğJ M
,
ğğM N
$num
ğğO R
,
ğğR S
$num
ğğT W
,
ğğW X
$num
ğğY ]
)
ğğ] ^
}
ğğ_ `
,
ğğ` a
{
ññ 
$str
ññ 
,
ññ 
CIELabFromRGB
ññ< I
(
ññI J
$num
ññJ M
,
ññM N
$num
ññO R
,
ññR S
$num
ññT W
,
ññW X
$num
ññY ]
)
ññ] ^
}
ññ_ `
,
ññ` a
{
òò 
$str
òò 
,
òò 
CIELabFromRGB
òò< I
(
òòI J
$num
òòJ M
,
òòM N
$num
òòO R
,
òòR S
$num
òòT W
,
òòW X
$num
òòY ]
)
òò] ^
}
òò_ `
,
òò` a
{
óó 
$str
óó 
,
óó 
CIELabFromRGB
óó< I
(
óóI J
$num
óóJ M
,
óóM N
$num
óóO R
,
óóR S
$num
óóT W
,
óóW X
$num
óóY ]
)
óó] ^
}
óó_ `
,
óó` a
{
ôô 
$str
ôô $
,
ôô$ %
CIELabFromRGB
ôô< I
(
ôôI J
$num
ôôJ M
,
ôôM N
$num
ôôO R
,
ôôR S
$num
ôôT W
,
ôôW X
$num
ôôY ]
)
ôô] ^
}
ôô_ `
,
ôô` a
{
õõ 
$str
õõ 
,
õõ 
CIELabFromRGB
õõ< I
(
õõI J
$num
õõJ M
,
õõM N
$num
õõO R
,
õõR S
$num
õõT W
,
õõW X
$num
õõY ]
)
õõ] ^
}
õõ_ `
,
õõ` a
{
öö 
$str
öö 
,
öö 
CIELabFromRGB
öö< I
(
ööI J
$num
ööJ M
,
ööM N
$num
ööO R
,
ööR S
$num
ööT W
,
ööW X
$num
ööY ]
)
öö] ^
}
öö_ `
,
öö` a
{
÷÷ 
$str
÷÷ 
,
÷÷ 
CIELabFromRGB
÷÷< I
(
÷÷I J
$num
÷÷J M
,
÷÷M N
$num
÷÷O R
,
÷÷R S
$num
÷÷T W
,
÷÷W X
$num
÷÷Y ]
)
÷÷] ^
}
÷÷_ `
,
÷÷` a
{
øø 
$str
øø 
,
øø 
CIELabFromRGB
øø< I
(
øøI J
$num
øøJ M
,
øøM N
$num
øøO R
,
øøR S
$num
øøT W
,
øøW X
$num
øøY ]
)
øø] ^
}
øø_ `
,
øø` a
{
ùù 
$str
ùù 
,
ùù 
CIELabFromRGB
ùù< I
(
ùùI J
$num
ùùJ M
,
ùùM N
$num
ùùO R
,
ùùR S
$num
ùùT X
,
ùùX Y
$num
ùùZ ^
)
ùù^ _
}
ùù` a
,
ùùa b
{
úú 
$str
úú 
,
úú 
CIELabFromRGB
úú< I
(
úúI J
$num
úúJ M
,
úúM N
$num
úúO R
,
úúR S
$num
úúT W
,
úúW X
$num
úúY ]
)
úú] ^
}
úú_ `
,
úú` a
{
ûû 
$str
ûû !
,
ûû! "
CIELabFromRGB
ûû< I
(
ûûI J
$num
ûûJ N
,
ûûN O
$num
ûûP S
,
ûûS T
$num
ûûU X
,
ûûX Y
$num
ûûZ ^
)
ûû^ _
}
ûû` a
,
ûûa b
{
üü 
$str
üü 
,
üü 
CIELabFromRGB
üü< I
(
üüI J
$num
üüJ M
,
üüM N
$num
üüO R
,
üüR S
$num
üüT W
,
üüW X
$num
üüY ]
)
üü] ^
}
üü_ `
,
üü` a
{
ıı 
$str
ıı 
,
ıı 
CIELabFromRGB
ıı< I
(
ııI J
$num
ııJ M
,
ııM N
$num
ııO R
,
ııR S
$num
ııT W
,
ııW X
$num
ııY ]
)
ıı] ^
}
ıı_ `
,
ıı` a
{
şş 
$str
şş 
,
şş  
CIELabFromRGB
şş< I
(
şşI J
$num
şşJ M
,
şşM N
$num
şşO R
,
şşR S
$num
şşT W
,
şşW X
$num
şşY ]
)
şş] ^
}
şş_ `
,
şş` a
{
ÿÿ 
$str
ÿÿ #
,
ÿÿ# $
CIELabFromRGB
ÿÿ< I
(
ÿÿI J
$num
ÿÿJ M
,
ÿÿM N
$num
ÿÿO R
,
ÿÿR S
$num
ÿÿT W
,
ÿÿW X
$num
ÿÿY ]
)
ÿÿ] ^
}
ÿÿ_ `
,
ÿÿ` a
{
€	€	 
$str
€	€	 
,
€	€	 
CIELabFromRGB
€	€	< I
(
€	€	I J
$num
€	€	J M
,
€	€	M N
$num
€	€	O R
,
€	€	R S
$num
€	€	T W
,
€	€	W X
$num
€	€	Y ]
)
€	€	] ^
}
€	€	_ `
,
€	€	` a
{
		 
$str
		 
,
		  
CIELabFromRGB
		< I
(
		I J
$num
		J M
,
		M N
$num
		O R
,
		R S
$num
		T W
,
		W X
$num
		Y ]
)
		] ^
}
		_ `
,
		` a
{
‚	‚	 
$str
‚	‚	 
,
‚	‚	 
CIELabFromRGB
‚	‚	< I
(
‚	‚	I J
$num
‚	‚	J M
,
‚	‚	M N
$num
‚	‚	O R
,
‚	‚	R S
$num
‚	‚	T W
,
‚	‚	W X
$num
‚	‚	Y ]
)
‚	‚	] ^
}
‚	‚	_ `
,
‚	‚	` a
{
ƒ	ƒ	 
$str
ƒ	ƒ	 
,
ƒ	ƒ	 
CIELabFromRGB
ƒ	ƒ	< I
(
ƒ	ƒ	I J
$num
ƒ	ƒ	J M
,
ƒ	ƒ	M N
$num
ƒ	ƒ	O R
,
ƒ	ƒ	R S
$num
ƒ	ƒ	T W
,
ƒ	ƒ	W X
$num
ƒ	ƒ	Y ]
)
ƒ	ƒ	] ^
}
ƒ	ƒ	_ `
,
ƒ	ƒ	` a
{
„	„	 
$str
„	„	 
,
„	„	 
CIELabFromRGB
„	„	< I
(
„	„	I J
$num
„	„	J M
,
„	„	M N
$num
„	„	O R
,
„	„	R S
$num
„	„	T X
,
„	„	X Y
$num
„	„	Z ^
)
„	„	^ _
}
„	„	` a
,
„	„	a b
{
…	…	 
$str
…	…	 
,
…	…	  
CIELabFromRGB
…	…	< I
(
…	…	I J
$num
…	…	J M
,
…	…	M N
$num
…	…	O R
,
…	…	R S
$num
…	…	T W
,
…	…	W X
$num
…	…	Y ]
)
…	…	] ^
}
…	…	_ `
,
…	…	` a
{
†	†	 
$str
†	†	 
,
†	†	 
CIELabFromRGB
†	†	< I
(
†	†	I J
$num
†	†	J M
,
†	†	M N
$num
†	†	O Q
,
†	†	Q R
$num
†	†	S V
,
†	†	V W
$num
†	†	X \
)
†	†	\ ]
}
†	†	^ _
,
†	†	_ `
{
‡	‡	 
$str
‡	‡	 $
,
‡	‡	$ %
CIELabFromRGB
‡	‡	< I
(
‡	‡	I J
$num
‡	‡	J L
,
‡	‡	L M
$num
‡	‡	N Q
,
‡	‡	Q R
$num
‡	‡	S V
,
‡	‡	V W
$num
‡	‡	X \
)
‡	‡	\ ]
}
‡	‡	^ _
,
‡	‡	_ `
{
ˆ	ˆ	 
$str
ˆ	ˆ	 
,
ˆ	ˆ	 
CIELabFromRGB
ˆ	ˆ	< I
(
ˆ	ˆ	I J
$num
ˆ	ˆ	J N
,
ˆ	ˆ	N O
$num
ˆ	ˆ	P S
,
ˆ	ˆ	S T
$num
ˆ	ˆ	U X
,
ˆ	ˆ	X Y
$num
ˆ	ˆ	Z ^
)
ˆ	ˆ	^ _
}
ˆ	ˆ	` a
,
ˆ	ˆ	a b
{
‰	‰	 
$str
‰	‰	 
,
‰	‰	 
CIELabFromRGB
‰	‰	< I
(
‰	‰	I J
$num
‰	‰	J M
,
‰	‰	M N
$num
‰	‰	O R
,
‰	‰	R S
$num
‰	‰	T W
,
‰	‰	W X
$num
‰	‰	Y ]
)
‰	‰	] ^
}
‰	‰	_ `
,
‰	‰	` a
{
Š	Š	 
$str
Š	Š	 
,
Š	Š	 
CIELabFromRGB
Š	Š	< I
(
Š	Š	I J
$num
Š	Š	J M
,
Š	Š	M N
$num
Š	Š	O R
,
Š	Š	R S
$num
Š	Š	T W
,
Š	Š	W X
$num
Š	Š	Y ]
)
Š	Š	] ^
}
Š	Š	_ `
,
Š	Š	` a
{
‹	‹	 
$str
‹	‹	 
,
‹	‹	 
CIELabFromRGB
‹	‹	< I
(
‹	‹	I J
$num
‹	‹	J M
,
‹	‹	M N
$num
‹	‹	O R
,
‹	‹	R S
$num
‹	‹	T W
,
‹	‹	W X
$num
‹	‹	Y ]
)
‹	‹	] ^
}
‹	‹	_ `
,
‹	‹	` a
{
Œ	Œ	 
$str
Œ	Œ	 
,
Œ	Œ	 
CIELabFromRGB
Œ	Œ	< I
(
Œ	Œ	I J
$num
Œ	Œ	J M
,
Œ	Œ	M N
$num
Œ	Œ	O R
,
Œ	Œ	R S
$num
Œ	Œ	T W
,
Œ	Œ	W X
$num
Œ	Œ	Y ]
)
Œ	Œ	] ^
}
Œ	Œ	_ `
,
Œ	Œ	` a
{
		 
$str
		 
,
		 
CIELabFromRGB
		< I
(
		I J
$num
		J M
,
		M N
$num
		O R
,
		R S
$num
		T W
,
		W X
$num
		Y ]
)
		] ^
}
		_ `
,
		` a
{
		 
$str
		 
,
		 
CIELabFromRGB
		< I
(
		I J
$num
		J M
,
		M N
$num
		O R
,
		R S
$num
		T W
,
		W X
$num
		Y ]
)
		] ^
}
		_ `
,
		` a
{
		 
$str
		 
,
		 
CIELabFromRGB
		< I
(
		I J
$num
		J M
,
		M N
$num
		O R
,
		R S
$num
		T W
,
		W X
$num
		Y ]
)
		] ^
}
		_ `
,
		` a
{
		 
$str
		 
,
		 
CIELabFromRGB
		< I
(
		I J
$num
		J N
,
		N O
$num
		P S
,
		S T
$num
		U X
,
		X Y
$num
		Z ^
)
		^ _
}
		` a
,
		a b
{
‘	‘	 
$str
‘	‘	 
,
‘	‘	 
CIELabFromRGB
‘	‘	< I
(
‘	‘	I J
$num
‘	‘	J M
,
‘	‘	M N
$num
‘	‘	O R
,
‘	‘	R S
$num
‘	‘	T W
,
‘	‘	W X
$num
‘	‘	Y ]
)
‘	‘	] ^
}
‘	‘	_ `
,
‘	‘	` a
{
’	’	 
$str
’	’	 
,
’	’	 
CIELabFromRGB
’	’	< I
(
’	’	I J
$num
’	’	J M
,
’	’	M N
$num
’	’	O R
,
’	’	R S
$num
’	’	T W
,
’	’	W X
$num
’	’	Y ]
)
’	’	] ^
}
’	’	_ `
,
’	’	` a
{
“	“	 
$str
“	“	 
,
“	“	 
CIELabFromRGB
“	“	< I
(
“	“	I J
$num
“	“	J N
,
“	“	N O
$num
“	“	P S
,
“	“	S T
$num
“	“	U X
,
“	“	X Y
$num
“	“	Z ^
)
“	“	^ _
}
“	“	` a
,
“	“	a b
{
”	”	 
$str
”	”	 
,
”	”	 
CIELabFromRGB
”	”	< I
(
”	”	I J
$num
”	”	J M
,
”	”	M N
$num
”	”	O R
,
”	”	R S
$num
”	”	T W
,
”	”	W X
$num
”	”	Y ]
)
”	”	] ^
}
”	”	_ `
,
”	”	` a
{
•	•	 
$str
•	•	 
,
•	•	 
CIELabFromRGB
•	•	< I
(
•	•	I J
$num
•	•	J M
,
•	•	M N
$num
•	•	O R
,
•	•	R S
$num
•	•	T W
,
•	•	W X
$num
•	•	Y ]
)
•	•	] ^
}
•	•	_ `
,
•	•	` a
{
–	–	 
$str
–	–	 
,
–	–	 
CIELabFromRGB
–	–	< I
(
–	–	I J
$num
–	–	J M
,
–	–	M N
$num
–	–	O Q
,
–	–	Q R
$num
–	–	S V
,
–	–	V W
$num
–	–	X \
)
–	–	\ ]
}
–	–	^ _
,
–	–	_ `
{
—	—	 
$str
—	—	 
,
—	—	 
CIELabFromRGB
—	—	< I
(
—	—	I J
$num
—	—	J M
,
—	—	M N
$num
—	—	O R
,
—	—	R S
$num
—	—	T W
,
—	—	W X
$num
—	—	Y ]
)
—	—	] ^
}
—	—	_ `
,
—	—	` a
{
˜	˜	 
$str
˜	˜	 
,
˜	˜	 
CIELabFromRGB
˜	˜	< I
(
˜	˜	I J
$num
˜	˜	J N
,
˜	˜	N O
$num
˜	˜	P S
,
˜	˜	S T
$num
˜	˜	U X
,
˜	˜	X Y
$num
˜	˜	Z ^
)
˜	˜	^ _
}
˜	˜	` a
,
˜	˜	a b
{
™	™	 
$str
™	™	 
,
™	™	 
CIELabFromRGB
™	™	< I
(
™	™	I J
$num
™	™	J N
,
™	™	N O
$num
™	™	P S
,
™	™	S T
$num
™	™	U X
,
™	™	X Y
$num
™	™	Z ^
)
™	™	^ _
}
™	™	` a
,
™	™	a b
{
š	š	 
$str
š	š	 
,
š	š	 
CIELabFromRGB
š	š	< I
(
š	š	I J
$num
š	š	J N
,
š	š	N O
$num
š	š	P S
,
š	š	S T
$num
š	š	U X
,
š	š	X Y
$num
š	š	Z ^
)
š	š	^ _
}
š	š	` a
,
š	š	a b
{
›	›	 
$str
›	›	 
,
›	›	 
CIELabFromRGB
›	›	< I
(
›	›	I J
$num
›	›	J N
,
›	›	N O
$num
›	›	P S
,
›	›	S T
$num
›	›	U X
,
›	›	X Y
$num
›	›	Z ^
)
›	›	^ _
}
›	›	` a
,
›	›	a b
{
œ	œ	 
$str
œ	œ	 
,
œ	œ	 
CIELabFromRGB
œ	œ	< I
(
œ	œ	I J
$num
œ	œ	J M
,
œ	œ	M N
$num
œ	œ	O R
,
œ	œ	R S
$num
œ	œ	T W
,
œ	œ	W X
$num
œ	œ	Y ]
)
œ	œ	] ^
}
œ	œ	_ `
,
œ	œ	` a
{
		 
$str
		 
,
		 
CIELabFromRGB
		< I
(
		I J
$num
		J M
,
		M N
$num
		O R
,
		R S
$num
		T W
,
		W X
$num
		Y ]
)
		] ^
}
		_ `
,
		` a
{
		 
$str
		 
,
		 
CIELabFromRGB
		< I
(
		I J
$num
		J M
,
		M N
$num
		O R
,
		R S
$num
		T W
,
		W X
$num
		Y ]
)
		] ^
}
		_ `
,
		` a
{
Ÿ	Ÿ	 
$str
Ÿ	Ÿ	 
,
Ÿ	Ÿ	 
CIELabFromRGB
Ÿ	Ÿ	< I
(
Ÿ	Ÿ	I J
$num
Ÿ	Ÿ	J M
,
Ÿ	Ÿ	M N
$num
Ÿ	Ÿ	O R
,
Ÿ	Ÿ	R S
$num
Ÿ	Ÿ	T W
,
Ÿ	Ÿ	W X
$num
Ÿ	Ÿ	Y ]
)
Ÿ	Ÿ	] ^
}
Ÿ	Ÿ	_ `
,
Ÿ	Ÿ	` a
{
 	 	 
$str
 	 	 
,
 	 	 
CIELabFromRGB
 	 	< I
(
 	 	I J
$num
 	 	J M
,
 	 	M N
$num
 	 	O R
,
 	 	R S
$num
 	 	T W
,
 	 	W X
$num
 	 	Y ]
)
 	 	] ^
}
 	 	_ `
,
 	 	` a
{
¡	¡	 
$str
¡	¡	 
,
¡	¡	 
CIELabFromRGB
¡	¡	< I
(
¡	¡	I J
$num
¡	¡	J M
,
¡	¡	M N
$num
¡	¡	O R
,
¡	¡	R S
$num
¡	¡	T V
,
¡	¡	V W
$num
¡	¡	X \
)
¡	¡	\ ]
}
¡	¡	^ _
,
¡	¡	_ `
{
¢	¢	 
$str
¢	¢	 
,
¢	¢	 
CIELabFromRGB
¢	¢	< I
(
¢	¢	I J
$num
¢	¢	J M
,
¢	¢	M N
$num
¢	¢	O R
,
¢	¢	R S
$num
¢	¢	T X
,
¢	¢	X Y
$num
¢	¢	Z ^
)
¢	¢	^ _
}
¢	¢	` a
,
¢	¢	a b
{
£	£	 
$str
£	£	 
,
£	£	 
CIELabFromRGB
£	£	< I
(
£	£	I J
$num
£	£	J M
,
£	£	M N
$num
£	£	O R
,
£	£	R S
$num
£	£	T W
,
£	£	W X
$num
£	£	Y ]
)
£	£	] ^
}
£	£	_ `
,
£	£	` a
{
¤	¤	 
$str
¤	¤	 
,
¤	¤	 
CIELabFromRGB
¤	¤	< I
(
¤	¤	I J
$num
¤	¤	J L
,
¤	¤	L M
$num
¤	¤	N Q
,
¤	¤	Q R
$num
¤	¤	S V
,
¤	¤	V W
$num
¤	¤	X \
)
¤	¤	\ ]
}
¤	¤	^ _
,
¤	¤	_ `
{
¥	¥	 
$str
¥	¥	 
,
¥	¥	 
CIELabFromRGB
¥	¥	< I
(
¥	¥	I J
$num
¥	¥	J M
,
¥	¥	M N
$num
¥	¥	O Q
,
¥	¥	Q R
$num
¥	¥	S V
,
¥	¥	V W
$num
¥	¥	X \
)
¥	¥	\ ]
}
¥	¥	^ _
,
¥	¥	_ `
{
¦	¦	 
$str
¦	¦	 
,
¦	¦	 
CIELabFromRGB
¦	¦	< I
(
¦	¦	I J
$num
¦	¦	J M
,
¦	¦	M N
$num
¦	¦	O R
,
¦	¦	R S
$num
¦	¦	T W
,
¦	¦	W X
$num
¦	¦	Y ]
)
¦	¦	] ^
}
¦	¦	_ `
,
¦	¦	` a
{
§	§	 
$str
§	§	 
,
§	§	 
CIELabFromRGB
§	§	< I
(
§	§	I J
$num
§	§	J M
,
§	§	M N
$num
§	§	O R
,
§	§	R S
$num
§	§	T W
,
§	§	W X
$num
§	§	Y ]
)
§	§	] ^
}
§	§	_ `
,
§	§	` a
{
¨	¨	 
$str
¨	¨	 
,
¨	¨	 
CIELabFromRGB
¨	¨	< I
(
¨	¨	I J
$num
¨	¨	J M
,
¨	¨	M N
$num
¨	¨	O R
,
¨	¨	R S
$num
¨	¨	T W
,
¨	¨	W X
$num
¨	¨	Y ]
)
¨	¨	] ^
}
¨	¨	_ `
,
¨	¨	` a
{
©	©	 
$str
©	©	 
,
©	©	 
CIELabFromRGB
©	©	< I
(
©	©	I J
$num
©	©	J M
,
©	©	M N
$num
©	©	O R
,
©	©	R S
$num
©	©	T W
,
©	©	W X
$num
©	©	Y ]
)
©	©	] ^
}
©	©	_ `
,
©	©	` a
{
ª	ª	 
$str
ª	ª	 
,
ª	ª	 
CIELabFromRGB
ª	ª	< I
(
ª	ª	I J
$num
ª	ª	J N
,
ª	ª	N O
$num
ª	ª	P S
,
ª	ª	S T
$num
ª	ª	U X
,
ª	ª	X Y
$num
ª	ª	Z ^
)
ª	ª	^ _
}
ª	ª	` a
,
ª	ª	a b
{
«	«	 
$str
«	«	 
,
«	«	 
CIELabFromRGB
«	«	< I
(
«	«	I J
$num
«	«	J M
,
«	«	M N
$num
«	«	O R
,
«	«	R S
$num
«	«	T V
,
«	«	V W
$num
«	«	X \
)
«	«	\ ]
}
«	«	^ _
,
«	«	_ `
{
¬	¬	 
$str
¬	¬	 
,
¬	¬	 
CIELabFromRGB
¬	¬	< I
(
¬	¬	I J
$num
¬	¬	J M
,
¬	¬	M N
$num
¬	¬	O R
,
¬	¬	R S
$num
¬	¬	T W
,
¬	¬	W X
$num
¬	¬	Y ]
)
¬	¬	] ^
}
¬	¬	_ `
,
¬	¬	` a
{
­	­	 
$str
­	­	 
,
­	­	 
CIELabFromRGB
­	­	< I
(
­	­	I J
$num
­	­	J M
,
­	­	M N
$num
­	­	O Q
,
­	­	Q R
$num
­	­	S W
,
­	­	W X
$num
­	­	Y ]
)
­	­	] ^
}
­	­	_ `
,
­	­	` a
{
®	®	 
$str
®	®	 
,
®	®	 
CIELabFromRGB
®	®	< I
(
®	®	I J
$num
®	®	J L
,
®	®	L M
$num
®	®	N P
,
®	®	P Q
$num
®	®	R U
,
®	®	U V
$num
®	®	W [
)
®	®	[ \
}
®	®	] ^
,
®	®	^ _
{
¯	¯	 
$str
¯	¯	 
,
¯	¯	 
CIELabFromRGB
¯	¯	< I
(
¯	¯	I J
$num
¯	¯	J L
,
¯	¯	L M
$num
¯	¯	N Q
,
¯	¯	Q R
$num
¯	¯	S V
,
¯	¯	V W
$num
¯	¯	X \
)
¯	¯	\ ]
}
¯	¯	^ _
,
¯	¯	_ `
{
°	°	 
$str
°	°	 
,
°	°	 
CIELabFromRGB
°	°	< I
(
°	°	I J
$num
°	°	J M
,
°	°	M N
$num
°	°	O R
,
°	°	R S
$num
°	°	T W
,
°	°	W X
$num
°	°	Y ]
)
°	°	] ^
}
°	°	_ `
,
°	°	` a
{
±	±	 
$str
±	±	 !
,
±	±	! "
CIELabFromRGB
±	±	< I
(
±	±	I J
$num
±	±	J M
,
±	±	M N
$num
±	±	O Q
,
±	±	Q R
$num
±	±	S V
,
±	±	V W
$num
±	±	X \
)
±	±	\ ]
}
±	±	^ _
,
±	±	_ `
{
²	²	 
$str
²	²	 
,
²	²	 
CIELabFromRGB
²	²	< I
(
²	²	I J
$num
²	²	J M
,
²	²	M N
$num
²	²	O R
,
²	²	R S
$num
²	²	T W
,
²	²	W X
$num
²	²	Y ]
)
²	²	] ^
}
²	²	_ `
,
²	²	` a
{
³	³	 
$str
³	³	 
,
³	³	 
CIELabFromRGB
³	³	< I
(
³	³	I J
$num
³	³	J L
,
³	³	L M
$num
³	³	N Q
,
³	³	Q R
$num
³	³	S V
,
³	³	V W
$num
³	³	X \
)
³	³	\ ]
}
³	³	^ _
,
³	³	_ `
{
´	´	 
$str
´	´	 
,
´	´	 
CIELabFromRGB
´	´	< I
(
´	´	I J
$num
´	´	J M
,
´	´	M N
$num
´	´	O R
,
´	´	R S
$num
´	´	T V
,
´	´	V W
$num
´	´	X \
)
´	´	\ ]
}
´	´	^ _
,
´	´	_ `
{
µ	µ	 
$str
µ	µ	 
,
µ	µ	 
CIELabFromRGB
µ	µ	< I
(
µ	µ	I J
$num
µ	µ	J N
,
µ	µ	N O
$num
µ	µ	P S
,
µ	µ	S T
$num
µ	µ	U X
,
µ	µ	X Y
$num
µ	µ	Z ^
)
µ	µ	^ _
}
µ	µ	` a
,
µ	µ	a b
{
¶	¶	 
$str
¶	¶	 
,
¶	¶	 
CIELabFromRGB
¶	¶	< I
(
¶	¶	I J
$num
¶	¶	J M
,
¶	¶	M N
$num
¶	¶	O R
,
¶	¶	R S
$num
¶	¶	T W
,
¶	¶	W X
$num
¶	¶	Y ]
)
¶	¶	] ^
}
¶	¶	_ `
,
¶	¶	` a
{
·	·	 
$str
·	·	 
,
·	·	 
CIELabFromRGB
·	·	< I
(
·	·	I J
$num
·	·	J N
,
·	·	N O
$num
·	·	P S
,
·	·	S T
$num
·	·	U X
,
·	·	X Y
$num
·	·	Z ^
)
·	·	^ _
}
·	·	` a
,
·	·	a b
{
¸	¸	 
$str
¸	¸	 
,
¸	¸	 
CIELabFromRGB
¸	¸	< I
(
¸	¸	I J
$num
¸	¸	J M
,
¸	¸	M N
$num
¸	¸	O R
,
¸	¸	R S
$num
¸	¸	T W
,
¸	¸	W X
$num
¸	¸	Y ]
)
¸	¸	] ^
}
¸	¸	_ `
,
¸	¸	` a
{
¹	¹	 
$str
¹	¹	 
,
¹	¹	 
CIELabFromRGB
¹	¹	< I
(
¹	¹	I J
$num
¹	¹	J N
,
¹	¹	N O
$num
¹	¹	P S
,
¹	¹	S T
$num
¹	¹	U X
,
¹	¹	X Y
$num
¹	¹	Z ^
)
¹	¹	^ _
}
¹	¹	` a
,
¹	¹	a b
{
º	º	 
$str
º	º	 
,
º	º	 
CIELabFromRGB
º	º	< I
(
º	º	I J
$num
º	º	J M
,
º	º	M N
$num
º	º	O R
,
º	º	R S
$num
º	º	T W
,
º	º	W X
$num
º	º	Y ]
)
º	º	] ^
}
º	º	_ `
,
º	º	` a
{
»	»	 
$str
»	»	 
,
»	»	 
CIELabFromRGB
»	»	< I
(
»	»	I J
$num
»	»	J M
,
»	»	M N
$num
»	»	O Q
,
»	»	Q R
$num
»	»	S V
,
»	»	V W
$num
»	»	X \
)
»	»	\ ]
}
»	»	^ _
,
»	»	_ `
{
¼	¼	 
$str
¼	¼	 
,
¼	¼	 
CIELabFromRGB
¼	¼	< I
(
¼	¼	I J
$num
¼	¼	J M
,
¼	¼	M N
$num
¼	¼	O R
,
¼	¼	R S
$num
¼	¼	T W
,
¼	¼	W X
$num
¼	¼	Y ]
)
¼	¼	] ^
}
¼	¼	_ `
,
¼	¼	` a
{
½	½	 
$str
½	½	 
,
½	½	 
CIELabFromRGB
½	½	< I
(
½	½	I J
$num
½	½	J M
,
½	½	M N
$num
½	½	O R
,
½	½	R S
$num
½	½	T W
,
½	½	W X
$num
½	½	Y ]
)
½	½	] ^
}
½	½	_ `
,
½	½	` a
{
¾	¾	 
$str
¾	¾	 
,
¾	¾	 
CIELabFromRGB
¾	¾	< I
(
¾	¾	I J
$num
¾	¾	J M
,
¾	¾	M N
$num
¾	¾	O R
,
¾	¾	R S
$num
¾	¾	T W
,
¾	¾	W X
$num
¾	¾	Y ]
)
¾	¾	] ^
}
¾	¾	_ `
,
¾	¾	` a
{
¿	¿	 
$str
¿	¿	 
,
¿	¿	 
CIELabFromRGB
¿	¿	< I
(
¿	¿	I J
$num
¿	¿	J M
,
¿	¿	M N
$num
¿	¿	O R
,
¿	¿	R S
$num
¿	¿	T W
,
¿	¿	W X
$num
¿	¿	Y ]
)
¿	¿	] ^
}
¿	¿	_ `
,
¿	¿	` a
{
À	À	 
$str
À	À	 
,
À	À	 
CIELabFromRGB
À	À	< I
(
À	À	I J
$num
À	À	J M
,
À	À	M N
$num
À	À	O R
,
À	À	R S
$num
À	À	T W
,
À	À	W X
$num
À	À	Y ]
)
À	À	] ^
}
À	À	_ `
,
À	À	` a
{
Á	Á	 
$str
Á	Á	 
,
Á	Á	 
CIELabFromRGB
Á	Á	< I
(
Á	Á	I J
$num
Á	Á	J M
,
Á	Á	M N
$num
Á	Á	O R
,
Á	Á	R S
$num
Á	Á	T W
,
Á	Á	W X
$num
Á	Á	Y ]
)
Á	Á	] ^
}
Á	Á	_ `
,
Á	Á	` a
{
Â	Â	 
$str
Â	Â	 
,
Â	Â	 
CIELabFromRGB
Â	Â	< I
(
Â	Â	I J
$num
Â	Â	J M
,
Â	Â	M N
$num
Â	Â	O R
,
Â	Â	R S
$num
Â	Â	T W
,
Â	Â	W X
$num
Â	Â	Y ]
)
Â	Â	] ^
}
Â	Â	_ `
,
Â	Â	` a
{
Ã	Ã	 
$str
Ã	Ã	 
,
Ã	Ã	  
CIELabFromRGB
Ã	Ã	< I
(
Ã	Ã	I J
$num
Ã	Ã	J N
,
Ã	Ã	N O
$num
Ã	Ã	P S
,
Ã	Ã	S T
$num
Ã	Ã	U X
,
Ã	Ã	X Y
$num
Ã	Ã	Z ^
)
Ã	Ã	^ _
}
Ã	Ã	` a
,
Ã	Ã	a b
{
Ä	Ä	 
$str
Ä	Ä	 
,
Ä	Ä	 
CIELabFromRGB
Ä	Ä	< I
(
Ä	Ä	I J
$num
Ä	Ä	J M
,
Ä	Ä	M N
$num
Ä	Ä	O R
,
Ä	Ä	R S
$num
Ä	Ä	T W
,
Ä	Ä	W X
$num
Ä	Ä	Y ]
)
Ä	Ä	] ^
}
Ä	Ä	_ `
,
Ä	Ä	` a
{
Å	Å	 
$str
Å	Å	  
,
Å	Å	  !
CIELabFromRGB
Å	Å	< I
(
Å	Å	I J
$num
Å	Å	J M
,
Å	Å	M N
$num
Å	Å	O R
,
Å	Å	R S
$num
Å	Å	T W
,
Å	Å	W X
$num
Å	Å	Y ]
)
Å	Å	] ^
}
Å	Å	_ `
,
Å	Å	` a
{
Æ	Æ	 
$str
Æ	Æ	 
,
Æ	Æ	 
CIELabFromRGB
Æ	Æ	< I
(
Æ	Æ	I J
$num
Æ	Æ	J M
,
Æ	Æ	M N
$num
Æ	Æ	O R
,
Æ	Æ	R S
$num
Æ	Æ	T W
,
Æ	Æ	W X
$num
Æ	Æ	Y ]
)
Æ	Æ	] ^
}
Æ	Æ	_ `
,
Æ	Æ	` a
{
Ç	Ç	 
$str
Ç	Ç	 
,
Ç	Ç	 
CIELabFromRGB
Ç	Ç	< I
(
Ç	Ç	I J
$num
Ç	Ç	J L
,
Ç	Ç	L M
$num
Ç	Ç	N Q
,
Ç	Ç	Q R
$num
Ç	Ç	S V
,
Ç	Ç	V W
$num
Ç	Ç	X \
)
Ç	Ç	\ ]
}
Ç	Ç	^ _
,
Ç	Ç	_ `
{
È	È	 
$str
È	È	 "
,
È	È	" #
CIELabFromRGB
È	È	< I
(
È	È	I J
$num
È	È	J M
,
È	È	M N
$num
È	È	O Q
,
È	È	Q R
$num
È	È	S W
,
È	È	W X
$num
È	È	Y ]
)
È	È	] ^
}
È	È	_ `
,
È	È	` a
{
É	É	 
$str
É	É	 
,
É	É	 
CIELabFromRGB
É	É	< I
(
É	É	I J
$num
É	É	J M
,
É	É	M N
$num
É	É	O R
,
É	É	R S
$num
É	É	T W
,
É	É	W X
$num
É	É	Y ]
)
É	É	] ^
}
É	É	_ `
,
É	É	` a
{
Ê	Ê	 
$str
Ê	Ê	 
,
Ê	Ê	 
CIELabFromRGB
Ê	Ê	< I
(
Ê	Ê	I J
$num
Ê	Ê	J M
,
Ê	Ê	M N
$num
Ê	Ê	O R
,
Ê	Ê	R S
$num
Ê	Ê	T W
,
Ê	Ê	W X
$num
Ê	Ê	Y ]
)
Ê	Ê	] ^
}
Ê	Ê	_ `
,
Ê	Ê	` a
{
Ë	Ë	 
$str
Ë	Ë	 )
,
Ë	Ë	) *
CIELabFromRGB
Ë	Ë	< I
(
Ë	Ë	I J
$num
Ë	Ë	J M
,
Ë	Ë	M N
$num
Ë	Ë	O R
,
Ë	Ë	R S
$num
Ë	Ë	T V
,
Ë	Ë	V W
$num
Ë	Ë	X \
)
Ë	Ë	\ ]
}
Ë	Ë	^ _
,
Ë	Ë	_ `
{
Ì	Ì	 
$str
Ì	Ì	 
,
Ì	Ì	 
CIELabFromRGB
Ì	Ì	< I
(
Ì	Ì	I J
$num
Ì	Ì	J M
,
Ì	Ì	M N
$num
Ì	Ì	O R
,
Ì	Ì	R S
$num
Ì	Ì	T W
,
Ì	Ì	W X
$num
Ì	Ì	Y ]
)
Ì	Ì	] ^
}
Ì	Ì	_ `
,
Ì	Ì	` a
{
Í	Í	 
$str
Í	Í	 
,
Í	Í	 
CIELabFromRGB
Í	Í	< I
(
Í	Í	I J
$num
Í	Í	J N
,
Í	Í	N O
$num
Í	Í	P S
,
Í	Í	S T
$num
Í	Í	U W
,
Í	Í	W X
$num
Í	Í	Y ]
)
Í	Í	] ^
}
Í	Í	_ `
,
Í	Í	` a
{
Î	Î	 
$str
Î	Î	 
,
Î	Î	 
CIELabFromRGB
Î	Î	< I
(
Î	Î	I J
$num
Î	Î	J M
,
Î	Î	M N
$num
Î	Î	O Q
,
Î	Î	Q R
$num
Î	Î	S V
,
Î	Î	V W
$num
Î	Î	X \
)
Î	Î	\ ]
}
Î	Î	^ _
,
Î	Î	_ `
{
Ï	Ï	 
$str
Ï	Ï	  
,
Ï	Ï	  !
CIELabFromRGB
Ï	Ï	< I
(
Ï	Ï	I J
$num
Ï	Ï	J M
,
Ï	Ï	M N
$num
Ï	Ï	O Q
,
Ï	Ï	Q R
$num
Ï	Ï	S V
,
Ï	Ï	V W
$num
Ï	Ï	X \
)
Ï	Ï	\ ]
}
Ï	Ï	^ _
,
Ï	Ï	_ `
{
Ğ	Ğ	 
$str
Ğ	Ğ	 
,
Ğ	Ğ	 
CIELabFromRGB
Ğ	Ğ	< I
(
Ğ	Ğ	I J
$num
Ğ	Ğ	J M
,
Ğ	Ğ	M N
$num
Ğ	Ğ	O R
,
Ğ	Ğ	R S
$num
Ğ	Ğ	T W
,
Ğ	Ğ	W X
$num
Ğ	Ğ	Y ]
)
Ğ	Ğ	] ^
}
Ğ	Ğ	_ `
,
Ğ	Ğ	` a
{
Ñ	Ñ	 
$str
Ñ	Ñ	 
,
Ñ	Ñ	 
CIELabFromRGB
Ñ	Ñ	< I
(
Ñ	Ñ	I J
$num
Ñ	Ñ	J M
,
Ñ	Ñ	M N
$num
Ñ	Ñ	O R
,
Ñ	Ñ	R S
$num
Ñ	Ñ	T W
,
Ñ	Ñ	W X
$num
Ñ	Ñ	Y ]
)
Ñ	Ñ	] ^
}
Ñ	Ñ	_ `
,
Ñ	Ñ	` a
{
Ò	Ò	 
$str
Ò	Ò	 '
,
Ò	Ò	' (
CIELabFromRGB
Ò	Ò	< I
(
Ò	Ò	I J
$num
Ò	Ò	J M
,
Ò	Ò	M N
$num
Ò	Ò	O R
,
Ò	Ò	R S
$num
Ò	Ò	T W
,
Ò	Ò	W X
$num
Ò	Ò	Y ]
)
Ò	Ò	] ^
}
Ò	Ò	_ `
,
Ò	Ò	` a
{
Ó	Ó	 
$str
Ó	Ó	 
,
Ó	Ó	 
CIELabFromRGB
Ó	Ó	< I
(
Ó	Ó	I J
$num
Ó	Ó	J M
,
Ó	Ó	M N
$num
Ó	Ó	O R
,
Ó	Ó	R S
$num
Ó	Ó	T W
,
Ó	Ó	W X
$num
Ó	Ó	Y ]
)
Ó	Ó	] ^
}
Ó	Ó	_ `
,
Ó	Ó	` a
{
Ô	Ô	 
$str
Ô	Ô	 
,
Ô	Ô	 
CIELabFromRGB
Ô	Ô	< I
(
Ô	Ô	I J
$num
Ô	Ô	J N
,
Ô	Ô	N O
$num
Ô	Ô	P S
,
Ô	Ô	S T
$num
Ô	Ô	U X
,
Ô	Ô	X Y
$num
Ô	Ô	Z ^
)
Ô	Ô	^ _
}
Ô	Ô	` a
,
Ô	Ô	a b
{
Õ	Õ	 
$str
Õ	Õ	 
,
Õ	Õ	 
CIELabFromRGB
Õ	Õ	< I
(
Õ	Õ	I J
$num
Õ	Õ	J M
,
Õ	Õ	M N
$num
Õ	Õ	O R
,
Õ	Õ	R S
$num
Õ	Õ	T W
,
Õ	Õ	W X
$num
Õ	Õ	Y ]
)
Õ	Õ	] ^
}
Õ	Õ	_ `
,
Õ	Õ	` a
{
Ö	Ö	 
$str
Ö	Ö	 
,
Ö	Ö	 
CIELabFromRGB
Ö	Ö	< I
(
Ö	Ö	I J
$num
Ö	Ö	J M
,
Ö	Ö	M N
$num
Ö	Ö	O R
,
Ö	Ö	R S
$num
Ö	Ö	T W
,
Ö	Ö	W X
$num
Ö	Ö	Y ]
)
Ö	Ö	] ^
}
Ö	Ö	_ `
,
Ö	Ö	` a
{
×	×	 
$str
×	×	 
,
×	×	 
CIELabFromRGB
×	×	< I
(
×	×	I J
$num
×	×	J M
,
×	×	M N
$num
×	×	O R
,
×	×	R S
$num
×	×	T W
,
×	×	W X
$num
×	×	Y ]
)
×	×	] ^
}
×	×	_ `
,
×	×	` a
{
Ø	Ø	 
$str
Ø	Ø	 
,
Ø	Ø	 
CIELabFromRGB
Ø	Ø	< I
(
Ø	Ø	I J
$num
Ø	Ø	J M
,
Ø	Ø	M N
$num
Ø	Ø	O R
,
Ø	Ø	R S
$num
Ø	Ø	T W
,
Ø	Ø	W X
$num
Ø	Ø	Y ]
)
Ø	Ø	] ^
}
Ø	Ø	_ `
,
Ø	Ø	` a
{
Ù	Ù	 
$str
Ù	Ù	 
,
Ù	Ù	 
CIELabFromRGB
Ù	Ù	< I
(
Ù	Ù	I J
$num
Ù	Ù	J M
,
Ù	Ù	M N
$num
Ù	Ù	O R
,
Ù	Ù	R S
$num
Ù	Ù	T W
,
Ù	Ù	W X
$num
Ù	Ù	Y ]
)
Ù	Ù	] ^
}
Ù	Ù	_ `
,
Ù	Ù	` a
{
Ú	Ú	 
$str
Ú	Ú	 $
,
Ú	Ú	$ %
CIELabFromRGB
Ú	Ú	< I
(
Ú	Ú	I J
$num
Ú	Ú	J M
,
Ú	Ú	M N
$num
Ú	Ú	O R
,
Ú	Ú	R S
$num
Ú	Ú	T W
,
Ú	Ú	W X
$num
Ú	Ú	Y ]
)
Ú	Ú	] ^
}
Ú	Ú	_ `
,
Ú	Ú	` a
{
Û	Û	 
$str
Û	Û	 
,
Û	Û	 
CIELabFromRGB
Û	Û	< I
(
Û	Û	I J
$num
Û	Û	J M
,
Û	Û	M N
$num
Û	Û	O R
,
Û	Û	R S
$num
Û	Û	T W
,
Û	Û	W X
$num
Û	Û	Y ]
)
Û	Û	] ^
}
Û	Û	_ `
,
Û	Û	` a
{
Ü	Ü	 
$str
Ü	Ü	 
,
Ü	Ü	 
CIELabFromRGB
Ü	Ü	< I
(
Ü	Ü	I J
$num
Ü	Ü	J N
,
Ü	Ü	N O
$num
Ü	Ü	P S
,
Ü	Ü	S T
$num
Ü	Ü	U X
,
Ü	Ü	X Y
$num
Ü	Ü	Z ^
)
Ü	Ü	^ _
}
Ü	Ü	` a
,
Ü	Ü	a b
{
İ	İ	 
$str
İ	İ	 
,
İ	İ	 
CIELabFromRGB
İ	İ	< I
(
İ	İ	I J
$num
İ	İ	J M
,
İ	İ	M N
$num
İ	İ	O R
,
İ	İ	R S
$num
İ	İ	T W
,
İ	İ	W X
$num
İ	İ	Y ]
)
İ	İ	] ^
}
İ	İ	_ `
,
İ	İ	` a
{
Ş	Ş	 
$str
Ş	Ş	 
,
Ş	Ş	 
CIELabFromRGB
Ş	Ş	< I
(
Ş	Ş	I J
$num
Ş	Ş	J M
,
Ş	Ş	M N
$num
Ş	Ş	O Q
,
Ş	Ş	Q R
$num
Ş	Ş	S V
,
Ş	Ş	V W
$num
Ş	Ş	X \
)
Ş	Ş	\ ]
}
Ş	Ş	^ _
,
Ş	Ş	_ `
{
ß	ß	 
$str
ß	ß	 
,
ß	ß	  
CIELabFromRGB
ß	ß	< I
(
ß	ß	I J
$num
ß	ß	J M
,
ß	ß	M N
$num
ß	ß	O R
,
ß	ß	R S
$num
ß	ß	T W
,
ß	ß	W X
$num
ß	ß	Y ]
)
ß	ß	] ^
}
ß	ß	_ `
,
ß	ß	` a
{
à	à	 
$str
à	à	 
,
à	à	 
CIELabFromRGB
à	à	< I
(
à	à	I J
$num
à	à	J M
,
à	à	M N
$num
à	à	O R
,
à	à	R S
$num
à	à	T W
,
à	à	W X
$num
à	à	Y ]
)
à	à	] ^
}
à	à	_ `
,
à	à	` a
{
á	á	 
$str
á	á	 
,
á	á	 
CIELabFromRGB
á	á	< I
(
á	á	I J
$num
á	á	J M
,
á	á	M N
$num
á	á	O R
,
á	á	R S
$num
á	á	T W
,
á	á	W X
$num
á	á	Y ]
)
á	á	] ^
}
á	á	_ `
,
á	á	` a
{
â	â	 
$str
â	â	 
,
â	â	 
CIELabFromRGB
â	â	< I
(
â	â	I J
$num
â	â	J M
,
â	â	M N
$num
â	â	O R
,
â	â	R S
$num
â	â	T W
,
â	â	W X
$num
â	â	Y ]
)
â	â	] ^
}
â	â	_ `
,
â	â	` a
{
ã	ã	 
$str
ã	ã	 "
,
ã	ã	" #
CIELabFromRGB
ã	ã	< I
(
ã	ã	I J
$num
ã	ã	J N
,
ã	ã	N O
$num
ã	ã	P S
,
ã	ã	S T
$num
ã	ã	U X
,
ã	ã	X Y
$num
ã	ã	Z ^
)
ã	ã	^ _
}
ã	ã	` a
,
ã	ã	a b
{
ä	ä	 
$str
ä	ä	 
,
ä	ä	 
CIELabFromRGB
ä	ä	< I
(
ä	ä	I J
$num
ä	ä	J M
,
ä	ä	M N
$num
ä	ä	O R
,
ä	ä	R S
$num
ä	ä	T W
,
ä	ä	W X
$num
ä	ä	Y ]
)
ä	ä	] ^
}
ä	ä	_ `
,
ä	ä	` a
{
å	å	 
$str
å	å	 
,
å	å	 
CIELabFromRGB
å	å	< I
(
å	å	I J
$num
å	å	J M
,
å	å	M N
$num
å	å	O R
,
å	å	R S
$num
å	å	T W
,
å	å	W X
$num
å	å	Y ]
)
å	å	] ^
}
å	å	_ `
,
å	å	` a
{
æ	æ	 
$str
æ	æ	 
,
æ	æ	 
CIELabFromRGB
æ	æ	< I
(
æ	æ	I J
$num
æ	æ	J M
,
æ	æ	M N
$num
æ	æ	O R
,
æ	æ	R S
$num
æ	æ	T W
,
æ	æ	W X
$num
æ	æ	Y ]
)
æ	æ	] ^
}
æ	æ	_ `
,
æ	æ	` a
{
ç	ç	 
$str
ç	ç	 
,
ç	ç	 
CIELabFromRGB
ç	ç	< I
(
ç	ç	I J
$num
ç	ç	J N
,
ç	ç	N O
$num
ç	ç	P R
,
ç	ç	R S
$num
ç	ç	T V
,
ç	ç	V W
$num
ç	ç	X \
)
ç	ç	\ ]
}
ç	ç	^ _
,
ç	ç	_ `
{
è	è	 
$str
è	è	 
,
è	è	 
CIELabFromRGB
è	è	< I
(
è	è	I J
$num
è	è	J M
,
è	è	M N
$num
è	è	O R
,
è	è	R S
$num
è	è	T W
,
è	è	W X
$num
è	è	Y ]
)
è	è	] ^
}
è	è	_ `
,
è	è	` a
{
é	é	 
$str
é	é	 
,
é	é	 
CIELabFromRGB
é	é	< I
(
é	é	I J
$num
é	é	J M
,
é	é	M N
$num
é	é	O Q
,
é	é	Q R
$num
é	é	S V
,
é	é	V W
$num
é	é	X \
)
é	é	\ ]
}
é	é	^ _
,
é	é	_ `
{
ê	ê	 
$str
ê	ê	 
,
ê	ê	 
CIELabFromRGB
ê	ê	< I
(
ê	ê	I J
$num
ê	ê	J M
,
ê	ê	M N
$num
ê	ê	O Q
,
ê	ê	Q R
$num
ê	ê	S V
,
ê	ê	V W
$num
ê	ê	X \
)
ê	ê	\ ]
}
ê	ê	^ _
,
ê	ê	_ `
{
ë	ë	 
$str
ë	ë	 
,
ë	ë	 
CIELabFromRGB
ë	ë	< I
(
ë	ë	I J
$num
ë	ë	J M
,
ë	ë	M N
$num
ë	ë	O R
,
ë	ë	R S
$num
ë	ë	T W
,
ë	ë	W X
$num
ë	ë	Y ]
)
ë	ë	] ^
}
ë	ë	_ `
,
ë	ë	` a
{
ì	ì	 
$str
ì	ì	 
,
ì	ì	 
CIELabFromRGB
ì	ì	< I
(
ì	ì	I J
$num
ì	ì	J M
,
ì	ì	M N
$num
ì	ì	O R
,
ì	ì	R S
$num
ì	ì	T W
,
ì	ì	W X
$num
ì	ì	Y ]
)
ì	ì	] ^
}
ì	ì	_ `
,
ì	ì	` a
{
í	í	 
$str
í	í	 
,
í	í	 
CIELabFromRGB
í	í	< I
(
í	í	I J
$num
í	í	J N
,
í	í	N O
$num
í	í	P S
,
í	í	S T
$num
í	í	U W
,
í	í	W X
$num
í	í	Y ]
)
í	í	] ^
}
í	í	_ `
,
í	í	` a
{
î	î	 
$str
î	î	 
,
î	î	 
CIELabFromRGB
î	î	< I
(
î	î	I J
$num
î	î	J M
,
î	î	M N
$num
î	î	O R
,
î	î	R S
$num
î	î	T W
,
î	î	W X
$num
î	î	Y ]
)
î	î	] ^
}
î	î	_ `
,
î	î	` a
{
ï	ï	 
$str
ï	ï	 
,
ï	ï	 
CIELabFromRGB
ï	ï	< I
(
ï	ï	I J
$num
ï	ï	J M
,
ï	ï	M N
$num
ï	ï	O Q
,
ï	ï	Q R
$num
ï	ï	S U
,
ï	ï	U V
$num
ï	ï	W [
)
ï	ï	[ \
}
ï	ï	] ^
,
ï	ï	^ _
{
ğ	ğ	 
$str
ğ	ğ	 
,
ğ	ğ	 
CIELabFromRGB
ğ	ğ	< I
(
ğ	ğ	I J
$num
ğ	ğ	J N
,
ğ	ğ	N O
$num
ğ	ğ	P S
,
ğ	ğ	S T
$num
ğ	ğ	U X
,
ğ	ğ	X Y
$num
ğ	ğ	Z ^
)
ğ	ğ	^ _
}
ğ	ğ	` a
,
ğ	ğ	a b
{
ñ	ñ	 
$str
ñ	ñ	 
,
ñ	ñ	 
CIELabFromRGB
ñ	ñ	< I
(
ñ	ñ	I J
$num
ñ	ñ	J M
,
ñ	ñ	M N
$num
ñ	ñ	O Q
,
ñ	ñ	Q R
$num
ñ	ñ	S V
,
ñ	ñ	V W
$num
ñ	ñ	X \
)
ñ	ñ	\ ]
}
ñ	ñ	^ _
,
ñ	ñ	_ `
{
ò	ò	 
$str
ò	ò	 
,
ò	ò	 
CIELabFromRGB
ò	ò	< I
(
ò	ò	I J
$num
ò	ò	J M
,
ò	ò	M N
$num
ò	ò	O Q
,
ò	ò	Q R
$num
ò	ò	S V
,
ò	ò	V W
$num
ò	ò	X \
)
ò	ò	\ ]
}
ò	ò	^ _
,
ò	ò	_ `
{
ó	ó	 
$str
ó	ó	 
,
ó	ó	 
CIELabFromRGB
ó	ó	< I
(
ó	ó	I J
$num
ó	ó	J M
,
ó	ó	M N
$num
ó	ó	O R
,
ó	ó	R S
$num
ó	ó	T W
,
ó	ó	W X
$num
ó	ó	Y ]
)
ó	ó	] ^
}
ó	ó	_ `
,
ó	ó	` a
{
ô	ô	 
$str
ô	ô	 
,
ô	ô	 
CIELabFromRGB
ô	ô	< I
(
ô	ô	I J
$num
ô	ô	J M
,
ô	ô	M N
$num
ô	ô	O R
,
ô	ô	R S
$num
ô	ô	T W
,
ô	ô	W X
$num
ô	ô	Y ]
)
ô	ô	] ^
}
ô	ô	_ `
,
ô	ô	` a
{
õ	õ	 
$str
õ	õ	 "
,
õ	õ	" #
CIELabFromRGB
õ	õ	< I
(
õ	õ	I J
$num
õ	õ	J L
,
õ	õ	L M
$num
õ	õ	N P
,
õ	õ	P Q
$num
õ	õ	R T
,
õ	õ	T U
$num
õ	õ	V Z
)
õ	õ	Z [
}
õ	õ	\ ]
,
õ	õ	] ^
{
ö	ö	 
$str
ö	ö	 
,
ö	ö	  
CIELabFromRGB
ö	ö	< I
(
ö	ö	I J
$num
ö	ö	J L
,
ö	ö	L M
$num
ö	ö	N Q
,
ö	ö	Q R
$num
ö	ö	S V
,
ö	ö	V W
$num
ö	ö	X \
)
ö	ö	\ ]
}
ö	ö	^ _
,
ö	ö	_ `
{
÷	÷	 
$str
÷	÷	 
,
÷	÷	 
CIELabFromRGB
÷	÷	< I
(
÷	÷	I J
$num
÷	÷	J M
,
÷	÷	M N
$num
÷	÷	O R
,
÷	÷	R S
$num
÷	÷	T W
,
÷	÷	W X
$num
÷	÷	Y ]
)
÷	÷	] ^
}
÷	÷	_ `
,
÷	÷	` a
{
ø	ø	 
$str
ø	ø	 
,
ø	ø	 
CIELabFromRGB
ø	ø	< I
(
ø	ø	I J
$num
ø	ø	J L
,
ø	ø	L M
$num
ø	ø	N Q
,
ø	ø	Q R
$num
ø	ø	S V
,
ø	ø	V W
$num
ø	ø	X \
)
ø	ø	\ ]
}
ø	ø	^ _
,
ø	ø	_ `
{
ù	ù	 
$str
ù	ù	 $
,
ù	ù	$ %
CIELabFromRGB
ù	ù	< I
(
ù	ù	I J
$num
ù	ù	J L
,
ù	ù	L M
$num
ù	ù	N P
,
ù	ù	P Q
$num
ù	ù	R T
,
ù	ù	T U
$num
ù	ù	V Z
)
ù	ù	Z [
}
ù	ù	\ ]
,
ù	ù	] ^
{
ú	ú	 
$str
ú	ú	 $
,
ú	ú	$ %
CIELabFromRGB
ú	ú	< I
(
ú	ú	I J
$num
ú	ú	J L
,
ú	ú	L M
$num
ú	ú	N P
,
ú	ú	P Q
$num
ú	ú	R T
,
ú	ú	T U
$num
ú	ú	V Z
)
ú	ú	Z [
}
ú	ú	\ ]
,
ú	ú	] ^
{
û	û	 
$str
û	û	 '
,
û	û	' (
CIELabFromRGB
û	û	< I
(
û	û	I J
$num
û	û	J M
,
û	û	M N
$num
û	û	O R
,
û	û	R S
$num
û	û	T X
,
û	û	X Y
$num
û	û	Z ^
)
û	û	^ _
}
û	û	` a
,
û	û	a b
{
ü	ü	 
$str
ü	ü	 
,
ü	ü	 
CIELabFromRGB
ü	ü	< I
(
ü	ü	I J
$num
ü	ü	J M
,
ü	ü	M N
$num
ü	ü	O Q
,
ü	ü	Q R
$num
ü	ü	S V
,
ü	ü	V W
$num
ü	ü	X \
)
ü	ü	\ ]
}
ü	ü	^ _
,
ü	ü	_ `
{
ı	ı	 
$str
ı	ı	 "
,
ı	ı	" #
CIELabFromRGB
ı	ı	< I
(
ı	ı	I J
$num
ı	ı	J L
,
ı	ı	L M
$num
ı	ı	N Q
,
ı	ı	Q R
$num
ı	ı	S V
,
ı	ı	V W
$num
ı	ı	X \
)
ı	ı	\ ]
}
ı	ı	^ _
,
ı	ı	_ `
{
ş	ş	 
$str
ş	ş	 
,
ş	ş	 
CIELabFromRGB
ş	ş	< I
(
ş	ş	I J
$num
ş	ş	J M
,
ş	ş	M N
$num
ş	ş	O R
,
ş	ş	R S
$num
ş	ş	T W
,
ş	ş	W X
$num
ş	ş	Y ]
)
ş	ş	] ^
}
ş	ş	_ `
,
ş	ş	` a
{
ÿ	ÿ	 
$str
ÿ	ÿ	 
,
ÿ	ÿ	 
CIELabFromRGB
ÿ	ÿ	< I
(
ÿ	ÿ	I J
$num
ÿ	ÿ	J M
,
ÿ	ÿ	M N
$num
ÿ	ÿ	O R
,
ÿ	ÿ	R S
$num
ÿ	ÿ	T W
,
ÿ	ÿ	W X
$num
ÿ	ÿ	Y ]
)
ÿ	ÿ	] ^
}
ÿ	ÿ	_ `
,
ÿ	ÿ	` a
{
€
€
 
$str
€
€
 
,
€
€
 
CIELabFromRGB
€
€
< I
(
€
€
I J
$num
€
€
J M
,
€
€
M N
$num
€
€
O R
,
€
€
R S
$num
€
€
T W
,
€
€
W X
$num
€
€
Y ]
)
€
€
] ^
}
€
€
_ `
,
€
€
` a
{


 
$str


 
,


 
CIELabFromRGB


< I
(


I J
$num


J M
,


M N
$num


O R
,


R S
$num


T W
,


W X
$num


Y ]
)


] ^
}


_ `
,


` a
{
‚
‚
 
$str
‚
‚
 
,
‚
‚
 
CIELabFromRGB
‚
‚
< I
(
‚
‚
I J
$num
‚
‚
J M
,
‚
‚
M N
$num
‚
‚
O R
,
‚
‚
R S
$num
‚
‚
T W
,
‚
‚
W X
$num
‚
‚
Y ]
)
‚
‚
] ^
}
‚
‚
_ `
,
‚
‚
` a
{
ƒ
ƒ
 
$str
ƒ
ƒ
 
,
ƒ
ƒ
 
CIELabFromRGB
ƒ
ƒ
< I
(
ƒ
ƒ
I J
$num
ƒ
ƒ
J L
,
ƒ
ƒ
L M
$num
ƒ
ƒ
N Q
,
ƒ
ƒ
Q R
$num
ƒ
ƒ
S V
,
ƒ
ƒ
V W
$num
ƒ
ƒ
X \
)
ƒ
ƒ
\ ]
}
ƒ
ƒ
^ _
,
ƒ
ƒ
_ `
{
„
„
 
$str
„
„
 
,
„
„
  
CIELabFromRGB
„
„
< I
(
„
„
I J
$num
„
„
J M
,
„
„
M N
$num
„
„
O R
,
„
„
R S
$num
„
„
T W
,
„
„
W X
$num
„
„
Y ]
)
„
„
] ^
}
„
„
_ `
,
„
„
` a
{
…
…
 
$str
…
…
 
,
…
…
 
CIELabFromRGB
…
…
< I
(
…
…
I J
$num
…
…
J M
,
…
…
M N
$num
…
…
O R
,
…
…
R S
$num
…
…
T W
,
…
…
W X
$num
…
…
Y ]
)
…
…
] ^
}
…
…
_ `
,
…
…
` a
{
†
†
 
$str
†
†
 
,
†
†
 
CIELabFromRGB
†
†
< I
(
†
†
I J
$num
†
†
J N
,
†
†
N O
$num
†
†
P R
,
†
†
R S
$num
†
†
T W
,
†
†
W X
$num
†
†
Y ]
)
†
†
] ^
}
†
†
_ `
,
†
†
` a
{
‡
‡
 
$str
‡
‡
 
,
‡
‡
 
CIELabFromRGB
‡
‡
< I
(
‡
‡
I J
$num
‡
‡
J M
,
‡
‡
M N
$num
‡
‡
O R
,
‡
‡
R S
$num
‡
‡
T W
,
‡
‡
W X
$num
‡
‡
Y ]
)
‡
‡
] ^
}
‡
‡
_ `
,
‡
‡
` a
{
ˆ
ˆ
 
$str
ˆ
ˆ
 
,
ˆ
ˆ
 
CIELabFromRGB
ˆ
ˆ
< I
(
ˆ
ˆ
I J
$num
ˆ
ˆ
J M
,
ˆ
ˆ
M N
$num
ˆ
ˆ
O R
,
ˆ
ˆ
R S
$num
ˆ
ˆ
T W
,
ˆ
ˆ
W X
$num
ˆ
ˆ
Y ]
)
ˆ
ˆ
] ^
}
ˆ
ˆ
_ `
,
ˆ
ˆ
` a
{
‰
‰
 
$str
‰
‰
 
,
‰
‰
 
CIELabFromRGB
‰
‰
< I
(
‰
‰
I J
$num
‰
‰
J M
,
‰
‰
M N
$num
‰
‰
O R
,
‰
‰
R S
$num
‰
‰
T W
,
‰
‰
W X
$num
‰
‰
Y ]
)
‰
‰
] ^
}
‰
‰
_ `
,
‰
‰
` a
{
Š
Š
 
$str
Š
Š
 
,
Š
Š
 
CIELabFromRGB
Š
Š
< I
(
Š
Š
I J
$num
Š
Š
J M
,
Š
Š
M N
$num
Š
Š
O R
,
Š
Š
R S
$num
Š
Š
T W
,
Š
Š
W X
$num
Š
Š
Y ]
)
Š
Š
] ^
}
Š
Š
_ `
,
Š
Š
` a
{
‹
‹
 
$str
‹
‹
 
,
‹
‹
 
CIELabFromRGB
‹
‹
< I
(
‹
‹
I J
$num
‹
‹
J N
,
‹
‹
N O
$num
‹
‹
P S
,
‹
‹
S T
$num
‹
‹
U X
,
‹
‹
X Y
$num
‹
‹
Z ^
)
‹
‹
^ _
}
‹
‹
` a
,
‹
‹
a b
{
Œ
Œ
 
$str
Œ
Œ
 
,
Œ
Œ
 
CIELabFromRGB
Œ
Œ
< I
(
Œ
Œ
I J
$num
Œ
Œ
J M
,
Œ
Œ
M N
$num
Œ
Œ
O R
,
Œ
Œ
R S
$num
Œ
Œ
T W
,
Œ
Œ
W X
$num
Œ
Œ
Y ]
)
Œ
Œ
] ^
}
Œ
Œ
_ `
,
Œ
Œ
` a
{


 
$str


 
,


 
CIELabFromRGB


< I
(


I J
$num


J M
,


M N
$num


O R
,


R S
$num


T W
,


W X
$num


Y ]
)


] ^
}


_ `
,


` a
{


 
$str


 
,


 
CIELabFromRGB


< I
(


I J
$num


J M
,


M N
$num


O R
,


R S
$num


T W
,


W X
$num


Y ]
)


] ^
}


_ `
,


` a
{


 
$str


 
,


 
CIELabFromRGB


< I
(


I J
$num


J M
,


M N
$num


O R
,


R S
$num


T W
,


W X
$num


Y ]
)


] ^
}


_ `
,


` a
{


 
$str


 
,


 
CIELabFromRGB


< I
(


I J
$num


J M
,


M N
$num


O Q
,


Q R
$num


S U
,


U V
$num


W [
)


[ \
}


] ^
,


^ _
{
‘
‘
 
$str
‘
‘
 
,
‘
‘
 
CIELabFromRGB
‘
‘
< I
(
‘
‘
I J
$num
‘
‘
J M
,
‘
‘
M N
$num
‘
‘
O Q
,
‘
‘
Q R
$num
‘
‘
S U
,
‘
‘
U V
$num
‘
‘
W [
)
‘
‘
[ \
}
‘
‘
] ^
,
‘
‘
^ _
{
’
’
 
$str
’
’
 
,
’
’
 
CIELabFromRGB
’
’
< I
(
’
’
I J
$num
’
’
J M
,
’
’
M N
$num
’
’
O R
,
’
’
R S
$num
’
’
T W
,
’
’
W X
$num
’
’
Y ]
)
’
’
] ^
}
’
’
_ `
,
’
’
` a
{
“
“
 
$str
“
“
 
,
“
“
 
CIELabFromRGB
“
“
< I
(
“
“
I J
$num
“
“
J L
,
“
“
L M
$num
“
“
N Q
,
“
“
Q R
$num
“
“
S V
,
“
“
V W
$num
“
“
X \
)
“
“
\ ]
}
“
“
^ _
,
“
“
_ `
{
”
”
 
$str
”
”
 
,
”
”
 
CIELabFromRGB
”
”
< I
(
”
”
I J
$num
”
”
J L
,
”
”
L M
$num
”
”
N Q
,
”
”
Q R
$num
”
”
S V
,
”
”
V W
$num
”
”
X \
)
”
”
\ ]
}
”
”
^ _
,
”
”
_ `
{
•
•
 
$str
•
•
 
,
•
•
 
CIELabFromRGB
•
•
< I
(
•
•
I J
$num
•
•
J M
,
•
•
M N
$num
•
•
O R
,
•
•
R S
$num
•
•
T W
,
•
•
W X
$num
•
•
Y ]
)
•
•
] ^
}
•
•
_ `
,
•
•
` a
{
–
–
 
$str
–
–
 
,
–
–
 
CIELabFromRGB
–
–
< I
(
–
–
I J
$num
–
–
J M
,
–
–
M N
$num
–
–
O R
,
–
–
R S
$num
–
–
T W
,
–
–
W X
$num
–
–
Y ]
)
–
–
] ^
}
–
–
_ `
,
–
–
` a
{
—
—
 
$str
—
—
 
,
—
—
 
CIELabFromRGB
—
—
< I
(
—
—
I J
$num
—
—
J M
,
—
—
M N
$num
—
—
O R
,
—
—
R S
$num
—
—
T W
,
—
—
W X
$num
—
—
Y ]
)
—
—
] ^
}
—
—
_ `
,
—
—
` a
{
˜
˜
 
$str
˜
˜
 
,
˜
˜
 
CIELabFromRGB
˜
˜
< I
(
˜
˜
I J
$num
˜
˜
J M
,
˜
˜
M N
$num
˜
˜
O R
,
˜
˜
R S
$num
˜
˜
T W
,
˜
˜
W X
$num
˜
˜
Y ]
)
˜
˜
] ^
}
˜
˜
_ `
,
˜
˜
` a
{
™
™
 
$str
™
™
 
,
™
™
 
CIELabFromRGB
™
™
< I
(
™
™
I J
$num
™
™
J M
,
™
™
M N
$num
™
™
O R
,
™
™
R S
$num
™
™
T W
,
™
™
W X
$num
™
™
Y ]
)
™
™
] ^
}
™
™
_ `
,
™
™
` a
{
š
š
 
$str
š
š
 
,
š
š
 
CIELabFromRGB
š
š
< I
(
š
š
I J
$num
š
š
J M
,
š
š
M N
$num
š
š
O Q
,
š
š
Q R
$num
š
š
S V
,
š
š
V W
$num
š
š
X \
)
š
š
\ ]
}
š
š
^ _
,
š
š
_ `
{
›
›
 
$str
›
›
 
,
›
›
 
CIELabFromRGB
›
›
< I
(
›
›
I J
$num
›
›
J M
,
›
›
M N
$num
›
›
O Q
,
›
›
Q R
$num
›
›
S V
,
›
›
V W
$num
›
›
X \
)
›
›
\ ]
}
›
›
^ _
,
›
›
_ `
{
œ
œ
 
$str
œ
œ
 
,
œ
œ
 
CIELabFromRGB
œ
œ
< I
(
œ
œ
I J
$num
œ
œ
J M
,
œ
œ
M N
$num
œ
œ
O Q
,
œ
œ
Q R
$num
œ
œ
S V
,
œ
œ
V W
$num
œ
œ
X \
)
œ
œ
\ ]
}
œ
œ
^ _
,
œ
œ
_ `
{


 
$str


 
,


 
CIELabFromRGB


< I
(


I J
$num


J N
,


N O
$num


P R
,


R S
$num


T W
,


W X
$num


Y ]
)


] ^
}


_ `
,


` a
{


 
$str


 
,


 
CIELabFromRGB


< I
(


I J
$num


J M
,


M N
$num


O R
,


R S
$num


T W
,


W X
$num


Y ]
)


] ^
}


_ `
,


` a
{
Ÿ
Ÿ
 
$str
Ÿ
Ÿ
 
,
Ÿ
Ÿ
 
CIELabFromRGB
Ÿ
Ÿ
< I
(
Ÿ
Ÿ
I J
$num
Ÿ
Ÿ
J M
,
Ÿ
Ÿ
M N
$num
Ÿ
Ÿ
O R
,
Ÿ
Ÿ
R S
$num
Ÿ
Ÿ
T W
,
Ÿ
Ÿ
W X
$num
Ÿ
Ÿ
Y ]
)
Ÿ
Ÿ
] ^
}
Ÿ
Ÿ
_ `
,
Ÿ
Ÿ
` a
{
 
 
 
$str
 
 
 
,
 
 
 
CIELabFromRGB
 
 
< I
(
 
 
I J
$num
 
 
J M
,
 
 
M N
$num
 
 
O R
,
 
 
R S
$num
 
 
T V
,
 
 
V W
$num
 
 
X \
)
 
 
\ ]
}
 
 
^ _
,
 
 
_ `
{
¡
¡
 
$str
¡
¡
 
,
¡
¡
 
CIELabFromRGB
¡
¡
< I
(
¡
¡
I J
$num
¡
¡
J M
,
¡
¡
M N
$num
¡
¡
O R
,
¡
¡
R S
$num
¡
¡
T W
,
¡
¡
W X
$num
¡
¡
Y ]
)
¡
¡
] ^
}
¡
¡
_ `
,
¡
¡
` a
{
¢
¢
 
$str
¢
¢
 
,
¢
¢
 
CIELabFromRGB
¢
¢
< I
(
¢
¢
I J
$num
¢
¢
J M
,
¢
¢
M N
$num
¢
¢
O R
,
¢
¢
R S
$num
¢
¢
T W
,
¢
¢
W X
$num
¢
¢
Y ]
)
¢
¢
] ^
}
¢
¢
_ `
,
¢
¢
` a
{
£
£
 
$str
£
£
 
,
£
£
 
CIELabFromRGB
£
£
< I
(
£
£
I J
$num
£
£
J M
,
£
£
M N
$num
£
£
O Q
,
£
£
Q R
$num
£
£
S V
,
£
£
V W
$num
£
£
X \
)
£
£
\ ]
}
£
£
^ _
,
£
£
_ `
{
¤
¤
 
$str
¤
¤
 
,
¤
¤
 
CIELabFromRGB
¤
¤
< I
(
¤
¤
I J
$num
¤
¤
J M
,
¤
¤
M N
$num
¤
¤
O R
,
¤
¤
R S
$num
¤
¤
T V
,
¤
¤
V W
$num
¤
¤
X \
)
¤
¤
\ ]
}
¤
¤
^ _
,
¤
¤
_ `
{
¥
¥
 
$str
¥
¥
 
,
¥
¥
 
CIELabFromRGB
¥
¥
< I
(
¥
¥
I J
$num
¥
¥
J M
,
¥
¥
M N
$num
¥
¥
O R
,
¥
¥
R S
$num
¥
¥
T W
,
¥
¥
W X
$num
¥
¥
Y ]
)
¥
¥
] ^
}
¥
¥
_ `
,
¥
¥
` a
{
¦
¦
 
$str
¦
¦
 &
,
¦
¦
& '
CIELabFromRGB
¦
¦
< I
(
¦
¦
I J
$num
¦
¦
J L
,
¦
¦
L M
$num
¦
¦
N Q
,
¦
¦
Q R
$num
¦
¦
S V
,
¦
¦
V W
$num
¦
¦
X \
)
¦
¦
\ ]
}
¦
¦
^ _
,
¦
¦
_ `
{
§
§
 
$str
§
§
 
,
§
§
 
CIELabFromRGB
§
§
< I
(
§
§
I J
$num
§
§
J M
,
§
§
M N
$num
§
§
O R
,
§
§
R S
$num
§
§
T V
,
§
§
V W
$num
§
§
X \
)
§
§
\ ]
}
§
§
^ _
,
§
§
_ `
{
¨
¨
 
$str
¨
¨
 
,
¨
¨
 
CIELabFromRGB
¨
¨
< I
(
¨
¨
I J
$num
¨
¨
J N
,
¨
¨
N O
$num
¨
¨
P S
,
¨
¨
S T
$num
¨
¨
U W
,
¨
¨
W X
$num
¨
¨
Y ]
)
¨
¨
] ^
}
¨
¨
_ `
,
¨
¨
` a
{
©
©
 
$str
©
©
 ,
,
©
©
, -
CIELabFromRGB
©
©
< I
(
©
©
I J
$num
©
©
J N
,
©
©
N O
$num
©
©
P S
,
©
©
S T
$num
©
©
U W
,
©
©
W X
$num
©
©
Y ]
)
©
©
] ^
}
©
©
_ `
,
©
©
` a
{
ª
ª
 
$str
ª
ª
 
,
ª
ª
 
CIELabFromRGB
ª
ª
< I
(
ª
ª
I J
$num
ª
ª
J M
,
ª
ª
M N
$num
ª
ª
O R
,
ª
ª
R S
$num
ª
ª
T V
,
ª
ª
V W
$num
ª
ª
X \
)
ª
ª
\ ]
}
ª
ª
^ _
,
ª
ª
_ `
{
«
«
 
$str
«
«
 
,
«
«
 
CIELabFromRGB
«
«
< I
(
«
«
I J
$num
«
«
J M
,
«
«
M N
$num
«
«
O R
,
«
«
R S
$num
«
«
T W
,
«
«
W X
$num
«
«
Y ]
)
«
«
] ^
}
«
«
_ `
,
«
«
` a
{
¬
¬
 
$str
¬
¬
 
,
¬
¬
 
CIELabFromRGB
¬
¬
< I
(
¬
¬
I J
$num
¬
¬
J M
,
¬
¬
M N
$num
¬
¬
O R
,
¬
¬
R S
$num
¬
¬
T W
,
¬
¬
W X
$num
¬
¬
Y ]
)
¬
¬
] ^
}
¬
¬
_ `
,
¬
¬
` a
{
­
­
 
$str
­
­
 "
,
­
­
" #
CIELabFromRGB
­
­
< I
(
­
­
I J
$num
­
­
J M
,
­
­
M N
$num
­
­
O R
,
­
­
R S
$num
­
­
T W
,
­
­
W X
$num
­
­
Y ]
)
­
­
] ^
}
­
­
_ `
,
­
­
` a
{
®
®
 
$str
®
®
 
,
®
®
 
CIELabFromRGB
®
®
< I
(
®
®
I J
$num
®
®
J M
,
®
®
M N
$num
®
®
O R
,
®
®
R S
$num
®
®
T W
,
®
®
W X
$num
®
®
Y ]
)
®
®
] ^
}
®
®
_ `
,
®
®
` a
{
¯
¯
 
$str
¯
¯
 
,
¯
¯
 
CIELabFromRGB
¯
¯
< I
(
¯
¯
I J
$num
¯
¯
J N
,
¯
¯
N O
$num
¯
¯
P S
,
¯
¯
S T
$num
¯
¯
U X
,
¯
¯
X Y
$num
¯
¯
Z ^
)
¯
¯
^ _
}
¯
¯
` a
,
¯
¯
a b
{
°
°
 
$str
°
°
 
,
°
°
 
CIELabFromRGB
°
°
< I
(
°
°
I J
$num
°
°
J M
,
°
°
M N
$num
°
°
O R
,
°
°
R S
$num
°
°
T W
,
°
°
W X
$num
°
°
Y ]
)
°
°
] ^
}
°
°
_ `
,
°
°
` a
{
±
±
 
$str
±
±
 
,
±
±
 
CIELabFromRGB
±
±
< I
(
±
±
I J
$num
±
±
J M
,
±
±
M N
$num
±
±
O R
,
±
±
R S
$num
±
±
T V
,
±
±
V W
$num
±
±
X \
)
±
±
\ ]
}
±
±
^ _
,
±
±
_ `
{
²
²
 
$str
²
²
 
,
²
²
 
CIELabFromRGB
²
²
< I
(
²
²
I J
$num
²
²
J M
,
²
²
M N
$num
²
²
O R
,
²
²
R S
$num
²
²
T W
,
²
²
W X
$num
²
²
Y ]
)
²
²
] ^
}
²
²
_ `
,
²
²
` a
{
³
³
 
$str
³
³
 
,
³
³
 
CIELabFromRGB
³
³
< I
(
³
³
I J
$num
³
³
J M
,
³
³
M N
$num
³
³
O R
,
³
³
R S
$num
³
³
T W
,
³
³
W X
$num
³
³
Y ]
)
³
³
] ^
}
³
³
_ `
,
³
³
` a
{
´
´
 
$str
´
´
 
,
´
´
 
CIELabFromRGB
´
´
< I
(
´
´
I J
$num
´
´
J M
,
´
´
M N
$num
´
´
O R
,
´
´
R S
$num
´
´
T V
,
´
´
V W
$num
´
´
X \
)
´
´
\ ]
}
´
´
^ _
,
´
´
_ `
{
µ
µ
 
$str
µ
µ
 
,
µ
µ
 
CIELabFromRGB
µ
µ
< I
(
µ
µ
I J
$num
µ
µ
J M
,
µ
µ
M N
$num
µ
µ
O Q
,
µ
µ
Q R
$num
µ
µ
S U
,
µ
µ
U V
$num
µ
µ
W [
)
µ
µ
[ \
}
µ
µ
] ^
,
µ
µ
^ _
{
¶
¶
 
$str
¶
¶
 
,
¶
¶
 
CIELabFromRGB
¶
¶
< I
(
¶
¶
I J
$num
¶
¶
J M
,
¶
¶
M N
$num
¶
¶
O R
,
¶
¶
R S
$num
¶
¶
T W
,
¶
¶
W X
$num
¶
¶
Y ]
)
¶
¶
] ^
}
¶
¶
_ `
,
¶
¶
` a
{
·
·
 
$str
·
·
 
,
·
·
 
CIELabFromRGB
·
·
< I
(
·
·
I J
$num
·
·
J L
,
·
·
L M
$num
·
·
N Q
,
·
·
Q R
$num
·
·
S V
,
·
·
V W
$num
·
·
X \
)
·
·
\ ]
}
·
·
^ _
,
·
·
_ `
{
¸
¸
 
$str
¸
¸
 
,
¸
¸
 
CIELabFromRGB
¸
¸
< I
(
¸
¸
I J
$num
¸
¸
J L
,
¸
¸
L M
$num
¸
¸
N Q
,
¸
¸
Q R
$num
¸
¸
S V
,
¸
¸
V W
$num
¸
¸
X \
)
¸
¸
\ ]
}
¸
¸
^ _
,
¸
¸
_ `
{
¹
¹
 
$str
¹
¹
  
,
¹
¹
  !
CIELabFromRGB
¹
¹
< I
(
¹
¹
I J
$num
¹
¹
J M
,
¹
¹
M N
$num
¹
¹
O R
,
¹
¹
R S
$num
¹
¹
T W
,
¹
¹
W X
$num
¹
¹
Y ]
)
¹
¹
] ^
}
¹
¹
_ `
,
¹
¹
` a
{
º
º
 
$str
º
º
 
,
º
º
 
CIELabFromRGB
º
º
< I
(
º
º
I J
$num
º
º
J N
,
º
º
N O
$num
º
º
P S
,
º
º
S T
$num
º
º
U W
,
º
º
W X
$num
º
º
Y ]
)
º
º
] ^
}
º
º
_ `
,
º
º
` a
{
»
»
 
$str
»
»
 
,
»
»
 
CIELabFromRGB
»
»
< I
(
»
»
I J
$num
»
»
J M
,
»
»
M N
$num
»
»
O Q
,
»
»
Q R
$num
»
»
S V
,
»
»
V W
$num
»
»
X \
)
»
»
\ ]
}
»
»
^ _
,
»
»
_ `
{
¼
¼
 
$str
¼
¼
 
,
¼
¼
 
CIELabFromRGB
¼
¼
< I
(
¼
¼
I J
$num
¼
¼
J N
,
¼
¼
N O
$num
¼
¼
P S
,
¼
¼
S T
$num
¼
¼
U X
,
¼
¼
X Y
$num
¼
¼
Z ^
)
¼
¼
^ _
}
¼
¼
` a
,
¼
¼
a b
{
½
½
 
$str
½
½
 !
,
½
½
! "
CIELabFromRGB
½
½
< I
(
½
½
I J
$num
½
½
J N
,
½
½
N O
$num
½
½
P S
,
½
½
S T
$num
½
½
U W
,
½
½
W X
$num
½
½
Y ]
)
½
½
] ^
}
½
½
_ `
,
½
½
` a
{
¾
¾
 
$str
¾
¾
 
,
¾
¾
  
CIELabFromRGB
¾
¾
< I
(
¾
¾
I J
$num
¾
¾
J M
,
¾
¾
M N
$num
¾
¾
O S
,
¾
¾
S T
$num
¾
¾
U X
,
¾
¾
X Y
$num
¾
¾
Z ^
)
¾
¾
^ _
}
¾
¾
` a
,
¾
¾
a b
{
¿
¿
 
$str
¿
¿
 
,
¿
¿
 
CIELabFromRGB
¿
¿
< I
(
¿
¿
I J
$num
¿
¿
J L
,
¿
¿
L M
$num
¿
¿
N Q
,
¿
¿
Q R
$num
¿
¿
S V
,
¿
¿
V W
$num
¿
¿
X \
)
¿
¿
\ ]
}
¿
¿
^ _
,
¿
¿
_ `
{
À
À
 
$str
À
À
 
,
À
À
 
CIELabFromRGB
À
À
< I
(
À
À
I J
$num
À
À
J M
,
À
À
M N
$num
À
À
O R
,
À
À
R S
$num
À
À
T W
,
À
À
W X
$num
À
À
Y ]
)
À
À
] ^
}
À
À
_ `
,
À
À
` a
{
Á
Á
 
$str
Á
Á
 
,
Á
Á
 
CIELabFromRGB
Á
Á
< I
(
Á
Á
I J
$num
Á
Á
J M
,
Á
Á
M N
$num
Á
Á
O Q
,
Á
Á
Q R
$num
Á
Á
S U
,
Á
Á
U V
$num
Á
Á
W [
)
Á
Á
[ \
}
Á
Á
] ^
,
Á
Á
^ _
{
Â
Â
 
$str
Â
Â
 
,
Â
Â
 
CIELabFromRGB
Â
Â
< I
(
Â
Â
I J
$num
Â
Â
J N
,
Â
Â
N O
$num
Â
Â
P S
,
Â
Â
S T
$num
Â
Â
U X
,
Â
Â
X Y
$num
Â
Â
Z ^
)
Â
Â
^ _
}
Â
Â
` a
,
Â
Â
a b
{
Ã
Ã
 
$str
Ã
Ã
  
,
Ã
Ã
  !
CIELabFromRGB
Ã
Ã
< I
(
Ã
Ã
I J
$num
Ã
Ã
J N
,
Ã
Ã
N O
$num
Ã
Ã
P S
,
Ã
Ã
S T
$num
Ã
Ã
U W
,
Ã
Ã
W X
$num
Ã
Ã
Y ]
)
Ã
Ã
] ^
}
Ã
Ã
_ `
,
Ã
Ã
` a
{
Ä
Ä
 
$str
Ä
Ä
 
,
Ä
Ä
 
CIELabFromRGB
Ä
Ä
< I
(
Ä
Ä
I J
$num
Ä
Ä
J M
,
Ä
Ä
M N
$num
Ä
Ä
O R
,
Ä
Ä
R S
$num
Ä
Ä
T V
,
Ä
Ä
V W
$num
Ä
Ä
X \
)
Ä
Ä
\ ]
}
Ä
Ä
^ _
,
Ä
Ä
_ `
{
Å
Å
 
$str
Å
Å
 
,
Å
Å
 
CIELabFromRGB
Å
Å
< I
(
Å
Å
I J
$num
Å
Å
J M
,
Å
Å
M N
$num
Å
Å
O R
,
Å
Å
R S
$num
Å
Å
T W
,
Å
Å
W X
$num
Å
Å
Y ]
)
Å
Å
] ^
}
Å
Å
_ `
,
Å
Å
` a
{
Æ
Æ
 
$str
Æ
Æ
 
,
Æ
Æ
 
CIELabFromRGB
Æ
Æ
< I
(
Æ
Æ
I J
$num
Æ
Æ
J M
,
Æ
Æ
M N
$num
Æ
Æ
O R
,
Æ
Æ
R S
$num
Æ
Æ
T W
,
Æ
Æ
W X
$num
Æ
Æ
Y ]
)
Æ
Æ
] ^
}
Æ
Æ
_ `
,
Æ
Æ
` a
{
Ç
Ç
 
$str
Ç
Ç
 
,
Ç
Ç
 
CIELabFromRGB
Ç
Ç
< I
(
Ç
Ç
I J
$num
Ç
Ç
J N
,
Ç
Ç
N O
$num
Ç
Ç
P S
,
Ç
Ç
S T
$num
Ç
Ç
U X
,
Ç
Ç
X Y
$num
Ç
Ç
Z ^
)
Ç
Ç
^ _
}
Ç
Ç
` a
,
Ç
Ç
a b
{
È
È
 
$str
È
È
 
,
È
È
 
CIELabFromRGB
È
È
< I
(
È
È
I J
$num
È
È
J L
,
È
È
L M
$num
È
È
N Q
,
È
È
Q R
$num
È
È
S V
,
È
È
V W
$num
È
È
X \
)
È
È
\ ]
}
È
È
^ _
,
È
È
_ `
{
É
É
 
$str
É
É
 
,
É
É
 
CIELabFromRGB
É
É
< I
(
É
É
I J
$num
É
É
J M
,
É
É
M N
$num
É
É
O R
,
É
É
R S
$num
É
É
T V
,
É
É
V W
$num
É
É
X \
)
É
É
\ ]
}
É
É
^ _
,
É
É
_ `
{
Ê
Ê
 
$str
Ê
Ê
  
,
Ê
Ê
  !
CIELabFromRGB
Ê
Ê
< I
(
Ê
Ê
I J
$num
Ê
Ê
J M
,
Ê
Ê
M N
$num
Ê
Ê
O R
,
Ê
Ê
R S
$num
Ê
Ê
T W
,
Ê
Ê
W X
$num
Ê
Ê
Y ]
)
Ê
Ê
] ^
}
Ê
Ê
_ `
,
Ê
Ê
` a
{
Ë
Ë
 
$str
Ë
Ë
 
,
Ë
Ë
 
CIELabFromRGB
Ë
Ë
< I
(
Ë
Ë
I J
$num
Ë
Ë
J M
,
Ë
Ë
M N
$num
Ë
Ë
O Q
,
Ë
Ë
Q R
$num
Ë
Ë
S V
,
Ë
Ë
V W
$num
Ë
Ë
X \
)
Ë
Ë
\ ]
}
Ë
Ë
^ _
,
Ë
Ë
_ `
{
Ì
Ì
 
$str
Ì
Ì
 '
,
Ì
Ì
' (
CIELabFromRGB
Ì
Ì
< I
(
Ì
Ì
I J
$num
Ì
Ì
J N
,
Ì
Ì
N O
$num
Ì
Ì
P S
,
Ì
Ì
S T
$num
Ì
Ì
U Y
,
Ì
Ì
Y Z
$num
Ì
Ì
[ _
)
Ì
Ì
_ `
}
Ì
Ì
a b
,
Ì
Ì
b c
{
Í
Í
 
$str
Í
Í
 
,
Í
Í
 
CIELabFromRGB
Í
Í
< I
(
Í
Í
I J
$num
Í
Í
J M
,
Í
Í
M N
$num
Í
Í
O R
,
Í
Í
R S
$num
Í
Í
T V
,
Í
Í
V W
$num
Í
Í
X \
)
Í
Í
\ ]
}
Í
Í
^ _
,
Í
Í
_ `
{
Î
Î
 
$str
Î
Î
 
,
Î
Î
 
CIELabFromRGB
Î
Î
< I
(
Î
Î
I J
$num
Î
Î
J M
,
Î
Î
M N
$num
Î
Î
O R
,
Î
Î
R S
$num
Î
Î
T W
,
Î
Î
W X
$num
Î
Î
Y ]
)
Î
Î
] ^
}
Î
Î
_ `
,
Î
Î
` a
{
Ï
Ï
 
$str
Ï
Ï
 
,
Ï
Ï
 
CIELabFromRGB
Ï
Ï
< I
(
Ï
Ï
I J
$num
Ï
Ï
J M
,
Ï
Ï
M N
$num
Ï
Ï
O R
,
Ï
Ï
R S
$num
Ï
Ï
T W
,
Ï
Ï
W X
$num
Ï
Ï
Y ]
)
Ï
Ï
] ^
}
Ï
Ï
_ `
,
Ï
Ï
` a
{
Ğ
Ğ
 
$str
Ğ
Ğ
  
,
Ğ
Ğ
  !
CIELabFromRGB
Ğ
Ğ
< I
(
Ğ
Ğ
I J
$num
Ğ
Ğ
J M
,
Ğ
Ğ
M N
$num
Ğ
Ğ
O R
,
Ğ
Ğ
R S
$num
Ğ
Ğ
T W
,
Ğ
Ğ
W X
$num
Ğ
Ğ
Y ]
)
Ğ
Ğ
] ^
}
Ğ
Ğ
_ `
,
Ğ
Ğ
` a
{
Ñ
Ñ
 
$str
Ñ
Ñ
 
,
Ñ
Ñ
 
CIELabFromRGB
Ñ
Ñ
< I
(
Ñ
Ñ
I J
$num
Ñ
Ñ
J M
,
Ñ
Ñ
M N
$num
Ñ
Ñ
O R
,
Ñ
Ñ
R S
$num
Ñ
Ñ
T W
,
Ñ
Ñ
W X
$num
Ñ
Ñ
Y ]
)
Ñ
Ñ
] ^
}
Ñ
Ñ
_ `
,
Ñ
Ñ
` a
{
Ò
Ò
 
$str
Ò
Ò
 
,
Ò
Ò
 
CIELabFromRGB
Ò
Ò
< I
(
Ò
Ò
I J
$num
Ò
Ò
J M
,
Ò
Ò
M N
$num
Ò
Ò
O R
,
Ò
Ò
R S
$num
Ò
Ò
T W
,
Ò
Ò
W X
$num
Ò
Ò
Y ]
)
Ò
Ò
] ^
}
Ò
Ò
_ `
,
Ò
Ò
` a
{
Ó
Ó
 
$str
Ó
Ó
 
,
Ó
Ó
 
CIELabFromRGB
Ó
Ó
< I
(
Ó
Ó
I J
$num
Ó
Ó
J M
,
Ó
Ó
M N
$num
Ó
Ó
O R
,
Ó
Ó
R S
$num
Ó
Ó
T V
,
Ó
Ó
V W
$num
Ó
Ó
X \
)
Ó
Ó
\ ]
}
Ó
Ó
^ _
,
Ó
Ó
_ `
{
Ô
Ô
 
$str
Ô
Ô
 
,
Ô
Ô
 
CIELabFromRGB
Ô
Ô
< I
(
Ô
Ô
I J
$num
Ô
Ô
J L
,
Ô
Ô
L M
$num
Ô
Ô
N Q
,
Ô
Ô
Q R
$num
Ô
Ô
S V
,
Ô
Ô
V W
$num
Ô
Ô
X \
)
Ô
Ô
\ ]
}
Ô
Ô
^ _
,
Ô
Ô
_ `
{
Õ
Õ
 
$str
Õ
Õ
 
,
Õ
Õ
 
CIELabFromRGB
Õ
Õ
< I
(
Õ
Õ
I J
$num
Õ
Õ
J M
,
Õ
Õ
M N
$num
Õ
Õ
O R
,
Õ
Õ
R S
$num
Õ
Õ
T W
,
Õ
Õ
W X
$num
Õ
Õ
Y ]
)
Õ
Õ
] ^
}
Õ
Õ
_ `
,
Õ
Õ
` a
{
Ö
Ö
 
$str
Ö
Ö
 
,
Ö
Ö
 
CIELabFromRGB
Ö
Ö
< I
(
Ö
Ö
I J
$num
Ö
Ö
J M
,
Ö
Ö
M N
$num
Ö
Ö
O R
,
Ö
Ö
R S
$num
Ö
Ö
T W
,
Ö
Ö
W X
$num
Ö
Ö
Y ]
)
Ö
Ö
] ^
}
Ö
Ö
_ `
,
Ö
Ö
` a
{
×
×
 
$str
×
×
 
,
×
×
 
CIELabFromRGB
×
×
< I
(
×
×
I J
$num
×
×
J M
,
×
×
M N
$num
×
×
O R
,
×
×
R S
$num
×
×
T W
,
×
×
W X
$num
×
×
Y ]
)
×
×
] ^
}
×
×
_ `
,
×
×
` a
{
Ø
Ø
 
$str
Ø
Ø
 
,
Ø
Ø
 
CIELabFromRGB
Ø
Ø
< I
(
Ø
Ø
I J
$num
Ø
Ø
J M
,
Ø
Ø
M N
$num
Ø
Ø
O R
,
Ø
Ø
R S
$num
Ø
Ø
T W
,
Ø
Ø
W X
$num
Ø
Ø
Y ]
)
Ø
Ø
] ^
}
Ø
Ø
_ `
,
Ø
Ø
` a
{
Ù
Ù
 
$str
Ù
Ù
 (
,
Ù
Ù
( )
CIELabFromRGB
Ù
Ù
< I
(
Ù
Ù
I J
$num
Ù
Ù
J L
,
Ù
Ù
L M
$num
Ù
Ù
N Q
,
Ù
Ù
Q R
$num
Ù
Ù
S V
,
Ù
Ù
V W
$num
Ù
Ù
X \
)
Ù
Ù
\ ]
}
Ù
Ù
^ _
,
Ù
Ù
_ `
{
Ú
Ú
 
$str
Ú
Ú
 
,
Ú
Ú
 
CIELabFromRGB
Ú
Ú
< I
(
Ú
Ú
I J
$num
Ú
Ú
J M
,
Ú
Ú
M N
$num
Ú
Ú
O R
,
Ú
Ú
R S
$num
Ú
Ú
T W
,
Ú
Ú
W X
$num
Ú
Ú
Y ]
)
Ú
Ú
] ^
}
Ú
Ú
_ `
,
Ú
Ú
` a
{
Û
Û
 
$str
Û
Û
 
,
Û
Û
 
CIELabFromRGB
Û
Û
< I
(
Û
Û
I J
$num
Û
Û
J M
,
Û
Û
M N
$num
Û
Û
O R
,
Û
Û
R S
$num
Û
Û
T W
,
Û
Û
W X
$num
Û
Û
Y ]
)
Û
Û
] ^
}
Û
Û
_ `
,
Û
Û
` a
{
Ü
Ü
 
$str
Ü
Ü
 
,
Ü
Ü
 
CIELabFromRGB
Ü
Ü
< I
(
Ü
Ü
I J
$num
Ü
Ü
J L
,
Ü
Ü
L M
$num
Ü
Ü
N P
,
Ü
Ü
P Q
$num
Ü
Ü
R T
,
Ü
Ü
T U
$num
Ü
Ü
V Z
)
Ü
Ü
Z [
}
Ü
Ü
\ ]
,
Ü
Ü
] ^
{
İ
İ
 
$str
İ
İ
 
,
İ
İ
 
CIELabFromRGB
İ
İ
< I
(
İ
İ
I J
$num
İ
İ
J M
,
İ
İ
M N
$num
İ
İ
O R
,
İ
İ
R S
$num
İ
İ
T W
,
İ
İ
W X
$num
İ
İ
Y ]
)
İ
İ
] ^
}
İ
İ
_ `
,
İ
İ
` a
{
Ş
Ş
 
$str
Ş
Ş
 
,
Ş
Ş
 
CIELabFromRGB
Ş
Ş
< I
(
Ş
Ş
I J
$num
Ş
Ş
J N
,
Ş
Ş
N O
$num
Ş
Ş
P S
,
Ş
Ş
S T
$num
Ş
Ş
U X
,
Ş
Ş
X Y
$num
Ş
Ş
Z ^
)
Ş
Ş
^ _
}
Ş
Ş
` a
,
Ş
Ş
a b
{
ß
ß
 
$str
ß
ß
 
,
ß
ß
 
CIELabFromRGB
ß
ß
< I
(
ß
ß
I J
$num
ß
ß
J M
,
ß
ß
M N
$num
ß
ß
O R
,
ß
ß
R S
$num
ß
ß
T W
,
ß
ß
W X
$num
ß
ß
Y ]
)
ß
ß
] ^
}
ß
ß
_ `
,
ß
ß
` a
{
à
à
 
$str
à
à
 
,
à
à
 
CIELabFromRGB
à
à
< I
(
à
à
I J
$num
à
à
J M
,
à
à
M N
$num
à
à
O R
,
à
à
R S
$num
à
à
T W
,
à
à
W X
$num
à
à
Y ]
)
à
à
] ^
}
à
à
_ `
,
à
à
` a
{
á
á
 
$str
á
á
 
,
á
á
 
CIELabFromRGB
á
á
< I
(
á
á
I J
$num
á
á
J M
,
á
á
M N
$num
á
á
O R
,
á
á
R S
$num
á
á
T W
,
á
á
W X
$num
á
á
Y ]
)
á
á
] ^
}
á
á
_ `
,
á
á
` a
{
â
â
 
$str
â
â
 
,
â
â
  
CIELabFromRGB
â
â
< I
(
â
â
I J
$num
â
â
J M
,
â
â
M N
$num
â
â
O Q
,
â
â
Q R
$num
â
â
S U
,
â
â
U V
$num
â
â
W [
)
â
â
[ \
}
â
â
] ^
,
â
â
^ _
{
ã
ã
 
$str
ã
ã
 
,
ã
ã
 
CIELabFromRGB
ã
ã
< I
(
ã
ã
I J
$num
ã
ã
J M
,
ã
ã
M N
$num
ã
ã
O R
,
ã
ã
R S
$num
ã
ã
T W
,
ã
ã
W X
$num
ã
ã
Y ]
)
ã
ã
] ^
}
ã
ã
_ `
,
ã
ã
` a
{
ä
ä
 
$str
ä
ä
 
,
ä
ä
 
CIELabFromRGB
ä
ä
< I
(
ä
ä
I J
$num
ä
ä
J M
,
ä
ä
M N
$num
ä
ä
O R
,
ä
ä
R S
$num
ä
ä
T W
,
ä
ä
W X
$num
ä
ä
Y ]
)
ä
ä
] ^
}
ä
ä
_ `
,
ä
ä
` a
{
å
å
 
$str
å
å
 
,
å
å
 
CIELabFromRGB
å
å
< I
(
å
å
I J
$num
å
å
J L
,
å
å
L M
$num
å
å
N Q
,
å
å
Q R
$num
å
å
S V
,
å
å
V W
$num
å
å
X \
)
å
å
\ ]
}
å
å
^ _
,
å
å
_ `
{
æ
æ
 
$str
æ
æ
 
,
æ
æ
  
CIELabFromRGB
æ
æ
< I
(
æ
æ
I J
$num
æ
æ
J M
,
æ
æ
M N
$num
æ
æ
O Q
,
æ
æ
Q R
$num
æ
æ
S V
,
æ
æ
V W
$num
æ
æ
X \
)
æ
æ
\ ]
}
æ
æ
^ _
,
æ
æ
_ `
{
ç
ç
 
$str
ç
ç
 
,
ç
ç
  
CIELabFromRGB
ç
ç
< I
(
ç
ç
I J
$num
ç
ç
J M
,
ç
ç
M N
$num
ç
ç
O R
,
ç
ç
R S
$num
ç
ç
T W
,
ç
ç
W X
$num
ç
ç
Y ]
)
ç
ç
] ^
}
ç
ç
_ `
,
ç
ç
` a
{
è
è
 
$str
è
è
 
,
è
è
 
CIELabFromRGB
è
è
< I
(
è
è
I J
$num
è
è
J M
,
è
è
M N
$num
è
è
O R
,
è
è
R S
$num
è
è
T W
,
è
è
W X
$num
è
è
Y ]
)
è
è
] ^
}
è
è
_ `
,
è
è
` a
{
é
é
 
$str
é
é
 
,
é
é
 
CIELabFromRGB
é
é
< I
(
é
é
I J
$num
é
é
J L
,
é
é
L M
$num
é
é
N Q
,
é
é
Q R
$num
é
é
S V
,
é
é
V W
$num
é
é
X \
)
é
é
\ ]
}
é
é
^ _
,
é
é
_ `
{
ê
ê
 
$str
ê
ê
 
,
ê
ê
 
CIELabFromRGB
ê
ê
< I
(
ê
ê
I J
$num
ê
ê
J M
,
ê
ê
M N
$num
ê
ê
O R
,
ê
ê
R S
$num
ê
ê
T V
,
ê
ê
V W
$num
ê
ê
X \
)
ê
ê
\ ]
}
ê
ê
^ _
,
ê
ê
_ `
{
ë
ë
 
$str
ë
ë
 
,
ë
ë
 
CIELabFromRGB
ë
ë
< I
(
ë
ë
I J
$num
ë
ë
J M
,
ë
ë
M N
$num
ë
ë
O R
,
ë
ë
R S
$num
ë
ë
T W
,
ë
ë
W X
$num
ë
ë
Y ]
)
ë
ë
] ^
}
ë
ë
_ `
,
ë
ë
` a
{
ì
ì
 
$str
ì
ì
 
,
ì
ì
 
CIELabFromRGB
ì
ì
< I
(
ì
ì
I J
$num
ì
ì
J M
,
ì
ì
M N
$num
ì
ì
O Q
,
ì
ì
Q R
$num
ì
ì
S V
,
ì
ì
V W
$num
ì
ì
X \
)
ì
ì
\ ]
}
ì
ì
^ _
,
ì
ì
_ `
{
í
í
 
$str
í
í
  
,
í
í
  !
CIELabFromRGB
í
í
< I
(
í
í
I J
$num
í
í
J L
,
í
í
L M
$num
í
í
N R
,
í
í
R S
$num
í
í
T X
,
í
í
X Y
$num
í
í
Z ^
)
í
í
^ _
}
í
í
` a
,
í
í
a b
{
î
î
 
$str
î
î
 
,
î
î
 
CIELabFromRGB
î
î
< I
(
î
î
I J
$num
î
î
J M
,
î
î
M N
$num
î
î
O R
,
î
î
R S
$num
î
î
T W
,
î
î
W X
$num
î
î
Y ]
)
î
î
] ^
}
î
î
_ `
,
î
î
` a
{
ï
ï
 
$str
ï
ï
  
,
ï
ï
  !
CIELabFromRGB
ï
ï
< I
(
ï
ï
I J
$num
ï
ï
J L
,
ï
ï
L M
$num
ï
ï
N Q
,
ï
ï
Q R
$num
ï
ï
S V
,
ï
ï
V W
$num
ï
ï
X \
)
ï
ï
\ ]
}
ï
ï
^ _
,
ï
ï
_ `
{
ğ
ğ
 
$str
ğ
ğ
 
,
ğ
ğ
 
CIELabFromRGB
ğ
ğ
< I
(
ğ
ğ
I J
$num
ğ
ğ
J M
,
ğ
ğ
M N
$num
ğ
ğ
O R
,
ğ
ğ
R S
$num
ğ
ğ
T W
,
ğ
ğ
W X
$num
ğ
ğ
Y ]
)
ğ
ğ
] ^
}
ğ
ğ
_ `
,
ğ
ğ
` a
{
ñ
ñ
 
$str
ñ
ñ
  
,
ñ
ñ
  !
CIELabFromRGB
ñ
ñ
< I
(
ñ
ñ
I J
$num
ñ
ñ
J L
,
ñ
ñ
L M
$num
ñ
ñ
N Q
,
ñ
ñ
Q R
$num
ñ
ñ
S V
,
ñ
ñ
V W
$num
ñ
ñ
X \
)
ñ
ñ
\ ]
}
ñ
ñ
^ _
,
ñ
ñ
_ `
{
ò
ò
 
$str
ò
ò
 
,
ò
ò
 
CIELabFromRGB
ò
ò
< I
(
ò
ò
I J
$num
ò
ò
J M
,
ò
ò
M N
$num
ò
ò
O R
,
ò
ò
R S
$num
ò
ò
T V
,
ò
ò
V W
$num
ò
ò
X \
)
ò
ò
\ ]
}
ò
ò
^ _
,
ò
ò
_ `
{
ó
ó
 
$str
ó
ó
 
,
ó
ó
 
CIELabFromRGB
ó
ó
< I
(
ó
ó
I J
$num
ó
ó
J L
,
ó
ó
L M
$num
ó
ó
N R
,
ó
ó
R S
$num
ó
ó
T W
,
ó
ó
W X
$num
ó
ó
Y ]
)
ó
ó
] ^
}
ó
ó
_ `
,
ó
ó
` a
{
ô
ô
 
$str
ô
ô
 !
,
ô
ô
! "
CIELabFromRGB
ô
ô
< I
(
ô
ô
I J
$num
ô
ô
J L
,
ô
ô
L M
$num
ô
ô
N Q
,
ô
ô
Q R
$num
ô
ô
S V
,
ô
ô
V W
$num
ô
ô
X \
)
ô
ô
\ ]
}
ô
ô
^ _
,
ô
ô
_ `
{
õ
õ
 
$str
õ
õ
 
,
õ
õ
 
CIELabFromRGB
õ
õ
< I
(
õ
õ
I J
$num
õ
õ
J M
,
õ
õ
M N
$num
õ
õ
O R
,
õ
õ
R S
$num
õ
õ
T W
,
õ
õ
W X
$num
õ
õ
Y ]
)
õ
õ
] ^
}
õ
õ
_ `
,
õ
õ
` a
{
ö
ö
 
$str
ö
ö
 
,
ö
ö
 
CIELabFromRGB
ö
ö
< I
(
ö
ö
I J
$num
ö
ö
J M
,
ö
ö
M N
$num
ö
ö
O R
,
ö
ö
R S
$num
ö
ö
T W
,
ö
ö
W X
$num
ö
ö
Y ]
)
ö
ö
] ^
}
ö
ö
_ `
,
ö
ö
` a
{
÷
÷
 
$str
÷
÷
 $
,
÷
÷
$ %
CIELabFromRGB
÷
÷
< I
(
÷
÷
I J
$num
÷
÷
J M
,
÷
÷
M N
$num
÷
÷
O R
,
÷
÷
R S
$num
÷
÷
T W
,
÷
÷
W X
$num
÷
÷
Y ]
)
÷
÷
] ^
}
÷
÷
_ `
,
÷
÷
` a
{
ø
ø
 
$str
ø
ø
 
,
ø
ø
 
CIELabFromRGB
ø
ø
< I
(
ø
ø
I J
$num
ø
ø
J M
,
ø
ø
M N
$num
ø
ø
O Q
,
ø
ø
Q R
$num
ø
ø
S U
,
ø
ø
U V
$num
ø
ø
W [
)
ø
ø
[ \
}
ø
ø
] ^
,
ø
ø
^ _
{
ù
ù
 
$str
ù
ù
 
,
ù
ù
 
CIELabFromRGB
ù
ù
< I
(
ù
ù
I J
$num
ù
ù
J M
,
ù
ù
M N
$num
ù
ù
O R
,
ù
ù
R S
$num
ù
ù
T W
,
ù
ù
W X
$num
ù
ù
Y ]
)
ù
ù
] ^
}
ù
ù
_ `
,
ù
ù
` a
{
ú
ú
 
$str
ú
ú
 
,
ú
ú
 
CIELabFromRGB
ú
ú
< I
(
ú
ú
I J
$num
ú
ú
J M
,
ú
ú
M N
$num
ú
ú
O R
,
ú
ú
R S
$num
ú
ú
T W
,
ú
ú
W X
$num
ú
ú
Y ]
)
ú
ú
] ^
}
ú
ú
_ `
,
ú
ú
` a
{
û
û
 
$str
û
û
 
,
û
û
 
CIELabFromRGB
û
û
< I
(
û
û
I J
$num
û
û
J M
,
û
û
M N
$num
û
û
O R
,
û
û
R S
$num
û
û
T W
,
û
û
W X
$num
û
û
Y ]
)
û
û
] ^
}
û
û
_ `
,
û
û
` a
{
ü
ü
 
$str
ü
ü
 
,
ü
ü
 
CIELabFromRGB
ü
ü
< I
(
ü
ü
I J
$num
ü
ü
J M
,
ü
ü
M N
$num
ü
ü
O R
,
ü
ü
R S
$num
ü
ü
T W
,
ü
ü
W X
$num
ü
ü
Y ]
)
ü
ü
] ^
}
ü
ü
_ `
,
ü
ü
` a
{
ı
ı
 
$str
ı
ı
 
,
ı
ı
 
CIELabFromRGB
ı
ı
< I
(
ı
ı
I J
$num
ı
ı
J N
,
ı
ı
N O
$num
ı
ı
P S
,
ı
ı
S T
$num
ı
ı
U X
,
ı
ı
X Y
$num
ı
ı
Z ^
)
ı
ı
^ _
}
ı
ı
` a
,
ı
ı
a b
{
ş
ş
 
$str
ş
ş
 
,
ş
ş
 
CIELabFromRGB
ş
ş
< I
(
ş
ş
I J
$num
ş
ş
J M
,
ş
ş
M N
$num
ş
ş
O R
,
ş
ş
R S
$num
ş
ş
T W
,
ş
ş
W X
$num
ş
ş
Y ]
)
ş
ş
] ^
}
ş
ş
_ `
,
ş
ş
` a
{
ÿ
ÿ
 
$str
ÿ
ÿ
 
,
ÿ
ÿ
 
CIELabFromRGB
ÿ
ÿ
< I
(
ÿ
ÿ
I J
$num
ÿ
ÿ
J M
,
ÿ
ÿ
M N
$num
ÿ
ÿ
O R
,
ÿ
ÿ
R S
$num
ÿ
ÿ
T W
,
ÿ
ÿ
W X
$num
ÿ
ÿ
Y ]
)
ÿ
ÿ
] ^
}
ÿ
ÿ
_ `
,
ÿ
ÿ
` a
{
€€ 
$str
€€ 
,
€€ 
CIELabFromRGB
€€< I
(
€€I J
$num
€€J M
,
€€M N
$num
€€O R
,
€€R S
$num
€€T W
,
€€W X
$num
€€Y ]
)
€€] ^
}
€€_ `
,
€€` a
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
‚‚ 
$str
‚‚ 
,
‚‚ 
CIELabFromRGB
‚‚< I
(
‚‚I J
$num
‚‚J M
,
‚‚M N
$num
‚‚O R
,
‚‚R S
$num
‚‚T W
,
‚‚W X
$num
‚‚Y ]
)
‚‚] ^
}
‚‚_ `
,
‚‚` a
{
ƒƒ 
$str
ƒƒ 
,
ƒƒ 
CIELabFromRGB
ƒƒ< I
(
ƒƒI J
$num
ƒƒJ M
,
ƒƒM N
$num
ƒƒO R
,
ƒƒR S
$num
ƒƒT V
,
ƒƒV W
$num
ƒƒX \
)
ƒƒ\ ]
}
ƒƒ^ _
,
ƒƒ_ `
{
„„ 
$str
„„ 
,
„„ 
CIELabFromRGB
„„< I
(
„„I J
$num
„„J M
,
„„M N
$num
„„O R
,
„„R S
$num
„„T V
,
„„V W
$num
„„X \
)
„„\ ]
}
„„^ _
,
„„_ `
{
…… 
$str
……  
,
……  !
CIELabFromRGB
……< I
(
……I J
$num
……J N
,
……N O
$num
……P S
,
……S T
$num
……U W
,
……W X
$num
……Y ]
)
……] ^
}
……_ `
,
……` a
{
†† 
$str
†† 
,
†† 
CIELabFromRGB
††< I
(
††I J
$num
††J M
,
††M N
$num
††O R
,
††R S
$num
††T W
,
††W X
$num
††Y ]
)
††] ^
}
††_ `
,
††` a
{
‡‡ 
$str
‡‡ 
,
‡‡ 
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J M
,
‡‡M N
$num
‡‡O R
,
‡‡R S
$num
‡‡T W
,
‡‡W X
$num
‡‡Y ]
)
‡‡] ^
}
‡‡_ `
,
‡‡` a
{
ˆˆ 
$str
ˆˆ 
,
ˆˆ 
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ M
,
ˆˆM N
$num
ˆˆO R
,
ˆˆR S
$num
ˆˆT W
,
ˆˆW X
$num
ˆˆY ]
)
ˆˆ] ^
}
ˆˆ_ `
,
ˆˆ` a
{
‰‰ 
$str
‰‰ 
,
‰‰ 
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J M
,
‰‰M N
$num
‰‰O R
,
‰‰R S
$num
‰‰T W
,
‰‰W X
$num
‰‰Y ]
)
‰‰] ^
}
‰‰_ `
,
‰‰` a
{
ŠŠ 
$str
ŠŠ 
,
ŠŠ 
CIELabFromRGB
ŠŠ< I
(
ŠŠI J
$num
ŠŠJ M
,
ŠŠM N
$num
ŠŠO R
,
ŠŠR S
$num
ŠŠT W
,
ŠŠW X
$num
ŠŠY ]
)
ŠŠ] ^
}
ŠŠ_ `
,
ŠŠ` a
{
‹‹ 
$str
‹‹ 
,
‹‹ 
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J M
,
‹‹M N
$num
‹‹O R
,
‹‹R S
$num
‹‹T W
,
‹‹W X
$num
‹‹Y ]
)
‹‹] ^
}
‹‹_ `
,
‹‹` a
{
ŒŒ 
$str
ŒŒ 
,
ŒŒ 
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ L
,
ŒŒL M
$num
ŒŒN Q
,
ŒŒQ R
$num
ŒŒS V
,
ŒŒV W
$num
ŒŒX \
)
ŒŒ\ ]
}
ŒŒ^ _
,
ŒŒ_ `
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J L
,
L M
$num
N Q
,
Q R
$num
S V
,
V W
$num
X \
)
\ ]
}
^ _
,
_ `
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
‘‘ 
$str
‘‘ 
,
‘‘ 
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J M
,
‘‘M N
$num
‘‘O R
,
‘‘R S
$num
‘‘T V
,
‘‘V W
$num
‘‘X \
)
‘‘\ ]
}
‘‘^ _
,
‘‘_ `
{
’’ 
$str
’’ 
,
’’ 
CIELabFromRGB
’’< I
(
’’I J
$num
’’J M
,
’’M N
$num
’’O R
,
’’R S
$num
’’T W
,
’’W X
$num
’’Y ]
)
’’] ^
}
’’_ `
,
’’` a
{
““ 
$str
““ 
,
““ 
CIELabFromRGB
““< I
(
““I J
$num
““J M
,
““M N
$num
““O R
,
““R S
$num
““T W
,
““W X
$num
““Y ]
)
““] ^
}
““_ `
,
““` a
{
”” 
$str
”” 
,
”” 
CIELabFromRGB
””< I
(
””I J
$num
””J M
,
””M N
$num
””O R
,
””R S
$num
””T W
,
””W X
$num
””Y ]
)
””] ^
}
””_ `
,
””` a
{
•• 
$str
•• 
,
•• 
CIELabFromRGB
••< I
(
••I J
$num
••J L
,
••L M
$num
••N Q
,
••Q R
$num
••S V
,
••V W
$num
••X \
)
••\ ]
}
••^ _
,
••_ `
{
–– 
$str
–– 
,
–– 
CIELabFromRGB
––< I
(
––I J
$num
––J M
,
––M N
$num
––O R
,
––R S
$num
––T W
,
––W X
$num
––Y ]
)
––] ^
}
––_ `
,
––` a
{
—— 
$str
—— 
,
—— 
CIELabFromRGB
——< I
(
——I J
$num
——J M
,
——M N
$num
——O R
,
——R S
$num
——T W
,
——W X
$num
——Y ]
)
——] ^
}
——_ `
,
——` a
{
˜˜ 
$str
˜˜ 
,
˜˜  
CIELabFromRGB
˜˜< I
(
˜˜I J
$num
˜˜J M
,
˜˜M N
$num
˜˜O R
,
˜˜R S
$num
˜˜T V
,
˜˜V W
$num
˜˜X \
)
˜˜\ ]
}
˜˜^ _
,
˜˜_ `
{
™™ 
$str
™™ 
,
™™ 
CIELabFromRGB
™™< I
(
™™I J
$num
™™J N
,
™™N O
$num
™™P S
,
™™S T
$num
™™U X
,
™™X Y
$num
™™Z ^
)
™™^ _
}
™™` a
,
™™a b
{
šš 
$str
šš 
,
šš 
CIELabFromRGB
šš< I
(
ššI J
$num
ššJ M
,
ššM N
$num
ššO R
,
ššR S
$num
ššT W
,
ššW X
$num
ššY ]
)
šš] ^
}
šš_ `
,
šš` a
{
›› 
$str
›› 
,
›› 
CIELabFromRGB
››< I
(
››I J
$num
››J N
,
››N O
$num
››P S
,
››S T
$num
››U X
,
››X Y
$num
››Z ^
)
››^ _
}
››` a
,
››a b
{
œœ 
$str
œœ 
,
œœ 
CIELabFromRGB
œœ< I
(
œœI J
$num
œœJ M
,
œœM N
$num
œœO Q
,
œœQ R
$num
œœS V
,
œœV W
$num
œœX \
)
œœ\ ]
}
œœ^ _
,
œœ_ `
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
 
$str
 $
,
$ %
CIELabFromRGB
< I
(
I J
$num
J L
,
L M
$num
N Q
,
Q R
$num
S V
,
V W
$num
X \
)
\ ]
}
^ _
,
_ `
{
ŸŸ 
$str
ŸŸ 
,
ŸŸ 
CIELabFromRGB
ŸŸ< I
(
ŸŸI J
$num
ŸŸJ L
,
ŸŸL M
$num
ŸŸN Q
,
ŸŸQ R
$num
ŸŸS V
,
ŸŸV W
$num
ŸŸX \
)
ŸŸ\ ]
}
ŸŸ^ _
,
ŸŸ_ `
{
   
$str
   
,
   
CIELabFromRGB
  < I
(
  I J
$num
  J M
,
  M N
$num
  O R
,
  R S
$num
  T W
,
  W X
$num
  Y ]
)
  ] ^
}
  _ `
,
  ` a
{
¡¡ 
$str
¡¡ 
,
¡¡ 
CIELabFromRGB
¡¡< I
(
¡¡I J
$num
¡¡J N
,
¡¡N O
$num
¡¡P S
,
¡¡S T
$num
¡¡U X
,
¡¡X Y
$num
¡¡Z ^
)
¡¡^ _
}
¡¡` a
,
¡¡a b
{
¢¢ 
$str
¢¢ 
,
¢¢ 
CIELabFromRGB
¢¢< I
(
¢¢I J
$num
¢¢J M
,
¢¢M N
$num
¢¢O R
,
¢¢R S
$num
¢¢T W
,
¢¢W X
$num
¢¢Y ]
)
¢¢] ^
}
¢¢_ `
,
¢¢` a
{
££ 
$str
££ 
,
££ 
CIELabFromRGB
££< I
(
££I J
$num
££J M
,
££M N
$num
££O R
,
££R S
$num
££T W
,
££W X
$num
££Y ]
)
££] ^
}
££_ `
,
££` a
{
¤¤ 
$str
¤¤ 
,
¤¤ 
CIELabFromRGB
¤¤< I
(
¤¤I J
$num
¤¤J M
,
¤¤M N
$num
¤¤O R
,
¤¤R S
$num
¤¤T W
,
¤¤W X
$num
¤¤Y ]
)
¤¤] ^
}
¤¤_ `
,
¤¤` a
{
¥¥ 
$str
¥¥ 
,
¥¥ 
CIELabFromRGB
¥¥< I
(
¥¥I J
$num
¥¥J L
,
¥¥L M
$num
¥¥N R
,
¥¥R S
$num
¥¥T W
,
¥¥W X
$num
¥¥Y ]
)
¥¥] ^
}
¥¥_ `
,
¥¥` a
{
¦¦ 
$str
¦¦ 
,
¦¦  
CIELabFromRGB
¦¦< I
(
¦¦I J
$num
¦¦J M
,
¦¦M N
$num
¦¦O R
,
¦¦R S
$num
¦¦T W
,
¦¦W X
$num
¦¦Y ]
)
¦¦] ^
}
¦¦_ `
,
¦¦` a
{
§§ 
$str
§§ 
,
§§ 
CIELabFromRGB
§§< I
(
§§I J
$num
§§J M
,
§§M N
$num
§§O R
,
§§R S
$num
§§T W
,
§§W X
$num
§§Y ]
)
§§] ^
}
§§_ `
,
§§` a
{
¨¨ 
$str
¨¨ 
,
¨¨ 
CIELabFromRGB
¨¨< I
(
¨¨I J
$num
¨¨J M
,
¨¨M N
$num
¨¨O R
,
¨¨R S
$num
¨¨T W
,
¨¨W X
$num
¨¨Y ]
)
¨¨] ^
}
¨¨_ `
,
¨¨` a
{
©© 
$str
©© 
,
©© 
CIELabFromRGB
©©< I
(
©©I J
$num
©©J M
,
©©M N
$num
©©O R
,
©©R S
$num
©©T W
,
©©W X
$num
©©Y ]
)
©©] ^
}
©©_ `
,
©©` a
{
ªª 
$str
ªª 
,
ªª 
CIELabFromRGB
ªª< I
(
ªªI J
$num
ªªJ M
,
ªªM N
$num
ªªO R
,
ªªR S
$num
ªªT W
,
ªªW X
$num
ªªY ]
)
ªª] ^
}
ªª_ `
,
ªª` a
{
«« 
$str
«« 
,
«« 
CIELabFromRGB
««< I
(
««I J
$num
««J M
,
««M N
$num
««O R
,
««R S
$num
««T W
,
««W X
$num
««Y ]
)
««] ^
}
««_ `
,
««` a
{
¬¬ 
$str
¬¬ !
,
¬¬! "
CIELabFromRGB
¬¬< I
(
¬¬I J
$num
¬¬J M
,
¬¬M N
$num
¬¬O R
,
¬¬R S
$num
¬¬T W
,
¬¬W X
$num
¬¬Y ]
)
¬¬] ^
}
¬¬_ `
,
¬¬` a
{
­­ 
$str
­­ 
,
­­ 
CIELabFromRGB
­­< I
(
­­I J
$num
­­J M
,
­­M N
$num
­­O Q
,
­­Q R
$num
­­S V
,
­­V W
$num
­­X \
)
­­\ ]
}
­­^ _
,
­­_ `
{
®® 
$str
®® 
,
®® 
CIELabFromRGB
®®< I
(
®®I J
$num
®®J L
,
®®L M
$num
®®N Q
,
®®Q R
$num
®®S V
,
®®V W
$num
®®X \
)
®®\ ]
}
®®^ _
,
®®_ `
{
¯¯ 
$str
¯¯ 
,
¯¯ 
CIELabFromRGB
¯¯< I
(
¯¯I J
$num
¯¯J M
,
¯¯M N
$num
¯¯O Q
,
¯¯Q R
$num
¯¯S V
,
¯¯V W
$num
¯¯X \
)
¯¯\ ]
}
¯¯^ _
,
¯¯_ `
{
°° 
$str
°° 
,
°° 
CIELabFromRGB
°°< I
(
°°I J
$num
°°J M
,
°°M N
$num
°°O R
,
°°R S
$num
°°T W
,
°°W X
$num
°°Y ]
)
°°] ^
}
°°_ `
,
°°` a
{
±± 
$str
±± 
,
±± 
CIELabFromRGB
±±< I
(
±±I J
$num
±±J M
,
±±M N
$num
±±O R
,
±±R S
$num
±±T W
,
±±W X
$num
±±Y ]
)
±±] ^
}
±±_ `
,
±±` a
{
²² 
$str
²² 
,
²² 
CIELabFromRGB
²²< I
(
²²I J
$num
²²J N
,
²²N O
$num
²²P S
,
²²S T
$num
²²U W
,
²²W X
$num
²²Y ]
)
²²] ^
}
²²_ `
,
²²` a
{
³³ 
$str
³³ 
,
³³ 
CIELabFromRGB
³³< I
(
³³I J
$num
³³J M
,
³³M N
$num
³³O R
,
³³R S
$num
³³T W
,
³³W X
$num
³³Y ]
)
³³] ^
}
³³_ `
,
³³` a
{
´´ 
$str
´´ 
,
´´ 
CIELabFromRGB
´´< I
(
´´I J
$num
´´J L
,
´´L M
$num
´´N P
,
´´P Q
$num
´´R U
,
´´U V
$num
´´W [
)
´´[ \
}
´´] ^
,
´´^ _
{
µµ 
$str
µµ  
,
µµ  !
CIELabFromRGB
µµ< I
(
µµI J
$num
µµJ M
,
µµM N
$num
µµO R
,
µµR S
$num
µµT W
,
µµW X
$num
µµY ]
)
µµ] ^
}
µµ_ `
,
µµ` a
{
¶¶ 
$str
¶¶ 
,
¶¶ 
CIELabFromRGB
¶¶< I
(
¶¶I J
$num
¶¶J N
,
¶¶N O
$num
¶¶P S
,
¶¶S T
$num
¶¶U Y
,
¶¶Y Z
$num
¶¶[ _
)
¶¶_ `
}
¶¶a b
,
¶¶b c
{
·· 
$str
·· 
,
·· 
CIELabFromRGB
··< I
(
··I J
$num
··J M
,
··M N
$num
··O R
,
··R S
$num
··T W
,
··W X
$num
··Y ]
)
··] ^
}
··_ `
,
··` a
{
¸¸ 
$str
¸¸ 
,
¸¸ 
CIELabFromRGB
¸¸< I
(
¸¸I J
$num
¸¸J M
,
¸¸M N
$num
¸¸O R
,
¸¸R S
$num
¸¸T W
,
¸¸W X
$num
¸¸Y ]
)
¸¸] ^
}
¸¸_ `
,
¸¸` a
{
¹¹ 
$str
¹¹ 
,
¹¹  
CIELabFromRGB
¹¹< I
(
¹¹I J
$num
¹¹J N
,
¹¹N O
$num
¹¹P S
,
¹¹S T
$num
¹¹U X
,
¹¹X Y
$num
¹¹Z ^
)
¹¹^ _
}
¹¹` a
,
¹¹a b
{
ºº 
$str
ºº #
,
ºº# $
CIELabFromRGB
ºº< I
(
ººI J
$num
ººJ M
,
ººM N
$num
ººO R
,
ººR S
$num
ººT W
,
ººW X
$num
ººY ]
)
ºº] ^
}
ºº_ `
,
ºº` a
{
»» 
$str
»» -
,
»»- .
CIELabFromRGB
»»< I
(
»»I J
$num
»»J M
,
»»M N
$num
»»O R
,
»»R S
$num
»»T W
,
»»W X
$num
»»Y ]
)
»»] ^
}
»»_ `
,
»»` a
{
¼¼ 
$str
¼¼ 
,
¼¼  
CIELabFromRGB
¼¼< I
(
¼¼I J
$num
¼¼J N
,
¼¼N O
$num
¼¼P T
,
¼¼T U
$num
¼¼V Y
,
¼¼Y Z
$num
¼¼[ _
)
¼¼_ `
}
¼¼a b
,
¼¼b c
{
½½ 
$str
½½ 
,
½½  
CIELabFromRGB
½½< I
(
½½I J
$num
½½J L
,
½½L M
$num
½½N Q
,
½½Q R
$num
½½S V
,
½½V W
$num
½½X \
)
½½\ ]
}
½½^ _
,
½½_ `
{
¾¾ 
$str
¾¾ 
,
¾¾ 
CIELabFromRGB
¾¾< I
(
¾¾I J
$num
¾¾J M
,
¾¾M N
$num
¾¾O Q
,
¾¾Q R
$num
¾¾S U
,
¾¾U V
$num
¾¾W [
)
¾¾[ \
}
¾¾] ^
,
¾¾^ _
{
¿¿ 
$str
¿¿ 
,
¿¿ 
CIELabFromRGB
¿¿< I
(
¿¿I J
$num
¿¿J M
,
¿¿M N
$num
¿¿O R
,
¿¿R S
$num
¿¿T W
,
¿¿W X
$num
¿¿Y ]
)
¿¿] ^
}
¿¿_ `
,
¿¿` a
{
ÀÀ 
$str
ÀÀ 
,
ÀÀ 
CIELabFromRGB
ÀÀ< I
(
ÀÀI J
$num
ÀÀJ M
,
ÀÀM N
$num
ÀÀO R
,
ÀÀR S
$num
ÀÀT W
,
ÀÀW X
$num
ÀÀY ]
)
ÀÀ] ^
}
ÀÀ_ `
,
ÀÀ` a
{
ÁÁ 
$str
ÁÁ 
,
ÁÁ 
CIELabFromRGB
ÁÁ< I
(
ÁÁI J
$num
ÁÁJ L
,
ÁÁL M
$num
ÁÁN Q
,
ÁÁQ R
$num
ÁÁS V
,
ÁÁV W
$num
ÁÁX \
)
ÁÁ\ ]
}
ÁÁ^ _
,
ÁÁ_ `
{
ÂÂ 
$str
ÂÂ 
,
ÂÂ 
CIELabFromRGB
ÂÂ< I
(
ÂÂI J
$num
ÂÂJ M
,
ÂÂM N
$num
ÂÂO Q
,
ÂÂQ R
$num
ÂÂS U
,
ÂÂU V
$num
ÂÂW [
)
ÂÂ[ \
}
ÂÂ] ^
,
ÂÂ^ _
{
ÃÃ 
$str
ÃÃ 
,
ÃÃ 
CIELabFromRGB
ÃÃ< I
(
ÃÃI J
$num
ÃÃJ N
,
ÃÃN O
$num
ÃÃP S
,
ÃÃS T
$num
ÃÃU W
,
ÃÃW X
$num
ÃÃY ]
)
ÃÃ] ^
}
ÃÃ_ `
,
ÃÃ` a
{
ÄÄ 
$str
ÄÄ .
,
ÄÄ. /
CIELabFromRGB
ÄÄ< I
(
ÄÄI J
$num
ÄÄJ M
,
ÄÄM N
$num
ÄÄO R
,
ÄÄR S
$num
ÄÄT V
,
ÄÄV W
$num
ÄÄX \
)
ÄÄ\ ]
}
ÄÄ^ _
,
ÄÄ_ `
{
ÅÅ 
$str
ÅÅ 
,
ÅÅ 
CIELabFromRGB
ÅÅ< I
(
ÅÅI J
$num
ÅÅJ M
,
ÅÅM N
$num
ÅÅO Q
,
ÅÅQ R
$num
ÅÅS V
,
ÅÅV W
$num
ÅÅX \
)
ÅÅ\ ]
}
ÅÅ^ _
,
ÅÅ_ `
{
ÆÆ 
$str
ÆÆ 
,
ÆÆ 
CIELabFromRGB
ÆÆ< I
(
ÆÆI J
$num
ÆÆJ M
,
ÆÆM N
$num
ÆÆO R
,
ÆÆR S
$num
ÆÆT W
,
ÆÆW X
$num
ÆÆY ]
)
ÆÆ] ^
}
ÆÆ_ `
,
ÆÆ` a
{
ÇÇ 
$str
ÇÇ 
,
ÇÇ 
CIELabFromRGB
ÇÇ< I
(
ÇÇI J
$num
ÇÇJ M
,
ÇÇM N
$num
ÇÇO R
,
ÇÇR S
$num
ÇÇT W
,
ÇÇW X
$num
ÇÇY ]
)
ÇÇ] ^
}
ÇÇ_ `
,
ÇÇ` a
{
ÈÈ 
$str
ÈÈ 
,
ÈÈ 
CIELabFromRGB
ÈÈ< I
(
ÈÈI J
$num
ÈÈJ M
,
ÈÈM N
$num
ÈÈO R
,
ÈÈR S
$num
ÈÈT W
,
ÈÈW X
$num
ÈÈY ]
)
ÈÈ] ^
}
ÈÈ_ `
,
ÈÈ` a
{
ÉÉ 
$str
ÉÉ 
,
ÉÉ 
CIELabFromRGB
ÉÉ< I
(
ÉÉI J
$num
ÉÉJ M
,
ÉÉM N
$num
ÉÉO Q
,
ÉÉQ R
$num
ÉÉS U
,
ÉÉU V
$num
ÉÉW [
)
ÉÉ[ \
}
ÉÉ] ^
,
ÉÉ^ _
{
ÊÊ 
$str
ÊÊ 
,
ÊÊ 
CIELabFromRGB
ÊÊ< I
(
ÊÊI J
$num
ÊÊJ M
,
ÊÊM N
$num
ÊÊO R
,
ÊÊR S
$num
ÊÊT W
,
ÊÊW X
$num
ÊÊY ]
)
ÊÊ] ^
}
ÊÊ_ `
,
ÊÊ` a
{
ËË 
$str
ËË 
,
ËË 
CIELabFromRGB
ËË< I
(
ËËI J
$num
ËËJ M
,
ËËM N
$num
ËËO R
,
ËËR S
$num
ËËT W
,
ËËW X
$num
ËËY ]
)
ËË] ^
}
ËË_ `
,
ËË` a
{
ÌÌ 
$str
ÌÌ 
,
ÌÌ 
CIELabFromRGB
ÌÌ< I
(
ÌÌI J
$num
ÌÌJ M
,
ÌÌM N
$num
ÌÌO R
,
ÌÌR S
$num
ÌÌT W
,
ÌÌW X
$num
ÌÌY ]
)
ÌÌ] ^
}
ÌÌ_ `
,
ÌÌ` a
{
ÍÍ 
$str
ÍÍ 
,
ÍÍ 
CIELabFromRGB
ÍÍ< I
(
ÍÍI J
$num
ÍÍJ M
,
ÍÍM N
$num
ÍÍO R
,
ÍÍR S
$num
ÍÍT W
,
ÍÍW X
$num
ÍÍY ]
)
ÍÍ] ^
}
ÍÍ_ `
,
ÍÍ` a
{
ÎÎ 
$str
ÎÎ  
,
ÎÎ  !
CIELabFromRGB
ÎÎ< I
(
ÎÎI J
$num
ÎÎJ M
,
ÎÎM N
$num
ÎÎO R
,
ÎÎR S
$num
ÎÎT W
,
ÎÎW X
$num
ÎÎY ]
)
ÎÎ] ^
}
ÎÎ_ `
,
ÎÎ` a
{
ÏÏ 
$str
ÏÏ 
,
ÏÏ  
CIELabFromRGB
ÏÏ< I
(
ÏÏI J
$num
ÏÏJ M
,
ÏÏM N
$num
ÏÏO R
,
ÏÏR S
$num
ÏÏT X
,
ÏÏX Y
$num
ÏÏZ ^
)
ÏÏ^ _
}
ÏÏ` a
,
ÏÏa b
{
ĞĞ 
$str
ĞĞ *
,
ĞĞ* +
CIELabFromRGB
ĞĞ< I
(
ĞĞI J
$num
ĞĞJ M
,
ĞĞM N
$num
ĞĞO R
,
ĞĞR S
$num
ĞĞT W
,
ĞĞW X
$num
ĞĞY ]
)
ĞĞ] ^
}
ĞĞ_ `
,
ĞĞ` a
{
ÑÑ 
$str
ÑÑ "
,
ÑÑ" #
CIELabFromRGB
ÑÑ< I
(
ÑÑI J
$num
ÑÑJ N
,
ÑÑN O
$num
ÑÑP S
,
ÑÑS T
$num
ÑÑU X
,
ÑÑX Y
$num
ÑÑZ ^
)
ÑÑ^ _
}
ÑÑ` a
,
ÑÑa b
{
ÒÒ 
$str
ÒÒ  
,
ÒÒ  !
CIELabFromRGB
ÒÒ< I
(
ÒÒI J
$num
ÒÒJ N
,
ÒÒN O
$num
ÒÒP S
,
ÒÒS T
$num
ÒÒU X
,
ÒÒX Y
$num
ÒÒZ ^
)
ÒÒ^ _
}
ÒÒ` a
,
ÒÒa b
{
ÓÓ 
$str
ÓÓ  
,
ÓÓ  !
CIELabFromRGB
ÓÓ< I
(
ÓÓI J
$num
ÓÓJ N
,
ÓÓN O
$num
ÓÓP T
,
ÓÓT U
$num
ÓÓV Y
,
ÓÓY Z
$num
ÓÓ[ _
)
ÓÓ_ `
}
ÓÓa b
,
ÓÓb c
{
ÔÔ 
$str
ÔÔ 
,
ÔÔ 
CIELabFromRGB
ÔÔ< I
(
ÔÔI J
$num
ÔÔJ M
,
ÔÔM N
$num
ÔÔO Q
,
ÔÔQ R
$num
ÔÔS W
,
ÔÔW X
$num
ÔÔY ]
)
ÔÔ] ^
}
ÔÔ_ `
,
ÔÔ` a
{
ÕÕ 
$str
ÕÕ $
,
ÕÕ$ %
CIELabFromRGB
ÕÕ< I
(
ÕÕI J
$num
ÕÕJ M
,
ÕÕM N
$num
ÕÕO Q
,
ÕÕQ R
$num
ÕÕS W
,
ÕÕW X
$num
ÕÕY ]
)
ÕÕ] ^
}
ÕÕ_ `
,
ÕÕ` a
{
ÖÖ 
$str
ÖÖ 
,
ÖÖ 
CIELabFromRGB
ÖÖ< I
(
ÖÖI J
$num
ÖÖJ M
,
ÖÖM N
$num
ÖÖO Q
,
ÖÖQ R
$num
ÖÖS V
,
ÖÖV W
$num
ÖÖX \
)
ÖÖ\ ]
}
ÖÖ^ _
,
ÖÖ_ `
{
×× 
$str
×× 
,
×× 
CIELabFromRGB
××< I
(
××I J
$num
××J M
,
××M N
$num
××O R
,
××R S
$num
××T W
,
××W X
$num
××Y ]
)
××] ^
}
××_ `
,
××` a
{
ØØ 
$str
ØØ 
,
ØØ 
CIELabFromRGB
ØØ< I
(
ØØI J
$num
ØØJ M
,
ØØM N
$num
ØØO R
,
ØØR S
$num
ØØT W
,
ØØW X
$num
ØØY ]
)
ØØ] ^
}
ØØ_ `
,
ØØ` a
{
ÙÙ 
$str
ÙÙ 
,
ÙÙ 
CIELabFromRGB
ÙÙ< I
(
ÙÙI J
$num
ÙÙJ M
,
ÙÙM N
$num
ÙÙO R
,
ÙÙR S
$num
ÙÙT W
,
ÙÙW X
$num
ÙÙY ]
)
ÙÙ] ^
}
ÙÙ_ `
,
ÙÙ` a
{
ÚÚ 
$str
ÚÚ 
,
ÚÚ 
CIELabFromRGB
ÚÚ< I
(
ÚÚI J
$num
ÚÚJ M
,
ÚÚM N
$num
ÚÚO R
,
ÚÚR S
$num
ÚÚT W
,
ÚÚW X
$num
ÚÚY ]
)
ÚÚ] ^
}
ÚÚ_ `
,
ÚÚ` a
{
ÛÛ 
$str
ÛÛ 
,
ÛÛ 
CIELabFromRGB
ÛÛ< I
(
ÛÛI J
$num
ÛÛJ L
,
ÛÛL M
$num
ÛÛN Q
,
ÛÛQ R
$num
ÛÛS V
,
ÛÛV W
$num
ÛÛX \
)
ÛÛ\ ]
}
ÛÛ^ _
,
ÛÛ_ `
{
ÜÜ 
$str
ÜÜ 
,
ÜÜ 
CIELabFromRGB
ÜÜ< I
(
ÜÜI J
$num
ÜÜJ M
,
ÜÜM N
$num
ÜÜO R
,
ÜÜR S
$num
ÜÜT W
,
ÜÜW X
$num
ÜÜY ]
)
ÜÜ] ^
}
ÜÜ_ `
,
ÜÜ` a
{
İİ 
$str
İİ 
,
İİ 
CIELabFromRGB
İİ< I
(
İİI J
$num
İİJ M
,
İİM N
$num
İİO R
,
İİR S
$num
İİT V
,
İİV W
$num
İİX \
)
İİ\ ]
}
İİ^ _
,
İİ_ `
{
ŞŞ 
$str
ŞŞ 
,
ŞŞ 
CIELabFromRGB
ŞŞ< I
(
ŞŞI J
$num
ŞŞJ M
,
ŞŞM N
$num
ŞŞO R
,
ŞŞR S
$num
ŞŞT W
,
ŞŞW X
$num
ŞŞY ]
)
ŞŞ] ^
}
ŞŞ_ `
,
ŞŞ` a
{
ßß 
$str
ßß 
,
ßß 
CIELabFromRGB
ßß< I
(
ßßI J
$num
ßßJ M
,
ßßM N
$num
ßßO R
,
ßßR S
$num
ßßT W
,
ßßW X
$num
ßßY ]
)
ßß] ^
}
ßß_ `
,
ßß` a
{
àà 
$str
àà 
,
àà 
CIELabFromRGB
àà< I
(
ààI J
$num
ààJ M
,
ààM N
$num
ààO R
,
ààR S
$num
ààT W
,
ààW X
$num
ààY ]
)
àà] ^
}
àà_ `
,
àà` a
{
áá 
$str
áá 
,
áá 
CIELabFromRGB
áá< I
(
ááI J
$num
ááJ L
,
ááL M
$num
ááN Q
,
ááQ R
$num
ááS V
,
ááV W
$num
ááX \
)
áá\ ]
}
áá^ _
,
áá_ `
{
ââ 
$str
ââ 
,
ââ 
CIELabFromRGB
ââ< I
(
ââI J
$num
ââJ M
,
ââM N
$num
ââO Q
,
ââQ R
$num
ââS V
,
ââV W
$num
ââX \
)
ââ\ ]
}
ââ^ _
,
ââ_ `
{
ãã 
$str
ãã 
,
ãã 
CIELabFromRGB
ãã< I
(
ããI J
$num
ããJ N
,
ããN O
$num
ããP S
,
ããS T
$num
ããU W
,
ããW X
$num
ããY ]
)
ãã] ^
}
ãã_ `
,
ãã` a
{
ää 
$str
ää  
,
ää  !
CIELabFromRGB
ää< I
(
ääI J
$num
ääJ M
,
ääM N
$num
ääO R
,
ääR S
$num
ääT V
,
ääV W
$num
ääX \
)
ää\ ]
}
ää^ _
,
ää_ `
{
åå 
$str
åå 
,
åå  
CIELabFromRGB
åå< I
(
ååI J
$num
ååJ L
,
ååL M
$num
ååN Q
,
ååQ R
$num
ååS V
,
ååV W
$num
ååX \
)
åå\ ]
}
åå^ _
,
åå_ `
{
ææ 
$str
ææ 
,
ææ 
CIELabFromRGB
ææ< I
(
ææI J
$num
ææJ M
,
ææM N
$num
ææO Q
,
ææQ R
$num
ææS V
,
ææV W
$num
ææX \
)
ææ\ ]
}
ææ^ _
,
ææ_ `
{
çç 
$str
çç 
,
çç 
CIELabFromRGB
çç< I
(
ççI J
$num
ççJ N
,
ççN O
$num
ççP S
,
ççS T
$num
ççU W
,
ççW X
$num
ççY ]
)
çç] ^
}
çç_ `
,
çç` a
{
èè 
$str
èè !
,
èè! "
CIELabFromRGB
èè< I
(
èèI J
$num
èèJ N
,
èèN O
$num
èèP S
,
èèS T
$num
èèU W
,
èèW X
$num
èèY ]
)
èè] ^
}
èè_ `
,
èè` a
{
éé 
$str
éé 
,
éé 
CIELabFromRGB
éé< I
(
ééI J
$num
ééJ M
,
ééM N
$num
ééO Q
,
ééQ R
$num
ééS W
,
ééW X
$num
ééY ]
)
éé] ^
}
éé_ `
,
éé` a
{
êê 
$str
êê 
,
êê  
CIELabFromRGB
êê< I
(
êêI J
$num
êêJ N
,
êêN O
$num
êêP R
,
êêR S
$num
êêT W
,
êêW X
$num
êêY ]
)
êê] ^
}
êê_ `
,
êê` a
{
ëë 
$str
ëë 
,
ëë 
CIELabFromRGB
ëë< I
(
ëëI J
$num
ëëJ M
,
ëëM N
$num
ëëO Q
,
ëëQ R
$num
ëëS V
,
ëëV W
$num
ëëX \
)
ëë\ ]
}
ëë^ _
,
ëë_ `
{
ìì 
$str
ìì !
,
ìì! "
CIELabFromRGB
ìì< I
(
ììI J
$num
ììJ M
,
ììM N
$num
ììO R
,
ììR S
$num
ììT W
,
ììW X
$num
ììY ]
)
ìì] ^
}
ìì_ `
,
ìì` a
{
íí 
$str
íí 
,
íí 
CIELabFromRGB
íí< I
(
ííI J
$num
ííJ L
,
ííL M
$num
ííN Q
,
ííQ R
$num
ííS W
,
ííW X
$num
ííY ]
)
íí] ^
}
íí_ `
,
íí` a
{
îî 
$str
îî 
,
îî 
CIELabFromRGB
îî< I
(
îîI J
$num
îîJ M
,
îîM N
$num
îîO R
,
îîR S
$num
îîT W
,
îîW X
$num
îîY ]
)
îî] ^
}
îî_ `
,
îî` a
{
ïï 
$str
ïï 
,
ïï  
CIELabFromRGB
ïï< I
(
ïïI J
$num
ïïJ N
,
ïïN O
$num
ïïP S
,
ïïS T
$num
ïïU X
,
ïïX Y
$num
ïïZ ^
)
ïï^ _
}
ïï` a
,
ïïa b
{
ğğ 
$str
ğğ 
,
ğğ  
CIELabFromRGB
ğğ< I
(
ğğI J
$num
ğğJ M
,
ğğM N
$num
ğğO R
,
ğğR S
$num
ğğT W
,
ğğW X
$num
ğğY ]
)
ğğ] ^
}
ğğ_ `
,
ğğ` a
{
ññ 
$str
ññ 
,
ññ 
CIELabFromRGB
ññ< I
(
ññI J
$num
ññJ M
,
ññM N
$num
ññO Q
,
ññQ R
$num
ññS W
,
ññW X
$num
ññY ]
)
ññ] ^
}
ññ_ `
,
ññ` a
{
òò 
$str
òò 
,
òò 
CIELabFromRGB
òò< I
(
òòI J
$num
òòJ N
,
òòN O
$num
òòP S
,
òòS T
$num
òòU W
,
òòW X
$num
òòY ]
)
òò] ^
}
òò_ `
,
òò` a
{
óó 
$str
óó 
,
óó 
CIELabFromRGB
óó< I
(
óóI J
$num
óóJ L
,
óóL M
$num
óóN Q
,
óóQ R
$num
óóS V
,
óóV W
$num
óóX \
)
óó\ ]
}
óó^ _
,
óó_ `
{
ôô 
$str
ôô 
,
ôô 
CIELabFromRGB
ôô< I
(
ôôI J
$num
ôôJ M
,
ôôM N
$num
ôôO R
,
ôôR S
$num
ôôT W
,
ôôW X
$num
ôôY ]
)
ôô] ^
}
ôô_ `
,
ôô` a
{
õõ 
$str
õõ 
,
õõ 
CIELabFromRGB
õõ< I
(
õõI J
$num
õõJ M
,
õõM N
$num
õõO R
,
õõR S
$num
õõT W
,
õõW X
$num
õõY ]
)
õõ] ^
}
õõ_ `
,
õõ` a
{
öö 
$str
öö 
,
öö 
CIELabFromRGB
öö< I
(
ööI J
$num
ööJ M
,
ööM N
$num
ööO R
,
ööR S
$num
ööT W
,
ööW X
$num
ööY ]
)
öö] ^
}
öö_ `
,
öö` a
{
÷÷ 
$str
÷÷ 
,
÷÷ 
CIELabFromRGB
÷÷< I
(
÷÷I J
$num
÷÷J N
,
÷÷N O
$num
÷÷P T
,
÷÷T U
$num
÷÷V Z
,
÷÷Z [
$num
÷÷\ `
)
÷÷` a
}
÷÷b c
,
÷÷c d
{
øø 
$str
øø 
,
øø 
CIELabFromRGB
øø< I
(
øøI J
$num
øøJ M
,
øøM N
$num
øøO R
,
øøR S
$num
øøT W
,
øøW X
$num
øøY ]
)
øø] ^
}
øø_ `
,
øø` a
{
ùù 
$str
ùù  
,
ùù  !
CIELabFromRGB
ùù< I
(
ùùI J
$num
ùùJ M
,
ùùM N
$num
ùùO R
,
ùùR S
$num
ùùT W
,
ùùW X
$num
ùùY ]
)
ùù] ^
}
ùù_ `
,
ùù` a
{
úú 
$str
úú 
,
úú 
CIELabFromRGB
úú< I
(
úúI J
$num
úúJ M
,
úúM N
$num
úúO R
,
úúR S
$num
úúT W
,
úúW X
$num
úúY ]
)
úú] ^
}
úú_ `
,
úú` a
{
ûû 
$str
ûû 
,
ûû  
CIELabFromRGB
ûû< I
(
ûûI J
$num
ûûJ N
,
ûûN O
$num
ûûP S
,
ûûS T
$num
ûûU X
,
ûûX Y
$num
ûûZ ^
)
ûû^ _
}
ûû` a
,
ûûa b
{
üü 
$str
üü 
,
üü  
CIELabFromRGB
üü< I
(
üüI J
$num
üüJ M
,
üüM N
$num
üüO R
,
üüR S
$num
üüT W
,
üüW X
$num
üüY ]
)
üü] ^
}
üü_ `
,
üü` a
{
ıı 
$str
ıı  
,
ıı  !
CIELabFromRGB
ıı< I
(
ııI J
$num
ııJ M
,
ııM N
$num
ııO R
,
ııR S
$num
ııT V
,
ııV W
$num
ııX \
)
ıı\ ]
}
ıı^ _
,
ıı_ `
{
şş 
$str
şş 
,
şş 
CIELabFromRGB
şş< I
(
şşI J
$num
şşJ M
,
şşM N
$num
şşO R
,
şşR S
$num
şşT V
,
şşV W
$num
şşX \
)
şş\ ]
}
şş^ _
,
şş_ `
{
ÿÿ 
$str
ÿÿ 
,
ÿÿ 
CIELabFromRGB
ÿÿ< I
(
ÿÿI J
$num
ÿÿJ M
,
ÿÿM N
$num
ÿÿO R
,
ÿÿR S
$num
ÿÿT W
,
ÿÿW X
$num
ÿÿY ]
)
ÿÿ] ^
}
ÿÿ_ `
,
ÿÿ` a
{
€€ 
$str
€€ 
,
€€ 
CIELabFromRGB
€€< I
(
€€I J
$num
€€J M
,
€€M N
$num
€€O R
,
€€R S
$num
€€T W
,
€€W X
$num
€€Y ]
)
€€] ^
}
€€_ `
,
€€` a
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
‚‚ 
$str
‚‚ 
,
‚‚ 
CIELabFromRGB
‚‚< I
(
‚‚I J
$num
‚‚J M
,
‚‚M N
$num
‚‚O R
,
‚‚R S
$num
‚‚T W
,
‚‚W X
$num
‚‚Y ]
)
‚‚] ^
}
‚‚_ `
,
‚‚` a
{
ƒƒ 
$str
ƒƒ 
,
ƒƒ 
CIELabFromRGB
ƒƒ< I
(
ƒƒI J
$num
ƒƒJ M
,
ƒƒM N
$num
ƒƒO R
,
ƒƒR S
$num
ƒƒT W
,
ƒƒW X
$num
ƒƒY ]
)
ƒƒ] ^
}
ƒƒ_ `
,
ƒƒ` a
{
„„ 
$str
„„ 
,
„„ 
CIELabFromRGB
„„< I
(
„„I J
$num
„„J L
,
„„L M
$num
„„N Q
,
„„Q R
$num
„„S V
,
„„V W
$num
„„X \
)
„„\ ]
}
„„^ _
,
„„_ `
{
…… 
$str
…… 
,
…… 
CIELabFromRGB
……< I
(
……I J
$num
……J M
,
……M N
$num
……O R
,
……R S
$num
……T W
,
……W X
$num
……Y ]
)
……] ^
}
……_ `
,
……` a
{
†† 
$str
†† 
,
†† 
CIELabFromRGB
††< I
(
††I J
$num
††J N
,
††N O
$num
††P T
,
††T U
$num
††V X
,
††X Y
$num
††Z ^
)
††^ _
}
††` a
,
††a b
{
‡‡ 
$str
‡‡  
,
‡‡  !
CIELabFromRGB
‡‡< I
(
‡‡I J
$num
‡‡J M
,
‡‡M N
$num
‡‡O R
,
‡‡R S
$num
‡‡T W
,
‡‡W X
$num
‡‡Y ]
)
‡‡] ^
}
‡‡_ `
,
‡‡` a
{
ˆˆ 
$str
ˆˆ  
,
ˆˆ  !
CIELabFromRGB
ˆˆ< I
(
ˆˆI J
$num
ˆˆJ M
,
ˆˆM N
$num
ˆˆO R
,
ˆˆR S
$num
ˆˆT V
,
ˆˆV W
$num
ˆˆX \
)
ˆˆ\ ]
}
ˆˆ^ _
,
ˆˆ_ `
{
‰‰ 
$str
‰‰ 
,
‰‰ 
CIELabFromRGB
‰‰< I
(
‰‰I J
$num
‰‰J N
,
‰‰N O
$num
‰‰P S
,
‰‰S T
$num
‰‰U W
,
‰‰W X
$num
‰‰Y ]
)
‰‰] ^
}
‰‰_ `
,
‰‰` a
{
ŠŠ 
$str
ŠŠ  
,
ŠŠ  !
CIELabFromRGB
ŠŠ< I
(
ŠŠI J
$num
ŠŠJ N
,
ŠŠN O
$num
ŠŠP S
,
ŠŠS T
$num
ŠŠU W
,
ŠŠW X
$num
ŠŠY ]
)
ŠŠ] ^
}
ŠŠ_ `
,
ŠŠ` a
{
‹‹ 
$str
‹‹  
,
‹‹  !
CIELabFromRGB
‹‹< I
(
‹‹I J
$num
‹‹J N
,
‹‹N O
$num
‹‹P S
,
‹‹S T
$num
‹‹U W
,
‹‹W X
$num
‹‹Y ]
)
‹‹] ^
}
‹‹_ `
,
‹‹` a
{
ŒŒ 
$str
ŒŒ 
,
ŒŒ 
CIELabFromRGB
ŒŒ< I
(
ŒŒI J
$num
ŒŒJ N
,
ŒŒN O
$num
ŒŒP T
,
ŒŒT U
$num
ŒŒV Y
,
ŒŒY Z
$num
ŒŒ[ _
)
ŒŒ_ `
}
ŒŒa b
,
ŒŒb c
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J M
,
M N
$num
O R
,
R S
$num
T W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J N
,
N O
$num
P S
,
S T
$num
U X
,
X Y
$num
Z ^
)
^ _
}
` a
,
a b
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J N
,
N O
$num
P S
,
S T
$num
U W
,
W X
$num
Y ]
)
] ^
}
_ `
,
` a
{
 
$str
 
,
 
CIELabFromRGB
< I
(
I J
$num
J L
,
L M
$num
N P
,
P Q
$num
R U
,
U V
$num
W [
)
[ \
}
] ^
,
^ _
{
‘‘ 
$str
‘‘ !
,
‘‘! "
CIELabFromRGB
‘‘< I
(
‘‘I J
$num
‘‘J M
,
‘‘M N
$num
‘‘O Q
,
‘‘Q R
$num
‘‘S U
,
‘‘U V
$num
‘‘W [
)
‘‘[ \
}
‘‘] ^
,
‘‘^ _
{
’’ 
$str
’’ 
,
’’ 
CIELabFromRGB
’’< I
(
’’I J
$num
’’J M
,
’’M N
$num
’’O R
,
’’R S
$num
’’T W
,
’’W X
$num
’’Y ]
)
’’] ^
}
’’_ `
}
““ 	
;
““	 

}
”” 
}•• õê
˜D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\VertexEditing.cs
	namespace

 	
UnityEngine


 
.

 

ProBuilder

  
.

  !
MeshOperations

! /
{ 
public 

static 
class 
VertexEditing %
{ 
public 
static 
int 
MergeVertices '
(' (
this( ,
ProBuilderMesh- ;
mesh< @
,@ A
intB E
[E F
]F G
indexesH O
,O P
boolQ U
collapseToFirstV e
=f g
falseh m
)m n
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new !
ArgumentNullException /
(/ 0
$str0 6
)6 7
;7 8
if   
(   
indexes   
==   
null   
)    
throw!! 
new!! !
ArgumentNullException!! /
(!!/ 0
$str!!0 9
)!!9 :
;!!: ;
Vertex## 
[## 
]## 
vertices## 
=## 
mesh##  $
.##$ %
GetVertices##% 0
(##0 1
)##1 2
;##2 3
Vertex$$ 
cen$$ 
=$$ 
collapseToFirst$$ (
?$$) *
vertices$$+ 3
[$$3 4
indexes$$4 ;
[$$; <
$num$$< =
]$$= >
]$$> ?
:$$@ A
Vertex$$B H
.$$H I
Average$$I P
($$P Q
vertices$$Q Y
,$$Y Z
indexes$$[ b
)$$b c
;$$c d
mesh%% 
.%% !
SetVerticesCoincident%% &
(%%& '
indexes%%' .
)%%. /
;%%/ 0
	UVEditing&& 
.&& 
SplitUVs&& 
(&& 
mesh&& #
,&&# $
indexes&&% ,
)&&, -
;&&- .
int'' 
sharedVertexHandle'' "
=''# $
mesh''% )
.'') *!
GetSharedVertexHandle''* ?
(''? @
indexes''@ G
.''G H
First''H M
(''M N
)''N O
)''O P
;''P Q
mesh(( 
.(( !
SetSharedVertexValues(( &
(((& '
sharedVertexHandle((' 9
,((9 :
cen((; >
)((> ?
;((? @
SharedVertex** 
merged** 
=**  !
mesh**" &
.**& '"
sharedVerticesInternal**' =
[**= >
sharedVertexHandle**> P
]**P Q
;**Q R
List++ 
<++ 
int++ 
>++ 
removedIndexes++ $
=++% &
new++' *
List+++ /
<++/ 0
int++0 3
>++3 4
(++4 5
)++5 6
;++6 7
MeshValidation-- 
.-- %
RemoveDegenerateTriangles-- 4
(--4 5
mesh--5 9
,--9 :
removedIndexes--; I
)--I J
;--J K
int00 
ind00 
=00 
-00 
$num00 
;00 
for11 
(11 
int11 
i11 
=11 
$num11 
;11 
i11 
<11 
merged11  &
.11& '
Count11' ,
;11, -
i11. /
++11/ 1
)111 2
if22 
(22 
!22 
removedIndexes22 #
.22# $
Contains22$ ,
(22, -
merged22- 3
[223 4
i224 5
]225 6
)226 7
)227 8
ind33 
=33 
merged33  
[33  !
i33! "
]33" #
;33# $
int55 
res55 
=55 
ind55 
;55 
for77 
(77 
int77 
i77 
=77 
$num77 
;77 
i77 
<77 
removedIndexes77  .
.77. /
Count77/ 4
;774 5
i776 7
++777 9
)779 :
if88 
(88 
ind88 
>88 
removedIndexes88 (
[88( )
i88) *
]88* +
)88+ ,
res99 
--99 
;99 
return;; 
res;; 
;;; 
}<< 	
publicGG 
staticGG 
voidGG 
SplitVerticesGG (
(GG( )
thisGG) -
ProBuilderMeshGG. <
meshGG= A
,GGA B
EdgeGGC G
edgeGGH L
)GGL M
{HH 	
SplitVerticesII 
(II 
meshII 
,II 
newII  #
intII$ '
[II' (
]II( )
{II* +
edgeII, 0
.II0 1
aII1 2
,II2 3
edgeII4 8
.II8 9
bII9 :
}II; <
)II< =
;II= >
}JJ 	
publicRR 
staticRR 
voidRR 
SplitVerticesRR (
(RR( )
thisRR) -
ProBuilderMeshRR. <
meshRR= A
,RRA B
IEnumerableRRC N
<RRN O
intRRO R
>RRR S
verticesRRT \
)RR\ ]
{SS 	
ifTT 
(TT 
meshTT 
==TT 
nullTT 
)TT 
throwUU 
newUU !
ArgumentNullExceptionUU /
(UU/ 0
$strUU0 6
)UU6 7
;UU7 8
ifWW 
(WW 
verticesWW 
==WW 
nullWW  
)WW  !
throwXX 
newXX !
ArgumentNullExceptionXX /
(XX/ 0
$strXX0 :
)XX: ;
;XX; <

Dictionary[[ 
<[[ 
int[[ 
,[[ 
int[[ 
>[[  
lookup[[! '
=[[( )
mesh[[* .
.[[. /
sharedVertexLookup[[/ A
;[[A B
int\\ 
max\\ 
=\\ 
lookup\\ 
.\\ 
Count\\ "
(\\" #
)\\# $
;\\$ %
foreach]] 
(]] 
int]] 
i]] 
in]] 
vertices]] &
)]]& '
lookup^^ 
[^^ 
i^^ 
]^^ 
=^^ 
++^^ 
max^^ !
;^^! "
mesh__ 
.__ 
SetSharedVertices__ "
(__" #
lookup__# )
)__) *
;__* +
}`` 	
publicii 
staticii 
intii 
[ii 
]ii 
WeldVerticesii (
(ii( )
thisii) -
ProBuilderMeshii. <
meshii= A
,iiA B
IEnumerableiiC N
<iiN O
intiiO R
>iiR S
indexesiiT [
,ii[ \
floatii] b
neighborRadiusiic q
)iiq r
{jj 	
ifkk 
(kk 
meshkk 
==kk 
nullkk 
)kk 
throwll 
newll !
ArgumentNullExceptionll /
(ll/ 0
$strll0 6
)ll6 7
;ll7 8
ifnn 
(nn 
indexesnn 
==nn 
nullnn 
)nn  
throwoo 
newoo !
ArgumentNullExceptionoo /
(oo/ 0
$stroo0 9
)oo9 :
;oo: ;
Vertexqq 
[qq 
]qq 
verticesqq 
=qq 
meshqq  $
.qq$ %
GetVerticesqq% 0
(qq0 1
)qq1 2
;qq2 3
SharedVertexrr 
[rr 
]rr 
sharedIndexesrr (
=rr) *
meshrr+ /
.rr/ 0"
sharedVerticesInternalrr0 F
;rrF G
HashSettt 
<tt 
inttt 
>tt 
commontt 
=tt  !
meshtt" &
.tt& '"
GetSharedVertexHandlestt' =
(tt= >
indexestt> E
)ttE F
;ttF G
intuu 
vertexCountuu 
=uu 
commonuu $
.uu$ %
Countuu% *
;uu* +
int{{ 
maxNearestNeighbors{{ #
={{$ %
System{{& ,
.{{, -
Math{{- 1
.{{1 2
Min{{2 5
({{5 6
$num{{6 8
,{{8 9
common{{: @
.{{@ A
Count{{A F
({{F G
){{G H
){{H I
;{{I J
KdTree~~ 
<~~ 
float~~ 
,~~ 
int~~ 
>~~ 
tree~~ #
=~~$ %
new~~& )
KdTree~~* 0
<~~0 1
float~~1 6
,~~6 7
int~~8 ;
>~~; <
(~~< =
$num~~= >
,~~> ?
new~~@ C
	FloatMath~~D M
(~~M N
)~~N O
,~~O P 
AddDuplicateBehavior~~Q e
.~~e f
Collect~~f m
)~~m n
;~~n o
foreach
€€ 
(
€€ 
int
€€ 
i
€€ 
in
€€ 
common
€€ $
)
€€$ %
{
 
Vector3
‚‚ 
v
‚‚ 
=
‚‚ 
vertices
‚‚ $
[
‚‚$ %
sharedIndexes
‚‚% 2
[
‚‚2 3
i
‚‚3 4
]
‚‚4 5
[
‚‚5 6
$num
‚‚6 7
]
‚‚7 8
]
‚‚8 9
.
‚‚9 :
position
‚‚: B
;
‚‚B C
tree
ƒƒ 
.
ƒƒ 
Add
ƒƒ 
(
ƒƒ 
new
ƒƒ 
float
ƒƒ "
[
ƒƒ" #
]
ƒƒ# $
{
ƒƒ% &
v
ƒƒ' (
.
ƒƒ( )
x
ƒƒ) *
,
ƒƒ* +
v
ƒƒ, -
.
ƒƒ- .
y
ƒƒ. /
,
ƒƒ/ 0
v
ƒƒ1 2
.
ƒƒ2 3
z
ƒƒ3 4
}
ƒƒ5 6
,
ƒƒ6 7
i
ƒƒ8 9
)
ƒƒ9 :
;
ƒƒ: ;
}
„„ 
float
†† 
[
†† 
]
†† 
point
†† 
=
†† 
new
†† 
float
††  %
[
††% &
$num
††& '
]
††' (
{
††) *
$num
††+ ,
,
††, -
$num
††. /
,
††/ 0
$num
††1 2
}
††3 4
;
††4 5

Dictionary
‡‡ 
<
‡‡ 
int
‡‡ 
,
‡‡ 
int
‡‡ 
>
‡‡  
remapped
‡‡! )
=
‡‡* +
new
‡‡, /

Dictionary
‡‡0 :
<
‡‡: ;
int
‡‡; >
,
‡‡> ?
int
‡‡@ C
>
‡‡C D
(
‡‡D E
)
‡‡E F
;
‡‡F G

Dictionary
ˆˆ 
<
ˆˆ 
int
ˆˆ 
,
ˆˆ 
Vector3
ˆˆ #
>
ˆˆ# $
averages
ˆˆ% -
=
ˆˆ. /
new
ˆˆ0 3

Dictionary
ˆˆ4 >
<
ˆˆ> ?
int
ˆˆ? B
,
ˆˆB C
Vector3
ˆˆD K
>
ˆˆK L
(
ˆˆL M
)
ˆˆM N
;
ˆˆN O
int
‰‰ 
index
‰‰ 
=
‰‰ 
sharedIndexes
‰‰ %
.
‰‰% &
Length
‰‰& ,
;
‰‰, -
foreach
‹‹ 
(
‹‹ 
int
‹‹ 
commonIndex
‹‹ $
in
‹‹% '
common
‹‹( .
)
‹‹. /
{
ŒŒ 
if
 
(
 
remapped
 
.
 
ContainsKey
 (
(
( )
commonIndex
) 4
)
4 5
)
5 6
continue
 
;
 
Vector3
‘‘ 
v
‘‘ 
=
‘‘ 
vertices
‘‘ $
[
‘‘$ %
sharedIndexes
‘‘% 2
[
‘‘2 3
commonIndex
‘‘3 >
]
‘‘> ?
[
‘‘? @
$num
‘‘@ A
]
‘‘A B
]
‘‘B C
.
‘‘C D
position
‘‘D L
;
‘‘L M
point
““ 
[
““ 
$num
““ 
]
““ 
=
““ 
v
““ 
.
““ 
x
““ 
;
““ 
point
”” 
[
”” 
$num
”” 
]
”” 
=
”” 
v
”” 
.
”” 
y
”” 
;
”” 
point
•• 
[
•• 
$num
•• 
]
•• 
=
•• 
v
•• 
.
•• 
z
•• 
;
•• 

KdTreeNode
˜˜ 
<
˜˜ 
float
˜˜  
,
˜˜  !
int
˜˜" %
>
˜˜% &
[
˜˜& '
]
˜˜' (
	neighbors
˜˜) 2
=
˜˜3 4
tree
˜˜5 9
.
˜˜9 :
RadialSearch
˜˜: F
(
˜˜F G
point
˜˜G L
,
˜˜L M
neighborRadius
˜˜N \
,
˜˜\ ]!
maxNearestNeighbors
˜˜^ q
)
˜˜q r
;
˜˜r s
if
œœ 
(
œœ !
maxNearestNeighbors
œœ '
<
œœ( )
vertexCount
œœ* 5
&&
œœ6 8
	neighbors
œœ9 B
.
œœB C
Length
œœC I
>=
œœJ L!
maxNearestNeighbors
œœM `
)
œœ` a
{
 
	neighbors
 
=
 
tree
  $
.
$ %
RadialSearch
% 1
(
1 2
point
2 7
,
7 8
neighborRadius
9 G
,
G H
vertexCount
I T
)
T U
;
U V!
maxNearestNeighbors
ŸŸ '
=
ŸŸ( )
System
ŸŸ* 0
.
ŸŸ0 1
Math
ŸŸ1 5
.
ŸŸ5 6
Min
ŸŸ6 9
(
ŸŸ9 :
vertexCount
ŸŸ: E
,
ŸŸE F
	neighbors
ŸŸG P
.
ŸŸP Q
Length
ŸŸQ W
+
ŸŸX Y
	neighbors
ŸŸZ c
.
ŸŸc d
Length
ŸŸd j
/
ŸŸk l
$num
ŸŸm n
)
ŸŸn o
;
ŸŸo p
}
   
Vector3
¢¢ 
avg
¢¢ 
=
¢¢ 
Vector3
¢¢ %
.
¢¢% &
zero
¢¢& *
;
¢¢* +
float
££ 
count
££ 
=
££ 
$num
££ 
;
££  
for
¥¥ 
(
¥¥ 
int
¥¥ 
neighborIndex
¥¥ &
=
¥¥' (
$num
¥¥) *
;
¥¥* +
neighborIndex
¥¥, 9
<
¥¥: ;
	neighbors
¥¥< E
.
¥¥E F
Length
¥¥F L
;
¥¥L M
neighborIndex
¥¥N [
++
¥¥[ ]
)
¥¥] ^
{
¦¦ 
int
¨¨ 
c
¨¨ 
=
¨¨ 
	neighbors
¨¨ %
[
¨¨% &
neighborIndex
¨¨& 3
]
¨¨3 4
.
¨¨4 5
Value
¨¨5 :
;
¨¨: ;
if
«« 
(
«« 
remapped
««  
.
««  !
ContainsKey
««! ,
(
««, -
c
««- .
)
««. /
)
««/ 0
continue
¬¬  
;
¬¬  !
avg
®® 
.
®® 
x
®® 
+=
®® 
	neighbors
®® &
[
®®& '
neighborIndex
®®' 4
]
®®4 5
.
®®5 6
Point
®®6 ;
[
®®; <
$num
®®< =
]
®®= >
;
®®> ?
avg
¯¯ 
.
¯¯ 
y
¯¯ 
+=
¯¯ 
	neighbors
¯¯ &
[
¯¯& '
neighborIndex
¯¯' 4
]
¯¯4 5
.
¯¯5 6
Point
¯¯6 ;
[
¯¯; <
$num
¯¯< =
]
¯¯= >
;
¯¯> ?
avg
°° 
.
°° 
z
°° 
+=
°° 
	neighbors
°° &
[
°°& '
neighborIndex
°°' 4
]
°°4 5
.
°°5 6
Point
°°6 ;
[
°°; <
$num
°°< =
]
°°= >
;
°°> ?
remapped
²² 
.
²² 
Add
²²  
(
²²  !
c
²²! "
,
²²" #
index
²²$ )
)
²²) *
;
²²* +
count
´´ 
++
´´ 
;
´´ 
if
¶¶ 
(
¶¶ 
	neighbors
¶¶ !
[
¶¶! "
neighborIndex
¶¶" /
]
¶¶/ 0
.
¶¶0 1

Duplicates
¶¶1 ;
!=
¶¶< >
null
¶¶? C
)
¶¶C D
{
·· 
for
¸¸ 
(
¸¸ 
int
¸¸  
duplicateIndex
¸¸! /
=
¸¸0 1
$num
¸¸2 3
;
¸¸3 4
duplicateIndex
¸¸5 C
<
¸¸D E
	neighbors
¸¸F O
[
¸¸O P
neighborIndex
¸¸P ]
]
¸¸] ^
.
¸¸^ _

Duplicates
¸¸_ i
.
¸¸i j
Count
¸¸j o
;
¸¸o p
duplicateIndex
¸¸q 
++¸¸ 
)¸¸ ‚
remapped
¹¹ $
.
¹¹$ %
Add
¹¹% (
(
¹¹( )
	neighbors
¹¹) 2
[
¹¹2 3
neighborIndex
¹¹3 @
]
¹¹@ A
.
¹¹A B

Duplicates
¹¹B L
[
¹¹L M
duplicateIndex
¹¹M [
]
¹¹[ \
,
¹¹\ ]
index
¹¹^ c
)
¹¹c d
;
¹¹d e
}
ºº 
}
»» 
avg
½½ 
.
½½ 
x
½½ 
/=
½½ 
count
½½ 
;
½½ 
avg
¾¾ 
.
¾¾ 
y
¾¾ 
/=
¾¾ 
count
¾¾ 
;
¾¾ 
avg
¿¿ 
.
¿¿ 
z
¿¿ 
/=
¿¿ 
count
¿¿ 
;
¿¿ 
averages
ÁÁ 
.
ÁÁ 
Add
ÁÁ 
(
ÁÁ 
index
ÁÁ "
,
ÁÁ" #
avg
ÁÁ$ '
)
ÁÁ' (
;
ÁÁ( )
index
ÃÃ 
++
ÃÃ 
;
ÃÃ 
}
ÄÄ 
var
ÆÆ 
welds
ÆÆ 
=
ÆÆ 
new
ÆÆ 
int
ÆÆ 
[
ÆÆ  
remapped
ÆÆ  (
.
ÆÆ( )
Count
ÆÆ) .
]
ÆÆ. /
;
ÆÆ/ 0
int
ÇÇ 
n
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
;
ÇÇ 
var
ÈÈ 
lookup
ÈÈ 
=
ÈÈ 
mesh
ÈÈ 
.
ÈÈ  
sharedVertexLookup
ÈÈ 0
;
ÈÈ0 1
foreach
ÊÊ 
(
ÊÊ 
var
ÊÊ 
kvp
ÊÊ 
in
ÊÊ 
remapped
ÊÊ  (
)
ÊÊ( )
{
ËË 
SharedVertex
ÌÌ 
tris
ÌÌ !
=
ÌÌ" #
sharedIndexes
ÌÌ$ 1
[
ÌÌ1 2
kvp
ÌÌ2 5
.
ÌÌ5 6
Key
ÌÌ6 9
]
ÌÌ9 :
;
ÌÌ: ;
welds
ÎÎ 
[
ÎÎ 
n
ÎÎ 
++
ÎÎ 
]
ÎÎ 
=
ÎÎ 
tris
ÎÎ !
[
ÎÎ! "
$num
ÎÎ" #
]
ÎÎ# $
;
ÎÎ$ %
for
ĞĞ 
(
ĞĞ 
int
ĞĞ 
i
ĞĞ 
=
ĞĞ 
$num
ĞĞ 
;
ĞĞ 
i
ĞĞ  !
<
ĞĞ" #
tris
ĞĞ$ (
.
ĞĞ( )
Count
ĞĞ) .
;
ĞĞ. /
i
ĞĞ0 1
++
ĞĞ1 3
)
ĞĞ3 4
{
ÑÑ 
lookup
ÒÒ 
[
ÒÒ 
tris
ÒÒ 
[
ÒÒ  
i
ÒÒ  !
]
ÒÒ! "
]
ÒÒ" #
=
ÒÒ$ %
kvp
ÒÒ& )
.
ÒÒ) *
Value
ÒÒ* /
;
ÒÒ/ 0
vertices
ÓÓ 
[
ÓÓ 
tris
ÓÓ !
[
ÓÓ! "
i
ÓÓ" #
]
ÓÓ# $
]
ÓÓ$ %
.
ÓÓ% &
position
ÓÓ& .
=
ÓÓ/ 0
averages
ÓÓ1 9
[
ÓÓ9 :
kvp
ÓÓ: =
.
ÓÓ= >
Value
ÓÓ> C
]
ÓÓC D
;
ÓÓD E
}
ÔÔ 
}
ÕÕ 
mesh
×× 
.
×× 
SetSharedVertices
×× "
(
××" #
lookup
××# )
)
××) *
;
××* +
mesh
ØØ 
.
ØØ 
SetVertices
ØØ 
(
ØØ 
vertices
ØØ %
)
ØØ% &
;
ØØ& '
return
ÙÙ 
welds
ÙÙ 
;
ÙÙ 
}
ÚÚ 	
internal
îî 
static
îî 
FaceRebuildData
îî '
ExplodeVertex
îî( 5
(
îî5 6
IList
ïï 
<
ïï 
Vertex
ïï 
>
ïï 
vertices
ïï "
,
ïï" #
IList
ğğ 
<
ğğ 
SimpleTuple
ğğ 
<
ğğ 

WingedEdge
ğğ (
,
ğğ( )
int
ğğ* -
>
ğğ- .
>
ğğ. / 
edgeAndCommonIndex
ğğ0 B
,
ğğB C
float
ññ 
distance
ññ 
,
ññ 
out
òò 

Dictionary
òò 
<
òò 
int
òò 
,
òò 
List
òò  $
<
òò$ %
int
òò% (
>
òò( )
>
òò) *
appendedVertices
òò+ ;
)
òò; <
{
óó 	
Face
ôô 
face
ôô 
=
ôô  
edgeAndCommonIndex
ôô *
.
ôô* +
FirstOrDefault
ôô+ 9
(
ôô9 :
)
ôô: ;
.
ôô; <
item1
ôô< A
.
ôôA B
face
ôôB F
;
ôôF G
List
õõ 
<
õõ 
Edge
õõ 
>
õõ 
	perimeter
õõ  
=
õõ! "

WingedEdge
õõ# -
.
õõ- ."
SortEdgesByAdjacency
õõ. B
(
õõB C
face
õõC G
)
õõG H
;
õõH I
appendedVertices
öö 
=
öö 
new
öö "

Dictionary
öö# -
<
öö- .
int
öö. 1
,
öö1 2
List
öö3 7
<
öö7 8
int
öö8 ;
>
öö; <
>
öö< =
(
öö= >
)
öö> ?
;
öö? @
Vector3
÷÷ 
	oldNormal
÷÷ 
=
÷÷ 
Math
÷÷  $
.
÷÷$ %
Normal
÷÷% +
(
÷÷+ ,
vertices
÷÷, 4
,
÷÷4 5
face
÷÷6 :
.
÷÷: ;
indexesInternal
÷÷; J
)
÷÷J K
;
÷÷K L

Dictionary
úú 
<
úú 
int
úú 
,
úú 
int
úú 
>
úú  
toSplit
úú! (
=
úú) *
new
úú+ .

Dictionary
úú/ 9
<
úú9 :
int
úú: =
,
úú= >
int
úú? B
>
úúB C
(
úúC D
)
úúD E
;
úúE F
foreach
üü 
(
üü 
SimpleTuple
üü  
<
üü  !

WingedEdge
üü! +
,
üü+ ,
int
üü- 0
>
üü0 1
v
üü2 3
in
üü4 6 
edgeAndCommonIndex
üü7 I
)
üüI J
{
ıı 
if
şş 
(
şş 
v
şş 
.
şş 
item2
şş 
==
şş 
v
şş  
.
şş  !
item1
şş! &
.
şş& '
edge
şş' +
.
şş+ ,
common
şş, 2
.
şş2 3
a
şş3 4
)
şş4 5
toSplit
ÿÿ 
.
ÿÿ 
Add
ÿÿ 
(
ÿÿ  
v
ÿÿ  !
.
ÿÿ! "
item1
ÿÿ" '
.
ÿÿ' (
edge
ÿÿ( ,
.
ÿÿ, -
local
ÿÿ- 2
.
ÿÿ2 3
a
ÿÿ3 4
,
ÿÿ4 5
v
ÿÿ6 7
.
ÿÿ7 8
item2
ÿÿ8 =
)
ÿÿ= >
;
ÿÿ> ?
else
€€ 
toSplit
 
.
 
Add
 
(
  
v
  !
.
! "
item1
" '
.
' (
edge
( ,
.
, -
local
- 2
.
2 3
b
3 4
,
4 5
v
6 7
.
7 8
item2
8 =
)
= >
;
> ?
}
‚‚ 
int
„„ 
pc
„„ 
=
„„ 
	perimeter
„„ 
.
„„ 
Count
„„ $
;
„„$ %
List
…… 
<
…… 
Vertex
…… 
>
…… 

n_vertices
…… #
=
……$ %
new
……& )
List
……* .
<
……. /
Vertex
……/ 5
>
……5 6
(
……6 7
)
……7 8
;
……8 9
for
‡‡ 
(
‡‡ 
int
‡‡ 
i
‡‡ 
=
‡‡ 
$num
‡‡ 
;
‡‡ 
i
‡‡ 
<
‡‡ 
pc
‡‡  "
;
‡‡" #
i
‡‡$ %
++
‡‡% '
)
‡‡' (
{
ˆˆ 
int
‰‰ 
index
‰‰ 
=
‰‰ 
	perimeter
‰‰ %
[
‰‰% &
i
‰‰& '
]
‰‰' (
.
‰‰( )
b
‰‰) *
;
‰‰* +
if
ŒŒ 
(
ŒŒ 
toSplit
ŒŒ 
.
ŒŒ 
ContainsKey
ŒŒ '
(
ŒŒ' (
index
ŒŒ( -
)
ŒŒ- .
)
ŒŒ. /
{
 
Vertex
 
a
 
=
 
vertices
 '
[
' (
	perimeter
( 1
[
1 2
i
2 3
]
3 4
.
4 5
a
5 6
]
6 7
;
7 8
Vertex
 
b
 
=
 
vertices
 '
[
' (
	perimeter
( 1
[
1 2
i
2 3
]
3 4
.
4 5
b
5 6
]
6 7
;
7 8
Vertex
‘‘ 
c
‘‘ 
=
‘‘ 
vertices
‘‘ '
[
‘‘' (
	perimeter
‘‘( 1
[
‘‘1 2
(
‘‘2 3
i
‘‘3 4
+
‘‘5 6
$num
‘‘7 8
)
‘‘8 9
%
‘‘: ;
pc
‘‘< >
]
‘‘> ?
.
‘‘? @
b
‘‘@ A
]
‘‘A B
;
‘‘B C
Vertex
““ 
leading_dir
““ &
=
““' (
a
““) *
-
““+ ,
b
““- .
;
““. /
Vertex
”” 
following_dir
”” (
=
””) *
c
””+ ,
-
””- .
b
””/ 0
;
””0 1
leading_dir
•• 
.
••  
	Normalize
••  )
(
••) *
)
••* +
;
••+ ,
following_dir
–– !
.
––! "
	Normalize
––" +
(
––+ ,
)
––, -
;
––- .
Vertex
˜˜ 
leading_insert
˜˜ )
=
˜˜* +
vertices
˜˜, 4
[
˜˜4 5
index
˜˜5 :
]
˜˜: ;
+
˜˜< =
leading_dir
˜˜> I
*
˜˜J K
distance
˜˜L T
;
˜˜T U
Vertex
™™ 
following_insert
™™ +
=
™™, -
vertices
™™. 6
[
™™6 7
index
™™7 <
]
™™< =
+
™™> ?
following_dir
™™@ M
*
™™N O
distance
™™P X
;
™™X Y
appendedVertices
›› $
.
››$ %
AddOrAppend
››% 0
(
››0 1
toSplit
››1 8
[
››8 9
index
››9 >
]
››> ?
,
››? @

n_vertices
››A K
.
››K L
Count
››L Q
)
››Q R
;
››R S

n_vertices
œœ 
.
œœ 
Add
œœ "
(
œœ" #
leading_insert
œœ# 1
)
œœ1 2
;
œœ2 3
appendedVertices
 $
.
$ %
AddOrAppend
% 0
(
0 1
toSplit
1 8
[
8 9
index
9 >
]
> ?
,
? @

n_vertices
A K
.
K L
Count
L Q
)
Q R
;
R S

n_vertices
ŸŸ 
.
ŸŸ 
Add
ŸŸ "
(
ŸŸ" #
following_insert
ŸŸ# 3
)
ŸŸ3 4
;
ŸŸ4 5
}
   
else
¡¡ 
{
¢¢ 

n_vertices
££ 
.
££ 
Add
££ "
(
££" #
vertices
££# +
[
££+ ,
index
££, 1
]
££1 2
)
££2 3
;
££3 4
}
¤¤ 
}
¥¥ 
List
§§ 
<
§§ 
int
§§ 
>
§§ 
	triangles
§§ 
;
§§  
if
©© 
(
©© 
Triangulation
©© 
.
©© !
TriangulateVertices
©© 1
(
©©1 2

n_vertices
©©2 <
,
©©< =
out
©©> A
	triangles
©©B K
,
©©K L
false
©©M R
)
©©R S
)
©©S T
{
ªª 
FaceRebuildData
«« 
data
««  $
=
««% &
new
««' *
FaceRebuildData
««+ :
(
««: ;
)
««; <
;
««< =
data
¬¬ 
.
¬¬ 
vertices
¬¬ 
=
¬¬ 

n_vertices
¬¬  *
;
¬¬* +
data
­­ 
.
­­ 
face
­­ 
=
­­ 
new
­­ 
Face
­­  $
(
­­$ %
face
­­% )
)
­­) *
;
­­* +
Vector3
¯¯ 
	newNormal
¯¯ !
=
¯¯" #
Math
¯¯$ (
.
¯¯( )
Normal
¯¯) /
(
¯¯/ 0

n_vertices
¯¯0 :
,
¯¯: ;
	triangles
¯¯< E
)
¯¯E F
;
¯¯F G
if
±± 
(
±± 
Vector3
±± 
.
±± 
Dot
±± 
(
±±  
	oldNormal
±±  )
,
±±) *
	newNormal
±±+ 4
)
±±4 5
<
±±6 7
$num
±±8 :
)
±±: ;
	triangles
²² 
.
²² 
Reverse
²² %
(
²²% &
)
²²& '
;
²²' (
data
´´ 
.
´´ 
face
´´ 
.
´´ 
indexesInternal
´´ )
=
´´* +
	triangles
´´, 5
.
´´5 6
ToArray
´´6 =
(
´´= >
)
´´> ?
;
´´? @
return
¶¶ 
data
¶¶ 
;
¶¶ 
}
·· 
return
¹¹ 
null
¹¹ 
;
¹¹ 
}
ºº 	
static
¼¼ 
Edge
¼¼ $
AlignEdgeWithDirection
¼¼ *
(
¼¼* +

EdgeLookup
¼¼+ 5
edge
¼¼6 :
,
¼¼: ;
int
¼¼< ?
commonIndex
¼¼@ K
)
¼¼K L
{
½½ 	
if
¾¾ 
(
¾¾ 
edge
¾¾ 
.
¾¾ 
common
¾¾ 
.
¾¾ 
a
¾¾ 
==
¾¾  
commonIndex
¾¾! ,
)
¾¾, -
return
¿¿ 
new
¿¿ 
Edge
¿¿ 
(
¿¿  
edge
¿¿  $
.
¿¿$ %
local
¿¿% *
.
¿¿* +
a
¿¿+ ,
,
¿¿, -
edge
¿¿. 2
.
¿¿2 3
local
¿¿3 8
.
¿¿8 9
b
¿¿9 :
)
¿¿: ;
;
¿¿; <
else
ÀÀ 
return
ÁÁ 
new
ÁÁ 
Edge
ÁÁ 
(
ÁÁ  
edge
ÁÁ  $
.
ÁÁ$ %
local
ÁÁ% *
.
ÁÁ* +
b
ÁÁ+ ,
,
ÁÁ, -
edge
ÁÁ. 2
.
ÁÁ2 3
local
ÁÁ3 8
.
ÁÁ8 9
a
ÁÁ9 :
)
ÁÁ: ;
;
ÁÁ; <
}
ÂÂ 	
}
ÃÃ 
}ÄÄ ì'
ŒD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\BezierShape.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ 
AddComponentMenu 
( 
$str 
) 
] 
[ %
DisallowMultipleComponent 
, 
ExcludeFromPreset  1
,1 2$
ExcludeFromObjectFactory3 K
]K L
[		 
RequireComponent		 
(		 
typeof		 
(		 
ProBuilderMesh		 +
)		+ ,
)		, -
]		- .
sealed

 

class

 
BezierShape

 
:

 
MonoBehaviour

 ,
{ 
public 
List 
< 
BezierPoint 
>  
points! '
=( )
new* -
List. 2
<2 3
BezierPoint3 >
>> ?
(? @
)@ A
;A B
public 
bool 
	closeLoop 
= 
false  %
;% &
public 
float 
radius 
= 
$num !
;! "
public 
int 
rows 
= 
$num 
; 
public 
int 
columns 
= 
$num 
;  
public 
bool 
smooth 
= 
true !
;! "
[ 	
SerializeField	 
] 
bool 
m_IsEditing 
; 
public 
bool 
	isEditing 
{ 	
get 
{ 
return 
m_IsEditing $
;$ %
}& '
set 
{ 
m_IsEditing 
= 
value  %
;% &
}' (
} 	
ProBuilderMesh 
m_Mesh 
; 
public 
ProBuilderMesh 
mesh "
{ 	
get 
{ 
if   
(   
m_Mesh   
==   
null   "
)  " #
m_Mesh!! 
=!! 
GetComponent!! )
<!!) *
ProBuilderMesh!!* 8
>!!8 9
(!!9 :
)!!: ;
;!!; <
return## 
m_Mesh## 
;## 
}$$ 
set&& 
{'' 
m_Mesh(( 
=(( 
value(( 
;(( 
})) 
}** 	
public// 
void// 
Init// 
(// 
)// 
{00 	
Vector311 
tan11 
=11 
new11 
Vector311 %
(11% &
$num11& (
,11( )
$num11* ,
,11, -
$num11. 0
)110 1
;111 2
Vector322 
p122 
=22 
new22 
Vector322 $
(22$ %
$num22% '
,22' (
$num22) +
,22+ ,
$num22- /
)22/ 0
;220 1
points33 
.33 
Add33 
(33 
new33 
BezierPoint33 &
(33& '
Vector333' .
.33. /
zero33/ 3
,333 4
-335 6
tan336 9
,339 :
tan33; >
,33> ?

Quaternion33@ J
.33J K
identity33K S
)33S T
)33T U
;33U V
points44 
.44 
Add44 
(44 
new44 
BezierPoint44 &
(44& '
p144' )
,44) *
p144+ -
+44. /
tan440 3
,443 4
p1445 7
+448 9
-44: ;
tan44; >
,44> ?

Quaternion44@ J
.44J K
identity44K S
)44S T
)44T U
;44U V
}55 	
public:: 
void:: 
Refresh:: 
(:: 
):: 
{;; 	
if<< 
(<< 
points<< 
.<< 
Count<< 
<<< 
$num<<  
)<<  !
{== 
mesh>> 
.>> 
Clear>> 
(>> 
)>> 
;>> 
mesh?? 
.?? 
ToMesh?? 
(?? 
)?? 
;?? 
mesh@@ 
.@@ 
Refresh@@ 
(@@ 
)@@ 
;@@ 
}AA 
elseBB 
{CC 
ProBuilderMeshDD 
mDD  
=DD! "
meshDD# '
;DD' (
SplineEE 
.EE 
ExtrudeEE 
(EE 
pointsEE %
,EE% &
radiusEE' -
,EE- .
columnsEE/ 6
,EE6 7
rowsEE8 <
,EE< =
	closeLoopEE> G
,EEG H
smoothEEI O
,EEO P
refEEQ T
mEEU V
)EEV W
;EEW X
}FF 
}GG 	
}HH 
}II Ï

‹D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\RaycastHit.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed 

class 

RaycastHit 
{		 
public

 
float

 
distance

 
;

 
public 
Vector3 
point 
; 
public 
Vector3 
normal 
; 
public 
int 
face 
; 
public 

RaycastHit 
( 
float 
distance 
, 
Vector3 
point 
, 
Vector3 
normal 
, 
int 
face 
) 
{ 	
this 
. 
distance 
= 
distance $
;$ %
this 
. 
point 
= 
point 
; 
this 
. 
normal 
= 
normal  
;  !
this 
. 
face 
= 
face 
; 
} 	
} 
} ¸
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\AssemblyInfo.cs
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> _
)_ `
]` a
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> W
)W X
]X Y
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> V
)V W
]W X
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> `
)` a
]a b
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> [
)[ \
]\ ]
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> ]
)] ^
]^ _
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> ]
)] ^
]^ _
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> ^
)^ _
]_ `˜L
‘D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\TransformUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public		 

static		 
class		 
TransformUtility		 (
{

 
static 

Dictionary 
< 
	Transform #
,# $
	Transform% .
[. /
]/ 0
>0 1
s_ChildStack2 >
=? @
newA D

DictionaryE O
<O P
	TransformP Y
,Y Z
	Transform[ d
[d e
]e f
>f g
(g h
)h i
;i j
internal 
static 
void 
UnparentChildren -
(- .
	Transform. 7
t8 9
)9 :
{ 	
	Transform 
[ 
] 
children  
=! "
new# &
	Transform' 0
[0 1
t1 2
.2 3

childCount3 =
]= >
;> ?
for 
( 
int 
i 
= 
t 
. 

childCount %
-& '
$num( )
;) *
i+ ,
>=- /
$num0 1
;1 2
--3 5
i5 6
)6 7
{ 
	Transform 
child 
=  !
t" #
.# $
GetChild$ ,
(, -
i- .
). /
;/ 0
children 
[ 
i 
] 
= 
child #
;# $
child 
. 
	SetParent 
(  
null  $
,$ %
true& *
)* +
;+ ,
} 
s_ChildStack 
. 
Add 
( 
t 
, 
children  (
)( )
;) *
} 	
internal## 
static## 
void## 
ReparentChildren## -
(##- .
	Transform##. 7
t##8 9
)##9 :
{$$ 	
	Transform%% 
[%% 
]%% 
children%%  
;%%  !
if'' 
('' 
s_ChildStack'' 
.'' 
TryGetValue'' (
(''( )
t'') *
,''* +
out'', /
children''0 8
)''8 9
)''9 :
{(( 
foreach)) 
()) 
	Transform)) "
c))# $
in))% '
children))( 0
)))0 1
c** 
.** 
	SetParent** 
(**  
t**  !
,**! "
true**# '
)**' (
;**( )
s_ChildStack,, 
.,, 
Remove,, #
(,,# $
t,,$ %
),,% &
;,,& '
}-- 
}.. 	
public66 
static66 
Vertex66 
TransformVertex66 ,
(66, -
this66- 1
	Transform662 ;
	transform66< E
,66E F
Vertex66G M
vertex66N T
)66T U
{77 	
var88 
v88 
=88 
new88 
Vertex88 
(88 
)88  
;88  !
if:: 
(:: 
vertex:: 
.:: 
	HasArrays::  
(::  !

MeshArrays::! +
.::+ ,
Position::, 4
)::4 5
)::5 6
v;; 
.;; 
position;; 
=;; 
	transform;; &
.;;& '
TransformPoint;;' 5
(;;5 6
vertex;;6 <
.;;< =
position;;= E
);;E F
;;;F G
if== 
(== 
vertex== 
.== 
	HasArrays==  
(==  !

MeshArrays==! +
.==+ ,
Color==, 1
)==1 2
)==2 3
v>> 
.>> 
color>> 
=>> 
vertex>>  
.>>  !
color>>! &
;>>& '
if@@ 
(@@ 
vertex@@ 
.@@ 
	HasArrays@@  
(@@  !

MeshArrays@@! +
.@@+ ,
Normal@@, 2
)@@2 3
)@@3 4
vAA 
.AA 
normalAA 
=AA 
	transformAA $
.AA$ %
TransformDirectionAA% 7
(AA7 8
vertexAA8 >
.AA> ?
normalAA? E
)AAE F
;AAF G
ifCC 
(CC 
vertexCC 
.CC 
	HasArraysCC  
(CC  !

MeshArraysCC! +
.CC+ ,
TangentCC, 3
)CC3 4
)CC4 5
vDD 
.DD 
tangentDD 
=DD 
	transformDD %
.DD% &
rotationDD& .
*DD/ 0
vertexDD1 7
.DD7 8
tangentDD8 ?
;DD? @
ifFF 
(FF 
vertexFF 
.FF 
	HasArraysFF  
(FF  !

MeshArraysFF! +
.FF+ ,
Texture0FF, 4
)FF4 5
)FF5 6
vGG 
.GG 
uv0GG 
=GG 
vertexGG 
.GG 
uv0GG "
;GG" #
ifII 
(II 
vertexII 
.II 
	HasArraysII  
(II  !

MeshArraysII! +
.II+ ,
Texture1II, 4
)II4 5
)II5 6
vJJ 
.JJ 
uv2JJ 
=JJ 
vertexJJ 
.JJ 
uv2JJ "
;JJ" #
ifLL 
(LL 
vertexLL 
.LL 
	HasArraysLL  
(LL  !

MeshArraysLL! +
.LL+ ,
Texture2LL, 4
)LL4 5
)LL5 6
vMM 
.MM 
uv3MM 
=MM 
vertexMM 
.MM 
uv3MM "
;MM" #
ifOO 
(OO 
vertexOO 
.OO 
	HasArraysOO  
(OO  !

MeshArraysOO! +
.OO+ ,
Texture3OO, 4
)OO4 5
)OO5 6
vPP 
.PP 
uv4PP 
=PP 
vertexPP 
.PP 
uv4PP "
;PP" #
returnRR 
vRR 
;RR 
}SS 	
public[[ 
static[[ 
Vertex[[ "
InverseTransformVertex[[ 3
([[3 4
this[[4 8
	Transform[[9 B
	transform[[C L
,[[L M
Vertex[[N T
vertex[[U [
)[[[ \
{\\ 	
var]] 
v]] 
=]] 
new]] 
Vertex]] 
(]] 
)]]  
;]]  !
if__ 
(__ 
vertex__ 
.__ 
	HasArrays__  
(__  !

MeshArrays__! +
.__+ ,
Position__, 4
)__4 5
)__5 6
v`` 
.`` 
position`` 
=`` 
	transform`` &
.``& '!
InverseTransformPoint``' <
(``< =
vertex``= C
.``C D
position``D L
)``L M
;``M N
ifbb 
(bb 
vertexbb 
.bb 
	HasArraysbb  
(bb  !

MeshArraysbb! +
.bb+ ,
Colorbb, 1
)bb1 2
)bb2 3
vcc 
.cc 
colorcc 
=cc 
vertexcc  
.cc  !
colorcc! &
;cc& '
ifee 
(ee 
vertexee 
.ee 
	HasArraysee  
(ee  !

MeshArraysee! +
.ee+ ,
Normalee, 2
)ee2 3
)ee3 4
vff 
.ff 
normalff 
=ff 
	transformff $
.ff$ %%
InverseTransformDirectionff% >
(ff> ?
vertexff? E
.ffE F
normalffF L
)ffL M
;ffM N
ifhh 
(hh 
vertexhh 
.hh 
	HasArrayshh  
(hh  !

MeshArrayshh! +
.hh+ ,
Tangenthh, 3
)hh3 4
)hh4 5
vii 
.ii 
tangentii 
=ii 
	transformii %
.ii% &%
InverseTransformDirectionii& ?
(ii? @
vertexii@ F
.iiF G
tangentiiG N
)iiN O
;iiO P
ifkk 
(kk 
vertexkk 
.kk 
	HasArrayskk  
(kk  !

MeshArrayskk! +
.kk+ ,
Texture0kk, 4
)kk4 5
)kk5 6
vll 
.ll 
uv0ll 
=ll 
vertexll 
.ll 
uv0ll "
;ll" #
ifnn 
(nn 
vertexnn 
.nn 
	HasArraysnn  
(nn  !

MeshArraysnn! +
.nn+ ,
Texture1nn, 4
)nn4 5
)nn5 6
voo 
.oo 
uv2oo 
=oo 
vertexoo 
.oo 
uv2oo "
;oo" #
ifqq 
(qq 
vertexqq 
.qq 
	HasArraysqq  
(qq  !

MeshArraysqq! +
.qq+ ,
Texture2qq, 4
)qq4 5
)qq5 6
vrr 
.rr 
uv3rr 
=rr 
vertexrr 
.rr 
uv3rr "
;rr" #
iftt 
(tt 
vertextt 
.tt 
	HasArraystt  
(tt  !

MeshArraystt! +
.tt+ ,
Texture3tt, 4
)tt4 5
)tt5 6
vuu 
.uu 
uv4uu 
=uu 
vertexuu 
.uu 
uv4uu "
;uu" #
returnww 
vww 
;ww 
}xx 	
}yy 
}zz “!
ŒD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SimpleTuple.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

struct 
SimpleTuple 
< 
T1  
,  !
T2" $
>$ %
{		 
T1

 

m_Item1

 
;

 
T2 

m_Item2 
; 
public 
T1 
item1 
{ 	
get 
{ 
return 
m_Item1  
;  !
}" #
set 
{ 
m_Item1 
= 
value !
;! "
}# $
} 	
public 
T2 
item2 
{ 	
get 
{ 
return 
m_Item2  
;  !
}" #
set 
{ 
m_Item2 
= 
value !
;! "
}# $
} 	
public 
SimpleTuple 
( 
T1 
item1 #
,# $
T2% '
item2( -
)- .
{ 	
m_Item1 
= 
item1 
; 
m_Item2 
= 
item2 
; 
} 	
public 
override 
string 
ToString '
(' (
)( )
{   	
return!! 
string!! 
.!! 
Format!!  
(!!  !
$str!!! +
,!!+ ,
item1!!- 2
.!!2 3
ToString!!3 ;
(!!; <
)!!< =
,!!= >
item2!!? D
.!!D E
ToString!!E M
(!!M N
)!!N O
)!!O P
;!!P Q
}"" 	
}## 
struct++ 

SimpleTuple++ 
<++ 
T1++ 
,++ 
T2++ 
,++ 
T3++ !
>++! "
{,, 
T1-- 

m_Item1-- 
;-- 
T2.. 

m_Item2.. 
;.. 
T3// 

m_Item3// 
;// 
public11 
T111 
item111 
{22 	
get33 
{33 
return33 
m_Item133  
;33  !
}33" #
set44 
{44 
m_Item144 
=44 
value44 !
;44! "
}44# $
}55 	
public77 
T277 
item277 
{88 	
get99 
{99 
return99 
m_Item299  
;99  !
}99" #
set:: 
{:: 
m_Item2:: 
=:: 
value:: !
;::! "
}::# $
};; 	
public== 
T3== 
item3== 
{>> 	
get?? 
{?? 
return?? 
m_Item3??  
;??  !
}??" #
set@@ 
{@@ 
m_Item3@@ 
=@@ 
value@@ !
;@@! "
}@@# $
}AA 	
publicCC 
SimpleTupleCC 
(CC 
T1CC 
item1CC #
,CC# $
T2CC% '
item2CC( -
,CC- .
T3CC/ 1
item3CC2 7
)CC7 8
{DD 	
m_Item1EE 
=EE 
item1EE 
;EE 
m_Item2FF 
=FF 
item2FF 
;FF 
m_Item3GG 
=GG 
item3GG 
;GG 
}HH 	
publicJJ 
overrideJJ 
stringJJ 
ToStringJJ '
(JJ' (
)JJ( )
{KK 	
returnLL 
stringLL 
.LL 
FormatLL  
(LL  !
$strLL! 0
,LL0 1
item1LL2 7
.LL7 8
ToStringLL8 @
(LL@ A
)LLA B
,LLB C
item2LLD I
.LLI J
ToStringLLJ R
(LLR S
)LLS T
,LLT U
item3LLV [
.LL[ \
ToStringLL\ d
(LLd e
)LLe f
)LLf g
;LLg h
}MM 	
}NN 
}OO †ğ
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ShapeGenerator.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public

 

enum

 
	ShapeType

 
{ 
Cube 
, 
Stair 
, 
CurvedStair 
, 
Prism 
, 
Cylinder 
, 
Plane## 
,## 
Door'' 
,'' 
Pipe++ 
,++ 
Cone// 
,// 
Sprite33 
,33 
Arch77 
,77 
Sphere;; 
,;; 
TorusBB 
}CC 
publicHH 

enumHH 
PivotLocationHH 
{II 
CenterJJ 
,JJ 
FirstVertexKK 
}LL 
publicQQ 

staticQQ 
classQQ 
ShapeGeneratorQQ &
{RR 
staticSS 
readonlySS 
Vector3SS 
[SS  
]SS  !
k_IcosphereVerticesSS" 5
=SS6 7
newSS8 ;
Vector3SS< C
[SSC D
$numSSD F
]SSF G
{TT 	
newUU 
Vector3UU 
(UU 
-UU 
$numUU 
,UU 
MathUU "
.UU" #
phiUU# &
,UU& '
$numUU) +
)UU+ ,
,UU, -
newVV 
Vector3VV 
(VV 
$numVV 
,VV 
MathVV !
.VV! "
phiVV" %
,VV% &
$numVV( *
)VV* +
,VV+ ,
newWW 
Vector3WW 
(WW 
-WW 
$numWW 
,WW 
-WW 
MathWW "
.WW" #
phiWW# &
,WW& '
$numWW) +
)WW+ ,
,WW, -
newXX 
Vector3XX 
(XX 
$numXX 
,XX 
-XX 
MathXX !
.XX! "
phiXX" %
,XX% &
$numXX( *
)XX* +
,XX+ ,
newZZ 
Vector3ZZ 
(ZZ 
$numZZ 
,ZZ 
-ZZ 
$numZZ 
,ZZ  
MathZZ" &
.ZZ& '
phiZZ' *
)ZZ* +
,ZZ+ ,
new[[ 
Vector3[[ 
([[ 
$num[[ 
,[[ 
$num[[ 
,[[  
Math[[" &
.[[& '
phi[[' *
)[[* +
,[[+ ,
new\\ 
Vector3\\ 
(\\ 
$num\\ 
,\\ 
-\\ 
$num\\ 
,\\  
-\\! "
Math\\" &
.\\& '
phi\\' *
)\\* +
,\\+ ,
new]] 
Vector3]] 
(]] 
$num]] 
,]] 
$num]] 
,]]  
-]]! "
Math]]" &
.]]& '
phi]]' *
)]]* +
,]]+ ,
new__ 
Vector3__ 
(__ 
Math__ 
.__ 
phi__  
,__  !
$num__" $
,__$ %
-__& '
$num__' )
)__) *
,__* +
new`` 
Vector3`` 
(`` 
Math`` 
.`` 
phi``  
,``  !
$num``" $
,``$ %
$num``' )
)``) *
,``* +
newaa 
Vector3aa 
(aa 
-aa 
Mathaa 
.aa 
phiaa !
,aa! "
$numaa# %
,aa% &
-aa' (
$numaa( *
)aa* +
,aa+ ,
newbb 
Vector3bb 
(bb 
-bb 
Mathbb 
.bb 
phibb !
,bb! "
$numbb# %
,bb% &
$numbb( *
)bb* +
}cc 	
;cc	 

staticee 
readonlyee 
intee 
[ee 
]ee  
k_IcosphereTrianglesee 2
=ee3 4
newee5 8
intee9 <
[ee< =
$numee= ?
]ee? @
{ff 	
$numgg 
,gg 
$numgg 
,gg 
$numgg 
,gg 
$numhh 
,hh 
$numhh 
,hh 
$numhh 
,hh 
$numii 
,ii 
$numii 
,ii 
$numii 
,ii 
$numjj 
,jj 
$numjj 
,jj 
$numjj 
,jj 
$numkk 
,kk 
$numkk 
,kk 
$numkk 
,kk 
$nummm 
,mm 
$nummm 
,mm 
$nummm 
,mm 
$numnn 
,nn 
$numnn 
,nn 
$numnn 
,nn 
$numoo 
,oo 
$numoo 
,oo 
$numoo 
,oo 
$numpp 
,pp 
$numpp 
,pp 
$numpp 
,pp 
$numqq 
,qq 
$numqq 
,qq 
$numqq 
,qq 
$numss 
,ss 
$numss 
,ss 
$numss 
,ss 
$numtt 
,tt 
$numtt 
,tt 
$numtt 
,tt 
$numuu 
,uu 
$numuu 
,uu 
$numuu 
,uu 
$numvv 
,vv 
$numvv 
,vv 
$numvv 
,vv 
$numww 
,ww 
$numww 
,ww 
$numww 
,ww 
$numyy 
,yy 
$numyy 
,yy 
$numyy 
,yy 
$numzz 
,zz 
$numzz 
,zz 
$numzz 
,zz 
$num{{ 
,{{ 
$num{{ 
,{{ 
$num{{ 
,{{ 
$num|| 
,|| 
$num|| 
,|| 
$num|| 
,|| 
$num}} 
,}} 
$num}} 
,}} 
$num}} 
}~~ 	
;~~	 

static
ƒƒ 
readonly
ƒƒ 
Vector3
ƒƒ 
[
ƒƒ  
]
ƒƒ  !
k_CubeVertices
ƒƒ" 0
=
ƒƒ1 2
new
ƒƒ3 6
Vector3
ƒƒ7 >
[
ƒƒ> ?
]
ƒƒ? @
{
ƒƒA B
new
…… 
Vector3
…… 
(
…… 
-
…… 
$num
…… 
,
…… 
-
…… 
$num
…… "
,
……" #
$num
……$ '
)
……' (
,
……( )
new
†† 
Vector3
†† 
(
†† 
$num
†† 
,
†† 
-
†† 
$num
†† !
,
††! "
$num
††# &
)
††& '
,
††' (
new
‡‡ 
Vector3
‡‡ 
(
‡‡ 
$num
‡‡ 
,
‡‡ 
-
‡‡ 
$num
‡‡ !
,
‡‡! "
-
‡‡# $
$num
‡‡$ '
)
‡‡' (
,
‡‡( )
new
ˆˆ 
Vector3
ˆˆ 
(
ˆˆ 
-
ˆˆ 
$num
ˆˆ 
,
ˆˆ 
-
ˆˆ 
$num
ˆˆ "
,
ˆˆ" #
-
ˆˆ$ %
$num
ˆˆ% (
)
ˆˆ( )
,
ˆˆ) *
new
‹‹ 
Vector3
‹‹ 
(
‹‹ 
-
‹‹ 
$num
‹‹ 
,
‹‹ 
$num
‹‹ !
,
‹‹! "
$num
‹‹# &
)
‹‹& '
,
‹‹' (
new
ŒŒ 
Vector3
ŒŒ 
(
ŒŒ 
$num
ŒŒ 
,
ŒŒ 
$num
ŒŒ  
,
ŒŒ  !
$num
ŒŒ" %
)
ŒŒ% &
,
ŒŒ& '
new
 
Vector3
 
(
 
$num
 
,
 
$num
  
,
  !
-
" #
$num
# &
)
& '
,
' (
new
 
Vector3
 
(
 
-
 
$num
 
,
 
$num
 !
,
! "
-
# $
$num
$ '
)
' (
}
 	
;
	 

static
”” 
readonly
”” 
int
”” 
[
”” 
]
”” 
k_CubeTriangles
”” -
=
””. /
new
””0 3
int
””4 7
[
””7 8
]
””8 9
{
””: ;
$num
•• 
,
•• 
$num
•• 
,
•• 
$num
•• 
,
•• 
$num
•• 
,
•• 
$num
•• 
,
•• 
$num
•• 
,
•• 
$num
•• 
,
••  
$num
••! "
,
••" #
$num
••$ %
,
••% &
$num
••' (
,
••( )
$num
••* +
,
••+ ,
$num
••- .
,
••. /
$num
••0 1
,
••1 2
$num
••3 4
,
••4 5
$num
••6 7
,
••7 8
$num
••9 :
,
••: ;
$num
••< =
,
••= >
$num
••? @
,
••@ A
$num
••B C
,
••C D
$num
••E F
,
••F G
$num
••H I
,
••I J
$num
••K L
,
••L M
$num
••N O
,
••O P
$num
••Q R
}
–– 	
;
––	 

public
 
static
 
ProBuilderMesh
 $
CreateShape
% 0
(
0 1
	ShapeType
1 :
shape
; @
,
@ A
PivotLocation
B O
	pivotType
P Y
=
Z [
PivotLocation
\ i
.
i j
Center
j p
)
p q
{
ŸŸ 	
ProBuilderMesh
   
pb
   
=
   
null
    $
;
  $ %
if
¢¢ 
(
¢¢ 
shape
¢¢ 
==
¢¢ 
	ShapeType
¢¢ "
.
¢¢" #
Cube
¢¢# '
)
¢¢' (
pb
££ 
=
££ 
GenerateCube
££ !
(
££! "
	pivotType
££" +
,
££+ ,
Vector3
££- 4
.
££4 5
one
££5 8
)
££8 9
;
££9 :
if
¤¤ 
(
¤¤ 
shape
¤¤ 
==
¤¤ 
	ShapeType
¤¤ "
.
¤¤" #
Stair
¤¤# (
)
¤¤( )
pb
¥¥ 
=
¥¥ 
GenerateStair
¥¥ "
(
¥¥" #
	pivotType
¥¥# ,
,
¥¥, -
new
¥¥. 1
Vector3
¥¥2 9
(
¥¥9 :
$num
¥¥: <
,
¥¥< =
$num
¥¥> B
,
¥¥B C
$num
¥¥D F
)
¥¥F G
,
¥¥G H
$num
¥¥I J
,
¥¥J K
true
¥¥L P
)
¥¥P Q
;
¥¥Q R
if
¦¦ 
(
¦¦ 
shape
¦¦ 
==
¦¦ 
	ShapeType
¦¦ "
.
¦¦" #
CurvedStair
¦¦# .
)
¦¦. /
pb
§§ 
=
§§ !
GenerateCurvedStair
§§ (
(
§§( )
	pivotType
§§) 2
,
§§2 3
$num
§§4 6
,
§§6 7
$num
§§8 <
,
§§< =
$num
§§> @
,
§§@ A
$num
§§B F
,
§§F G
$num
§§H I
,
§§I J
true
§§K O
)
§§O P
;
§§P Q
if
¨¨ 
(
¨¨ 
shape
¨¨ 
==
¨¨ 
	ShapeType
¨¨ "
.
¨¨" #
Prism
¨¨# (
)
¨¨( )
pb
©© 
=
©© 
GeneratePrism
©© "
(
©©" #
	pivotType
©©# ,
,
©©, -
Vector3
©©. 5
.
©©5 6
one
©©6 9
)
©©9 :
;
©©: ;
if
ªª 
(
ªª 
shape
ªª 
==
ªª 
	ShapeType
ªª "
.
ªª" #
Cylinder
ªª# +
)
ªª+ ,
pb
«« 
=
«« 
GenerateCylinder
«« %
(
««% &
	pivotType
««& /
,
««/ 0
$num
««1 2
,
««2 3
$num
««4 6
,
««6 7
$num
««8 :
,
««: ;
$num
««< =
)
««= >
;
««> ?
if
¬¬ 
(
¬¬ 
shape
¬¬ 
==
¬¬ 
	ShapeType
¬¬ "
.
¬¬" #
Plane
¬¬# (
)
¬¬( )
pb
­­ 
=
­­ 
GeneratePlane
­­ "
(
­­" #
	pivotType
­­# ,
,
­­, -
$num
­­. 0
,
­­0 1
$num
­­2 4
,
­­4 5
$num
­­6 7
,
­­7 8
$num
­­9 :
,
­­: ;
Axis
­­< @
.
­­@ A
Up
­­A C
)
­­C D
;
­­D E
if
®® 
(
®® 
shape
®® 
==
®® 
	ShapeType
®® "
.
®®" #
Door
®®# '
)
®®' (
pb
¯¯ 
=
¯¯ 
GenerateDoor
¯¯ !
(
¯¯! "
	pivotType
¯¯" +
,
¯¯+ ,
$num
¯¯- /
,
¯¯/ 0
$num
¯¯1 5
,
¯¯5 6
$num
¯¯7 :
,
¯¯: ;
$num
¯¯< @
,
¯¯@ A
$num
¯¯B D
)
¯¯D E
;
¯¯E F
if
°° 
(
°° 
shape
°° 
==
°° 
	ShapeType
°° "
.
°°" #
Pipe
°°# '
)
°°' (
pb
±± 
=
±± 
GeneratePipe
±± !
(
±±! "
	pivotType
±±" +
,
±±+ ,
$num
±±- /
,
±±/ 0
$num
±±1 3
,
±±3 4
$num
±±5 9
,
±±9 :
$num
±±; <
,
±±< =
$num
±±> ?
)
±±? @
;
±±@ A
if
²² 
(
²² 
shape
²² 
==
²² 
	ShapeType
²² "
.
²²" #
Cone
²²# '
)
²²' (
pb
³³ 
=
³³ 
GenerateCone
³³ !
(
³³! "
	pivotType
³³" +
,
³³+ ,
$num
³³- 0
,
³³0 1
$num
³³2 4
,
³³4 5
$num
³³6 7
)
³³7 8
;
³³8 9
if
´´ 
(
´´ 
shape
´´ 
==
´´ 
	ShapeType
´´ "
.
´´" #
Sprite
´´# )
)
´´) *
pb
µµ 
=
µµ 
GeneratePlane
µµ "
(
µµ" #
	pivotType
µµ# ,
,
µµ, -
$num
µµ. 0
,
µµ0 1
$num
µµ2 4
,
µµ4 5
$num
µµ6 7
,
µµ7 8
$num
µµ9 :
,
µµ: ;
Axis
µµ< @
.
µµ@ A
Up
µµA C
)
µµC D
;
µµD E
if
¶¶ 
(
¶¶ 
shape
¶¶ 
==
¶¶ 
	ShapeType
¶¶ "
.
¶¶" #
Arch
¶¶# '
)
¶¶' (
pb
·· 
=
·· 
GenerateArch
·· !
(
··! "
	pivotType
··" +
,
··+ ,
$num
··- 1
,
··1 2
$num
··3 5
,
··5 6
$num
··7 9
,
··9 :
$num
··; =
,
··= >
$num
··? @
,
··@ A
true
··B F
,
··F G
true
··H L
,
··L M
true
··N R
,
··R S
true
··T X
,
··X Y
true
··Z ^
)
··^ _
;
··_ `
if
¸¸ 
(
¸¸ 
shape
¸¸ 
==
¸¸ 
	ShapeType
¸¸ "
.
¸¸" #
Sphere
¸¸# )
)
¸¸) *
pb
¹¹ 
=
¹¹ !
GenerateIcosahedron
¹¹ (
(
¹¹( )
	pivotType
¹¹) 2
,
¹¹2 3
$num
¹¹4 7
,
¹¹7 8
$num
¹¹9 :
,
¹¹: ;
true
¹¹< @
,
¹¹@ A
false
¹¹B G
)
¹¹G H
;
¹¹H I
if
ºº 
(
ºº 
shape
ºº 
==
ºº 
	ShapeType
ºº "
.
ºº" #
Torus
ºº# (
)
ºº( )
{
»» 
pb
¼¼ 
=
¼¼ 
GenerateTorus
¼¼ "
(
¼¼" #
	pivotType
¼¼# ,
,
¼¼, -
$num
¼¼. 0
,
¼¼0 1
$num
¼¼2 4
,
¼¼4 5
$num
¼¼6 8
,
¼¼8 9
$num
¼¼: =
,
¼¼= >
true
¼¼? C
,
¼¼C D
$num
¼¼E I
,
¼¼I J
$num
¼¼K O
,
¼¼O P
true
¼¼Q U
)
¼¼U V
;
¼¼V W
	UVEditing
½½ 
.
½½ 
ProjectFacesBox
½½ )
(
½½) *
pb
½½* ,
,
½½, -
pb
½½. 0
.
½½0 1
facesInternal
½½1 >
)
½½> ?
;
½½? @
}
¾¾ 
if
ÀÀ 
(
ÀÀ 
pb
ÀÀ 
==
ÀÀ 
null
ÀÀ 
)
ÀÀ 
{
ÁÁ 
Log
ÃÃ 
.
ÃÃ 
Error
ÃÃ 
(
ÃÃ 
shape
ÃÃ 
.
ÃÃ  
ToString
ÃÃ  (
(
ÃÃ( )
)
ÃÃ) *
+
ÃÃ+ ,
$str
ÃÃ- D
)
ÃÃD E
;
ÃÃE F
pb
ÅÅ 
=
ÅÅ 
GenerateCube
ÅÅ !
(
ÅÅ! "
	pivotType
ÅÅ" +
,
ÅÅ+ ,
Vector3
ÅÅ- 4
.
ÅÅ4 5
one
ÅÅ5 8
)
ÅÅ8 9
;
ÅÅ9 :
}
ÆÆ 
pb
ÈÈ 
.
ÈÈ 

gameObject
ÈÈ 
.
ÈÈ 
name
ÈÈ 
=
ÈÈ  
shape
ÈÈ! &
.
ÈÈ& '
ToString
ÈÈ' /
(
ÈÈ/ 0
)
ÈÈ0 1
;
ÈÈ1 2
pb
ÉÉ 
.
ÉÉ 
renderer
ÉÉ 
.
ÉÉ 
sharedMaterial
ÉÉ &
=
ÉÉ' (
BuiltinMaterials
ÉÉ) 9
.
ÉÉ9 :
defaultMaterial
ÉÉ: I
;
ÉÉI J
return
ËË 
pb
ËË 
;
ËË 
}
ÌÌ 	
public
ÖÖ 
static
ÖÖ 
ProBuilderMesh
ÖÖ $
GenerateStair
ÖÖ% 2
(
ÖÖ2 3
PivotLocation
ÖÖ3 @
	pivotType
ÖÖA J
,
ÖÖJ K
Vector3
ÖÖL S
size
ÖÖT X
,
ÖÖX Y
int
ÖÖZ ]
steps
ÖÖ^ c
,
ÖÖc d
bool
ÖÖe i

buildSides
ÖÖj t
)
ÖÖt u
{
×× 	
Vector3
ÙÙ 
[
ÙÙ 
]
ÙÙ 
vertices
ÙÙ 
=
ÙÙ  
new
ÙÙ! $
Vector3
ÙÙ% ,
[
ÙÙ, -
$num
ÙÙ- .
*
ÙÙ/ 0
steps
ÙÙ1 6
*
ÙÙ7 8
$num
ÙÙ9 :
]
ÙÙ: ;
;
ÙÙ; <
Face
ÚÚ 
[
ÚÚ 
]
ÚÚ 
faces
ÚÚ 
=
ÚÚ 
new
ÚÚ 
Face
ÚÚ #
[
ÚÚ# $
steps
ÚÚ$ )
*
ÚÚ* +
$num
ÚÚ, -
]
ÚÚ- .
;
ÚÚ. /
int
İİ 
v
İİ 
=
İİ 
$num
İİ 
,
İİ 
t
İİ 
=
İİ 
$num
İİ 
;
İİ 
for
ßß 
(
ßß 
int
ßß 
i
ßß 
=
ßß 
$num
ßß 
;
ßß 
i
ßß 
<
ßß 
steps
ßß  %
;
ßß% &
i
ßß' (
++
ßß( *
)
ßß* +
{
àà 
float
áá 
inc0
áá 
=
áá 
i
áá 
/
áá  
(
áá! "
float
áá" '
)
áá' (
steps
áá( -
;
áá- .
float
ââ 
inc1
ââ 
=
ââ 
(
ââ 
i
ââ 
+
ââ  !
$num
ââ" #
)
ââ# $
/
ââ% &
(
ââ' (
float
ââ( -
)
ââ- .
steps
ââ. 3
;
ââ3 4
float
ää 
x0
ää 
=
ää 
size
ää 
.
ää  
x
ää  !
;
ää! "
float
åå 
x1
åå 
=
åå 
$num
åå 
;
åå 
float
ææ 
y0
ææ 
=
ææ 
size
ææ 
.
ææ  
y
ææ  !
*
ææ" #
inc0
ææ$ (
;
ææ( )
float
çç 
y1
çç 
=
çç 
size
çç 
.
çç  
y
çç  !
*
çç" #
inc1
çç$ (
;
çç( )
float
èè 
z0
èè 
=
èè 
size
èè 
.
èè  
z
èè  !
*
èè" #
inc0
èè$ (
;
èè( )
float
éé 
z1
éé 
=
éé 
size
éé 
.
éé  
z
éé  !
*
éé" #
inc1
éé$ (
;
éé( )
vertices
ëë 
[
ëë 
v
ëë 
+
ëë 
$num
ëë 
]
ëë 
=
ëë  !
new
ëë" %
Vector3
ëë& -
(
ëë- .
x0
ëë. 0
,
ëë0 1
y0
ëë2 4
,
ëë4 5
z0
ëë6 8
)
ëë8 9
;
ëë9 :
vertices
ìì 
[
ìì 
v
ìì 
+
ìì 
$num
ìì 
]
ìì 
=
ìì  !
new
ìì" %
Vector3
ìì& -
(
ìì- .
x1
ìì. 0
,
ìì0 1
y0
ìì2 4
,
ìì4 5
z0
ìì6 8
)
ìì8 9
;
ìì9 :
vertices
íí 
[
íí 
v
íí 
+
íí 
$num
íí 
]
íí 
=
íí  !
new
íí" %
Vector3
íí& -
(
íí- .
x0
íí. 0
,
íí0 1
y1
íí2 4
,
íí4 5
z0
íí6 8
)
íí8 9
;
íí9 :
vertices
îî 
[
îî 
v
îî 
+
îî 
$num
îî 
]
îî 
=
îî  !
new
îî" %
Vector3
îî& -
(
îî- .
x1
îî. 0
,
îî0 1
y1
îî2 4
,
îî4 5
z0
îî6 8
)
îî8 9
;
îî9 :
vertices
ğğ 
[
ğğ 
v
ğğ 
+
ğğ 
$num
ğğ 
]
ğğ 
=
ğğ  !
new
ğğ" %
Vector3
ğğ& -
(
ğğ- .
x0
ğğ. 0
,
ğğ0 1
y1
ğğ2 4
,
ğğ4 5
z0
ğğ6 8
)
ğğ8 9
;
ğğ9 :
vertices
ññ 
[
ññ 
v
ññ 
+
ññ 
$num
ññ 
]
ññ 
=
ññ  !
new
ññ" %
Vector3
ññ& -
(
ññ- .
x1
ññ. 0
,
ññ0 1
y1
ññ2 4
,
ññ4 5
z0
ññ6 8
)
ññ8 9
;
ññ9 :
vertices
òò 
[
òò 
v
òò 
+
òò 
$num
òò 
]
òò 
=
òò  !
new
òò" %
Vector3
òò& -
(
òò- .
x0
òò. 0
,
òò0 1
y1
òò2 4
,
òò4 5
z1
òò6 8
)
òò8 9
;
òò9 :
vertices
óó 
[
óó 
v
óó 
+
óó 
$num
óó 
]
óó 
=
óó  !
new
óó" %
Vector3
óó& -
(
óó- .
x1
óó. 0
,
óó0 1
y1
óó2 4
,
óó4 5
z1
óó6 8
)
óó8 9
;
óó9 :
faces
õõ 
[
õõ 
t
õõ 
+
õõ 
$num
õõ 
]
õõ 
=
õõ 
new
õõ "
Face
õõ# '
(
õõ' (
new
õõ( +
int
õõ, /
[
õõ/ 0
]
õõ0 1
{
õõ2 3
v
õõ5 6
+
õõ7 8
$num
õõ9 :
,
õõ: ;
v
öö5 6
+
öö7 8
$num
öö9 :
,
öö: ;
v
÷÷5 6
+
÷÷7 8
$num
÷÷9 :
,
÷÷: ;
v
øø5 6
+
øø7 8
$num
øø9 :
,
øø: ;
v
ùù5 6
+
ùù7 8
$num
ùù9 :
,
ùù: ;
v
úú5 6
+
úú7 8
$num
úú9 :
}
úú; <
)
úú< =
;
úú= >
faces
üü 
[
üü 
t
üü 
+
üü 
$num
üü 
]
üü 
=
üü 
new
üü "
Face
üü# '
(
üü' (
new
üü( +
int
üü, /
[
üü/ 0
]
üü0 1
{
üü2 3
v
üü5 6
+
üü7 8
$num
üü9 :
,
üü: ;
v
ıı5 6
+
ıı7 8
$num
ıı9 :
,
ıı: ;
v
şş5 6
+
şş7 8
$num
şş9 :
,
şş: ;
v
ÿÿ5 6
+
ÿÿ7 8
$num
ÿÿ9 :
,
ÿÿ: ;
v
€€5 6
+
€€7 8
$num
€€9 :
,
€€: ;
v
5 6
+
7 8
$num
9 :
}
; <
)
< =
;
= >
v
ƒƒ 
+=
ƒƒ 
$num
ƒƒ 
;
ƒƒ 
t
„„ 
+=
„„ 
$num
„„ 
;
„„ 
}
…… 
if
ˆˆ 
(
ˆˆ 

buildSides
ˆˆ 
)
ˆˆ 
{
‰‰ 
float
ŒŒ 
x
ŒŒ 
=
ŒŒ 
$num
ŒŒ 
;
ŒŒ 
for
 
(
 
int
 
side
 
=
 
$num
  !
;
! "
side
# '
<
( )
$num
* +
;
+ ,
side
- 1
++
1 3
)
3 4
{
 
Vector3
 
[
 
]
 
sides_v
 %
=
& '
new
( +
Vector3
, 3
[
3 4
steps
4 9
*
: ;
$num
< =
+
> ?
(
@ A
steps
A F
-
G H
$num
I J
)
J K
*
L M
$num
N O
]
O P
;
P Q
Face
‘‘ 
[
‘‘ 
]
‘‘ 
sides_f
‘‘ "
=
‘‘# $
new
‘‘% (
Face
‘‘) -
[
‘‘- .
steps
‘‘. 3
+
‘‘4 5
steps
‘‘6 ;
-
‘‘< =
$num
‘‘> ?
]
‘‘? @
;
‘‘@ A
int
““ 
sv
““ 
=
““ 
$num
““ 
,
““ 
st
““  "
=
““# $
$num
““% &
;
““& '
for
•• 
(
•• 
int
•• 
i
•• 
=
••  
$num
••! "
;
••" #
i
••$ %
<
••& '
steps
••( -
;
••- .
i
••/ 0
++
••0 2
)
••2 3
{
–– 
float
—— 
y0
——  
=
——! "
(
——# $
Mathf
——$ )
.
——) *
Max
——* -
(
——- .
i
——. /
,
——/ 0
$num
——1 2
)
——2 3
/
——4 5
(
——6 7
float
——7 <
)
——< =
steps
——= B
)
——B C
*
——D E
size
——F J
.
——J K
y
——K L
;
——L M
float
˜˜ 
y1
˜˜  
=
˜˜! "
(
˜˜# $
(
˜˜$ %
i
˜˜% &
+
˜˜' (
$num
˜˜) *
)
˜˜* +
/
˜˜, -
(
˜˜. /
float
˜˜/ 4
)
˜˜4 5
steps
˜˜5 :
)
˜˜: ;
*
˜˜< =
size
˜˜> B
.
˜˜B C
y
˜˜C D
;
˜˜D E
float
šš 
z0
šš  
=
šš! "
(
šš# $
i
šš$ %
/
šš& '
(
šš( )
float
šš) .
)
šš. /
steps
šš/ 4
)
šš4 5
*
šš6 7
size
šš8 <
.
šš< =
z
šš= >
;
šš> ?
float
›› 
z1
››  
=
››! "
(
››# $
(
››$ %
i
››% &
+
››' (
$num
››) *
)
››* +
/
››, -
(
››. /
float
››/ 4
)
››4 5
steps
››5 :
)
››: ;
*
››< =
size
››> B
.
››B C
z
››C D
;
››D E
sides_v
 
[
  
sv
  "
+
# $
$num
% &
]
& '
=
( )
new
* -
Vector3
. 5
(
5 6
x
6 7
,
7 8
$num
9 ;
,
; <
z0
= ?
)
? @
;
@ A
sides_v
 
[
  
sv
  "
+
# $
$num
% &
]
& '
=
( )
new
* -
Vector3
. 5
(
5 6
x
6 7
,
7 8
$num
9 ;
,
; <
z1
= ?
)
? @
;
@ A
sides_v
ŸŸ 
[
ŸŸ  
sv
ŸŸ  "
+
ŸŸ# $
$num
ŸŸ% &
]
ŸŸ& '
=
ŸŸ( )
new
ŸŸ* -
Vector3
ŸŸ. 5
(
ŸŸ5 6
x
ŸŸ6 7
,
ŸŸ7 8
y0
ŸŸ9 ;
,
ŸŸ; <
z0
ŸŸ= ?
)
ŸŸ? @
;
ŸŸ@ A
sides_v
   
[
    
sv
    "
+
  # $
$num
  % &
]
  & '
=
  ( )
new
  * -
Vector3
  . 5
(
  5 6
x
  6 7
,
  7 8
y1
  9 ;
,
  ; <
z1
  = ?
)
  ? @
;
  @ A
sides_f
¢¢ 
[
¢¢  
st
¢¢  "
++
¢¢" $
]
¢¢$ %
=
¢¢& '
new
¢¢( +
Face
¢¢, 0
(
¢¢0 1
side
¢¢1 5
%
¢¢6 7
$num
¢¢8 9
==
¢¢: <
$num
¢¢= >
?
¢¢? @
new
££  #
int
££$ '
[
££' (
]
££( )
{
££* +
v
££, -
+
££. /
$num
££0 1
,
££1 2
v
££3 4
+
££5 6
$num
££7 8
,
££8 9
v
££: ;
+
££< =
$num
££> ?
,
££? @
v
££A B
+
££C D
$num
££E F
,
££F G
v
££H I
+
££J K
$num
££L M
,
££M N
v
££O P
+
££Q R
$num
££S T
}
££U V
:
££W X
new
¤¤  #
int
¤¤$ '
[
¤¤' (
]
¤¤( )
{
¤¤* +
v
¤¤, -
+
¤¤. /
$num
¤¤0 1
,
¤¤1 2
v
¤¤3 4
+
¤¤5 6
$num
¤¤7 8
,
¤¤8 9
v
¤¤: ;
+
¤¤< =
$num
¤¤> ?
,
¤¤? @
v
¤¤A B
+
¤¤C D
$num
¤¤E F
,
¤¤F G
v
¤¤H I
+
¤¤J K
$num
¤¤L M
,
¤¤M N
v
¤¤O P
+
¤¤Q R
$num
¤¤S T
}
¤¤U V
)
¤¤V W
;
¤¤W X
sides_f
¦¦ 
[
¦¦  
st
¦¦  "
-
¦¦# $
$num
¦¦% &
]
¦¦& '
.
¦¦' (
textureGroup
¦¦( 4
=
¦¦5 6
side
¦¦7 ;
+
¦¦< =
$num
¦¦> ?
;
¦¦? @
v
¨¨ 
+=
¨¨ 
$num
¨¨ 
;
¨¨ 
sv
©© 
+=
©© 
$num
©© 
;
©©  
if
¬¬ 
(
¬¬ 
i
¬¬ 
>
¬¬ 
$num
¬¬  !
)
¬¬! "
{
­­ 
sides_v
®® #
[
®®# $
sv
®®$ &
+
®®' (
$num
®®) *
]
®®* +
=
®®, -
new
®®. 1
Vector3
®®2 9
(
®®9 :
x
®®: ;
,
®®; <
y0
®®= ?
,
®®? @
z0
®®A C
)
®®C D
;
®®D E
sides_v
¯¯ #
[
¯¯# $
sv
¯¯$ &
+
¯¯' (
$num
¯¯) *
]
¯¯* +
=
¯¯, -
new
¯¯. 1
Vector3
¯¯2 9
(
¯¯9 :
x
¯¯: ;
,
¯¯; <
y1
¯¯= ?
,
¯¯? @
z0
¯¯A C
)
¯¯C D
;
¯¯D E
sides_v
°° #
[
°°# $
sv
°°$ &
+
°°' (
$num
°°) *
]
°°* +
=
°°, -
new
°°. 1
Vector3
°°2 9
(
°°9 :
x
°°: ;
,
°°; <
y1
°°= ?
,
°°? @
z1
°°A C
)
°°C D
;
°°D E
sides_f
²² #
[
²²# $
st
²²$ &
++
²²& (
]
²²( )
=
²²* +
new
²², /
Face
²²0 4
(
²²4 5
side
²²5 9
%
²²: ;
$num
²²< =
==
²²> @
$num
²²A B
?
²²C D
new
³³$ '
int
³³( +
[
³³+ ,
]
³³, -
{
³³. /
v
³³0 1
+
³³2 3
$num
³³4 5
,
³³5 6
v
³³7 8
+
³³9 :
$num
³³; <
,
³³< =
v
³³> ?
+
³³@ A
$num
³³B C
}
³³D E
:
³³F G
new
´´$ '
int
´´( +
[
´´+ ,
]
´´, -
{
´´. /
v
´´0 1
+
´´2 3
$num
´´4 5
,
´´5 6
v
´´7 8
+
´´9 :
$num
´´; <
,
´´< =
v
´´> ?
+
´´@ A
$num
´´B C
}
´´D E
)
´´E F
;
´´F G
sides_f
¶¶ #
[
¶¶# $
st
¶¶$ &
-
¶¶' (
$num
¶¶) *
]
¶¶* +
.
¶¶+ ,
textureGroup
¶¶, 8
=
¶¶9 :
side
¶¶; ?
+
¶¶@ A
$num
¶¶B C
;
¶¶C D
v
¸¸ 
+=
¸¸  
$num
¸¸! "
;
¸¸" #
sv
¹¹ 
+=
¹¹ !
$num
¹¹" #
;
¹¹# $
}
ºº 
}
»» 
vertices
½½ 
=
½½ 
vertices
½½ '
.
½½' (
Concat
½½( .
(
½½. /
sides_v
½½/ 6
)
½½6 7
;
½½7 8
faces
¾¾ 
=
¾¾ 
faces
¾¾ !
.
¾¾! "
Concat
¾¾" (
(
¾¾( )
sides_f
¾¾) 0
)
¾¾0 1
;
¾¾1 2
x
ÀÀ 
+=
ÀÀ 
size
ÀÀ 
.
ÀÀ 
x
ÀÀ 
;
ÀÀ  
}
ÁÁ 
vertices
ÄÄ 
=
ÄÄ 
vertices
ÄÄ #
.
ÄÄ# $
Concat
ÄÄ$ *
(
ÄÄ* +
new
ÄÄ+ .
Vector3
ÄÄ/ 6
[
ÄÄ6 7
]
ÄÄ7 8
{
ÄÄ9 :
new
ÅÅ 
Vector3
ÅÅ 
(
ÅÅ  
$num
ÅÅ  "
,
ÅÅ" #
$num
ÅÅ$ &
,
ÅÅ& '
size
ÅÅ( ,
.
ÅÅ, -
z
ÅÅ- .
)
ÅÅ. /
,
ÅÅ/ 0
new
ÆÆ 
Vector3
ÆÆ 
(
ÆÆ  
size
ÆÆ  $
.
ÆÆ$ %
x
ÆÆ% &
,
ÆÆ& '
$num
ÆÆ( *
,
ÆÆ* +
size
ÆÆ, 0
.
ÆÆ0 1
z
ÆÆ1 2
)
ÆÆ2 3
,
ÆÆ3 4
new
ÇÇ 
Vector3
ÇÇ 
(
ÇÇ  
$num
ÇÇ  "
,
ÇÇ" #
size
ÇÇ$ (
.
ÇÇ( )
y
ÇÇ) *
,
ÇÇ* +
size
ÇÇ, 0
.
ÇÇ0 1
z
ÇÇ1 2
)
ÇÇ2 3
,
ÇÇ3 4
new
ÈÈ 
Vector3
ÈÈ 
(
ÈÈ  
size
ÈÈ  $
.
ÈÈ$ %
x
ÈÈ% &
,
ÈÈ& '
size
ÈÈ( ,
.
ÈÈ, -
y
ÈÈ- .
,
ÈÈ. /
size
ÈÈ0 4
.
ÈÈ4 5
z
ÈÈ5 6
)
ÈÈ6 7
}
ÉÉ 
)
ÉÉ 
;
ÉÉ 
faces
ËË 
=
ËË 
faces
ËË 
.
ËË 
Add
ËË !
(
ËË! "
new
ËË" %
Face
ËË& *
(
ËË* +
new
ËË+ .
int
ËË/ 2
[
ËË2 3
]
ËË3 4
{
ËË5 6
v
ËË6 7
+
ËË8 9
$num
ËË: ;
,
ËË; <
v
ËË= >
+
ËË? @
$num
ËËA B
,
ËËB C
v
ËËD E
+
ËËF G
$num
ËËH I
,
ËËI J
v
ËËK L
+
ËËM N
$num
ËËO P
,
ËËP Q
v
ËËR S
+
ËËT U
$num
ËËV W
,
ËËW X
v
ËËY Z
+
ËË[ \
$num
ËË] ^
}
ËË^ _
)
ËË_ `
)
ËË` a
;
ËËa b
}
ÌÌ 
ProBuilderMesh
ÎÎ 
pb
ÎÎ 
=
ÎÎ 
ProBuilderMesh
ÎÎ  .
.
ÎÎ. /
Create
ÎÎ/ 5
(
ÎÎ5 6
vertices
ÎÎ6 >
,
ÎÎ> ?
faces
ÎÎ@ E
)
ÎÎE F
;
ÎÎF G
pb
ÏÏ 
.
ÏÏ 

gameObject
ÏÏ 
.
ÏÏ 
name
ÏÏ 
=
ÏÏ  
$str
ÏÏ! )
;
ÏÏ) *
pb
ĞĞ 
.
ĞĞ 
SetPivot
ĞĞ 
(
ĞĞ 
	pivotType
ĞĞ !
)
ĞĞ! "
;
ĞĞ" #
return
ÒÒ 
pb
ÒÒ 
;
ÒÒ 
}
ÓÓ 	
public
àà 
static
àà 
ProBuilderMesh
àà $!
GenerateCurvedStair
àà% 8
(
àà8 9
PivotLocation
àà9 F
	pivotType
ààG P
,
ààP Q
float
ààR W

stairWidth
ààX b
,
ààb c
float
ààd i
height
ààj p
,
ààp q
float
ààr w
innerRadiusààx ƒ
,ààƒ „
floatàà… Š
circumferenceàà‹ ˜
,àà˜ ™
intààš 
stepsàà £
,àà£ ¤
boolàà¥ ©

buildSidesààª ´
)àà´ µ
{
áá 	
bool
ââ 
noInnerSide
ââ 
=
ââ 
innerRadius
ââ *
<
ââ+ ,
Mathf
ââ- 2
.
ââ2 3
Epsilon
ââ3 :
;
ââ: ;
Vector3
ææ 
[
ææ 
]
ææ 
	positions
ææ 
=
ææ  !
new
ææ" %
Vector3
ææ& -
[
ææ- .
(
ææ. /
$num
ææ/ 0
*
ææ1 2
steps
ææ3 8
)
ææ8 9
+
ææ: ;
(
ææ< =
(
ææ= >
noInnerSide
ææ> I
?
ææJ K
$num
ææL M
:
ææN O
$num
ææP Q
)
ææQ R
*
ææS T
steps
ææU Z
)
ææZ [
]
ææ[ \
;
ææ\ ]
Face
çç 
[
çç 
]
çç 
faces
çç 
=
çç 
new
çç 
Face
çç #
[
çç# $
steps
çç$ )
*
çç* +
$num
çç, -
]
çç- .
;
çç. /
int
êê 
v
êê 
=
êê 
$num
êê 
,
êê 
t
êê 
=
êê 
$num
êê 
;
êê 
float
ìì 
cir
ìì 
=
ìì 
Mathf
ìì 
.
ìì 
Abs
ìì !
(
ìì! "
circumference
ìì" /
)
ìì/ 0
*
ìì1 2
Mathf
ìì3 8
.
ìì8 9
Deg2Rad
ìì9 @
;
ìì@ A
float
íí 
outerRadius
íí 
=
íí 
innerRadius
íí  +
+
íí, -

stairWidth
íí. 8
;
íí8 9
for
ïï 
(
ïï 
int
ïï 
i
ïï 
=
ïï 
$num
ïï 
;
ïï 
i
ïï 
<
ïï 
steps
ïï  %
;
ïï% &
i
ïï' (
++
ïï( *
)
ïï* +
{
ğğ 
float
ññ 
inc0
ññ 
=
ññ 
(
ññ 
i
ññ 
/
ññ  !
(
ññ" #
float
ññ# (
)
ññ( )
steps
ññ) .
)
ññ. /
*
ññ0 1
cir
ññ2 5
;
ññ5 6
float
òò 
inc1
òò 
=
òò 
(
òò 
(
òò 
i
òò  
+
òò! "
$num
òò# $
)
òò$ %
/
òò& '
(
òò( )
float
òò) .
)
òò. /
steps
òò/ 4
)
òò4 5
*
òò6 7
cir
òò8 ;
;
òò; <
float
ôô 
h0
ôô 
=
ôô 
(
ôô 
(
ôô 
i
ôô 
/
ôô  
(
ôô! "
float
ôô" '
)
ôô' (
steps
ôô( -
)
ôô- .
*
ôô/ 0
height
ôô1 7
)
ôô7 8
;
ôô8 9
float
õõ 
h1
õõ 
=
õõ 
(
õõ 
(
õõ 
(
õõ 
i
õõ 
+
õõ  !
$num
õõ" #
)
õõ# $
/
õõ% &
(
õõ' (
float
õõ( -
)
õõ- .
steps
õõ. 3
)
õõ3 4
*
õõ5 6
height
õõ7 =
)
õõ= >
;
õõ> ?
Vector3
÷÷ 
v0
÷÷ 
=
÷÷ 
new
÷÷  
Vector3
÷÷! (
(
÷÷( )
-
÷÷) *
Mathf
÷÷* /
.
÷÷/ 0
Cos
÷÷0 3
(
÷÷3 4
inc0
÷÷4 8
)
÷÷8 9
,
÷÷9 :
$num
÷÷; =
,
÷÷= >
Mathf
÷÷? D
.
÷÷D E
Sin
÷÷E H
(
÷÷H I
inc0
÷÷I M
)
÷÷M N
)
÷÷N O
;
÷÷O P
Vector3
øø 
v1
øø 
=
øø 
new
øø  
Vector3
øø! (
(
øø( )
-
øø) *
Mathf
øø* /
.
øø/ 0
Cos
øø0 3
(
øø3 4
inc1
øø4 8
)
øø8 9
,
øø9 :
$num
øø; =
,
øø= >
Mathf
øø? D
.
øøD E
Sin
øøE H
(
øøH I
inc1
øøI M
)
øøM N
)
øøN O
;
øøO P
	positions
…… 
[
…… 
v
…… 
+
…… 
$num
…… 
]
……  
=
……! "
v0
……# %
*
……& '
innerRadius
……( 3
;
……3 4
	positions
†† 
[
†† 
v
†† 
+
†† 
$num
†† 
]
††  
=
††! "
v0
††# %
*
††& '
outerRadius
††( 3
;
††3 4
	positions
‡‡ 
[
‡‡ 
v
‡‡ 
+
‡‡ 
$num
‡‡ 
]
‡‡  
=
‡‡! "
v0
‡‡# %
*
‡‡& '
innerRadius
‡‡( 3
;
‡‡3 4
	positions
ˆˆ 
[
ˆˆ 
v
ˆˆ 
+
ˆˆ 
$num
ˆˆ 
]
ˆˆ  
=
ˆˆ! "
v0
ˆˆ# %
*
ˆˆ& '
outerRadius
ˆˆ( 3
;
ˆˆ3 4
	positions
ŠŠ 
[
ŠŠ 
v
ŠŠ 
+
ŠŠ 
$num
ŠŠ 
]
ŠŠ  
.
ŠŠ  !
y
ŠŠ! "
=
ŠŠ# $
h0
ŠŠ% '
;
ŠŠ' (
	positions
‹‹ 
[
‹‹ 
v
‹‹ 
+
‹‹ 
$num
‹‹ 
]
‹‹  
.
‹‹  !
y
‹‹! "
=
‹‹# $
h0
‹‹% '
;
‹‹' (
	positions
ŒŒ 
[
ŒŒ 
v
ŒŒ 
+
ŒŒ 
$num
ŒŒ 
]
ŒŒ  
.
ŒŒ  !
y
ŒŒ! "
=
ŒŒ# $
h1
ŒŒ% '
;
ŒŒ' (
	positions
 
[
 
v
 
+
 
$num
 
]
  
.
  !
y
! "
=
# $
h1
% '
;
' (
	positions
 
[
 
v
 
+
 
$num
 
]
  
=
! "
	positions
# ,
[
, -
v
- .
+
/ 0
$num
1 2
]
2 3
;
3 4
	positions
 
[
 
v
 
+
 
$num
 
]
  
=
! "
	positions
# ,
[
, -
v
- .
+
/ 0
$num
1 2
]
2 3
;
3 4
	positions
’’ 
[
’’ 
v
’’ 
+
’’ 
$num
’’ 
]
’’  
=
’’! "
v1
’’# %
*
’’& '
outerRadius
’’( 3
;
’’3 4
	positions
““ 
[
““ 
v
““ 
+
““ 
$num
““ 
]
““  
.
““  !
y
““! "
=
““# $
h1
““% '
;
““' (
if
•• 
(
•• 
!
•• 
noInnerSide
••  
)
••  !
{
–– 
	positions
—— 
[
—— 
v
—— 
+
——  !
$num
——" #
]
——# $
=
——% &
v1
——' )
*
——* +
innerRadius
——, 7
;
——7 8
	positions
˜˜ 
[
˜˜ 
v
˜˜ 
+
˜˜  !
$num
˜˜" #
]
˜˜# $
.
˜˜$ %
y
˜˜% &
=
˜˜' (
h1
˜˜) +
;
˜˜+ ,
}
™™ 
faces
›› 
[
›› 
t
›› 
+
›› 
$num
›› 
]
›› 
=
›› 
new
›› "
Face
››# '
(
››' (
new
››( +
int
››, /
[
››/ 0
]
››0 1
{
››2 3
v
œœ 
+
œœ 
$num
œœ 
,
œœ 
v
 
+
 
$num
 
,
 
v
 
+
 
$num
 
,
 
v
ŸŸ 
+
ŸŸ 
$num
ŸŸ 
,
ŸŸ 
v
   
+
   
$num
   
,
   
v
¡¡ 
+
¡¡ 
$num
¡¡ 
}
¢¢ 
)
¢¢ 
;
¢¢ 
if
¤¤ 
(
¤¤ 
noInnerSide
¤¤ 
)
¤¤  
{
¥¥ 
faces
¦¦ 
[
¦¦ 
t
¦¦ 
+
¦¦ 
$num
¦¦ 
]
¦¦  
=
¦¦! "
new
¦¦# &
Face
¦¦' +
(
¦¦+ ,
new
¦¦, /
int
¦¦0 3
[
¦¦3 4
]
¦¦4 5
{
¦¦6 7
v
§§ 
+
§§ 
$num
§§ 
,
§§ 
v
¨¨ 
+
¨¨ 
$num
¨¨ 
,
¨¨ 
v
©© 
+
©© 
$num
©© 
}
ªª 
)
ªª 
;
ªª 
}
«« 
else
¬¬ 
{
­­ 
faces
®® 
[
®® 
t
®® 
+
®® 
$num
®® 
]
®®  
=
®®! "
new
®®# &
Face
®®' +
(
®®+ ,
new
®®, /
int
®®0 3
[
®®3 4
]
®®4 5
{
®®6 7
v
¯¯ 
+
¯¯ 
$num
¯¯ 
,
¯¯ 
v
°° 
+
°° 
$num
°° 
,
°° 
v
±± 
+
±± 
$num
±± 
,
±± 
v
²² 
+
²² 
$num
²² 
,
²² 
v
³³ 
+
³³ 
$num
³³ 
,
³³ 
v
´´ 
+
´´ 
$num
´´ 
}
µµ 
)
µµ 
;
µµ 
}
¶¶ 
float
¸¸ 

uvRotation
¸¸  
=
¸¸! "
(
¸¸# $
(
¸¸$ %
inc1
¸¸% )
+
¸¸* +
inc0
¸¸, 0
)
¸¸0 1
*
¸¸2 3
-
¸¸4 5
$num
¸¸5 8
)
¸¸8 9
*
¸¸: ;
Mathf
¸¸< A
.
¸¸A B
Rad2Deg
¸¸B I
;
¸¸I J

uvRotation
¹¹ 
%=
¹¹ 
$num
¹¹ "
;
¹¹" #
if
ºº 
(
ºº 

uvRotation
ºº 
<
ºº  
$num
ºº! #
)
ºº# $

uvRotation
»» 
=
»»  
$num
»»! %
+
»»& '

uvRotation
»»( 2
;
»»2 3
var
½½ 
uv
½½ 
=
½½ 
faces
½½ 
[
½½ 
t
½½  
+
½½! "
$num
½½# $
]
½½$ %
.
½½% &
uv
½½& (
;
½½( )
uv
¾¾ 
.
¾¾ 
rotation
¾¾ 
=
¾¾ 

uvRotation
¾¾ (
;
¾¾( )
faces
¿¿ 
[
¿¿ 
t
¿¿ 
+
¿¿ 
$num
¿¿ 
]
¿¿ 
.
¿¿ 
uv
¿¿ 
=
¿¿  !
uv
¿¿" $
;
¿¿$ %
v
ÁÁ 
+=
ÁÁ 
noInnerSide
ÁÁ  
?
ÁÁ! "
$num
ÁÁ# $
:
ÁÁ% &
$num
ÁÁ' (
;
ÁÁ( )
t
ÂÂ 
+=
ÂÂ 
$num
ÂÂ 
;
ÂÂ 
}
ÃÃ 
if
ÆÆ 
(
ÆÆ 

buildSides
ÆÆ 
)
ÆÆ 
{
ÇÇ 
float
ÊÊ 
x
ÊÊ 
=
ÊÊ 
noInnerSide
ÊÊ %
?
ÊÊ& '
innerRadius
ÊÊ( 3
+
ÊÊ4 5

stairWidth
ÊÊ6 @
:
ÊÊA B
innerRadius
ÊÊC N
;
ÊÊN O
for
ÌÌ 
(
ÌÌ 
int
ÌÌ 
side
ÌÌ 
=
ÌÌ 
(
ÌÌ  !
noInnerSide
ÌÌ! ,
?
ÌÌ- .
$num
ÌÌ/ 0
:
ÌÌ1 2
$num
ÌÌ3 4
)
ÌÌ4 5
;
ÌÌ5 6
side
ÌÌ7 ;
<
ÌÌ< =
$num
ÌÌ> ?
;
ÌÌ? @
side
ÌÌA E
++
ÌÌE G
)
ÌÌG H
{
ÍÍ 
Vector3
ÎÎ 
[
ÎÎ 
]
ÎÎ 
sides_v
ÎÎ %
=
ÎÎ& '
new
ÎÎ( +
Vector3
ÎÎ, 3
[
ÎÎ3 4
steps
ÎÎ4 9
*
ÎÎ: ;
$num
ÎÎ< =
+
ÎÎ> ?
(
ÎÎ@ A
steps
ÎÎA F
-
ÎÎG H
$num
ÎÎI J
)
ÎÎJ K
*
ÎÎL M
$num
ÎÎN O
]
ÎÎO P
;
ÎÎP Q
Face
ÏÏ 
[
ÏÏ 
]
ÏÏ 
sides_f
ÏÏ "
=
ÏÏ# $
new
ÏÏ% (
Face
ÏÏ) -
[
ÏÏ- .
steps
ÏÏ. 3
+
ÏÏ4 5
steps
ÏÏ6 ;
-
ÏÏ< =
$num
ÏÏ> ?
]
ÏÏ? @
;
ÏÏ@ A
int
ÑÑ 
sv
ÑÑ 
=
ÑÑ 
$num
ÑÑ 
,
ÑÑ 
st
ÑÑ  "
=
ÑÑ# $
$num
ÑÑ% &
;
ÑÑ& '
for
ÓÓ 
(
ÓÓ 
int
ÓÓ 
i
ÓÓ 
=
ÓÓ  
$num
ÓÓ! "
;
ÓÓ" #
i
ÓÓ$ %
<
ÓÓ& '
steps
ÓÓ( -
;
ÓÓ- .
i
ÓÓ/ 0
++
ÓÓ0 2
)
ÓÓ2 3
{
ÔÔ 
float
ÕÕ 
inc0
ÕÕ "
=
ÕÕ# $
(
ÕÕ% &
i
ÕÕ& '
/
ÕÕ( )
(
ÕÕ* +
float
ÕÕ+ 0
)
ÕÕ0 1
steps
ÕÕ1 6
)
ÕÕ6 7
*
ÕÕ8 9
cir
ÕÕ: =
;
ÕÕ= >
float
ÖÖ 
inc1
ÖÖ "
=
ÖÖ# $
(
ÖÖ% &
(
ÖÖ& '
i
ÖÖ' (
+
ÖÖ) *
$num
ÖÖ+ ,
)
ÖÖ, -
/
ÖÖ. /
(
ÖÖ0 1
float
ÖÖ1 6
)
ÖÖ6 7
steps
ÖÖ7 <
)
ÖÖ< =
*
ÖÖ> ?
cir
ÖÖ@ C
;
ÖÖC D
float
ØØ 
h0
ØØ  
=
ØØ! "
(
ØØ# $
(
ØØ$ %
Mathf
ØØ% *
.
ØØ* +
Max
ØØ+ .
(
ØØ. /
i
ØØ/ 0
,
ØØ0 1
$num
ØØ2 3
)
ØØ3 4
/
ØØ5 6
(
ØØ7 8
float
ØØ8 =
)
ØØ= >
steps
ØØ> C
)
ØØC D
*
ØØE F
height
ØØG M
)
ØØM N
;
ØØN O
float
ÙÙ 
h1
ÙÙ  
=
ÙÙ! "
(
ÙÙ# $
(
ÙÙ$ %
(
ÙÙ% &
i
ÙÙ& '
+
ÙÙ( )
$num
ÙÙ* +
)
ÙÙ+ ,
/
ÙÙ- .
(
ÙÙ/ 0
float
ÙÙ0 5
)
ÙÙ5 6
steps
ÙÙ6 ;
)
ÙÙ; <
*
ÙÙ= >
height
ÙÙ? E
)
ÙÙE F
;
ÙÙF G
Vector3
ÛÛ 
v0
ÛÛ  "
=
ÛÛ# $
new
ÛÛ% (
Vector3
ÛÛ) 0
(
ÛÛ0 1
-
ÛÛ1 2
Mathf
ÛÛ2 7
.
ÛÛ7 8
Cos
ÛÛ8 ;
(
ÛÛ; <
inc0
ÛÛ< @
)
ÛÛ@ A
,
ÛÛA B
$num
ÛÛC E
,
ÛÛE F
Mathf
ÛÛG L
.
ÛÛL M
Sin
ÛÛM P
(
ÛÛP Q
inc0
ÛÛQ U
)
ÛÛU V
)
ÛÛV W
*
ÛÛX Y
x
ÛÛZ [
;
ÛÛ[ \
Vector3
ÜÜ 
v1
ÜÜ  "
=
ÜÜ# $
new
ÜÜ% (
Vector3
ÜÜ) 0
(
ÜÜ0 1
-
ÜÜ1 2
Mathf
ÜÜ2 7
.
ÜÜ7 8
Cos
ÜÜ8 ;
(
ÜÜ; <
inc1
ÜÜ< @
)
ÜÜ@ A
,
ÜÜA B
$num
ÜÜC E
,
ÜÜE F
Mathf
ÜÜG L
.
ÜÜL M
Sin
ÜÜM P
(
ÜÜP Q
inc1
ÜÜQ U
)
ÜÜU V
)
ÜÜV W
*
ÜÜX Y
x
ÜÜZ [
;
ÜÜ[ \
sides_v
ŞŞ 
[
ŞŞ  
sv
ŞŞ  "
+
ŞŞ# $
$num
ŞŞ% &
]
ŞŞ& '
=
ŞŞ( )
v0
ŞŞ* ,
;
ŞŞ, -
sides_v
ßß 
[
ßß  
sv
ßß  "
+
ßß# $
$num
ßß% &
]
ßß& '
=
ßß( )
v1
ßß* ,
;
ßß, -
sides_v
àà 
[
àà  
sv
àà  "
+
àà# $
$num
àà% &
]
àà& '
=
àà( )
v0
àà* ,
;
àà, -
sides_v
áá 
[
áá  
sv
áá  "
+
áá# $
$num
áá% &
]
áá& '
=
áá( )
v1
áá* ,
;
áá, -
sides_v
ãã 
[
ãã  
sv
ãã  "
+
ãã# $
$num
ãã% &
]
ãã& '
.
ãã' (
y
ãã( )
=
ãã* +
$num
ãã, .
;
ãã. /
sides_v
ää 
[
ää  
sv
ää  "
+
ää# $
$num
ää% &
]
ää& '
.
ää' (
y
ää( )
=
ää* +
$num
ää, .
;
ää. /
sides_v
åå 
[
åå  
sv
åå  "
+
åå# $
$num
åå% &
]
åå& '
.
åå' (
y
åå( )
=
åå* +
h0
åå, .
;
åå. /
sides_v
ææ 
[
ææ  
sv
ææ  "
+
ææ# $
$num
ææ% &
]
ææ& '
.
ææ' (
y
ææ( )
=
ææ* +
h1
ææ, .
;
ææ. /
sides_f
èè 
[
èè  
st
èè  "
++
èè" $
]
èè$ %
=
èè& '
new
èè( +
Face
èè, 0
(
èè0 1
side
èè1 5
%
èè6 7
$num
èè8 9
==
èè: <
$num
èè= >
?
èè? @
new
éé  #
int
éé$ '
[
éé' (
]
éé( )
{
éé* +
v
éé, -
+
éé. /
$num
éé0 1
,
éé1 2
v
éé3 4
+
éé5 6
$num
éé7 8
,
éé8 9
v
éé: ;
+
éé< =
$num
éé> ?
,
éé? @
v
ééA B
+
ééC D
$num
ééE F
,
ééF G
v
ééH I
+
ééJ K
$num
ééL M
,
ééM N
v
ééO P
+
ééQ R
$num
ééS T
}
ééU V
:
ééW X
new
êê  #
int
êê$ '
[
êê' (
]
êê( )
{
êê* +
v
êê, -
+
êê. /
$num
êê0 1
,
êê1 2
v
êê3 4
+
êê5 6
$num
êê7 8
,
êê8 9
v
êê: ;
+
êê< =
$num
êê> ?
,
êê? @
v
êêA B
+
êêC D
$num
êêE F
,
êêF G
v
êêH I
+
êêJ K
$num
êêL M
,
êêM N
v
êêO P
+
êêQ R
$num
êêS T
}
êêU V
)
êêV W
;
êêW X
sides_f
ëë 
[
ëë  
st
ëë  "
-
ëë# $
$num
ëë% &
]
ëë& '
.
ëë' (
smoothingGroup
ëë( 6
=
ëë7 8
side
ëë9 =
+
ëë> ?
$num
ëë@ A
;
ëëA B
v
íí 
+=
íí 
$num
íí 
;
íí 
sv
îî 
+=
îî 
$num
îî 
;
îî  
if
ññ 
(
ññ 
i
ññ 
>
ññ 
$num
ññ  !
)
ññ! "
{
òò 
sides_f
óó #
[
óó# $
st
óó$ &
-
óó' (
$num
óó) *
]
óó* +
.
óó+ ,
textureGroup
óó, 8
=
óó9 :
(
óó; <
side
óó< @
*
óóA B
steps
óóC H
)
óóH I
+
óóJ K
i
óóL M
;
óóM N
sides_v
õõ #
[
õõ# $
sv
õõ$ &
+
õõ' (
$num
õõ) *
]
õõ* +
=
õõ, -
v0
õõ. 0
;
õõ0 1
sides_v
öö #
[
öö# $
sv
öö$ &
+
öö' (
$num
öö) *
]
öö* +
=
öö, -
v1
öö. 0
;
öö0 1
sides_v
÷÷ #
[
÷÷# $
sv
÷÷$ &
+
÷÷' (
$num
÷÷) *
]
÷÷* +
=
÷÷, -
v0
÷÷. 0
;
÷÷0 1
sides_v
øø #
[
øø# $
sv
øø$ &
+
øø' (
$num
øø) *
]
øø* +
.
øø+ ,
y
øø, -
=
øø. /
h0
øø0 2
;
øø2 3
sides_v
ùù #
[
ùù# $
sv
ùù$ &
+
ùù' (
$num
ùù) *
]
ùù* +
.
ùù+ ,
y
ùù, -
=
ùù. /
h1
ùù0 2
;
ùù2 3
sides_v
úú #
[
úú# $
sv
úú$ &
+
úú' (
$num
úú) *
]
úú* +
.
úú+ ,
y
úú, -
=
úú. /
h1
úú0 2
;
úú2 3
sides_f
üü #
[
üü# $
st
üü$ &
++
üü& (
]
üü( )
=
üü* +
new
üü, /
Face
üü0 4
(
üü4 5
side
üü5 9
%
üü: ;
$num
üü< =
==
üü> @
$num
üüA B
?
üüC D
new
ıı$ '
int
ıı( +
[
ıı+ ,
]
ıı, -
{
ıı. /
v
ıı0 1
+
ıı2 3
$num
ıı4 5
,
ıı5 6
v
ıı7 8
+
ıı9 :
$num
ıı; <
,
ıı< =
v
ıı> ?
+
ıı@ A
$num
ııB C
}
ııD E
:
ııF G
new
şş$ '
int
şş( +
[
şş+ ,
]
şş, -
{
şş. /
v
şş0 1
+
şş2 3
$num
şş4 5
,
şş5 6
v
şş7 8
+
şş9 :
$num
şş; <
,
şş< =
v
şş> ?
+
şş@ A
$num
şşB C
}
şşD E
)
şşE F
;
şşF G
sides_f
€€ #
[
€€# $
st
€€$ &
-
€€' (
$num
€€) *
]
€€* +
.
€€+ ,
textureGroup
€€, 8
=
€€9 :
(
€€; <
side
€€< @
*
€€A B
steps
€€C H
)
€€H I
+
€€J K
i
€€L M
;
€€M N
sides_f
 #
[
# $
st
$ &
-
' (
$num
) *
]
* +
.
+ ,
smoothingGroup
, :
=
; <
side
= A
+
B C
$num
D E
;
E F
v
ƒƒ 
+=
ƒƒ  
$num
ƒƒ! "
;
ƒƒ" #
sv
„„ 
+=
„„ !
$num
„„" #
;
„„# $
}
…… 
}
†† 
	positions
ˆˆ 
=
ˆˆ 
	positions
ˆˆ  )
.
ˆˆ) *
Concat
ˆˆ* 0
(
ˆˆ0 1
sides_v
ˆˆ1 8
)
ˆˆ8 9
;
ˆˆ9 :
faces
‰‰ 
=
‰‰ 
faces
‰‰ !
.
‰‰! "
Concat
‰‰" (
(
‰‰( )
sides_f
‰‰) 0
)
‰‰0 1
;
‰‰1 2
x
‹‹ 
+=
‹‹ 

stairWidth
‹‹ #
;
‹‹# $
}
ŒŒ 
float
 
cos
 
=
 
-
 
Mathf
 "
.
" #
Cos
# &
(
& '
cir
' *
)
* +
,
+ ,
sin
- 0
=
1 2
Mathf
3 8
.
8 9
Sin
9 <
(
< =
cir
= @
)
@ A
;
A B
	positions
‘‘ 
=
‘‘ 
	positions
‘‘ %
.
‘‘% &
Concat
‘‘& ,
(
‘‘, -
new
‘‘- 0
Vector3
‘‘1 8
[
‘‘8 9
]
‘‘9 :
{
’’ 
new
““ 
Vector3
““ 
(
““  
cos
““  #
,
““# $
$num
““% '
,
““' (
sin
““) ,
)
““, -
*
““. /
innerRadius
““0 ;
,
““; <
new
”” 
Vector3
”” 
(
””  
cos
””  #
,
””# $
$num
””% '
,
””' (
sin
””) ,
)
””, -
*
””. /
outerRadius
””0 ;
,
””; <
new
•• 
Vector3
•• 
(
••  
cos
••  #
*
••$ %
innerRadius
••& 1
,
••1 2
height
••3 9
,
••9 :
sin
••; >
*
••? @
innerRadius
••A L
)
••L M
,
••M N
new
–– 
Vector3
–– 
(
––  
cos
––  #
*
––$ %
outerRadius
––& 1
,
––1 2
height
––3 9
,
––9 :
sin
––; >
*
––? @
outerRadius
––A L
)
––L M
}
—— 
)
—— 
;
—— 
faces
™™ 
=
™™ 
faces
™™ 
.
™™ 
Add
™™ !
(
™™! "
new
™™" %
Face
™™& *
(
™™* +
new
™™+ .
int
™™/ 2
[
™™2 3
]
™™3 4
{
™™5 6
v
™™6 7
+
™™8 9
$num
™™: ;
,
™™; <
v
™™= >
+
™™? @
$num
™™A B
,
™™B C
v
™™D E
+
™™F G
$num
™™H I
,
™™I J
v
™™K L
+
™™M N
$num
™™O P
,
™™P Q
v
™™R S
+
™™T U
$num
™™V W
,
™™W X
v
™™Y Z
+
™™[ \
$num
™™] ^
}
™™^ _
)
™™_ `
)
™™` a
;
™™a b
}
šš 
if
œœ 
(
œœ 
circumference
œœ 
<
œœ 
$num
œœ  "
)
œœ" #
{
 
Vector3
 
flip
 
=
 
new
 "
Vector3
# *
(
* +
-
+ ,
$num
, .
,
. /
$num
0 2
,
2 3
$num
4 6
)
6 7
;
7 8
for
   
(
   
int
   
i
   
=
   
$num
   
;
   
i
    !
<
  " #
	positions
  $ -
.
  - .
Length
  . 4
;
  4 5
i
  6 7
++
  7 9
)
  9 :
	positions
¡¡ 
[
¡¡ 
i
¡¡ 
]
¡¡  
.
¡¡  !
Scale
¡¡! &
(
¡¡& '
flip
¡¡' +
)
¡¡+ ,
;
¡¡, -
foreach
££ 
(
££ 
Face
££ 
f
££ 
in
££  "
faces
££# (
)
££( )
f
¤¤ 
.
¤¤ 
Reverse
¤¤ 
(
¤¤ 
)
¤¤ 
;
¤¤  
}
¥¥ 
ProBuilderMesh
§§ 
pb
§§ 
=
§§ 
ProBuilderMesh
§§  .
.
§§. /
Create
§§/ 5
(
§§5 6
	positions
§§6 ?
,
§§? @
faces
§§A F
)
§§F G
;
§§G H
pb
©© 
.
©© 

gameObject
©© 
.
©© 
name
©© 
=
©©  
$str
©©! )
;
©©) *
pb
ªª 
.
ªª 
SetPivot
ªª 
(
ªª 
	pivotType
ªª !
)
ªª! "
;
ªª" #
return
¬¬ 
pb
¬¬ 
;
¬¬ 
}
­­ 	
internal
»» 
static
»» 
ProBuilderMesh
»» &
GenerateStair
»»' 4
(
»»4 5
PivotLocation
»»5 B
	pivotType
»»C L
,
»»L M
int
»»N Q
steps
»»R W
,
»»W X
float
»»Y ^
width
»»_ d
,
»»d e
float
»»f k
height
»»l r
,
»»r s
float
»»t y
depth
»»z 
,»» €
bool»» …
sidesGoToFloor»»† ”
,»»” •
bool»»– š
generateBack»»› §
,»»§ ¨
bool»»© ­
platformsOnly»»® »
)»»» ¼
{
¼¼ 	
int
½½ 
i
½½ 
=
½½ 
$num
½½ 
;
½½ 
List
¿¿ 
<
¿¿ 
Vector3
¿¿ 
>
¿¿ 
verts
¿¿ 
=
¿¿  !
new
¿¿" %
List
¿¿& *
<
¿¿* +
Vector3
¿¿+ 2
>
¿¿2 3
(
¿¿3 4
)
¿¿4 5
;
¿¿5 6
Vector3
ÀÀ 
[
ÀÀ 
]
ÀÀ 
v
ÀÀ 
=
ÀÀ 
(
ÀÀ 
platformsOnly
ÀÀ (
)
ÀÀ( )
?
ÀÀ* +
new
ÀÀ, /
Vector3
ÀÀ0 7
[
ÀÀ7 8
$num
ÀÀ8 9
]
ÀÀ9 :
:
ÀÀ; <
new
ÀÀ= @
Vector3
ÀÀA H
[
ÀÀH I
$num
ÀÀI K
]
ÀÀK L
;
ÀÀL M
float
ÂÂ 
	stepWidth
ÂÂ 
=
ÂÂ 
width
ÂÂ #
;
ÂÂ# $
float
ÃÃ 

stepHeight
ÃÃ 
=
ÃÃ 
height
ÃÃ %
/
ÃÃ& '
steps
ÃÃ( -
;
ÃÃ- .
float
ÄÄ 
	stepDepth
ÄÄ 
=
ÄÄ 
depth
ÄÄ #
/
ÄÄ$ %
steps
ÄÄ& +
;
ÄÄ+ ,
float
ÅÅ 
yMax
ÅÅ 
=
ÅÅ 

stepHeight
ÅÅ #
;
ÅÅ# $
for
ÈÈ 
(
ÈÈ 
i
ÈÈ 
=
ÈÈ 
$num
ÈÈ 
;
ÈÈ 
i
ÈÈ 
<
ÈÈ 
steps
ÈÈ !
;
ÈÈ! "
i
ÈÈ# $
++
ÈÈ$ &
)
ÈÈ& '
{
ÉÉ 
float
ÊÊ 
x
ÊÊ 
=
ÊÊ 
	stepWidth
ÊÊ #
/
ÊÊ$ %
$num
ÊÊ& (
,
ÊÊ( )
y
ÊÊ* +
=
ÊÊ, -
i
ÊÊ. /
*
ÊÊ0 1

stepHeight
ÊÊ2 <
,
ÊÊ< =
z
ÊÊ> ?
=
ÊÊ@ A
i
ÊÊB C
*
ÊÊD E
	stepDepth
ÊÊF O
;
ÊÊO P
if
ÌÌ 
(
ÌÌ 
sidesGoToFloor
ÌÌ "
)
ÌÌ" #
y
ÍÍ 
=
ÍÍ 
$num
ÍÍ 
;
ÍÍ 
yMax
ÏÏ 
=
ÏÏ 
i
ÏÏ 
*
ÏÏ 

stepHeight
ÏÏ %
+
ÏÏ& '

stepHeight
ÏÏ( 2
;
ÏÏ2 3
v
ÒÒ 
[
ÒÒ 
$num
ÒÒ 
]
ÒÒ 
=
ÒÒ 
new
ÒÒ 
Vector3
ÒÒ #
(
ÒÒ# $
x
ÒÒ$ %
,
ÒÒ% &
i
ÒÒ' (
*
ÒÒ) *

stepHeight
ÒÒ+ 5
,
ÒÒ5 6
z
ÒÒ9 :
)
ÒÒ: ;
;
ÒÒ; <
v
ÓÓ 
[
ÓÓ 
$num
ÓÓ 
]
ÓÓ 
=
ÓÓ 
new
ÓÓ 
Vector3
ÓÓ #
(
ÓÓ# $
-
ÓÓ$ %
x
ÓÓ% &
,
ÓÓ& '
i
ÓÓ( )
*
ÓÓ* +

stepHeight
ÓÓ, 6
,
ÓÓ6 7
z
ÓÓ: ;
)
ÓÓ; <
;
ÓÓ< =
v
ÔÔ 
[
ÔÔ 
$num
ÔÔ 
]
ÔÔ 
=
ÔÔ 
new
ÔÔ 
Vector3
ÔÔ "
(
ÔÔ" #
x
ÔÔ# $
,
ÔÔ$ %
yMax
ÔÔ& *
,
ÔÔ* +
z
ÔÔ7 8
)
ÔÔ8 9
;
ÔÔ9 :
v
ÕÕ 
[
ÕÕ 
$num
ÕÕ 
]
ÕÕ 
=
ÕÕ 
new
ÕÕ 
Vector3
ÕÕ "
(
ÕÕ" #
-
ÕÕ# $
x
ÕÕ$ %
,
ÕÕ% &
yMax
ÕÕ' +
,
ÕÕ+ ,
z
ÕÕ8 9
)
ÕÕ9 :
;
ÕÕ: ;
v
ØØ 
[
ØØ 
$num
ØØ 
]
ØØ 
=
ØØ 
new
ØØ 
Vector3
ØØ "
(
ØØ" #
x
ØØ# $
,
ØØ$ %
yMax
ØØ& *
,
ØØ* +
z
ØØ, -
)
ØØ- .
;
ØØ. /
v
ÙÙ 
[
ÙÙ 
$num
ÙÙ 
]
ÙÙ 
=
ÙÙ 
new
ÙÙ 
Vector3
ÙÙ "
(
ÙÙ" #
-
ÙÙ# $
x
ÙÙ$ %
,
ÙÙ% &
yMax
ÙÙ' +
,
ÙÙ+ ,
z
ÙÙ- .
)
ÙÙ. /
;
ÙÙ/ 0
v
ÚÚ 
[
ÚÚ 
$num
ÚÚ 
]
ÚÚ 
=
ÚÚ 
new
ÚÚ 
Vector3
ÚÚ "
(
ÚÚ" #
x
ÚÚ# $
,
ÚÚ$ %
yMax
ÚÚ& *
,
ÚÚ* +
z
ÚÚ, -
+
ÚÚ. /
	stepDepth
ÚÚ0 9
)
ÚÚ9 :
;
ÚÚ: ;
v
ÛÛ 
[
ÛÛ 
$num
ÛÛ 
]
ÛÛ 
=
ÛÛ 
new
ÛÛ 
Vector3
ÛÛ "
(
ÛÛ" #
-
ÛÛ# $
x
ÛÛ$ %
,
ÛÛ% &
yMax
ÛÛ' +
,
ÛÛ+ ,
z
ÛÛ- .
+
ÛÛ/ 0
	stepDepth
ÛÛ1 :
)
ÛÛ: ;
;
ÛÛ; <
if
İİ 
(
İİ 
!
İİ 
platformsOnly
İİ "
)
İİ" #
{
ŞŞ 
v
àà 
[
àà 
$num
àà 
]
àà 
=
àà 
new
àà 
Vector3
àà &
(
àà& '
x
àà' (
,
àà( )
y
àà* +
,
àà+ ,
z
àà3 4
+
àà5 6
	stepDepth
àà7 @
)
àà@ A
;
ààA B
v
áá 
[
áá 
$num
áá 
]
áá 
=
áá 
new
áá 
Vector3
áá &
(
áá& '
x
áá' (
,
áá( )
y
áá* +
,
áá+ ,
z
áá3 4
)
áá4 5
;
áá5 6
v
ââ 
[
ââ 
$num
ââ 
]
ââ 
=
ââ 
new
ââ 
Vector3
ââ  '
(
ââ' (
x
ââ( )
,
ââ) *
yMax
ââ+ /
,
ââ/ 0
z
ââ4 5
+
ââ6 7
	stepDepth
ââ8 A
)
ââA B
;
ââB C
v
ãã 
[
ãã 
$num
ãã 
]
ãã 
=
ãã 
new
ãã 
Vector3
ãã  '
(
ãã' (
x
ãã( )
,
ãã) *
yMax
ãã+ /
,
ãã/ 0
z
ãã4 5
)
ãã5 6
;
ãã6 7
v
ææ 
[
ææ 
$num
ææ 
]
ææ 
=
ææ 
new
ææ 
Vector3
ææ  '
(
ææ' (
-
ææ( )
x
ææ) *
,
ææ* +
y
ææ, -
,
ææ- .
z
ææ3 4
)
ææ4 5
;
ææ5 6
v
çç 
[
çç 
$num
çç 
]
çç 
=
çç 
new
çç 
Vector3
çç  '
(
çç' (
-
çç( )
x
çç) *
,
çç* +
y
çç, -
,
çç- .
z
çç3 4
+
çç5 6
	stepDepth
çç7 @
)
çç@ A
;
ççA B
v
èè 
[
èè 
$num
èè 
]
èè 
=
èè 
new
èè 
Vector3
èè  '
(
èè' (
-
èè( )
x
èè) *
,
èè* +
yMax
èè, 0
,
èè0 1
z
èè3 4
)
èè4 5
;
èè5 6
v
éé 
[
éé 
$num
éé 
]
éé 
=
éé 
new
éé 
Vector3
éé  '
(
éé' (
-
éé( )
x
éé) *
,
éé* +
yMax
éé, 0
,
éé0 1
z
éé3 4
+
éé5 6
	stepDepth
éé7 @
)
éé@ A
;
ééA B
}
êê 
verts
ìì 
.
ìì 
AddRange
ìì 
(
ìì 
v
ìì  
)
ìì  !
;
ìì! "
}
íí 
if
ïï 
(
ïï 
generateBack
ïï 
)
ïï 
{
ğğ 
verts
ññ 
.
ññ 
Add
ññ 
(
ññ 
new
ññ 
Vector3
ññ %
(
ññ% &
-
ññ& '
	stepWidth
ññ' 0
/
ññ1 2
$num
ññ3 5
,
ññ5 6
$num
ññ7 9
,
ññ9 :
depth
ññ; @
)
ññ@ A
)
ññA B
;
ññB C
verts
òò 
.
òò 
Add
òò 
(
òò 
new
òò 
Vector3
òò %
(
òò% &
	stepWidth
òò& /
/
òò0 1
$num
òò2 4
,
òò4 5
$num
òò6 8
,
òò8 9
depth
òò: ?
)
òò? @
)
òò@ A
;
òòA B
verts
óó 
.
óó 
Add
óó 
(
óó 
new
óó 
Vector3
óó %
(
óó% &
-
óó& '
	stepWidth
óó' 0
/
óó1 2
$num
óó3 5
,
óó5 6
height
óó7 =
,
óó= >
depth
óó? D
)
óóD E
)
óóE F
;
óóF G
verts
ôô 
.
ôô 
Add
ôô 
(
ôô 
new
ôô 
Vector3
ôô %
(
ôô% &
	stepWidth
ôô& /
/
ôô0 1
$num
ôô2 4
,
ôô4 5
height
ôô6 <
,
ôô< =
depth
ôô> C
)
ôôC D
)
ôôD E
;
ôôE F
}
õõ 
ProBuilderMesh
÷÷ 
pb
÷÷ 
=
÷÷ 
ProBuilderMesh
÷÷  .
.
÷÷. /&
CreateInstanceWithPoints
÷÷/ G
(
÷÷G H
verts
÷÷H M
.
÷÷M N
ToArray
÷÷N U
(
÷÷U V
)
÷÷V W
)
÷÷W X
;
÷÷X Y
pb
øø 
.
øø 

gameObject
øø 
.
øø 
name
øø 
=
øø  
$str
øø! )
;
øø) *
pb
ùù 
.
ùù 
SetPivot
ùù 
(
ùù 
	pivotType
ùù !
)
ùù! "
;
ùù" #
return
ûû 
pb
ûû 
;
ûû 
}
üü 	
public
„„ 
static
„„ 
ProBuilderMesh
„„ $
GenerateCube
„„% 1
(
„„1 2
PivotLocation
„„2 ?
	pivotType
„„@ I
,
„„I J
Vector3
„„K R
size
„„S W
)
„„W X
{
…… 	
Vector3
†† 
[
†† 
]
†† 
points
†† 
=
†† 
new
†† "
Vector3
††# *
[
††* +
k_CubeTriangles
††+ :
.
††: ;
Length
††; A
]
††A B
;
††B C
for
ˆˆ 
(
ˆˆ 
int
ˆˆ 
i
ˆˆ 
=
ˆˆ 
$num
ˆˆ 
;
ˆˆ 
i
ˆˆ 
<
ˆˆ 
k_CubeTriangles
ˆˆ  /
.
ˆˆ/ 0
Length
ˆˆ0 6
;
ˆˆ6 7
i
ˆˆ8 9
++
ˆˆ9 ;
)
ˆˆ; <
points
‰‰ 
[
‰‰ 
i
‰‰ 
]
‰‰ 
=
‰‰ 
Vector3
‰‰ #
.
‰‰# $
Scale
‰‰$ )
(
‰‰) *
k_CubeVertices
‰‰* 8
[
‰‰8 9
k_CubeTriangles
‰‰9 H
[
‰‰H I
i
‰‰I J
]
‰‰J K
]
‰‰K L
,
‰‰L M
size
‰‰N R
)
‰‰R S
;
‰‰S T
ProBuilderMesh
‹‹ 
pb
‹‹ 
=
‹‹ 
ProBuilderMesh
‹‹  .
.
‹‹. /&
CreateInstanceWithPoints
‹‹/ G
(
‹‹G H
points
‹‹H N
)
‹‹N O
;
‹‹O P
pb
ŒŒ 
.
ŒŒ 

gameObject
ŒŒ 
.
ŒŒ 
name
ŒŒ 
=
ŒŒ  
$str
ŒŒ! '
;
ŒŒ' (
pb
 
.
 
SetPivot
 
(
 
	pivotType
 !
)
! "
;
" #
return
 
pb
 
;
 
}
 	
public
œœ 
static
œœ 
ProBuilderMesh
œœ $
GenerateCylinder
œœ% 5
(
œœ5 6
PivotLocation
œœ6 C
	pivotType
œœD M
,
œœM N
int
œœO R
axisDivisions
œœS `
,
œœ` a
float
œœb g
radius
œœh n
,
œœn o
float
œœp u
height
œœv |
,
œœ| }
intœœ~ 

heightCutsœœ‚ Œ
,œœŒ 
intœœ ‘
	smoothingœœ’ ›
=œœœ 
-œœ Ÿ
$numœœŸ  
)œœ  ¡
{
 	
if
 
(
 
axisDivisions
 
%
 
$num
  !
!=
" $
$num
% &
)
& '
axisDivisions
ŸŸ 
++
ŸŸ 
;
ŸŸ  
if
¡¡ 
(
¡¡ 
axisDivisions
¡¡ 
>
¡¡ 
$num
¡¡  "
)
¡¡" #
axisDivisions
¢¢ 
=
¢¢ 
$num
¢¢  "
;
¢¢" #
float
¤¤ 
	stepAngle
¤¤ 
=
¤¤ 
$num
¤¤ "
/
¤¤# $
axisDivisions
¤¤% 2
;
¤¤2 3
float
¥¥ 

heightStep
¥¥ 
=
¥¥ 
height
¥¥ %
/
¥¥& '
(
¥¥( )

heightCuts
¥¥) 3
+
¥¥4 5
$num
¥¥6 7
)
¥¥7 8
;
¥¥8 9
Vector3
§§ 
[
§§ 
]
§§ 
circle
§§ 
=
§§ 
new
§§ "
Vector3
§§# *
[
§§* +
axisDivisions
§§+ 8
]
§§8 9
;
§§9 :
for
ªª 
(
ªª 
int
ªª 
i
ªª 
=
ªª 
$num
ªª 
;
ªª 
i
ªª 
<
ªª 
axisDivisions
ªª  -
;
ªª- .
i
ªª/ 0
++
ªª0 2
)
ªª2 3
{
«« 
float
¬¬ 
angle0
¬¬ 
=
¬¬ 
	stepAngle
¬¬ (
*
¬¬) *
i
¬¬+ ,
*
¬¬- .
Mathf
¬¬/ 4
.
¬¬4 5
Deg2Rad
¬¬5 <
;
¬¬< =
float
®® 
x
®® 
=
®® 
Mathf
®® 
.
®®  
Cos
®®  #
(
®®# $
angle0
®®$ *
)
®®* +
*
®®, -
radius
®®. 4
;
®®4 5
float
¯¯ 
z
¯¯ 
=
¯¯ 
Mathf
¯¯ 
.
¯¯  
Sin
¯¯  #
(
¯¯# $
angle0
¯¯$ *
)
¯¯* +
*
¯¯, -
radius
¯¯. 4
;
¯¯4 5
circle
±± 
[
±± 
i
±± 
]
±± 
=
±± 
new
±± 
Vector3
±±  '
(
±±' (
x
±±( )
,
±±) *
$num
±±+ -
,
±±- .
z
±±/ 0
)
±±0 1
;
±±1 2
}
²² 
Vector3
µµ 
[
µµ 
]
µµ 
verts
µµ 
=
µµ 
new
µµ !
Vector3
µµ" )
[
µµ) *
(
µµ* +
axisDivisions
µµ+ 8
*
µµ9 :
(
µµ; <

heightCuts
µµ< F
+
µµG H
$num
µµI J
)
µµJ K
*
µµL M
$num
µµN O
)
µµO P
+
µµQ R
(
µµS T
axisDivisions
µµT a
*
µµb c
$num
µµd e
)
µµe f
]
µµf g
;
µµg h
Face
¶¶ 
[
¶¶ 
]
¶¶ 
faces
¶¶ 
=
¶¶ 
new
¶¶ 
Face
¶¶ #
[
¶¶# $
axisDivisions
¶¶$ 1
*
¶¶2 3
(
¶¶4 5

heightCuts
¶¶5 ?
+
¶¶@ A
$num
¶¶B C
)
¶¶C D
+
¶¶G H
(
¶¶I J
axisDivisions
¶¶J W
*
¶¶X Y
$num
¶¶Z [
)
¶¶[ \
]
¶¶\ ]
;
¶¶] ^
int
¹¹ 
it
¹¹ 
=
¹¹ 
$num
¹¹ 
;
¹¹ 
for
»» 
(
»» 
int
»» 
i
»» 
=
»» 
$num
»» 
;
»» 
i
»» 
<
»» 

heightCuts
»»  *
+
»»+ ,
$num
»»- .
;
»». /
i
»»0 1
++
»»1 3
)
»»3 4
{
¼¼ 
float
½½ 
Y
½½ 
=
½½ 
i
½½ 
*
½½ 

heightStep
½½ (
;
½½( )
float
¾¾ 
Y2
¾¾ 
=
¾¾ 
(
¾¾ 
i
¾¾ 
+
¾¾ 
$num
¾¾  !
)
¾¾! "
*
¾¾# $

heightStep
¾¾% /
;
¾¾/ 0
for
ÀÀ 
(
ÀÀ 
int
ÀÀ 
n
ÀÀ 
=
ÀÀ 
$num
ÀÀ 
;
ÀÀ 
n
ÀÀ  !
<
ÀÀ" #
axisDivisions
ÀÀ$ 1
;
ÀÀ1 2
n
ÀÀ3 4
++
ÀÀ4 6
)
ÀÀ6 7
{
ÁÁ 
verts
ÂÂ 
[
ÂÂ 
it
ÂÂ 
+
ÂÂ 
$num
ÂÂ  
]
ÂÂ  !
=
ÂÂ" #
new
ÂÂ$ '
Vector3
ÂÂ( /
(
ÂÂ/ 0
circle
ÂÂ0 6
[
ÂÂ6 7
n
ÂÂ7 8
+
ÂÂ9 :
$num
ÂÂ; <
]
ÂÂ< =
.
ÂÂ= >
x
ÂÂ> ?
,
ÂÂ? @
Y
ÂÂA B
,
ÂÂB C
circle
ÂÂD J
[
ÂÂJ K
n
ÂÂK L
+
ÂÂM N
$num
ÂÂO P
]
ÂÂP Q
.
ÂÂQ R
z
ÂÂR S
)
ÂÂS T
;
ÂÂT U
verts
ÃÃ 
[
ÃÃ 
it
ÃÃ 
+
ÃÃ 
$num
ÃÃ  
]
ÃÃ  !
=
ÃÃ" #
new
ÃÃ$ '
Vector3
ÃÃ( /
(
ÃÃ/ 0
circle
ÃÃ0 6
[
ÃÃ6 7
n
ÃÃ7 8
+
ÃÃ9 :
$num
ÃÃ; <
]
ÃÃ< =
.
ÃÃ= >
x
ÃÃ> ?
,
ÃÃ? @
Y2
ÃÃA C
,
ÃÃC D
circle
ÃÃE K
[
ÃÃK L
n
ÃÃL M
+
ÃÃN O
$num
ÃÃP Q
]
ÃÃQ R
.
ÃÃR S
z
ÃÃS T
)
ÃÃT U
;
ÃÃU V
if
ÅÅ 
(
ÅÅ 
n
ÅÅ 
!=
ÅÅ 
axisDivisions
ÅÅ *
-
ÅÅ+ ,
$num
ÅÅ- .
)
ÅÅ. /
{
ÆÆ 
verts
ÇÇ 
[
ÇÇ 
it
ÇÇ  
+
ÇÇ! "
$num
ÇÇ# $
]
ÇÇ$ %
=
ÇÇ& '
new
ÇÇ( +
Vector3
ÇÇ, 3
(
ÇÇ3 4
circle
ÇÇ4 :
[
ÇÇ: ;
n
ÇÇ; <
+
ÇÇ= >
$num
ÇÇ? @
]
ÇÇ@ A
.
ÇÇA B
x
ÇÇB C
,
ÇÇC D
Y
ÇÇE F
,
ÇÇF G
circle
ÇÇH N
[
ÇÇN O
n
ÇÇO P
+
ÇÇQ R
$num
ÇÇS T
]
ÇÇT U
.
ÇÇU V
z
ÇÇV W
)
ÇÇW X
;
ÇÇX Y
verts
ÈÈ 
[
ÈÈ 
it
ÈÈ  
+
ÈÈ! "
$num
ÈÈ# $
]
ÈÈ$ %
=
ÈÈ& '
new
ÈÈ( +
Vector3
ÈÈ, 3
(
ÈÈ3 4
circle
ÈÈ4 :
[
ÈÈ: ;
n
ÈÈ; <
+
ÈÈ= >
$num
ÈÈ? @
]
ÈÈ@ A
.
ÈÈA B
x
ÈÈB C
,
ÈÈC D
Y2
ÈÈE G
,
ÈÈG H
circle
ÈÈI O
[
ÈÈO P
n
ÈÈP Q
+
ÈÈR S
$num
ÈÈT U
]
ÈÈU V
.
ÈÈV W
z
ÈÈW X
)
ÈÈX Y
;
ÈÈY Z
}
ÉÉ 
else
ÊÊ 
{
ËË 
verts
ÌÌ 
[
ÌÌ 
it
ÌÌ  
+
ÌÌ! "
$num
ÌÌ# $
]
ÌÌ$ %
=
ÌÌ& '
new
ÌÌ( +
Vector3
ÌÌ, 3
(
ÌÌ3 4
circle
ÌÌ4 :
[
ÌÌ: ;
$num
ÌÌ; <
]
ÌÌ< =
.
ÌÌ= >
x
ÌÌ> ?
,
ÌÌ? @
Y
ÌÌA B
,
ÌÌB C
circle
ÌÌD J
[
ÌÌJ K
$num
ÌÌK L
]
ÌÌL M
.
ÌÌM N
z
ÌÌN O
)
ÌÌO P
;
ÌÌP Q
verts
ÍÍ 
[
ÍÍ 
it
ÍÍ  
+
ÍÍ! "
$num
ÍÍ# $
]
ÍÍ$ %
=
ÍÍ& '
new
ÍÍ( +
Vector3
ÍÍ, 3
(
ÍÍ3 4
circle
ÍÍ4 :
[
ÍÍ: ;
$num
ÍÍ; <
]
ÍÍ< =
.
ÍÍ= >
x
ÍÍ> ?
,
ÍÍ? @
Y2
ÍÍA C
,
ÍÍC D
circle
ÍÍE K
[
ÍÍK L
$num
ÍÍL M
]
ÍÍM N
.
ÍÍN O
z
ÍÍO P
)
ÍÍP Q
;
ÍÍQ R
}
ÎÎ 
it
ĞĞ 
+=
ĞĞ 
$num
ĞĞ 
;
ĞĞ 
}
ÑÑ 
}
ÒÒ 
int
ÕÕ 
f
ÕÕ 
=
ÕÕ 
$num
ÕÕ 
;
ÕÕ 
for
ÖÖ 
(
ÖÖ 
int
ÖÖ 
i
ÖÖ 
=
ÖÖ 
$num
ÖÖ 
;
ÖÖ 
i
ÖÖ 
<
ÖÖ 

heightCuts
ÖÖ  *
+
ÖÖ+ ,
$num
ÖÖ- .
;
ÖÖ. /
i
ÖÖ0 1
++
ÖÖ1 3
)
ÖÖ3 4
{
×× 
for
ØØ 
(
ØØ 
int
ØØ 
n
ØØ 
=
ØØ 
$num
ØØ 
;
ØØ 
n
ØØ  !
<
ØØ" #
axisDivisions
ØØ$ 1
*
ØØ2 3
$num
ØØ4 5
;
ØØ5 6
n
ØØ7 8
+=
ØØ9 ;
$num
ØØ< =
)
ØØ= >
{
ÙÙ 
int
ÚÚ 
index
ÚÚ 
=
ÚÚ 
(
ÚÚ  !
i
ÚÚ! "
*
ÚÚ# $
(
ÚÚ% &
axisDivisions
ÚÚ& 3
*
ÚÚ4 5
$num
ÚÚ6 7
)
ÚÚ7 8
)
ÚÚ8 9
+
ÚÚ: ;
n
ÚÚ< =
;
ÚÚ= >
int
ÛÛ 
zero
ÛÛ 
=
ÛÛ  !
index
ÛÛ" '
;
ÛÛ' (
int
ÜÜ 
one
ÜÜ 
=
ÜÜ  !
index
ÜÜ" '
+
ÜÜ( )
$num
ÜÜ* +
;
ÜÜ+ ,
int
İİ 
two
İİ 
=
İİ  !
index
İİ" '
+
İİ( )
$num
İİ* +
;
İİ+ ,
int
ŞŞ 
three
ŞŞ 
=
ŞŞ  !
index
ŞŞ" '
+
ŞŞ( )
$num
ŞŞ* +
;
ŞŞ+ ,
faces
àà 
[
àà 
f
àà 
++
àà 
]
àà 
=
àà  
new
àà! $
Face
àà% )
(
àà) *
new
áá 
int
áá  #
[
áá# $
$num
áá$ %
]
áá% &
{
áá' (
zero
áá) -
,
áá- .
one
áá/ 2
,
áá2 3
two
áá4 7
,
áá7 8
one
áá9 <
,
áá< =
three
áá> C
,
ááC D
two
ááE H
}
ááI J
,
ááJ K
$num
ââ 
,
ââ  
AutoUnwrapSettings
ãã .
.
ãã. /
tile
ãã/ 3
,
ãã3 4
	smoothing
ää %
,
ää% &
-
åå 
$num
åå 
,
åå 
-
ææ 
$num
ææ 
,
ææ 
false
çç !
)
çç! "
;
çç" #
}
èè 
}
éé 
int
ìì 
ind
ìì 
=
ìì 
(
ìì 
axisDivisions
ìì $
*
ìì% &
(
ìì' (

heightCuts
ìì( 2
+
ìì3 4
$num
ìì5 6
)
ìì6 7
*
ìì8 9
$num
ìì: ;
)
ìì; <
;
ìì< =
int
íí 
f_ind
íí 
=
íí 
axisDivisions
íí %
*
íí& '
(
íí( )

heightCuts
íí) 3
+
íí4 5
$num
íí6 7
)
íí7 8
;
íí8 9
for
ïï 
(
ïï 
int
ïï 
n
ïï 
=
ïï 
$num
ïï 
;
ïï 
n
ïï 
<
ïï 
axisDivisions
ïï  -
;
ïï- .
n
ïï/ 0
++
ïï0 2
)
ïï2 3
{
ğğ 
verts
òò 
[
òò 
ind
òò 
+
òò 
$num
òò 
]
òò 
=
òò  
new
òò! $
Vector3
òò% ,
(
òò, -
circle
òò- 3
[
òò3 4
n
òò4 5
]
òò5 6
.
òò6 7
x
òò7 8
,
òò8 9
$num
òò: <
,
òò< =
circle
òò> D
[
òòD E
n
òòE F
]
òòF G
.
òòG H
z
òòH I
)
òòI J
;
òòJ K
verts
ôô 
[
ôô 
ind
ôô 
+
ôô 
$num
ôô 
]
ôô 
=
ôô  
Vector3
ôô! (
.
ôô( )
zero
ôô) -
;
ôô- .
if
öö 
(
öö 
n
öö 
!=
öö 
axisDivisions
öö &
-
öö' (
$num
öö) *
)
öö* +
verts
÷÷ 
[
÷÷ 
ind
÷÷ 
+
÷÷ 
$num
÷÷  !
]
÷÷! "
=
÷÷# $
new
÷÷% (
Vector3
÷÷) 0
(
÷÷0 1
circle
÷÷1 7
[
÷÷7 8
n
÷÷8 9
+
÷÷: ;
$num
÷÷< =
]
÷÷= >
.
÷÷> ?
x
÷÷? @
,
÷÷@ A
$num
÷÷B D
,
÷÷D E
circle
÷÷F L
[
÷÷L M
n
÷÷M N
+
÷÷O P
$num
÷÷Q R
]
÷÷R S
.
÷÷S T
z
÷÷T U
)
÷÷U V
;
÷÷V W
else
øø 
verts
ùù 
[
ùù 
ind
ùù 
+
ùù 
$num
ùù  !
]
ùù! "
=
ùù# $
new
ùù% (
Vector3
ùù) 0
(
ùù0 1
circle
ùù1 7
[
ùù7 8
$num
ùù8 ;
]
ùù; <
.
ùù< =
x
ùù= >
,
ùù> ?
$num
ùù@ B
,
ùùB C
circle
ùùD J
[
ùùJ K
$num
ùùK N
]
ùùN O
.
ùùO P
z
ùùP Q
)
ùùQ R
;
ùùR S
faces
ûû 
[
ûû 
f_ind
ûû 
+
ûû 
n
ûû 
]
ûû  
=
ûû! "
new
ûû# &
Face
ûû' +
(
ûû+ ,
new
ûû, /
int
ûû0 3
[
ûû3 4
$num
ûû4 5
]
ûû5 6
{
ûû7 8
ind
ûû8 ;
+
ûû< =
$num
ûû> ?
,
ûû? @
ind
ûûA D
+
ûûE F
$num
ûûG H
,
ûûH I
ind
ûûJ M
+
ûûN O
$num
ûûP Q
}
ûûQ R
)
ûûR S
;
ûûS T
ind
ıı 
+=
ıı 
$num
ıı 
;
ıı 
verts
€€ 
[
€€ 
ind
€€ 
+
€€ 
$num
€€ 
]
€€ 
=
€€" #
new
€€$ '
Vector3
€€( /
(
€€/ 0
circle
€€0 6
[
€€6 7
n
€€7 8
]
€€8 9
.
€€9 :
x
€€: ;
,
€€; <
height
€€= C
,
€€C D
circle
€€E K
[
€€K L
n
€€L M
]
€€M N
.
€€N O
z
€€O P
)
€€P Q
;
€€Q R
verts
 
[
 
ind
 
+
 
$num
 
]
 
=
" #
new
$ '
Vector3
( /
(
/ 0
$num
0 2
,
2 3
height
4 :
,
: ;
$num
< >
)
> ?
;
? @
if
‚‚ 
(
‚‚ 
n
‚‚ 
!=
‚‚ 
axisDivisions
‚‚ &
-
‚‚' (
$num
‚‚) *
)
‚‚* +
verts
ƒƒ 
[
ƒƒ 
ind
ƒƒ 
+
ƒƒ 
$num
ƒƒ  !
]
ƒƒ! "
=
ƒƒ# $
new
ƒƒ% (
Vector3
ƒƒ) 0
(
ƒƒ0 1
circle
ƒƒ1 7
[
ƒƒ7 8
n
ƒƒ8 9
+
ƒƒ: ;
$num
ƒƒ< =
]
ƒƒ= >
.
ƒƒ> ?
x
ƒƒ? @
,
ƒƒ@ A
height
ƒƒB H
,
ƒƒH I
circle
ƒƒJ P
[
ƒƒP Q
n
ƒƒQ R
+
ƒƒS T
$num
ƒƒU V
]
ƒƒV W
.
ƒƒW X
z
ƒƒX Y
)
ƒƒY Z
;
ƒƒZ [
else
„„ 
verts
…… 
[
…… 
ind
…… 
+
…… 
$num
……  !
]
……! "
=
……# $
new
……% (
Vector3
……) 0
(
……0 1
circle
……1 7
[
……7 8
$num
……8 ;
]
……; <
.
……< =
x
……= >
,
……> ?
height
……@ F
,
……F G
circle
……H N
[
……N O
$num
……O R
]
……R S
.
……S T
z
……T U
)
……U V
;
……V W
faces
‡‡ 
[
‡‡ 
f_ind
‡‡ 
+
‡‡ 
(
‡‡ 
n
‡‡  
+
‡‡! "
axisDivisions
‡‡# 0
)
‡‡0 1
]
‡‡1 2
=
‡‡3 4
new
‡‡5 8
Face
‡‡9 =
(
‡‡= >
new
‡‡> A
int
‡‡B E
[
‡‡E F
$num
‡‡F G
]
‡‡G H
{
‡‡I J
ind
‡‡J M
+
‡‡N O
$num
‡‡P Q
,
‡‡Q R
ind
‡‡S V
+
‡‡W X
$num
‡‡Y Z
,
‡‡Z [
ind
‡‡\ _
+
‡‡` a
$num
‡‡b c
}
‡‡c d
)
‡‡d e
;
‡‡e f
ind
‰‰ 
+=
‰‰ 
$num
‰‰ 
;
‰‰ 
}
ŠŠ 
ProBuilderMesh
ŒŒ 
pb
ŒŒ 
=
ŒŒ 
ProBuilderMesh
ŒŒ  .
.
ŒŒ. /
Create
ŒŒ/ 5
(
ŒŒ5 6
verts
ŒŒ6 ;
,
ŒŒ; <
faces
ŒŒ= B
)
ŒŒB C
;
ŒŒC D
pb
 
.
 

gameObject
 
.
 
name
 
=
  
$str
! +
;
+ ,
pb
 
.
 
SetPivot
 
(
 
	pivotType
 !
)
! "
;
" #
return
 
pb
 
;
 
}
‘‘ 	
public
™™ 
static
™™ 
ProBuilderMesh
™™ $
GeneratePrism
™™% 2
(
™™2 3
PivotLocation
™™3 @
	pivotType
™™A J
,
™™J K
Vector3
™™L S
size
™™T X
)
™™X Y
{
šš 	
size
›› 
.
›› 
y
›› 
*=
›› 
$num
›› 
;
›› 
Vector3
 
[
 
]
 
template
 
=
  
new
! $
Vector3
% ,
[
, -
$num
- .
]
. /
{
 
Vector3
ŸŸ 
.
ŸŸ 
Scale
ŸŸ 
(
ŸŸ 
new
ŸŸ !
Vector3
ŸŸ" )
(
ŸŸ) *
-
ŸŸ* +
$num
ŸŸ+ .
,
ŸŸ. /
$num
ŸŸ0 2
,
ŸŸ2 3
-
ŸŸ4 5
$num
ŸŸ5 8
)
ŸŸ8 9
,
ŸŸ9 :
size
ŸŸ< @
)
ŸŸ@ A
,
ŸŸA B
Vector3
   
.
   
Scale
   
(
   
new
   !
Vector3
  " )
(
  ) *
$num
  * -
,
  - .
$num
  / 1
,
  1 2
-
  3 4
$num
  4 7
)
  7 8
,
  8 9
size
  < @
)
  @ A
,
  A B
Vector3
¡¡ 
.
¡¡ 
Scale
¡¡ 
(
¡¡ 
new
¡¡ !
Vector3
¡¡" )
(
¡¡) *
$num
¡¡* ,
,
¡¡, -
$num
¡¡. 1
,
¡¡1 2
-
¡¡3 4
$num
¡¡4 7
)
¡¡7 8
,
¡¡8 9
size
¡¡< @
)
¡¡@ A
,
¡¡A B
Vector3
¢¢ 
.
¢¢ 
Scale
¢¢ 
(
¢¢ 
new
¢¢ !
Vector3
¢¢" )
(
¢¢) *
-
¢¢* +
$num
¢¢+ .
,
¢¢. /
$num
¢¢0 2
,
¢¢2 3
$num
¢¢4 7
)
¢¢7 8
,
¢¢8 9
size
¢¢< @
)
¢¢@ A
,
¢¢A B
Vector3
££ 
.
££ 
Scale
££ 
(
££ 
new
££ !
Vector3
££" )
(
££) *
$num
££* .
,
££. /
$num
££0 2
,
££2 3
$num
££4 7
)
££7 8
,
££8 9
size
££< @
)
££@ A
,
££A B
Vector3
¤¤ 
.
¤¤ 
Scale
¤¤ 
(
¤¤ 
new
¤¤ !
Vector3
¤¤" )
(
¤¤) *
$num
¤¤* ,
,
¤¤, -
$num
¤¤. 1
,
¤¤1 2
$num
¤¤3 6
)
¤¤6 7
,
¤¤7 8
size
¤¤< @
)
¤¤@ A
}
¥¥ 
;
¥¥ 
Vector3
§§ 
[
§§ 
]
§§ 
v
§§ 
=
§§ 
new
§§ 
Vector3
§§ %
[
§§% &
$num
§§& (
]
§§( )
{
¨¨ 
template
©© 
[
©© 
$num
©© 
]
©© 
,
©© 
template
ªª 
[
ªª 
$num
ªª 
]
ªª 
,
ªª 
template
«« 
[
«« 
$num
«« 
]
«« 
,
«« 
template
­­ 
[
­­ 
$num
­­ 
]
­­ 
,
­­ 
template
®® 
[
®® 
$num
®® 
]
®® 
,
®® 
template
¯¯ 
[
¯¯ 
$num
¯¯ 
]
¯¯ 
,
¯¯ 
template
°° 
[
°° 
$num
°° 
]
°° 
,
°° 
template
²² 
[
²² 
$num
²² 
]
²² 
,
²² 
template
³³ 
[
³³ 
$num
³³ 
]
³³ 
,
³³ 
template
´´ 
[
´´ 
$num
´´ 
]
´´ 
,
´´ 
template
¶¶ 
[
¶¶ 
$num
¶¶ 
]
¶¶ 
,
¶¶ 
template
·· 
[
·· 
$num
·· 
]
·· 
,
·· 
template
¸¸ 
[
¸¸ 
$num
¸¸ 
]
¸¸ 
,
¸¸ 
template
¹¹ 
[
¹¹ 
$num
¹¹ 
]
¹¹ 
,
¹¹ 
template
»» 
[
»» 
$num
»» 
]
»» 
,
»» 
template
¼¼ 
[
¼¼ 
$num
¼¼ 
]
¼¼ 
,
¼¼ 
template
½½ 
[
½½ 
$num
½½ 
]
½½ 
,
½½ 
template
¾¾ 
[
¾¾ 
$num
¾¾ 
]
¾¾ 
}
¿¿ 
;
¿¿ 
Face
ÁÁ 
[
ÁÁ 
]
ÁÁ 
f
ÁÁ 
=
ÁÁ 
new
ÁÁ 
Face
ÁÁ 
[
ÁÁ  
$num
ÁÁ  !
]
ÁÁ! "
{
ÂÂ 
new
ÃÃ 
Face
ÃÃ 
(
ÃÃ 
new
ÃÃ 
int
ÃÃ  
[
ÃÃ  !
$num
ÃÃ! "
]
ÃÃ" #
{
ÃÃ$ %
$num
ÃÃ% &
,
ÃÃ& '
$num
ÃÃ( )
,
ÃÃ) *
$num
ÃÃ+ ,
}
ÃÃ, -
)
ÃÃ- .
,
ÃÃ. /
new
ÄÄ 
Face
ÄÄ 
(
ÄÄ 
new
ÄÄ 
int
ÄÄ  
[
ÄÄ  !
$num
ÄÄ! "
]
ÄÄ" #
{
ÄÄ$ %
$num
ÄÄ% &
,
ÄÄ& '
$num
ÄÄ( )
,
ÄÄ) *
$num
ÄÄ+ ,
,
ÄÄ, -
$num
ÄÄ. /
,
ÄÄ/ 0
$num
ÄÄ1 2
,
ÄÄ2 3
$num
ÄÄ4 5
}
ÄÄ5 6
)
ÄÄ6 7
,
ÄÄ7 8
new
ÅÅ 
Face
ÅÅ 
(
ÅÅ 
new
ÅÅ 
int
ÅÅ  
[
ÅÅ  !
$num
ÅÅ! "
]
ÅÅ" #
{
ÅÅ$ %
$num
ÅÅ% &
,
ÅÅ& '
$num
ÅÅ( )
,
ÅÅ) *
$num
ÅÅ+ ,
}
ÅÅ, -
)
ÅÅ- .
,
ÅÅ. /
new
ÆÆ 
Face
ÆÆ 
(
ÆÆ 
new
ÆÆ 
int
ÆÆ  
[
ÆÆ  !
$num
ÆÆ! "
]
ÆÆ" #
{
ÆÆ$ %
$num
ÆÆ% '
,
ÆÆ' (
$num
ÆÆ) +
,
ÆÆ+ ,
$num
ÆÆ- /
,
ÆÆ/ 0
$num
ÆÆ1 3
,
ÆÆ3 4
$num
ÆÆ5 7
,
ÆÆ7 8
$num
ÆÆ9 ;
}
ÆÆ; <
)
ÆÆ< =
,
ÆÆ= >
new
ÇÇ 
Face
ÇÇ 
(
ÇÇ 
new
ÇÇ 
int
ÇÇ  
[
ÇÇ  !
$num
ÇÇ! "
]
ÇÇ" #
{
ÇÇ$ %
$num
ÇÇ% '
,
ÇÇ' (
$num
ÇÇ) +
,
ÇÇ+ ,
$num
ÇÇ- /
,
ÇÇ/ 0
$num
ÇÇ1 3
,
ÇÇ3 4
$num
ÇÇ5 7
,
ÇÇ7 8
$num
ÇÇ9 ;
}
ÇÇ; <
)
ÇÇ< =
}
ÈÈ 
;
ÈÈ 
ProBuilderMesh
ÊÊ 
pb
ÊÊ 
=
ÊÊ 
ProBuilderMesh
ÊÊ  .
.
ÊÊ. /
Create
ÊÊ/ 5
(
ÊÊ5 6
v
ÊÊ6 7
,
ÊÊ7 8
f
ÊÊ9 :
)
ÊÊ: ;
;
ÊÊ; <
pb
ËË 
.
ËË 

gameObject
ËË 
.
ËË 
name
ËË 
=
ËË  
$str
ËË! (
;
ËË( )
pb
ÌÌ 
.
ÌÌ 
SetPivot
ÌÌ 
(
ÌÌ 
	pivotType
ÌÌ !
)
ÌÌ! "
;
ÌÌ" #
return
ÎÎ 
pb
ÎÎ 
;
ÎÎ 
}
ÏÏ 	
public
ÛÛ 
static
ÛÛ 
ProBuilderMesh
ÛÛ $
GenerateDoor
ÛÛ% 1
(
ÛÛ1 2
PivotLocation
ÛÛ2 ?
	pivotType
ÛÛ@ I
,
ÛÛI J
float
ÛÛK P

totalWidth
ÛÛQ [
,
ÛÛ[ \
float
ÛÛ] b
totalHeight
ÛÛc n
,
ÛÛn o
float
ÛÛp u
ledgeHeightÛÛv 
,ÛÛ ‚
floatÛÛƒ ˆ
legWidthÛÛ‰ ‘
,ÛÛ‘ ’
floatÛÛ“ ˜
depthÛÛ™ 
)ÛÛ Ÿ
{
ÜÜ 	
float
İİ 
	xLegCoord
İİ 
=
İİ 

totalWidth
İİ (
/
İİ) *
$num
İİ+ -
;
İİ- .
legWidth
ŞŞ 
=
ŞŞ 
	xLegCoord
ŞŞ  
-
ŞŞ! "
legWidth
ŞŞ# +
;
ŞŞ+ ,
ledgeHeight
ßß 
=
ßß 
totalHeight
ßß %
-
ßß& '
ledgeHeight
ßß( 3
;
ßß3 4
Vector3
ææ 
[
ææ 
]
ææ 
template
ææ 
=
ææ  
new
ææ! $
Vector3
ææ% ,
[
ææ, -
$num
ææ- /
]
ææ/ 0
{
çç 
new
èè 
Vector3
èè 
(
èè 
-
èè 
	xLegCoord
èè &
,
èè& '
$num
èè( *
,
èè* +
depth
èè, 1
)
èè1 2
,
èè2 3
new
éé 
Vector3
éé 
(
éé 
-
éé 
legWidth
éé %
,
éé% &
$num
éé' )
,
éé) *
depth
éé+ 0
)
éé0 1
,
éé1 2
new
êê 
Vector3
êê 
(
êê 
legWidth
êê $
,
êê$ %
$num
êê& (
,
êê( )
depth
êê* /
)
êê/ 0
,
êê0 1
new
ëë 
Vector3
ëë 
(
ëë 
	xLegCoord
ëë %
,
ëë% &
$num
ëë' )
,
ëë) *
depth
ëë+ 0
)
ëë0 1
,
ëë1 2
new
ìì 
Vector3
ìì 
(
ìì 
-
ìì 
	xLegCoord
ìì &
,
ìì& '
ledgeHeight
ìì( 3
,
ìì3 4
depth
ìì5 :
)
ìì: ;
,
ìì; <
new
íí 
Vector3
íí 
(
íí 
-
íí 
legWidth
íí %
,
íí% &
ledgeHeight
íí' 2
,
íí2 3
depth
íí4 9
)
íí9 :
,
íí: ;
new
îî 
Vector3
îî 
(
îî 
legWidth
îî $
,
îî$ %
ledgeHeight
îî& 1
,
îî1 2
depth
îî3 8
)
îî8 9
,
îî9 :
new
ïï 
Vector3
ïï 
(
ïï 
	xLegCoord
ïï %
,
ïï% &
ledgeHeight
ïï' 2
,
ïï2 3
depth
ïï4 9
)
ïï9 :
,
ïï: ;
new
ğğ 
Vector3
ğğ 
(
ğğ 
-
ğğ 
	xLegCoord
ğğ &
,
ğğ& '
totalHeight
ğğ( 3
,
ğğ3 4
depth
ğğ5 :
)
ğğ: ;
,
ğğ; <
new
ññ 
Vector3
ññ 
(
ññ 
-
ññ 
legWidth
ññ %
,
ññ% &
totalHeight
ññ' 2
,
ññ2 3
depth
ññ4 9
)
ññ9 :
,
ññ: ;
new
òò 
Vector3
òò 
(
òò 
legWidth
òò $
,
òò$ %
totalHeight
òò& 1
,
òò1 2
depth
òò3 8
)
òò8 9
,
òò9 :
new
óó 
Vector3
óó 
(
óó 
	xLegCoord
óó %
,
óó% &
totalHeight
óó' 2
,
óó2 3
depth
óó4 9
)
óó9 :
}
ôô 
;
ôô 
List
öö 
<
öö 
Vector3
öö 
>
öö 
points
öö  
=
öö! "
new
öö# &
List
öö' +
<
öö+ ,
Vector3
öö, 3
>
öö3 4
(
öö4 5
)
öö5 6
;
öö6 7
points
øø 
.
øø 
Add
øø 
(
øø 
template
øø 
[
øø  
$num
øø  !
]
øø! "
)
øø" #
;
øø# $
points
ùù 
.
ùù 
Add
ùù 
(
ùù 
template
ùù 
[
ùù  
$num
ùù  !
]
ùù! "
)
ùù" #
;
ùù# $
points
úú 
.
úú 
Add
úú 
(
úú 
template
úú 
[
úú  
$num
úú  !
]
úú! "
)
úú" #
;
úú# $
points
ûû 
.
ûû 
Add
ûû 
(
ûû 
template
ûû 
[
ûû  
$num
ûû  !
]
ûû! "
)
ûû" #
;
ûû# $
points
ıı 
.
ıı 
Add
ıı 
(
ıı 
template
ıı 
[
ıı  
$num
ıı  !
]
ıı! "
)
ıı" #
;
ıı# $
points
şş 
.
şş 
Add
şş 
(
şş 
template
şş 
[
şş  
$num
şş  !
]
şş! "
)
şş" #
;
şş# $
points
ÿÿ 
.
ÿÿ 
Add
ÿÿ 
(
ÿÿ 
template
ÿÿ 
[
ÿÿ  
$num
ÿÿ  !
]
ÿÿ! "
)
ÿÿ" #
;
ÿÿ# $
points
€€ 
.
€€ 
Add
€€ 
(
€€ 
template
€€ 
[
€€  
$num
€€  !
]
€€! "
)
€€" #
;
€€# $
points
‚‚ 
.
‚‚ 
Add
‚‚ 
(
‚‚ 
template
‚‚ 
[
‚‚  
$num
‚‚  !
]
‚‚! "
)
‚‚" #
;
‚‚# $
points
ƒƒ 
.
ƒƒ 
Add
ƒƒ 
(
ƒƒ 
template
ƒƒ 
[
ƒƒ  
$num
ƒƒ  !
]
ƒƒ! "
)
ƒƒ" #
;
ƒƒ# $
points
„„ 
.
„„ 
Add
„„ 
(
„„ 
template
„„ 
[
„„  
$num
„„  !
]
„„! "
)
„„" #
;
„„# $
points
…… 
.
…… 
Add
…… 
(
…… 
template
…… 
[
……  
$num
……  !
]
……! "
)
……" #
;
……# $
points
‡‡ 
.
‡‡ 
Add
‡‡ 
(
‡‡ 
template
‡‡ 
[
‡‡  
$num
‡‡  !
]
‡‡! "
)
‡‡" #
;
‡‡# $
points
ˆˆ 
.
ˆˆ 
Add
ˆˆ 
(
ˆˆ 
template
ˆˆ 
[
ˆˆ  
$num
ˆˆ  !
]
ˆˆ! "
)
ˆˆ" #
;
ˆˆ# $
points
‰‰ 
.
‰‰ 
Add
‰‰ 
(
‰‰ 
template
‰‰ 
[
‰‰  
$num
‰‰  "
]
‰‰" #
)
‰‰# $
;
‰‰$ %
points
ŠŠ 
.
ŠŠ 
Add
ŠŠ 
(
ŠŠ 
template
ŠŠ 
[
ŠŠ  
$num
ŠŠ  "
]
ŠŠ" #
)
ŠŠ# $
;
ŠŠ$ %
points
ŒŒ 
.
ŒŒ 
Add
ŒŒ 
(
ŒŒ 
template
ŒŒ 
[
ŒŒ  
$num
ŒŒ  !
]
ŒŒ! "
)
ŒŒ" #
;
ŒŒ# $
points
 
.
 
Add
 
(
 
template
 
[
  
$num
  !
]
! "
)
" #
;
# $
points
 
.
 
Add
 
(
 
template
 
[
  
$num
  !
]
! "
)
" #
;
# $
points
 
.
 
Add
 
(
 
template
 
[
  
$num
  "
]
" #
)
# $
;
$ %
List
‘‘ 
<
‘‘ 
Vector3
‘‘ 
>
‘‘ 
reverse
‘‘ !
=
‘‘" #
new
‘‘$ '
List
‘‘( ,
<
‘‘, -
Vector3
‘‘- 4
>
‘‘4 5
(
‘‘5 6
)
‘‘6 7
;
‘‘7 8
for
““ 
(
““ 
int
““ 
i
““ 
=
““ 
$num
““ 
;
““ 
i
““ 
<
““ 
points
““  &
.
““& '
Count
““' ,
;
““, -
i
““. /
+=
““0 2
$num
““3 4
)
““4 5
{
”” 
reverse
•• 
.
•• 
Add
•• 
(
•• 
points
•• "
[
••" #
i
••# $
+
••% &
$num
••' (
]
••( )
-
••* +
Vector3
••, 3
.
••3 4
forward
••4 ;
*
••< =
depth
••> C
)
••C D
;
••D E
reverse
–– 
.
–– 
Add
–– 
(
–– 
points
–– "
[
––" #
i
––# $
+
––% &
$num
––' (
]
––( )
-
––* +
Vector3
––, 3
.
––3 4
forward
––4 ;
*
––< =
depth
––> C
)
––C D
;
––D E
reverse
—— 
.
—— 
Add
—— 
(
—— 
points
—— "
[
——" #
i
——# $
+
——% &
$num
——' (
]
——( )
-
——* +
Vector3
——, 3
.
——3 4
forward
——4 ;
*
——< =
depth
——> C
)
——C D
;
——D E
reverse
˜˜ 
.
˜˜ 
Add
˜˜ 
(
˜˜ 
points
˜˜ "
[
˜˜" #
i
˜˜# $
+
˜˜% &
$num
˜˜' (
]
˜˜( )
-
˜˜* +
Vector3
˜˜, 3
.
˜˜3 4
forward
˜˜4 ;
*
˜˜< =
depth
˜˜> C
)
˜˜C D
;
˜˜D E
}
™™ 
points
›› 
.
›› 
AddRange
›› 
(
›› 
reverse
›› #
)
››# $
;
››$ %
points
 
.
 
Add
 
(
 
template
 
[
  
$num
  !
]
! "
)
" #
;
# $
points
 
.
 
Add
 
(
 
template
 
[
  
$num
  !
]
! "
)
" #
;
# $
points
ŸŸ 
.
ŸŸ 
Add
ŸŸ 
(
ŸŸ 
template
ŸŸ 
[
ŸŸ  
$num
ŸŸ  !
]
ŸŸ! "
-
ŸŸ# $
Vector3
ŸŸ% ,
.
ŸŸ, -
forward
ŸŸ- 4
*
ŸŸ5 6
depth
ŸŸ7 <
)
ŸŸ< =
;
ŸŸ= >
points
   
.
   
Add
   
(
   
template
   
[
    
$num
    !
]
  ! "
-
  # $
Vector3
  % ,
.
  , -
forward
  - 4
*
  5 6
depth
  7 <
)
  < =
;
  = >
points
¢¢ 
.
¢¢ 
Add
¢¢ 
(
¢¢ 
template
¢¢ 
[
¢¢  
$num
¢¢  !
]
¢¢! "
-
¢¢# $
Vector3
¢¢% ,
.
¢¢, -
forward
¢¢- 4
*
¢¢5 6
depth
¢¢7 <
)
¢¢< =
;
¢¢= >
points
££ 
.
££ 
Add
££ 
(
££ 
template
££ 
[
££  
$num
££  !
]
££! "
)
££" #
;
££# $
points
¤¤ 
.
¤¤ 
Add
¤¤ 
(
¤¤ 
template
¤¤ 
[
¤¤  
$num
¤¤  !
]
¤¤! "
-
¤¤# $
Vector3
¤¤% ,
.
¤¤, -
forward
¤¤- 4
*
¤¤5 6
depth
¤¤7 <
)
¤¤< =
;
¤¤= >
points
¥¥ 
.
¥¥ 
Add
¥¥ 
(
¥¥ 
template
¥¥ 
[
¥¥  
$num
¥¥  !
]
¥¥! "
)
¥¥" #
;
¥¥# $
points
§§ 
.
§§ 
Add
§§ 
(
§§ 
template
§§ 
[
§§  
$num
§§  !
]
§§! "
)
§§" #
;
§§# $
points
¨¨ 
.
¨¨ 
Add
¨¨ 
(
¨¨ 
template
¨¨ 
[
¨¨  
$num
¨¨  !
]
¨¨! "
-
¨¨# $
Vector3
¨¨% ,
.
¨¨, -
forward
¨¨- 4
*
¨¨5 6
depth
¨¨7 <
)
¨¨< =
;
¨¨= >
points
©© 
.
©© 
Add
©© 
(
©© 
template
©© 
[
©©  
$num
©©  !
]
©©! "
)
©©" #
;
©©# $
points
ªª 
.
ªª 
Add
ªª 
(
ªª 
template
ªª 
[
ªª  
$num
ªª  !
]
ªª! "
-
ªª# $
Vector3
ªª% ,
.
ªª, -
forward
ªª- 4
*
ªª5 6
depth
ªª7 <
)
ªª< =
;
ªª= >
ProBuilderMesh
¬¬ 
pb
¬¬ 
=
¬¬ 
ProBuilderMesh
¬¬  .
.
¬¬. /&
CreateInstanceWithPoints
¬¬/ G
(
¬¬G H
points
¬¬H N
.
¬¬N O
ToArray
¬¬O V
(
¬¬V W
)
¬¬W X
)
¬¬X Y
;
¬¬Y Z
pb
­­ 
.
­­ 

gameObject
­­ 
.
­­ 
name
­­ 
=
­­  
$str
­­! '
;
­­' (
pb
®® 
.
®® 
SetPivot
®® 
(
®® 
	pivotType
®® !
)
®®! "
;
®®" #
return
°° 
pb
°° 
;
°° 
}
±± 	
public
½½ 
static
½½ 
ProBuilderMesh
½½ $
GeneratePlane
½½% 2
(
½½2 3
PivotLocation
½½3 @
	pivotType
½½A J
,
½½J K
float
½½L Q
width
½½R W
,
½½W X
float
½½Y ^
height
½½_ e
,
½½e f
int
½½g j
	widthCuts
½½k t
,
½½t u
int
½½v y

heightCuts½½z „
,½½„ …
Axis½½† Š
axis½½‹ 
)½½ 
{
¾¾ 	
int
¿¿ 
w
¿¿ 
=
¿¿ 
	widthCuts
¿¿ 
+
¿¿ 
$num
¿¿  !
;
¿¿! "
int
ÀÀ 
h
ÀÀ 
=
ÀÀ 

heightCuts
ÀÀ 
+
ÀÀ  
$num
ÀÀ! "
;
ÀÀ" #
Vector2
ÂÂ 
[
ÂÂ 
]
ÂÂ 
p
ÂÂ 
=
ÂÂ 
new
ÂÂ 
Vector2
ÂÂ %
[
ÂÂ% &
(
ÂÂ& '
w
ÂÂ' (
*
ÂÂ) *
h
ÂÂ+ ,
)
ÂÂ, -
*
ÂÂ. /
$num
ÂÂ0 1
]
ÂÂ1 2
;
ÂÂ2 3
Vector3
ÃÃ 
[
ÃÃ 
]
ÃÃ 
v
ÃÃ 
=
ÃÃ 
new
ÃÃ 
Vector3
ÃÃ %
[
ÃÃ% &
(
ÃÃ& '
w
ÃÃ' (
*
ÃÃ) *
h
ÃÃ+ ,
)
ÃÃ, -
*
ÃÃ. /
$num
ÃÃ0 1
]
ÃÃ1 2
;
ÃÃ2 3
Face
ÄÄ 
[
ÄÄ 
]
ÄÄ 
f
ÄÄ 
=
ÄÄ 
new
ÄÄ 
Face
ÄÄ 
[
ÄÄ  
w
ÄÄ  !
*
ÄÄ" #
h
ÄÄ$ %
]
ÄÄ% &
;
ÄÄ& '
int
ÆÆ 
i
ÆÆ 
=
ÆÆ 
$num
ÆÆ 
,
ÆÆ 
j
ÆÆ 
=
ÆÆ 
$num
ÆÆ 
;
ÆÆ 
{
ÇÇ 
for
ÈÈ 
(
ÈÈ 
int
ÈÈ 
y
ÈÈ 
=
ÈÈ 
$num
ÈÈ 
;
ÈÈ 
y
ÈÈ  !
<
ÈÈ" #
h
ÈÈ$ %
;
ÈÈ% &
y
ÈÈ' (
++
ÈÈ( *
)
ÈÈ* +
{
ÉÉ 
for
ÊÊ 
(
ÊÊ 
int
ÊÊ 
x
ÊÊ 
=
ÊÊ  
$num
ÊÊ! "
;
ÊÊ" #
x
ÊÊ$ %
<
ÊÊ& '
w
ÊÊ( )
;
ÊÊ) *
x
ÊÊ+ ,
++
ÊÊ, .
)
ÊÊ. /
{
ËË 
float
ÌÌ 
x0
ÌÌ  
=
ÌÌ! "
x
ÌÌ# $
*
ÌÌ% &
(
ÌÌ' (
width
ÌÌ( -
/
ÌÌ. /
w
ÌÌ0 1
)
ÌÌ1 2
-
ÌÌ3 4
(
ÌÌ5 6
width
ÌÌ6 ;
/
ÌÌ< =
$num
ÌÌ> @
)
ÌÌ@ A
;
ÌÌA B
float
ÍÍ 
x1
ÍÍ  
=
ÍÍ! "
(
ÍÍ# $
x
ÍÍ$ %
+
ÍÍ& '
$num
ÍÍ( )
)
ÍÍ) *
*
ÍÍ+ ,
(
ÍÍ- .
width
ÍÍ. 3
/
ÍÍ4 5
w
ÍÍ6 7
)
ÍÍ7 8
-
ÍÍ9 :
(
ÍÍ; <
width
ÍÍ< A
/
ÍÍB C
$num
ÍÍD F
)
ÍÍF G
;
ÍÍG H
float
ÏÏ 
y0
ÏÏ  
=
ÏÏ! "
y
ÏÏ# $
*
ÏÏ% &
(
ÏÏ' (
height
ÏÏ( .
/
ÏÏ/ 0
h
ÏÏ1 2
)
ÏÏ2 3
-
ÏÏ4 5
(
ÏÏ6 7
height
ÏÏ7 =
/
ÏÏ> ?
$num
ÏÏ@ B
)
ÏÏB C
;
ÏÏC D
float
ĞĞ 
y1
ĞĞ  
=
ĞĞ! "
(
ĞĞ# $
y
ĞĞ$ %
+
ĞĞ& '
$num
ĞĞ( )
)
ĞĞ) *
*
ĞĞ+ ,
(
ĞĞ- .
height
ĞĞ. 4
/
ĞĞ5 6
h
ĞĞ7 8
)
ĞĞ8 9
-
ĞĞ: ;
(
ĞĞ< =
height
ĞĞ= C
/
ĞĞD E
$num
ĞĞF H
)
ĞĞH I
;
ĞĞI J
p
ÒÒ 
[
ÒÒ 
i
ÒÒ 
+
ÒÒ 
$num
ÒÒ 
]
ÒÒ  
=
ÒÒ! "
new
ÒÒ# &
Vector2
ÒÒ' .
(
ÒÒ. /
x0
ÒÒ/ 1
,
ÒÒ1 2
y0
ÒÒ6 8
)
ÒÒ8 9
;
ÒÒ9 :
p
ÓÓ 
[
ÓÓ 
i
ÓÓ 
+
ÓÓ 
$num
ÓÓ 
]
ÓÓ  
=
ÓÓ! "
new
ÓÓ# &
Vector2
ÓÓ' .
(
ÓÓ. /
x1
ÓÓ/ 1
,
ÓÓ1 2
y0
ÓÓ6 8
)
ÓÓ8 9
;
ÓÓ9 :
p
ÔÔ 
[
ÔÔ 
i
ÔÔ 
+
ÔÔ 
$num
ÔÔ 
]
ÔÔ  
=
ÔÔ! "
new
ÔÔ# &
Vector2
ÔÔ' .
(
ÔÔ. /
x0
ÔÔ/ 1
,
ÔÔ1 2
y1
ÔÔ6 8
)
ÔÔ8 9
;
ÔÔ9 :
p
ÕÕ 
[
ÕÕ 
i
ÕÕ 
+
ÕÕ 
$num
ÕÕ 
]
ÕÕ  
=
ÕÕ! "
new
ÕÕ# &
Vector2
ÕÕ' .
(
ÕÕ. /
x1
ÕÕ/ 1
,
ÕÕ1 2
y1
ÕÕ6 8
)
ÕÕ8 9
;
ÕÕ9 :
f
×× 
[
×× 
j
×× 
++
×× 
]
×× 
=
××  
new
××! $
Face
××% )
(
××) *
new
××* -
int
××. 1
[
××1 2
$num
××2 3
]
××3 4
{
ØØ 
i
ÙÙ 
+
ÙÙ 
$num
ÙÙ  !
,
ÙÙ! "
i
ÚÚ 
+
ÚÚ 
$num
ÚÚ  !
,
ÚÚ! "
i
ÛÛ 
+
ÛÛ 
$num
ÛÛ  !
,
ÛÛ! "
i
ÜÜ 
+
ÜÜ 
$num
ÜÜ  !
,
ÜÜ! "
i
İİ 
+
İİ 
$num
İİ  !
,
İİ! "
i
ŞŞ 
+
ŞŞ 
$num
ŞŞ  !
}
ßß 
)
ßß 
;
ßß 
i
áá 
+=
áá 
$num
áá 
;
áá 
}
ââ 
}
ãã 
}
ää 
switch
ææ 
(
ææ 
axis
ææ 
)
ææ 
{
çç 
case
èè 
Axis
èè 
.
èè 
Right
èè 
:
èè  
for
éé 
(
éé 
i
éé 
=
éé 
$num
éé 
;
éé 
i
éé  !
<
éé" #
v
éé$ %
.
éé% &
Length
éé& ,
;
éé, -
i
éé. /
++
éé/ 1
)
éé1 2
v
êê 
[
êê 
i
êê 
]
êê 
=
êê 
new
êê "
Vector3
êê# *
(
êê* +
$num
êê+ -
,
êê- .
p
êê/ 0
[
êê0 1
i
êê1 2
]
êê2 3
.
êê3 4
x
êê4 5
,
êê5 6
p
êê7 8
[
êê8 9
i
êê9 :
]
êê: ;
.
êê; <
y
êê< =
)
êê= >
;
êê> ?
break
ëë 
;
ëë 
case
ìì 
Axis
ìì 
.
ìì 
Left
ìì 
:
ìì 
for
íí 
(
íí 
i
íí 
=
íí 
$num
íí 
;
íí 
i
íí  !
<
íí" #
v
íí$ %
.
íí% &
Length
íí& ,
;
íí, -
i
íí. /
++
íí/ 1
)
íí1 2
v
îî 
[
îî 
i
îî 
]
îî 
=
îî 
new
îî "
Vector3
îî# *
(
îî* +
$num
îî+ -
,
îî- .
p
îî/ 0
[
îî0 1
i
îî1 2
]
îî2 3
.
îî3 4
y
îî4 5
,
îî5 6
p
îî7 8
[
îî8 9
i
îî9 :
]
îî: ;
.
îî; <
x
îî< =
)
îî= >
;
îî> ?
break
ïï 
;
ïï 
case
ğğ 
Axis
ğğ 
.
ğğ 
Up
ğğ 
:
ğğ 
for
ññ 
(
ññ 
i
ññ 
=
ññ 
$num
ññ 
;
ññ 
i
ññ  !
<
ññ" #
v
ññ$ %
.
ññ% &
Length
ññ& ,
;
ññ, -
i
ññ. /
++
ññ/ 1
)
ññ1 2
v
òò 
[
òò 
i
òò 
]
òò 
=
òò 
new
òò "
Vector3
òò# *
(
òò* +
p
òò+ ,
[
òò, -
i
òò- .
]
òò. /
.
òò/ 0
y
òò0 1
,
òò1 2
$num
òò3 5
,
òò5 6
p
òò7 8
[
òò8 9
i
òò9 :
]
òò: ;
.
òò; <
x
òò< =
)
òò= >
;
òò> ?
break
óó 
;
óó 
case
ôô 
Axis
ôô 
.
ôô 
Down
ôô 
:
ôô 
for
õõ 
(
õõ 
i
õõ 
=
õõ 
$num
õõ 
;
õõ 
i
õõ  !
<
õõ" #
v
õõ$ %
.
õõ% &
Length
õõ& ,
;
õõ, -
i
õõ. /
++
õõ/ 1
)
õõ1 2
v
öö 
[
öö 
i
öö 
]
öö 
=
öö 
new
öö "
Vector3
öö# *
(
öö* +
p
öö+ ,
[
öö, -
i
öö- .
]
öö. /
.
öö/ 0
x
öö0 1
,
öö1 2
$num
öö3 5
,
öö5 6
p
öö7 8
[
öö8 9
i
öö9 :
]
öö: ;
.
öö; <
y
öö< =
)
öö= >
;
öö> ?
break
÷÷ 
;
÷÷ 
case
øø 
Axis
øø 
.
øø 
Forward
øø !
:
øø! "
for
ùù 
(
ùù 
i
ùù 
=
ùù 
$num
ùù 
;
ùù 
i
ùù  !
<
ùù" #
v
ùù$ %
.
ùù% &
Length
ùù& ,
;
ùù, -
i
ùù. /
++
ùù/ 1
)
ùù1 2
v
úú 
[
úú 
i
úú 
]
úú 
=
úú 
new
úú "
Vector3
úú# *
(
úú* +
p
úú+ ,
[
úú, -
i
úú- .
]
úú. /
.
úú/ 0
x
úú0 1
,
úú1 2
p
úú3 4
[
úú4 5
i
úú5 6
]
úú6 7
.
úú7 8
y
úú8 9
,
úú9 :
$num
úú; =
)
úú= >
;
úú> ?
break
ûû 
;
ûû 
case
üü 
Axis
üü 
.
üü 
Backward
üü "
:
üü" #
for
ıı 
(
ıı 
i
ıı 
=
ıı 
$num
ıı 
;
ıı 
i
ıı  !
<
ıı" #
v
ıı$ %
.
ıı% &
Length
ıı& ,
;
ıı, -
i
ıı. /
++
ıı/ 1
)
ıı1 2
v
şş 
[
şş 
i
şş 
]
şş 
=
şş 
new
şş "
Vector3
şş# *
(
şş* +
p
şş+ ,
[
şş, -
i
şş- .
]
şş. /
.
şş/ 0
y
şş0 1
,
şş1 2
p
şş3 4
[
şş4 5
i
şş5 6
]
şş6 7
.
şş7 8
x
şş8 9
,
şş9 :
$num
şş; =
)
şş= >
;
şş> ?
break
ÿÿ 
;
ÿÿ 
}
€€ 
ProBuilderMesh
‚‚ 
pb
‚‚ 
=
‚‚ 
ProBuilderMesh
‚‚  .
.
‚‚. /
Create
‚‚/ 5
(
‚‚5 6
v
‚‚6 7
,
‚‚7 8
f
‚‚9 :
)
‚‚: ;
;
‚‚; <
pb
ƒƒ 
.
ƒƒ 

gameObject
ƒƒ 
.
ƒƒ 
name
ƒƒ 
=
ƒƒ  
$str
ƒƒ! (
;
ƒƒ( )
pb
„„ 
.
„„ 
SetPivot
„„ 
(
„„ 
	pivotType
„„ !
)
„„! "
;
„„" #
return
†† 
pb
†† 
;
†† 
}
‡‡ 	
public
““ 
static
““ 
ProBuilderMesh
““ $
GeneratePipe
““% 1
(
““1 2
PivotLocation
““2 ?
	pivotType
““@ I
,
““I J
float
““K P
radius
““Q W
,
““W X
float
““Y ^
height
““_ e
,
““e f
float
““g l
	thickness
““m v
,
““v w
int
““x {

subdivAxis““| †
,““† ‡
int““ˆ ‹
subdivHeight““Œ ˜
)““˜ ™
{
”” 	
Vector2
–– 
[
–– 
]
–– 
templateOut
–– !
=
––" #
new
––$ '
Vector2
––( /
[
––/ 0

subdivAxis
––0 :
]
––: ;
;
––; <
Vector2
—— 
[
—— 
]
—— 

templateIn
——  
=
——! "
new
——# &
Vector2
——' .
[
——. /

subdivAxis
——/ 9
]
——9 :
;
——: ;
for
™™ 
(
™™ 
int
™™ 
i
™™ 
=
™™ 
$num
™™ 
;
™™ 
i
™™ 
<
™™ 

subdivAxis
™™  *
;
™™* +
i
™™, -
++
™™- /
)
™™/ 0
{
šš 
templateOut
›› 
[
›› 
i
›› 
]
›› 
=
››  
Math
››! %
.
››% &"
PointInCircumference
››& :
(
››: ;
radius
››; A
,
››A B
i
››C D
*
››E F
(
››G H
$num
››H L
/
››M N

subdivAxis
››O Y
)
››Y Z
,
››Z [
Vector2
››\ c
.
››c d
zero
››d h
)
››h i
;
››i j

templateIn
œœ 
[
œœ 
i
œœ 
]
œœ 
=
œœ 
Math
œœ  $
.
œœ$ %"
PointInCircumference
œœ% 9
(
œœ9 :
radius
œœ: @
-
œœA B
	thickness
œœC L
,
œœL M
i
œœN O
*
œœP Q
(
œœR S
$num
œœS W
/
œœX Y

subdivAxis
œœZ d
)
œœd e
,
œœe f
Vector2
œœg n
.
œœn o
zero
œœo s
)
œœs t
;
œœt u
}
 
List
ŸŸ 
<
ŸŸ 
Vector3
ŸŸ 
>
ŸŸ 
v
ŸŸ 
=
ŸŸ 
new
ŸŸ !
List
ŸŸ" &
<
ŸŸ& '
Vector3
ŸŸ' .
>
ŸŸ. /
(
ŸŸ/ 0
)
ŸŸ0 1
;
ŸŸ1 2
subdivHeight
¡¡ 
+=
¡¡ 
$num
¡¡ 
;
¡¡ 
Vector2
¤¤ 
tmp
¤¤ 
,
¤¤ 
tmp2
¤¤ 
,
¤¤ 
tmp3
¤¤ #
,
¤¤# $
tmp4
¤¤% )
;
¤¤) *
for
¥¥ 
(
¥¥ 
int
¥¥ 
i
¥¥ 
=
¥¥ 
$num
¥¥ 
;
¥¥ 
i
¥¥ 
<
¥¥ 
subdivHeight
¥¥  ,
;
¥¥, -
i
¥¥. /
++
¥¥/ 1
)
¥¥1 2
{
¦¦ 
float
¨¨ 
y
¨¨ 
=
¨¨ 
i
¨¨ 
*
¨¨ 
(
¨¨ 
height
¨¨ %
/
¨¨& '
subdivHeight
¨¨( 4
)
¨¨4 5
;
¨¨5 6
float
©© 
y2
©© 
=
©© 
(
©© 
i
©© 
+
©© 
$num
©©  !
)
©©! "
*
©©# $
(
©©% &
height
©©& ,
/
©©- .
subdivHeight
©©/ ;
)
©©; <
;
©©< =
for
«« 
(
«« 
int
«« 
n
«« 
=
«« 
$num
«« 
;
«« 
n
««  !
<
««" #

subdivAxis
««$ .
;
««. /
n
««0 1
++
««1 3
)
««3 4
{
¬¬ 
tmp
­­ 
=
­­ 
templateOut
­­ %
[
­­% &
n
­­& '
]
­­' (
;
­­( )
tmp2
®® 
=
®® 
n
®® 
<
®® 
(
®®  

subdivAxis
®®  *
-
®®+ ,
$num
®®- .
)
®®. /
?
®®0 1
templateOut
®®2 =
[
®®= >
n
®®> ?
+
®®@ A
$num
®®B C
]
®®C D
:
®®E F
templateOut
®®G R
[
®®R S
$num
®®S T
]
®®T U
;
®®U V
Vector3
±± 
[
±± 
]
±± 
qvo
±± !
=
±±" #
new
±±$ '
Vector3
±±( /
[
±±/ 0
$num
±±0 1
]
±±1 2
{
²² 
new
³³ 
Vector3
³³ #
(
³³# $
tmp2
³³$ (
.
³³( )
x
³³) *
,
³³* +
y
³³, -
,
³³- .
tmp2
³³/ 3
.
³³3 4
y
³³4 5
)
³³5 6
,
³³6 7
new
´´ 
Vector3
´´ #
(
´´# $
tmp
´´$ '
.
´´' (
x
´´( )
,
´´) *
y
´´+ ,
,
´´, -
tmp
´´. 1
.
´´1 2
y
´´2 3
)
´´3 4
,
´´4 5
new
µµ 
Vector3
µµ #
(
µµ# $
tmp2
µµ$ (
.
µµ( )
x
µµ) *
,
µµ* +
y2
µµ, .
,
µµ. /
tmp2
µµ0 4
.
µµ4 5
y
µµ5 6
)
µµ6 7
,
µµ7 8
new
¶¶ 
Vector3
¶¶ #
(
¶¶# $
tmp
¶¶$ '
.
¶¶' (
x
¶¶( )
,
¶¶) *
y2
¶¶+ -
,
¶¶- .
tmp
¶¶/ 2
.
¶¶2 3
y
¶¶3 4
)
¶¶4 5
}
·· 
;
·· 
tmp
ºº 
=
ºº 

templateIn
ºº $
[
ºº$ %
n
ºº% &
]
ºº& '
;
ºº' (
tmp2
»» 
=
»» 
n
»» 
<
»» 
(
»»  

subdivAxis
»»  *
-
»»+ ,
$num
»»- .
)
»». /
?
»»0 1

templateIn
»»2 <
[
»»< =
n
»»= >
+
»»? @
$num
»»A B
]
»»B C
:
»»D E

templateIn
»»F P
[
»»P Q
$num
»»Q R
]
»»R S
;
»»S T
Vector3
¼¼ 
[
¼¼ 
]
¼¼ 
qvi
¼¼ !
=
¼¼" #
new
¼¼$ '
Vector3
¼¼( /
[
¼¼/ 0
$num
¼¼0 1
]
¼¼1 2
{
½½ 
new
¾¾ 
Vector3
¾¾ #
(
¾¾# $
tmp
¾¾$ '
.
¾¾' (
x
¾¾( )
,
¾¾) *
y
¾¾+ ,
,
¾¾, -
tmp
¾¾. 1
.
¾¾1 2
y
¾¾2 3
)
¾¾3 4
,
¾¾4 5
new
¿¿ 
Vector3
¿¿ #
(
¿¿# $
tmp2
¿¿$ (
.
¿¿( )
x
¿¿) *
,
¿¿* +
y
¿¿, -
,
¿¿- .
tmp2
¿¿/ 3
.
¿¿3 4
y
¿¿4 5
)
¿¿5 6
,
¿¿6 7
new
ÀÀ 
Vector3
ÀÀ #
(
ÀÀ# $
tmp
ÀÀ$ '
.
ÀÀ' (
x
ÀÀ( )
,
ÀÀ) *
y2
ÀÀ+ -
,
ÀÀ- .
tmp
ÀÀ/ 2
.
ÀÀ2 3
y
ÀÀ3 4
)
ÀÀ4 5
,
ÀÀ5 6
new
ÁÁ 
Vector3
ÁÁ #
(
ÁÁ# $
tmp2
ÁÁ$ (
.
ÁÁ( )
x
ÁÁ) *
,
ÁÁ* +
y2
ÁÁ, .
,
ÁÁ. /
tmp2
ÁÁ0 4
.
ÁÁ4 5
y
ÁÁ5 6
)
ÁÁ6 7
}
ÂÂ 
;
ÂÂ 
v
ÄÄ 
.
ÄÄ 
AddRange
ÄÄ 
(
ÄÄ 
qvo
ÄÄ "
)
ÄÄ" #
;
ÄÄ# $
v
ÅÅ 
.
ÅÅ 
AddRange
ÅÅ 
(
ÅÅ 
qvi
ÅÅ "
)
ÅÅ" #
;
ÅÅ# $
}
ÆÆ 
}
ÇÇ 
for
ÊÊ 
(
ÊÊ 
int
ÊÊ 
i
ÊÊ 
=
ÊÊ 
$num
ÊÊ 
;
ÊÊ 
i
ÊÊ 
<
ÊÊ 

subdivAxis
ÊÊ  *
;
ÊÊ* +
i
ÊÊ, -
++
ÊÊ- /
)
ÊÊ/ 0
{
ËË 
tmp
ÌÌ 
=
ÌÌ 
templateOut
ÌÌ !
[
ÌÌ! "
i
ÌÌ" #
]
ÌÌ# $
;
ÌÌ$ %
tmp2
ÍÍ 
=
ÍÍ 
(
ÍÍ 
i
ÍÍ 
<
ÍÍ 

subdivAxis
ÍÍ &
-
ÍÍ' (
$num
ÍÍ) *
)
ÍÍ* +
?
ÍÍ, -
templateOut
ÍÍ. 9
[
ÍÍ9 :
i
ÍÍ: ;
+
ÍÍ< =
$num
ÍÍ> ?
]
ÍÍ? @
:
ÍÍA B
templateOut
ÍÍC N
[
ÍÍN O
$num
ÍÍO P
]
ÍÍP Q
;
ÍÍQ R
tmp3
ÎÎ 
=
ÎÎ 

templateIn
ÎÎ !
[
ÎÎ! "
i
ÎÎ" #
]
ÎÎ# $
;
ÎÎ$ %
tmp4
ÏÏ 
=
ÏÏ 
(
ÏÏ 
i
ÏÏ 
<
ÏÏ 

subdivAxis
ÏÏ &
-
ÏÏ' (
$num
ÏÏ) *
)
ÏÏ* +
?
ÏÏ, -

templateIn
ÏÏ. 8
[
ÏÏ8 9
i
ÏÏ9 :
+
ÏÏ; <
$num
ÏÏ= >
]
ÏÏ> ?
:
ÏÏ@ A

templateIn
ÏÏB L
[
ÏÏL M
$num
ÏÏM N
]
ÏÏN O
;
ÏÏO P
Vector3
ÒÒ 
[
ÒÒ 
]
ÒÒ 
tpt
ÒÒ 
=
ÒÒ 
new
ÒÒ  #
Vector3
ÒÒ$ +
[
ÒÒ+ ,
$num
ÒÒ, -
]
ÒÒ- .
{
ÓÓ 
new
ÔÔ 
Vector3
ÔÔ 
(
ÔÔ  
tmp2
ÔÔ  $
.
ÔÔ$ %
x
ÔÔ% &
,
ÔÔ& '
height
ÔÔ( .
,
ÔÔ. /
tmp2
ÔÔ0 4
.
ÔÔ4 5
y
ÔÔ5 6
)
ÔÔ6 7
,
ÔÔ7 8
new
ÕÕ 
Vector3
ÕÕ 
(
ÕÕ  
tmp
ÕÕ  #
.
ÕÕ# $
x
ÕÕ$ %
,
ÕÕ% &
height
ÕÕ( .
,
ÕÕ. /
tmp
ÕÕ0 3
.
ÕÕ3 4
y
ÕÕ4 5
)
ÕÕ5 6
,
ÕÕ6 7
new
ÖÖ 
Vector3
ÖÖ 
(
ÖÖ  
tmp4
ÖÖ  $
.
ÖÖ$ %
x
ÖÖ% &
,
ÖÖ& '
height
ÖÖ( .
,
ÖÖ. /
tmp4
ÖÖ0 4
.
ÖÖ4 5
y
ÖÖ5 6
)
ÖÖ6 7
,
ÖÖ7 8
new
×× 
Vector3
×× 
(
××  
tmp3
××  $
.
××$ %
x
××% &
,
××& '
height
××( .
,
××. /
tmp3
××0 4
.
××4 5
y
××5 6
)
××6 7
}
ØØ 
;
ØØ 
Vector3
ÛÛ 
[
ÛÛ 
]
ÛÛ 
tpb
ÛÛ 
=
ÛÛ 
new
ÛÛ  #
Vector3
ÛÛ$ +
[
ÛÛ+ ,
$num
ÛÛ, -
]
ÛÛ- .
{
ÜÜ 
new
İİ 
Vector3
İİ 
(
İİ  
tmp
İİ  #
.
İİ# $
x
İİ$ %
,
İİ% &
$num
İİ' )
,
İİ) *
tmp
İİ+ .
.
İİ. /
y
İİ/ 0
)
İİ0 1
,
İİ1 2
new
ŞŞ 
Vector3
ŞŞ 
(
ŞŞ  
tmp2
ŞŞ  $
.
ŞŞ$ %
x
ŞŞ% &
,
ŞŞ& '
$num
ŞŞ( *
,
ŞŞ* +
tmp2
ŞŞ, 0
.
ŞŞ0 1
y
ŞŞ1 2
)
ŞŞ2 3
,
ŞŞ3 4
new
ßß 
Vector3
ßß 
(
ßß  
tmp3
ßß  $
.
ßß$ %
x
ßß% &
,
ßß& '
$num
ßß( *
,
ßß* +
tmp3
ßß, 0
.
ßß0 1
y
ßß1 2
)
ßß2 3
,
ßß3 4
new
àà 
Vector3
àà 
(
àà  
tmp4
àà  $
.
àà$ %
x
àà% &
,
àà& '
$num
àà( *
,
àà* +
tmp4
àà, 0
.
àà0 1
y
àà1 2
)
àà2 3
,
àà3 4
}
áá 
;
áá 
v
ãã 
.
ãã 
AddRange
ãã 
(
ãã 
tpb
ãã 
)
ãã 
;
ãã  
v
ää 
.
ää 
AddRange
ää 
(
ää 
tpt
ää 
)
ää 
;
ää  
}
åå 
ProBuilderMesh
çç 
pb
çç 
=
çç 
ProBuilderMesh
çç  .
.
çç. /&
CreateInstanceWithPoints
çç/ G
(
ççG H
v
ççH I
.
ççI J
ToArray
ççJ Q
(
ççQ R
)
ççR S
)
ççS T
;
ççT U
pb
éé 
.
éé 

gameObject
éé 
.
éé 
name
éé 
=
éé  
$str
éé! '
;
éé' (
pb
êê 
.
êê 
SetPivot
êê 
(
êê 
	pivotType
êê !
,
êê! "
$num
êê# $
)
êê$ %
;
êê% &
return
ìì 
pb
ìì 
;
ìì 
}
íí 	
public
÷÷ 
static
÷÷ 
ProBuilderMesh
÷÷ $
GenerateCone
÷÷% 1
(
÷÷1 2
PivotLocation
÷÷2 ?
	pivotType
÷÷@ I
,
÷÷I J
float
÷÷K P
radius
÷÷Q W
,
÷÷W X
float
÷÷Y ^
height
÷÷_ e
,
÷÷e f
int
÷÷g j

subdivAxis
÷÷k u
)
÷÷u v
{
øø 	
Vector3
úú 
[
úú 
]
úú 
template
úú 
=
úú  
new
úú! $
Vector3
úú% ,
[
úú, -

subdivAxis
úú- 7
]
úú7 8
;
úú8 9
for
üü 
(
üü 
int
üü 
i
üü 
=
üü 
$num
üü 
;
üü 
i
üü 
<
üü 

subdivAxis
üü  *
;
üü* +
i
üü, -
++
üü- /
)
üü/ 0
{
ıı 
Vector2
şş 
ct
şş 
=
şş 
Math
şş !
.
şş! ""
PointInCircumference
şş" 6
(
şş6 7
radius
şş7 =
,
şş= >
i
şş? @
*
şşA B
(
şşC D
$num
şşD H
/
şşI J

subdivAxis
şşK U
)
şşU V
,
şşV W
Vector2
şşX _
.
şş_ `
zero
şş` d
)
şşd e
;
şşe f
template
ÿÿ 
[
ÿÿ 
i
ÿÿ 
]
ÿÿ 
=
ÿÿ 
new
ÿÿ !
Vector3
ÿÿ" )
(
ÿÿ) *
ct
ÿÿ* ,
.
ÿÿ, -
x
ÿÿ- .
,
ÿÿ. /
$num
ÿÿ0 2
,
ÿÿ2 3
ct
ÿÿ4 6
.
ÿÿ6 7
y
ÿÿ7 8
)
ÿÿ8 9
;
ÿÿ9 :
}
€	€	 
List
‚	‚	 
<
‚	‚	 
Vector3
‚	‚	 
>
‚	‚	 
v
‚	‚	 
=
‚	‚	 
new
‚	‚	 !
List
‚	‚	" &
<
‚	‚	& '
Vector3
‚	‚	' .
>
‚	‚	. /
(
‚	‚	/ 0
)
‚	‚	0 1
;
‚	‚	1 2
List
ƒ	ƒ	 
<
ƒ	ƒ	 
Face
ƒ	ƒ	 
>
ƒ	ƒ	 
f
ƒ	ƒ	 
=
ƒ	ƒ	 
new
ƒ	ƒ	 
List
ƒ	ƒ	 #
<
ƒ	ƒ	# $
Face
ƒ	ƒ	$ (
>
ƒ	ƒ	( )
(
ƒ	ƒ	) *
)
ƒ	ƒ	* +
;
ƒ	ƒ	+ ,
for
†	†	 
(
†	†	 
int
†	†	 
i
†	†	 
=
†	†	 
$num
†	†	 
;
†	†	 
i
†	†	 
<
†	†	 

subdivAxis
†	†	  *
;
†	†	* +
i
†	†	, -
++
†	†	- /
)
†	†	/ 0
{
‡	‡	 
v
‰	‰	 
.
‰	‰	 
Add
‰	‰	 
(
‰	‰	 
template
‰	‰	 
[
‰	‰	 
i
‰	‰	  
]
‰	‰	  !
)
‰	‰	! "
;
‰	‰	" #
v
Š	Š	 
.
Š	Š	 
Add
Š	Š	 
(
Š	Š	 
(
Š	Š	 
i
Š	Š	 
<
Š	Š	 

subdivAxis
Š	Š	 %
-
Š	Š	& '
$num
Š	Š	( )
)
Š	Š	) *
?
Š	Š	+ ,
template
Š	Š	- 5
[
Š	Š	5 6
i
Š	Š	6 7
+
Š	Š	8 9
$num
Š	Š	: ;
]
Š	Š	; <
:
Š	Š	= >
template
Š	Š	? G
[
Š	Š	G H
$num
Š	Š	H I
]
Š	Š	I J
)
Š	Š	J K
;
Š	Š	K L
v
‹	‹	 
.
‹	‹	 
Add
‹	‹	 
(
‹	‹	 
Vector3
‹	‹	 
.
‹	‹	 
up
‹	‹	  
*
‹	‹	! "
height
‹	‹	# )
)
‹	‹	) *
;
‹	‹	* +
v
		 
.
		 
Add
		 
(
		 
template
		 
[
		 
i
		  
]
		  !
)
		! "
;
		" #
v
		 
.
		 
Add
		 
(
		 
(
		 
i
		 
<
		 

subdivAxis
		 %
-
		& '
$num
		( )
)
		) *
?
		+ ,
template
		- 5
[
		5 6
i
		6 7
+
		8 9
$num
		: ;
]
		; <
:
		= >
template
		? G
[
		G H
$num
		H I
]
		I J
)
		J K
;
		K L
v
		 
.
		 
Add
		 
(
		 
Vector3
		 
.
		 
zero
		 "
)
		" #
;
		# $
}
‘	‘	 
List
“	“	 
<
“	“	 
Face
“	“	 
>
“	“	 
	sideFaces
“	“	  
=
“	“	! "
new
“	“	# &
List
“	“	' +
<
“	“	+ ,
Face
“	“	, 0
>
“	“	0 1
(
“	“	1 2
)
“	“	2 3
;
“	“	3 4
for
”	”	 
(
”	”	 
int
”	”	 
i
”	”	 
=
”	”	 
$num
”	”	 
;
”	”	 
i
”	”	 
<
”	”	 

subdivAxis
”	”	  *
*
”	”	+ ,
$num
”	”	- .
;
”	”	. /
i
”	”	0 1
+=
”	”	2 4
$num
”	”	5 6
)
”	”	6 7
{
•	•	 
Face
–	–	 
face
–	–	 
=
–	–	 
new
–	–	 
Face
–	–	  $
(
–	–	$ %
new
–	–	% (
int
–	–	) ,
[
–	–	, -
$num
–	–	- .
]
–	–	. /
{
–	–	0 1
i
–	–	2 3
+
–	–	4 5
$num
–	–	6 7
,
–	–	7 8
i
–	–	9 :
+
–	–	; <
$num
–	–	= >
,
–	–	> ?
i
–	–	@ A
+
–	–	B C
$num
–	–	D E
}
–	–	F G
)
–	–	G H
;
–	–	H I
f
—	—	 
.
—	—	 
Add
—	—	 
(
—	—	 
face
—	—	 
)
—	—	 
;
—	—	 
	sideFaces
˜	˜	 
.
˜	˜	 
Add
˜	˜	 
(
˜	˜	 
face
˜	˜	 "
)
˜	˜	" #
;
˜	˜	# $
f
™	™	 
.
™	™	 
Add
™	™	 
(
™	™	 
new
™	™	 
Face
™	™	 
(
™	™	 
new
™	™	 "
int
™	™	# &
[
™	™	& '
$num
™	™	' (
]
™	™	( )
{
™	™	* +
i
™	™	+ ,
+
™	™	- .
$num
™	™	/ 0
,
™	™	0 1
i
™	™	2 3
+
™	™	4 5
$num
™	™	6 7
,
™	™	7 8
i
™	™	9 :
+
™	™	; <
$num
™	™	= >
}
™	™	> ?
)
™	™	? @
)
™	™	@ A
;
™	™	A B
}
š	š	 
ProBuilderMesh
œ	œ	 
pb
œ	œ	 
=
œ	œ	 
ProBuilderMesh
œ	œ	  .
.
œ	œ	. /
Create
œ	œ	/ 5
(
œ	œ	5 6
v
œ	œ	6 7
.
œ	œ	7 8
ToArray
œ	œ	8 ?
(
œ	œ	? @
)
œ	œ	@ A
,
œ	œ	A B
f
œ	œ	C D
.
œ	œ	D E
ToArray
œ	œ	E L
(
œ	œ	L M
)
œ	œ	M N
)
œ	œ	N O
;
œ	œ	O P
pb
		 
.
		 

gameObject
		 
.
		 
name
		 
=
		  
$str
		! '
;
		' (
pb
		 
.
		 
SetPivot
		 
(
		 
	pivotType
		 !
)
		! "
;
		" #
pb
Ÿ	Ÿ	 
.
Ÿ	Ÿ	 
unwrapParameters
Ÿ	Ÿ	 
=
Ÿ	Ÿ	  !
new
Ÿ	Ÿ	" %
UnwrapParameters
Ÿ	Ÿ	& 6
(
Ÿ	Ÿ	6 7
)
Ÿ	Ÿ	7 8
{
 	 	 

packMargin
¡	¡	 
=
¡	¡	 
$num
¡	¡	  
}
¢	¢	 
;
¢	¢	 
var
¦	¦	 
	firstFace
¦	¦	 
=
¦	¦	 
	sideFaces
¦	¦	 %
[
¦	¦	% &
$num
¦	¦	& '
]
¦	¦	' (
;
¦	¦	( )
var
§	§	 
uv
§	§	 
=
§	§	 
	firstFace
§	§	 
.
§	§	 
uv
§	§	 !
;
§	§	! "
uv
¨	¨	 
.
¨	¨	 
anchor
¨	¨	 
=
¨	¨	  
AutoUnwrapSettings
¨	¨	 *
.
¨	¨	* +
Anchor
¨	¨	+ 1
.
¨	¨	1 2
	LowerLeft
¨	¨	2 ;
;
¨	¨	; <
	firstFace
©	©	 
.
©	©	 
uv
©	©	 
=
©	©	 
uv
©	©	 
;
©	©	 
	firstFace
ª	ª	 
.
ª	ª	 
manualUV
ª	ª	 
=
ª	ª	  
true
ª	ª	! %
;
ª	ª	% &
UvUnwrapping
­	­	 
.
­	­	 
Unwrap
­	­	 
(
­	­	  
pb
­	­	  "
,
­	­	" #
	firstFace
­	­	$ -
,
­	­	- .

projection
­	­	/ 9
:
­	­	9 :
Vector3
­	­	; B
.
­	­	B C
up
­	­	C E
)
­	­	E F
;
­	­	F G
for
®	®	 
(
®	®	 
int
®	®	 
i
®	®	 
=
®	®	 
$num
®	®	 
;
®	®	 
i
®	®	 
<
®	®	 
	sideFaces
®	®	  )
.
®	®	) *
Count
®	®	* /
;
®	®	/ 0
i
®	®	1 2
++
®	®	2 4
)
®	®	4 5
{
¯	¯	 
var
°	°	 
sideFace
°	°	 
=
°	°	 
	sideFaces
°	°	 (
[
°	°	( )
i
°	°	) *
]
°	°	* +
;
°	°	+ ,
sideFace
±	±	 
.
±	±	 
manualUV
±	±	 !
=
±	±	" #
true
±	±	$ (
;
±	±	( )
UvUnwrapping
²	²	 
.
²	²	 
CopyUVs
²	²	 $
(
²	²	$ %
pb
²	²	% '
,
²	²	' (
	firstFace
²	²	) 2
,
²	²	2 3
sideFace
²	²	4 <
)
²	²	< =
;
²	²	= >
}
³	³	 
pb
´	´	 
.
´	´	 
	RefreshUV
´	´	 
(
´	´	 
	sideFaces
´	´	 "
)
´	´	" #
;
´	´	# $
return
µ	µ	 
pb
µ	µ	 
;
µ	µ	 
}
¶	¶	 	
public
Ç	Ç	 
static
Ç	Ç	 
ProBuilderMesh
Ç	Ç	 $
GenerateArch
Ç	Ç	% 1
(
Ç	Ç	1 2
PivotLocation
Ç	Ç	2 ?
	pivotType
Ç	Ç	@ I
,
Ç	Ç	I J
float
Ç	Ç	K P
angle
Ç	Ç	Q V
,
Ç	Ç	V W
float
Ç	Ç	X ]
radius
Ç	Ç	^ d
,
Ç	Ç	d e
float
Ç	Ç	f k
width
Ç	Ç	l q
,
Ç	Ç	q r
float
Ç	Ç	s x
depth
Ç	Ç	y ~
,
Ç	Ç	~ 
intÇ	Ç	€ ƒ

radialCutsÇ	Ç	„ 
,Ç	Ç	 
boolÇ	Ç	 ”
insideFacesÇ	Ç	•  
,Ç	Ç	  ¡
boolÇ	Ç	¢ ¦
outsideFacesÇ	Ç	§ ³
,Ç	Ç	³ ´
boolÇ	Ç	µ ¹

frontFacesÇ	Ç	º Ä
,Ç	Ç	Ä Å
boolÇ	Ç	Æ Ê
	backFacesÇ	Ç	Ë Ô
,Ç	Ç	Ô Õ
boolÇ	Ç	Ö Ú
endCapsÇ	Ç	Û â
)Ç	Ç	â ã
{
È	È	 	
Vector2
É	É	 
[
É	É	 
]
É	É	 
templateOut
É	É	 !
=
É	É	" #
new
É	É	$ '
Vector2
É	É	( /
[
É	É	/ 0

radialCuts
É	É	0 :
]
É	É	: ;
;
É	É	; <
Vector2
Ê	Ê	 
[
Ê	Ê	 
]
Ê	Ê	 

templateIn
Ê	Ê	  
=
Ê	Ê	! "
new
Ê	Ê	# &
Vector2
Ê	Ê	' .
[
Ê	Ê	. /

radialCuts
Ê	Ê	/ 9
]
Ê	Ê	9 :
;
Ê	Ê	: ;
for
Ì	Ì	 
(
Ì	Ì	 
int
Ì	Ì	 
i
Ì	Ì	 
=
Ì	Ì	 
$num
Ì	Ì	 
;
Ì	Ì	 
i
Ì	Ì	 
<
Ì	Ì	 

radialCuts
Ì	Ì	  *
;
Ì	Ì	* +
i
Ì	Ì	, -
++
Ì	Ì	- /
)
Ì	Ì	/ 0
{
Í	Í	 
templateOut
Î	Î	 
[
Î	Î	 
i
Î	Î	 
]
Î	Î	 
=
Î	Î	  
Math
Î	Î	! %
.
Î	Î	% &"
PointInCircumference
Î	Î	& :
(
Î	Î	: ;
radius
Î	Î	; A
,
Î	Î	A B
i
Î	Î	C D
*
Î	Î	E F
(
Î	Î	G H
angle
Î	Î	H M
/
Î	Î	N O
(
Î	Î	P Q

radialCuts
Î	Î	Q [
-
Î	Î	\ ]
$num
Î	Î	^ _
)
Î	Î	_ `
)
Î	Î	` a
,
Î	Î	a b
Vector2
Î	Î	c j
.
Î	Î	j k
zero
Î	Î	k o
)
Î	Î	o p
;
Î	Î	p q

templateIn
Ï	Ï	 
[
Ï	Ï	 
i
Ï	Ï	 
]
Ï	Ï	 
=
Ï	Ï	 
Math
Ï	Ï	  $
.
Ï	Ï	$ %"
PointInCircumference
Ï	Ï	% 9
(
Ï	Ï	9 :
radius
Ï	Ï	: @
-
Ï	Ï	A B
width
Ï	Ï	C H
,
Ï	Ï	H I
i
Ï	Ï	J K
*
Ï	Ï	L M
(
Ï	Ï	N O
angle
Ï	Ï	O T
/
Ï	Ï	U V
(
Ï	Ï	W X

radialCuts
Ï	Ï	X b
-
Ï	Ï	c d
$num
Ï	Ï	e f
)
Ï	Ï	f g
)
Ï	Ï	g h
,
Ï	Ï	h i
Vector2
Ï	Ï	j q
.
Ï	Ï	q r
zero
Ï	Ï	r v
)
Ï	Ï	v w
;
Ï	Ï	w x
}
Ğ	Ğ	 
List
Ò	Ò	 
<
Ò	Ò	 
Vector3
Ò	Ò	 
>
Ò	Ò	 
v
Ò	Ò	 
=
Ò	Ò	 
new
Ò	Ò	 !
List
Ò	Ò	" &
<
Ò	Ò	& '
Vector3
Ò	Ò	' .
>
Ò	Ò	. /
(
Ò	Ò	/ 0
)
Ò	Ò	0 1
;
Ò	Ò	1 2
Vector2
Ô	Ô	 
tmp
Ô	Ô	 
,
Ô	Ô	 
tmp2
Ô	Ô	 
,
Ô	Ô	 
tmp3
Ô	Ô	 #
,
Ô	Ô	# $
tmp4
Ô	Ô	% )
;
Ô	Ô	) *
float
Ö	Ö	 
y
Ö	Ö	 
=
Ö	Ö	 
$num
Ö	Ö	 
;
Ö	Ö	 
for
Ø	Ø	 
(
Ø	Ø	 
int
Ø	Ø	 
n
Ø	Ø	 
=
Ø	Ø	 
$num
Ø	Ø	 
;
Ø	Ø	 
n
Ø	Ø	 
<
Ø	Ø	 

radialCuts
Ø	Ø	  *
-
Ø	Ø	+ ,
$num
Ø	Ø	- .
;
Ø	Ø	. /
n
Ø	Ø	0 1
++
Ø	Ø	1 3
)
Ø	Ø	3 4
{
Ù	Ù	 
tmp
Û	Û	 
=
Û	Û	 
templateOut
Û	Û	 !
[
Û	Û	! "
n
Û	Û	" #
]
Û	Û	# $
;
Û	Û	$ %
tmp2
Ü	Ü	 
=
Ü	Ü	 
n
Ü	Ü	 
<
Ü	Ü	 
(
Ü	Ü	 

radialCuts
Ü	Ü	 &
-
Ü	Ü	' (
$num
Ü	Ü	) *
)
Ü	Ü	* +
?
Ü	Ü	, -
templateOut
Ü	Ü	. 9
[
Ü	Ü	9 :
n
Ü	Ü	: ;
+
Ü	Ü	< =
$num
Ü	Ü	> ?
]
Ü	Ü	? @
:
Ü	Ü	A B
templateOut
Ü	Ü	C N
[
Ü	Ü	N O
n
Ü	Ü	O P
]
Ü	Ü	P Q
;
Ü	Ü	Q R
Vector3
Ş	Ş	 
[
Ş	Ş	 
]
Ş	Ş	 
qvo
Ş	Ş	 
=
Ş	Ş	 
new
Ş	Ş	  #
Vector3
Ş	Ş	$ +
[
Ş	Ş	+ ,
$num
Ş	Ş	, -
]
Ş	Ş	- .
{
ß	ß	 
new
à	à	 
Vector3
à	à	 
(
à	à	  
tmp
à	à	  #
.
à	à	# $
x
à	à	$ %
,
à	à	% &
tmp
à	à	' *
.
à	à	* +
y
à	à	+ ,
,
à	à	, -
y
à	à	. /
)
à	à	/ 0
,
à	à	0 1
new
á	á	 
Vector3
á	á	 
(
á	á	  
tmp2
á	á	  $
.
á	á	$ %
x
á	á	% &
,
á	á	& '
tmp2
á	á	( ,
.
á	á	, -
y
á	á	- .
,
á	á	. /
y
á	á	0 1
)
á	á	1 2
,
á	á	2 3
new
â	â	 
Vector3
â	â	 
(
â	â	  
tmp
â	â	  #
.
â	â	# $
x
â	â	$ %
,
â	â	% &
tmp
â	â	' *
.
â	â	* +
y
â	â	+ ,
,
â	â	, -
depth
â	â	. 3
)
â	â	3 4
,
â	â	4 5
new
ã	ã	 
Vector3
ã	ã	 
(
ã	ã	  
tmp2
ã	ã	  $
.
ã	ã	$ %
x
ã	ã	% &
,
ã	ã	& '
tmp2
ã	ã	( ,
.
ã	ã	, -
y
ã	ã	- .
,
ã	ã	. /
depth
ã	ã	0 5
)
ã	ã	5 6
}
ä	ä	 
;
ä	ä	 
tmp
ç	ç	 
=
ç	ç	 

templateIn
ç	ç	  
[
ç	ç	  !
n
ç	ç	! "
]
ç	ç	" #
;
ç	ç	# $
tmp2
è	è	 
=
è	è	 
n
è	è	 
<
è	è	 
(
è	è	 

radialCuts
è	è	 &
-
è	è	' (
$num
è	è	) *
)
è	è	* +
?
è	è	, -

templateIn
è	è	. 8
[
è	è	8 9
n
è	è	9 :
+
è	è	; <
$num
è	è	= >
]
è	è	> ?
:
è	è	@ A

templateIn
è	è	B L
[
è	è	L M
n
è	è	M N
]
è	è	N O
;
è	è	O P
Vector3
ê	ê	 
[
ê	ê	 
]
ê	ê	 
qvi
ê	ê	 
=
ê	ê	 
new
ê	ê	  #
Vector3
ê	ê	$ +
[
ê	ê	+ ,
$num
ê	ê	, -
]
ê	ê	- .
{
ë	ë	 
new
ì	ì	 
Vector3
ì	ì	 
(
ì	ì	  
tmp2
ì	ì	  $
.
ì	ì	$ %
x
ì	ì	% &
,
ì	ì	& '
tmp2
ì	ì	( ,
.
ì	ì	, -
y
ì	ì	- .
,
ì	ì	. /
y
ì	ì	0 1
)
ì	ì	1 2
,
ì	ì	2 3
new
í	í	 
Vector3
í	í	 
(
í	í	  
tmp
í	í	  #
.
í	í	# $
x
í	í	$ %
,
í	í	% &
tmp
í	í	' *
.
í	í	* +
y
í	í	+ ,
,
í	í	, -
y
í	í	. /
)
í	í	/ 0
,
í	í	0 1
new
î	î	 
Vector3
î	î	 
(
î	î	  
tmp2
î	î	  $
.
î	î	$ %
x
î	î	% &
,
î	î	& '
tmp2
î	î	( ,
.
î	î	, -
y
î	î	- .
,
î	î	. /
depth
î	î	0 5
)
î	î	5 6
,
î	î	6 7
new
ï	ï	 
Vector3
ï	ï	 
(
ï	ï	  
tmp
ï	ï	  #
.
ï	ï	# $
x
ï	ï	$ %
,
ï	ï	% &
tmp
ï	ï	' *
.
ï	ï	* +
y
ï	ï	+ ,
,
ï	ï	, -
depth
ï	ï	. 3
)
ï	ï	3 4
}
ğ	ğ	 
;
ğ	ğ	 
if
ò	ò	 
(
ò	ò	 
outsideFaces
ò	ò	  
)
ò	ò	  !
v
ó	ó	 
.
ó	ó	 
AddRange
ó	ó	 
(
ó	ó	 
qvo
ó	ó	 "
)
ó	ó	" #
;
ó	ó	# $
if
õ	õ	 
(
õ	õ	 
n
õ	õ	 
!=
õ	õ	 

radialCuts
õ	õ	 #
-
õ	õ	$ %
$num
õ	õ	& '
&&
õ	õ	( *
insideFaces
õ	õ	+ 6
)
õ	õ	6 7
v
ö	ö	 
.
ö	ö	 
AddRange
ö	ö	 
(
ö	ö	 
qvi
ö	ö	 "
)
ö	ö	" #
;
ö	ö	# $
if
ù	ù	 
(
ù	ù	 
angle
ù	ù	 
<
ù	ù	 
$num
ù	ù	  
&&
ù	ù	! #
endCaps
ù	ù	$ +
)
ù	ù	+ ,
{
ú	ú	 
if
û	û	 
(
û	û	 
n
û	û	 
==
û	û	 
$num
û	û	 
)
û	û	 
{
ü	ü	 
v
ı	ı	 
.
ı	ı	 
AddRange
ı	ı	 "
(
ı	ı	" #
new
ş	ş	 
Vector3
ş	ş	  '
[
ş	ş	' (
$num
ş	ş	( )
]
ş	ş	) *
{
ÿ	ÿ	 
new
€
€
 
Vector3
€
€
  '
(
€
€
' (
templateOut
€
€
( 3
[
€
€
3 4
n
€
€
4 5
]
€
€
5 6
.
€
€
6 7
x
€
€
7 8
,
€
€
8 9
templateOut
€
€
: E
[
€
€
E F
n
€
€
F G
]
€
€
G H
.
€
€
H I
y
€
€
I J
,
€
€
J K
depth
€
€
L Q
)
€
€
Q R
,
€
€
R S
new


 
Vector3


  '
(


' (

templateIn


( 2
[


2 3
n


3 4
]


4 5
.


5 6
x


6 7
,


7 8

templateIn


9 C
[


C D
n


D E
]


E F
.


F G
y


G H
,


H I
depth


J O
)


O P
,


P Q
new
‚
‚
 
Vector3
‚
‚
  '
(
‚
‚
' (
templateOut
‚
‚
( 3
[
‚
‚
3 4
n
‚
‚
4 5
]
‚
‚
5 6
.
‚
‚
6 7
x
‚
‚
7 8
,
‚
‚
8 9
templateOut
‚
‚
: E
[
‚
‚
E F
n
‚
‚
F G
]
‚
‚
G H
.
‚
‚
H I
y
‚
‚
I J
,
‚
‚
J K
y
‚
‚
L M
)
‚
‚
M N
,
‚
‚
N O
new
ƒ
ƒ
 
Vector3
ƒ
ƒ
  '
(
ƒ
ƒ
' (

templateIn
ƒ
ƒ
( 2
[
ƒ
ƒ
2 3
n
ƒ
ƒ
3 4
]
ƒ
ƒ
4 5
.
ƒ
ƒ
5 6
x
ƒ
ƒ
6 7
,
ƒ
ƒ
7 8

templateIn
ƒ
ƒ
9 C
[
ƒ
ƒ
C D
n
ƒ
ƒ
D E
]
ƒ
ƒ
E F
.
ƒ
ƒ
F G
y
ƒ
ƒ
G H
,
ƒ
ƒ
H I
y
ƒ
ƒ
J K
)
ƒ
ƒ
K L
}
„
„
 
)
„
„
 
;
„
„
 
}
…
…
 
if
ˆ
ˆ
 
(
ˆ
ˆ
 
n
ˆ
ˆ
 
==
ˆ
ˆ
 

radialCuts
ˆ
ˆ
 '
-
ˆ
ˆ
( )
$num
ˆ
ˆ
* +
)
ˆ
ˆ
+ ,
{
‰
‰
 
v
Š
Š
 
.
Š
Š
 
AddRange
Š
Š
 "
(
Š
Š
" #
new
‹
‹
 
Vector3
‹
‹
  '
[
‹
‹
' (
$num
‹
‹
( )
]
‹
‹
) *
{
Œ
Œ
 
new


 
Vector3


  '
(


' (

templateIn


( 2
[


2 3
n


3 4
+


5 6
$num


7 8
]


8 9
.


9 :
x


: ;
,


; <

templateIn


= G
[


G H
n


H I
+


J K
$num


L M
]


M N
.


N O
y


O P
,


P Q
depth


R W
)


W X
,


X Y
new


 
Vector3


  '
(


' (
templateOut


( 3
[


3 4
n


4 5
+


6 7
$num


8 9
]


9 :
.


: ;
x


; <
,


< =
templateOut


> I
[


I J
n


J K
+


L M
$num


N O
]


O P
.


P Q
y


Q R
,


R S
depth


T Y
)


Y Z
,


Z [
new


 
Vector3


  '
(


' (

templateIn


( 2
[


2 3
n


3 4
+


5 6
$num


7 8
]


8 9
.


9 :
x


: ;
,


; <

templateIn


= G
[


G H
n


H I
+


J K
$num


L M
]


M N
.


N O
y


O P
,


P Q
y


R S
)


S T
,


T U
new


 
Vector3


  '
(


' (
templateOut


( 3
[


3 4
n


4 5
+


6 7
$num


8 9
]


9 :
.


: ;
x


; <
,


< =
templateOut


> I
[


I J
n


J K
+


L M
$num


N O
]


O P
.


P Q
y


Q R
,


R S
y


T U
)


U V
}
‘
‘
 
)
‘
‘
 
;
‘
‘
 
}
’
’
 
}
“
“
 
}
”
”
 
for
—
—
 
(
—
—
 
int
—
—
 
i
—
—
 
=
—
—
 
$num
—
—
 
;
—
—
 
i
—
—
 
<
—
—
 

radialCuts
—
—
  *
-
—
—
+ ,
$num
—
—
- .
;
—
—
. /
i
—
—
0 1
++
—
—
1 3
)
—
—
3 4
{
˜
˜
 
tmp
™
™
 
=
™
™
 
templateOut
™
™
 !
[
™
™
! "
i
™
™
" #
]
™
™
# $
;
™
™
$ %
tmp2
š
š
 
=
š
š
 
(
š
š
 
i
š
š
 
<
š
š
 

radialCuts
š
š
 &
-
š
š
' (
$num
š
š
) *
)
š
š
* +
?
š
š
, -
templateOut
š
š
. 9
[
š
š
9 :
i
š
š
: ;
+
š
š
< =
$num
š
š
> ?
]
š
š
? @
:
š
š
A B
templateOut
š
š
C N
[
š
š
N O
i
š
š
O P
]
š
š
P Q
;
š
š
Q R
tmp3
›
›
 
=
›
›
 

templateIn
›
›
 !
[
›
›
! "
i
›
›
" #
]
›
›
# $
;
›
›
$ %
tmp4
œ
œ
 
=
œ
œ
 
(
œ
œ
 
i
œ
œ
 
<
œ
œ
 

radialCuts
œ
œ
 &
-
œ
œ
' (
$num
œ
œ
) *
)
œ
œ
* +
?
œ
œ
, -

templateIn
œ
œ
. 8
[
œ
œ
8 9
i
œ
œ
9 :
+
œ
œ
; <
$num
œ
œ
= >
]
œ
œ
> ?
:
œ
œ
@ A

templateIn
œ
œ
B L
[
œ
œ
L M
i
œ
œ
M N
]
œ
œ
N O
;
œ
œ
O P
Vector3
Ÿ
Ÿ
 
[
Ÿ
Ÿ
 
]
Ÿ
Ÿ
 
tpb
Ÿ
Ÿ
 
=
Ÿ
Ÿ
 
new
Ÿ
Ÿ
  #
Vector3
Ÿ
Ÿ
$ +
[
Ÿ
Ÿ
+ ,
$num
Ÿ
Ÿ
, -
]
Ÿ
Ÿ
- .
{
 
 
 
new
¡
¡
 
Vector3
¡
¡
 
(
¡
¡
  
tmp
¡
¡
  #
.
¡
¡
# $
x
¡
¡
$ %
,
¡
¡
% &
tmp
¡
¡
' *
.
¡
¡
* +
y
¡
¡
+ ,
,
¡
¡
, -
depth
¡
¡
. 3
)
¡
¡
3 4
,
¡
¡
4 5
new
¢
¢
 
Vector3
¢
¢
 
(
¢
¢
  
tmp2
¢
¢
  $
.
¢
¢
$ %
x
¢
¢
% &
,
¢
¢
& '
tmp2
¢
¢
( ,
.
¢
¢
, -
y
¢
¢
- .
,
¢
¢
. /
depth
¢
¢
0 5
)
¢
¢
5 6
,
¢
¢
6 7
new
£
£
 
Vector3
£
£
 
(
£
£
  
tmp3
£
£
  $
.
£
£
$ %
x
£
£
% &
,
£
£
& '
tmp3
£
£
( ,
.
£
£
, -
y
£
£
- .
,
£
£
. /
depth
£
£
0 5
)
£
£
5 6
,
£
£
6 7
new
¤
¤
 
Vector3
¤
¤
 
(
¤
¤
  
tmp4
¤
¤
  $
.
¤
¤
$ %
x
¤
¤
% &
,
¤
¤
& '
tmp4
¤
¤
( ,
.
¤
¤
, -
y
¤
¤
- .
,
¤
¤
. /
depth
¤
¤
0 5
)
¤
¤
5 6
,
¤
¤
6 7
}
¥
¥
 
;
¥
¥
 
Vector3
¨
¨
 
[
¨
¨
 
]
¨
¨
 
tpt
¨
¨
 
=
¨
¨
 
new
¨
¨
  #
Vector3
¨
¨
$ +
[
¨
¨
+ ,
$num
¨
¨
, -
]
¨
¨
- .
{
©
©
 
new
ª
ª
 
Vector3
ª
ª
 
(
ª
ª
  
tmp2
ª
ª
  $
.
ª
ª
$ %
x
ª
ª
% &
,
ª
ª
& '
tmp2
ª
ª
( ,
.
ª
ª
, -
y
ª
ª
- .
,
ª
ª
. /
$num
ª
ª
0 2
)
ª
ª
2 3
,
ª
ª
3 4
new
«
«
 
Vector3
«
«
 
(
«
«
  
tmp
«
«
  #
.
«
«
# $
x
«
«
$ %
,
«
«
% &
tmp
«
«
( +
.
«
«
+ ,
y
«
«
, -
,
«
«
- .
$num
«
«
/ 1
)
«
«
1 2
,
«
«
2 3
new
¬
¬
 
Vector3
¬
¬
 
(
¬
¬
  
tmp4
¬
¬
  $
.
¬
¬
$ %
x
¬
¬
% &
,
¬
¬
& '
tmp4
¬
¬
( ,
.
¬
¬
, -
y
¬
¬
- .
,
¬
¬
. /
$num
¬
¬
0 2
)
¬
¬
2 3
,
¬
¬
3 4
new
­
­
 
Vector3
­
­
 
(
­
­
  
tmp3
­
­
  $
.
­
­
$ %
x
­
­
% &
,
­
­
& '
tmp3
­
­
( ,
.
­
­
, -
y
­
­
- .
,
­
­
. /
$num
­
­
0 2
)
­
­
2 3
}
®
®
 
;
®
®
 
if
°
°
 
(
°
°
 

frontFaces
°
°
 
)
°
°
 
v
±
±
 
.
±
±
 
AddRange
±
±
 
(
±
±
 
tpb
±
±
 "
)
±
±
" #
;
±
±
# $
if
²
²
 
(
²
²
 
	backFaces
²
²
 
)
²
²
 
v
³
³
 
.
³
³
 
AddRange
³
³
 
(
³
³
 
tpt
³
³
 "
)
³
³
" #
;
³
³
# $
}
´
´
 
ProBuilderMesh
¶
¶
 
pb
¶
¶
 
=
¶
¶
 
ProBuilderMesh
¶
¶
  .
.
¶
¶
. /&
CreateInstanceWithPoints
¶
¶
/ G
(
¶
¶
G H
v
¶
¶
H I
.
¶
¶
I J
ToArray
¶
¶
J Q
(
¶
¶
Q R
)
¶
¶
R S
)
¶
¶
S T
;
¶
¶
T U
pb
¸
¸
 
.
¸
¸
 

gameObject
¸
¸
 
.
¸
¸
 
name
¸
¸
 
=
¸
¸
  
$str
¸
¸
! '
;
¸
¸
' (
pb
¹
¹
 
.
¹
¹
 
SetPivot
¹
¹
 
(
¹
¹
 
	pivotType
¹
¹
 !
)
¹
¹
! "
;
¹
¹
" #
return
»
»
 
pb
»
»
 
;
»
»
 
}
¼
¼
 	
public
Ê
Ê
 
static
Ê
Ê
 
ProBuilderMesh
Ê
Ê
 $!
GenerateIcosahedron
Ê
Ê
% 8
(
Ê
Ê
8 9
PivotLocation
Ê
Ê
9 F
	pivotType
Ê
Ê
G P
,
Ê
Ê
P Q
float
Ê
Ê
R W
radius
Ê
Ê
X ^
,
Ê
Ê
^ _
int
Ê
Ê
` c
subdivisions
Ê
Ê
d p
,
Ê
Ê
p q
bool
Ê
Ê
r v
weldVerticesÊ
Ê
w ƒ
=Ê
Ê
„ …
trueÊ
Ê
† Š
,Ê
Ê
Š ‹
boolÊ
Ê
Œ 
	manualUvsÊ
Ê
‘ š
=Ê
Ê
› œ
trueÊ
Ê
 ¡
)Ê
Ê
¡ ¢
{
Ë
Ë
 	
Vector3
Î
Î
 
[
Î
Î
 
]
Î
Î
 
v
Î
Î
 
=
Î
Î
 
new
Î
Î
 
Vector3
Î
Î
 %
[
Î
Î
% &"
k_IcosphereTriangles
Î
Î
& :
.
Î
Î
: ;
Length
Î
Î
; A
]
Î
Î
A B
;
Î
Î
B C
for
Ñ
Ñ
 
(
Ñ
Ñ
 
int
Ñ
Ñ
 
i
Ñ
Ñ
 
=
Ñ
Ñ
 
$num
Ñ
Ñ
 
;
Ñ
Ñ
 
i
Ñ
Ñ
 
<
Ñ
Ñ
 "
k_IcosphereTriangles
Ñ
Ñ
  4
.
Ñ
Ñ
4 5
Length
Ñ
Ñ
5 ;
;
Ñ
Ñ
; <
i
Ñ
Ñ
= >
+=
Ñ
Ñ
? A
$num
Ñ
Ñ
B C
)
Ñ
Ñ
C D
{
Ò
Ò
 
v
Ó
Ó
 
[
Ó
Ó
 
i
Ó
Ó
 
+
Ó
Ó
 
$num
Ó
Ó
 
]
Ó
Ó
 
=
Ó
Ó
 !
k_IcosphereVertices
Ó
Ó
 .
[
Ó
Ó
. /"
k_IcosphereTriangles
Ó
Ó
/ C
[
Ó
Ó
C D
i
Ó
Ó
D E
+
Ó
Ó
F G
$num
Ó
Ó
H I
]
Ó
Ó
I J
]
Ó
Ó
J K
.
Ó
Ó
K L

normalized
Ó
Ó
L V
*
Ó
Ó
W X
radius
Ó
Ó
Y _
;
Ó
Ó
_ `
v
Ô
Ô
 
[
Ô
Ô
 
i
Ô
Ô
 
+
Ô
Ô
 
$num
Ô
Ô
 
]
Ô
Ô
 
=
Ô
Ô
 !
k_IcosphereVertices
Ô
Ô
 .
[
Ô
Ô
. /"
k_IcosphereTriangles
Ô
Ô
/ C
[
Ô
Ô
C D
i
Ô
Ô
D E
+
Ô
Ô
F G
$num
Ô
Ô
H I
]
Ô
Ô
I J
]
Ô
Ô
J K
.
Ô
Ô
K L

normalized
Ô
Ô
L V
*
Ô
Ô
W X
radius
Ô
Ô
Y _
;
Ô
Ô
_ `
v
Õ
Õ
 
[
Õ
Õ
 
i
Õ
Õ
 
+
Õ
Õ
 
$num
Õ
Õ
 
]
Õ
Õ
 
=
Õ
Õ
 !
k_IcosphereVertices
Õ
Õ
 .
[
Õ
Õ
. /"
k_IcosphereTriangles
Õ
Õ
/ C
[
Õ
Õ
C D
i
Õ
Õ
D E
+
Õ
Õ
F G
$num
Õ
Õ
H I
]
Õ
Õ
I J
]
Õ
Õ
J K
.
Õ
Õ
K L

normalized
Õ
Õ
L V
*
Õ
Õ
W X
radius
Õ
Õ
Y _
;
Õ
Õ
_ `
}
Ö
Ö
 
for
Ø
Ø
 
(
Ø
Ø
 
int
Ø
Ø
 
i
Ø
Ø
 
=
Ø
Ø
 
$num
Ø
Ø
 
;
Ø
Ø
 
i
Ø
Ø
 
<
Ø
Ø
 
subdivisions
Ø
Ø
  ,
;
Ø
Ø
, -
i
Ø
Ø
. /
++
Ø
Ø
/ 1
)
Ø
Ø
1 2
{
Ù
Ù
 
v
Ú
Ú
 
=
Ú
Ú
 "
SubdivideIcosahedron
Ú
Ú
 (
(
Ú
Ú
( )
v
Ú
Ú
) *
,
Ú
Ú
* +
radius
Ú
Ú
, 2
)
Ú
Ú
2 3
;
Ú
Ú
3 4
}
Û
Û
 
Face
İ
İ
 
[
İ
İ
 
]
İ
İ
 
f
İ
İ
 
=
İ
İ
 
new
İ
İ
 
Face
İ
İ
 
[
İ
İ
  
v
İ
İ
  !
.
İ
İ
! "
Length
İ
İ
" (
/
İ
İ
) *
$num
İ
İ
+ ,
]
İ
İ
, -
;
İ
İ
- .
Vector3
ß
ß
 &
bottomMostVertexPosition
ß
ß
 ,
=
ß
ß
- .
Vector3
ß
ß
/ 6
.
ß
ß
6 7
positiveInfinity
ß
ß
7 G
;
ß
ß
G H
int
à
à
 #
bottomMostVertexIndex
à
à
 %
=
à
à
& '
-
à
à
( )
$num
à
à
) *
;
à
à
* +
for
â
â
 
(
â
â
 
int
â
â
 
i
â
â
 
=
â
â
 
$num
â
â
 
;
â
â
 
i
â
â
 
<
â
â
 
v
â
â
  !
.
â
â
! "
Length
â
â
" (
;
â
â
( )
i
â
â
* +
+=
â
â
, .
$num
â
â
/ 0
)
â
â
0 1
{
ã
ã
 
f
ä
ä
 
[
ä
ä
 
i
ä
ä
 
/
ä
ä
 
$num
ä
ä
 
]
ä
ä
 
=
ä
ä
 
new
ä
ä
 
Face
ä
ä
 #
(
ä
ä
# $
new
ä
ä
$ '
int
ä
ä
( +
[
ä
ä
+ ,
$num
ä
ä
, -
]
ä
ä
- .
{
ä
ä
/ 0
i
ä
ä
1 2
,
ä
ä
2 3
i
ä
ä
4 5
+
ä
ä
6 7
$num
ä
ä
8 9
,
ä
ä
9 :
i
ä
ä
; <
+
ä
ä
= >
$num
ä
ä
? @
}
ä
ä
A B
)
ä
ä
B C
;
ä
ä
C D
f
å
å
 
[
å
å
 
i
å
å
 
/
å
å
 
$num
å
å
 
]
å
å
 
.
å
å
 
manualUV
å
å
 !
=
å
å
" #
	manualUvs
å
å
$ -
;
å
å
- .
for
è
è
 
(
è
è
 
int
è
è
 
j
è
è
 
=
è
è
 
$num
è
è
 
;
è
è
 
j
è
è
  !
<
è
è
" #
f
è
è
$ %
[
è
è
% &
i
è
è
& '
/
è
è
( )
$num
è
è
* +
]
è
è
+ ,
.
è
è
, -
indexes
è
è
- 4
.
è
è
4 5
Count
è
è
5 :
;
è
è
: ;
++
è
è
< >
j
è
è
> ?
)
è
è
? @
{
é
é
 
int
ê
ê
 
index
ê
ê
 
=
ê
ê
 
f
ê
ê
  !
[
ê
ê
! "
i
ê
ê
" #
/
ê
ê
$ %
$num
ê
ê
& '
]
ê
ê
' (
.
ê
ê
( )
indexes
ê
ê
) 0
[
ê
ê
0 1
j
ê
ê
1 2
]
ê
ê
2 3
;
ê
ê
3 4
if
ì
ì
 
(
ì
ì
 
v
ì
ì
 
[
ì
ì
 
index
ì
ì
 
]
ì
ì
  
.
ì
ì
  !
y
ì
ì
! "
<
ì
ì
# $&
bottomMostVertexPosition
ì
ì
% =
.
ì
ì
= >
y
ì
ì
> ?
)
ì
ì
? @
{
í
í
 &
bottomMostVertexPosition
î
î
 0
=
î
î
1 2
v
î
î
3 4
[
î
î
4 5
index
î
î
5 :
]
î
î
: ;
;
î
î
; <#
bottomMostVertexIndex
ï
ï
 -
=
ï
ï
. /
index
ï
ï
0 5
;
ï
ï
5 6
}
ğ
ğ
 
}
ñ
ñ
 
}
ò
ò
 
if
ô
ô
 
(
ô
ô
 
!
ô
ô
 
	manualUvs
ô
ô
 
)
ô
ô
 
{
õ
õ
 
for
ö
ö
 
(
ö
ö
 
int
ö
ö
 
i
ö
ö
 
=
ö
ö
 
$num
ö
ö
 
;
ö
ö
 
i
ö
ö
  !
<
ö
ö
" #
f
ö
ö
$ %
.
ö
ö
% &
Length
ö
ö
& ,
;
ö
ö
, -
i
ö
ö
. /
++
ö
ö
/ 1
)
ö
ö
1 2
{
÷
÷
 
var
ø
ø
 
nrm
ø
ø
 
=
ø
ø
 
Math
ø
ø
 "
.
ø
ø
" #
Normal
ø
ø
# )
(
ø
ø
) *
v
ø
ø
* +
[
ø
ø
+ ,
f
ø
ø
, -
[
ø
ø
- .
i
ø
ø
. /
]
ø
ø
/ 0
.
ø
ø
0 1
indexesInternal
ø
ø
1 @
[
ø
ø
@ A
$num
ø
ø
A B
]
ø
ø
B C
]
ø
ø
C D
,
ø
ø
D E
v
ø
ø
F G
[
ø
ø
G H
f
ø
ø
H I
[
ø
ø
I J
i
ø
ø
J K
]
ø
ø
K L
.
ø
ø
L M
indexesInternal
ø
ø
M \
[
ø
ø
\ ]
$num
ø
ø
] ^
]
ø
ø
^ _
]
ø
ø
_ `
,
ø
ø
` a
v
ø
ø
b c
[
ø
ø
c d
f
ø
ø
d e
[
ø
ø
e f
i
ø
ø
f g
]
ø
ø
g h
.
ø
ø
h i
indexesInternal
ø
ø
i x
[
ø
ø
x y
$num
ø
ø
y z
]
ø
ø
z {
]
ø
ø
{ |
)
ø
ø
| }
;
ø
ø
} ~
var
ù
ù
 
axis
ù
ù
 
=
ù
ù
 

Projection
ù
ù
 )
.
ù
ù
) *$
VectorToProjectionAxis
ù
ù
* @
(
ù
ù
@ A
nrm
ù
ù
A D
)
ù
ù
D E
;
ù
ù
E F
if
û
û
 
(
û
û
 
axis
û
û
 
==
û
û
 
ProjectionAxis
û
û
  .
.
û
û
. /
X
û
û
/ 0
)
û
û
0 1
f
ü
ü
 
[
ü
ü
 
i
ü
ü
 
]
ü
ü
 
.
ü
ü
 
textureGroup
ü
ü
 )
=
ü
ü
* +
$num
ü
ü
, -
;
ü
ü
- .
else
ı
ı
 
if
ı
ı
 
(
ı
ı
 
axis
ı
ı
 !
==
ı
ı
" $
ProjectionAxis
ı
ı
% 3
.
ı
ı
3 4
Y
ı
ı
4 5
)
ı
ı
5 6
f
ş
ş
 
[
ş
ş
 
i
ş
ş
 
]
ş
ş
 
.
ş
ş
 
textureGroup
ş
ş
 )
=
ş
ş
* +
$num
ş
ş
, -
;
ş
ş
- .
else
ÿ
ÿ
 
if
ÿ
ÿ
 
(
ÿ
ÿ
 
axis
ÿ
ÿ
 !
==
ÿ
ÿ
" $
ProjectionAxis
ÿ
ÿ
% 3
.
ÿ
ÿ
3 4
Z
ÿ
ÿ
4 5
)
ÿ
ÿ
5 6
f
€€ 
[
€€ 
i
€€ 
]
€€ 
.
€€ 
textureGroup
€€ )
=
€€* +
$num
€€, -
;
€€- .
else
 
if
 
(
 
axis
 !
==
" $
ProjectionAxis
% 3
.
3 4
	XNegative
4 =
)
= >
f
‚‚ 
[
‚‚ 
i
‚‚ 
]
‚‚ 
.
‚‚ 
textureGroup
‚‚ )
=
‚‚* +
$num
‚‚, -
;
‚‚- .
else
ƒƒ 
if
ƒƒ 
(
ƒƒ 
axis
ƒƒ !
==
ƒƒ" $
ProjectionAxis
ƒƒ% 3
.
ƒƒ3 4
	YNegative
ƒƒ4 =
)
ƒƒ= >
f
„„ 
[
„„ 
i
„„ 
]
„„ 
.
„„ 
textureGroup
„„ )
=
„„* +
$num
„„, -
;
„„- .
else
…… 
if
…… 
(
…… 
axis
…… !
==
……" $
ProjectionAxis
……% 3
.
……3 4
	ZNegative
……4 =
)
……= >
f
†† 
[
†† 
i
†† 
]
†† 
.
†† 
textureGroup
†† )
=
††* +
$num
††, -
;
††- .
}
‡‡ 
}
ˆˆ 

GameObject
ŠŠ 
go
ŠŠ 
=
ŠŠ 
new
ŠŠ 

GameObject
ŠŠ  *
(
ŠŠ* +
)
ŠŠ+ ,
;
ŠŠ, -
ProBuilderMesh
‹‹ 
pb
‹‹ 
=
‹‹ 
go
‹‹  "
.
‹‹" #
AddComponent
‹‹# /
<
‹‹/ 0
ProBuilderMesh
‹‹0 >
>
‹‹> ?
(
‹‹? @
)
‹‹@ A
;
‹‹A B
pb
ŒŒ 
.
ŒŒ 
Clear
ŒŒ 
(
ŒŒ 
)
ŒŒ 
;
ŒŒ 
pb
 
.
 
positionsInternal
  
=
! "
v
# $
;
$ %
pb
 
.
 
facesInternal
 
=
 
f
  
;
  !
if
 
(
 
!
 
weldVertices
 
)
 
{
‘‘ 
SharedVertex
’’ 
[
’’ 
]
’’ 
si
’’ !
=
’’" #
new
’’$ '
SharedVertex
’’( 4
[
’’4 5
v
’’5 6
.
’’6 7
Length
’’7 =
]
’’= >
;
’’> ?
for
““ 
(
““ 
int
““ 
i
““ 
=
““ 
$num
““ 
;
““ 
i
““  !
<
““" #
si
““$ &
.
““& '
Length
““' -
;
““- .
i
““/ 0
++
““0 2
)
““2 3
si
”” 
[
”” 
i
”” 
]
”” 
=
”” 
new
”” 
SharedVertex
””  ,
(
””, -
new
””- 0
int
””1 4
[
””4 5
]
””5 6
{
””7 8
i
””8 9
}
””9 :
)
””: ;
;
””; <
pb
–– 
.
–– $
sharedVerticesInternal
–– )
=
––* +
si
––, .
;
––. /
}
—— 
else
˜˜ 
{
™™ 
pb
šš 
.
šš $
sharedVerticesInternal
šš )
=
šš* +
SharedVertex
šš, 8
.
šš8 9,
GetSharedVerticesWithPositions
šš9 W
(
ššW X
v
ššX Y
)
ššY Z
;
ššZ [
}
›› 
pb
 
.
 
ToMesh
 
(
 
)
 
;
 
pb
 
.
 
Refresh
 
(
 
)
 
;
 
pb
ŸŸ 
.
ŸŸ 

gameObject
ŸŸ 
.
ŸŸ 
name
ŸŸ 
=
ŸŸ  
$str
ŸŸ! ,
;
ŸŸ, -
pb
   
.
   
SetPivot
   
(
   
	pivotType
   !
,
  ! "#
bottomMostVertexIndex
  # 8
)
  8 9
;
  9 :
pb
¢¢ 
.
¢¢ 
unwrapParameters
¢¢ 
=
¢¢  !
new
¢¢" %
UnwrapParameters
¢¢& 6
(
¢¢6 7
)
¢¢7 8
{
££ 

packMargin
¤¤ 
=
¤¤ 
$num
¤¤  
}
¥¥ 
;
¥¥ 
return
§§ 
pb
§§ 
;
§§ 
}
¨¨ 	
static
°° 
Vector3
°° 
[
°° 
]
°° "
SubdivideIcosahedron
°° -
(
°°- .
Vector3
°°. 5
[
°°5 6
]
°°6 7
vertices
°°8 @
,
°°@ A
float
°°B G
radius
°°H N
)
°°N O
{
±± 	
Vector3
²² 
[
²² 
]
²² 
v
²² 
=
²² 
new
²² 
Vector3
²² %
[
²²% &
vertices
²²& .
.
²². /
Length
²²/ 5
*
²²6 7
$num
²²8 9
]
²²9 :
;
²²: ;
int
´´ 
index
´´ 
=
´´ 
$num
´´ 
;
´´ 
Vector3
¶¶ 
p0
¶¶ 
=
¶¶ 
Vector3
¶¶  
.
¶¶  !
zero
¶¶! %
,
¶¶% &
p1
·· 
=
·· 
Vector3
··  
.
··  !
zero
··! %
,
··% &
p2
¸¸ 
=
¸¸ 
Vector3
¸¸  
.
¸¸  !
zero
¸¸! %
,
¸¸% &
p3
¹¹ 
=
¹¹ 
Vector3
¹¹  
.
¹¹  !
zero
¹¹! %
,
¹¹% &
p4
ºº 
=
ºº 
Vector3
ºº  
.
ºº  !
zero
ºº! %
,
ºº% &
p5
»» 
=
»» 
Vector3
»»  
.
»»  !
zero
»»! %
;
»»% &
for
½½ 
(
½½ 
int
½½ 
i
½½ 
=
½½ 
$num
½½ 
;
½½ 
i
½½ 
<
½½ 
vertices
½½  (
.
½½( )
Length
½½) /
;
½½/ 0
i
½½1 2
+=
½½3 5
$num
½½6 7
)
½½7 8
{
¾¾ 
p0
¿¿ 
=
¿¿ 
vertices
¿¿ 
[
¿¿ 
i
¿¿ 
+
¿¿  !
$num
¿¿" #
]
¿¿# $
;
¿¿$ %
p2
ÀÀ 
=
ÀÀ 
vertices
ÀÀ 
[
ÀÀ 
i
ÀÀ 
+
ÀÀ  !
$num
ÀÀ" #
]
ÀÀ# $
;
ÀÀ$ %
p5
ÁÁ 
=
ÁÁ 
vertices
ÁÁ 
[
ÁÁ 
i
ÁÁ 
+
ÁÁ  !
$num
ÁÁ" #
]
ÁÁ# $
;
ÁÁ$ %
p1
ÂÂ 
=
ÂÂ 
(
ÂÂ 
(
ÂÂ 
p0
ÂÂ 
+
ÂÂ 
p2
ÂÂ 
)
ÂÂ 
*
ÂÂ  !
$num
ÂÂ" %
)
ÂÂ% &
.
ÂÂ& '

normalized
ÂÂ' 1
*
ÂÂ2 3
radius
ÂÂ4 :
;
ÂÂ: ;
p3
ÃÃ 
=
ÃÃ 
(
ÃÃ 
(
ÃÃ 
p0
ÃÃ 
+
ÃÃ 
p5
ÃÃ 
)
ÃÃ 
*
ÃÃ  !
$num
ÃÃ" %
)
ÃÃ% &
.
ÃÃ& '

normalized
ÃÃ' 1
*
ÃÃ2 3
radius
ÃÃ4 :
;
ÃÃ: ;
p4
ÄÄ 
=
ÄÄ 
(
ÄÄ 
(
ÄÄ 
p2
ÄÄ 
+
ÄÄ 
p5
ÄÄ 
)
ÄÄ 
*
ÄÄ  !
$num
ÄÄ" %
)
ÄÄ% &
.
ÄÄ& '

normalized
ÄÄ' 1
*
ÄÄ2 3
radius
ÄÄ4 :
;
ÄÄ: ;
v
ÆÆ 
[
ÆÆ 
index
ÆÆ 
++
ÆÆ 
]
ÆÆ 
=
ÆÆ 
p0
ÆÆ 
;
ÆÆ  
v
ÇÇ 
[
ÇÇ 
index
ÇÇ 
++
ÇÇ 
]
ÇÇ 
=
ÇÇ 
p1
ÇÇ 
;
ÇÇ  
v
ÈÈ 
[
ÈÈ 
index
ÈÈ 
++
ÈÈ 
]
ÈÈ 
=
ÈÈ 
p3
ÈÈ 
;
ÈÈ  
v
ÊÊ 
[
ÊÊ 
index
ÊÊ 
++
ÊÊ 
]
ÊÊ 
=
ÊÊ 
p1
ÊÊ 
;
ÊÊ  
v
ËË 
[
ËË 
index
ËË 
++
ËË 
]
ËË 
=
ËË 
p2
ËË 
;
ËË  
v
ÌÌ 
[
ÌÌ 
index
ÌÌ 
++
ÌÌ 
]
ÌÌ 
=
ÌÌ 
p4
ÌÌ 
;
ÌÌ  
v
ÎÎ 
[
ÎÎ 
index
ÎÎ 
++
ÎÎ 
]
ÎÎ 
=
ÎÎ 
p1
ÎÎ 
;
ÎÎ  
v
ÏÏ 
[
ÏÏ 
index
ÏÏ 
++
ÏÏ 
]
ÏÏ 
=
ÏÏ 
p4
ÏÏ 
;
ÏÏ  
v
ĞĞ 
[
ĞĞ 
index
ĞĞ 
++
ĞĞ 
]
ĞĞ 
=
ĞĞ 
p3
ĞĞ 
;
ĞĞ  
v
ÒÒ 
[
ÒÒ 
index
ÒÒ 
++
ÒÒ 
]
ÒÒ 
=
ÒÒ 
p3
ÒÒ 
;
ÒÒ  
v
ÓÓ 
[
ÓÓ 
index
ÓÓ 
++
ÓÓ 
]
ÓÓ 
=
ÓÓ 
p4
ÓÓ 
;
ÓÓ  
v
ÔÔ 
[
ÔÔ 
index
ÔÔ 
++
ÔÔ 
]
ÔÔ 
=
ÔÔ 
p5
ÔÔ 
;
ÔÔ  
}
ÕÕ 
return
×× 
v
×× 
;
×× 
}
ØØ 	
static
ÚÚ 
Vector3
ÚÚ 
[
ÚÚ 
]
ÚÚ 
GetCirclePoints
ÚÚ (
(
ÚÚ( )
int
ÚÚ) ,
segments
ÚÚ- 5
,
ÚÚ5 6
float
ÚÚ7 <
radius
ÚÚ= C
,
ÚÚC D
float
ÚÚE J
circumference
ÚÚK X
,
ÚÚX Y

Quaternion
ÚÚZ d
rotation
ÚÚe m
,
ÚÚm n
float
ÚÚo t
offset
ÚÚu {
)
ÚÚ{ |
{
ÛÛ 	
float
ÜÜ 
seg
ÜÜ 
=
ÜÜ 
(
ÜÜ 
float
ÜÜ 
)
ÜÜ 
segments
ÜÜ '
-
ÜÜ( )
$num
ÜÜ* +
;
ÜÜ+ ,
Vector3
ŞŞ 
[
ŞŞ 
]
ŞŞ 
v
ŞŞ 
=
ŞŞ 
new
ŞŞ 
Vector3
ŞŞ %
[
ŞŞ% &
(
ŞŞ& '
segments
ŞŞ' /
-
ŞŞ0 1
$num
ŞŞ2 3
)
ŞŞ3 4
*
ŞŞ5 6
$num
ŞŞ7 8
]
ŞŞ8 9
;
ŞŞ9 :
v
ßß 
[
ßß 
$num
ßß 
]
ßß 
=
ßß 
new
ßß 
Vector3
ßß 
(
ßß 
Mathf
ßß $
.
ßß$ %
Cos
ßß% (
(
ßß( )
(
ßß) *
(
ßß* +
$num
ßß+ -
/
ßß. /
seg
ßß0 3
)
ßß3 4
*
ßß5 6
circumference
ßß7 D
)
ßßD E
*
ßßF G
Mathf
ßßH M
.
ßßM N
Deg2Rad
ßßN U
)
ßßU V
*
ßßW X
radius
ßßY _
,
ßß_ `
Mathf
ßßa f
.
ßßf g
Sin
ßßg j
(
ßßj k
(
ßßk l
(
ßßl m
$num
ßßm o
/
ßßp q
seg
ßßr u
)
ßßu v
*
ßßw x
circumferenceßßy †
)ßß† ‡
*ßßˆ ‰
MathfßßŠ 
.ßß 
Deg2Radßß —
)ßß— ˜
*ßß™ š
radiusßß› ¡
,ßß¡ ¢
$numßß£ ¥
)ßß¥ ¦
;ßß¦ §
v
àà 
[
àà 
$num
àà 
]
àà 
=
àà 
new
àà 
Vector3
àà 
(
àà 
Mathf
àà $
.
àà$ %
Cos
àà% (
(
àà( )
(
àà) *
(
àà* +
$num
àà+ -
/
àà. /
seg
àà0 3
)
àà3 4
*
àà5 6
circumference
àà7 D
)
ààD E
*
ààF G
Mathf
ààH M
.
ààM N
Deg2Rad
ààN U
)
ààU V
*
ààW X
radius
ààY _
,
àà_ `
Mathf
ààa f
.
ààf g
Sin
ààg j
(
ààj k
(
ààk l
(
ààl m
$num
ààm o
/
ààp q
seg
ààr u
)
ààu v
*
ààw x
circumferenceàày †
)àà† ‡
*ààˆ ‰
MathfààŠ 
.àà 
Deg2Radàà —
)àà— ˜
*àà™ š
radiusàà› ¡
,àà¡ ¢
$numàà£ ¥
)àà¥ ¦
;àà¦ §
v
ââ 
[
ââ 
$num
ââ 
]
ââ 
=
ââ 
rotation
ââ 
*
ââ 
(
ââ 
(
ââ  
v
ââ  !
[
ââ! "
$num
ââ" #
]
ââ# $
+
ââ% &
Vector3
ââ' .
.
ââ. /
right
ââ/ 4
*
ââ5 6
offset
ââ7 =
)
ââ= >
)
ââ> ?
;
ââ? @
v
ãã 
[
ãã 
$num
ãã 
]
ãã 
=
ãã 
rotation
ãã 
*
ãã 
(
ãã 
(
ãã  
v
ãã  !
[
ãã! "
$num
ãã" #
]
ãã# $
+
ãã% &
Vector3
ãã' .
.
ãã. /
right
ãã/ 4
*
ãã5 6
offset
ãã7 =
)
ãã= >
)
ãã> ?
;
ãã? @
int
åå 
n
åå 
=
åå 
$num
åå 
;
åå 
System
çç 
.
çç 
Text
çç 
.
çç 
StringBuilder
çç %
sb
çç& (
=
çç) *
new
çç+ .
System
çç/ 5
.
çç5 6
Text
çç6 :
.
çç: ;
StringBuilder
çç; H
(
ççH I
)
ççI J
;
ççJ K
for
éé 
(
éé 
int
éé 
i
éé 
=
éé 
$num
éé 
;
éé 
i
éé 
<
éé 
segments
éé  (
;
éé( )
i
éé* +
++
éé+ -
)
éé- .
{
êê 
float
ëë 
rad
ëë 
=
ëë 
(
ëë 
(
ëë 
i
ëë 
/
ëë  !
seg
ëë" %
)
ëë% &
*
ëë' (
circumference
ëë) 6
)
ëë6 7
*
ëë8 9
Mathf
ëë: ?
.
ëë? @
Deg2Rad
ëë@ G
;
ëëG H
sb
ìì 
.
ìì 

AppendLine
ìì 
(
ìì 
rad
ìì !
.
ìì! "
ToString
ìì" *
(
ìì* +
)
ìì+ ,
)
ìì, -
;
ìì- .
v
îî 
[
îî 
n
îî 
+
îî 
$num
îî 
]
îî 
=
îî 
v
îî 
[
îî 
n
îî 
-
îî  
$num
îî! "
]
îî" #
;
îî# $
v
ïï 
[
ïï 
n
ïï 
+
ïï 
$num
ïï 
]
ïï 
=
ïï 
rotation
ïï #
*
ïï$ %
(
ïï& '
new
ïï' *
Vector3
ïï+ 2
(
ïï2 3
Mathf
ïï3 8
.
ïï8 9
Cos
ïï9 <
(
ïï< =
rad
ïï= @
)
ïï@ A
*
ïïB C
radius
ïïD J
,
ïïJ K
Mathf
ïïL Q
.
ïïQ R
Sin
ïïR U
(
ïïU V
rad
ïïV Y
)
ïïY Z
*
ïï[ \
radius
ïï] c
,
ïïc d
$num
ïïe g
)
ïïg h
+
ïïi j
Vector3
ïïk r
.
ïïr s
right
ïïs x
*
ïïy z
offsetïï{ 
)ïï ‚
;ïï‚ ƒ
n
ññ 
+=
ññ 
$num
ññ 
;
ññ 
}
òò 
return
ôô 
v
ôô 
;
ôô 
}
õõ 	
public
„„ 
static
„„ 
ProBuilderMesh
„„ $
GenerateTorus
„„% 2
(
„„2 3
PivotLocation
„„3 @
	pivotType
„„A J
,
„„J K
int
„„L O
rows
„„P T
,
„„T U
int
„„V Y
columns
„„Z a
,
„„a b
float
„„c h
innerRadius
„„i t
,
„„t u
float
„„v {
outerRadius„„| ‡
,„„‡ ˆ
bool„„‰ 
smooth„„ ”
,„„” •
float„„– ›'
horizontalCircumference„„œ ³
,„„³ ´
float„„µ º%
verticalCircumference„„» Ğ
,„„Ğ Ñ
bool„„Ò Ö
	manualUvs„„× à
=„„á â
false„„ã è
)„„è é
{
…… 	
int
†† 
clampedRows
†† 
=
†† 
(
†† 
int
†† "
)
††" #
Mathf
††# (
.
††( )
Clamp
††) .
(
††. /
rows
††/ 3
+
††4 5
$num
††6 7
,
††7 8
$num
††9 :
,
††: ;
$num
††< ?
)
††? @
;
††@ A
int
‡‡ 
clampedColumns
‡‡ 
=
‡‡  
(
‡‡! "
int
‡‡" %
)
‡‡% &
Mathf
‡‡& +
.
‡‡+ ,
Clamp
‡‡, 1
(
‡‡1 2
columns
‡‡2 9
+
‡‡: ;
$num
‡‡< =
,
‡‡= >
$num
‡‡? @
,
‡‡@ A
$num
‡‡B E
)
‡‡E F
;
‡‡F G
float
ˆˆ 
clampedRadius
ˆˆ 
=
ˆˆ  !
Mathf
ˆˆ" '
.
ˆˆ' (
Clamp
ˆˆ( -
(
ˆˆ- .
innerRadius
ˆˆ. 9
,
ˆˆ9 :
$num
ˆˆ; ?
,
ˆˆ? @
$num
ˆˆA F
)
ˆˆF G
;
ˆˆG H
float
‰‰ 
clampedTubeRadius
‰‰ #
=
‰‰$ %
Mathf
‰‰& +
.
‰‰+ ,
Clamp
‰‰, 1
(
‰‰1 2
outerRadius
‰‰2 =
,
‰‰= >
$num
‰‰? C
,
‰‰C D
clampedRadius
‰‰E R
-
‰‰S T
$num
‰‰U Z
)
‰‰Z [
;
‰‰[ \
clampedRadius
ŠŠ 
-=
ŠŠ 
clampedTubeRadius
ŠŠ .
;
ŠŠ. /
float
‹‹ ,
clampedHorizontalCircumference
‹‹ 0
=
‹‹1 2
Mathf
‹‹3 8
.
‹‹8 9
Clamp
‹‹9 >
(
‹‹> ?%
horizontalCircumference
‹‹? V
,
‹‹V W
$num
‹‹X \
,
‹‹\ ]
$num
‹‹^ b
)
‹‹b c
;
‹‹c d
float
ŒŒ *
clampedVerticalCircumference
ŒŒ .
=
ŒŒ/ 0
Mathf
ŒŒ1 6
.
ŒŒ6 7
Clamp
ŒŒ7 <
(
ŒŒ< =#
verticalCircumference
ŒŒ= R
,
ŒŒR S
$num
ŒŒT X
,
ŒŒX Y
$num
ŒŒZ ^
)
ŒŒ^ _
;
ŒŒ_ `
List
 
<
 
Vector3
 
>
 
vertices
 "
=
# $
new
% (
List
) -
<
- .
Vector3
. 5
>
5 6
(
6 7
)
7 8
;
8 9
int
 
col
 
=
 
clampedColumns
 $
-
% &
$num
' (
;
( )
Vector3
’’ 
[
’’ 
]
’’ 
cir
’’ 
=
’’ 
GetCirclePoints
’’ +
(
’’+ ,
clampedRows
’’, 7
,
’’7 8
clampedTubeRadius
’’9 J
,
’’J K*
clampedVerticalCircumference
’’L h
,
’’h i

Quaternion
’’j t
.
’’t u
Euler
’’u z
(
’’z {
Vector3’’{ ‚
.’’‚ ƒ
up’’ƒ …
*’’† ‡
$num’’ˆ Š
*’’‹ Œ.
clampedHorizontalCircumference’’ «
)’’« ¬
,’’¬ ­
clampedRadius’’® »
)’’» ¼
;’’¼ ½
for
”” 
(
”” 
int
”” 
i
”” 
=
”” 
$num
”” 
;
”” 
i
”” 
<
”” 
clampedColumns
””  .
;
””. /
i
””0 1
++
””1 3
)
””3 4
{
•• 
vertices
–– 
.
–– 
AddRange
–– !
(
––! "
cir
––" %
)
––% &
;
––& '

Quaternion
—— 
rotation
—— #
=
——$ %

Quaternion
——& 0
.
——0 1
Euler
——1 6
(
——6 7
Vector3
——7 >
.
——> ?
up
——? A
*
——B C
(
——D E
(
——E F
i
——F G
/
——H I
(
——J K
float
——K P
)
——P Q
col
——Q T
)
——T U
*
——V W,
clampedHorizontalCircumference
——X v
)
——v w
)
——w x
;
——x y
cir
˜˜ 
=
˜˜ 
GetCirclePoints
˜˜ %
(
˜˜% &
clampedRows
˜˜& 1
,
˜˜1 2
clampedTubeRadius
˜˜3 D
,
˜˜D E*
clampedVerticalCircumference
˜˜F b
,
˜˜b c
rotation
˜˜d l
,
˜˜l m
clampedRadius
˜˜n {
)
˜˜{ |
;
˜˜| }
vertices
™™ 
.
™™ 
AddRange
™™ !
(
™™! "
cir
™™" %
)
™™% &
;
™™& '
}
šš 
List
 
<
 
Face
 
>
 
faces
 
=
 
new
 "
List
# '
<
' (
Face
( ,
>
, -
(
- .
)
. /
;
/ 0
int
 
fc
 
=
 
$num
 
;
 
for
¡¡ 
(
¡¡ 
int
¡¡ 
i
¡¡ 
=
¡¡ 
$num
¡¡ 
;
¡¡ 
i
¡¡ 
<
¡¡ 
(
¡¡  !
clampedColumns
¡¡! /
-
¡¡0 1
$num
¡¡2 3
)
¡¡3 4
*
¡¡5 6
$num
¡¡7 8
;
¡¡8 9
i
¡¡: ;
+=
¡¡< >
$num
¡¡? @
)
¡¡@ A
{
¢¢ 
for
££ 
(
££ 
int
££ 
n
££ 
=
££ 
$num
££ 
;
££ 
n
££  !
<
££" #
clampedRows
££$ /
-
££0 1
$num
££2 3
;
££3 4
n
££5 6
++
££6 8
)
££8 9
{
¤¤ 
int
¥¥ 
a
¥¥ 
=
¥¥ 
(
¥¥ 
i
¥¥ 
+
¥¥  
$num
¥¥! "
)
¥¥" #
*
¥¥$ %
(
¥¥& '
(
¥¥' (
clampedRows
¥¥( 3
-
¥¥4 5
$num
¥¥6 7
)
¥¥7 8
*
¥¥9 :
$num
¥¥; <
)
¥¥< =
+
¥¥> ?
(
¥¥@ A
n
¥¥A B
*
¥¥C D
$num
¥¥E F
)
¥¥F G
;
¥¥G H
int
¦¦ 
b
¦¦ 
=
¦¦ 
(
¦¦ 
i
¦¦ 
+
¦¦  
$num
¦¦! "
)
¦¦" #
*
¦¦$ %
(
¦¦& '
(
¦¦' (
clampedRows
¦¦( 3
-
¦¦4 5
$num
¦¦6 7
)
¦¦7 8
*
¦¦9 :
$num
¦¦; <
)
¦¦< =
+
¦¦> ?
(
¦¦@ A
n
¦¦A B
*
¦¦C D
$num
¦¦E F
)
¦¦F G
;
¦¦G H
int
¨¨ 
c
¨¨ 
=
¨¨ 
(
¨¨ 
i
¨¨ 
+
¨¨  
$num
¨¨! "
)
¨¨" #
*
¨¨$ %
(
¨¨& '
(
¨¨' (
clampedRows
¨¨( 3
-
¨¨4 5
$num
¨¨6 7
)
¨¨7 8
*
¨¨9 :
$num
¨¨; <
)
¨¨< =
+
¨¨> ?
(
¨¨@ A
n
¨¨A B
*
¨¨C D
$num
¨¨E F
)
¨¨F G
+
¨¨H I
$num
¨¨J K
;
¨¨K L
int
©© 
d
©© 
=
©© 
(
©© 
i
©© 
+
©©  
$num
©©! "
)
©©" #
*
©©$ %
(
©©& '
(
©©' (
clampedRows
©©( 3
-
©©4 5
$num
©©6 7
)
©©7 8
*
©©9 :
$num
©©; <
)
©©< =
+
©©> ?
(
©©@ A
n
©©A B
*
©©C D
$num
©©E F
)
©©F G
+
©©H I
$num
©©J K
;
©©K L
faces
«« 
.
«« 
Add
«« 
(
«« 
new
«« !
Face
««" &
(
««& '
new
««' *
int
««+ .
[
««. /
]
««/ 0
{
««1 2
a
««3 4
,
««4 5
b
««6 7
,
««7 8
c
««9 :
,
««: ;
b
««< =
,
««= >
d
««? @
,
««@ A
c
««B C
}
««D E
)
««E F
)
««F G
;
««G H
faces
¬¬ 
[
¬¬ 
fc
¬¬ 
]
¬¬ 
.
¬¬ 
smoothingGroup
¬¬ ,
=
¬¬- .
smooth
¬¬/ 5
?
¬¬6 7
$num
¬¬8 9
:
¬¬: ;
-
¬¬< =
$num
¬¬= >
;
¬¬> ?
faces
­­ 
[
­­ 
fc
­­ 
]
­­ 
.
­­ 
manualUV
­­ &
=
­­' (
	manualUvs
­­) 2
;
­­2 3
fc
¯¯ 
++
¯¯ 
;
¯¯ 
}
°° 
}
±± 
ProBuilderMesh
³³ 
pb
³³ 
=
³³ 
ProBuilderMesh
³³  .
.
³³. /
Create
³³/ 5
(
³³5 6
vertices
³³6 >
.
³³> ?
ToArray
³³? F
(
³³F G
)
³³G H
,
³³H I
faces
³³J O
.
³³O P
ToArray
³³P W
(
³³W X
)
³³X Y
)
³³Y Z
;
³³Z [
pb
´´ 
.
´´ 

gameObject
´´ 
.
´´ 
name
´´ 
=
´´  
$str
´´! (
;
´´( )
pb
µµ 
.
µµ 
SetPivot
µµ 
(
µµ 
	pivotType
µµ !
)
µµ! "
;
µµ" #
return
·· 
pb
·· 
;
·· 
}
¸¸ 	
}
¹¹ 
}ºº œ˜
˜D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ProBuilderMeshSelection.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

sealed 
partial 
class 
ProBuilderMesh  .
{		 
[

 	
SerializeField

	 
]

 
bool 
m_IsSelectable 
= 
true "
;" #
[ 	
SerializeField	 
] 
int 
[ 
] 
m_SelectedFaces 
= 
new  #
int$ '
[' (
]( )
{* +
}+ ,
;, -
[ 	
SerializeField	 
] 
Edge 
[ 
] 
m_SelectedEdges 
=  
new! $
Edge% )
[) *
]* +
{, -
}- .
;. /
[ 	
SerializeField	 
] 
int 
[ 
] 
m_SelectedVertices  
=! "
new# &
int' *
[* +
]+ ,
{- .
}. /
;/ 0
bool  
m_SelectedCacheDirty !
;! "
int )
m_SelectedSharedVerticesCount )
=* +
$num, -
;- .
int +
m_SelectedCoincidentVertexCount +
=, -
$num. /
;/ 0
HashSet 
< 
int 
> $
m_SelectedSharedVertices -
=. /
new0 3
HashSet4 ;
<; <
int< ?
>? @
(@ A
)A B
;B C
List 
< 
int 
> (
m_SelectedCoincidentVertices .
=/ 0
new1 4
List5 9
<9 :
int: =
>= >
(> ?
)? @
;@ A
public 
bool 

selectable 
{ 	
get   
{   
return   
m_IsSelectable   '
;  ' (
}  ) *
set!! 
{!! 
m_IsSelectable!!  
=!!! "
value!!# (
;!!( )
}!!* +
}"" 	
public'' 
int'' 
selectedFaceCount'' $
{(( 	
get)) 
{)) 
return)) 
m_SelectedFaces)) (
.))( )
Length))) /
;))/ 0
}))1 2
}** 	
public// 
int// 
selectedVertexCount// &
{00 	
get11 
{11 
return11 
m_SelectedVertices11 +
.11+ ,
Length11, 2
;112 3
}114 5
}22 	
public77 
int77 
selectedEdgeCount77 $
{88 	
get99 
{99 
return99 
m_SelectedEdges99 (
.99( )
Length99) /
;99/ 0
}991 2
}:: 	
internal<< 
int<< '
selectedSharedVerticesCount<< 0
{== 	
get>> 
{?? 
CacheSelection@@ 
(@@ 
)@@  
;@@  !
returnAA )
m_SelectedSharedVerticesCountAA 4
;AA4 5
}BB 
}CC 	
internalEE 
intEE )
selectedCoincidentVertexCountEE 2
{FF 	
getGG 
{HH 
CacheSelectionII 
(II 
)II  
;II  !
returnJJ +
m_SelectedCoincidentVertexCountJJ 6
;JJ6 7
}KK 
}LL 	
internalNN 
IEnumerableNN 
<NN 
intNN  
>NN  !"
selectedSharedVerticesNN" 8
{OO 	
getPP 
{QQ 
CacheSelectionRR 
(RR 
)RR  
;RR  !
returnSS $
m_SelectedSharedVerticesSS /
;SS/ 0
}TT 
}UU 	
internalZZ 
IEnumerableZZ 
<ZZ 
intZZ  
>ZZ  !&
selectedCoincidentVerticesZZ" <
{[[ 	
get\\ 
{]] 
CacheSelection^^ 
(^^ 
)^^  
;^^  !
return__ (
m_SelectedCoincidentVertices__ 3
;__3 4
}`` 
}aa 	
voidcc 
CacheSelectioncc 
(cc 
)cc 
{dd 	
ifee 
(ee  
m_SelectedCacheDirtyee $
)ee$ %
{ff  
m_SelectedCacheDirtygg $
=gg% &
falsegg' ,
;gg, -$
m_SelectedSharedVerticeshh (
.hh( )
Clearhh) .
(hh. /
)hh/ 0
;hh0 1(
m_SelectedCoincidentVerticesii ,
.ii, -
Clearii- 2
(ii2 3
)ii3 4
;ii4 5
varjj 
lookupjj 
=jj 
sharedVertexLookupjj /
;jj/ 0)
m_SelectedSharedVerticesCountkk -
=kk. /
$numkk0 1
;kk1 2+
m_SelectedCoincidentVertexCountll /
=ll0 1
$numll2 3
;ll3 4
trynn 
{oo 
foreachpp 
(pp 
varpp  
ipp! "
inpp# %
m_SelectedVerticespp& 8
)pp8 9
{qq 
ifrr 
(rr $
m_SelectedSharedVerticesrr 4
.rr4 5
Addrr5 8
(rr8 9
lookuprr9 ?
[rr? @
irr@ A
]rrA B
)rrB C
)rrC D
{ss 
vartt 

coincidenttt  *
=tt+ ,"
sharedVerticesInternaltt- C
[ttC D
lookupttD J
[ttJ K
ittK L
]ttL M
]ttM N
;ttN O)
m_SelectedSharedVerticesCountvv 9
++vv9 ;
;vv; <+
m_SelectedCoincidentVertexCountww ;
+=ww< >

coincidentww? I
.wwI J
CountwwJ O
;wwO P
foreachyy #
(yy$ %
varyy% (
nyy) *
inyy+ -

coincidentyy. 8
)yy8 9(
m_SelectedCoincidentVerticeszz  <
.zz< =
Addzz= @
(zz@ A
nzzA B
)zzB C
;zzC D
}{{ 
}|| 
}}} 
catch~~ 
{ 
ClearSelection
€€ "
(
€€" #
)
€€# $
;
€€$ %
}
 
}
‚‚ 
}
ƒƒ 	
public
ˆˆ 
Face
ˆˆ 
[
ˆˆ 
]
ˆˆ 
GetSelectedFaces
ˆˆ &
(
ˆˆ& '
)
ˆˆ' (
{
‰‰ 	
int
ŠŠ 
len
ŠŠ 
=
ŠŠ 
m_SelectedFaces
ŠŠ %
.
ŠŠ% &
Length
ŠŠ& ,
;
ŠŠ, -
var
‹‹ 
selected
‹‹ 
=
‹‹ 
new
‹‹ 
Face
‹‹ #
[
‹‹# $
len
‹‹$ '
]
‹‹' (
;
‹‹( )
for
ŒŒ 
(
ŒŒ 
var
ŒŒ 
i
ŒŒ 
=
ŒŒ 
$num
ŒŒ 
;
ŒŒ 
i
ŒŒ 
<
ŒŒ 
len
ŒŒ  #
;
ŒŒ# $
i
ŒŒ% &
++
ŒŒ& (
)
ŒŒ( )
selected
 
[
 
i
 
]
 
=
 
m_Faces
 %
[
% &
m_SelectedFaces
& 5
[
5 6
i
6 7
]
7 8
]
8 9
;
9 :
return
 
selected
 
;
 
}
 	
public
””  
ReadOnlyCollection
”” !
<
””! "
int
””" %
>
””% &!
selectedFaceIndexes
””' :
{
•• 	
get
–– 
{
–– 
return
–– 
new
––  
ReadOnlyCollection
–– /
<
––/ 0
int
––0 3
>
––3 4
(
––4 5
m_SelectedFaces
––5 D
)
––D E
;
––E F
}
––G H
}
—— 	
public
œœ  
ReadOnlyCollection
œœ !
<
œœ! "
int
œœ" %
>
œœ% &
selectedVertices
œœ' 7
{
 	
get
 
{
 
return
 
new
  
ReadOnlyCollection
 /
<
/ 0
int
0 3
>
3 4
(
4 5 
m_SelectedVertices
5 G
)
G H
;
H I
}
J K
}
ŸŸ 	
public
¤¤  
ReadOnlyCollection
¤¤ !
<
¤¤! "
Edge
¤¤" &
>
¤¤& '
selectedEdges
¤¤( 5
{
¥¥ 	
get
¦¦ 
{
¦¦ 
return
¦¦ 
new
¦¦  
ReadOnlyCollection
¦¦ /
<
¦¦/ 0
Edge
¦¦0 4
>
¦¦4 5
(
¦¦5 6
m_SelectedEdges
¦¦6 E
)
¦¦E F
;
¦¦F G
}
¦¦H I
}
§§ 	
internal
©© 
Face
©© 
[
©© 
]
©© #
selectedFacesInternal
©© -
{
ªª 	
get
«« 
{
«« 
return
«« 
GetSelectedFaces
«« )
(
««) *
)
««* +
;
««+ ,
}
««- .
set
¬¬ 
{
¬¬ 
m_SelectedFaces
¬¬ !
=
¬¬" #
value
¬¬$ )
.
¬¬) *
Select
¬¬* 0
(
¬¬0 1
x
¬¬1 2
=>
¬¬3 5
Array
¬¬6 ;
.
¬¬; <
IndexOf
¬¬< C
(
¬¬C D
m_Faces
¬¬D K
,
¬¬K L
x
¬¬M N
)
¬¬N O
)
¬¬O P
.
¬¬P Q
ToArray
¬¬Q X
(
¬¬X Y
)
¬¬Y Z
;
¬¬Z [
}
¬¬\ ]
}
­­ 	
internal
¯¯ 
int
¯¯ 
[
¯¯ 
]
¯¯ )
selectedFaceIndicesInternal
¯¯ 2
{
°° 	
get
±± 
{
±± 
return
±± 
m_SelectedFaces
±± (
;
±±( )
}
±±* +
set
²² 
{
²² 
m_SelectedFaces
²² !
=
²²" #
value
²²$ )
;
²²) *
}
²²+ ,
}
³³ 	
internal
µµ 
Edge
µµ 
[
µµ 
]
µµ #
selectedEdgesInternal
µµ -
{
¶¶ 	
get
·· 
{
·· 
return
·· 
m_SelectedEdges
·· (
;
··( )
}
··* +
set
¸¸ 
{
¸¸ 
m_SelectedEdges
¸¸ !
=
¸¸" #
value
¸¸$ )
;
¸¸) *
}
¸¸+ ,
}
¹¹ 	
internal
»» 
int
»» 
[
»» 
]
»» %
selectedIndexesInternal
»» .
{
¼¼ 	
get
½½ 
{
½½ 
return
½½  
m_SelectedVertices
½½ +
;
½½+ ,
}
½½- .
set
¾¾ 
{
¾¾  
m_SelectedVertices
¾¾ $
=
¾¾% &
value
¾¾' ,
;
¾¾, -
}
¾¾. /
}
¿¿ 	
internal
ÁÁ 
Face
ÁÁ 
GetActiveFace
ÁÁ #
(
ÁÁ# $
)
ÁÁ$ %
{
ÂÂ 	
if
ÃÃ 
(
ÃÃ 
selectedFaceCount
ÃÃ !
<
ÃÃ" #
$num
ÃÃ$ %
)
ÃÃ% &
return
ÄÄ 
null
ÄÄ 
;
ÄÄ 
return
ÅÅ 
m_Faces
ÅÅ 
[
ÅÅ )
selectedFaceIndicesInternal
ÅÅ 6
[
ÅÅ6 7
selectedFaceCount
ÅÅ7 H
-
ÅÅI J
$num
ÅÅK L
]
ÅÅL M
]
ÅÅM N
;
ÅÅN O
}
ÆÆ 	
internal
ÈÈ 
Edge
ÈÈ 
GetActiveEdge
ÈÈ #
(
ÈÈ# $
)
ÈÈ$ %
{
ÉÉ 	
if
ÊÊ 
(
ÊÊ 
selectedEdgeCount
ÊÊ !
<
ÊÊ" #
$num
ÊÊ$ %
)
ÊÊ% &
return
ËË 
Edge
ËË 
.
ËË 
Empty
ËË !
;
ËË! "
return
ÌÌ 
m_SelectedEdges
ÌÌ "
[
ÌÌ" #
selectedEdgeCount
ÌÌ# 4
-
ÌÌ5 6
$num
ÌÌ7 8
]
ÌÌ8 9
;
ÌÌ9 :
}
ÍÍ 	
internal
ÏÏ 
int
ÏÏ 
GetActiveVertex
ÏÏ $
(
ÏÏ$ %
)
ÏÏ% &
{
ĞĞ 	
if
ÑÑ 
(
ÑÑ !
selectedVertexCount
ÑÑ #
<
ÑÑ$ %
$num
ÑÑ& '
)
ÑÑ' (
return
ÒÒ 
-
ÒÒ 
$num
ÒÒ 
;
ÒÒ 
return
ÓÓ  
m_SelectedVertices
ÓÓ %
[
ÓÓ% &!
selectedVertexCount
ÓÓ& 9
-
ÓÓ: ;
$num
ÓÓ< =
]
ÓÓ= >
;
ÓÓ> ?
}
ÔÔ 	
internal
ÖÖ 
void
ÖÖ  
AddToFaceSelection
ÖÖ (
(
ÖÖ( )
int
ÖÖ) ,
index
ÖÖ- 2
)
ÖÖ2 3
{
×× 	
if
ØØ 
(
ØØ 
index
ØØ 
>
ØØ 
-
ØØ 
$num
ØØ 
)
ØØ 
SetSelectedFaces
ÙÙ  
(
ÙÙ  !
m_SelectedFaces
ÙÙ! 0
.
ÙÙ0 1
Add
ÙÙ1 4
(
ÙÙ4 5
index
ÙÙ5 :
)
ÙÙ: ;
)
ÙÙ; <
;
ÙÙ< =
}
ÚÚ 	
public
àà 
void
àà 
SetSelectedFaces
àà $
(
àà$ %
IEnumerable
àà% 0
<
àà0 1
Face
àà1 5
>
àà5 6
selected
àà7 ?
)
àà? @
{
áá 	
SetSelectedFaces
ââ 
(
ââ 
selected
ââ %
!=
ââ& (
null
ââ) -
?
ââ. /
selected
ââ0 8
.
ââ8 9
Select
ââ9 ?
(
ââ? @
x
ââ@ A
=>
ââB D
Array
ââE J
.
ââJ K
IndexOf
ââK R
(
ââR S
facesInternal
ââS `
,
ââ` a
x
ââb c
)
ââc d
)
ââd e
:
ââf g
null
ââh l
)
ââl m
;
ââm n
}
ãã 	
internal
åå 
void
åå 
SetSelectedFaces
åå &
(
åå& '
IEnumerable
åå' 2
<
åå2 3
int
åå3 6
>
åå6 7
selected
åå8 @
)
åå@ A
{
ææ 	
if
çç 
(
çç 
selected
çç 
==
çç 
null
çç  
)
çç  !
{
èè 
ClearSelection
éé 
(
éé 
)
éé  
;
éé  !
}
êê 
else
ëë 
{
ìì 
m_SelectedFaces
íí 
=
íí  !
selected
íí" *
.
íí* +
ToArray
íí+ 2
(
íí2 3
)
íí3 4
;
íí4 5 
m_SelectedVertices
îî "
=
îî# $
m_SelectedFaces
îî% 4
.
îî4 5

SelectMany
îî5 ?
(
îî? @
x
îî@ A
=>
îîB D
facesInternal
îîE R
[
îîR S
x
îîS T
]
îîT U
.
îîU V%
distinctIndexesInternal
îîV m
)
îîm n
.
îîn o
ToArray
îîo v
(
îîv w
)
îîw x
;
îîx y
m_SelectedEdges
ïï 
=
ïï  !
m_SelectedFaces
ïï" 1
.
ïï1 2

SelectMany
ïï2 <
(
ïï< =
x
ïï= >
=>
ïï? A
facesInternal
ïïB O
[
ïïO P
x
ïïP Q
]
ïïQ R
.
ïïR S
edges
ïïS X
)
ïïX Y
.
ïïY Z
ToArray
ïïZ a
(
ïïa b
)
ïïb c
;
ïïc d
}
ğğ "
m_SelectedCacheDirty
òò  
=
òò! "
true
òò# '
;
òò' (
if
ôô 
(
ôô %
elementSelectionChanged
ôô '
!=
ôô( *
null
ôô+ /
)
ôô/ 0%
elementSelectionChanged
õõ '
(
õõ' (
this
õõ( ,
)
õõ, -
;
õõ- .
}
öö 	
public
üü 
void
üü 
SetSelectedEdges
üü $
(
üü$ %
IEnumerable
üü% 0
<
üü0 1
Edge
üü1 5
>
üü5 6
edges
üü7 <
)
üü< =
{
ıı 	
if
şş 
(
şş 
edges
şş 
==
şş 
null
şş 
)
şş 
{
ÿÿ 
ClearSelection
€€ 
(
€€ 
)
€€  
;
€€  !
}
 
else
‚‚ 
{
ƒƒ 
m_SelectedFaces
„„ 
=
„„  !
new
„„" %
int
„„& )
[
„„) *
$num
„„* +
]
„„+ ,
;
„„, -
m_SelectedEdges
…… 
=
……  !
edges
……" '
.
……' (
ToArray
……( /
(
……/ 0
)
……0 1
;
……1 2 
m_SelectedVertices
†† "
=
††# $
m_SelectedEdges
††% 4
.
††4 5
AllTriangles
††5 A
(
††A B
)
††B C
;
††C D
}
‡‡ "
m_SelectedCacheDirty
‰‰  
=
‰‰! "
true
‰‰# '
;
‰‰' (
if
‹‹ 
(
‹‹ %
elementSelectionChanged
‹‹ '
!=
‹‹( *
null
‹‹+ /
)
‹‹/ 0%
elementSelectionChanged
ŒŒ '
(
ŒŒ' (
this
ŒŒ( ,
)
ŒŒ, -
;
ŒŒ- .
}
 	
public
““ 
void
““ !
SetSelectedVertices
““ '
(
““' (
IEnumerable
““( 3
<
““3 4
int
““4 7
>
““7 8
vertices
““9 A
)
““A B
{
”” 	
m_SelectedFaces
•• 
=
•• 
new
•• !
int
••" %
[
••% &
$num
••& '
]
••' (
;
••( )
m_SelectedEdges
–– 
=
–– 
new
–– !
Edge
––" &
[
––& '
$num
––' (
]
––( )
;
––) * 
m_SelectedVertices
—— 
=
——  
vertices
——! )
!=
——* ,
null
——- 1
?
——2 3
vertices
——4 <
.
——< =
Distinct
——= E
(
——E F
)
——F G
.
——G H
ToArray
——H O
(
——O P
)
——P Q
:
——R S
new
——T W
int
——X [
[
——[ \
$num
——\ ]
]
——] ^
;
——^ _"
m_SelectedCacheDirty
™™  
=
™™! "
true
™™# '
;
™™' (
if
›› 
(
›› %
elementSelectionChanged
›› '
!=
››( *
null
››+ /
)
››/ 0%
elementSelectionChanged
œœ '
(
œœ' (
this
œœ( ,
)
œœ, -
;
œœ- .
}
 	
internal
££ 
void
££ ,
RemoveFromFaceSelectionAtIndex
££ 4
(
££4 5
int
££5 8
index
££9 >
)
££> ?
{
¤¤ 	
SetSelectedFaces
¥¥ 
(
¥¥ 
m_SelectedFaces
¥¥ ,
.
¥¥, -
RemoveAt
¥¥- 5
(
¥¥5 6
index
¥¥6 ;
)
¥¥; <
)
¥¥< =
;
¥¥= >
}
¦¦ 	
public
«« 
void
«« 
ClearSelection
«« "
(
««" #
)
««# $
{
¬¬ 	
m_SelectedFaces
­­ 
=
­­ 
new
­­ !
int
­­" %
[
­­% &
$num
­­& '
]
­­' (
;
­­( )
m_SelectedEdges
®® 
=
®® 
new
®® !
Edge
®®" &
[
®®& '
$num
®®' (
]
®®( )
;
®®) * 
m_SelectedVertices
¯¯ 
=
¯¯  
new
¯¯! $
int
¯¯% (
[
¯¯( )
$num
¯¯) *
]
¯¯* +
;
¯¯+ ,"
m_SelectedCacheDirty
°°  
=
°°! "
true
°°# '
;
°°' (
}
±± 	
}
²² 
}³³ ¼‹
—D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\MeshImporter.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
[ 
Serializable 
] 
public 

sealed 
class 
MeshImportSettings *
{ 
[ 	
SerializeField	 
] 
bool 
m_Quads 
= 
true 
; 
[ 	
SerializeField	 
] 
bool 
m_Smoothing 
= 
true 
;  
[ 	
SerializeField	 
] 
float  
m_SmoothingThreshold "
=# $
$num% '
;' (
public 
bool 
quads 
{ 	
get 
{ 
return 
m_Quads  
;  !
}" #
set 
{ 
m_Quads 
= 
value !
;! "
}# $
} 	
public'' 
bool'' 
	smoothing'' 
{(( 	
get)) 
{)) 
return)) 
m_Smoothing)) $
;))$ %
}))& '
set** 
{** 
m_Smoothing** 
=** 
value**  %
;**% &
}**' (
}++ 	
public00 
float00 
smoothingAngle00 #
{11 	
get22 
{22 
return22  
m_SmoothingThreshold22 -
;22- .
}22/ 0
set33 
{33  
m_SmoothingThreshold33 &
=33' (
value33) .
;33. /
}330 1
}44 	
public66 
override66 
string66 
ToString66 '
(66' (
)66( )
{77 	
return88 
string88 
.88 
Format88  
(88  !
$str88! M
,88M N
quads99 
,99 
	smoothing:: 
,:: 
smoothingAngle;; 
);; 
;;;  
}<< 	
}== 
publicBB 

sealedBB 
classBB 
MeshImporterBB $
{CC 
staticDD 
readonlyDD 
MeshImportSettingsDD *#
k_DefaultImportSettingsDD+ B
=DDC D
newDDE H
MeshImportSettingsDDI [
(DD[ \
)DD\ ]
{EE 	
quadsFF 
=FF 
trueFF 
,FF 
	smoothingGG 
=GG 
trueGG 
,GG 
smoothingAngleHH 
=HH 
$numHH 
}II 	
;II	 

MeshKK 
m_SourceMeshKK 
;KK 
MaterialLL 
[LL 
]LL 
m_SourceMaterialsLL $
;LL$ %
ProBuilderMeshMM 
m_DestinationMM $
;MM$ %
VertexNN 
[NN 
]NN 

m_VerticesNN 
;NN 
publicPP 
MeshImporterPP 
(PP 

GameObjectPP &

gameObjectPP' 1
)PP1 2
{QQ 	

MeshFilterRR 

meshFilterRR !
=RR" #

gameObjectRR$ .
.RR. /
GetComponentRR/ ;
<RR; <

MeshFilterRR< F
>RRF G
(RRG H
)RRH I
;RRI J
m_SourceMeshSS 
=SS 

meshFilterSS %
.SS% &

sharedMeshSS& 0
;SS0 1
ifTT 
(TT 
m_SourceMeshTT 
==TT 
nullTT #
)TT# $
throwUU 
newUU !
ArgumentNullExceptionUU /
(UU/ 0
$strUU0 <
,UU< =
$strUU> z
)UUz {
;UU{ |
m_DestinationVV 
=VV 

gameObjectVV &
.VV& '
DemandComponentVV' 6
<VV6 7
ProBuilderMeshVV7 E
>VVE F
(VVF G
)VVG H
;VVH I
m_SourceMaterialsWW 
=WW 

gameObjectWW  *
.WW* +
GetComponentWW+ 7
<WW7 8
MeshRendererWW8 D
>WWD E
(WWE F
)WWF G
?WWG H
.WWH I
sharedMaterialsWWI X
;WWX Y
}XX 	
public`` 
MeshImporter`` 
(`` 
Mesh``  

sourceMesh``! +
,``+ ,
Material``- 5
[``5 6
]``6 7
sourceMaterials``8 G
,``G H
ProBuilderMesh``I W
destination``X c
)``c d
{aa 	
ifbb 
(bb 

sourceMeshbb 
==bb 
nullbb !
)bb! "
throwcc 
newcc !
ArgumentNullExceptioncc /
(cc/ 0
$strcc0 <
)cc< =
;cc= >
ifdd 
(dd 
destinationdd 
==dd 
nulldd "
)dd" #
throwee 
newee !
ArgumentNullExceptionee /
(ee/ 0
$stree0 =
)ee= >
;ee> ?
m_SourceMeshff 
=ff 

sourceMeshff %
;ff% &
m_SourceMaterialsgg 
=gg 
sourceMaterialsgg  /
;gg/ 0
m_Destinationhh 
=hh 
destinationhh '
;hh' (
}ii 	
[kk 	
Obsoletekk	 
,kk 
EditorBrowsablekk "
(kk" # 
EditorBrowsableStatekk# 7
.kk7 8
Neverkk8 =
)kk= >
]kk> ?
publicll 
MeshImporterll 
(ll 
ProBuilderMeshll *
destinationll+ 6
)ll6 7
{mm 	
m_Destinationnn 
=nn 
destinationnn '
;nn' (
}oo 	
[qq 	
Obsoleteqq	 
,qq 
EditorBrowsableqq "
(qq" # 
EditorBrowsableStateqq# 7
.qq7 8
Neverqq8 =
)qq= >
]qq> ?
publicrr 
boolrr 
Importrr 
(rr 

GameObjectrr %
gorr& (
,rr( )
MeshImportSettingsrr* <
importSettingsrr= K
=rrL M
nullrrN R
)rrR S
{ss 	
trytt 
{uu 
m_SourceMeshvv 
=vv 
govv !
.vv! "
GetComponentvv" .
<vv. /

MeshFiltervv/ 9
>vv9 :
(vv: ;
)vv; <
.vv< =

sharedMeshvv= G
;vvG H
m_SourceMaterialsww !
=ww" #
goww$ &
.ww& '
GetComponentww' 3
<ww3 4
MeshRendererww4 @
>ww@ A
(wwA B
)wwB C
?wwC D
.wwD E
sharedMaterialswwE T
;wwT U
Importxx 
(xx 
importSettingsxx %
)xx% &
;xx& '
}yy 
catchzz 
(zz 
	Exceptionzz 
ezz 
)zz 
{{{ 
Log|| 
.|| 
Error|| 
(|| 
e|| 
.|| 
ToString|| $
(||$ %
)||% &
)||& '
;||' (
return}} 
false}} 
;}} 
}~~ 
return
€€ 
true
€€ 
;
€€ 
}
 	
public
ŠŠ 
void
ŠŠ 
Import
ŠŠ 
(
ŠŠ  
MeshImportSettings
ŠŠ -
importSettings
ŠŠ. <
=
ŠŠ= >
null
ŠŠ? C
)
ŠŠC D
{
‹‹ 	
if
ŒŒ 
(
ŒŒ 
importSettings
ŒŒ 
==
ŒŒ !
null
ŒŒ" &
)
ŒŒ& '
importSettings
 
=
  %
k_DefaultImportSettings
! 8
;
8 9
Vertex
’’ 
[
’’ 
]
’’ 
sourceVertices
’’ #
=
’’$ %
m_SourceMesh
’’& 2
.
’’2 3
GetVertices
’’3 >
(
’’> ?
)
’’? @
;
’’@ A
List
““ 
<
““ 
Vertex
““ 
>
““ 
splitVertices
““ &
=
““' (
new
““) ,
List
““- 1
<
““1 2
Vertex
““2 8
>
““8 9
(
““9 :
)
““: ;
;
““; <
List
”” 
<
”” 
Face
”” 
>
”” 
faces
”” 
=
”” 
new
”” "
List
””# '
<
””' (
Face
””( ,
>
””, -
(
””- .
)
””. /
;
””/ 0
int
˜˜ 
vertexIndex
˜˜ 
=
˜˜ 
$num
˜˜ 
;
˜˜  
int
™™ 
materialCount
™™ 
=
™™ 
m_SourceMaterials
™™  1
!=
™™2 4
null
™™5 9
?
™™: ;
m_SourceMaterials
™™< M
.
™™M N
Length
™™N T
:
™™U V
$num
™™W X
;
™™X Y
for
›› 
(
›› 
int
›› 
submeshIndex
›› !
=
››" #
$num
››$ %
;
››% &
submeshIndex
››' 3
<
››4 5
m_SourceMesh
››6 B
.
››B C
subMeshCount
››C O
;
››O P
submeshIndex
››Q ]
++
››] _
)
››_ `
{
œœ 
switch
 
(
 
m_SourceMesh
 $
.
$ %
GetTopology
% 0
(
0 1
submeshIndex
1 =
)
= >
)
> ?
{
 
case
ŸŸ 
MeshTopology
ŸŸ %
.
ŸŸ% &
	Triangles
ŸŸ& /
:
ŸŸ/ 0
{
   
int
¡¡ 
[
¡¡ 
]
¡¡ 
indexes
¡¡ %
=
¡¡& '
m_SourceMesh
¡¡( 4
.
¡¡4 5

GetIndices
¡¡5 ?
(
¡¡? @
submeshIndex
¡¡@ L
)
¡¡L M
;
¡¡M N
for
££ 
(
££ 
int
££  
tri
££! $
=
££% &
$num
££' (
;
££( )
tri
££* -
<
££. /
indexes
££0 7
.
££7 8
Length
££8 >
;
££> ?
tri
££@ C
+=
££D F
$num
££G H
)
££H I
{
¤¤ 
faces
¥¥ !
.
¥¥! "
Add
¥¥" %
(
¥¥% &
new
¥¥& )
Face
¥¥* .
(
¥¥. /
new
¦¦$ '
int
¦¦( +
[
¦¦+ ,
]
¦¦, -
{
¦¦. /
vertexIndex
¦¦0 ;
,
¦¦; <
vertexIndex
¦¦= H
+
¦¦I J
$num
¦¦K L
,
¦¦L M
vertexIndex
¦¦N Y
+
¦¦Z [
$num
¦¦\ ]
}
¦¦^ _
,
¦¦_ `
Math
§§$ (
.
§§( )
Clamp
§§) .
(
§§. /
submeshIndex
§§/ ;
,
§§; <
$num
§§= >
,
§§> ?
materialCount
§§@ M
-
§§N O
$num
§§P Q
)
§§Q R
,
§§R S 
AutoUnwrapSettings
¨¨$ 6
.
¨¨6 7
tile
¨¨7 ;
,
¨¨; <
	Smoothing
©©$ -
.
©©- . 
smoothingGroupNone
©©. @
,
©©@ A
-
ªª$ %
$num
ªª% &
,
ªª& '
-
««$ %
$num
««% &
,
««& '
true
¬¬$ (
)
¬¬( )
)
¬¬) *
;
¬¬* +
splitVertices
®® )
.
®®) *
Add
®®* -
(
®®- .
sourceVertices
®®. <
[
®®< =
indexes
®®= D
[
®®D E
tri
®®E H
]
®®H I
]
®®I J
)
®®J K
;
®®K L
splitVertices
¯¯ )
.
¯¯) *
Add
¯¯* -
(
¯¯- .
sourceVertices
¯¯. <
[
¯¯< =
indexes
¯¯= D
[
¯¯D E
tri
¯¯E H
+
¯¯I J
$num
¯¯K L
]
¯¯L M
]
¯¯M N
)
¯¯N O
;
¯¯O P
splitVertices
°° )
.
°°) *
Add
°°* -
(
°°- .
sourceVertices
°°. <
[
°°< =
indexes
°°= D
[
°°D E
tri
°°E H
+
°°I J
$num
°°K L
]
°°L M
]
°°M N
)
°°N O
;
°°O P
vertexIndex
²² '
+=
²²( *
$num
²²+ ,
;
²², -
}
³³ 
}
´´ 
break
µµ 
;
µµ 
case
·· 
MeshTopology
·· %
.
··% &
Quads
··& +
:
··+ ,
{
¸¸ 
int
¹¹ 
[
¹¹ 
]
¹¹ 
indexes
¹¹ %
=
¹¹& '
m_SourceMesh
¹¹( 4
.
¹¹4 5

GetIndices
¹¹5 ?
(
¹¹? @
submeshIndex
¹¹@ L
)
¹¹L M
;
¹¹M N
for
»» 
(
»» 
int
»»  
quad
»»! %
=
»»& '
$num
»»( )
;
»») *
quad
»»+ /
<
»»0 1
indexes
»»2 9
.
»»9 :
Length
»»: @
;
»»@ A
quad
»»B F
+=
»»G I
$num
»»J K
)
»»K L
{
¼¼ 
faces
½½ !
.
½½! "
Add
½½" %
(
½½% &
new
½½& )
Face
½½* .
(
½½. /
new
½½/ 2
int
½½3 6
[
½½6 7
]
½½7 8
{
¾¾  !
vertexIndex
¿¿$ /
,
¿¿/ 0
vertexIndex
¿¿1 <
+
¿¿= >
$num
¿¿? @
,
¿¿@ A
vertexIndex
¿¿B M
+
¿¿N O
$num
¿¿P Q
,
¿¿Q R
vertexIndex
ÀÀ$ /
+
ÀÀ0 1
$num
ÀÀ2 3
,
ÀÀ3 4
vertexIndex
ÀÀ5 @
+
ÀÀA B
$num
ÀÀC D
,
ÀÀD E
vertexIndex
ÀÀF Q
+
ÀÀR S
$num
ÀÀT U
}
ÁÁ  !
,
ÁÁ! "
Math
ÂÂ  $
.
ÂÂ$ %
Clamp
ÂÂ% *
(
ÂÂ* +
submeshIndex
ÂÂ+ 7
,
ÂÂ7 8
$num
ÂÂ9 :
,
ÂÂ: ;
materialCount
ÂÂ< I
-
ÂÂJ K
$num
ÂÂL M
)
ÂÂM N
,
ÂÂN O 
AutoUnwrapSettings
ÃÃ  2
.
ÃÃ2 3
tile
ÃÃ3 7
,
ÃÃ7 8
	Smoothing
ÄÄ  )
.
ÄÄ) * 
smoothingGroupNone
ÄÄ* <
,
ÄÄ< =
-
ÅÅ  !
$num
ÅÅ! "
,
ÅÅ" #
-
ÆÆ  !
$num
ÆÆ! "
,
ÆÆ" #
true
ÇÇ  $
)
ÇÇ$ %
)
ÇÇ% &
;
ÇÇ& '
splitVertices
ÉÉ )
.
ÉÉ) *
Add
ÉÉ* -
(
ÉÉ- .
sourceVertices
ÉÉ. <
[
ÉÉ< =
indexes
ÉÉ= D
[
ÉÉD E
quad
ÉÉE I
]
ÉÉI J
]
ÉÉJ K
)
ÉÉK L
;
ÉÉL M
splitVertices
ÊÊ )
.
ÊÊ) *
Add
ÊÊ* -
(
ÊÊ- .
sourceVertices
ÊÊ. <
[
ÊÊ< =
indexes
ÊÊ= D
[
ÊÊD E
quad
ÊÊE I
+
ÊÊJ K
$num
ÊÊL M
]
ÊÊM N
]
ÊÊN O
)
ÊÊO P
;
ÊÊP Q
splitVertices
ËË )
.
ËË) *
Add
ËË* -
(
ËË- .
sourceVertices
ËË. <
[
ËË< =
indexes
ËË= D
[
ËËD E
quad
ËËE I
+
ËËJ K
$num
ËËL M
]
ËËM N
]
ËËN O
)
ËËO P
;
ËËP Q
splitVertices
ÌÌ )
.
ÌÌ) *
Add
ÌÌ* -
(
ÌÌ- .
sourceVertices
ÌÌ. <
[
ÌÌ< =
indexes
ÌÌ= D
[
ÌÌD E
quad
ÌÌE I
+
ÌÌJ K
$num
ÌÌL M
]
ÌÌM N
]
ÌÌN O
)
ÌÌO P
;
ÌÌP Q
vertexIndex
ÎÎ '
+=
ÎÎ( *
$num
ÎÎ+ ,
;
ÎÎ, -
}
ÏÏ 
}
ĞĞ 
break
ÑÑ 
;
ÑÑ 
default
ÓÓ 
:
ÓÓ 
throw
ÔÔ 
new
ÔÔ !#
NotSupportedException
ÔÔ" 7
(
ÔÔ7 8
$str
ÔÔ8 v
)
ÔÔv w
;
ÔÔw x
}
ÕÕ 
}
ÖÖ 

m_Vertices
ØØ 
=
ØØ 
splitVertices
ØØ &
.
ØØ& '
ToArray
ØØ' .
(
ØØ. /
)
ØØ/ 0
;
ØØ0 1
m_Destination
ÚÚ 
.
ÚÚ 
Clear
ÚÚ 
(
ÚÚ  
)
ÚÚ  !
;
ÚÚ! "
m_Destination
ÛÛ 
.
ÛÛ 
SetVertices
ÛÛ %
(
ÛÛ% &

m_Vertices
ÛÛ& 0
)
ÛÛ0 1
;
ÛÛ1 2
m_Destination
ÜÜ 
.
ÜÜ 
faces
ÜÜ 
=
ÜÜ  !
faces
ÜÜ" '
;
ÜÜ' (
m_Destination
İİ 
.
İİ 
sharedVertices
İİ (
=
İİ) *
SharedVertex
İİ+ 7
.
İİ7 8,
GetSharedVerticesWithPositions
İİ8 V
(
İİV W
m_Destination
İİW d
.
İİd e
positionsInternal
İİe v
)
İİv w
;
İİw x
m_Destination
ŞŞ 
.
ŞŞ 
sharedTextures
ŞŞ (
=
ŞŞ) *
new
ŞŞ+ .
SharedVertex
ŞŞ/ ;
[
ŞŞ; <
$num
ŞŞ< =
]
ŞŞ= >
;
ŞŞ> ?
HashSet
àà 
<
àà 
Face
àà 
>
àà 
	processed
àà #
=
àà$ %
new
àà& )
HashSet
àà* 1
<
àà1 2
Face
àà2 6
>
àà6 7
(
àà7 8
)
àà8 9
;
àà9 :
if
ââ 
(
ââ 
importSettings
ââ 
.
ââ 
quads
ââ $
)
ââ$ %
{
ãã 
List
ää 
<
ää 

WingedEdge
ää 
>
ää  
wings
ää! &
=
ää' (

WingedEdge
ää) 3
.
ää3 4
GetWingedEdges
ää4 B
(
ääB C
m_Destination
ääC P
,
ääP Q
m_Destination
ääR _
.
ää_ `
facesInternal
ää` m
,
ääm n
true
ääo s
)
ääs t
;
äät u

Dictionary
çç 
<
çç 

EdgeLookup
çç %
,
çç% &
float
çç' ,
>
çç, -
connections
çç. 9
=
çç: ;
new
çç< ?

Dictionary
çç@ J
<
ççJ K

EdgeLookup
ççK U
,
ççU V
float
ççW \
>
çç\ ]
(
çç] ^
)
çç^ _
;
çç_ `
for
éé 
(
éé 
int
éé 
i
éé 
=
éé 
$num
éé 
;
éé 
i
éé  !
<
éé" #
wings
éé$ )
.
éé) *
Count
éé* /
;
éé/ 0
i
éé1 2
++
éé2 4
)
éé4 5
{
êê 
using
ëë 
(
ëë 
var
ëë 
it
ëë !
=
ëë" #
new
ëë$ '"
WingedEdgeEnumerator
ëë( <
(
ëë< =
wings
ëë= B
[
ëëB C
i
ëëC D
]
ëëD E
)
ëëE F
)
ëëF G
{
ìì 
while
íí 
(
íí 
it
íí !
.
íí! "
MoveNext
íí" *
(
íí* +
)
íí+ ,
)
íí, -
{
îî 
var
ïï 
border
ïï  &
=
ïï' (
it
ïï) +
.
ïï+ ,
Current
ïï, 3
;
ïï3 4
if
ññ 
(
ññ  
border
ññ  &
.
ññ& '
opposite
ññ' /
!=
ññ0 2
null
ññ3 7
&&
ññ8 :
!
ññ; <
connections
ññ< G
.
ññG H
ContainsKey
ññH S
(
ññS T
border
ññT Z
.
ññZ [
edge
ññ[ _
)
ññ_ `
)
ññ` a
{
òò 
float
óó  %
score
óó& +
=
óó, -
GetQuadScore
óó. :
(
óó: ;
border
óó; A
,
óóA B
border
óóC I
.
óóI J
opposite
óóJ R
)
óóR S
;
óóS T
connections
ôô  +
.
ôô+ ,
Add
ôô, /
(
ôô/ 0
border
ôô0 6
.
ôô6 7
edge
ôô7 ;
,
ôô; <
score
ôô= B
)
ôôB C
;
ôôC D
}
õõ 
}
öö 
}
÷÷ 
}
øø 
List
úú 
<
úú 
SimpleTuple
úú  
<
úú  !
Face
úú! %
,
úú% &
Face
úú' +
>
úú+ ,
>
úú, -
quads
úú. 3
=
úú4 5
new
úú6 9
List
úú: >
<
úú> ?
SimpleTuple
úú? J
<
úúJ K
Face
úúK O
,
úúO P
Face
úúQ U
>
úúU V
>
úúV W
(
úúW X
)
úúX Y
;
úúY Z
foreach
ıı 
(
ıı 

WingedEdge
ıı #
face
ıı$ (
in
ıı) +
wings
ıı, 1
)
ıı1 2
{
şş 
if
ÿÿ 
(
ÿÿ 
!
ÿÿ 
	processed
ÿÿ "
.
ÿÿ" #
Add
ÿÿ# &
(
ÿÿ& '
face
ÿÿ' +
.
ÿÿ+ ,
face
ÿÿ, 0
)
ÿÿ0 1
)
ÿÿ1 2
continue
€€  
;
€€  !
float
‚‚ 
	bestScore
‚‚ #
=
‚‚$ %
$num
‚‚& (
;
‚‚( )
Face
ƒƒ 
buddy
ƒƒ 
=
ƒƒ  
null
ƒƒ! %
;
ƒƒ% &
using
…… 
(
…… 
var
…… 
it
…… !
=
……" #
new
……$ '"
WingedEdgeEnumerator
……( <
(
……< =
face
……= A
)
……A B
)
……B C
{
†† 
while
‡‡ 
(
‡‡ 
it
‡‡ !
.
‡‡! "
MoveNext
‡‡" *
(
‡‡* +
)
‡‡+ ,
)
‡‡, -
{
ˆˆ 
var
‰‰ 
border
‰‰  &
=
‰‰' (
it
‰‰) +
.
‰‰+ ,
Current
‰‰, 3
;
‰‰3 4
if
‹‹ 
(
‹‹  
border
‹‹  &
.
‹‹& '
opposite
‹‹' /
!=
‹‹0 2
null
‹‹3 7
&&
‹‹8 :
	processed
‹‹; D
.
‹‹D E
Contains
‹‹E M
(
‹‹M N
border
‹‹N T
.
‹‹T U
opposite
‹‹U ]
.
‹‹] ^
face
‹‹^ b
)
‹‹b c
)
‹‹c d
continue
ŒŒ  (
;
ŒŒ( )
float
 !
borderScore
" -
;
- .
if
‘‘ 
(
‘‘  
connections
‘‘  +
.
‘‘+ ,
TryGetValue
‘‘, 7
(
‘‘7 8
border
‘‘8 >
.
‘‘> ?
edge
‘‘? C
,
‘‘C D
out
‘‘E H
borderScore
‘‘I T
)
‘‘T U
&&
‘‘V X
borderScore
’’  +
>
’’, -
	bestScore
’’. 7
&&
’’8 :
face
““  $
.
““$ %
face
““% )
==
““* ,#
GetBestQuadConnection
““- B
(
““B C
border
““C I
.
““I J
opposite
““J R
,
““R S
connections
““T _
)
““_ `
)
““` a
{
”” 
	bestScore
••  )
=
••* +
borderScore
••, 7
;
••7 8
buddy
––  %
=
––& '
border
––( .
.
––. /
opposite
––/ 7
.
––7 8
face
––8 <
;
––< =
}
—— 
}
˜˜ 
}
™™ 
if
›› 
(
›› 
buddy
›› 
!=
››  
null
››! %
)
››% &
{
œœ 
	processed
 !
.
! "
Add
" %
(
% &
buddy
& +
)
+ ,
;
, -
quads
 
.
 
Add
 !
(
! "
new
" %
SimpleTuple
& 1
<
1 2
Face
2 6
,
6 7
Face
8 <
>
< =
(
= >
face
> B
.
B C
face
C G
,
G H
buddy
I N
)
N O
)
O P
;
P Q
}
ŸŸ 
}
   
MergeElements
££ 
.
££ 

MergePairs
££ (
(
££( )
m_Destination
££) 6
,
££6 7
quads
££8 =
,
££= >
!
££? @
importSettings
££@ N
.
££N O
	smoothing
££O X
)
££X Y
;
££Y Z
}
¤¤ 
if
¦¦ 
(
¦¦ 
importSettings
¦¦ 
.
¦¦ 
	smoothing
¦¦ (
)
¦¦( )
{
§§ 
	Smoothing
¨¨ 
.
¨¨ "
ApplySmoothingGroups
¨¨ .
(
¨¨. /
m_Destination
¨¨/ <
,
¨¨< =
m_Destination
¨¨> K
.
¨¨K L
facesInternal
¨¨L Y
,
¨¨Y Z
importSettings
¨¨[ i
.
¨¨i j
smoothingAngle
¨¨j x
,
¨¨x y

m_Vertices¨¨z „
.¨¨„ …
Select¨¨… ‹
(¨¨‹ Œ
x¨¨Œ 
=>¨¨ 
x¨¨‘ ’
.¨¨’ “
normal¨¨“ ™
)¨¨™ š
.¨¨š ›
ToArray¨¨› ¢
(¨¨¢ £
)¨¨£ ¤
)¨¨¤ ¥
;¨¨¥ ¦
MergeElements
ªª 
.
ªª (
CollapseCoincidentVertices
ªª 8
(
ªª8 9
m_Destination
ªª9 F
,
ªªF G
m_Destination
ªªH U
.
ªªU V
facesInternal
ªªV c
)
ªªc d
;
ªªd e
}
«« 
}
¬¬ 	
static
®® 
Face
®® #
GetBestQuadConnection
®® )
(
®®) *

WingedEdge
®®* 4
wing
®®5 9
,
®®9 :

Dictionary
®®; E
<
®®E F

EdgeLookup
®®F P
,
®®P Q
float
®®R W
>
®®W X
connections
®®Y d
)
®®d e
{
¯¯ 	
float
°° 
score
°° 
=
°° 
$num
°° 
;
°° 
Face
±± 
face
±± 
=
±± 
null
±± 
;
±± 
using
³³ 
(
³³ 
var
³³ 
it
³³ 
=
³³ 
new
³³ "
WingedEdgeEnumerator
³³  4
(
³³4 5
wing
³³5 9
)
³³9 :
)
³³: ;
{
´´ 
while
µµ 
(
µµ 
it
µµ 
.
µµ 
MoveNext
µµ "
(
µµ" #
)
µµ# $
)
µµ$ %
{
¶¶ 
var
·· 
border
·· 
=
··  
it
··! #
.
··# $
Current
··$ +
;
··+ ,
float
¹¹ 
s
¹¹ 
=
¹¹ 
$num
¹¹  
;
¹¹  !
if
»» 
(
»» 
connections
»» #
.
»»# $
TryGetValue
»»$ /
(
»»/ 0
border
»»0 6
.
»»6 7
edge
»»7 ;
,
»»; <
out
»»= @
s
»»A B
)
»»B C
&&
»»D F
s
»»G H
>
»»I J
score
»»K P
)
»»P Q
{
¼¼ 
score
½½ 
=
½½ 
connections
½½  +
[
½½+ ,
border
½½, 2
.
½½2 3
edge
½½3 7
]
½½7 8
;
½½8 9
face
¾¾ 
=
¾¾ 
border
¾¾ %
.
¾¾% &
opposite
¾¾& .
.
¾¾. /
face
¾¾/ 3
;
¾¾3 4
}
¿¿ 
}
ÀÀ 
}
ÁÁ 
return
ÃÃ 
face
ÃÃ 
;
ÃÃ 
}
ÄÄ 	
float
ËË 
GetQuadScore
ËË 
(
ËË 

WingedEdge
ËË %
left
ËË& *
,
ËË* +

WingedEdge
ËË, 6
right
ËË7 <
,
ËË< =
float
ËË> C
normalThreshold
ËËD S
=
ËËT U
$num
ËËV Y
)
ËËY Z
{
ÌÌ 	
int
ÍÍ 
[
ÍÍ 
]
ÍÍ 
quad
ÍÍ 
=
ÍÍ 

WingedEdge
ÍÍ #
.
ÍÍ# $
MakeQuad
ÍÍ$ ,
(
ÍÍ, -
left
ÍÍ- 1
,
ÍÍ1 2
right
ÍÍ3 8
)
ÍÍ8 9
;
ÍÍ9 :
if
ÏÏ 
(
ÏÏ 
quad
ÏÏ 
==
ÏÏ 
null
ÏÏ 
)
ÏÏ 
return
ĞĞ 
$num
ĞĞ 
;
ĞĞ 
Vector3
ÓÓ 

leftNormal
ÓÓ 
=
ÓÓ  
Math
ÓÓ! %
.
ÓÓ% &
Normal
ÓÓ& ,
(
ÓÓ, -

m_Vertices
ÓÓ- 7
[
ÓÓ7 8
quad
ÓÓ8 <
[
ÓÓ< =
$num
ÓÓ= >
]
ÓÓ> ?
]
ÓÓ? @
.
ÓÓ@ A
position
ÓÓA I
,
ÓÓI J

m_Vertices
ÓÓK U
[
ÓÓU V
quad
ÓÓV Z
[
ÓÓZ [
$num
ÓÓ[ \
]
ÓÓ\ ]
]
ÓÓ] ^
.
ÓÓ^ _
position
ÓÓ_ g
,
ÓÓg h

m_Vertices
ÓÓi s
[
ÓÓs t
quad
ÓÓt x
[
ÓÓx y
$num
ÓÓy z
]
ÓÓz {
]
ÓÓ{ |
.
ÓÓ| }
positionÓÓ} …
)ÓÓ… †
;ÓÓ† ‡
Vector3
ÔÔ 
rightNormal
ÔÔ 
=
ÔÔ  !
Math
ÔÔ" &
.
ÔÔ& '
Normal
ÔÔ' -
(
ÔÔ- .

m_Vertices
ÔÔ. 8
[
ÔÔ8 9
quad
ÔÔ9 =
[
ÔÔ= >
$num
ÔÔ> ?
]
ÔÔ? @
]
ÔÔ@ A
.
ÔÔA B
position
ÔÔB J
,
ÔÔJ K

m_Vertices
ÔÔL V
[
ÔÔV W
quad
ÔÔW [
[
ÔÔ[ \
$num
ÔÔ\ ]
]
ÔÔ] ^
]
ÔÔ^ _
.
ÔÔ_ `
position
ÔÔ` h
,
ÔÔh i

m_Vertices
ÔÔj t
[
ÔÔt u
quad
ÔÔu y
[
ÔÔy z
$num
ÔÔz {
]
ÔÔ{ |
]
ÔÔ| }
.
ÔÔ} ~
positionÔÔ~ †
)ÔÔ† ‡
;ÔÔ‡ ˆ
float
ÖÖ 
score
ÖÖ 
=
ÖÖ 
Vector3
ÖÖ !
.
ÖÖ! "
Dot
ÖÖ" %
(
ÖÖ% &

leftNormal
ÖÖ& 0
,
ÖÖ0 1
rightNormal
ÖÖ2 =
)
ÖÖ= >
;
ÖÖ> ?
if
ØØ 
(
ØØ 
score
ØØ 
<
ØØ 
normalThreshold
ØØ '
)
ØØ' (
return
ÙÙ 
$num
ÙÙ 
;
ÙÙ 
Vector3
ÜÜ 
a
ÜÜ 
=
ÜÜ 
(
ÜÜ 

m_Vertices
ÜÜ #
[
ÜÜ# $
quad
ÜÜ$ (
[
ÜÜ( )
$num
ÜÜ) *
]
ÜÜ* +
]
ÜÜ+ ,
.
ÜÜ, -
position
ÜÜ- 5
-
ÜÜ6 7

m_Vertices
ÜÜ8 B
[
ÜÜB C
quad
ÜÜC G
[
ÜÜG H
$num
ÜÜH I
]
ÜÜI J
]
ÜÜJ K
.
ÜÜK L
position
ÜÜL T
)
ÜÜT U
;
ÜÜU V
Vector3
İİ 
b
İİ 
=
İİ 
(
İİ 

m_Vertices
İİ #
[
İİ# $
quad
İİ$ (
[
İİ( )
$num
İİ) *
]
İİ* +
]
İİ+ ,
.
İİ, -
position
İİ- 5
-
İİ6 7

m_Vertices
İİ8 B
[
İİB C
quad
İİC G
[
İİG H
$num
İİH I
]
İİI J
]
İİJ K
.
İİK L
position
İİL T
)
İİT U
;
İİU V
Vector3
ŞŞ 
c
ŞŞ 
=
ŞŞ 
(
ŞŞ 

m_Vertices
ŞŞ #
[
ŞŞ# $
quad
ŞŞ$ (
[
ŞŞ( )
$num
ŞŞ) *
]
ŞŞ* +
]
ŞŞ+ ,
.
ŞŞ, -
position
ŞŞ- 5
-
ŞŞ6 7

m_Vertices
ŞŞ8 B
[
ŞŞB C
quad
ŞŞC G
[
ŞŞG H
$num
ŞŞH I
]
ŞŞI J
]
ŞŞJ K
.
ŞŞK L
position
ŞŞL T
)
ŞŞT U
;
ŞŞU V
Vector3
ßß 
d
ßß 
=
ßß 
(
ßß 

m_Vertices
ßß #
[
ßß# $
quad
ßß$ (
[
ßß( )
$num
ßß) *
]
ßß* +
]
ßß+ ,
.
ßß, -
position
ßß- 5
-
ßß6 7

m_Vertices
ßß8 B
[
ßßB C
quad
ßßC G
[
ßßG H
$num
ßßH I
]
ßßI J
]
ßßJ K
.
ßßK L
position
ßßL T
)
ßßT U
;
ßßU V
a
áá 
.
áá 
	Normalize
áá 
(
áá 
)
áá 
;
áá 
b
ââ 
.
ââ 
	Normalize
ââ 
(
ââ 
)
ââ 
;
ââ 
c
ãã 
.
ãã 
	Normalize
ãã 
(
ãã 
)
ãã 
;
ãã 
d
ää 
.
ää 
	Normalize
ää 
(
ää 
)
ää 
;
ää 
float
ææ 
da
ææ 
=
ææ 
Mathf
ææ 
.
ææ 
Abs
ææ  
(
ææ  !
Vector3
ææ! (
.
ææ( )
Dot
ææ) ,
(
ææ, -
a
ææ- .
,
ææ. /
b
ææ0 1
)
ææ1 2
)
ææ2 3
;
ææ3 4
float
çç 
db
çç 
=
çç 
Mathf
çç 
.
çç 
Abs
çç  
(
çç  !
Vector3
çç! (
.
çç( )
Dot
çç) ,
(
çç, -
b
çç- .
,
çç. /
c
çç0 1
)
çç1 2
)
çç2 3
;
çç3 4
float
èè 
dc
èè 
=
èè 
Mathf
èè 
.
èè 
Abs
èè  
(
èè  !
Vector3
èè! (
.
èè( )
Dot
èè) ,
(
èè, -
c
èè- .
,
èè. /
d
èè0 1
)
èè1 2
)
èè2 3
;
èè3 4
float
éé 
dd
éé 
=
éé 
Mathf
éé 
.
éé 
Abs
éé  
(
éé  !
Vector3
éé! (
.
éé( )
Dot
éé) ,
(
éé, -
d
éé- .
,
éé. /
a
éé0 1
)
éé1 2
)
éé2 3
;
éé3 4
score
ëë 
+=
ëë 
$num
ëë 
-
ëë 
(
ëë 
(
ëë 
da
ëë 
+
ëë  
db
ëë! #
+
ëë$ %
dc
ëë& (
+
ëë) *
dd
ëë+ -
)
ëë- .
*
ëë/ 0
$num
ëë1 5
)
ëë5 6
;
ëë6 7
score
îî 
+=
îî 
Mathf
îî 
.
îî 
Abs
îî 
(
îî 
Vector3
îî &
.
îî& '
Dot
îî' *
(
îî* +
a
îî+ ,
,
îî, -
c
îî. /
)
îî/ 0
)
îî0 1
*
îî2 3
$num
îî4 7
;
îî7 8
score
ïï 
+=
ïï 
Mathf
ïï 
.
ïï 
Abs
ïï 
(
ïï 
Vector3
ïï &
.
ïï& '
Dot
ïï' *
(
ïï* +
b
ïï+ ,
,
ïï, -
d
ïï. /
)
ïï/ 0
)
ïï0 1
*
ïï2 3
$num
ïï4 7
;
ïï7 8
return
òò 
score
òò 
*
òò 
$num
òò 
;
òò  
}
óó 	
}
ôô 
}õõ Ø%
ŠD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\PolyShape.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ 
AddComponentMenu 
( 
$str 
) 
] 
[ %
DisallowMultipleComponent 
] 
[ 
ExcludeFromPreset 
, $
ExcludeFromObjectFactory 0
]0 1
[ #
ProGridsConditionalSnap 
] 
public 

sealed 
class 
	PolyShape !
:" #
MonoBehaviour$ 1
{ 
internal 
enum 
PolyEditMode "
{ 	
None 
, 
Path 
, 
Height 
, 
Edit 
} 	
ProBuilderMesh 
m_Mesh 
; 
[ 	 
FormerlySerializedAs	 
( 
$str &
)& '
]' (
[   	
SerializeField  	 
]   
internal!! 
List!! 
<!! 
Vector3!! 
>!! 
m_Points!! '
=!!( )
new!!* -
List!!. 2
<!!2 3
Vector3!!3 :
>!!: ;
(!!; <
)!!< =
;!!= >
[## 	 
FormerlySerializedAs##	 
(## 
$str## '
)##' (
]##( )
[$$ 	
SerializeField$$	 
]$$ 
float%% 
	m_Extrude%% 
=%% 
$num%% 
;%% 
['' 	 
FormerlySerializedAs''	 
('' 
$str'' ,
)'', -
]''- .
[(( 	
SerializeField((	 
](( 
PolyEditMode)) 

m_EditMode)) 
;))  
[++ 	 
FormerlySerializedAs++	 
(++ 
$str++ +
)+++ ,
]++, -
[,, 	
SerializeField,,	 
],, 
bool-- 
m_FlipNormals-- 
;-- 
[// 	
SerializeField//	 
]// 
internal00 
bool00 
isOnGrid00 
=00  
true00! %
;00% &
public55 
ReadOnlyCollection55 !
<55! "
Vector355" )
>55) *
controlPoints55+ 8
{66 	
get77 
{77 
return77 
new77 
ReadOnlyCollection77 /
<77/ 0
Vector3770 7
>777 8
(778 9
m_Points779 A
)77A B
;77B C
}77D E
}88 	
public== 
void== 
SetControlPoints== $
(==$ %
IList==% *
<==* +
Vector3==+ 2
>==2 3
points==4 :
)==: ;
{>> 	
m_Points?? 
=?? 
points?? 
.?? 
ToList?? $
(??$ %
)??% &
;??& '
}@@ 	
publicFF 
floatFF 
extrudeFF 
{GG 	
getHH 
{HH 
returnHH 
	m_ExtrudeHH "
;HH" #
}HH$ %
setII 
{II 
	m_ExtrudeII 
=II 
valueII #
;II# $
}II% &
}JJ 	
internalLL 
PolyEditModeLL 
polyEditModeLL *
{MM 	
getNN 
{NN 
returnNN 

m_EditModeNN #
;NN# $
}NN% &
setOO 
{OO 

m_EditModeOO 
=OO 
valueOO $
;OO$ %
}OO& '
}PP 	
publicUU 
boolUU 
flipNormalsUU 
{VV 	
getWW 
{WW 
returnWW 
m_FlipNormalsWW &
;WW& '
}WW( )
setXX 
{XX 
m_FlipNormalsXX 
=XX  !
valueXX" '
;XX' (
}XX) *
}YY 	
internal[[ 
ProBuilderMesh[[ 
mesh[[  $
{\\ 	
get]] 
{^^ 
if__ 
(__ 
m_Mesh__ 
==__ 
null__ "
)__" #
m_Mesh`` 
=`` 
GetComponent`` )
<``) *
ProBuilderMesh``* 8
>``8 9
(``9 :
)``: ;
;``; <
returnbb 
m_Meshbb 
;bb 
}cc 
setee 
{ff 
m_Meshgg 
=gg 
valuegg 
;gg 
}hh 
}ii 	
booloo 
IsSnapEnabledoo 
(oo 
)oo 
{pp 	
returnqq 
isOnGridqq 
;qq 
}rr 	
}ss 
}tt õ/
‘D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\UnwrapParameters.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[		 
System		 
.		 
Serializable		 
]		 
public

 

sealed

 
class

 
UnwrapParameters

 (
{ 
internal 
const 
float 
k_HardAngle (
=) *
$num+ .
;. /
internal 
const 
float 
k_PackMargin )
=* +
$num, /
;/ 0
internal 
const 
float 
k_AngleError )
=* +
$num, .
;. /
internal 
const 
float 
k_AreaError (
=) *
$num+ .
;. /
[ 	
Tooltip	 
( 
$str L
)L M
]M N
[ 	
Range	 
( 
$num 
, 
$num 
) 
] 
[ 	
SerializeField	 
] 
[ 	 
FormerlySerializedAs	 
( 
$str )
)) *
]* +
float 
m_HardAngle 
= 
k_HardAngle '
;' (
[ 	
Tooltip	 
( 
$str ]
)] ^
]^ _
[ 	
Range	 
( 
$num 
, 
$num 
) 
] 
[ 	
SerializeField	 
] 
[ 	 
FormerlySerializedAs	 
( 
$str *
)* +
]+ ,
float 
m_PackMargin 
= 
k_PackMargin )
;) *
[ 	
Tooltip	 
( 
$str v
+ 
$str o
)o p
]p q
[ 	
Range	 
( 
$num 
, 
$num 
) 
] 
[   	
SerializeField  	 
]   
[!! 	 
FormerlySerializedAs!!	 
(!! 
$str!! *
)!!* +
]!!+ ,
float"" 
m_AngleError"" 
="" 
k_AngleError"" )
;"") *
[$$ 	
Range$$	 
($$ 
$num$$ 
,$$ 
$num$$ 
)$$ 
]$$ 
[%% 	
SerializeField%%	 
]%% 
[&& 	 
FormerlySerializedAs&&	 
(&& 
$str&& )
)&&) *
]&&* +
float'' 
m_AreaError'' 
='' 
k_AreaError'' '
;''' (
public,, 
float,, 
	hardAngle,, 
{,,  
get,,! $
{,,% &
return,,' -
m_HardAngle,,. 9
;,,9 :
},,; <
set,,= @
{,,A B
m_HardAngle,,C N
=,,O P
value,,Q V
;,,V W
},,X Y
},,Z [
public11 
float11 

packMargin11 
{11  !
get11" %
{11& '
return11( .
m_PackMargin11/ ;
;11; <
}11= >
set11? B
{11C D
m_PackMargin11E Q
=11R S
value11T Y
;11Y Z
}11[ \
}11] ^
public77 
float77 

angleError77 
{77  !
get77" %
{77& '
return77( .
m_AngleError77/ ;
;77; <
}77= >
set77? B
{77C D
m_AngleError77E Q
=77R S
value77T Y
;77Y Z
}77[ \
}77] ^
public<< 
float<< 
	areaError<< 
{<<  
get<<! $
{<<% &
return<<' -
m_AreaError<<. 9
;<<9 :
}<<; <
set<<= @
{<<A B
m_AreaError<<C N
=<<O P
value<<Q V
;<<V W
}<<X Y
}<<Z [
public>> 
UnwrapParameters>> 
(>>  
)>>  !
{?? 	
Reset@@ 
(@@ 
)@@ 
;@@ 
}AA 	
publicGG 
UnwrapParametersGG 
(GG  
UnwrapParametersGG  0
otherGG1 6
)GG6 7
{HH 	
ifII 
(II 
otherII 
==II 
nullII 
)II 
throwJJ 
newJJ 
SystemJJ  
.JJ  !!
ArgumentNullExceptionJJ! 6
(JJ6 7
$strJJ7 >
)JJ> ?
;JJ? @
	hardAngleLL 
=LL 
otherLL 
.LL 
	hardAngleLL '
;LL' (

packMarginMM 
=MM 
otherMM 
.MM 

packMarginMM )
;MM) *

angleErrorNN 
=NN 
otherNN 
.NN 

angleErrorNN )
;NN) *
	areaErrorOO 
=OO 
otherOO 
.OO 
	areaErrorOO '
;OO' (
}PP 	
publicUU 
voidUU 
ResetUU 
(UU 
)UU 
{VV 	
	hardAngleWW 
=WW 
k_HardAngleWW #
;WW# $

packMarginXX 
=XX 
k_PackMarginXX %
;XX% &

angleErrorYY 
=YY 
k_AngleErrorYY %
;YY% &
	areaErrorZZ 
=ZZ 
k_AreaErrorZZ #
;ZZ# $
}[[ 	
public]] 
override]] 
string]] 
ToString]] '
(]]' (
)]]( )
{^^ 	
return__ 
string__ 
.__ 
Format__  
(__  !
$str__! c
,__c d
	hardAngle`` 
,`` 

packMarginaa 
,aa 

angleErrorbb 
,bb 
	areaErrorcc 
)cc 
;cc 
}dd 	
}ee 
}ff Ûş
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ArrayUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
ArrayUtility 
{ 
public		 
static		 
T		 
[		 
]		 
ValuesWithIndexes		 +
<		+ ,
T		, -
>		- .
(		. /
this		/ 3
T		4 5
[		5 6
]		6 7
arr		8 ;
,		; <
int		= @
[		@ A
]		A B
indexes		C J
)		J K
{

 	
T 
[ 
] 
vals 
= 
new 
T 
[ 
indexes $
.$ %
Length% +
]+ ,
;, -
for 
( 
int 
i 
= 
$num 
; 
i 
< 
indexes  '
.' (
Length( .
;. /
i0 1
++1 3
)3 4
vals 
[ 
i 
] 
= 
arr 
[ 
indexes %
[% &
i& '
]' (
]( )
;) *
return 
vals 
; 
} 	
public 
static 
List 
< 
T 
> 
ValuesWithIndexes /
</ 0
T0 1
>1 2
(2 3
this3 7
List8 <
<< =
T= >
>> ?
arr@ C
,C D
IListE J
<J K
intK N
>N O
indexesP W
)W X
{ 	
List 
< 
T 
> 
vals 
= 
new 
List #
<# $
T$ %
>% &
(& '
indexes' .
.. /
Count/ 4
)4 5
;5 6
foreach 
( 
var 
i 
in 
indexes %
)% &
vals 
. 
Add 
( 
arr 
[ 
i 
] 
)  
;  !
return 
vals 
; 
} 	
public 
static 
IEnumerable !
<! "
int" %
>% &
AllIndexesOf' 3
<3 4
T4 5
>5 6
(6 7
this7 ;
IList< A
<A B
TB C
>C D
listE I
,I J
FuncK O
<O P
TP Q
,Q R
boolS W
>W X
lambdaY _
)_ `
{ 	
var 
indexes 
= 
new 
List "
<" #
int# &
>& '
(' (
)( )
;) *
for 
( 
int 
i 
= 
$num 
, 
c 
= 
list  $
.$ %
Count% *
;* +
i, -
<. /
c0 1
;1 2
i3 4
++4 6
)6 7
if 
( 
lambda 
( 
list 
[  
i  !
]! "
)" #
)# $
indexes   
.   
Add   
(    
i    !
)  ! "
;  " #
return!! 
indexes!! 
;!! 
}"" 	
public$$ 
static$$ 
T$$ 
[$$ 
]$$ 
Add$$ 
<$$ 
T$$ 
>$$  
($$  !
this$$! %
T$$& '
[$$' (
]$$( )
arr$$* -
,$$- .
T$$/ 0
val$$1 4
)$$4 5
{%% 	
T&& 
[&& 
]&& 
v&& 
=&& 
new&& 
T&& 
[&& 
arr&& 
.&& 
Length&& $
+&&% &
$num&&' (
]&&( )
;&&) *
System'' 
.'' 
Array'' 
.'' 
ConstrainedCopy'' (
(''( )
arr'') ,
,'', -
$num''. /
,''/ 0
v''1 2
,''2 3
$num''4 5
,''5 6
arr''7 :
.'': ;
Length''; A
)''A B
;''B C
v(( 
[(( 
arr(( 
.(( 
Length(( 
](( 
=(( 
val(( 
;((  
return)) 
v)) 
;)) 
}** 	
public,, 
static,, 
T,, 
[,, 
],, 
AddRange,, "
<,," #
T,,# $
>,,$ %
(,,% &
this,,& *
T,,+ ,
[,,, -
],,- .
arr,,/ 2
,,,2 3
T,,4 5
[,,5 6
],,6 7
val,,8 ;
),,; <
{-- 	
T.. 
[.. 
].. 
ret.. 
=.. 
new.. 
T.. 
[.. 
arr.. 
...  
Length..  &
+..' (
val..) ,
..., -
Length..- 3
]..3 4
;..4 5
System// 
.// 
Array// 
.// 
ConstrainedCopy// (
(//( )
arr//) ,
,//, -
$num//. /
,/// 0
ret//1 4
,//4 5
$num//6 7
,//7 8
arr//9 <
.//< =
Length//= C
)//C D
;//D E
System00 
.00 
Array00 
.00 
ConstrainedCopy00 (
(00( )
val00) ,
,00, -
$num00. /
,00/ 0
ret001 4
,004 5
arr006 9
.009 :
Length00: @
,00@ A
val00B E
.00E F
Length00F L
)00L M
;00M N
return11 
ret11 
;11 
}22 	
public77 
static77 
T77 
[77 
]77 
Remove77  
<77  !
T77! "
>77" #
(77# $
this77$ (
T77) *
[77* +
]77+ ,
arr77- 0
,770 1
T772 3
val774 7
)777 8
{88 	
List99 
<99 
T99 
>99 
list99 
=99 
new99 
List99 #
<99# $
T99$ %
>99% &
(99& '
arr99' *
)99* +
;99+ ,
list:: 
.:: 
Remove:: 
(:: 
val:: 
):: 
;:: 
return;; 
list;; 
.;; 
ToArray;; 
(;;  
);;  !
;;;! "
}<< 	
public>> 
static>> 
T>> 
[>> 
]>> 
Remove>>  
<>>  !
T>>! "
>>>" #
(>># $
this>>$ (
T>>) *
[>>* +
]>>+ ,
arr>>- 0
,>>0 1
IEnumerable>>2 =
<>>= >
T>>> ?
>>>? @
val>>A D
)>>D E
{?? 	
return@@ 
arr@@ 
.@@ 
Except@@ 
(@@ 
val@@ !
)@@! "
.@@" #
ToArray@@# *
(@@* +
)@@+ ,
;@@, -
}AA 	
publicCC 
staticCC 
TCC 
[CC 
]CC 
RemoveAtCC "
<CC" #
TCC# $
>CC$ %
(CC% &
thisCC& *
TCC+ ,
[CC, -
]CC- .
arrCC/ 2
,CC2 3
intCC4 7
indexCC8 =
)CC= >
{DD 	
TEE 
[EE 
]EE 
newArrayEE 
=EE 
newEE 
TEE  
[EE  !
arrEE! $
.EE$ %
LengthEE% +
-EE, -
$numEE. /
]EE/ 0
;EE0 1
intFF 
nFF 
=FF 
$numFF 
;FF 
forGG 
(GG 
intGG 
iGG 
=GG 
$numGG 
;GG 
iGG 
<GG 
arrGG  #
.GG# $
LengthGG$ *
;GG* +
iGG, -
++GG- /
)GG/ 0
{HH 
ifII 
(II 
iII 
!=II 
indexII 
)II 
{JJ 
newArrayKK 
[KK 
nKK 
]KK 
=KK  !
arrKK" %
[KK% &
iKK& '
]KK' (
;KK( )
nLL 
++LL 
;LL 
}MM 
}NN 
returnOO 
newArrayOO 
;OO 
}PP 	
publicRR 
staticRR 
TRR 
[RR 
]RR 
RemoveAtRR "
<RR" #
TRR# $
>RR$ %
(RR% &
thisRR& *
IListRR+ 0
<RR0 1
TRR1 2
>RR2 3
listRR4 8
,RR8 9
IEnumerableRR: E
<RRE F
intRRF I
>RRI J
indexesRRK R
)RRR S
{SS 	
ListTT 
<TT 
intTT 
>TT 
sortedTT 
=TT 
newTT "
ListTT# '
<TT' (
intTT( +
>TT+ ,
(TT, -
indexesTT- 4
)TT4 5
;TT5 6
sortedUU 
.UU 
SortUU 
(UU 
)UU 
;UU 
returnVV 
SortedRemoveAtVV !
(VV! "
listVV" &
,VV& '
sortedVV( .
)VV. /
;VV/ 0
}WW 	
public\\ 
static\\ 
T\\ 
[\\ 
]\\ 
SortedRemoveAt\\ (
<\\( )
T\\) *
>\\* +
(\\+ ,
this\\, 0
IList\\1 6
<\\6 7
T\\7 8
>\\8 9
list\\: >
,\\> ?
IList\\@ E
<\\E F
int\\F I
>\\I J
sorted\\K Q
)\\Q R
{]] 	
int^^ 
indexeSortedCount^^ !
=^^" #
sorted^^$ *
.^^* +
Count^^+ 0
;^^0 1
int__ 
len__ 
=__ 
list__ 
.__ 
Count__  
;__  !
Taa 
[aa 
]aa 
newArrayaa 
=aa 
newaa 
Taa  
[aa  !
lenaa! $
-aa% &
indexeSortedCountaa' 8
]aa8 9
;aa9 :
intbb 
nbb 
=bb 
$numbb 
;bb 
fordd 
(dd 
intdd 
idd 
=dd 
$numdd 
;dd 
idd 
<dd 
lendd  #
;dd# $
idd% &
++dd& (
)dd( )
{ee 
ifff 
(ff 
nff 
<ff 
indexeSortedCountff )
&&ff* ,
sortedff- 3
[ff3 4
nff4 5
]ff5 6
==ff7 9
iff: ;
)ff; <
{gg 
whileii 
(ii 
nii 
<ii 
indexeSortedCountii 0
&&ii1 3
sortedii4 :
[ii: ;
nii; <
]ii< =
==ii> @
iiiA B
)iiB C
njj 
++jj 
;jj 
continuell 
;ll 
}mm 
newArrayoo 
[oo 
ioo 
-oo 
noo 
]oo 
=oo  !
listoo" &
[oo& '
ioo' (
]oo( )
;oo) *
}pp 
returnrr 
newArrayrr 
;rr 
}ss 	
structxx 
SearchRangexx 
{yy 	
publiczz 
intzz 
beginzz 
,zz 
endzz !
;zz! "
public|| 
SearchRange|| 
(|| 
int|| "
begin||# (
,||( )
int||* -
end||. 1
)||1 2
{}} 
this~~ 
.~~ 
begin~~ 
=~~ 
begin~~ "
;~~" #
this 
. 
end 
= 
end 
; 
}
€€ 
public
‚‚ 
bool
‚‚ 
Valid
‚‚ 
(
‚‚ 
)
‚‚ 
{
‚‚  !
return
‚‚" (
end
‚‚) ,
-
‚‚- .
begin
‚‚/ 4
>
‚‚5 6
$num
‚‚7 8
;
‚‚8 9
}
‚‚: ;
public
ƒƒ 
int
ƒƒ 
Center
ƒƒ 
(
ƒƒ 
)
ƒƒ 
{
ƒƒ  !
return
ƒƒ" (
begin
ƒƒ) .
+
ƒƒ/ 0
(
ƒƒ1 2
end
ƒƒ2 5
-
ƒƒ6 7
begin
ƒƒ8 =
)
ƒƒ= >
/
ƒƒ? @
$num
ƒƒA B
;
ƒƒB C
}
ƒƒD E
public
…… 
override
…… 
string
…… "
ToString
……# +
(
……+ ,
)
……, -
{
†† 
return
‡‡ 
$str
‡‡ 
+
‡‡ 
begin
‡‡ "
+
‡‡# $
$str
‡‡% )
+
‡‡* +
end
‡‡, /
+
‡‡0 1
$str
‡‡2 8
+
‡‡9 :
Center
‡‡; A
(
‡‡A B
)
‡‡B C
;
‡‡C D
}
ˆˆ 
}
‰‰ 	
public
‘‘ 
static
‘‘ 
int
‘‘ &
NearestIndexPriorToValue
‘‘ 2
<
‘‘2 3
T
‘‘3 4
>
‘‘4 5
(
‘‘5 6
IList
‘‘6 ;
<
‘‘; <
T
‘‘< =
>
‘‘= >
sorted_list
‘‘? J
,
‘‘J K
T
‘‘L M
value
‘‘N S
)
‘‘S T
where
‘‘U Z
T
‘‘[ \
:
‘‘] ^
System
‘‘_ e
.
‘‘e f
IComparable
‘‘f q
<
‘‘q r
T
‘‘r s
>
‘‘s t
{
’’ 	
int
““ 
count
““ 
=
““ 
sorted_list
““ #
.
““# $
Count
““$ )
;
““) *
if
”” 
(
”” 
count
”” 
<
”” 
$num
”” 
)
”” 
return
”” !
-
””" #
$num
””# $
;
””$ %
SearchRange
–– 
range
–– 
=
–– 
new
––  #
SearchRange
––$ /
(
––/ 0
$num
––0 1
,
––1 2
count
––3 8
-
––9 :
$num
––; <
)
––< =
;
––= >
if
˜˜ 
(
˜˜ 
value
˜˜ 
.
˜˜ 
	CompareTo
˜˜ 
(
˜˜  
sorted_list
˜˜  +
[
˜˜+ ,
$num
˜˜, -
]
˜˜- .
)
˜˜. /
<
˜˜0 1
$num
˜˜2 3
)
˜˜3 4
return
™™ 
-
™™ 
$num
™™ 
;
™™ 
if
›› 
(
›› 
value
›› 
.
›› 
	CompareTo
›› 
(
››  
sorted_list
››  +
[
››+ ,
count
››, 1
-
››2 3
$num
››4 5
]
››5 6
)
››6 7
>
››8 9
$num
››: ;
)
››; <
return
œœ 
count
œœ 
-
œœ 
$num
œœ  
;
œœ  !
while
 
(
 
range
 
.
 
Valid
 
(
 
)
  
)
  !
{
ŸŸ 
if
   
(
   
sorted_list
   
[
    
range
    %
.
  % &
Center
  & ,
(
  , -
)
  - .
]
  . /
.
  / 0
	CompareTo
  0 9
(
  9 :
value
  : ?
)
  ? @
>
  A B
$num
  C D
)
  D E
{
¡¡ 
range
££ 
.
££ 
end
££ 
=
££ 
range
££  %
.
££% &
Center
££& ,
(
££, -
)
££- .
;
££. /
}
¤¤ 
else
¥¥ 
{
¦¦ 
range
¨¨ 
.
¨¨ 
begin
¨¨ 
=
¨¨  !
range
¨¨" '
.
¨¨' (
Center
¨¨( .
(
¨¨. /
)
¨¨/ 0
;
¨¨0 1
if
ªª 
(
ªª 
sorted_list
ªª #
[
ªª# $
range
ªª$ )
.
ªª) *
begin
ªª* /
+
ªª0 1
$num
ªª2 3
]
ªª3 4
.
ªª4 5
	CompareTo
ªª5 >
(
ªª> ?
value
ªª? D
)
ªªD E
>=
ªªF H
$num
ªªI J
)
ªªJ K
{
«« 
return
¬¬ 
range
¬¬ $
.
¬¬$ %
begin
¬¬% *
;
¬¬* +
}
­­ 
}
®® 
}
¯¯ 
return
±± 
$num
±± 
;
±± 
}
²² 	
public
´´ 
static
´´ 
List
´´ 
<
´´ 
T
´´ 
>
´´ 
Fill
´´ "
<
´´" #
T
´´# $
>
´´$ %
(
´´% &
System
´´& ,
.
´´, -
Func
´´- 1
<
´´1 2
int
´´2 5
,
´´5 6
T
´´7 8
>
´´8 9
ctor
´´: >
,
´´> ?
int
´´@ C
length
´´D J
)
´´J K
{
µµ 	
List
¶¶ 
<
¶¶ 
T
¶¶ 
>
¶¶ 
list
¶¶ 
=
¶¶ 
new
¶¶ 
List
¶¶ #
<
¶¶# $
T
¶¶$ %
>
¶¶% &
(
¶¶& '
length
¶¶' -
)
¶¶- .
;
¶¶. /
for
·· 
(
·· 
int
·· 
i
·· 
=
·· 
$num
·· 
;
·· 
i
·· 
<
·· 
length
··  &
;
··& '
i
··( )
++
··) +
)
··+ ,
list
¸¸ 
.
¸¸ 
Add
¸¸ 
(
¸¸ 
ctor
¸¸ 
(
¸¸ 
i
¸¸ 
)
¸¸  
)
¸¸  !
;
¸¸! "
return
¹¹ 
list
¹¹ 
;
¹¹ 
}
ºº 	
public
¼¼ 
static
¼¼ 
T
¼¼ 
[
¼¼ 
]
¼¼ 
Fill
¼¼ 
<
¼¼ 
T
¼¼  
>
¼¼  !
(
¼¼! "
T
¼¼" #
val
¼¼$ '
,
¼¼' (
int
¼¼) ,
length
¼¼- 3
)
¼¼3 4
{
½½ 	
T
¾¾ 
[
¾¾ 
]
¾¾ 
arr
¾¾ 
=
¾¾ 
new
¾¾ 
T
¾¾ 
[
¾¾ 
length
¾¾ "
]
¾¾" #
;
¾¾# $
for
¿¿ 
(
¿¿ 
int
¿¿ 
i
¿¿ 
=
¿¿ 
$num
¿¿ 
;
¿¿ 
i
¿¿ 
<
¿¿ 
length
¿¿  &
;
¿¿& '
i
¿¿( )
++
¿¿) +
)
¿¿+ ,
{
ÀÀ 
arr
ÁÁ 
[
ÁÁ 
i
ÁÁ 
]
ÁÁ 
=
ÁÁ 
val
ÁÁ 
;
ÁÁ 
}
ÂÂ 
return
ÃÃ 
arr
ÃÃ 
;
ÃÃ 
}
ÄÄ 	
public
ÉÉ 
static
ÉÉ 
bool
ÉÉ 
ContainsMatch
ÉÉ (
<
ÉÉ( )
T
ÉÉ) *
>
ÉÉ* +
(
ÉÉ+ ,
this
ÉÉ, 0
T
ÉÉ1 2
[
ÉÉ2 3
]
ÉÉ3 4
a
ÉÉ5 6
,
ÉÉ6 7
T
ÉÉ8 9
[
ÉÉ9 :
]
ÉÉ: ;
b
ÉÉ< =
)
ÉÉ= >
{
ÊÊ 	
int
ËË 
ind
ËË 
=
ËË 
-
ËË 
$num
ËË 
;
ËË 
for
ÌÌ 
(
ÌÌ 
int
ÌÌ 
i
ÌÌ 
=
ÌÌ 
$num
ÌÌ 
;
ÌÌ 
i
ÌÌ 
<
ÌÌ 
a
ÌÌ  !
.
ÌÌ! "
Length
ÌÌ" (
;
ÌÌ( )
i
ÌÌ* +
++
ÌÌ+ -
)
ÌÌ- .
{
ÍÍ 
ind
ÎÎ 
=
ÎÎ 
System
ÎÎ 
.
ÎÎ 
Array
ÎÎ "
.
ÎÎ" #
IndexOf
ÎÎ# *
(
ÎÎ* +
b
ÎÎ+ ,
,
ÎÎ, -
a
ÎÎ. /
[
ÎÎ/ 0
i
ÎÎ0 1
]
ÎÎ1 2
)
ÎÎ2 3
;
ÎÎ3 4
if
ÏÏ 
(
ÏÏ 
ind
ÏÏ 
>
ÏÏ 
-
ÏÏ 
$num
ÏÏ 
)
ÏÏ 
return
ÏÏ $
true
ÏÏ% )
;
ÏÏ) *
}
ĞĞ 
return
ÑÑ 
false
ÑÑ 
;
ÑÑ 
}
ÒÒ 	
public
×× 
static
×× 
bool
×× 
ContainsMatch
×× (
<
××( )
T
××) *
>
××* +
(
××+ ,
this
××, 0
T
××1 2
[
××2 3
]
××3 4
a
××5 6
,
××6 7
T
××8 9
[
××9 :
]
××: ;
b
××< =
,
××= >
out
××? B
int
××C F
index_a
××G N
,
××N O
out
××P S
int
××T W
index_b
××X _
)
××_ `
{
ØØ 	
index_b
ÙÙ 
=
ÙÙ 
-
ÙÙ 
$num
ÙÙ 
;
ÙÙ 
for
ÚÚ 
(
ÚÚ 
index_a
ÚÚ 
=
ÚÚ 
$num
ÚÚ 
;
ÚÚ 
index_a
ÚÚ %
<
ÚÚ& '
a
ÚÚ( )
.
ÚÚ) *
Length
ÚÚ* 0
;
ÚÚ0 1
index_a
ÚÚ2 9
++
ÚÚ9 ;
)
ÚÚ; <
{
ÛÛ 
index_b
ÜÜ 
=
ÜÜ 
Array
ÜÜ 
.
ÜÜ  
IndexOf
ÜÜ  '
(
ÜÜ' (
b
ÜÜ( )
,
ÜÜ) *
a
ÜÜ+ ,
[
ÜÜ, -
index_a
ÜÜ- 4
]
ÜÜ4 5
)
ÜÜ5 6
;
ÜÜ6 7
if
İİ 
(
İİ 
index_b
İİ 
>
İİ 
-
İİ 
$num
İİ  
)
İİ  !
return
ŞŞ 
true
ŞŞ 
;
ŞŞ  
}
ßß 
return
áá 
false
áá 
;
áá 
}
ââ 	
public
çç 
static
çç 
T
çç 
[
çç 
]
çç 
Concat
çç  
<
çç  !
T
çç! "
>
çç" #
(
çç# $
this
çç$ (
T
çç) *
[
çç* +
]
çç+ ,
x
çç- .
,
çç. /
T
çç0 1
[
çç1 2
]
çç2 3
y
çç4 5
)
çç5 6
{
èè 	
if
éé 
(
éé 
x
éé 
==
éé 
null
éé 
)
éé 
throw
éé  
new
éé! $#
ArgumentNullException
éé% :
(
éé: ;
$str
éé; >
)
éé> ?
;
éé? @
if
êê 
(
êê 
y
êê 
==
êê 
null
êê 
)
êê 
throw
êê  
new
êê! $#
ArgumentNullException
êê% :
(
êê: ;
$str
êê; >
)
êê> ?
;
êê? @
int
ëë 
oldLen
ëë 
=
ëë 
x
ëë 
.
ëë 
Length
ëë !
;
ëë! "
Array
ìì 
.
ìì 
Resize
ìì 
<
ìì 
T
ìì 
>
ìì 
(
ìì 
ref
ìì 
x
ìì  !
,
ìì! "
x
ìì# $
.
ìì$ %
Length
ìì% +
+
ìì, -
y
ìì. /
.
ìì/ 0
Length
ìì0 6
)
ìì6 7
;
ìì7 8
Array
íí 
.
íí 
Copy
íí 
(
íí 
y
íí 
,
íí 
$num
íí 
,
íí 
x
íí 
,
íí 
oldLen
íí  &
,
íí& '
y
íí( )
.
íí) *
Length
íí* 0
)
íí0 1
;
íí1 2
return
îî 
x
îî 
;
îî 
}
ïï 	
public
ôô 
static
ôô 
int
ôô 
IndexOf
ôô !
<
ôô! "
T
ôô" #
>
ôô# $
(
ôô$ %
this
ôô% )
List
ôô* .
<
ôô. /
List
ôô/ 3
<
ôô3 4
T
ôô4 5
>
ôô5 6
>
ôô6 7
InList
ôô8 >
,
ôô> ?
T
ôô@ A
InValue
ôôB I
)
ôôI J
{
õõ 	
for
öö 
(
öö 
int
öö 
i
öö 
=
öö 
$num
öö 
;
öö 
i
öö 
<
öö 
InList
öö  &
.
öö& '
Count
öö' ,
;
öö, -
i
öö. /
++
öö/ 1
)
öö1 2
{
÷÷ 
for
øø 
(
øø 
int
øø 
x
øø 
=
øø 
$num
øø 
;
øø 
x
øø  !
<
øø" #
InList
øø$ *
[
øø* +
i
øø+ ,
]
øø, -
.
øø- .
Count
øø. 3
;
øø3 4
x
øø5 6
++
øø6 8
)
øø8 9
if
ùù 
(
ùù 
InList
ùù 
[
ùù 
i
ùù  
]
ùù  !
[
ùù! "
x
ùù" #
]
ùù# $
.
ùù$ %
Equals
ùù% +
(
ùù+ ,
InValue
ùù, 3
)
ùù3 4
)
ùù4 5
return
úú 
i
úú  
;
úú  !
}
ûû 
return
ıı 
-
ıı 
$num
ıı 
;
ıı 
}
şş 	
public
ƒƒ 
static
ƒƒ 
T
ƒƒ 
[
ƒƒ 
]
ƒƒ 
Fill
ƒƒ 
<
ƒƒ 
T
ƒƒ  
>
ƒƒ  !
(
ƒƒ! "
int
ƒƒ" %
count
ƒƒ& +
,
ƒƒ+ ,
System
ƒƒ- 3
.
ƒƒ3 4
Func
ƒƒ4 8
<
ƒƒ8 9
int
ƒƒ9 <
,
ƒƒ< =
T
ƒƒ> ?
>
ƒƒ? @
ctor
ƒƒA E
)
ƒƒE F
{
„„ 	
T
…… 
[
…… 
]
…… 
arr
…… 
=
…… 
new
…… 
T
…… 
[
…… 
count
…… !
]
……! "
;
……" #
for
†† 
(
†† 
int
†† 
i
†† 
=
†† 
$num
†† 
;
†† 
i
†† 
<
†† 
count
††  %
;
††% &
i
††' (
++
††( *
)
††* +
arr
‡‡ 
[
‡‡ 
i
‡‡ 
]
‡‡ 
=
‡‡ 
ctor
‡‡ 
(
‡‡ 
i
‡‡ 
)
‡‡  
;
‡‡  !
return
ˆˆ 
arr
ˆˆ 
;
ˆˆ 
}
‰‰ 	
public
 
static
 
void
 
AddOrAppend
 &
<
& '
T
' (
,
( )
K
* +
>
+ ,
(
, -
this
- 1

Dictionary
2 <
<
< =
T
= >
,
> ?
List
@ D
<
D E
K
E F
>
F G
>
G H

dictionary
I S
,
S T
T
U V
key
W Z
,
Z [
K
\ ]
value
^ c
)
c d
{
 	
List
 
<
 
K
 
>
 
list
 
;
 
if
’’ 
(
’’ 

dictionary
’’ 
.
’’ 
TryGetValue
’’ &
(
’’& '
key
’’' *
,
’’* +
out
’’, /
list
’’0 4
)
’’4 5
)
’’5 6
list
““ 
.
““ 
Add
““ 
(
““ 
value
““ 
)
““ 
;
““  
else
”” 

dictionary
•• 
.
•• 
Add
•• 
(
•• 
key
•• "
,
••" #
new
••$ '
List
••( ,
<
••, -
K
••- .
>
••. /
(
••/ 0
)
••0 1
{
••2 3
value
••4 9
}
••: ;
)
••; <
;
••< =
}
–– 	
public
›› 
static
›› 
void
›› 
AddOrAppendRange
›› +
<
››+ ,
T
››, -
,
››- .
K
››/ 0
>
››0 1
(
››1 2
this
››2 6

Dictionary
››7 A
<
››A B
T
››B C
,
››C D
List
››E I
<
››I J
K
››J K
>
››K L
>
››L M

dictionary
››N X
,
››X Y
T
››Z [
key
››\ _
,
››_ `
List
››a e
<
››e f
K
››f g
>
››g h
value
››i n
)
››n o
{
œœ 	
List
 
<
 
K
 
>
 
list
 
;
 
if
ŸŸ 
(
ŸŸ 

dictionary
ŸŸ 
.
ŸŸ 
TryGetValue
ŸŸ &
(
ŸŸ& '
key
ŸŸ' *
,
ŸŸ* +
out
ŸŸ, /
list
ŸŸ0 4
)
ŸŸ4 5
)
ŸŸ5 6
list
   
.
   
AddRange
   
(
   
value
   #
)
  # $
;
  $ %
else
¡¡ 

dictionary
¢¢ 
.
¢¢ 
Add
¢¢ 
(
¢¢ 
key
¢¢ "
,
¢¢" #
value
¢¢$ )
)
¢¢) *
;
¢¢* +
}
££ 	
public
¨¨ 
static
¨¨ 
IEnumerable
¨¨ !
<
¨¨! "
TSource
¨¨" )
>
¨¨) *

DistinctBy
¨¨+ 5
<
¨¨5 6
TSource
¨¨6 =
,
¨¨= >
TKey
¨¨? C
>
¨¨C D
(
¨¨D E
this
©© 
IEnumerable
©© 
<
©© 
TSource
©© $
>
©©$ %
source
©©& ,
,
©©, -
Func
ªª 
<
ªª 
TSource
ªª 
,
ªª 
TKey
ªª 
>
ªª 
keySelector
ªª  +
)
ªª+ ,
{
«« 	
HashSet
¬¬ 
<
¬¬ 
TKey
¬¬ 
>
¬¬ 
	knownKeys
¬¬ #
=
¬¬$ %
new
¬¬& )
HashSet
¬¬* 1
<
¬¬1 2
TKey
¬¬2 6
>
¬¬6 7
(
¬¬7 8
)
¬¬8 9
;
¬¬9 :
return
­­ 
source
­­ 
.
­­ 
Where
­­ 
(
­­  
x
­­  !
=>
­­" $
	knownKeys
­­% .
.
­­. /
Add
­­/ 2
(
­­2 3
keySelector
­­3 >
(
­­> ?
x
­­? @
)
­­@ A
)
­­A B
)
­­B C
;
­­C D
}
®® 	
public
°° 
static
°° 
string
°° 
ToString
°° %
<
°°% &
TKey
°°& *
,
°°* +
TValue
°°, 2
>
°°2 3
(
°°3 4
this
°°4 8

Dictionary
°°9 C
<
°°C D
TKey
°°D H
,
°°H I
TValue
°°J P
>
°°P Q
dict
°°R V
)
°°V W
{
±± 	
System
²² 
.
²² 
Text
²² 
.
²² 
StringBuilder
²² %
sb
²²& (
=
²²) *
new
²²+ .
System
²²/ 5
.
²²5 6
Text
²²6 :
.
²²: ;
StringBuilder
²²; H
(
²²H I
)
²²I J
;
²²J K
foreach
´´ 
(
´´ 
KeyValuePair
´´ !
<
´´! "
TKey
´´" &
,
´´& '
TValue
´´( .
>
´´. /
kvp
´´0 3
in
´´4 6
dict
´´7 ;
)
´´; <
sb
µµ 
.
µµ 

AppendLine
µµ 
(
µµ 
string
µµ $
.
µµ$ %
Format
µµ% +
(
µµ+ ,
$str
µµ, B
,
µµB C
kvp
µµD G
.
µµG H
Key
µµH K
,
µµK L
kvp
µµM P
.
µµP Q
Value
µµQ V
)
µµV W
)
µµW X
;
µµX Y
return
¶¶ 
sb
¶¶ 
.
¶¶ 
ToString
¶¶ 
(
¶¶ 
)
¶¶  
;
¶¶  !
}
·· 	
public
¹¹ 
static
¹¹ 
string
¹¹ 
ToString
¹¹ %
<
¹¹% &
T
¹¹& '
>
¹¹' (
(
¹¹( )
this
¹¹) -
IEnumerable
¹¹. 9
<
¹¹9 :
T
¹¹: ;
>
¹¹; <
arr
¹¹= @
,
¹¹@ A
string
¹¹B H
	separator
¹¹I R
=
¹¹S T
$str
¹¹U Y
)
¹¹Y Z
{
ºº 	
return
»» 
string
»» 
.
»» 
Join
»» 
(
»» 
	separator
»» (
,
»»( )
arr
»»* -
.
»»- .
Select
»». 4
(
»»4 5
x
»»5 6
=>
»»7 9
x
»»: ;
.
»»; <
ToString
»»< D
(
»»D E
)
»»E F
)
»»F G
.
»»G H
ToArray
»»H O
(
»»O P
)
»»P Q
)
»»Q R
;
»»R S
}
¼¼ 	
}
½½ 
}¾¾ ˜
•D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SerializationUtility.csÿ
˜D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\CombineMeshes.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
public

 
static

 
class

 
CombineMeshes

 "
{ 
[ 	
Obsolete	 
( 
$str	  
)
  ¡
]
¡ ¢
public 
static 
List 
< 
ProBuilderMesh )
>) *
Combine+ 2
(2 3
IEnumerable3 >
<> ?
ProBuilderMesh? M
>M N
meshesO U
)U V
{ 	
return 
CombineToNewMeshes %
(% &
meshes& ,
), -
;- .
} 	
public&& 
static&& 
List&& 
<&& 
ProBuilderMesh&& )
>&&) *
Combine&&+ 2
(&&2 3
IEnumerable&&3 >
<&&> ?
ProBuilderMesh&&? M
>&&M N
meshes&&O U
,&&U V
ProBuilderMesh&&W e

meshTarget&&f p
)&&p q
{'' 	
if(( 
((( 
meshes(( 
==(( 
null(( 
)(( 
throw)) 
new)) !
ArgumentNullException)) /
())/ 0
$str))0 8
)))8 9
;))9 :
if++ 
(++ 

meshTarget++ 
==++ 
null++ "
)++" #
throw,, 
new,, !
ArgumentNullException,, /
(,,/ 0
$str,,0 <
),,< =
;,,= >
if.. 
(.. 
!.. 
meshes.. 
... 
Any.. 
(.. 
).. 
||..  
meshes..! '
...' (
Count..( -
(..- .
)... /
<..0 1
$num..2 3
)..4 5
return// 
null// 
;// 
if11 
(11 
!11 
meshes11 
.11 
Contains11  
(11  !

meshTarget11! +
)11+ ,
)11, -
return22 
null22 
;22 
var44 
vertices44 
=44 
new44 
List44 #
<44# $
Vertex44$ *
>44* +
(44+ ,

meshTarget44, 6
.446 7
GetVertices447 B
(44B C
)44C D
)44D E
;44E F
var55 
faces55 
=55 
new55 
List55  
<55  !
Face55! %
>55% &
(55& '

meshTarget55' 1
.551 2
facesInternal552 ?
)55? @
;55@ A
var66 
sharedVertices66 
=66  
new66! $
List66% )
<66) *
SharedVertex66* 6
>666 7
(667 8

meshTarget668 B
.66B C
sharedVertices66C Q
)66Q R
;66R S
var77 
sharedTextures77 
=77  
new77! $
List77% )
<77) *
SharedVertex77* 6
>776 7
(777 8

meshTarget778 B
.77B C
sharedTextures77C Q
)77Q R
;77R S
int88 
offset88 
=88 

meshTarget88 #
.88# $
vertexCount88$ /
;88/ 0
var99 
materialMap99 
=99 
new99 !
List99" &
<99& '
Material99' /
>99/ 0
(990 1

meshTarget991 ;
.99; <
renderer99< D
.99D E
sharedMaterials99E T
)99T U
;99U V
var:: 
targetTransform:: 
=::  !

meshTarget::" ,
.::, -
	transform::- 6
;::6 7
var<< !
firstMeshContributors<< %
=<<& '
new<<( +
List<<, 0
<<<0 1
ProBuilderMesh<<1 ?
><<? @
(<<@ A
)<<A B
;<<B C
var== %
remainderMeshContributors== )
===* +
new==, /
List==0 4
<==4 5
ProBuilderMesh==5 C
>==C D
(==D E
)==E F
;==F G
var?? "
currentMeshVertexCount?? &
=??' (
offset??) /
;??/ 0
foreach@@ 
(@@ 
var@@ 
mesh@@ 
in@@  
meshes@@! '
)@@' (
{AA 
ifBB 
(BB 
meshBB 
!=BB 

meshTargetBB &
)BB& '
{CC 
ifDD 
(DD "
currentMeshVertexCountDD .
+DD/ 0
meshDD1 5
.DD5 6
vertexCountDD6 A
<DDB C
ProBuilderMeshDDD R
.DDR S
maxVertexCountDDS a
)DDa b
{EE "
currentMeshVertexCountFF .
+=FF/ 1
meshFF2 6
.FF6 7
vertexCountFF7 B
;FFB C!
firstMeshContributorsGG -
.GG- .
AddGG. 1
(GG1 2
meshGG2 6
)GG6 7
;GG7 8
}HH 
elseII 
{JJ %
remainderMeshContributorsKK 1
.KK1 2
AddKK2 5
(KK5 6
meshKK6 :
)KK: ;
;KK; <
}LL 
}MM 
}NN 
varPP 
autoUvFacesPP 
=PP 
newPP !
ListPP" &
<PP& '
FacePP' +
>PP+ ,
(PP, -
)PP- .
;PP. / 
AccumulateMeshesInfoQQ  
(QQ  !!
firstMeshContributorsRR %
,RR% &
offsetSS 
,SS 
refTT 
verticesTT 
,TT 
refUU 
facesUU 
,UU 
refVV 
autoUvFacesVV 
,VV  
refWW 
sharedVerticesWW "
,WW" #
refXX 
sharedTexturesXX "
,XX" #
refYY 
materialMapYY 
,YY  
targetTransformZZ 
)[[ 
;[[ 

meshTarget]] 
.]] 
SetVertices]] "
(]]" #
vertices]]# +
)]]+ ,
;]], -

meshTarget^^ 
.^^ 
faces^^ 
=^^ 
faces^^ $
;^^$ %

meshTarget__ 
.__ 
sharedVertices__ %
=__& '
sharedVertices__( 6
;__6 7

meshTarget`` 
.`` 
sharedTextures`` %
=``& '
sharedTextures``( 6
!=``7 9
null``: >
?``? @
sharedTextures``A O
.``O P
ToArray``P W
(``W X
)``X Y
:``Z [
null``\ `
;``` a

meshTargetaa 
.aa 
rendereraa 
.aa  
sharedMaterialsaa  /
=aa0 1
materialMapaa2 =
.aa= >
ToArrayaa> E
(aaE F
)aaF G
;aaG H

meshTargetbb 
.bb 
ToMeshbb 
(bb 
)bb 
;bb  

meshTargetcc 
.cc 
Refreshcc 
(cc 
)cc  
;cc  !
	UVEditingdd 
.dd ,
 SetAutoAndAlignUnwrapParamsToUVsdd 6
(dd6 7

meshTargetdd7 A
,ddA B
autoUvFacesddC N
)ddN O
;ddO P
MeshValidationff 
.ff 
EnsureMeshIsValidff ,
(ff, -

meshTargetff- 7
,ff7 8
outff9 <
intff= @
removedVerticesffA P
)ffP Q
;ffQ R
varhh 
returnedMeshhh 
=hh 
newhh "
Listhh# '
<hh' (
ProBuilderMeshhh( 6
>hh6 7
(hh7 8
)hh8 9
{hh: ;

meshTargethh< F
}hhG H
;hhH I
ifii 
(ii %
remainderMeshContributorsii )
.ii) *
Countii* /
>ii0 1
$numii2 3
)ii3 4
{jj 
varkk 
	newMesheskk 
=kk 
CombineToNewMesheskk  2
(kk2 3%
remainderMeshContributorskk3 L
)kkL M
;kkM N
foreachll 
(ll 
varll 
meshll !
inll" $
	newMeshesll% .
)ll. /
{mm 
MeshValidationnn "
.nn" #
EnsureMeshIsValidnn# 4
(nn4 5
meshnn5 9
,nn9 :
outnn; >
removedVerticesnn? N
)nnN O
;nnO P
returnedMeshoo  
.oo  !
Addoo! $
(oo$ %
meshoo% )
)oo) *
;oo* +
}pp 
}qq 
elserr 
ifrr 
(rr %
remainderMeshContributorsrr .
.rr. /
Countrr/ 4
==rr5 7
$numrr8 9
)rr9 :
{ss 
returnedMeshtt 
.tt 
Addtt  
(tt  !%
remainderMeshContributorstt! :
[tt: ;
$numtt; <
]tt< =
)tt= >
;tt> ?
}uu 
returnww 
returnedMeshww 
;ww  
}xx 	
staticzz 
Listzz 
<zz 
ProBuilderMeshzz "
>zz" #
CombineToNewMesheszz$ 6
(zz6 7
IEnumerablezz7 B
<zzB C
ProBuilderMeshzzC Q
>zzQ R
mesheszzS Y
)zzY Z
{{{ 	
if|| 
(|| 
meshes|| 
==|| 
null|| 
)|| 
throw}} 
new}} !
ArgumentNullException}} /
(}}/ 0
$str}}0 8
)}}8 9
;}}9 :
if 
( 
! 
meshes 
. 
Any 
( 
) 
||  
meshes! '
.' (
Count( -
(- .
). /
<0 1
$num2 3
)3 4
return
€€ 
null
€€ 
;
€€ 
var
‚‚ 
vertices
‚‚ 
=
‚‚ 
new
‚‚ 
List
‚‚ #
<
‚‚# $
Vertex
‚‚$ *
>
‚‚* +
(
‚‚+ ,
)
‚‚, -
;
‚‚- .
var
ƒƒ 
faces
ƒƒ 
=
ƒƒ 
new
ƒƒ 
List
ƒƒ  
<
ƒƒ  !
Face
ƒƒ! %
>
ƒƒ% &
(
ƒƒ& '
)
ƒƒ' (
;
ƒƒ( )
var
„„ 
autoUvFaces
„„ 
=
„„ 
new
„„ !
List
„„" &
<
„„& '
Face
„„' +
>
„„+ ,
(
„„, -
)
„„- .
;
„„. /
var
…… 
sharedVertices
…… 
=
……  
new
……! $
List
……% )
<
……) *
SharedVertex
……* 6
>
……6 7
(
……7 8
)
……8 9
;
……9 :
var
†† 
sharedTextures
†† 
=
††  
new
††! $
List
††% )
<
††) *
SharedVertex
††* 6
>
††6 7
(
††7 8
)
††8 9
;
††9 :
int
‡‡ 
offset
‡‡ 
=
‡‡ 
$num
‡‡ 
;
‡‡ 
var
ˆˆ 
materialMap
ˆˆ 
=
ˆˆ 
new
ˆˆ !
List
ˆˆ" &
<
ˆˆ& '
Material
ˆˆ' /
>
ˆˆ/ 0
(
ˆˆ0 1
)
ˆˆ1 2
;
ˆˆ2 3"
AccumulateMeshesInfo
ŠŠ  
(
ŠŠ  !
meshes
‹‹ 
,
‹‹ 
offset
ŒŒ 
,
ŒŒ 
ref
 
vertices
 
,
 
ref
 
faces
 
,
 
ref
 
autoUvFaces
 
,
 
ref
 
sharedVertices
 !
,
! "
ref
‘‘ 
sharedTextures
‘‘ !
,
‘‘! "
ref
’’ 
materialMap
’’ 
)
““ 
;
““ 
var
•• 
res
•• 
=
•• #
SplitByMaxVertexCount
•• +
(
••+ ,
vertices
••, 4
,
••4 5
faces
••6 ;
,
••; <
sharedVertices
••= K
,
••K L
sharedTextures
••M [
)
••[ \
;
••\ ]
var
–– 
pivot
–– 
=
–– 
meshes
–– 
.
–– 
LastOrDefault
–– ,
(
––, -
)
––- .
.
––. /
	transform
––/ 8
.
––8 9
position
––9 A
;
––A B
foreach
˜˜ 
(
˜˜ 
var
˜˜ 
m
˜˜ 
in
˜˜ 
res
˜˜ !
)
˜˜! "
{
™™ 
m
šš 
.
šš 
renderer
šš 
.
šš 
sharedMaterials
šš *
=
šš+ ,
materialMap
šš- 8
.
šš8 9
ToArray
šš9 @
(
šš@ A
)
ššA B
;
ššB C!
InternalMeshUtility
›› #
.
››# $(
FilterUnusedSubmeshIndexes
››$ >
(
››> ?
m
››? @
)
››@ A
;
››A B
m
œœ 
.
œœ 
SetPivot
œœ 
(
œœ 
pivot
œœ  
)
œœ  !
;
œœ! "
	UVEditing
 
.
 .
 SetAutoAndAlignUnwrapParamsToUVs
 :
(
: ;
m
; <
,
< =
autoUvFaces
> I
)
I J
;
J K
}
ŸŸ 
return
¡¡ 
res
¡¡ 
;
¡¡ 
}
¢¢ 	
static
¤¤ 
void
¤¤ "
AccumulateMeshesInfo
¤¤ (
(
¤¤( )
IEnumerable
¥¥ 
<
¥¥ 
ProBuilderMesh
¥¥ *
>
¥¥* +
meshes
¥¥, 2
,
¥¥2 3
int
¦¦ 
offset
¦¦ 
,
¦¦ 
ref
§§ 
List
§§ 
<
§§ 
Vertex
§§ 
>
§§  
vertices
§§! )
,
§§) *
ref
¨¨ 
List
¨¨ 
<
¨¨ 
Face
¨¨ 
>
¨¨ 
faces
¨¨ $
,
¨¨$ %
ref
©© 
List
©© 
<
©© 
Face
©© 
>
©© 
autoUvFaces
©© *
,
©©* +
ref
ªª 
List
ªª 
<
ªª 
SharedVertex
ªª %
>
ªª% &
sharedVertices
ªª' 5
,
ªª5 6
ref
«« 
List
«« 
<
«« 
SharedVertex
«« %
>
««% &
sharedTextures
««' 5
,
««5 6
ref
¬¬ 
List
¬¬ 
<
¬¬ 
Material
¬¬ !
>
¬¬! "
materialMap
¬¬# .
,
¬¬. /
	Transform
­­ 
targetTransform
­­ )
=
­­* +
null
­­, 0
)
®® 
{
¯¯ 	
foreach
°° 
(
°° 
var
°° 
mesh
°° 
in
°°  
meshes
°°! '
)
°°' (
{
±± 
var
²² 
meshVertexCount
²² #
=
²²$ %
mesh
²²& *
.
²²* +
vertexCount
²²+ 6
;
²²6 7
var
³³ 
	transform
³³ 
=
³³ 
mesh
³³  $
.
³³$ %
	transform
³³% .
;
³³. /
var
´´ 
meshVertices
´´  
=
´´! "
mesh
´´# '
.
´´' (
GetVertices
´´( 3
(
´´3 4
)
´´4 5
;
´´5 6
var
µµ 
	meshFaces
µµ 
=
µµ 
mesh
µµ  $
.
µµ$ %
facesInternal
µµ% 2
;
µµ2 3
var
¶¶  
meshSharedVertices
¶¶ &
=
¶¶' (
mesh
¶¶) -
.
¶¶- .
sharedVertices
¶¶. <
;
¶¶< =
var
··  
meshSharedTextures
·· &
=
··' (
mesh
··) -
.
··- .
sharedTextures
··. <
;
··< =
var
¸¸ 
	materials
¸¸ 
=
¸¸ 
mesh
¸¸  $
.
¸¸$ %
renderer
¸¸% -
.
¸¸- .
sharedMaterials
¸¸. =
;
¸¸= >
var
¹¹ 
materialCount
¹¹ !
=
¹¹" #
	materials
¹¹$ -
.
¹¹- .
Length
¹¹. 4
;
¹¹4 5
for
»» 
(
»» 
int
»» 
i
»» 
=
»» 
$num
»» 
;
»» 
i
»»  !
<
»»" #
meshVertexCount
»»$ 3
;
»»3 4
i
»»5 6
++
»»6 8
)
»»8 9
{
¼¼ 
var
½½ 
worldVertex
½½ #
=
½½$ %
	transform
½½& /
.
½½/ 0
TransformVertex
½½0 ?
(
½½? @
meshVertices
½½@ L
[
½½L M
i
½½M N
]
½½N O
)
½½O P
;
½½P Q
if
¾¾ 
(
¾¾ 
targetTransform
¾¾ '
!=
¾¾( *
null
¾¾+ /
)
¾¾/ 0
vertices
¿¿  
.
¿¿  !
Add
¿¿! $
(
¿¿$ %
targetTransform
¿¿% 4
.
¿¿4 5$
InverseTransformVertex
¿¿5 K
(
¿¿K L
worldVertex
¿¿L W
)
¿¿W X
)
¿¿X Y
;
¿¿Y Z
else
ÀÀ 
vertices
ÁÁ  
.
ÁÁ  !
Add
ÁÁ! $
(
ÁÁ$ %
worldVertex
ÁÁ% 0
)
ÁÁ0 1
;
ÁÁ1 2
}
ÂÂ 
foreach
ÄÄ 
(
ÄÄ 
var
ÄÄ 
face
ÄÄ !
in
ÄÄ" $
	meshFaces
ÄÄ% .
)
ÄÄ. /
{
ÅÅ 
var
ÆÆ 
newFace
ÆÆ 
=
ÆÆ  !
new
ÆÆ" %
Face
ÆÆ& *
(
ÆÆ* +
face
ÆÆ+ /
)
ÆÆ/ 0
;
ÆÆ0 1
newFace
ÇÇ 
.
ÇÇ 
ShiftIndexes
ÇÇ (
(
ÇÇ( )
offset
ÇÇ) /
)
ÇÇ/ 0
;
ÇÇ0 1
if
ÊÊ 
(
ÊÊ 
!
ÊÊ 
newFace
ÊÊ  
.
ÊÊ  !
manualUV
ÊÊ! )
&&
ÊÊ* ,
!
ÊÊ- .
newFace
ÊÊ. 5
.
ÊÊ5 6
uv
ÊÊ6 8
.
ÊÊ8 9
useWorldSpace
ÊÊ9 F
)
ÊÊF G
{
ËË 
newFace
ÌÌ 
.
ÌÌ  
manualUV
ÌÌ  (
=
ÌÌ) *
true
ÌÌ+ /
;
ÌÌ/ 0
autoUvFaces
ÍÍ #
.
ÍÍ# $
Add
ÍÍ$ '
(
ÍÍ' (
newFace
ÍÍ( /
)
ÍÍ/ 0
;
ÍÍ0 1
}
ÎÎ 
var
ÏÏ 
material
ÏÏ  
=
ÏÏ! "
	materials
ÏÏ# ,
[
ÏÏ, -
Math
ÏÏ- 1
.
ÏÏ1 2
Clamp
ÏÏ2 7
(
ÏÏ7 8
face
ÏÏ8 <
.
ÏÏ< =
submeshIndex
ÏÏ= I
,
ÏÏI J
$num
ÏÏK L
,
ÏÏL M
materialCount
ÏÏN [
-
ÏÏ\ ]
$num
ÏÏ^ _
)
ÏÏ_ `
]
ÏÏ` a
;
ÏÏa b
var
ĞĞ 
submeshIndex
ĞĞ $
=
ĞĞ% &
materialMap
ĞĞ' 2
.
ĞĞ2 3
IndexOf
ĞĞ3 :
(
ĞĞ: ;
material
ĞĞ; C
)
ĞĞC D
;
ĞĞD E
if
ÒÒ 
(
ÒÒ 
submeshIndex
ÒÒ $
>
ÒÒ% &
-
ÒÒ' (
$num
ÒÒ( )
)
ÒÒ) *
{
ÓÓ 
newFace
ÔÔ 
.
ÔÔ  
submeshIndex
ÔÔ  ,
=
ÔÔ- .
submeshIndex
ÔÔ/ ;
;
ÔÔ; <
}
ÕÕ 
else
ÖÖ 
{
×× 
if
ØØ 
(
ØØ 
material
ØØ $
==
ØØ% '
null
ØØ( ,
)
ØØ, -
{
ÙÙ 
newFace
ÚÚ #
.
ÚÚ# $
submeshIndex
ÚÚ$ 0
=
ÚÚ1 2
$num
ÚÚ3 4
;
ÚÚ4 5
}
ÛÛ 
else
ÜÜ 
{
İİ 
newFace
ŞŞ #
.
ŞŞ# $
submeshIndex
ŞŞ$ 0
=
ŞŞ1 2
materialMap
ŞŞ3 >
.
ŞŞ> ?
Count
ŞŞ? D
;
ŞŞD E
materialMap
ßß '
.
ßß' (
Add
ßß( +
(
ßß+ ,
material
ßß, 4
)
ßß4 5
;
ßß5 6
}
àà 
}
áá 
faces
ãã 
.
ãã 
Add
ãã 
(
ãã 
newFace
ãã %
)
ãã% &
;
ãã& '
}
ää 
foreach
ææ 
(
ææ 
var
ææ 
sv
ææ 
in
ææ  " 
meshSharedVertices
ææ# 5
)
ææ5 6
{
çç 
var
èè 
nsv
èè 
=
èè 
new
èè !
SharedVertex
èè" .
(
èè. /
sv
èè/ 1
)
èè1 2
;
èè2 3
nsv
éé 
.
éé 
ShiftIndexes
éé $
(
éé$ %
offset
éé% +
)
éé+ ,
;
éé, -
sharedVertices
êê "
.
êê" #
Add
êê# &
(
êê& '
nsv
êê' *
)
êê* +
;
êê+ ,
}
ëë 
foreach
íí 
(
íí 
var
íí 
st
íí 
in
íí  " 
meshSharedTextures
íí# 5
)
íí5 6
{
îî 
var
ïï 
nst
ïï 
=
ïï 
new
ïï !
SharedVertex
ïï" .
(
ïï. /
st
ïï/ 1
)
ïï1 2
;
ïï2 3
nst
ğğ 
.
ğğ 
ShiftIndexes
ğğ $
(
ğğ$ %
offset
ğğ% +
)
ğğ+ ,
;
ğğ, -
sharedTextures
ññ "
.
ññ" #
Add
ññ# &
(
ññ& '
nst
ññ' *
)
ññ* +
;
ññ+ ,
}
òò 
offset
ôô 
+=
ôô 
meshVertexCount
ôô )
;
ôô) *
}
õõ 
}
öö 	
static
øø 
ProBuilderMesh
øø !
CreateMeshFromSplit
øø 1
(
øø1 2
List
øø2 6
<
øø6 7
Vertex
øø7 =
>
øø= >
vertices
øø? G
,
øøG H
List
ùù 
<
ùù 
Face
ùù 
>
ùù 
faces
ùù 
,
ùù 

Dictionary
úú 
<
úú 
int
úú 
,
úú 
int
úú 
>
úú   
sharedVertexLookup
úú! 3
,
úú3 4

Dictionary
ûû 
<
ûû 
int
ûû 
,
ûû 
int
ûû 
>
ûû  !
sharedTextureLookup
ûû! 4
,
ûû4 5

Dictionary
üü 
<
üü 
int
üü 
,
üü 
int
üü 
>
üü  
remap
üü! &
,
üü& '
Material
ıı 
[
ıı 
]
ıı 
	materials
ıı  
)
ıı  !
{
şş 	
var
€€ 
sv
€€ 
=
€€ 
new
€€ 

Dictionary
€€ #
<
€€# $
int
€€$ '
,
€€' (
int
€€) ,
>
€€, -
(
€€- .
)
€€. /
;
€€/ 0
var
 
st
 
=
 
new
 

Dictionary
 #
<
# $
int
$ '
,
' (
int
) ,
>
, -
(
- .
)
. /
;
/ 0
foreach
ƒƒ 
(
ƒƒ 
var
ƒƒ 
f
ƒƒ 
in
ƒƒ 
faces
ƒƒ #
)
ƒƒ# $
{
„„ 
for
…… 
(
…… 
int
…… 
i
…… 
=
…… 
$num
…… 
,
…… 
c
……  !
=
……" #
f
……$ %
.
……% &
indexesInternal
……& 5
.
……5 6
Length
……6 <
;
……< =
i
……> ?
<
……@ A
c
……B C
;
……C D
i
……E F
++
……F H
)
……H I
f
†† 
.
†† 
indexesInternal
†† %
[
††% &
i
††& '
]
††' (
=
††) *
remap
††+ 0
[
††0 1
f
††1 2
.
††2 3
indexesInternal
††3 B
[
††B C
i
††C D
]
††D E
]
††E F
;
††F G
f
ˆˆ 
.
ˆˆ 
InvalidateCache
ˆˆ !
(
ˆˆ! "
)
ˆˆ" #
;
ˆˆ# $
}
‰‰ 
foreach
‹‹ 
(
‹‹ 
var
‹‹ 
kvp
‹‹ 
in
‹‹ 
remap
‹‹  %
)
‹‹% &
{
ŒŒ 
int
 
v
 
;
 
if
 
(
  
sharedVertexLookup
 &
.
& '
TryGetValue
' 2
(
2 3
kvp
3 6
.
6 7
Key
7 :
,
: ;
out
< ?
v
@ A
)
A B
)
B C
sv
 
.
 
Add
 
(
 
kvp
 
.
 
Value
 $
,
$ %
v
& '
)
' (
;
( )
if
’’ 
(
’’ !
sharedTextureLookup
’’ '
.
’’' (
TryGetValue
’’( 3
(
’’3 4
kvp
’’4 7
.
’’7 8
Key
’’8 ;
,
’’; <
out
’’= @
v
’’A B
)
’’B C
)
’’C D
st
““ 
.
““ 
Add
““ 
(
““ 
kvp
““ 
.
““ 
Value
““ $
,
““$ %
v
““& '
)
““' (
;
““( )
}
”” 
return
–– 
ProBuilderMesh
–– !
.
––! "
Create
––" (
(
––( )
vertices
—— 
,
—— 
faces
˜˜ 
,
˜˜ 
SharedVertex
™™ 
.
™™ 
ToSharedVertices
™™ -
(
™™- .
sv
™™. 0
)
™™0 1
,
™™1 2
st
šš 
.
šš 
Any
šš 
(
šš 
)
šš 
?
šš 
SharedVertex
šš '
.
šš' (
ToSharedVertices
šš( 8
(
šš8 9
st
šš9 ;
)
šš; <
:
šš= >
null
šš? C
,
ššC D
	materials
›› 
)
›› 
;
›› 
}
œœ 	
internal
¢¢ 
static
¢¢ 
List
¢¢ 
<
¢¢ 
ProBuilderMesh
¢¢ +
>
¢¢+ ,#
SplitByMaxVertexCount
¢¢- B
(
¢¢B C
IList
¢¢C H
<
¢¢H I
Vertex
¢¢I O
>
¢¢O P
vertices
¢¢Q Y
,
¢¢Y Z
IList
¢¢[ `
<
¢¢` a
Face
¢¢a e
>
¢¢e f
faces
¢¢g l
,
¢¢l m
IList
¢¢n s
<
¢¢s t
SharedVertex¢¢t €
>¢¢€ 
sharedVertices¢¢‚ 
,¢¢ ‘
IList¢¢’ —
<¢¢— ˜
SharedVertex¢¢˜ ¤
>¢¢¤ ¥
sharedTextures¢¢¦ ´
,¢¢´ µ
uint¢¢¶ º
maxVertexCount¢¢» É
=¢¢Ê Ë
ProBuilderMesh¢¢Ì Ú
.¢¢Ú Û
maxVertexCount¢¢Û é
)¢¢é ê
{
££ 	
uint
¤¤ 
vertexCount
¤¤ 
=
¤¤ 
(
¤¤  
uint
¤¤  $
)
¤¤$ %
vertices
¤¤% -
.
¤¤- .
Count
¤¤. 3
;
¤¤3 4
uint
¥¥ 
	meshCount
¥¥ 
=
¥¥ 
System
¥¥ #
.
¥¥# $
Math
¥¥$ (
.
¥¥( )
Max
¥¥) ,
(
¥¥, -
$num
¥¥- /
,
¥¥/ 0
vertexCount
¥¥1 <
/
¥¥= >
maxVertexCount
¥¥? M
)
¥¥M N
;
¥¥N O
var
¦¦ 
submeshCount
¦¦ 
=
¦¦ 
faces
¦¦ $
.
¦¦$ %
Max
¦¦% (
(
¦¦( )
x
¦¦) *
=>
¦¦+ -
x
¦¦. /
.
¦¦/ 0
submeshIndex
¦¦0 <
)
¦¦< =
+
¦¦> ?
$num
¦¦@ A
;
¦¦A B
if
¨¨ 
(
¨¨ 
	meshCount
¨¨ 
<
¨¨ 
$num
¨¨ 
)
¨¨ 
return
©© 
new
©© 
List
©© 
<
©©  
ProBuilderMesh
©©  .
>
©©. /
(
©©/ 0
)
©©0 1
{
©©2 3
ProBuilderMesh
©©4 B
.
©©B C
Create
©©C I
(
©©I J
vertices
©©J R
,
©©R S
faces
©©T Y
,
©©Y Z
sharedVertices
©©[ i
,
©©i j
sharedTextures
©©k y
,
©©y z
new
©©{ ~
Material©© ‡
[©©‡ ˆ
submeshCount©©ˆ ”
]©©” •
)©©• –
}©©— ˜
;©©˜ ™
var
««  
sharedVertexLookup
«« "
=
««# $
new
««% (

Dictionary
««) 3
<
««3 4
int
««4 7
,
««7 8
int
««9 <
>
««< =
(
««= >
)
««> ?
;
««? @
SharedVertex
¬¬ 
.
¬¬ #
GetSharedVertexLookup
¬¬ .
(
¬¬. /
sharedVertices
¬¬/ =
,
¬¬= > 
sharedVertexLookup
¬¬? Q
)
¬¬Q R
;
¬¬R S
var
®® !
sharedTextureLookup
®® #
=
®®$ %
new
®®& )

Dictionary
®®* 4
<
®®4 5
int
®®5 8
,
®®8 9
int
®®: =
>
®®= >
(
®®> ?
)
®®? @
;
®®@ A
SharedVertex
¯¯ 
.
¯¯ #
GetSharedVertexLookup
¯¯ .
(
¯¯. /
sharedTextures
¯¯/ =
,
¯¯= >!
sharedTextureLookup
¯¯? R
)
¯¯R S
;
¯¯S T
var
±± 
meshes
±± 
=
±± 
new
±± 
List
±± !
<
±±! "
ProBuilderMesh
±±" 0
>
±±0 1
(
±±1 2
)
±±2 3
;
±±3 4
var
²² 
mv
²² 
=
²² 
new
²² 
List
²² 
<
²² 
Vertex
²² $
>
²²$ %
(
²²% &
)
²²& '
;
²²' (
var
³³ 
mf
³³ 
=
³³ 
new
³³ 
List
³³ 
<
³³ 
Face
³³ "
>
³³" #
(
³³# $
)
³³$ %
;
³³% &
var
´´ 
remap
´´ 
=
´´ 
new
´´ 

Dictionary
´´ &
<
´´& '
int
´´' *
,
´´* +
int
´´, /
>
´´/ 0
(
´´0 1
)
´´1 2
;
´´2 3
foreach
¶¶ 
(
¶¶ 
var
¶¶ 
face
¶¶ 
in
¶¶  
faces
¶¶! &
)
¶¶& '
{
·· 
if
¸¸ 
(
¸¸ 
mv
¸¸ 
.
¸¸ 
Count
¸¸ 
+
¸¸ 
face
¸¸ #
.
¸¸# $
distinctIndexes
¸¸$ 3
.
¸¸3 4
Count
¸¸4 9
>
¸¸: ;
maxVertexCount
¸¸< J
)
¸¸J K
{
¹¹ 
meshes
»» 
.
»» 
Add
»» 
(
»» !
CreateMeshFromSplit
»» 2
(
»»2 3
mv
»»3 5
,
»»5 6
mf
»»7 9
,
»»9 : 
sharedVertexLookup
»»; M
,
»»M N!
sharedTextureLookup
»»O b
,
»»b c
remap
»»d i
,
»»i j
new
»»k n
Material
»»o w
[
»»w x
submeshCount»»x „
]»»„ …
)»»… †
)»»† ‡
;»»‡ ˆ
mv
¼¼ 
.
¼¼ 
Clear
¼¼ 
(
¼¼ 
)
¼¼ 
;
¼¼ 
mf
½½ 
.
½½ 
Clear
½½ 
(
½½ 
)
½½ 
;
½½ 
remap
¾¾ 
.
¾¾ 
Clear
¾¾ 
(
¾¾  
)
¾¾  !
;
¾¾! "
}
¿¿ 
foreach
ÁÁ 
(
ÁÁ 
int
ÁÁ 
i
ÁÁ 
in
ÁÁ !
face
ÁÁ" &
.
ÁÁ& '
distinctIndexes
ÁÁ' 6
)
ÁÁ6 7
{
ÂÂ 
mv
ÃÃ 
.
ÃÃ 
Add
ÃÃ 
(
ÃÃ 
vertices
ÃÃ #
[
ÃÃ# $
i
ÃÃ$ %
]
ÃÃ% &
)
ÃÃ& '
;
ÃÃ' (
remap
ÄÄ 
.
ÄÄ 
Add
ÄÄ 
(
ÄÄ 
i
ÄÄ 
,
ÄÄ  
mv
ÄÄ! #
.
ÄÄ# $
Count
ÄÄ$ )
-
ÄÄ* +
$num
ÄÄ, -
)
ÄÄ- .
;
ÄÄ. /
}
ÅÅ 
mf
ÇÇ 
.
ÇÇ 
Add
ÇÇ 
(
ÇÇ 
face
ÇÇ 
)
ÇÇ 
;
ÇÇ 
}
ÈÈ 
if
ÊÊ 
(
ÊÊ 
mv
ÊÊ 
.
ÊÊ 
Any
ÊÊ 
(
ÊÊ 
)
ÊÊ 
)
ÊÊ 
meshes
ËË 
.
ËË 
Add
ËË 
(
ËË !
CreateMeshFromSplit
ËË .
(
ËË. /
mv
ËË/ 1
,
ËË1 2
mf
ËË3 5
,
ËË5 6 
sharedVertexLookup
ËË7 I
,
ËËI J!
sharedTextureLookup
ËËK ^
,
ËË^ _
remap
ËË` e
,
ËËe f
new
ËËg j
Material
ËËk s
[
ËËs t
submeshCountËËt €
]ËË€ 
)ËË ‚
)ËË‚ ƒ
;ËËƒ „
return
ÍÍ 
meshes
ÍÍ 
;
ÍÍ 
}
ÎÎ 	
}
ÏÏ 
}ĞĞ Ğ‘
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\InternalMeshUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
static		 

class		 
InternalMeshUtility		 $
{

 
internal 
static 
Vector3 $
AverageNormalWithIndexes  8
(8 9
SharedVertex9 E
sharedF L
,L M
intN Q
[Q R
]R S
allT W
,W X
IListY ^
<^ _
Vector3_ f
>f g
normh l
)l m
{ 	
Vector3 
n 
= 
Vector3 
.  
zero  $
;$ %
int 
count 
= 
$num 
; 
for 
( 
int 
i 
= 
$num 
; 
i 
< 
all  #
.# $
Length$ *
;* +
i, -
++- /
)/ 0
{ 
if 
( 
shared 
. 
Contains #
(# $
all$ '
[' (
i( )
]) *
)* +
)+ ,
{ 
n 
+= 
norm 
[ 
all !
[! "
i" #
]# $
]$ %
;% &
count 
++ 
; 
} 
} 
return 
( 
n 
/ 
( 
float 
) 
count $
)$ %
;% &
} 	
public$$ 
static$$ 
ProBuilderMesh$$ $#
CreateMeshWithTransform$$% <
($$< =
	Transform$$= F
t$$G H
,$$H I
bool$$J N
preserveFaces$$O \
)$$\ ]
{%% 	
Mesh&& 
m&& 
=&& 
t&& 
.&& 
GetComponent&& #
<&&# $

MeshFilter&&$ .
>&&. /
(&&/ 0
)&&0 1
.&&1 2

sharedMesh&&2 <
;&&< =
Vector3(( 
[(( 
](( 

m_vertices((  
=((! "
MeshUtility((# .
.((. /
GetMeshChannel((/ =
(((= >
t((> ?
.((? @

gameObject((@ J
,((J K
x((L M
=>((N P
x((Q R
.((R S
vertices((S [
)(([ \
;((\ ]
Color)) 
[)) 
])) 
m_colors)) 
=)) 
MeshUtility)) *
.))* +
GetMeshChannel))+ 9
())9 :
t)): ;
.)); <

gameObject))< F
,))F G
x))H I
=>))J L
x))M N
.))N O
colors))O U
)))U V
;))V W
Vector2** 
[** 
]** 
m_uvs** 
=** 
MeshUtility** )
.**) *
GetMeshChannel*** 8
(**8 9
t**9 :
.**: ;

gameObject**; E
,**E F
x**G H
=>**I K
x**L M
.**M N
uv**N P
)**P Q
;**Q R
List,, 
<,, 
Vector3,, 
>,, 
verts,, 
=,,  !
preserveFaces,," /
?,,0 1
new,,2 5
List,,6 :
<,,: ;
Vector3,,; B
>,,B C
(,,C D
m,,D E
.,,E F
vertices,,F N
),,N O
:,,P Q
new,,R U
List,,V Z
<,,Z [
Vector3,,[ b
>,,b c
(,,c d
),,d e
;,,e f
List-- 
<-- 
Color-- 
>-- 
cols-- 
=-- 
preserveFaces-- ,
?--- .
new--/ 2
List--3 7
<--7 8
Color--8 =
>--= >
(--> ?
m--? @
.--@ A
colors--A G
)--G H
:--I J
new--K N
List--O S
<--S T
Color--T Y
>--Y Z
(--Z [
)--[ \
;--\ ]
List.. 
<.. 
Vector2.. 
>.. 
uvs.. 
=.. 
preserveFaces..  -
?... /
new..0 3
List..4 8
<..8 9
Vector2..9 @
>..@ A
(..A B
m..B C
...C D
uv..D F
)..F G
:..H I
new..J M
List..N R
<..R S
Vector2..S Z
>..Z [
(..[ \
)..\ ]
;..] ^
List// 
<// 
Face// 
>// 
faces// 
=// 
new// "
List//# '
<//' (
Face//( ,
>//, -
(//- .
)//. /
;/// 0
for11 
(11 
int11 
n11 
=11 
$num11 
;11 
n11 
<11 
m11  !
.11! "
subMeshCount11" .
;11. /
n110 1
++111 3
)113 4
{22 
int33 
[33 
]33 
tris33 
=33 
m33 
.33 
GetTriangles33 +
(33+ ,
n33, -
)33- .
;33. /
for55 
(55 
int55 
i55 
=55 
$num55 
;55 
i55  !
<55" #
tris55$ (
.55( )
Length55) /
;55/ 0
i551 2
+=553 5
$num556 7
)557 8
{66 
int77 
index77 
=77 
-77  !
$num77! "
;77" #
if88 
(88 
preserveFaces88 %
)88% &
{99 
for:: 
(:: 
int::  
j::! "
=::# $
$num::% &
;::& '
j::( )
<::* +
faces::, 1
.::1 2
Count::2 7
;::7 8
j::9 :
++::: <
)::< =
{;; 
if<< 
(<<  
faces<<  %
[<<% &
j<<& '
]<<' (
.<<( )#
distinctIndexesInternal<<) @
.<<@ A
Contains<<A I
(<<I J
tris<<J N
[<<N O
i<<O P
+<<Q R
$num<<S T
]<<T U
)<<U V
||<<W Y
faces==  %
[==% &
j==& '
]==' (
.==( )#
distinctIndexesInternal==) @
.==@ A
Contains==A I
(==I J
tris==J N
[==N O
i==O P
+==Q R
$num==S T
]==T U
)==U V
||==W Y
faces>>  %
[>>% &
j>>& '
]>>' (
.>>( )#
distinctIndexesInternal>>) @
.>>@ A
Contains>>A I
(>>I J
tris>>J N
[>>N O
i>>O P
+>>Q R
$num>>S T
]>>T U
)>>U V
)>>V W
{?? 
index@@  %
=@@& '
j@@( )
;@@) *
breakAA  %
;AA% &
}BB 
}CC 
}DD 
ifFF 
(FF 
indexFF 
>FF 
-FF  !
$numFF! "
&&FF# %
preserveFacesFF& 3
)FF3 4
{GG 
intHH 
lenHH 
=HH  !
facesHH" '
[HH' (
indexHH( -
]HH- .
.HH. /
indexesInternalHH/ >
.HH> ?
LengthHH? E
;HHE F
intII 
[II 
]II 
arrII !
=II" #
newII$ '
intII( +
[II+ ,
lenII, /
+II0 1
$numII2 3
]II3 4
;II4 5
SystemJJ 
.JJ 
ArrayJJ $
.JJ$ %
CopyJJ% )
(JJ) *
facesJJ* /
[JJ/ 0
indexJJ0 5
]JJ5 6
.JJ6 7
indexesInternalJJ7 F
,JJF G
$numJJH I
,JJI J
arrJJK N
,JJN O
$numJJP Q
,JJQ R
lenJJS V
)JJV W
;JJW X
arrKK 
[KK 
lenKK 
+KK  !
$numKK" #
]KK# $
=KK% &
trisKK' +
[KK+ ,
iKK, -
+KK. /
$numKK0 1
]KK1 2
;KK2 3
arrLL 
[LL 
lenLL 
+LL  !
$numLL" #
]LL# $
=LL% &
trisLL' +
[LL+ ,
iLL, -
+LL. /
$numLL0 1
]LL1 2
;LL2 3
arrMM 
[MM 
lenMM 
+MM  !
$numMM" #
]MM# $
=MM% &
trisMM' +
[MM+ ,
iMM, -
+MM. /
$numMM0 1
]MM1 2
;MM2 3
facesNN 
[NN 
indexNN #
]NN# $
.NN$ %
indexesInternalNN% 4
=NN5 6
arrNN7 :
;NN: ;
}OO 
elsePP 
{QQ 
intRR 
[RR 
]RR 
faceTrisRR &
;RR& '
ifTT 
(TT 
preserveFacesTT )
)TT) *
{UU 
faceTrisVV $
=VV% &
newVV' *
intVV+ .
[VV. /
$numVV/ 0
]VV0 1
{WW 
trisXX  $
[XX$ %
iXX% &
+XX' (
$numXX) *
]XX* +
,XX+ ,
trisYY  $
[YY$ %
iYY% &
+YY' (
$numYY) *
]YY* +
,YY+ ,
trisZZ  $
[ZZ$ %
iZZ% &
+ZZ' (
$numZZ) *
]ZZ* +
}[[ 
;[[ 
}\\ 
else]] 
{^^ 
verts__ !
.__! "
Add__" %
(__% &

m_vertices__& 0
[__0 1
tris__1 5
[__5 6
i__6 7
+__8 9
$num__: ;
]__; <
]__< =
)__= >
;__> ?
verts`` !
.``! "
Add``" %
(``% &

m_vertices``& 0
[``0 1
tris``1 5
[``5 6
i``6 7
+``8 9
$num``: ;
]``; <
]``< =
)``= >
;``> ?
vertsaa !
.aa! "
Addaa" %
(aa% &

m_verticesaa& 0
[aa0 1
trisaa1 5
[aa5 6
iaa6 7
+aa8 9
$numaa: ;
]aa; <
]aa< =
)aa= >
;aa> ?
colscc  
.cc  !
Addcc! $
(cc$ %
m_colorscc% -
!=cc. 0
nullcc1 5
?cc6 7
m_colorscc8 @
[cc@ A
trisccA E
[ccE F
iccF G
+ccH I
$numccJ K
]ccK L
]ccL M
:ccN O
ColorccP U
.ccU V
whiteccV [
)cc[ \
;cc\ ]
colsdd  
.dd  !
Adddd! $
(dd$ %
m_colorsdd% -
!=dd. 0
nulldd1 5
?dd6 7
m_colorsdd8 @
[dd@ A
trisddA E
[ddE F
iddF G
+ddH I
$numddJ K
]ddK L
]ddL M
:ddN O
ColorddP U
.ddU V
whiteddV [
)dd[ \
;dd\ ]
colsee  
.ee  !
Addee! $
(ee$ %
m_colorsee% -
!=ee. 0
nullee1 5
?ee6 7
m_colorsee8 @
[ee@ A
triseeA E
[eeE F
ieeF G
+eeH I
$numeeJ K
]eeK L
]eeL M
:eeN O
ColoreeP U
.eeU V
whiteeeV [
)ee[ \
;ee\ ]
uvsgg 
.gg  
Addgg  #
(gg# $
m_uvsgg$ )
[gg) *
trisgg* .
[gg. /
igg/ 0
+gg1 2
$numgg3 4
]gg4 5
]gg5 6
)gg6 7
;gg7 8
uvshh 
.hh  
Addhh  #
(hh# $
m_uvshh$ )
[hh) *
trishh* .
[hh. /
ihh/ 0
+hh1 2
$numhh3 4
]hh4 5
]hh5 6
)hh6 7
;hh7 8
uvsii 
.ii  
Addii  #
(ii# $
m_uvsii$ )
[ii) *
trisii* .
[ii. /
iii/ 0
+ii1 2
$numii3 4
]ii4 5
]ii5 6
)ii6 7
;ii7 8
faceTriskk $
=kk% &
newkk' *
intkk+ .
[kk. /
$numkk/ 0
]kk0 1
{kk2 3
ikk4 5
+kk6 7
$numkk8 9
,kk9 :
ikk; <
+kk= >
$numkk? @
,kk@ A
ikkB C
+kkD E
$numkkF G
}kkH I
;kkI J
}ll 
facesnn 
.nn 
Addnn !
(nn! "
newoo 
Faceoo  $
(oo$ %
faceTrispp  (
,pp( )
nqq  !
,qq! "
AutoUnwrapSettingsrr  2
.rr2 3
tilerr3 7
,rr7 8
$numss  !
,ss! "
-tt  !
$numtt! "
,tt" #
-uu  !
$numuu! "
,uu" #
truevv  $
)ww  !
)ww! "
;ww" #
}xx 
}yy 
}zz 

GameObject|| 
go|| 
=|| 
(|| 

GameObject|| '
)||' (
Object||( .
.||. /
Instantiate||/ :
(||: ;
t||; <
.||< =

gameObject||= G
)||G H
;||H I
go}} 
.}} 
GetComponent}} 
<}} 

MeshFilter}} &
>}}& '
(}}' (
)}}( )
.}}) *

sharedMesh}}* 4
=}}5 6
null}}7 ;
;}}; <
ProBuilderMesh 
pb 
= 
go  "
." #
AddComponent# /
</ 0
ProBuilderMesh0 >
>> ?
(? @
)@ A
;A B
pb
€€ 
.
€€ *
RebuildWithPositionsAndFaces
€€ +
(
€€+ ,
verts
€€, 1
.
€€1 2
ToArray
€€2 9
(
€€9 :
)
€€: ;
,
€€; <
faces
€€= B
.
€€B C
ToArray
€€C J
(
€€J K
)
€€K L
)
€€L M
;
€€M N
pb
‚‚ 
.
‚‚ 
colorsInternal
‚‚ 
=
‚‚ 
cols
‚‚  $
.
‚‚$ %
ToArray
‚‚% ,
(
‚‚, -
)
‚‚- .
;
‚‚. /
pb
ƒƒ 
.
ƒƒ 
textures
ƒƒ 
=
ƒƒ 
uvs
ƒƒ 
;
ƒƒ 
pb
…… 
.
…… 

gameObject
…… 
.
…… 
name
…… 
=
……  
t
……! "
.
……" #
name
……# '
;
……' (
go
‡‡ 
.
‡‡ 
	transform
‡‡ 
.
‡‡ 
position
‡‡ !
=
‡‡" #
t
‡‡$ %
.
‡‡% &
position
‡‡& .
;
‡‡. /
go
ˆˆ 
.
ˆˆ 
	transform
ˆˆ 
.
ˆˆ 
localRotation
ˆˆ &
=
ˆˆ' (
t
ˆˆ) *
.
ˆˆ* +
localRotation
ˆˆ+ 8
;
ˆˆ8 9
go
‰‰ 
.
‰‰ 
	transform
‰‰ 
.
‰‰ 

localScale
‰‰ #
=
‰‰$ %
t
‰‰& '
.
‰‰' (

localScale
‰‰( 2
;
‰‰2 3
pb
‹‹ 
.
‹‹ 
CenterPivot
‹‹ 
(
‹‹ 
null
‹‹ 
)
‹‹  
;
‹‹  !
return
 
pb
 
;
 
}
 	
public
˜˜ 
static
˜˜ 
bool
˜˜ )
ResetPbObjectWithMeshFilter
˜˜ 6
(
˜˜6 7
ProBuilderMesh
˜˜7 E
pb
˜˜F H
,
˜˜H I
bool
˜˜J N
preserveFaces
˜˜O \
)
˜˜\ ]
{
™™ 	

MeshFilter
šš 
mf
šš 
=
šš 
pb
šš 
.
šš 

gameObject
šš )
.
šš) *
GetComponent
šš* 6
<
šš6 7

MeshFilter
šš7 A
>
ššA B
(
ššB C
)
ššC D
;
ššD E
if
œœ 
(
œœ 
mf
œœ 
==
œœ 
null
œœ 
||
œœ 
mf
œœ  
.
œœ  !

sharedMesh
œœ! +
==
œœ, .
null
œœ/ 3
)
œœ3 4
{
 
Log
 
.
 
Error
 
(
 
pb
 
.
 
name
 !
+
" #
$str
$ U
)
U V
;
V W
return
ŸŸ 
false
ŸŸ 
;
ŸŸ 
}
   
Mesh
¢¢ 
m
¢¢ 
=
¢¢ 
mf
¢¢ 
.
¢¢ 

sharedMesh
¢¢ "
;
¢¢" #
int
¤¤ 
vertexCount
¤¤ 
=
¤¤ 
m
¤¤ 
.
¤¤  
vertexCount
¤¤  +
;
¤¤+ ,
Vector3
¥¥ 
[
¥¥ 
]
¥¥ 
m_positions
¥¥ !
=
¥¥" #
MeshUtility
¥¥$ /
.
¥¥/ 0
GetMeshChannel
¥¥0 >
<
¥¥> ?
Vector3
¥¥? F
[
¥¥F G
]
¥¥G H
>
¥¥H I
(
¥¥I J
pb
¥¥J L
.
¥¥L M

gameObject
¥¥M W
,
¥¥W X
x
¥¥Y Z
=>
¥¥[ ]
x
¥¥^ _
.
¥¥_ `
vertices
¥¥` h
)
¥¥h i
;
¥¥i j
Color
¦¦ 
[
¦¦ 
]
¦¦ 
m_colors
¦¦ 
=
¦¦ 
MeshUtility
¦¦ *
.
¦¦* +
GetMeshChannel
¦¦+ 9
<
¦¦9 :
Color
¦¦: ?
[
¦¦? @
]
¦¦@ A
>
¦¦A B
(
¦¦B C
pb
¦¦C E
.
¦¦E F

gameObject
¦¦F P
,
¦¦P Q
x
¦¦R S
=>
¦¦T V
x
¦¦W X
.
¦¦X Y
colors
¦¦Y _
)
¦¦_ `
;
¦¦` a
Vector2
§§ 
[
§§ 
]
§§ 
m_uvs
§§ 
=
§§ 
MeshUtility
§§ )
.
§§) *
GetMeshChannel
§§* 8
<
§§8 9
Vector2
§§9 @
[
§§@ A
]
§§A B
>
§§B C
(
§§C D
pb
§§D F
.
§§F G

gameObject
§§G Q
,
§§Q R
x
§§S T
=>
§§U W
x
§§X Y
.
§§Y Z
uv
§§Z \
)
§§\ ]
;
§§] ^
List
©© 
<
©© 
Vector3
©© 
>
©© 
verts
©© 
=
©©  !
preserveFaces
©©" /
?
©©0 1
new
©©2 5
List
©©6 :
<
©©: ;
Vector3
©©; B
>
©©B C
(
©©C D
m
©©D E
.
©©E F
vertices
©©F N
)
©©N O
:
©©P Q
new
©©R U
List
©©V Z
<
©©Z [
Vector3
©©[ b
>
©©b c
(
©©c d
)
©©d e
;
©©e f
List
ªª 
<
ªª 
Color
ªª 
>
ªª 
cols
ªª 
=
ªª 
preserveFaces
ªª ,
?
ªª- .
new
ªª/ 2
List
ªª3 7
<
ªª7 8
Color
ªª8 =
>
ªª= >
(
ªª> ?
m
ªª? @
.
ªª@ A
colors
ªªA G
)
ªªG H
:
ªªI J
new
ªªK N
List
ªªO S
<
ªªS T
Color
ªªT Y
>
ªªY Z
(
ªªZ [
)
ªª[ \
;
ªª\ ]
List
«« 
<
«« 
Vector2
«« 
>
«« 
uvs
«« 
=
«« 
preserveFaces
««  -
?
««. /
new
««0 3
List
««4 8
<
««8 9
Vector2
««9 @
>
««@ A
(
««A B
m
««B C
.
««C D
uv
««D F
)
««F G
:
««H I
new
««J M
List
««N R
<
««R S
Vector2
««S Z
>
««Z [
(
««[ \
)
««\ ]
;
««] ^
List
¬¬ 
<
¬¬ 
Face
¬¬ 
>
¬¬ 
faces
¬¬ 
=
¬¬ 
new
¬¬ "
List
¬¬# '
<
¬¬' (
Face
¬¬( ,
>
¬¬, -
(
¬¬- .
)
¬¬. /
;
¬¬/ 0
MeshRenderer
®® 
mr
®® 
=
®® 
pb
®®  
.
®®  !

gameObject
®®! +
.
®®+ ,
GetComponent
®®, 8
<
®®8 9
MeshRenderer
®®9 E
>
®®E F
(
®®F G
)
®®G H
;
®®H I
if
¯¯ 
(
¯¯ 
mr
¯¯ 
==
¯¯ 
null
¯¯ 
)
¯¯ 
mr
¯¯ 
=
¯¯  
pb
¯¯! #
.
¯¯# $

gameObject
¯¯$ .
.
¯¯. /
AddComponent
¯¯/ ;
<
¯¯; <
MeshRenderer
¯¯< H
>
¯¯H I
(
¯¯I J
)
¯¯J K
;
¯¯K L
Material
±± 
[
±± 
]
±± 
sharedMaterials
±± &
=
±±' (
mr
±±) +
.
±±+ ,
sharedMaterials
±±, ;
;
±±; <
int
²² 

mat_length
²² 
=
²² 
sharedMaterials
²² ,
.
²², -
Length
²²- 3
;
²²3 4
for
´´ 
(
´´ 
int
´´ 
n
´´ 
=
´´ 
$num
´´ 
;
´´ 
n
´´ 
<
´´ 
m
´´  !
.
´´! "
subMeshCount
´´" .
;
´´. /
n
´´0 1
++
´´1 3
)
´´3 4
{
µµ 
int
¶¶ 
[
¶¶ 
]
¶¶ 
tris
¶¶ 
=
¶¶ 
m
¶¶ 
.
¶¶ 
GetTriangles
¶¶ +
(
¶¶+ ,
n
¶¶, -
)
¶¶- .
;
¶¶. /
for
·· 
(
·· 
int
·· 
i
·· 
=
·· 
$num
·· 
;
·· 
i
··  !
<
··" #
tris
··$ (
.
··( )
Length
··) /
;
··/ 0
i
··1 2
+=
··3 5
$num
··6 7
)
··7 8
{
¸¸ 
int
¹¹ 
index
¹¹ 
=
¹¹ 
-
¹¹  !
$num
¹¹! "
;
¹¹" #
if
ºº 
(
ºº 
preserveFaces
ºº %
)
ºº% &
{
»» 
for
¼¼ 
(
¼¼ 
int
¼¼  
j
¼¼! "
=
¼¼# $
$num
¼¼% &
;
¼¼& '
j
¼¼( )
<
¼¼* +
faces
¼¼, 1
.
¼¼1 2
Count
¼¼2 7
;
¼¼7 8
j
¼¼9 :
++
¼¼: <
)
¼¼< =
{
½½ 
if
¾¾ 
(
¾¾  
faces
¾¾  %
[
¾¾% &
j
¾¾& '
]
¾¾' (
.
¾¾( )%
distinctIndexesInternal
¾¾) @
.
¾¾@ A
Contains
¾¾A I
(
¾¾I J
tris
¾¾J N
[
¾¾N O
i
¾¾O P
+
¾¾Q R
$num
¾¾S T
]
¾¾T U
)
¾¾U V
||
¾¾W Y
faces
¿¿  %
[
¿¿% &
j
¿¿& '
]
¿¿' (
.
¿¿( )%
distinctIndexesInternal
¿¿) @
.
¿¿@ A
Contains
¿¿A I
(
¿¿I J
tris
¿¿J N
[
¿¿N O
i
¿¿O P
+
¿¿Q R
$num
¿¿S T
]
¿¿T U
)
¿¿U V
||
¿¿W Y
faces
ÀÀ  %
[
ÀÀ% &
j
ÀÀ& '
]
ÀÀ' (
.
ÀÀ( )%
distinctIndexesInternal
ÀÀ) @
.
ÀÀ@ A
Contains
ÀÀA I
(
ÀÀI J
tris
ÀÀJ N
[
ÀÀN O
i
ÀÀO P
+
ÀÀQ R
$num
ÀÀS T
]
ÀÀT U
)
ÀÀU V
)
ÀÀV W
{
ÁÁ 
index
ÂÂ  %
=
ÂÂ& '
j
ÂÂ( )
;
ÂÂ) *
break
ÃÃ  %
;
ÃÃ% &
}
ÄÄ 
}
ÅÅ 
}
ÆÆ 
if
ÈÈ 
(
ÈÈ 
index
ÈÈ 
>
ÈÈ 
-
ÈÈ  !
$num
ÈÈ! "
&&
ÈÈ# %
preserveFaces
ÈÈ& 3
)
ÈÈ3 4
{
ÉÉ 
int
ÊÊ 
len
ÊÊ 
=
ÊÊ  !
faces
ÊÊ" '
[
ÊÊ' (
index
ÊÊ( -
]
ÊÊ- .
.
ÊÊ. /
indexesInternal
ÊÊ/ >
.
ÊÊ> ?
Length
ÊÊ? E
;
ÊÊE F
int
ËË 
[
ËË 
]
ËË 
arr
ËË !
=
ËË" #
new
ËË$ '
int
ËË( +
[
ËË+ ,
len
ËË, /
+
ËË0 1
$num
ËË2 3
]
ËË3 4
;
ËË4 5
System
ÌÌ 
.
ÌÌ 
Array
ÌÌ $
.
ÌÌ$ %
Copy
ÌÌ% )
(
ÌÌ) *
faces
ÌÌ* /
[
ÌÌ/ 0
index
ÌÌ0 5
]
ÌÌ5 6
.
ÌÌ6 7
indexesInternal
ÌÌ7 F
,
ÌÌF G
$num
ÌÌH I
,
ÌÌI J
arr
ÌÌK N
,
ÌÌN O
$num
ÌÌP Q
,
ÌÌQ R
len
ÌÌS V
)
ÌÌV W
;
ÌÌW X
arr
ÍÍ 
[
ÍÍ 
len
ÍÍ 
+
ÍÍ  !
$num
ÍÍ" #
]
ÍÍ# $
=
ÍÍ% &
tris
ÍÍ' +
[
ÍÍ+ ,
i
ÍÍ, -
+
ÍÍ. /
$num
ÍÍ0 1
]
ÍÍ1 2
;
ÍÍ2 3
arr
ÎÎ 
[
ÎÎ 
len
ÎÎ 
+
ÎÎ  !
$num
ÎÎ" #
]
ÎÎ# $
=
ÎÎ% &
tris
ÎÎ' +
[
ÎÎ+ ,
i
ÎÎ, -
+
ÎÎ. /
$num
ÎÎ0 1
]
ÎÎ1 2
;
ÎÎ2 3
arr
ÏÏ 
[
ÏÏ 
len
ÏÏ 
+
ÏÏ  !
$num
ÏÏ" #
]
ÏÏ# $
=
ÏÏ% &
tris
ÏÏ' +
[
ÏÏ+ ,
i
ÏÏ, -
+
ÏÏ. /
$num
ÏÏ0 1
]
ÏÏ1 2
;
ÏÏ2 3
faces
ĞĞ 
[
ĞĞ 
index
ĞĞ #
]
ĞĞ# $
.
ĞĞ$ %
indexesInternal
ĞĞ% 4
=
ĞĞ5 6
arr
ĞĞ7 :
;
ĞĞ: ;
}
ÑÑ 
else
ÒÒ 
{
ÓÓ 
int
ÔÔ 
[
ÔÔ 
]
ÔÔ 
faceTris
ÔÔ &
;
ÔÔ& '
if
ÖÖ 
(
ÖÖ 
preserveFaces
ÖÖ )
)
ÖÖ) *
{
×× 
faceTris
ØØ $
=
ØØ% &
new
ØØ' *
int
ØØ+ .
[
ØØ. /
$num
ØØ/ 0
]
ØØ0 1
{
ÙÙ 
tris
ÚÚ  $
[
ÚÚ$ %
i
ÚÚ% &
+
ÚÚ' (
$num
ÚÚ) *
]
ÚÚ* +
,
ÚÚ+ ,
tris
ÛÛ  $
[
ÛÛ$ %
i
ÛÛ% &
+
ÛÛ' (
$num
ÛÛ) *
]
ÛÛ* +
,
ÛÛ+ ,
tris
ÜÜ  $
[
ÜÜ$ %
i
ÜÜ% &
+
ÜÜ' (
$num
ÜÜ) *
]
ÜÜ* +
}
İİ 
;
İİ 
}
ŞŞ 
else
ßß 
{
àà 
verts
áá !
.
áá! "
Add
áá" %
(
áá% &
m_positions
áá& 1
[
áá1 2
tris
áá2 6
[
áá6 7
i
áá7 8
+
áá9 :
$num
áá; <
]
áá< =
]
áá= >
)
áá> ?
;
áá? @
verts
ââ !
.
ââ! "
Add
ââ" %
(
ââ% &
m_positions
ââ& 1
[
ââ1 2
tris
ââ2 6
[
ââ6 7
i
ââ7 8
+
ââ9 :
$num
ââ; <
]
ââ< =
]
ââ= >
)
ââ> ?
;
ââ? @
verts
ãã !
.
ãã! "
Add
ãã" %
(
ãã% &
m_positions
ãã& 1
[
ãã1 2
tris
ãã2 6
[
ãã6 7
i
ãã7 8
+
ãã9 :
$num
ãã; <
]
ãã< =
]
ãã= >
)
ãã> ?
;
ãã? @
cols
åå  
.
åå  !
Add
åå! $
(
åå$ %
m_colors
åå% -
!=
åå. 0
null
åå1 5
&&
åå6 8
m_colors
åå9 A
.
ååA B
Length
ååB H
==
ååI K
vertexCount
ååL W
?
ååX Y
m_colors
ååZ b
[
ååb c
tris
ååc g
[
ååg h
i
ååh i
+
ååj k
$num
åål m
]
ååm n
]
åån o
:
ååp q
Color
åår w
.
ååw x
white
ååx }
)
åå} ~
;
åå~ 
cols
ææ  
.
ææ  !
Add
ææ! $
(
ææ$ %
m_colors
ææ% -
!=
ææ. 0
null
ææ1 5
&&
ææ6 8
m_colors
ææ9 A
.
ææA B
Length
ææB H
==
ææI K
vertexCount
ææL W
?
ææX Y
m_colors
ææZ b
[
ææb c
tris
ææc g
[
ææg h
i
ææh i
+
ææj k
$num
ææl m
]
ææm n
]
ææn o
:
ææp q
Color
æær w
.
ææw x
white
ææx }
)
ææ} ~
;
ææ~ 
cols
çç  
.
çç  !
Add
çç! $
(
çç$ %
m_colors
çç% -
!=
çç. 0
null
çç1 5
&&
çç6 8
m_colors
çç9 A
.
ççA B
Length
ççB H
==
ççI K
vertexCount
ççL W
?
ççX Y
m_colors
ççZ b
[
ççb c
tris
ççc g
[
ççg h
i
ççh i
+
ççj k
$num
ççl m
]
ççm n
]
ççn o
:
ççp q
Color
ççr w
.
ççw x
white
ççx }
)
çç} ~
;
çç~ 
uvs
éé 
.
éé  
Add
éé  #
(
éé# $
m_uvs
éé$ )
[
éé) *
tris
éé* .
[
éé. /
i
éé/ 0
+
éé1 2
$num
éé3 4
]
éé4 5
]
éé5 6
)
éé6 7
;
éé7 8
uvs
êê 
.
êê  
Add
êê  #
(
êê# $
m_uvs
êê$ )
[
êê) *
tris
êê* .
[
êê. /
i
êê/ 0
+
êê1 2
$num
êê3 4
]
êê4 5
]
êê5 6
)
êê6 7
;
êê7 8
uvs
ëë 
.
ëë  
Add
ëë  #
(
ëë# $
m_uvs
ëë$ )
[
ëë) *
tris
ëë* .
[
ëë. /
i
ëë/ 0
+
ëë1 2
$num
ëë3 4
]
ëë4 5
]
ëë5 6
)
ëë6 7
;
ëë7 8
faceTris
íí $
=
íí% &
new
íí' *
int
íí+ .
[
íí. /
$num
íí/ 0
]
íí0 1
{
íí2 3
i
íí4 5
+
íí6 7
$num
íí8 9
,
íí9 :
i
íí; <
+
íí= >
$num
íí? @
,
íí@ A
i
ííB C
+
ííD E
$num
ííF G
}
ííH I
;
ííI J
}
îî 
faces
ğğ 
.
ğğ 
Add
ğğ !
(
ğğ! "
new
ññ 
Face
ññ  $
(
ññ$ %
faceTris
òò  (
,
òò( )
Math
óó  $
.
óó$ %
Clamp
óó% *
(
óó* +
n
óó+ ,
,
óó, -
$num
óó. /
,
óó/ 0

mat_length
óó1 ;
-
óó< =
$num
óó> ?
)
óó? @
,
óó@ A 
AutoUnwrapSettings
ôô  2
.
ôô2 3
tile
ôô3 7
,
ôô7 8
$num
õõ  !
,
õõ! "
-
öö  !
$num
öö! "
,
öö" #
-
÷÷  !
$num
÷÷! "
,
÷÷" #
true
øø  $
)
ùù  !
)
ùù! "
;
ùù" #
}
úú 
}
ûû 
}
üü 
pb
şş 
.
şş 
positionsInternal
şş  
=
şş! "
verts
şş# (
.
şş( )
ToArray
şş) 0
(
şş0 1
)
şş1 2
;
şş2 3
pb
ÿÿ 
.
ÿÿ 
texturesInternal
ÿÿ 
=
ÿÿ  !
uvs
ÿÿ" %
.
ÿÿ% &
ToArray
ÿÿ& -
(
ÿÿ- .
)
ÿÿ. /
;
ÿÿ/ 0
pb
€€ 
.
€€ 
facesInternal
€€ 
=
€€ 
faces
€€ $
.
€€$ %
ToArray
€€% ,
(
€€, -
)
€€- .
;
€€. /
pb
 
.
 $
sharedVerticesInternal
 %
=
& '
SharedVertex
( 4
.
4 5,
GetSharedVerticesWithPositions
5 S
(
S T
verts
T Y
.
Y Z
ToArray
Z a
(
a b
)
b c
)
c d
;
d e
pb
‚‚ 
.
‚‚ 
colorsInternal
‚‚ 
=
‚‚ 
cols
‚‚  $
.
‚‚$ %
ToArray
‚‚% ,
(
‚‚, -
)
‚‚- .
;
‚‚. /
return
„„ 
true
„„ 
;
„„ 
}
…… 	
internal
‡‡ 
static
‡‡ 
void
‡‡ (
FilterUnusedSubmeshIndexes
‡‡ 7
(
‡‡7 8
ProBuilderMesh
‡‡8 F
mesh
‡‡G K
)
‡‡K L
{
ˆˆ 	
var
‰‰ 
	materials
‰‰ 
=
‰‰ 
mesh
‰‰  
.
‰‰  !
renderer
‰‰! )
.
‰‰) *
sharedMaterials
‰‰* 9
;
‰‰9 :
var
ŠŠ 
submeshCount
ŠŠ 
=
ŠŠ 
	materials
ŠŠ (
.
ŠŠ( )
Length
ŠŠ) /
;
ŠŠ/ 0
var
‹‹ 
used
‹‹ 
=
‹‹ 
new
‹‹ 
bool
‹‹ 
[
‹‹  
submeshCount
‹‹  ,
]
‹‹, -
;
‹‹- .
foreach
 
(
 
var
 
face
 
in
  
mesh
! %
.
% &
facesInternal
& 3
)
3 4
used
 
[
 
Math
 
.
 
Clamp
 
(
  
face
  $
.
$ %
submeshIndex
% 1
,
1 2
$num
3 4
,
4 5
submeshCount
6 B
-
C D
$num
E F
)
F G
]
G H
=
I J
true
K O
;
O P
var
 
unused
 
=
 
ArrUtil
  
.
  !
AllIndexesOf
! -
(
- .
used
. 2
,
2 3
x
4 5
=>
6 8
!
9 :
x
: ;
)
; <
;
< =
if
’’ 
(
’’ 
unused
’’ 
.
’’ 
Any
’’ 
(
’’ 
)
’’ 
)
’’ 
{
““ 
foreach
”” 
(
”” 
var
”” 
face
”” !
in
””" $
mesh
””% )
.
””) *
facesInternal
””* 7
)
””7 8
{
•• 
var
–– 
original
––  
=
––! "
face
––# '
.
––' (
submeshIndex
––( 4
;
––4 5
foreach
—— 
(
—— 
var
——  
index
——! &
in
——' )
unused
——* 0
)
——0 1
if
˜˜ 
(
˜˜ 
original
˜˜ $
>
˜˜% &
index
˜˜' ,
)
˜˜, -
face
™™  
.
™™  !
submeshIndex
™™! -
--
™™- /
;
™™/ 0
}
šš 
mesh
œœ 
.
œœ 
renderer
œœ 
.
œœ 
sharedMaterials
œœ -
=
œœ. /
ArrUtil
œœ0 7
.
œœ7 8
RemoveAt
œœ8 @
(
œœ@ A
	materials
œœA J
,
œœJ K
unused
œœL R
)
œœR S
;
œœS T
}
 
}
 	
}
ŸŸ 
}   Í
„D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Log.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ 
Flags 

]
 
enum 
LogLevel	 
{ 
None 
= 
$num 
, 
Error 
= 
$num 
, 
Warning 
= 
$num 
, 
Info 
= 
$num 
, 
Default 
= 
Error 
| 
Warning %
,% &
All 
= 
$num 
} 
[ 
Flags 

]
 
enum 
	LogOutput	 
{   
None!! 
=!! 
$num!! 
,!! 
Console"" 
="" 
$num"" 
,"" 
File## 
=## 
$num## 
,## 
}$$ 
static,, 

class,, 
Log,, 
{-- 
public.. 
const.. 
string.. #
k_ProBuilderLogFileName.. 3
=..4 5
$str..6 I
;..I J
static11 
Stack11 
<11 
LogLevel11 
>11 

s_logStack11 )
=11* +
new11, /
Stack110 5
<115 6
LogLevel116 >
>11> ?
(11? @
)11@ A
;11A B
static44 
LogLevel44 

s_LogLevel44 "
=44# $
LogLevel44% -
.44- .
All44. 1
;441 2
static77 
	LogOutput77 
s_Output77 !
=77" #
	LogOutput77$ -
.77- .
Console77. 5
;775 6
static:: 
string:: 
s_LogFilePath:: #
=::$ %#
k_ProBuilderLogFileName::& =
;::= >
public@@ 
static@@ 
void@@ 
PushLogLevel@@ '
(@@' (
LogLevel@@( 0
level@@1 6
)@@6 7
{AA 	

s_logStackBB 
.BB 
PushBB 
(BB 

s_LogLevelBB &
)BB& '
;BB' (

s_LogLevelCC 
=CC 
levelCC 
;CC 
}DD 	
publicII 
staticII 
voidII 
PopLogLevelII &
(II& '
)II' (
{JJ 	

s_LogLevelKK 
=KK 

s_logStackKK #
.KK# $
PopKK$ '
(KK' (
)KK( )
;KK) *
}LL 	
publicRR 
staticRR 
voidRR 
SetLogLevelRR &
(RR& '
LogLevelRR' /
levelRR0 5
)RR5 6
{SS 	

s_LogLevelTT 
=TT 
levelTT 
;TT 
}UU 	
public\\ 
static\\ 
void\\ 
	SetOutput\\ $
(\\$ %
	LogOutput\\% .
output\\/ 5
)\\5 6
{]] 	
s_Output^^ 
=^^ 
output^^ 
;^^ 
}__ 	
publicee 
staticee 
voidee 

SetLogFileee %
(ee% &
stringee& ,
pathee- 1
)ee1 2
{ff 	
s_LogFilePathgg 
=gg 
pathgg  
;gg  !
}hh 	
[pp 	
Conditionalpp	 
(pp 
$strpp 
)pp 
]pp 
publicqq 
staticqq 
voidqq 
Debugqq  
<qq  !
Tqq! "
>qq" #
(qq# $
Tqq$ %
valueqq& +
)qq+ ,
{rr 	
Debugss 
(ss 
valuess 
.ss 
ToStringss  
(ss  !
)ss! "
)ss" #
;ss# $
}tt 	
[}} 	
Conditional}}	 
(}} 
$str}} 
)}} 
]}} 
public~~ 
static~~ 
void~~ 
Debug~~  
(~~  !
string~~! '
message~~( /
)~~/ 0
{ 	
DoPrint
€€ 
(
€€ 
message
€€ 
,
€€ 
LogType
€€ $
.
€€$ %
Log
€€% (
)
€€( )
;
€€) *
}
 	
[
ƒƒ 	
Conditional
ƒƒ	 
(
ƒƒ 
$str
ƒƒ 
)
ƒƒ 
]
ƒƒ 
public
„„ 
static
„„ 
void
„„ 
Debug
„„  
(
„„  !
string
„„! '
format
„„( .
,
„„. /
params
„„0 6
object
„„7 =
[
„„= >
]
„„> ?
values
„„@ F
)
„„F G
{
…… 	
Debug
†† 
(
†† 
string
†† 
.
†† 
Format
†† 
(
††  
format
††  &
,
††& '
values
††( .
)
††. /
)
††/ 0
;
††0 1
}
‡‡ 	
public
 
static
 
void
 
Info
 
(
  
string
  &
format
' -
,
- .
params
/ 5
object
6 <
[
< =
]
= >
values
? E
)
E F
{
 	
Info
 
(
 
string
 
.
 
Format
 
(
 
format
 %
,
% &
values
' -
)
- .
)
. /
;
/ 0
}
‘‘ 	
public
““ 
static
““ 
void
““ 
Info
““ 
(
““  
string
““  &
message
““' .
)
““. /
{
”” 	
if
•• 
(
•• 
(
•• 

s_LogLevel
•• 
&
•• 
LogLevel
•• &
.
••& '
Info
••' +
)
••+ ,
>
••- .
$num
••/ 0
)
••0 1
DoPrint
–– 
(
–– 
message
–– 
,
––  
LogType
––! (
.
––( )
Log
––) ,
)
––, -
;
––- .
}
—— 	
public
 
static
 
void
 
Warning
 "
(
" #
string
# )
format
* 0
,
0 1
params
2 8
object
9 ?
[
? @
]
@ A
values
B H
)
H I
{
ŸŸ 	
Warning
   
(
   
string
   
.
   
Format
   !
(
  ! "
format
  " (
,
  ( )
values
  * 0
)
  0 1
)
  1 2
;
  2 3
}
¡¡ 	
public
££ 
static
££ 
void
££ 
Warning
££ "
(
££" #
string
££# )
message
££* 1
)
££1 2
{
¤¤ 	
if
¥¥ 
(
¥¥ 
(
¥¥ 

s_LogLevel
¥¥ 
&
¥¥ 
LogLevel
¥¥ &
.
¥¥& '
Warning
¥¥' .
)
¥¥. /
>
¥¥0 1
$num
¥¥2 3
)
¥¥3 4
DoPrint
¦¦ 
(
¦¦ 
message
¦¦ 
,
¦¦  
LogType
¦¦! (
.
¦¦( )
Warning
¦¦) 0
)
¦¦0 1
;
¦¦1 2
}
§§ 	
public
®® 
static
®® 
void
®® 
Error
®®  
(
®®  !
string
®®! '
format
®®( .
,
®®. /
params
®®0 6
object
®®7 =
[
®®= >
]
®®> ?
values
®®@ F
)
®®F G
{
¯¯ 	
Error
°° 
(
°° 
string
°° 
.
°° 
Format
°° 
(
°°  
format
°°  &
,
°°& '
values
°°( .
)
°°. /
)
°°/ 0
;
°°0 1
}
±± 	
public
³³ 
static
³³ 
void
³³ 
Error
³³  
(
³³  !
string
³³! '
message
³³( /
)
³³/ 0
{
´´ 	
if
µµ 
(
µµ 
(
µµ 

s_LogLevel
µµ 
&
µµ 
LogLevel
µµ &
.
µµ& '
Error
µµ' ,
)
µµ, -
>
µµ. /
$num
µµ0 1
)
µµ1 2
DoPrint
¶¶ 
(
¶¶ 
message
¶¶ 
,
¶¶  
LogType
¶¶! (
.
¶¶( )
Error
¶¶) .
)
¶¶. /
;
¶¶/ 0
}
·· 	
[
ÀÀ 	
Conditional
ÀÀ	 
(
ÀÀ 
$str
ÀÀ *
)
ÀÀ* +
]
ÀÀ+ ,
internal
ÁÁ 
static
ÁÁ 
void
ÁÁ 
Watch
ÁÁ "
<
ÁÁ" #
T
ÁÁ# $
,
ÁÁ$ %
K
ÁÁ& '
>
ÁÁ' (
(
ÁÁ( )
T
ÁÁ) *
key
ÁÁ+ .
,
ÁÁ. /
K
ÁÁ0 1
value
ÁÁ2 7
)
ÁÁ7 8
{
ÂÂ 	
UnityEngine
ÃÃ 
.
ÃÃ 
Debug
ÃÃ 
.
ÃÃ 
Log
ÃÃ !
(
ÃÃ! "
string
ÃÃ" (
.
ÃÃ( )
Format
ÃÃ) /
(
ÃÃ/ 0
$str
ÃÃ0 i
,
ÃÃi j
key
ÃÃk n
.
ÃÃn o
ToString
ÃÃo w
(
ÃÃw x
)
ÃÃx y
,
ÃÃy z
valueÃÃ{ €
.ÃÃ€ 
ToStringÃÃ ‰
(ÃÃ‰ Š
)ÃÃŠ ‹
)ÃÃ‹ Œ
)ÃÃŒ 
;ÃÃ 
}
ÄÄ 	
static
ÆÆ 
void
ÆÆ 
DoPrint
ÆÆ 
(
ÆÆ 
string
ÆÆ "
message
ÆÆ# *
,
ÆÆ* +
LogType
ÆÆ, 3
type
ÆÆ4 8
)
ÆÆ8 9
{
ÇÇ 	
if
ÈÈ 
(
ÈÈ 
(
ÈÈ 
s_Output
ÈÈ 
&
ÈÈ 
	LogOutput
ÈÈ %
.
ÈÈ% &
Console
ÈÈ& -
)
ÈÈ- .
>
ÈÈ/ 0
$num
ÈÈ1 2
)
ÈÈ2 3
PrintToConsole
ÉÉ 
(
ÉÉ 
message
ÉÉ &
,
ÉÉ& '
type
ÉÉ( ,
)
ÉÉ, -
;
ÉÉ- .
if
ËË 
(
ËË 
(
ËË 
s_Output
ËË 
&
ËË 
	LogOutput
ËË %
.
ËË% &
File
ËË& *
)
ËË* +
>
ËË, -
$num
ËË. /
)
ËË/ 0
PrintToFile
ÌÌ 
(
ÌÌ 
message
ÌÌ #
,
ÌÌ# $
s_LogFilePath
ÌÌ% 2
)
ÌÌ2 3
;
ÌÌ3 4
}
ÍÍ 	
static
ÔÔ 
void
ÔÔ 
PrintToFile
ÔÔ 
(
ÔÔ  
string
ÔÔ  &
message
ÔÔ' .
,
ÔÔ. /
string
ÔÔ0 6
path
ÔÔ7 ;
)
ÔÔ; <
{
ÕÕ 	
if
ÖÖ 
(
ÖÖ 
string
ÖÖ 
.
ÖÖ 
IsNullOrEmpty
ÖÖ $
(
ÖÖ$ %
path
ÖÖ% )
)
ÖÖ) *
)
ÖÖ* +
return
×× 
;
×× 
string
ÙÙ 
	full_path
ÙÙ 
=
ÙÙ 
Path
ÙÙ #
.
ÙÙ# $
GetFullPath
ÙÙ$ /
(
ÙÙ/ 0
path
ÙÙ0 4
)
ÙÙ4 5
;
ÙÙ5 6
if
ÛÛ 
(
ÛÛ 
string
ÛÛ 
.
ÛÛ 
IsNullOrEmpty
ÛÛ $
(
ÛÛ$ %
	full_path
ÛÛ% .
)
ÛÛ. /
)
ÛÛ/ 0
{
ÜÜ 
Log
İİ 
.
İİ 
PrintToConsole
İİ "
(
İİ" #
$str
İİ# 8
+
İİ9 :
	full_path
İİ; D
)
İİD E
;
İİE F
return
ŞŞ 
;
ŞŞ 
}
ßß 
if
áá 
(
áá 
!
áá 
File
áá 
.
áá 
Exists
áá 
(
áá 
	full_path
áá &
)
áá& '
)
áá' (
{
ââ 
string
ãã 
	directory
ãã  
=
ãã! "
Path
ãã# '
.
ãã' (
GetDirectoryName
ãã( 8
(
ãã8 9
	full_path
ãã9 B
)
ããB C
;
ããC D
if
åå 
(
åå 
string
åå 
.
åå 
IsNullOrEmpty
åå (
(
åå( )
	directory
åå) 2
)
åå2 3
)
åå3 4
{
ææ 
Log
çç 
.
çç 
PrintToConsole
çç &
(
çç& '
$str
çç' <
+
çç= >
	full_path
çç? H
)
ççH I
;
ççI J
return
èè 
;
èè 
}
éé 
	Directory
ëë 
.
ëë 
CreateDirectory
ëë )
(
ëë) *
	directory
ëë* 3
)
ëë3 4
;
ëë4 5
using
íí 
(
íí 
StreamWriter
íí #
sw
íí$ &
=
íí' (
File
íí) -
.
íí- .

CreateText
íí. 8
(
íí8 9
	full_path
íí9 B
)
ííB C
)
ííC D
{
îî 
sw
ïï 
.
ïï 
	WriteLine
ïï  
(
ïï  !
message
ïï! (
)
ïï( )
;
ïï) *
}
ğğ 
}
ññ 
else
òò 
{
óó 
using
ôô 
(
ôô 
StreamWriter
ôô #
sw
ôô$ &
=
ôô' (
File
ôô) -
.
ôô- .

AppendText
ôô. 8
(
ôô8 9
	full_path
ôô9 B
)
ôôB C
)
ôôC D
{
õõ 
sw
÷÷ 
.
÷÷ 
	WriteLine
÷÷  
(
÷÷  !
message
÷÷! (
)
÷÷( )
;
÷÷) *
}
øø 
}
ùù 
}
úú 	
public
ÿÿ 
static
ÿÿ 
void
ÿÿ 
ClearLogFile
ÿÿ '
(
ÿÿ' (
)
ÿÿ( )
{
€€ 	
if
 
(
 
File
 
.
 
Exists
 
(
 
s_LogFilePath
 )
)
) *
)
* +
File
‚‚ 
.
‚‚ 
Delete
‚‚ 
(
‚‚ 
s_LogFilePath
‚‚ )
)
‚‚) *
;
‚‚* +
}
ƒƒ 	
static
ŠŠ 
void
ŠŠ 
PrintToConsole
ŠŠ "
(
ŠŠ" #
string
ŠŠ# )
message
ŠŠ* 1
,
ŠŠ1 2
LogType
ŠŠ3 :
type
ŠŠ; ?
=
ŠŠ@ A
LogType
ŠŠB I
.
ŠŠI J
Log
ŠŠJ M
)
ŠŠM N
{
‹‹ 	
if
ŒŒ 
(
ŒŒ 
type
ŒŒ 
==
ŒŒ 
LogType
ŒŒ 
.
ŒŒ  
Log
ŒŒ  #
)
ŒŒ# $
UnityEngine
 
.
 
Debug
 !
.
! "
Log
" %
(
% &
message
& -
)
- .
;
. /
else
 
if
 
(
 
type
 
==
 
LogType
 $
.
$ %
Warning
% ,
)
, -
UnityEngine
 
.
 
Debug
 !
.
! "

LogWarning
" ,
(
, -
message
- 4
)
4 5
;
5 6
else
 
if
 
(
 
type
 
==
 
LogType
 $
.
$ %
Error
% *
)
* +
UnityEngine
‘‘ 
.
‘‘ 
Debug
‘‘ !
.
‘‘! "
LogError
‘‘" *
(
‘‘* +
message
‘‘+ 2
)
‘‘2 3
;
‘‘3 4
else
’’ 
if
’’ 
(
’’ 
type
’’ 
==
’’ 
LogType
’’ $
.
’’$ %
Assert
’’% +
)
’’+ ,
UnityEngine
”” 
.
”” 
Debug
”” !
.
””! "
LogAssertion
””" .
(
””. /
message
””/ 6
)
””6 7
;
””7 8
else
˜˜ 
UnityEngine
™™ 
.
™™ 
Debug
™™ !
.
™™! "
Log
™™" %
(
™™% &
message
™™& -
)
™™- .
;
™™. /
}
šš 	
internal
œœ 
static
œœ 
void
œœ 
NotNull
œœ $
<
œœ$ %
T
œœ% &
>
œœ& '
(
œœ' (
T
œœ( )
obj
œœ* -
,
œœ- .
string
œœ/ 5
message
œœ6 =
)
œœ= >
{
 	
if
 
(
 
obj
 
==
 
null
 
)
 
throw
ŸŸ 
new
ŸŸ #
ArgumentNullException
ŸŸ /
(
ŸŸ/ 0
message
ŸŸ0 7
)
ŸŸ7 8
;
ŸŸ8 9
}
   	
}
¡¡ 
}¢¢ ë
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\EntityBehaviour.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
abstract 
class 
EntityBehaviour "
:# $
MonoBehaviour% 2
{		 
[

 	
Tooltip

	 
(

 
$str

 r
)

r s
]

s t
public 
bool 
manageVisibility $
=% &
true' +
;+ ,
public 
abstract 
void 

Initialize '
(' (
)( )
;) *
public 
abstract 
void 
OnEnterPlayMode ,
(, -
)- .
;. /
public 
abstract 
void 
OnSceneLoaded *
(* +
Scene+ 0
scene1 6
,6 7
LoadSceneMode8 E
modeF J
)J K
;K L
	protected 
void 
SetMaterial "
(" #
Material# +
material, 4
)4 5
{ 	
if 
( 
GetComponent 
< 
Renderer %
>% &
(& '
)' (
)( )
GetComponent 
< 
Renderer %
>% &
(& '
)' (
.( )
sharedMaterial) 7
=8 9
material: B
;B C
else 

gameObject 
. 
AddComponent '
<' (
MeshRenderer( 4
>4 5
(5 6
)6 7
.7 8
sharedMaterial8 F
=G H
materialI Q
;Q R
} 	
} 
} n
’D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\VertexPositioning.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

static 
class 
VertexPositioning )
{ 
static 
List 
< 
int 
>  
s_CoincidentVertices -
=. /
new0 3
List4 8
<8 9
int9 <
>< =
(= >
)> ?
;? @
public 
static 
Vector3 
[ 
]  
VerticesInWorldSpace  4
(4 5
this5 9
ProBuilderMesh: H
meshI M
)M N
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new !
ArgumentNullException /
(/ 0
$str0 6
)6 7
;7 8
int 
len 
= 
mesh 
. 
vertexCount &
;& '
Vector3 
[ 
] 
worldPoints !
=" #
new$ '
Vector3( /
[/ 0
len0 3
]3 4
;4 5
Vector3 
[ 
] 
localPoints !
=" #
mesh$ (
.( )
positionsInternal) :
;: ;
for 
( 
int 
i 
= 
$num 
; 
i 
< 
len  #
;# $
i% &
++& (
)( )
worldPoints 
[ 
i 
] 
=  
mesh! %
.% &
	transform& /
./ 0
TransformPoint0 >
(> ?
localPoints? J
[J K
iK L
]L M
)M N
;N O
return!! 
worldPoints!! 
;!! 
}"" 	
public,, 
static,, 
void,, )
TranslateVerticesInWorldSpace,, 8
(,,8 9
this,,9 =
ProBuilderMesh,,> L
mesh,,M Q
,,,Q R
int,,S V
[,,V W
],,W X
indexes,,Y `
,,,` a
Vector3,,b i
offset,,j p
),,p q
{-- 	
if.. 
(.. 
mesh.. 
==.. 
null.. 
).. 
throw// 
new// !
ArgumentNullException// /
(/// 0
$str//0 6
)//6 7
;//7 8
mesh11 
.11 )
TranslateVerticesInWorldSpace11 .
(11. /
indexes11/ 6
,116 7
offset118 >
,11> ?
$num11@ B
,11B C
false11D I
)11I J
;11J K
}22 	
internal>> 
static>> 
void>> )
TranslateVerticesInWorldSpace>> :
(>>: ;
this>>; ?
ProBuilderMesh>>@ N
mesh>>O S
,>>S T
int?? 
[?? 
]?? 
indexes?? 
,?? 
Vector3@@ 
offset@@ 
,@@ 
floatAA 
	snapValueAA 
,AA 
boolBB 
snapAxisOnlyBB 
)BB 
{CC 	
ifDD 
(DD 
meshDD 
==DD 
nullDD 
)DD 
throwEE 
newEE !
ArgumentNullExceptionEE /
(EE/ 0
$strEE0 6
)EE6 7
;EE7 8
intGG 
iGG 
=GG 
$numGG 
;GG 
meshII 
.II !
GetCoincidentVerticesII &
(II& '
indexesII' .
,II. / 
s_CoincidentVerticesII0 D
)IID E
;IIE F
	Matrix4x4KK 
w2lKK 
=KK 
meshKK  
.KK  !
	transformKK! *
.KK* +
worldToLocalMatrixKK+ =
;KK= >
Vector3MM 
localOffsetMM 
=MM  !
w2lMM" %
*MM& '
offsetMM( .
;MM. /
Vector3OO 
[OO 
]OO 
vertsOO 
=OO 
meshOO "
.OO" #
positionsInternalOO# 4
;OO4 5
ifRR 
(RR 
MathfRR 
.RR 
AbsRR 
(RR 
	snapValueRR #
)RR# $
>RR% &
MathfRR' ,
.RR, -
EpsilonRR- 4
)RR4 5
{SS 
	Matrix4x4TT 
l2wTT 
=TT 
meshTT  $
.TT$ %
	transformTT% .
.TT. /
localToWorldMatrixTT/ A
;TTA B
varUU 
maskUU 
=UU 
snapAxisOnlyUU '
?UU( )
newUU* -
Vector3MaskUU. 9
(UU9 :
offsetUU: @
,UU@ A
MathUUB F
.UUF G
handleEpsilonUUG T
)UUT U
:UUV W
Vector3MaskUUX c
.UUc d
XYZUUd g
;UUg h
forWW 
(WW 
iWW 
=WW 
$numWW 
;WW 
iWW 
<WW  
s_CoincidentVerticesWW  4
.WW4 5
CountWW5 :
;WW: ;
iWW< =
++WW= ?
)WW? @
{XX 
varYY 
vYY 
=YY 
l2wYY 
.YY  
MultiplyPoint3x4YY  0
(YY0 1
vertsYY1 6
[YY6 7 
s_CoincidentVerticesYY7 K
[YYK L
iYYL M
]YYM N
]YYN O
+YYP Q
localOffsetYYR ]
)YY] ^
;YY^ _
vertsZZ 
[ZZ  
s_CoincidentVerticesZZ .
[ZZ. /
iZZ/ 0
]ZZ0 1
]ZZ1 2
=ZZ3 4
w2lZZ5 8
.ZZ8 9
MultiplyPoint3x4ZZ9 I
(ZZI J
ProBuilderSnappingZZJ \
.ZZ\ ]
	SnapValueZZ] f
(ZZf g
vZZg h
,ZZh i
(ZZj k
(ZZk l
Vector3ZZl s
)ZZs t
maskZZt x
)ZZx y
*ZZz {
	snapValue	ZZ| …
)
ZZ… †
)
ZZ† ‡
;
ZZ‡ ˆ
}[[ 
}\\ 
else]] 
{^^ 
for__ 
(__ 
i__ 
=__ 
$num__ 
;__ 
i__ 
<__  
s_CoincidentVertices__  4
.__4 5
Count__5 :
;__: ;
i__< =
++__= ?
)__? @
verts`` 
[``  
s_CoincidentVertices`` .
[``. /
i``/ 0
]``0 1
]``1 2
+=``3 5
localOffset``6 A
;``A B
}aa 
meshdd 
.dd 
positionsInternaldd "
=dd# $
vertsdd% *
;dd* +
meshee 
.ee 
meshee 
.ee 
verticesee 
=ee  
vertsee! &
;ee& '
}ff 	
publicpp 
staticpp 
voidpp 
TranslateVerticespp ,
(pp, -
thispp- 1
ProBuilderMeshpp2 @
meshppA E
,ppE F
IEnumerableppG R
<ppR S
intppS V
>ppV W
indexesppX _
,pp_ `
Vector3ppa h
offsetppi o
)ppo p
{qq 	
ifrr 
(rr 
meshrr 
==rr 
nullrr 
)rr 
throwss 
newss !
ArgumentNullExceptionss /
(ss/ 0
$strss0 6
)ss6 7
;ss7 8
meshtt 
.tt !
GetCoincidentVerticestt &
(tt& '
indexestt' .
,tt. / 
s_CoincidentVerticestt0 D
)ttD E
;ttE F%
TranslateVerticesInternaluu %
(uu% &
meshuu& *
,uu* + 
s_CoincidentVerticesuu, @
,uu@ A
offsetuuB H
)uuH I
;uuI J
}vv 	
public
€€ 
static
€€ 
void
€€ 
TranslateVertices
€€ ,
(
€€, -
this
€€- 1
ProBuilderMesh
€€2 @
mesh
€€A E
,
€€E F
IEnumerable
€€G R
<
€€R S
Edge
€€S W
>
€€W X
edges
€€Y ^
,
€€^ _
Vector3
€€` g
offset
€€h n
)
€€n o
{
 	
if
‚‚ 
(
‚‚ 
mesh
‚‚ 
==
‚‚ 
null
‚‚ 
)
‚‚ 
throw
ƒƒ 
new
ƒƒ #
ArgumentNullException
ƒƒ /
(
ƒƒ/ 0
$str
ƒƒ0 6
)
ƒƒ6 7
;
ƒƒ7 8
mesh
„„ 
.
„„ #
GetCoincidentVertices
„„ &
(
„„& '
edges
„„' ,
,
„„, -"
s_CoincidentVertices
„„. B
)
„„B C
;
„„C D'
TranslateVerticesInternal
…… %
(
……% &
mesh
……& *
,
……* +"
s_CoincidentVertices
……, @
,
……@ A
offset
……B H
)
……H I
;
……I J
}
†† 	
public
 
static
 
void
 
TranslateVertices
 ,
(
, -
this
- 1
ProBuilderMesh
2 @
mesh
A E
,
E F
IEnumerable
G R
<
R S
Face
S W
>
W X
faces
Y ^
,
^ _
Vector3
` g
offset
h n
)
n o
{
‘‘ 	
if
’’ 
(
’’ 
mesh
’’ 
==
’’ 
null
’’ 
)
’’ 
throw
““ 
new
““ #
ArgumentNullException
““ /
(
““/ 0
$str
““0 6
)
““6 7
;
““7 8
mesh
”” 
.
”” #
GetCoincidentVertices
”” &
(
””& '
faces
””' ,
,
””, -"
s_CoincidentVertices
””. B
)
””B C
;
””C D'
TranslateVerticesInternal
•• %
(
••% &
mesh
••& *
,
••* +"
s_CoincidentVertices
••, @
,
••@ A
offset
••B H
)
••H I
;
••I J
}
–– 	
static
˜˜ 
void
˜˜ '
TranslateVerticesInternal
˜˜ -
(
˜˜- .
ProBuilderMesh
˜˜. <
mesh
˜˜= A
,
˜˜A B
IEnumerable
˜˜C N
<
˜˜N O
int
˜˜O R
>
˜˜R S
indices
˜˜T [
,
˜˜[ \
Vector3
˜˜] d
offset
˜˜e k
)
˜˜k l
{
™™ 	
Vector3
šš 
[
šš 
]
šš 
verts
šš 
=
šš 
mesh
šš "
.
šš" #
positionsInternal
šš# 4
;
šš4 5
for
œœ 
(
œœ 
int
œœ 
i
œœ 
=
œœ 
$num
œœ 
,
œœ 
c
œœ 
=
œœ "
s_CoincidentVertices
œœ  4
.
œœ4 5
Count
œœ5 :
;
œœ: ;
i
œœ< =
<
œœ> ?
c
œœ@ A
;
œœA B
i
œœC D
++
œœD F
)
œœF G
verts
 
[
 "
s_CoincidentVertices
 *
[
* +
i
+ ,
]
, -
]
- .
+=
/ 1
offset
2 8
;
8 9
mesh
   
.
   
mesh
   
.
   
vertices
   
=
    
verts
  ! &
;
  & '
}
¡¡ 	
public
¬¬ 
static
¬¬ 
void
¬¬ %
SetSharedVertexPosition
¬¬ 2
(
¬¬2 3
this
¬¬3 7
ProBuilderMesh
¬¬8 F
mesh
¬¬G K
,
¬¬K L
int
¬¬M P 
sharedVertexHandle
¬¬Q c
,
¬¬c d
Vector3
¬¬e l
position
¬¬m u
)
¬¬u v
{
­­ 	
if
®® 
(
®® 
mesh
®® 
==
®® 
null
®® 
)
®® 
throw
¯¯ 
new
¯¯ #
ArgumentNullException
¯¯ /
(
¯¯/ 0
$str
¯¯0 6
)
¯¯6 7
;
¯¯7 8
Vector3
±± 
[
±± 
]
±± 
v
±± 
=
±± 
mesh
±± 
.
±± 
positionsInternal
±± 0
;
±±0 1
foreach
³³ 
(
³³ 
var
³³ 
index
³³ 
in
³³ !
mesh
³³" &
.
³³& '$
sharedVerticesInternal
³³' =
[
³³= > 
sharedVertexHandle
³³> P
]
³³P Q
)
³³Q R
v
´´ 
[
´´ 
index
´´ 
]
´´ 
=
´´ 
position
´´ #
;
´´# $
mesh
¶¶ 
.
¶¶ 
positionsInternal
¶¶ "
=
¶¶# $
v
¶¶% &
;
¶¶& '
mesh
·· 
.
·· 
mesh
·· 
.
·· 
vertices
·· 
=
··  
v
··! "
;
··" #
}
¸¸ 	
internal
ÂÂ 
static
ÂÂ 
void
ÂÂ #
SetSharedVertexValues
ÂÂ 2
(
ÂÂ2 3
this
ÂÂ3 7
ProBuilderMesh
ÂÂ8 F
mesh
ÂÂG K
,
ÂÂK L
int
ÂÂM P 
sharedVertexHandle
ÂÂQ c
,
ÂÂc d
Vertex
ÂÂe k
vertex
ÂÂl r
)
ÂÂr s
{
ÃÃ 	
Vertex
ÄÄ 
[
ÄÄ 
]
ÄÄ 
vertices
ÄÄ 
=
ÄÄ 
mesh
ÄÄ  $
.
ÄÄ$ %
GetVertices
ÄÄ% 0
(
ÄÄ0 1
)
ÄÄ1 2
;
ÄÄ2 3
foreach
ÆÆ 
(
ÆÆ 
var
ÆÆ 
index
ÆÆ 
in
ÆÆ !
mesh
ÆÆ" &
.
ÆÆ& '$
sharedVerticesInternal
ÆÆ' =
[
ÆÆ= > 
sharedVertexHandle
ÆÆ> P
]
ÆÆP Q
)
ÆÆQ R
vertices
ÇÇ 
[
ÇÇ 
index
ÇÇ 
]
ÇÇ 
=
ÇÇ  !
vertex
ÇÇ" (
;
ÇÇ( )
mesh
ÉÉ 
.
ÉÉ 
SetVertices
ÉÉ 
(
ÉÉ 
vertices
ÉÉ %
)
ÉÉ% &
;
ÉÉ& '
}
ÊÊ 	
}
ËË 
}ÌÌ ‹ë
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SelectionPicker.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

static 
class 
SelectionPicker '
{		 
public 
static 

Dictionary  
<  !
ProBuilderMesh! /
,/ 0
HashSet1 8
<8 9
int9 <
>< =
>= >
PickVerticesInRect? Q
(Q R
Camera 
cam 
, 
Rect 
rect 
, 
IList 
< 
ProBuilderMesh  
>  !

selectable" ,
,, -
PickerOptions 
options !
,! "
float 
pixelsPerPoint  
=! "
$num# %
)% &
{ 	
if 
( 
options 
. 
	depthTest !
)! "
{ 
return #
SelectionPickerRenderer .
.. /
PickVerticesInRect/ A
(A B
cam 
, 
rect 
, 

selectable 
, 
true   
,   
(!! 
int!! 
)!! 
(!! 
cam!! 
.!! 

pixelWidth!! (
/!!) *
pixelsPerPoint!!+ 9
)!!9 :
,!!: ;
("" 
int"" 
)"" 
("" 
cam"" 
."" 
pixelHeight"" )
/""* +
pixelsPerPoint"", :
)"": ;
)""; <
;""< =
}## 
var'' 
selected'' 
='' 
new'' 

Dictionary'' )
<'') *
ProBuilderMesh''* 8
,''8 9
HashSet'': A
<''A B
int''B E
>''E F
>''F G
(''G H
)''H I
;''I J
foreach)) 
()) 
var)) 
pb)) 
in)) 

selectable)) )
)))) *
{** 
if++ 
(++ 
!++ 
pb++ 
.++ 

selectable++ "
)++" #
continue,, 
;,, 
SharedVertex.. 
[.. 
].. 
sharedIndexes.. ,
=..- .
pb../ 1
...1 2"
sharedVerticesInternal..2 H
;..H I
HashSet// 
<// 
int// 
>// 
inRect// #
=//$ %
new//& )
HashSet//* 1
<//1 2
int//2 5
>//5 6
(//6 7
)//7 8
;//8 9
Vector300 
[00 
]00 
	positions00 #
=00$ %
pb00& (
.00( )
positionsInternal00) :
;00: ;
var11 
trs11 
=11 
pb11 
.11 
	transform11 &
;11& '
float22 
pixelHeight22 !
=22" #
cam22$ '
.22' (
pixelHeight22( 3
;223 4
for44 
(44 
int44 
n44 
=44 
$num44 
;44 
n44  !
<44" #
sharedIndexes44$ 1
.441 2
Length442 8
;448 9
n44: ;
++44; =
)44= >
{55 
Vector366 
v66 
=66 
trs66  #
.66# $
TransformPoint66$ 2
(662 3
	positions663 <
[66< =
sharedIndexes66= J
[66J K
n66K L
]66L M
[66M N
$num66N O
]66O P
]66P Q
)66Q R
;66R S
Vector377 
p77 
=77 
cam77  #
.77# $
WorldToScreenPoint77$ 6
(776 7
v777 8
)778 9
;779 :
if99 
(99 
p99 
.99 
z99 
<99 
cam99 !
.99! "
nearClipPlane99" /
)99/ 0
continue::  
;::  !
p<< 
.<< 
x<< 
/=<< 
pixelsPerPoint<< )
;<<) *
p== 
.== 
y== 
=== 
(== 
pixelHeight== &
-==' (
p==) *
.==* +
y==+ ,
)==, -
/==. /
pixelsPerPoint==0 >
;==> ?
if?? 
(?? 
rect?? 
.?? 
Contains?? %
(??% &
p??& '
)??' (
)??( )
inRect@@ 
.@@ 
Add@@ "
(@@" #
n@@# $
)@@$ %
;@@% &
}AA 
selectedCC 
.CC 
AddCC 
(CC 
pbCC 
,CC  
inRectCC! '
)CC' (
;CC( )
}DD 
returnFF 
selectedFF 
;FF 
}GG 	
publicRR 
staticRR 

DictionaryRR  
<RR  !
ProBuilderMeshRR! /
,RR/ 0
HashSetRR1 8
<RR8 9
FaceRR9 =
>RR= >
>RR> ?
PickFacesInRectRR@ O
(RRO P
CameraSS 
camSS 
,SS 
RectTT 
rectTT 
,TT 
IListUU 
<UU 
ProBuilderMeshUU  
>UU  !

selectableUU" ,
,UU, -
PickerOptionsVV 
optionsVV !
,VV! "
floatWW 
pixelsPerPointWW  
=WW! "
$numWW# %
)WW% &
{XX 	
ifYY 
(YY 
optionsYY 
.YY 
	depthTestYY !
&&YY" $
optionsYY% ,
.YY, -
rectSelectModeYY- ;
==YY< >
RectSelectModeYY? M
.YYM N
PartialYYN U
)YYU V
{ZZ 
return[[ #
SelectionPickerRenderer[[ .
.[[. /
PickFacesInRect[[/ >
([[> ?
cam\\ 
,\\ 
rect]] 
,]] 

selectable^^ 
,^^ 
(__ 
int__ 
)__ 
(__ 
cam__ 
.__ 

pixelWidth__ (
/__) *
pixelsPerPoint__+ 9
)__9 :
,__: ;
(`` 
int`` 
)`` 
(`` 
cam`` 
.`` 
pixelHeight`` )
/``* +
pixelsPerPoint``, :
)``: ;
)``; <
;``< =
}aa 
varcc 
selectedcc 
=cc 
newcc 

Dictionarycc )
<cc) *
ProBuilderMeshcc* 8
,cc8 9
HashSetcc: A
<ccA B
FaceccB F
>ccF G
>ccG H
(ccH I
)ccI J
;ccJ K
foreachee 
(ee 
varee 
pbee 
inee 

selectableee )
)ee) *
{ff 
ifgg 
(gg 
!gg 
pbgg 
.gg 

selectablegg "
)gg" #
continuehh 
;hh 
HashSetjj 
<jj 
Facejj 
>jj 
selectedFacesjj +
=jj, -
newjj. 1
HashSetjj2 9
<jj9 :
Facejj: >
>jj> ?
(jj? @
)jj@ A
;jjA B
	Transformkk 
trskk 
=kk 
pbkk  "
.kk" #
	transformkk# ,
;kk, -
Vector3ll 
[ll 
]ll 
	positionsll #
=ll$ %
pbll& (
.ll( )
positionsInternalll) :
;ll: ;
Vector3mm 
[mm 
]mm 
screenPointsmm &
=mm' (
newmm) ,
Vector3mm- 4
[mm4 5
pbmm5 7
.mm7 8
vertexCountmm8 C
]mmC D
;mmD E
foroo 
(oo 
intoo 
nnoo 
=oo 
$numoo 
;oo  
nnoo! #
<oo$ %
pboo& (
.oo( )
vertexCountoo) 4
;oo4 5
nnoo6 8
++oo8 :
)oo: ;
screenPointspp  
[pp  !
nnpp! #
]pp# $
=pp% &
campp' *
.pp* +
ScreenToGuiPointpp+ ;
(pp; <
campp< ?
.pp? @
WorldToScreenPointpp@ R
(ppR S
trsppS V
.ppV W
TransformPointppW e
(ppe f
	positionsppf o
[ppo p
nnppp r
]ppr s
)pps t
)ppt u
,ppu v
pixelsPerPoint	ppw …
)
pp… †
;
pp† ‡
forrr 
(rr 
intrr 
nrr 
=rr 
$numrr 
;rr 
nrr  !
<rr" #
pbrr$ &
.rr& '
facesInternalrr' 4
.rr4 5
Lengthrr5 ;
;rr; <
nrr= >
++rr> @
)rr@ A
{ss 
Facett 
facett 
=tt 
pbtt  "
.tt" #
facesInternaltt# 0
[tt0 1
ntt1 2
]tt2 3
;tt3 4
ifww 
(ww 
optionsww 
.ww  
rectSelectModeww  .
==ww/ 1
RectSelectModeww2 @
.ww@ A
CompletewwA I
)wwI J
{xx 
ifzz 
(zz 
screenPointszz (
[zz( )
facezz) -
.zz- .
indexesInternalzz. =
[zz= >
$numzz> ?
]zz? @
]zz@ A
.zzA B
zzzB C
<zzD E
camzzF I
.zzI J
nearClipPlanezzJ W
)zzW X
continue{{ $
;{{$ %
if~~ 
(~~ 
rect~~  
.~~  !
Contains~~! )
(~~) *
screenPoints~~* 6
[~~6 7
face~~7 ;
.~~; <
indexesInternal~~< K
[~~K L
$num~~L M
]~~M N
]~~N O
)~~O P
)~~P Q
{ 
bool
€€  
nope
€€! %
=
€€& '
false
€€( -
;
€€- .
for
‚‚ 
(
‚‚  !
int
‚‚! $
q
‚‚% &
=
‚‚' (
$num
‚‚) *
;
‚‚* +
q
‚‚, -
<
‚‚. /
face
‚‚0 4
.
‚‚4 5%
distinctIndexesInternal
‚‚5 L
.
‚‚L M
Length
‚‚M S
;
‚‚S T
q
‚‚U V
++
‚‚V X
)
‚‚X Y
{
ƒƒ 
int
„„  #
index
„„$ )
=
„„* +
face
„„, 0
.
„„0 1%
distinctIndexesInternal
„„1 H
[
„„H I
q
„„I J
]
„„J K
;
„„K L
if
††  "
(
††# $
screenPoints
††$ 0
[
††0 1
index
††1 6
]
††6 7
.
††7 8
z
††8 9
<
††: ;
cam
††< ?
.
††? @
nearClipPlane
††@ M
||
††N P
!
††Q R
rect
††R V
.
††V W
Contains
††W _
(
††_ `
screenPoints
††` l
[
††l m
index
††m r
]
††r s
)
††s t
)
††t u
{
‡‡  !
nope
ˆˆ$ (
=
ˆˆ) *
true
ˆˆ+ /
;
ˆˆ/ 0
break
‰‰$ )
;
‰‰) *
}
ŠŠ  !
}
‹‹ 
if
 
(
  
!
  !
nope
! %
)
% &
{
 
if
  "
(
# $
!
$ %
options
% ,
.
, -
	depthTest
- 6
||
7 9
!
$ %
HandleUtility
% 2
.
2 3
PointIsOccluded
3 B
(
B C
cam
C F
,
F G
pb
H J
,
J K
trs
L O
.
O P
TransformPoint
P ^
(
^ _
Math
_ c
.
c d
Average
d k
(
k l
	positions
l u
,
u v
face
w {
.
{ |&
distinctIndexesInternal| “
)“ ”
)” •
)• –
)– —
{
‘‘  !
selectedFaces
’’$ 1
.
’’1 2
Add
’’2 5
(
’’5 6
face
’’6 :
)
’’: ;
;
’’; <
}
““  !
}
”” 
}
•• 
}
–– 
else
˜˜ 
{
™™ 
Bounds2D
šš  
poly
šš! %
=
šš& '
new
šš( +
Bounds2D
šš, 4
(
šš4 5
screenPoints
šš5 A
,
ššA B
face
ššC G
.
ššG H
edgesInternal
ššH U
)
ššU V
;
ššV W
bool
›› 
overlaps
›› %
=
››& '
false
››( -
;
››- .
if
 
(
 
poly
  
.
  !

Intersects
! +
(
+ ,
rect
, 0
)
0 1
)
1 2
{
 
for
   
(
    !
int
  ! $
nn
  % '
=
  ( )
$num
  * +
;
  + ,
nn
  - /
<
  0 1
face
  2 6
.
  6 7%
distinctIndexesInternal
  7 N
.
  N O
Length
  O U
&&
  V X
!
  Y Z
overlaps
  Z b
;
  b c
nn
  d f
++
  f h
)
  h i
{
¡¡ 
Vector3
¢¢  '
p
¢¢( )
=
¢¢* +
screenPoints
¢¢, 8
[
¢¢8 9
face
¢¢9 =
.
¢¢= >%
distinctIndexesInternal
¢¢> U
[
¢¢U V
nn
¢¢V X
]
¢¢X Y
]
¢¢Y Z
;
¢¢Z [
overlaps
££  (
=
££) *
p
££+ ,
.
££, -
z
££- .
>
££/ 0
cam
££1 4
.
££4 5
nearClipPlane
££5 B
&&
££C E
rect
££F J
.
££J K
Contains
££K S
(
££S T
p
££T U
)
££U V
;
££V W
}
¤¤ 
if
§§ 
(
§§  
!
§§  !
overlaps
§§! )
)
§§) *
{
¨¨ 
Vector2
©©  '
tl
©©( *
=
©©+ ,
new
©©- 0
Vector2
©©1 8
(
©©8 9
rect
©©9 =
.
©©= >
xMin
©©> B
,
©©B C
rect
©©D H
.
©©H I
yMax
©©I M
)
©©M N
;
©©N O
Vector2
ªª  '
tr
ªª( *
=
ªª+ ,
new
ªª- 0
Vector2
ªª1 8
(
ªª8 9
rect
ªª9 =
.
ªª= >
xMax
ªª> B
,
ªªB C
rect
ªªD H
.
ªªH I
yMax
ªªI M
)
ªªM N
;
ªªN O
Vector2
««  '
bl
««( *
=
««+ ,
new
««- 0
Vector2
««1 8
(
««8 9
rect
««9 =
.
««= >
xMin
««> B
,
««B C
rect
««D H
.
««H I
yMin
««I M
)
««M N
;
««N O
Vector2
¬¬  '
br
¬¬( *
=
¬¬+ ,
new
¬¬- 0
Vector2
¬¬1 8
(
¬¬8 9
rect
¬¬9 =
.
¬¬= >
xMax
¬¬> B
,
¬¬B C
rect
¬¬D H
.
¬¬H I
yMin
¬¬I M
)
¬¬M N
;
¬¬N O
overlaps
®®  (
=
®®) *
Math
®®+ /
.
®®/ 0
PointInPolygon
®®0 >
(
®®> ?
screenPoints
®®? K
,
®®K L
poly
®®M Q
,
®®Q R
face
®®S W
.
®®W X
edgesInternal
®®X e
,
®®e f
tl
®®g i
)
®®i j
;
®®j k
if
¯¯  "
(
¯¯# $
!
¯¯$ %
overlaps
¯¯% -
)
¯¯- .
overlaps
¯¯/ 7
=
¯¯8 9
Math
¯¯: >
.
¯¯> ?
PointInPolygon
¯¯? M
(
¯¯M N
screenPoints
¯¯N Z
,
¯¯Z [
poly
¯¯\ `
,
¯¯` a
face
¯¯b f
.
¯¯f g
edgesInternal
¯¯g t
,
¯¯t u
tr
¯¯v x
)
¯¯x y
;
¯¯y z
if
°°  "
(
°°# $
!
°°$ %
overlaps
°°% -
)
°°- .
overlaps
°°/ 7
=
°°8 9
Math
°°: >
.
°°> ?
PointInPolygon
°°? M
(
°°M N
screenPoints
°°N Z
,
°°Z [
poly
°°\ `
,
°°` a
face
°°b f
.
°°f g
edgesInternal
°°g t
,
°°t u
br
°°v x
)
°°x y
;
°°y z
if
±±  "
(
±±# $
!
±±$ %
overlaps
±±% -
)
±±- .
overlaps
±±/ 7
=
±±8 9
Math
±±: >
.
±±> ?
PointInPolygon
±±? M
(
±±M N
screenPoints
±±N Z
,
±±Z [
poly
±±\ `
,
±±` a
face
±±b f
.
±±f g
edgesInternal
±±g t
,
±±t u
bl
±±v x
)
±±x y
;
±±y z
for
´´  #
(
´´$ %
int
´´% (
nn
´´) +
=
´´, -
$num
´´. /
;
´´/ 0
nn
´´1 3
<
´´4 5
face
´´6 :
.
´´: ;
edgesInternal
´´; H
.
´´H I
Length
´´I O
&&
´´P R
!
´´S T
overlaps
´´T \
;
´´\ ]
nn
´´^ `
++
´´` b
)
´´b c
{
µµ  !
if
¶¶$ &
(
¶¶' (
Math
¶¶( ,
.
¶¶, -%
GetLineSegmentIntersect
¶¶- D
(
¶¶D E
tr
¶¶E G
,
¶¶G H
tl
¶¶I K
,
¶¶K L
screenPoints
¶¶M Y
[
¶¶Y Z
face
¶¶Z ^
.
¶¶^ _
edgesInternal
¶¶_ l
[
¶¶l m
nn
¶¶m o
]
¶¶o p
.
¶¶p q
a
¶¶q r
]
¶¶r s
,
¶¶s t
screenPoints¶¶u 
[¶¶ ‚
face¶¶‚ †
.¶¶† ‡
edgesInternal¶¶‡ ”
[¶¶” •
nn¶¶• —
]¶¶— ˜
.¶¶˜ ™
b¶¶™ š
]¶¶š ›
)¶¶› œ
)¶¶œ 
overlaps
··( 0
=
··1 2
true
··3 7
;
··7 8
else
¸¸$ (
if
¸¸) +
(
¸¸, -
Math
¸¸- 1
.
¸¸1 2%
GetLineSegmentIntersect
¸¸2 I
(
¸¸I J
tl
¸¸J L
,
¸¸L M
bl
¸¸N P
,
¸¸P Q
screenPoints
¸¸R ^
[
¸¸^ _
face
¸¸_ c
.
¸¸c d
edgesInternal
¸¸d q
[
¸¸q r
nn
¸¸r t
]
¸¸t u
.
¸¸u v
a
¸¸v w
]
¸¸w x
,
¸¸x y
screenPoints¸¸z †
[¸¸† ‡
face¸¸‡ ‹
.¸¸‹ Œ
edgesInternal¸¸Œ ™
[¸¸™ š
nn¸¸š œ
]¸¸œ 
.¸¸ 
b¸¸ Ÿ
]¸¸Ÿ  
)¸¸  ¡
)¸¸¡ ¢
overlaps
¹¹( 0
=
¹¹1 2
true
¹¹3 7
;
¹¹7 8
else
ºº$ (
if
ºº) +
(
ºº, -
Math
ºº- 1
.
ºº1 2%
GetLineSegmentIntersect
ºº2 I
(
ººI J
bl
ººJ L
,
ººL M
br
ººN P
,
ººP Q
screenPoints
ººR ^
[
ºº^ _
face
ºº_ c
.
ººc d
edgesInternal
ººd q
[
ººq r
nn
ººr t
]
ººt u
.
ººu v
a
ººv w
]
ººw x
,
ººx y
screenPointsººz †
[ºº† ‡
faceºº‡ ‹
.ºº‹ Œ
edgesInternalººŒ ™
[ºº™ š
nnººš œ
]ººœ 
.ºº 
bºº Ÿ
]ººŸ  
)ºº  ¡
)ºº¡ ¢
overlaps
»»( 0
=
»»1 2
true
»»3 7
;
»»7 8
else
¼¼$ (
if
¼¼) +
(
¼¼, -
Math
¼¼- 1
.
¼¼1 2%
GetLineSegmentIntersect
¼¼2 I
(
¼¼I J
br
¼¼J L
,
¼¼L M
tl
¼¼N P
,
¼¼P Q
screenPoints
¼¼R ^
[
¼¼^ _
face
¼¼_ c
.
¼¼c d
edgesInternal
¼¼d q
[
¼¼q r
nn
¼¼r t
]
¼¼t u
.
¼¼u v
a
¼¼v w
]
¼¼w x
,
¼¼x y
screenPoints¼¼z †
[¼¼† ‡
face¼¼‡ ‹
.¼¼‹ Œ
edgesInternal¼¼Œ ™
[¼¼™ š
nn¼¼š œ
]¼¼œ 
.¼¼ 
b¼¼ Ÿ
]¼¼Ÿ  
)¼¼  ¡
)¼¼¡ ¢
overlaps
½½( 0
=
½½1 2
true
½½3 7
;
½½7 8
}
¾¾  !
}
¿¿ 
}
ÀÀ 
if
ÃÃ 
(
ÃÃ 
overlaps
ÃÃ $
)
ÃÃ$ %
selectedFaces
ÄÄ )
.
ÄÄ) *
Add
ÄÄ* -
(
ÄÄ- .
face
ÄÄ. 2
)
ÄÄ2 3
;
ÄÄ3 4
}
ÅÅ 
}
ÆÆ 
selected
ÈÈ 
.
ÈÈ 
Add
ÈÈ 
(
ÈÈ 
pb
ÈÈ 
,
ÈÈ  
selectedFaces
ÈÈ! .
)
ÈÈ. /
;
ÈÈ/ 0
}
ÉÉ 
return
ËË 
selected
ËË 
;
ËË 
}
ÌÌ 	
public
×× 
static
×× 

Dictionary
××  
<
××  !
ProBuilderMesh
××! /
,
××/ 0
HashSet
××1 8
<
××8 9
Edge
××9 =
>
××= >
>
××> ?
PickEdgesInRect
××@ O
(
××O P
Camera
ØØ 
cam
ØØ 
,
ØØ 
Rect
ÙÙ 
rect
ÙÙ 
,
ÙÙ 
IList
ÚÚ 
<
ÚÚ 
ProBuilderMesh
ÚÚ  
>
ÚÚ  !

selectable
ÚÚ" ,
,
ÚÚ, -
PickerOptions
ÛÛ 
options
ÛÛ !
,
ÛÛ! "
float
ÜÜ 
pixelsPerPoint
ÜÜ  
=
ÜÜ! "
$num
ÜÜ# %
)
ÜÜ% &
{
İİ 	
if
ŞŞ 
(
ŞŞ 
options
ŞŞ 
.
ŞŞ 
	depthTest
ŞŞ !
&&
ŞŞ" $
options
ŞŞ% ,
.
ŞŞ, -
rectSelectMode
ŞŞ- ;
==
ŞŞ< >
RectSelectMode
ŞŞ? M
.
ŞŞM N
Partial
ŞŞN U
)
ŞŞU V
{
ßß 
return
àà %
SelectionPickerRenderer
àà .
.
àà. /
PickEdgesInRect
àà/ >
(
àà> ?
cam
áá 
,
áá 
rect
ââ 
,
ââ 

selectable
ãã 
,
ãã 
true
ää 
,
ää 
(
åå 
int
åå 
)
åå 
(
åå 
cam
åå 
.
åå 

pixelWidth
åå (
/
åå) *
pixelsPerPoint
åå+ 9
)
åå9 :
,
åå: ;
(
ææ 
int
ææ 
)
ææ 
(
ææ 
cam
ææ 
.
ææ 
pixelHeight
ææ )
/
ææ* +
pixelsPerPoint
ææ, :
)
ææ: ;
)
ææ; <
;
ææ< =
}
çç 
var
éé 
selected
éé 
=
éé 
new
éé 

Dictionary
éé )
<
éé) *
ProBuilderMesh
éé* 8
,
éé8 9
HashSet
éé: A
<
ééA B
Edge
ééB F
>
ééF G
>
ééG H
(
ééH I
)
ééI J
;
ééJ K
foreach
ëë 
(
ëë 
var
ëë 
pb
ëë 
in
ëë 

selectable
ëë )
)
ëë) *
{
ìì 
if
íí 
(
íí 
!
íí 
pb
íí 
.
íí 

selectable
íí "
)
íí" #
continue
îî 
;
îî 
	Transform
ğğ 
trs
ğğ 
=
ğğ 
pb
ğğ  "
.
ğğ" #
	transform
ğğ# ,
;
ğğ, -
var
ññ 
selectedEdges
ññ !
=
ññ" #
new
ññ$ '
HashSet
ññ( /
<
ññ/ 0
Edge
ññ0 4
>
ññ4 5
(
ññ5 6
)
ññ6 7
;
ññ7 8
for
óó 
(
óó 
int
óó 
i
óó 
=
óó 
$num
óó 
,
óó 
fc
óó  "
=
óó# $
pb
óó% '
.
óó' (
	faceCount
óó( 1
;
óó1 2
i
óó3 4
<
óó5 6
fc
óó7 9
;
óó9 :
i
óó; <
++
óó< >
)
óó> ?
{
ôô 
var
õõ 
edges
õõ 
=
õõ 
pb
õõ  "
.
õõ" #
facesInternal
õõ# 0
[
õõ0 1
i
õõ1 2
]
õõ2 3
.
õõ3 4
edgesInternal
õõ4 A
;
õõA B
for
÷÷ 
(
÷÷ 
int
÷÷ 
n
÷÷ 
=
÷÷  
$num
÷÷! "
,
÷÷" #
ec
÷÷$ &
=
÷÷' (
edges
÷÷) .
.
÷÷. /
Length
÷÷/ 5
;
÷÷5 6
n
÷÷7 8
<
÷÷9 :
ec
÷÷; =
;
÷÷= >
n
÷÷? @
++
÷÷@ B
)
÷÷B C
{
øø 
var
ùù 
edge
ùù  
=
ùù! "
edges
ùù# (
[
ùù( )
n
ùù) *
]
ùù* +
;
ùù+ ,
var
ûû 
posA
ûû  
=
ûû! "
trs
ûû# &
.
ûû& '
TransformPoint
ûû' 5
(
ûû5 6
pb
ûû6 8
.
ûû8 9
positionsInternal
ûû9 J
[
ûûJ K
edge
ûûK O
.
ûûO P
a
ûûP Q
]
ûûQ R
)
ûûR S
;
ûûS T
var
üü 
posB
üü  
=
üü! "
trs
üü# &
.
üü& '
TransformPoint
üü' 5
(
üü5 6
pb
üü6 8
.
üü8 9
positionsInternal
üü9 J
[
üüJ K
edge
üüK O
.
üüO P
b
üüP Q
]
üüQ R
)
üüR S
;
üüS T
Vector3
şş 
a
şş  !
=
şş" #
cam
şş$ '
.
şş' (
ScreenToGuiPoint
şş( 8
(
şş8 9
cam
şş9 <
.
şş< = 
WorldToScreenPoint
şş= O
(
şşO P
posA
şşP T
)
şşT U
,
şşU V
pixelsPerPoint
şşW e
)
şşe f
;
şşf g
Vector3
ÿÿ 
b
ÿÿ  !
=
ÿÿ" #
cam
ÿÿ$ '
.
ÿÿ' (
ScreenToGuiPoint
ÿÿ( 8
(
ÿÿ8 9
cam
ÿÿ9 <
.
ÿÿ< = 
WorldToScreenPoint
ÿÿ= O
(
ÿÿO P
posB
ÿÿP T
)
ÿÿT U
,
ÿÿU V
pixelsPerPoint
ÿÿW e
)
ÿÿe f
;
ÿÿf g
switch
 
(
  
options
  '
.
' (
rectSelectMode
( 6
)
6 7
{
‚‚ 
case
ƒƒ  
RectSelectMode
ƒƒ! /
.
ƒƒ/ 0
Complete
ƒƒ0 8
:
ƒƒ8 9
{
„„ 
if
††  "
(
††# $
(
††$ %
a
††% &
.
††& '
z
††' (
<
††) *
cam
††+ .
.
††. /
nearClipPlane
††/ <
||
††= ?
b
††@ A
.
††A B
z
††B C
<
††D E
cam
††F I
.
††I J
nearClipPlane
††J W
)
††W X
)
††X Y
continue
‡‡$ ,
;
‡‡, -
if
‰‰  "
(
‰‰# $
rect
‰‰$ (
.
‰‰( )
Contains
‰‰) 1
(
‰‰1 2
a
‰‰2 3
)
‰‰3 4
&&
‰‰5 7
rect
‰‰8 <
.
‰‰< =
Contains
‰‰= E
(
‰‰E F
b
‰‰F G
)
‰‰G H
)
‰‰H I
{
ŠŠ  !
if
‹‹$ &
(
‹‹' (
!
‹‹( )
options
‹‹) 0
.
‹‹0 1
	depthTest
‹‹1 :
||
‹‹; =
!
‹‹> ?
HandleUtility
‹‹? L
.
‹‹L M
PointIsOccluded
‹‹M \
(
‹‹\ ]
cam
‹‹] `
,
‹‹` a
pb
‹‹b d
,
‹‹d e
(
‹‹f g
posA
‹‹g k
+
‹‹l m
posB
‹‹n r
)
‹‹r s
*
‹‹t u
$num
‹‹v y
)
‹‹y z
)
‹‹z {
selectedEdges
ŒŒ( 5
.
ŒŒ5 6
Add
ŒŒ6 9
(
ŒŒ9 :
edge
ŒŒ: >
)
ŒŒ> ?
;
ŒŒ? @
}
  !
break
  %
;
% &
}
 
case
’’  
RectSelectMode
’’! /
.
’’/ 0
Partial
’’0 7
:
’’7 8
{
““ 
if
••  "
(
••# $
Math
••$ (
.
••( )'
RectIntersectsLineSegment
••) B
(
••B C
rect
••C G
,
••G H
a
••I J
,
••J K
b
••L M
)
••M N
)
••N O
selectedEdges
––$ 1
.
––1 2
Add
––2 5
(
––5 6
edge
––6 :
)
––: ;
;
––; <
break
˜˜  %
;
˜˜% &
}
™™ 
}
šš 
}
›› 
}
œœ 
selected
 
.
 
Add
 
(
 
pb
 
,
  
selectedEdges
! .
)
. /
;
/ 0
}
ŸŸ 
return
¡¡ 
selected
¡¡ 
;
¡¡ 
}
¢¢ 	
public
«« 
static
«« 
Face
«« 
PickFace
«« #
(
««# $
Camera
««$ *
camera
««+ 1
,
««1 2
Vector3
««3 :
mousePosition
««; H
,
««H I
ProBuilderMesh
««J X
pickable
««Y a
)
««a b
{
¬¬ 	
Ray
­­ 
ray
­­ 
=
­­ 
camera
­­ 
.
­­ 
ScreenPointToRay
­­ -
(
­­- .
mousePosition
­­. ;
)
­­; <
;
­­< =

RaycastHit
¯¯ 
hit
¯¯ 
;
¯¯ 
if
±± 
(
±± 
HandleUtility
±± 
.
±± 
FaceRaycast
±± )
(
±±) *
ray
±±* -
,
±±- .
pickable
±±/ 7
,
±±7 8
out
±±9 <
hit
±±= @
,
±±@ A
Mathf
±±B G
.
±±G H
Infinity
±±H P
,
±±P Q
CullingMode
±±R ]
.
±±] ^
Back
±±^ b
)
±±b c
)
±±c d
return
²² 
pickable
²² 
.
²²  
facesInternal
²²  -
[
²²- .
hit
²². 1
.
²²1 2
face
²²2 6
]
²²6 7
;
²²7 8
return
´´ 
null
´´ 
;
´´ 
}
µµ 	
}
¶¶ 
}·· Ò«
‹D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\VectorMask.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
struct 

Vector2Mask 
{ 
const 
byte 
X 
= 
$num 
<< 
$num 
; 
const 
byte 
Y 
= 
$num 
<< 
$num 
; 
public

 
static

 
readonly

 
Vector2Mask

 *
XY

+ -
=

. /
new

0 3
Vector2Mask

4 ?
(

? @
X

@ A
|

B C
Y

D E
)

E F
;

F G
byte 
m_Mask 
; 
public 
float 
x 
{ 	
get 
{ 
return 
( 
m_Mask  
&! "
X# $
)$ %
==& (
X) *
?+ ,
$num- /
:0 1
$num2 4
;4 5
}6 7
} 	
public 
float 
y 
{ 	
get 
{ 
return 
( 
m_Mask  
&! "
Y# $
)$ %
==& (
Y) *
?+ ,
$num- /
:0 1
$num2 4
;4 5
}6 7
} 	
public 
Vector2Mask 
( 
Vector3 "
v# $
,$ %
float& +
epsilon, 3
=4 5
float6 ;
.; <
Epsilon< C
)C D
{ 	
m_Mask 
= 
$num 
; 
if 
( 
Mathf 
. 
Abs 
( 
v 
. 
x 
) 
>  
epsilon! (
)( )
m_Mask 
|= 
X 
; 
if 
( 
Mathf 
. 
Abs 
( 
v 
. 
y 
) 
>  
epsilon! (
)( )
m_Mask 
|= 
Y 
; 
}   	
public"" 
Vector2Mask"" 
("" 
byte"" 
mask""  $
)""$ %
{## 	
m_Mask$$ 
=$$ 
mask$$ 
;$$ 
}%% 	
public'' 
static'' 
implicit'' 
operator'' '
Vector2''( /
(''/ 0
Vector2Mask''0 ;
mask''< @
)''@ A
{(( 	
return)) 
new)) 
Vector2)) 
()) 
mask)) #
.))# $
x))$ %
,))% &
mask))' +
.))+ ,
y)), -
)))- .
;)). /
}** 	
public,, 
static,, 
implicit,, 
operator,, '
Vector2Mask,,( 3
(,,3 4
Vector2,,4 ;
v,,< =
),,= >
{-- 	
return.. 
new.. 
Vector2Mask.. "
(.." #
v..# $
)..$ %
;..% &
}// 	
public11 
static11 
Vector2Mask11 !
operator11" *
|11* +
(11+ ,
Vector2Mask11, 7
left118 <
,11< =
Vector2Mask11> I
right11J O
)11O P
{22 	
return33 
new33 
Vector2Mask33 "
(33" #
(33# $
byte33$ (
)33( )
(33) *
left33* .
.33. /
m_Mask33/ 5
|336 7
right338 =
.33= >
m_Mask33> D
)33D E
)33E F
;33F G
}44 	
public66 
static66 
Vector2Mask66 !
operator66" *
&66* +
(66+ ,
Vector2Mask66, 7
left668 <
,66< =
Vector2Mask66> I
right66J O
)66O P
{77 	
return88 
new88 
Vector2Mask88 "
(88" #
(88# $
byte88$ (
)88( )
(88) *
left88* .
.88. /
m_Mask88/ 5
&886 7
right888 =
.88= >
m_Mask88> D
)88D E
)88E F
;88F G
}99 	
public;; 
static;; 
Vector2Mask;; !
operator;;" *
^;;* +
(;;+ ,
Vector2Mask;;, 7
left;;8 <
,;;< =
Vector2Mask;;> I
right;;J O
);;O P
{<< 	
return== 
new== 
Vector2Mask== "
(==" #
(==# $
byte==$ (
)==( )
(==) *
left==* .
.==. /
m_Mask==/ 5
^==6 7
right==8 =
.=== >
m_Mask==> D
)==D E
)==E F
;==F G
}>> 	
public@@ 
static@@ 
Vector2@@ 
operator@@ &
*@@& '
(@@' (
Vector2Mask@@( 3
mask@@4 8
,@@8 9
float@@: ?
value@@@ E
)@@E F
{AA 	
returnBB 
newBB 
Vector2BB 
(BB 
maskBB #
.BB# $
xBB$ %
*BB& '
valueBB( -
,BB- .
maskBB/ 3
.BB3 4
yBB4 5
*BB6 7
valueBB8 =
)BB= >
;BB> ?
}CC 	
}DD 
structFF 

Vector3MaskFF 
:FF 

IEquatableFF #
<FF# $
Vector3MaskFF$ /
>FF/ 0
{GG 
constHH 
byteHH 
XHH 
=HH 
$numHH 
<<HH 
$numHH 
;HH 
constII 
byteII 
YII 
=II 
$numII 
<<II 
$numII 
;II 
constJJ 
byteJJ 
ZJJ 
=JJ 
$numJJ 
<<JJ 
$numJJ 
;JJ 
publicLL 
staticLL 
readonlyLL 
Vector3MaskLL *
XYZLL+ .
=LL/ 0
newLL1 4
Vector3MaskLL5 @
(LL@ A
XLLA B
|LLC D
YLLE F
|LLG H
ZLLI J
)LLJ K
;LLK L
byteNN 
m_MaskNN 
;NN 
publicPP 
floatPP 
xPP 
{QQ 	
getRR 
{RR 
returnRR 
(RR 
m_MaskRR  
&RR! "
XRR# $
)RR$ %
==RR& (
XRR) *
?RR+ ,
$numRR- /
:RR0 1
$numRR2 4
;RR4 5
}RR6 7
}SS 	
publicUU 
floatUU 
yUU 
{VV 	
getWW 
{WW 
returnWW 
(WW 
m_MaskWW  
&WW! "
YWW# $
)WW$ %
==WW& (
YWW) *
?WW+ ,
$numWW- /
:WW0 1
$numWW2 4
;WW4 5
}WW6 7
}XX 	
publicZZ 
floatZZ 
zZZ 
{[[ 	
get\\ 
{\\ 
return\\ 
(\\ 
m_Mask\\  
&\\! "
Z\\# $
)\\$ %
==\\& (
Z\\) *
?\\+ ,
$num\\- /
:\\0 1
$num\\2 4
;\\4 5
}\\6 7
}]] 	
public__ 
Vector3Mask__ 
(__ 
Vector3__ "
v__# $
,__$ %
float__& +
epsilon__, 3
=__4 5
float__6 ;
.__; <
Epsilon__< C
)__C D
{`` 	
m_Maskaa 
=aa 
$numaa 
;aa 
ifcc 
(cc 
Mathfcc 
.cc 
Abscc 
(cc 
vcc 
.cc 
xcc 
)cc 
>cc  
epsiloncc! (
)cc( )
m_Maskdd 
|=dd 
Xdd 
;dd 
ifee 
(ee 
Mathfee 
.ee 
Absee 
(ee 
vee 
.ee 
yee 
)ee 
>ee  
epsilonee! (
)ee( )
m_Maskff 
|=ff 
Yff 
;ff 
ifgg 
(gg 
Mathfgg 
.gg 
Absgg 
(gg 
vgg 
.gg 
zgg 
)gg 
>gg  
epsilongg! (
)gg( )
m_Maskhh 
|=hh 
Zhh 
;hh 
}ii 	
publickk 
Vector3Maskkk 
(kk 
bytekk 
maskkk  $
)kk$ %
{ll 	
m_Maskmm 
=mm 
maskmm 
;mm 
}nn 	
publicpp 
overridepp 
stringpp 
ToStringpp '
(pp' (
)pp( )
{qq 	
returnrr 
stringrr 
.rr 
Formatrr  
(rr  !
$strrr! 4
,rr4 5
xrr6 7
,rr7 8
yrr9 :
,rr: ;
zrr< =
)rr= >
;rr> ?
}ss 	
publicxx 
intxx 
activexx 
{yy 	
getzz 
{{{ 
int|| 
count|| 
=|| 
$num|| 
;|| 
if}} 
(}} 
(}} 
m_Mask}} 
&}} 
X}} 
)}}  
>}}! "
$num}}# $
)}}$ %
count~~ 
++~~ 
;~~ 
if 
( 
( 
m_Mask 
& 
Y 
)  
>! "
$num# $
)$ %
count
€€ 
++
€€ 
;
€€ 
if
 
(
 
(
 
m_Mask
 
&
 
Z
 
)
  
>
! "
$num
# $
)
$ %
count
‚‚ 
++
‚‚ 
;
‚‚ 
return
ƒƒ 
count
ƒƒ 
;
ƒƒ 
}
„„ 
}
…… 	
public
‡‡ 
static
‡‡ 
implicit
‡‡ 
operator
‡‡ '
Vector3
‡‡( /
(
‡‡/ 0
Vector3Mask
‡‡0 ;
mask
‡‡< @
)
‡‡@ A
{
ˆˆ 	
return
‰‰ 
new
‰‰ 
Vector3
‰‰ 
(
‰‰ 
mask
‰‰ #
.
‰‰# $
x
‰‰$ %
,
‰‰% &
mask
‰‰' +
.
‰‰+ ,
y
‰‰, -
,
‰‰- .
mask
‰‰/ 3
.
‰‰3 4
z
‰‰4 5
)
‰‰5 6
;
‰‰6 7
}
ŠŠ 	
public
ŒŒ 
static
ŒŒ 
explicit
ŒŒ 
operator
ŒŒ '
Vector3Mask
ŒŒ( 3
(
ŒŒ3 4
Vector3
ŒŒ4 ;
v
ŒŒ< =
)
ŒŒ= >
{
 	
return
 
new
 
Vector3Mask
 "
(
" #
v
# $
)
$ %
;
% &
}
 	
public
‘‘ 
static
‘‘ 
Vector3Mask
‘‘ !
operator
‘‘" *
|
‘‘* +
(
‘‘+ ,
Vector3Mask
‘‘, 7
left
‘‘8 <
,
‘‘< =
Vector3Mask
‘‘> I
right
‘‘J O
)
‘‘O P
{
’’ 	
return
““ 
new
““ 
Vector3Mask
““ "
(
““" #
(
““# $
byte
““$ (
)
““( )
(
““) *
left
““* .
.
““. /
m_Mask
““/ 5
|
““6 7
right
““8 =
.
““= >
m_Mask
““> D
)
““D E
)
““E F
;
““F G
}
”” 	
public
–– 
static
–– 
Vector3Mask
–– !
operator
––" *
&
––* +
(
––+ ,
Vector3Mask
––, 7
left
––8 <
,
––< =
Vector3Mask
––> I
right
––J O
)
––O P
{
—— 	
return
˜˜ 
new
˜˜ 
Vector3Mask
˜˜ "
(
˜˜" #
(
˜˜# $
byte
˜˜$ (
)
˜˜( )
(
˜˜) *
left
˜˜* .
.
˜˜. /
m_Mask
˜˜/ 5
&
˜˜6 7
right
˜˜8 =
.
˜˜= >
m_Mask
˜˜> D
)
˜˜D E
)
˜˜E F
;
˜˜F G
}
™™ 	
public
›› 
static
›› 
Vector3Mask
›› !
operator
››" *
^
››* +
(
››+ ,
Vector3Mask
››, 7
left
››8 <
,
››< =
Vector3Mask
››> I
right
››J O
)
››O P
{
œœ 	
return
 
new
 
Vector3Mask
 "
(
" #
(
# $
byte
$ (
)
( )
(
) *
left
* .
.
. /
m_Mask
/ 5
^
6 7
right
8 =
.
= >
m_Mask
> D
)
D E
)
E F
;
F G
}
 	
public
   
static
   
Vector3
   
operator
   &
*
  & '
(
  ' (
Vector3Mask
  ( 3
mask
  4 8
,
  8 9
float
  : ?
value
  @ E
)
  E F
{
¡¡ 	
return
¢¢ 
new
¢¢ 
Vector3
¢¢ 
(
¢¢ 
mask
¢¢ #
.
¢¢# $
x
¢¢$ %
*
¢¢& '
value
¢¢( -
,
¢¢- .
mask
¢¢/ 3
.
¢¢3 4
y
¢¢4 5
*
¢¢6 7
value
¢¢8 =
,
¢¢= >
mask
¢¢? C
.
¢¢C D
z
¢¢D E
*
¢¢F G
value
¢¢H M
)
¢¢M N
;
¢¢N O
}
££ 	
public
¥¥ 
static
¥¥ 
Vector3
¥¥ 
operator
¥¥ &
*
¥¥& '
(
¥¥' (
Vector3Mask
¥¥( 3
mask
¥¥4 8
,
¥¥8 9
Vector3
¥¥: A
value
¥¥B G
)
¥¥G H
{
¦¦ 	
return
§§ 
new
§§ 
Vector3
§§ 
(
§§ 
mask
§§ #
.
§§# $
x
§§$ %
*
§§& '
value
§§( -
.
§§- .
x
§§. /
,
§§/ 0
mask
§§1 5
.
§§5 6
y
§§6 7
*
§§8 9
value
§§: ?
.
§§? @
y
§§@ A
,
§§A B
mask
§§C G
.
§§G H
z
§§H I
*
§§J K
value
§§L Q
.
§§Q R
z
§§R S
)
§§S T
;
§§T U
}
¨¨ 	
public
ªª 
static
ªª 
Vector3
ªª 
operator
ªª &
*
ªª& '
(
ªª' (

Quaternion
ªª( 2
rotation
ªª3 ;
,
ªª; <
Vector3Mask
ªª= H
mask
ªªI M
)
ªªM N
{
«« 	
var
¬¬ 
active
¬¬ 
=
¬¬ 
mask
¬¬ 
.
¬¬ 
active
¬¬ $
;
¬¬$ %
if
®® 
(
®® 
active
®® 
>
®® 
$num
®® 
)
®® 
return
¯¯ 
mask
¯¯ 
;
¯¯ 
var
±± 
rotated
±± 
=
±± 
(
±± 
rotation
±± #
*
±±$ %
(
±±& '
Vector3
±±' .
)
±±. /
mask
±±/ 3
)
±±3 4
.
±±4 5
Abs
±±5 8
(
±±8 9
)
±±9 :
;
±±: ;
if
³³ 
(
³³ 
active
³³ 
>
³³ 
$num
³³ 
)
³³ 
{
´´ 
return
µµ 
new
µµ 
Vector3
µµ "
(
µµ" #
rotated
¶¶ 
.
¶¶ 
x
¶¶ 
>
¶¶ 
rotated
¶¶  '
.
¶¶' (
y
¶¶( )
||
¶¶* ,
rotated
¶¶- 4
.
¶¶4 5
x
¶¶5 6
>
¶¶7 8
rotated
¶¶9 @
.
¶¶@ A
z
¶¶A B
?
¶¶C D
$num
¶¶E F
:
¶¶G H
$num
¶¶I J
,
¶¶J K
rotated
·· 
.
·· 
y
·· 
>
·· 
rotated
··  '
.
··' (
x
··( )
||
··* ,
rotated
··- 4
.
··4 5
y
··5 6
>
··7 8
rotated
··9 @
.
··@ A
z
··A B
?
··C D
$num
··E F
:
··G H
$num
··I J
,
··J K
rotated
¸¸ 
.
¸¸ 
z
¸¸ 
>
¸¸ 
rotated
¸¸  '
.
¸¸' (
x
¸¸( )
||
¸¸* ,
rotated
¸¸- 4
.
¸¸4 5
z
¸¸5 6
>
¸¸7 8
rotated
¸¸9 @
.
¸¸@ A
y
¸¸A B
?
¸¸C D
$num
¸¸E F
:
¸¸G H
$num
¸¸I J
)
¹¹ 
;
¹¹ 
}
ºº 
return
¼¼ 
new
¼¼ 
Vector3
¼¼ 
(
¼¼ 
rotated
½½ 
.
½½ 
x
½½ 
>
½½ 
rotated
½½ #
.
½½# $
y
½½$ %
&&
½½& (
rotated
½½) 0
.
½½0 1
x
½½1 2
>
½½3 4
rotated
½½5 <
.
½½< =
z
½½= >
?
½½? @
$num
½½A B
:
½½C D
$num
½½E F
,
½½F G
rotated
¾¾ 
.
¾¾ 
y
¾¾ 
>
¾¾ 
rotated
¾¾ #
.
¾¾# $
z
¾¾$ %
&&
¾¾& (
rotated
¾¾) 0
.
¾¾0 1
y
¾¾1 2
>
¾¾3 4
rotated
¾¾5 <
.
¾¾< =
x
¾¾= >
?
¾¾? @
$num
¾¾A B
:
¾¾C D
$num
¾¾E F
,
¾¾F G
rotated
¿¿ 
.
¿¿ 
z
¿¿ 
>
¿¿ 
rotated
¿¿ #
.
¿¿# $
x
¿¿$ %
&&
¿¿& (
rotated
¿¿) 0
.
¿¿0 1
z
¿¿1 2
>
¿¿3 4
rotated
¿¿5 <
.
¿¿< =
y
¿¿= >
?
¿¿? @
$num
¿¿A B
:
¿¿C D
$num
¿¿E F
)
¿¿F G
;
¿¿G H
}
ÀÀ 	
public
ÂÂ 
static
ÂÂ 
bool
ÂÂ 
operator
ÂÂ #
==
ÂÂ$ &
(
ÂÂ& '
Vector3Mask
ÂÂ' 2
left
ÂÂ3 7
,
ÂÂ7 8
Vector3Mask
ÂÂ9 D
right
ÂÂE J
)
ÂÂJ K
{
ÃÃ 	
return
ÄÄ 
left
ÄÄ 
.
ÄÄ 
m_Mask
ÄÄ 
==
ÄÄ !
right
ÄÄ" '
.
ÄÄ' (
m_Mask
ÄÄ( .
;
ÄÄ. /
}
ÅÅ 	
public
ÇÇ 
static
ÇÇ 
bool
ÇÇ 
operator
ÇÇ #
!=
ÇÇ$ &
(
ÇÇ& '
Vector3Mask
ÇÇ' 2
left
ÇÇ3 7
,
ÇÇ7 8
Vector3Mask
ÇÇ9 D
right
ÇÇE J
)
ÇÇJ K
{
ÈÈ 	
return
ÉÉ 
!
ÉÉ 
(
ÉÉ 
left
ÉÉ 
==
ÉÉ 
right
ÉÉ "
)
ÉÉ" #
;
ÉÉ# $
}
ÊÊ 	
public
ÌÌ 
float
ÌÌ 
this
ÌÌ 
[
ÌÌ 
int
ÌÌ 
i
ÌÌ 
]
ÌÌ  
{
ÍÍ 	
get
ÎÎ 
{
ÏÏ 
if
ĞĞ 
(
ĞĞ 
i
ĞĞ 
<
ĞĞ 
$num
ĞĞ 
||
ĞĞ 
i
ĞĞ 
>
ĞĞ 
$num
ĞĞ  !
)
ĞĞ! "
throw
ÑÑ 
new
ÑÑ &
IndexOutOfRangeException
ÑÑ 6
(
ÑÑ6 7
)
ÑÑ7 8
;
ÑÑ8 9
return
ÓÓ 
(
ÓÓ 
$num
ÓÓ 
&
ÓÓ 
(
ÓÓ 
m_Mask
ÓÓ #
>>
ÓÓ$ &
i
ÓÓ' (
)
ÓÓ( )
)
ÓÓ) *
*
ÓÓ+ ,
$num
ÓÓ- /
;
ÓÓ/ 0
}
ÔÔ 
set
ÖÖ 
{
×× 
if
ØØ 
(
ØØ 
i
ØØ 
<
ØØ 
$num
ØØ 
||
ØØ 
i
ØØ 
>
ØØ 
$num
ØØ  !
)
ØØ! "
throw
ÙÙ 
new
ÙÙ &
IndexOutOfRangeException
ÙÙ 6
(
ÙÙ6 7
)
ÙÙ7 8
;
ÙÙ8 9
m_Mask
ÛÛ 
&=
ÛÛ 
(
ÛÛ 
byte
ÛÛ 
)
ÛÛ  
~
ÛÛ! "
(
ÛÛ" #
$num
ÛÛ# $
<<
ÛÛ% '
i
ÛÛ( )
)
ÛÛ) *
;
ÛÛ* +
m_Mask
ÜÜ 
|=
ÜÜ 
(
ÜÜ 
byte
ÜÜ 
)
ÜÜ  
(
ÜÜ! "
(
ÜÜ" #
value
ÜÜ# (
>
ÜÜ) *
$num
ÜÜ+ -
?
ÜÜ. /
$num
ÜÜ0 1
:
ÜÜ2 3
$num
ÜÜ4 5
)
ÜÜ5 6
<<
ÜÜ7 9
i
ÜÜ: ;
)
ÜÜ; <
;
ÜÜ< =
}
İİ 
}
ŞŞ 	
public
àà 
bool
àà 
Equals
àà 
(
àà 
Vector3Mask
àà &
other
àà' ,
)
àà, -
{
áá 	
return
ââ 
m_Mask
ââ 
==
ââ 
other
ââ "
.
ââ" #
m_Mask
ââ# )
;
ââ) *
}
ãã 	
public
åå 
override
åå 
bool
åå 
Equals
åå #
(
åå# $
object
åå$ *
obj
åå+ .
)
åå. /
{
ææ 	
if
çç 
(
çç 
ReferenceEquals
çç 
(
çç  
null
çç  $
,
çç$ %
obj
çç& )
)
çç) *
)
çç* +
return
çç, 2
false
çç3 8
;
çç8 9
return
èè 
obj
èè 
is
èè 
Vector3Mask
èè %
&&
èè& (
Equals
èè) /
(
èè/ 0
(
èè0 1
Vector3Mask
èè1 <
)
èè< =
obj
èè> A
)
èèA B
;
èèB C
}
éé 	
public
ëë 
override
ëë 
int
ëë 
GetHashCode
ëë '
(
ëë' (
)
ëë( )
{
ìì 	
return
íí 
m_Mask
íí 
.
íí 
GetHashCode
íí %
(
íí% &
)
íí& '
;
íí' (
}
îî 	
}
ïï 
}ğğ Ï¢
—D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\UV\UVEditing.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
static 

partial 
class 
	UVEditing "
{ 
internal 
static 
Vector2 
[  
]  !
GetUVs" (
(( )
ProBuilderMesh) 7
mesh8 <
,< =
int> A
channelB I
)I J
{ 	
switch 
( 
channel 
) 
{ 
case 
$num 
: 
{ 
Mesh 
m 
= 
mesh !
.! "
mesh" &
;& '
if 
( 
m 
== 
null !
)! "
return 
null #
;# $
return 
mesh 
.  
mesh  $
.$ %
uv2% (
;( )
} 
case 
$num 
: 
case   
$num   
:   
{!! 
if"" 
("" 
channel"" 
==""  "
$num""# $
?""% &
mesh""' +
.""+ ,
	HasArrays"", 5
(""5 6

MeshArrays""6 @
.""@ A
Texture2""A I
)""I J
:""K L
mesh""M Q
.""Q R
	HasArrays""R [
(""[ \

MeshArrays""\ f
.""f g
Texture3""g o
)""o p
)""p q
{## 
List$$ 
<$$ 
Vector4$$ $
>$$$ %
uvs$$& )
=$$* +
new$$, /
List$$0 4
<$$4 5
Vector4$$5 <
>$$< =
($$= >
)$$> ?
;$$? @
mesh%% 
.%% 
GetUVs%% #
(%%# $
channel%%$ +
,%%+ ,
uvs%%- 0
)%%0 1
;%%1 2
return&& 
uvs&& "
.&&" #
Select&&# )
(&&) *
x&&* +
=>&&, .
(&&/ 0
Vector2&&0 7
)&&7 8
x&&8 9
)&&9 :
.&&: ;
ToArray&&; B
(&&B C
)&&C D
;&&D E
}'' 
return)) 
null)) 
;))  
}** 
default,, 
:,, 
return-- 
mesh-- 
.--  
texturesInternal--  0
;--0 1
}.. 
}// 	
internal44 
static44 
void44 
ApplyUVs44 %
(44% &
ProBuilderMesh44& 4
mesh445 9
,449 :
Vector244; B
[44B C
]44C D
uvs44E H
,44H I
int44J M
channel44N U
,44U V
bool44W [
applyToMesh44\ g
=44h i
true44j n
)44n o
{55 	
switch66 
(66 
channel66 
)66 
{77 
case88 
$num88 
:88 
mesh99 
.99 
texturesInternal99 )
=99* +
uvs99, /
;99/ 0
if:: 
(:: 
applyToMesh:: #
&&::$ &
mesh::' +
.::+ ,
mesh::, 0
!=::1 3
null::4 8
)::8 9
mesh;; 
.;; 
mesh;; !
.;;! "
uv;;" $
=;;% &
uvs;;' *
;;;* +
break<< 
;<< 
case>> 
$num>> 
:>> 
if?? 
(?? 
applyToMesh?? #
&&??$ &
mesh??' +
.??+ ,
mesh??, 0
!=??1 3
null??4 8
)??8 9
mesh@@ 
.@@ 
mesh@@ !
.@@! "
uv2@@" %
=@@& '
uvs@@( +
;@@+ ,
breakAA 
;AA 
caseCC 
$numCC 
:CC 
caseDD 
$numDD 
:DD 
intEE 
vcEE 
=EE 
meshEE !
.EE! "
vertexCountEE" -
;EE- .
ifFF 
(FF 
vcFF 
!=FF 
uvsFF !
.FF! "
LengthFF" (
)FF( )
throwGG 
newGG !$
IndexOutOfRangeExceptionGG" :
(GG: ;
$strGG; @
)GG@ A
;GGA B
ListHH 
<HH 
Vector4HH  
>HH  !
listHH" &
=HH' (
newHH) ,
ListHH- 1
<HH1 2
Vector4HH2 9
>HH9 :
(HH: ;
vcHH; =
)HH= >
;HH> ?
forII 
(II 
intII 
iII 
=II  
$numII! "
;II" #
iII$ %
<II& '
vcII( *
;II* +
iII, -
++II- /
)II/ 0
listJJ 
.JJ 
AddJJ  
(JJ  !
uvsJJ! $
[JJ$ %
iJJ% &
]JJ& '
)JJ' (
;JJ( )
meshKK 
.KK 
SetUVsKK 
(KK  
channelKK  '
,KK' (
listKK) -
)KK- .
;KK. /
ifLL 
(LL 
applyToMeshLL #
&&LL$ &
meshLL' +
.LL+ ,
meshLL, 0
!=LL1 3
nullLL4 8
)LL8 9
meshMM 
.MM 
meshMM !
.MM! "
SetUVsMM" (
(MM( )
channelMM) 0
,MM0 1
listMM2 6
)MM6 7
;MM7 8
breakNN 
;NN 
}OO 
}PP 	
publicYY 
staticYY 
voidYY 
SewUVsYY !
(YY! "
thisYY" &
ProBuilderMeshYY' 5
meshYY6 :
,YY: ;
intYY< ?
[YY? @
]YY@ A
indexesYYB I
,YYI J
floatYYK P
deltaYYQ V
)YYV W
{ZZ 	
Vector2[[ 
[[[ 
][[ 
uvs[[ 
=[[ 
mesh[[  
.[[  !
texturesInternal[[! 1
;[[1 2
if]] 
(]] 
uvs]] 
==]] 
null]] 
||]] 
uvs]] "
.]]" #
Length]]# )
!=]]* ,
mesh]]- 1
.]]1 2
vertexCount]]2 =
)]]= >
uvs^^ 
=^^ 
new^^ 
Vector2^^ !
[^^! "
mesh^^" &
.^^& '
vertexCount^^' 2
]^^2 3
;^^3 4
var`` 
lookup`` 
=`` 
mesh`` 
.`` 
sharedTextureLookup`` 1
;``1 2
forbb 
(bb 
intbb 
ibb 
=bb 
$numbb 
;bb 
ibb 
<bb 
indexesbb  '
.bb' (
Lengthbb( .
-bb/ 0
$numbb1 2
;bb2 3
ibb4 5
++bb5 7
)bb7 8
{cc 
fordd 
(dd 
intdd 
ndd 
=dd 
idd 
+dd  
$numdd! "
;dd" #
ndd$ %
<dd& '
indexesdd( /
.dd/ 0
Lengthdd0 6
;dd6 7
ndd8 9
++dd9 ;
)dd; <
{ee 
intff 
aff 
,ff 
bff 
;ff 
ifhh 
(hh 
!hh 
lookuphh 
.hh  
TryGetValuehh  +
(hh+ ,
indexeshh, 3
[hh3 4
ihh4 5
]hh5 6
,hh6 7
outhh8 ;
ahh< =
)hh= >
)hh> ?
lookupii 
.ii 
Addii "
(ii" #
indexesii# *
[ii* +
iii+ ,
]ii, -
,ii- .
aii/ 0
=ii1 2
lookupii3 9
.ii9 :
Countii: ?
(ii? @
)ii@ A
)iiA B
;iiB C
ifkk 
(kk 
!kk 
lookupkk 
.kk  
TryGetValuekk  +
(kk+ ,
indexeskk, 3
[kk3 4
nkk4 5
]kk5 6
,kk6 7
outkk8 ;
bkk< =
)kk= >
)kk> ?
lookupll 
.ll 
Addll "
(ll" #
indexesll# *
[ll* +
nll+ ,
]ll, -
,ll- .
bll/ 0
=ll1 2
lookupll3 9
.ll9 :
Countll: ?
(ll? @
)ll@ A
)llA B
;llB C
ifnn 
(nn 
ann 
==nn 
bnn 
)nn 
continueoo  
;oo  !
ifqq 
(qq 
Vector2qq 
.qq  
Distanceqq  (
(qq( )
uvsqq) ,
[qq, -
indexesqq- 4
[qq4 5
iqq5 6
]qq6 7
]qq7 8
,qq8 9
uvsqq: =
[qq= >
indexesqq> E
[qqE F
nqqF G
]qqG H
]qqH I
)qqI J
<qqK L
deltaqqM R
)qqR S
{rr 
Vector3ss 
censs  #
=ss$ %
(ss& '
uvsss' *
[ss* +
indexesss+ 2
[ss2 3
iss3 4
]ss4 5
]ss5 6
+ss7 8
uvsss9 <
[ss< =
indexesss= D
[ssD E
nssE F
]ssF G
]ssG H
)ssH I
/ssJ K
$numssL N
;ssN O
uvsuu 
[uu 
indexesuu #
[uu# $
iuu$ %
]uu% &
]uu& '
=uu( )
cenuu* -
;uu- .
uvsvv 
[vv 
indexesvv #
[vv# $
nvv$ %
]vv% &
]vv& '
=vv( )
cenvv* -
;vv- .
varzz 
mergezz !
=zz" #
lookupzz$ *
.zz* +
Wherezz+ 0
(zz0 1
xzz1 2
=>zz3 5
xzz6 7
.zz7 8
Valuezz8 =
==zz> @
bzzA B
)zzB C
.zzC D
SelectzzD J
(zzJ K
yzzK L
=>zzM O
yzzP Q
.zzQ R
KeyzzR U
)zzU V
.zzV W
ToArrayzzW ^
(zz^ _
)zz_ `
;zz` a
foreach|| 
(||  !
var||! $
key||% (
in||) +
merge||, 1
)||1 2
lookup}} "
[}}" #
key}}# &
]}}& '
=}}( )
a}}* +
;}}+ ,
}~~ 
} 
}
€€ 
mesh
‚‚ 
.
‚‚ 
SetSharedTextures
‚‚ "
(
‚‚" #
lookup
‚‚# )
)
‚‚) *
;
‚‚* +
}
ƒƒ 	
public
ŠŠ 
static
ŠŠ 
void
ŠŠ 
CollapseUVs
ŠŠ &
(
ŠŠ& '
this
ŠŠ' +
ProBuilderMesh
ŠŠ, :
mesh
ŠŠ; ?
,
ŠŠ? @
int
ŠŠA D
[
ŠŠD E
]
ŠŠE F
indexes
ŠŠG N
)
ŠŠN O
{
‹‹ 	
Vector2
ŒŒ 
[
ŒŒ 
]
ŒŒ 
uvs
ŒŒ 
=
ŒŒ 
mesh
ŒŒ  
.
ŒŒ  !
texturesInternal
ŒŒ! 1
;
ŒŒ1 2
Vector2
 
cen
 
=
 
Math
 
.
 
Average
 &
(
& '
ArrayUtility
' 3
.
3 4
ValuesWithIndexes
4 E
(
E F
uvs
F I
,
I J
indexes
K R
)
R S
)
S T
;
T U
foreach
‘‘ 
(
‘‘ 
int
‘‘ 
i
‘‘ 
in
‘‘ 
indexes
‘‘ %
)
‘‘% &
uvs
’’ 
[
’’ 
i
’’ 
]
’’ 
=
’’ 
cen
’’ 
;
’’ 
mesh
”” 
.
”” #
SetTexturesCoincident
”” &
(
””& '
indexes
””' .
)
””. /
;
””/ 0
}
•• 	
public
œœ 
static
œœ 
void
œœ 
SplitUVs
œœ #
(
œœ# $
this
œœ$ (
ProBuilderMesh
œœ) 7
mesh
œœ8 <
,
œœ< =
IEnumerable
œœ> I
<
œœI J
int
œœJ M
>
œœM N
indexes
œœO V
)
œœV W
{
 	
var
 
lookup
 
=
 
mesh
 
.
 !
sharedTextureLookup
 1
;
1 2
var
ŸŸ 
index
ŸŸ 
=
ŸŸ 
lookup
ŸŸ 
.
ŸŸ 
Count
ŸŸ $
;
ŸŸ$ %
foreach
¡¡ 
(
¡¡ 
var
¡¡ 
vertex
¡¡ 
in
¡¡  "
indexes
¡¡# *
)
¡¡* +
{
¢¢ 
int
££ 
a
££ 
;
££ 
if
¥¥ 
(
¥¥ 
lookup
¥¥ 
.
¥¥ 
TryGetValue
¥¥ &
(
¥¥& '
vertex
¥¥' -
,
¥¥- .
out
¥¥/ 2
a
¥¥3 4
)
¥¥4 5
)
¥¥5 6
lookup
¦¦ 
[
¦¦ 
vertex
¦¦ !
]
¦¦! "
=
¦¦# $
index
¦¦% *
++
¦¦* ,
;
¦¦, -
}
§§ 
mesh
©© 
.
©© 
SetSharedTextures
©© "
(
©©" #
lookup
©©# )
)
©©) *
;
©©* +
}
ªª 	
internal
¯¯ 
static
¯¯ 
void
¯¯ 
SplitUVs
¯¯ %
(
¯¯% &
ProBuilderMesh
¯¯& 4
mesh
¯¯5 9
,
¯¯9 :
IEnumerable
¯¯; F
<
¯¯F G
Face
¯¯G K
>
¯¯K L
faces
¯¯M R
)
¯¯R S
{
°° 	
var
±± 
lookup
±± 
=
±± 
mesh
±± 
.
±± !
sharedTextureLookup
±± 1
;
±±1 2
var
²² 
index
²² 
=
²² 
lookup
²² 
.
²² 
Count
²² $
;
²²$ %
foreach
´´ 
(
´´ 
var
´´ 
face
´´ 
in
´´ 
faces
´´  %
)
´´% &
{
µµ 
foreach
¶¶ 
(
¶¶ 
var
¶¶ 
vertex
¶¶ #
in
¶¶$ &
face
¶¶' +
.
¶¶+ ,%
distinctIndexesInternal
¶¶, C
)
¶¶C D
{
·· 
int
¸¸ 
a
¸¸ 
;
¸¸ 
if
ºº 
(
ºº 
lookup
ºº 
.
ºº 
TryGetValue
ºº *
(
ºº* +
vertex
ºº+ 1
,
ºº1 2
out
ºº3 6
a
ºº7 8
)
ºº8 9
)
ºº9 :
lookup
»» 
[
»» 
vertex
»» %
]
»»% &
=
»»' (
index
»») .
++
»». 0
;
»»0 1
}
¼¼ 
}
½½ 
mesh
¿¿ 
.
¿¿ 
SetSharedTextures
¿¿ "
(
¿¿" #
lookup
¿¿# )
)
¿¿) *
;
¿¿* +
}
ÀÀ 	
internal
ÉÉ 
static
ÉÉ 
void
ÉÉ 
ProjectFacesAuto
ÉÉ -
(
ÉÉ- .
ProBuilderMesh
ÉÉ. <
mesh
ÉÉ= A
,
ÉÉA B
Face
ÉÉC G
[
ÉÉG H
]
ÉÉH I
faces
ÉÉJ O
,
ÉÉO P
int
ÉÉQ T
channel
ÉÉU \
)
ÉÉ\ ]
{
ÊÊ 	
if
ËË 
(
ËË 
faces
ËË 
.
ËË 
Length
ËË 
<
ËË 
$num
ËË  
)
ËË  !
return
ÌÌ 
;
ÌÌ 
int
ÎÎ 
[
ÎÎ 
]
ÎÎ 
ind
ÎÎ 
=
ÎÎ 
faces
ÎÎ 
.
ÎÎ 

SelectMany
ÎÎ (
(
ÎÎ( )
x
ÎÎ) *
=>
ÎÎ+ -
x
ÎÎ. /
.
ÎÎ/ 0%
distinctIndexesInternal
ÎÎ0 G
)
ÎÎG H
.
ÎÎH I
ToArray
ÎÎI P
(
ÎÎP Q
)
ÎÎQ R
;
ÎÎR S
var
ÑÑ !
projectionDirection
ÑÑ #
=
ÑÑ$ %
Vector3
ÑÑ& -
.
ÑÑ- .
zero
ÑÑ. 2
;
ÑÑ2 3
foreach
ÓÓ 
(
ÓÓ 
var
ÓÓ 
face
ÓÓ 
in
ÓÓ  
faces
ÓÓ! &
)
ÓÓ& '
{
ÔÔ 
var
ÕÕ 
nrm
ÕÕ 
=
ÕÕ 
Math
ÕÕ 
.
ÕÕ 
Normal
ÕÕ %
(
ÕÕ% &
mesh
ÕÕ& *
,
ÕÕ* +
face
ÕÕ, 0
)
ÕÕ0 1
;
ÕÕ1 2!
projectionDirection
ÖÖ #
+=
ÖÖ$ &
nrm
ÖÖ' *
;
ÖÖ* +
}
×× !
projectionDirection
ÙÙ 
/=
ÙÙ  "
(
ÙÙ# $
float
ÙÙ$ )
)
ÙÙ) *
faces
ÙÙ+ 0
.
ÙÙ0 1
Length
ÙÙ1 7
;
ÙÙ7 8
Vector2
ÜÜ 
[
ÜÜ 
]
ÜÜ 
uvs
ÜÜ 
=
ÜÜ 

Projection
ÜÜ &
.
ÜÜ& '
PlanarProject
ÜÜ' 4
(
ÜÜ4 5
mesh
ÜÜ5 9
.
ÜÜ9 :
positionsInternal
ÜÜ: K
,
ÜÜK L
ind
ÜÜM P
,
ÜÜP Q!
projectionDirection
ÜÜR e
)
ÜÜe f
;
ÜÜf g
Vector2
ßß 
[
ßß 
]
ßß 

rebuiltUVs
ßß  
=
ßß! "
GetUVs
ßß# )
(
ßß) *
mesh
ßß* .
,
ßß. /
channel
ßß0 7
)
ßß7 8
;
ßß8 9
for
áá 
(
áá 
int
áá 
i
áá 
=
áá 
$num
áá 
;
áá 
i
áá 
<
áá 
ind
áá  #
.
áá# $
Length
áá$ *
;
áá* +
i
áá, -
++
áá- /
)
áá/ 0

rebuiltUVs
ââ 
[
ââ 
ind
ââ 
[
ââ 
i
ââ  
]
ââ  !
]
ââ! "
=
ââ# $
uvs
ââ% (
[
ââ( )
i
ââ) *
]
ââ* +
;
ââ+ ,
ApplyUVs
åå 
(
åå 
mesh
åå 
,
åå 

rebuiltUVs
åå %
,
åå% &
channel
åå' .
)
åå. /
;
åå/ 0
foreach
èè 
(
èè 
Face
èè 
f
èè 
in
èè 
faces
èè $
)
èè$ %
{
éé 
f
êê 
.
êê 
elementGroup
êê 
=
êê  
-
êê! "
$num
êê" #
;
êê# $
SplitUVs
ëë 
(
ëë 
mesh
ëë 
,
ëë 
f
ëë  
.
ëë  !%
distinctIndexesInternal
ëë! 8
)
ëë8 9
;
ëë9 :
}
ìì 
mesh
îî 
.
îî 
SewUVs
îî 
(
îî 
faces
îî 
.
îî 

SelectMany
îî (
(
îî( )
x
îî) *
=>
îî+ -
x
îî. /
.
îî/ 0%
distinctIndexesInternal
îî0 G
)
îîG H
.
îîH I
ToArray
îîI P
(
îîP Q
)
îîQ R
,
îîR S
$num
îîT Y
)
îîY Z
;
îîZ [
}
ïï 	
public
÷÷ 
static
÷÷ 
void
÷÷ 
ProjectFacesBox
÷÷ *
(
÷÷* +
ProBuilderMesh
÷÷+ 9
mesh
÷÷: >
,
÷÷> ?
Face
÷÷@ D
[
÷÷D E
]
÷÷E F
faces
÷÷G L
,
÷÷L M
int
÷÷N Q
channel
÷÷R Y
=
÷÷Z [
$num
÷÷\ ]
)
÷÷] ^
{
øø 	
Vector2
ùù 
[
ùù 
]
ùù 
uv
ùù 
=
ùù 
GetUVs
ùù !
(
ùù! "
mesh
ùù" &
,
ùù& '
channel
ùù( /
)
ùù/ 0
;
ùù0 1

Dictionary
ûû 
<
ûû 
ProjectionAxis
ûû %
,
ûû% &
List
ûû' +
<
ûû+ ,
Face
ûû, 0
>
ûû0 1
>
ûû1 2
sorted
ûû3 9
=
ûû: ;
new
ûû< ?

Dictionary
ûû@ J
<
ûûJ K
ProjectionAxis
ûûK Y
,
ûûY Z
List
ûû[ _
<
ûû_ `
Face
ûû` d
>
ûûd e
>
ûûe f
(
ûûf g
)
ûûg h
;
ûûh i
for
ıı 
(
ıı 
int
ıı 
i
ıı 
=
ıı 
$num
ıı 
;
ıı 
i
ıı 
<
ıı 
faces
ıı  %
.
ıı% &
Length
ıı& ,
;
ıı, -
i
ıı. /
++
ıı/ 1
)
ıı1 2
{
şş 
Vector3
ÿÿ 
nrm
ÿÿ 
=
ÿÿ 
Math
ÿÿ "
.
ÿÿ" #
Normal
ÿÿ# )
(
ÿÿ) *
mesh
ÿÿ* .
,
ÿÿ. /
faces
ÿÿ0 5
[
ÿÿ5 6
i
ÿÿ6 7
]
ÿÿ7 8
)
ÿÿ8 9
;
ÿÿ9 :
ProjectionAxis
€€ 
axis
€€ #
=
€€$ %

Projection
€€& 0
.
€€0 1$
VectorToProjectionAxis
€€1 G
(
€€G H
nrm
€€H K
)
€€K L
;
€€L M
if
‚‚ 
(
‚‚ 
sorted
‚‚ 
.
‚‚ 
ContainsKey
‚‚ &
(
‚‚& '
axis
‚‚' +
)
‚‚+ ,
)
‚‚, -
sorted
ƒƒ 
[
ƒƒ 
axis
ƒƒ 
]
ƒƒ  
.
ƒƒ  !
Add
ƒƒ! $
(
ƒƒ$ %
faces
ƒƒ% *
[
ƒƒ* +
i
ƒƒ+ ,
]
ƒƒ, -
)
ƒƒ- .
;
ƒƒ. /
else
„„ 
sorted
…… 
.
…… 
Add
…… 
(
…… 
axis
…… #
,
……# $
new
……% (
List
……) -
<
……- .
Face
……. 2
>
……2 3
(
……3 4
)
……4 5
{
……6 7
faces
……8 =
[
……= >
i
……> ?
]
……? @
}
……A B
)
……B C
;
……C D
faces
ˆˆ 
[
ˆˆ 
i
ˆˆ 
]
ˆˆ 
.
ˆˆ 
elementGroup
ˆˆ %
=
ˆˆ& '
-
ˆˆ( )
$num
ˆˆ) *
;
ˆˆ* +
faces
‰‰ 
[
‰‰ 
i
‰‰ 
]
‰‰ 
.
‰‰ 
manualUV
‰‰ !
=
‰‰" #
true
‰‰$ (
;
‰‰( )
}
ŠŠ 
foreach
ŒŒ 
(
ŒŒ 
KeyValuePair
ŒŒ !
<
ŒŒ! "
ProjectionAxis
ŒŒ" 0
,
ŒŒ0 1
List
ŒŒ2 6
<
ŒŒ6 7
Face
ŒŒ7 ;
>
ŒŒ; <
>
ŒŒ< =
kvp
ŒŒ> A
in
ŒŒB D
sorted
ŒŒE K
)
ŒŒK L
{
 
int
 
[
 
]
 
distinct
 
=
  
kvp
! $
.
$ %
Value
% *
.
* +

SelectMany
+ 5
(
5 6
x
6 7
=>
8 :
x
; <
.
< =%
distinctIndexesInternal
= T
)
T U
.
U V
ToArray
V ]
(
] ^
)
^ _
;
_ `
Vector2
 
[
 
]
 
uvs
 
=
 

Projection
  *
.
* +
PlanarProject
+ 8
(
8 9
mesh
9 =
.
= >
positionsInternal
> O
,
O P
distinct
Q Y
,
Y Z

Projection
[ e
.
e f$
ProjectionAxisToVector
f |
(
| }
kvp} €
.€ 
Key „
)„ …
)… †
;† ‡
for
’’ 
(
’’ 
int
’’ 
n
’’ 
=
’’ 
$num
’’ 
;
’’ 
n
’’  !
<
’’" #
distinct
’’$ ,
.
’’, -
Length
’’- 3
;
’’3 4
n
’’5 6
++
’’6 8
)
’’8 9
uv
““ 
[
““ 
distinct
““ 
[
““  
n
““  !
]
““! "
]
““" #
=
““$ %
uvs
““& )
[
““) *
n
““* +
]
““+ ,
;
““, -
SplitUVs
•• 
(
•• 
mesh
•• 
,
•• 
distinct
•• '
)
••' (
;
••( )
}
–– 
ApplyUVs
™™ 
(
™™ 
mesh
™™ 
,
™™ 
uv
™™ 
,
™™ 
channel
™™ &
)
™™& '
;
™™' (
}
šš 	
internal
ŸŸ 
static
ŸŸ 
Vector2
ŸŸ 
FindMinimalUV
ŸŸ  -
(
ŸŸ- .
Vector2
ŸŸ. 5
[
ŸŸ5 6
]
ŸŸ6 7
uvs
ŸŸ8 ;
,
ŸŸ; <
int
ŸŸ= @
[
ŸŸ@ A
]
ŸŸA B
indices
ŸŸC J
=
ŸŸK L
null
ŸŸM Q
,
ŸŸQ R
float
ŸŸS X
xMin
ŸŸY ]
=
ŸŸ^ _
$num
ŸŸ` b
,
ŸŸb c
float
ŸŸd i
yMin
ŸŸj n
=
ŸŸo p
$num
ŸŸq s
)
ŸŸs t
{
   	
int
¡¡ 

nbElements
¡¡ 
=
¡¡ 
(
¡¡ 
indices
¡¡ %
==
¡¡& (
null
¡¡) -
?
¡¡. /
uvs
¡¡0 3
.
¡¡3 4
Length
¡¡4 :
:
¡¡; <
indices
¡¡= D
.
¡¡D E
Length
¡¡E K
)
¡¡K L
;
¡¡L M
bool
¢¢ 
first
¢¢ 
=
¢¢ 
(
¢¢ 
xMin
¢¢ 
==
¢¢ !
$num
¢¢" $
&&
¢¢% '
yMin
¢¢( ,
==
¢¢- /
$num
¢¢0 2
)
¢¢2 3
;
¢¢3 4
for
££ 
(
££ 
int
££ 
i
££ 
=
££ 
$num
££ 
;
££ 
i
££ 
<
££ 

nbElements
££  *
;
££* +
++
££, .
i
££. /
)
££/ 0
{
¤¤ 
int
¥¥ 
currentIndex
¥¥  
=
¥¥! "
(
¥¥# $
indices
¥¥$ +
==
¥¥, .
null
¥¥/ 3
?
¥¥4 5
i
¥¥6 7
:
¥¥8 9
indices
¥¥: A
[
¥¥A B
i
¥¥B C
]
¥¥C D
)
¥¥D E
;
¥¥E F
if
¦¦ 
(
¦¦ 
first
¦¦ 
)
¦¦ 
{
§§ 
xMin
¨¨ 
=
¨¨ 
uvs
¨¨ 
[
¨¨ 
currentIndex
¨¨ +
]
¨¨+ ,
.
¨¨, -
x
¨¨- .
;
¨¨. /
yMin
©© 
=
©© 
uvs
©© 
[
©© 
currentIndex
©© +
]
©©+ ,
.
©©, -
y
©©- .
;
©©. /
first
ªª 
=
ªª 
false
ªª !
;
ªª! "
}
«« 
else
¬¬ 
{
­­ 
if
¯¯ 
(
¯¯ 
uvs
¯¯ 
[
¯¯ 
currentIndex
¯¯ (
]
¯¯( )
.
¯¯) *
x
¯¯* +
<
¯¯, -
xMin
¯¯. 2
)
¯¯2 3
{
°° 
xMin
±± 
=
±± 
uvs
±± "
[
±±" #
currentIndex
±±# /
]
±±/ 0
.
±±0 1
x
±±1 2
;
±±2 3
}
²² 
if
´´ 
(
´´ 
uvs
´´ 
[
´´ 
currentIndex
´´ (
]
´´( )
.
´´) *
y
´´* +
<
´´, -
yMin
´´. 2
)
´´2 3
{
µµ 
yMin
¶¶ 
=
¶¶ 
uvs
¶¶ "
[
¶¶" #
currentIndex
¶¶# /
]
¶¶/ 0
.
¶¶0 1
y
¶¶1 2
;
¶¶2 3
}
·· 
}
¸¸ 
}
¹¹ 
return
»» 
new
»» 
Vector2
»» 
(
»» 
xMin
»» #
,
»»# $
yMin
»»% )
)
»») *
;
»»* +
}
¼¼ 	
public
ÅÅ 
static
ÅÅ 
void
ÅÅ 
ProjectFacesBox
ÅÅ *
(
ÅÅ* +
ProBuilderMesh
ÅÅ+ 9
mesh
ÅÅ: >
,
ÅÅ> ?
Face
ÅÅ@ D
[
ÅÅD E
]
ÅÅE F
faces
ÅÅG L
,
ÅÅL M
Vector2
ÅÅN U
lowerLeftAnchor
ÅÅV e
,
ÅÅe f
int
ÅÅg j
channel
ÅÅk r
=
ÅÅs t
$num
ÅÅu v
)
ÅÅv w
{
ÆÆ 	
Vector2
ÇÇ 
[
ÇÇ 
]
ÇÇ 
uv
ÇÇ 
=
ÇÇ 
GetUVs
ÇÇ !
(
ÇÇ! "
mesh
ÇÇ" &
,
ÇÇ& '
channel
ÇÇ( /
)
ÇÇ/ 0
;
ÇÇ0 1

Dictionary
ÉÉ 
<
ÉÉ 
ProjectionAxis
ÉÉ %
,
ÉÉ% &
List
ÉÉ' +
<
ÉÉ+ ,
Face
ÉÉ, 0
>
ÉÉ0 1
>
ÉÉ1 2
sorted
ÉÉ3 9
=
ÉÉ: ;
new
ÉÉ< ?

Dictionary
ÉÉ@ J
<
ÉÉJ K
ProjectionAxis
ÉÉK Y
,
ÉÉY Z
List
ÉÉ[ _
<
ÉÉ_ `
Face
ÉÉ` d
>
ÉÉd e
>
ÉÉe f
(
ÉÉf g
)
ÉÉg h
;
ÉÉh i
for
ËË 
(
ËË 
int
ËË 
i
ËË 
=
ËË 
$num
ËË 
;
ËË 
i
ËË 
<
ËË 
faces
ËË  %
.
ËË% &
Length
ËË& ,
;
ËË, -
i
ËË. /
++
ËË/ 1
)
ËË1 2
{
ÌÌ 
Vector3
ÍÍ 
nrm
ÍÍ 
=
ÍÍ 
Math
ÍÍ "
.
ÍÍ" #
Normal
ÍÍ# )
(
ÍÍ) *
mesh
ÍÍ* .
,
ÍÍ. /
faces
ÍÍ0 5
[
ÍÍ5 6
i
ÍÍ6 7
]
ÍÍ7 8
)
ÍÍ8 9
;
ÍÍ9 :
ProjectionAxis
ÎÎ 
axis
ÎÎ #
=
ÎÎ$ %

Projection
ÎÎ& 0
.
ÎÎ0 1$
VectorToProjectionAxis
ÎÎ1 G
(
ÎÎG H
nrm
ÎÎH K
)
ÎÎK L
;
ÎÎL M
if
ĞĞ 
(
ĞĞ 
sorted
ĞĞ 
.
ĞĞ 
ContainsKey
ĞĞ &
(
ĞĞ& '
axis
ĞĞ' +
)
ĞĞ+ ,
)
ĞĞ, -
sorted
ÑÑ 
[
ÑÑ 
axis
ÑÑ 
]
ÑÑ  
.
ÑÑ  !
Add
ÑÑ! $
(
ÑÑ$ %
faces
ÑÑ% *
[
ÑÑ* +
i
ÑÑ+ ,
]
ÑÑ, -
)
ÑÑ- .
;
ÑÑ. /
else
ÒÒ 
sorted
ÓÓ 
.
ÓÓ 
Add
ÓÓ 
(
ÓÓ 
axis
ÓÓ #
,
ÓÓ# $
new
ÓÓ% (
List
ÓÓ) -
<
ÓÓ- .
Face
ÓÓ. 2
>
ÓÓ2 3
(
ÓÓ3 4
)
ÓÓ4 5
{
ÓÓ6 7
faces
ÓÓ8 =
[
ÓÓ= >
i
ÓÓ> ?
]
ÓÓ? @
}
ÓÓA B
)
ÓÓB C
;
ÓÓC D
faces
ÖÖ 
[
ÖÖ 
i
ÖÖ 
]
ÖÖ 
.
ÖÖ 
elementGroup
ÖÖ %
=
ÖÖ& '
-
ÖÖ( )
$num
ÖÖ) *
;
ÖÖ* +
faces
×× 
[
×× 
i
×× 
]
×× 
.
×× 
manualUV
×× !
=
××" #
true
××$ (
;
××( )
}
ØØ 
foreach
ÚÚ 
(
ÚÚ 
KeyValuePair
ÚÚ !
<
ÚÚ! "
ProjectionAxis
ÚÚ" 0
,
ÚÚ0 1
List
ÚÚ2 6
<
ÚÚ6 7
Face
ÚÚ7 ;
>
ÚÚ; <
>
ÚÚ< =
kvp
ÚÚ> A
in
ÚÚB D
sorted
ÚÚE K
)
ÚÚK L
{
ÛÛ 
int
ÜÜ 
[
ÜÜ 
]
ÜÜ 
distinct
ÜÜ 
=
ÜÜ  
kvp
ÜÜ! $
.
ÜÜ$ %
Value
ÜÜ% *
.
ÜÜ* +

SelectMany
ÜÜ+ 5
(
ÜÜ5 6
x
ÜÜ6 7
=>
ÜÜ8 :
x
ÜÜ; <
.
ÜÜ< =%
distinctIndexesInternal
ÜÜ= T
)
ÜÜT U
.
ÜÜU V
ToArray
ÜÜV ]
(
ÜÜ] ^
)
ÜÜ^ _
;
ÜÜ_ `
Vector2
ŞŞ 
[
ŞŞ 
]
ŞŞ 
uvs
ŞŞ 
=
ŞŞ 

Projection
ŞŞ  *
.
ŞŞ* +
PlanarProject
ŞŞ+ 8
(
ŞŞ8 9
mesh
ŞŞ9 =
.
ŞŞ= >
positionsInternal
ŞŞ> O
,
ŞŞO P
distinct
ŞŞQ Y
,
ŞŞY Z

Projection
ŞŞ[ e
.
ŞŞe f$
ProjectionAxisToVector
ŞŞf |
(
ŞŞ| }
kvpŞŞ} €
.ŞŞ€ 
KeyŞŞ „
)ŞŞ„ …
)ŞŞ… †
;ŞŞ† ‡
Vector2
áá 
	minimalUV
áá !
=
áá" #
FindMinimalUV
áá$ 1
(
áá1 2
uvs
áá2 5
)
áá5 6
;
áá6 7
for
ãã 
(
ãã 
int
ãã 
n
ãã 
=
ãã 
$num
ãã 
;
ãã 
n
ãã  !
<
ãã" #
distinct
ãã$ ,
.
ãã, -
Length
ãã- 3
;
ãã3 4
n
ãã5 6
++
ãã6 8
)
ãã8 9
uv
ää 
[
ää 
distinct
ää 
[
ää  
n
ää  !
]
ää! "
]
ää" #
=
ää$ %
uvs
ää& )
[
ää) *
n
ää* +
]
ää+ ,
-
ää- .
	minimalUV
ää/ 8
;
ää8 9
SplitUVs
ææ 
(
ææ 
mesh
ææ 
,
ææ 
distinct
ææ '
)
ææ' (
;
ææ( )
}
çç 
ApplyUVs
êê 
(
êê 
mesh
êê 
,
êê 
uv
êê 
,
êê 
channel
êê &
)
êê& '
;
êê' (
}
ëë 	
public
óó 
static
óó 
void
óó  
ProjectFacesSphere
óó -
(
óó- .
ProBuilderMesh
óó. <
pb
óó= ?
,
óó? @
int
óóA D
[
óóD E
]
óóE F
indexes
óóG N
,
óóN O
int
óóP S
channel
óóT [
=
óó\ ]
$num
óó^ _
)
óó_ `
{
ôô 	
foreach
õõ 
(
õõ 
Face
õõ 
f
õõ 
in
õõ 
pb
õõ !
.
õõ! "
facesInternal
õõ" /
)
õõ/ 0
{
öö 
if
÷÷ 
(
÷÷ 
ArrayUtility
÷÷  
.
÷÷  !
ContainsMatch
÷÷! .
<
÷÷. /
int
÷÷/ 2
>
÷÷2 3
(
÷÷3 4
f
÷÷4 5
.
÷÷5 6%
distinctIndexesInternal
÷÷6 M
,
÷÷M N
indexes
÷÷O V
)
÷÷V W
)
÷÷W X
{
øø 
f
ùù 
.
ùù 
elementGroup
ùù "
=
ùù# $
-
ùù% &
$num
ùù& '
;
ùù' (
f
úú 
.
úú 
manualUV
úú 
=
úú  
true
úú! %
;
úú% &
}
ûû 
}
üü 
SplitUVs
şş 
(
şş 
pb
şş 
,
şş 
indexes
şş  
)
şş  !
;
şş! "
Vector2
€€ 
[
€€ 
]
€€ 
	projected
€€ 
=
€€  !

Projection
€€" ,
.
€€, -
SphericalProject
€€- =
(
€€= >
pb
€€> @
.
€€@ A
positionsInternal
€€A R
,
€€R S
indexes
€€T [
)
€€[ \
;
€€\ ]
Vector2
 
[
 
]
 
uv
 
=
 
GetUVs
 !
(
! "
pb
" $
,
$ %
channel
& -
)
- .
;
. /
for
ƒƒ 
(
ƒƒ 
int
ƒƒ 
i
ƒƒ 
=
ƒƒ 
$num
ƒƒ 
;
ƒƒ 
i
ƒƒ 
<
ƒƒ 
indexes
ƒƒ  '
.
ƒƒ' (
Length
ƒƒ( .
;
ƒƒ. /
i
ƒƒ0 1
++
ƒƒ1 3
)
ƒƒ3 4
uv
„„ 
[
„„ 
indexes
„„ 
[
„„ 
i
„„ 
]
„„ 
]
„„ 
=
„„  
	projected
„„! *
[
„„* +
i
„„+ ,
]
„„, -
;
„„- .
ApplyUVs
‡‡ 
(
‡‡ 
pb
‡‡ 
,
‡‡ 
uv
‡‡ 
,
‡‡ 
channel
‡‡ $
)
‡‡$ %
;
‡‡% &
}
ˆˆ 	
public
 
static
 
Vector2
 
[
 
]
 
FitUVs
  &
(
& '
Vector2
' .
[
. /
]
/ 0
uvs
1 4
)
4 5
{
 	
Vector2
 
smallestVector2
 #
=
$ %
Math
& *
.
* +
SmallestVector2
+ :
(
: ;
uvs
; >
)
> ?
;
? @
int
’’ 
i
’’ 
;
’’ 
for
““ 
(
““ 
i
““ 
=
““ 
$num
““ 
;
““ 
i
““ 
<
““ 
uvs
““ 
.
““  
Length
““  &
;
““& '
i
““( )
++
““) +
)
““+ ,
{
”” 
uvs
•• 
[
•• 
i
•• 
]
•• 
-=
•• 
smallestVector2
•• )
;
••) *
}
–– 
float
˜˜ 
scale
˜˜ 
=
˜˜ 
Math
˜˜ 
.
˜˜ 
LargestValue
˜˜ +
(
˜˜+ ,
Math
˜˜, 0
.
˜˜0 1
LargestVector2
˜˜1 ?
(
˜˜? @
uvs
˜˜@ C
)
˜˜C D
)
˜˜D E
;
˜˜E F
for
šš 
(
šš 
i
šš 
=
šš 
$num
šš 
;
šš 
i
šš 
<
šš 
uvs
šš 
.
šš  
Length
šš  &
;
šš& '
i
šš( )
++
šš) +
)
šš+ ,
{
›› 
uvs
œœ 
[
œœ 
i
œœ 
]
œœ 
/=
œœ 
scale
œœ 
;
œœ  
}
 
return
ŸŸ 
uvs
ŸŸ 
;
ŸŸ 
}
   	
}
¡¡ 
}¢¢ Œ
‰D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Shortcut.csë€
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SelectPathFaces.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
SelectPathFaces  
{ 
static 
int 
[ 
]  
s_cachedPredecessors )
;) *
static		 
int		 
s_cachedStart		  
;		  !
static

 
ProBuilderMesh

 
s_cachedMesh

 *
;

* +
static 
int 
s_cachedFacesCount %
;% &
static 
List 
< 

WingedEdge 
> 
s_cachedWings  -
;- .
static 

Dictionary 
< 
Face 
, 
int  #
># $
s_cachedFacesIndex% 7
=8 9
new: =

Dictionary> H
<H I
FaceI M
,M N
intO R
>R S
(S T
)T U
;U V
public 
static 
List 
< 
int 
> 
GetPath  '
(' (
ProBuilderMesh( 6
mesh7 ;
,; <
int= @
startA F
,F G
intH K
endL O
)O P
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new 
System  
.  !
ArgumentException! 2
(2 3
$str3 M
,M N
$strO U
)U V
;V W
if 
( 
start 
< 
$num 
|| 
start "
># $
mesh% )
.) *
	faceCount* 3
-4 5
$num6 7
)7 8
throw 
new 
System  
.  !
ArgumentException! 2
(2 3
$str3 O
,O P
$strQ X
)X Y
;Y Z
if 
( 
end 
< 
$num 
|| 
end 
>  
mesh! %
.% &
	faceCount& /
-0 1
$num2 3
)3 4
throw 
new 
System  
.  !
ArgumentException! 2
(2 3
$str3 O
,O P
$strQ V
)V W
;W X
List 
< 
int 
> 
path 
; 
if!! 
(!! 
start!! 
==!! 
s_cachedStart!! &
&&!!' )
mesh!!* .
==!!/ 1
s_cachedMesh!!2 >
&&!!? A
mesh!!C G
.!!G H
	faceCount!!H Q
==!!R T
s_cachedFacesCount!!U g
)!!g h
return"" 
GetMinimalPath"" %
(""% & 
s_cachedPredecessors""& :
,"": ;
start""< A
,""A B
end""C F
)""F G
;""G H
var$$ 
predecessors$$ 
=$$ 
Dijkstra$$ '
($$' (
mesh$$( ,
,$$, -
start$$. 3
)$$3 4
;$$4 5
path%% 
=%% 
GetMinimalPath%% !
(%%! "
predecessors%%" .
,%%. /
start%%0 5
,%%5 6
end%%7 :
)%%: ;
;%%; < 
s_cachedPredecessors&&  
=&&! "
predecessors&&# /
;&&/ 0
s_cachedStart'' 
='' 
start'' !
;''! "
s_cachedMesh(( 
=(( 
mesh(( 
;((  
return** 
path** 
;** 
}++ 	
static44 
int44 
[44 
]44 
Dijkstra44 
(44 
ProBuilderMesh44 ,
mesh44- 1
,441 2
int443 6
start447 <
)44< =
{55 	
HashSet66 
<66 
int66 
>66 
visited66  
=66! "
new66# &
HashSet66' .
<66. /
int66/ 2
>662 3
(663 4
)664 5
;665 6
HashSet77 
<77 
int77 
>77 
toVisit77  
=77! "
new77# &
HashSet77' .
<77. /
int77/ 2
>772 3
(773 4
)774 5
;775 6
if88 
(88 
s_cachedMesh88 
!=88 
mesh88  $
||88% '
s_cachedFacesCount88( :
!=88; =
mesh88> B
.88B C
	faceCount88C L
)88L M
{99 
s_cachedWings:: 
=:: 

WingedEdge::  *
.::* +
GetWingedEdges::+ 9
(::9 :
mesh::: >
,::> ?
true::@ D
)::D E
;::E F
s_cachedFacesIndex;; "
.;;" #
Clear;;# (
(;;( )
);;) *
;;;* +
s_cachedFacesCount<< "
=<<# $
mesh<<% )
.<<) *
	faceCount<<* 3
;<<3 4
for>> 
(>> 
int>> 
i>> 
=>> 
$num>> 
;>> 
i>>  !
<>>" #
mesh>>$ (
.>>( )
facesInternal>>) 6
.>>6 7
Length>>7 =
;>>= >
i>>? @
++>>@ B
)>>B C
{?? 
s_cachedFacesIndex@@ &
.@@& '
Add@@' *
(@@* +
mesh@@+ /
.@@/ 0
facesInternal@@0 =
[@@= >
i@@> ?
]@@? @
,@@@ A
i@@B C
)@@C D
;@@D E
}AA 
}BB 
intCC 
	wingCountCC 
=CC 
s_cachedWingsCC )
.CC) *
CountCC* /
;CC/ 0
floatEE 
[EE 
]EE 
weightsEE 
=EE 
newEE !
floatEE" '
[EE' (
	wingCountEE( 1
]EE1 2
;EE2 3
intFF 
[FF 
]FF 
predecessorsFF 
=FF  
newFF! $
intFF% (
[FF( )
	wingCountFF) 2
]FF2 3
;FF3 4
forHH 
(HH 
intHH 
iHH 
=HH 
$numHH 
;HH 
iHH 
<HH 
	wingCountHH  )
;HH) *
iHH+ ,
++HH, .
)HH. /
{II 
weightsJJ 
[JJ 
iJJ 
]JJ 
=JJ 
floatJJ "
.JJ" #
MaxValueJJ# +
;JJ+ ,
predecessorsKK 
[KK 
iKK 
]KK 
=KK  !
-KK" #
$numKK# $
;KK$ %
}LL 
intNN 
currentNN 
=NN 
startNN 
;NN  
weightsOO 
[OO 
currentOO 
]OO 
=OO 
$numOO  
;OO  !
visitedPP 
.PP 
AddPP 
(PP 
currentPP 
)PP  
;PP  !
whileSS 
(SS 
visitedSS 
.SS 
CountSS  
<SS! "
	wingCountSS# ,
)SS, -
{TT 
varUU 
currentWingUU 
=UU  !
s_cachedWingsUU" /
[UU/ 0
currentUU0 7
]UU7 8
;UU8 9
varVV 
	otherWingVV 
=VV 
currentWingVV  +
;VV+ ,
doXX 
{YY 
varZZ 
oppositeZZ  
=ZZ! "
	otherWingZZ# ,
.ZZ, -
oppositeZZ- 5
;ZZ5 6
if[[ 
([[ 
opposite[[  
==[[! #
null[[$ (
)[[( )
{\\ 
	otherWing]] !
=]]" #
	otherWing]]$ -
.]]- .
next]]. 2
;]]2 3
continue^^  
;^^  !
}__ 
varaa 
idxaa 
=aa 
s_cachedFacesIndexaa 0
[aa0 1
oppositeaa1 9
.aa9 :
faceaa: >
]aa> ?
;aa? @
varbb 
weightbb 
=bb  
	GetWeightbb! *
(bb* +
currentbb+ 2
,bb2 3
idxbb4 7
,bb7 8
meshbb9 =
)bb= >
;bb> ?
ifdd 
(dd 
weightsdd 
[dd  
currentdd  '
]dd' (
+dd) *
weightdd+ 1
<dd2 3
weightsdd4 ;
[dd; <
idxdd< ?
]dd? @
)dd@ A
{ee 
weightsff 
[ff  
idxff  #
]ff# $
=ff% &
weightsff' .
[ff. /
currentff/ 6
]ff6 7
+ff8 9
weightff: @
;ff@ A
predecessorsgg $
[gg$ %
idxgg% (
]gg( )
=gg* +
currentgg, 3
;gg3 4
}hh 
ifjj 
(jj 
!jj 
toVisitjj  
.jj  !
Containsjj! )
(jj) *
idxjj* -
)jj- .
&&jj/ 1
!jj2 3
visitedjj3 :
.jj: ;
Containsjj; C
(jjC D
idxjjD G
)jjG H
)jjH I
{kk 
toVisitll 
.ll  
Addll  #
(ll# $
idxll$ '
)ll' (
;ll( )
}mm 
	otherWingoo 
=oo 
	otherWingoo  )
.oo) *
nextoo* .
;oo. /
}qq 
whileqq 
(qq 
	otherWingqq "
!=qq# %
currentWingqq& 1
)qq1 2
;qq2 3
iftt 
(tt 
toVisittt 
.tt 
Counttt !
==tt" $
$numtt% &
)tt& '
{uu 
returnvv 
predecessorsvv '
;vv' (
}ww 
floatyy 
minyy 
=yy 
floatyy !
.yy! "
MaxValueyy" *
;yy* +
foreachzz 
(zz 
varzz 
izz 
inzz !
toVisitzz" )
)zz) *
{{{ 
if|| 
(|| 
weights|| 
[||  
i||  !
]||! "
<||# $
min||% (
)||( )
{}} 
min~~ 
=~~ 
weights~~ %
[~~% &
i~~& '
]~~' (
;~~( )
current 
=  !
i" #
;# $
}
€€ 
}
 
visited
‚‚ 
.
‚‚ 
Add
‚‚ 
(
‚‚ 
current
‚‚ #
)
‚‚# $
;
‚‚$ %
toVisit
ƒƒ 
.
ƒƒ 
Remove
ƒƒ 
(
ƒƒ 
current
ƒƒ &
)
ƒƒ& '
;
ƒƒ' (
}
„„ 
return
†† 
predecessors
†† 
;
††  
}
‡‡ 	
static
‰‰ 
float
‰‰ 
	GetWeight
‰‰ 
(
‰‰ 
int
‰‰ "
face1
‰‰# (
,
‰‰( )
int
‰‰* -
face2
‰‰. 3
,
‰‰3 4
ProBuilderMesh
‰‰5 C
mesh
‰‰D H
)
‰‰H I
{
ŠŠ 	
const
‹‹ 
float
‹‹ 
baseCost
‹‹  
=
‹‹! "
$num
‹‹# &
;
‹‹& '
const
ŒŒ 
float
ŒŒ 

normalMult
ŒŒ "
=
ŒŒ# $
$num
ŒŒ% '
;
ŒŒ' (
const
 
float
 
distMult
  
=
! "
$num
# %
;
% &
var
 
n1
 
=
 
Math
 
.
 
Normal
  
(
  !
mesh
! %
,
% &
mesh
' +
.
+ ,
facesInternal
, 9
[
9 :
face1
: ?
]
? @
)
@ A
;
A B
var
‘‘ 
n2
‘‘ 
=
‘‘ 
Math
‘‘ 
.
‘‘ 
Normal
‘‘  
(
‘‘  !
mesh
‘‘! %
,
‘‘% &
mesh
‘‘' +
.
‘‘+ ,
facesInternal
‘‘, 9
[
‘‘9 :
face2
‘‘: ?
]
‘‘? @
)
‘‘@ A
;
‘‘A B
float
’’ 

normalCost
’’ 
=
’’ 
(
’’  
$num
’’  "
-
’’# $
Vector3
’’% ,
.
’’, -
Dot
’’- 0
(
’’0 1
n1
’’1 3
.
’’3 4

normalized
’’4 >
,
’’> ?
n2
’’@ B
.
’’B C

normalized
’’C M
)
’’M N
)
’’N O
*
’’P Q

normalMult
’’R \
;
’’\ ]
Vector3
•• 
p1
•• 
=
•• 
Vector3
••  
.
••  !
zero
••! %
;
••% &
Vector3
–– 
p2
–– 
=
–– 
Vector3
––  
.
––  !
zero
––! %
;
––% &
foreach
—— 
(
—— 
var
—— 
point
—— 
in
—— !
mesh
——" &
.
——& '
facesInternal
——' 4
[
——4 5
face1
——5 :
]
——: ;
.
——; <
indexesInternal
——< K
)
——K L
{
˜˜ 
p1
™™ 
+=
™™ 
mesh
™™ 
.
™™ 
positionsInternal
™™ ,
[
™™, -
point
™™- 2
]
™™2 3
/
™™4 5
mesh
™™6 :
.
™™: ;
facesInternal
™™; H
[
™™H I
face1
™™I N
]
™™N O
.
™™O P
indexesInternal
™™P _
.
™™_ `
Count
™™` e
(
™™e f
)
™™f g
;
™™g h
}
šš 
foreach
›› 
(
›› 
var
›› 
point
›› 
in
›› !
mesh
››" &
.
››& '
facesInternal
››' 4
[
››4 5
face2
››5 :
]
››: ;
.
››; <
indexesInternal
››< K
)
››K L
{
œœ 
p2
 
+=
 
mesh
 
.
 
positionsInternal
 ,
[
, -
point
- 2
]
2 3
/
4 5
mesh
6 :
.
: ;
facesInternal
; H
[
H I
face2
I N
]
N O
.
O P
indexesInternal
P _
.
_ `
Count
` e
(
e f
)
f g
;
g h
}
 
float
   
distCost
   
=
   
(
   
p2
    
-
  ! "
p1
  # %
)
  % &
.
  & '
	magnitude
  ' 0
*
  1 2
distMult
  3 ;
;
  ; <
return
¢¢ 
baseCost
¢¢ 
+
¢¢ 
distCost
¢¢ &
+
¢¢' (

normalCost
¢¢) 3
;
¢¢3 4
}
££ 	
static
¥¥ 
List
¥¥ 
<
¥¥ 
int
¥¥ 
>
¥¥ 
GetMinimalPath
¥¥ '
(
¥¥' (
int
¥¥( +
[
¥¥+ ,
]
¥¥, -
predecessors
¥¥. :
,
¥¥: ;
int
¥¥< ?
start
¥¥@ E
,
¥¥E F
int
¥¥G J
end
¥¥K N
)
¥¥N O
{
¦¦ 	
if
§§ 
(
§§ 
predecessors
§§ 
[
§§ 
end
§§  
]
§§  !
==
§§" $
-
§§% &
$num
§§& '
)
§§' (
{
¨¨ 
return
©© 
null
©© 
;
©© 
}
ªª 
Stack
«« 
<
«« 
int
«« 
>
«« 
list
«« 
=
«« 
new
«« !
Stack
««" '
<
««' (
int
««( +
>
««+ ,
(
««, -
)
««- .
;
««. /
int
¬¬ 
a
¬¬ 
=
¬¬ 
end
¬¬ 
;
¬¬ 
while
­­ 
(
­­ 
a
­­ 
!=
­­ 
start
­­ 
)
­­ 
{
®® 
list
¯¯ 
.
¯¯ 
Push
¯¯ 
(
¯¯ 
a
¯¯ 
)
¯¯ 
;
¯¯ 
a
°° 
=
°° 
predecessors
°°  
[
°°  !
a
°°! "
]
°°" #
;
°°# $
}
±± 
return
²² 
list
²² 
.
²² 
ToList
²² 
(
²² 
)
²²  
;
²²  !
}
³³ 	
}
´´ 
}µµ Ì1
 D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SelectionPickerRendererStandard.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
internal 
partial 
class #
SelectionPickerRenderer 2
{ 
internal 
class +
SelectionPickerRendererStandard 6
:6 7$
ISelectionPickerRenderer8 P
{ 	
public 
	Texture2D 
RenderLookupTexture 0
(0 1
Camera 
camera 
, 
Shader 
shader 
, 
string 
tag 
, 
int 
width 
= 
- 
$num 
, 
int 
height 
= 
- 
$num 
)  
{ 
bool 
autoSize 
= 
width  %
<& '
$num( )
||* ,
height- 3
<4 5
$num6 7
;7 8
int 
_width 
= 
autoSize %
?& '
(( )
int) ,
), -
camera- 3
.3 4
	pixelRect4 =
.= >
width> C
:D E
widthF K
;K L
int 
_height 
= 
autoSize &
?' (
() *
int* -
)- .
camera. 4
.4 5
	pixelRect5 >
.> ?
height? E
:F G
heightH N
;N O

GameObject 
go 
= 
new  #

GameObject$ .
(. /
)/ 0
;0 1
Camera   
	renderCam    
=  ! "
go  # %
.  % &
AddComponent  & 2
<  2 3
Camera  3 9
>  9 :
(  : ;
)  ; <
;  < =
	renderCam!! 
.!! 
CopyFrom!! "
(!!" #
camera!!# )
)!!) *
;!!* +
	renderCam## 
.## 
renderingPath## '
=##( )
RenderingPath##* 7
.##7 8
Forward##8 ?
;##? @
	renderCam$$ 
.$$ 
enabled$$ !
=$$" #
false$$$ )
;$$) *
	renderCam%% 
.%% 

clearFlags%% $
=%%% &
CameraClearFlags%%' 7
.%%7 8

SolidColor%%8 B
;%%B C
	renderCam&& 
.&& 
backgroundColor&& )
=&&* +
Color&&, 1
.&&1 2
white&&2 7
;&&7 8
	renderCam(( 
.(( 
allowHDR(( "
=((# $
false((% *
;((* +
	renderCam)) 
.)) 
	allowMSAA)) #
=))$ %
false))& +
;))+ ,
	renderCam** 
.** "
forceIntoRenderTexture** 0
=**1 2
true**3 7
;**7 8#
RenderTextureDescriptor.. '

descriptor..( 2
=..3 4
new..5 8#
RenderTextureDescriptor..9 P
(..P Q
)..Q R
{// 
width00 
=00 
_width00 "
,00" #
height11 
=11 
_height11 $
,11$ %
colorFormat22 
=22  !
renderTextureFormat22" 5
,225 6
autoGenerateMips33 $
=33% &
false33' ,
,33, -
depthBufferBits44 #
=44$ %
$num44& (
,44( )
	dimension55 
=55 
UnityEngine55  +
.55+ ,
	Rendering55, 5
.555 6
TextureDimension556 F
.55F G
Tex2D55G L
,55L M
enableRandomWrite66 %
=66& '
false66( -
,66- .

memoryless77 
=77  #
RenderTextureMemoryless77! 8
.778 9
None779 =
,77= >
sRGB88 
=88 
false88  
,88  !
	useMipMap99 
=99 
false99  %
,99% &
volumeDepth:: 
=::  !
$num::" #
,::# $
msaaSamples;; 
=;;  !
$num;;" #
}<< 
;<< 
RenderTexture== 
rt==  
===! "
RenderTexture==# 0
.==0 1
GetTemporary==1 =
(=== >

descriptor==> H
)==H I
;==I J
RenderTextureHH 
prevHH "
=HH# $
RenderTextureHH% 2
.HH2 3
activeHH3 9
;HH9 :
	renderCamII 
.II 
targetTextureII '
=II( )
rtII* ,
;II, -
RenderTextureJJ 
.JJ 
activeJJ $
=JJ% &
rtJJ' )
;JJ) *
	renderCam^^ 
.^^ 
RenderWithShader^^ *
(^^* +
shader^^+ 1
,^^1 2
tag^^3 6
)^^6 7
;^^7 8
	Texture2D`` 
img`` 
=`` 
new``  #
	Texture2D``$ -
(``- .
_width``. 4
,``4 5
_height``6 =
,``= >
textureFormat``? L
,``L M
false``N S
,``S T
false``U Z
)``Z [
;``[ \
imgaa 
.aa 

ReadPixelsaa 
(aa 
newaa "
Rectaa# '
(aa' (
$numaa( )
,aa) *
$numaa+ ,
,aa, -
_widthaa. 4
,aa4 5
_heightaa6 =
)aa= >
,aa> ?
$numaa@ A
,aaA B
$numaaC D
)aaD E
;aaE F
imgbb 
.bb 
Applybb 
(bb 
)bb 
;bb 
RenderTexturedd 
.dd 
activedd $
=dd% &
prevdd' +
;dd+ ,
RenderTextureee 
.ee 
ReleaseTemporaryee .
(ee. /
rtee/ 1
)ee1 2
;ee2 3
UObjectgg 
.gg 
DestroyImmediategg (
(gg( )
gogg) +
)gg+ ,
;gg, -
returnii 
imgii 
;ii 
}jj 
}kk 	
}ll 
}mm Ú‘
šD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\SurfaceTopology.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{		 
public 

static 
class 
SurfaceTopology '
{ 
public 
static 
Face 
[ 
] 
ToTriangles (
(( )
this) -
ProBuilderMesh. <
mesh= A
,A B
IListC H
<H I
FaceI M
>M N
facesO T
)T U
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new 
System  
.  !!
ArgumentNullException! 6
(6 7
$str7 =
)= >
;> ?
if 
( 
faces 
== 
null 
) 
throw 
new 
System  
.  !!
ArgumentNullException! 6
(6 7
$str7 >
)> ?
;? @
List 
< 
Vertex 
> 
vertices !
=" #
new$ '
List( ,
<, -
Vertex- 3
>3 4
(4 5
mesh5 9
.9 :
GetVertices: E
(E F
)F G
)G H
;H I

Dictionary   
<   
int   
,   
int   
>    
lookup  ! '
=  ( )
mesh  * .
.  . /
sharedVertexLookup  / A
;  A B
List"" 
<"" 
FaceRebuildData""  
>""  !
rebuild""" )
=""* +
new"", /
List""0 4
<""4 5
FaceRebuildData""5 D
>""D E
(""E F
)""F G
;""G H
foreach$$ 
($$ 
Face$$ 
face$$ 
in$$ !
faces$$" '
)$$' (
{%% 
List&& 
<&& 
FaceRebuildData&& $
>&&$ %
res&&& )
=&&* +
BreakFaceIntoTris&&, =
(&&= >
face&&> B
,&&B C
vertices&&D L
,&&L M
lookup&&N T
)&&T U
;&&U V
rebuild'' 
.'' 
AddRange''  
(''  !
res''! $
)''$ %
;''% &
}(( 
FaceRebuildData** 
.** 
Apply** !
(**! "
rebuild**" )
,**) *
mesh**+ /
,**/ 0
vertices**1 9
,**9 :
null**; ?
)**? @
;**@ A
mesh++ 
.++ 
DeleteFaces++ 
(++ 
faces++ "
)++" #
;++# $
mesh,, 
.,, 
ToMesh,, 
(,, 
),, 
;,, 
return.. 
rebuild.. 
... 
Select.. !
(..! "
x.." #
=>..$ &
x..' (
...( )
face..) -
)..- .
.... /
ToArray../ 6
(..6 7
)..7 8
;..8 9
}// 	
static11 
List11 
<11 
FaceRebuildData11 #
>11# $
BreakFaceIntoTris11% 6
(116 7
Face117 ;
face11< @
,11@ A
List11B F
<11F G
Vertex11G M
>11M N
vertices11O W
,11W X

Dictionary11Y c
<11c d
int11d g
,11g h
int11i l
>11l m
lookup11n t
)11t u
{22 	
int33 
[33 
]33 
tris33 
=33 
face33 
.33 
indexesInternal33 -
;33- .
int44 
triCount44 
=44 
tris44 
.44  
Length44  &
;44& '
List55 
<55 
FaceRebuildData55  
>55  !
rebuild55" )
=55* +
new55, /
List550 4
<554 5
FaceRebuildData555 D
>55D E
(55E F
triCount55F N
/55O P
$num55Q R
)55R S
;55S T
for77 
(77 
int77 
i77 
=77 
$num77 
;77 
i77 
<77 
triCount77  (
;77( )
i77* +
+=77, .
$num77/ 0
)770 1
{88 
FaceRebuildData99 
r99  !
=99" #
new99$ '
FaceRebuildData99( 7
(997 8
)998 9
;999 :
r;; 
.;; 
face;; 
=;; 
new;; 
Face;; !
(;;! "
face;;" &
);;& '
;;;' (
r<< 
.<< 
face<< 
.<< 
indexesInternal<< &
=<<' (
new<<) ,
int<<- 0
[<<0 1
]<<1 2
{<<3 4
$num<<5 6
,<<6 7
$num<<8 9
,<<9 :
$num<<; <
}<<< =
;<<= >
r>> 
.>> 
vertices>> 
=>> 
new>>  
List>>! %
<>>% &
Vertex>>& ,
>>>, -
(>>- .
)>>. /
{>>0 1
vertices?? 
[?? 
tris?? !
[??! "
i??" #
]??# $
]??$ %
,??% &
vertices@@ 
[@@ 
tris@@ !
[@@! "
i@@" #
+@@$ %
$num@@& '
]@@' (
]@@( )
,@@) *
verticesAA 
[AA 
trisAA !
[AA! "
iAA" #
+AA$ %
$numAA& '
]AA' (
]AA( )
}BB 
;BB 
rDD 
.DD 
sharedIndexesDD 
=DD  !
newDD" %
ListDD& *
<DD* +
intDD+ .
>DD. /
(DD/ 0
)DD0 1
{DD2 3
lookupEE 
[EE 
trisEE 
[EE  
iEE  !
]EE! "
]EE" #
,EE# $
lookupFF 
[FF 
trisFF 
[FF  
iFF  !
+FF" #
$numFF$ %
]FF% &
]FF& '
,FF' (
lookupGG 
[GG 
trisGG 
[GG  
iGG  !
+GG" #
$numGG$ %
]GG% &
]GG& '
}HH 
;HH 
rebuildJJ 
.JJ 
AddJJ 
(JJ 
rJJ 
)JJ 
;JJ 
}KK 
returnMM 
rebuildMM 
;MM 
}NN 	
publicVV 
staticVV 
WindingOrderVV "
GetWindingOrderVV# 2
(VV2 3
thisVV3 7
ProBuilderMeshVV8 F
meshVVG K
,VVK L
FaceVVM Q
faceVVR V
)VVV W
{WW 	
Vector2XX 
[XX 
]XX 
pXX 
=XX 

ProjectionXX $
.XX$ %
PlanarProjectXX% 2
(XX2 3
meshXX3 7
.XX7 8
positionsInternalXX8 I
,XXI J
faceXXK O
.XXO P#
distinctIndexesInternalXXP g
)XXg h
;XXh i
returnYY 
GetWindingOrderYY "
(YY" #
pYY# $
)YY$ %
;YY% &
}ZZ 	
static\\ 
WindingOrder\\ 
GetWindingOrder\\ +
(\\+ ,
IList\\, 1
<\\1 2
Vertex\\2 8
>\\8 9
vertices\\: B
,\\B C
IList\\D I
<\\I J
int\\J M
>\\M N
indexes\\O V
)\\V W
{]] 	
if^^ 
(^^ 
vertices^^ 
==^^ 
null^^  
)^^  !
throw__ 
new__ !
ArgumentNullException__ /
(__/ 0
$str__0 :
)__: ;
;__; <
ifaa 
(aa 
indexesaa 
==aa 
nullaa 
)aa  
throwbb 
newbb !
ArgumentNullExceptionbb /
(bb/ 0
$strbb0 9
)bb9 :
;bb: ;
Vector2dd 
[dd 
]dd 
pdd 
=dd 

Projectiondd $
.dd$ %
PlanarProjectdd% 2
(dd2 3
verticesdd3 ;
.dd; <
Selectdd< B
(ddB C
xddC D
=>ddE G
xddH I
.ddI J
positionddJ R
)ddR S
.ddS T
ToArrayddT [
(dd[ \
)dd\ ]
,dd] ^
indexesdd_ f
)ddf g
;ddg h
returnee 
GetWindingOrderee "
(ee" #
pee# $
)ee$ %
;ee% &
}ff 	
publicnn 
staticnn 
WindingOrdernn "
GetWindingOrdernn# 2
(nn2 3
IListnn3 8
<nn8 9
Vector2nn9 @
>nn@ A
pointsnnB H
)nnH I
{oo 	
ifpp 
(pp 
pointspp 
==pp 
nullpp 
)pp 
throwqq 
newqq !
ArgumentNullExceptionqq /
(qq/ 0
$strqq0 8
)qq8 9
;qq9 :
floatss 
sumss 
=ss 
$numss 
;ss 
intuu 
lenuu 
=uu 
pointsuu 
.uu 
Countuu "
;uu" #
forxx 
(xx 
intxx 
ixx 
=xx 
$numxx 
;xx 
ixx 
<xx 
lenxx  #
;xx# $
ixx% &
++xx& (
)xx( )
{yy 
Vector2zz 
azz 
=zz 
pointszz "
[zz" #
izz# $
]zz$ %
;zz% &
Vector2{{ 
b{{ 
={{ 
i{{ 
<{{ 
len{{  #
-{{$ %
$num{{& '
?{{( )
points{{* 0
[{{0 1
i{{1 2
+{{3 4
$num{{5 6
]{{6 7
:{{8 9
points{{: @
[{{@ A
$num{{A B
]{{B C
;{{C D
sum}} 
+=}} 
(}} 
(}} 
b}} 
.}} 
x}} 
-}} 
a}}  
.}}  !
x}}! "
)}}" #
*}}$ %
(}}& '
b}}' (
.}}( )
y}}) *
+}}+ ,
a}}- .
.}}. /
y}}/ 0
)}}0 1
)}}1 2
;}}2 3
}~~ 
return
€€ 
sum
€€ 
==
€€ 
$num
€€ 
?
€€ 
WindingOrder
€€ +
.
€€+ ,
Unknown
€€, 3
:
€€4 5
(
€€6 7
sum
€€7 :
>
€€; <
$num
€€= ?
?
€€@ A
WindingOrder
€€B N
.
€€N O
	Clockwise
€€O X
:
€€Y Z
WindingOrder
€€[ g
.
€€g h
CounterClockwise
€€h x
)
€€x y
;
€€y z
}
 	
public
‘‘ 
static
‘‘ 
bool
‘‘ 
FlipEdge
‘‘ #
(
‘‘# $
this
‘‘$ (
ProBuilderMesh
‘‘) 7
mesh
‘‘8 <
,
‘‘< =
Face
‘‘> B
face
‘‘C G
)
‘‘G H
{
’’ 	
if
““ 
(
““ 
mesh
““ 
==
““ 
null
““ 
)
““ 
throw
”” 
new
”” #
ArgumentNullException
”” /
(
””/ 0
$str
””0 6
)
””6 7
;
””7 8
if
–– 
(
–– 
face
–– 
==
–– 
null
–– 
)
–– 
throw
—— 
new
—— #
ArgumentNullException
—— /
(
——/ 0
$str
——0 6
)
——6 7
;
——7 8
int
™™ 
[
™™ 
]
™™ 
indexes
™™ 
=
™™ 
face
™™  
.
™™  !
indexesInternal
™™! 0
;
™™0 1
if
›› 
(
›› 
indexes
›› 
.
›› 
Length
›› 
!=
›› !
$num
››" #
)
››# $
return
œœ 
false
œœ 
;
œœ 
int
 
[
 
]
 
mode
 
=
 
ArrayUtility
 %
.
% &
Fill
& *
<
* +
int
+ .
>
. /
(
/ 0
$num
0 1
,
1 2
indexes
3 :
.
: ;
Length
; A
)
A B
;
B C
for
   
(
   
int
   
x
   
=
   
$num
   
;
   
x
   
<
   
indexes
    '
.
  ' (
Length
  ( .
-
  / 0
$num
  1 2
;
  2 3
x
  4 5
++
  5 7
)
  7 8
{
¡¡ 
for
¢¢ 
(
¢¢ 
int
¢¢ 
y
¢¢ 
=
¢¢ 
x
¢¢ 
+
¢¢  
$num
¢¢! "
;
¢¢" #
y
¢¢$ %
<
¢¢& '
indexes
¢¢( /
.
¢¢/ 0
Length
¢¢0 6
;
¢¢6 7
y
¢¢8 9
++
¢¢9 ;
)
¢¢; <
{
££ 
if
¤¤ 
(
¤¤ 
indexes
¤¤ 
[
¤¤  
x
¤¤  !
]
¤¤! "
==
¤¤# %
indexes
¤¤& -
[
¤¤- .
y
¤¤. /
]
¤¤/ 0
)
¤¤0 1
{
¥¥ 
mode
¦¦ 
[
¦¦ 
x
¦¦ 
]
¦¦ 
++
¦¦ !
;
¦¦! "
mode
§§ 
[
§§ 
y
§§ 
]
§§ 
++
§§ !
;
§§! "
}
¨¨ 
}
©© 
}
ªª 
if
¬¬ 
(
¬¬ 
mode
¬¬ 
[
¬¬ 
$num
¬¬ 
]
¬¬ 
+
¬¬ 
mode
¬¬ 
[
¬¬ 
$num
¬¬  
]
¬¬  !
+
¬¬" #
mode
¬¬$ (
[
¬¬( )
$num
¬¬) *
]
¬¬* +
!=
¬¬, .
$num
¬¬/ 0
||
¬¬1 3
mode
­­ 
[
­­ 
$num
­­ 
]
­­ 
+
­­ 
mode
­­ 
[
­­ 
$num
­­  
]
­­  !
+
­­" #
mode
­­$ (
[
­­( )
$num
­­) *
]
­­* +
!=
­­, .
$num
­­/ 0
)
­­0 1
return
®® 
false
®® 
;
®® 
int
°° 
i0
°° 
=
°° 
indexes
°° 
[
°° 
mode
°° !
[
°°! "
$num
°°" #
]
°°# $
==
°°% '
$num
°°( )
?
°°* +
$num
°°, -
:
°°. /
mode
°°0 4
[
°°4 5
$num
°°5 6
]
°°6 7
==
°°8 :
$num
°°; <
?
°°= >
$num
°°? @
:
°°A B
$num
°°C D
]
°°D E
;
°°E F
int
±± 
i1
±± 
=
±± 
indexes
±± 
[
±± 
mode
±± !
[
±±! "
$num
±±" #
]
±±# $
==
±±% '
$num
±±( )
?
±±* +
$num
±±, -
:
±±. /
mode
±±0 4
[
±±4 5
$num
±±5 6
]
±±6 7
==
±±8 :
$num
±±; <
?
±±= >
$num
±±? @
:
±±A B
$num
±±C D
]
±±D E
;
±±E F
int
³³ 
used
³³ 
=
³³ 
-
³³ 
$num
³³ 
;
³³ 
if
µµ 
(
µµ 
mode
µµ 
[
µµ 
$num
µµ 
]
µµ 
==
µµ 
$num
µµ 
)
µµ 
{
¶¶ 
used
·· 
=
·· 
indexes
·· 
[
·· 
$num
··  
]
··  !
;
··! "
indexes
¸¸ 
[
¸¸ 
$num
¸¸ 
]
¸¸ 
=
¸¸ 
i1
¸¸  
;
¸¸  !
}
¹¹ 
else
ºº 
if
ºº 
(
ºº 
mode
ºº 
[
ºº 
$num
ºº 
]
ºº 
==
ºº 
$num
ºº  !
)
ºº! "
{
»» 
used
¼¼ 
=
¼¼ 
indexes
¼¼ 
[
¼¼ 
$num
¼¼  
]
¼¼  !
;
¼¼! "
indexes
½½ 
[
½½ 
$num
½½ 
]
½½ 
=
½½ 
i1
½½ 
;
½½  
}
¾¾ 
else
¿¿ 
if
¿¿ 
(
¿¿ 
mode
¿¿ 
[
¿¿ 
$num
¿¿ 
]
¿¿ 
==
¿¿ 
$num
¿¿  !
)
¿¿! "
{
ÀÀ 
used
ÁÁ 
=
ÁÁ 
indexes
ÁÁ 
[
ÁÁ 
$num
ÁÁ  
]
ÁÁ  !
;
ÁÁ! "
indexes
ÂÂ 
[
ÂÂ 
$num
ÂÂ 
]
ÂÂ 
=
ÂÂ 
i1
ÂÂ 
;
ÂÂ  
}
ÃÃ 
if
ÅÅ 
(
ÅÅ 
mode
ÅÅ 
[
ÅÅ 
$num
ÅÅ 
]
ÅÅ 
==
ÅÅ 
$num
ÅÅ 
&&
ÅÅ 
indexes
ÅÅ  '
[
ÅÅ' (
$num
ÅÅ( )
]
ÅÅ) *
!=
ÅÅ+ -
used
ÅÅ. 2
)
ÅÅ2 3
indexes
ÆÆ 
[
ÆÆ 
$num
ÆÆ 
]
ÆÆ 
=
ÆÆ 
i0
ÆÆ 
;
ÆÆ  
else
ÇÇ 
if
ÇÇ 
(
ÇÇ 
mode
ÇÇ 
[
ÇÇ 
$num
ÇÇ 
]
ÇÇ 
==
ÇÇ 
$num
ÇÇ  !
&&
ÇÇ" $
indexes
ÇÇ% ,
[
ÇÇ, -
$num
ÇÇ- .
]
ÇÇ. /
!=
ÇÇ0 2
used
ÇÇ3 7
)
ÇÇ7 8
indexes
ÈÈ 
[
ÈÈ 
$num
ÈÈ 
]
ÈÈ 
=
ÈÈ 
i0
ÈÈ 
;
ÈÈ  
else
ÉÉ 
if
ÉÉ 
(
ÉÉ 
mode
ÉÉ 
[
ÉÉ 
$num
ÉÉ 
]
ÉÉ 
==
ÉÉ 
$num
ÉÉ  !
&&
ÉÉ" $
indexes
ÉÉ% ,
[
ÉÉ, -
$num
ÉÉ- .
]
ÉÉ. /
!=
ÉÉ0 2
used
ÉÉ3 7
)
ÉÉ7 8
indexes
ÊÊ 
[
ÊÊ 
$num
ÊÊ 
]
ÊÊ 
=
ÊÊ 
i0
ÊÊ 
;
ÊÊ  
face
ÌÌ 
.
ÌÌ 
InvalidateCache
ÌÌ  
(
ÌÌ  !
)
ÌÌ! "
;
ÌÌ" #
return
ÎÎ 
true
ÎÎ 
;
ÎÎ 
}
ÏÏ 	
public
×× 
static
×× 
ActionResult
×× "
ConformNormals
××# 1
(
××1 2
this
××2 6
ProBuilderMesh
××7 E
mesh
××F J
,
××J K
IEnumerable
××L W
<
××W X
Face
××X \
>
××\ ]
faces
××^ c
)
××c d
{
ØØ 	
List
ÙÙ 
<
ÙÙ 

WingedEdge
ÙÙ 
>
ÙÙ 
wings
ÙÙ "
=
ÙÙ# $

WingedEdge
ÙÙ% /
.
ÙÙ/ 0
GetWingedEdges
ÙÙ0 >
(
ÙÙ> ?
mesh
ÙÙ? C
,
ÙÙC D
faces
ÙÙE J
)
ÙÙJ K
;
ÙÙK L
HashSet
ÚÚ 
<
ÚÚ 
Face
ÚÚ 
>
ÚÚ 
used
ÚÚ 
=
ÚÚ  
new
ÚÚ! $
HashSet
ÚÚ% ,
<
ÚÚ, -
Face
ÚÚ- 1
>
ÚÚ1 2
(
ÚÚ2 3
)
ÚÚ3 4
;
ÚÚ4 5
int
ÛÛ 
count
ÛÛ 
=
ÛÛ 
$num
ÛÛ 
;
ÛÛ 
for
ŞŞ 
(
ŞŞ 
int
ŞŞ 
i
ŞŞ 
=
ŞŞ 
$num
ŞŞ 
;
ŞŞ 
i
ŞŞ 
<
ŞŞ 
wings
ŞŞ  %
.
ŞŞ% &
Count
ŞŞ& +
;
ŞŞ+ ,
i
ŞŞ- .
++
ŞŞ. 0
)
ŞŞ0 1
{
ßß 
if
àà 
(
àà 
used
àà 
.
àà 
Contains
àà !
(
àà! "
wings
àà" '
[
àà' (
i
àà( )
]
àà) *
.
àà* +
face
àà+ /
)
àà/ 0
)
àà0 1
continue
áá 
;
áá 

Dictionary
ãã 
<
ãã 
Face
ãã 
,
ãã  
bool
ãã! %
>
ãã% &
flags
ãã' ,
=
ãã- .
new
ãã/ 2

Dictionary
ãã3 =
<
ãã= >
Face
ãã> B
,
ããB C
bool
ããD H
>
ããH I
(
ããI J
)
ããJ K
;
ããK L
GetWindingFlags
åå 
(
åå  
wings
åå  %
[
åå% &
i
åå& '
]
åå' (
,
åå( )
true
åå* .
,
åå. /
flags
åå0 5
)
åå5 6
;
åå6 7
int
çç 
flip
çç 
=
çç 
$num
çç 
;
çç 
foreach
éé 
(
éé 
var
éé 
kvp
éé  
in
éé! #
flags
éé$ )
)
éé) *
flip
êê 
+=
êê 
kvp
êê 
.
êê  
Value
êê  %
?
êê& '
$num
êê( )
:
êê* +
-
êê, -
$num
êê- .
;
êê. /
bool
ìì 
	direction
ìì 
=
ìì  
flip
ìì! %
>
ìì& '
$num
ìì( )
;
ìì) *
foreach
îî 
(
îî 
var
îî 
kvp
îî  
in
îî! #
flags
îî$ )
)
îî) *
{
ïï 
if
ğğ 
(
ğğ 
	direction
ğğ !
!=
ğğ" $
kvp
ğğ% (
.
ğğ( )
Value
ğğ) .
)
ğğ. /
{
ññ 
count
òò 
++
òò 
;
òò  
kvp
óó 
.
óó 
Key
óó 
.
óó  
Reverse
óó  '
(
óó' (
)
óó( )
;
óó) *
}
ôô 
}
õõ 
used
÷÷ 
.
÷÷ 
	UnionWith
÷÷ 
(
÷÷ 
flags
÷÷ $
.
÷÷$ %
Keys
÷÷% )
)
÷÷) *
;
÷÷* +
}
øø 
if
úú 
(
úú 
count
úú 
>
úú 
$num
úú 
)
úú 
return
ûû 
new
ûû 
ActionResult
ûû '
(
ûû' (
ActionResult
ûû( 4
.
ûû4 5
Status
ûû5 ;
.
ûû; <
Success
ûû< C
,
ûûC D
count
ûûE J
>
ûûK L
$num
ûûM N
?
ûûO P
string
ûûQ W
.
ûûW X
Format
ûûX ^
(
ûû^ _
$str
ûû_ r
,
ûûr s
count
ûût y
)
ûûy z
:
ûû{ |
$strûû} 
)ûû 
;ûû 
else
üü 
return
ıı 
new
ıı 
ActionResult
ıı '
(
ıı' (
ActionResult
ıı( 4
.
ıı4 5
Status
ıı5 ;
.
ıı; <
NoChange
ıı< D
,
ııD E
$str
ııF U
)
ııU V
;
ııV W
}
şş 	
static
€€ 
void
€€ 
GetWindingFlags
€€ #
(
€€# $

WingedEdge
€€$ .
edge
€€/ 3
,
€€3 4
bool
€€5 9
flag
€€: >
,
€€> ?

Dictionary
€€@ J
<
€€J K
Face
€€K O
,
€€O P
bool
€€Q U
>
€€U V
flags
€€W \
)
€€\ ]
{
 	
flags
‚‚ 
.
‚‚ 
Add
‚‚ 
(
‚‚ 
edge
‚‚ 
.
‚‚ 
face
‚‚ 
,
‚‚  
flag
‚‚! %
)
‚‚% &
;
‚‚& '

WingedEdge
„„ 
next
„„ 
=
„„ 
edge
„„ "
;
„„" #
do
†† 
{
‡‡ 

WingedEdge
ˆˆ 
opp
ˆˆ 
=
ˆˆ  
next
ˆˆ! %
.
ˆˆ% &
opposite
ˆˆ& .
;
ˆˆ. /
if
ŠŠ 
(
ŠŠ 
opp
ŠŠ 
!=
ŠŠ 
null
ŠŠ 
&&
ŠŠ  "
!
ŠŠ# $
flags
ŠŠ$ )
.
ŠŠ) *
ContainsKey
ŠŠ* 5
(
ŠŠ5 6
opp
ŠŠ6 9
.
ŠŠ9 :
face
ŠŠ: >
)
ŠŠ> ?
)
ŠŠ? @
{
‹‹ 
Edge
ŒŒ 
cea
ŒŒ 
=
ŒŒ )
GetCommonEdgeInWindingOrder
ŒŒ :
(
ŒŒ: ;
next
ŒŒ; ?
)
ŒŒ? @
;
ŒŒ@ A
Edge
 
ceb
 
=
 )
GetCommonEdgeInWindingOrder
 :
(
: ;
opp
; >
)
> ?
;
? @
GetWindingFlags
 #
(
# $
opp
$ '
,
' (
cea
) ,
.
, -
a
- .
==
/ 1
ceb
2 5
.
5 6
a
6 7
?
8 9
!
: ;
flag
; ?
:
@ A
flag
B F
,
F G
flags
H M
)
M N
;
N O
}
 
next
’’ 
=
’’ 
next
’’ 
.
’’ 
next
’’  
;
’’  !
}
““ 
while
”” 
(
”” 
next
”” 
!=
”” 
edge
”” 
)
””  
;
””  !
}
•• 	
internal
œœ 
static
œœ 
ActionResult
œœ $#
ConformOppositeNormal
œœ% :
(
œœ: ;

WingedEdge
œœ; E
source
œœF L
)
œœL M
{
 	
if
 
(
 
source
 
==
 
null
 
||
 !
source
" (
.
( )
opposite
) 1
==
2 4
null
5 9
)
9 :
return
ŸŸ 
new
ŸŸ 
ActionResult
ŸŸ '
(
ŸŸ' (
ActionResult
ŸŸ( 4
.
ŸŸ4 5
Status
ŸŸ5 ;
.
ŸŸ; <
Failure
ŸŸ< C
,
ŸŸC D
$str
ŸŸE |
)
ŸŸ| }
;
ŸŸ} ~
Edge
¡¡ 
cea
¡¡ 
=
¡¡ )
GetCommonEdgeInWindingOrder
¡¡ 2
(
¡¡2 3
source
¡¡3 9
)
¡¡9 :
;
¡¡: ;
Edge
¢¢ 
ceb
¢¢ 
=
¢¢ )
GetCommonEdgeInWindingOrder
¢¢ 2
(
¢¢2 3
source
¢¢3 9
.
¢¢9 :
opposite
¢¢: B
)
¢¢B C
;
¢¢C D
if
¤¤ 
(
¤¤ 
cea
¤¤ 
.
¤¤ 
a
¤¤ 
==
¤¤ 
ceb
¤¤ 
.
¤¤ 
a
¤¤ 
)
¤¤ 
{
¥¥ 
source
¦¦ 
.
¦¦ 
opposite
¦¦ 
.
¦¦  
face
¦¦  $
.
¦¦$ %
Reverse
¦¦% ,
(
¦¦, -
)
¦¦- .
;
¦¦. /
return
¨¨ 
new
¨¨ 
ActionResult
¨¨ '
(
¨¨' (
ActionResult
¨¨( 4
.
¨¨4 5
Status
¨¨5 ;
.
¨¨; <
Success
¨¨< C
,
¨¨C D
$str
¨¨E j
)
¨¨j k
;
¨¨k l
}
©© 
return
«« 
new
«« 
ActionResult
«« #
(
««# $
ActionResult
««$ 0
.
««0 1
Status
««1 7
.
««7 8
NoChange
««8 @
,
««@ A
$str
««B Z
)
««Z [
;
««[ \
}
¬¬ 	
static
³³ 
Edge
³³ )
GetCommonEdgeInWindingOrder
³³ /
(
³³/ 0

WingedEdge
³³0 :
wing
³³; ?
)
³³? @
{
´´ 	
int
µµ 
[
µµ 
]
µµ 
indexes
µµ 
=
µµ 
wing
µµ  
.
µµ  !
face
µµ! %
.
µµ% &
indexesInternal
µµ& 5
;
µµ5 6
int
¶¶ 
len
¶¶ 
=
¶¶ 
indexes
¶¶ 
.
¶¶ 
Length
¶¶ $
;
¶¶$ %
for
¸¸ 
(
¸¸ 
int
¸¸ 
i
¸¸ 
=
¸¸ 
$num
¸¸ 
;
¸¸ 
i
¸¸ 
<
¸¸ 
len
¸¸  #
;
¸¸# $
i
¸¸% &
+=
¸¸' )
$num
¸¸* +
)
¸¸+ ,
{
¹¹ 
Edge
ºº 
e
ºº 
=
ºº 
wing
ºº 
.
ºº 
edge
ºº "
.
ºº" #
local
ºº# (
;
ºº( )
int
»» 
a
»» 
=
»» 
indexes
»» 
[
»»  
i
»»  !
]
»»! "
,
»»" #
b
»»$ %
=
»»& '
indexes
»»( /
[
»»/ 0
i
»»0 1
+
»»2 3
$num
»»4 5
]
»»5 6
,
»»6 7
c
»»8 9
=
»»: ;
indexes
»»< C
[
»»C D
i
»»D E
+
»»F G
$num
»»H I
]
»»I J
;
»»J K
if
½½ 
(
½½ 
e
½½ 
.
½½ 
a
½½ 
==
½½ 
a
½½ 
&&
½½ 
e
½½  !
.
½½! "
b
½½" #
==
½½$ &
b
½½' (
)
½½( )
return
¾¾ 
wing
¾¾ 
.
¾¾  
edge
¾¾  $
.
¾¾$ %
common
¾¾% +
;
¾¾+ ,
else
¿¿ 
if
¿¿ 
(
¿¿ 
e
¿¿ 
.
¿¿ 
a
¿¿ 
==
¿¿ 
b
¿¿  !
&&
¿¿" $
e
¿¿% &
.
¿¿& '
b
¿¿' (
==
¿¿) +
a
¿¿, -
)
¿¿- .
return
ÀÀ 
new
ÀÀ 
Edge
ÀÀ #
(
ÀÀ# $
wing
ÀÀ$ (
.
ÀÀ( )
edge
ÀÀ) -
.
ÀÀ- .
common
ÀÀ. 4
.
ÀÀ4 5
b
ÀÀ5 6
,
ÀÀ6 7
wing
ÀÀ8 <
.
ÀÀ< =
edge
ÀÀ= A
.
ÀÀA B
common
ÀÀB H
.
ÀÀH I
a
ÀÀI J
)
ÀÀJ K
;
ÀÀK L
else
ÁÁ 
if
ÁÁ 
(
ÁÁ 
e
ÁÁ 
.
ÁÁ 
a
ÁÁ 
==
ÁÁ 
b
ÁÁ  !
&&
ÁÁ" $
e
ÁÁ% &
.
ÁÁ& '
b
ÁÁ' (
==
ÁÁ) +
c
ÁÁ, -
)
ÁÁ- .
return
ÂÂ 
wing
ÂÂ 
.
ÂÂ  
edge
ÂÂ  $
.
ÂÂ$ %
common
ÂÂ% +
;
ÂÂ+ ,
else
ÃÃ 
if
ÃÃ 
(
ÃÃ 
e
ÃÃ 
.
ÃÃ 
a
ÃÃ 
==
ÃÃ 
c
ÃÃ  !
&&
ÃÃ" $
e
ÃÃ% &
.
ÃÃ& '
b
ÃÃ' (
==
ÃÃ) +
b
ÃÃ, -
)
ÃÃ- .
return
ÄÄ 
new
ÄÄ 
Edge
ÄÄ #
(
ÄÄ# $
wing
ÄÄ$ (
.
ÄÄ( )
edge
ÄÄ) -
.
ÄÄ- .
common
ÄÄ. 4
.
ÄÄ4 5
b
ÄÄ5 6
,
ÄÄ6 7
wing
ÄÄ8 <
.
ÄÄ< =
edge
ÄÄ= A
.
ÄÄA B
common
ÄÄB H
.
ÄÄH I
a
ÄÄI J
)
ÄÄJ K
;
ÄÄK L
else
ÅÅ 
if
ÅÅ 
(
ÅÅ 
e
ÅÅ 
.
ÅÅ 
a
ÅÅ 
==
ÅÅ 
c
ÅÅ  !
&&
ÅÅ" $
e
ÅÅ% &
.
ÅÅ& '
b
ÅÅ' (
==
ÅÅ) +
a
ÅÅ, -
)
ÅÅ- .
return
ÆÆ 
wing
ÆÆ 
.
ÆÆ  
edge
ÆÆ  $
.
ÆÆ$ %
common
ÆÆ% +
;
ÆÆ+ ,
else
ÇÇ 
if
ÇÇ 
(
ÇÇ 
e
ÇÇ 
.
ÇÇ 
a
ÇÇ 
==
ÇÇ 
a
ÇÇ  !
&&
ÇÇ" $
e
ÇÇ% &
.
ÇÇ& '
b
ÇÇ' (
==
ÇÇ) +
c
ÇÇ, -
)
ÇÇ- .
return
ÈÈ 
new
ÈÈ 
Edge
ÈÈ #
(
ÈÈ# $
wing
ÈÈ$ (
.
ÈÈ( )
edge
ÈÈ) -
.
ÈÈ- .
common
ÈÈ. 4
.
ÈÈ4 5
b
ÈÈ5 6
,
ÈÈ6 7
wing
ÈÈ8 <
.
ÈÈ< =
edge
ÈÈ= A
.
ÈÈA B
common
ÈÈB H
.
ÈÈH I
a
ÈÈI J
)
ÈÈJ K
;
ÈÈK L
}
ÉÉ 
return
ËË 
Edge
ËË 
.
ËË 
Empty
ËË 
;
ËË 
}
ÌÌ 	
internal
ÔÔ 
static
ÔÔ 
void
ÔÔ 
MatchNormal
ÔÔ (
(
ÔÔ( )
Face
ÔÔ) -
source
ÔÔ. 4
,
ÔÔ4 5
Face
ÔÔ6 :
target
ÔÔ; A
,
ÔÔA B

Dictionary
ÔÔC M
<
ÔÔM N
int
ÔÔN Q
,
ÔÔQ R
int
ÔÔS V
>
ÔÔV W
lookup
ÔÔX ^
)
ÔÔ^ _
{
ÕÕ 	
List
ÖÖ 
<
ÖÖ 

EdgeLookup
ÖÖ 
>
ÖÖ 
sourceEdges
ÖÖ (
=
ÖÖ) *

EdgeLookup
ÖÖ+ 5
.
ÖÖ5 6
GetEdgeLookup
ÖÖ6 C
(
ÖÖC D
source
ÖÖD J
.
ÖÖJ K
edgesInternal
ÖÖK X
,
ÖÖX Y
lookup
ÖÖZ `
)
ÖÖ` a
.
ÖÖa b
ToList
ÖÖb h
(
ÖÖh i
)
ÖÖi j
;
ÖÖj k
List
×× 
<
×× 

EdgeLookup
×× 
>
×× 
targetEdges
×× (
=
××) *

EdgeLookup
××+ 5
.
××5 6
GetEdgeLookup
××6 C
(
××C D
target
××D J
.
××J K
edgesInternal
××K X
,
××X Y
lookup
××Z `
)
××` a
.
××a b
ToList
××b h
(
××h i
)
××i j
;
××j k
bool
ÙÙ 

superBreak
ÙÙ 
=
ÙÙ 
false
ÙÙ #
;
ÙÙ# $
Edge
ÛÛ 
src
ÛÛ 
,
ÛÛ 
tar
ÛÛ 
;
ÛÛ 
for
İİ 
(
İİ 
int
İİ 
i
İİ 
=
İİ 
$num
İİ 
;
İİ 
!
İİ 

superBreak
İİ '
&&
İİ( *
i
İİ+ ,
<
İİ- .
sourceEdges
İİ/ :
.
İİ: ;
Count
İİ; @
;
İİ@ A
i
İİB C
++
İİC E
)
İİE F
{
ŞŞ 
src
ßß 
=
ßß 
sourceEdges
ßß !
[
ßß! "
i
ßß" #
]
ßß# $
.
ßß$ %
common
ßß% +
;
ßß+ ,
for
áá 
(
áá 
int
áá 
n
áá 
=
áá 
$num
áá 
;
áá 
!
áá  !

superBreak
áá! +
&&
áá, .
n
áá/ 0
<
áá1 2
targetEdges
áá3 >
.
áá> ?
Count
áá? D
;
ááD E
n
ááF G
++
ááG I
)
ááI J
{
ââ 
tar
ãã 
=
ãã 
targetEdges
ãã %
[
ãã% &
n
ãã& '
]
ãã' (
.
ãã( )
common
ãã) /
;
ãã/ 0
if
åå 
(
åå 
src
åå 
.
åå 
Equals
åå "
(
åå" #
tar
åå# &
)
åå& '
)
åå' (
{
ææ 
if
çç 
(
çç 
src
çç 
.
çç  
a
çç  !
==
çç" $
tar
çç% (
.
çç( )
a
çç) *
)
çç* +
target
èè "
.
èè" #
Reverse
èè# *
(
èè* +
)
èè+ ,
;
èè, -

superBreak
êê "
=
êê# $
true
êê% )
;
êê) *
}
ëë 
}
ìì 
}
íí 
}
îî 	
}
ïï 
}ğğ áç
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ProBuilderMesh.cs
	namespace		 	
UnityEngine		
 
.		 

ProBuilder		  
{

 
[ 
AddComponentMenu 
( 
$str /
)/ 0
]0 1
[ 
RequireComponent 
( 
typeof 
( 
MeshRenderer )
)) *
)* +
]+ ,
[ %
DisallowMultipleComponent 
, 
ExecuteInEditMode  1
,1 2
ExcludeFromPreset3 D
,D E$
ExcludeFromObjectFactoryF ^
]^ _
public 

sealed 
partial 
class 
ProBuilderMesh  .
:/ 0
MonoBehaviour1 >
{ 
internal 
const 
	HideFlags  !
k_MeshFilterHideFlags! 6
=7 8
	HideFlags9 B
.B C
HideInInspectorC R
|S T
	HideFlagsU ^
.^ _
NotEditable_ j
;j k
const   
int   
k_UVChannelCount   "
=  # $
$num  % &
;  & '
const%% 
int%% 
k_MeshFormatVersion%% %
=%%& '
$num%%( )
;%%) *
const'' 
int'' 6
*k_MeshFormatVersionSubmeshMaterialRefactor'' <
=''= >
$num''? @
;''@ A
public,, 
const,, 
uint,, 
maxVertexCount,, (
=,,) *
ushort,,+ 1
.,,1 2
MaxValue,,2 :
;,,: ;
[.. 	
SerializeField..	 
].. 
int// 
m_MeshFormatVersion// 
;//  
[11 	
SerializeField11	 
]11 
[22 	 
FormerlySerializedAs22	 
(22 
$str22 &
)22& '
]22' (
Face33 
[33 
]33 
m_Faces33 
;33 
[55 	
SerializeField55	 
]55 
[66 	 
FormerlySerializedAs66	 
(66 
$str66 .
)66. /
]66/ 0
[77 	 
FormerlySerializedAs77	 
(77 
$str77 0
)770 1
]771 2
SharedVertex88 
[88 
]88 
m_SharedVertices88 '
;88' (
[:: 	
Flags::	 
]:: 
enum;; 
CacheValidState;; 
:;; 
byte;; #
{<< 	
SharedVertex== 
=== 
$num== 
<<== 
$num==  !
,==! "
SharedTexture>> 
=>> 
$num>> 
<<>>  
$num>>! "
}?? 	
[AA 	
NonSerializedAA	 
]AA 
CacheValidStateBB 
m_CacheValidBB $
;BB$ %
[DD 	
NonSerializedDD	 
]DD 

DictionaryEE 
<EE 
intEE 
,EE 
intEE 
>EE  
m_SharedVertexLookupEE 1
;EE1 2
[GG 	
SerializeFieldGG	 
]GG 
[HH 	 
FormerlySerializedAsHH	 
(HH 
$strHH 0
)HH0 1
]HH1 2
SharedVertexII 
[II 
]II 
m_SharedTexturesII '
;II' (
[KK 	
NonSerializedKK	 
]KK 

DictionaryLL 
<LL 
intLL 
,LL 
intLL 
>LL !
m_SharedTextureLookupLL 2
;LL2 3
[NN 	
SerializeFieldNN	 
]NN 
[OO 	 
FormerlySerializedAsOO	 
(OO 
$strOO )
)OO) *
]OO* +
Vector3PP 
[PP 
]PP 
m_PositionsPP 
;PP 
[RR 	
SerializeFieldRR	 
]RR 
[SS 	 
FormerlySerializedAsSS	 
(SS 
$strSS #
)SS# $
]SS$ %
Vector2TT 
[TT 
]TT 
m_Textures0TT 
;TT 
[VV 	
SerializeFieldVV	 
]VV 
[WW 	 
FormerlySerializedAsWW	 
(WW 
$strWW $
)WW$ %
]WW% &
ListXX 
<XX 
Vector4XX 
>XX 
m_Textures2XX !
;XX! "
[ZZ 	
SerializeFieldZZ	 
]ZZ 
[[[ 	 
FormerlySerializedAs[[	 
([[ 
$str[[ $
)[[$ %
][[% &
List\\ 
<\\ 
Vector4\\ 
>\\ 
m_Textures3\\ !
;\\! "
[^^ 	
SerializeField^^	 
]^^ 
[__ 	 
FormerlySerializedAs__	 
(__ 
$str__ )
)__) *
]__* +
Vector4`` 
[`` 
]`` 

m_Tangents`` 
;`` 
[bb 	
NonSerializedbb	 
]bb 
Vector3cc 
[cc 
]cc 
	m_Normalscc 
;cc 
[ee 	
SerializeFieldee	 
]ee 
[ff 	 
FormerlySerializedAsff	 
(ff 
$strff '
)ff' (
]ff( )
Colorgg 
[gg 
]gg 
m_Colorsgg 
;gg 
publicll 
boolll 
userCollisionsll "
{ll# $
getll% (
;ll( )
setll* -
;ll- .
}ll/ 0
[nn 	 
FormerlySerializedAsnn	 
(nn 
$strnn 0
)nn0 1
]nn1 2
[oo 	
SerializeFieldoo	 
]oo 
UnwrapParameterspp 
m_UnwrapParameterspp +
;pp+ ,
publicuu 
UnwrapParametersuu 
unwrapParametersuu  0
{vv 	
getww 
{ww 
returnww 
m_UnwrapParametersww +
;ww+ ,
}ww- .
setxx 
{xx 
m_UnwrapParametersxx $
=xx% &
valuexx' ,
;xx, -
}xx. /
}yy 	
[{{ 	 
FormerlySerializedAs{{	 
({{ 
$str{{ 7
){{7 8
]{{8 9
[|| 	
SerializeField||	 
]|| 
bool}} (
m_PreserveMeshAssetOnDestroy}} )
;}}) *
[
‚‚ 	
SerializeField
‚‚	 
]
‚‚ 
internal
ƒƒ 
string
ƒƒ 
	assetGuid
ƒƒ !
;
ƒƒ! "
[
…… 	
SerializeField
……	 
]
…… 
Mesh
†† 
m_Mesh
†† 
;
†† 
[
ˆˆ 	
NonSerialized
ˆˆ	 
]
ˆˆ 
MeshRenderer
‰‰ 
m_MeshRenderer
‰‰ #
;
‰‰# $
internal
ŒŒ 
new
ŒŒ 
MeshRenderer
ŒŒ !
renderer
ŒŒ" *
{
 	
get
 
{
 
if
 
(
 
!
 

gameObject
 
.
  
TryGetComponent
  /
<
/ 0
MeshRenderer
0 <
>
< =
(
= >
out
> A
m_MeshRenderer
B P
)
P Q
)
Q R
return
‘‘ 
null
‘‘ 
;
‘‘  
return
’’ 
m_MeshRenderer
’’ %
;
’’% &
}
““ 
}
”” 	
[
—— 	
NonSerialized
——	 
]
—— 

MeshFilter
˜˜ 
m_MeshFilter
˜˜ 
;
˜˜  
internal
›› 
new
›› 

MeshFilter
›› 
filter
››  &
{
œœ 	
get
 
{
 
if
ŸŸ 
(
ŸŸ 
m_MeshFilter
ŸŸ  
==
ŸŸ! #
null
ŸŸ$ (
)
ŸŸ( )
{
   
if
¡¡ 
(
¡¡ 
!
¡¡ 

gameObject
¡¡ #
.
¡¡# $
TryGetComponent
¡¡$ 3
<
¡¡3 4

MeshFilter
¡¡4 >
>
¡¡> ?
(
¡¡? @
out
¡¡@ C
m_MeshFilter
¡¡D P
)
¡¡P Q
)
¡¡Q R
return
¢¢ 
null
¢¢ #
;
¢¢# $
m_MeshFilter
¤¤  
.
¤¤  !
	hideFlags
¤¤! *
=
¤¤+ ,#
k_MeshFilterHideFlags
¤¤- B
;
¤¤B C
}
¦¦ 
return
¨¨ 
m_MeshFilter
¨¨ #
;
¨¨# $
}
©© 
}
ªª 	
public
±± 
bool
±± (
preserveMeshAssetOnDestroy
±± .
{
²² 	
get
³³ 
{
³³ 
return
³³ *
m_PreserveMeshAssetOnDestroy
³³ 5
;
³³5 6
}
³³7 8
set
´´ 
{
´´ *
m_PreserveMeshAssetOnDestroy
´´ .
=
´´/ 0
value
´´1 6
;
´´6 7
}
´´8 9
}
µµ 	
public
¼¼ 
bool
¼¼ 
	HasArrays
¼¼ 
(
¼¼ 

MeshArrays
¼¼ (
channels
¼¼) 1
)
¼¼1 2
{
½½ 	
bool
¾¾ 
missing
¾¾ 
=
¾¾ 
false
¾¾  
;
¾¾  !
int
ÀÀ 
vc
ÀÀ 
=
ÀÀ 
vertexCount
ÀÀ  
;
ÀÀ  !
missing
ÂÂ 
|=
ÂÂ 
(
ÂÂ 
channels
ÂÂ  
&
ÂÂ! "

MeshArrays
ÂÂ# -
.
ÂÂ- .
Position
ÂÂ. 6
)
ÂÂ6 7
==
ÂÂ8 :

MeshArrays
ÂÂ; E
.
ÂÂE F
Position
ÂÂF N
&&
ÂÂO Q
m_Positions
ÂÂR ]
==
ÂÂ^ `
null
ÂÂa e
;
ÂÂe f
missing
ÃÃ 
|=
ÃÃ 
(
ÃÃ 
channels
ÃÃ  
&
ÃÃ! "

MeshArrays
ÃÃ# -
.
ÃÃ- .
Normal
ÃÃ. 4
)
ÃÃ4 5
==
ÃÃ6 8

MeshArrays
ÃÃ9 C
.
ÃÃC D
Normal
ÃÃD J
&&
ÃÃK M
(
ÃÃN O
	m_Normals
ÃÃO X
==
ÃÃY [
null
ÃÃ\ `
||
ÃÃa c
	m_Normals
ÃÃd m
.
ÃÃm n
Length
ÃÃn t
!=
ÃÃu w
vc
ÃÃx z
)
ÃÃz {
;
ÃÃ{ |
missing
ÄÄ 
|=
ÄÄ 
(
ÄÄ 
channels
ÄÄ  
&
ÄÄ! "

MeshArrays
ÄÄ# -
.
ÄÄ- .
Texture0
ÄÄ. 6
)
ÄÄ6 7
==
ÄÄ8 :

MeshArrays
ÄÄ; E
.
ÄÄE F
Texture0
ÄÄF N
&&
ÄÄO Q
(
ÄÄR S
m_Textures0
ÄÄS ^
==
ÄÄ_ a
null
ÄÄb f
||
ÄÄg i
m_Textures0
ÄÄj u
.
ÄÄu v
Length
ÄÄv |
!=
ÄÄ} 
vcÄÄ€ ‚
)ÄÄ‚ ƒ
;ÄÄƒ „
missing
ÅÅ 
|=
ÅÅ 
(
ÅÅ 
channels
ÅÅ  
&
ÅÅ! "

MeshArrays
ÅÅ# -
.
ÅÅ- .
Texture2
ÅÅ. 6
)
ÅÅ6 7
==
ÅÅ8 :

MeshArrays
ÅÅ; E
.
ÅÅE F
Texture2
ÅÅF N
&&
ÅÅO Q
(
ÅÅR S
m_Textures2
ÅÅS ^
==
ÅÅ_ a
null
ÅÅb f
||
ÅÅg i
m_Textures2
ÅÅj u
.
ÅÅu v
Count
ÅÅv {
!=
ÅÅ| ~
vcÅÅ 
)ÅÅ ‚
;ÅÅ‚ ƒ
missing
ÆÆ 
|=
ÆÆ 
(
ÆÆ 
channels
ÆÆ  
&
ÆÆ! "

MeshArrays
ÆÆ# -
.
ÆÆ- .
Texture3
ÆÆ. 6
)
ÆÆ6 7
==
ÆÆ8 :

MeshArrays
ÆÆ; E
.
ÆÆE F
Texture3
ÆÆF N
&&
ÆÆO Q
(
ÆÆR S
m_Textures3
ÆÆS ^
==
ÆÆ_ a
null
ÆÆb f
||
ÆÆg i
m_Textures3
ÆÆj u
.
ÆÆu v
Count
ÆÆv {
!=
ÆÆ| ~
vcÆÆ 
)ÆÆ ‚
;ÆÆ‚ ƒ
missing
ÇÇ 
|=
ÇÇ 
(
ÇÇ 
channels
ÇÇ  
&
ÇÇ! "

MeshArrays
ÇÇ# -
.
ÇÇ- .
Color
ÇÇ. 3
)
ÇÇ3 4
==
ÇÇ5 7

MeshArrays
ÇÇ8 B
.
ÇÇB C
Color
ÇÇC H
&&
ÇÇI K
(
ÇÇL M
m_Colors
ÇÇM U
==
ÇÇV X
null
ÇÇY ]
||
ÇÇ^ `
m_Colors
ÇÇa i
.
ÇÇi j
Length
ÇÇj p
!=
ÇÇq s
vc
ÇÇt v
)
ÇÇv w
;
ÇÇw x
missing
ÈÈ 
|=
ÈÈ 
(
ÈÈ 
channels
ÈÈ  
&
ÈÈ! "

MeshArrays
ÈÈ# -
.
ÈÈ- .
Tangent
ÈÈ. 5
)
ÈÈ5 6
==
ÈÈ7 9

MeshArrays
ÈÈ: D
.
ÈÈD E
Tangent
ÈÈE L
&&
ÈÈM O
(
ÈÈP Q

m_Tangents
ÈÈQ [
==
ÈÈ\ ^
null
ÈÈ_ c
||
ÈÈd f

m_Tangents
ÈÈg q
.
ÈÈq r
Length
ÈÈr x
!=
ÈÈy {
vc
ÈÈ| ~
)
ÈÈ~ 
;ÈÈ €
if
ÌÌ 
(
ÌÌ 
(
ÌÌ 
channels
ÌÌ 
&
ÌÌ 

MeshArrays
ÌÌ &
.
ÌÌ& '
Texture1
ÌÌ' /
)
ÌÌ/ 0
==
ÌÌ1 3

MeshArrays
ÌÌ4 >
.
ÌÌ> ?
Texture1
ÌÌ? G
&&
ÌÌH J
mesh
ÌÌK O
!=
ÌÌP R
null
ÌÌS W
)
ÌÌW X
{
ÍÍ 
missing
ÏÏ 
|=
ÏÏ 
!
ÏÏ 
mesh
ÏÏ  
.
ÏÏ  ! 
HasVertexAttribute
ÏÏ! 3
(
ÏÏ3 4
VertexAttribute
ÏÏ4 C
.
ÏÏC D
	TexCoord1
ÏÏD M
)
ÏÏM N
;
ÏÏN O
}
ÔÔ 
return
ÖÖ 
!
ÖÖ 
missing
ÖÖ 
;
ÖÖ 
}
×× 	
internal
ÙÙ 
Face
ÙÙ 
[
ÙÙ 
]
ÙÙ 
facesInternal
ÙÙ %
{
ÚÚ 	
get
ÛÛ 
{
ÛÛ 
return
ÛÛ 
m_Faces
ÛÛ  
;
ÛÛ  !
}
ÛÛ" #
set
ÜÜ 
{
ÜÜ 
m_Faces
ÜÜ 
=
ÜÜ 
value
ÜÜ !
;
ÜÜ! "
}
ÜÜ# $
}
İİ 	
public
åå 
IList
åå 
<
åå 
Face
åå 
>
åå 
faces
åå  
{
ææ 	
get
çç 
{
çç 
return
çç 
new
çç  
ReadOnlyCollection
çç /
<
çç/ 0
Face
çç0 4
>
çç4 5
(
çç5 6
m_Faces
çç6 =
)
çç= >
;
çç> ?
}
çç@ A
set
èè 
{
éé 
if
êê 
(
êê 
value
êê 
==
êê 
null
êê !
)
êê! "
throw
ëë 
new
ëë #
ArgumentNullException
ëë 3
(
ëë3 4
$str
ëë4 ;
)
ëë; <
;
ëë< =
m_Faces
ìì 
=
ìì 
value
ìì 
.
ìì  
ToArray
ìì  '
(
ìì' (
)
ìì( )
;
ìì) *
}
íí 
}
îî 	
internal
ğğ 
void
ğğ *
InvalidateSharedVertexLookup
ğğ 2
(
ğğ2 3
)
ğğ3 4
{
ññ 	
if
òò 
(
òò "
m_SharedVertexLookup
òò $
==
òò% '
null
òò( ,
)
òò, -"
m_SharedVertexLookup
óó $
=
óó% &
new
óó' *

Dictionary
óó+ 5
<
óó5 6
int
óó6 9
,
óó9 :
int
óó; >
>
óó> ?
(
óó? @
)
óó@ A
;
óóA B"
m_SharedVertexLookup
ôô  
.
ôô  !
Clear
ôô! &
(
ôô& '
)
ôô' (
;
ôô( )
m_CacheValid
õõ 
&=
õõ 
~
õõ 
CacheValidState
õõ ,
.
õõ, -
SharedVertex
õõ- 9
;
õõ9 :
}
öö 	
internal
øø 
void
øø +
InvalidateSharedTextureLookup
øø 3
(
øø3 4
)
øø4 5
{
ùù 	
if
úú 
(
úú #
m_SharedTextureLookup
úú %
==
úú& (
null
úú) -
)
úú- .#
m_SharedTextureLookup
ûû %
=
ûû& '
new
ûû( +

Dictionary
ûû, 6
<
ûû6 7
int
ûû7 :
,
ûû: ;
int
ûû< ?
>
ûû? @
(
ûû@ A
)
ûûA B
;
ûûB C#
m_SharedTextureLookup
üü !
.
üü! "
Clear
üü" '
(
üü' (
)
üü( )
;
üü) *
m_CacheValid
ıı 
&=
ıı 
~
ıı 
CacheValidState
ıı ,
.
ıı, -
SharedTexture
ıı- :
;
ıı: ;
}
şş 	
internal
€€ 
void
€€ 
InvalidateFaces
€€ %
(
€€% &
)
€€& '
{
 	
if
‚‚ 
(
‚‚ 
m_Faces
‚‚ 
==
‚‚ 
null
‚‚ 
)
‚‚  
{
ƒƒ 
m_Faces
„„ 
=
„„ 
new
„„ 
Face
„„ "
[
„„" #
$num
„„# $
]
„„$ %
;
„„% &
return
…… 
;
…… 
}
†† 
foreach
ˆˆ 
(
ˆˆ 
var
ˆˆ 
face
ˆˆ 
in
ˆˆ  
faces
ˆˆ! &
)
ˆˆ& '
face
‰‰ 
.
‰‰ 
InvalidateCache
‰‰ $
(
‰‰$ %
)
‰‰% &
;
‰‰& '
}
ŠŠ 	
internal
ŒŒ 
void
ŒŒ 
InvalidateCaches
ŒŒ &
(
ŒŒ& '
)
ŒŒ' (
{
 	*
InvalidateSharedVertexLookup
 (
(
( )
)
) *
;
* ++
InvalidateSharedTextureLookup
 )
(
) *
)
* +
;
+ ,
InvalidateFaces
 
(
 
)
 
;
 "
m_SelectedCacheDirty
‘‘  
=
‘‘! "
true
‘‘# '
;
‘‘' (
}
’’ 	
internal
”” 
SharedVertex
”” 
[
”” 
]
”” $
sharedVerticesInternal
””  6
{
•• 	
get
–– 
{
–– 
return
–– 
m_SharedVertices
–– )
;
––) *
}
––+ ,
set
˜˜ 
{
™™ 
m_SharedVertices
šš  
=
šš! "
value
šš# (
;
šš( )*
InvalidateSharedVertexLookup
›› ,
(
››, -
)
››- .
;
››. /
}
œœ 
}
 	
public
ªª 
IList
ªª 
<
ªª 
SharedVertex
ªª !
>
ªª! "
sharedVertices
ªª# 1
{
«« 	
get
¬¬ 
{
¬¬ 
return
¬¬ 
new
¬¬  
ReadOnlyCollection
¬¬ /
<
¬¬/ 0
SharedVertex
¬¬0 <
>
¬¬< =
(
¬¬= >
m_SharedVertices
¬¬> N
)
¬¬N O
;
¬¬O P
}
¬¬Q R
set
®® 
{
¯¯ 
if
°° 
(
°° 
value
°° 
==
°° 
null
°° !
)
°°! "
throw
±± 
new
±± #
ArgumentNullException
±± 3
(
±±3 4
$str
±±4 ;
)
±±; <
;
±±< =
int
³³ 
len
³³ 
=
³³ 
value
³³ 
.
³³  
Count
³³  %
;
³³% &
m_SharedVertices
´´  
=
´´! "
new
´´# &
SharedVertex
´´' 3
[
´´3 4
len
´´4 7
]
´´7 8
;
´´8 9
for
µµ 
(
µµ 
var
µµ 
i
µµ 
=
µµ 
$num
µµ 
;
µµ 
i
µµ  !
<
µµ" #
len
µµ$ '
;
µµ' (
i
µµ) *
++
µµ* ,
)
µµ, -
m_SharedVertices
¶¶ $
[
¶¶$ %
i
¶¶% &
]
¶¶& '
=
¶¶( )
new
¶¶* -
SharedVertex
¶¶. :
(
¶¶: ;
value
¶¶; @
[
¶¶@ A
i
¶¶A B
]
¶¶B C
)
¶¶C D
;
¶¶D E*
InvalidateSharedVertexLookup
¸¸ ,
(
¸¸, -
)
¸¸- .
;
¸¸. /
}
¹¹ 
}
ºº 	
internal
¼¼ 

Dictionary
¼¼ 
<
¼¼ 
int
¼¼ 
,
¼¼  
int
¼¼! $
>
¼¼$ % 
sharedVertexLookup
¼¼& 8
{
½½ 	
get
¾¾ 
{
¿¿ 
if
ÀÀ 
(
ÀÀ 
(
ÀÀ 
m_CacheValid
ÀÀ !
&
ÀÀ" #
CacheValidState
ÀÀ$ 3
.
ÀÀ3 4
SharedVertex
ÀÀ4 @
)
ÀÀ@ A
!=
ÀÀB D
CacheValidState
ÀÀE T
.
ÀÀT U
SharedVertex
ÀÀU a
)
ÀÀa b
{
ÁÁ 
if
ÂÂ 
(
ÂÂ "
m_SharedVertexLookup
ÂÂ ,
==
ÂÂ- /
null
ÂÂ0 4
)
ÂÂ4 5"
m_SharedVertexLookup
ÃÃ ,
=
ÃÃ- .
new
ÃÃ/ 2

Dictionary
ÃÃ3 =
<
ÃÃ= >
int
ÃÃ> A
,
ÃÃA B
int
ÃÃC F
>
ÃÃF G
(
ÃÃG H
)
ÃÃH I
;
ÃÃI J
SharedVertex
ÄÄ  
.
ÄÄ  !#
GetSharedVertexLookup
ÄÄ! 6
(
ÄÄ6 7
m_SharedVertices
ÄÄ7 G
,
ÄÄG H"
m_SharedVertexLookup
ÄÄI ]
)
ÄÄ] ^
;
ÄÄ^ _
m_CacheValid
ÅÅ  
|=
ÅÅ! #
CacheValidState
ÅÅ$ 3
.
ÅÅ3 4
SharedVertex
ÅÅ4 @
;
ÅÅ@ A
}
ÆÆ 
return
ÈÈ "
m_SharedVertexLookup
ÈÈ +
;
ÈÈ+ ,
}
ÉÉ 
}
ÊÊ 	
internal
ÓÓ 
void
ÓÓ 
SetSharedVertices
ÓÓ '
(
ÓÓ' (
IEnumerable
ÓÓ( 3
<
ÓÓ3 4
KeyValuePair
ÓÓ4 @
<
ÓÓ@ A
int
ÓÓA D
,
ÓÓD E
int
ÓÓF I
>
ÓÓI J
>
ÓÓJ K
indexes
ÓÓL S
)
ÓÓS T
{
ÔÔ 	
if
ÕÕ 
(
ÕÕ 
indexes
ÕÕ 
==
ÕÕ 
null
ÕÕ 
)
ÕÕ  
throw
ÖÖ 
new
ÖÖ #
ArgumentNullException
ÖÖ /
(
ÖÖ/ 0
$str
ÖÖ0 9
)
ÖÖ9 :
;
ÖÖ: ;
m_SharedVertices
×× 
=
×× 
SharedVertex
×× +
.
××+ ,
ToSharedVertices
××, <
(
××< =
indexes
××= D
)
××D E
;
××E F*
InvalidateSharedVertexLookup
ØØ (
(
ØØ( )
)
ØØ) *
;
ØØ* +
}
ÙÙ 	
internal
ÛÛ 
SharedVertex
ÛÛ 
[
ÛÛ 
]
ÛÛ 
sharedTextures
ÛÛ  .
{
ÜÜ 	
get
İİ 
{
İİ 
return
İİ 
m_SharedTextures
İİ )
;
İİ) *
}
İİ+ ,
set
ŞŞ 
{
ßß 
m_SharedTextures
àà  
=
àà! "
value
àà# (
;
àà( )+
InvalidateSharedTextureLookup
áá -
(
áá- .
)
áá. /
;
áá/ 0
}
ââ 
}
ãã 	
internal
åå 

Dictionary
åå 
<
åå 
int
åå 
,
åå  
int
åå! $
>
åå$ %!
sharedTextureLookup
åå& 9
{
ææ 	
get
çç 
{
èè 
if
éé 
(
éé 
(
éé 
m_CacheValid
éé !
&
éé" #
CacheValidState
éé$ 3
.
éé3 4
SharedTexture
éé4 A
)
ééA B
!=
ééC E
CacheValidState
ééF U
.
ééU V
SharedTexture
ééV c
)
ééc d
{
êê 
m_CacheValid
ëë  
|=
ëë! #
CacheValidState
ëë$ 3
.
ëë3 4
SharedTexture
ëë4 A
;
ëëA B
if
ìì 
(
ìì #
m_SharedTextureLookup
ìì -
==
ìì. 0
null
ìì1 5
)
ìì5 6#
m_SharedTextureLookup
íí -
=
íí. /
new
íí0 3

Dictionary
íí4 >
<
íí> ?
int
íí? B
,
ííB C
int
ííD G
>
ííG H
(
ííH I
)
ííI J
;
ííJ K
SharedVertex
îî  
.
îî  !#
GetSharedVertexLookup
îî! 6
(
îî6 7
m_SharedTextures
îî7 G
,
îîG H#
m_SharedTextureLookup
îîI ^
)
îî^ _
;
îî_ `
}
ïï 
return
ññ #
m_SharedTextureLookup
ññ ,
;
ññ, -
}
òò 
}
óó 	
internal
õõ 
void
õõ 
SetSharedTextures
õõ '
(
õõ' (
IEnumerable
õõ( 3
<
õõ3 4
KeyValuePair
õõ4 @
<
õõ@ A
int
õõA D
,
õõD E
int
õõF I
>
õõI J
>
õõJ K
indexes
õõL S
)
õõS T
{
öö 	
if
÷÷ 
(
÷÷ 
indexes
÷÷ 
==
÷÷ 
null
÷÷ 
)
÷÷  
throw
øø 
new
øø #
ArgumentNullException
øø /
(
øø/ 0
$str
øø0 9
)
øø9 :
;
øø: ;
m_SharedTextures
ùù 
=
ùù 
SharedVertex
ùù +
.
ùù+ ,
ToSharedVertices
ùù, <
(
ùù< =
indexes
ùù= D
)
ùùD E
;
ùùE F+
InvalidateSharedTextureLookup
úú )
(
úú) *
)
úú* +
;
úú+ ,
}
ûû 	
internal
ıı 
Vector3
ıı 
[
ıı 
]
ıı 
positionsInternal
ıı ,
{
şş 	
get
ÿÿ 
{
ÿÿ 
return
ÿÿ 
m_Positions
ÿÿ $
;
ÿÿ$ %
}
ÿÿ& '
set
€€ 
{
€€ 
m_Positions
€€ 
=
€€ 
value
€€  %
;
€€% &
}
€€' (
}
 	
public
†† 
IList
†† 
<
†† 
Vector3
†† 
>
†† 
	positions
†† '
{
‡‡ 	
get
ˆˆ 
{
ˆˆ 
return
ˆˆ 
new
ˆˆ  
ReadOnlyCollection
ˆˆ /
<
ˆˆ/ 0
Vector3
ˆˆ0 7
>
ˆˆ7 8
(
ˆˆ8 9
m_Positions
ˆˆ9 D
)
ˆˆD E
;
ˆˆE F
}
ˆˆG H
set
‰‰ 
{
ŠŠ 
if
‹‹ 
(
‹‹ 
value
‹‹ 
==
‹‹ 
null
‹‹ !
)
‹‹! "
throw
ŒŒ 
new
ŒŒ #
ArgumentNullException
ŒŒ 3
(
ŒŒ3 4
$str
ŒŒ4 ;
)
ŒŒ; <
;
ŒŒ< =
m_Positions
 
=
 
value
 #
.
# $
ToArray
$ +
(
+ ,
)
, -
;
- .
}
 
}
 	
public
–– 
Vertex
–– 
[
–– 
]
–– 
GetVertices
–– #
(
––# $
IList
––$ )
<
––) *
int
––* -
>
––- .
indexes
––/ 6
=
––7 8
null
––9 =
)
––= >
{
—— 	
int
˜˜ 
meshVertexCount
˜˜ 
=
˜˜  !
vertexCount
˜˜" -
;
˜˜- .
int
™™ 
vc
™™ 
=
™™ 
indexes
™™ 
!=
™™ 
null
™™  $
?
™™% &
indexes
™™' .
.
™™. /
Count
™™/ 4
:
™™5 6
vertexCount
™™7 B
;
™™B C
Vertex
›› 
[
›› 
]
›› 
v
›› 
=
›› 
new
›› 
Vertex
›› #
[
››# $
vc
››$ &
]
››& '
;
››' (
Vector3
 
[
 
]
 
	positions
 
=
  !
positionsInternal
" 3
;
3 4
Color
 
[
 
]
 
colors
 
=
 
colorsInternal
 +
;
+ ,
Vector2
ŸŸ 
[
ŸŸ 
]
ŸŸ 
uv0s
ŸŸ 
=
ŸŸ 
texturesInternal
ŸŸ -
;
ŸŸ- .
Vector4
   
[
   
]
   
tangents
   
=
    
GetTangents
  ! ,
(
  , -
)
  - .
;
  . /
Vector3
¡¡ 
[
¡¡ 
]
¡¡ 
normals
¡¡ 
=
¡¡ 

GetNormals
¡¡  *
(
¡¡* +
)
¡¡+ ,
;
¡¡, -
Vector2
¢¢ 
[
¢¢ 
]
¢¢ 
uv2s
¢¢ 
=
¢¢ 
mesh
¢¢ !
!=
¢¢" $
null
¢¢% )
?
¢¢* +
mesh
¢¢, 0
.
¢¢0 1
uv2
¢¢1 4
:
¢¢5 6
null
¢¢7 ;
;
¢¢; <
List
¤¤ 
<
¤¤ 
Vector4
¤¤ 
>
¤¤ 
uv3s
¤¤ 
=
¤¤  
new
¤¤! $
List
¤¤% )
<
¤¤) *
Vector4
¤¤* 1
>
¤¤1 2
(
¤¤2 3
)
¤¤3 4
;
¤¤4 5
List
¥¥ 
<
¥¥ 
Vector4
¥¥ 
>
¥¥ 
uv4s
¥¥ 
=
¥¥  
new
¥¥! $
List
¥¥% )
<
¥¥) *
Vector4
¥¥* 1
>
¥¥1 2
(
¥¥2 3
)
¥¥3 4
;
¥¥4 5
GetUVs
§§ 
(
§§ 
$num
§§ 
,
§§ 
uv3s
§§ 
)
§§ 
;
§§ 
GetUVs
¨¨ 
(
¨¨ 
$num
¨¨ 
,
¨¨ 
uv4s
¨¨ 
)
¨¨ 
;
¨¨ 
bool
ªª 
_hasPositions
ªª 
=
ªª  
	positions
ªª! *
!=
ªª+ -
null
ªª. 2
&&
ªª3 5
	positions
ªª6 ?
.
ªª? @
Count
ªª@ E
(
ªªE F
)
ªªF G
==
ªªH J
meshVertexCount
ªªK Z
;
ªªZ [
bool
«« 

_hasColors
«« 
=
«« 
colors
«« $
!=
««% '
null
««( ,
&&
««- /
colors
««0 6
.
««6 7
Count
««7 <
(
««< =
)
««= >
==
««? A
meshVertexCount
««B Q
;
««Q R
bool
¬¬ 
_hasNormals
¬¬ 
=
¬¬ 
normals
¬¬ &
!=
¬¬' )
null
¬¬* .
&&
¬¬/ 1
normals
¬¬2 9
.
¬¬9 :
Count
¬¬: ?
(
¬¬? @
)
¬¬@ A
==
¬¬B D
meshVertexCount
¬¬E T
;
¬¬T U
bool
­­ 
_hasTangents
­­ 
=
­­ 
tangents
­­  (
!=
­­) +
null
­­, 0
&&
­­1 3
tangents
­­4 <
.
­­< =
Count
­­= B
(
­­B C
)
­­C D
==
­­E G
meshVertexCount
­­H W
;
­­W X
bool
®® 
_hasUv0
®® 
=
®® 
uv0s
®® 
!=
®®  "
null
®®# '
&&
®®( *
uv0s
®®+ /
.
®®/ 0
Count
®®0 5
(
®®5 6
)
®®6 7
==
®®8 :
meshVertexCount
®®; J
;
®®J K
bool
¯¯ 
_hasUv2
¯¯ 
=
¯¯ 
uv2s
¯¯ 
!=
¯¯  "
null
¯¯# '
&&
¯¯( *
uv2s
¯¯+ /
.
¯¯/ 0
Count
¯¯0 5
(
¯¯5 6
)
¯¯6 7
==
¯¯8 :
meshVertexCount
¯¯; J
;
¯¯J K
bool
°° 
_hasUv3
°° 
=
°° 
uv3s
°° 
.
°°  
Count
°°  %
(
°°% &
)
°°& '
==
°°( *
meshVertexCount
°°+ :
;
°°: ;
bool
±± 
_hasUv4
±± 
=
±± 
uv4s
±± 
.
±±  
Count
±±  %
(
±±% &
)
±±& '
==
±±( *
meshVertexCount
±±+ :
;
±±: ;
for
³³ 
(
³³ 
int
³³ 
i
³³ 
=
³³ 
$num
³³ 
;
³³ 
i
³³ 
<
³³ 
vc
³³  "
;
³³" #
i
³³$ %
++
³³% '
)
³³' (
{
´´ 
v
µµ 
[
µµ 
i
µµ 
]
µµ 
=
µµ 
new
µµ 
Vertex
µµ !
(
µµ! "
)
µµ" #
;
µµ# $
int
·· 
ind
·· 
=
·· 
indexes
·· !
==
··" $
null
··% )
?
··* +
i
··, -
:
··. /
indexes
··0 7
[
··7 8
i
··8 9
]
··9 :
;
··: ;
if
¹¹ 
(
¹¹ 
_hasPositions
¹¹ !
)
¹¹! "
v
ºº 
[
ºº 
i
ºº 
]
ºº 
.
ºº 
position
ºº !
=
ºº" #
	positions
ºº$ -
[
ºº- .
ind
ºº. 1
]
ºº1 2
;
ºº2 3
if
¼¼ 
(
¼¼ 

_hasColors
¼¼ 
)
¼¼ 
v
½½ 
[
½½ 
i
½½ 
]
½½ 
.
½½ 
color
½½ 
=
½½  
colors
½½! '
[
½½' (
ind
½½( +
]
½½+ ,
;
½½, -
if
¿¿ 
(
¿¿ 
_hasNormals
¿¿ 
)
¿¿  
v
ÀÀ 
[
ÀÀ 
i
ÀÀ 
]
ÀÀ 
.
ÀÀ 
normal
ÀÀ 
=
ÀÀ  !
normals
ÀÀ" )
[
ÀÀ) *
ind
ÀÀ* -
]
ÀÀ- .
;
ÀÀ. /
if
ÂÂ 
(
ÂÂ 
_hasTangents
ÂÂ  
)
ÂÂ  !
v
ÃÃ 
[
ÃÃ 
i
ÃÃ 
]
ÃÃ 
.
ÃÃ 
tangent
ÃÃ  
=
ÃÃ! "
tangents
ÃÃ# +
[
ÃÃ+ ,
ind
ÃÃ, /
]
ÃÃ/ 0
;
ÃÃ0 1
if
ÅÅ 
(
ÅÅ 
_hasUv0
ÅÅ 
)
ÅÅ 
v
ÆÆ 
[
ÆÆ 
i
ÆÆ 
]
ÆÆ 
.
ÆÆ 
uv0
ÆÆ 
=
ÆÆ 
uv0s
ÆÆ #
[
ÆÆ# $
ind
ÆÆ$ '
]
ÆÆ' (
;
ÆÆ( )
if
ÈÈ 
(
ÈÈ 
_hasUv2
ÈÈ 
)
ÈÈ 
v
ÉÉ 
[
ÉÉ 
i
ÉÉ 
]
ÉÉ 
.
ÉÉ 
uv2
ÉÉ 
=
ÉÉ 
uv2s
ÉÉ #
[
ÉÉ# $
ind
ÉÉ$ '
]
ÉÉ' (
;
ÉÉ( )
if
ËË 
(
ËË 
_hasUv3
ËË 
)
ËË 
v
ÌÌ 
[
ÌÌ 
i
ÌÌ 
]
ÌÌ 
.
ÌÌ 
uv3
ÌÌ 
=
ÌÌ 
uv3s
ÌÌ #
[
ÌÌ# $
ind
ÌÌ$ '
]
ÌÌ' (
;
ÌÌ( )
if
ÎÎ 
(
ÎÎ 
_hasUv4
ÎÎ 
)
ÎÎ 
v
ÏÏ 
[
ÏÏ 
i
ÏÏ 
]
ÏÏ 
.
ÏÏ 
uv4
ÏÏ 
=
ÏÏ 
uv4s
ÏÏ #
[
ÏÏ# $
ind
ÏÏ$ '
]
ÏÏ' (
;
ÏÏ( )
}
ĞĞ 
return
ÒÒ 
v
ÒÒ 
;
ÒÒ 
}
ÓÓ 	
public
ÚÚ 
void
ÚÚ 
SetVertices
ÚÚ 
(
ÚÚ  
IList
ÚÚ  %
<
ÚÚ% &
Vertex
ÚÚ& ,
>
ÚÚ, -
vertices
ÚÚ. 6
,
ÚÚ6 7
bool
ÚÚ8 <
	applyMesh
ÚÚ= F
=
ÚÚG H
false
ÚÚI N
)
ÚÚN O
{
ÛÛ 	
if
ÜÜ 
(
ÜÜ 
vertices
ÜÜ 
==
ÜÜ 
null
ÜÜ  
)
ÜÜ  !
throw
İİ 
new
İİ #
ArgumentNullException
İİ /
(
İİ/ 0
$str
İİ0 :
)
İİ: ;
;
İİ; <
var
ßß 
first
ßß 
=
ßß 
vertices
ßß  
.
ßß  !
FirstOrDefault
ßß! /
(
ßß/ 0
)
ßß0 1
;
ßß1 2
if
áá 
(
áá 
first
áá 
==
áá 
null
áá 
||
áá  
!
áá! "
first
áá" '
.
áá' (
	HasArrays
áá( 1
(
áá1 2

MeshArrays
áá2 <
.
áá< =
Position
áá= E
)
ááE F
)
ááF G
{
ââ 
Clear
ãã 
(
ãã 
)
ãã 
;
ãã 
return
ää 
;
ää 
}
åå 
Vector3
çç 
[
çç 
]
çç 
position
çç 
;
çç 
Color
èè 
[
èè 
]
èè 
color
èè 
;
èè 
Vector3
éé 
[
éé 
]
éé 
normal
éé 
;
éé 
Vector4
êê 
[
êê 
]
êê 
tangent
êê 
;
êê 
Vector2
ëë 
[
ëë 
]
ëë 
uv0
ëë 
;
ëë 
Vector2
ìì 
[
ìì 
]
ìì 
uv2
ìì 
;
ìì 
List
íí 
<
íí 
Vector4
íí 
>
íí 
uv3
íí 
;
íí 
List
îî 
<
îî 
Vector4
îî 
>
îî 
uv4
îî 
;
îî 
Vertex
ğğ 
.
ğğ 
	GetArrays
ğğ 
(
ğğ 
vertices
ğğ %
,
ğğ% &
out
ğğ' *
position
ğğ+ 3
,
ğğ3 4
out
ğğ5 8
color
ğğ9 >
,
ğğ> ?
out
ğğ@ C
uv0
ğğD G
,
ğğG H
out
ğğI L
normal
ğğM S
,
ğğS T
out
ğğU X
tangent
ğğY `
,
ğğ` a
out
ğğb e
uv2
ğğf i
,
ğği j
out
ğğk n
uv3
ğğo r
,
ğğr s
out
ğğt w
uv4
ğğx {
)
ğğ{ |
;
ğğ| }
m_Positions
òò 
=
òò 
position
òò "
;
òò" #
m_Colors
óó 
=
óó 
color
óó 
;
óó 

m_Tangents
ôô 
=
ôô 
tangent
ôô  
;
ôô  !
m_Textures0
õõ 
=
õõ 
uv0
õõ 
;
õõ 
m_Textures2
öö 
=
öö 
uv3
öö 
;
öö 
m_Textures3
÷÷ 
=
÷÷ 
uv4
÷÷ 
;
÷÷ 
if
ùù 
(
ùù 
	applyMesh
ùù 
)
ùù 
{
úú 
Mesh
ûû 
umesh
ûû 
=
ûû 
mesh
ûû !
;
ûû! "
if
ıı 
(
ıı 
first
ıı 
.
ıı 
	HasArrays
ıı #
(
ıı# $

MeshArrays
ıı$ .
.
ıı. /
Position
ıı/ 7
)
ıı7 8
)
ıı8 9
umesh
şş 
.
şş 
vertices
şş "
=
şş# $
position
şş% -
;
şş- .
if
ÿÿ 
(
ÿÿ 
first
ÿÿ 
.
ÿÿ 
	HasArrays
ÿÿ #
(
ÿÿ# $

MeshArrays
ÿÿ$ .
.
ÿÿ. /
Color
ÿÿ/ 4
)
ÿÿ4 5
)
ÿÿ5 6
umesh
€€ 
.
€€ 
colors
€€  
=
€€! "
color
€€# (
;
€€( )
if
 
(
 
first
 
.
 
	HasArrays
 #
(
# $

MeshArrays
$ .
.
. /
Texture0
/ 7
)
7 8
)
8 9
umesh
‚‚ 
.
‚‚ 
uv
‚‚ 
=
‚‚ 
uv0
‚‚ "
;
‚‚" #
if
ƒƒ 
(
ƒƒ 
first
ƒƒ 
.
ƒƒ 
	HasArrays
ƒƒ #
(
ƒƒ# $

MeshArrays
ƒƒ$ .
.
ƒƒ. /
Normal
ƒƒ/ 5
)
ƒƒ5 6
)
ƒƒ6 7
umesh
„„ 
.
„„ 
normals
„„ !
=
„„" #
normal
„„$ *
;
„„* +
if
…… 
(
…… 
first
…… 
.
…… 
	HasArrays
…… #
(
……# $

MeshArrays
……$ .
.
……. /
Tangent
……/ 6
)
……6 7
)
……7 8
umesh
†† 
.
†† 
tangents
†† "
=
††# $
tangent
††% ,
;
††, -
if
‡‡ 
(
‡‡ 
first
‡‡ 
.
‡‡ 
	HasArrays
‡‡ #
(
‡‡# $

MeshArrays
‡‡$ .
.
‡‡. /
Texture1
‡‡/ 7
)
‡‡7 8
)
‡‡8 9
umesh
ˆˆ 
.
ˆˆ 
uv2
ˆˆ 
=
ˆˆ 
uv2
ˆˆ  #
;
ˆˆ# $
if
‰‰ 
(
‰‰ 
first
‰‰ 
.
‰‰ 
	HasArrays
‰‰ #
(
‰‰# $

MeshArrays
‰‰$ .
.
‰‰. /
Texture2
‰‰/ 7
)
‰‰7 8
)
‰‰8 9
umesh
ŠŠ 
.
ŠŠ 
SetUVs
ŠŠ  
(
ŠŠ  !
$num
ŠŠ! "
,
ŠŠ" #
uv3
ŠŠ$ '
)
ŠŠ' (
;
ŠŠ( )
if
‹‹ 
(
‹‹ 
first
‹‹ 
.
‹‹ 
	HasArrays
‹‹ #
(
‹‹# $

MeshArrays
‹‹$ .
.
‹‹. /
Texture3
‹‹/ 7
)
‹‹7 8
)
‹‹8 9
umesh
ŒŒ 
.
ŒŒ 
SetUVs
ŒŒ  
(
ŒŒ  !
$num
ŒŒ! "
,
ŒŒ" #
uv4
ŒŒ$ '
)
ŒŒ' (
;
ŒŒ( )
}
 
}
 	
public
•• 
IList
•• 
<
•• 
Vector3
•• 
>
•• 
normals
•• %
{
–– 	
get
—— 
{
—— 
return
—— 
	m_Normals
—— "
!=
——# %
null
——& *
?
——+ ,
new
——- 0 
ReadOnlyCollection
——1 C
<
——C D
Vector3
——D K
>
——K L
(
——L M
	m_Normals
——M V
)
——V W
:
——X Y
null
——Z ^
;
——^ _
}
——` a
}
˜˜ 	
internal
šš 
Vector3
šš 
[
šš 
]
šš 
normalsInternal
šš *
{
›› 	
get
œœ 
{
œœ 
return
œœ 
	m_Normals
œœ "
;
œœ" #
}
œœ$ %
set
 
{
 
	m_Normals
 
=
 
value
 #
;
# $
}
% &
}
 	
public
¦¦ 
Vector3
¦¦ 
[
¦¦ 
]
¦¦ 

GetNormals
¦¦ #
(
¦¦# $
)
¦¦$ %
{
§§ 	
if
¨¨ 
(
¨¨ 
!
¨¨ 
	HasArrays
¨¨ 
(
¨¨ 

MeshArrays
¨¨ %
.
¨¨% &
Normal
¨¨& ,
)
¨¨, -
)
¨¨- .
Normals
©© 
.
©© 
CalculateNormals
©© (
(
©©( )
this
©©) -
)
©©- .
;
©©. /
return
«« 
normals
«« 
.
«« 
ToArray
«« "
(
««" #
)
««# $
;
««$ %
}
¬¬ 	
internal
®® 
Color
®® 
[
®® 
]
®® 
colorsInternal
®® '
{
¯¯ 	
get
°° 
{
°° 
return
°° 
m_Colors
°° !
;
°°! "
}
°°# $
set
±± 
{
±± 
m_Colors
±± 
=
±± 
value
±± "
;
±±" #
}
±±$ %
}
²² 	
public
·· 
IList
·· 
<
·· 
Color
·· 
>
·· 
colors
·· "
{
¸¸ 	
get
¹¹ 
{
¹¹ 
return
¹¹ 
m_Colors
¹¹ !
!=
¹¹" $
null
¹¹% )
?
¹¹* +
new
¹¹, / 
ReadOnlyCollection
¹¹0 B
<
¹¹B C
Color
¹¹C H
>
¹¹H I
(
¹¹I J
m_Colors
¹¹J R
)
¹¹R S
:
¹¹T U
null
¹¹V Z
;
¹¹Z [
}
¹¹\ ]
set
»» 
{
¼¼ 
if
½½ 
(
½½ 
value
½½ 
==
½½ 
null
½½ !
)
½½! "
m_Colors
¾¾ 
=
¾¾ 
null
¾¾ #
;
¾¾# $
else
¿¿ 
if
¿¿ 
(
¿¿ 
value
¿¿ 
.
¿¿ 
Count
¿¿ $
(
¿¿$ %
)
¿¿% &
!=
¿¿' )
vertexCount
¿¿* 5
)
¿¿5 6
throw
ÀÀ 
new
ÀÀ )
ArgumentOutOfRangeException
ÀÀ 9
(
ÀÀ9 :
$str
ÀÀ: A
,
ÀÀA B
$str
ÀÀC j
)
ÀÀj k
;
ÀÀk l
else
ÁÁ 
m_Colors
ÂÂ 
=
ÂÂ 
value
ÂÂ $
.
ÂÂ$ %
ToArray
ÂÂ% ,
(
ÂÂ, -
)
ÂÂ- .
;
ÂÂ. /
}
ÃÃ 
}
ÄÄ 	
public
ÊÊ 
Color
ÊÊ 
[
ÊÊ 
]
ÊÊ 
	GetColors
ÊÊ  
(
ÊÊ  !
)
ÊÊ! "
{
ËË 	
if
ÌÌ 
(
ÌÌ 
	HasArrays
ÌÌ 
(
ÌÌ 

MeshArrays
ÌÌ $
.
ÌÌ$ %
Color
ÌÌ% *
)
ÌÌ* +
)
ÌÌ+ ,
return
ÍÍ 
colors
ÍÍ 
.
ÍÍ 
ToArray
ÍÍ %
(
ÍÍ% &
)
ÍÍ& '
;
ÍÍ' (
return
ÎÎ 
ArrayUtility
ÎÎ 
.
ÎÎ  
Fill
ÎÎ  $
(
ÎÎ$ %
Color
ÎÎ% *
.
ÎÎ* +
white
ÎÎ+ 0
,
ÎÎ0 1
vertexCount
ÎÎ2 =
)
ÎÎ= >
;
ÎÎ> ?
}
ÏÏ 	
public
ØØ 
IList
ØØ 
<
ØØ 
Vector4
ØØ 
>
ØØ 
tangents
ØØ &
{
ÙÙ 	
get
ÚÚ 
{
ÛÛ 
return
ÜÜ 

m_Tangents
ÜÜ !
==
ÜÜ" $
null
ÜÜ% )
||
ÜÜ* ,

m_Tangents
ÜÜ- 7
.
ÜÜ7 8
Length
ÜÜ8 >
!=
ÜÜ? A
vertexCount
ÜÜB M
?
İİ 
null
İİ 
:
ŞŞ 
new
ŞŞ  
ReadOnlyCollection
ŞŞ ,
<
ŞŞ, -
Vector4
ŞŞ- 4
>
ŞŞ4 5
(
ŞŞ5 6

m_Tangents
ŞŞ6 @
)
ŞŞ@ A
;
ŞŞA B
}
ßß 
set
áá 
{
ââ 
if
ãã 
(
ãã 
value
ãã 
==
ãã 
null
ãã !
)
ãã! "

m_Tangents
ää 
=
ää  
null
ää! %
;
ää% &
else
åå 
if
åå 
(
åå 
value
åå 
.
åå 
Count
åå $
(
åå$ %
)
åå% &
!=
åå' )
vertexCount
åå* 5
)
åå5 6
throw
ææ 
new
ææ )
ArgumentOutOfRangeException
ææ 9
(
ææ9 :
$str
ææ: A
,
ææA B
$str
ææC q
)
ææq r
;
æær s
else
çç 

m_Tangents
èè 
=
èè  
value
èè! &
.
èè& '
ToArray
èè' .
(
èè. /
)
èè/ 0
;
èè0 1
}
éé 
}
êê 	
internal
ìì 
Vector4
ìì 
[
ìì 
]
ìì 
tangentsInternal
ìì +
{
íí 	
get
îî 
{
îî 
return
îî 

m_Tangents
îî #
;
îî# $
}
îî% &
set
ïï 
{
ïï 

m_Tangents
ïï 
=
ïï 
value
ïï $
;
ïï$ %
}
ïï& '
}
ğğ 	
public
öö 
Vector4
öö 
[
öö 
]
öö 
GetTangents
öö $
(
öö$ %
)
öö% &
{
÷÷ 	
if
øø 
(
øø 
!
øø 
	HasArrays
øø 
(
øø 

MeshArrays
øø %
.
øø% &
Tangent
øø& -
)
øø- .
)
øø. /
Normals
ùù 
.
ùù 
CalculateTangents
ùù )
(
ùù) *
this
ùù* .
)
ùù. /
;
ùù/ 0
return
ûû 
tangents
ûû 
.
ûû 
ToArray
ûû #
(
ûû# $
)
ûû$ %
;
ûû% &
}
üü 	
internal
şş 
Vector2
şş 
[
şş 
]
şş 
texturesInternal
şş +
{
ÿÿ 	
get
€€ 
{
€€ 
return
€€ 
m_Textures0
€€ $
;
€€$ %
}
€€& '
set
 
{
 
m_Textures0
 
=
 
value
  %
;
% &
}
' (
}
‚‚ 	
public
ˆˆ 
IList
ˆˆ 
<
ˆˆ 
Vector2
ˆˆ 
>
ˆˆ 
textures
ˆˆ &
{
‰‰ 	
get
ŠŠ 
{
ŠŠ 
return
ŠŠ 
m_Textures0
ŠŠ $
!=
ŠŠ% '
null
ŠŠ( ,
?
ŠŠ- .
new
ŠŠ/ 2 
ReadOnlyCollection
ŠŠ3 E
<
ŠŠE F
Vector2
ŠŠF M
>
ŠŠM N
(
ŠŠN O
m_Textures0
ŠŠO Z
)
ŠŠZ [
:
ŠŠ\ ]
null
ŠŠ^ b
;
ŠŠb c
}
ŠŠd e
set
‹‹ 
{
ŒŒ 
if
 
(
 
value
 
==
 
null
 !
)
! "
m_Textures0
 
=
  !
null
" &
;
& '
else
 
if
 
(
 
value
 
.
 
Count
 $
(
$ %
)
% &
!=
' )
vertexCount
* 5
)
5 6
throw
 
new
 )
ArgumentOutOfRangeException
 9
(
9 :
$str
: A
)
A B
;
B C
else
‘‘ 
m_Textures0
’’ 
=
’’  !
value
’’" '
.
’’' (
ToArray
’’( /
(
’’/ 0
)
’’0 1
;
’’1 2
}
““ 
}
”” 	
public
›› 
void
›› 
GetUVs
›› 
(
›› 
int
›› 
channel
›› &
,
››& '
List
››( ,
<
››, -
Vector4
››- 4
>
››4 5
uvs
››6 9
)
››9 :
{
œœ 	
if
 
(
 
uvs
 
==
 
null
 
)
 
throw
 
new
 #
ArgumentNullException
 /
(
/ 0
$str
0 5
)
5 6
;
6 7
if
   
(
   
channel
   
<
   
$num
   
||
   
channel
   &
>
  ' (
$num
  ) *
)
  * +
throw
¡¡ 
new
¡¡ )
ArgumentOutOfRangeException
¡¡ 5
(
¡¡5 6
$str
¡¡6 ?
)
¡¡? @
;
¡¡@ A
uvs
££ 
.
££ 
Clear
££ 
(
££ 
)
££ 
;
££ 
switch
¥¥ 
(
¥¥ 
channel
¥¥ 
)
¥¥ 
{
¦¦ 
case
§§ 
$num
§§ 
:
§§ 
for
¨¨ 
(
¨¨ 
int
¨¨ 
i
¨¨ 
=
¨¨  
$num
¨¨! "
;
¨¨" #
i
¨¨$ %
<
¨¨& '
vertexCount
¨¨( 3
;
¨¨3 4
i
¨¨5 6
++
¨¨6 8
)
¨¨8 9
uvs
©© 
.
©© 
Add
©© 
(
©©  
(
©©  !
Vector4
©©! (
)
©©( )
m_Textures0
©©) 4
[
©©4 5
i
©©5 6
]
©©6 7
)
©©7 8
;
©©8 9
break
ªª 
;
ªª 
case
¬¬ 
$num
¬¬ 
:
¬¬ 
if
­­ 
(
­­ 
mesh
­­ 
!=
­­ 
null
­­  $
&&
­­% '
mesh
­­( ,
.
­­, -
uv2
­­- 0
!=
­­1 3
null
­­4 8
)
­­8 9
{
®® 
Vector2
¯¯ 
[
¯¯  
]
¯¯  !
uv2
¯¯" %
=
¯¯& '
mesh
¯¯( ,
.
¯¯, -
uv2
¯¯- 0
;
¯¯0 1
for
°° 
(
°° 
int
°°  
i
°°! "
=
°°# $
$num
°°% &
;
°°& '
i
°°( )
<
°°* +
uv2
°°, /
.
°°/ 0
Length
°°0 6
;
°°6 7
i
°°8 9
++
°°9 ;
)
°°; <
uvs
±± 
.
±±  
Add
±±  #
(
±±# $
(
±±$ %
Vector4
±±% ,
)
±±, -
uv2
±±- 0
[
±±0 1
i
±±1 2
]
±±2 3
)
±±3 4
;
±±4 5
}
²² 
break
³³ 
;
³³ 
case
µµ 
$num
µµ 
:
µµ 
if
¶¶ 
(
¶¶ 
m_Textures2
¶¶ #
!=
¶¶$ &
null
¶¶' +
)
¶¶+ ,
uvs
·· 
.
·· 
AddRange
·· $
(
··$ %
m_Textures2
··% 0
)
··0 1
;
··1 2
break
¸¸ 
;
¸¸ 
case
ºº 
$num
ºº 
:
ºº 
if
»» 
(
»» 
m_Textures3
»» #
!=
»»$ &
null
»»' +
)
»»+ ,
uvs
¼¼ 
.
¼¼ 
AddRange
¼¼ $
(
¼¼$ %
m_Textures3
¼¼% 0
)
¼¼0 1
;
¼¼1 2
break
½½ 
;
½½ 
}
¾¾ 
}
¿¿ 	
internal
ÁÁ  
ReadOnlyCollection
ÁÁ #
<
ÁÁ# $
Vector2
ÁÁ$ +
>
ÁÁ+ ,
GetUVs
ÁÁ- 3
(
ÁÁ3 4
int
ÁÁ4 7
channel
ÁÁ8 ?
)
ÁÁ? @
{
ÂÂ 	
if
ÃÃ 
(
ÃÃ 
channel
ÃÃ 
==
ÃÃ 
$num
ÃÃ 
)
ÃÃ 
return
ÄÄ 
new
ÄÄ  
ReadOnlyCollection
ÄÄ -
<
ÄÄ- .
Vector2
ÄÄ. 5
>
ÄÄ5 6
(
ÄÄ6 7
m_Textures0
ÄÄ7 B
)
ÄÄB C
;
ÄÄC D
if
ÆÆ 
(
ÆÆ 
channel
ÆÆ 
==
ÆÆ 
$num
ÆÆ 
)
ÆÆ 
return
ÇÇ 
new
ÇÇ  
ReadOnlyCollection
ÇÇ -
<
ÇÇ- .
Vector2
ÇÇ. 5
>
ÇÇ5 6
(
ÇÇ6 7
mesh
ÇÇ7 ;
.
ÇÇ; <
uv2
ÇÇ< ?
)
ÇÇ? @
;
ÇÇ@ A
if
ÉÉ 
(
ÉÉ 
channel
ÉÉ 
==
ÉÉ 
$num
ÉÉ 
)
ÉÉ 
return
ÊÊ 
m_Textures2
ÊÊ "
==
ÊÊ# %
null
ÊÊ& *
?
ÊÊ+ ,
null
ÊÊ- 1
:
ÊÊ2 3
new
ÊÊ4 7 
ReadOnlyCollection
ÊÊ8 J
<
ÊÊJ K
Vector2
ÊÊK R
>
ÊÊR S
(
ÊÊS T
m_Textures2
ÊÊT _
.
ÊÊ_ `
Cast
ÊÊ` d
<
ÊÊd e
Vector2
ÊÊe l
>
ÊÊl m
(
ÊÊm n
)
ÊÊn o
.
ÊÊo p
ToList
ÊÊp v
(
ÊÊv w
)
ÊÊw x
)
ÊÊx y
;
ÊÊy z
if
ÌÌ 
(
ÌÌ 
channel
ÌÌ 
==
ÌÌ 
$num
ÌÌ 
)
ÌÌ 
return
ÍÍ 
m_Textures3
ÍÍ "
==
ÍÍ# %
null
ÍÍ& *
?
ÍÍ+ ,
null
ÍÍ- 1
:
ÍÍ2 3
new
ÍÍ4 7 
ReadOnlyCollection
ÍÍ8 J
<
ÍÍJ K
Vector2
ÍÍK R
>
ÍÍR S
(
ÍÍS T
m_Textures3
ÍÍT _
.
ÍÍ_ `
Cast
ÍÍ` d
<
ÍÍd e
Vector2
ÍÍe l
>
ÍÍl m
(
ÍÍm n
)
ÍÍn o
.
ÍÍo p
ToList
ÍÍp v
(
ÍÍv w
)
ÍÍw x
)
ÍÍx y
;
ÍÍy z
return
ÏÏ 
null
ÏÏ 
;
ÏÏ 
}
ĞĞ 	
public
ØØ 
void
ØØ 
SetUVs
ØØ 
(
ØØ 
int
ØØ 
channel
ØØ &
,
ØØ& '
List
ØØ( ,
<
ØØ, -
Vector4
ØØ- 4
>
ØØ4 5
uvs
ØØ6 9
)
ØØ9 :
{
ÙÙ 	
switch
ÚÚ 
(
ÚÚ 
channel
ÚÚ 
)
ÚÚ 
{
ÛÛ 
case
ÜÜ 
$num
ÜÜ 
:
ÜÜ 
m_Textures0
İİ 
=
İİ  !
uvs
İİ" %
!=
İİ& (
null
İİ) -
?
İİ. /
uvs
İİ0 3
.
İİ3 4
Select
İİ4 :
(
İİ: ;
x
İİ; <
=>
İİ= ?
(
İİ@ A
Vector2
İİA H
)
İİH I
x
İİI J
)
İİJ K
.
İİK L
ToArray
İİL S
(
İİS T
)
İİT U
:
İİV W
null
İİX \
;
İİ\ ]
break
ŞŞ 
;
ŞŞ 
case
àà 
$num
àà 
:
àà 
mesh
áá 
.
áá 
uv2
áá 
=
áá 
uvs
áá "
!=
áá# %
null
áá& *
?
áá+ ,
uvs
áá- 0
.
áá0 1
Select
áá1 7
(
áá7 8
x
áá8 9
=>
áá: <
(
áá= >
Vector2
áá> E
)
ááE F
x
ááF G
)
ááG H
.
ááH I
ToArray
ááI P
(
ááP Q
)
ááQ R
:
ááS T
null
ááU Y
;
ááY Z
break
ââ 
;
ââ 
case
ää 
$num
ää 
:
ää 
m_Textures2
åå 
=
åå  !
uvs
åå" %
!=
åå& (
null
åå) -
?
åå. /
new
åå0 3
List
åå4 8
<
åå8 9
Vector4
åå9 @
>
åå@ A
(
ååA B
uvs
ååB E
)
ååE F
:
ååG H
null
ååI M
;
ååM N
break
ææ 
;
ææ 
case
èè 
$num
èè 
:
èè 
m_Textures3
éé 
=
éé  !
uvs
éé" %
!=
éé& (
null
éé) -
?
éé. /
new
éé0 3
List
éé4 8
<
éé8 9
Vector4
éé9 @
>
éé@ A
(
ééA B
uvs
ééB E
)
ééE F
:
ééG H
null
ééI M
;
ééM N
break
êê 
;
êê 
}
ëë 
}
ìì 	
public
ññ 
int
ññ 
	faceCount
ññ 
{
òò 	
get
óó 
{
óó 
return
óó 
m_Faces
óó  
==
óó! #
null
óó$ (
?
óó) *
$num
óó+ ,
:
óó- .
m_Faces
óó/ 6
.
óó6 7
Length
óó7 =
;
óó= >
}
óó? @
}
ôô 	
public
ùù 
int
ùù 
vertexCount
ùù 
{
úú 	
get
ûû 
{
ûû 
return
ûû 
m_Positions
ûû $
==
ûû% '
null
ûû( ,
?
ûû- .
$num
ûû/ 0
:
ûû1 2
m_Positions
ûû3 >
.
ûû> ?
Length
ûû? E
;
ûûE F
}
ûûG H
}
üü 	
public
 
int
 
	edgeCount
 
{
‚‚ 	
get
ƒƒ 
{
„„ 
int
…… 
count
…… 
=
…… 
$num
…… 
;
…… 
for
†† 
(
†† 
int
†† 
i
†† 
=
†† 
$num
†† 
,
†† 
c
††  !
=
††" #
	faceCount
††$ -
;
††- .
i
††/ 0
<
††1 2
c
††3 4
;
††4 5
i
††6 7
++
††7 9
)
††9 :
count
‡‡ 
+=
‡‡ 
facesInternal
‡‡ *
[
‡‡* +
i
‡‡+ ,
]
‡‡, -
.
‡‡- .
edgesInternal
‡‡. ;
.
‡‡; <
Length
‡‡< B
;
‡‡B C
return
ˆˆ 
count
ˆˆ 
;
ˆˆ 
}
‰‰ 
}
ŠŠ 	
public
 
int
 

indexCount
 
{
 	
get
‘‘ 
{
‘‘ 
return
‘‘ 
m_Faces
‘‘  
==
‘‘! #
null
‘‘$ (
?
‘‘) *
$num
‘‘+ ,
:
‘‘- .
m_Faces
‘‘/ 6
.
‘‘6 7
Sum
‘‘7 :
(
‘‘: ;
x
‘‘; <
=>
‘‘= ?
x
‘‘@ A
.
‘‘A B
indexesInternal
‘‘B Q
.
‘‘Q R
Length
‘‘R X
)
‘‘X Y
;
‘‘Y Z
}
‘‘[ \
}
’’ 	
public
—— 
int
—— 
triangleCount
——  
{
˜˜ 	
get
™™ 
{
™™ 
return
™™ 
m_Faces
™™  
==
™™! #
null
™™$ (
?
™™) *
$num
™™+ ,
:
™™- .
m_Faces
™™/ 6
.
™™6 7
Sum
™™7 :
(
™™: ;
x
™™; <
=>
™™= ?
x
™™@ A
.
™™A B
indexesInternal
™™B Q
.
™™Q R
Length
™™R X
)
™™X Y
/
™™Z [
$num
™™\ ]
;
™™] ^
}
™™_ `
}
šš 	
public
¤¤ 
static
¤¤ 
event
¤¤ 
Action
¤¤ "
<
¤¤" #
ProBuilderMesh
¤¤# 1
>
¤¤1 2!
meshWillBeDestroyed
¤¤3 F
;
¤¤F G
internal
©© 
static
©© 
event
©© 
Action
©© $
<
©©$ %
ProBuilderMesh
©©% 3
>
©©3 4&
componentWillBeDestroyed
©©5 M
;
©©M N
internal
®® 
static
®® 
event
®® 
Action
®® $
<
®®$ %
ProBuilderMesh
®®% 3
>
®®3 4#
componentHasBeenReset
®®5 J
;
®®J K
public
¶¶ 
static
¶¶ 
event
¶¶ 
Action
¶¶ "
<
¶¶" #
ProBuilderMesh
¶¶# 1
>
¶¶1 2%
elementSelectionChanged
¶¶3 J
;
¶¶J K
internal
¸¸ 
Mesh
¸¸ 
mesh
¸¸ 
{
¹¹ 	
get
ºº 
{
»» 
if
¼¼ 
(
¼¼ 
m_Mesh
¼¼ 
==
¼¼ 
null
¼¼ "
&&
¼¼# %
filter
¼¼& ,
!=
¼¼- /
null
¼¼0 4
)
¼¼4 5
m_Mesh
½½ 
=
½½ 
filter
½½ #
.
½½# $

sharedMesh
½½$ .
;
½½. /
return
¾¾ 
m_Mesh
¾¾ 
;
¾¾ 
}
¿¿ 
set
ÁÁ 
{
ÁÁ 
m_Mesh
ÁÁ 
=
ÁÁ 
value
ÁÁ  
;
ÁÁ  !
}
ÁÁ" #
}
ÂÂ 	
internal
ÄÄ 
int
ÄÄ 
id
ÄÄ 
{
ÅÅ 	
get
ÆÆ 
{
ÆÆ 
return
ÆÆ 

gameObject
ÆÆ #
.
ÆÆ# $
GetInstanceID
ÆÆ$ 1
(
ÆÆ1 2
)
ÆÆ2 3
;
ÆÆ3 4
}
ÆÆ5 6
}
ÇÇ 	
public
ÍÍ 
MeshSyncState
ÍÍ 
meshSyncState
ÍÍ *
{
ÎÎ 	
get
ÏÏ 
{
ĞĞ 
if
ÑÑ 
(
ÑÑ 
mesh
ÑÑ 
==
ÑÑ 
null
ÑÑ  
)
ÑÑ  !
return
ÒÒ 
MeshSyncState
ÒÒ (
.
ÒÒ( )
Null
ÒÒ) -
;
ÒÒ- .
int
ÔÔ 
meshNo
ÔÔ 
;
ÔÔ 
int
ÖÖ 
.
ÖÖ 
TryParse
ÖÖ 
(
ÖÖ 
mesh
ÖÖ !
.
ÖÖ! "
name
ÖÖ" &
.
ÖÖ& '
Replace
ÖÖ' .
(
ÖÖ. /
$str
ÖÖ/ 8
,
ÖÖ8 9
$str
ÖÖ: <
)
ÖÖ< =
,
ÖÖ= >
out
ÖÖ? B
meshNo
ÖÖC I
)
ÖÖI J
;
ÖÖJ K
if
ØØ 
(
ØØ 
meshNo
ØØ 
!=
ØØ 
id
ØØ  
)
ØØ  !
return
ÙÙ 
MeshSyncState
ÙÙ (
.
ÙÙ( ) 
InstanceIDMismatch
ÙÙ) ;
;
ÙÙ; <
return
ÛÛ 
mesh
ÛÛ 
.
ÛÛ 
uv2
ÛÛ 
==
ÛÛ  "
null
ÛÛ# '
?
ÛÛ( )
MeshSyncState
ÛÛ* 7
.
ÛÛ7 8
Lightmap
ÛÛ8 @
:
ÛÛA B
MeshSyncState
ÛÛC P
.
ÛÛP Q
InSync
ÛÛQ W
;
ÛÛW X
}
ÜÜ 
}
İİ 	
}
ŞŞ 
}ßß ä
’D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ColliderBehaviour.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ %
DisallowMultipleComponent 
] 
sealed 

class 
ColliderBehaviour "
:# $
EntityBehaviour% 4
{ 
public 
override 
void 

Initialize '
(' (
)( )
{ 	
var 
	collision 
= 

gameObject &
.& '
GetComponent' 3
<3 4
Collider4 <
>< =
(= >
)> ?
;? @
if 
( 
! 
	collision 
) 
	collision 
= 

gameObject &
.& '
AddComponent' 3
<3 4
MeshCollider4 @
>@ A
(A B
)B C
;C D
	collision 
. 
	isTrigger 
=  !
false" '
;' (
SetMaterial 
( 
BuiltinMaterials (
.( )
colliderMaterial) 9
)9 :
;: ;
var 
r 
= 
GetComponent  
<  !
Renderer! )
>) *
(* +
)+ ,
;, -
if 
( 
r 
!= 
null 
) 
r 
. 
	hideFlags 
= 
	HideFlags '
.' (
DontSaveInBuild( 7
;7 8
} 	
public 
override 
void 
OnEnterPlayMode ,
(, -
)- .
{ 	
var 
r 
= 
GetComponent  
<  !
Renderer! )
>) *
(* +
)+ ,
;, -
if 
( 
r 
!= 
null 
) 
r 
. 
enabled 
= 
false !
;! "
}   	
public"" 
override"" 
void"" 
OnSceneLoaded"" *
(""* +
Scene""+ 0
scene""1 6
,""6 7
LoadSceneMode""8 E
mode""F J
)""J K
{## 	
var$$ 
r$$ 
=$$ 
GetComponent$$  
<$$  !
Renderer$$! )
>$$) *
($$* +
)$$+ ,
;$$, -
if&& 
(&& 
r&& 
!=&& 
null&& 
)&& 
r'' 
.'' 
enabled'' 
='' 
false'' !
;''! "
}(( 	
})) 
}** ¨ö
‹D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Projection.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

static 
class 

Projection "
{ 
public 
static 
Vector2 
[ 
] 
PlanarProject  -
(- .
IList. 3
<3 4
Vector34 ;
>; <
	positions= F
,F G
IListH M
<M N
intN Q
>Q R
indexesS Z
=[ \
null] a
)a b
{ 	
return 
PlanarProject  
(  !
	positions! *
,* +
indexes, 3
,3 4
FindBestPlane5 B
(B C
	positionsC L
,L M
indexesN U
)U V
.V W
normalW ]
)] ^
;^ _
} 	
public"" 
static"" 
Vector2"" 
["" 
]"" 
PlanarProject""  -
(""- .
IList"". 3
<""3 4
Vector3""4 ;
>""; <
	positions""= F
,""F G
IList""H M
<""M N
int""N Q
>""Q R
indexes""S Z
,""Z [
Vector3""\ c
	direction""d m
)""m n
{## 	
List$$ 
<$$ 
Vector2$$ 
>$$ 
results$$ !
=$$" #
new$$$ '
List$$( ,
<$$, -
Vector2$$- 4
>$$4 5
($$5 6
indexes$$6 =
!=$$> @
null$$A E
?$$F G
indexes$$H O
.$$O P
Count$$P U
:$$V W
	positions$$X a
.$$a b
Count$$b g
)$$g h
;$$h i
PlanarProject%% 
(%% 
	positions%% #
,%%# $
indexes%%% ,
,%%, -
	direction%%. 7
,%%7 8
results%%9 @
)%%@ A
;%%A B
return&& 
results&& 
.&& 
ToArray&& "
(&&" #
)&&# $
;&&$ %
}'' 	
internal)) 
static)) 
void)) 
PlanarProject)) *
())* +
IList))+ 0
<))0 1
Vector3))1 8
>))8 9
	positions)): C
,))C D
IList))E J
<))J K
int))K N
>))N O
indexes))P W
,))W X
Vector3))Y `
	direction))a j
,))j k
List))l p
<))p q
Vector2))q x
>))x y
results	))z 
)
)) ‚
{** 	
if++ 
(++ 
	positions++ 
==++ 
null++  
)++  !
throw,, 
new,, !
ArgumentNullException,, /
(,,/ 0
$str,,0 ;
),,; <
;,,< =
if.. 
(.. 
results.. 
==.. 
null.. 
).. 
throw// 
new// !
ArgumentNullException// /
(/// 0
$str//0 9
)//9 :
;//: ;
var11 
nrm11 
=11 
	direction11 
;11  
var22 
axis22 
=22 "
VectorToProjectionAxis22 -
(22- .
nrm22. 1
)221 2
;222 3
var33 
prj33 
=33 
GetTangentToAxis33 &
(33& '
axis33' +
)33+ ,
;33, -
var44 
len44 
=44 
indexes44 
==44  
null44! %
?44& '
	positions44( 1
.441 2
Count442 7
:448 9
indexes44: A
.44A B
Count44B G
;44G H
results55 
.55 
Clear55 
(55 
)55 
;55 
var77 
u77 
=77 
Vector377 
.77 
Cross77 !
(77! "
nrm77" %
,77% &
prj77' *
)77* +
;77+ ,
var88 
v88 
=88 
Vector388 
.88 
Cross88 !
(88! "
u88" #
,88# $
nrm88% (
)88( )
;88) *
u:: 
.:: 
	Normalize:: 
(:: 
):: 
;:: 
v;; 
.;; 
	Normalize;; 
(;; 
);; 
;;; 
if== 
(== 
indexes== 
!=== 
null== 
)==  
{>> 
for?? 
(?? 
int?? 
i?? 
=?? 
$num?? 
,?? 
ic??  "
=??# $
len??% (
;??( )
i??* +
<??, -
ic??. 0
;??0 1
++??2 4
i??4 5
)??5 6
results@@ 
.@@ 
Add@@ 
(@@  
new@@  #
Vector2@@$ +
(@@+ ,
Vector3@@, 3
.@@3 4
Dot@@4 7
(@@7 8
u@@8 9
,@@9 :
	positions@@; D
[@@D E
indexes@@E L
[@@L M
i@@M N
]@@N O
]@@O P
)@@P Q
,@@Q R
Vector3@@S Z
.@@Z [
Dot@@[ ^
(@@^ _
v@@_ `
,@@` a
	positions@@b k
[@@k l
indexes@@l s
[@@s t
i@@t u
]@@u v
]@@v w
)@@w x
)@@x y
)@@y z
;@@z {
}AA 
elseBB 
{CC 
forDD 
(DD 
intDD 
iDD 
=DD 
$numDD 
,DD 
icDD  "
=DD# $
lenDD% (
;DD( )
iDD* +
<DD, -
icDD. 0
;DD0 1
++DD2 4
iDD4 5
)DD5 6
resultsEE 
.EE 
AddEE 
(EE  
newEE  #
Vector2EE$ +
(EE+ ,
Vector3EE, 3
.EE3 4
DotEE4 7
(EE7 8
uEE8 9
,EE9 :
	positionsEE; D
[EED E
iEEE F
]EEF G
)EEG H
,EEH I
Vector3EEJ Q
.EEQ R
DotEER U
(EEU V
vEEV W
,EEW X
	positionsEEY b
[EEb c
iEEc d
]EEd e
)EEe f
)EEf g
)EEg h
;EEh i
}FF 
}GG 	
internalII 
staticII 
voidII 
PlanarProjectII *
(II* +
ProBuilderMeshII+ 9
meshII: >
,II> ?
intII@ C
textureGroupIID P
,IIP Q
AutoUnwrapSettingsIIR d
unwrapSettingsIIe s
)IIs t
{JJ 	
varKK 

worldSpaceKK 
=KK 
unwrapSettingsKK +
.KK+ ,
useWorldSpaceKK, 9
;KK9 :
varLL 
trsLL 
=LL 
(LL 
	TransformLL  
)LL  !
nullLL! %
;LL% &
varMM 
facesMM 
=MM 
meshMM 
.MM 
facesInternalMM *
;MM* +
varPP 
projectionDirectionPP #
=PP$ %
Vector3PP& -
.PP- .
zeroPP. 2
;PP2 3
forRR 
(RR 
intRR 
fRR 
=RR 
$numRR 
,RR 
fcRR 
=RR  
facesRR! &
.RR& '
LengthRR' -
;RR- .
fRR/ 0
<RR1 2
fcRR3 5
;RR5 6
++RR7 9
fRR9 :
)RR: ;
{SS 
ifTT 
(TT 
facesTT 
[TT 
fTT 
]TT 
.TT 
textureGroupTT )
!=TT* ,
textureGroupTT- 9
)TT9 :
continueUU 
;UU 
varWW 
nrmWW 
=WW 
MathWW 
.WW 
NormalWW %
(WW% &
meshWW& *
,WW* +
facesWW, 1
[WW1 2
fWW2 3
]WW3 4
)WW4 5
;WW5 6
projectionDirectionXX #
+=XX$ &
nrmXX' *
;XX* +
}YY 
if[[ 
([[ 

worldSpace[[ 
)[[ 
{\\ 
trs]] 
=]] 
mesh]] 
.]] 
	transform]] $
;]]$ %
projectionDirection^^ #
=^^$ %
trs^^& )
.^^) *
TransformDirection^^* <
(^^< =
projectionDirection^^= P
)^^P Q
;^^Q R
}__ 
varaa 
axisaa 
=aa "
VectorToProjectionAxisaa -
(aa- .
projectionDirectionaa. A
)aaA B
;aaB C
varbb 
prjbb 
=bb 
GetTangentToAxisbb &
(bb& '
axisbb' +
)bb+ ,
;bb, -
vardd 
udd 
=dd 
Vector3dd 
.dd 
Crossdd !
(dd! "
projectionDirectiondd" 5
,dd5 6
prjdd7 :
)dd: ;
;dd; <
varee 
vee 
=ee 
Vector3ee 
.ee 
Crossee !
(ee! "
uee" #
,ee# $
projectionDirectionee% 8
)ee8 9
;ee9 :
ugg 
.gg 
	Normalizegg 
(gg 
)gg 
;gg 
vhh 
.hh 
	Normalizehh 
(hh 
)hh 
;hh 
varjj 
	positionsjj 
=jj 
meshjj  
.jj  !
positionsInternaljj! 2
;jj2 3
varkk 
textureskk 
=kk 
meshkk 
.kk  
texturesInternalkk  0
;kk0 1
formm 
(mm 
intmm 
fmm 
=mm 
$nummm 
,mm 
fcmm 
=mm  
facesmm! &
.mm& '
Lengthmm' -
;mm- .
fmm/ 0
<mm1 2
fcmm3 5
;mm5 6
++mm7 9
fmm9 :
)mm: ;
{nn 
ifoo 
(oo 
facesoo 
[oo 
foo 
]oo 
.oo 
textureGroupoo )
!=oo* ,
textureGroupoo- 9
)oo9 :
continuepp 
;pp 
varrr 
indexesrr 
=rr 
facesrr #
[rr# $
frr$ %
]rr% &
.rr& '#
distinctIndexesInternalrr' >
;rr> ?
fortt 
(tt 
inttt 
itt 
=tt 
$numtt 
,tt 
ictt  "
=tt# $
indexestt% ,
.tt, -
Lengthtt- 3
;tt3 4
itt5 6
<tt7 8
ictt9 ;
;tt; <
++tt= ?
itt? @
)tt@ A
{uu 
varvv 
pvv 
=vv 

worldSpacevv &
?vv' (
trsvv) ,
.vv, -
TransformPointvv- ;
(vv; <
	positionsvv< E
[vvE F
indexesvvF M
[vvM N
ivvN O
]vvO P
]vvP Q
)vvQ R
:vvS T
	positionsvvU ^
[vv^ _
indexesvv_ f
[vvf g
ivvg h
]vvh i
]vvi j
;vvj k
texturesxx 
[xx 
indexesxx $
[xx$ %
ixx% &
]xx& '
]xx' (
.xx( )
xxx) *
=xx+ ,
Vector3xx- 4
.xx4 5
Dotxx5 8
(xx8 9
uxx9 :
,xx: ;
pxx< =
)xx= >
;xx> ?
texturesyy 
[yy 
indexesyy $
[yy$ %
iyy% &
]yy& '
]yy' (
.yy( )
yyy) *
=yy+ ,
Vector3yy- 4
.yy4 5
Dotyy5 8
(yy8 9
vyy9 :
,yy: ;
pyy< =
)yy= >
;yy> ?
}zz 
}{{ 
}|| 	
internal~~ 
static~~ 
void~~ 
PlanarProject~~ *
(~~* +
ProBuilderMesh~~+ 9
mesh~~: >
,~~> ?
Face~~@ D
face~~E I
,~~I J
Vector3~~K R

projection~~S ]
=~~^ _
default~~` g
)~~g h
{ 	
var
€€ 
nrm
€€ 
=
€€ 
Math
€€ 
.
€€ 
Normal
€€ !
(
€€! "
mesh
€€" &
,
€€& '
face
€€( ,
)
€€, -
;
€€- .
var
 
trs
 
=
 
(
 
	Transform
  
)
  !
null
! %
;
% &
var
‚‚ 

worldSpace
‚‚ 
=
‚‚ 
face
‚‚ !
.
‚‚! "
uv
‚‚" $
.
‚‚$ %
useWorldSpace
‚‚% 2
;
‚‚2 3
if
„„ 
(
„„ 

worldSpace
„„ 
)
„„ 
{
…… 
trs
†† 
=
†† 
mesh
†† 
.
†† 
	transform
†† $
;
††$ %
nrm
‡‡ 
=
‡‡ 
trs
‡‡ 
.
‡‡  
TransformDirection
‡‡ ,
(
‡‡, -
nrm
‡‡- 0
)
‡‡0 1
;
‡‡1 2
}
ˆˆ 
Vector3
ŠŠ 
prj
ŠŠ 
=
ŠŠ 

projection
ŠŠ $
;
ŠŠ$ %
if
‹‹ 
(
‹‹ 
prj
‹‹ 
==
‹‹ 
Vector3
‹‹ 
.
‹‹ 
zero
‹‹ #
)
‹‹# $
{
ŒŒ 
var
 
axis
 
=
 $
VectorToProjectionAxis
 1
(
1 2
nrm
2 5
)
5 6
;
6 7
prj
 
=
 
GetTangentToAxis
 &
(
& '
axis
' +
)
+ ,
;
, -
}
 
var
‘‘ 
uAxis
‘‘ 
=
‘‘ 
Vector3
‘‘ 
.
‘‘  
Cross
‘‘  %
(
‘‘% &
nrm
‘‘& )
,
‘‘) *
prj
‘‘+ .
)
‘‘. /
;
‘‘/ 0
var
’’ 
vAxis
’’ 
=
’’ 
Vector3
’’ 
.
’’  
Cross
’’  %
(
’’% &
uAxis
’’& +
,
’’+ ,
nrm
’’- 0
)
’’0 1
;
’’1 2
uAxis
”” 
.
”” 
	Normalize
”” 
(
”” 
)
”” 
;
”” 
vAxis
•• 
.
•• 
	Normalize
•• 
(
•• 
)
•• 
;
•• 
var
—— 
	positions
—— 
=
—— 
mesh
——  
.
——  !
positionsInternal
——! 2
;
——2 3
var
˜˜ 
textures
˜˜ 
=
˜˜ 
mesh
˜˜ 
.
˜˜  
texturesInternal
˜˜  0
;
˜˜0 1
int
šš 
[
šš 
]
šš 
indexes
šš 
=
šš 
face
šš  
.
šš  !%
distinctIndexesInternal
šš! 8
;
šš8 9
for
œœ 
(
œœ 
int
œœ 
i
œœ 
=
œœ 
$num
œœ 
,
œœ 
ic
œœ 
=
œœ  
indexes
œœ! (
.
œœ( )
Length
œœ) /
;
œœ/ 0
i
œœ1 2
<
œœ3 4
ic
œœ5 7
;
œœ7 8
++
œœ9 ;
i
œœ; <
)
œœ< =
{
 
var
 
p
 
=
 

worldSpace
 "
?
# $
trs
% (
.
( )
TransformPoint
) 7
(
7 8
	positions
8 A
[
A B
indexes
B I
[
I J
i
J K
]
K L
]
L M
)
M N
:
O P
	positions
Q Z
[
Z [
indexes
[ b
[
b c
i
c d
]
d e
]
e f
;
f g
textures
   
[
   
indexes
    
[
    !
i
  ! "
]
  " #
]
  # $
.
  $ %
x
  % &
=
  ' (
Vector3
  ) 0
.
  0 1
Dot
  1 4
(
  4 5
uAxis
  5 :
,
  : ;
p
  < =
)
  = >
;
  > ?
textures
¡¡ 
[
¡¡ 
indexes
¡¡  
[
¡¡  !
i
¡¡! "
]
¡¡" #
]
¡¡# $
.
¡¡$ %
y
¡¡% &
=
¡¡' (
Vector3
¡¡) 0
.
¡¡0 1
Dot
¡¡1 4
(
¡¡4 5
vAxis
¡¡5 :
,
¡¡: ;
p
¡¡< =
)
¡¡= >
;
¡¡> ?
}
¢¢ 
}
££ 	
internal
¥¥ 
static
¥¥ 
Vector2
¥¥ 
[
¥¥  
]
¥¥  !
SphericalProject
¥¥" 2
(
¥¥2 3
IList
¥¥3 8
<
¥¥8 9
Vector3
¥¥9 @
>
¥¥@ A
vertices
¥¥B J
,
¥¥J K
IList
¥¥L Q
<
¥¥Q R
int
¥¥R U
>
¥¥U V
indexes
¥¥W ^
=
¥¥_ `
null
¥¥a e
)
¥¥e f
{
¦¦ 	
int
§§ 
len
§§ 
=
§§ 
indexes
§§ 
==
§§  
null
§§! %
?
§§& '
vertices
§§( 0
.
§§0 1
Count
§§1 6
:
§§7 8
indexes
§§9 @
.
§§@ A
Count
§§A F
;
§§F G
Vector2
¨¨ 
[
¨¨ 
]
¨¨ 
uv
¨¨ 
=
¨¨ 
new
¨¨ 
Vector2
¨¨ &
[
¨¨& '
len
¨¨' *
]
¨¨* +
;
¨¨+ ,
Vector3
©© 
cen
©© 
=
©© 
Math
©© 
.
©© 
Average
©© &
(
©©& '
vertices
©©' /
,
©©/ 0
indexes
©©1 8
)
©©8 9
;
©©9 :
for
«« 
(
«« 
int
«« 
i
«« 
=
«« 
$num
«« 
;
«« 
i
«« 
<
«« 
len
««  #
;
««# $
i
««% &
++
««& (
)
««( )
{
¬¬ 
int
­­ 
indx
­­ 
=
­­ 
indexes
­­ "
==
­­# %
null
­­& *
?
­­+ ,
i
­­- .
:
­­/ 0
indexes
­­1 8
[
­­8 9
i
­­9 :
]
­­: ;
;
­­; <
Vector3
®® 
p
®® 
=
®® 
(
®® 
vertices
®® %
[
®®% &
indx
®®& *
]
®®* +
-
®®, -
cen
®®. 1
)
®®1 2
;
®®2 3
p
¯¯ 
.
¯¯ 
	Normalize
¯¯ 
(
¯¯ 
)
¯¯ 
;
¯¯ 
uv
°° 
[
°° 
i
°° 
]
°° 
.
°° 
x
°° 
=
°° 
$num
°° 
+
°° 
(
°°  !
Mathf
°°! &
.
°°& '
Atan2
°°' ,
(
°°, -
p
°°- .
.
°°. /
z
°°/ 0
,
°°0 1
p
°°2 3
.
°°3 4
x
°°4 5
)
°°5 6
/
°°7 8
(
°°9 :
$num
°°: <
*
°°= >
Mathf
°°? D
.
°°D E
PI
°°E G
)
°°G H
)
°°H I
;
°°I J
uv
±± 
[
±± 
i
±± 
]
±± 
.
±± 
y
±± 
=
±± 
$num
±± 
-
±± 
(
±±  !
Mathf
±±! &
.
±±& '
Asin
±±' +
(
±±+ ,
p
±±, -
.
±±- .
y
±±. /
)
±±/ 0
/
±±1 2
Mathf
±±3 8
.
±±8 9
PI
±±9 ;
)
±±; <
;
±±< =
}
²² 
return
´´ 
uv
´´ 
;
´´ 
}
µµ 	
internal
½½ 
static
½½ 
IList
½½ 
<
½½ 
Vector2
½½ %
>
½½% &
Sort
½½' +
(
½½+ ,
IList
½½, 1
<
½½1 2
Vector2
½½2 9
>
½½9 :
verts
½½; @
,
½½@ A

SortMethod
½½B L
method
½½M S
=
½½T U

SortMethod
½½V `
.
½½` a
CounterClockwise
½½a q
)
½½q r
{
¾¾ 	
Vector2
¿¿ 
cen
¿¿ 
=
¿¿ 
Math
¿¿ 
.
¿¿ 
Average
¿¿ &
(
¿¿& '
verts
¿¿' ,
)
¿¿, -
;
¿¿- .
Vector2
ÀÀ 
up
ÀÀ 
=
ÀÀ 
Vector2
ÀÀ  
.
ÀÀ  !
up
ÀÀ! #
;
ÀÀ# $
int
ÁÁ 
count
ÁÁ 
=
ÁÁ 
verts
ÁÁ 
.
ÁÁ 
Count
ÁÁ #
;
ÁÁ# $
List
ÃÃ 
<
ÃÃ 
SimpleTuple
ÃÃ 
<
ÃÃ 
float
ÃÃ "
,
ÃÃ" #
Vector2
ÃÃ$ +
>
ÃÃ+ ,
>
ÃÃ, -
angles
ÃÃ. 4
=
ÃÃ5 6
new
ÃÃ7 :
List
ÃÃ; ?
<
ÃÃ? @
SimpleTuple
ÃÃ@ K
<
ÃÃK L
float
ÃÃL Q
,
ÃÃQ R
Vector2
ÃÃS Z
>
ÃÃZ [
>
ÃÃ[ \
(
ÃÃ\ ]
count
ÃÃ] b
)
ÃÃb c
;
ÃÃc d
for
ÅÅ 
(
ÅÅ 
int
ÅÅ 
i
ÅÅ 
=
ÅÅ 
$num
ÅÅ 
;
ÅÅ 
i
ÅÅ 
<
ÅÅ 
count
ÅÅ  %
;
ÅÅ% &
i
ÅÅ' (
++
ÅÅ( *
)
ÅÅ* +
angles
ÆÆ 
.
ÆÆ 
Add
ÆÆ 
(
ÆÆ 
new
ÆÆ 
SimpleTuple
ÆÆ *
<
ÆÆ* +
float
ÆÆ+ 0
,
ÆÆ0 1
Vector2
ÆÆ2 9
>
ÆÆ9 :
(
ÆÆ: ;
Math
ÆÆ; ?
.
ÆÆ? @
SignedAngle
ÆÆ@ K
(
ÆÆK L
up
ÆÆL N
,
ÆÆN O
verts
ÆÆP U
[
ÆÆU V
i
ÆÆV W
]
ÆÆW X
-
ÆÆY Z
cen
ÆÆ[ ^
)
ÆÆ^ _
,
ÆÆ_ `
verts
ÆÆa f
[
ÆÆf g
i
ÆÆg h
]
ÆÆh i
)
ÆÆi j
)
ÆÆj k
;
ÆÆk l
angles
ÈÈ 
.
ÈÈ 
Sort
ÈÈ 
(
ÈÈ 
(
ÈÈ 
a
ÈÈ 
,
ÈÈ 
b
ÈÈ 
)
ÈÈ 
=>
ÈÈ !
{
ÈÈ" #
return
ÈÈ$ *
a
ÈÈ+ ,
.
ÈÈ, -
item1
ÈÈ- 2
<
ÈÈ3 4
b
ÈÈ5 6
.
ÈÈ6 7
item1
ÈÈ7 <
?
ÈÈ= >
-
ÈÈ? @
$num
ÈÈ@ A
:
ÈÈB C
$num
ÈÈD E
;
ÈÈE F
}
ÈÈG H
)
ÈÈH I
;
ÈÈI J
IList
ÊÊ 
<
ÊÊ 
Vector2
ÊÊ 
>
ÊÊ 
values
ÊÊ !
=
ÊÊ" #
angles
ÊÊ$ *
.
ÊÊ* +
Select
ÊÊ+ 1
(
ÊÊ1 2
x
ÊÊ2 3
=>
ÊÊ4 6
x
ÊÊ7 8
.
ÊÊ8 9
item2
ÊÊ9 >
)
ÊÊ> ?
.
ÊÊ? @
ToList
ÊÊ@ F
(
ÊÊF G
)
ÊÊG H
;
ÊÊH I
if
ÌÌ 
(
ÌÌ 
method
ÌÌ 
==
ÌÌ 

SortMethod
ÌÌ $
.
ÌÌ$ %
	Clockwise
ÌÌ% .
)
ÌÌ. /
values
ÍÍ 
=
ÍÍ 
values
ÍÍ 
.
ÍÍ  
Reverse
ÍÍ  '
(
ÍÍ' (
)
ÍÍ( )
.
ÍÍ) *
ToList
ÍÍ* 0
(
ÍÍ0 1
)
ÍÍ1 2
;
ÍÍ2 3
return
ÏÏ 
values
ÏÏ 
;
ÏÏ 
}
ĞĞ 	
internal
ÒÒ 
static
ÒÒ 
Vector3
ÒÒ 
GetTangentToAxis
ÒÒ  0
(
ÒÒ0 1
ProjectionAxis
ÒÒ1 ?
axis
ÒÒ@ D
)
ÒÒD E
{
ÓÓ 	
switch
ÖÖ 
(
ÖÖ 
axis
ÖÖ 
)
ÖÖ 
{
×× 
case
ØØ 
ProjectionAxis
ØØ #
.
ØØ# $
X
ØØ$ %
:
ØØ% &
case
ÙÙ 
ProjectionAxis
ÙÙ #
.
ÙÙ# $
	XNegative
ÙÙ$ -
:
ÙÙ- .
return
ÚÚ 
Vector3
ÚÚ "
.
ÚÚ" #
up
ÚÚ# %
;
ÚÚ% &
case
ÜÜ 
ProjectionAxis
ÜÜ #
.
ÜÜ# $
Y
ÜÜ$ %
:
ÜÜ% &
case
İİ 
ProjectionAxis
İİ #
.
İİ# $
	YNegative
İİ$ -
:
İİ- .
return
ŞŞ 
Vector3
ŞŞ "
.
ŞŞ" #
forward
ŞŞ# *
;
ŞŞ* +
case
àà 
ProjectionAxis
àà #
.
àà# $
Z
àà$ %
:
àà% &
case
áá 
ProjectionAxis
áá #
.
áá# $
	ZNegative
áá$ -
:
áá- .
return
ââ 
Vector3
ââ "
.
ââ" #
up
ââ# %
;
ââ% &
default
ää 
:
ää 
return
åå 
Vector3
åå "
.
åå" #
up
åå# %
;
åå% &
}
ææ 
}
çç 	
internal
îî 
static
îî 
Vector3
îî $
ProjectionAxisToVector
îî  6
(
îî6 7
ProjectionAxis
îî7 E
axis
îîF J
)
îîJ K
{
ïï 	
switch
ğğ 
(
ğğ 
axis
ğğ 
)
ğğ 
{
ññ 
case
òò 
ProjectionAxis
òò #
.
òò# $
X
òò$ %
:
òò% &
return
óó 
Vector3
óó "
.
óó" #
right
óó# (
;
óó( )
case
õõ 
ProjectionAxis
õõ #
.
õõ# $
Y
õõ$ %
:
õõ% &
return
öö 
Vector3
öö "
.
öö" #
up
öö# %
;
öö% &
case
øø 
ProjectionAxis
øø #
.
øø# $
Z
øø$ %
:
øø% &
return
ùù 
Vector3
ùù "
.
ùù" #
forward
ùù# *
;
ùù* +
case
ûû 
ProjectionAxis
ûû #
.
ûû# $
	XNegative
ûû$ -
:
ûû- .
return
üü 
-
üü 
Vector3
üü #
.
üü# $
right
üü$ )
;
üü) *
case
şş 
ProjectionAxis
şş #
.
şş# $
	YNegative
şş$ -
:
şş- .
return
ÿÿ 
-
ÿÿ 
Vector3
ÿÿ #
.
ÿÿ# $
up
ÿÿ$ &
;
ÿÿ& '
case
 
ProjectionAxis
 #
.
# $
	ZNegative
$ -
:
- .
return
‚‚ 
-
‚‚ 
Vector3
‚‚ #
.
‚‚# $
forward
‚‚$ +
;
‚‚+ ,
default
„„ 
:
„„ 
return
…… 
Vector3
…… "
.
……" #
zero
……# '
;
……' (
}
†† 
}
‡‡ 	
internal
 
static
 
ProjectionAxis
 &$
VectorToProjectionAxis
' =
(
= >
Vector3
> E
	direction
F O
)
O P
{
 	
float
 
x
 
=
 
System
 
.
 
Math
 !
.
! "
Abs
" %
(
% &
	direction
& /
.
/ 0
x
0 1
)
1 2
;
2 3
float
‘‘ 
y
‘‘ 
=
‘‘ 
System
‘‘ 
.
‘‘ 
Math
‘‘ !
.
‘‘! "
Abs
‘‘" %
(
‘‘% &
	direction
‘‘& /
.
‘‘/ 0
y
‘‘0 1
)
‘‘1 2
;
‘‘2 3
float
’’ 
z
’’ 
=
’’ 
System
’’ 
.
’’ 
Math
’’ !
.
’’! "
Abs
’’" %
(
’’% &
	direction
’’& /
.
’’/ 0
z
’’0 1
)
’’1 2
;
’’2 3
if
šš 
(
šš 
!
šš 
Math
šš 
.
šš 
Approx
šš 
(
šš 
x
šš 
,
šš 
y
šš  !
)
šš! "
&&
šš# %
x
šš& '
>
šš( )
y
šš* +
&&
šš, .
!
šš/ 0
Math
šš0 4
.
šš4 5
Approx
šš5 ;
(
šš; <
x
šš< =
,
šš= >
z
šš? @
)
šš@ A
&&
ššB D
x
ššE F
>
ššG H
z
ššI J
)
ššJ K
return
›› 
	direction
››  
.
››  !
x
››! "
>
››# $
$num
››% &
?
››' (
ProjectionAxis
››) 7
.
››7 8
X
››8 9
:
››: ;
ProjectionAxis
››< J
.
››J K
	XNegative
››K T
;
››T U
if
 
(
 
!
 
Math
 
.
 
Approx
 
(
 
y
 
,
 
z
  !
)
! "
&&
# %
y
& '
>
( )
z
* +
)
+ ,
return
 
	direction
  
.
  !
y
! "
>
# $
$num
% &
?
' (
ProjectionAxis
) 7
.
7 8
Y
8 9
:
: ;
ProjectionAxis
< J
.
J K
	YNegative
K T
;
T U
return
   
	direction
   
.
   
z
   
>
    
$num
  ! "
?
  # $
ProjectionAxis
  % 3
.
  3 4
Z
  4 5
:
  6 7
ProjectionAxis
  8 F
.
  F G
	ZNegative
  G P
;
  P Q
}
¡¡ 	
public
ªª 
static
ªª 
Plane
ªª 
FindBestPlane
ªª )
(
ªª) *
IList
ªª* /
<
ªª/ 0
Vector3
ªª0 7
>
ªª7 8
points
ªª9 ?
,
ªª? @
IList
ªªA F
<
ªªF G
int
ªªG J
>
ªªJ K
indexes
ªªL S
=
ªªT U
null
ªªV Z
)
ªªZ [
{
«« 	
float
¬¬ 
xx
¬¬ 
=
¬¬ 
$num
¬¬ 
,
¬¬ 
xy
¬¬ 
=
¬¬  !
$num
¬¬" $
,
¬¬$ %
xz
¬¬& (
=
¬¬) *
$num
¬¬+ -
,
¬¬- .
yy
­­ 
=
­­ 
$num
­­ 
,
­­ 
yz
­­ 
=
­­  !
$num
­­" $
,
­­$ %
zz
­­& (
=
­­) *
$num
­­+ -
;
­­- .
if
¯¯ 
(
¯¯ 
points
¯¯ 
==
¯¯ 
null
¯¯ 
)
¯¯ 
throw
°° 
new
°° 
System
°°  
.
°°  !#
ArgumentNullException
°°! 6
(
°°6 7
$str
°°7 ?
)
°°? @
;
°°@ A
bool
²² 
ind
²² 
=
²² 
indexes
²² 
!=
²² !
null
²²" &
&&
²²' )
indexes
²²* 1
.
²²1 2
Count
²²2 7
>
²²8 9
$num
²²: ;
;
²²; <
int
³³ 
len
³³ 
=
³³ 
ind
³³ 
?
³³ 
indexes
³³ #
.
³³# $
Count
³³$ )
:
³³* +
points
³³, 2
.
³³2 3
Count
³³3 8
;
³³8 9
Vector3
µµ 
c
µµ 
=
µµ 
Vector3
µµ 
.
µµ  
zero
µµ  $
,
µµ$ %
n
µµ& '
=
µµ( )
Vector3
µµ* 1
.
µµ1 2
zero
µµ2 6
;
µµ6 7
for
·· 
(
·· 
int
·· 
i
·· 
=
·· 
$num
·· 
;
·· 
i
·· 
<
·· 
len
··  #
;
··# $
i
··% &
++
··& (
)
··( )
{
¸¸ 
c
¹¹ 
.
¹¹ 
x
¹¹ 
+=
¹¹ 
points
¹¹ 
[
¹¹ 
ind
¹¹ !
?
¹¹" #
indexes
¹¹$ +
[
¹¹+ ,
i
¹¹, -
]
¹¹- .
:
¹¹/ 0
i
¹¹1 2
]
¹¹2 3
.
¹¹3 4
x
¹¹4 5
;
¹¹5 6
c
ºº 
.
ºº 
y
ºº 
+=
ºº 
points
ºº 
[
ºº 
ind
ºº !
?
ºº" #
indexes
ºº$ +
[
ºº+ ,
i
ºº, -
]
ºº- .
:
ºº/ 0
i
ºº1 2
]
ºº2 3
.
ºº3 4
y
ºº4 5
;
ºº5 6
c
»» 
.
»» 
z
»» 
+=
»» 
points
»» 
[
»» 
ind
»» !
?
»»" #
indexes
»»$ +
[
»»+ ,
i
»», -
]
»»- .
:
»»/ 0
i
»»1 2
]
»»2 3
.
»»3 4
z
»»4 5
;
»»5 6
}
¼¼ 
c
¾¾ 
.
¾¾ 
x
¾¾ 
/=
¾¾ 
(
¾¾ 
float
¾¾ 
)
¾¾ 
len
¾¾ 
;
¾¾ 
c
¿¿ 
.
¿¿ 
y
¿¿ 
/=
¿¿ 
(
¿¿ 
float
¿¿ 
)
¿¿ 
len
¿¿ 
;
¿¿ 
c
ÀÀ 
.
ÀÀ 
z
ÀÀ 
/=
ÀÀ 
(
ÀÀ 
float
ÀÀ 
)
ÀÀ 
len
ÀÀ 
;
ÀÀ 
for
ÂÂ 
(
ÂÂ 
int
ÂÂ 
i
ÂÂ 
=
ÂÂ 
$num
ÂÂ 
;
ÂÂ 
i
ÂÂ 
<
ÂÂ 
len
ÂÂ  #
;
ÂÂ# $
i
ÂÂ% &
++
ÂÂ& (
)
ÂÂ( )
{
ÃÃ 
Vector3
ÄÄ 
r
ÄÄ 
=
ÄÄ 
points
ÄÄ "
[
ÄÄ" #
ind
ÄÄ# &
?
ÄÄ' (
indexes
ÄÄ) 0
[
ÄÄ0 1
i
ÄÄ1 2
]
ÄÄ2 3
:
ÄÄ4 5
i
ÄÄ6 7
]
ÄÄ7 8
-
ÄÄ9 :
c
ÄÄ; <
;
ÄÄ< =
xx
ÆÆ 
+=
ÆÆ 
r
ÆÆ 
.
ÆÆ 
x
ÆÆ 
*
ÆÆ 
r
ÆÆ 
.
ÆÆ 
x
ÆÆ 
;
ÆÆ  
xy
ÇÇ 
+=
ÇÇ 
r
ÇÇ 
.
ÇÇ 
x
ÇÇ 
*
ÇÇ 
r
ÇÇ 
.
ÇÇ 
y
ÇÇ 
;
ÇÇ  
xz
ÈÈ 
+=
ÈÈ 
r
ÈÈ 
.
ÈÈ 
x
ÈÈ 
*
ÈÈ 
r
ÈÈ 
.
ÈÈ 
z
ÈÈ 
;
ÈÈ  
yy
ÉÉ 
+=
ÉÉ 
r
ÉÉ 
.
ÉÉ 
y
ÉÉ 
*
ÉÉ 
r
ÉÉ 
.
ÉÉ 
y
ÉÉ 
;
ÉÉ  
yz
ÊÊ 
+=
ÊÊ 
r
ÊÊ 
.
ÊÊ 
y
ÊÊ 
*
ÊÊ 
r
ÊÊ 
.
ÊÊ 
z
ÊÊ 
;
ÊÊ  
zz
ËË 
+=
ËË 
r
ËË 
.
ËË 
z
ËË 
*
ËË 
r
ËË 
.
ËË 
z
ËË 
;
ËË  
}
ÌÌ 
float
ÎÎ 
det_x
ÎÎ 
=
ÎÎ 
yy
ÎÎ 
*
ÎÎ 
zz
ÎÎ !
-
ÎÎ" #
yz
ÎÎ$ &
*
ÎÎ' (
yz
ÎÎ) +
;
ÎÎ+ ,
float
ÏÏ 
det_y
ÏÏ 
=
ÏÏ 
xx
ÏÏ 
*
ÏÏ 
zz
ÏÏ !
-
ÏÏ" #
xz
ÏÏ$ &
*
ÏÏ' (
xz
ÏÏ) +
;
ÏÏ+ ,
float
ĞĞ 
det_z
ĞĞ 
=
ĞĞ 
xx
ĞĞ 
*
ĞĞ 
yy
ĞĞ !
-
ĞĞ" #
xy
ĞĞ$ &
*
ĞĞ' (
xy
ĞĞ) +
;
ĞĞ+ ,
if
ÒÒ 
(
ÒÒ 
det_x
ÒÒ 
>
ÒÒ 
det_y
ÒÒ 
&&
ÒÒ  
det_x
ÒÒ! &
>
ÒÒ' (
det_z
ÒÒ) .
)
ÒÒ. /
{
ÓÓ 
n
ÔÔ 
.
ÔÔ 
x
ÔÔ 
=
ÔÔ 
$num
ÔÔ 
;
ÔÔ 
n
ÕÕ 
.
ÕÕ 
y
ÕÕ 
=
ÕÕ 
(
ÕÕ 
xz
ÕÕ 
*
ÕÕ 
yz
ÕÕ 
-
ÕÕ  
xy
ÕÕ! #
*
ÕÕ$ %
zz
ÕÕ& (
)
ÕÕ( )
/
ÕÕ* +
det_x
ÕÕ, 1
;
ÕÕ1 2
n
ÖÖ 
.
ÖÖ 
z
ÖÖ 
=
ÖÖ 
(
ÖÖ 
xy
ÖÖ 
*
ÖÖ 
yz
ÖÖ 
-
ÖÖ  
xz
ÖÖ! #
*
ÖÖ$ %
yy
ÖÖ& (
)
ÖÖ( )
/
ÖÖ* +
det_x
ÖÖ, 1
;
ÖÖ1 2
}
×× 
else
ØØ 
if
ØØ 
(
ØØ 
det_y
ØØ 
>
ØØ 
det_z
ØØ "
)
ØØ" #
{
ÙÙ 
n
ÚÚ 
.
ÚÚ 
x
ÚÚ 
=
ÚÚ 
(
ÚÚ 
yz
ÚÚ 
*
ÚÚ 
xz
ÚÚ 
-
ÚÚ  
xy
ÚÚ! #
*
ÚÚ$ %
zz
ÚÚ& (
)
ÚÚ( )
/
ÚÚ* +
det_y
ÚÚ, 1
;
ÚÚ1 2
n
ÛÛ 
.
ÛÛ 
y
ÛÛ 
=
ÛÛ 
$num
ÛÛ 
;
ÛÛ 
n
ÜÜ 
.
ÜÜ 
z
ÜÜ 
=
ÜÜ 
(
ÜÜ 
xy
ÜÜ 
*
ÜÜ 
xz
ÜÜ 
-
ÜÜ  
yz
ÜÜ! #
*
ÜÜ$ %
xx
ÜÜ& (
)
ÜÜ( )
/
ÜÜ* +
det_y
ÜÜ, 1
;
ÜÜ1 2
}
İİ 
else
ŞŞ 
{
ßß 
n
àà 
.
àà 
x
àà 
=
àà 
(
àà 
yz
àà 
*
àà 
xy
àà 
-
àà  
xz
àà! #
*
àà$ %
yy
àà& (
)
àà( )
/
àà* +
det_z
àà, 1
;
àà1 2
n
áá 
.
áá 
y
áá 
=
áá 
(
áá 
xz
áá 
*
áá 
xy
áá 
-
áá  
yz
áá! #
*
áá$ %
xx
áá& (
)
áá( )
/
áá* +
det_z
áá, 1
;
áá1 2
n
ââ 
.
ââ 
z
ââ 
=
ââ 
$num
ââ 
;
ââ 
}
ãã 
n
åå 
.
åå 
	Normalize
åå 
(
åå 
)
åå 
;
åå 
return
çç 
new
çç 
Plane
çç 
(
çç 
n
çç 
,
çç 
c
çç  !
)
çç! "
;
çç" #
}
èè 	
internal
îî 
static
îî 
Plane
îî 
FindBestPlane
îî +
(
îî+ ,
ProBuilderMesh
îî, :
mesh
îî; ?
,
îî? @
int
îîA D
textureGroup
îîE Q
)
îîQ R
{
ïï 	
float
ğğ 
xx
ğğ 
=
ğğ 
$num
ğğ 
,
ğğ 
xy
ğğ 
=
ğğ  !
$num
ğğ" $
,
ğğ$ %
xz
ğğ& (
=
ğğ) *
$num
ğğ+ -
,
ğğ- .
yy
ññ 
=
ññ 
$num
ññ 
,
ññ 
yz
ññ 
=
ññ  !
$num
ññ" $
,
ññ$ %
zz
ññ& (
=
ññ) *
$num
ññ+ -
;
ññ- .
if
óó 
(
óó 
mesh
óó 
==
óó 
null
óó 
)
óó 
throw
ôô 
new
ôô 
System
ôô  
.
ôô  !#
ArgumentNullException
ôô! 6
(
ôô6 7
$str
ôô7 =
)
ôô= >
;
ôô> ?
Vector3
öö 
c
öö 
=
öö 
Vector3
öö 
.
öö  
zero
öö  $
;
öö$ %
int
÷÷ 
len
÷÷ 
=
÷÷ 
$num
÷÷ 
;
÷÷ 
Vector3
øø 
[
øø 
]
øø 
	positions
øø 
=
øø  !
mesh
øø" &
.
øø& '
positionsInternal
øø' 8
;
øø8 9
int
ùù 
	faceCount
ùù 
=
ùù 
mesh
ùù  
.
ùù  !
	faceCount
ùù! *
;
ùù* +
Face
úú 
[
úú 
]
úú 
faces
úú 
=
úú 
mesh
úú 
.
úú  
facesInternal
úú  -
;
úú- .
for
üü 
(
üü 
int
üü 
	faceIndex
üü 
=
üü  
$num
üü! "
;
üü" #
	faceIndex
üü$ -
<
üü. /
	faceCount
üü0 9
;
üü9 :
	faceIndex
üü; D
++
üüD F
)
üüF G
{
ıı 
if
şş 
(
şş 
faces
şş 
[
şş 
	faceIndex
şş #
]
şş# $
.
şş$ %
textureGroup
şş% 1
!=
şş2 4
textureGroup
şş5 A
)
şşA B
continue
ÿÿ 
;
ÿÿ 
int
 
[
 
]
 
indexes
 
=
 
faces
  %
[
% &
	faceIndex
& /
]
/ 0
.
0 1
indexesInternal
1 @
;
@ A
for
ƒƒ 
(
ƒƒ 
int
ƒƒ 
index
ƒƒ 
=
ƒƒ  
$num
ƒƒ! "
,
ƒƒ" #

indexCount
ƒƒ$ .
=
ƒƒ/ 0
indexes
ƒƒ1 8
.
ƒƒ8 9
Length
ƒƒ9 ?
;
ƒƒ? @
index
ƒƒA F
<
ƒƒG H

indexCount
ƒƒI S
;
ƒƒS T
index
ƒƒU Z
++
ƒƒZ \
)
ƒƒ\ ]
{
„„ 
c
…… 
.
…… 
x
…… 
+=
…… 
	positions
…… $
[
……$ %
indexes
……% ,
[
……, -
index
……- 2
]
……2 3
]
……3 4
.
……4 5
x
……5 6
;
……6 7
c
†† 
.
†† 
y
†† 
+=
†† 
	positions
†† $
[
††$ %
indexes
††% ,
[
††, -
index
††- 2
]
††2 3
]
††3 4
.
††4 5
y
††5 6
;
††6 7
c
‡‡ 
.
‡‡ 
z
‡‡ 
+=
‡‡ 
	positions
‡‡ $
[
‡‡$ %
indexes
‡‡% ,
[
‡‡, -
index
‡‡- 2
]
‡‡2 3
]
‡‡3 4
.
‡‡4 5
z
‡‡5 6
;
‡‡6 7
len
‰‰ 
++
‰‰ 
;
‰‰ 
}
ŠŠ 
}
‹‹ 
c
 
.
 
x
 
/=
 
len
 
;
 
c
 
.
 
y
 
/=
 
len
 
;
 
c
 
.
 
z
 
/=
 
len
 
;
 
for
‘‘ 
(
‘‘ 
int
‘‘ 
	faceIndex
‘‘ 
=
‘‘  
$num
‘‘! "
;
‘‘" #
	faceIndex
‘‘$ -
<
‘‘. /
	faceCount
‘‘0 9
;
‘‘9 :
	faceIndex
‘‘; D
++
‘‘D F
)
‘‘F G
{
’’ 
if
““ 
(
““ 
faces
““ 
[
““ 
	faceIndex
““ #
]
““# $
.
““$ %
textureGroup
““% 1
!=
““2 4
textureGroup
““5 A
)
““A B
continue
”” 
;
”” 
int
–– 
[
–– 
]
–– 
indexes
–– 
=
–– 
faces
––  %
[
––% &
	faceIndex
––& /
]
––/ 0
.
––0 1
indexesInternal
––1 @
;
––@ A
for
˜˜ 
(
˜˜ 
int
˜˜ 
index
˜˜ 
=
˜˜  
$num
˜˜! "
,
˜˜" #

indexCount
˜˜$ .
=
˜˜/ 0
indexes
˜˜1 8
.
˜˜8 9
Length
˜˜9 ?
;
˜˜? @
index
˜˜A F
<
˜˜G H

indexCount
˜˜I S
;
˜˜S T
index
˜˜U Z
++
˜˜Z \
)
˜˜\ ]
{
™™ 
Vector3
šš 
r
šš 
=
šš 
	positions
šš  )
[
šš) *
indexes
šš* 1
[
šš1 2
index
šš2 7
]
šš7 8
]
šš8 9
-
šš: ;
c
šš< =
;
šš= >
xx
œœ 
+=
œœ 
r
œœ 
.
œœ 
x
œœ 
*
œœ 
r
œœ  !
.
œœ! "
x
œœ" #
;
œœ# $
xy
 
+=
 
r
 
.
 
x
 
*
 
r
  !
.
! "
y
" #
;
# $
xz
 
+=
 
r
 
.
 
x
 
*
 
r
  !
.
! "
z
" #
;
# $
yy
ŸŸ 
+=
ŸŸ 
r
ŸŸ 
.
ŸŸ 
y
ŸŸ 
*
ŸŸ 
r
ŸŸ  !
.
ŸŸ! "
y
ŸŸ" #
;
ŸŸ# $
yz
   
+=
   
r
   
.
   
y
   
*
   
r
    !
.
  ! "
z
  " #
;
  # $
zz
¡¡ 
+=
¡¡ 
r
¡¡ 
.
¡¡ 
z
¡¡ 
*
¡¡ 
r
¡¡  !
.
¡¡! "
z
¡¡" #
;
¡¡# $
}
¢¢ 
}
££ 
float
¥¥ 
det_x
¥¥ 
=
¥¥ 
yy
¥¥ 
*
¥¥ 
zz
¥¥ !
-
¥¥" #
yz
¥¥$ &
*
¥¥' (
yz
¥¥) +
;
¥¥+ ,
float
¦¦ 
det_y
¦¦ 
=
¦¦ 
xx
¦¦ 
*
¦¦ 
zz
¦¦ !
-
¦¦" #
xz
¦¦$ &
*
¦¦' (
xz
¦¦) +
;
¦¦+ ,
float
§§ 
det_z
§§ 
=
§§ 
xx
§§ 
*
§§ 
yy
§§ !
-
§§" #
xy
§§$ &
*
§§' (
xy
§§) +
;
§§+ ,
Vector3
¨¨ 
n
¨¨ 
=
¨¨ 
Vector3
¨¨ 
.
¨¨  
zero
¨¨  $
;
¨¨$ %
if
ªª 
(
ªª 
det_x
ªª 
>
ªª 
det_y
ªª 
&&
ªª  
det_x
ªª! &
>
ªª' (
det_z
ªª) .
)
ªª. /
{
«« 
n
¬¬ 
.
¬¬ 
x
¬¬ 
=
¬¬ 
$num
¬¬ 
;
¬¬ 
n
­­ 
.
­­ 
y
­­ 
=
­­ 
(
­­ 
xz
­­ 
*
­­ 
yz
­­ 
-
­­  
xy
­­! #
*
­­$ %
zz
­­& (
)
­­( )
/
­­* +
det_x
­­, 1
;
­­1 2
n
®® 
.
®® 
z
®® 
=
®® 
(
®® 
xy
®® 
*
®® 
yz
®® 
-
®®  
xz
®®! #
*
®®$ %
yy
®®& (
)
®®( )
/
®®* +
det_x
®®, 1
;
®®1 2
}
¯¯ 
else
°° 
if
°° 
(
°° 
det_y
°° 
>
°° 
det_z
°° "
)
°°" #
{
±± 
n
²² 
.
²² 
x
²² 
=
²² 
(
²² 
yz
²² 
*
²² 
xz
²² 
-
²²  
xy
²²! #
*
²²$ %
zz
²²& (
)
²²( )
/
²²* +
det_y
²², 1
;
²²1 2
n
³³ 
.
³³ 
y
³³ 
=
³³ 
$num
³³ 
;
³³ 
n
´´ 
.
´´ 
z
´´ 
=
´´ 
(
´´ 
xy
´´ 
*
´´ 
xz
´´ 
-
´´  
yz
´´! #
*
´´$ %
xx
´´& (
)
´´( )
/
´´* +
det_y
´´, 1
;
´´1 2
}
µµ 
else
¶¶ 
{
·· 
n
¸¸ 
.
¸¸ 
x
¸¸ 
=
¸¸ 
(
¸¸ 
yz
¸¸ 
*
¸¸ 
xy
¸¸ 
-
¸¸  
xz
¸¸! #
*
¸¸$ %
yy
¸¸& (
)
¸¸( )
/
¸¸* +
det_z
¸¸, 1
;
¸¸1 2
n
¹¹ 
.
¹¹ 
y
¹¹ 
=
¹¹ 
(
¹¹ 
xz
¹¹ 
*
¹¹ 
xy
¹¹ 
-
¹¹  
yz
¹¹! #
*
¹¹$ %
xx
¹¹& (
)
¹¹( )
/
¹¹* +
det_z
¹¹, 1
;
¹¹1 2
n
ºº 
.
ºº 
z
ºº 
=
ºº 
$num
ºº 
;
ºº 
}
»» 
n
½½ 
.
½½ 
	Normalize
½½ 
(
½½ 
)
½½ 
;
½½ 
return
¿¿ 
new
¿¿ 
Plane
¿¿ 
(
¿¿ 
n
¿¿ 
,
¿¿ 
c
¿¿  !
)
¿¿! "
;
¿¿" #
}
ÀÀ 	
}
ÁÁ 
}ÂÂ ú
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ActionResult.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

sealed 
class 
ActionResult $
{		 
public 
enum 
Status 
{ 	
Success 
, 
Failure 
, 
Canceled 
, 
NoChange 
} 	
public$$ 
Status$$ 
status$$ 
{$$ 
get$$ "
;$$" #
private$$$ +
set$$, /
;$$/ 0
}$$1 2
public)) 
string)) 
notification)) "
{))# $
get))% (
;))( )
private))* 1
set))2 5
;))5 6
}))7 8
public00 
ActionResult00 
(00 
ActionResult00 (
.00( )
Status00) /
status000 6
,006 7
string008 >
notification00? K
)00K L
{11 	
this22 
.22 
status22 
=22 
status22  
;22  !
this33 
.33 
notification33 
=33 
notification33  ,
;33, -
}44 	
public;; 
static;; 
implicit;; 
operator;; '
bool;;( ,
(;;, -
ActionResult;;- 9
res;;: =
);;= >
{<< 	
return== 
res== 
!=== 
null== 
&&== !
res==" %
.==% &
status==& ,
====- /
Status==0 6
.==6 7
Success==7 >
;==> ?
}>> 	
public@@ 
bool@@ 
ToBool@@ 
(@@ 
)@@ 
{AA 	
returnBB 
statusBB 
==BB 
StatusBB #
.BB# $
SuccessBB$ +
;BB+ ,
}CC 	
publicEE 
staticEE 
boolEE 
FromBoolEE #
(EE# $
boolEE$ (
successEE) 0
)EE0 1
{FF 	
returnGG 
successGG 
?GG 
ActionResultGG )
.GG) *
SuccessGG* 1
:GG2 3
newGG4 7
ActionResultGG8 D
(GGD E
ActionResultGGE Q
.GGQ R
StatusGGR X
.GGX Y
FailureGGY `
,GG` a
$strGGb k
)GGk l
;GGl m
}HH 	
publicMM 
staticMM 
ActionResultMM "
SuccessMM# *
{NN 	
getOO 
{OO 
returnOO 
newOO 
ActionResultOO )
(OO) *
ActionResultOO* 6
.OO6 7
StatusOO7 =
.OO= >
SuccessOO> E
,OOE F
$strOOG I
)OOI J
;OOJ K
}OOL M
}PP 	
publicUU 
staticUU 
ActionResultUU "
NoSelectionUU# .
{VV 	
getWW 
{WW 
returnWW 
newWW 
ActionResultWW )
(WW) *
ActionResultWW* 6
.WW6 7
StatusWW7 =
.WW= >
CanceledWW> F
,WWF G
$strWWH Z
)WWZ [
;WW[ \
}WW] ^
}XX 	
public]] 
static]] 
ActionResult]] "
UserCanceled]]# /
{^^ 	
get__ 
{__ 
return__ 
new__ 
ActionResult__ )
(__) *
ActionResult__* 6
.__6 7
Status__7 =
.__= >
Canceled__> F
,__F G
$str__H W
)__W X
;__X Y
}__Z [
}`` 	
}aa 
}bb ®”
•D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\PreferenceDictionary.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed 

class  
PreferenceDictionary %
:& '
ScriptableObject 
, *
ISerializationCallbackReceiver &
,& '
IHasDefault 
{ 

Dictionary 
< 
string 
, 
bool 
>  
m_Bool( .
=4 5
new6 9

Dictionary: D
<D E
stringE K
,K L
boolM Q
>Q R
(R S
)S T
;T U

Dictionary 
< 
string 
, 
int 
> 
m_Int( -
=4 5
new6 9

Dictionary: D
<D E
stringE K
,K L
intM P
>P Q
(Q R
)R S
;S T

Dictionary 
< 
string 
, 
float  
>  !
m_Float( /
=4 5
new6 9

Dictionary: D
<D E
stringE K
,K L
floatM R
>R S
(S T
)T U
;U V

Dictionary 
< 
string 
, 
string !
>! "
m_String( 0
=4 5
new6 9

Dictionary: D
<D E
stringE K
,K L
stringM S
>S T
(T U
)U V
;V W

Dictionary 
< 
string 
, 
Color  
>  !
m_Color( /
=4 5
new6 9

Dictionary: D
<D E
stringE K
,K L
ColorM R
>R S
(S T
)T U
;U V

Dictionary 
< 
string 
, 
Material #
># $

m_Material( 2
=4 5
new6 9

Dictionary: D
<D E
stringE K
,K L
MaterialM U
>U V
(V W
)W X
;X Y
[ 	
SerializeField	 
] 
List 
< 
string $
>$ %
m_Bool_keys( 3
;3 4
[ 	
SerializeField	 
] 
List 
< 
string $
>$ %

m_Int_keys( 2
;2 3
[ 	
SerializeField	 
] 
List 
< 
string $
>$ %
m_Float_keys( 4
;4 5
[ 	
SerializeField	 
] 
List 
< 
string $
>$ %
m_String_keys( 5
;5 6
[ 	
SerializeField	 
] 
List 
< 
string $
>$ %
m_Color_keys( 4
;4 5
[ 	
SerializeField	 
] 
List 
< 
string $
>$ %
m_Material_keys( 7
;7 8
[ 	
SerializeField	 
] 
List 
< 
bool "
>" #
m_Bool_values( 5
;5 6
[ 	
SerializeField	 
] 
List 
< 
int !
>! "
m_Int_values( 4
;4 5
[   	
SerializeField  	 
]   
List   
<   
float   #
>  # $
m_Float_values  ( 6
;  6 7
[!! 	
SerializeField!!	 
]!! 
List!! 
<!! 
string!! $
>!!$ %
m_String_values!!( 7
;!!7 8
["" 	
SerializeField""	 
]"" 
List"" 
<"" 
Color"" #
>""# $
m_Color_values""( 6
;""6 7
[## 	
SerializeField##	 
]## 
List## 
<## 
Material## &
>##& '
m_Material_values##( 9
;##9 :
public(( 
void(( 
OnBeforeSerialize(( %
(((% &
)((& '
{)) 	
m_Bool_keys** 
=**  !
m_Bool**" (
.**( )
Keys**) -
.**- .
ToList**. 4
(**4 5
)**5 6
;**6 7

m_Int_keys++ 
=++  !
m_Int++" '
.++' (
Keys++( ,
.++, -
ToList++- 3
(++3 4
)++4 5
;++5 6
m_Float_keys,, 
=,,  !
m_Float,," )
.,,) *
Keys,,* .
.,,. /
ToList,,/ 5
(,,5 6
),,6 7
;,,7 8
m_String_keys-- 
=--  !
m_String--" *
.--* +
Keys--+ /
.--/ 0
ToList--0 6
(--6 7
)--7 8
;--8 9
m_Color_keys.. 
=..  !
m_Color.." )
...) *
Keys..* .
.... /
ToList../ 5
(..5 6
)..6 7
;..7 8
m_Material_keys// 
=//  !

m_Material//" ,
.//, -
Keys//- 1
.//1 2
ToList//2 8
(//8 9
)//9 :
;//: ;
m_Bool_values11 
=11  !
m_Bool11" (
.11( )
Values11) /
.11/ 0
ToList110 6
(116 7
)117 8
;118 9
m_Int_values22 
=22  !
m_Int22" '
.22' (
Values22( .
.22. /
ToList22/ 5
(225 6
)226 7
;227 8
m_Float_values33 
=33  !
m_Float33" )
.33) *
Values33* 0
.330 1
ToList331 7
(337 8
)338 9
;339 :
m_String_values44 
=44  !
m_String44" *
.44* +
Values44+ 1
.441 2
ToList442 8
(448 9
)449 :
;44: ;
m_Color_values55 
=55  !
m_Color55" )
.55) *
Values55* 0
.550 1
ToList551 7
(557 8
)558 9
;559 :
m_Material_values66 
=66  !

m_Material66" ,
.66, -
Values66- 3
.663 4
ToList664 :
(66: ;
)66; <
;66< =
}77 	
public<< 
void<< 
OnAfterDeserialize<< &
(<<& '
)<<' (
{== 	
for>> 
(>> 
int>> 
i>> 
=>> 
$num>> 
;>> 
i>> 
<>> 
m_Bool_keys>>  +
.>>+ ,
Count>>, 1
;>>1 2
i>>3 4
++>>4 6
)>>6 7
m_Bool?? 
.?? 
Add?? 
(?? 
m_Bool_keys?? &
[??& '
i??' (
]??( )
,??) *
m_Bool_values??+ 8
[??8 9
i??9 :
]??: ;
)??; <
;??< =
forAA 
(AA 
intAA 
iAA 
=AA 
$numAA 
;AA 
iAA 
<AA 

m_Int_keysAA  *
.AA* +
CountAA+ 0
;AA0 1
iAA2 3
++AA3 5
)AA5 6
m_IntBB 
.BB 
AddBB 
(BB 

m_Int_keysBB $
[BB$ %
iBB% &
]BB& '
,BB' (
m_Int_valuesBB) 5
[BB5 6
iBB6 7
]BB7 8
)BB8 9
;BB9 :
forDD 
(DD 
intDD 
iDD 
=DD 
$numDD 
;DD 
iDD 
<DD 
m_Float_keysDD  ,
.DD, -
CountDD- 2
;DD2 3
iDD4 5
++DD5 7
)DD7 8
m_FloatEE 
.EE 
AddEE 
(EE 
m_Float_keysEE (
[EE( )
iEE) *
]EE* +
,EE+ ,
m_Float_valuesEE- ;
[EE; <
iEE< =
]EE= >
)EE> ?
;EE? @
forGG 
(GG 
intGG 
iGG 
=GG 
$numGG 
;GG 
iGG 
<GG 
m_String_keysGG  -
.GG- .
CountGG. 3
;GG3 4
iGG5 6
++GG6 8
)GG8 9
m_StringHH 
.HH 
AddHH 
(HH 
m_String_keysHH *
[HH* +
iHH+ ,
]HH, -
,HH- .
m_String_valuesHH/ >
[HH> ?
iHH? @
]HH@ A
)HHA B
;HHB C
forJJ 
(JJ 
intJJ 
iJJ 
=JJ 
$numJJ 
;JJ 
iJJ 
<JJ 
m_Color_keysJJ  ,
.JJ, -
CountJJ- 2
;JJ2 3
iJJ4 5
++JJ5 7
)JJ7 8
m_ColorKK 
.KK 
AddKK 
(KK 
m_Color_keysKK (
[KK( )
iKK) *
]KK* +
,KK+ ,
m_Color_valuesKK- ;
[KK; <
iKK< =
]KK= >
)KK> ?
;KK? @
forMM 
(MM 
intMM 
iMM 
=MM 
$numMM 
;MM 
iMM 
<MM 
m_Material_keysMM  /
.MM/ 0
CountMM0 5
;MM5 6
iMM7 8
++MM8 :
)MM: ;

m_MaterialNN 
.NN 
AddNN 
(NN 
m_Material_keysNN .
[NN. /
iNN/ 0
]NN0 1
,NN1 2
m_Material_valuesNN3 D
[NND E
iNNE F
]NNF G
)NNG H
;NNH I
}OO 	
publicTT 
voidTT 
SetDefaultValuesTT $
(TT$ %
)TT% &
{UU 	
m_BoolVV 
.VV 
ClearVV 
(VV 
)VV 
;VV 
m_IntWW 
.WW 
ClearWW 
(WW 
)WW 
;WW 
m_FloatXX 
.XX 
ClearXX 
(XX 
)XX 
;XX 
m_StringYY 
.YY 
ClearYY 
(YY 
)YY 
;YY 
m_ColorZZ 
.ZZ 
ClearZZ 
(ZZ 
)ZZ 
;ZZ 

m_Material[[ 
.[[ 
Clear[[ 
([[ 
)[[ 
;[[ 
}\\ 	
publiccc 
boolcc 
HasKeycc 
(cc 
stringcc !
keycc" %
)cc% &
{dd 	
returnee 
m_Boolee 
.ee 
ContainsKeyee %
(ee% &
keyee& )
)ee) *
||ee+ -
m_Intff 
.ff 
ContainsKeyff !
(ff! "
keyff" %
)ff% &
||ff' )
m_Floatgg 
.gg 
ContainsKeygg #
(gg# $
keygg$ '
)gg' (
||gg) +
m_Stringhh 
.hh 
ContainsKeyhh $
(hh$ %
keyhh% (
)hh( )
||hh* ,
m_Colorii 
.ii 
ContainsKeyii #
(ii# $
keyii$ '
)ii' (
||ii) +

m_Materialjj 
.jj 
ContainsKeyjj &
(jj& '
keyjj' *
)jj* +
;jj+ ,
}kk 	
publicss 
boolss 
HasKeyss 
<ss 
Tss 
>ss 
(ss 
stringss $
keyss% (
)ss( )
{tt 	
Systemuu 
.uu 
Typeuu 
typeuu 
=uu 
typeofuu %
(uu% &
Tuu& '
)uu' (
;uu( )
ifww 
(ww 
typeww 
==ww 
typeofww 
(ww 
intww "
)ww" #
)ww# $
returnxx 
m_Intxx 
.xx 
ContainsKeyxx (
(xx( )
keyxx) ,
)xx, -
;xx- .
elseyy 
ifyy 
(yy 
typeyy 
==yy 
typeofyy #
(yy# $
floatyy$ )
)yy) *
)yy* +
returnzz 
m_Floatzz 
.zz 
ContainsKeyzz *
(zz* +
keyzz+ .
)zz. /
;zz/ 0
else{{ 
if{{ 
({{ 
type{{ 
=={{ 
typeof{{ #
({{# $
bool{{$ (
){{( )
){{) *
return|| 
m_Bool|| 
.|| 
ContainsKey|| )
(||) *
key||* -
)||- .
;||. /
else}} 
if}} 
(}} 
type}} 
==}} 
typeof}} #
(}}# $
string}}$ *
)}}* +
)}}+ ,
return~~ 
m_String~~ 
.~~  
ContainsKey~~  +
(~~+ ,
key~~, /
)~~/ 0
;~~0 1
else 
if 
( 
type 
== 
typeof #
(# $
Color$ )
)) *
)* +
return
€€ 
m_Color
€€ 
.
€€ 
ContainsKey
€€ *
(
€€* +
key
€€+ .
)
€€. /
;
€€/ 0
else
 
if
 
(
 
type
 
==
 
typeof
 #
(
# $
Material
$ ,
)
, -
)
- .
return
‚‚ 

m_Material
‚‚ !
.
‚‚! "
ContainsKey
‚‚" -
(
‚‚- .
key
‚‚. 1
)
‚‚1 2
;
‚‚2 3
else
ƒƒ 
{
„„ 
Debug
…… 
.
…… 

LogWarning
……  
(
……  !
string
……! '
.
……' (
Format
……( .
(
……. /
$str
……/ \
,
……\ ]
typeof
†† 
(
†† 
T
††  
)
††  !
.
††! "
ToString
††" *
(
††* +
)
††+ ,
,
††, -
key
‡‡ 
)
‡‡ 
)
‡‡ 
;
‡‡ 
}
ˆˆ 
return
ŠŠ 
false
ŠŠ 
;
ŠŠ 
}
‹‹ 	
public
 
void
 
	DeleteKey
 
(
 
string
 $
key
% (
)
( )
{
 	
if
 
(
 
m_Bool
 
.
 
ContainsKey
 "
(
" #
key
# &
)
& '
)
' (
m_Bool
 
.
 
Remove
 
(
 
key
 !
)
! "
;
" #
if
‘‘ 
(
‘‘ 
m_Int
‘‘ 
.
‘‘ 
ContainsKey
‘‘ !
(
‘‘! "
key
‘‘" %
)
‘‘% &
)
‘‘& '
m_Int
’’ 
.
’’ 
Remove
’’ 
(
’’ 
key
’’  
)
’’  !
;
’’! "
if
““ 
(
““ 
m_Float
““ 
.
““ 
ContainsKey
““ #
(
““# $
key
““$ '
)
““' (
)
““( )
m_Float
”” 
.
”” 
Remove
”” 
(
”” 
key
”” "
)
””" #
;
””# $
if
•• 
(
•• 
m_String
•• 
.
•• 
ContainsKey
•• $
(
••$ %
key
••% (
)
••( )
)
••) *
m_String
–– 
.
–– 
Remove
–– 
(
––  
key
––  #
)
––# $
;
––$ %
if
—— 
(
—— 
m_Color
—— 
.
—— 
ContainsKey
—— #
(
——# $
key
——$ '
)
——' (
)
——( )
m_Color
˜˜ 
.
˜˜ 
Remove
˜˜ 
(
˜˜ 
key
˜˜ "
)
˜˜" #
;
˜˜# $
if
™™ 
(
™™ 

m_Material
™™ 
.
™™ 
ContainsKey
™™ &
(
™™& '
key
™™' *
)
™™* +
)
™™+ ,

m_Material
šš 
.
šš 
Remove
šš !
(
šš! "
key
šš" %
)
šš% &
;
šš& '
}
›› 	
public
¤¤ 
T
¤¤ 
Get
¤¤ 
<
¤¤ 
T
¤¤ 
>
¤¤ 
(
¤¤ 
string
¤¤ 
key
¤¤ "
,
¤¤" #
T
¤¤$ %
fallback
¤¤& .
=
¤¤/ 0
default
¤¤1 8
(
¤¤8 9
T
¤¤9 :
)
¤¤: ;
)
¤¤; <
{
¥¥ 	
System
¦¦ 
.
¦¦ 
Type
¦¦ 
type
¦¦ 
=
¦¦ 
typeof
¦¦ %
(
¦¦% &
T
¦¦& '
)
¦¦' (
;
¦¦( )
if
¨¨ 
(
¨¨ 
type
¨¨ 
==
¨¨ 
typeof
¨¨ 
(
¨¨ 
int
¨¨ "
)
¨¨" #
)
¨¨# $
{
©© 
if
ªª 
(
ªª 
m_Int
ªª 
.
ªª 
ContainsKey
ªª %
(
ªª% &
key
ªª& )
)
ªª) *
)
ªª* +
return
«« 
(
«« 
T
«« 
)
«« 
(
«« 
object
«« %
)
««% &
GetInt
««& ,
(
««, -
key
««- 0
)
««0 1
;
««1 2
}
¬¬ 
else
­­ 
if
­­ 
(
­­ 
type
­­ 
==
­­ 
typeof
­­ #
(
­­# $
float
­­$ )
)
­­) *
)
­­* +
{
®® 
if
¯¯ 
(
¯¯ 
m_Float
¯¯ 
.
¯¯ 
ContainsKey
¯¯ '
(
¯¯' (
key
¯¯( +
)
¯¯+ ,
)
¯¯, -
return
°° 
(
°° 
T
°° 
)
°° 
(
°° 
object
°° %
)
°°% &
GetFloat
°°& .
(
°°. /
key
°°/ 2
)
°°2 3
;
°°3 4
}
±± 
else
²² 
if
²² 
(
²² 
type
²² 
==
²² 
typeof
²² #
(
²²# $
bool
²²$ (
)
²²( )
)
²²) *
{
³³ 
if
´´ 
(
´´ 
m_Bool
´´ 
.
´´ 
ContainsKey
´´ &
(
´´& '
key
´´' *
)
´´* +
)
´´+ ,
return
µµ 
(
µµ 
T
µµ 
)
µµ 
(
µµ 
object
µµ %
)
µµ% &
GetBool
µµ& -
(
µµ- .
key
µµ. 1
)
µµ1 2
;
µµ2 3
}
¶¶ 
else
·· 
if
·· 
(
·· 
type
·· 
==
·· 
typeof
·· #
(
··# $
string
··$ *
)
··* +
)
··+ ,
{
¸¸ 
if
¹¹ 
(
¹¹ 
m_String
¹¹ 
.
¹¹ 
ContainsKey
¹¹ (
(
¹¹( )
key
¹¹) ,
)
¹¹, -
)
¹¹- .
return
ºº 
(
ºº 
T
ºº 
)
ºº 
(
ºº 
object
ºº %
)
ºº% &
	GetString
ºº& /
(
ºº/ 0
key
ºº0 3
)
ºº3 4
;
ºº4 5
}
»» 
else
¼¼ 
if
¼¼ 
(
¼¼ 
type
¼¼ 
==
¼¼ 
typeof
¼¼ #
(
¼¼# $
Color
¼¼$ )
)
¼¼) *
)
¼¼* +
{
½½ 
if
¾¾ 
(
¾¾ 
m_Color
¾¾ 
.
¾¾ 
ContainsKey
¾¾ '
(
¾¾' (
key
¾¾( +
)
¾¾+ ,
)
¾¾, -
return
¿¿ 
(
¿¿ 
T
¿¿ 
)
¿¿ 
(
¿¿ 
object
¿¿ %
)
¿¿% &
GetColor
¿¿& .
(
¿¿. /
key
¿¿/ 2
)
¿¿2 3
;
¿¿3 4
}
ÀÀ 
else
ÁÁ 
if
ÁÁ 
(
ÁÁ 
type
ÁÁ 
==
ÁÁ 
typeof
ÁÁ #
(
ÁÁ# $
Material
ÁÁ$ ,
)
ÁÁ, -
)
ÁÁ- .
{
ÂÂ 
if
ÃÃ 
(
ÃÃ 

m_Material
ÃÃ 
.
ÃÃ 
ContainsKey
ÃÃ *
(
ÃÃ* +
key
ÃÃ+ .
)
ÃÃ. /
)
ÃÃ/ 0
return
ÄÄ 
(
ÄÄ 
T
ÄÄ 
)
ÄÄ 
(
ÄÄ 
object
ÄÄ %
)
ÄÄ% &
GetMaterial
ÄÄ& 1
(
ÄÄ1 2
key
ÄÄ2 5
)
ÄÄ5 6
;
ÄÄ6 7
}
ÅÅ 
else
ÆÆ 
{
ÇÇ 
Debug
ÈÈ 
.
ÈÈ 

LogWarning
ÈÈ  
(
ÈÈ  !
string
ÈÈ! '
.
ÈÈ' (
Format
ÈÈ( .
(
ÈÈ. /
$str
ÈÈ/ Y
,
ÈÈY Z
typeof
ÉÉ 
(
ÉÉ 
T
ÉÉ  
)
ÉÉ  !
.
ÉÉ! "
ToString
ÉÉ" *
(
ÉÉ* +
)
ÉÉ+ ,
,
ÉÉ, -
key
ÊÊ 
)
ÊÊ 
)
ÊÊ 
;
ÊÊ 
}
ËË 
return
ÍÍ 
fallback
ÍÍ 
;
ÍÍ 
}
ÎÎ 	
public
ÜÜ 
void
ÜÜ 
Set
ÜÜ 
<
ÜÜ 
T
ÜÜ 
>
ÜÜ 
(
ÜÜ 
string
ÜÜ !
key
ÜÜ" %
,
ÜÜ% &
T
ÜÜ' (
value
ÜÜ) .
)
ÜÜ. /
{
İİ 	
object
ŞŞ 
o
ŞŞ 
=
ŞŞ 
(
ŞŞ 
object
ŞŞ 
)
ŞŞ 
value
ŞŞ $
;
ŞŞ$ %
if
àà 
(
àà 
value
àà 
is
àà 
int
àà 
)
àà 
SetInt
áá 
(
áá 
key
áá 
,
áá 
(
áá 
int
áá  
)
áá  !
o
áá! "
)
áá" #
;
áá# $
else
ââ 
if
ââ 
(
ââ 
value
ââ 
is
ââ 
float
ââ #
)
ââ# $
SetFloat
ãã 
(
ãã 
key
ãã 
,
ãã 
(
ãã 
float
ãã $
)
ãã$ %
o
ãã% &
)
ãã& '
;
ãã' (
else
ää 
if
ää 
(
ää 
value
ää 
is
ää 
bool
ää "
)
ää" #
SetBool
åå 
(
åå 
key
åå 
,
åå 
(
åå 
bool
åå "
)
åå" #
o
åå# $
)
åå$ %
;
åå% &
else
ææ 
if
ææ 
(
ææ 
value
ææ 
is
ææ 
string
ææ $
)
ææ$ %
	SetString
çç 
(
çç 
key
çç 
,
çç 
(
çç  
string
çç  &
)
çç& '
o
çç' (
)
çç( )
;
çç) *
else
èè 
if
èè 
(
èè 
value
èè 
is
èè 
Color
èè #
)
èè# $
SetColor
éé 
(
éé 
key
éé 
,
éé 
(
éé 
Color
éé $
)
éé$ %
o
éé% &
)
éé& '
;
éé' (
else
êê 
if
êê 
(
êê 
value
êê 
is
êê 
Material
êê &
)
êê& '
SetMaterial
ëë 
(
ëë 
key
ëë 
,
ëë  
(
ëë! "
Material
ëë" *
)
ëë* +
o
ëë+ ,
)
ëë, -
;
ëë- .
else
ìì 
Debug
íí 
.
íí 

LogWarning
íí  
(
íí  !
string
íí! '
.
íí' (
Format
íí( .
(
íí. /
$str
íí/ ^
,
íí^ _
typeof
îî 
(
îî 
T
îî  
)
îî  !
.
îî! "
ToString
îî" *
(
îî* +
)
îî+ ,
,
îî, -
key
ïï 
,
ïï 
value
ğğ 
.
ğğ 
ToString
ğğ &
(
ğğ& '
)
ğğ' (
)
ğğ( )
)
ğğ) *
;
ğğ* +
}
ññ 	
public
öö 
bool
öö 
GetBool
öö 
(
öö 
string
öö "
key
öö# &
,
öö& '
bool
öö( ,
fallback
öö- 5
=
öö6 7
default
öö8 ?
(
öö? @
bool
öö@ D
)
ööD E
)
ööE F
{
÷÷ 	
bool
øø 
value
øø 
;
øø 
if
ùù 
(
ùù 
m_Bool
ùù 
.
ùù 
TryGetValue
ùù "
(
ùù" #
key
ùù# &
,
ùù& '
out
ùù( +
value
ùù, 1
)
ùù1 2
)
ùù2 3
return
úú 
value
úú 
;
úú 
return
ûû 
fallback
ûû 
;
ûû 
}
üü 	
public
 
int
 
GetInt
 
(
 
string
  
key
! $
,
$ %
int
& )
fallback
* 2
=
3 4
default
5 <
(
< =
int
= @
)
@ A
)
A B
{
‚‚ 	
int
ƒƒ 
value
ƒƒ 
;
ƒƒ 
if
„„ 
(
„„ 
m_Int
„„ 
.
„„ 
TryGetValue
„„ !
(
„„! "
key
„„" %
,
„„% &
out
„„' *
value
„„+ 0
)
„„0 1
)
„„1 2
return
…… 
value
…… 
;
…… 
return
†† 
fallback
†† 
;
†† 
}
‡‡ 	
public
ŒŒ 
float
ŒŒ 
GetFloat
ŒŒ 
(
ŒŒ 
string
ŒŒ $
key
ŒŒ% (
,
ŒŒ( )
float
ŒŒ* /
fallback
ŒŒ0 8
=
ŒŒ9 :
default
ŒŒ; B
(
ŒŒB C
float
ŒŒC H
)
ŒŒH I
)
ŒŒI J
{
 	
float
 
value
 
;
 
if
 
(
 
m_Float
 
.
 
TryGetValue
 #
(
# $
key
$ '
,
' (
out
) ,
value
- 2
)
2 3
)
3 4
return
 
value
 
;
 
return
‘‘ 
fallback
‘‘ 
;
‘‘ 
}
’’ 	
public
—— 
string
—— 
	GetString
—— 
(
——  
string
——  &
key
——' *
,
——* +
string
——, 2
fallback
——3 ;
=
——< =
default
——> E
(
——E F
string
——F L
)
——L M
)
——M N
{
˜˜ 	
string
™™ 
value
™™ 
;
™™ 
if
šš 
(
šš 
m_String
šš 
.
šš 
TryGetValue
šš $
(
šš$ %
key
šš% (
,
šš( )
out
šš* -
value
šš. 3
)
šš3 4
)
šš4 5
return
›› 
value
›› 
;
›› 
return
œœ 
fallback
œœ 
;
œœ 
}
 	
public
¢¢ 
Color
¢¢ 
GetColor
¢¢ 
(
¢¢ 
string
¢¢ $
key
¢¢% (
,
¢¢( )
Color
¢¢* /
fallback
¢¢0 8
=
¢¢9 :
default
¢¢; B
(
¢¢B C
Color
¢¢C H
)
¢¢H I
)
¢¢I J
{
££ 	
Color
¤¤ 
value
¤¤ 
;
¤¤ 
if
¥¥ 
(
¥¥ 
m_Color
¥¥ 
.
¥¥ 
TryGetValue
¥¥ #
(
¥¥# $
key
¥¥$ '
,
¥¥' (
out
¥¥) ,
value
¥¥- 2
)
¥¥2 3
)
¥¥3 4
return
¦¦ 
value
¦¦ 
;
¦¦ 
return
§§ 
fallback
§§ 
;
§§ 
}
¨¨ 	
public
­­ 
Material
­­ 
GetMaterial
­­ #
(
­­# $
string
­­$ *
key
­­+ .
,
­­. /
Material
­­0 8
fallback
­­9 A
=
­­B C
default
­­D K
(
­­K L
Material
­­L T
)
­­T U
)
­­U V
{
®® 	
Material
¯¯ 
value
¯¯ 
;
¯¯ 
if
°° 
(
°° 

m_Material
°° 
.
°° 
TryGetValue
°° &
(
°°& '
key
°°' *
,
°°* +
out
°°, /
value
°°0 5
)
°°5 6
)
°°6 7
return
±± 
value
±± 
;
±± 
return
²² 
fallback
²² 
;
²² 
}
³³ 	
public
¸¸ 
void
¸¸ 
SetBool
¸¸ 
(
¸¸ 
string
¸¸ "
key
¸¸# &
,
¸¸& '
bool
¸¸( ,
value
¸¸- 2
)
¸¸2 3
{
¹¹ 	
if
ºº 
(
ºº 
m_Bool
ºº 
.
ºº 
ContainsKey
ºº "
(
ºº" #
key
ºº# &
)
ºº& '
)
ºº' (
m_Bool
»» 
[
»» 
key
»» 
]
»» 
=
»» 
value
»» #
;
»»# $
else
¼¼ 
m_Bool
½½ 
.
½½ 
Add
½½ 
(
½½ 
key
½½ 
,
½½ 
value
½½  %
)
½½% &
;
½½& '
}
¾¾ 	
public
ÃÃ 
void
ÃÃ 
SetInt
ÃÃ 
(
ÃÃ 
string
ÃÃ !
key
ÃÃ" %
,
ÃÃ% &
int
ÃÃ' *
value
ÃÃ+ 0
)
ÃÃ0 1
{
ÄÄ 	
if
ÅÅ 
(
ÅÅ 
m_Int
ÅÅ 
.
ÅÅ 
ContainsKey
ÅÅ !
(
ÅÅ! "
key
ÅÅ" %
)
ÅÅ% &
)
ÅÅ& '
m_Int
ÆÆ 
[
ÆÆ 
key
ÆÆ 
]
ÆÆ 
=
ÆÆ 
value
ÆÆ "
;
ÆÆ" #
else
ÇÇ 
m_Int
ÈÈ 
.
ÈÈ 
Add
ÈÈ 
(
ÈÈ 
key
ÈÈ 
,
ÈÈ 
value
ÈÈ $
)
ÈÈ$ %
;
ÈÈ% &
}
ÉÉ 	
public
ÎÎ 
void
ÎÎ 
SetFloat
ÎÎ 
(
ÎÎ 
string
ÎÎ #
key
ÎÎ$ '
,
ÎÎ' (
float
ÎÎ) .
value
ÎÎ/ 4
)
ÎÎ4 5
{
ÏÏ 	
if
ĞĞ 
(
ĞĞ 
m_Float
ĞĞ 
.
ĞĞ 
ContainsKey
ĞĞ #
(
ĞĞ# $
key
ĞĞ$ '
)
ĞĞ' (
)
ĞĞ( )
m_Float
ÑÑ 
[
ÑÑ 
key
ÑÑ 
]
ÑÑ 
=
ÑÑ 
value
ÑÑ $
;
ÑÑ$ %
else
ÒÒ 
m_Float
ÓÓ 
.
ÓÓ 
Add
ÓÓ 
(
ÓÓ 
key
ÓÓ 
,
ÓÓ  
value
ÓÓ! &
)
ÓÓ& '
;
ÓÓ' (
}
ÔÔ 	
public
ÙÙ 
void
ÙÙ 
	SetString
ÙÙ 
(
ÙÙ 
string
ÙÙ $
key
ÙÙ% (
,
ÙÙ( )
string
ÙÙ* 0
value
ÙÙ1 6
)
ÙÙ6 7
{
ÚÚ 	
if
ÛÛ 
(
ÛÛ 
m_String
ÛÛ 
.
ÛÛ 
ContainsKey
ÛÛ $
(
ÛÛ$ %
key
ÛÛ% (
)
ÛÛ( )
)
ÛÛ) *
m_String
ÜÜ 
[
ÜÜ 
key
ÜÜ 
]
ÜÜ 
=
ÜÜ 
value
ÜÜ  %
;
ÜÜ% &
else
İİ 
m_String
ŞŞ 
.
ŞŞ 
Add
ŞŞ 
(
ŞŞ 
key
ŞŞ  
,
ŞŞ  !
value
ŞŞ" '
)
ŞŞ' (
;
ŞŞ( )
}
ßß 	
public
ää 
void
ää 
SetColor
ää 
(
ää 
string
ää #
key
ää$ '
,
ää' (
Color
ää) .
value
ää/ 4
)
ää4 5
{
åå 	
if
ææ 
(
ææ 
m_Color
ææ 
.
ææ 
ContainsKey
ææ #
(
ææ# $
key
ææ$ '
)
ææ' (
)
ææ( )
m_Color
çç 
[
çç 
key
çç 
]
çç 
=
çç 
value
çç $
;
çç$ %
else
èè 
m_Color
éé 
.
éé 
Add
éé 
(
éé 
key
éé 
,
éé  
value
éé! &
)
éé& '
;
éé' (
}
êê 	
public
ïï 
void
ïï 
SetMaterial
ïï 
(
ïï  
string
ïï  &
key
ïï' *
,
ïï* +
Material
ïï, 4
value
ïï5 :
)
ïï: ;
{
ğğ 	
if
ññ 
(
ññ 

m_Material
ññ 
.
ññ 
ContainsKey
ññ &
(
ññ& '
key
ññ' *
)
ññ* +
)
ññ+ ,

m_Material
òò 
[
òò 
key
òò 
]
òò 
=
òò  !
value
òò" '
;
òò' (
else
óó 

m_Material
ôô 
.
ôô 
Add
ôô 
(
ôô 
key
ôô "
,
ôô" #
value
ôô$ )
)
ôô) *
;
ôô* +
}
õõ 	
public
úú 

Dictionary
úú 
<
úú 
string
úú  
,
úú  !
bool
úú" &
>
úú& '
GetBoolDictionary
úú( 9
(
úú9 :
)
úú: ;
{
úú< =
return
úú> D
m_Bool
úúE K
;
úúK L
}
úúM N
public
ÿÿ 

Dictionary
ÿÿ 
<
ÿÿ 
string
ÿÿ  
,
ÿÿ  !
int
ÿÿ" %
>
ÿÿ% &
GetIntDictionary
ÿÿ' 7
(
ÿÿ7 8
)
ÿÿ8 9
{
ÿÿ: ;
return
ÿÿ< B
m_Int
ÿÿC H
;
ÿÿH I
}
ÿÿJ K
public
„„ 

Dictionary
„„ 
<
„„ 
string
„„  
,
„„  !
float
„„" '
>
„„' ( 
GetFloatDictionary
„„) ;
(
„„; <
)
„„< =
{
„„> ?
return
„„@ F
m_Float
„„G N
;
„„N O
}
„„P Q
public
‰‰ 

Dictionary
‰‰ 
<
‰‰ 
string
‰‰  
,
‰‰  !
string
‰‰" (
>
‰‰( )!
GetStringDictionary
‰‰* =
(
‰‰= >
)
‰‰> ?
{
‰‰@ A
return
‰‰B H
m_String
‰‰I Q
;
‰‰Q R
}
‰‰S T
public
 

Dictionary
 
<
 
string
  
,
  !
Color
" '
>
' ( 
GetColorDictionary
) ;
(
; <
)
< =
{
> ?
return
@ F
m_Color
G N
;
N O
}
P Q
public
““ 

Dictionary
““ 
<
““ 
string
““  
,
““  !
Material
““" *
>
““* +#
GetMaterialDictionary
““, A
(
““A B
)
““B C
{
““D E
return
““F L

m_Material
““M W
;
““W X
}
““Y Z
public
˜˜ 
void
˜˜ 
Clear
˜˜ 
(
˜˜ 
)
˜˜ 
{
™™ 	
m_Bool
šš 
.
šš 
Clear
šš 
(
šš 
)
šš 
;
šš 
m_Int
›› 
.
›› 
Clear
›› 
(
›› 
)
›› 
;
›› 
m_Float
œœ 
.
œœ 
Clear
œœ 
(
œœ 
)
œœ 
;
œœ 
m_String
 
.
 
Clear
 
(
 
)
 
;
 
m_Color
 
.
 
Clear
 
(
 
)
 
;
 
}
ŸŸ 	
}
   
}¡¡ ù*
ˆD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\IntVec2.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
struct 
IntVec2 
: 
System 
. 

IEquatable #
<# $
IntVec2$ +
>+ ,
{		 
public

 
Vector2

	 
value

 
;

 
public 
float	 
x 
{ 
get 
{ 
return 
value  %
.% &
x& '
;' (
}) *
}+ ,
public 
float	 
y 
{ 
get 
{ 
return 
value  %
.% &
y& '
;' (
}) *
}+ ,
public 
IntVec2	 
( 
Vector2 
vector 
)  
{ 
this 
. 
value 
= 
vector 
; 
} 
public 
override	 
string 
ToString !
(! "
)" #
{ 
return 	
string
 
. 
Format 
( 
$str *
,* +
x, -
,- .
y/ 0
)0 1
;1 2
} 
public 
static	 
bool 
operator 
== 
(  
IntVec2  '
a( )
,) *
IntVec2+ 2
b3 4
)4 5
{ 
return 	
a
 
. 
Equals 
( 
b 
) 
; 
} 
public 
static	 
bool 
operator 
!= 
(  
IntVec2  '
a( )
,) *
IntVec2+ 2
b3 4
)4 5
{ 
return   	
!  
 
(   
a   
==   
b   
)   
;   
}!! 
public## 
bool##	 
Equals## 
(## 
IntVec2## 
p## 
)## 
{$$ 
return%% 	
round%%
 
(%% 
x%% 
)%% 
==%% 
round%% 
(%% 
p%% 
.%% 
x%% 
)%%  
&&%%! #
round&& 	
(&&	 

y&&
 
)&& 
==&& 
round&& 
(&& 
p&& 
.&& 
y&& 
)&& 
;&& 
}'' 
public)) 
bool))	 
Equals)) 
()) 
Vector2)) 
p)) 
))) 
{** 
return++ 	
round++
 
(++ 
x++ 
)++ 
==++ 
round++ 
(++ 
p++ 
.++ 
x++ 
)++  
&&++! #
round,, 	
(,,	 

y,,
 
),, 
==,, 
round,, 
(,, 
p,, 
.,, 
y,, 
),, 
;,, 
}-- 
public// 
override//	 
bool// 
Equals// 
(// 
System// $
.//$ %
Object//% +
b//, -
)//- .
{00 
return11 	
(11
 
b11 
is11 
IntVec211 
&&11 
(11 
this11  
.11  !
Equals11! '
(11' (
(11( )
IntVec211) 0
)110 1
b111 2
)112 3
)113 4
)114 5
||116 8
(22 
b22 
is22 	
Vector222
 
&&22 
this22 
.22 
Equals22  
(22  !
(22! "
Vector222" )
)22) *
b22* +
)22+ ,
)22, -
;22- .
}33 
public55 
override55	 
int55 
GetHashCode55 !
(55! "
)55" #
{66 
return77 	

VectorHash77
 
.77 
GetHashCode77  
(77  !
value77! &
)77& '
;77' (
}88 
private:: 	
static::
 
int:: 
round:: 
(:: 
float::  
v::! "
)::" #
{;; 
return<< 	
System<<
 
.<< 
Convert<< 
.<< 
ToInt32<<  
(<<  !
v<<! "
*<<# $

VectorHash<<% /
.<</ 0 
FltCompareResolution<<0 D
)<<D E
;<<E F
}== 
public?? 
static??	 
implicit?? 
operator?? !
Vector2??" )
(??) *
IntVec2??* 1
p??2 3
)??3 4
{@@ 
returnAA 	
pAA
 
.AA 
valueAA 
;AA 
}BB 
publicDD 
staticDD	 
implicitDD 
operatorDD !
IntVec2DD" )
(DD) *
Vector2DD* 1
pDD2 3
)DD3 4
{EE 
returnFF 	
newFF
 
IntVec2FF 
(FF 
pFF 
)FF 
;FF 
}GG 
}HH 
}II À
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\MaterialUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
MaterialUtility  
{ 
static

 
List

 
<

 
Material

 
>

 
s_MaterialArray

 -
=

. /
new

0 3
List

4 8
<

8 9
Material

9 A
>

A B
(

B C
)

C D
;

D E
internal 
static 
int 
GetMaterialCount ,
(, -
Renderer- 5
renderer6 >
)> ?
{ 	
s_MaterialArray 
. 
Clear !
(! "
)" #
;# $
renderer 
. 
GetSharedMaterials '
(' (
s_MaterialArray( 7
)7 8
;8 9
return 
s_MaterialArray "
." #
Count# (
;( )
} 	
internal 
static 
Material  
GetSharedMaterial! 2
(2 3
Renderer3 ;
renderer< D
,D E
intF I
indexJ O
)O P
{ 	
s_MaterialArray 
. 
Clear !
(! "
)" #
;# $
renderer 
. 
GetSharedMaterials '
(' (
s_MaterialArray( 7
)7 8
;8 9
var 
count 
= 
s_MaterialArray '
.' (
Count( -
;- .
if 
( 
count 
< 
$num 
) 
return 
null 
; 
return   
s_MaterialArray   "
[  " #
Math  # '
.  ' (
Clamp  ( -
(  - .
index  . 3
,  3 4
$num  5 6
,  6 7
count  8 =
-  > ?
$num  @ A
)  A B
]  B C
;  C D
}(( 	
})) 
}** »ö
‹D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\WingedEdge.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

sealed 
class 

WingedEdge "
:# $

IEquatable% /
</ 0

WingedEdge0 :
>: ;
{ 
static 
readonly 

Dictionary "
<" #
Edge# '
,' (

WingedEdge) 3
>3 4$
k_OppositeEdgeDictionary5 M
=N O
newP S

DictionaryT ^
<^ _
Edge_ c
,c d

WingedEdgee o
>o p
(p q
)q r
;r s
public!! 

EdgeLookup!! 
edge!! 
{!!  
get!!! $
;!!$ %
private!!& -
set!!. 1
;!!1 2
}!!3 4
public&& 
Face&& 
face&& 
{&& 
get&& 
;&& 
private&&  '
set&&( +
;&&+ ,
}&&- .
public++ 

WingedEdge++ 
next++ 
{++  
get++! $
;++$ %
private++& -
set++. 1
;++1 2
}++3 4
public00 

WingedEdge00 
previous00 "
{00# $
get00% (
;00( )
private00* 1
set002 5
;005 6
}007 8
public55 

WingedEdge55 
opposite55 "
{55# $
get55% (
;55( )
private55* 1
set552 5
;555 6
}557 8

WingedEdge77 
(77 
)77 
{77 
}77 
public>> 
bool>> 
Equals>> 
(>> 

WingedEdge>> %
other>>& +
)>>+ ,
{?? 	
return@@ 
!@@ 
ReferenceEquals@@ #
(@@# $
other@@$ )
,@@) *
null@@+ /
)@@/ 0
&&@@1 3
edge@@4 8
.@@8 9
local@@9 >
.@@> ?
Equals@@? E
(@@E F
other@@F K
.@@K L
edge@@L P
.@@P Q
local@@Q V
)@@V W
;@@W X
}AA 	
publicHH 
overrideHH 
boolHH 
EqualsHH #
(HH# $
objectHH$ *
objHH+ .
)HH. /
{II 	

WingedEdgeJJ 
beJJ 
=JJ 
objJJ 
asJJ  "

WingedEdgeJJ# -
;JJ- .
ifLL 
(LL 
beLL 
!=LL 
nullLL 
&&LL 
thisLL "
.LL" #
EqualsLL# )
(LL) *
beLL* ,
)LL, -
)LL- .
returnMM 
trueMM 
;MM 
ifOO 
(OO 
objOO 
isOO 
EdgeOO 
&&OO 
thisOO #
.OO# $
edgeOO$ (
.OO( )
localOO) .
.OO. /
EqualsOO/ 5
(OO5 6
(OO6 7
EdgeOO7 ;
)OO; <
objOO< ?
)OO? @
)OO@ A
returnPP 
truePP 
;PP 
returnRR 
falseRR 
;RR 
}SS 	
publicYY 
overrideYY 
intYY 
GetHashCodeYY '
(YY' (
)YY( )
{ZZ 	
return[[ 
edge[[ 
.[[ 
local[[ 
.[[ 
GetHashCode[[ )
([[) *
)[[* +
;[[+ ,
}\\ 	
publicbb 
intbb 
Countbb 
(bb 
)bb 
{cc 	

WingedEdgedd 
currentdd 
=dd  
thisdd! %
;dd% &
intee 
countee 
=ee 
$numee 
;ee 
dogg 
{hh 
countii 
++ii 
;ii 
currentjj 
=jj 
currentjj !
.jj! "
nextjj" &
;jj& '
}kk 
whilell 
(ll 
currentll 
!=ll 
nullll "
&&ll# %
!ll& '
ReferenceEqualsll' 6
(ll6 7
currentll7 >
,ll> ?
thisll@ D
)llD E
)llE F
;llF G
returnnn 
countnn 
;nn 
}oo 	
publicrr 
overriderr 
stringrr 
ToStringrr '
(rr' (
)rr( )
{ss 	
returntt 
stringtt 
.tt 
Formattt  
(tt  !
$strtt! T
,ttT U
edgeuu 
.uu 
commonuu 
.uu 
ToStringuu $
(uu$ %
)uu% &
,uu& '
edgevv 
.vv 
localvv 
.vv 
ToStringvv #
(vv# $
)vv$ %
,vv% &
oppositeww 
==ww 
nullww  
?ww! "
$strww# )
:ww* +
oppositeww, 4
.ww4 5
edgeww5 9
.ww9 :
ToStringww: B
(wwB C
)wwC D
,wwD E
facexx 
.xx 
ToStringxx 
(xx 
)xx 
)xx  
;xx  !
}yy 	
internal
 
static
 
int
 
[
 
]
 
MakeQuad
 &
(
& '

WingedEdge
' 1
left
2 6
,
6 7

WingedEdge
8 B
right
C H
)
H I
{
‚‚ 	
if
„„ 
(
„„ 
left
„„ 
.
„„ 
Count
„„ 
(
„„ 
)
„„ 
!=
„„ 
$num
„„  !
||
„„" $
right
„„% *
.
„„* +
Count
„„+ 0
(
„„0 1
)
„„1 2
!=
„„3 5
$num
„„6 7
)
„„7 8
return
…… 
null
…… 
;
…… 

EdgeLookup
‡‡ 
[
‡‡ 
]
‡‡ 
all
‡‡ 
=
‡‡ 
new
‡‡ "

EdgeLookup
‡‡# -
[
‡‡- .
$num
‡‡. /
]
‡‡/ 0
{
ˆˆ 
left
‰‰ 
.
‰‰ 
edge
‰‰ 
,
‰‰ 
left
ŠŠ 
.
ŠŠ 
next
ŠŠ 
.
ŠŠ 
edge
ŠŠ 
,
ŠŠ 
left
‹‹ 
.
‹‹ 
next
‹‹ 
.
‹‹ 
next
‹‹ 
.
‹‹ 
edge
‹‹ #
,
‹‹# $
right
ŒŒ 
.
ŒŒ 
edge
ŒŒ 
,
ŒŒ 
right
 
.
 
next
 
.
 
edge
 
,
  
right
 
.
 
next
 
.
 
next
 
.
  
edge
  $
}
 
;
 
int
‘‘ 
[
‘‘ 
]
‘‘ 
dup
‘‘ 
=
‘‘ 
new
‘‘ 
int
‘‘ 
[
‘‘  
$num
‘‘  !
]
‘‘! "
;
‘‘" #
int
’’ 
matches
’’ 
=
’’ 
$num
’’ 
;
’’ 
for
”” 
(
”” 
int
”” 
i
”” 
=
”” 
$num
”” 
;
”” 
i
”” 
<
”” 
$num
””  !
;
””! "
i
””# $
++
””$ &
)
””& '
{
•• 
for
–– 
(
–– 
int
–– 
n
–– 
=
–– 
$num
–– 
;
–– 
n
––  !
<
––" #
$num
––$ %
;
––% &
n
––' (
++
––( *
)
––* +
{
—— 
if
˜˜ 
(
˜˜ 
all
˜˜ 
[
˜˜ 
i
˜˜ 
]
˜˜ 
.
˜˜ 
Equals
˜˜ %
(
˜˜% &
all
˜˜& )
[
˜˜) *
n
˜˜* +
]
˜˜+ ,
)
˜˜, -
)
˜˜- .
{
™™ 
matches
šš 
++
šš !
;
šš! "
dup
›› 
[
›› 
i
›› 
]
›› 
=
››  
$num
››! "
;
››" #
dup
œœ 
[
œœ 
n
œœ 
]
œœ 
=
œœ  
$num
œœ! "
;
œœ" #
break
 
;
 
}
 
}
ŸŸ 
}
   
if
££ 
(
££ 
matches
££ 
!=
££ 
$num
££ 
)
££ 
return
¤¤ 
null
¤¤ 
;
¤¤ 
int
¦¦ 
qi
¦¦ 
=
¦¦ 
$num
¦¦ 
;
¦¦ 

EdgeLookup
¨¨ 
[
¨¨ 
]
¨¨ 
edges
¨¨ 
=
¨¨  
new
¨¨! $

EdgeLookup
¨¨% /
[
¨¨/ 0
$num
¨¨0 1
]
¨¨1 2
;
¨¨2 3
for
ªª 
(
ªª 
int
ªª 
i
ªª 
=
ªª 
$num
ªª 
;
ªª 
i
ªª 
<
ªª 
$num
ªª  !
;
ªª! "
i
ªª# $
++
ªª$ &
)
ªª& '
if
«« 
(
«« 
dup
«« 
[
«« 
i
«« 
]
«« 
<
«« 
$num
«« 
)
«« 
edges
¬¬ 
[
¬¬ 
qi
¬¬ 
++
¬¬ 
]
¬¬ 
=
¬¬  !
all
¬¬" %
[
¬¬% &
i
¬¬& '
]
¬¬' (
;
¬¬( )
int
®® 
[
®® 
]
®® 
quad
®® 
=
®® 
new
®® 
int
®®  
[
®®  !
$num
®®! "
]
®®" #
{
®®$ %
edges
®®& +
[
®®+ ,
$num
®®, -
]
®®- .
.
®®. /
local
®®/ 4
.
®®4 5
a
®®5 6
,
®®6 7
edges
®®8 =
[
®®= >
$num
®®> ?
]
®®? @
.
®®@ A
local
®®A F
.
®®F G
b
®®G H
,
®®H I
-
®®J K
$num
®®K L
,
®®L M
-
®®N O
$num
®®O P
}
®®Q R
;
®®R S
int
°° 
c1
°° 
=
°° 
edges
°° 
[
°° 
$num
°° 
]
°° 
.
°° 
common
°° $
.
°°$ %
b
°°% &
,
°°& '
c2
°°( *
=
°°+ ,
-
°°- .
$num
°°. /
;
°°/ 0
if
²² 
(
²² 
edges
²² 
[
²² 
$num
²² 
]
²² 
.
²² 
common
²² 
.
²²  
a
²²  !
==
²²" $
c1
²²% '
)
²²' (
{
³³ 
quad
´´ 
[
´´ 
$num
´´ 
]
´´ 
=
´´ 
edges
´´ 
[
´´  
$num
´´  !
]
´´! "
.
´´" #
local
´´# (
.
´´( )
b
´´) *
;
´´* +
c2
µµ 
=
µµ 
edges
µµ 
[
µµ 
$num
µµ 
]
µµ 
.
µµ 
common
µµ $
.
µµ$ %
b
µµ% &
;
µµ& '
}
¶¶ 
else
·· 
if
·· 
(
·· 
edges
·· 
[
·· 
$num
·· 
]
·· 
.
·· 
common
·· $
.
··$ %
a
··% &
==
··' )
c1
··* ,
)
··, -
{
¸¸ 
quad
¹¹ 
[
¹¹ 
$num
¹¹ 
]
¹¹ 
=
¹¹ 
edges
¹¹ 
[
¹¹  
$num
¹¹  !
]
¹¹! "
.
¹¹" #
local
¹¹# (
.
¹¹( )
b
¹¹) *
;
¹¹* +
c2
ºº 
=
ºº 
edges
ºº 
[
ºº 
$num
ºº 
]
ºº 
.
ºº 
common
ºº $
.
ºº$ %
b
ºº% &
;
ºº& '
}
»» 
else
¼¼ 
if
¼¼ 
(
¼¼ 
edges
¼¼ 
[
¼¼ 
$num
¼¼ 
]
¼¼ 
.
¼¼ 
common
¼¼ $
.
¼¼$ %
a
¼¼% &
==
¼¼' )
c1
¼¼* ,
)
¼¼, -
{
½½ 
quad
¾¾ 
[
¾¾ 
$num
¾¾ 
]
¾¾ 
=
¾¾ 
edges
¾¾ 
[
¾¾  
$num
¾¾  !
]
¾¾! "
.
¾¾" #
local
¾¾# (
.
¾¾( )
b
¾¾) *
;
¾¾* +
c2
¿¿ 
=
¿¿ 
edges
¿¿ 
[
¿¿ 
$num
¿¿ 
]
¿¿ 
.
¿¿ 
common
¿¿ $
.
¿¿$ %
b
¿¿% &
;
¿¿& '
}
ÀÀ 
if
ÂÂ 
(
ÂÂ 
edges
ÂÂ 
[
ÂÂ 
$num
ÂÂ 
]
ÂÂ 
.
ÂÂ 
common
ÂÂ 
.
ÂÂ  
a
ÂÂ  !
==
ÂÂ" $
c2
ÂÂ% '
)
ÂÂ' (
quad
ÃÃ 
[
ÃÃ 
$num
ÃÃ 
]
ÃÃ 
=
ÃÃ 
edges
ÃÃ 
[
ÃÃ  
$num
ÃÃ  !
]
ÃÃ! "
.
ÃÃ" #
local
ÃÃ# (
.
ÃÃ( )
b
ÃÃ) *
;
ÃÃ* +
else
ÄÄ 
if
ÄÄ 
(
ÄÄ 
edges
ÄÄ 
[
ÄÄ 
$num
ÄÄ 
]
ÄÄ 
.
ÄÄ 
common
ÄÄ $
.
ÄÄ$ %
a
ÄÄ% &
==
ÄÄ' )
c2
ÄÄ* ,
)
ÄÄ, -
quad
ÅÅ 
[
ÅÅ 
$num
ÅÅ 
]
ÅÅ 
=
ÅÅ 
edges
ÅÅ 
[
ÅÅ  
$num
ÅÅ  !
]
ÅÅ! "
.
ÅÅ" #
local
ÅÅ# (
.
ÅÅ( )
b
ÅÅ) *
;
ÅÅ* +
else
ÆÆ 
if
ÆÆ 
(
ÆÆ 
edges
ÆÆ 
[
ÆÆ 
$num
ÆÆ 
]
ÆÆ 
.
ÆÆ 
common
ÆÆ $
.
ÆÆ$ %
a
ÆÆ% &
==
ÆÆ' )
c2
ÆÆ* ,
)
ÆÆ, -
quad
ÇÇ 
[
ÇÇ 
$num
ÇÇ 
]
ÇÇ 
=
ÇÇ 
edges
ÇÇ 
[
ÇÇ  
$num
ÇÇ  !
]
ÇÇ! "
.
ÇÇ" #
local
ÇÇ# (
.
ÇÇ( )
b
ÇÇ) *
;
ÇÇ* +
if
ÉÉ 
(
ÉÉ 
quad
ÉÉ 
[
ÉÉ 
$num
ÉÉ 
]
ÉÉ 
==
ÉÉ 
-
ÉÉ 
$num
ÉÉ 
||
ÉÉ  
quad
ÉÉ! %
[
ÉÉ% &
$num
ÉÉ& '
]
ÉÉ' (
==
ÉÉ) +
-
ÉÉ, -
$num
ÉÉ- .
)
ÉÉ. /
return
ÊÊ 
null
ÊÊ 
;
ÊÊ 
return
ÌÌ 
quad
ÌÌ 
;
ÌÌ 
}
ÍÍ 	
public
ÔÔ 

WingedEdge
ÔÔ ,
GetAdjacentEdgeWithCommonIndex
ÔÔ 8
(
ÔÔ8 9
int
ÔÔ9 <
common
ÔÔ= C
)
ÔÔC D
{
ÕÕ 	
if
ÖÖ 
(
ÖÖ 
next
ÖÖ 
.
ÖÖ 
edge
ÖÖ 
.
ÖÖ 
common
ÖÖ  
.
ÖÖ  !
Contains
ÖÖ! )
(
ÖÖ) *
common
ÖÖ* 0
)
ÖÖ0 1
)
ÖÖ1 2
return
×× 
next
×× 
;
×× 
else
ØØ 
if
ØØ 
(
ØØ 
previous
ØØ 
.
ØØ 
edge
ØØ "
.
ØØ" #
common
ØØ# )
.
ØØ) *
Contains
ØØ* 2
(
ØØ2 3
common
ØØ3 9
)
ØØ9 :
)
ØØ: ;
return
ÙÙ 
previous
ÙÙ 
;
ÙÙ  
return
ÛÛ 
null
ÛÛ 
;
ÛÛ 
}
ÜÜ 	
public
ää 
static
ää 
List
ää 
<
ää 
Edge
ää 
>
ää  "
SortEdgesByAdjacency
ää! 5
(
ää5 6
Face
ää6 :
face
ää; ?
)
ää? @
{
åå 	
if
ææ 
(
ææ 
face
ææ 
==
ææ 
null
ææ 
||
ææ 
face
ææ  $
.
ææ$ %
edgesInternal
ææ% 2
==
ææ3 5
null
ææ6 :
)
ææ: ;
throw
çç 
new
çç #
ArgumentNullException
çç /
(
çç/ 0
$str
çç0 6
)
çç6 7
;
çç7 8
List
èè 
<
èè 
Edge
èè 
>
èè 
edges
èè 
=
èè 
new
èè "
List
èè# '
<
èè' (
Edge
èè( ,
>
èè, -
(
èè- .
face
èè. 2
.
èè2 3
edgesInternal
èè3 @
)
èè@ A
;
èèA B"
SortEdgesByAdjacency
éé  
(
éé  !
edges
éé! &
)
éé& '
;
éé' (
return
êê 
edges
êê 
;
êê 
}
ëë 	
public
ññ 
static
ññ 
void
ññ "
SortEdgesByAdjacency
ññ /
(
ññ/ 0
List
ññ0 4
<
ññ4 5
Edge
ññ5 9
>
ññ9 :
edges
ññ; @
)
ññ@ A
{
òò 	
if
óó 
(
óó 
edges
óó 
==
óó 
null
óó 
)
óó 
throw
ôô 
new
ôô #
ArgumentNullException
ôô /
(
ôô/ 0
$str
ôô0 7
)
ôô7 8
;
ôô8 9
for
öö 
(
öö 
int
öö 
i
öö 
=
öö 
$num
öö 
;
öö 
i
öö 
<
öö 
edges
öö  %
.
öö% &
Count
öö& +
;
öö+ ,
i
öö- .
++
öö. 0
)
öö0 1
{
÷÷ 
int
øø 
want
øø 
=
øø 
edges
øø  
[
øø  !
i
øø! "
-
øø# $
$num
øø% &
]
øø& '
.
øø' (
b
øø( )
;
øø) *
for
úú 
(
úú 
int
úú 
n
úú 
=
úú 
i
úú 
+
úú  
$num
úú! "
;
úú" #
n
úú$ %
<
úú& '
edges
úú( -
.
úú- .
Count
úú. 3
;
úú3 4
n
úú5 6
++
úú6 8
)
úú8 9
{
ûû 
if
üü 
(
üü 
edges
üü 
[
üü 
n
üü 
]
üü  
.
üü  !
a
üü! "
==
üü# %
want
üü& *
||
üü+ -
edges
üü. 3
[
üü3 4
n
üü4 5
]
üü5 6
.
üü6 7
b
üü7 8
==
üü9 ;
want
üü< @
)
üü@ A
{
ıı 
Edge
şş 
swap
şş !
=
şş" #
edges
şş$ )
[
şş) *
n
şş* +
]
şş+ ,
;
şş, -
edges
ÿÿ 
[
ÿÿ 
n
ÿÿ 
]
ÿÿ  
=
ÿÿ! "
edges
ÿÿ# (
[
ÿÿ( )
i
ÿÿ) *
]
ÿÿ* +
;
ÿÿ+ ,
edges
€€ 
[
€€ 
i
€€ 
]
€€  
=
€€! "
swap
€€# '
;
€€' (
}
 
}
‚‚ 
}
ƒƒ 
}
„„ 	
public
‹‹ 
static
‹‹ 

Dictionary
‹‹  
<
‹‹  !
int
‹‹! $
,
‹‹$ %
List
‹‹& *
<
‹‹* +

WingedEdge
‹‹+ 5
>
‹‹5 6
>
‹‹6 7
	GetSpokes
‹‹8 A
(
‹‹A B
List
‹‹B F
<
‹‹F G

WingedEdge
‹‹G Q
>
‹‹Q R
wings
‹‹S X
)
‹‹X Y
{
ŒŒ 	
if
 
(
 
wings
 
==
 
null
 
)
 
throw
 
new
 #
ArgumentNullException
 /
(
/ 0
$str
0 7
)
7 8
;
8 9

Dictionary
 
<
 
int
 
,
 
List
  
<
  !

WingedEdge
! +
>
+ ,
>
, -
spokes
. 4
=
5 6
new
7 :

Dictionary
; E
<
E F
int
F I
,
I J
List
K O
<
O P

WingedEdge
P Z
>
Z [
>
[ \
(
\ ]
)
] ^
;
^ _
List
‘‘ 
<
‘‘ 

WingedEdge
‘‘ 
>
‘‘ 
l
‘‘ 
=
‘‘  
null
‘‘! %
;
‘‘% &
for
““ 
(
““ 
int
““ 
i
““ 
=
““ 
$num
““ 
;
““ 
i
““ 
<
““ 
wings
““  %
.
““% &
Count
““& +
;
““+ ,
i
““- .
++
““. 0
)
““0 1
{
”” 
if
•• 
(
•• 
spokes
•• 
.
•• 
TryGetValue
•• &
(
••& '
wings
••' ,
[
••, -
i
••- .
]
••. /
.
••/ 0
edge
••0 4
.
••4 5
common
••5 ;
.
••; <
a
••< =
,
••= >
out
••? B
l
••C D
)
••D E
)
••E F
l
–– 
.
–– 
Add
–– 
(
–– 
wings
–– 
[
––  
i
––  !
]
––! "
)
––" #
;
––# $
else
—— 
spokes
˜˜ 
.
˜˜ 
Add
˜˜ 
(
˜˜ 
wings
˜˜ $
[
˜˜$ %
i
˜˜% &
]
˜˜& '
.
˜˜' (
edge
˜˜( ,
.
˜˜, -
common
˜˜- 3
.
˜˜3 4
a
˜˜4 5
,
˜˜5 6
new
˜˜7 :
List
˜˜; ?
<
˜˜? @

WingedEdge
˜˜@ J
>
˜˜J K
(
˜˜K L
)
˜˜L M
{
˜˜N O
wings
˜˜P U
[
˜˜U V
i
˜˜V W
]
˜˜W X
}
˜˜Y Z
)
˜˜Z [
;
˜˜[ \
if
šš 
(
šš 
spokes
šš 
.
šš 
TryGetValue
šš &
(
šš& '
wings
šš' ,
[
šš, -
i
šš- .
]
šš. /
.
šš/ 0
edge
šš0 4
.
šš4 5
common
šš5 ;
.
šš; <
b
šš< =
,
šš= >
out
šš? B
l
ššC D
)
ššD E
)
ššE F
l
›› 
.
›› 
Add
›› 
(
›› 
wings
›› 
[
››  
i
››  !
]
››! "
)
››" #
;
››# $
else
œœ 
spokes
 
.
 
Add
 
(
 
wings
 $
[
$ %
i
% &
]
& '
.
' (
edge
( ,
.
, -
common
- 3
.
3 4
b
4 5
,
5 6
new
7 :
List
; ?
<
? @

WingedEdge
@ J
>
J K
(
K L
)
L M
{
N O
wings
P U
[
U V
i
V W
]
W X
}
Y Z
)
Z [
;
[ \
}
 
return
   
spokes
   
;
   
}
¡¡ 	
internal
«« 
static
«« 
List
«« 
<
«« 
int
««  
>
««  !*
SortCommonIndexesByAdjacency
««" >
(
««> ?
List
««? C
<
««C D

WingedEdge
««D N
>
««N O
wings
««P U
,
««U V
HashSet
««W ^
<
««^ _
int
««_ b
>
««b c
common
««d j
)
««j k
{
¬¬ 	
List
­­ 
<
­­ 
Edge
­­ 
>
­­ 
matches
­­ 
=
­­  
wings
­­! &
.
­­& '
Where
­­' ,
(
­­, -
x
­­- .
=>
­­/ 1
common
­­2 8
.
­­8 9
Contains
­­9 A
(
­­A B
x
­­B C
.
­­C D
edge
­­D H
.
­­H I
common
­­I O
.
­­O P
a
­­P Q
)
­­Q R
&&
­­S U
common
­­V \
.
­­\ ]
Contains
­­] e
(
­­e f
x
­­f g
.
­­g h
edge
­­h l
.
­­l m
common
­­m s
.
­­s t
b
­­t u
)
­­u v
)
­­v w
.
­­w x
Select
­­x ~
(
­­~ 
y­­ €
=>­­ ƒ
y­­„ …
.­­… †
edge­­† Š
.­­Š ‹
common­­‹ ‘
)­­‘ ’
.­­’ “
ToList­­“ ™
(­­™ š
)­­š ›
;­­› œ
if
°° 
(
°° 
matches
°° 
.
°° 
Count
°° 
!=
°°  
common
°°! '
.
°°' (
Count
°°( -
)
°°- .
return
±± 
null
±± 
;
±± "
SortEdgesByAdjacency
³³  
(
³³  !
matches
³³! (
)
³³( )
;
³³) *
return
´´ 
matches
´´ 
.
´´ 
Select
´´ !
(
´´! "
x
´´" #
=>
´´$ &
x
´´' (
.
´´( )
a
´´) *
)
´´* +
.
´´+ ,
ToList
´´, 2
(
´´2 3
)
´´3 4
;
´´4 5
}
µµ 	
public
½½ 
static
½½ 
List
½½ 
<
½½ 

WingedEdge
½½ %
>
½½% &
GetWingedEdges
½½' 5
(
½½5 6
ProBuilderMesh
½½6 D
mesh
½½E I
,
½½I J
bool
½½K O
oneWingPerFace
½½P ^
=
½½_ `
false
½½a f
)
½½f g
{
¾¾ 	
if
¿¿ 
(
¿¿ 
mesh
¿¿ 
==
¿¿ 
null
¿¿ 
)
¿¿ 
throw
ÀÀ 
new
ÀÀ #
ArgumentNullException
ÀÀ /
(
ÀÀ/ 0
$str
ÀÀ0 6
)
ÀÀ6 7
;
ÀÀ7 8
return
ÂÂ 
GetWingedEdges
ÂÂ !
(
ÂÂ! "
mesh
ÂÂ" &
,
ÂÂ& '
mesh
ÂÂ( ,
.
ÂÂ, -
facesInternal
ÂÂ- :
,
ÂÂ: ;
oneWingPerFace
ÂÂ< J
)
ÂÂJ K
;
ÂÂK L
}
ÃÃ 	
public
ÌÌ 
static
ÌÌ 
List
ÌÌ 
<
ÌÌ 

WingedEdge
ÌÌ %
>
ÌÌ% &
GetWingedEdges
ÌÌ' 5
(
ÌÌ5 6
ProBuilderMesh
ÌÌ6 D
mesh
ÌÌE I
,
ÌÌI J
IEnumerable
ÌÌK V
<
ÌÌV W
Face
ÌÌW [
>
ÌÌ[ \
faces
ÌÌ] b
,
ÌÌb c
bool
ÌÌd h
oneWingPerFace
ÌÌi w
=
ÌÌx y
false
ÌÌz 
)ÌÌ €
{
ÍÍ 	
if
ÎÎ 
(
ÎÎ 
mesh
ÎÎ 
==
ÎÎ 
null
ÎÎ 
)
ÎÎ 
throw
ÏÏ 
new
ÏÏ #
ArgumentNullException
ÏÏ /
(
ÏÏ/ 0
$str
ÏÏ0 6
)
ÏÏ6 7
;
ÏÏ7 8
var
ÑÑ 
lookup
ÑÑ 
=
ÑÑ 
mesh
ÑÑ 
.
ÑÑ  
sharedVertexLookup
ÑÑ 0
;
ÑÑ0 1
List
ÓÓ 
<
ÓÓ 

WingedEdge
ÓÓ 
>
ÓÓ 
winged
ÓÓ #
=
ÓÓ$ %
new
ÓÓ& )
List
ÓÓ* .
<
ÓÓ. /

WingedEdge
ÓÓ/ 9
>
ÓÓ9 :
(
ÓÓ: ;
)
ÓÓ; <
;
ÓÓ< =&
k_OppositeEdgeDictionary
ÔÔ $
.
ÔÔ$ %
Clear
ÔÔ% *
(
ÔÔ* +
)
ÔÔ+ ,
;
ÔÔ, -
foreach
ÖÖ 
(
ÖÖ 
Face
ÖÖ 
f
ÖÖ 
in
ÖÖ 
faces
ÖÖ $
)
ÖÖ$ %
{
×× 
List
ØØ 
<
ØØ 
Edge
ØØ 
>
ØØ 
edges
ØØ  
=
ØØ! ""
SortEdgesByAdjacency
ØØ# 7
(
ØØ7 8
f
ØØ8 9
)
ØØ9 :
;
ØØ: ;
int
ÙÙ 

edgeLength
ÙÙ 
=
ÙÙ  
edges
ÙÙ! &
.
ÙÙ& '
Count
ÙÙ' ,
;
ÙÙ, -

WingedEdge
ÚÚ 
first
ÚÚ  
=
ÚÚ! "
null
ÚÚ# '
,
ÚÚ' (
prev
ÚÚ) -
=
ÚÚ. /
null
ÚÚ0 4
;
ÚÚ4 5
for
ÜÜ 
(
ÜÜ 
int
ÜÜ 
n
ÜÜ 
=
ÜÜ 
$num
ÜÜ 
;
ÜÜ 
n
ÜÜ  !
<
ÜÜ" #

edgeLength
ÜÜ$ .
;
ÜÜ. /
n
ÜÜ0 1
++
ÜÜ1 3
)
ÜÜ3 4
{
İİ 
Edge
ŞŞ 
e
ŞŞ 
=
ŞŞ 
edges
ŞŞ "
[
ŞŞ" #
n
ŞŞ# $
]
ŞŞ$ %
;
ŞŞ% &

WingedEdge
àà 
w
àà  
=
àà! "
new
àà# &

WingedEdge
àà' 1
(
àà1 2
)
àà2 3
;
àà3 4
w
áá 
.
áá 
edge
áá 
=
áá 
new
áá  

EdgeLookup
áá! +
(
áá+ ,
lookup
áá, 2
[
áá2 3
e
áá3 4
.
áá4 5
a
áá5 6
]
áá6 7
,
áá7 8
lookup
áá9 ?
[
áá? @
e
áá@ A
.
ááA B
b
ááB C
]
ááC D
,
ááD E
e
ááF G
.
ááG H
a
ááH I
,
ááI J
e
ááK L
.
ááL M
b
ááM N
)
ááN O
;
ááO P
w
ââ 
.
ââ 
face
ââ 
=
ââ 
f
ââ 
;
ââ 
if
ãã 
(
ãã 
n
ãã 
<
ãã 
$num
ãã 
)
ãã 
first
ää 
=
ää 
w
ää  !
;
ää! "
if
ææ 
(
ææ 
n
ææ 
>
ææ 
$num
ææ 
)
ææ 
{
çç 
w
èè 
.
èè 
previous
èè "
=
èè# $
prev
èè% )
;
èè) *
prev
éé 
.
éé 
next
éé !
=
éé" #
w
éé$ %
;
éé% &
}
êê 
if
ìì 
(
ìì 
n
ìì 
==
ìì 

edgeLength
ìì '
-
ìì( )
$num
ìì* +
)
ìì+ ,
{
íí 
w
îî 
.
îî 
next
îî 
=
îî  
first
îî! &
;
îî& '
first
ïï 
.
ïï 
previous
ïï &
=
ïï' (
w
ïï) *
;
ïï* +
}
ğğ 
prev
òò 
=
òò 
w
òò 
;
òò 

WingedEdge
ôô 
opp
ôô "
;
ôô" #
if
öö 
(
öö &
k_OppositeEdgeDictionary
öö 0
.
öö0 1
TryGetValue
öö1 <
(
öö< =
w
öö= >
.
öö> ?
edge
öö? C
.
ööC D
common
ööD J
,
ööJ K
out
ööL O
opp
ööP S
)
ööS T
)
ööT U
{
÷÷ 
opp
øø 
.
øø 
opposite
øø $
=
øø% &
w
øø' (
;
øø( )
w
ùù 
.
ùù 
opposite
ùù "
=
ùù# $
opp
ùù% (
;
ùù( )
}
úú 
else
ûû 
{
üü 
w
ıı 
.
ıı 
opposite
ıı "
=
ıı# $
null
ıı% )
;
ıı) *&
k_OppositeEdgeDictionary
şş 0
.
şş0 1
Add
şş1 4
(
şş4 5
w
şş5 6
.
şş6 7
edge
şş7 ;
.
şş; <
common
şş< B
,
şşB C
w
şşD E
)
şşE F
;
şşF G
}
ÿÿ 
if
 
(
 
!
 
oneWingPerFace
 '
||
( *
n
+ ,
<
- .
$num
/ 0
)
0 1
winged
‚‚ 
.
‚‚ 
Add
‚‚ "
(
‚‚" #
w
‚‚# $
)
‚‚$ %
;
‚‚% &
}
ƒƒ 
}
„„ 
return
†† 
winged
†† 
;
†† 
}
‡‡ 	
}
ˆˆ 
}‰‰ €[
…D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Edge.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[

 
System

 
.

 
Serializable

 
]

 
public 

struct 
Edge 
: 
System 
.  

IEquatable  *
<* +
Edge+ /
>/ 0
{ 
public 
int 
a 
; 
public 
int 
b 
; 
public 
static 
readonly 
Edge #
Empty$ )
=* +
new, /
Edge0 4
(4 5
-5 6
$num6 7
,7 8
-9 :
$num: ;
); <
;< =
public!! 
Edge!! 
(!! 
int!! 
a!! 
,!! 
int!! 
b!!  
)!!  !
{"" 	
this## 
.## 
a## 
=## 
a## 
;## 
this$$ 
.$$ 
b$$ 
=$$ 
b$$ 
;$$ 
}%% 	
public++ 
bool++ 
IsValid++ 
(++ 
)++ 
{,, 	
return-- 
a-- 
>-- 
--- 
$num-- 
&&-- 
b-- 
>--  
---! "
$num--" #
&&--$ &
a--' (
!=--) +
b--, -
;--- .
}.. 	
public00 
override00 
string00 
ToString00 '
(00' (
)00( )
{11 	
return22 
$str22 
+22 
a22 
+22 
$str22 !
+22" #
b22$ %
+22& '
$str22( +
;22+ ,
}33 	
public55 
bool55 
Equals55 
(55 
Edge55 
other55  %
)55% &
{66 	
return77 
(77 
a77 
==77 
other77 
.77 
a77  
&&77! #
b77$ %
==77& (
other77) .
.77. /
b77/ 0
)770 1
||772 4
(775 6
a776 7
==778 :
other77; @
.77@ A
b77A B
&&77C E
b77F G
==77H J
other77K P
.77P Q
a77Q R
)77R S
;77S T
}88 	
public:: 
override:: 
bool:: 
Equals:: #
(::# $
object::$ *
obj::+ .
)::. /
{;; 	
return<< 
obj<< 
is<< 
Edge<< 
&&<< !
Equals<<" (
(<<( )
(<<) *
Edge<<* .
)<<. /
obj<</ 2
)<<2 3
;<<3 4
}== 	
public?? 
override?? 
int?? 
GetHashCode?? '
(??' (
)??( )
{@@ 	
intBB 
hashBB 
=BB 
$numBB 
;BB 
	uncheckedDD 
{EE 
hashFF 
=FF 
hashFF 
*FF 
$numFF  
+FF! "
(FF# $
aFF$ %
<FF& '
bFF( )
?FF* +
aFF, -
:FF. /
bFF0 1
)FF1 2
;FF2 3
hashGG 
=GG 
hashGG 
*GG 
$numGG  
+GG! "
(GG# $
aGG$ %
<GG& '
bGG( )
?GG* +
bGG, -
:GG. /
aGG0 1
)GG1 2
;GG2 3
}HH 
returnJJ 
hashJJ 
;JJ 
}KK 	
publicMM 
staticMM 
EdgeMM 
operatorMM #
+MM# $
(MM$ %
EdgeMM% )
aMM* +
,MM+ ,
EdgeMM- 1
bMM2 3
)MM3 4
{NN 	
returnOO 
newOO 
EdgeOO 
(OO 
aOO 
.OO 
aOO 
+OO  !
bOO" #
.OO# $
aOO$ %
,OO% &
aOO' (
.OO( )
bOO) *
+OO+ ,
bOO- .
.OO. /
bOO/ 0
)OO0 1
;OO1 2
}PP 	
publicRR 
staticRR 
EdgeRR 
operatorRR #
-RR# $
(RR$ %
EdgeRR% )
aRR* +
,RR+ ,
EdgeRR- 1
bRR2 3
)RR3 4
{SS 	
returnTT 
newTT 
EdgeTT 
(TT 
aTT 
.TT 
aTT 
-TT  !
bTT" #
.TT# $
aTT$ %
,TT% &
aTT' (
.TT( )
bTT) *
-TT+ ,
bTT- .
.TT. /
bTT/ 0
)TT0 1
;TT1 2
}UU 	
publicWW 
staticWW 
EdgeWW 
operatorWW #
+WW# $
(WW$ %
EdgeWW% )
aWW* +
,WW+ ,
intWW- 0
bWW1 2
)WW2 3
{XX 	
returnYY 
newYY 
EdgeYY 
(YY 
aYY 
.YY 
aYY 
+YY  !
bYY" #
,YY# $
aYY% &
.YY& '
bYY' (
+YY) *
bYY+ ,
)YY, -
;YY- .
}ZZ 	
public\\ 
static\\ 
Edge\\ 
operator\\ #
-\\# $
(\\$ %
Edge\\% )
a\\* +
,\\+ ,
int\\- 0
b\\1 2
)\\2 3
{]] 	
return^^ 
new^^ 
Edge^^ 
(^^ 
a^^ 
.^^ 
a^^ 
-^^  !
b^^" #
,^^# $
a^^% &
.^^& '
b^^' (
-^^) *
b^^+ ,
)^^, -
;^^- .
}__ 	
publicaa 
staticaa 
boolaa 
operatoraa #
==aa# %
(aa% &
Edgeaa& *
aaa+ ,
,aa, -
Edgeaa. 2
baa3 4
)aa4 5
{bb 	
returncc 
acc 
.cc 
Equalscc 
(cc 
bcc 
)cc 
;cc 
}dd 	
publicff 
staticff 
boolff 
operatorff #
!=ff# %
(ff% &
Edgeff& *
aff+ ,
,ff, -
Edgeff. 2
bff3 4
)ff4 5
{gg 	
returnhh 
!hh 
(hh 
ahh 
==hh 
bhh 
)hh 
;hh 
}ii 	
publictt 
statictt 
Edgett 
Addtt 
(tt 
Edgett #
att$ %
,tt% &
Edgett' +
btt, -
)tt- .
{uu 	
returnvv 
avv 
+vv 
bvv 
;vv 
}ww 	
public
‚‚ 
static
‚‚ 
Edge
‚‚ 
Subtract
‚‚ #
(
‚‚# $
Edge
‚‚$ (
a
‚‚) *
,
‚‚* +
Edge
‚‚, 0
b
‚‚1 2
)
‚‚2 3
{
ƒƒ 	
return
„„ 
a
„„ 
-
„„ 
b
„„ 
;
„„ 
}
…… 	
public
 
bool
 
Equals
 
(
 
Edge
 
other
  %
,
% &

Dictionary
' 1
<
1 2
int
2 5
,
5 6
int
7 :
>
: ;
lookup
< B
)
B C
{
 	
if
 
(
 
lookup
 
==
 
null
 
)
 
return
‘‘ 
Equals
‘‘ 
(
‘‘ 
other
‘‘ #
)
‘‘# $
;
‘‘$ %
int
’’ 
x0
’’ 
=
’’ 
lookup
’’ 
[
’’ 
a
’’ 
]
’’ 
,
’’ 
y0
’’  "
=
’’# $
lookup
’’% +
[
’’+ ,
b
’’, -
]
’’- .
,
’’. /
x1
’’0 2
=
’’3 4
lookup
’’5 ;
[
’’; <
other
’’< A
.
’’A B
a
’’B C
]
’’C D
,
’’D E
y1
’’F H
=
’’I J
lookup
’’K Q
[
’’Q R
other
’’R W
.
’’W X
b
’’X Y
]
’’Y Z
;
’’Z [
return
““ 
(
““ 
x0
““ 
==
““ 
x1
““ 
&&
““ 
y0
““  "
==
““# %
y1
““& (
)
““( )
||
““* ,
(
““- .
x0
““. 0
==
““1 3
y1
““4 6
&&
““7 9
y0
““: <
==
““= ?
x1
““@ B
)
““B C
;
““C D
}
”” 	
public
›› 
bool
›› 
Contains
›› 
(
›› 
int
››  
index
››! &
)
››& '
{
œœ 	
return
 
(
 
a
 
==
 
index
 
||
 !
b
" #
==
$ &
index
' ,
)
, -
;
- .
}
 	
public
¥¥ 
bool
¥¥ 
Contains
¥¥ 
(
¥¥ 
Edge
¥¥ !
other
¥¥" '
)
¥¥' (
{
¦¦ 	
return
§§ 
(
§§ 
a
§§ 
==
§§ 
other
§§ 
.
§§ 
a
§§  
||
§§! #
b
§§$ %
==
§§& (
other
§§) .
.
§§. /
a
§§/ 0
||
§§1 3
a
§§4 5
==
§§6 8
other
§§9 >
.
§§> ?
b
§§? @
||
§§A C
b
§§D E
==
§§F H
other
§§I N
.
§§N O
a
§§O P
)
§§P Q
;
§§Q R
}
¨¨ 	
internal
ªª 
bool
ªª 
Contains
ªª 
(
ªª 
int
ªª "
index
ªª# (
,
ªª( )

Dictionary
ªª* 4
<
ªª4 5
int
ªª5 8
,
ªª8 9
int
ªª: =
>
ªª= >
lookup
ªª? E
)
ªªE F
{
«« 	
var
¬¬ 
common
¬¬ 
=
¬¬ 
lookup
¬¬ 
[
¬¬  
index
¬¬  %
]
¬¬% &
;
¬¬& '
return
­­ 
lookup
­­ 
[
­­ 
a
­­ 
]
­­ 
==
­­ 
common
­­  &
||
­­' )
lookup
­­* 0
[
­­0 1
b
­­1 2
]
­­2 3
==
­­4 6
common
­­7 =
;
­­= >
}
®® 	
internal
°° 
static
°° 
void
°° 

GetIndices
°° '
(
°°' (
IEnumerable
°°( 3
<
°°3 4
Edge
°°4 8
>
°°8 9
edges
°°: ?
,
°°? @
List
°°A E
<
°°E F
int
°°F I
>
°°I J
indices
°°K R
)
°°R S
{
±± 	
indices
²² 
.
²² 
Clear
²² 
(
²² 
)
²² 
;
²² 
foreach
´´ 
(
´´ 
var
´´ 
edge
´´ 
in
´´  
edges
´´! &
)
´´& '
{
µµ 
indices
¶¶ 
.
¶¶ 
Add
¶¶ 
(
¶¶ 
edge
¶¶  
.
¶¶  !
a
¶¶! "
)
¶¶" #
;
¶¶# $
indices
·· 
.
·· 
Add
·· 
(
·· 
edge
··  
.
··  !
b
··! "
)
··" #
;
··# $
}
¸¸ 
}
¹¹ 	
}
ºº 
}»» ¥~
‘D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\BuiltinMaterials.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

static 
class 
BuiltinMaterials (
{ 
static 
bool 
s_IsInitialized #
;# $
public 
const 
string 

faceShader &
=' (
$str) J
;J K
public 
const 
string 

lineShader &
=' (
$str) J
;J K
public"" 
const"" 
string"" 
lineShaderMetal"" +
="", -
$str"". T
;""T U
public++ 
const++ 
string++ 
pointShader++ '
=++( )
$str++* L
;++L M
public11 
const11 
string11 

wireShader11 &
=11' (
$str11) J
;11J K
public77 
const77 
string77 
	dotShader77 %
=77& '
$str77( H
;77H I
internal99 
static99 
readonly99  
Color99! &
previewColor99' 3
=994 5
new996 9
Color99: ?
(99? @
$num99@ C
,99C D
$num99E H
,99H I
$num99J L
,99L M
$num99N R
)99R S
;99S T
static;; 
Shader;; #
s_SelectionPickerShader;; -
;;;- .
static== 
bool== &
s_GeometryShadersSupported== .
;==. /
static?? 
Material?? 
s_DefaultMaterial?? )
;??) *
static@@ 
Material@@  
s_FacePickerMaterial@@ ,
;@@, -
staticAA 
MaterialAA "
s_VertexPickerMaterialAA .
;AA. /
staticBB 
MaterialBB  
s_EdgePickerMaterialBB ,
;BB, -
staticCC 
MaterialCC !
s_UnityDefaultDiffuseCC -
;CC- .
staticDD 
MaterialDD &
s_UnlitVertexColorMaterialDD 2
;DD2 3
staticEE 
MaterialEE "
s_ShapePreviewMaterialEE .
;EE. /
staticQQ 
stringQQ  
k_EdgePickerMaterialQQ *
=QQ+ ,
$strQQ- C
;QQC D
staticRR 
stringRR  
k_FacePickerMaterialRR *
=RR+ ,
$strRR- C
;RRC D
staticSS 
stringSS "
k_VertexPickerMaterialSS ,
=SS- .
$strSS/ G
;SSG H
staticUU 
stringUU 
k_EdgePickerShaderUU (
=UU) *
$strUU+ I
;UUI J
staticVV 
stringVV 
k_FacePickerShaderVV (
=VV) *
$strVV+ I
;VVI J
staticWW 
stringWW  
k_VertexPickerShaderWW *
=WW+ ,
$strWW- M
;WWM N
staticZZ 
voidZZ 
InitZZ 
(ZZ 
)ZZ 
{[[ 	
if\\ 
(\\ 
s_IsInitialized\\ 
)\\  
return]] 
;]] 
s_IsInitialized__ 
=__ 
true__ "
;__" #
varaa 
geoaa 
=aa 
Shaderaa 
.aa 
Findaa !
(aa! "

lineShaderaa" ,
)aa, -
;aa- .&
s_GeometryShadersSupportedbb &
=bb' (
geobb) ,
!=bb- /
nullbb0 4
&&bb5 7
geobb8 ;
.bb; <
isSupportedbb< G
;bbG H
s_DefaultMaterialdd 
=dd 
GetDefaultMaterialdd  2
(dd2 3
)dd3 4
;dd4 5#
s_SelectionPickerShadergg #
=gg$ %
(gg& '
Shadergg' -
)gg- .
Shadergg. 4
.gg4 5
Findgg5 9
(gg9 :
$strgg: ]
)gg] ^
;gg^ _
ifii 
(ii 
(ii  
s_FacePickerMaterialii %
=ii& '
	Resourcesii( 1
.ii1 2
Loadii2 6
<ii6 7
Materialii7 ?
>ii? @
(ii@ A 
k_FacePickerMaterialiiA U
)iiU V
)iiV W
==iiX Z
nullii[ _
)ii_ `
{jj 
Logkk 
.kk 
Errorkk 
(kk 
$strkk m
)kkm n
;kkn o 
s_FacePickerMaterialll $
=ll% &
newll' *
Materialll+ 3
(ll3 4
Shaderll4 :
.ll: ;
Findll; ?
(ll? @
k_FacePickerShaderll@ R
)llR S
)llS T
;llT U
}mm 
ifoo 
(oo 
(oo "
s_VertexPickerMaterialoo '
=oo( )
	Resourcesoo* 3
.oo3 4
Loadoo4 8
<oo8 9
Materialoo9 A
>ooA B
(ooB C"
k_VertexPickerMaterialooC Y
)ooY Z
)ooZ [
==oo\ ^
nulloo_ c
)ooc d
{pp 
Logqq 
.qq 
Errorqq 
(qq 
$strqq o
)qqo p
;qqp q"
s_VertexPickerMaterialrr &
=rr' (
newrr) ,
Materialrr- 5
(rr5 6
Shaderrr6 <
.rr< =
Findrr= A
(rrA B 
k_VertexPickerShaderrrB V
)rrV W
)rrW X
;rrX Y
}ss 	
ifuu 
(uu 
(uu  
s_EdgePickerMaterialuu %
=uu& '
	Resourcesuu( 1
.uu1 2
Loaduu2 6
<uu6 7
Materialuu7 ?
>uu? @
(uu@ A 
k_EdgePickerMaterialuuA U
)uuU V
)uuV W
==uuX Z
nulluu[ _
)uu_ `
{vv 
Logww 
.ww 
Errorww 
(ww 
$strww m
)wwm n
;wwn o 
s_EdgePickerMaterialxx $
=xx% &
newxx' *
Materialxx+ 3
(xx3 4
Shaderxx4 :
.xx: ;
Findxx; ?
(xx? @
k_EdgePickerShaderxx@ R
)xxR S
)xxS T
;xxT U
}yy &
s_UnlitVertexColorMaterial{{ &
={{' (
({{) *
Material{{* 2
){{2 3
	Resources{{3 <
.{{< =
Load{{= A
({{A B
$str{{B ^
,{{^ _
typeof{{` f
({{f g
Material{{g o
){{o p
){{p q
;{{q r"
s_ShapePreviewMaterial}} "
=}}# $
new}}% (
Material}}) 1
(}}1 2
s_DefaultMaterial}}2 C
.}}C D
shader}}D J
)}}J K
;}}K L"
s_ShapePreviewMaterial~~ "
.~~" #
	hideFlags~~# ,
=~~- .
	HideFlags~~/ 8
.~~8 9
HideAndDontSave~~9 H
;~~H I
if
€€ 
(
€€ $
s_ShapePreviewMaterial
€€ &
.
€€& '
HasProperty
€€' 2
(
€€2 3
$str
€€3 =
)
€€= >
)
€€> ?$
s_ShapePreviewMaterial
 &
.
& '
mainTexture
' 2
=
3 4
(
5 6
	Texture2D
6 ?
)
? @
	Resources
@ I
.
I J
Load
J N
(
N O
$str
O i
)
i j
;
j k
if
ƒƒ 
(
ƒƒ $
s_ShapePreviewMaterial
ƒƒ &
.
ƒƒ& '
HasProperty
ƒƒ' 2
(
ƒƒ2 3
$str
ƒƒ3 ;
)
ƒƒ; <
)
ƒƒ< =$
s_ShapePreviewMaterial
„„ &
.
„„& '
SetColor
„„' /
(
„„/ 0
$str
„„0 8
,
„„8 9
previewColor
„„: F
)
„„F G
;
„„G H
}
…… 	
public
ŠŠ 
static
ŠŠ 
bool
ŠŠ &
geometryShadersSupported
ŠŠ 3
{
‹‹ 	
get
ŒŒ 
{
 
Init
 
(
 
)
 
;
 
return
 (
s_GeometryShadersSupported
 1
;
1 2
}
 
}
‘‘ 	
public
™™ 
static
™™ 
Material
™™ 
defaultMaterial
™™ .
{
šš 	
get
›› 
{
œœ 
Init
 
(
 
)
 
;
 
return
 
s_DefaultMaterial
 (
;
( )
}
ŸŸ 
}
   	
internal
¥¥ 
static
¥¥ 
Shader
¥¥ #
selectionPickerShader
¥¥ 4
{
¦¦ 	
get
§§ 
{
¨¨ 
Init
©© 
(
©© 
)
©© 
;
©© 
return
ªª %
s_SelectionPickerShader
ªª .
;
ªª. /
}
«« 
}
¬¬ 	
internal
±± 
static
±± 
Material
±±   
facePickerMaterial
±±! 3
{
²² 	
get
³³ 
{
´´ 
Init
µµ 
(
µµ 
)
µµ 
;
µµ 
return
¶¶ "
s_FacePickerMaterial
¶¶ +
;
¶¶+ ,
}
·· 
}
¸¸ 	
internal
½½ 
static
½½ 
Material
½½  "
vertexPickerMaterial
½½! 5
{
¾¾ 	
get
¿¿ 
{
ÀÀ 
Init
ÁÁ 
(
ÁÁ 
)
ÁÁ 
;
ÁÁ 
return
ÂÂ $
s_VertexPickerMaterial
ÂÂ -
;
ÂÂ- .
}
ÃÃ 
}
ÄÄ 	
internal
ÉÉ 
static
ÉÉ 
Material
ÉÉ   
edgePickerMaterial
ÉÉ! 3
{
ÊÊ 	
get
ËË 
{
ÌÌ 
Init
ÍÍ 
(
ÍÍ 
)
ÍÍ 
;
ÍÍ 
return
ÎÎ "
s_EdgePickerMaterial
ÎÎ +
;
ÎÎ+ ,
}
ÏÏ 
}
ĞĞ 	
internal
ÕÕ 
static
ÕÕ 
Material
ÕÕ  
triggerMaterial
ÕÕ! 0
{
ÖÖ 	
get
×× 
{
ØØ 
Init
ÙÙ 
(
ÙÙ 
)
ÙÙ 
;
ÙÙ 
return
ÚÚ 
(
ÚÚ 
Material
ÚÚ  
)
ÚÚ  !
	Resources
ÚÚ! *
.
ÚÚ* +
Load
ÚÚ+ /
(
ÚÚ/ 0
$str
ÚÚ0 C
,
ÚÚC D
typeof
ÚÚE K
(
ÚÚK L
Material
ÚÚL T
)
ÚÚT U
)
ÚÚU V
;
ÚÚV W
}
ÛÛ 
}
ÜÜ 	
internal
áá 
static
áá 
Material
áá  
colliderMaterial
áá! 1
{
ââ 	
get
ãã 
{
ää 
Init
åå 
(
åå 
)
åå 
;
åå 
return
ææ 
(
ææ 
Material
ææ  
)
ææ  !
	Resources
ææ! *
.
ææ* +
Load
ææ+ /
(
ææ/ 0
$str
ææ0 D
,
ææD E
typeof
ææF L
(
ææL M
Material
ææM U
)
ææU V
)
ææV W
;
ææW X
}
çç 
}
èè 	
[
íí 	
Obsolete
íí	 
(
íí 
$str
íí 2
)
íí2 3
]
íí3 4
internal
îî 
static
îî 
Material
îî  
noDrawMaterial
îî! /
{
ïï 	
get
ğğ 
{
ññ 
Init
òò 
(
òò 
)
òò 
;
òò 
return
óó 
(
óó 
Material
óó  
)
óó  !
	Resources
óó! *
.
óó* +
Load
óó+ /
(
óó/ 0
$str
óó0 B
,
óóB C
typeof
óóD J
(
óóJ K
Material
óóK S
)
óóS T
)
óóT U
;
óóU V
}
ôô 
}
õõ 	
internal
úú 
static
úú 
Material
úú  
GetLegacyDiffuse
úú! 1
(
úú1 2
)
úú2 3
{
ûû 	
Init
üü 
(
üü 
)
üü 
;
üü 
if
şş 
(
şş #
s_UnityDefaultDiffuse
şş %
==
şş& (
null
şş) -
)
şş- .
{
ÿÿ 
var
€€ 
mi
€€ 
=
€€ 
typeof
€€ 
(
€€  
Material
€€  (
)
€€( )
.
€€) *
	GetMethod
€€* 3
(
€€3 4
$str
€€4 H
,
€€H I
BindingFlags
 $
.
$ %
	NonPublic
% .
|
/ 0
BindingFlags
1 =
.
= >
Public
> D
|
E F
BindingFlags
G S
.
S T
Static
T Z
)
Z [
;
[ \
if
ƒƒ 
(
ƒƒ 
mi
ƒƒ 
!=
ƒƒ 
null
ƒƒ 
)
ƒƒ #
s_UnityDefaultDiffuse
„„ )
=
„„* +
mi
„„, .
.
„„. /
Invoke
„„/ 5
(
„„5 6
null
„„6 :
,
„„: ;
null
„„< @
)
„„@ A
as
„„B D
Material
„„E M
;
„„M N
if
†† 
(
†† #
s_UnityDefaultDiffuse
†† )
==
††* ,
null
††- 1
)
††1 2
{
‡‡ 
var
ˆˆ 
go
ˆˆ 
=
ˆˆ 

GameObject
ˆˆ '
.
ˆˆ' (
CreatePrimitive
ˆˆ( 7
(
ˆˆ7 8
PrimitiveType
ˆˆ8 E
.
ˆˆE F
Cube
ˆˆF J
)
ˆˆJ K
;
ˆˆK L#
s_UnityDefaultDiffuse
‰‰ )
=
‰‰* +
go
‰‰, .
.
‰‰. /
GetComponent
‰‰/ ;
<
‰‰; <
MeshRenderer
‰‰< H
>
‰‰H I
(
‰‰I J
)
‰‰J K
.
‰‰K L
sharedMaterial
‰‰L Z
;
‰‰Z [
Object
ŠŠ 
.
ŠŠ 
DestroyImmediate
ŠŠ +
(
ŠŠ+ ,
go
ŠŠ, .
)
ŠŠ. /
;
ŠŠ/ 0
}
‹‹ 
}
ŒŒ 
return
 #
s_UnityDefaultDiffuse
 (
;
( )
}
 	
internal
‘‘ 
static
‘‘ 
Material
‘‘   
GetDefaultMaterial
‘‘! 3
(
‘‘3 4
)
‘‘4 5
{
’’ 	
Material
““ 
material
““ 
=
““ 
null
““  $
;
““$ %
if
•• 
(
•• 
GraphicsSettings
••  
.
••  !!
renderPipelineAsset
••! 4
!=
••5 7
null
••8 <
)
••< =
{
–– 
material
˜˜ 
=
˜˜ 
GraphicsSettings
˜˜ /
.
˜˜/ 0!
renderPipelineAsset
˜˜0 C
.
˜˜C D
defaultMaterial
˜˜D S
;
˜˜S T
}
œœ 
if
 
(
 
material
 
==
 
null
  
)
  !
{
ŸŸ 
material
   
=
   
(
   
Material
   $
)
  $ %
	Resources
  & /
.
  / 0
Load
  0 4
(
  4 5
$str
  5 R
,
  R S
typeof
  T Z
(
  Z [
Material
  [ c
)
  c d
)
  d e
;
  e f
if
¢¢ 
(
¢¢ 
material
¢¢ 
==
¢¢ 
null
¢¢  $
||
¢¢% '
!
¢¢( )
material
¢¢) 1
.
¢¢1 2
shader
¢¢2 8
.
¢¢8 9
isSupported
¢¢9 D
)
¢¢D E
material
££ 
=
££ 
GetLegacyDiffuse
££ /
(
££/ 0
)
££0 1
;
££1 2
}
¤¤ 
return
¦¦ 
material
¦¦ 
;
¦¦ 
}
§§ 	
internal
¬¬ 
static
¬¬ 
Material
¬¬  
unlitVertexColor
¬¬! 1
{
­­ 	
get
®® 
{
¯¯ 
Init
°° 
(
°° 
)
°° 
;
°° 
return
±± (
s_UnlitVertexColorMaterial
±± 1
;
±±1 2
}
²² 
}
³³ 	
internal
µµ 
static
µµ 
Material
µµ  "
ShapePreviewMaterial
µµ! 5
{
¶¶ 	
get
·· 
{
¸¸ 
Init
¹¹ 
(
¹¹ 
)
¹¹ 
;
¹¹ 
return
ºº $
s_ShapePreviewMaterial
ºº -
;
ºº- .
}
»» 
}
¼¼ 	
}
½½ 
}¾¾ Ë±
ŒD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\MeshHandles.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
MeshHandles 
{ 
static		 
List		 
<		 
Vector3		 
>		 
s_Vector2List		 *
=		+ ,
new		- 0
List		1 5
<		5 6
Vector3		6 =
>		= >
(		> ?
)		? @
;		@ A
static

 
List

 
<

 
Vector3

 
>

 
s_Vector3List

 *
=

+ ,
new

- 0
List

1 5
<

5 6
Vector3

6 =
>

= >
(

> ?
)

? @
;

@ A
static 
List 
< 
Vector4 
> 
s_Vector4List *
=+ ,
new- 0
List1 5
<5 6
Vector46 =
>= >
(> ?
)? @
;@ A
static 
List 
< 
int 
> 
s_IndexList $
=% &
new' *
List+ /
</ 0
int0 3
>3 4
(4 5
)5 6
;6 7
static 
List 
< 
int 
> #
s_SharedVertexIndexList 0
=1 2
new3 6
List7 ;
<; <
int< ?
>? @
(@ A
)A B
;B C
static 
readonly 
Vector2 
k_Billboard0  ,
=- .
new/ 2
Vector23 :
(: ;
-; <
$num< >
,> ?
-@ A
$numA C
)C D
;D E
static 
readonly 
Vector2 
k_Billboard1  ,
=- .
new/ 2
Vector23 :
(: ;
-; <
$num< >
,> ?
$numA C
)C D
;D E
static 
readonly 
Vector2 
k_Billboard2  ,
=- .
new/ 2
Vector23 :
(: ;
$num< >
,> ?
-@ A
$numA C
)C D
;D E
static 
readonly 
Vector2 
k_Billboard3  ,
=- .
new/ 2
Vector23 :
(: ;
$num< >
,> ?
$numA C
)C D
;D E
internal 
static 
void 
CreateFaceMesh +
(+ ,
ProBuilderMesh, :
mesh; ?
,? @
MeshA E
targetF L
)L M
{ 	
target 
. 
Clear 
( 
) 
; 
target 
. 
vertices 
= 
mesh "
." #
positionsInternal# 4
;4 5
target 
. 
	triangles 
= 
mesh #
.# $!
selectedFacesInternal$ 9
.9 :

SelectMany: D
(D E
xE F
=>G I
xJ K
.K L
indexesL S
)S T
.T U
ToArrayU \
(\ ]
)] ^
;^ _
} 	
internal 
static 
void 
CreateEdgeMesh +
(+ ,
ProBuilderMesh, :
mesh; ?
,? @
MeshA E
targetF L
)L M
{ 	
int 
	edgeCount 
= 
$num 
; 
int 
	faceCount 
= 
mesh  
.  !
	faceCount! *
;* +
for   
(   
int   
i   
=   
$num   
;   
i   
<   
	faceCount    )
;  ) *
i  + ,
++  , .
)  . /
	edgeCount!! 
+=!! 
mesh!! !
.!!! "
facesInternal!!" /
[!!/ 0
i!!0 1
]!!1 2
.!!2 3
edgesInternal!!3 @
.!!@ A
Length!!A G
;!!G H
s_IndexList## 
.## 
Clear## 
(## 
)## 
;##  
s_IndexList$$ 
.$$ 
Capacity$$  
=$$! "
	edgeCount$$# ,
*$$- .
$num$$/ 0
;$$0 1
int&& 
	edgeIndex&& 
=&& 
$num&& 
;&& 
for(( 
((( 
int(( 
i(( 
=(( 
$num(( 
;(( 
i(( 
<(( 
	faceCount((  )
&&((* ,
	edgeIndex((- 6
<((7 8
	edgeCount((9 B
;((B C
i((D E
++((E G
)((G H
{)) 
for** 
(** 
int** 
n** 
=** 
$num** 
;** 
n**  !
<**" #
mesh**$ (
.**( )
facesInternal**) 6
[**6 7
i**7 8
]**8 9
.**9 :
edgesInternal**: G
.**G H
Length**H N
&&**O Q
	edgeIndex**R [
<**\ ]
	edgeCount**^ g
;**g h
n**i j
++**j l
)**l m
{++ 
var,, 
edge,, 
=,, 
mesh,, #
.,,# $
facesInternal,,$ 1
[,,1 2
i,,2 3
],,3 4
.,,4 5
edgesInternal,,5 B
[,,B C
n,,C D
],,D E
;,,E F
s_IndexList-- 
.--  
Add--  #
(--# $
edge--$ (
.--( )
a--) *
)--* +
;--+ ,
s_IndexList.. 
...  
Add..  #
(..# $
edge..$ (
...( )
b..) *
)..* +
;..+ ,
	edgeIndex00 
++00 
;00  
}11 
}22 
target44 
.44 
Clear44 
(44 
)44 
;44 
target55 
.55 
indexFormat55 
=55  
	edgeCount55! *
*55+ ,
$num55- .
>55/ 0
ushort551 7
.557 8
MaxValue558 @
?55A B
	Rendering55C L
.55L M
IndexFormat55M X
.55X Y
UInt1655Y _
:55` a
	Rendering55b k
.55k l
IndexFormat55l w
.55w x
UInt3255x ~
;55~ 
target66 
.66 
name66 
=66 
$str66 0
+661 2
target663 9
.669 :
GetInstanceID66: G
(66G H
)66H I
;66I J
target77 
.77 
vertices77 
=77 
mesh77 "
.77" #
positionsInternal77# 4
;774 5
target88 
.88 
subMeshCount88 
=88  !
$num88" #
;88# $
target:: 
.:: 

SetIndices:: 
(:: 
s_IndexList:: )
,::) *
MeshTopology::+ 7
.::7 8
Lines::8 =
,::= >
$num::? @
)::@ A
;::A B
}>> 	
internal@@ 
static@@ 
void@@ 
CreateEdgeMesh@@ +
(@@+ ,
ProBuilderMesh@@, :
mesh@@; ?
,@@? @
Mesh@@A E
target@@F L
,@@L M
Edge@@N R
[@@R S
]@@S T
edges@@U Z
)@@Z [
{AA 	
intBB 
	edgeCountBB 
=BB 
edgesBB !
.BB! "
LengthBB" (
;BB( )
intCC 
vertexCountCC 
=CC 
	edgeCountCC '
*CC( )
$numCC* +
;CC+ ,
s_IndexListEE 
.EE 
ClearEE 
(EE 
)EE 
;EE  
s_IndexListFF 
.FF 
CapacityFF  
=FF! "
vertexCountFF# .
;FF. /
forHH 
(HH 
intHH 
nHH 
=HH 
$numHH 
;HH 
nHH 
<HH 
	edgeCountHH  )
;HH) *
nHH+ ,
++HH, .
)HH. /
{II 
varJJ 
edgeJJ 
=JJ 
edgesJJ  
[JJ  !
nJJ! "
]JJ" #
;JJ# $
s_IndexListKK 
.KK 
AddKK 
(KK  
edgeKK  $
.KK$ %
aKK% &
)KK& '
;KK' (
s_IndexListLL 
.LL 
AddLL 
(LL  
edgeLL  $
.LL$ %
bLL% &
)LL& '
;LL' (
}MM 
targetOO 
.OO 
ClearOO 
(OO 
)OO 
;OO 
targetPP 
.PP 
indexFormatPP 
=PP  
vertexCountPP! ,
>PP- .
ushortPP/ 5
.PP5 6
MaxValuePP6 >
?PP? @
	RenderingPPA J
.PPJ K
IndexFormatPPK V
.PPV W
UInt16PPW ]
:PP^ _
	RenderingPP` i
.PPi j
IndexFormatPPj u
.PPu v
UInt32PPv |
;PP| }
targetQQ 
.QQ 
nameQQ 
=QQ 
$strQQ 0
+QQ1 2
targetQQ3 9
.QQ9 :
GetInstanceIDQQ: G
(QQG H
)QQH I
;QQI J
targetRR 
.RR 
verticesRR 
=RR 
meshRR "
.RR" #
positionsInternalRR# 4
;RR4 5
targetSS 
.SS 
subMeshCountSS 
=SS  !
$numSS" #
;SS# $
targetUU 
.UU 

SetIndicesUU 
(UU 
s_IndexListUU )
,UU) *
MeshTopologyUU+ 7
.UU7 8
LinesUU8 =
,UU= >
$numUU? @
)UU@ A
;UUA B
}YY 	
internal[[ 
static[[ 
void[[ 
CreateVertexMesh[[ -
([[- .
ProBuilderMesh[[. <
mesh[[= A
,[[A B
Mesh[[C G
target[[H N
)[[N O
{\\ 	#
s_SharedVertexIndexList]] #
.]]# $
Clear]]$ )
(]]) *
)]]* +
;]]+ ,
int^^ 
sharedVertexCount^^ !
=^^" #
mesh^^$ (
.^^( )"
sharedVerticesInternal^^) ?
.^^? @
Length^^@ F
;^^F G#
s_SharedVertexIndexList__ #
.__# $
Capacity__$ ,
=__- .
sharedVertexCount__/ @
;__@ A
foraa 
(aa 
intaa 
iaa 
=aa 
$numaa 
;aa 
iaa 
<aa 
sharedVertexCountaa  1
;aa1 2
iaa3 4
++aa4 6
)aa6 7#
s_SharedVertexIndexListbb '
.bb' (
Addbb( +
(bb+ ,
meshbb, 0
.bb0 1"
sharedVerticesInternalbb1 G
[bbG H
ibbH I
]bbI J
[bbJ K
$numbbK L
]bbL M
)bbM N
;bbN O
CreateVertexMeshdd 
(dd 
meshdd !
,dd! "
targetdd# )
,dd) *#
s_SharedVertexIndexListdd+ B
)ddB C
;ddC D
}ee 	
internalgg 
staticgg 
voidgg 
CreateVertexMeshgg -
(gg- .
ProBuilderMeshgg. <
meshgg= A
,ggA B
MeshggC G
targetggH N
,ggN O
IListggP U
<ggU V
intggV Y
>ggY Z
indexesgg[ b
)ggb c
{hh 	
ifii 
(ii 
BuiltinMaterialsii  
.ii  !$
geometryShadersSupportedii! 9
)ii9 :
CreatePointMeshjj 
(jj  
meshjj  $
.jj$ %
positionsInternaljj% 6
,jj6 7
indexesjj8 ?
,jj? @
targetjjA G
)jjG H
;jjH I
elsekk $
CreatePointBillboardMeshll (
(ll( )
meshll) -
.ll- .
positionsInternalll. ?
,ll? @
indexesllA H
,llH I
targetllJ P
)llP Q
;llQ R
}mm 	
staticoo 
voidoo 
CreatePointMeshoo #
(oo# $
Vector3oo$ +
[oo+ ,
]oo, -
	positionsoo. 7
,oo7 8
IListoo9 >
<oo> ?
intoo? B
>ooB C
indexesooD K
,ooK L
MeshooM Q
targetooR X
)ooX Y
{pp 	
intqq 
vertexCountqq 
=qq 
	positionsqq '
.qq' (
Lengthqq( .
;qq. /
targetrr 
.rr 
Clearrr 
(rr 
)rr 
;rr 
targetss 
.ss 
indexFormatss 
=ss  
vertexCountss! ,
>ss- .
ushortss/ 5
.ss5 6
MaxValuess6 >
?ss? @
	RenderingssA J
.ssJ K
IndexFormatssK V
.ssV W
UInt16ssW ]
:ss^ _
	Renderingss` i
.ssi j
IndexFormatssj u
.ssu v
UInt32ssv |
;ss| }
targettt 
.tt 
namett 
=tt 
$strtt 1
;tt1 2
targetuu 
.uu 
verticesuu 
=uu 
	positionsuu '
;uu' (
targetvv 
.vv 
subMeshCountvv 
=vv  !
$numvv" #
;vv# $
ifxx 
(xx 
indexesxx 
isxx 
intxx 
[xx 
]xx 
)xx  
targetyy 
.yy 

SetIndicesyy !
(yy! "
(yy" #
intyy# &
[yy& '
]yy' (
)yy( )
indexesyy* 1
,yy1 2
MeshTopologyyy3 ?
.yy? @
Pointsyy@ F
,yyF G
$numyyH I
)yyI J
;yyJ K
else{{ 
if{{ 
({{ 
indexes{{ 
is{{ 
List{{ #
<{{# $
int{{$ '
>{{' (
){{( )
target|| 
.|| 

SetIndices|| !
(||! "
(||" #
List||# '
<||' (
int||( +
>||+ ,
)||, -
indexes||. 5
,||5 6
MeshTopology||7 C
.||C D
Points||D J
,||J K
$num||L M
)||M N
;||N O
else~~ 
target 
. 

SetIndices !
(! "
indexes" )
.) *
ToArray* 1
(1 2
)2 3
,3 4
MeshTopology5 A
.A B
PointsB H
,H I
$numJ K
)K L
;L M
}
€€ 	
internal
‚‚ 
static
‚‚ 
void
‚‚ &
CreatePointBillboardMesh
‚‚ 5
(
‚‚5 6
IList
‚‚6 ;
<
‚‚; <
Vector3
‚‚< C
>
‚‚C D
	positions
‚‚E N
,
‚‚N O
Mesh
‚‚P T
target
‚‚U [
)
‚‚[ \
{
ƒƒ 	
var
„„ 

pointCount
„„ 
=
„„ 
	positions
„„ &
.
„„& '
Count
„„' ,
;
„„, -
var
…… 
vertexCount
…… 
=
…… 

pointCount
…… (
*
……) *
$num
……+ ,
;
……, -
s_Vector2List
‡‡ 
.
‡‡ 
Clear
‡‡ 
(
‡‡  
)
‡‡  !
;
‡‡! "
s_Vector3List
ˆˆ 
.
ˆˆ 
Clear
ˆˆ 
(
ˆˆ  
)
ˆˆ  !
;
ˆˆ! "
s_IndexList
‰‰ 
.
‰‰ 
Clear
‰‰ 
(
‰‰ 
)
‰‰ 
;
‰‰  
s_Vector2List
ŠŠ 
.
ŠŠ 
Capacity
ŠŠ "
=
ŠŠ# $
vertexCount
ŠŠ% 0
;
ŠŠ0 1
s_Vector3List
‹‹ 
.
‹‹ 
Capacity
‹‹ "
=
‹‹# $
vertexCount
‹‹% 0
;
‹‹0 1
s_IndexList
ŒŒ 
.
ŒŒ 
Capacity
ŒŒ  
=
ŒŒ! "
vertexCount
ŒŒ# .
;
ŒŒ. /
for
 
(
 
int
 
i
 
=
 
$num
 
;
 
i
 
<
 

pointCount
  *
;
* +
i
, -
++
- /
)
/ 0
{
 
s_Vector3List
 
.
 
Add
 !
(
! "
	positions
" +
[
+ ,
i
, -
]
- .
)
. /
;
/ 0
s_Vector3List
‘‘ 
.
‘‘ 
Add
‘‘ !
(
‘‘! "
	positions
‘‘" +
[
‘‘+ ,
i
‘‘, -
]
‘‘- .
)
‘‘. /
;
‘‘/ 0
s_Vector3List
’’ 
.
’’ 
Add
’’ !
(
’’! "
	positions
’’" +
[
’’+ ,
i
’’, -
]
’’- .
)
’’. /
;
’’/ 0
s_Vector3List
““ 
.
““ 
Add
““ !
(
““! "
	positions
““" +
[
““+ ,
i
““, -
]
““- .
)
““. /
;
““/ 0
s_Vector2List
•• 
.
•• 
Add
•• !
(
••! "
k_Billboard0
••" .
)
••. /
;
••/ 0
s_Vector2List
–– 
.
–– 
Add
–– !
(
––! "
k_Billboard1
––" .
)
––. /
;
––/ 0
s_Vector2List
—— 
.
—— 
Add
—— !
(
——! "
k_Billboard2
——" .
)
——. /
;
——/ 0
s_Vector2List
˜˜ 
.
˜˜ 
Add
˜˜ !
(
˜˜! "
k_Billboard3
˜˜" .
)
˜˜. /
;
˜˜/ 0
s_IndexList
šš 
.
šš 
Add
šš 
(
šš  
i
šš  !
*
šš" #
$num
šš$ %
+
šš& '
$num
šš( )
)
šš) *
;
šš* +
s_IndexList
›› 
.
›› 
Add
›› 
(
››  
i
››  !
*
››" #
$num
››$ %
+
››& '
$num
››( )
)
››) *
;
››* +
s_IndexList
œœ 
.
œœ 
Add
œœ 
(
œœ  
i
œœ  !
*
œœ" #
$num
œœ$ %
+
œœ& '
$num
œœ( )
)
œœ) *
;
œœ* +
s_IndexList
 
.
 
Add
 
(
  
i
  !
*
" #
$num
$ %
+
& '
$num
( )
)
) *
;
* +
}
 
target
   
.
   
Clear
   
(
   
)
   
;
   
target
¡¡ 
.
¡¡ 
indexFormat
¡¡ 
=
¡¡  
vertexCount
¡¡! ,
>
¡¡- .
ushort
¡¡/ 5
.
¡¡5 6
MaxValue
¡¡6 >
?
¡¡? @
	Rendering
¡¡A J
.
¡¡J K
IndexFormat
¡¡K V
.
¡¡V W
UInt32
¡¡W ]
:
¡¡^ _
	Rendering
¡¡` i
.
¡¡i j
IndexFormat
¡¡j u
.
¡¡u v
UInt16
¡¡v |
;
¡¡| }
target
¢¢ 
.
¢¢ 
SetVertices
¢¢ 
(
¢¢ 
s_Vector3List
¢¢ ,
)
¢¢, -
;
¢¢- .
target
££ 
.
££ 
SetUVs
££ 
(
££ 
$num
££ 
,
££ 
s_Vector2List
££ *
)
££* +
;
££+ ,
target
¤¤ 
.
¤¤ 
subMeshCount
¤¤ 
=
¤¤  !
$num
¤¤" #
;
¤¤# $
target
¦¦ 
.
¦¦ 

SetIndices
¦¦ 
(
¦¦ 
s_IndexList
¦¦ )
,
¦¦) *
MeshTopology
¦¦+ 7
.
¦¦7 8
Quads
¦¦8 =
,
¦¦= >
$num
¦¦? @
)
¦¦@ A
;
¦¦A B
}
ªª 	
static
¬¬ 
void
¬¬ &
CreatePointBillboardMesh
¬¬ ,
(
¬¬, -
IList
¬¬- 2
<
¬¬2 3
Vector3
¬¬3 :
>
¬¬: ;
	positions
¬¬< E
,
¬¬E F
IList
¬¬G L
<
¬¬L M
int
¬¬M P
>
¬¬P Q
indexes
¬¬R Y
,
¬¬Y Z
Mesh
¬¬[ _
target
¬¬` f
)
¬¬f g
{
­­ 	
var
®® 

pointCount
®® 
=
®® 
indexes
®® $
.
®®$ %
Count
®®% *
;
®®* +
var
¯¯ 
vertexCount
¯¯ 
=
¯¯ 

pointCount
¯¯ (
*
¯¯) *
$num
¯¯+ ,
;
¯¯, -
s_Vector2List
±± 
.
±± 
Clear
±± 
(
±±  
)
±±  !
;
±±! "
s_Vector3List
²² 
.
²² 
Clear
²² 
(
²²  
)
²²  !
;
²²! "
s_IndexList
³³ 
.
³³ 
Clear
³³ 
(
³³ 
)
³³ 
;
³³  
s_Vector2List
´´ 
.
´´ 
Capacity
´´ "
=
´´# $
vertexCount
´´% 0
;
´´0 1
s_Vector3List
µµ 
.
µµ 
Capacity
µµ "
=
µµ# $
vertexCount
µµ% 0
;
µµ0 1
s_IndexList
¶¶ 
.
¶¶ 
Capacity
¶¶  
=
¶¶! "
vertexCount
¶¶# .
;
¶¶. /
for
¸¸ 
(
¸¸ 
int
¸¸ 
i
¸¸ 
=
¸¸ 
$num
¸¸ 
;
¸¸ 
i
¸¸ 
<
¸¸ 

pointCount
¸¸  *
;
¸¸* +
i
¸¸, -
++
¸¸- /
)
¸¸/ 0
{
¹¹ 
var
ºº 
index
ºº 
=
ºº 
indexes
ºº #
[
ºº# $
i
ºº$ %
]
ºº% &
;
ºº& '
s_Vector3List
¼¼ 
.
¼¼ 
Add
¼¼ !
(
¼¼! "
	positions
¼¼" +
[
¼¼+ ,
index
¼¼, 1
]
¼¼1 2
)
¼¼2 3
;
¼¼3 4
s_Vector3List
½½ 
.
½½ 
Add
½½ !
(
½½! "
	positions
½½" +
[
½½+ ,
index
½½, 1
]
½½1 2
)
½½2 3
;
½½3 4
s_Vector3List
¾¾ 
.
¾¾ 
Add
¾¾ !
(
¾¾! "
	positions
¾¾" +
[
¾¾+ ,
index
¾¾, 1
]
¾¾1 2
)
¾¾2 3
;
¾¾3 4
s_Vector3List
¿¿ 
.
¿¿ 
Add
¿¿ !
(
¿¿! "
	positions
¿¿" +
[
¿¿+ ,
index
¿¿, 1
]
¿¿1 2
)
¿¿2 3
;
¿¿3 4
s_Vector2List
ÁÁ 
.
ÁÁ 
Add
ÁÁ !
(
ÁÁ! "
k_Billboard0
ÁÁ" .
)
ÁÁ. /
;
ÁÁ/ 0
s_Vector2List
ÂÂ 
.
ÂÂ 
Add
ÂÂ !
(
ÂÂ! "
k_Billboard1
ÂÂ" .
)
ÂÂ. /
;
ÂÂ/ 0
s_Vector2List
ÃÃ 
.
ÃÃ 
Add
ÃÃ !
(
ÃÃ! "
k_Billboard2
ÃÃ" .
)
ÃÃ. /
;
ÃÃ/ 0
s_Vector2List
ÄÄ 
.
ÄÄ 
Add
ÄÄ !
(
ÄÄ! "
k_Billboard3
ÄÄ" .
)
ÄÄ. /
;
ÄÄ/ 0
s_IndexList
ÆÆ 
.
ÆÆ 
Add
ÆÆ 
(
ÆÆ  
i
ÆÆ  !
*
ÆÆ" #
$num
ÆÆ$ %
+
ÆÆ& '
$num
ÆÆ( )
)
ÆÆ) *
;
ÆÆ* +
s_IndexList
ÇÇ 
.
ÇÇ 
Add
ÇÇ 
(
ÇÇ  
i
ÇÇ  !
*
ÇÇ" #
$num
ÇÇ$ %
+
ÇÇ& '
$num
ÇÇ( )
)
ÇÇ) *
;
ÇÇ* +
s_IndexList
ÈÈ 
.
ÈÈ 
Add
ÈÈ 
(
ÈÈ  
i
ÈÈ  !
*
ÈÈ" #
$num
ÈÈ$ %
+
ÈÈ& '
$num
ÈÈ( )
)
ÈÈ) *
;
ÈÈ* +
s_IndexList
ÉÉ 
.
ÉÉ 
Add
ÉÉ 
(
ÉÉ  
i
ÉÉ  !
*
ÉÉ" #
$num
ÉÉ$ %
+
ÉÉ& '
$num
ÉÉ( )
)
ÉÉ) *
;
ÉÉ* +
}
ÊÊ 
target
ÌÌ 
.
ÌÌ 
Clear
ÌÌ 
(
ÌÌ 
)
ÌÌ 
;
ÌÌ 
target
ÍÍ 
.
ÍÍ 
indexFormat
ÍÍ 
=
ÍÍ  
vertexCount
ÍÍ! ,
>
ÍÍ- .
ushort
ÍÍ/ 5
.
ÍÍ5 6
MaxValue
ÍÍ6 >
?
ÍÍ? @
	Rendering
ÍÍA J
.
ÍÍJ K
IndexFormat
ÍÍK V
.
ÍÍV W
UInt32
ÍÍW ]
:
ÍÍ^ _
	Rendering
ÍÍ` i
.
ÍÍi j
IndexFormat
ÍÍj u
.
ÍÍu v
UInt16
ÍÍv |
;
ÍÍ| }
target
ÎÎ 
.
ÎÎ 
SetVertices
ÎÎ 
(
ÎÎ 
s_Vector3List
ÎÎ ,
)
ÎÎ, -
;
ÎÎ- .
target
ÏÏ 
.
ÏÏ 
SetUVs
ÏÏ 
(
ÏÏ 
$num
ÏÏ 
,
ÏÏ 
s_Vector2List
ÏÏ *
)
ÏÏ* +
;
ÏÏ+ ,
target
ĞĞ 
.
ĞĞ 
subMeshCount
ĞĞ 
=
ĞĞ  !
$num
ĞĞ" #
;
ĞĞ# $
target
ÒÒ 
.
ÒÒ 

SetIndices
ÒÒ 
(
ÒÒ 
s_IndexList
ÒÒ )
,
ÒÒ) *
MeshTopology
ÒÒ+ 7
.
ÒÒ7 8
Quads
ÒÒ8 =
,
ÒÒ= >
$num
ÒÒ? @
)
ÒÒ@ A
;
ÒÒA B
}
ÖÖ 	
internal
ØØ 
static
ØØ 
void
ØØ %
CreateEdgeBillboardMesh
ØØ 4
(
ØØ4 5
ProBuilderMesh
ØØ5 C
mesh
ØØD H
,
ØØH I
Mesh
ØØJ N
target
ØØO U
)
ØØU V
{
ÙÙ 	
target
ÚÚ 
.
ÚÚ 
Clear
ÚÚ 
(
ÚÚ 
)
ÚÚ 
;
ÚÚ 
const
ÛÛ 
ushort
ÛÛ #
k_MaxPointCountUShort
ÛÛ .
=
ÛÛ/ 0
ushort
ÛÛ1 7
.
ÛÛ7 8
MaxValue
ÛÛ8 @
/
ÛÛA B
$num
ÛÛC D
;
ÛÛD E
var
ÜÜ 
	lineCount
ÜÜ 
=
ÜÜ 
mesh
ÜÜ  
.
ÜÜ  !
	edgeCount
ÜÜ! *
;
ÜÜ* +
target
ŞŞ 
.
ŞŞ 
indexFormat
ŞŞ 
=
ŞŞ  
	lineCount
ŞŞ! *
>
ŞŞ+ ,#
k_MaxPointCountUShort
ŞŞ- B
?
ßß 
	Rendering
ßß 
.
ßß 
IndexFormat
ßß '
.
ßß' (
UInt32
ßß( .
:
àà 
	Rendering
àà 
.
àà 
IndexFormat
àà '
.
àà' (
UInt16
àà( .
;
àà. /
var
ââ 
vertices
ââ 
=
ââ 
mesh
ââ 
.
ââ  
positionsInternal
ââ  1
;
ââ1 2
s_Vector3List
ää 
.
ää 
Clear
ää 
(
ää  
)
ää  !
;
ää! "
s_Vector4List
åå 
.
åå 
Clear
åå 
(
åå  
)
åå  !
;
åå! "
s_IndexList
ææ 
.
ææ 
Clear
ææ 
(
ææ 
)
ææ 
;
ææ  
s_Vector3List
çç 
.
çç 
Capacity
çç "
=
çç# $
	lineCount
çç% .
*
çç/ 0
$num
çç1 2
;
çç2 3
s_Vector4List
èè 
.
èè 
Capacity
èè "
=
èè# $
	lineCount
èè% .
*
èè/ 0
$num
èè1 2
;
èè2 3
s_IndexList
éé 
.
éé 
Capacity
éé  
=
éé! "
	lineCount
éé# ,
*
éé- .
$num
éé/ 0
;
éé0 1
int
ëë 
n
ëë 
=
ëë 
$num
ëë 
;
ëë 
foreach
íí 
(
íí 
var
íí 
face
íí 
in
íí 
mesh
íí  $
.
íí$ %
facesInternal
íí% 2
)
íí2 3
{
îî 
foreach
ïï 
(
ïï 
var
ïï 
edge
ïï !
in
ïï" $
face
ïï% )
.
ïï) *
edgesInternal
ïï* 7
)
ïï7 8
{
ğğ 
Vector3
ññ 
a
ññ 
=
ññ 
vertices
ññ  (
[
ññ( )
edge
ññ) -
.
ññ- .
a
ññ. /
]
ññ/ 0
,
ññ0 1
b
ññ2 3
=
ññ4 5
vertices
ññ6 >
[
ññ> ?
edge
ññ? C
.
ññC D
b
ññD E
]
ññE F
;
ññF G
Vector3
òò 
c
òò 
=
òò 
b
òò  !
+
òò" #
(
òò$ %
b
òò% &
-
òò' (
a
òò) *
)
òò* +
;
òò+ ,
s_Vector3List
ôô !
.
ôô! "
Add
ôô" %
(
ôô% &
a
ôô& '
)
ôô' (
;
ôô( )
s_Vector3List
õõ !
.
õõ! "
Add
õõ" %
(
õõ% &
a
õõ& '
)
õõ' (
;
õõ( )
s_Vector3List
öö !
.
öö! "
Add
öö" %
(
öö% &
b
öö& '
)
öö' (
;
öö( )
s_Vector3List
÷÷ !
.
÷÷! "
Add
÷÷" %
(
÷÷% &
b
÷÷& '
)
÷÷' (
;
÷÷( )
s_Vector4List
ùù !
.
ùù! "
Add
ùù" %
(
ùù% &
new
ùù& )
Vector4
ùù* 1
(
ùù1 2
b
ùù2 3
.
ùù3 4
x
ùù4 5
,
ùù5 6
b
ùù7 8
.
ùù8 9
y
ùù9 :
,
ùù: ;
b
ùù< =
.
ùù= >
z
ùù> ?
,
ùù? @
$num
ùùA C
)
ùùC D
)
ùùD E
;
ùùE F
s_Vector4List
úú !
.
úú! "
Add
úú" %
(
úú% &
new
úú& )
Vector4
úú* 1
(
úú1 2
b
úú2 3
.
úú3 4
x
úú4 5
,
úú5 6
b
úú7 8
.
úú8 9
y
úú9 :
,
úú: ;
b
úú< =
.
úú= >
z
úú> ?
,
úú? @
-
úúA B
$num
úúB D
)
úúD E
)
úúE F
;
úúF G
s_Vector4List
ûû !
.
ûû! "
Add
ûû" %
(
ûû% &
new
ûû& )
Vector4
ûû* 1
(
ûû1 2
c
ûû2 3
.
ûû3 4
x
ûû4 5
,
ûû5 6
c
ûû7 8
.
ûû8 9
y
ûû9 :
,
ûû: ;
c
ûû< =
.
ûû= >
z
ûû> ?
,
ûû? @
$num
ûûA C
)
ûûC D
)
ûûD E
;
ûûE F
s_Vector4List
üü !
.
üü! "
Add
üü" %
(
üü% &
new
üü& )
Vector4
üü* 1
(
üü1 2
c
üü2 3
.
üü3 4
x
üü4 5
,
üü5 6
c
üü7 8
.
üü8 9
y
üü9 :
,
üü: ;
c
üü< =
.
üü= >
z
üü> ?
,
üü? @
-
üüA B
$num
üüB D
)
üüD E
)
üüE F
;
üüF G
s_IndexList
şş 
.
şş  
Add
şş  #
(
şş# $
n
şş$ %
+
şş& '
$num
şş( )
)
şş) *
;
şş* +
s_IndexList
ÿÿ 
.
ÿÿ  
Add
ÿÿ  #
(
ÿÿ# $
n
ÿÿ$ %
+
ÿÿ& '
$num
ÿÿ( )
)
ÿÿ) *
;
ÿÿ* +
s_IndexList
€€ 
.
€€  
Add
€€  #
(
€€# $
n
€€$ %
+
€€& '
$num
€€( )
)
€€) *
;
€€* +
s_IndexList
 
.
  
Add
  #
(
# $
n
$ %
+
& '
$num
( )
)
) *
;
* +
n
ƒƒ 
+=
ƒƒ 
$num
ƒƒ 
;
ƒƒ 
}
„„ 
}
…… 
target
‡‡ 
.
‡‡ 
SetVertices
‡‡ 
(
‡‡ 
s_Vector3List
‡‡ ,
)
‡‡, -
;
‡‡- .
target
ˆˆ 
.
ˆˆ 
SetTangents
ˆˆ 
(
ˆˆ 
s_Vector4List
ˆˆ ,
)
ˆˆ, -
;
ˆˆ- .
target
‰‰ 
.
‰‰ 
subMeshCount
‰‰ 
=
‰‰  !
$num
‰‰" #
;
‰‰# $
target
‹‹ 
.
‹‹ 

SetIndices
‹‹ 
(
‹‹ 
s_IndexList
‹‹ )
,
‹‹) *
MeshTopology
‹‹+ 7
.
‹‹7 8
Quads
‹‹8 =
,
‹‹= >
$num
‹‹? @
)
‹‹@ A
;
‹‹A B
}
 	
internal
‘‘ 
static
‘‘ 
void
‘‘ %
CreateEdgeBillboardMesh
‘‘ 4
(
‘‘4 5
ProBuilderMesh
‘‘5 C
mesh
‘‘D H
,
‘‘H I
Mesh
‘‘J N
target
‘‘O U
,
‘‘U V
ICollection
‘‘W b
<
‘‘b c
Edge
‘‘c g
>
‘‘g h
edges
‘‘i n
)
‘‘n o
{
’’ 	
target
““ 
.
““ 
Clear
““ 
(
““ 
)
““ 
;
““ 
const
•• 
ushort
•• #
k_MaxPointCountUShort
•• .
=
••/ 0
ushort
••1 7
.
••7 8
MaxValue
••8 @
/
••A B
$num
••C D
;
••D E
var
—— 
	lineCount
—— 
=
—— 
edges
—— !
.
——! "
Count
——" '
;
——' (
target
™™ 
.
™™ 
indexFormat
™™ 
=
™™  
	lineCount
™™! *
>
™™+ ,#
k_MaxPointCountUShort
™™- B
?
šš 
	Rendering
šš 
.
šš 
IndexFormat
šš '
.
šš' (
UInt32
šš( .
:
›› 
	Rendering
›› 
.
›› 
IndexFormat
›› '
.
››' (
UInt16
››( .
;
››. /
var
 
vertices
 
=
 
mesh
 
.
  
positionsInternal
  1
;
1 2
s_Vector3List
ŸŸ 
.
ŸŸ 
Clear
ŸŸ 
(
ŸŸ  
)
ŸŸ  !
;
ŸŸ! "
s_Vector4List
   
.
   
Clear
   
(
    
)
    !
;
  ! "
s_IndexList
¡¡ 
.
¡¡ 
Clear
¡¡ 
(
¡¡ 
)
¡¡ 
;
¡¡  
s_Vector3List
¢¢ 
.
¢¢ 
Capacity
¢¢ "
=
¢¢# $
	lineCount
¢¢% .
*
¢¢/ 0
$num
¢¢1 2
;
¢¢2 3
s_Vector4List
££ 
.
££ 
Capacity
££ "
=
££# $
	lineCount
££% .
*
££/ 0
$num
££1 2
;
££2 3
s_IndexList
¤¤ 
.
¤¤ 
Capacity
¤¤  
=
¤¤! "
	lineCount
¤¤# ,
*
¤¤- .
$num
¤¤/ 0
;
¤¤0 1
int
¦¦ 
n
¦¦ 
=
¦¦ 
$num
¦¦ 
;
¦¦ 
foreach
¨¨ 
(
¨¨ 
var
¨¨ 
edge
¨¨ 
in
¨¨  
edges
¨¨! &
)
¨¨& '
{
©© 
Vector3
ªª 
a
ªª 
=
ªª 
vertices
ªª $
[
ªª$ %
edge
ªª% )
.
ªª) *
a
ªª* +
]
ªª+ ,
,
ªª, -
b
ªª. /
=
ªª0 1
vertices
ªª2 :
[
ªª: ;
edge
ªª; ?
.
ªª? @
b
ªª@ A
]
ªªA B
;
ªªB C
Vector3
«« 
c
«« 
=
«« 
b
«« 
+
«« 
(
««  !
b
««! "
-
««# $
a
««% &
)
««& '
;
««' (
s_Vector3List
­­ 
.
­­ 
Add
­­ !
(
­­! "
a
­­" #
)
­­# $
;
­­$ %
s_Vector3List
®® 
.
®® 
Add
®® !
(
®®! "
a
®®" #
)
®®# $
;
®®$ %
s_Vector3List
¯¯ 
.
¯¯ 
Add
¯¯ !
(
¯¯! "
b
¯¯" #
)
¯¯# $
;
¯¯$ %
s_Vector3List
°° 
.
°° 
Add
°° !
(
°°! "
b
°°" #
)
°°# $
;
°°$ %
s_Vector4List
²² 
.
²² 
Add
²² !
(
²²! "
new
²²" %
Vector4
²²& -
(
²²- .
b
²². /
.
²²/ 0
x
²²0 1
,
²²1 2
b
²²3 4
.
²²4 5
y
²²5 6
,
²²6 7
b
²²8 9
.
²²9 :
z
²²: ;
,
²²; <
$num
²²= ?
)
²²? @
)
²²@ A
;
²²A B
s_Vector4List
³³ 
.
³³ 
Add
³³ !
(
³³! "
new
³³" %
Vector4
³³& -
(
³³- .
b
³³. /
.
³³/ 0
x
³³0 1
,
³³1 2
b
³³3 4
.
³³4 5
y
³³5 6
,
³³6 7
b
³³8 9
.
³³9 :
z
³³: ;
,
³³; <
-
³³= >
$num
³³> @
)
³³@ A
)
³³A B
;
³³B C
s_Vector4List
´´ 
.
´´ 
Add
´´ !
(
´´! "
new
´´" %
Vector4
´´& -
(
´´- .
c
´´. /
.
´´/ 0
x
´´0 1
,
´´1 2
c
´´3 4
.
´´4 5
y
´´5 6
,
´´6 7
c
´´8 9
.
´´9 :
z
´´: ;
,
´´; <
$num
´´= ?
)
´´? @
)
´´@ A
;
´´A B
s_Vector4List
µµ 
.
µµ 
Add
µµ !
(
µµ! "
new
µµ" %
Vector4
µµ& -
(
µµ- .
c
µµ. /
.
µµ/ 0
x
µµ0 1
,
µµ1 2
c
µµ3 4
.
µµ4 5
y
µµ5 6
,
µµ6 7
c
µµ8 9
.
µµ9 :
z
µµ: ;
,
µµ; <
-
µµ= >
$num
µµ> @
)
µµ@ A
)
µµA B
;
µµB C
s_IndexList
·· 
.
·· 
Add
·· 
(
··  
n
··  !
+
··" #
$num
··$ %
)
··% &
;
··& '
s_IndexList
¸¸ 
.
¸¸ 
Add
¸¸ 
(
¸¸  
n
¸¸  !
+
¸¸" #
$num
¸¸$ %
)
¸¸% &
;
¸¸& '
s_IndexList
¹¹ 
.
¹¹ 
Add
¹¹ 
(
¹¹  
n
¹¹  !
+
¹¹" #
$num
¹¹$ %
)
¹¹% &
;
¹¹& '
s_IndexList
ºº 
.
ºº 
Add
ºº 
(
ºº  
n
ºº  !
+
ºº" #
$num
ºº$ %
)
ºº% &
;
ºº& '
n
¼¼ 
+=
¼¼ 
$num
¼¼ 
;
¼¼ 
}
½½ 
target
¿¿ 
.
¿¿ 
SetVertices
¿¿ 
(
¿¿ 
s_Vector3List
¿¿ ,
)
¿¿, -
;
¿¿- .
target
ÀÀ 
.
ÀÀ 
SetTangents
ÀÀ 
(
ÀÀ 
s_Vector4List
ÀÀ ,
)
ÀÀ, -
;
ÀÀ- .
target
ÁÁ 
.
ÁÁ 
subMeshCount
ÁÁ 
=
ÁÁ  !
$num
ÁÁ" #
;
ÁÁ# $
target
ÃÃ 
.
ÃÃ 

SetIndices
ÃÃ 
(
ÃÃ 
s_IndexList
ÃÃ )
,
ÃÃ) *
MeshTopology
ÃÃ+ 7
.
ÃÃ7 8
Quads
ÃÃ8 =
,
ÃÃ= >
$num
ÃÃ? @
)
ÃÃ@ A
;
ÃÃA B
}
ÇÇ 	
}
ÈÈ 
}ÉÉ ¤¯
šD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\UV\UvUnwrapping.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
UvUnwrapping 
{ 
static 
Vector2 
s_TempVector2 $
=% &
Vector2' .
.. /
zero/ 3
;3 4
static 
readonly 
List 
< 
int  
>  !
s_IndexBuffer" /
=0 1
new2 5
List6 :
<: ;
int; >
>> ?
(? @
$num@ B
)B C
;C D
internal

 
static

 
void

 
Unwrap

 #
(

# $
ProBuilderMesh

$ 2
mesh

3 7
,

7 8
Face

9 =
face

> B
,

B C
Vector3

D K

projection

L V
=

W X
default

Y `
)

` a
{ 	

Projection 
. 
PlanarProject $
($ %
mesh% )
,) *
face+ /
,/ 0

projection1 ;
!=< >
Vector3? F
.F G
zeroG K
?K L

projectionM W
:X Y
Vector3Z a
.a b
zerob f
)f g
;g h
ApplyUVSettings 
( 
mesh  
.  !
texturesInternal! 1
,1 2
face3 7
.7 8#
distinctIndexesInternal8 O
,O P
faceQ U
.U V
uvV X
)X Y
;Y Z
} 	
internal 
static 
void 
CopyUVs $
($ %
ProBuilderMesh% 3
mesh4 8
,8 9
Face: >
source? E
,E F
FaceG K
destL P
)P Q
{ 	
var 
uvs 
= 
mesh 
. 
texturesInternal +
;+ ,
var 
sourceIndexes 
= 
source  &
.& '#
distinctIndexesInternal' >
;> ?
var 
destIndexes 
= 
dest "
." ##
distinctIndexesInternal# :
;: ;
for 
( 
int 
i 
= 
$num 
; 
i 
< 
sourceIndexes  -
.- .
Length. 4
;4 5
i6 7
++7 9
)9 :
{ 
uvs 
[ 
destIndexes 
[  
i  !
]! "
]" #
.# $
x$ %
=& '
uvs( +
[+ ,
sourceIndexes, 9
[9 :
i: ;
]; <
]< =
.= >
x> ?
;? @
uvs 
[ 
destIndexes 
[  
i  !
]! "
]" #
.# $
y$ %
=& '
uvs( +
[+ ,
sourceIndexes, 9
[9 :
i: ;
]; <
]< =
.= >
y> ?
;? @
} 
}   	
internal"" 
static"" 
void"" 
ProjectTextureGroup"" 0
(""0 1
ProBuilderMesh""1 ?
mesh""@ D
,""D E
int""F I
group""J O
,""O P
AutoUnwrapSettings""Q c
unwrapSettings""d r
)""r s
{## 	

Projection$$ 
.$$ 
PlanarProject$$ $
($$$ %
mesh$$% )
,$$) *
group$$+ 0
,$$0 1
unwrapSettings$$2 @
)$$@ A
;$$A B
s_IndexBuffer&& 
.&& 
Clear&& 
(&&  
)&&  !
;&&! "
foreach'' 
('' 
var'' 
face'' 
in''  
mesh''! %
.''% &
facesInternal''& 3
)''3 4
{(( 
if)) 
()) 
face)) 
.)) 
textureGroup)) %
==))& (
group))) .
))). /
{** 
s_IndexBuffer++ !
.++! "
AddRange++" *
(++* +
face+++ /
.++/ 0#
distinctIndexesInternal++0 G
)++G H
;++H I
},, 
}-- 
ApplyUVSettings// 
(// 
mesh//  
.//  !
texturesInternal//! 1
,//1 2
s_IndexBuffer//3 @
,//@ A
unwrapSettings//B P
)//P Q
;//Q R
}00 	
static22 
void22 
ApplyUVSettings22 #
(22# $
Vector222$ +
[22+ ,
]22, -
uvs22. 1
,221 2
IList223 8
<228 9
int229 <
>22< =
indexes22> E
,22E F
AutoUnwrapSettings22G Y

uvSettings22Z d
)22d e
{33 	
int44 
len44 
=44 
indexes44 
.44 
Count44 #
;44# $
switch66 
(66 

uvSettings66 
.66 
fill66 #
)66# $
{77 
case88 
AutoUnwrapSettings88 '
.88' (
Fill88( ,
.88, -
Tile88- 1
:881 2
break99 
;99 
case:: 
AutoUnwrapSettings:: '
.::' (
Fill::( ,
.::, -
Fit::- 0
:::0 1
FitUVs;; 
(;; 
uvs;; 
,;; 
indexes;;  '
);;' (
;;;( )
break<< 
;<< 
case== 
AutoUnwrapSettings== '
.==' (
Fill==( ,
.==, -
Stretch==- 4
:==4 5

StretchUVs>> 
(>> 
uvs>> "
,>>" #
indexes>>$ +
)>>+ ,
;>>, -
break?? 
;?? 
}@@ 
ifCC 
(CC 

uvSettingsCC 
.CC 
scaleCC  
.CC  !
xCC! "
!=CC# %
$numCC& (
||CC) +

uvSettingsDD 
.DD 
scaleDD  
.DD  !
yDD! "
!=DD# %
$numDD& (
||DD) +

uvSettingsEE 
.EE 
rotationEE #
!=EE$ &
$numEE' )
)EE) *
{FF 
Vector2GG 
centerGG 
=GG  
Bounds2DGG! )
.GG) *
CenterGG* 0
(GG0 1
uvsGG1 4
,GG4 5
indexesGG6 =
)GG= >
;GG> ?
forII 
(II 
intII 
iII 
=II 
$numII 
;II 
iII  !
<II" #
lenII$ '
;II' (
iII) *
++II* ,
)II, -
{JJ 
uvsKK 
[KK 
indexesKK 
[KK  
iKK  !
]KK! "
]KK" #
=KK$ %
uvsKK& )
[KK) *
indexesKK* 1
[KK1 2
iKK2 3
]KK3 4
]KK4 5
.KK5 6
ScaleAroundPointKK6 F
(KKF G
centerKKG M
,KKM N

uvSettingsKKO Y
.KKY Z
scaleKKZ _
)KK_ `
;KK` a
uvsLL 
[LL 
indexesLL 
[LL  
iLL  !
]LL! "
]LL" #
=LL$ %
uvsLL& )
[LL) *
indexesLL* 1
[LL1 2
iLL2 3
]LL3 4
]LL4 5
.LL5 6
RotateAroundPointLL6 G
(LLG H
centerLLH N
,LLN O

uvSettingsLLP Z
.LLZ [
rotationLL[ c
)LLc d
;LLd e
}MM 
}NN 
ifPP 
(PP 
!PP 

uvSettingsPP 
.PP 
useWorldSpacePP )
&&PP* ,

uvSettingsPP- 7
.PP7 8
anchorPP8 >
!=PP? A
AutoUnwrapSettingsPPB T
.PPT U
AnchorPPU [
.PP[ \
NonePP\ `
)PP` a
ApplyUVAnchorQQ 
(QQ 
uvsQQ !
,QQ! "
indexesQQ# *
,QQ* +

uvSettingsQQ, 6
.QQ6 7
anchorQQ7 =
)QQ= >
;QQ> ?
ifSS 
(SS 

uvSettingsSS 
.SS 
flipUSS  
||SS! #

uvSettingsSS$ .
.SS. /
flipVSS/ 4
||SS5 7

uvSettingsSS8 B
.SSB C
swapUVSSC I
)SSI J
{TT 
forUU 
(UU 
intUU 
iUU 
=UU 
$numUU 
;UU 
iUU  !
<UU" #
lenUU$ '
;UU' (
iUU) *
++UU* ,
)UU, -
{VV 
floatWW 
uWW 
=WW 
uvsWW  #
[WW# $
indexesWW$ +
[WW+ ,
iWW, -
]WW- .
]WW. /
.WW/ 0
xWW0 1
,WW1 2
vXX 
=XX 
uvsXX  #
[XX# $
indexesXX$ +
[XX+ ,
iXX, -
]XX- .
]XX. /
.XX/ 0
yXX0 1
;XX1 2
ifZZ 
(ZZ 

uvSettingsZZ "
.ZZ" #
flipUZZ# (
)ZZ( )
u[[ 
=[[ 
-[[ 
u[[ 
;[[ 
if]] 
(]] 

uvSettings]] "
.]]" #
flipV]]# (
)]]( )
v^^ 
=^^ 
-^^ 
v^^ 
;^^ 
if`` 
(`` 
!`` 

uvSettings`` #
.``# $
swapUV``$ *
)``* +
{aa 
uvsbb 
[bb 
indexesbb #
[bb# $
ibb$ %
]bb% &
]bb& '
.bb' (
xbb( )
=bb* +
ubb, -
;bb- .
uvscc 
[cc 
indexescc #
[cc# $
icc$ %
]cc% &
]cc& '
.cc' (
ycc( )
=cc* +
vcc, -
;cc- .
}dd 
elseee 
{ff 
uvsgg 
[gg 
indexesgg #
[gg# $
igg$ %
]gg% &
]gg& '
.gg' (
xgg( )
=gg* +
vgg, -
;gg- .
uvshh 
[hh 
indexeshh #
[hh# $
ihh$ %
]hh% &
]hh& '
.hh' (
yhh( )
=hh* +
uhh, -
;hh- .
}ii 
}jj 
}kk 
formm 
(mm 
intmm 
imm 
=mm 
$nummm 
;mm 
imm 
<mm 
indexesmm  '
.mm' (
Countmm( -
;mm- .
imm/ 0
++mm0 2
)mm2 3
{nn 
uvsoo 
[oo 
indexesoo 
[oo 
ioo 
]oo 
]oo 
.oo  
xoo  !
-=oo" $

uvSettingsoo% /
.oo/ 0
offsetoo0 6
.oo6 7
xoo7 8
;oo8 9
uvspp 
[pp 
indexespp 
[pp 
ipp 
]pp 
]pp 
.pp  
ypp  !
-=pp" $

uvSettingspp% /
.pp/ 0
offsetpp0 6
.pp6 7
ypp7 8
;pp8 9
}qq 
}rr 	
statictt 
voidtt 

StretchUVstt 
(tt 
Vector2tt &
[tt& '
]tt' (
uvstt) ,
,tt, -
IListtt. 3
<tt3 4
inttt4 7
>tt7 8
indexestt9 @
)tt@ A
{uu 	
varvv 
boundsvv 
=vv 
newvv 
Bounds2Dvv %
(vv% &
)vv& '
;vv' (
boundsww 
.ww 
SetWithPointsww  
(ww  !
uvsww! $
,ww$ %
indexesww& -
)ww- .
;ww. /
varxx 
cxx 
=xx 
boundsxx 
.xx 
centerxx !
;xx! "
varyy 
syy 
=yy 
boundsyy 
.yy 
sizeyy 
;yy  
for{{ 
({{ 
int{{ 
i{{ 
={{ 
$num{{ 
;{{ 
i{{ 
<{{ 
indexes{{  '
.{{' (
Count{{( -
;{{- .
i{{/ 0
++{{0 2
){{2 3
{|| 
var}} 
uv}} 
=}} 
uvs}} 
[}} 
indexes}} $
[}}$ %
i}}% &
]}}& '
]}}' (
;}}( )
uv 
. 
x 
= 
( 
( 
uv 
. 
x 
- 
c  !
.! "
x" #
)# $
/% &
s' (
.( )
x) *
)* +
+, -
c. /
./ 0
x0 1
;1 2
uv
€€ 
.
€€ 
y
€€ 
=
€€ 
(
€€ 
(
€€ 
uv
€€ 
.
€€ 
y
€€ 
-
€€ 
c
€€  !
.
€€! "
y
€€" #
)
€€# $
/
€€% &
s
€€' (
.
€€( )
y
€€) *
)
€€* +
+
€€, -
c
€€. /
.
€€/ 0
y
€€0 1
;
€€1 2
uvs
‚‚ 
[
‚‚ 
indexes
‚‚ 
[
‚‚ 
i
‚‚ 
]
‚‚ 
]
‚‚ 
=
‚‚  !
uv
‚‚" $
;
‚‚$ %
}
ƒƒ 
}
„„ 	
static
†† 
void
†† 
FitUVs
†† 
(
†† 
Vector2
†† "
[
††" #
]
††# $
uvs
††% (
,
††( )
IList
††* /
<
††/ 0
int
††0 3
>
††3 4
indexes
††5 <
)
††< =
{
‡‡ 	
var
ˆˆ 
bounds
ˆˆ 
=
ˆˆ 
new
ˆˆ 
Bounds2D
ˆˆ %
(
ˆˆ% &
)
ˆˆ& '
;
ˆˆ' (
bounds
‰‰ 
.
‰‰ 
SetWithPoints
‰‰  
(
‰‰  !
uvs
‰‰! $
,
‰‰$ %
indexes
‰‰& -
)
‰‰- .
;
‰‰. /
var
ŠŠ 
c
ŠŠ 
=
ŠŠ 
bounds
ŠŠ 
.
ŠŠ 
center
ŠŠ !
;
ŠŠ! "
var
‹‹ 
s
‹‹ 
=
‹‹ 
Mathf
‹‹ 
.
‹‹ 
Max
‹‹ 
(
‹‹ 
bounds
‹‹ $
.
‹‹$ %
size
‹‹% )
.
‹‹) *
x
‹‹* +
,
‹‹+ ,
bounds
‹‹- 3
.
‹‹3 4
size
‹‹4 8
.
‹‹8 9
y
‹‹9 :
)
‹‹: ;
;
‹‹; <
for
 
(
 
int
 
i
 
=
 
$num
 
;
 
i
 
<
 
indexes
  '
.
' (
Count
( -
;
- .
i
/ 0
++
0 2
)
2 3
{
 
var
 
uv
 
=
 
uvs
 
[
 
indexes
 $
[
$ %
i
% &
]
& '
]
' (
;
( )
uv
‘‘ 
.
‘‘ 
x
‘‘ 
=
‘‘ 
(
‘‘ 
(
‘‘ 
uv
‘‘ 
.
‘‘ 
x
‘‘ 
-
‘‘ 
c
‘‘  !
.
‘‘! "
x
‘‘" #
)
‘‘# $
/
‘‘% &
s
‘‘' (
)
‘‘( )
+
‘‘* +
c
‘‘, -
.
‘‘- .
x
‘‘. /
;
‘‘/ 0
uv
’’ 
.
’’ 
y
’’ 
=
’’ 
(
’’ 
(
’’ 
uv
’’ 
.
’’ 
y
’’ 
-
’’ 
c
’’  !
.
’’! "
y
’’" #
)
’’# $
/
’’% &
s
’’' (
)
’’( )
+
’’* +
c
’’, -
.
’’- .
y
’’. /
;
’’/ 0
uvs
”” 
[
”” 
indexes
”” 
[
”” 
i
”” 
]
”” 
]
”” 
=
””  !
uv
””" $
;
””$ %
}
•• 
}
–– 	
static
˜˜ 
void
˜˜ 
ApplyUVAnchor
˜˜ !
(
˜˜! "
Vector2
˜˜" )
[
˜˜) *
]
˜˜* +
uvs
˜˜, /
,
˜˜/ 0
IList
˜˜1 6
<
˜˜6 7
int
˜˜7 :
>
˜˜: ;
indexes
˜˜< C
,
˜˜C D 
AutoUnwrapSettings
˜˜E W
.
˜˜W X
Anchor
˜˜X ^
anchor
˜˜_ e
)
˜˜e f
{
™™ 	
s_TempVector2
šš 
.
šš 
x
šš 
=
šš 
$num
šš  
;
šš  !
s_TempVector2
›› 
.
›› 
y
›› 
=
›› 
$num
››  
;
››  !
Vector2
 
min
 
=
 
Math
 
.
 
SmallestVector2
 .
(
. /
uvs
/ 2
,
2 3
indexes
4 ;
)
; <
;
< =
Vector2
 
max
 
=
 
Math
 
.
 
LargestVector2
 -
(
- .
uvs
. 1
,
1 2
indexes
3 :
)
: ;
;
; <
if
   
(
   
anchor
   
==
    
AutoUnwrapSettings
   ,
.
  , -
Anchor
  - 3
.
  3 4
	UpperLeft
  4 =
||
  > @
anchor
  A G
==
  H J 
AutoUnwrapSettings
  K ]
.
  ] ^
Anchor
  ^ d
.
  d e

MiddleLeft
  e o
||
  p r
anchor
  s y
==
  z |!
AutoUnwrapSettings  } 
.   
Anchor   –
.  – —
	LowerLeft  —  
)    ¡
s_TempVector2
¡¡ 
.
¡¡ 
x
¡¡ 
=
¡¡  !
min
¡¡" %
.
¡¡% &
x
¡¡& '
;
¡¡' (
else
¢¢ 
if
¢¢ 
(
¢¢ 
anchor
¢¢ 
==
¢¢  
AutoUnwrapSettings
¢¢ 1
.
¢¢1 2
Anchor
¢¢2 8
.
¢¢8 9

UpperRight
¢¢9 C
||
¢¢D F
anchor
¢¢G M
==
¢¢N P 
AutoUnwrapSettings
¢¢Q c
.
¢¢c d
Anchor
¢¢d j
.
¢¢j k
MiddleRight
¢¢k v
||
¢¢w y
anchor¢¢z €
==¢¢ ƒ"
AutoUnwrapSettings¢¢„ –
.¢¢– —
Anchor¢¢— 
.¢¢ 

LowerRight¢¢ ¨
)¢¢¨ ©
s_TempVector2
££ 
.
££ 
x
££ 
=
££  !
max
££" %
.
££% &
x
££& '
-
££( )
$num
££* ,
;
££, -
else
¤¤ 
s_TempVector2
¥¥ 
.
¥¥ 
x
¥¥ 
=
¥¥  !
(
¥¥" #
min
¥¥# &
.
¥¥& '
x
¥¥' (
+
¥¥) *
(
¥¥+ ,
(
¥¥, -
max
¥¥- 0
.
¥¥0 1
x
¥¥1 2
-
¥¥3 4
min
¥¥5 8
.
¥¥8 9
x
¥¥9 :
)
¥¥: ;
*
¥¥< =
$num
¥¥> A
)
¥¥A B
)
¥¥B C
-
¥¥D E
$num
¥¥F I
;
¥¥I J
if
§§ 
(
§§ 
anchor
§§ 
==
§§  
AutoUnwrapSettings
§§ ,
.
§§, -
Anchor
§§- 3
.
§§3 4
	UpperLeft
§§4 =
||
§§> @
anchor
§§A G
==
§§H J 
AutoUnwrapSettings
§§K ]
.
§§] ^
Anchor
§§^ d
.
§§d e
UpperCenter
§§e p
||
§§q s
anchor
§§t z
==
§§{ }!
AutoUnwrapSettings§§~ 
.§§ ‘
Anchor§§‘ —
.§§— ˜

UpperRight§§˜ ¢
)§§¢ £
s_TempVector2
¨¨ 
.
¨¨ 
y
¨¨ 
=
¨¨  !
max
¨¨" %
.
¨¨% &
y
¨¨& '
-
¨¨( )
$num
¨¨* ,
;
¨¨, -
else
©© 
if
©© 
(
©© 
anchor
©© 
==
©©  
AutoUnwrapSettings
©© 1
.
©©1 2
Anchor
©©2 8
.
©©8 9

MiddleLeft
©©9 C
||
©©D F
anchor
©©G M
==
©©N P 
AutoUnwrapSettings
©©Q c
.
©©c d
Anchor
©©d j
.
©©j k
MiddleCenter
©©k w
||
©©x z
anchor©©{ 
==©©‚ „"
AutoUnwrapSettings©©… —
.©©— ˜
Anchor©©˜ 
.©© Ÿ
MiddleRight©©Ÿ ª
)©©ª «
s_TempVector2
ªª 
.
ªª 
y
ªª 
=
ªª  !
(
ªª" #
min
ªª# &
.
ªª& '
y
ªª' (
+
ªª) *
(
ªª+ ,
(
ªª, -
max
ªª- 0
.
ªª0 1
y
ªª1 2
-
ªª3 4
min
ªª5 8
.
ªª8 9
y
ªª9 :
)
ªª: ;
*
ªª< =
$num
ªª> A
)
ªªA B
)
ªªB C
-
ªªD E
$num
ªªF I
;
ªªI J
else
«« 
s_TempVector2
¬¬ 
.
¬¬ 
y
¬¬ 
=
¬¬  !
min
¬¬" %
.
¬¬% &
y
¬¬& '
;
¬¬' (
int
®® 
len
®® 
=
®® 
indexes
®® 
.
®® 
Count
®® #
;
®®# $
for
°° 
(
°° 
int
°° 
i
°° 
=
°° 
$num
°° 
;
°° 
i
°° 
<
°° 
len
°°  #
;
°°# $
i
°°% &
++
°°& (
)
°°( )
{
±± 
uvs
²² 
[
²² 
indexes
²² 
[
²² 
i
²² 
]
²² 
]
²² 
.
²²  
x
²²  !
-=
²²" $
s_TempVector2
²²% 2
.
²²2 3
x
²²3 4
;
²²4 5
uvs
³³ 
[
³³ 
indexes
³³ 
[
³³ 
i
³³ 
]
³³ 
]
³³ 
.
³³  
y
³³  !
-=
³³" $
s_TempVector2
³³% 2
.
³³2 3
y
³³3 4
;
³³4 5
}
´´ 
}
µµ 	
}
¶¶ 
}·· ‰C
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\FaceRebuildData.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed

 

class

 
FaceRebuildData

  
{ 
public 
Face 
face 
; 
public 
List 
< 
Vertex 
> 
vertices $
;$ %
public 
List 
< 
int 
> 
sharedIndexes &
;& '
public 
List 
< 
int 
> 
sharedIndexesUV (
;( )
private 
int 
_appliedOffset "
=# $
$num% &
;& '
public 
int 
Offset 
( 
) 
{ 	
return 
_appliedOffset !
;! "
} 	
public!! 
override!! 
string!! 
ToString!! '
(!!' (
)!!( )
{"" 	
return## 
string## 
.## 
Format##  
(##  !
$str##! +
,##+ ,
vertices##- 5
.##5 6
ToString##6 >
(##> ?
$str##? C
)##C D
,##D E
sharedIndexes##F S
.##S T
ToString##T \
(##\ ]
$str##] a
)##a b
)##b c
;##c d
}$$ 	
public&& 
static&& 
void&& 
Apply&&  
(&&  !
IEnumerable'' 
<'' 
FaceRebuildData'' '
>''' (
newFaces'') 1
,''1 2
ProBuilderMesh(( 
mesh(( 
,((  
List)) 
<)) 
Vertex)) 
>)) 
vertices)) !
=))" #
null))$ (
,))( )
List** 
<** 
Face** 
>** 
faces** 
=** 
null** #
)**# $
{++ 	
if,, 
(,, 
faces,, 
==,, 
null,, 
),, 
faces-- 
=-- 
new-- 
List--  
<--  !
Face--! %
>--% &
(--& '
mesh--' +
.--+ ,
facesInternal--, 9
)--9 :
;--: ;
if// 
(// 
vertices// 
==// 
null//  
)//  !
vertices00 
=00 
new00 
List00 #
<00# $
Vertex00$ *
>00* +
(00+ ,
mesh00, 0
.000 1
GetVertices001 <
(00< =
)00= >
)00> ?
;00? @
var22 
lookup22 
=22 
mesh22 
.22 
sharedVertexLookup22 0
;220 1
var33 
lookupUV33 
=33 
mesh33 
.33  
sharedTextureLookup33  3
;333 4
Apply55 
(55 
newFaces55 
,55 
vertices55 $
,55$ %
faces55& +
,55+ ,
lookup55- 3
,553 4
lookupUV555 =
)55= >
;55> ?
mesh77 
.77 
SetVertices77 
(77 
vertices77 %
)77% &
;77& '
mesh88 
.88 
faces88 
=88 
faces88 
;88 
mesh99 
.99 
SetSharedVertices99 "
(99" #
lookup99# )
)99) *
;99* +
mesh:: 
.:: 
SetSharedTextures:: "
(::" #
lookupUV::# +
)::+ ,
;::, -
};; 	
publicEE 
staticEE 
voidEE 
ApplyEE  
(EE  !
IEnumerableFF 
<FF 
FaceRebuildDataFF '
>FF' (
newFacesFF) 1
,FF1 2
ListGG 
<GG 
VertexGG 
>GG 
verticesGG !
,GG! "
ListHH 
<HH 
FaceHH 
>HH 
facesHH 
,HH 

DictionaryII 
<II 
intII 
,II 
intII 
>II  
sharedVertexLookupII! 3
,II3 4

DictionaryJJ 
<JJ 
intJJ 
,JJ 
intJJ 
>JJ  
sharedTextureLookupJJ! 4
=JJ5 6
nullJJ7 ;
)JJ; <
{KK 	
intLL 
indexLL 
=LL 
verticesLL  
.LL  !
CountLL! &
;LL& '
foreachNN 
(NN 
FaceRebuildDataNN $
rdNN% '
inNN( *
newFacesNN+ 3
)NN3 4
{OO 
FacePP 
facePP 
=PP 
rdPP 
.PP 
facePP #
;PP# $
intQQ 
faceVertexCountQQ #
=QQ$ %
rdQQ& (
.QQ( )
verticesQQ) 1
.QQ1 2
CountQQ2 7
;QQ7 8
boolSS 
hasSharedIndexesSS %
=SS& '
sharedVertexLookupSS( :
!=SS; =
nullSS> B
&&SSC E
rdSSF H
.SSH I
sharedIndexesSSI V
!=SSW Y
nullSSZ ^
&&SS_ a
rdSSb d
.SSd e
sharedIndexesSSe r
.SSr s
CountSSs x
==SSy {
faceVertexCount	SS| ‹
;
SS‹ Œ
boolTT 
hasSharedIndexesUVTT '
=TT( )
sharedTextureLookupTT* =
!=TT> @
nullTTA E
&&TTF H
rdTTI K
.TTK L
sharedIndexesUVTTL [
!=TT\ ^
nullTT_ c
&&TTd f
rdTTg i
.TTi j
sharedIndexesUVTTj y
.TTy z
CountTTz 
==
TT€ ‚
faceVertexCount
TTƒ ’
;
TT’ “
forVV 
(VV 
intVV 
nVV 
=VV 
$numVV 
;VV 
nVV  !
<VV" #
faceVertexCountVV$ 3
;VV3 4
nVV5 6
++VV6 8
)VV8 9
{WW 
intXX 

localIndexXX "
=XX# $
nXX% &
;XX& '
ifZZ 
(ZZ 
sharedVertexLookupZZ *
!=ZZ+ -
nullZZ. 2
)ZZ2 3
sharedVertexLookup[[ *
.[[* +
Add[[+ .
([[. /

localIndex[[/ 9
+[[: ;
index[[< A
,[[A B
hasSharedIndexes[[C S
?[[T U
rd[[V X
.[[X Y
sharedIndexes[[Y f
[[[f g

localIndex[[g q
][[q r
:[[s t
-[[u v
$num[[v w
)[[w x
;[[x y
if]] 
(]] 
sharedTextureLookup]] +
!=]], .
null]]/ 3
&&]]4 6
hasSharedIndexesUV]]7 I
)]]I J
sharedTextureLookup^^ +
.^^+ ,
Add^^, /
(^^/ 0

localIndex^^0 :
+^^; <
index^^= B
,^^B C
rd^^D F
.^^F G
sharedIndexesUV^^G V
[^^V W

localIndex^^W a
]^^a b
)^^b c
;^^c d
}__ 
rdaa 
.aa 
_appliedOffsetaa !
=aa" #
indexaa$ )
;aa) *
intbb 
[bb 
]bb 
faceIndexesbb !
=bb" #
facebb$ (
.bb( )
indexesInternalbb) 8
;bb8 9
fordd 
(dd 
intdd 
ndd 
=dd 
$numdd 
,dd 
cdd  !
=dd" #
faceIndexesdd$ /
.dd/ 0
Lengthdd0 6
;dd6 7
ndd8 9
<dd: ;
cdd< =
;dd= >
ndd? @
++dd@ B
)ddB C
faceIndexesee 
[ee  
nee  !
]ee! "
+=ee# %
indexee& +
;ee+ ,
indexgg 
+=gg 
rdgg 
.gg 
verticesgg $
.gg$ %
Countgg% *
;gg* +
facehh 
.hh 
indexesInternalhh $
=hh% &
faceIndexeshh' 2
;hh2 3
facesii 
.ii 
Addii 
(ii 
faceii 
)ii 
;ii  
verticesjj 
.jj 
AddRangejj !
(jj! "
rdjj" $
.jj$ %
verticesjj% -
)jj- .
;jj. /
}kk 
}ll 	
}mm 
}nn ¿
’D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\HandleOrientation.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public

 

enum

 
HandleOrientation

 !
{ 
World 
= 
$num 
, 
ActiveObject 
= 
$num 
, 
ActiveElement 
= 
$num 
, 
} 
}   µ{
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\InternalUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
InternalUtility  
{ 
[ 	
Obsolete	 
] 
public 
static 
T 
[ 
] 
GetComponents '
<' (
T( )
>) *
(* +
this+ /
IEnumerable0 ;
<; <

GameObject< F
>F G
gameObjectsH S
)S T
whereU Z
T[ \
:] ^
	Component_ h
{ 	
List 
< 
T 
> 
c 
= 
new 
List  
<  !
T! "
>" #
(# $
)$ %
;% &
foreach 
( 

GameObject 
go  "
in# %
gameObjects& 1
)1 2
c 
. 
AddRange 
( 
go 
. 
	transform '
.' (#
GetComponentsInChildren( ?
<? @
T@ A
>A B
(B C
)C D
)D E
;E F
return 
c 
. 
ToArray 
( 
) 
; 
} 	
public 
static 
T 
[ 
] 
GetComponents '
<' (
T( )
>) *
(* +

GameObject+ 5
go6 8
)8 9
where: ?
T@ A
:B C
	ComponentD M
{ 	
return 
go 
. 
	transform 
.  #
GetComponentsInChildren  7
<7 8
T8 9
>9 :
(: ;
); <
;< =
} 	
public 
static 
T 
[ 
] 
GetComponents '
<' (
T( )
>) *
(* +
this+ /
IEnumerable0 ;
<; <
	Transform< E
>E F

transformsG Q
)Q R
whereS X
TY Z
:[ \
	Component] f
{   	
List!! 
<!! 
T!! 
>!! 
c!! 
=!! 
new!! 
List!!  
<!!  !
T!!! "
>!!" #
(!!# $
)!!$ %
;!!% &
foreach"" 
("" 
	Transform"" 
t""  
in""! #

transforms""$ .
)"". /
c## 
.## 
AddRange## 
(## 
t## 
.## #
GetComponentsInChildren## 4
<##4 5
T##5 6
>##6 7
(##7 8
)##8 9
)##9 :
;##: ;
return$$ 
c$$ 
.$$ 
ToArray$$ 
($$ 
)$$ 
as$$ !
T$$" #
[$$# $
]$$$ %
;$$% &
}%% 	
public'' 
static'' 

GameObject''  (
EmptyGameObjectWithTransform''! =
(''= >
	Transform''> G
t''H I
)''I J
{(( 	

GameObject)) 
go)) 
=)), -
new)). 1

GameObject))2 <
())< =
)))= >
;))> ?
go** 
.** 
	transform** 
.** 
position** !
=**, -
t**. /
.**/ 0
position**0 8
;**8 9
go++ 
.++ 
	transform++ 
.++ 
localRotation++ &
=++, -
t++. /
.++/ 0
localRotation++0 =
;++= >
go,, 
.,, 
	transform,, 
.,, 

localScale,, #
=,,, -
t,,. /
.,,/ 0

localScale,,0 :
;,,: ;
StageUtility// 
.// )
PlaceGameObjectInCurrentStage// 6
(//6 7
go//7 9
)//9 :
;//: ;
return22 
go22 
;22 
}33 	
public55 
static55 
T55 
NextEnumValue55 %
<55% &
T55& '
>55' (
(55( )
this55) -
T55. /
current550 7
)557 8
where559 >
T55? @
:55A B
IConvertible55C O
{66 	
Assert77 
.77 
IsTrue77 
(77 
current77 !
is77" $
Enum77% )
)77) *
;77* +
var99 
values99 
=99 
Enum99 
.99 
	GetValues99 '
(99' (
current99( /
.99/ 0
GetType990 7
(997 8
)998 9
)999 :
;99: ;
for;; 
(;; 
int;; 
i;; 
=;; 
$num;; 
,;; 
c;; 
=;; 
values;;  &
.;;& '
Length;;' -
;;;- .
i;;/ 0
<;;1 2
c;;3 4
;;;4 5
i;;6 7
++;;7 9
);;9 :
if<< 
(<< 
current<< 
.<< 
Equals<< "
(<<" #
values<<# )
.<<) *
GetValue<<* 2
(<<2 3
(<<3 4
i<<4 5
)<<5 6
)<<6 7
)<<7 8
)<<8 9
return== 
(== 
T== 
)== 
values== $
.==$ %
GetValue==% -
(==- .
(==. /
i==/ 0
+==1 2
$num==3 4
)==4 5
%==6 7
c==8 9
)==9 :
;==: ;
return?? 
current?? 
;?? 
}@@ 	
publicBB 
staticBB 
stringBB 
ControlKeyStringBB -
(BB- .
charBB. 2
	characterBB3 <
)BB< =
{CC 	
ifDD 
(DD 
	characterDD 
==DD 
PreferenceKeysDD +
.DD+ ,
	CMD_SUPERDD, 5
)DD5 6
returnEE 
$strEE  
;EE  !
elseFF 
ifFF 
(FF 
	characterFF 
==FF !
PreferenceKeysFF" 0
.FF0 1
	CMD_SHIFTFF1 :
)FF: ;
returnGG 
$strGG 
;GG 
elseHH 
ifHH 
(HH 
	characterHH 
==HH !
PreferenceKeysHH" 0
.HH0 1

CMD_OPTIONHH1 ;
)HH; <
returnII 
$strII 
;II 
elseJJ 
ifJJ 
(JJ 
	characterJJ 
==JJ !
PreferenceKeysJJ" 0
.JJ0 1
CMD_ALTJJ1 8
)JJ8 9
returnKK 
$strKK 
;KK 
elseLL 
ifLL 
(LL 
	characterLL 
==LL !
PreferenceKeysLL" 0
.LL0 1

CMD_DELETELL1 ;
)LL; <
returnNN 
$strNN "
;NN" #
elseRR 
returnSS 
	characterSS  
.SS  !
ToStringSS! )
(SS) *
)SS* +
;SS+ ,
}TT 	
publicYY 
staticYY 
boolYY 
TryParseColorYY (
(YY( )
stringYY) /
valueYY0 5
,YY5 6
refYY7 :
ColorYY; @
colYYA D
)YYD E
{ZZ 	
string[[ 
valid[[ 
=[[ 
$str[[ *
;[[* +
value\\ 
=\\ 
new\\ 
string\\ 
(\\ 
value\\ $
.\\$ %
Where\\% *
(\\* +
c\\+ ,
=>\\- /
valid\\0 5
.\\5 6
Contains\\6 >
(\\> ?
c\\? @
)\\@ A
)\\A B
.\\B C
ToArray\\C J
(\\J K
)\\K L
)\\L M
;\\M N
string]] 
[]] 
]]] 
rgba]] 
=]] 
value]] !
.]]! "
Split]]" '
(]]' (
$char]]( +
)]]+ ,
;]], -
if__ 
(__ 
rgba__ 
.__ 
Length__ 
<__ 
$num__ 
)__  
return`` 
false`` 
;`` 
trybb 
{cc 
floatdd 
rdd 
=dd 
floatdd 
.dd  
Parsedd  %
(dd% &
rgbadd& *
[dd* +
$numdd+ ,
]dd, -
)dd- .
;dd. /
floatee 
gee 
=ee 
floatee 
.ee  
Parseee  %
(ee% &
rgbaee& *
[ee* +
$numee+ ,
]ee, -
)ee- .
;ee. /
floatff 
bff 
=ff 
floatff 
.ff  
Parseff  %
(ff% &
rgbaff& *
[ff* +
$numff+ ,
]ff, -
)ff- .
;ff. /
floatgg 
agg 
=gg 
floatgg 
.gg  
Parsegg  %
(gg% &
rgbagg& *
[gg* +
$numgg+ ,
]gg, -
)gg- .
;gg. /
colii 
.ii 
rii 
=ii 
rii 
;ii 
coljj 
.jj 
gjj 
=jj 
gjj 
;jj 
colkk 
.kk 
bkk 
=kk 
bkk 
;kk 
colll 
.ll 
all 
=ll 
all 
;ll 
}mm 
catchnn 
{oo 
returnpp 
falsepp 
;pp 
}qq 
returnss 
truess 
;ss 
}tt 	
public}} 
static}} 
Vector3}} 
[}} 
]}}  
StringToVector3Array}}  4
(}}4 5
string}}5 ;
str}}< ?
)}}? @
{~~ 	
List 
< 
Vector3 
> 
v 
= 
new !
List" &
<& '
Vector3' .
>. /
(/ 0
)0 1
;1 2
str
 
=
 
str
 
.
 
Replace
 
(
 
$str
 !
,
! "
$str
# %
)
% &
;
& '
string
‚‚ 
[
‚‚ 
]
‚‚ 
lines
‚‚ 
=
‚‚ 
str
‚‚  
.
‚‚  !
Split
‚‚! &
(
‚‚& '
$char
‚‚' +
)
‚‚+ ,
;
‚‚, -
foreach
„„ 
(
„„ 
string
„„ 
vec
„„ 
in
„„  "
lines
„„# (
)
„„( )
{
…… 
if
†† 
(
†† 
vec
†† 
.
†† 
Contains
††  
(
††  !
$str
††! %
)
††% &
)
††& '
continue
‡‡ 
;
‡‡ 
string
‰‰ 
[
‰‰ 
]
‰‰ 
values
‰‰ 
=
‰‰  !
vec
‰‰" %
.
‰‰% &
Split
‰‰& +
(
‰‰+ ,
$char
‰‰, /
)
‰‰/ 0
;
‰‰0 1
if
‹‹ 
(
‹‹ 
values
‹‹ 
.
‹‹ 
Length
‹‹ !
<
‹‹" #
$num
‹‹$ %
)
‹‹% &
continue
ŒŒ 
;
ŒŒ 
float
 
v0
 
,
 
v1
 
,
 
v2
  
;
  !
if
 
(
 
!
 
float
 
.
 
TryParse
 #
(
# $
values
$ *
[
* +
$num
+ ,
]
, -
,
- .
System
/ 5
.
5 6
Globalization
6 C
.
C D
NumberStyles
D P
.
P Q
Any
Q T
,
T U
System
V \
.
\ ]
Globalization
] j
.
j k
CultureInfo
k v
.
v w
InvariantCulturew ‡
,‡ ˆ
out‰ Œ
v0 
) 
) ‘
continue
 
;
 
if
‘‘ 
(
‘‘ 
!
‘‘ 
float
‘‘ 
.
‘‘ 
TryParse
‘‘ #
(
‘‘# $
values
‘‘$ *
[
‘‘* +
$num
‘‘+ ,
]
‘‘, -
,
‘‘- .
System
‘‘/ 5
.
‘‘5 6
Globalization
‘‘6 C
.
‘‘C D
NumberStyles
‘‘D P
.
‘‘P Q
Any
‘‘Q T
,
‘‘T U
System
‘‘V \
.
‘‘\ ]
Globalization
‘‘] j
.
‘‘j k
CultureInfo
‘‘k v
.
‘‘v w
InvariantCulture‘‘w ‡
,‘‘‡ ˆ
out‘‘‰ Œ
v1‘‘ 
)‘‘ 
)‘‘ ‘
continue
’’ 
;
’’ 
if
““ 
(
““ 
!
““ 
float
““ 
.
““ 
TryParse
““ #
(
““# $
values
““$ *
[
““* +
$num
““+ ,
]
““, -
,
““- .
System
““/ 5
.
““5 6
Globalization
““6 C
.
““C D
NumberStyles
““D P
.
““P Q
Any
““Q T
,
““T U
System
““V \
.
““\ ]
Globalization
““] j
.
““j k
CultureInfo
““k v
.
““v w
InvariantCulture““w ‡
,““‡ ˆ
out““‰ Œ
v2““ 
)““ 
)““ ‘
continue
”” 
;
”” 
v
•• 
.
•• 
Add
•• 
(
•• 
new
•• 
Vector3
•• !
(
••! "
v0
••" $
,
••$ %
v1
••& (
,
••( )
v2
••* ,
)
••, -
)
••- .
;
••. /
}
–– 
return
—— 
v
—— 
.
—— 
ToArray
—— 
(
—— 
)
—— 
;
—— 
}
˜˜ 	
public
©© 
static
©© 
T
©© 
DemandComponent
©© '
<
©©' (
T
©©( )
>
©©) *
(
©©* +
this
©©+ /
	Component
©©0 9
	component
©©: C
)
©©C D
where
©©E J
T
©©K L
:
©©M N
	Component
©©O X
{
ªª 	
return
«« 
	component
«« 
.
«« 

gameObject
«« '
.
««' (
DemandComponent
««( 7
<
««7 8
T
««8 9
>
««9 :
(
««: ;
)
««; <
;
««< =
}
¬¬ 	
public
®® 
static
®® 
T
®® 
DemandComponent
®® '
<
®®' (
T
®®( )
>
®®) *
(
®®* +
this
®®+ /

GameObject
®®0 :

gameObject
®®; E
)
®®E F
where
®®G L
T
®®M N
:
®®O P
	Component
®®Q Z
{
¯¯ 	
T
°° 
	component
°° 
;
°° 
if
±± 
(
±± 
!
±± 

gameObject
±± 
.
±± 
TryGetComponent
±± +
<
±±+ ,
T
±±, -
>
±±- .
(
±±. /
out
±±/ 2
	component
±±3 <
)
±±< =
)
±±= >
	component
²² 
=
²² 

gameObject
²² &
.
²²& '
AddComponent
²²' 3
<
²²3 4
T
²²4 5
>
²²5 6
(
²²6 7
)
²²7 8
;
²²8 9
return
³³ 
	component
³³ 
;
³³ 
}
´´ 	
}
µµ 
}¶¶ ­
‡D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Normal.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

struct 
Normal 
: 

IEquatable %
<% &
Normal& ,
>, -
{		 
public 
Vector3 
normal 
{ 
get  #
;# $
set% (
;( )
}* +
public 
Vector4 
tangent 
{  
get! $
;$ %
set& )
;) *
}+ ,
public 
Vector3 
	bitangent  
{! "
get# &
;& '
set( +
;+ ,
}- .
public 
override 
bool 
Equals #
(# $
object$ *
obj+ .
). /
{ 	
return 
obj 
is 
Normal  
&&! #
Equals$ *
(* +
(+ ,
Normal, 2
)2 3
obj3 6
)6 7
;7 8
} 	
public 
override 
int 
GetHashCode '
(' (
)( )
{ 	
	unchecked   
{!! 
int"" 
hashCode"" 
="" 

VectorHash"" )
."") *
GetHashCode""* 5
(""5 6
normal""6 <
)""< =
;""= >
hashCode## 
=## 
(## 
hashCode## $
*##% &
$num##' *
)##* +
^##, -

VectorHash##. 8
.##8 9
GetHashCode##9 D
(##D E
tangent##E L
)##L M
;##M N
hashCode$$ 
=$$ 
($$ 
hashCode$$ $
*$$% &
$num$$' *
)$$* +
^$$, -

VectorHash$$. 8
.$$8 9
GetHashCode$$9 D
($$D E
	bitangent$$E N
)$$N O
;$$O P
return%% 
hashCode%% 
;%%  
}&& 
}'' 	
public)) 
bool)) 
Equals)) 
()) 
Normal)) !
other))" '
)))' (
{** 	
return++ 
Math++ 
.++ 
Approx3++ 
(++  
normal++  &
,++& '
other++( -
.++- .
normal++. 4
)++4 5
&&++6 8
Math,, 
.,, 
Approx3,, 
(,, 
tangent,, $
,,,$ %
other,,& +
.,,+ ,
tangent,,, 3
),,3 4
&&,,5 7
Math-- 
.-- 
Approx3-- 
(-- 
	bitangent-- &
,--& '
other--( -
.--- .
	bitangent--. 7
)--7 8
;--8 9
}.. 	
public00 
static00 
bool00 
operator00 #
==00# %
(00% &
Normal00& ,
a00- .
,00. /
Normal000 6
b007 8
)008 9
{11 	
return22 
a22 
.22 
Equals22 
(22 
b22 
)22 
;22 
}33 	
public55 
static55 
bool55 
operator55 #
!=55# %
(55% &
Normal55& ,
a55- .
,55. /
Normal550 6
b557 8
)558 9
{66 	
return77 
!77 
(77 
a77 
==77 
b77 
)77 
;77 
}88 	
}99 
}:: Ô
‡D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Entity.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[		 %
DisallowMultipleComponent		 
]		 
[

 
AddComponentMenu

 
(

 
$str

 
)

 
]

 
sealed 

class 
Entity 
: 
MonoBehaviour '
{ 
public 

EntityType 

entityType $
{% &
get' *
{+ ,
return- 3
m_EntityType4 @
;@ A
}B C
}D E
[ 	
SerializeField	 
] 
[ 	
HideInInspector	 
] 
[ 	 
FormerlySerializedAs	 
( 
$str +
)+ ,
], -

EntityType 
m_EntityType 
;  
public 
void 
Awake 
( 
) 
{ 	
MeshRenderer 
mr 
= 
GetComponent *
<* +
MeshRenderer+ 7
>7 8
(8 9
)9 :
;: ;
if 
( 
! 
mr 
) 
return 
; 
switch 
( 

entityType 
) 
{ 
case 

EntityType 
.  
Occluder  (
:( )
break   
;   
case"" 

EntityType"" 
.""  
Detail""  &
:""& '
break## 
;## 
case%% 

EntityType%% 
.%%  
Trigger%%  '
:%%' (
mr&& 
.&& 
enabled&& 
=&&  
false&&! &
;&&& '
break'' 
;'' 
case)) 

EntityType)) 
.))  
Collider))  (
:))( )
mr** 
.** 
enabled** 
=**  
false**! &
;**& '
break++ 
;++ 
},, 
}-- 	
public33 
void33 
	SetEntity33 
(33 

EntityType33 (
t33) *
)33* +
{44 	
m_EntityType55 
=55 
t55 
;55 
}66 	
}77 
}88 ş6
‹D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\EdgeLookup.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

struct 

EdgeLookup 
: 

IEquatable )
<) *

EdgeLookup* 4
>4 5
{ 
Edge 
m_Local 
; 
Edge 
m_Common 
; 
public 
Edge 
local 
{ 	
get 
{ 
return 
m_Local  
;  !
}" #
set 
{ 
m_Local 
= 
value !
;! "
}# $
} 	
public   
Edge   
common   
{!! 	
get"" 
{"" 
return"" 
m_Common"" !
;""! "
}""# $
set## 
{## 
m_Common## 
=## 
value## "
;##" #
}##$ %
}$$ 	
public++ 

EdgeLookup++ 
(++ 
Edge++ 
common++ %
,++% &
Edge++' +
local++, 1
)++1 2
{,, 	
m_Common-- 
=-- 
common-- 
;-- 
m_Local.. 
=.. 
local.. 
;.. 
}// 	
public88 

EdgeLookup88 
(88 
int88 
cx88  
,88  !
int88" %
cy88& (
,88( )
int88* -
x88. /
,88/ 0
int881 4
y885 6
)886 7
{99 	
m_Common:: 
=:: 
new:: 
Edge:: 
(::  
cx::  "
,::" #
cy::$ &
)::& '
;::' (
m_Local;; 
=;; 
new;; 
Edge;; 
(;; 
x;;  
,;;  !
y;;" #
);;# $
;;;$ %
}<< 	
publicCC 
boolCC 
EqualsCC 
(CC 

EdgeLookupCC %
otherCC& +
)CC+ ,
{DD 	
returnEE 
otherEE 
.EE 
commonEE 
.EE  
EqualsEE  &
(EE& '
commonEE' -
)EE- .
;EE. /
}FF 	
publicMM 
overrideMM 
boolMM 
EqualsMM #
(MM# $
objectMM$ *
objMM+ .
)MM. /
{NN 	
returnOO 
!OO 
ReferenceEqualsOO #
(OO# $
objOO$ '
,OO' (
nullOO) -
)OO- .
&&OO/ 1
EqualsOO2 8
(OO8 9
(OO9 :

EdgeLookupOO: D
)OOD E
objOOE H
)OOH I
;OOI J
}PP 	
publicRR 
overrideRR 
intRR 
GetHashCodeRR '
(RR' (
)RR( )
{SS 	
returnTT 
commonTT 
.TT 
GetHashCodeTT %
(TT% &
)TT& '
;TT' (
}UU 	
publicWW 
staticWW 
boolWW 
operatorWW #
==WW# %
(WW% &

EdgeLookupWW& 0
aWW1 2
,WW2 3

EdgeLookupWW4 >
bWW? @
)WW@ A
{XX 	
returnYY 
EqualsYY 
(YY 
aYY 
,YY 
bYY 
)YY 
;YY  
}ZZ 	
public\\ 
static\\ 
bool\\ 
operator\\ #
!=\\# %
(\\% &

EdgeLookup\\& 0
a\\1 2
,\\2 3

EdgeLookup\\4 >
b\\? @
)\\@ A
{]] 	
return^^ 
!^^ 
Equals^^ 
(^^ 
a^^ 
,^^ 
b^^ 
)^^  
;^^  !
}__ 	
publicee 
overrideee 
stringee 
ToStringee '
(ee' (
)ee( )
{ff 	
returngg 
stringgg 
.gg 
Formatgg  
(gg  !
$strgg! H
,ggH I
commonggJ P
.ggP Q
aggQ R
,ggR S
commonggT Z
.ggZ [
bgg[ \
,gg\ ]
localgg^ c
.ggc d
aggd e
,gge f
localggg l
.ggl m
bggm n
)ggn o
;ggo p
}hh 	
publicpp 
staticpp 
IEnumerablepp !
<pp! "

EdgeLookuppp" ,
>pp, -
GetEdgeLookuppp. ;
(pp; <
IEnumerablepp< G
<ppG H
EdgeppH L
>ppL M
edgesppN S
,ppS T

DictionaryppU _
<pp_ `
intpp` c
,ppc d
intppe h
>pph i
lookupppj p
)ppp q
{qq 	
returnrr 
edgesrr 
.rr 
Selectrr 
(rr  
xrr  !
=>rr" $
newrr% (

EdgeLookuprr) 3
(rr3 4
newrr4 7
Edgerr8 <
(rr< =
lookuprr= C
[rrC D
xrrD E
.rrE F
arrF G
]rrG H
,rrH I
lookuprrJ P
[rrP Q
xrrQ R
.rrR S
brrS T
]rrT U
)rrU V
,rrV W
xrrX Y
)rrY Z
)rrZ [
;rr[ \
}ss 	
public{{ 
static{{ 
HashSet{{ 
<{{ 

EdgeLookup{{ (
>{{( ) 
GetEdgeLookupHashSet{{* >
({{> ?
IEnumerable{{? J
<{{J K
Edge{{K O
>{{O P
edges{{Q V
,{{V W

Dictionary{{X b
<{{b c
int{{c f
,{{f g
int{{h k
>{{k l
lookup{{m s
){{s t
{|| 	
if}} 
(}} 
lookup}} 
==}} 
null}} 
||}} !
edges}}" '
==}}( *
null}}+ /
)}}/ 0
return~~ 
null~~ 
;~~ 
var 
hash 
= 
new 
HashSet "
<" #

EdgeLookup# -
>- .
(. /
)/ 0
;0 1
foreach
€€ 
(
€€ 
var
€€ 
local
€€ 
in
€€ !
edges
€€" '
)
€€' (
hash
 
.
 
Add
 
(
 
new
 

EdgeLookup
 '
(
' (
new
( +
Edge
, 0
(
0 1
lookup
1 7
[
7 8
local
8 =
.
= >
a
> ?
]
? @
,
@ A
lookup
B H
[
H I
local
I N
.
N O
b
O P
]
P Q
)
Q R
,
R S
local
T Y
)
Y Z
)
Z [
;
[ \
return
‚‚ 
hash
‚‚ 
;
‚‚ 
}
ƒƒ 	
}
„„ 
}…… Ä³
‰D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Bounds2D.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed

 

class

 
Bounds2D

 
{ 
public 
Vector2 
center 
= 
Vector2  '
.' (
zero( ,
;, -
[ 	
SerializeField	 
] 
Vector2  
m_Size! '
=( )
Vector2* 1
.1 2
zero2 6
;6 7
[ 	
SerializeField	 
] 
Vector2  
	m_Extents! *
=+ ,
Vector2- 4
.4 5
zero5 9
;9 :
public 
Vector2 
size 
{ 	
get 
{ 
return 
m_Size 
;  
}! "
set 
{ 
m_Size 
= 
value 
; 
	m_Extents 
. 
x 
= 
m_Size $
.$ %
x% &
*' (
$num) ,
;, -
	m_Extents 
. 
y 
= 
m_Size $
.$ %
y% &
*' (
$num) ,
;, -
} 
} 	
public 
Vector2 
extents 
{ 	
get 
{ 
return 
	m_Extents "
;" #
}$ %
}   	
public%% 
Vector2%% 
[%% 
]%% 
corners%%  
{&& 	
get'' 
{(( 
return)) 
new)) 
Vector2)) "
[))" #
]))# $
{))% &
new** 
Vector2** 
(**  
center**  &
.**& '
x**' (
-**) *
extents**+ 2
.**2 3
x**3 4
,**4 5
center**6 <
.**< =
y**= >
+**? @
extents**A H
.**H I
y**I J
)**J K
,**K L
new++ 
Vector2++ 
(++  
center++  &
.++& '
x++' (
+++) *
extents+++ 2
.++2 3
x++3 4
,++4 5
center++6 <
.++< =
y++= >
+++? @
extents++A H
.++H I
y++I J
)++J K
,++K L
new,, 
Vector2,, 
(,,  
center,,  &
.,,& '
x,,' (
-,,) *
extents,,+ 2
.,,2 3
x,,3 4
,,,4 5
center,,6 <
.,,< =
y,,= >
-,,? @
extents,,A H
.,,H I
y,,I J
),,J K
,,,K L
new-- 
Vector2-- 
(--  
center--  &
.--& '
x--' (
+--) *
extents--+ 2
.--2 3
x--3 4
,--4 5
center--6 <
.--< =
y--= >
---? @
extents--A H
.--H I
y--I J
)--J K
}.. 
;.. 
}// 
}00 	
public22 
Bounds2D22 
(22 
)22 
{33 	
}33	 

public55 
Bounds2D55 
(55 
Vector255 
center55  &
,55& '
Vector255( /
size550 4
)554 5
{66 	
this77 
.77 
center77 
=77 
center77  
;77  !
this88 
.88 
size88 
=88 
size88 
;88 
}99 	
public?? 
Bounds2D?? 
(?? 
IList?? 
<?? 
Vector2?? %
>??% &
points??' -
)??- .
{@@ 	
SetWithPointsAA 
(AA 
pointsAA  
)AA  !
;AA! "
}BB 	
publicII 
Bounds2DII 
(II 
IListII 
<II 
Vector2II %
>II% &
pointsII' -
,II- .
IListII/ 4
<II4 5
intII5 8
>II8 9
indexesII: A
)IIA B
{JJ 	
SetWithPointsKK 
(KK 
pointsKK  
,KK  !
indexesKK" )
)KK) *
;KK* +
}LL 	
internalSS 
Bounds2DSS 
(SS 
Vector3SS !
[SS! "
]SS" #
pointsSS$ *
,SS* +
EdgeSS, 0
[SS0 1
]SS1 2
edgesSS3 8
)SS8 9
{TT 	
floatUU 
xMinUU 
=UU 
$numUU 
,UU 
xMaxVV$ (
=VV) *
$numVV+ -
,VV- .
yMinWW$ (
=WW) *
$numWW+ -
,WW- .
yMaxXX$ (
=XX) *
$numXX+ -
;XX- .
ifZZ 
(ZZ 
pointsZZ 
.ZZ 
LengthZZ 
>ZZ 
$numZZ  !
&&ZZ" $
edgesZZ% *
.ZZ* +
LengthZZ+ 1
>ZZ2 3
$numZZ4 5
)ZZ5 6
{[[ 
xMin\\ 
=\\ 
points\\ 
[\\ 
edges\\ #
[\\# $
$num\\$ %
]\\% &
.\\& '
a\\' (
]\\( )
.\\) *
x\\* +
;\\+ ,
yMin]] 
=]] 
points]] 
[]] 
edges]] #
[]]# $
$num]]$ %
]]]% &
.]]& '
a]]' (
]]]( )
.]]) *
y]]* +
;]]+ ,
xMax^^ 
=^^ 
xMin^^ 
;^^ 
yMax__ 
=__ 
yMin__ 
;__ 
foraa 
(aa 
intaa 
iaa 
=aa 
$numaa 
;aa 
iaa  !
<aa" #
edgesaa$ )
.aa) *
Lengthaa* 0
;aa0 1
iaa2 3
++aa3 5
)aa5 6
{bb 
xMincc 
=cc 
Mathfcc  
.cc  !
Mincc! $
(cc$ %
xMincc% )
,cc) *
pointscc+ 1
[cc1 2
edgescc2 7
[cc7 8
icc8 9
]cc9 :
.cc: ;
acc; <
]cc< =
.cc= >
xcc> ?
)cc? @
;cc@ A
xMindd 
=dd 
Mathfdd  
.dd  !
Mindd! $
(dd$ %
xMindd% )
,dd) *
pointsdd+ 1
[dd1 2
edgesdd2 7
[dd7 8
idd8 9
]dd9 :
.dd: ;
bdd; <
]dd< =
.dd= >
xdd> ?
)dd? @
;dd@ A
yMinee 
=ee 
Mathfee  
.ee  !
Minee! $
(ee$ %
yMinee% )
,ee) *
pointsee+ 1
[ee1 2
edgesee2 7
[ee7 8
iee8 9
]ee9 :
.ee: ;
aee; <
]ee< =
.ee= >
yee> ?
)ee? @
;ee@ A
yMinff 
=ff 
Mathfff  
.ff  !
Minff! $
(ff$ %
yMinff% )
,ff) *
pointsff+ 1
[ff1 2
edgesff2 7
[ff7 8
iff8 9
]ff9 :
.ff: ;
bff; <
]ff< =
.ff= >
yff> ?
)ff? @
;ff@ A
xMaxhh 
=hh 
Mathfhh  
.hh  !
Maxhh! $
(hh$ %
xMaxhh% )
,hh) *
pointshh+ 1
[hh1 2
edgeshh2 7
[hh7 8
ihh8 9
]hh9 :
.hh: ;
ahh; <
]hh< =
.hh= >
xhh> ?
)hh? @
;hh@ A
xMaxii 
=ii 
Mathfii  
.ii  !
Maxii! $
(ii$ %
xMaxii% )
,ii) *
pointsii+ 1
[ii1 2
edgesii2 7
[ii7 8
iii8 9
]ii9 :
.ii: ;
bii; <
]ii< =
.ii= >
xii> ?
)ii? @
;ii@ A
yMaxjj 
=jj 
Mathfjj  
.jj  !
Maxjj! $
(jj$ %
yMaxjj% )
,jj) *
pointsjj+ 1
[jj1 2
edgesjj2 7
[jj7 8
ijj8 9
]jj9 :
.jj: ;
ajj; <
]jj< =
.jj= >
yjj> ?
)jj? @
;jj@ A
yMaxkk 
=kk 
Mathfkk  
.kk  !
Maxkk! $
(kk$ %
yMaxkk% )
,kk) *
pointskk+ 1
[kk1 2
edgeskk2 7
[kk7 8
ikk8 9
]kk9 :
.kk: ;
bkk; <
]kk< =
.kk= >
ykk> ?
)kk? @
;kk@ A
}ll 
}mm 
thisoo 
.oo 
centeroo 
=oo 
newoo 
Vector2oo %
(oo% &
(oo& '
xMinoo' +
+oo, -
xMaxoo. 2
)oo2 3
/oo4 5
$numoo6 8
,oo8 9
(oo: ;
yMinoo; ?
+oo@ A
yMaxooB F
)ooF G
/ooH I
$numooJ L
)ooL M
;ooM N
thispp 
.pp 
sizepp 
=pp 
newpp 
Vector3pp #
(pp# $
xMaxpp$ (
-pp) *
xMinpp+ /
,pp/ 0
yMaxpp1 5
-pp6 7
yMinpp8 <
)pp< =
;pp= >
}qq 	
publicss 
Bounds2Dss 
(ss 
Vector2ss 
[ss  
]ss  !
pointsss" (
,ss( )
intss* -
lengthss. 4
)ss4 5
{tt 	
floatuu 
xMinuu 
=uu 
$numuu 
,uu 
xMaxvv" &
=vv' (
$numvv) +
,vv+ ,
yMinww" &
=ww' (
$numww) +
,ww+ ,
yMaxxx" &
=xx' (
$numxx) +
;xx+ ,
ifzz 
(zz 
pointszz 
.zz 
Lengthzz 
>zz 
$numzz  !
)zz! "
{{{ 
xMin|| 
=|| 
points|| 
[|| 
$num|| 
]||  
.||  !
x||! "
;||" #
yMin}} 
=}} 
points}} 
[}} 
$num}} 
]}}  
.}}  !
y}}! "
;}}" #
xMax~~ 
=~~ 
xMin~~ 
;~~ 
yMax 
= 
yMin 
; 
for
 
(
 
int
 
i
 
=
 
$num
 
;
 
i
  !
<
" #
length
$ *
;
* +
i
, -
++
- /
)
/ 0
{
‚‚ 
xMin
ƒƒ 
=
ƒƒ 
Mathf
ƒƒ  
.
ƒƒ  !
Min
ƒƒ! $
(
ƒƒ$ %
xMin
ƒƒ% )
,
ƒƒ) *
points
ƒƒ+ 1
[
ƒƒ1 2
i
ƒƒ2 3
]
ƒƒ3 4
.
ƒƒ4 5
x
ƒƒ5 6
)
ƒƒ6 7
;
ƒƒ7 8
yMin
„„ 
=
„„ 
Mathf
„„  
.
„„  !
Min
„„! $
(
„„$ %
yMin
„„% )
,
„„) *
points
„„+ 1
[
„„1 2
i
„„2 3
]
„„3 4
.
„„4 5
y
„„5 6
)
„„6 7
;
„„7 8
xMax
†† 
=
†† 
Mathf
††  
.
††  !
Max
††! $
(
††$ %
xMax
††% )
,
††) *
points
††+ 1
[
††1 2
i
††2 3
]
††3 4
.
††4 5
x
††5 6
)
††6 7
;
††7 8
yMax
‡‡ 
=
‡‡ 
Mathf
‡‡  
.
‡‡  !
Max
‡‡! $
(
‡‡$ %
yMax
‡‡% )
,
‡‡) *
points
‡‡+ 1
[
‡‡1 2
i
‡‡2 3
]
‡‡3 4
.
‡‡4 5
y
‡‡5 6
)
‡‡6 7
;
‡‡7 8
}
ˆˆ 
}
‰‰ 
this
‹‹ 
.
‹‹ 
center
‹‹ 
=
‹‹ 
new
‹‹ 
Vector2
‹‹ %
(
‹‹% &
(
‹‹& '
xMin
‹‹' +
+
‹‹, -
xMax
‹‹. 2
)
‹‹2 3
/
‹‹4 5
$num
‹‹6 8
,
‹‹8 9
(
‹‹: ;
yMin
‹‹; ?
+
‹‹@ A
yMax
‹‹B F
)
‹‹F G
/
‹‹H I
$num
‹‹J L
)
‹‹L M
;
‹‹M N
this
ŒŒ 
.
ŒŒ 
size
ŒŒ 
=
ŒŒ 
new
ŒŒ 
Vector3
ŒŒ #
(
ŒŒ# $
xMax
ŒŒ$ (
-
ŒŒ) *
xMin
ŒŒ+ /
,
ŒŒ/ 0
yMax
ŒŒ1 5
-
ŒŒ6 7
yMin
ŒŒ8 <
)
ŒŒ< =
;
ŒŒ= >
}
 	
public
”” 
bool
”” 
ContainsPoint
”” !
(
””! "
Vector2
””" )
point
””* /
)
””/ 0
{
•• 	
return
–– 
!
–– 
(
–– 
point
–– 
.
–– 
x
–– 
>
–– 
center
–– %
.
––% &
x
––& '
+
––( )
extents
––* 1
.
––1 2
x
––2 3
||
––4 6
point
—— 
.
—— 
x
—— 
<
—— 
center
—— %
.
——% &
x
——& '
-
——( )
extents
——* 1
.
——1 2
x
——2 3
||
——4 6
point
˜˜ 
.
˜˜ 
y
˜˜ 
>
˜˜ 
center
˜˜ %
.
˜˜% &
y
˜˜& '
+
˜˜( )
extents
˜˜* 1
.
˜˜1 2
y
˜˜2 3
||
˜˜4 6
point
™™ 
.
™™ 
y
™™ 
<
™™ 
center
™™ %
.
™™% &
y
™™& '
-
™™( )
extents
™™* 1
.
™™1 2
y
™™2 3
)
™™3 4
;
™™4 5
}
šš 	
public
¢¢ 
bool
¢¢ #
IntersectsLineSegment
¢¢ )
(
¢¢) *
Vector2
¢¢* 1
	lineStart
¢¢2 ;
,
¢¢; <
Vector2
¢¢= D
lineEnd
¢¢E L
)
¢¢L M
{
££ 	
if
¤¤ 
(
¤¤ 
ContainsPoint
¤¤ 
(
¤¤ 
	lineStart
¤¤ '
)
¤¤' (
||
¤¤) +
ContainsPoint
¤¤, 9
(
¤¤9 :
lineEnd
¤¤: A
)
¤¤A B
)
¤¤B C
{
¥¥ 
return
¦¦ 
true
¦¦ 
;
¦¦ 
}
§§ 
else
¨¨ 
{
©© 
Vector2
ªª 
[
ªª 
]
ªª 
aabb
ªª 
=
ªª  
corners
ªª! (
;
ªª( )
return
«« 
(
«« 
Math
«« 
.
«« %
GetLineSegmentIntersect
«« 4
(
««4 5
aabb
««5 9
[
««9 :
$num
««: ;
]
««; <
,
««< =
aabb
««> B
[
««B C
$num
««C D
]
««D E
,
««E F
	lineStart
««G P
,
««P Q
lineEnd
««R Y
)
««Y Z
||
««[ ]
Math
¬¬ 
.
¬¬ %
GetLineSegmentIntersect
¬¬ 4
(
¬¬4 5
aabb
¬¬5 9
[
¬¬9 :
$num
¬¬: ;
]
¬¬; <
,
¬¬< =
aabb
¬¬> B
[
¬¬B C
$num
¬¬C D
]
¬¬D E
,
¬¬E F
	lineStart
¬¬G P
,
¬¬P Q
lineEnd
¬¬R Y
)
¬¬Y Z
||
¬¬[ ]
Math
­­ 
.
­­ %
GetLineSegmentIntersect
­­ 4
(
­­4 5
aabb
­­5 9
[
­­9 :
$num
­­: ;
]
­­; <
,
­­< =
aabb
­­> B
[
­­B C
$num
­­C D
]
­­D E
,
­­E F
	lineStart
­­G P
,
­­P Q
lineEnd
­­R Y
)
­­Y Z
||
­­[ ]
Math
®® 
.
®® %
GetLineSegmentIntersect
®® 4
(
®®4 5
aabb
®®5 9
[
®®9 :
$num
®®: ;
]
®®; <
,
®®< =
aabb
®®> B
[
®®B C
$num
®®C D
]
®®D E
,
®®E F
	lineStart
®®G P
,
®®P Q
lineEnd
®®R Y
)
®®Y Z
)
®®Z [
;
®®[ \
}
¯¯ 
}
°° 	
public
·· 
bool
·· 

Intersects
·· 
(
·· 
Bounds2D
·· '
bounds
··( .
)
··. /
{
¸¸ 	
Vector2
¹¹ 
dist
¹¹ 
=
¹¹ 
this
¹¹ 
.
¹¹  
center
¹¹  &
-
¹¹' (
bounds
¹¹) /
.
¹¹/ 0
center
¹¹0 6
;
¹¹6 7
Vector2
ºº 
size
ºº 
=
ºº 
this
ºº 
.
ºº  
size
ºº  $
+
ºº% &
bounds
ºº' -
.
ºº- .
size
ºº. 2
;
ºº2 3
return
¼¼ 
Mathf
¼¼ 
.
¼¼ 
Abs
¼¼ 
(
¼¼ 
dist
¼¼ !
.
¼¼! "
x
¼¼" #
)
¼¼# $
*
¼¼% &
$num
¼¼' )
<
¼¼* +
size
¼¼, 0
.
¼¼0 1
x
¼¼1 2
&&
¼¼3 5
Mathf
½½ 
.
½½ 
Abs
½½ 
(
½½ 
dist
½½ 
.
½½ 
y
½½  
)
½½  !
*
½½" #
$num
½½$ &
<
½½' (
size
½½) -
.
½½- .
y
½½. /
;
½½/ 0
}
¾¾ 	
public
ÅÅ 
bool
ÅÅ 

Intersects
ÅÅ 
(
ÅÅ 
Rect
ÅÅ #
rect
ÅÅ$ (
)
ÅÅ( )
{
ÆÆ 	
Vector2
ÇÇ 
dist
ÇÇ 
=
ÇÇ 
this
ÇÇ 
.
ÇÇ  
center
ÇÇ  &
-
ÇÇ' (
rect
ÇÇ) -
.
ÇÇ- .
center
ÇÇ. 4
;
ÇÇ4 5
Vector2
ÈÈ 
size
ÈÈ 
=
ÈÈ 
this
ÈÈ 
.
ÈÈ  
size
ÈÈ  $
+
ÈÈ% &
rect
ÈÈ' +
.
ÈÈ+ ,
size
ÈÈ, 0
;
ÈÈ0 1
return
ÊÊ 
Mathf
ÊÊ 
.
ÊÊ 
Abs
ÊÊ 
(
ÊÊ 
dist
ÊÊ !
.
ÊÊ! "
x
ÊÊ" #
)
ÊÊ# $
*
ÊÊ% &
$num
ÊÊ' )
<
ÊÊ* +
size
ÊÊ, 0
.
ÊÊ0 1
x
ÊÊ1 2
&&
ÊÊ3 5
Mathf
ËË 
.
ËË 
Abs
ËË 
(
ËË 
dist
ËË 
.
ËË 
y
ËË  
)
ËË  !
*
ËË" #
$num
ËË$ &
<
ËË' (
size
ËË) -
.
ËË- .
y
ËË. /
;
ËË/ 0
}
ÌÌ 	
public
ÒÒ 
void
ÒÒ 
SetWithPoints
ÒÒ !
(
ÒÒ! "
IList
ÒÒ" '
<
ÒÒ' (
Vector2
ÒÒ( /
>
ÒÒ/ 0
points
ÒÒ1 7
)
ÒÒ7 8
{
ÓÓ 	
float
ÔÔ 
xMin
ÔÔ 
=
ÔÔ 
$num
ÔÔ 
,
ÔÔ 
xMax
ÕÕ 
=
ÕÕ 
$num
ÕÕ 
,
ÕÕ 
yMin
ÖÖ 
=
ÖÖ 
$num
ÖÖ 
,
ÖÖ 
yMax
×× 
=
×× 
$num
×× 
;
×× 
int
ÙÙ 
len
ÙÙ 
=
ÙÙ 
points
ÙÙ 
.
ÙÙ 
Count
ÙÙ "
;
ÙÙ" #
if
ÛÛ 
(
ÛÛ 
len
ÛÛ 
>
ÛÛ 
$num
ÛÛ 
)
ÛÛ 
{
ÜÜ 
xMin
İİ 
=
İİ 
points
İİ 
[
İİ 
$num
İİ 
]
İİ  
.
İİ  !
x
İİ! "
;
İİ" #
yMin
ŞŞ 
=
ŞŞ 
points
ŞŞ 
[
ŞŞ 
$num
ŞŞ 
]
ŞŞ  
.
ŞŞ  !
y
ŞŞ! "
;
ŞŞ" #
xMax
ßß 
=
ßß 
xMin
ßß 
;
ßß 
yMax
àà 
=
àà 
yMin
àà 
;
àà 
for
ââ 
(
ââ 
int
ââ 
i
ââ 
=
ââ 
$num
ââ 
;
ââ 
i
ââ  !
<
ââ" #
len
ââ$ '
;
ââ' (
i
ââ) *
++
ââ* ,
)
ââ, -
{
ãã 
float
ää 
x
ää 
=
ää 
points
ää $
[
ää$ %
i
ää% &
]
ää& '
.
ää' (
x
ää( )
;
ää) *
float
åå 
y
åå 
=
åå 
points
åå $
[
åå$ %
i
åå% &
]
åå& '
.
åå' (
y
åå( )
;
åå) *
if
çç 
(
çç 
x
çç 
<
çç 
xMin
çç  
)
çç  !
xMin
çç" &
=
çç' (
x
çç) *
;
çç* +
if
èè 
(
èè 
x
èè 
>
èè 
xMax
èè  
)
èè  !
xMax
èè" &
=
èè' (
x
èè) *
;
èè* +
if
êê 
(
êê 
y
êê 
<
êê 
yMin
êê  
)
êê  !
yMin
êê" &
=
êê' (
y
êê) *
;
êê* +
if
ëë 
(
ëë 
y
ëë 
>
ëë 
yMax
ëë  
)
ëë  !
yMax
ëë" &
=
ëë' (
y
ëë) *
;
ëë* +
}
ìì 
}
íí 
center
ïï 
.
ïï 
x
ïï 
=
ïï 
(
ïï 
xMin
ïï 
+
ïï 
xMax
ïï #
)
ïï# $
/
ïï% &
$num
ïï' )
;
ïï) *
center
ğğ 
.
ğğ 
y
ğğ 
=
ğğ 
(
ğğ 
yMin
ğğ 
+
ğğ 
yMax
ğğ #
)
ğğ# $
/
ğğ% &
$num
ğğ' )
;
ğğ) *
m_Size
òò 
.
òò 
x
òò 
=
òò 
xMax
òò 
-
òò 
xMin
òò "
;
òò" #
m_Size
óó 
.
óó 
y
óó 
=
óó 
yMax
óó 
-
óó 
yMin
óó "
;
óó" #
	m_Extents
õõ 
.
õõ 
x
õõ 
=
õõ 
m_Size
õõ  
.
õõ  !
x
õõ! "
*
õõ# $
$num
õõ% (
;
õõ( )
	m_Extents
öö 
.
öö 
y
öö 
=
öö 
m_Size
öö  
.
öö  !
y
öö! "
*
öö# $
$num
öö% (
;
öö( )
}
÷÷ 	
public
şş 
void
şş 
SetWithPoints
şş !
(
şş! "
IList
şş" '
<
şş' (
Vector2
şş( /
>
şş/ 0
points
şş1 7
,
şş7 8
IList
şş9 >
<
şş> ?
int
şş? B
>
şşB C
indexes
şşD K
)
şşK L
{
ÿÿ 	
float
€€ 
xMin
€€ 
=
€€ 
$num
€€ 
,
€€ 
xMax
 
=
 
$num
 
,
 
yMin
‚‚ 
=
‚‚ 
$num
‚‚ 
,
‚‚ 
yMax
ƒƒ 
=
ƒƒ 
$num
ƒƒ 
;
ƒƒ 
if
…… 
(
…… 
points
…… 
.
…… 
Count
…… 
>
…… 
$num
……  
&&
……! #
indexes
……$ +
.
……+ ,
Count
……, 1
>
……2 3
$num
……4 5
)
……5 6
{
†† 
xMin
‡‡ 
=
‡‡ 
points
‡‡ 
[
‡‡ 
indexes
‡‡ %
[
‡‡% &
$num
‡‡& '
]
‡‡' (
]
‡‡( )
.
‡‡) *
x
‡‡* +
;
‡‡+ ,
yMin
ˆˆ 
=
ˆˆ 
points
ˆˆ 
[
ˆˆ 
indexes
ˆˆ %
[
ˆˆ% &
$num
ˆˆ& '
]
ˆˆ' (
]
ˆˆ( )
.
ˆˆ) *
y
ˆˆ* +
;
ˆˆ+ ,
xMax
‰‰ 
=
‰‰ 
xMin
‰‰ 
;
‰‰ 
yMax
ŠŠ 
=
ŠŠ 
yMin
ŠŠ 
;
ŠŠ 
for
ŒŒ 
(
ŒŒ 
int
ŒŒ 
i
ŒŒ 
=
ŒŒ 
$num
ŒŒ 
;
ŒŒ 
i
ŒŒ  !
<
ŒŒ" #
indexes
ŒŒ$ +
.
ŒŒ+ ,
Count
ŒŒ, 1
;
ŒŒ1 2
i
ŒŒ3 4
++
ŒŒ4 6
)
ŒŒ6 7
{
 
float
 
x
 
=
 
points
 $
[
$ %
indexes
% ,
[
, -
i
- .
]
. /
]
/ 0
.
0 1
x
1 2
;
2 3
float
 
y
 
=
 
points
 $
[
$ %
indexes
% ,
[
, -
i
- .
]
. /
]
/ 0
.
0 1
y
1 2
;
2 3
if
‘‘ 
(
‘‘ 
x
‘‘ 
<
‘‘ 
xMin
‘‘  
)
‘‘  !
xMin
‘‘" &
=
‘‘' (
x
‘‘) *
;
‘‘* +
if
’’ 
(
’’ 
x
’’ 
>
’’ 
xMax
’’  
)
’’  !
xMax
’’" &
=
’’' (
x
’’) *
;
’’* +
if
”” 
(
”” 
y
”” 
<
”” 
yMin
””  
)
””  !
yMin
””" &
=
””' (
y
””) *
;
””* +
if
•• 
(
•• 
y
•• 
>
•• 
yMax
••  
)
••  !
yMax
••" &
=
••' (
y
••) *
;
••* +
}
–– 
}
—— 
center
™™ 
.
™™ 
x
™™ 
=
™™ 
(
™™ 
xMin
™™ 
+
™™ 
xMax
™™ #
)
™™# $
/
™™% &
$num
™™' )
;
™™) *
center
šš 
.
šš 
y
šš 
=
šš 
(
šš 
yMin
šš 
+
šš 
yMax
šš #
)
šš# $
/
šš% &
$num
šš' )
;
šš) *
m_Size
œœ 
.
œœ 
x
œœ 
=
œœ 
xMax
œœ 
-
œœ 
xMin
œœ "
;
œœ" #
m_Size
 
.
 
y
 
=
 
yMax
 
-
 
yMin
 "
;
" #
	m_Extents
ŸŸ 
.
ŸŸ 
x
ŸŸ 
=
ŸŸ 
m_Size
ŸŸ  
.
ŸŸ  !
x
ŸŸ! "
*
ŸŸ# $
$num
ŸŸ% (
;
ŸŸ( )
	m_Extents
   
.
   
y
   
=
   
m_Size
    
.
    !
y
  ! "
*
  # $
$num
  % (
;
  ( )
}
¡¡ 	
public
ªª 
static
ªª 
Vector2
ªª 
Center
ªª $
(
ªª$ %
IList
ªª% *
<
ªª* +
Vector2
ªª+ 2
>
ªª2 3
points
ªª4 :
)
ªª: ;
{
«« 	
float
¬¬ 
xMin
¬¬ 
=
¬¬ 
$num
¬¬ 
,
¬¬ 
xMax
­­ 
=
­­ 
$num
­­ 
,
­­ 
yMin
®® 
=
®® 
$num
®® 
,
®® 
yMax
¯¯ 
=
¯¯ 
$num
¯¯ 
;
¯¯ 
int
±± 
size
±± 
=
±± 
points
±± 
.
±± 
Count
±± #
;
±±# $
xMin
³³ 
=
³³ 
points
³³ 
[
³³ 
$num
³³ 
]
³³ 
.
³³ 
x
³³ 
;
³³ 
yMin
´´ 
=
´´ 
points
´´ 
[
´´ 
$num
´´ 
]
´´ 
.
´´ 
y
´´ 
;
´´ 
xMax
µµ 
=
µµ 
xMin
µµ 
;
µµ 
yMax
¶¶ 
=
¶¶ 
yMin
¶¶ 
;
¶¶ 
for
¸¸ 
(
¸¸ 
int
¸¸ 
i
¸¸ 
=
¸¸ 
$num
¸¸ 
;
¸¸ 
i
¸¸ 
<
¸¸ 
size
¸¸  $
;
¸¸$ %
i
¸¸& '
++
¸¸' )
)
¸¸) *
{
¹¹ 
float
ºº 
x
ºº 
=
ºº 
points
ºº  
[
ºº  !
i
ºº! "
]
ºº" #
.
ºº# $
x
ºº$ %
;
ºº% &
float
»» 
y
»» 
=
»» 
points
»»  
[
»»  !
i
»»! "
]
»»" #
.
»»# $
y
»»$ %
;
»»% &
if
½½ 
(
½½ 
x
½½ 
<
½½ 
xMin
½½ 
)
½½ 
xMin
½½ "
=
½½# $
x
½½% &
;
½½& '
if
¾¾ 
(
¾¾ 
x
¾¾ 
>
¾¾ 
xMax
¾¾ 
)
¾¾ 
xMax
¾¾ "
=
¾¾# $
x
¾¾% &
;
¾¾& '
if
ÀÀ 
(
ÀÀ 
y
ÀÀ 
<
ÀÀ 
yMin
ÀÀ 
)
ÀÀ 
yMin
ÀÀ "
=
ÀÀ# $
y
ÀÀ% &
;
ÀÀ& '
if
ÁÁ 
(
ÁÁ 
y
ÁÁ 
>
ÁÁ 
yMax
ÁÁ 
)
ÁÁ 
yMax
ÁÁ "
=
ÁÁ# $
y
ÁÁ% &
;
ÁÁ& '
}
ÂÂ 
return
ÄÄ 
new
ÄÄ 
Vector2
ÄÄ 
(
ÄÄ 
(
ÄÄ  
xMin
ÄÄ  $
+
ÄÄ% &
xMax
ÄÄ' +
)
ÄÄ+ ,
/
ÄÄ- .
$num
ÄÄ/ 1
,
ÄÄ1 2
(
ÄÄ3 4
yMin
ÄÄ4 8
+
ÄÄ9 :
yMax
ÄÄ; ?
)
ÄÄ? @
/
ÄÄA B
$num
ÄÄC E
)
ÄÄE F
;
ÄÄF G
}
ÅÅ 	
public
ÇÇ 
static
ÇÇ 
Vector2
ÇÇ 
Center
ÇÇ $
(
ÇÇ$ %
IList
ÇÇ% *
<
ÇÇ* +
Vector2
ÇÇ+ 2
>
ÇÇ2 3
points
ÇÇ4 :
,
ÇÇ: ;
IList
ÇÇ< A
<
ÇÇA B
int
ÇÇB E
>
ÇÇE F
indexes
ÇÇG N
)
ÇÇN O
{
ÈÈ 	
float
ÉÉ 
xMin
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
,
ÉÉ 
xMax
ÊÊ 
=
ÊÊ 
$num
ÊÊ 
,
ÊÊ 
yMin
ËË 
=
ËË 
$num
ËË 
,
ËË 
yMax
ÌÌ 
=
ÌÌ 
$num
ÌÌ 
;
ÌÌ 
int
ÎÎ 
size
ÎÎ 
=
ÎÎ 
indexes
ÎÎ 
.
ÎÎ 
Count
ÎÎ $
;
ÎÎ$ %
xMin
ĞĞ 
=
ĞĞ 
points
ĞĞ 
[
ĞĞ 
indexes
ĞĞ !
[
ĞĞ! "
$num
ĞĞ" #
]
ĞĞ# $
]
ĞĞ$ %
.
ĞĞ% &
x
ĞĞ& '
;
ĞĞ' (
yMin
ÑÑ 
=
ÑÑ 
points
ÑÑ 
[
ÑÑ 
indexes
ÑÑ !
[
ÑÑ! "
$num
ÑÑ" #
]
ÑÑ# $
]
ÑÑ$ %
.
ÑÑ% &
y
ÑÑ& '
;
ÑÑ' (
xMax
ÒÒ 
=
ÒÒ 
xMin
ÒÒ 
;
ÒÒ 
yMax
ÓÓ 
=
ÓÓ 
yMin
ÓÓ 
;
ÓÓ 
for
ÕÕ 
(
ÕÕ 
int
ÕÕ 
i
ÕÕ 
=
ÕÕ 
$num
ÕÕ 
;
ÕÕ 
i
ÕÕ 
<
ÕÕ 
size
ÕÕ  $
;
ÕÕ$ %
i
ÕÕ& '
++
ÕÕ' )
)
ÕÕ) *
{
ÖÖ 
float
×× 
x
×× 
=
×× 
points
××  
[
××  !
indexes
××! (
[
××( )
i
××) *
]
××* +
]
××+ ,
.
××, -
x
××- .
;
××. /
float
ØØ 
y
ØØ 
=
ØØ 
points
ØØ  
[
ØØ  !
indexes
ØØ! (
[
ØØ( )
i
ØØ) *
]
ØØ* +
]
ØØ+ ,
.
ØØ, -
y
ØØ- .
;
ØØ. /
if
ÚÚ 
(
ÚÚ 
x
ÚÚ 
<
ÚÚ 
xMin
ÚÚ 
)
ÚÚ 
xMin
ÚÚ "
=
ÚÚ# $
x
ÚÚ% &
;
ÚÚ& '
if
ÛÛ 
(
ÛÛ 
x
ÛÛ 
>
ÛÛ 
xMax
ÛÛ 
)
ÛÛ 
xMax
ÛÛ "
=
ÛÛ# $
x
ÛÛ% &
;
ÛÛ& '
if
İİ 
(
İİ 
y
İİ 
<
İİ 
yMin
İİ 
)
İİ 
yMin
İİ "
=
İİ# $
y
İİ% &
;
İİ& '
if
ŞŞ 
(
ŞŞ 
y
ŞŞ 
>
ŞŞ 
yMax
ŞŞ 
)
ŞŞ 
yMax
ŞŞ "
=
ŞŞ# $
y
ŞŞ% &
;
ŞŞ& '
}
ßß 
return
áá 
new
áá 
Vector2
áá 
(
áá 
(
áá  
xMin
áá  $
+
áá% &
xMax
áá' +
)
áá+ ,
/
áá- .
$num
áá/ 1
,
áá1 2
(
áá3 4
yMin
áá4 8
+
áá9 :
yMax
áá; ?
)
áá? @
/
ááA B
$num
ááC E
)
ááE F
;
ááF G
}
ââ 	
public
ää 
static
ää 
Vector2
ää 
Size
ää "
(
ää" #
IList
ää# (
<
ää( )
Vector2
ää) 0
>
ää0 1
points
ää2 8
,
ää8 9
IList
ää: ?
<
ää? @
int
ää@ C
>
ääC D
indexes
ääE L
)
ääL M
{
åå 	
float
ææ 
xMin
ææ 
=
ææ 
$num
ææ 
,
ææ 
xMax
çç 
=
çç 
$num
çç 
,
çç 
yMin
èè 
=
èè 
$num
èè 
,
èè 
yMax
éé 
=
éé 
$num
éé 
;
éé 
int
ëë 
size
ëë 
=
ëë 
indexes
ëë 
.
ëë 
Count
ëë $
;
ëë$ %
xMin
íí 
=
íí 
points
íí 
[
íí 
indexes
íí !
[
íí! "
$num
íí" #
]
íí# $
]
íí$ %
.
íí% &
x
íí& '
;
íí' (
yMin
îî 
=
îî 
points
îî 
[
îî 
indexes
îî !
[
îî! "
$num
îî" #
]
îî# $
]
îî$ %
.
îî% &
y
îî& '
;
îî' (
xMax
ïï 
=
ïï 
xMin
ïï 
;
ïï 
yMax
ğğ 
=
ğğ 
yMin
ğğ 
;
ğğ 
for
òò 
(
òò 
int
òò 
i
òò 
=
òò 
$num
òò 
;
òò 
i
òò 
<
òò 
size
òò  $
;
òò$ %
i
òò& '
++
òò' )
)
òò) *
{
óó 
float
ôô 
x
ôô 
=
ôô 
points
ôô  
[
ôô  !
indexes
ôô! (
[
ôô( )
i
ôô) *
]
ôô* +
]
ôô+ ,
.
ôô, -
x
ôô- .
;
ôô. /
float
õõ 
y
õõ 
=
õõ 
points
õõ  
[
õõ  !
indexes
õõ! (
[
õõ( )
i
õõ) *
]
õõ* +
]
õõ+ ,
.
õõ, -
y
õõ- .
;
õõ. /
if
÷÷ 
(
÷÷ 
x
÷÷ 
<
÷÷ 
xMin
÷÷ 
)
÷÷ 
xMin
÷÷ "
=
÷÷# $
x
÷÷% &
;
÷÷& '
if
øø 
(
øø 
x
øø 
>
øø 
xMax
øø 
)
øø 
xMax
øø "
=
øø# $
x
øø% &
;
øø& '
if
úú 
(
úú 
y
úú 
<
úú 
yMin
úú 
)
úú 
yMin
úú "
=
úú# $
y
úú% &
;
úú& '
if
ûû 
(
ûû 
y
ûû 
>
ûû 
yMax
ûû 
)
ûû 
yMax
ûû "
=
ûû# $
y
ûû% &
;
ûû& '
}
üü 
return
şş 
new
şş 
Vector2
şş 
(
şş 
xMax
şş #
-
şş$ %
xMin
şş& *
,
şş* +
yMax
şş, 0
-
şş1 2
yMin
şş3 7
)
şş7 8
;
şş8 9
}
ÿÿ 	
internal
 
static
 
Vector2
 
Center
  &
(
& '
IList
' ,
<
, -
Vector4
- 4
>
4 5
points
6 <
,
< =
IEnumerable
> I
<
I J
int
J M
>
M N
indexes
O V
)
V W
{
‚‚ 	
float
ƒƒ 
xMin
ƒƒ 
=
ƒƒ 
$num
ƒƒ 
,
ƒƒ 
xMax
„„ 
=
„„ 
$num
„„ 
,
„„ 
yMin
…… 
=
…… 
$num
…… 
,
…… 
yMax
†† 
=
†† 
$num
†† 
;
†† 
if
ˆˆ 
(
ˆˆ 
indexes
ˆˆ 
.
ˆˆ 
Any
ˆˆ 
(
ˆˆ 
)
ˆˆ 
)
ˆˆ 
{
‰‰ 
var
ŠŠ 
first
ŠŠ 
=
ŠŠ 
indexes
ŠŠ #
.
ŠŠ# $
First
ŠŠ$ )
(
ŠŠ) *
)
ŠŠ* +
;
ŠŠ+ ,
xMin
ŒŒ 
=
ŒŒ 
points
ŒŒ 
[
ŒŒ 
first
ŒŒ #
]
ŒŒ# $
.
ŒŒ$ %
x
ŒŒ% &
;
ŒŒ& '
yMin
 
=
 
points
 
[
 
first
 #
]
# $
.
$ %
y
% &
;
& '
xMax
 
=
 
xMin
 
;
 
yMax
 
=
 
yMin
 
;
 
foreach
‘‘ 
(
‘‘ 
var
‘‘ 
index
‘‘ "
in
‘‘# %
indexes
‘‘& -
)
‘‘- .
{
’’ 
float
““ 
x
““ 
=
““ 
points
““ $
[
““$ %
index
““% *
]
““* +
.
““+ ,
x
““, -
;
““- .
float
”” 
y
”” 
=
”” 
points
”” $
[
””$ %
index
””% *
]
””* +
.
””+ ,
y
””, -
;
””- .
if
–– 
(
–– 
x
–– 
<
–– 
xMin
––  
)
––  !
xMin
––" &
=
––' (
x
––) *
;
––* +
if
—— 
(
—— 
x
—— 
>
—— 
xMax
——  
)
——  !
xMax
——" &
=
——' (
x
——) *
;
——* +
if
™™ 
(
™™ 
y
™™ 
<
™™ 
yMin
™™  
)
™™  !
yMin
™™" &
=
™™' (
y
™™) *
;
™™* +
if
šš 
(
šš 
y
šš 
>
šš 
yMax
šš  
)
šš  !
yMax
šš" &
=
šš' (
y
šš) *
;
šš* +
}
›› 
}
œœ 
return
 
new
 
Vector2
 
(
 
(
  
xMin
  $
+
% &
xMax
' +
)
+ ,
/
- .
$num
/ 1
,
1 2
(
3 4
yMin
4 8
+
9 :
yMax
; ?
)
? @
/
A B
$num
C E
)
E F
;
F G
}
 	
public
   
override
   
string
   
ToString
   '
(
  ' (
)
  ( )
{
¡¡ 	
return
¢¢ 
$str
¢¢ 
+
¢¢ 
center
¢¢ $
+
¢¢% &
$str
¢¢' 0
+
¢¢1 2
size
¢¢3 7
+
¢¢8 9
$str
¢¢: =
;
¢¢= >
}
££ 	
}
¤¤ 
}¥¥ Éô
šD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\ExtrudeElements.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
public 

static 
class 
ExtrudeElements '
{ 
public 
static 
Face 
[ 
] 
Extrude $
($ %
this% )
ProBuilderMesh* 8
mesh9 =
,= >
IEnumerable? J
<J K
FaceK O
>O P
facesQ V
,V W
ExtrudeMethodX e
methodf l
,l m
floatn s
distancet |
)| }
{ 	
switch 
( 
method 
) 
{ 
case 
ExtrudeMethod "
." #
IndividualFaces# 2
:2 3
return 
ExtrudePerFace )
() *
mesh* .
,. /
faces0 5
,5 6
distance7 ?
)? @
;@ A
default 
: 
return 
ExtrudeAsGroups *
(* +
mesh+ /
,/ 0
faces1 6
,6 7
method8 >
==? A
ExtrudeMethodB O
.O P

FaceNormalP Z
,Z [
distance\ d
)d e
;e f
} 
}   	
public++ 
static++ 
Edge++ 
[++ 
]++ 
Extrude++ $
(++$ %
this++% )
ProBuilderMesh++* 8
mesh++9 =
,++= >
IEnumerable++? J
<++J K
Edge++K O
>++O P
edges++Q V
,++V W
float++X ]
distance++^ f
,++f g
bool++h l
extrudeAsGroup++m {
,++{ |
bool	++} #
enableManifoldExtrude
++‚ —
)
++— ˜
{,, 	
if-- 
(-- 
mesh-- 
==-- 
null-- 
)-- 
throw.. 
new.. !
ArgumentNullException.. /
(../ 0
$str..0 6
)..6 7
;..7 8
if00 
(00 
edges00 
==00 
null00 
)00 
throw11 
new11 !
ArgumentNullException11 /
(11/ 0
$str110 7
)117 8
;118 9
SharedVertex33 
[33 
]33 
sharedIndexes33 (
=33) *
mesh33+ /
.33/ 0"
sharedVerticesInternal330 F
;33F G
List55 
<55 
Edge55 
>55 

validEdges55 !
=55" #
new55$ '
List55( ,
<55, -
Edge55- 1
>551 2
(552 3
)553 4
;554 5
List66 
<66 
Face66 
>66 
	edgeFaces66  
=66! "
new66# &
List66' +
<66+ ,
Face66, 0
>660 1
(661 2
)662 3
;663 4
foreach88 
(88 
Edge88 
e88 
in88 
edges88 $
)88$ %
{99 
int:: 
	faceCount:: 
=:: 
$num::  !
;::! "
Face;; 
fa;; 
=;; 
null;; 
;;; 
foreach== 
(== 
Face== 
face== "
in==# %
mesh==& *
.==* +
facesInternal==+ 8
)==8 9
{>> 
if?? 
(?? 
mesh?? 
.?? 
IndexOf?? $
(??$ %
face??% )
.??) *
edgesInternal??* 7
,??7 8
e??9 :
)??: ;
>??< =
-??> ?
$num??? @
)??@ A
{@@ 
faAA 
=AA 
faceAA !
;AA! "
ifCC 
(CC 
++CC 
	faceCountCC '
>CC( )
$numCC* +
)CC+ ,
breakDD !
;DD! "
}EE 
}FF 
ifHH 
(HH !
enableManifoldExtrudeHH )
||HH* ,
	faceCountHH- 6
<HH7 8
$numHH9 :
)HH: ;
{II 

validEdgesJJ 
.JJ 
AddJJ "
(JJ" #
eJJ# $
)JJ$ %
;JJ% &
	edgeFacesKK 
.KK 
AddKK !
(KK! "
faKK" $
)KK$ %
;KK% &
}LL 
}MM 
ifOO 
(OO 

validEdgesOO 
.OO 
CountOO  
<OO! "
$numOO# $
)OO$ %
returnPP 
nullPP 
;PP 
Vector3RR 
[RR 
]RR 

localVertsRR  
=RR! "
meshRR# '
.RR' (
positionsInternalRR( 9
;RR9 :
ifSS 
(SS 
!SS 
meshSS 
.SS 
	HasArraysSS 
(SS  

MeshArraysSS  *
.SS* +
NormalSS+ 1
)SS1 2
)SS2 3
meshTT 
.TT 
RefreshTT 
(TT 
RefreshMaskTT (
.TT( )
NormalsTT) 0
)TT0 1
;TT1 2
IListUU 
<UU 
Vector3UU 
>UU 
oNormalsUU #
=UU$ %
meshUU& *
.UU* +
normalsUU+ 2
;UU2 3
intWW 
[WW 
]WW 
allEdgeIndexesWW  
=WW! "
newWW# &
intWW' *
[WW* +

validEdgesWW+ 5
.WW5 6
CountWW6 ;
*WW< =
$numWW> ?
]WW? @
;WW@ A
intXX 
cXX 
=XX 
$numXX 
;XX 
forYY 
(YY 
intYY 
iYY 
=YY 
$numYY 
;YY 
iYY 
<YY 

validEdgesYY  *
.YY* +
CountYY+ 0
;YY0 1
iYY2 3
++YY3 5
)YY5 6
{ZZ 
allEdgeIndexes[[ 
[[[ 
c[[  
++[[  "
][[" #
=[[$ %

validEdges[[& 0
[[[0 1
i[[1 2
][[2 3
.[[3 4
a[[4 5
;[[5 6
allEdgeIndexes\\ 
[\\ 
c\\  
++\\  "
]\\" #
=\\$ %

validEdges\\& 0
[\\0 1
i\\1 2
]\\2 3
.\\3 4
b\\4 5
;\\5 6
}]] 
List__ 
<__ 
Edge__ 
>__ 
extrudedIndexes__ &
=__' (
new__) ,
List__- 1
<__1 2
Edge__2 6
>__6 7
(__7 8
)__8 9
;__9 :
Listaa 
<aa 
Edgeaa 
>aa 
newEdgesaa 
=aa  !
newaa" %
Listaa& *
<aa* +
Edgeaa+ /
>aa/ 0
(aa0 1
)aa1 2
;aa2 3
boolbb 
	hasColorsbb 
=bb 
meshbb !
.bb! "
	HasArraysbb" +
(bb+ ,

MeshArraysbb, 6
.bb6 7
Colorbb7 <
)bb< =
;bb= >
foree 
(ee 
intee 
iee 
=ee 
$numee 
;ee 
iee 
<ee 

validEdgesee  *
.ee* +
Countee+ 0
;ee0 1
iee2 3
++ee3 5
)ee5 6
{ff 
Edgegg 
edgegg 
=gg 

validEdgesgg &
[gg& '
igg' (
]gg( )
;gg) *
Facehh 
facehh 
=hh 
	edgeFaceshh %
[hh% &
ihh& '
]hh' (
;hh( )
Vector3kk 
xnormkk 
=kk 
extrudeAsGroupkk  .
?ll 
InternalMeshUtilityll )
.ll) *$
AverageNormalWithIndexesll* B
(llB C
sharedIndexesllC P
[llP Q
meshllQ U
.llU V!
GetSharedVertexHandlellV k
(llk l
edgelll p
.llp q
allq r
)llr s
]lls t
,llt u
allEdgeIndexes	llv „
,
ll„ …
oNormals
ll† 
)
ll 
:mm 
Mathmm 
.mm 
Normalmm !
(mm! "
meshmm" &
,mm& '
facemm( ,
)mm, -
;mm- .
Vector3oo 
ynormoo 
=oo 
extrudeAsGroupoo  .
?pp 
InternalMeshUtilitypp )
.pp) *$
AverageNormalWithIndexespp* B
(ppB C
sharedIndexesppC P
[ppP Q
meshppQ U
.ppU V!
GetSharedVertexHandleppV k
(ppk l
edgeppl p
.ppp q
bppq r
)ppr s
]pps t
,ppt u
allEdgeIndexes	ppv „
,
pp„ …
oNormals
pp† 
)
pp 
:qq 
Mathqq 
.qq 
Normalqq !
(qq! "
meshqq" &
,qq& '
faceqq( ,
)qq, -
;qq- .
intss 
x_sharedIndexss !
=ss" #
meshss$ (
.ss( )!
GetSharedVertexHandless) >
(ss> ?
edgess? C
.ssC D
assD E
)ssE F
;ssF G
inttt 
y_sharedIndextt !
=tt" #
meshtt$ (
.tt( )!
GetSharedVertexHandlett) >
(tt> ?
edgett? C
.ttC D
bttD E
)ttE F
;ttF G
varvv 
	positionsvv 
=vv 
newvv  #
Vector3vv$ +
[vv+ ,
$numvv, -
]vv- .
{ww 

localVertsxx 
[xx 
edgexx #
.xx# $
axx$ %
]xx% &
,xx& '

localVertsyy 
[yy 
edgeyy #
.yy# $
byy$ %
]yy% &
,yy& '

localVertszz 
[zz 
edgezz #
.zz# $
azz$ %
]zz% &
+zz' (
xnormzz) .
.zz. /

normalizedzz/ 9
*zz: ;
distancezz< D
,zzD E

localVerts{{ 
[{{ 
edge{{ #
.{{# $
b{{$ %
]{{% &
+{{' (
ynorm{{) .
.{{. /

normalized{{/ 9
*{{: ;
distance{{< D
}|| 
;|| 
var~~ 
colors~~ 
=~~ 
	hasColors~~ &
? 
new 
Color 
[  
$num  !
]! "
{
€€ 
mesh
 
.
 
colorsInternal
 +
[
+ ,
edge
, 0
.
0 1
a
1 2
]
2 3
,
3 4
mesh
‚‚ 
.
‚‚ 
colorsInternal
‚‚ +
[
‚‚+ ,
edge
‚‚, 0
.
‚‚0 1
b
‚‚1 2
]
‚‚2 3
,
‚‚3 4
mesh
ƒƒ 
.
ƒƒ 
colorsInternal
ƒƒ +
[
ƒƒ+ ,
edge
ƒƒ, 0
.
ƒƒ0 1
a
ƒƒ1 2
]
ƒƒ2 3
,
ƒƒ3 4
mesh
„„ 
.
„„ 
colorsInternal
„„ +
[
„„+ ,
edge
„„, 0
.
„„0 1
b
„„1 2
]
„„2 3
}
…… 
:
†† 
null
†† 
;
†† 
Face
ˆˆ 
newFace
ˆˆ 
=
ˆˆ 
mesh
ˆˆ #
.
ˆˆ# $

AppendFace
ˆˆ$ .
(
ˆˆ. /
	positions
‰‰ !
,
‰‰! "
colors
ŠŠ 
,
ŠŠ 
new
‹‹ 
Vector2
‹‹ #
[
‹‹# $
$num
‹‹$ %
]
‹‹% &
,
‹‹& '
new
ŒŒ 
Face
ŒŒ  
(
ŒŒ  !
new
ŒŒ! $
int
ŒŒ% (
[
ŒŒ( )
$num
ŒŒ) *
]
ŒŒ* +
{
ŒŒ, -
$num
ŒŒ. /
,
ŒŒ/ 0
$num
ŒŒ1 2
,
ŒŒ2 3
$num
ŒŒ4 5
,
ŒŒ5 6
$num
ŒŒ7 8
,
ŒŒ8 9
$num
ŒŒ: ;
,
ŒŒ; <
$num
ŒŒ= >
}
ŒŒ? @
,
ŒŒ@ A
face
ŒŒB F
.
ŒŒF G
submeshIndex
ŒŒG S
,
ŒŒS T 
AutoUnwrapSettings
ŒŒU g
.
ŒŒg h
tile
ŒŒh l
,
ŒŒl m
$num
ŒŒn o
,
ŒŒo p
-
ŒŒq r
$num
ŒŒr s
,
ŒŒs t
-
ŒŒu v
$num
ŒŒv w
,
ŒŒw x
false
ŒŒy ~
)
ŒŒ~ 
,ŒŒ €
new
 
int
 
[
  
$num
  !
]
! "
{
# $
x_sharedIndex
% 2
,
2 3
y_sharedIndex
4 A
,
A B
-
C D
$num
D E
,
E F
-
G H
$num
H I
}
J K
)
K L
;
L M
newEdges
 
.
 
Add
 
(
 
new
  
Edge
! %
(
% &
newFace
& -
.
- .
indexesInternal
. =
[
= >
$num
> ?
]
? @
,
@ A
newFace
B I
.
I J
indexesInternal
J Y
[
Y Z
$num
Z [
]
[ \
)
\ ]
)
] ^
;
^ _
extrudedIndexes
‘‘ 
.
‘‘  
Add
‘‘  #
(
‘‘# $
new
‘‘$ '
Edge
‘‘( ,
(
‘‘, -
x_sharedIndex
‘‘- :
,
‘‘: ;
newFace
‘‘< C
.
‘‘C D
indexesInternal
‘‘D S
[
‘‘S T
$num
‘‘T U
]
‘‘U V
)
‘‘V W
)
‘‘W X
;
‘‘X Y
extrudedIndexes
’’ 
.
’’  
Add
’’  #
(
’’# $
new
’’$ '
Edge
’’( ,
(
’’, -
y_sharedIndex
’’- :
,
’’: ;
newFace
’’< C
.
’’C D
indexesInternal
’’D S
[
’’S T
$num
’’T U
]
’’U V
)
’’V W
)
’’W X
;
’’X Y
}
““ 
if
–– 
(
–– 
extrudeAsGroup
–– 
)
–– 
{
—— 
for
˜˜ 
(
˜˜ 
int
˜˜ 
i
˜˜ 
=
˜˜ 
$num
˜˜ 
;
˜˜ 
i
˜˜  !
<
˜˜" #
extrudedIndexes
˜˜$ 3
.
˜˜3 4
Count
˜˜4 9
;
˜˜9 :
i
˜˜; <
++
˜˜< >
)
˜˜> ?
{
™™ 
int
šš 
val
šš 
=
šš 
extrudedIndexes
šš -
[
šš- .
i
šš. /
]
šš/ 0
.
šš0 1
a
šš1 2
;
šš2 3
for
œœ 
(
œœ 
int
œœ 
n
œœ 
=
œœ  
$num
œœ! "
;
œœ" #
n
œœ$ %
<
œœ& '
extrudedIndexes
œœ( 7
.
œœ7 8
Count
œœ8 =
;
œœ= >
n
œœ? @
++
œœ@ B
)
œœB C
{
 
if
 
(
 
n
 
==
  
i
! "
)
" #
continue
ŸŸ $
;
ŸŸ$ %
if
¡¡ 
(
¡¡ 
extrudedIndexes
¡¡ +
[
¡¡+ ,
n
¡¡, -
]
¡¡- .
.
¡¡. /
a
¡¡/ 0
==
¡¡1 3
val
¡¡4 7
)
¡¡7 8
{
¢¢ 
mesh
££  
.
££  !#
SetVerticesCoincident
££! 6
(
££6 7
new
££7 :
int
££; >
[
££> ?
]
££? @
{
££A B
extrudedIndexes
££C R
[
££R S
n
££S T
]
££T U
.
££U V
b
££V W
,
££W X
extrudedIndexes
££Y h
[
££h i
i
££i j
]
££j k
.
££k l
b
££l m
}
££n o
)
££o p
;
££p q
break
¤¤ !
;
¤¤! "
}
¥¥ 
}
¦¦ 
}
§§ 
}
¨¨ 
foreach
«« 
(
«« 
Face
«« 
f
«« 
in
«« 
mesh
«« #
.
««# $
facesInternal
««$ 1
)
««1 2
f
¬¬ 
.
¬¬ 
InvalidateCache
¬¬ !
(
¬¬! "
)
¬¬" #
;
¬¬# $
return
®® 
newEdges
®® 
.
®® 
ToArray
®® #
(
®®# $
)
®®$ %
;
®®% &
}
¯¯ 	
public
·· 
static
·· 
List
·· 
<
·· 
Face
·· 
>
··  
DetachFaces
··! ,
(
··, -
this
··- 1
ProBuilderMesh
··2 @
mesh
··A E
,
··E F
IEnumerable
··G R
<
··R S
Face
··S W
>
··W X
faces
··Y ^
)
··^ _
{
¸¸ 	
return
¹¹ 
DetachFaces
¹¹ 
(
¹¹ 
mesh
¹¹ #
,
¹¹# $
faces
¹¹% *
,
¹¹* +
true
¹¹, 0
)
¹¹0 1
;
¹¹1 2
}
ºº 	
public
ÃÃ 
static
ÃÃ 
List
ÃÃ 
<
ÃÃ 
Face
ÃÃ 
>
ÃÃ  
DetachFaces
ÃÃ! ,
(
ÃÃ, -
this
ÃÃ- 1
ProBuilderMesh
ÃÃ2 @
mesh
ÃÃA E
,
ÃÃE F
IEnumerable
ÃÃG R
<
ÃÃR S
Face
ÃÃS W
>
ÃÃW X
faces
ÃÃY ^
,
ÃÃ^ _
bool
ÃÃ` d
deleteSourceFaces
ÃÃe v
)
ÃÃv w
{
ÄÄ 	
if
ÅÅ 
(
ÅÅ 
mesh
ÅÅ 
==
ÅÅ 
null
ÅÅ 
)
ÅÅ 
throw
ÆÆ 
new
ÆÆ 
System
ÆÆ  
.
ÆÆ  !#
ArgumentNullException
ÆÆ! 6
(
ÆÆ6 7
$str
ÆÆ7 =
)
ÆÆ= >
;
ÆÆ> ?
if
ÈÈ 
(
ÈÈ 
faces
ÈÈ 
==
ÈÈ 
null
ÈÈ 
)
ÈÈ 
throw
ÉÉ 
new
ÉÉ 
System
ÉÉ  
.
ÉÉ  !#
ArgumentNullException
ÉÉ! 6
(
ÉÉ6 7
$str
ÉÉ7 >
)
ÉÉ> ?
;
ÉÉ? @
List
ËË 
<
ËË 
Vertex
ËË 
>
ËË 
vertices
ËË !
=
ËË" #
new
ËË$ '
List
ËË( ,
<
ËË, -
Vertex
ËË- 3
>
ËË3 4
(
ËË4 5
mesh
ËË5 9
.
ËË9 :
GetVertices
ËË: E
(
ËËE F
)
ËËF G
)
ËËG H
;
ËËH I
int
ÌÌ 
sharedIndexOffset
ÌÌ !
=
ÌÌ" #
mesh
ÌÌ$ (
.
ÌÌ( )$
sharedVerticesInternal
ÌÌ) ?
.
ÌÌ? @
Length
ÌÌ@ F
;
ÌÌF G
var
ÍÍ 
lookup
ÍÍ 
=
ÍÍ 
mesh
ÍÍ 
.
ÍÍ  
sharedVertexLookup
ÍÍ 0
;
ÍÍ0 1
List
ÏÏ 
<
ÏÏ 
FaceRebuildData
ÏÏ  
>
ÏÏ  !
detached
ÏÏ" *
=
ÏÏ+ ,
new
ÏÏ- 0
List
ÏÏ1 5
<
ÏÏ5 6
FaceRebuildData
ÏÏ6 E
>
ÏÏE F
(
ÏÏF G
)
ÏÏG H
;
ÏÏH I
foreach
ÑÑ 
(
ÑÑ 
Face
ÑÑ 
face
ÑÑ 
in
ÑÑ !
faces
ÑÑ" '
)
ÑÑ' (
{
ÒÒ 
FaceRebuildData
ÓÓ 
data
ÓÓ  $
=
ÓÓ% &
new
ÓÓ' *
FaceRebuildData
ÓÓ+ :
(
ÓÓ: ;
)
ÓÓ; <
;
ÓÓ< =
data
ÔÔ 
.
ÔÔ 
vertices
ÔÔ 
=
ÔÔ 
new
ÔÔ  #
List
ÔÔ$ (
<
ÔÔ( )
Vertex
ÔÔ) /
>
ÔÔ/ 0
(
ÔÔ0 1
)
ÔÔ1 2
;
ÔÔ2 3
data
ÕÕ 
.
ÕÕ 
sharedIndexes
ÕÕ "
=
ÕÕ# $
new
ÕÕ% (
List
ÕÕ) -
<
ÕÕ- .
int
ÕÕ. 1
>
ÕÕ1 2
(
ÕÕ2 3
)
ÕÕ3 4
;
ÕÕ4 5
data
ÖÖ 
.
ÖÖ 
face
ÖÖ 
=
ÖÖ 
new
ÖÖ 
Face
ÖÖ  $
(
ÖÖ$ %
face
ÖÖ% )
)
ÖÖ) *
;
ÖÖ* +

Dictionary
ØØ 
<
ØØ 
int
ØØ 
,
ØØ 
int
ØØ  #
>
ØØ# $
match
ØØ% *
=
ØØ+ ,
new
ØØ- 0

Dictionary
ØØ1 ;
<
ØØ; <
int
ØØ< ?
,
ØØ? @
int
ØØA D
>
ØØD E
(
ØØE F
)
ØØF G
;
ØØG H
int
ÙÙ 
[
ÙÙ 
]
ÙÙ 
indexes
ÙÙ 
=
ÙÙ 
new
ÙÙ  #
int
ÙÙ$ '
[
ÙÙ' (
face
ÙÙ( ,
.
ÙÙ, -
indexesInternal
ÙÙ- <
.
ÙÙ< =
Length
ÙÙ= C
]
ÙÙC D
;
ÙÙD E
for
ÛÛ 
(
ÛÛ 
int
ÛÛ 
i
ÛÛ 
=
ÛÛ 
$num
ÛÛ 
;
ÛÛ 
i
ÛÛ  !
<
ÛÛ" #
face
ÛÛ$ (
.
ÛÛ( )
indexesInternal
ÛÛ) 8
.
ÛÛ8 9
Length
ÛÛ9 ?
;
ÛÛ? @
i
ÛÛA B
++
ÛÛB D
)
ÛÛD E
{
ÜÜ 
int
İİ 
local
İİ 
;
İİ 
if
ßß 
(
ßß 
match
ßß 
.
ßß 
TryGetValue
ßß )
(
ßß) *
face
ßß* .
.
ßß. /
indexesInternal
ßß/ >
[
ßß> ?
i
ßß? @
]
ßß@ A
,
ßßA B
out
ßßC F
local
ßßG L
)
ßßL M
)
ßßM N
{
àà 
indexes
áá 
[
áá  
i
áá  !
]
áá! "
=
áá# $
local
áá% *
;
áá* +
}
ââ 
else
ãã 
{
ää 
local
åå 
=
åå 
data
åå  $
.
åå$ %
vertices
åå% -
.
åå- .
Count
åå. 3
;
åå3 4
indexes
ææ 
[
ææ  
i
ææ  !
]
ææ! "
=
ææ# $
local
ææ% *
;
ææ* +
match
çç 
.
çç 
Add
çç !
(
çç! "
face
çç" &
.
çç& '
indexesInternal
çç' 6
[
çç6 7
i
çç7 8
]
çç8 9
,
çç9 :
local
çç; @
)
çç@ A
;
ççA B
data
èè 
.
èè 
vertices
èè %
.
èè% &
Add
èè& )
(
èè) *
vertices
èè* 2
[
èè2 3
face
èè3 7
.
èè7 8
indexesInternal
èè8 G
[
èèG H
i
èèH I
]
èèI J
]
èèJ K
)
èèK L
;
èèL M
data
éé 
.
éé 
sharedIndexes
éé *
.
éé* +
Add
éé+ .
(
éé. /
lookup
éé/ 5
[
éé5 6
face
éé6 :
.
éé: ;
indexesInternal
éé; J
[
ééJ K
i
ééK L
]
ééL M
]
ééM N
+
ééO P
sharedIndexOffset
ééQ b
)
ééb c
;
ééc d
}
êê 
}
ëë 
data
íí 
.
íí 
face
íí 
.
íí 
indexesInternal
íí )
=
íí* +
indexes
íí, 3
.
íí3 4
ToArray
íí4 ;
(
íí; <
)
íí< =
;
íí= >
detached
îî 
.
îî 
Add
îî 
(
îî 
data
îî !
)
îî! "
;
îî" #
}
ïï 
FaceRebuildData
ññ 
.
ññ 
Apply
ññ !
(
ññ! "
detached
ññ" *
,
ññ* +
mesh
ññ, 0
,
ññ0 1
vertices
ññ2 :
)
ññ: ;
;
ññ; <
if
òò 
(
òò 
deleteSourceFaces
òò !
)
òò! "
{
óó 
mesh
ôô 
.
ôô 
DeleteFaces
ôô  
(
ôô  !
faces
ôô! &
)
ôô& '
;
ôô' (
}
õõ 
mesh
÷÷ 
.
÷÷ 
ToMesh
÷÷ 
(
÷÷ 
)
÷÷ 
;
÷÷ 
return
ùù 
detached
ùù 
.
ùù 
Select
ùù "
(
ùù" #
x
ùù# $
=>
ùù% '
x
ùù( )
.
ùù) *
face
ùù* .
)
ùù. /
.
ùù/ 0
ToList
ùù0 6
(
ùù6 7
)
ùù7 8
;
ùù8 9
}
úú 	
static
„„ 
Face
„„ 
[
„„ 
]
„„ 
ExtrudePerFace
„„ $
(
„„$ %
ProBuilderMesh
„„% 3
pb
„„4 6
,
„„6 7
IEnumerable
„„8 C
<
„„C D
Face
„„D H
>
„„H I
faces
„„J O
,
„„O P
float
„„Q V
distance
„„W _
)
„„_ `
{
…… 	
Face
†† 
[
†† 
]
†† 
	faceArray
†† 
=
†† 
faces
†† $
as
††% '
Face
††( ,
[
††, -
]
††- .
??
††/ 1
faces
††2 7
.
††7 8
ToArray
††8 ?
(
††? @
)
††@ A
;
††A B
if
ˆˆ 
(
ˆˆ 
!
ˆˆ 
	faceArray
ˆˆ 
.
ˆˆ 
Any
ˆˆ 
(
ˆˆ 
)
ˆˆ  
)
ˆˆ  !
return
‰‰ 
null
‰‰ 
;
‰‰ 
List
‹‹ 
<
‹‹ 
Vertex
‹‹ 
>
‹‹ 
vertices
‹‹ !
=
‹‹" #
new
‹‹$ '
List
‹‹( ,
<
‹‹, -
Vertex
‹‹- 3
>
‹‹3 4
(
‹‹4 5
pb
‹‹5 7
.
‹‹7 8
GetVertices
‹‹8 C
(
‹‹C D
)
‹‹D E
)
‹‹E F
;
‹‹F G
int
ŒŒ 
sharedIndexMax
ŒŒ 
=
ŒŒ  
pb
ŒŒ! #
.
ŒŒ# $$
sharedVerticesInternal
ŒŒ$ :
.
ŒŒ: ;
Length
ŒŒ; A
;
ŒŒA B
int
 
sharedIndexOffset
 !
=
" #
$num
$ %
;
% &
int
 
	faceIndex
 
=
 
$num
 
;
 

Dictionary
 
<
 
int
 
,
 
int
 
>
  
lookup
! '
=
( )
pb
* ,
.
, - 
sharedVertexLookup
- ?
;
? @

Dictionary
 
<
 
int
 
,
 
int
 
>
  
lookupUV
! )
=
* +
pb
, .
.
. /!
sharedTextureLookup
/ B
;
B C

Dictionary
‘‘ 
<
‘‘ 
int
‘‘ 
,
‘‘ 
int
‘‘ 
>
‘‘  
used
‘‘! %
=
‘‘& '
new
‘‘( +

Dictionary
‘‘, 6
<
‘‘6 7
int
‘‘7 :
,
‘‘: ;
int
‘‘< ?
>
‘‘? @
(
‘‘@ A
)
‘‘A B
;
‘‘B C
Face
’’ 
[
’’ 
]
’’ 
newFaces
’’ 
=
’’ 
new
’’ !
Face
’’" &
[
’’& '
	faceArray
’’' 0
.
’’0 1
Sum
’’1 4
(
’’4 5
x
’’5 6
=>
’’7 9
x
’’: ;
.
’’; <
edges
’’< A
.
’’A B
Count
’’B G
)
’’G H
]
’’H I
;
’’I J
foreach
”” 
(
”” 
Face
”” 
face
”” 
in
”” !
	faceArray
””" +
)
””+ ,
{
•• 
face
–– 
.
–– 
smoothingGroup
–– #
=
––$ %
	Smoothing
––& /
.
––/ 0 
smoothingGroupNone
––0 B
;
––B C
face
—— 
.
—— 
textureGroup
—— !
=
——" #
-
——$ %
$num
——% &
;
——& '
Vector3
™™ 
delta
™™ 
=
™™ 
Math
™™  $
.
™™$ %
Normal
™™% +
(
™™+ ,
pb
™™, .
,
™™. /
face
™™0 4
)
™™4 5
*
™™6 7
distance
™™8 @
;
™™@ A
Edge
šš 
[
šš 
]
šš 
edges
šš 
=
šš 
face
šš #
.
šš# $
edgesInternal
šš$ 1
;
šš1 2
used
œœ 
.
œœ 
Clear
œœ 
(
œœ 
)
œœ 
;
œœ 
for
 
(
 
int
 
i
 
=
 
$num
 
;
 
i
  !
<
" #
edges
$ )
.
) *
Length
* 0
;
0 1
i
2 3
++
3 5
)
5 6
{
ŸŸ 
int
   
vc
   
=
   
vertices
   %
.
  % &
Count
  & +
;
  + ,
int
¡¡ 
x
¡¡ 
=
¡¡ 
edges
¡¡ !
[
¡¡! "
i
¡¡" #
]
¡¡# $
.
¡¡$ %
a
¡¡% &
,
¡¡& '
y
¡¡( )
=
¡¡* +
edges
¡¡, 1
[
¡¡1 2
i
¡¡2 3
]
¡¡3 4
.
¡¡4 5
b
¡¡5 6
;
¡¡6 7
if
££ 
(
££ 
!
££ 
used
££ 
.
££ 
ContainsKey
££ )
(
££) *
x
££* +
)
££+ ,
)
££, -
{
¤¤ 
used
¥¥ 
.
¥¥ 
Add
¥¥  
(
¥¥  !
x
¥¥! "
,
¥¥" #
lookup
¥¥$ *
[
¥¥* +
x
¥¥+ ,
]
¥¥, -
)
¥¥- .
;
¥¥. /
lookup
¦¦ 
[
¦¦ 
x
¦¦  
]
¦¦  !
=
¦¦" #
sharedIndexMax
¦¦$ 2
+
¦¦3 4
(
¦¦5 6
sharedIndexOffset
¦¦6 G
++
¦¦G I
)
¦¦I J
;
¦¦J K
}
§§ 
if
©© 
(
©© 
!
©© 
used
©© 
.
©© 
ContainsKey
©© )
(
©©) *
y
©©* +
)
©©+ ,
)
©©, -
{
ªª 
used
«« 
.
«« 
Add
««  
(
««  !
y
««! "
,
««" #
lookup
««$ *
[
««* +
y
««+ ,
]
««, -
)
««- .
;
««. /
lookup
¬¬ 
[
¬¬ 
y
¬¬  
]
¬¬  !
=
¬¬" #
sharedIndexMax
¬¬$ 2
+
¬¬3 4
(
¬¬5 6
sharedIndexOffset
¬¬6 G
++
¬¬G I
)
¬¬I J
;
¬¬J K
}
­­ 
lookup
¯¯ 
.
¯¯ 
Add
¯¯ 
(
¯¯ 
vc
¯¯ !
+
¯¯" #
$num
¯¯$ %
,
¯¯% &
used
¯¯' +
[
¯¯+ ,
x
¯¯, -
]
¯¯- .
)
¯¯. /
;
¯¯/ 0
lookup
°° 
.
°° 
Add
°° 
(
°° 
vc
°° !
+
°°" #
$num
°°$ %
,
°°% &
used
°°' +
[
°°+ ,
y
°°, -
]
°°- .
)
°°. /
;
°°/ 0
lookup
±± 
.
±± 
Add
±± 
(
±± 
vc
±± !
+
±±" #
$num
±±$ %
,
±±% &
lookup
±±' -
[
±±- .
x
±±. /
]
±±/ 0
)
±±0 1
;
±±1 2
lookup
²² 
.
²² 
Add
²² 
(
²² 
vc
²² !
+
²²" #
$num
²²$ %
,
²²% &
lookup
²²' -
[
²²- .
y
²². /
]
²²/ 0
)
²²0 1
;
²²1 2
Vertex
´´ 
xx
´´ 
=
´´ 
new
´´  #
Vertex
´´$ *
(
´´* +
vertices
´´+ 3
[
´´3 4
x
´´4 5
]
´´5 6
)
´´6 7
,
´´7 8
yy
´´9 ;
=
´´< =
new
´´> A
Vertex
´´B H
(
´´H I
vertices
´´I Q
[
´´Q R
y
´´R S
]
´´S T
)
´´T U
;
´´U V
xx
µµ 
.
µµ 
position
µµ 
+=
µµ  "
delta
µµ# (
;
µµ( )
yy
¶¶ 
.
¶¶ 
position
¶¶ 
+=
¶¶  "
delta
¶¶# (
;
¶¶( )
vertices
¸¸ 
.
¸¸ 
Add
¸¸  
(
¸¸  !
new
¸¸! $
Vertex
¸¸% +
(
¸¸+ ,
vertices
¸¸, 4
[
¸¸4 5
x
¸¸5 6
]
¸¸6 7
)
¸¸7 8
)
¸¸8 9
;
¸¸9 :
vertices
¹¹ 
.
¹¹ 
Add
¹¹  
(
¹¹  !
new
¹¹! $
Vertex
¹¹% +
(
¹¹+ ,
vertices
¹¹, 4
[
¹¹4 5
y
¹¹5 6
]
¹¹6 7
)
¹¹7 8
)
¹¹8 9
;
¹¹9 :
vertices
»» 
.
»» 
Add
»»  
(
»»  !
xx
»»! #
)
»»# $
;
»»$ %
vertices
¼¼ 
.
¼¼ 
Add
¼¼  
(
¼¼  !
yy
¼¼! #
)
¼¼# $
;
¼¼$ %
Face
¾¾ 
bridge
¾¾ 
=
¾¾  !
new
¾¾" %
Face
¾¾& *
(
¾¾* +
new
¿¿ 
int
¿¿  #
[
¿¿# $
$num
¿¿$ %
]
¿¿% &
{
¿¿' (
vc
¿¿) +
+
¿¿, -
$num
¿¿. /
,
¿¿/ 0
vc
¿¿1 3
+
¿¿4 5
$num
¿¿6 7
,
¿¿7 8
vc
¿¿9 ;
+
¿¿< =
$num
¿¿> ?
,
¿¿? @
vc
¿¿A C
+
¿¿D E
$num
¿¿F G
,
¿¿G H
vc
¿¿I K
+
¿¿L M
$num
¿¿N O
,
¿¿O P
vc
¿¿Q S
+
¿¿T U
$num
¿¿V W
}
¿¿X Y
,
¿¿Y Z
face
ÀÀ  
.
ÀÀ  !
submeshIndex
ÀÀ! -
,
ÀÀ- .
new
ÁÁ  
AutoUnwrapSettings
ÁÁ  2
(
ÁÁ2 3
face
ÁÁ3 7
.
ÁÁ7 8
uv
ÁÁ8 :
)
ÁÁ: ;
,
ÁÁ; <
face
ÂÂ  
.
ÂÂ  !
smoothingGroup
ÂÂ! /
,
ÂÂ/ 0
-
ÃÃ 
$num
ÃÃ 
,
ÃÃ 
-
ÄÄ 
$num
ÄÄ 
,
ÄÄ 
false
ÅÅ !
)
ÆÆ 
;
ÆÆ 
newFaces
ÈÈ 
[
ÈÈ 
	faceIndex
ÈÈ &
++
ÈÈ& (
]
ÈÈ( )
=
ÈÈ* +
bridge
ÈÈ, 2
;
ÈÈ2 3
}
ÉÉ 
for
ËË 
(
ËË 
int
ËË 
i
ËË 
=
ËË 
$num
ËË 
;
ËË 
i
ËË  !
<
ËË" #
face
ËË$ (
.
ËË( )%
distinctIndexesInternal
ËË) @
.
ËË@ A
Length
ËËA G
;
ËËG H
i
ËËI J
++
ËËJ L
)
ËËL M
{
ÌÌ 
vertices
ÍÍ 
[
ÍÍ 
face
ÍÍ !
.
ÍÍ! "%
distinctIndexesInternal
ÍÍ" 9
[
ÍÍ9 :
i
ÍÍ: ;
]
ÍÍ; <
]
ÍÍ< =
.
ÍÍ= >
position
ÍÍ> F
+=
ÍÍG I
delta
ÍÍJ O
;
ÍÍO P
if
ĞĞ 
(
ĞĞ 
lookupUV
ĞĞ  
!=
ĞĞ! #
null
ĞĞ$ (
&&
ĞĞ) +
lookupUV
ĞĞ, 4
.
ĞĞ4 5
ContainsKey
ĞĞ5 @
(
ĞĞ@ A
face
ĞĞA E
.
ĞĞE F%
distinctIndexesInternal
ĞĞF ]
[
ĞĞ] ^
i
ĞĞ^ _
]
ĞĞ_ `
)
ĞĞ` a
)
ĞĞa b
lookupUV
ÑÑ  
.
ÑÑ  !
Remove
ÑÑ! '
(
ÑÑ' (
face
ÑÑ( ,
.
ÑÑ, -%
distinctIndexesInternal
ÑÑ- D
[
ÑÑD E
i
ÑÑE F
]
ÑÑF G
)
ÑÑG H
;
ÑÑH I
}
ÒÒ 
}
ÓÓ 
pb
ÕÕ 
.
ÕÕ 
SetVertices
ÕÕ 
(
ÕÕ 
vertices
ÕÕ #
)
ÕÕ# $
;
ÕÕ$ %
var
×× 
fc
×× 
=
×× 
pb
×× 
.
×× 
	faceCount
×× !
;
××! "
var
ØØ 
nc
ØØ 
=
ØØ 
newFaces
ØØ 
.
ØØ 
Length
ØØ $
;
ØØ$ %
var
ÙÙ 
appended
ÙÙ 
=
ÙÙ 
new
ÙÙ 
Face
ÙÙ #
[
ÙÙ# $
fc
ÙÙ$ &
+
ÙÙ' (
nc
ÙÙ) +
]
ÙÙ+ ,
;
ÙÙ, -
Array
ÚÚ 
.
ÚÚ 
Copy
ÚÚ 
(
ÚÚ 
pb
ÚÚ 
.
ÚÚ 
facesInternal
ÚÚ '
,
ÚÚ' (
$num
ÚÚ) *
,
ÚÚ* +
appended
ÚÚ, 4
,
ÚÚ4 5
$num
ÚÚ6 7
,
ÚÚ7 8
fc
ÚÚ9 ;
)
ÚÚ; <
;
ÚÚ< =
Array
ÛÛ 
.
ÛÛ 
Copy
ÛÛ 
(
ÛÛ 
newFaces
ÛÛ 
,
ÛÛ  
$num
ÛÛ! "
,
ÛÛ" #
appended
ÛÛ$ ,
,
ÛÛ, -
fc
ÛÛ. 0
,
ÛÛ0 1
nc
ÛÛ2 4
)
ÛÛ4 5
;
ÛÛ5 6
pb
ÜÜ 
.
ÜÜ 
faces
ÜÜ 
=
ÜÜ 
appended
ÜÜ 
;
ÜÜ  
pb
İİ 
.
İİ 
SetSharedVertices
İİ  
(
İİ  !
lookup
İİ! '
)
İİ' (
;
İİ( )
pb
ŞŞ 
.
ŞŞ 
SetSharedTextures
ŞŞ  
(
ŞŞ  !
lookupUV
ŞŞ! )
)
ŞŞ) *
;
ŞŞ* +
return
àà 
newFaces
àà 
;
àà 
}
áá 	
static
ëë 
Face
ëë 
[
ëë 
]
ëë 
ExtrudeAsGroups
ëë %
(
ëë% &
ProBuilderMesh
ëë& 4
mesh
ëë5 9
,
ëë9 :
IEnumerable
ëë; F
<
ëëF G
Face
ëëG K
>
ëëK L
faces
ëëM R
,
ëëR S
bool
ëëT X+
compensateAngleVertexDistance
ëëY v
,
ëëv w
float
ëëx }
distanceëë~ †
)ëë† ‡
{
ìì 	
if
íí 
(
íí 
faces
íí 
==
íí 
null
íí 
||
íí  
!
íí! "
faces
íí" '
.
íí' (
Any
íí( +
(
íí+ ,
)
íí, -
)
íí- .
return
îî 
null
îî 
;
îî 
List
ğğ 
<
ğğ 
Vertex
ğğ 
>
ğğ 
vertices
ğğ !
=
ğğ" #
new
ğğ$ '
List
ğğ( ,
<
ğğ, -
Vertex
ğğ- 3
>
ğğ3 4
(
ğğ4 5
mesh
ğğ5 9
.
ğğ9 :
GetVertices
ğğ: E
(
ğğE F
)
ğğF G
)
ğğG H
;
ğğH I
int
ññ 
sharedIndexMax
ññ 
=
ññ  
mesh
ññ! %
.
ññ% &$
sharedVerticesInternal
ññ& <
.
ññ< =
Length
ññ= C
;
ññC D
int
òò 
sharedIndexOffset
òò !
=
òò" #
$num
òò$ %
;
òò% &

Dictionary
óó 
<
óó 
int
óó 
,
óó 
int
óó 
>
óó  
lookup
óó! '
=
óó( )
mesh
óó* .
.
óó. / 
sharedVertexLookup
óó/ A
;
óóA B

Dictionary
ôô 
<
ôô 
int
ôô 
,
ôô 
int
ôô 
>
ôô  
lookupUV
ôô! )
=
ôô* +
mesh
ôô, 0
.
ôô0 1!
sharedTextureLookup
ôô1 D
;
ôôD E
List
öö 
<
öö 
Face
öö 
>
öö 
newFaces
öö 
=
öö  !
new
öö" %
List
öö& *
<
öö* +
Face
öö+ /
>
öö/ 0
(
öö0 1
)
öö1 2
;
öö2 3

Dictionary
øø 
<
øø 
int
øø 
,
øø 
int
øø 
>
øø  
oldSharedMap
øø! -
=
øø. /
new
øø0 3

Dictionary
øø4 >
<
øø> ?
int
øø? B
,
øøB C
int
øøD G
>
øøG H
(
øøH I
)
øøI J
;
øøJ K

Dictionary
úú 
<
úú 
int
úú 
,
úú 
int
úú 
>
úú  
newSharedMap
úú! -
=
úú. /
new
úú0 3

Dictionary
úú4 >
<
úú> ?
int
úú? B
,
úúB C
int
úúD G
>
úúG H
(
úúH I
)
úúI J
;
úúJ K

Dictionary
üü 
<
üü 
int
üü 
,
üü 
int
üü 
>
üü  
delayPosition
üü! .
=
üü/ 0
new
üü1 4

Dictionary
üü5 ?
<
üü? @
int
üü@ C
,
üüC D
int
üüE H
>
üüH I
(
üüI J
)
üüJ K
;
üüK L

Dictionary
ÿÿ 
<
ÿÿ 
int
ÿÿ 
,
ÿÿ 
SimpleTuple
ÿÿ '
<
ÿÿ' (
Vector3
ÿÿ( /
,
ÿÿ/ 0
Vector3
ÿÿ1 8
,
ÿÿ8 9
List
ÿÿ: >
<
ÿÿ> ?
int
ÿÿ? B
>
ÿÿB C
>
ÿÿC D
>
ÿÿD E

extrudeMap
ÿÿF P
=
ÿÿQ R
new
ÿÿS V

Dictionary
ÿÿW a
<
ÿÿa b
int
ÿÿb e
,
ÿÿe f
SimpleTuple
ÿÿg r
<
ÿÿr s
Vector3
ÿÿs z
,
ÿÿz {
Vector3ÿÿ| ƒ
,ÿÿƒ „
Listÿÿ… ‰
<ÿÿ‰ Š
intÿÿŠ 
>ÿÿ 
>ÿÿ 
>ÿÿ 
(ÿÿ ‘
)ÿÿ‘ ’
;ÿÿ’ “
List
 
<
 

WingedEdge
 
>
 
wings
 "
=
# $

WingedEdge
% /
.
/ 0
GetWingedEdges
0 >
(
> ?
mesh
? C
,
C D
faces
E J
,
J K
true
L P
)
P Q
;
Q R
List
‚‚ 
<
‚‚ 
HashSet
‚‚ 
<
‚‚ 
Face
‚‚ 
>
‚‚ 
>
‚‚ 
groups
‚‚  &
=
‚‚' (
GetFaceGroups
‚‚) 6
(
‚‚6 7
wings
‚‚7 <
)
‚‚< =
;
‚‚= >
foreach
„„ 
(
„„ 
HashSet
„„ 
<
„„ 
Face
„„ !
>
„„! "
group
„„# (
in
„„) +
groups
„„, 2
)
„„2 3
{
…… 

Dictionary
†† 
<
†† 

EdgeLookup
†† %
,
††% &
Face
††' +
>
††+ ,
	perimeter
††- 6
=
††7 8
GetPerimeterEdges
††9 J
(
††J K
group
††K P
,
††P Q
lookup
††R X
)
††X Y
;
††Y Z
newSharedMap
ˆˆ 
.
ˆˆ 
Clear
ˆˆ "
(
ˆˆ" #
)
ˆˆ# $
;
ˆˆ$ %
oldSharedMap
‰‰ 
.
‰‰ 
Clear
‰‰ "
(
‰‰" #
)
‰‰# $
;
‰‰$ %
foreach
‹‹ 
(
‹‹ 
var
‹‹ 
edgeAndFace
‹‹ (
in
‹‹) +
	perimeter
‹‹, 5
)
‹‹5 6
{
ŒŒ 

EdgeLookup
 
edge
 #
=
$ %
edgeAndFace
& 1
.
1 2
Key
2 5
;
5 6
Face
 
face
 
=
 
edgeAndFace
  +
.
+ ,
Value
, 1
;
1 2
int
 
vc
 
=
 
vertices
 %
.
% &
Count
& +
;
+ ,
int
‘‘ 
x
‘‘ 
=
‘‘ 
edge
‘‘  
.
‘‘  !
local
‘‘! &
.
‘‘& '
a
‘‘' (
,
‘‘( )
y
‘‘* +
=
‘‘, -
edge
‘‘. 2
.
‘‘2 3
local
‘‘3 8
.
‘‘8 9
b
‘‘9 :
;
‘‘: ;
if
““ 
(
““ 
!
““ 
oldSharedMap
““ %
.
““% &
ContainsKey
““& 1
(
““1 2
x
““2 3
)
““3 4
)
““4 5
{
”” 
oldSharedMap
•• $
.
••$ %
Add
••% (
(
••( )
x
••) *
,
••* +
lookup
••, 2
[
••2 3
x
••3 4
]
••4 5
)
••5 6
;
••6 7
int
–– 
newSharedIndex
–– *
=
––+ ,
-
––- .
$num
––. /
;
––/ 0
if
˜˜ 
(
˜˜ 
newSharedMap
˜˜ (
.
˜˜( )
TryGetValue
˜˜) 4
(
˜˜4 5
lookup
˜˜5 ;
[
˜˜; <
x
˜˜< =
]
˜˜= >
,
˜˜> ?
out
˜˜@ C
newSharedIndex
˜˜D R
)
˜˜R S
)
˜˜S T
{
™™ 
lookup
šš "
[
šš" #
x
šš# $
]
šš$ %
=
šš& '
newSharedIndex
šš( 6
;
šš6 7
}
›› 
else
œœ 
{
 
newSharedIndex
 *
=
+ ,
sharedIndexMax
- ;
+
< =
(
> ?
sharedIndexOffset
? P
++
P R
)
R S
;
S T
newSharedMap
ŸŸ (
.
ŸŸ( )
Add
ŸŸ) ,
(
ŸŸ, -
lookup
ŸŸ- 3
[
ŸŸ3 4
x
ŸŸ4 5
]
ŸŸ5 6
,
ŸŸ6 7
newSharedIndex
ŸŸ8 F
)
ŸŸF G
;
ŸŸG H
lookup
   "
[
  " #
x
  # $
]
  $ %
=
  & '
newSharedIndex
  ( 6
;
  6 7
}
¡¡ 
}
¢¢ 
if
¤¤ 
(
¤¤ 
!
¤¤ 
oldSharedMap
¤¤ %
.
¤¤% &
ContainsKey
¤¤& 1
(
¤¤1 2
y
¤¤2 3
)
¤¤3 4
)
¤¤4 5
{
¥¥ 
oldSharedMap
¦¦ $
.
¦¦$ %
Add
¦¦% (
(
¦¦( )
y
¦¦) *
,
¦¦* +
lookup
¦¦, 2
[
¦¦2 3
y
¦¦3 4
]
¦¦4 5
)
¦¦5 6
;
¦¦6 7
int
§§ 
newSharedIndex
§§ *
=
§§+ ,
-
§§- .
$num
§§. /
;
§§/ 0
if
©© 
(
©© 
newSharedMap
©© (
.
©©( )
TryGetValue
©©) 4
(
©©4 5
lookup
©©5 ;
[
©©; <
y
©©< =
]
©©= >
,
©©> ?
out
©©@ C
newSharedIndex
©©D R
)
©©R S
)
©©S T
{
ªª 
lookup
«« "
[
««" #
y
««# $
]
««$ %
=
««& '
newSharedIndex
««( 6
;
««6 7
}
¬¬ 
else
­­ 
{
®® 
newSharedIndex
¯¯ *
=
¯¯+ ,
sharedIndexMax
¯¯- ;
+
¯¯< =
(
¯¯> ?
sharedIndexOffset
¯¯? P
++
¯¯P R
)
¯¯R S
;
¯¯S T
newSharedMap
°° (
.
°°( )
Add
°°) ,
(
°°, -
lookup
°°- 3
[
°°3 4
y
°°4 5
]
°°5 6
,
°°6 7
newSharedIndex
°°8 F
)
°°F G
;
°°G H
lookup
±± "
[
±±" #
y
±±# $
]
±±$ %
=
±±& '
newSharedIndex
±±( 6
;
±±6 7
}
²² 
}
³³ 
lookup
µµ 
.
µµ 
Add
µµ 
(
µµ 
vc
µµ !
+
µµ" #
$num
µµ$ %
,
µµ% &
oldSharedMap
µµ' 3
[
µµ3 4
x
µµ4 5
]
µµ5 6
)
µµ6 7
;
µµ7 8
lookup
¶¶ 
.
¶¶ 
Add
¶¶ 
(
¶¶ 
vc
¶¶ !
+
¶¶" #
$num
¶¶$ %
,
¶¶% &
oldSharedMap
¶¶' 3
[
¶¶3 4
y
¶¶4 5
]
¶¶5 6
)
¶¶6 7
;
¶¶7 8
lookup
·· 
.
·· 
Add
·· 
(
·· 
vc
·· !
+
··" #
$num
··$ %
,
··% &
lookup
··' -
[
··- .
x
··. /
]
··/ 0
)
··0 1
;
··1 2
lookup
¸¸ 
.
¸¸ 
Add
¸¸ 
(
¸¸ 
vc
¸¸ !
+
¸¸" #
$num
¸¸$ %
,
¸¸% &
lookup
¸¸' -
[
¸¸- .
y
¸¸. /
]
¸¸/ 0
)
¸¸0 1
;
¸¸1 2
delayPosition
ºº !
.
ºº! "
Add
ºº" %
(
ºº% &
vc
ºº& (
+
ºº) *
$num
ºº+ ,
,
ºº, -
x
ºº. /
)
ºº/ 0
;
ºº0 1
delayPosition
»» !
.
»»! "
Add
»»" %
(
»»% &
vc
»»& (
+
»») *
$num
»»+ ,
,
»», -
y
»». /
)
»»/ 0
;
»»0 1
vertices
½½ 
.
½½ 
Add
½½  
(
½½  !
new
½½! $
Vertex
½½% +
(
½½+ ,
vertices
½½, 4
[
½½4 5
x
½½5 6
]
½½6 7
)
½½7 8
)
½½8 9
;
½½9 :
vertices
¾¾ 
.
¾¾ 
Add
¾¾  
(
¾¾  !
new
¾¾! $
Vertex
¾¾% +
(
¾¾+ ,
vertices
¾¾, 4
[
¾¾4 5
y
¾¾5 6
]
¾¾6 7
)
¾¾7 8
)
¾¾8 9
;
¾¾9 :
vertices
ÁÁ 
.
ÁÁ 
Add
ÁÁ  
(
ÁÁ  !
null
ÁÁ! %
)
ÁÁ% &
;
ÁÁ& '
vertices
ÂÂ 
.
ÂÂ 
Add
ÂÂ  
(
ÂÂ  !
null
ÂÂ! %
)
ÂÂ% &
;
ÂÂ& '
Face
ÄÄ 
bridge
ÄÄ 
=
ÄÄ  !
new
ÄÄ" %
Face
ÄÄ& *
(
ÄÄ* +
new
ÅÅ 
int
ÅÅ  #
[
ÅÅ# $
$num
ÅÅ$ %
]
ÅÅ% &
{
ÅÅ' (
vc
ÅÅ) +
+
ÅÅ, -
$num
ÅÅ. /
,
ÅÅ/ 0
vc
ÅÅ1 3
+
ÅÅ4 5
$num
ÅÅ6 7
,
ÅÅ7 8
vc
ÅÅ9 ;
+
ÅÅ< =
$num
ÅÅ> ?
,
ÅÅ? @
vc
ÅÅA C
+
ÅÅD E
$num
ÅÅF G
,
ÅÅG H
vc
ÅÅI K
+
ÅÅL M
$num
ÅÅN O
,
ÅÅO P
vc
ÅÅQ S
+
ÅÅT U
$num
ÅÅV W
}
ÅÅX Y
,
ÅÅY Z
face
ÆÆ  
.
ÆÆ  !
submeshIndex
ÆÆ! -
,
ÆÆ- .
new
ÇÇ  
AutoUnwrapSettings
ÇÇ  2
(
ÇÇ2 3
face
ÇÇ3 7
.
ÇÇ7 8
uv
ÇÇ8 :
)
ÇÇ: ;
,
ÇÇ; <
	Smoothing
ÈÈ %
.
ÈÈ% & 
smoothingGroupNone
ÈÈ& 8
,
ÈÈ8 9
-
ÉÉ 
$num
ÉÉ 
,
ÉÉ 
-
ÊÊ 
$num
ÊÊ 
,
ÊÊ 
false
ËË !
)
ÌÌ 
;
ÌÌ 
newFaces
ÎÎ 
.
ÎÎ 
Add
ÎÎ  
(
ÎÎ  !
bridge
ÎÎ! '
)
ÎÎ' (
;
ÎÎ( )
}
ÏÏ 
foreach
ÑÑ 
(
ÑÑ 
Face
ÑÑ 
face
ÑÑ "
in
ÑÑ# %
group
ÑÑ& +
)
ÑÑ+ ,
{
ÒÒ 
face
ÔÔ 
.
ÔÔ 
textureGroup
ÔÔ %
=
ÔÔ& '
-
ÔÔ( )
$num
ÔÔ) *
;
ÔÔ* +
Vector3
ÖÖ 
normal
ÖÖ "
=
ÖÖ# $
Math
ÖÖ% )
.
ÖÖ) *
Normal
ÖÖ* 0
(
ÖÖ0 1
mesh
ÖÖ1 5
,
ÖÖ5 6
face
ÖÖ7 ;
)
ÖÖ; <
;
ÖÖ< =
for
ØØ 
(
ØØ 
int
ØØ 
i
ØØ 
=
ØØ  
$num
ØØ! "
;
ØØ" #
i
ØØ$ %
<
ØØ& '
face
ØØ( ,
.
ØØ, -%
distinctIndexesInternal
ØØ- D
.
ØØD E
Length
ØØE K
;
ØØK L
i
ØØM N
++
ØØN P
)
ØØP Q
{
ÙÙ 
int
ÚÚ 
idx
ÚÚ 
=
ÚÚ  !
face
ÚÚ" &
.
ÚÚ& '%
distinctIndexesInternal
ÚÚ' >
[
ÚÚ> ?
i
ÚÚ? @
]
ÚÚ@ A
;
ÚÚA B
if
ŞŞ 
(
ŞŞ 
!
ŞŞ 
oldSharedMap
ŞŞ )
.
ŞŞ) *
ContainsKey
ŞŞ* 5
(
ŞŞ5 6
idx
ŞŞ6 9
)
ŞŞ9 :
&&
ŞŞ; =
newSharedMap
ŞŞ> J
.
ŞŞJ K
ContainsKey
ŞŞK V
(
ŞŞV W
lookup
ŞŞW ]
[
ŞŞ] ^
idx
ŞŞ^ a
]
ŞŞa b
)
ŞŞb c
)
ŞŞc d
lookup
ßß "
[
ßß" #
idx
ßß# &
]
ßß& '
=
ßß( )
newSharedMap
ßß* 6
[
ßß6 7
lookup
ßß7 =
[
ßß= >
idx
ßß> A
]
ßßA B
]
ßßB C
;
ßßC D
int
áá 
com
áá 
=
áá  !
lookup
áá" (
[
áá( )
idx
áá) ,
]
áá, -
;
áá- .
if
ää 
(
ää 
lookupUV
ää $
!=
ää% '
null
ää( ,
&&
ää- /
lookupUV
ää0 8
.
ää8 9
ContainsKey
ää9 D
(
ääD E
face
ääE I
.
ääI J%
distinctIndexesInternal
ääJ a
[
ääa b
i
ääb c
]
ääc d
)
ääd e
)
ääe f
lookupUV
åå $
.
åå$ %
Remove
åå% +
(
åå+ ,
face
åå, 0
.
åå0 1%
distinctIndexesInternal
åå1 H
[
ååH I
i
ååI J
]
ååJ K
)
ååK L
;
ååL M
SimpleTuple
èè #
<
èè# $
Vector3
èè$ +
,
èè+ ,
Vector3
èè- 4
,
èè4 5
List
èè6 :
<
èè: ;
int
èè; >
>
èè> ?
>
èè? @
dir
èèA D
;
èèD E
if
êê 
(
êê 

extrudeMap
êê &
.
êê& '
TryGetValue
êê' 2
(
êê2 3
com
êê3 6
,
êê6 7
out
êê8 ;
dir
êê< ?
)
êê? @
)
êê@ A
{
ëë 
dir
ìì 
.
ìì  
item1
ìì  %
+=
ìì& (
normal
ìì) /
;
ìì/ 0
dir
íí 
.
íí  
item3
íí  %
.
íí% &
Add
íí& )
(
íí) *
idx
íí* -
)
íí- .
;
íí. /

extrudeMap
îî &
[
îî& '
com
îî' *
]
îî* +
=
îî, -
dir
îî. 1
;
îî1 2
}
ïï 
else
ğğ 
{
ññ 

extrudeMap
òò &
.
òò& '
Add
òò' *
(
òò* +
com
òò+ .
,
òò. /
new
òò0 3
SimpleTuple
òò4 ?
<
òò? @
Vector3
òò@ G
,
òòG H
Vector3
òòI P
,
òòP Q
List
òòR V
<
òòV W
int
òòW Z
>
òòZ [
>
òò[ \
(
òò\ ]
normal
òò] c
,
òòc d
normal
òòe k
,
òòk l
new
òòm p
List
òòq u
<
òòu v
int
òòv y
>
òòy z
(
òòz {
)
òò{ |
{
òò} ~
idxòò ‚
}òòƒ „
)òò„ …
)òò… †
;òò† ‡
}
óó 
}
ôô 
}
õõ 
}
öö 
foreach
øø 
(
øø 
var
øø 
kvp
øø 
in
øø 

extrudeMap
øø  *
)
øø* +
{
ùù 
Vector3
úú 
	direction
úú !
=
úú" #
(
úú$ %
kvp
úú% (
.
úú( )
Value
úú) .
.
úú. /
item1
úú/ 4
/
úú5 6
kvp
úú7 :
.
úú: ;
Value
úú; @
.
úú@ A
item3
úúA F
.
úúF G
Count
úúG L
)
úúL M
;
úúM N
	direction
ûû 
.
ûû 
	Normalize
ûû #
(
ûû# $
)
ûû$ %
;
ûû% &
float
şş 
modifier
şş 
=
şş  +
compensateAngleVertexDistance
şş! >
?
şş? @
Math
şşA E
.
şşE F
Secant
şşF L
(
şşL M
Vector3
şşM T
.
şşT U
Angle
şşU Z
(
şşZ [
	direction
şş[ d
,
şşd e
kvp
şşf i
.
şşi j
Value
şşj o
.
şşo p
item2
şşp u
)
şşu v
*
şşw x
Mathf
şşy ~
.
şş~ 
Deg2Radşş †
)şş† ‡
:şşˆ ‰
$numşşŠ Œ
;şşŒ 
	direction
€€ 
.
€€ 
x
€€ 
*=
€€ 
distance
€€ '
*
€€( )
modifier
€€* 2
;
€€2 3
	direction
 
.
 
y
 
*=
 
distance
 '
*
( )
modifier
* 2
;
2 3
	direction
‚‚ 
.
‚‚ 
z
‚‚ 
*=
‚‚ 
distance
‚‚ '
*
‚‚( )
modifier
‚‚* 2
;
‚‚2 3
foreach
„„ 
(
„„ 
int
„„ 
i
„„ 
in
„„ !
kvp
„„" %
.
„„% &
Value
„„& +
.
„„+ ,
item3
„„, 1
)
„„1 2
{
…… 
vertices
†† 
[
†† 
i
†† 
]
†† 
.
††  
position
††  (
+=
††) +
	direction
††, 5
;
††5 6
}
‡‡ 
}
ˆˆ 
foreach
ŠŠ 
(
ŠŠ 
var
ŠŠ 
kvp
ŠŠ 
in
ŠŠ 
delayPosition
ŠŠ  -
)
ŠŠ- .
vertices
‹‹ 
[
‹‹ 
kvp
‹‹ 
.
‹‹ 
Key
‹‹  
]
‹‹  !
=
‹‹" #
new
‹‹$ '
Vertex
‹‹( .
(
‹‹. /
vertices
‹‹/ 7
[
‹‹7 8
kvp
‹‹8 ;
.
‹‹; <
Value
‹‹< A
]
‹‹A B
)
‹‹B C
;
‹‹C D
mesh
 
.
 
SetVertices
 
(
 
vertices
 %
)
% &
;
& '
var
 
fc
 
=
 
mesh
 
.
 
	faceCount
 #
;
# $
var
 
nc
 
=
 
newFaces
 
.
 
Count
 #
;
# $
var
‘‘ 
appended
‘‘ 
=
‘‘ 
new
‘‘ 
Face
‘‘ #
[
‘‘# $
fc
‘‘$ &
+
‘‘' (
nc
‘‘) +
]
‘‘+ ,
;
‘‘, -
Array
’’ 
.
’’ 
Copy
’’ 
(
’’ 
mesh
’’ 
.
’’ 
facesInternal
’’ )
,
’’) *
$num
’’+ ,
,
’’, -
appended
’’. 6
,
’’6 7
$num
’’8 9
,
’’9 :
fc
’’; =
)
’’= >
;
’’> ?
for
““ 
(
““ 
int
““ 
i
““ 
=
““ 
fc
““ 
,
““ 
c
““ 
=
““  
fc
““! #
+
““$ %
nc
““& (
;
““( )
i
““* +
<
““, -
c
““. /
;
““/ 0
i
““1 2
++
““2 4
)
““4 5
appended
”” 
[
”” 
i
”” 
]
”” 
=
”” 
newFaces
”” &
[
””& '
i
””' (
-
””) *
fc
””+ -
]
””- .
;
””. /
mesh
•• 
.
•• 
faces
•• 
=
•• 
appended
•• !
;
••! "
mesh
–– 
.
–– 
SetSharedVertices
–– "
(
––" #
lookup
––# )
)
––) *
;
––* +
mesh
—— 
.
—— 
SetSharedTextures
—— "
(
——" #
lookupUV
——# +
)
——+ ,
;
——, -
return
™™ 
newFaces
™™ 
.
™™ 
ToArray
™™ #
(
™™# $
)
™™$ %
;
™™% &
}
šš 	
static
œœ 
List
œœ 
<
œœ 
HashSet
œœ 
<
œœ 
Face
œœ  
>
œœ  !
>
œœ! "
GetFaceGroups
œœ# 0
(
œœ0 1
List
œœ1 5
<
œœ5 6

WingedEdge
œœ6 @
>
œœ@ A
wings
œœB G
)
œœG H
{
 	
HashSet
 
<
 
Face
 
>
 
used
 
=
  
new
! $
HashSet
% ,
<
, -
Face
- 1
>
1 2
(
2 3
)
3 4
;
4 5
List
ŸŸ 
<
ŸŸ 
HashSet
ŸŸ 
<
ŸŸ 
Face
ŸŸ 
>
ŸŸ 
>
ŸŸ 
groups
ŸŸ  &
=
ŸŸ' (
new
ŸŸ) ,
List
ŸŸ- 1
<
ŸŸ1 2
HashSet
ŸŸ2 9
<
ŸŸ9 :
Face
ŸŸ: >
>
ŸŸ> ?
>
ŸŸ? @
(
ŸŸ@ A
)
ŸŸA B
;
ŸŸB C
foreach
¡¡ 
(
¡¡ 

WingedEdge
¡¡ 
wing
¡¡  $
in
¡¡% '
wings
¡¡( -
)
¡¡- .
{
¢¢ 
if
££ 
(
££ 
used
££ 
.
££ 
Add
££ 
(
££ 
wing
££ !
.
££! "
face
££" &
)
££& '
)
££' (
{
¤¤ 
HashSet
¥¥ 
<
¥¥ 
Face
¥¥  
>
¥¥  !
group
¥¥" '
=
¥¥( )
new
¥¥* -
HashSet
¥¥. 5
<
¥¥5 6
Face
¥¥6 :
>
¥¥: ;
(
¥¥; <
)
¥¥< =
{
¥¥> ?
wing
¥¥@ D
.
¥¥D E
face
¥¥E I
}
¥¥J K
;
¥¥K L
ElementSelection
§§ $
.
§§$ %
Flood
§§% *
(
§§* +
wing
§§+ /
,
§§/ 0
group
§§1 6
)
§§6 7
;
§§7 8
foreach
©© 
(
©© 
Face
©© !
f
©©" #
in
©©$ &
group
©©' ,
)
©©, -
used
ªª 
.
ªª 
Add
ªª  
(
ªª  !
f
ªª! "
)
ªª" #
;
ªª# $
groups
¬¬ 
.
¬¬ 
Add
¬¬ 
(
¬¬ 
group
¬¬ $
)
¬¬$ %
;
¬¬% &
}
­­ 
}
®® 
return
°° 
groups
°° 
;
°° 
}
±± 	
static
³³ 

Dictionary
³³ 
<
³³ 

EdgeLookup
³³ $
,
³³$ %
Face
³³& *
>
³³* +
GetPerimeterEdges
³³, =
(
³³= >
HashSet
³³> E
<
³³E F
Face
³³F J
>
³³J K
faces
³³L Q
,
³³Q R

Dictionary
³³S ]
<
³³] ^
int
³³^ a
,
³³a b
int
³³c f
>
³³f g
lookup
³³h n
)
³³n o
{
´´ 	

Dictionary
µµ 
<
µµ 

EdgeLookup
µµ !
,
µµ! "
Face
µµ# '
>
µµ' (
	perimeter
µµ) 2
=
µµ3 4
new
µµ5 8

Dictionary
µµ9 C
<
µµC D

EdgeLookup
µµD N
,
µµN O
Face
µµP T
>
µµT U
(
µµU V
)
µµV W
;
µµW X
HashSet
¶¶ 
<
¶¶ 

EdgeLookup
¶¶ 
>
¶¶ 
used
¶¶  $
=
¶¶% &
new
¶¶' *
HashSet
¶¶+ 2
<
¶¶2 3

EdgeLookup
¶¶3 =
>
¶¶= >
(
¶¶> ?
)
¶¶? @
;
¶¶@ A
foreach
¸¸ 
(
¸¸ 
Face
¸¸ 
face
¸¸ 
in
¸¸ !
faces
¸¸" '
)
¸¸' (
{
¹¹ 
foreach
ºº 
(
ºº 
Edge
ºº 
edge
ºº "
in
ºº# %
face
ºº& *
.
ºº* +
edgesInternal
ºº+ 8
)
ºº8 9
{
»» 

EdgeLookup
¼¼ 
e
¼¼  
=
¼¼! "
new
¼¼# &

EdgeLookup
¼¼' 1
(
¼¼1 2
lookup
¼¼2 8
[
¼¼8 9
edge
¼¼9 =
.
¼¼= >
a
¼¼> ?
]
¼¼? @
,
¼¼@ A
lookup
¼¼B H
[
¼¼H I
edge
¼¼I M
.
¼¼M N
b
¼¼N O
]
¼¼O P
,
¼¼P Q
edge
¼¼R V
.
¼¼V W
a
¼¼W X
,
¼¼X Y
edge
¼¼Z ^
.
¼¼^ _
b
¼¼_ `
)
¼¼` a
;
¼¼a b
if
¾¾ 
(
¾¾ 
!
¾¾ 
used
¾¾ 
.
¾¾ 
Add
¾¾ !
(
¾¾! "
e
¾¾" #
)
¾¾# $
)
¾¾$ %
{
¿¿ 
if
ÀÀ 
(
ÀÀ 
	perimeter
ÀÀ %
.
ÀÀ% &
ContainsKey
ÀÀ& 1
(
ÀÀ1 2
e
ÀÀ2 3
)
ÀÀ3 4
)
ÀÀ4 5
	perimeter
ÁÁ %
.
ÁÁ% &
Remove
ÁÁ& ,
(
ÁÁ, -
e
ÁÁ- .
)
ÁÁ. /
;
ÁÁ/ 0
}
ÂÂ 
else
ÃÃ 
{
ÄÄ 
	perimeter
ÅÅ !
.
ÅÅ! "
Add
ÅÅ" %
(
ÅÅ% &
e
ÅÅ& '
,
ÅÅ' (
face
ÅÅ) -
)
ÅÅ- .
;
ÅÅ. /
}
ÆÆ 
}
ÇÇ 
}
ÈÈ 
return
ÊÊ 
	perimeter
ÊÊ 
;
ÊÊ 
}
ËË 	
}
ÌÌ 
}ÍÍ ˆó
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\HandleUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

static 
class 
HandleUtility %
{ 
internal 
static 
Vector3 
ScreenToGuiPoint  0
(0 1
this1 5
Camera6 <
camera= C
,C D
Vector3E L
pointM R
,R S
floatT Y
pixelsPerPointZ h
)h i
{ 	
return 
new 
Vector3 
( 
point $
.$ %
x% &
/' (
pixelsPerPoint) 7
,7 8
(9 :
camera: @
.@ A
pixelHeightA L
-M N
pointO T
.T U
yU V
)V W
/X Y
pixelsPerPointZ h
,h i
pointj o
.o p
zp q
)q r
;r s
} 	
internal## 
static## 
bool## 
FaceRaycast## (
(##( )
Ray##) ,
worldRay##- 5
,##5 6
ProBuilderMesh##7 E
mesh##F J
,##J K
out##L O

RaycastHit##P Z
hit##[ ^
,##^ _
HashSet##` g
<##g h
Face##h l
>##l m
ignore##n t
=##u v
null##w {
)##{ |
{$$ 	
return%% 
FaceRaycast%% 
(%% 
worldRay%% '
,%%' (
mesh%%) -
,%%- .
out%%/ 2
hit%%3 6
,%%6 7
Mathf%%8 =
.%%= >
Infinity%%> F
,%%F G
CullingMode%%H S
.%%S T
Back%%T X
,%%X Y
ignore%%Z `
)%%` a
;%%a b
}&& 	
internal22 
static22 
bool22 
FaceRaycast22 (
(22( )
Ray22) ,
worldRay22- 5
,225 6
ProBuilderMesh227 E
mesh22F J
,22J K
out22L O

RaycastHit22P Z
hit22[ ^
,22^ _
float22` e
distance22f n
,22n o
CullingMode22p {
cullingMode	22| ‡
,
22‡ ˆ
HashSet
22‰ 
<
22 ‘
Face
22‘ •
>
22• –
ignore
22— 
=
22 Ÿ
null
22  ¤
)
22¤ ¥
{33 	
worldRay55 
.55 
origin55 
-=55 
mesh55 #
.55# $
	transform55$ -
.55- .
position55. 6
;556 7
worldRay66 
.66 
origin66 
=66 
mesh66 "
.66" #
	transform66# ,
.66, -
worldToLocalMatrix66- ?
*66@ A
worldRay66B J
.66J K
origin66K Q
;66Q R
worldRay77 
.77 
	direction77 
=77  
mesh77! %
.77% &
	transform77& /
.77/ 0
worldToLocalMatrix770 B
*77C D
worldRay77E M
.77M N
	direction77N W
;77W X
var99 
	positions99 
=99 
mesh99  
.99  !
positionsInternal99! 2
;992 3
var:: 
faces:: 
=:: 
mesh:: 
.:: 
facesInternal:: *
;::* +
float<< 
OutHitPoint<< 
=<< 
Mathf<<  %
.<<% &
Infinity<<& .
;<<. /
int== 

OutHitFace== 
=== 
-== 
$num== 
;==  
Vector3>> 
OutNrm>> 
=>> 
Vector3>> $
.>>$ %
zero>>% )
;>>) *
forAA 
(AA 
intAA 
iAA 
=AA 
$numAA 
,AA 
fcAA 
=AA  
facesAA! &
.AA& '
LengthAA' -
;AA- .
iAA/ 0
<AA1 2
fcAA3 5
;AA5 6
++AA7 9
iAA9 :
)AA: ;
{BB 
ifCC 
(CC 
ignoreCC 
!=CC 
nullCC "
&&CC# %
ignoreCC& ,
.CC, -
ContainsCC- 5
(CC5 6
facesCC6 ;
[CC; <
iCC< =
]CC= >
)CC> ?
)CC? @
continueDD 
;DD 
intFF 
[FF 
]FF 
indexesFF 
=FF 
meshFF  $
.FF$ %
facesInternalFF% 2
[FF2 3
iFF3 4
]FF4 5
.FF5 6
indexesInternalFF6 E
;FFE F
forHH 
(HH 
intHH 
jHH 
=HH 
$numHH 
,HH 
icHH  "
=HH# $
indexesHH% ,
.HH, -
LengthHH- 3
;HH3 4
jHH5 6
<HH7 8
icHH9 ;
;HH; <
jHH= >
+=HH? A
$numHHB C
)HHC D
{II 
Vector3JJ 
aJJ 
=JJ 
	positionsJJ  )
[JJ) *
indexesJJ* 1
[JJ1 2
jJJ2 3
+JJ4 5
$numJJ6 7
]JJ7 8
]JJ8 9
;JJ9 :
Vector3KK 
bKK 
=KK 
	positionsKK  )
[KK) *
indexesKK* 1
[KK1 2
jKK2 3
+KK4 5
$numKK6 7
]KK7 8
]KK8 9
;KK9 :
Vector3LL 
cLL 
=LL 
	positionsLL  )
[LL) *
indexesLL* 1
[LL1 2
jLL2 3
+LL4 5
$numLL6 7
]LL7 8
]LL8 9
;LL9 :
Vector3NN 
nrmNN 
=NN  !
Vector3NN" )
.NN) *
CrossNN* /
(NN/ 0
bNN0 1
-NN2 3
aNN4 5
,NN5 6
cNN7 8
-NN9 :
aNN; <
)NN< =
;NN= >
floatOO 
dotOO 
=OO 
Vector3OO  '
.OO' (
DotOO( +
(OO+ ,
worldRayOO, 4
.OO4 5
	directionOO5 >
,OO> ?
nrmOO@ C
)OOC D
;OOD E
boolQQ 
skipQQ 
=QQ 
falseQQ  %
;QQ% &
switchSS 
(SS 
cullingModeSS '
)SS' (
{TT 
caseUU 
CullingModeUU (
.UU( )
FrontUU) .
:UU. /
ifVV 
(VV  
dotVV  #
<VV$ %
$numVV& (
)VV( )
skipVV* .
=VV/ 0
trueVV1 5
;VV5 6
breakWW !
;WW! "
caseYY 
CullingModeYY (
.YY( )
BackYY) -
:YY- .
ifZZ 
(ZZ  
dotZZ  #
>ZZ$ %
$numZZ& (
)ZZ( )
skipZZ* .
=ZZ/ 0
trueZZ1 5
;ZZ5 6
break[[ !
;[[! "
}\\ 
var^^ 
dist^^ 
=^^ 
$num^^ !
;^^! "
Vector3`` 
point`` !
;``! "
ifaa 
(aa 
!aa 
skipaa 
&&aa  
Mathaa! %
.aa% &!
RayIntersectsTriangleaa& ;
(aa; <
worldRayaa< D
,aaD E
aaaF G
,aaG H
baaI J
,aaJ K
caaL M
,aaM N
outaaO R
distaaS W
,aaW X
outaaY \
pointaa] b
)aab c
)aac d
{bb 
ifcc 
(cc 
distcc  
>cc! "
OutHitPointcc# .
||cc/ 1
distcc2 6
>cc7 8
distancecc9 A
)ccA B
continuedd $
;dd$ %
OutNrmff 
=ff  
nrmff! $
;ff$ %

OutHitFacegg "
=gg# $
igg% &
;gg& '
OutHitPointhh #
=hh$ %
disthh& *
;hh* +
}ii 
}jj 
}kk 
hitmm 
=mm 
newmm 

RaycastHitmm  
(mm  !
OutHitPointmm! ,
,mm, -
worldRaynn 
.nn 
GetPointnn %
(nn% &
OutHitPointnn& 1
)nn1 2
,nn2 3
OutNrmoo 
,oo 

OutHitFacepp 
)pp 
;pp  
returnrr 

OutHitFacerr 
>rr 
-rr  !
$numrr! "
;rr" #
}ss 	
internaluu 
staticuu 
booluu $
FaceRaycastBothCullModesuu 5
(uu5 6
Rayuu6 9
worldRayuu: B
,uuB C
ProBuilderMeshuuD R
meshuuS W
,uuW X
refuuY \
SimpleTupleuu] h
<uuh i
Faceuui m
,uum n
Vector3uuo v
>uuv w
backuux |
,uu| }
ref	uu~ 
SimpleTuple
uu‚ 
<
uu 
Face
uu ’
,
uu’ “
Vector3
uu” ›
>
uu› œ
front
uu ¢
)
uu¢ £
{vv 	
worldRayxx 
.xx 
originxx 
-=xx 
meshxx #
.xx# $
	transformxx$ -
.xx- .
positionxx. 6
;xx6 7
worldRayyy 
.yy 
originyy 
=yy 
meshyy "
.yy" #
	transformyy# ,
.yy, -
worldToLocalMatrixyy- ?
*yy@ A
worldRayyyB J
.yyJ K
originyyK Q
;yyQ R
worldRayzz 
.zz 
	directionzz 
=zz  
meshzz! %
.zz% &
	transformzz& /
.zz/ 0
worldToLocalMatrixzz0 B
*zzC D
worldRayzzE M
.zzM N
	directionzzN W
;zzW X
var|| 
	positions|| 
=|| 
mesh||  
.||  !
positionsInternal||! 2
;||2 3
var}} 
faces}} 
=}} 
mesh}} 
.}} 
facesInternal}} *
;}}* +
back 
. 
item1 
= 
null 
; 
front
€€ 
.
€€ 
item1
€€ 
=
€€ 
null
€€ 
;
€€ 
float
‚‚ 
backDistance
‚‚ 
=
‚‚  
Mathf
‚‚! &
.
‚‚& '
Infinity
‚‚' /
;
‚‚/ 0
float
ƒƒ 
frontDistance
ƒƒ 
=
ƒƒ  !
Mathf
ƒƒ" '
.
ƒƒ' (
Infinity
ƒƒ( 0
;
ƒƒ0 1
for
†† 
(
†† 
int
†† 
i
†† 
=
†† 
$num
†† 
,
†† 
fc
†† 
=
††  
faces
††! &
.
††& '
Length
††' -
;
††- .
i
††/ 0
<
††1 2
fc
††3 5
;
††5 6
++
††7 9
i
††9 :
)
††: ;
{
‡‡ 
int
ˆˆ 
[
ˆˆ 
]
ˆˆ 
indexes
ˆˆ 
=
ˆˆ 
mesh
ˆˆ  $
.
ˆˆ$ %
facesInternal
ˆˆ% 2
[
ˆˆ2 3
i
ˆˆ3 4
]
ˆˆ4 5
.
ˆˆ5 6
indexesInternal
ˆˆ6 E
;
ˆˆE F
for
ŠŠ 
(
ŠŠ 
int
ŠŠ 
j
ŠŠ 
=
ŠŠ 
$num
ŠŠ 
,
ŠŠ 
ic
ŠŠ  "
=
ŠŠ# $
indexes
ŠŠ% ,
.
ŠŠ, -
Length
ŠŠ- 3
;
ŠŠ3 4
j
ŠŠ5 6
<
ŠŠ7 8
ic
ŠŠ9 ;
;
ŠŠ; <
j
ŠŠ= >
+=
ŠŠ? A
$num
ŠŠB C
)
ŠŠC D
{
‹‹ 
Vector3
ŒŒ 
a
ŒŒ 
=
ŒŒ 
	positions
ŒŒ  )
[
ŒŒ) *
indexes
ŒŒ* 1
[
ŒŒ1 2
j
ŒŒ2 3
+
ŒŒ4 5
$num
ŒŒ6 7
]
ŒŒ7 8
]
ŒŒ8 9
;
ŒŒ9 :
Vector3
 
b
 
=
 
	positions
  )
[
) *
indexes
* 1
[
1 2
j
2 3
+
4 5
$num
6 7
]
7 8
]
8 9
;
9 :
Vector3
 
c
 
=
 
	positions
  )
[
) *
indexes
* 1
[
1 2
j
2 3
+
4 5
$num
6 7
]
7 8
]
8 9
;
9 :
float
 
dist
 
;
 
Vector3
‘‘ 
point
‘‘ !
;
‘‘! "
if
““ 
(
““ 
Math
““ 
.
““ #
RayIntersectsTriangle
““ 2
(
““2 3
worldRay
““3 ;
,
““; <
a
““= >
,
““> ?
b
““@ A
,
““A B
c
““C D
,
““D E
out
““F I
dist
““J N
,
““N O
out
““P S
point
““T Y
)
““Y Z
)
““Z [
{
”” 
if
•• 
(
•• 
dist
••  
<
••! "
backDistance
••# /
||
••0 2
dist
••3 7
<
••8 9
frontDistance
••: G
)
••G H
{
–– 
Vector3
—— #
nrm
——$ '
=
——( )
Vector3
——* 1
.
——1 2
Cross
——2 7
(
——7 8
b
——8 9
-
——: ;
a
——< =
,
——= >
c
——? @
-
——A B
a
——C D
)
——D E
;
——E F
float
˜˜ !
dot
˜˜" %
=
˜˜& '
Vector3
˜˜( /
.
˜˜/ 0
Dot
˜˜0 3
(
˜˜3 4
worldRay
˜˜4 <
.
˜˜< =
	direction
˜˜= F
,
˜˜F G
nrm
˜˜H K
)
˜˜K L
;
˜˜L M
if
šš 
(
šš  
dot
šš  #
<
šš$ %
$num
šš& (
)
šš( )
{
›› 
if
œœ  "
(
œœ# $
dist
œœ$ (
<
œœ) *
backDistance
œœ+ 7
)
œœ7 8
{
  !
backDistance
$ 0
=
1 2
dist
3 7
;
7 8
back
ŸŸ$ (
.
ŸŸ( )
item1
ŸŸ) .
=
ŸŸ/ 0
faces
ŸŸ1 6
[
ŸŸ6 7
i
ŸŸ7 8
]
ŸŸ8 9
;
ŸŸ9 :
}
    !
}
¡¡ 
else
¢¢  
{
££ 
if
¤¤  "
(
¤¤# $
dist
¤¤$ (
<
¤¤) *
frontDistance
¤¤+ 8
)
¤¤8 9
{
¥¥  !
frontDistance
¦¦$ 1
=
¦¦2 3
dist
¦¦4 8
;
¦¦8 9
front
§§$ )
.
§§) *
item1
§§* /
=
§§0 1
faces
§§2 7
[
§§7 8
i
§§8 9
]
§§9 :
;
§§: ;
}
¨¨  !
}
©© 
}
ªª 
}
«« 
}
¬¬ 
}
­­ 
if
¯¯ 
(
¯¯ 
back
¯¯ 
.
¯¯ 
item1
¯¯ 
!=
¯¯ 
null
¯¯ "
)
¯¯" #
back
°° 
.
°° 
item2
°° 
=
°° 
worldRay
°° %
.
°°% &
GetPoint
°°& .
(
°°. /
backDistance
°°/ ;
)
°°; <
;
°°< =
if
²² 
(
²² 
front
²² 
.
²² 
item1
²² 
!=
²² 
null
²² #
)
²²# $
front
³³ 
.
³³ 
item2
³³ 
=
³³ 
worldRay
³³ &
.
³³& '
GetPoint
³³' /
(
³³/ 0
frontDistance
³³0 =
)
³³= >
;
³³> ?
return
µµ 
back
µµ 
.
µµ 
item1
µµ 
!=
µµ  
null
µµ! %
||
µµ& (
front
µµ) .
.
µµ. /
item1
µµ/ 4
!=
µµ5 7
null
µµ8 <
;
µµ< =
}
¶¶ 	
internal
ÁÁ 
static
ÁÁ 
bool
ÁÁ 
FaceRaycast
ÁÁ (
(
ÁÁ( )
Ray
ÂÂ 

InWorldRay
ÂÂ 
,
ÂÂ 
ProBuilderMesh
ÃÃ 
mesh
ÃÃ 
,
ÃÃ  
out
ÄÄ 
List
ÄÄ 
<
ÄÄ 

RaycastHit
ÄÄ 
>
ÄÄ  
hits
ÄÄ! %
,
ÄÄ% &
CullingMode
ÅÅ 
cullingMode
ÅÅ #
,
ÅÅ# $
HashSet
ÆÆ 
<
ÆÆ 
Face
ÆÆ 
>
ÆÆ 
ignore
ÆÆ  
=
ÆÆ! "
null
ÆÆ# '
)
ÆÆ' (
{
ÇÇ 	

InWorldRay
ÉÉ 
.
ÉÉ 
origin
ÉÉ 
-=
ÉÉ  
mesh
ÉÉ! %
.
ÉÉ% &
	transform
ÉÉ& /
.
ÉÉ/ 0
position
ÉÉ0 8
;
ÉÉ8 9

InWorldRay
ËË 
.
ËË 
origin
ËË 
=
ËË$ %
mesh
ËË& *
.
ËË* +
	transform
ËË+ 4
.
ËË4 5 
worldToLocalMatrix
ËË5 G
*
ËËH I

InWorldRay
ËËJ T
.
ËËT U
origin
ËËU [
;
ËË[ \

InWorldRay
ÌÌ 
.
ÌÌ 
	direction
ÌÌ  
=
ÌÌ$ %
mesh
ÌÌ& *
.
ÌÌ* +
	transform
ÌÌ+ 4
.
ÌÌ4 5 
worldToLocalMatrix
ÌÌ5 G
*
ÌÌH I

InWorldRay
ÌÌJ T
.
ÌÌT U
	direction
ÌÌU ^
;
ÌÌ^ _
Vector3
ÎÎ 
[
ÎÎ 
]
ÎÎ 
vertices
ÎÎ 
=
ÎÎ  
mesh
ÎÎ! %
.
ÎÎ% &
positionsInternal
ÎÎ& 7
;
ÎÎ7 8
hits
ĞĞ 
=
ĞĞ 
new
ĞĞ 
List
ĞĞ 
<
ĞĞ 

RaycastHit
ĞĞ &
>
ĞĞ& '
(
ĞĞ' (
)
ĞĞ( )
;
ĞĞ) *
for
ÓÓ 
(
ÓÓ 
int
ÓÓ 
CurFace
ÓÓ 
=
ÓÓ 
$num
ÓÓ  
;
ÓÓ  !
CurFace
ÓÓ" )
<
ÓÓ* +
mesh
ÓÓ, 0
.
ÓÓ0 1
facesInternal
ÓÓ1 >
.
ÓÓ> ?
Length
ÓÓ? E
;
ÓÓE F
++
ÓÓG I
CurFace
ÓÓI P
)
ÓÓP Q
{
ÔÔ 
if
ÕÕ 
(
ÕÕ 
ignore
ÕÕ 
!=
ÕÕ 
null
ÕÕ "
&&
ÕÕ# %
ignore
ÕÕ& ,
.
ÕÕ, -
Contains
ÕÕ- 5
(
ÕÕ5 6
mesh
ÕÕ6 :
.
ÕÕ: ;
facesInternal
ÕÕ; H
[
ÕÕH I
CurFace
ÕÕI P
]
ÕÕP Q
)
ÕÕQ R
)
ÕÕR S
continue
ÖÖ 
;
ÖÖ 
int
ØØ 
[
ØØ 
]
ØØ 
indexes
ØØ 
=
ØØ 
mesh
ØØ  $
.
ØØ$ %
facesInternal
ØØ% 2
[
ØØ2 3
CurFace
ØØ3 :
]
ØØ: ;
.
ØØ; <
indexesInternal
ØØ< K
;
ØØK L
for
ÚÚ 
(
ÚÚ 
int
ÚÚ 
CurTriangle
ÚÚ $
=
ÚÚ% &
$num
ÚÚ' (
;
ÚÚ( )
CurTriangle
ÚÚ* 5
<
ÚÚ6 7
indexes
ÚÚ8 ?
.
ÚÚ? @
Length
ÚÚ@ F
;
ÚÚF G
CurTriangle
ÚÚH S
+=
ÚÚT V
$num
ÚÚW X
)
ÚÚX Y
{
ÛÛ 
Vector3
ÜÜ 
a
ÜÜ 
=
ÜÜ 
vertices
ÜÜ  (
[
ÜÜ( )
indexes
ÜÜ) 0
[
ÜÜ0 1
CurTriangle
ÜÜ1 <
+
ÜÜ= >
$num
ÜÜ? @
]
ÜÜ@ A
]
ÜÜA B
;
ÜÜB C
Vector3
İİ 
b
İİ 
=
İİ 
vertices
İİ  (
[
İİ( )
indexes
İİ) 0
[
İİ0 1
CurTriangle
İİ1 <
+
İİ= >
$num
İİ? @
]
İİ@ A
]
İİA B
;
İİB C
Vector3
ŞŞ 
c
ŞŞ 
=
ŞŞ 
vertices
ŞŞ  (
[
ŞŞ( )
indexes
ŞŞ) 0
[
ŞŞ0 1
CurTriangle
ŞŞ1 <
+
ŞŞ= >
$num
ŞŞ? @
]
ŞŞ@ A
]
ŞŞA B
;
ŞŞB C
var
àà 
dist
àà 
=
àà 
$num
àà !
;
àà! "
Vector3
áá 
point
áá !
;
áá! "
if
ãã 
(
ãã 
Math
ãã 
.
ãã #
RayIntersectsTriangle
ãã 2
(
ãã2 3

InWorldRay
ãã3 =
,
ãã= >
a
ãã? @
,
ãã@ A
b
ããB C
,
ããC D
c
ããE F
,
ããF G
out
ããH K
dist
ããL P
,
ããP Q
out
ããR U
point
ããV [
)
ãã[ \
)
ãã\ ]
{
ää 
Vector3
åå 
nrm
åå  #
=
åå$ %
Vector3
åå& -
.
åå- .
Cross
åå. 3
(
åå3 4
b
åå4 5
-
åå6 7
a
åå8 9
,
åå9 :
c
åå; <
-
åå= >
a
åå? @
)
åå@ A
;
ååA B
float
çç 
dot
çç !
;
çç! "
switch
èè 
(
èè  
cullingMode
èè  +
)
èè+ ,
{
éé 
case
êê  
CullingMode
êê! ,
.
êê, -
Front
êê- 2
:
êê2 3
dot
ëë  #
=
ëë$ %
Vector3
ëë& -
.
ëë- .
Dot
ëë. 1
(
ëë1 2

InWorldRay
ëë2 <
.
ëë< =
	direction
ëë= F
,
ëëF G
nrm
ëëH K
)
ëëK L
;
ëëL M
if
íí  "
(
íí# $
dot
íí$ '
>
íí( )
$num
íí* ,
)
íí, -
goto
îî$ (
case
îî) -
CullingMode
îî. 9
.
îî9 :
	FrontBack
îî: C
;
îîC D
break
ïï  %
;
ïï% &
case
ññ  
CullingMode
ññ! ,
.
ññ, -
Back
ññ- 1
:
ññ1 2
dot
òò  #
=
òò$ %
Vector3
òò& -
.
òò- .
Dot
òò. 1
(
òò1 2

InWorldRay
òò2 <
.
òò< =
	direction
òò= F
,
òòF G
nrm
òòH K
)
òòK L
;
òòL M
if
ôô  "
(
ôô# $
dot
ôô$ '
<
ôô( )
$num
ôô* ,
)
ôô, -
goto
õõ$ (
case
õõ) -
CullingMode
õõ. 9
.
õõ9 :
	FrontBack
õõ: C
;
õõC D
break
öö  %
;
öö% &
case
øø  
CullingMode
øø! ,
.
øø, -
	FrontBack
øø- 6
:
øø6 7
hits
ùù  $
.
ùù$ %
Add
ùù% (
(
ùù( )
new
ùù) ,

RaycastHit
ùù- 7
(
ùù7 8
dist
ùù8 <
,
ùù< =

InWorldRay
úú$ .
.
úú. /
GetPoint
úú/ 7
(
úú7 8
dist
úú8 <
)
úú< =
,
úú= >
nrm
ûû$ '
,
ûû' (
CurFace
üü$ +
)
üü+ ,
)
üü, -
;
üü- .
break
ıı  %
;
ıı% &
}
şş 
continue
€€  
;
€€  !
}
 
}
‚‚ 
}
ƒƒ 
return
…… 
hits
…… 
.
…… 
Count
…… 
>
…… 
$num
……  !
;
……! "
}
†† 	
internal
 
static
 
Ray
 !
InverseTransformRay
 /
(
/ 0
this
0 4
	Transform
5 >
	transform
? H
,
H I
Ray
J M

InWorldRay
N X
)
X Y
{
 	
Vector3
 
o
 
=
 

InWorldRay
 "
.
" #
origin
# )
;
) *
o
‘‘ 
-=
‘‘ 
	transform
‘‘ 
.
‘‘ 
position
‘‘ #
;
‘‘# $
o
’’ 
=
’’ 
	transform
’’ 
.
’’  
worldToLocalMatrix
’’ ,
*
’’- .
o
’’/ 0
;
’’0 1
Vector3
““ 
d
““ 
=
““ 
	transform
““ !
.
““! " 
worldToLocalMatrix
““" 4
.
““4 5
MultiplyVector
““5 C
(
““C D

InWorldRay
““D N
.
““N O
	direction
““O X
)
““X Y
;
““Y Z
return
”” 
new
”” 
Ray
”” 
(
”” 
o
”” 
,
”” 
d
”” 
)
””  
;
””  !
}
•• 	
internal
 
static
 
bool
 
MeshRaycast
 (
(
( )
Ray
) ,

InWorldRay
- 7
,
7 8

GameObject
9 C

gameObject
D N
,
N O
out
P S

RaycastHit
T ^
hit
_ b
,
b c
float
d i
distance
j r
=
s t
Mathf
u z
.
z {
Infinity{ ƒ
)ƒ „
{
ŸŸ 	
var
   

meshFilter
   
=
   

gameObject
   '
.
  ' (
GetComponent
  ( 4
<
  4 5

MeshFilter
  5 ?
>
  ? @
(
  @ A
)
  A B
;
  B C
var
¡¡ 
mesh
¡¡ 
=
¡¡ 

meshFilter
¡¡ !
!=
¡¡" $
null
¡¡% )
?
¡¡* +

meshFilter
¡¡, 6
.
¡¡6 7

sharedMesh
¡¡7 A
:
¡¡B C
null
¡¡D H
;
¡¡H I
if
££ 
(
££ 
!
££ 
mesh
££ 
)
££ 
{
¤¤ 
hit
¥¥ 
=
¥¥ 
default
¥¥ 
(
¥¥ 

RaycastHit
¥¥ (
)
¥¥( )
;
¥¥) *
return
¦¦ 
false
¦¦ 
;
¦¦ 
}
§§ 
var
©© 
	transform
©© 
=
©© 

gameObject
©© &
.
©©& '
	transform
©©' 0
;
©©0 1
var
ªª 
ray
ªª 
=
ªª 
	transform
ªª 
.
ªª  !
InverseTransformRay
ªª  3
(
ªª3 4

InWorldRay
ªª4 >
)
ªª> ?
;
ªª? @
return
«« 
MeshRaycast
«« 
(
«« 
ray
«« "
,
««" #
mesh
««$ (
.
««( )
vertices
««) 1
,
««1 2
mesh
««3 7
.
««7 8
	triangles
««8 A
,
««A B
out
««C F
hit
««G J
,
««J K
distance
««L T
)
««T U
;
««U V
}
¬¬ 	
internal
·· 
static
·· 
bool
·· 
MeshRaycast
·· (
(
··( )
Ray
··) ,
InRay
··- 2
,
··2 3
Vector3
··4 ;
[
··; <
]
··< =
mesh
··> B
,
··B C
int
··D G
[
··G H
]
··H I
	triangles
··J S
,
··S T
out
··U X

RaycastHit
··Y c
hit
··d g
,
··g h
float
··i n
distance
··o w
=
··x y
Mathf
··z 
.·· €
Infinity··€ ˆ
)··ˆ ‰
{
¸¸ 	
float
ºº 
hitDistance
ºº 
=
ºº 
Mathf
ºº  %
.
ºº% &
Infinity
ºº& .
;
ºº. /
Vector3
»» 
	hitNormal
»» 
=
»» 
new
»»  #
Vector3
»»$ +
(
»»+ ,
$num
»», .
,
»». /
$num
»»0 2
,
»»2 3
$num
»»4 6
)
»»6 7
;
»»7 8
Vector3
¼¼ 
a
¼¼ 
,
¼¼ 
b
¼¼ 
,
¼¼ 
c
¼¼ 
;
¼¼ 
int
½½ 
hitFace
½½ 
=
½½ 
-
½½ 
$num
½½ 
;
½½ 
Vector3
¾¾ 
o
¾¾ 
=
¾¾ 
InRay
¾¾ 
.
¾¾ 
origin
¾¾ $
,
¾¾$ %
d
¾¾& '
=
¾¾( )
InRay
¾¾* /
.
¾¾/ 0
	direction
¾¾0 9
;
¾¾9 :
for
ÁÁ 
(
ÁÁ 
int
ÁÁ 
CurTri
ÁÁ 
=
ÁÁ 
$num
ÁÁ 
;
ÁÁ  
CurTri
ÁÁ! '
<
ÁÁ( )
	triangles
ÁÁ* 3
.
ÁÁ3 4
Length
ÁÁ4 :
;
ÁÁ: ;
CurTri
ÁÁ< B
+=
ÁÁC E
$num
ÁÁF G
)
ÁÁG H
{
ÂÂ 
a
ÃÃ 
=
ÃÃ 
mesh
ÃÃ 
[
ÃÃ 
	triangles
ÃÃ "
[
ÃÃ" #
CurTri
ÃÃ# )
+
ÃÃ* +
$num
ÃÃ, -
]
ÃÃ- .
]
ÃÃ. /
;
ÃÃ/ 0
b
ÄÄ 
=
ÄÄ 
mesh
ÄÄ 
[
ÄÄ 
	triangles
ÄÄ "
[
ÄÄ" #
CurTri
ÄÄ# )
+
ÄÄ* +
$num
ÄÄ, -
]
ÄÄ- .
]
ÄÄ. /
;
ÄÄ/ 0
c
ÅÅ 
=
ÅÅ 
mesh
ÅÅ 
[
ÅÅ 
	triangles
ÅÅ "
[
ÅÅ" #
CurTri
ÅÅ# )
+
ÅÅ* +
$num
ÅÅ, -
]
ÅÅ- .
]
ÅÅ. /
;
ÅÅ/ 0
if
ÇÇ 
(
ÇÇ 
Math
ÇÇ 
.
ÇÇ $
RayIntersectsTriangle2
ÇÇ /
(
ÇÇ/ 0
o
ÇÇ0 1
,
ÇÇ1 2
d
ÇÇ3 4
,
ÇÇ4 5
a
ÇÇ6 7
,
ÇÇ7 8
b
ÇÇ9 :
,
ÇÇ: ;
c
ÇÇ< =
,
ÇÇ= >
ref
ÇÇ? B
distance
ÇÇC K
,
ÇÇK L
ref
ÇÇM P
	hitNormal
ÇÇQ Z
)
ÇÇZ [
)
ÇÇ[ \
{
ÈÈ 
hitFace
ÉÉ 
=
ÉÉ 
CurTri
ÉÉ $
/
ÉÉ% &
$num
ÉÉ' (
;
ÉÉ( )
hitDistance
ÊÊ 
=
ÊÊ  !
distance
ÊÊ" *
;
ÊÊ* +
break
ËË 
;
ËË 
}
ÌÌ 
}
ÍÍ 
hit
ÏÏ 
=
ÏÏ 
new
ÏÏ 

RaycastHit
ÏÏ  
(
ÏÏ  !
hitDistance
ÏÏ! ,
,
ÏÏ, -
InRay
ĞĞ 
.
ĞĞ 
GetPoint
ĞĞ "
(
ĞĞ" #
hitDistance
ĞĞ# .
)
ĞĞ. /
,
ĞĞ/ 0
	hitNormal
ÑÑ 
,
ÑÑ 
hitFace
ÒÒ 
)
ÒÒ 
;
ÒÒ 
return
ÔÔ 
hitFace
ÔÔ 
>
ÔÔ 
-
ÔÔ 
$num
ÔÔ 
;
ÔÔ  
}
ÕÕ 	
internal
ßß 
static
ßß 
bool
ßß 
PointIsOccluded
ßß ,
(
ßß, -
Camera
ßß- 3
cam
ßß4 7
,
ßß7 8
ProBuilderMesh
ßß9 G
pb
ßßH J
,
ßßJ K
Vector3
ßßL S

worldPoint
ßßT ^
)
ßß^ _
{
àà 	
Vector3
áá 
dir
áá 
=
áá 
(
áá 
cam
áá 
.
áá 
	transform
áá (
.
áá( )
position
áá) 1
-
áá2 3

worldPoint
áá4 >
)
áá> ?
.
áá? @

normalized
áá@ J
;
ááJ K
Ray
ää 
ray
ää 
=
ää 
new
ää 
Ray
ää 
(
ää 

worldPoint
ää (
+
ää) *
dir
ää+ .
*
ää/ 0
$num
ää1 7
,
ää7 8
dir
ää9 <
)
ää< =
;
ää= >

RaycastHit
ææ 
hit
ææ 
;
ææ 
return
èè 
FaceRaycast
èè 
(
èè 
ray
èè "
,
èè" #
pb
èè$ &
,
èè& '
out
èè( +
hit
èè, /
,
èè/ 0
Vector3
èè1 8
.
èè8 9
Distance
èè9 A
(
èèA B
cam
èèB E
.
èèE F
	transform
èèF O
.
èèO P
position
èèP X
,
èèX Y

worldPoint
èèZ d
)
èèd e
,
èèe f
CullingMode
èèg r
.
èèr s
Front
èès x
)
èèx y
;
èèy z
}
éé 	
public
ññ 
static
ññ 

Quaternion
ññ  
GetRotation
ññ! ,
(
ññ, -
ProBuilderMesh
ññ- ;
mesh
ññ< @
,
ññ@ A
IEnumerable
ññB M
<
ññM N
int
ññN Q
>
ññQ R
indices
ññS Z
)
ññZ [
{
òò 	
if
óó 
(
óó 
!
óó 
mesh
óó 
.
óó 
	HasArrays
óó 
(
óó  

MeshArrays
óó  *
.
óó* +
Normal
óó+ 1
)
óó1 2
)
óó2 3
Normals
ôô 
.
ôô 
CalculateNormals
ôô (
(
ôô( )
mesh
ôô) -
)
ôô- .
;
ôô. /
if
öö 
(
öö 
!
öö 
mesh
öö 
.
öö 
	HasArrays
öö 
(
öö  

MeshArrays
öö  *
.
öö* +
Tangent
öö+ 2
)
öö2 3
)
öö3 4
Normals
÷÷ 
.
÷÷ 
CalculateTangents
÷÷ )
(
÷÷) *
mesh
÷÷* .
)
÷÷. /
;
÷÷/ 0
var
ùù 
normals
ùù 
=
ùù 
mesh
ùù 
.
ùù 
normalsInternal
ùù .
;
ùù. /
var
úú 
tangents
úú 
=
úú 
mesh
úú 
.
úú  
tangentsInternal
úú  0
;
úú0 1
var
üü 
nrm
üü 
=
üü 
Vector3
üü 
.
üü 
zero
üü "
;
üü" #
var
ıı 
tan
ıı 
=
ıı 
Vector4
ıı 
.
ıı 
zero
ıı "
;
ıı" #
float
şş 
count
şş 
=
şş 
$num
şş 
;
şş 
foreach
€€ 
(
€€ 
var
€€ 
index
€€ 
in
€€ !
indices
€€" )
)
€€) *
{
 
var
‚‚ 
n
‚‚ 
=
‚‚ 
normals
‚‚ 
[
‚‚  
index
‚‚  %
]
‚‚% &
;
‚‚& '
var
ƒƒ 
t
ƒƒ 
=
ƒƒ 
tangents
ƒƒ  
[
ƒƒ  !
index
ƒƒ! &
]
ƒƒ& '
;
ƒƒ' (
nrm
…… 
.
…… 
x
…… 
+=
…… 
n
…… 
.
…… 
x
…… 
;
…… 
nrm
†† 
.
†† 
y
†† 
+=
†† 
n
†† 
.
†† 
y
†† 
;
†† 
nrm
‡‡ 
.
‡‡ 
z
‡‡ 
+=
‡‡ 
n
‡‡ 
.
‡‡ 
z
‡‡ 
;
‡‡ 
tan
‰‰ 
.
‰‰ 
x
‰‰ 
+=
‰‰ 
t
‰‰ 
.
‰‰ 
x
‰‰ 
;
‰‰ 
tan
ŠŠ 
.
ŠŠ 
y
ŠŠ 
+=
ŠŠ 
t
ŠŠ 
.
ŠŠ 
y
ŠŠ 
;
ŠŠ 
tan
‹‹ 
.
‹‹ 
z
‹‹ 
+=
‹‹ 
t
‹‹ 
.
‹‹ 
z
‹‹ 
;
‹‹ 
tan
ŒŒ 
.
ŒŒ 
w
ŒŒ 
+=
ŒŒ 
t
ŒŒ 
.
ŒŒ 
w
ŒŒ 
;
ŒŒ 
count
 
++
 
;
 
}
 
nrm
‘‘ 
.
‘‘ 
x
‘‘ 
/=
‘‘ 
count
‘‘ 
;
‘‘ 
nrm
’’ 
.
’’ 
y
’’ 
/=
’’ 
count
’’ 
;
’’ 
nrm
““ 
.
““ 
z
““ 
/=
““ 
count
““ 
;
““ 
tan
•• 
.
•• 
x
•• 
/=
•• 
count
•• 
;
•• 
tan
–– 
.
–– 
y
–– 
/=
–– 
count
–– 
;
–– 
tan
—— 
.
—— 
z
—— 
/=
—— 
count
—— 
;
—— 
tan
˜˜ 
.
˜˜ 
w
˜˜ 
/=
˜˜ 
count
˜˜ 
;
˜˜ 
if
šš 
(
šš 
nrm
šš 
==
šš 
Vector3
šš 
.
šš 
zero
šš #
||
šš$ &
tan
šš' *
==
šš+ -
Vector4
šš. 5
.
šš5 6
zero
šš6 :
)
šš: ;
return
›› 
mesh
›› 
.
›› 
	transform
›› %
.
››% &
rotation
››& .
;
››. /
var
 
bit
 
=
 
Vector3
 
.
 
Cross
 #
(
# $
nrm
$ '
,
' (
tan
) ,
*
- .
tan
/ 2
.
2 3
w
3 4
)
4 5
;
5 6
return
ŸŸ 
mesh
ŸŸ 
.
ŸŸ 
	transform
ŸŸ !
.
ŸŸ! "
rotation
ŸŸ" *
*
ŸŸ+ ,

Quaternion
ŸŸ- 7
.
ŸŸ7 8
LookRotation
ŸŸ8 D
(
ŸŸD E
nrm
ŸŸE H
,
ŸŸH I
bit
ŸŸJ M
)
ŸŸM N
;
ŸŸN O
}
   	
public
ªª 
static
ªª 

Quaternion
ªª  
GetFaceRotation
ªª! 0
(
ªª0 1
ProBuilderMesh
ªª1 ?
mesh
ªª@ D
,
ªªD E
HandleOrientation
ªªF W
orientation
ªªX c
,
ªªc d
IEnumerable
ªªe p
<
ªªp q
Face
ªªq u
>
ªªu v
faces
ªªw |
)
ªª| }
{
«« 	
if
¬¬ 
(
¬¬ 
mesh
¬¬ 
==
¬¬ 
null
¬¬ 
)
¬¬ 
return
­­ 

Quaternion
­­ !
.
­­! "
identity
­­" *
;
­­* +
switch
¯¯ 
(
¯¯ 
orientation
¯¯ 
)
¯¯  
{
°° 
case
±± 
HandleOrientation
±± &
.
±±& '
ActiveElement
±±' 4
:
±±4 5
return
´´ 
GetFaceRotation
´´ *
(
´´* +
mesh
´´+ /
,
´´/ 0
faces
´´1 6
.
´´6 7
Last
´´7 ;
(
´´; <
)
´´< =
)
´´= >
;
´´> ?
case
¶¶ 
HandleOrientation
¶¶ &
.
¶¶& '
ActiveObject
¶¶' 3
:
¶¶3 4
return
·· 
mesh
·· 
.
··  
	transform
··  )
.
··) *
rotation
··* 2
;
··2 3
default
¹¹ 
:
¹¹ 
return
ºº 

Quaternion
ºº %
.
ºº% &
identity
ºº& .
;
ºº. /
}
»» 
}
¼¼ 	
public
ÄÄ 
static
ÄÄ 

Quaternion
ÄÄ  
GetFaceRotation
ÄÄ! 0
(
ÄÄ0 1
ProBuilderMesh
ÄÄ1 ?
mesh
ÄÄ@ D
,
ÄÄD E
Face
ÄÄF J
face
ÄÄK O
)
ÄÄO P
{
ÅÅ 	
if
ÆÆ 
(
ÆÆ 
mesh
ÆÆ 
==
ÆÆ 
null
ÆÆ 
)
ÆÆ 
return
ÇÇ 

Quaternion
ÇÇ !
.
ÇÇ! "
identity
ÇÇ" *
;
ÇÇ* +
if
ÉÉ 
(
ÉÉ 
face
ÉÉ 
==
ÉÉ 
null
ÉÉ 
)
ÉÉ 
return
ÊÊ 
mesh
ÊÊ 
.
ÊÊ 
	transform
ÊÊ %
.
ÊÊ% &
rotation
ÊÊ& .
;
ÊÊ. /
Normal
ÎÎ 
nrm
ÎÎ 
=
ÎÎ 
Math
ÎÎ 
.
ÎÎ $
NormalTangentBitangent
ÎÎ 4
(
ÎÎ4 5
mesh
ÎÎ5 9
,
ÎÎ9 :
face
ÎÎ; ?
)
ÎÎ? @
;
ÎÎ@ A
if
ĞĞ 
(
ĞĞ 
nrm
ĞĞ 
.
ĞĞ 
normal
ĞĞ 
==
ĞĞ 
Vector3
ĞĞ %
.
ĞĞ% &
zero
ĞĞ& *
||
ĞĞ+ -
nrm
ĞĞ. 1
.
ĞĞ1 2
	bitangent
ĞĞ2 ;
==
ĞĞ< >
Vector3
ĞĞ? F
.
ĞĞF G
zero
ĞĞG K
)
ĞĞK L
return
ÑÑ 
mesh
ÑÑ 
.
ÑÑ 
	transform
ÑÑ %
.
ÑÑ% &
rotation
ÑÑ& .
;
ÑÑ. /
return
ÓÓ 
mesh
ÓÓ 
.
ÓÓ 
	transform
ÓÓ !
.
ÓÓ! "
rotation
ÓÓ" *
*
ÓÓ+ ,

Quaternion
ÓÓ- 7
.
ÓÓ7 8
LookRotation
ÓÓ8 D
(
ÓÓD E
nrm
ÓÓE H
.
ÓÓH I
normal
ÓÓI O
,
ÓÓO P
nrm
ÓÓQ T
.
ÓÓT U
	bitangent
ÓÓU ^
)
ÓÓ^ _
;
ÓÓ_ `
}
ÔÔ 	
public
ŞŞ 
static
ŞŞ 

Quaternion
ŞŞ  
GetEdgeRotation
ŞŞ! 0
(
ŞŞ0 1
ProBuilderMesh
ŞŞ1 ?
mesh
ŞŞ@ D
,
ŞŞD E
HandleOrientation
ŞŞF W
orientation
ŞŞX c
,
ŞŞc d
IEnumerable
ŞŞe p
<
ŞŞp q
Edge
ŞŞq u
>
ŞŞu v
edges
ŞŞw |
)
ŞŞ| }
{
ßß 	
if
àà 
(
àà 
mesh
àà 
==
àà 
null
àà 
)
àà 
return
áá 

Quaternion
áá !
.
áá! "
identity
áá" *
;
áá* +
switch
ãã 
(
ãã 
orientation
ãã 
)
ãã  
{
ää 
case
åå 
HandleOrientation
åå &
.
åå& '
ActiveElement
åå' 4
:
åå4 5
return
êê 
GetEdgeRotation
êê *
(
êê* +
mesh
êê+ /
,
êê/ 0
edges
êê1 6
.
êê6 7
Last
êê7 ;
(
êê; <
)
êê< =
)
êê= >
;
êê> ?
case
ìì 
HandleOrientation
ìì &
.
ìì& '
ActiveObject
ìì' 3
:
ìì3 4
return
íí 
mesh
íí 
.
íí  
	transform
íí  )
.
íí) *
rotation
íí* 2
;
íí2 3
default
ïï 
:
ïï 
return
ğğ 

Quaternion
ğğ %
.
ğğ% &
identity
ğğ& .
;
ğğ. /
}
ññ 
}
òò 	
public
úú 
static
úú 

Quaternion
úú  
GetEdgeRotation
úú! 0
(
úú0 1
ProBuilderMesh
úú1 ?
mesh
úú@ D
,
úúD E
Edge
úúF J
edge
úúK O
)
úúO P
{
ûû 	
if
üü 
(
üü 
mesh
üü 
==
üü 
null
üü 
)
üü 
return
ıı 

Quaternion
ıı !
.
ıı! "
identity
ıı" *
;
ıı* +
return
ÿÿ 
GetFaceRotation
ÿÿ "
(
ÿÿ" #
mesh
ÿÿ# '
,
ÿÿ' (
EdgeUtility
ÿÿ) 4
.
ÿÿ4 5
GetFace
ÿÿ5 <
(
ÿÿ< =
mesh
ÿÿ= A
,
ÿÿA B
edge
ÿÿC G
)
ÿÿG H
)
ÿÿH I
;
ÿÿI J
}
€€ 	
public
ŠŠ 
static
ŠŠ 

Quaternion
ŠŠ  
GetVertexRotation
ŠŠ! 2
(
ŠŠ2 3
ProBuilderMesh
ŠŠ3 A
mesh
ŠŠB F
,
ŠŠF G
HandleOrientation
ŠŠH Y
orientation
ŠŠZ e
,
ŠŠe f
IEnumerable
ŠŠg r
<
ŠŠr s
int
ŠŠs v
>
ŠŠv w
verticesŠŠx €
)ŠŠ€ 
{
‹‹ 	
if
ŒŒ 
(
ŒŒ 
mesh
ŒŒ 
==
ŒŒ 
null
ŒŒ 
)
ŒŒ 
return
 

Quaternion
 !
.
! "
identity
" *
;
* +
switch
 
(
 
orientation
 
)
  
{
 
case
‘‘ 
HandleOrientation
‘‘ &
.
‘‘& '
ActiveElement
‘‘' 4
:
‘‘4 5
if
’’ 
(
’’ 
mesh
’’ 
.
’’ !
selectedVertexCount
’’ 0
<
’’1 2
$num
’’3 4
)
’’4 5
goto
““ 
case
““ !
HandleOrientation
““" 3
.
““3 4
ActiveObject
““4 @
;
““@ A
return
”” 
GetRotation
”” &
(
””& '
mesh
””' +
,
””+ ,
vertices
””- 5
)
””5 6
;
””6 7
case
–– 
HandleOrientation
–– &
.
––& '
ActiveObject
––' 3
:
––3 4
return
—— 
mesh
—— 
.
——  
	transform
——  )
.
——) *
rotation
——* 2
;
——2 3
default
™™ 
:
™™ 
return
šš 

Quaternion
šš %
.
šš% &
identity
šš& .
;
šš. /
}
›› 
}
œœ 	
public
¤¤ 
static
¤¤ 

Quaternion
¤¤  
GetVertexRotation
¤¤! 2
(
¤¤2 3
ProBuilderMesh
¤¤3 A
mesh
¤¤B F
,
¤¤F G
int
¤¤H K
vertex
¤¤L R
)
¤¤R S
{
¥¥ 	
if
¦¦ 
(
¦¦ 
mesh
¦¦ 
==
¦¦ 
null
¦¦ 
)
¦¦ 
return
§§ 

Quaternion
§§ !
.
§§! "
identity
§§" *
;
§§* +
if
©© 
(
©© 
vertex
©© 
<
©© 
$num
©© 
)
©© 
return
ªª 
mesh
ªª 
.
ªª 
	transform
ªª %
.
ªª% &
rotation
ªª& .
;
ªª. /
return
¬¬ 
GetRotation
¬¬ 
(
¬¬ 
mesh
¬¬ #
,
¬¬# $
new
¬¬% (
int
¬¬) ,
[
¬¬, -
]
¬¬- .
{
¬¬/ 0
vertex
¬¬1 7
}
¬¬8 9
)
¬¬9 :
;
¬¬: ;
}
­­ 	
internal
¯¯ 
static
¯¯ 
Vector3
¯¯ &
GetActiveElementPosition
¯¯  8
(
¯¯8 9
ProBuilderMesh
¯¯9 G
mesh
¯¯H L
,
¯¯L M
IEnumerable
¯¯N Y
<
¯¯Y Z
Face
¯¯Z ^
>
¯¯^ _
faces
¯¯` e
)
¯¯e f
{
°° 	
return
±± 
mesh
±± 
.
±± 
	transform
±± !
.
±±! "
TransformPoint
±±" 0
(
±±0 1
Math
±±1 5
.
±±5 6
	GetBounds
±±6 ?
(
±±? @
mesh
±±@ D
.
±±D E
positionsInternal
±±E V
,
±±V W
faces
±±X ]
.
±±] ^
Last
±±^ b
(
±±b c
)
±±c d
.
±±d e%
distinctIndexesInternal
±±e |
)
±±| }
.
±±} ~
center±±~ „
)±±„ …
;±±… †
}
²² 	
internal
´´ 
static
´´ 
Vector3
´´ &
GetActiveElementPosition
´´  8
(
´´8 9
ProBuilderMesh
´´9 G
mesh
´´H L
,
´´L M
IEnumerable
´´N Y
<
´´Y Z
Edge
´´Z ^
>
´´^ _
edges
´´` e
)
´´e f
{
µµ 	
var
¶¶ 
edge
¶¶ 
=
¶¶ 
edges
¶¶ 
.
¶¶ 
Last
¶¶ !
(
¶¶! "
)
¶¶" #
;
¶¶# $
return
·· 
mesh
·· 
.
·· 
	transform
·· !
.
··! "
TransformPoint
··" 0
(
··0 1
Math
··1 5
.
··5 6
	GetBounds
··6 ?
(
··? @
mesh
··@ D
.
··D E
positionsInternal
··E V
,
··V W
new
··X [
int
··\ _
[
··_ `
]
··` a
{
··b c
edge
··d h
.
··h i
a
··i j
,
··j k
edge
··l p
.
··p q
b
··q r
}
··s t
)
··t u
.
··u v
center
··v |
)
··| }
;
··} ~
}
¸¸ 	
internal
ºº 
static
ºº 
Vector3
ºº &
GetActiveElementPosition
ºº  8
(
ºº8 9
ProBuilderMesh
ºº9 G
mesh
ººH L
,
ººL M
IEnumerable
ººN Y
<
ººY Z
int
ººZ ]
>
ºº] ^
vertices
ºº_ g
)
ººg h
{
»» 	
return
¼¼ 
mesh
¼¼ 
.
¼¼ 
	transform
¼¼ !
.
¼¼! "
TransformPoint
¼¼" 0
(
¼¼0 1
mesh
¼¼1 5
.
¼¼5 6
positionsInternal
¼¼6 G
[
¼¼G H
vertices
¼¼H P
.
¼¼P Q
First
¼¼Q V
(
¼¼V W
)
¼¼W X
]
¼¼X Y
)
¼¼Y Z
;
¼¼Z [
}
½½ 	
}
¾¾ 
}¿¿ ôu
ŠD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Smoothing.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

static 
class 
	Smoothing !
{ 
internal 
const 
int 
smoothingGroupNone -
=. /
$num0 1
;1 2
internal 
const 
int 
smoothRangeMin )
=* +
$num, -
;- .
internal 
const 
int 
smoothRangeMax )
=* +
$num, .
;. /
internal!! 
const!! 
int!! 
hardRangeMin!! '
=!!( )
$num!!* ,
;!!, -
internal&& 
const&& 
int&& 
hardRangeMax&& '
=&&( )
$num&&* ,
;&&, -
public-- 
static-- 
int-- #
GetUnusedSmoothingGroup-- 1
(--1 2
ProBuilderMesh--2 @
mesh--A E
)--E F
{.. 	
if// 
(// 
mesh// 
==// 
null// 
)// 
throw00 
new00 
System00  
.00  !!
ArgumentNullException00! 6
(006 7
$str007 =
)00= >
;00> ?
return22 '
GetNextUnusedSmoothingGroup22 .
(22. /
smoothRangeMin22/ =
,22= >
new22? B
HashSet22C J
<22J K
int22K N
>22N O
(22O P
mesh22P T
.22T U
facesInternal22U b
.22b c
Select22c i
(22i j
x22j k
=>22l n
x22o p
.22p q
smoothingGroup22q 
)	22 €
)
22€ 
)
22 ‚
;
22‚ ƒ
}33 	
static;; 
int;; '
GetNextUnusedSmoothingGroup;; .
(;;. /
int;;/ 2
start;;3 8
,;;8 9
HashSet;;: A
<;;A B
int;;B E
>;;E F
used;;G K
);;K L
{<< 	
while== 
(== 
used== 
.== 
Contains==  
(==  !
start==! &
)==& '
&&==( *
start==+ 0
<==1 2
int==3 6
.==6 7
MaxValue==7 ?
-==@ A
$num==B C
)==C D
{>> 
start?? 
++?? 
;?? 
ifAA 
(AA 
startAA 
>AA 
smoothRangeMaxAA *
&&AA+ -
startAA. 3
<AA4 5
hardRangeMaxAA6 B
)AAB C
startBB 
=BB 
hardRangeMaxBB (
+BB) *
$numBB+ ,
;BB, -
}CC 
returnEE 
startEE 
;EE 
}FF 	
publicMM 
staticMM 
boolMM 
IsSmoothMM #
(MM# $
intMM$ '
indexMM( -
)MM- .
{NN 	
returnOO 
(OO 
indexOO 
>OO 
smoothingGroupNoneOO .
&&OO/ 1
(OO2 3
indexOO3 8
<OO9 :
hardRangeMinOO; G
||OOH J
indexOOK P
>OOQ R
hardRangeMaxOOS _
)OO_ `
)OO` a
;OOa b
}PP 	
publicXX 
staticXX 
voidXX  
ApplySmoothingGroupsXX /
(XX/ 0
ProBuilderMeshXX0 >
meshXX? C
,XXC D
IEnumerableXXE P
<XXP Q
FaceXXQ U
>XXU V
facesXXW \
,XX\ ]
floatXX^ c
angleThresholdXXd r
)XXr s
{YY 	 
ApplySmoothingGroupsZZ  
(ZZ  !
meshZZ! %
,ZZ% &
facesZZ' ,
,ZZ, -
angleThresholdZZ. <
,ZZ< =
nullZZ> B
)ZZB C
;ZZC D
}[[ 	
internal]] 
static]] 
void]]  
ApplySmoothingGroups]] 1
(]]1 2
ProBuilderMesh]]2 @
mesh]]A E
,]]E F
IEnumerable]]G R
<]]R S
Face]]S W
>]]W X
faces]]Y ^
,]]^ _
float]]` e
angleThreshold]]f t
,]]t u
Vector3]]v }
[]]} ~
]]]~ 
normals
]]€ ‡
)
]]‡ ˆ
{^^ 	
if__ 
(__ 
mesh__ 
==__ 
null__ 
||__ 
faces__  %
==__& (
null__) -
)__- .
throw`` 
new`` 
System``  
.``  !!
ArgumentNullException``! 6
(``6 7
$str``7 =
)``= >
;``> ?
boolcc 
anySmoothedcc 
=cc 
falsecc $
;cc$ %
foreachee 
(ee 
Faceee 
faceee 
inee !
facesee" '
)ee' (
{ff 
ifgg 
(gg 
facegg 
.gg 
smoothingGroupgg '
!=gg( *
smoothingGroupNonegg+ =
)gg= >
anySmoothedhh 
=hh  !
truehh" &
;hh& '
facejj 
.jj 
smoothingGroupjj #
=jj$ %
	Smoothingjj& /
.jj/ 0
smoothingGroupNonejj0 B
;jjB C
}kk 
ifoo 
(oo 
normalsoo 
==oo 
nulloo 
)oo  
{pp 
ifqq 
(qq 
anySmoothedqq 
)qq  
meshrr 
.rr 
meshrr 
.rr 
normalsrr %
=rr& '
nullrr( ,
;rr, -
normalsss 
=ss 
meshss 
.ss 

GetNormalsss )
(ss) *
)ss* +
;ss+ ,
}tt 
floatvv 
	thresholdvv 
=vv 
Mathfvv #
.vv# $
Absvv$ '
(vv' (
Mathfvv( -
.vv- .
Cosvv. 1
(vv1 2
Mathfvv2 7
.vv7 8
Clampvv8 =
(vv= >
angleThresholdvv> L
,vvL M
$numvvN P
,vvP Q
$numvvR Y
)vvY Z
*vv[ \
Mathfvv] b
.vvb c
Deg2Radvvc j
)vvj k
)vvk l
;vvl m
HashSetww 
<ww 
intww 
>ww 
usedww 
=ww 
newww  #
HashSetww$ +
<ww+ ,
intww, /
>ww/ 0
(ww0 1
meshww1 5
.ww5 6
facesInternalww6 C
.wwC D
SelectwwD J
(wwJ K
xwwK L
=>wwM O
xwwP Q
.wwQ R
smoothingGroupwwR `
)ww` a
)wwa b
;wwb c
intxx 
groupxx 
=xx '
GetNextUnusedSmoothingGroupxx 3
(xx3 4
$numxx4 5
,xx5 6
usedxx7 ;
)xx; <
;xx< =
HashSetyy 
<yy 
Faceyy 
>yy 
	processedyy #
=yy$ %
newyy& )
HashSetyy* 1
<yy1 2
Faceyy2 6
>yy6 7
(yy7 8
)yy8 9
;yy9 :
Listzz 
<zz 

WingedEdgezz 
>zz 
wingszz "
=zz# $

WingedEdgezz% /
.zz/ 0
GetWingedEdgeszz0 >
(zz> ?
meshzz? C
,zzC D
faceszzE J
,zzJ K
truezzL P
)zzP Q
;zzQ R
foreach|| 
(|| 

WingedEdge|| 
wing||  $
in||% '
wings||( -
)||- .
{}} 
if 
( 
! 
	processed 
. 
Add "
(" #
wing# '
.' (
face( ,
), -
)- .
continue
€€ 
;
€€ 
wing
‚‚ 
.
‚‚ 
face
‚‚ 
.
‚‚ 
smoothingGroup
‚‚ (
=
‚‚) *
group
‚‚+ 0
;
‚‚0 1
if
„„ 
(
„„ $
FindSoftEdgesRecursive
„„ *
(
„„* +
normals
„„+ 2
,
„„2 3
wing
„„4 8
,
„„8 9
	threshold
„„: C
,
„„C D
	processed
„„E N
)
„„N O
)
„„O P
{
…… 
used
†† 
.
†† 
Add
†† 
(
†† 
group
†† "
)
††" #
;
††# $
group
‡‡ 
=
‡‡ )
GetNextUnusedSmoothingGroup
‡‡ 7
(
‡‡7 8
group
‡‡8 =
,
‡‡= >
used
‡‡? C
)
‡‡C D
;
‡‡D E
}
ˆˆ 
else
‰‰ 
{
ŠŠ 
wing
‹‹ 
.
‹‹ 
face
‹‹ 
.
‹‹ 
smoothingGroup
‹‹ ,
=
‹‹- .
	Smoothing
‹‹/ 8
.
‹‹8 9 
smoothingGroupNone
‹‹9 K
;
‹‹K L
}
ŒŒ 
}
 
}
 	
static
‘‘ 
bool
‘‘ $
FindSoftEdgesRecursive
‘‘ *
(
‘‘* +
Vector3
‘‘+ 2
[
‘‘2 3
]
‘‘3 4
normals
‘‘5 <
,
‘‘< =

WingedEdge
‘‘> H
wing
‘‘I M
,
‘‘M N
float
‘‘O T
angleThreshold
‘‘U c
,
‘‘c d
HashSet
‘‘e l
<
‘‘l m
Face
‘‘m q
>
‘‘q r
	processed
‘‘s |
)
‘‘| }
{
’’ 	
bool
““ 
foundSmoothEdge
““  
=
““! "
false
““# (
;
““( )
using
•• 
(
•• 
var
•• 
it
•• 
=
•• 
new
•• "
WingedEdgeEnumerator
••  4
(
••4 5
wing
••5 9
)
••9 :
)
••: ;
{
–– 
while
—— 
(
—— 
it
—— 
.
—— 
MoveNext
—— "
(
——" #
)
——# $
)
——$ %
{
˜˜ 
var
™™ 
border
™™ 
=
™™  
it
™™! #
.
™™# $
Current
™™$ +
;
™™+ ,
if
›› 
(
›› 
border
›› 
.
›› 
opposite
›› '
==
››( *
null
››+ /
)
››/ 0
continue
œœ  
;
œœ  !
if
 
(
 
border
 
.
 
opposite
 '
.
' (
face
( ,
.
, -
smoothingGroup
- ;
==
< >
	Smoothing
? H
.
H I 
smoothingGroupNone
I [
&&
ŸŸ 

IsSoftEdge
ŸŸ %
(
ŸŸ% &
normals
ŸŸ& -
,
ŸŸ- .
border
ŸŸ/ 5
.
ŸŸ5 6
edge
ŸŸ6 :
,
ŸŸ: ;
border
ŸŸ< B
.
ŸŸB C
opposite
ŸŸC K
.
ŸŸK L
edge
ŸŸL P
,
ŸŸP Q
angleThreshold
ŸŸR `
)
ŸŸ` a
)
ŸŸa b
{
   
if
¡¡ 
(
¡¡ 
	processed
¡¡ %
.
¡¡% &
Add
¡¡& )
(
¡¡) *
border
¡¡* 0
.
¡¡0 1
opposite
¡¡1 9
.
¡¡9 :
face
¡¡: >
)
¡¡> ?
)
¡¡? @
{
¢¢ 
foundSmoothEdge
££ +
=
££, -
true
££. 2
;
££2 3
border
¤¤ "
.
¤¤" #
opposite
¤¤# +
.
¤¤+ ,
face
¤¤, 0
.
¤¤0 1
smoothingGroup
¤¤1 ?
=
¤¤@ A
wing
¤¤B F
.
¤¤F G
face
¤¤G K
.
¤¤K L
smoothingGroup
¤¤L Z
;
¤¤Z [$
FindSoftEdgesRecursive
¥¥ 2
(
¥¥2 3
normals
¥¥3 :
,
¥¥: ;
border
¥¥< B
.
¥¥B C
opposite
¥¥C K
,
¥¥K L
angleThreshold
¥¥M [
,
¥¥[ \
	processed
¥¥] f
)
¥¥f g
;
¥¥g h
}
¦¦ 
}
§§ 
}
¨¨ 
}
©© 
return
«« 
foundSmoothEdge
«« "
;
««" #
}
¬¬ 	
static
®® 
bool
®® 

IsSoftEdge
®® 
(
®® 
Vector3
®® &
[
®®& '
]
®®' (
normals
®®) 0
,
®®0 1

EdgeLookup
®®2 <
left
®®= A
,
®®A B

EdgeLookup
®®C M
right
®®N S
,
®®S T
float
®®U Z
	threshold
®®[ d
)
®®d e
{
¯¯ 	
Vector3
°° 
lx
°° 
=
°° 
normals
°°  
[
°°  !
left
°°! %
.
°°% &
local
°°& +
.
°°+ ,
a
°°, -
]
°°- .
;
°°. /
Vector3
±± 
ly
±± 
=
±± 
normals
±±  
[
±±  !
left
±±! %
.
±±% &
local
±±& +
.
±±+ ,
b
±±, -
]
±±- .
;
±±. /
Vector3
²² 
rx
²² 
=
²² 
normals
²²  
[
²²  !
right
²²! &
.
²²& '
common
²²' -
.
²²- .
a
²². /
==
²²0 2
left
²²3 7
.
²²7 8
common
²²8 >
.
²²> ?
a
²²? @
?
²²A B
right
²²C H
.
²²H I
local
²²I N
.
²²N O
a
²²O P
:
²²Q R
right
²²S X
.
²²X Y
local
²²Y ^
.
²²^ _
b
²²_ `
]
²²` a
;
²²a b
Vector3
³³ 
ry
³³ 
=
³³ 
normals
³³  
[
³³  !
right
³³! &
.
³³& '
common
³³' -
.
³³- .
b
³³. /
==
³³0 2
left
³³3 7
.
³³7 8
common
³³8 >
.
³³> ?
b
³³? @
?
³³A B
right
³³C H
.
³³H I
local
³³I N
.
³³N O
b
³³O P
:
³³Q R
right
³³S X
.
³³X Y
local
³³Y ^
.
³³^ _
a
³³_ `
]
³³` a
;
³³a b
lx
´´ 
.
´´ 
	Normalize
´´ 
(
´´ 
)
´´ 
;
´´ 
ly
µµ 
.
µµ 
	Normalize
µµ 
(
µµ 
)
µµ 
;
µµ 
rx
¶¶ 
.
¶¶ 
	Normalize
¶¶ 
(
¶¶ 
)
¶¶ 
;
¶¶ 
ry
·· 
.
·· 
	Normalize
·· 
(
·· 
)
·· 
;
·· 
return
¸¸ 
Mathf
¸¸ 
.
¸¸ 
Abs
¸¸ 
(
¸¸ 
Vector3
¸¸ $
.
¸¸$ %
Dot
¸¸% (
(
¸¸( )
lx
¸¸) +
,
¸¸+ ,
rx
¸¸- /
)
¸¸/ 0
)
¸¸0 1
>
¸¸2 3
	threshold
¸¸4 =
&&
¸¸> @
Mathf
¸¸A F
.
¸¸F G
Abs
¸¸G J
(
¸¸J K
Vector3
¸¸K R
.
¸¸R S
Dot
¸¸S V
(
¸¸V W
ly
¸¸W Y
,
¸¸Y Z
ry
¸¸[ ]
)
¸¸] ^
)
¸¸^ _
>
¸¸` a
	threshold
¸¸b k
;
¸¸k l
}
¹¹ 	
}
ºº 
}»» è?
‰D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Clipping.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
Clipping 
{ 
[ 	
System	 
. 
Flags 
] 
enum 
OutCode 
{ 	
Inside 
= 
$num 
, 
Left 
= 
$num 
, 
Right 
= 
$num 
, 
Bottom 
= 
$num 
, 
Top 
= 
$num 
, 
} 	
static 
OutCode 
ComputeOutCode %
(% &
Rect& *
rect+ /
,/ 0
float1 6
x7 8
,8 9
float: ?
y@ A
)A B
{ 	
OutCode 
code 
= 
OutCode "
." #
Inside# )
;) *
if   
(   
x   
<   
rect   
.   
xMin   
)   
code!! 
|=!! 
OutCode!! 
.!!  
Left!!  $
;!!$ %
else"" 
if"" 
("" 
x"" 
>"" 
rect"" 
."" 
xMax"" "
)""" #
code## 
|=## 
OutCode## 
.##  
Right##  %
;##% &
if$$ 
($$ 
y$$ 
<$$ 
rect$$ 
.$$ 
yMin$$ 
)$$ 
code%% 
|=%% 
OutCode%% 
.%%  
Bottom%%  &
;%%& '
else&& 
if&& 
(&& 
y&& 
>&& 
rect&& 
.&& 
yMax&& "
)&&" #
code'' 
|='' 
OutCode'' 
.''  
Top''  #
;''# $
return)) 
code)) 
;)) 
}** 	
internal// 
static// 
bool// #
RectContainsLineSegment// 4
(//4 5
Rect//5 9
rect//: >
,//> ?
float//@ E
x0//F H
,//H I
float//J O
y0//P R
,//R S
float//T Y
x1//Z \
,//\ ]
float//^ c
y1//d f
)//f g
{00 	
OutCode22 
outcode022 
=22 
ComputeOutCode22 -
(22- .
rect22. 2
,222 3
x0224 6
,226 7
y0228 :
)22: ;
;22; <
OutCode33 
outcode133 
=33 
ComputeOutCode33 -
(33- .
rect33. 2
,332 3
x1334 6
,336 7
y1338 :
)33: ;
;33; <
bool55 
accept55 
=55 
false55 
;55  
while77 
(77 
true77 
)77 
{88 
if99 
(99 
(99 
outcode099 
|99 
outcode199  (
)99( )
==99* ,
OutCode99- 4
.994 5
Inside995 ;
)99; <
{:: 
accept<< 
=<< 
true<< !
;<<! "
break== 
;== 
}>> 
else?? 
if?? 
(?? 
(?? 
outcode0?? "
&??# $
outcode1??% -
)??- .
!=??/ 1
OutCode??2 9
.??9 :
Inside??: @
)??@ A
{@@ 
breakCC 
;CC 
}DD 
elseEE 
{FF 
floatII 
xII 
=II 
$numII  
,II  !
yII" #
=II$ %
$numII& (
;II( )
OutCodeLL 

outcodeOutLL &
=LL' (
outcode0LL) 1
!=LL2 4
OutCodeLL5 <
.LL< =
InsideLL= C
?LLD E
outcode0LLF N
:LLO P
outcode1LLQ Y
;LLY Z
ifUU 
(UU 
(UU 

outcodeOutUU #
&UU$ %
OutCodeUU& -
.UU- .
TopUU. 1
)UU1 2
==UU3 5
OutCodeUU6 =
.UU= >
TopUU> A
)UUA B
{VV 
xXX 
=XX 
x0XX 
+XX  
(XX! "
x1XX" $
-XX% &
x0XX' )
)XX) *
*XX+ ,
(XX- .
rectXX. 2
.XX2 3
yMaxXX3 7
-XX8 9
y0XX: <
)XX< =
/XX> ?
(XX@ A
y1XXA C
-XXD E
y0XXF H
)XXH I
;XXI J
yYY 
=YY 
rectYY  
.YY  !
yMaxYY! %
;YY% &
}ZZ 
else[[ 
if[[ 
([[ 
([[ 

outcodeOut[[ (
&[[) *
OutCode[[+ 2
.[[2 3
Bottom[[3 9
)[[9 :
==[[; =
OutCode[[> E
.[[E F
Bottom[[F L
)[[L M
{\\ 
x^^ 
=^^ 
x0^^ 
+^^  
(^^! "
x1^^" $
-^^% &
x0^^' )
)^^) *
*^^+ ,
(^^- .
rect^^. 2
.^^2 3
yMin^^3 7
-^^8 9
y0^^: <
)^^< =
/^^> ?
(^^@ A
y1^^A C
-^^D E
y0^^F H
)^^H I
;^^I J
y__ 
=__ 
rect__  
.__  !
yMin__! %
;__% &
}`` 
elseaa 
ifaa 
(aa 
(aa 

outcodeOutaa (
&aa) *
OutCodeaa+ 2
.aa2 3
Rightaa3 8
)aa8 9
==aa: <
OutCodeaa= D
.aaD E
RightaaE J
)aaJ K
{bb 
ydd 
=dd 
y0dd 
+dd  
(dd! "
y1dd" $
-dd% &
y0dd' )
)dd) *
*dd+ ,
(dd- .
rectdd. 2
.dd2 3
xMaxdd3 7
-dd8 9
x0dd: <
)dd< =
/dd> ?
(dd@ A
x1ddA C
-ddD E
x0ddF H
)ddH I
;ddI J
xee 
=ee 
rectee  
.ee  !
xMaxee! %
;ee% &
}ff 
elsegg 
ifgg 
(gg 
(gg 

outcodeOutgg (
&gg) *
OutCodegg+ 2
.gg2 3
Leftgg3 7
)gg7 8
==gg9 ;
OutCodegg< C
.ggC D
LeftggD H
)ggH I
{hh 
yjj 
=jj 
y0jj 
+jj  
(jj! "
y1jj" $
-jj% &
y0jj' )
)jj) *
*jj+ ,
(jj- .
rectjj. 2
.jj2 3
xMinjj3 7
-jj8 9
x0jj: <
)jj< =
/jj> ?
(jj@ A
x1jjA C
-jjD E
x0jjF H
)jjH I
;jjI J
xkk 
=kk 
rectkk  
.kk  !
xMinkk! %
;kk% &
}ll 
ifpp 
(pp 

outcodeOutpp "
==pp# %
outcode0pp& .
)pp. /
{qq 
x0rr 
=rr 
xrr 
;rr 
y0ss 
=ss 
yss 
;ss 
outcode0tt  
=tt! "
ComputeOutCodett# 1
(tt1 2
recttt2 6
,tt6 7
x0tt8 :
,tt: ;
y0tt< >
)tt> ?
;tt? @
}uu 
elsevv 
{ww 
x1xx 
=xx 
xxx 
;xx 
y1yy 
=yy 
yyy 
;yy 
outcode1zz  
=zz! "
ComputeOutCodezz# 1
(zz1 2
rectzz2 6
,zz6 7
x1zz8 :
,zz: ;
y1zz< >
)zz> ?
;zz? @
}{{ 
}|| 
}}} 
return 
accept 
; 
}
€€ 	
}
 
}‚‚ Ô
‹D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\PivotPoint.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

enum 

PivotPoint 
{ 
Center		 
,		 
IndividualOrigins 
, 
ActiveElement 
, 
} 
} â½
‡D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Spline.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static 

class 
Spline 
{ 
internal 
static 
ProBuilderMesh &
Extrude' .
(. /
IList/ 4
<4 5
BezierPoint5 @
>@ A
pointsB H
,H I
float 
radius 
= 
$num 
, 
int 
columns 
= 
$num 
, 
int 
rows 
= 
$num 
, 
bool 
	closeLoop 
= 
false "
," #
bool 
smooth 
= 
true 
) 
{ 	
ProBuilderMesh 
pb 
= 
null  $
;$ %
Extrude 
( 
points 
, 
radius "
," #
columns$ +
,+ ,
rows- 1
,1 2
	closeLoop3 <
,< =
smooth> D
,D E
refF I
pbJ L
)L M
;M N
return 
pb 
; 
} 	
internal   
static   
void   
Extrude   $
(  $ %
IList  % *
<  * +
BezierPoint  + 6
>  6 7
bezierPoints  8 D
,  D E
float!! 
radius!! 
,!! 
int"" 
columns"" 
,"" 
int## 
rows## 
,## 
bool$$ 
	closeLoop$$ 
,$$ 
bool%% 
smooth%% 
,%% 
ref&& 
ProBuilderMesh&& 
target&& %
)&&% &
{'' 	
List(( 
<(( 

Quaternion(( 
>(( 
	rotations(( &
=((' (
new(() ,
List((- 1
<((1 2

Quaternion((2 <
>((< =
(((= >
)((> ?
;((? @
List)) 
<)) 
Vector3)) 
>)) 
	positions)) #
=))$ %
GetControlPoints))& 6
())6 7
bezierPoints))7 C
,))C D
columns))E L
,))L M
	closeLoop))N W
,))W X
	rotations))Y b
)))b c
;))c d
Extrude** 
(** 
	positions** 
,** 
radius** %
,**% &
rows**' +
,**+ ,
	closeLoop**- 6
,**6 7
smooth**8 >
,**> ?
ref**@ C
target**D J
,**J K
	rotations**L U
)**U V
;**V W
}++ 	
internal.. 
static.. 
List.. 
<.. 
Vector3.. $
>..$ %
GetControlPoints..& 6
(..6 7
IList..7 <
<..< =
BezierPoint..= H
>..H I
bezierPoints..J V
,..V W
int..X ["
subdivisionsPerSegment..\ r
,..r s
bool..t x
	closeLoop	..y ‚
,
..‚ ƒ
List
..„ ˆ
<
..ˆ ‰

Quaternion
..‰ “
>
..“ ”
	rotations
..• 
)
.. Ÿ
{// 	
int00 
cols00 
=00 "
subdivisionsPerSegment00 -
;00- .
int11 
c11 
=11 
bezierPoints11  
.11  !
Count11! &
;11& '
List22 
<22 
Vector322 
>22 
	positions22 #
=22$ %
new22& )
List22* .
<22. /
Vector322/ 6
>226 7
(227 8
cols228 <
*22= >
c22? @
)22@ A
;22A B
if44 
(44 
	rotations44 
!=44 
null44 !
)44! "
{55 
	rotations66 
.66 
Clear66 
(66  
)66  !
;66! "
	rotations77 
.77 
Capacity77 "
=77# $
cols77% )
*77* +
c77, -
;77- .
}88 
int:: 
	keyframes:: 
=:: 
(:: 
	closeLoop:: &
?::' (
c::) *
:::+ ,
c::- .
-::/ 0
$num::1 2
)::2 3
;::3 4
for<< 
(<< 
int<< 
i<< 
=<< 
$num<< 
;<< 
i<< 
<<< 
	keyframes<<  )
;<<) *
i<<+ ,
++<<, .
)<<. /
{== 
int>> !
segments_per_keyframe>> )
=>>* +
(>>, -
(>>- .
!>>. /
	closeLoop>>/ 8
&&>>9 ;
i>>< =
>=>>> @
c>>A B
->>C D
$num>>E F
)>>F G
?>>H I
cols>>J N
+>>O P
$num>>Q R
:>>S T
cols>>U Y
)>>Y Z
;>>Z [
for@@ 
(@@ 
int@@ 
n@@ 
=@@ 
$num@@ 
;@@ 
n@@  !
<@@" #!
segments_per_keyframe@@$ 9
;@@9 :
n@@; <
++@@< >
)@@> ?
{AA 
floatBB 
sBB 
=BB 
colsBB "
;BB" #
	positionsDD 
.DD 
AddDD !
(DD! "
BezierPointDD" -
.DD- .
CubicPositionDD. ;
(DD; <
bezierPointsDD< H
[DDH I
iDDI J
]DDJ K
,DDK L
bezierPointsDDM Y
[DDY Z
(DDZ [
iDD[ \
+DD] ^
$numDD_ `
)DD` a
%DDb c
cDDd e
]DDe f
,DDf g
nDDh i
/DDj k
sDDl m
)DDm n
)DDn o
;DDo p
ifFF 
(FF 
	rotationsFF !
!=FF" $
nullFF% )
)FF) *
	rotationsGG !
.GG! "
AddGG" %
(GG% &

QuaternionGG& 0
.GG0 1
SlerpGG1 6
(GG6 7
bezierPointsGG7 C
[GGC D
iGGD E
]GGE F
.GGF G
rotationGGG O
,GGO P
bezierPointsGGQ ]
[GG] ^
(GG^ _
iGG_ `
+GGa b
$numGGc d
)GGd e
%GGf g
cGGh i
]GGi j
.GGj k
rotationGGk s
,GGs t
nGGu v
/GGw x
(GGy z
floatGGz 
)	GG €
(
GG€ #
segments_per_keyframe
GG –
-
GG— ˜
$num
GG™ š
)
GGš ›
)
GG› œ
)
GGœ 
;
GG 
}HH 
}II 
returnKK 
	positionsKK 
;KK 
}LL 	
internalOO 
staticOO 
voidOO 
ExtrudeOO $
(OO$ %
IListOO% *
<OO* +
Vector3OO+ 2
>OO2 3
pointsOO4 :
,OO: ;
floatPP 
radiusPP 
,PP 
intQQ 

radiusRowsQQ 
,QQ 
boolRR 
	closeLoopRR 
,RR 
boolSS 
smoothSS 
,SS 
refTT 
ProBuilderMeshTT 
targetTT %
,TT% &
IListUU 
<UU 

QuaternionUU 
>UU 
pointRotationsUU ,
=UU- .
nullUU/ 3
)UU3 4
{VV 	
ifWW 
(WW 
pointsWW 
==WW 
nullWW 
||WW !
pointsWW" (
.WW( )
CountWW) .
<WW/ 0
$numWW1 2
)WW2 3
returnXX 
;XX 
intZZ 
cntZZ 
=ZZ 
pointsZZ 
.ZZ 
CountZZ "
;ZZ" #
int[[ 
rows[[ 
=[[ 
System[[ 
.[[ 
Math[[ "
.[[" #
Max[[# &
([[& '
$num[[' (
,[[( )

radiusRows[[* 4
)[[4 5
;[[5 6
int\\ 
	rowsPlus1\\ 
=\\ 
rows\\  
+\\! "
$num\\# $
;\\$ %
int]] 
rowsPlus1Times2]] 
=]]  !
rows]]" &
*]]' (
$num]]) *
;]]* +
int^^ 
vertexCount^^ 
=^^ 
(^^ 
(^^  
	closeLoop^^  )
?^^* +
cnt^^, /
:^^0 1
cnt^^2 5
-^^6 7
$num^^8 9
)^^9 :
*^^; <
$num^^= >
)^^> ?
*^^@ A
rowsPlus1Times2^^B Q
;^^Q R
bool__ 
vertexCountsMatch__ "
=__# $
false__% *
;__* +
bool`` 
hasPointRotations`` "
=``# $
pointRotations``% 3
!=``4 6
null``7 ;
&&``< >
pointRotations``? M
.``M N
Count``N S
==``T V
points``W ]
.``] ^
Count``^ c
;``c d
Vector3bb 
[bb 
]bb 
	positionsbb 
=bb  !
newbb" %
Vector3bb& -
[bb- .
vertexCountbb. 9
]bb9 :
;bb: ;
Facecc 
[cc 
]cc 
facescc 
=cc 
vertexCountsMatchcc ,
?cc- .
nullcc/ 3
:cc4 5
newcc6 9
Facecc: >
[cc> ?
(cc? @
	closeLoopcc@ I
?ccJ K
cntccL O
:ccP Q
cntccR U
-ccV W
$numccX Y
)ccY Z
*cc[ \
rowscc] a
]cca b
;ccb c
intee 
triangleIndexee 
=ee 
$numee  !
,ee! "
	faceIndexee# ,
=ee- .
$numee/ 0
,ee0 1
vertexIndexee2 =
=ee> ?
$numee@ A
;eeA B
intff 
segmentCountff 
=ff 
(ff  
	closeLoopff  )
?ff* +
cntff, /
:ff0 1
cntff2 5
-ff6 7
$numff8 9
)ff9 :
;ff: ;
forhh 
(hh 
inthh 
ihh 
=hh 
$numhh 
;hh 
ihh 
<hh 
segmentCounthh  ,
;hh, -
ihh. /
++hh/ 1
)hh1 2
{ii 
floatjj 
secant_ajj 
,jj 
secant_bjj  (
;jj( )

Quaternionll 

rotation_all %
=ll& '
GetRingRotationll( 7
(ll7 8
pointsll8 >
,ll> ?
ill@ A
,llA B
	closeLoopllC L
,llL M
outllN Q
secant_allR Z
)llZ [
;ll[ \

Quaternionmm 

rotation_bmm %
=mm& '
GetRingRotationmm( 7
(mm7 8
pointsmm8 >
,mm> ?
(mm@ A
immA B
+mmC D
$nummmE F
)mmF G
%mmH I
cntmmJ M
,mmM N
	closeLoopmmO X
,mmX Y
outmmZ ]
secant_bmm^ f
)mmf g
;mmg h
ifoo 
(oo 
hasPointRotationsoo %
)oo% &
{pp 

rotation_aqq 
=qq  

rotation_aqq! +
*qq, -
pointRotationsqq. <
[qq< =
iqq= >
]qq> ?
;qq? @

rotation_brr 
=rr  

rotation_brr! +
*rr, -
pointRotationsrr. <
[rr< =
(rr= >
irr> ?
+rr@ A
$numrrB C
)rrC D
%rrE F
cntrrG J
]rrJ K
;rrK L
}ss 
Vector3uu 
[uu 
]uu 
ringAuu 
=uu  !

VertexRinguu" ,
(uu, -

rotation_auu- 7
,uu7 8
pointsuu9 ?
[uu? @
iuu@ A
]uuA B
,uuB C
radiusuuD J
,uuJ K
	rowsPlus1uuL U
)uuU V
;uuV W
Vector3vv 
[vv 
]vv 
ringBvv 
=vv  !

VertexRingvv" ,
(vv, -

rotation_bvv- 7
,vv7 8
pointsvv9 ?
[vv? @
(vv@ A
ivvA B
+vvC D
$numvvE F
)vvF G
%vvH I
cntvvJ M
]vvM N
,vvN O
radiusvvP V
,vvV W
	rowsPlus1vvX a
)vva b
;vvb c
Systemxx 
.xx 
Arrayxx 
.xx 
Copyxx !
(xx! "
ringAxx" '
,xx' (
$numxx) *
,xx* +
	positionsxx, 5
,xx5 6
vertexIndexxx7 B
,xxB C
rowsPlus1Times2xxD S
)xxS T
;xxT U
vertexIndexyy 
+=yy 
rowsPlus1Times2yy .
;yy. /
Systemzz 
.zz 
Arrayzz 
.zz 
Copyzz !
(zz! "
ringBzz" '
,zz' (
$numzz) *
,zz* +
	positionszz, 5
,zz5 6
vertexIndexzz7 B
,zzB C
rowsPlus1Times2zzD S
)zzS T
;zzT U
vertexIndex{{ 
+={{ 
rowsPlus1Times2{{ .
;{{. /
if}} 
(}} 
!}} 
vertexCountsMatch}} &
)}}& '
{~~ 
for 
( 
int 
n 
=  
$num! "
;" #
n$ %
<& '
rowsPlus1Times2( 7
;7 8
n9 :
+=; =
$num> ?
)? @
{
€€ 
faces
 
[
 
	faceIndex
 '
]
' (
=
) *
new
+ .
Face
/ 3
(
3 4
new
4 7
int
8 ;
[
; <
$num
< =
]
= >
{
‚‚ 
triangleIndex
ƒƒ )
,
ƒƒ) *
triangleIndex
ƒƒ+ 8
+
ƒƒ9 :
$num
ƒƒ; <
,
ƒƒ< =
triangleIndex
ƒƒ> K
+
ƒƒL M
rowsPlus1Times2
ƒƒN ]
,
ƒƒ] ^
triangleIndex
„„ )
+
„„* +
rowsPlus1Times2
„„, ;
,
„„; <
triangleIndex
„„= J
+
„„K L
$num
„„M N
,
„„N O
triangleIndex
„„P ]
+
„„^ _
rowsPlus1Times2
„„` o
+
„„p q
$num
„„r s
}
…… 
)
…… 
;
…… 
if
‡‡ 
(
‡‡ 
smooth
‡‡ "
)
‡‡" #
faces
ˆˆ !
[
ˆˆ! "
	faceIndex
ˆˆ" +
]
ˆˆ+ ,
.
ˆˆ, -
smoothingGroup
ˆˆ- ;
=
ˆˆ< =
$num
ˆˆ> ?
;
ˆˆ? @
	faceIndex
ŠŠ !
++
ŠŠ! #
;
ŠŠ# $
triangleIndex
‹‹ %
+=
‹‹& (
$num
‹‹) *
;
‹‹* +
}
ŒŒ 
triangleIndex
 !
+=
" $
rowsPlus1Times2
% 4
;
4 5
}
 
}
 
if
’’ 
(
’’ 
target
’’ 
!=
’’ 
null
’’ 
)
’’ 
{
““ 
if
”” 
(
”” 
faces
”” 
!=
”” 
null
”” !
)
””! "
{
•• 
target
–– 
.
–– *
RebuildWithPositionsAndFaces
–– 7
(
––7 8
	positions
––8 A
,
––A B
faces
––C H
)
––H I
;
––I J
}
—— 
else
˜˜ 
{
™™ 
target
šš 
.
šš 
	positions
šš $
=
šš% &
	positions
šš' 0
;
šš0 1
target
›› 
.
›› 
ToMesh
›› !
(
››! "
)
››" #
;
››# $
target
œœ 
.
œœ 
Refresh
œœ "
(
œœ" #
RefreshMask
œœ# .
.
œœ. /
UV
œœ/ 1
|
œœ2 3
RefreshMask
œœ4 ?
.
œœ? @
Colors
œœ@ F
|
œœG H
RefreshMask
œœI T
.
œœT U
Normals
œœU \
|
œœ] ^
RefreshMask
œœ_ j
.
œœj k
Tangents
œœk s
)
œœs t
;
œœt u
}
 
}
 
else
ŸŸ 
{
   
target
¡¡ 
=
¡¡ 
ProBuilderMesh
¡¡ '
.
¡¡' (
Create
¡¡( .
(
¡¡. /
	positions
¡¡/ 8
,
¡¡8 9
faces
¡¡: ?
)
¡¡? @
;
¡¡@ A
}
¢¢ 
}
££ 	
static
¥¥ 

Quaternion
¥¥ 
GetRingRotation
¥¥ )
(
¥¥) *
IList
¥¥* /
<
¥¥/ 0
Vector3
¥¥0 7
>
¥¥7 8
points
¥¥9 ?
,
¥¥? @
int
¥¥A D
i
¥¥E F
,
¥¥F G
bool
¥¥H L
	closeLoop
¥¥M V
,
¥¥V W
out
¥¥X [
float
¥¥\ a
secant
¥¥b h
)
¥¥h i
{
¦¦ 	
int
§§ 
cnt
§§ 
=
§§ 
points
§§ 
.
§§ 
Count
§§ "
;
§§" #
Vector3
¨¨ 
dir
¨¨ 
;
¨¨ 
if
ªª 
(
ªª 
	closeLoop
ªª 
||
ªª 
(
ªª 
i
ªª 
>
ªª  !
$num
ªª" #
&&
ªª$ &
i
ªª' (
<
ªª) *
cnt
ªª+ .
-
ªª/ 0
$num
ªª1 2
)
ªª2 3
)
ªª3 4
{
«« 
int
¬¬ 
a
¬¬ 
=
¬¬ 
i
¬¬ 
<
¬¬ 
$num
¬¬ 
?
¬¬ 
cnt
¬¬  #
-
¬¬$ %
$num
¬¬& '
:
¬¬( )
i
¬¬* +
-
¬¬, -
$num
¬¬. /
;
¬¬/ 0
int
­­ 
b
­­ 
=
­­ 
i
­­ 
;
­­ 
int
®® 
c
®® 
=
®® 
(
®® 
i
®® 
+
®® 
$num
®® 
)
®® 
%
®®  !
cnt
®®" %
;
®®% &
Vector3
°° 
coming
°° 
=
°°  
(
°°! "
points
°°" (
[
°°( )
b
°°) *
]
°°* +
-
°°, -
points
°°. 4
[
°°4 5
a
°°5 6
]
°°6 7
)
°°7 8
.
°°8 9

normalized
°°9 C
;
°°C D
Vector3
±± 
leaving
±± 
=
±±  !
(
±±" #
points
±±# )
[
±±) *
c
±±* +
]
±±+ ,
-
±±- .
points
±±/ 5
[
±±5 6
b
±±6 7
]
±±7 8
)
±±8 9
.
±±9 :

normalized
±±: D
;
±±D E
dir
³³ 
=
³³ 
(
³³ 
coming
³³ 
+
³³ 
leaving
³³  '
)
³³' (
*
³³) *
$num
³³+ .
;
³³. /
secant
µµ 
=
µµ 
Math
µµ 
.
µµ 
Secant
µµ $
(
µµ$ %
Vector3
µµ% ,
.
µµ, -
Angle
µµ- 2
(
µµ2 3
coming
µµ3 9
,
µµ9 :
dir
µµ; >
)
µµ> ?
*
µµ@ A
Mathf
µµB G
.
µµG H
Deg2Rad
µµH O
)
µµO P
;
µµP Q
}
¶¶ 
else
·· 
{
¸¸ 
if
¹¹ 
(
¹¹ 
i
¹¹ 
<
¹¹ 
$num
¹¹ 
)
¹¹ 
dir
ºº 
=
ºº 
points
ºº  
[
ºº  !
i
ºº! "
+
ºº# $
$num
ºº% &
]
ºº& '
-
ºº( )
points
ºº* 0
[
ºº0 1
i
ºº1 2
]
ºº2 3
;
ºº3 4
else
»» 
dir
¼¼ 
=
¼¼ 
points
¼¼  
[
¼¼  !
i
¼¼! "
]
¼¼" #
-
¼¼$ %
points
¼¼& ,
[
¼¼, -
i
¼¼- .
-
¼¼/ 0
$num
¼¼1 2
]
¼¼2 3
;
¼¼3 4
secant
¾¾ 
=
¾¾ 
$num
¾¾ 
;
¾¾ 
}
¿¿ 
dir
ÁÁ 
.
ÁÁ 
	Normalize
ÁÁ 
(
ÁÁ 
)
ÁÁ 
;
ÁÁ 
if
ÃÃ 
(
ÃÃ 
Math
ÃÃ 
.
ÃÃ 
Approx3
ÃÃ 
(
ÃÃ 
dir
ÃÃ  
,
ÃÃ  !
Vector3
ÃÃ" )
.
ÃÃ) *
up
ÃÃ* ,
)
ÃÃ, -
||
ÃÃ. 0
Math
ÃÃ1 5
.
ÃÃ5 6
Approx3
ÃÃ6 =
(
ÃÃ= >
dir
ÃÃ> A
,
ÃÃA B
Vector3
ÃÃC J
.
ÃÃJ K
zero
ÃÃK O
)
ÃÃO P
)
ÃÃP Q
return
ÄÄ 

Quaternion
ÄÄ !
.
ÄÄ! "
identity
ÄÄ" *
;
ÄÄ* +
return
ÆÆ 

Quaternion
ÆÆ 
.
ÆÆ 
LookRotation
ÆÆ *
(
ÆÆ* +
dir
ÆÆ+ .
)
ÆÆ. /
;
ÆÆ/ 0
}
ÇÇ 	
static
ÉÉ 
Vector3
ÉÉ 
[
ÉÉ 
]
ÉÉ 

VertexRing
ÉÉ #
(
ÉÉ# $

Quaternion
ÉÉ$ .
orientation
ÉÉ/ :
,
ÉÉ: ;
Vector3
ÉÉ< C
offset
ÉÉD J
,
ÉÉJ K
float
ÉÉL Q
radius
ÉÉR X
,
ÉÉX Y
int
ÉÉZ ]
segments
ÉÉ^ f
)
ÉÉf g
{
ÊÊ 	
Vector3
ËË 
[
ËË 
]
ËË 
v
ËË 
=
ËË 
new
ËË 
Vector3
ËË %
[
ËË% &
segments
ËË& .
*
ËË/ 0
$num
ËË1 2
]
ËË2 3
;
ËË3 4
for
ÍÍ 
(
ÍÍ 
int
ÍÍ 
i
ÍÍ 
=
ÍÍ 
$num
ÍÍ 
;
ÍÍ 
i
ÍÍ 
<
ÍÍ 
segments
ÍÍ  (
;
ÍÍ( )
i
ÍÍ* +
++
ÍÍ+ -
)
ÍÍ- .
{
ÎÎ 
float
ÏÏ 
rad0
ÏÏ 
=
ÏÏ 
(
ÏÏ 
i
ÏÏ 
/
ÏÏ  !
(
ÏÏ" #
float
ÏÏ# (
)
ÏÏ( )
(
ÏÏ) *
segments
ÏÏ* 2
-
ÏÏ3 4
$num
ÏÏ5 6
)
ÏÏ6 7
)
ÏÏ7 8
*
ÏÏ9 :
$num
ÏÏ; ?
*
ÏÏ@ A
Mathf
ÏÏB G
.
ÏÏG H
Deg2Rad
ÏÏH O
;
ÏÏO P
int
ĞĞ 
n
ĞĞ 
=
ĞĞ 
(
ĞĞ 
i
ĞĞ 
+
ĞĞ 
$num
ĞĞ 
)
ĞĞ 
%
ĞĞ  !
segments
ĞĞ" *
;
ĞĞ* +
float
ÑÑ 
rad1
ÑÑ 
=
ÑÑ 
(
ÑÑ 
n
ÑÑ 
/
ÑÑ  !
(
ÑÑ" #
float
ÑÑ# (
)
ÑÑ( )
(
ÑÑ) *
segments
ÑÑ* 2
-
ÑÑ3 4
$num
ÑÑ5 6
)
ÑÑ6 7
)
ÑÑ7 8
*
ÑÑ9 :
$num
ÑÑ; ?
*
ÑÑ@ A
Mathf
ÑÑB G
.
ÑÑG H
Deg2Rad
ÑÑH O
;
ÑÑO P
v
ÓÓ 
[
ÓÓ 
i
ÓÓ 
*
ÓÓ 
$num
ÓÓ 
]
ÓÓ 
=
ÓÓ 
offset
ÓÓ !
+
ÓÓ" #
(
ÓÓ$ %
orientation
ÓÓ% 0
*
ÓÓ1 2
new
ÓÓ3 6
Vector3
ÓÓ7 >
(
ÓÓ> ?
Mathf
ÓÓ? D
.
ÓÓD E
Cos
ÓÓE H
(
ÓÓH I
rad0
ÓÓI M
)
ÓÓM N
*
ÓÓO P
radius
ÓÓQ W
,
ÓÓW X
Mathf
ÓÓY ^
.
ÓÓ^ _
Sin
ÓÓ_ b
(
ÓÓb c
rad0
ÓÓc g
)
ÓÓg h
*
ÓÓi j
radius
ÓÓk q
,
ÓÓq r
$num
ÓÓs u
)
ÓÓu v
)
ÓÓv w
;
ÓÓw x
v
ÔÔ 
[
ÔÔ 
i
ÔÔ 
*
ÔÔ 
$num
ÔÔ 
+
ÔÔ 
$num
ÔÔ 
]
ÔÔ 
=
ÔÔ 
offset
ÔÔ %
+
ÔÔ& '
(
ÔÔ( )
orientation
ÔÔ) 4
*
ÔÔ5 6
new
ÔÔ7 :
Vector3
ÔÔ; B
(
ÔÔB C
Mathf
ÔÔC H
.
ÔÔH I
Cos
ÔÔI L
(
ÔÔL M
rad1
ÔÔM Q
)
ÔÔQ R
*
ÔÔS T
radius
ÔÔU [
,
ÔÔ[ \
Mathf
ÔÔ] b
.
ÔÔb c
Sin
ÔÔc f
(
ÔÔf g
rad1
ÔÔg k
)
ÔÔk l
*
ÔÔm n
radius
ÔÔo u
,
ÔÔu v
$num
ÔÔw y
)
ÔÔy z
)
ÔÔz {
;
ÔÔ{ |
}
ÕÕ 
return
×× 
v
×× 
;
×× 
}
ØØ 	
}
ÙÙ 
}ÚÚ Û4
ˆD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\IntVec4.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
struct 
IntVec4 
: 
System 
. 

IEquatable #
<# $
IntVec4$ +
>+ ,
{		 
public

 
Vector4

	 
value

 
;

 
public 
float	 
x 
{ 
get 
{ 
return 
value  %
.% &
x& '
;' (
}) *
}+ ,
public 
float	 
y 
{ 
get 
{ 
return 
value  %
.% &
y& '
;' (
}) *
}+ ,
public 
float	 
z 
{ 
get 
{ 
return 
value  %
.% &
z& '
;' (
}) *
}+ ,
public 
float	 
w 
{ 
get 
{ 
return 
value  %
.% &
w& '
;' (
}) *
}+ ,
public 
IntVec4	 
( 
Vector4 
vector 
)  
{ 
this 
. 
value 
= 
vector 
; 
} 
public 
override	 
string 
ToString !
(! "
)" #
{ 
return 	
string
 
. 
Format 
( 
$str :
,: ;
x< =
,= >
y? @
,@ A
zB C
,C D
wE F
)F G
;G H
} 
public 
static	 
bool 
operator 
== 
(  
IntVec4  '
a( )
,) *
IntVec4+ 2
b3 4
)4 5
{ 
return 	
a
 
. 
Equals 
( 
b 
) 
; 
} 
public   
static  	 
bool   
operator   
!=   
(    
IntVec4    '
a  ( )
,  ) *
IntVec4  + 2
b  3 4
)  4 5
{!! 
return"" 	
!""
 
("" 
a"" 
=="" 
b"" 
)"" 
;"" 
}## 
public%% 
bool%%	 
Equals%% 
(%% 
IntVec4%% 
p%% 
)%% 
{&& 
return'' 	
round''
 
('' 
x'' 
)'' 
=='' 
round'' 
('' 
p'' 
.'' 
x'' 
)''  
&&''! #
round(( 	
(((	 

y((
 
)(( 
==(( 
round(( 
((( 
p(( 
.(( 
y(( 
)(( 
&&(( 
round)) 	
())	 

z))
 
))) 
==)) 
round)) 
()) 
p)) 
.)) 
z)) 
))) 
&&)) 
round** 	
(**	 

w**
 
)** 
==** 
round** 
(** 
p** 
.** 
w** 
)** 
;** 
}++ 
public-- 
bool--	 
Equals-- 
(-- 
Vector4-- 
p-- 
)-- 
{.. 
return// 	
round//
 
(// 
x// 
)// 
==// 
round// 
(// 
p// 
.// 
x// 
)//  
&&//! #
round00 	
(00	 

y00
 
)00 
==00 
round00 
(00 
p00 
.00 
y00 
)00 
&&00 
round11 	
(11	 

z11
 
)11 
==11 
round11 
(11 
p11 
.11 
z11 
)11 
&&11 
round22 	
(22	 

w22
 
)22 
==22 
round22 
(22 
p22 
.22 
w22 
)22 
;22 
}33 
public55 
override55	 
bool55 
Equals55 
(55 
System55 $
.55$ %
Object55% +
b55, -
)55- .
{66 
return77 	
(77
 
b77 
is77 
IntVec477 
&&77 
(77 
this77  
.77  !
Equals77! '
(77' (
(77( )
IntVec477) 0
)770 1
b771 2
)772 3
)773 4
)774 5
||776 8
(88 
b88 
is88 	
Vector488
 
&&88 
this88 
.88 
Equals88  
(88  !
(88! "
Vector488" )
)88) *
b88* +
)88+ ,
)88, -
;88- .
}99 
public;; 
override;;	 
int;; 
GetHashCode;; !
(;;! "
);;" #
{<< 
return== 	

VectorHash==
 
.== 
GetHashCode==  
(==  !
value==! &
)==& '
;==' (
}>> 
private@@ 	
static@@
 
int@@ 
round@@ 
(@@ 
float@@  
v@@! "
)@@" #
{AA 
returnBB 	
SystemBB
 
.BB 
ConvertBB 
.BB 
ToInt32BB  
(BB  !
vBB! "
*BB# $

VectorHashBB% /
.BB/ 0 
FltCompareResolutionBB0 D
)BBD E
;BBE F
}CC 
publicEE 
staticEE	 
implicitEE 
operatorEE !
Vector4EE" )
(EE) *
IntVec4EE* 1
pEE2 3
)EE3 4
{FF 
returnGG 	
pGG
 
.GG 
valueGG 
;GG 
}HH 
publicJJ 
staticJJ	 
implicitJJ 
operatorJJ !
IntVec4JJ" )
(JJ) *
Vector4JJ* 1
pJJ2 3
)JJ3 4
{KK 
returnLL 	
newLL
 
IntVec4LL 
(LL 
pLL 
)LL 
;LL 
}MM 
}NN 
}OO Ÿ
‘D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\TriggerBehaviour.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[		 %
DisallowMultipleComponent		 
]		 
sealed

 

class

 
TriggerBehaviour

 !
:

" #
EntityBehaviour

$ 3
{ 
public 
override 
void 

Initialize '
(' (
)( )
{ 	
var 
	collision 
= 

gameObject &
.& '
GetComponent' 3
<3 4
Collider4 <
>< =
(= >
)> ?
;? @
if 
( 
! 
	collision 
) 
	collision 
= 

gameObject &
.& '
AddComponent' 3
<3 4
MeshCollider4 @
>@ A
(A B
)B C
;C D
var 
meshCollider 
= 
	collision (
as) +
MeshCollider, 8
;8 9
if 
( 
meshCollider 
) 
meshCollider 
. 
convex #
=$ %
true& *
;* +
	collision 
. 
	isTrigger 
=  !
true" &
;& '
SetMaterial 
( 
BuiltinMaterials (
.( )
triggerMaterial) 8
)8 9
;9 :
var 
r 
= 
GetComponent  
<  !
Renderer! )
>) *
(* +
)+ ,
;, -
if 
( 
r 
!= 
null 
) 
r 
. 
	hideFlags 
= 
	HideFlags '
.' (
DontSaveInBuild( 7
;7 8
}   	
public"" 
override"" 
void"" 
OnEnterPlayMode"" ,
("", -
)""- .
{## 	
var$$ 
r$$ 
=$$ 
GetComponent$$  
<$$  !
Renderer$$! )
>$$) *
($$* +
)$$+ ,
;$$, -
if&& 
(&& 
r&& 
!=&& 
null&& 
)&& 
r'' 
.'' 
enabled'' 
='' 
false'' !
;''! "
}(( 	
public** 
override** 
void** 
OnSceneLoaded** *
(*** +
Scene**+ 0
scene**1 6
,**6 7
LoadSceneMode**8 E
mode**F J
)**J K
{++ 	
var,, 
r,, 
=,, 
GetComponent,,  
<,,  !
Renderer,,! )
>,,) *
(,,* +
),,+ ,
;,,, -
if.. 
(.. 
r.. 
!=.. 
null.. 
).. 
r// 
.// 
enabled// 
=// 
false// !
;//! "
}00 	
}11 
}22 øô
˜D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SelectionPickerRenderer.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

struct 
PickerOptions 
{ 
public 
bool 
	depthTest 
{ 
get  #
;# $
set% (
;( )
}* +
public 
RectSelectMode 
rectSelectMode ,
{- .
get/ 2
;2 3
set4 7
;7 8
}9 :
static 
readonly 
PickerOptions %
	k_Default& /
=0 1
new2 5
PickerOptions6 C
(C D
)D E
{ 	
	depthTest 
= 
true 
, 
rectSelectMode 
= 
RectSelectMode +
.+ ,
Partial, 3
,3 4
}   	
;  	 

public%% 
static%% 
PickerOptions%% #
Default%%$ +
{&& 	
get'' 
{'' 
return'' 
	k_Default'' "
;''" #
}''$ %
}(( 	
public** 
override** 
bool** 
Equals** #
(**# $
object**$ *
obj**+ .
)**. /
{++ 	
if,, 
(,, 
!,, 
(,, 
obj,, 
is,, 
PickerOptions,, &
),,& '
),,' (
return-- 
false-- 
;-- 
return// 
Equals// 
(// 
(// 
PickerOptions// (
)//( )
obj//) ,
)//, -
;//- .
}00 	
public22 
bool22 
Equals22 
(22 
PickerOptions22 (
other22) .
)22. /
{33 	
return44 
	depthTest44 
==44 
other44  %
.44% &
	depthTest44& /
&&440 2
rectSelectMode443 A
==44B D
other44E J
.44J K
rectSelectMode44K Y
;44Y Z
}55 	
public77 
override77 
int77 
GetHashCode77 '
(77' (
)77( )
{88 	
	unchecked99 
{:: 
return;; 
(;; 
	depthTest;; !
.;;! "
GetHashCode;;" -
(;;- .
);;. /
*;;0 1
$num;;2 5
);;5 6
^;;7 8
(;;9 :
int;;: =
);;= >
rectSelectMode;;> L
;;;L M
}<< 
}== 	
public?? 
static?? 
bool?? 
operator?? #
==??# %
(??% &
PickerOptions??& 3
a??4 5
,??5 6
PickerOptions??7 D
b??E F
)??F G
{@@ 	
returnAA 
aAA 
.AA 
EqualsAA 
(AA 
bAA 
)AA 
;AA 
}BB 	
publicDD 
staticDD 
boolDD 
operatorDD #
!=DD# %
(DD% &
PickerOptionsDD& 3
aDD4 5
,DD5 6
PickerOptionsDD7 D
bDDE F
)DDF G
{EE 	
returnFF 
!FF 
aFF 
.FF 
EqualsFF 
(FF 
bFF 
)FF 
;FF  
}GG 	
}HH 
staticMM 

partialMM 
classMM #
SelectionPickerRendererMM 0
{NN 
internalOO 
	interfaceOO $
ISelectionPickerRendererOO 3
{PP 	
	Texture2DQQ 
RenderLookupTextureQQ )
(QQ) *
CameraQQ* 0
cameraQQ1 7
,QQ7 8
ShaderQQ9 ?
shaderQQ@ F
,QQF G
stringQQH N
tagQQO R
,QQR S
intQQT W
widthQQX ]
,QQ] ^
intQQ_ b
heightQQc i
)QQi j
;QQj k
}RR 	
constTT 
stringTT ,
 k_FacePickerOcclusionTintUniformTT 5
=TT6 7
$strTT8 ?
;TT? @
staticUU 
readonlyUU 
ColorUU 
k_BlackfUU &
=UU' (
newUU) ,
ColorUU- 2
(UU2 3
$numUU3 5
,UU5 6
$numUU7 9
,UU9 :
$numUU; =
,UU= >
$numUU? A
)UUA B
;UUB C
staticVV 
readonlyVV 
ColorVV 
k_WhitefVV &
=VV' (
newVV) ,
ColorVV- 2
(VV2 3
$numVV3 5
,VV5 6
$numVV7 9
,VV9 :
$numVV; =
,VV= >
$numVV? A
)VVA B
;VVB C
constWW 
uintWW 
k_PickerHashNoneWW #
=WW$ %
$numWW& *
;WW* +
constXX 
uintXX 
k_PickerHashMinXX "
=XX# $
$numXX% (
;XX( )
constYY 
uintYY 
k_PickerHashMaxYY "
=YY# $
$numYY% /
;YY/ 0
constZZ 
uintZZ ,
 k_MinEdgePixelsForValidSelectionZZ 3
=ZZ4 5
$numZZ6 7
;ZZ7 8
static\\ 
bool\\ 
s_Initialized\\ !
=\\" #
false\\$ )
;\\) *
static]] $
ISelectionPickerRenderer]] '
s_PickerRenderer]]( 8
=]]9 :
null]]; ?
;]]? @
static__ 
RenderTextureFormat__ "
renderTextureFormat__# 6
{`` 	
getaa 
{bb 
ifcc 
(cc 
s_Initializedcc !
)cc! "
returndd !
s_RenderTextureFormatdd 0
;dd0 1
s_Initializedff 
=ff 
trueff  $
;ff$ %
forhh 
(hh 
inthh 
ihh 
=hh 
$numhh 
;hh 
ihh  !
<hh" #
s_PreferredFormatshh$ 6
.hh6 7
Lengthhh7 =
;hh= >
ihh? @
++hh@ B
)hhB C
{ii 
ifjj 
(jj 

SystemInfojj "
.jj" #'
SupportsRenderTextureFormatjj# >
(jj> ?
s_PreferredFormatsjj? Q
[jjQ R
ijjR S
]jjS T
)jjT U
)jjU V
{kk !
s_RenderTextureFormatll -
=ll. /
s_PreferredFormatsll0 B
[llB C
illC D
]llD E
;llE F
breakmm 
;mm 
}nn 
}oo 
returnqq !
s_RenderTextureFormatqq ,
;qq, -
}rr 
}ss 	
staticuu 
TextureFormatuu 
textureFormatuu *
{uu+ ,
getuu- 0
{uu1 2
returnuu3 9
TextureFormatuu: G
.uuG H
ARGB32uuH N
;uuN O
}uuP Q
}uuR S
staticww 
RenderTextureFormatww "!
s_RenderTextureFormatww# 8
=ww9 :
RenderTextureFormatww; N
.wwN O
DefaultwwO V
;wwV W
staticyy 
RenderTextureFormatyy "
[yy" #
]yy# $
s_PreferredFormatsyy% 7
=yy8 9
newyy: =
RenderTextureFormatyy> Q
[yyQ R
]yyR S
{zz 	
RenderTextureFormat 
.  
ARGB32  &
,& '!
RenderTextureFormat
€€ 
.
€€  
	ARGBFloat
€€  )
,
€€) *
}
‚‚ 	
;
‚‚	 

static
‰‰ &
ISelectionPickerRenderer
‰‰ '
pickerRenderer
‰‰( 6
{
ŠŠ 	
get
‹‹ 
{
ŒŒ 
if
 
(
 
s_PickerRenderer
 $
==
% '
null
( ,
)
, -
s_PickerRenderer
 $
=
% &
ShouldUseHDRP
 %
(
% &
)
& '
?
' (
(
 &
ISelectionPickerRenderer
 1
)
1 2
new
2 5)
SelectionPickerRendererHDRP
6 Q
(
Q R
)
R S
:
‘‘ 
new
‘‘ -
SelectionPickerRendererStandard
‘‘ =
(
‘‘= >
)
‘‘> ?
;
‘‘? @
return
’’ 
s_PickerRenderer
’’ '
;
’’' (
}
““ 
}
”” 	
public
ŸŸ 
static
ŸŸ 

Dictionary
ŸŸ  
<
ŸŸ  !
ProBuilderMesh
ŸŸ! /
,
ŸŸ/ 0
HashSet
ŸŸ1 8
<
ŸŸ8 9
Face
ŸŸ9 =
>
ŸŸ= >
>
ŸŸ> ?
PickFacesInRect
ŸŸ@ O
(
ŸŸO P
Camera
   
camera
   
,
   
Rect
¡¡ 

pickerRect
¡¡ 
,
¡¡ 
IList
¢¢ 
<
¢¢ 
ProBuilderMesh
¢¢  
>
¢¢  !
	selection
¢¢" +
,
¢¢+ ,
int
££  
renderTextureWidth
££ "
=
££# $
-
££% &
$num
££& '
,
££' (
int
¤¤ !
renderTextureHeight
¤¤ #
=
¤¤$ %
-
¤¤& '
$num
¤¤' (
)
¤¤( )
{
¥¥ 	

Dictionary
¦¦ 
<
¦¦ 
uint
¦¦ 
,
¦¦ 
SimpleTuple
¦¦ (
<
¦¦( )
ProBuilderMesh
¦¦) 7
,
¦¦7 8
Face
¦¦9 =
>
¦¦= >
>
¦¦> ?
map
¦¦@ C
;
¦¦C D
	Texture2D
§§ 
tex
§§ 
=
§§ *
RenderSelectionPickerTexture
§§ 8
(
§§8 9
camera
§§9 ?
,
§§? @
	selection
§§A J
,
§§J K
out
§§L O
map
§§P S
,
§§S T 
renderTextureWidth
§§U g
,
§§g h!
renderTextureHeight
§§i |
)
§§| }
;
§§} ~
Color32
©© 
[
©© 
]
©© 
pix
©© 
=
©© 
tex
©© 
.
©©  
GetPixels32
©©  +
(
©©+ ,
)
©©, -
;
©©- .
int
«« 
ox
«« 
=
«« 
System
«« 
.
«« 
Math
««  
.
««  !
Max
««! $
(
««$ %
$num
««% &
,
««& '
Mathf
««( -
.
««- .

FloorToInt
««. 8
(
««8 9

pickerRect
««9 C
.
««C D
x
««D E
)
««E F
)
««F G
;
««G H
int
¬¬ 
oy
¬¬ 
=
¬¬ 
System
¬¬ 
.
¬¬ 
Math
¬¬  
.
¬¬  !
Max
¬¬! $
(
¬¬$ %
$num
¬¬% &
,
¬¬& '
Mathf
¬¬( -
.
¬¬- .

FloorToInt
¬¬. 8
(
¬¬8 9
(
¬¬9 :
tex
¬¬: =
.
¬¬= >
height
¬¬> D
-
¬¬E F

pickerRect
¬¬G Q
.
¬¬Q R
y
¬¬R S
)
¬¬S T
-
¬¬U V

pickerRect
¬¬W a
.
¬¬a b
height
¬¬b h
)
¬¬h i
)
¬¬i j
;
¬¬j k
int
­­ 

imageWidth
­­ 
=
­­ 
tex
­­  
.
­­  !
width
­­! &
;
­­& '
int
®® 
imageHeight
®® 
=
®® 
tex
®® !
.
®®! "
height
®®" (
;
®®( )
int
¯¯ 
width
¯¯ 
=
¯¯ 
Mathf
¯¯ 
.
¯¯ 

FloorToInt
¯¯ (
(
¯¯( )

pickerRect
¯¯) 3
.
¯¯3 4
width
¯¯4 9
)
¯¯9 :
;
¯¯: ;
int
°° 
height
°° 
=
°° 
Mathf
°° 
.
°° 

FloorToInt
°° )
(
°°) *

pickerRect
°°* 4
.
°°4 5
height
°°5 ;
)
°°; <
;
°°< =
UObject
±± 
.
±± 
DestroyImmediate
±± $
(
±±$ %
tex
±±% (
)
±±( )
;
±±) *

Dictionary
³³ 
<
³³ 
ProBuilderMesh
³³ %
,
³³% &
HashSet
³³' .
<
³³. /
Face
³³/ 3
>
³³3 4
>
³³4 5
selected
³³6 >
=
³³? @
new
³³A D

Dictionary
³³E O
<
³³O P
ProBuilderMesh
³³P ^
,
³³^ _
HashSet
³³` g
<
³³g h
Face
³³h l
>
³³l m
>
³³m n
(
³³n o
)
³³o p
;
³³p q
SimpleTuple
´´ 
<
´´ 
ProBuilderMesh
´´ &
,
´´& '
Face
´´( ,
>
´´, -
hit
´´. 1
;
´´1 2
HashSet
µµ 
<
µµ 
Face
µµ 
>
µµ 
faces
µµ 
=
µµ  !
null
µµ" &
;
µµ& '
HashSet
¶¶ 
<
¶¶ 
uint
¶¶ 
>
¶¶ 
used
¶¶ 
=
¶¶  
new
¶¶! $
HashSet
¶¶% ,
<
¶¶, -
uint
¶¶- 1
>
¶¶1 2
(
¶¶2 3
)
¶¶3 4
;
¶¶4 5
for
¼¼ 
(
¼¼ 
int
¼¼ 
y
¼¼ 
=
¼¼ 
oy
¼¼ 
;
¼¼ 
y
¼¼ 
<
¼¼  
System
¼¼! '
.
¼¼' (
Math
¼¼( ,
.
¼¼, -
Min
¼¼- 0
(
¼¼0 1
oy
¼¼1 3
+
¼¼4 5
height
¼¼6 <
,
¼¼< =
imageHeight
¼¼> I
)
¼¼I J
;
¼¼J K
y
¼¼L M
++
¼¼M O
)
¼¼O P
{
½½ 
for
¾¾ 
(
¾¾ 
int
¾¾ 
x
¾¾ 
=
¾¾ 
ox
¾¾ 
;
¾¾  
x
¾¾! "
<
¾¾# $
System
¾¾% +
.
¾¾+ ,
Math
¾¾, 0
.
¾¾0 1
Min
¾¾1 4
(
¾¾4 5
ox
¾¾5 7
+
¾¾8 9
width
¾¾: ?
,
¾¾? @

imageWidth
¾¾A K
)
¾¾K L
;
¾¾L M
x
¾¾N O
++
¾¾O Q
)
¾¾Q R
{
¿¿ 
uint
ÄÄ 
v
ÄÄ 
=
ÄÄ %
SelectionPickerRenderer
ÄÄ 4
.
ÄÄ4 5

DecodeRGBA
ÄÄ5 ?
(
ÄÄ? @
pix
ÄÄ@ C
[
ÄÄC D
y
ÄÄD E
*
ÄÄF G

imageWidth
ÄÄH R
+
ÄÄS T
x
ÄÄU V
]
ÄÄV W
)
ÄÄW X
;
ÄÄX Y
if
ÆÆ 
(
ÆÆ 
used
ÆÆ 
.
ÆÆ 
Add
ÆÆ  
(
ÆÆ  !
v
ÆÆ! "
)
ÆÆ" #
&&
ÆÆ$ &
map
ÆÆ' *
.
ÆÆ* +
TryGetValue
ÆÆ+ 6
(
ÆÆ6 7
v
ÆÆ7 8
,
ÆÆ8 9
out
ÆÆ: =
hit
ÆÆ> A
)
ÆÆA B
)
ÆÆB C
{
ÇÇ 
if
ÈÈ 
(
ÈÈ 
selected
ÈÈ $
.
ÈÈ$ %
TryGetValue
ÈÈ% 0
(
ÈÈ0 1
hit
ÈÈ1 4
.
ÈÈ4 5
item1
ÈÈ5 :
,
ÈÈ: ;
out
ÈÈ< ?
faces
ÈÈ@ E
)
ÈÈE F
)
ÈÈF G
faces
ÉÉ !
.
ÉÉ! "
Add
ÉÉ" %
(
ÉÉ% &
hit
ÉÉ& )
.
ÉÉ) *
item2
ÉÉ* /
)
ÉÉ/ 0
;
ÉÉ0 1
else
ÊÊ 
selected
ËË $
.
ËË$ %
Add
ËË% (
(
ËË( )
hit
ËË) ,
.
ËË, -
item1
ËË- 2
,
ËË2 3
new
ËË4 7
HashSet
ËË8 ?
<
ËË? @
Face
ËË@ D
>
ËËD E
(
ËËE F
)
ËËF G
{
ËËH I
hit
ËËJ M
.
ËËM N
item2
ËËN S
}
ËËT U
)
ËËU V
;
ËËV W
}
ÌÌ 
}
ÍÍ 
}
ÎÎ 
return
àà 
selected
àà 
;
àà 
}
áá 	
public
íí 
static
íí 

Dictionary
íí  
<
íí  !
ProBuilderMesh
íí! /
,
íí/ 0
HashSet
íí1 8
<
íí8 9
int
íí9 <
>
íí< =
>
íí= > 
PickVerticesInRect
íí? Q
(
ííQ R
Camera
îî 
camera
îî 
,
îî 
Rect
ïï 

pickerRect
ïï 
,
ïï 
IList
ğğ 
<
ğğ 
ProBuilderMesh
ğğ  
>
ğğ  !
	selection
ğğ" +
,
ğğ+ ,
bool
ññ 
doDepthTest
ññ 
,
ññ 
int
òò  
renderTextureWidth
òò "
=
òò# $
-
òò% &
$num
òò& '
,
òò' (
int
óó !
renderTextureHeight
óó #
=
óó$ %
-
óó& '
$num
óó' (
)
óó( )
{
ôô 	

Dictionary
õõ 
<
õõ 
uint
õõ 
,
õõ 
SimpleTuple
õõ (
<
õõ( )
ProBuilderMesh
õõ) 7
,
õõ7 8
int
õõ9 <
>
õõ< =
>
õõ= >
map
õõ? B
;
õõB C

Dictionary
öö 
<
öö 
ProBuilderMesh
öö %
,
öö% &
HashSet
öö' .
<
öö. /
int
öö/ 2
>
öö2 3
>
öö3 4
selected
öö5 =
=
öö> ?
new
öö@ C

Dictionary
ööD N
<
ööN O
ProBuilderMesh
ööO ]
,
öö] ^
HashSet
öö_ f
<
ööf g
int
öög j
>
ööj k
>
öök l
(
ööl m
)
ööm n
;
öön o
	Texture2D
üü 
tex
üü 
=
üü *
RenderSelectionPickerTexture
üü 8
(
üü8 9
camera
üü9 ?
,
üü? @
	selection
üüA J
,
üüJ K
doDepthTest
üüL W
,
üüW X
out
üüY \
map
üü] `
,
üü` a 
renderTextureWidth
üüb t
,
üüt u"
renderTextureHeightüüv ‰
)üü‰ Š
;üüŠ ‹
Color32
ıı 
[
ıı 
]
ıı 
pix
ıı 
=
ıı 
tex
ıı 
.
ıı  
GetPixels32
ıı  +
(
ıı+ ,
)
ıı, -
;
ıı- .
int
ÿÿ 
ox
ÿÿ 
=
ÿÿ 
System
ÿÿ 
.
ÿÿ 
Math
ÿÿ  
.
ÿÿ  !
Max
ÿÿ! $
(
ÿÿ$ %
$num
ÿÿ% &
,
ÿÿ& '
Mathf
ÿÿ( -
.
ÿÿ- .

FloorToInt
ÿÿ. 8
(
ÿÿ8 9

pickerRect
ÿÿ9 C
.
ÿÿC D
x
ÿÿD E
)
ÿÿE F
)
ÿÿF G
;
ÿÿG H
int
€€ 
oy
€€ 
=
€€ 
System
€€ 
.
€€ 
Math
€€  
.
€€  !
Max
€€! $
(
€€$ %
$num
€€% &
,
€€& '
Mathf
€€( -
.
€€- .

FloorToInt
€€. 8
(
€€8 9
(
€€9 :
tex
€€: =
.
€€= >
height
€€> D
-
€€E F

pickerRect
€€G Q
.
€€Q R
y
€€R S
)
€€S T
-
€€U V

pickerRect
€€W a
.
€€a b
height
€€b h
)
€€h i
)
€€i j
;
€€j k
int
 

imageWidth
 
=
 
tex
  
.
  !
width
! &
;
& '
int
‚‚ 
imageHeight
‚‚ 
=
‚‚ 
tex
‚‚ !
.
‚‚! "
height
‚‚" (
;
‚‚( )
int
ƒƒ 
width
ƒƒ 
=
ƒƒ 
Mathf
ƒƒ 
.
ƒƒ 

FloorToInt
ƒƒ (
(
ƒƒ( )

pickerRect
ƒƒ) 3
.
ƒƒ3 4
width
ƒƒ4 9
)
ƒƒ9 :
;
ƒƒ: ;
int
„„ 
height
„„ 
=
„„ 
Mathf
„„ 
.
„„ 

FloorToInt
„„ )
(
„„) *

pickerRect
„„* 4
.
„„4 5
height
„„5 ;
)
„„; <
;
„„< =
UObject
†† 
.
†† 
DestroyImmediate
†† $
(
††$ %
tex
††% (
)
††( )
;
††) *
SimpleTuple
ˆˆ 
<
ˆˆ 
ProBuilderMesh
ˆˆ &
,
ˆˆ& '
int
ˆˆ( +
>
ˆˆ+ ,
hit
ˆˆ- 0
;
ˆˆ0 1
HashSet
‰‰ 
<
‰‰ 
int
‰‰ 
>
‰‰ 
indexes
‰‰  
=
‰‰! "
null
‰‰# '
;
‰‰' (
HashSet
ŠŠ 
<
ŠŠ 
uint
ŠŠ 
>
ŠŠ 
used
ŠŠ 
=
ŠŠ  
new
ŠŠ! $
HashSet
ŠŠ% ,
<
ŠŠ, -
uint
ŠŠ- 1
>
ŠŠ1 2
(
ŠŠ2 3
)
ŠŠ3 4
;
ŠŠ4 5
for
ŒŒ 
(
ŒŒ 
int
ŒŒ 
y
ŒŒ 
=
ŒŒ 
oy
ŒŒ 
;
ŒŒ 
y
ŒŒ 
<
ŒŒ  
System
ŒŒ! '
.
ŒŒ' (
Math
ŒŒ( ,
.
ŒŒ, -
Min
ŒŒ- 0
(
ŒŒ0 1
oy
ŒŒ1 3
+
ŒŒ4 5
height
ŒŒ6 <
,
ŒŒ< =
imageHeight
ŒŒ> I
)
ŒŒI J
;
ŒŒJ K
y
ŒŒL M
++
ŒŒM O
)
ŒŒO P
{
 
for
 
(
 
int
 
x
 
=
 
ox
 
;
  
x
! "
<
# $
System
% +
.
+ ,
Math
, 0
.
0 1
Min
1 4
(
4 5
ox
5 7
+
8 9
width
: ?
,
? @

imageWidth
A K
)
K L
;
L M
x
N O
++
O Q
)
Q R
{
 
uint
 
v
 
=
 

DecodeRGBA
 '
(
' (
pix
( +
[
+ ,
y
, -
*
. /

imageWidth
0 :
+
; <
x
= >
]
> ?
)
? @
;
@ A
if
–– 
(
–– 
used
–– 
.
–– 
Add
––  
(
––  !
v
––! "
)
––" #
&&
––$ &
map
––' *
.
––* +
TryGetValue
––+ 6
(
––6 7
v
––7 8
,
––8 9
out
––: =
hit
––> A
)
––A B
)
––B C
{
—— 
if
˜˜ 
(
˜˜ 
selected
˜˜ $
.
˜˜$ %
TryGetValue
˜˜% 0
(
˜˜0 1
hit
˜˜1 4
.
˜˜4 5
item1
˜˜5 :
,
˜˜: ;
out
˜˜< ?
indexes
˜˜@ G
)
˜˜G H
)
˜˜H I
indexes
™™ #
.
™™# $
Add
™™$ '
(
™™' (
hit
™™( +
.
™™+ ,
item2
™™, 1
)
™™1 2
;
™™2 3
else
šš 
selected
›› $
.
››$ %
Add
››% (
(
››( )
hit
››) ,
.
››, -
item1
››- 2
,
››2 3
new
››4 7
HashSet
››8 ?
<
››? @
int
››@ C
>
››C D
(
››D E
)
››E F
{
››G H
hit
››I L
.
››L M
item2
››M R
}
››S T
)
››T U
;
››U V
}
œœ 
}
 
}
 
var
   !
coincidentSelection
   #
=
  $ %
new
  & )

Dictionary
  * 4
<
  4 5
ProBuilderMesh
  5 C
,
  C D
HashSet
  E L
<
  L M
int
  M P
>
  P Q
>
  Q R
(
  R S
)
  S T
;
  T U
foreach
££ 
(
££ 
var
££ 
meshSelection
££ &
in
££' )
selected
££* 2
)
££2 3
{
¤¤ 
var
¥¥ 
	positions
¥¥ 
=
¥¥ 
meshSelection
¥¥  -
.
¥¥- .
Key
¥¥. 1
.
¥¥1 2
positionsInternal
¥¥2 C
;
¥¥C D
var
¦¦ 
sharedVertices
¦¦ "
=
¦¦# $
meshSelection
¦¦% 2
.
¦¦2 3
Key
¦¦3 6
.
¦¦6 7$
sharedVerticesInternal
¦¦7 M
;
¦¦M N
var
§§ 
positionHash
§§  
=
§§! "
new
§§# &
HashSet
§§' .
<
§§. /
int
§§/ 2
>
§§2 3
(
§§3 4
meshSelection
§§4 A
.
§§A B
Value
§§B G
.
§§G H
Select
§§H N
(
§§N O
x
§§O P
=>
§§Q S

VectorHash
§§T ^
.
§§^ _
GetHashCode
§§_ j
(
§§j k
	positions
§§k t
[
§§t u
sharedVertices§§u ƒ
[§§ƒ „
x§§„ …
]§§… †
[§§† ‡
$num§§‡ ˆ
]§§ˆ ‰
]§§‰ Š
)§§Š ‹
)§§‹ Œ
)§§Œ 
;§§ 
var
¨¨ 
	collected
¨¨ 
=
¨¨ 
new
¨¨  #
HashSet
¨¨$ +
<
¨¨+ ,
int
¨¨, /
>
¨¨/ 0
(
¨¨0 1
)
¨¨1 2
;
¨¨2 3
for
ªª 
(
ªª 
int
ªª 
i
ªª 
=
ªª 
$num
ªª 
,
ªª 
c
ªª  !
=
ªª" #
sharedVertices
ªª$ 2
.
ªª2 3
Length
ªª3 9
;
ªª9 :
i
ªª; <
<
ªª= >
c
ªª? @
;
ªª@ A
i
ªªB C
++
ªªC E
)
ªªE F
{
«« 
var
¬¬ 
hash
¬¬ 
=
¬¬ 

VectorHash
¬¬ )
.
¬¬) *
GetHashCode
¬¬* 5
(
¬¬5 6
	positions
¬¬6 ?
[
¬¬? @
sharedVertices
¬¬@ N
[
¬¬N O
i
¬¬O P
]
¬¬P Q
[
¬¬Q R
$num
¬¬R S
]
¬¬S T
]
¬¬T U
)
¬¬U V
;
¬¬V W
if
­­ 
(
­­ 
positionHash
­­ $
.
­­$ %
Contains
­­% -
(
­­- .
hash
­­. 2
)
­­2 3
)
­­3 4
	collected
®® !
.
®®! "
Add
®®" %
(
®®% &
i
®®& '
)
®®' (
;
®®( )
}
¯¯ !
coincidentSelection
±± #
.
±±# $
Add
±±$ '
(
±±' (
meshSelection
±±( 5
.
±±5 6
Key
±±6 9
,
±±9 :
	collected
±±; D
)
±±D E
;
±±E F
}
²² 
selected
³³ 
=
³³ !
coincidentSelection
³³ *
;
³³* +
return
ÃÃ 
selected
ÃÃ 
;
ÃÃ 
}
ÄÄ 	
public
ĞĞ 
static
ĞĞ 

Dictionary
ĞĞ  
<
ĞĞ  !
ProBuilderMesh
ĞĞ! /
,
ĞĞ/ 0
HashSet
ĞĞ1 8
<
ĞĞ8 9
Edge
ĞĞ9 =
>
ĞĞ= >
>
ĞĞ> ?
PickEdgesInRect
ĞĞ@ O
(
ĞĞO P
Camera
ÑÑ 
camera
ÑÑ 
,
ÑÑ 
Rect
ÒÒ 

pickerRect
ÒÒ 
,
ÒÒ 
IList
ÓÓ 
<
ÓÓ 
ProBuilderMesh
ÓÓ  
>
ÓÓ  !
	selection
ÓÓ" +
,
ÓÓ+ ,
bool
ÔÔ 
doDepthTest
ÔÔ 
,
ÔÔ 
int
ÕÕ  
renderTextureWidth
ÕÕ "
=
ÕÕ# $
-
ÕÕ% &
$num
ÕÕ& '
,
ÕÕ' (
int
ÖÖ !
renderTextureHeight
ÖÖ #
=
ÖÖ$ %
-
ÖÖ& '
$num
ÖÖ' (
)
ÖÖ( )
{
×× 	
var
ØØ 
selected
ØØ 
=
ØØ 
new
ØØ 

Dictionary
ØØ )
<
ØØ) *
ProBuilderMesh
ØØ* 8
,
ØØ8 9
HashSet
ØØ: A
<
ØØA B
Edge
ØØB F
>
ØØF G
>
ØØG H
(
ØØH I
)
ØØI J
;
ØØJ K

Dictionary
ŞŞ 
<
ŞŞ 
uint
ŞŞ 
,
ŞŞ 
SimpleTuple
ŞŞ (
<
ŞŞ( )
ProBuilderMesh
ŞŞ) 7
,
ŞŞ7 8
Edge
ŞŞ9 =
>
ŞŞ= >
>
ŞŞ> ?
map
ŞŞ@ C
;
ŞŞC D
	Texture2D
ßß 
tex
ßß 
=
ßß *
RenderSelectionPickerTexture
ßß 8
(
ßß8 9
camera
ßß9 ?
,
ßß? @
	selection
ßßA J
,
ßßJ K
doDepthTest
ßßL W
,
ßßW X
out
ßßY \
map
ßß] `
,
ßß` a 
renderTextureWidth
ßßb t
,
ßßt u"
renderTextureHeightßßv ‰
)ßß‰ Š
;ßßŠ ‹
Color32
àà 
[
àà 
]
àà 
pix
àà 
=
àà 
tex
àà 
.
àà  
GetPixels32
àà  +
(
àà+ ,
)
àà, -
;
àà- .
int
ææ 
ox
ææ 
=
ææ 
System
ææ 
.
ææ 
Math
ææ  
.
ææ  !
Max
ææ! $
(
ææ$ %
$num
ææ% &
,
ææ& '
Mathf
ææ( -
.
ææ- .

FloorToInt
ææ. 8
(
ææ8 9

pickerRect
ææ9 C
.
ææC D
x
ææD E
)
ææE F
)
ææF G
;
ææG H
int
çç 
oy
çç 
=
çç 
System
çç 
.
çç 
Math
çç  
.
çç  !
Max
çç! $
(
çç$ %
$num
çç% &
,
çç& '
Mathf
çç( -
.
çç- .

FloorToInt
çç. 8
(
çç8 9
(
çç9 :
tex
çç: =
.
çç= >
height
çç> D
-
ççE F

pickerRect
ççG Q
.
ççQ R
y
ççR S
)
ççS T
-
ççU V

pickerRect
ççW a
.
çça b
height
ççb h
)
ççh i
)
ççi j
;
ççj k
int
èè 

imageWidth
èè 
=
èè 
tex
èè  
.
èè  !
width
èè! &
;
èè& '
int
éé 
imageHeight
éé 
=
éé 
tex
éé !
.
éé! "
height
éé" (
;
éé( )
int
êê 
width
êê 
=
êê 
Mathf
êê 
.
êê 

FloorToInt
êê (
(
êê( )

pickerRect
êê) 3
.
êê3 4
width
êê4 9
)
êê9 :
;
êê: ;
int
ëë 
height
ëë 
=
ëë 
Mathf
ëë 
.
ëë 

FloorToInt
ëë )
(
ëë) *

pickerRect
ëë* 4
.
ëë4 5
height
ëë5 ;
)
ëë; <
;
ëë< =
UObject
ìì 
.
ìì 
DestroyImmediate
ìì $
(
ìì$ %
tex
ìì% (
)
ìì( )
;
ìì) *
var
îî 

pixelCount
îî 
=
îî 
new
îî  

Dictionary
îî! +
<
îî+ ,
uint
îî, 0
,
îî0 1
uint
îî2 6
>
îî6 7
(
îî7 8
)
îî8 9
;
îî9 :
for
ğğ 
(
ğğ 
int
ğğ 
y
ğğ 
=
ğğ 
oy
ğğ 
;
ğğ 
y
ğğ 
<
ğğ  
System
ğğ! '
.
ğğ' (
Math
ğğ( ,
.
ğğ, -
Min
ğğ- 0
(
ğğ0 1
oy
ğğ1 3
+
ğğ4 5
height
ğğ6 <
,
ğğ< =
imageHeight
ğğ> I
)
ğğI J
;
ğğJ K
y
ğğL M
++
ğğM O
)
ğğO P
{
ññ 
for
òò 
(
òò 
int
òò 
x
òò 
=
òò 
ox
òò 
;
òò  
x
òò! "
<
òò# $
System
òò% +
.
òò+ ,
Math
òò, 0
.
òò0 1
Min
òò1 4
(
òò4 5
ox
òò5 7
+
òò8 9
width
òò: ?
,
òò? @

imageWidth
òòA K
)
òòK L
;
òòL M
x
òòN O
++
òòO Q
)
òòQ R
{
óó 
uint
÷÷ 
v
÷÷ 
=
÷÷ 

DecodeRGBA
÷÷ '
(
÷÷' (
pix
÷÷( +
[
÷÷+ ,
y
÷÷, -
*
÷÷. /

imageWidth
÷÷0 :
+
÷÷; <
x
÷÷= >
]
÷÷> ?
)
÷÷? @
;
÷÷@ A
if
ùù 
(
ùù 
v
ùù 
==
ùù 
k_PickerHashNone
ùù -
||
ùù. 0
v
ùù1 2
==
ùù3 5
k_PickerHashMax
ùù6 E
)
ùùE F
continue
úú  
;
úú  !
if
üü 
(
üü 
!
üü 

pixelCount
üü #
.
üü# $
ContainsKey
üü$ /
(
üü/ 0
v
üü0 1
)
üü1 2
)
üü2 3

pixelCount
ıı "
.
ıı" #
Add
ıı# &
(
ıı& '
v
ıı' (
,
ıı( )
$num
ıı* +
)
ıı+ ,
;
ıı, -
else
şş 

pixelCount
ÿÿ "
[
ÿÿ" #
v
ÿÿ# $
]
ÿÿ$ %
=
ÿÿ& '

pixelCount
ÿÿ( 2
[
ÿÿ2 3
v
ÿÿ3 4
]
ÿÿ4 5
+
ÿÿ6 7
$num
ÿÿ8 9
;
ÿÿ9 :
}
€€ 
}
 
foreach
ƒƒ 
(
ƒƒ 
var
ƒƒ 
kvp
ƒƒ 
in
ƒƒ 

pixelCount
ƒƒ  *
)
ƒƒ* +
{
„„ 
SimpleTuple
…… 
<
…… 
ProBuilderMesh
…… *
,
……* +
Edge
……, 0
>
……0 1
hit
……2 5
;
……5 6
if
‡‡ 
(
‡‡ 
kvp
‡‡ 
.
‡‡ 
Value
‡‡ 
>
‡‡ .
 k_MinEdgePixelsForValidSelection
‡‡  @
&&
‡‡A C
map
‡‡D G
.
‡‡G H
TryGetValue
‡‡H S
(
‡‡S T
kvp
‡‡T W
.
‡‡W X
Key
‡‡X [
,
‡‡[ \
out
‡‡] `
hit
‡‡a d
)
‡‡d e
)
‡‡e f
{
ˆˆ 
HashSet
‰‰ 
<
‰‰ 
Edge
‰‰  
>
‰‰  !
edges
‰‰" '
=
‰‰( )
null
‰‰* .
;
‰‰. /
if
‹‹ 
(
‹‹ 
selected
‹‹  
.
‹‹  !
TryGetValue
‹‹! ,
(
‹‹, -
hit
‹‹- 0
.
‹‹0 1
item1
‹‹1 6
,
‹‹6 7
out
‹‹8 ;
edges
‹‹< A
)
‹‹A B
)
‹‹B C
edges
ŒŒ 
.
ŒŒ 
Add
ŒŒ !
(
ŒŒ! "
hit
ŒŒ" %
.
ŒŒ% &
item2
ŒŒ& +
)
ŒŒ+ ,
;
ŒŒ, -
else
 
selected
  
.
  !
Add
! $
(
$ %
hit
% (
.
( )
item1
) .
,
. /
new
0 3
HashSet
4 ;
<
; <
Edge
< @
>
@ A
(
A B
)
B C
{
D E
hit
E H
.
H I
item2
I N
}
N O
)
O P
;
P Q
}
 
}
 
return
   
selected
   
;
   
}
¡¡ 	
internal
¬¬ 
static
¬¬ 
	Texture2D
¬¬ !*
RenderSelectionPickerTexture
¬¬" >
(
¬¬> ?
Camera
­­ 
camera
­­ 
,
­­ 
IList
®® 
<
®® 
ProBuilderMesh
®®  
>
®®  !
	selection
®®" +
,
®®+ ,
out
¯¯ 

Dictionary
¯¯ 
<
¯¯ 
uint
¯¯ 
,
¯¯  
SimpleTuple
¯¯! ,
<
¯¯, -
ProBuilderMesh
¯¯- ;
,
¯¯; <
Face
¯¯= A
>
¯¯A B
>
¯¯B C
map
¯¯D G
,
¯¯G H
int
°° 
width
°° 
=
°° 
-
°° 
$num
°° 
,
°° 
int
±± 
height
±± 
=
±± 
-
±± 
$num
±± 
)
±± 
{
²² 	
var
³³ 
pickerObjects
³³ 
=
³³ (
GenerateFacePickingObjects
³³  :
(
³³: ;
	selection
³³; D
,
³³D E
out
³³F I
map
³³J M
)
³³M N
;
³³N O
BuiltinMaterials
µµ 
.
µµ  
facePickerMaterial
µµ /
.
µµ/ 0
SetColor
µµ0 8
(
µµ8 9.
 k_FacePickerOcclusionTintUniform
µµ9 Y
,
µµY Z
k_Whitef
µµ[ c
)
µµc d
;
µµd e
	Texture2D
·· 
tex
·· 
=
·· 
pickerRenderer
·· *
.
··* +!
RenderLookupTexture
··+ >
(
··> ?
camera
··? E
,
··E F
BuiltinMaterials
··G W
.
··W X#
selectionPickerShader
··X m
,
··m n
$str··o 
,·· ‚
width··ƒ ˆ
,··ˆ ‰
height··Š 
)·· ‘
;··‘ ’
foreach
¹¹ 
(
¹¹ 

GameObject
¹¹ 
go
¹¹  "
in
¹¹# %
pickerObjects
¹¹& 3
)
¹¹3 4
{
ºº 
UObject
»» 
.
»» 
DestroyImmediate
»» (
(
»»( )
go
»») +
.
»»+ ,
GetComponent
»», 8
<
»»8 9

MeshFilter
»»9 C
>
»»C D
(
»»D E
)
»»E F
.
»»F G

sharedMesh
»»G Q
)
»»Q R
;
»»R S
UObject
¼¼ 
.
¼¼ 
DestroyImmediate
¼¼ (
(
¼¼( )
go
¼¼) +
)
¼¼+ ,
;
¼¼, -
}
½½ 
return
¿¿ 
tex
¿¿ 
;
¿¿ 
}
ÀÀ 	
internal
ÌÌ 
static
ÌÌ 
	Texture2D
ÌÌ !*
RenderSelectionPickerTexture
ÌÌ" >
(
ÌÌ> ?
Camera
ÍÍ 
camera
ÍÍ 
,
ÍÍ 
IList
ÎÎ 
<
ÎÎ 
ProBuilderMesh
ÎÎ  
>
ÎÎ  !
	selection
ÎÎ" +
,
ÎÎ+ ,
bool
ÏÏ 
doDepthTest
ÏÏ 
,
ÏÏ 
out
ĞĞ 

Dictionary
ĞĞ 
<
ĞĞ 
uint
ĞĞ 
,
ĞĞ  
SimpleTuple
ĞĞ! ,
<
ĞĞ, -
ProBuilderMesh
ĞĞ- ;
,
ĞĞ; <
int
ĞĞ= @
>
ĞĞ@ A
>
ĞĞA B
map
ĞĞC F
,
ĞĞF G
int
ÑÑ 
width
ÑÑ 
=
ÑÑ 
-
ÑÑ 
$num
ÑÑ 
,
ÑÑ 
int
ÒÒ 
height
ÒÒ 
=
ÒÒ 
-
ÒÒ 
$num
ÒÒ 
)
ÒÒ 
{
ÓÓ 	

GameObject
ÔÔ 
[
ÔÔ 
]
ÔÔ 
depthObjects
ÔÔ %
,
ÔÔ% &
pickerObjects
ÔÔ' 4
;
ÔÔ4 5*
GenerateVertexPickingObjects
ÖÖ (
(
ÖÖ( )
	selection
ÖÖ) 2
,
ÖÖ2 3
doDepthTest
ÖÖ4 ?
,
ÖÖ? @
out
ÖÖA D
map
ÖÖE H
,
ÖÖH I
out
ÖÖJ M
depthObjects
ÖÖN Z
,
ÖÖZ [
out
ÖÖ\ _
pickerObjects
ÖÖ` m
)
ÖÖm n
;
ÖÖn o
BuiltinMaterials
ØØ 
.
ØØ  
facePickerMaterial
ØØ /
.
ØØ/ 0
SetColor
ØØ0 8
(
ØØ8 9.
 k_FacePickerOcclusionTintUniform
ØØ9 Y
,
ØØY Z
k_Blackf
ØØ[ c
)
ØØc d
;
ØØd e
	Texture2D
ÚÚ 
tex
ÚÚ 
=
ÚÚ 
pickerRenderer
ÚÚ *
.
ÚÚ* +!
RenderLookupTexture
ÚÚ+ >
(
ÚÚ> ?
camera
ÚÚ? E
,
ÚÚE F
BuiltinMaterials
ÚÚG W
.
ÚÚW X#
selectionPickerShader
ÚÚX m
,
ÚÚm n
$strÚÚo 
,ÚÚ ‚
widthÚÚƒ ˆ
,ÚÚˆ ‰
heightÚÚŠ 
)ÚÚ ‘
;ÚÚ‘ ’
for
ÜÜ 
(
ÜÜ 
int
ÜÜ 
i
ÜÜ 
=
ÜÜ 
$num
ÜÜ 
,
ÜÜ 
c
ÜÜ 
=
ÜÜ 
pickerObjects
ÜÜ  -
.
ÜÜ- .
Length
ÜÜ. 4
;
ÜÜ4 5
i
ÜÜ6 7
<
ÜÜ8 9
c
ÜÜ: ;
;
ÜÜ; <
i
ÜÜ= >
++
ÜÜ> @
)
ÜÜ@ A
{
İİ 
UObject
ŞŞ 
.
ŞŞ 
DestroyImmediate
ŞŞ (
(
ŞŞ( )
pickerObjects
ŞŞ) 6
[
ŞŞ6 7
i
ŞŞ7 8
]
ŞŞ8 9
.
ŞŞ9 :
GetComponent
ŞŞ: F
<
ŞŞF G

MeshFilter
ŞŞG Q
>
ŞŞQ R
(
ŞŞR S
)
ŞŞS T
.
ŞŞT U

sharedMesh
ŞŞU _
)
ŞŞ_ `
;
ŞŞ` a
UObject
ßß 
.
ßß 
DestroyImmediate
ßß (
(
ßß( )
pickerObjects
ßß) 6
[
ßß6 7
i
ßß7 8
]
ßß8 9
)
ßß9 :
;
ßß: ;
}
àà 
if
ââ 
(
ââ 
doDepthTest
ââ 
)
ââ 
{
ãã 
for
ää 
(
ää 
int
ää 
i
ää 
=
ää 
$num
ää 
,
ää 
c
ää  !
=
ää" #
depthObjects
ää$ 0
.
ää0 1
Length
ää1 7
;
ää7 8
i
ää9 :
<
ää; <
c
ää= >
;
ää> ?
i
ää@ A
++
ääA C
)
ääC D
{
åå 
UObject
ææ 
.
ææ 
DestroyImmediate
ææ ,
(
ææ, -
depthObjects
ææ- 9
[
ææ9 :
i
ææ: ;
]
ææ; <
)
ææ< =
;
ææ= >
}
çç 
}
èè 
return
êê 
tex
êê 
;
êê 
}
ëë 	
internal
÷÷ 
static
÷÷ 
	Texture2D
÷÷ !*
RenderSelectionPickerTexture
÷÷" >
(
÷÷> ?
Camera
øø 
camera
øø 
,
øø 
IList
ùù 
<
ùù 
ProBuilderMesh
ùù  
>
ùù  !
	selection
ùù" +
,
ùù+ ,
bool
úú 
doDepthTest
úú 
,
úú 
out
ûû 

Dictionary
ûû 
<
ûû 
uint
ûû 
,
ûû  
SimpleTuple
ûû! ,
<
ûû, -
ProBuilderMesh
ûû- ;
,
ûû; <
Edge
ûû= A
>
ûûA B
>
ûûB C
map
ûûD G
,
ûûG H
int
üü 
width
üü 
=
üü 
-
üü 
$num
üü 
,
üü 
int
ıı 
height
ıı 
=
ıı 
-
ıı 
$num
ıı 
)
ıı 
{
şş 	

GameObject
ÿÿ 
[
ÿÿ 
]
ÿÿ 
depthObjects
ÿÿ %
,
ÿÿ% &
pickerObjects
ÿÿ' 4
;
ÿÿ4 5(
GenerateEdgePickingObjects
€€ &
(
€€& '
	selection
€€' 0
,
€€0 1
doDepthTest
€€2 =
,
€€= >
out
€€? B
map
€€C F
,
€€F G
out
€€H K
depthObjects
€€L X
,
€€X Y
out
€€Z ]
pickerObjects
€€^ k
)
€€k l
;
€€l m
BuiltinMaterials
‚‚ 
.
‚‚  
facePickerMaterial
‚‚ /
.
‚‚/ 0
SetColor
‚‚0 8
(
‚‚8 9.
 k_FacePickerOcclusionTintUniform
‚‚9 Y
,
‚‚Y Z
k_Blackf
‚‚[ c
)
‚‚c d
;
‚‚d e
	Texture2D
„„ 
tex
„„ 
=
„„ 
pickerRenderer
„„ *
.
„„* +!
RenderLookupTexture
„„+ >
(
„„> ?
camera
„„? E
,
„„E F
BuiltinMaterials
„„G W
.
„„W X#
selectionPickerShader
„„X m
,
„„m n
$str„„o 
,„„ ‚
width„„ƒ ˆ
,„„ˆ ‰
height„„Š 
)„„ ‘
;„„‘ ’
for
†† 
(
†† 
int
†† 
i
†† 
=
†† 
$num
†† 
,
†† 
c
†† 
=
†† 
pickerObjects
††  -
.
††- .
Length
††. 4
;
††4 5
i
††6 7
<
††8 9
c
††: ;
;
††; <
i
††= >
++
††> @
)
††@ A
{
‡‡ 
UObject
ˆˆ 
.
ˆˆ 
DestroyImmediate
ˆˆ (
(
ˆˆ( )
pickerObjects
ˆˆ) 6
[
ˆˆ6 7
i
ˆˆ7 8
]
ˆˆ8 9
.
ˆˆ9 :
GetComponent
ˆˆ: F
<
ˆˆF G

MeshFilter
ˆˆG Q
>
ˆˆQ R
(
ˆˆR S
)
ˆˆS T
.
ˆˆT U

sharedMesh
ˆˆU _
)
ˆˆ_ `
;
ˆˆ` a
UObject
‰‰ 
.
‰‰ 
DestroyImmediate
‰‰ (
(
‰‰( )
pickerObjects
‰‰) 6
[
‰‰6 7
i
‰‰7 8
]
‰‰8 9
)
‰‰9 :
;
‰‰: ;
}
ŠŠ 
if
ŒŒ 
(
ŒŒ 
doDepthTest
ŒŒ 
)
ŒŒ 
{
 
for
 
(
 
int
 
i
 
=
 
$num
 
,
 
c
  !
=
" #
depthObjects
$ 0
.
0 1
Length
1 7
;
7 8
i
9 :
<
; <
c
= >
;
> ?
i
@ A
++
A C
)
C D
{
 
UObject
 
.
 
DestroyImmediate
 ,
(
, -
depthObjects
- 9
[
9 :
i
: ;
]
; <
)
< =
;
= >
}
‘‘ 
}
’’ 
return
““ 
tex
““ 
;
““ 
}
”” 	
static
–– 

GameObject
–– 
[
–– 
]
–– (
GenerateFacePickingObjects
–– 6
(
––6 7
IList
—— 
<
—— 
ProBuilderMesh
——  
>
——  !
	selection
——" +
,
——+ ,
out
˜˜ 

Dictionary
˜˜ 
<
˜˜ 
uint
˜˜ 
,
˜˜  
SimpleTuple
˜˜! ,
<
˜˜, -
ProBuilderMesh
˜˜- ;
,
˜˜; <
Face
˜˜= A
>
˜˜A B
>
˜˜B C
map
˜˜D G
)
˜˜G H
{
™™ 	
int
šš 
selectionCount
šš 
=
šš  
	selection
šš! *
.
šš* +
Count
šš+ 0
;
šš0 1

GameObject
›› 
[
›› 
]
›› 
pickerObjects
›› &
=
››' (
new
››) ,

GameObject
››- 7
[
››7 8
selectionCount
››8 F
]
››F G
;
››G H
map
œœ 
=
œœ 
new
œœ 

Dictionary
œœ  
<
œœ  !
uint
œœ! %
,
œœ% &
SimpleTuple
œœ' 2
<
œœ2 3
ProBuilderMesh
œœ3 A
,
œœA B
Face
œœC G
>
œœG H
>
œœH I
(
œœI J
)
œœJ K
;
œœK L
uint
 
index
 
=
 
$num
 
;
 
for
   
(
   
int
   
i
   
=
   
$num
   
;
   
i
   
<
   
selectionCount
    .
;
  . /
i
  0 1
++
  1 3
)
  3 4
{
¡¡ 
var
¢¢ 
pb
¢¢ 
=
¢¢ 
	selection
¢¢ "
[
¢¢" #
i
¢¢# $
]
¢¢$ %
;
¢¢% &

GameObject
¤¤ 
go
¤¤ 
=
¤¤ 
InternalUtility
¤¤  /
.
¤¤/ 0*
EmptyGameObjectWithTransform
¤¤0 L
(
¤¤L M
pb
¤¤M O
.
¤¤O P
	transform
¤¤P Y
)
¤¤Y Z
;
¤¤Z [
go
¥¥ 
.
¥¥ 
name
¥¥ 
=
¥¥ 
pb
¥¥ 
.
¥¥ 
name
¥¥ !
+
¥¥" #
$str
¥¥$ 8
;
¥¥8 9
Mesh
§§ 
m
§§ 
=
§§ 
new
§§ 
Mesh
§§ !
(
§§! "
)
§§" #
;
§§# $
m
¨¨ 
.
¨¨ 
vertices
¨¨ 
=
¨¨ 
pb
¨¨ 
.
¨¨  
positionsInternal
¨¨  1
;
¨¨1 2
m
©© 
.
©© 
	triangles
©© 
=
©© 
pb
©©  
.
©©  !
facesInternal
©©! .
.
©©. /

SelectMany
©©/ 9
(
©©9 :
x
©©: ;
=>
©©< >
x
©©? @
.
©©@ A
indexesInternal
©©A P
)
©©P Q
.
©©Q R
ToArray
©©R Y
(
©©Y Z
)
©©Z [
;
©©[ \
Color32
ªª 
[
ªª 
]
ªª 
colors
ªª  
=
ªª! "
new
ªª# &
Color32
ªª' .
[
ªª. /
m
ªª/ 0
.
ªª0 1
vertexCount
ªª1 <
]
ªª< =
;
ªª= >
foreach
¬¬ 
(
¬¬ 
Face
¬¬ 
f
¬¬ 
in
¬¬  "
pb
¬¬# %
.
¬¬% &
facesInternal
¬¬& 3
)
¬¬3 4
{
­­ 
Color32
®® 
color
®® !
=
®®" #

EncodeRGBA
®®$ .
(
®®. /
index
®®/ 4
++
®®4 6
)
®®6 7
;
®®7 8
map
¯¯ 
.
¯¯ 
Add
¯¯ 
(
¯¯ 

DecodeRGBA
¯¯ &
(
¯¯& '
color
¯¯' ,
)
¯¯, -
,
¯¯- .
new
¯¯/ 2
SimpleTuple
¯¯3 >
<
¯¯> ?
ProBuilderMesh
¯¯? M
,
¯¯M N
Face
¯¯O S
>
¯¯S T
(
¯¯T U
pb
¯¯U W
,
¯¯W X
f
¯¯Y Z
)
¯¯Z [
)
¯¯[ \
;
¯¯\ ]
for
±± 
(
±± 
int
±± 
n
±± 
=
±±  
$num
±±! "
;
±±" #
n
±±$ %
<
±±& '
f
±±( )
.
±±) *%
distinctIndexesInternal
±±* A
.
±±A B
Length
±±B H
;
±±H I
n
±±J K
++
±±K M
)
±±M N
colors
²² 
[
²² 
f
²²  
.
²²  !%
distinctIndexesInternal
²²! 8
[
²²8 9
n
²²9 :
]
²²: ;
]
²²; <
=
²²= >
color
²²? D
;
²²D E
}
³³ 
m
µµ 
.
µµ 
colors32
µµ 
=
µµ 
colors
µµ #
;
µµ# $
go
·· 
.
·· 
AddComponent
·· 
<
··  

MeshFilter
··  *
>
··* +
(
··+ ,
)
··, -
.
··- .

sharedMesh
··. 8
=
··9 :
m
··; <
;
··< =
go
¸¸ 
.
¸¸ 
AddComponent
¸¸ 
<
¸¸  
MeshRenderer
¸¸  ,
>
¸¸, -
(
¸¸- .
)
¸¸. /
.
¸¸/ 0
sharedMaterial
¸¸0 >
=
¸¸? @
BuiltinMaterials
¸¸A Q
.
¸¸Q R 
facePickerMaterial
¸¸R d
;
¸¸d e
pickerObjects
ºº 
[
ºº 
i
ºº 
]
ºº  
=
ºº! "
go
ºº# %
;
ºº% &
}
»» 
return
½½ 
pickerObjects
½½  
;
½½  !
}
¾¾ 	
static
ÀÀ 
void
ÀÀ *
GenerateVertexPickingObjects
ÀÀ 0
(
ÀÀ0 1
IList
ÁÁ 
<
ÁÁ 
ProBuilderMesh
ÁÁ  
>
ÁÁ  !
	selection
ÁÁ" +
,
ÁÁ+ ,
bool
ÂÂ 
doDepthTest
ÂÂ 
,
ÂÂ 
out
ÃÃ 

Dictionary
ÃÃ 
<
ÃÃ 
uint
ÃÃ 
,
ÃÃ  
SimpleTuple
ÃÃ! ,
<
ÃÃ, -
ProBuilderMesh
ÃÃ- ;
,
ÃÃ; <
int
ÃÃ= @
>
ÃÃ@ A
>
ÃÃA B
map
ÃÃC F
,
ÃÃF G
out
ÄÄ 

GameObject
ÄÄ 
[
ÄÄ 
]
ÄÄ 
depthObjects
ÄÄ )
,
ÄÄ) *
out
ÅÅ 

GameObject
ÅÅ 
[
ÅÅ 
]
ÅÅ 
pickerObjects
ÅÅ *
)
ÅÅ* +
{
ÆÆ 	
map
ÇÇ 
=
ÇÇ 
new
ÇÇ 

Dictionary
ÇÇ  
<
ÇÇ  !
uint
ÇÇ! %
,
ÇÇ% &
SimpleTuple
ÇÇ' 2
<
ÇÇ2 3
ProBuilderMesh
ÇÇ3 A
,
ÇÇA B
int
ÇÇC F
>
ÇÇF G
>
ÇÇG H
(
ÇÇH I
)
ÇÇI J
;
ÇÇJ K
uint
ËË 
index
ËË 
=
ËË 
$num
ËË 
;
ËË 
int
ÌÌ 
selectionCount
ÌÌ 
=
ÌÌ  
	selection
ÌÌ! *
.
ÌÌ* +
Count
ÌÌ+ 0
;
ÌÌ0 1
pickerObjects
ÍÍ 
=
ÍÍ 
new
ÍÍ 

GameObject
ÍÍ  *
[
ÍÍ* +
selectionCount
ÍÍ+ 9
]
ÍÍ9 :
;
ÍÍ: ;
for
ÏÏ 
(
ÏÏ 
int
ÏÏ 
i
ÏÏ 
=
ÏÏ 
$num
ÏÏ 
;
ÏÏ 
i
ÏÏ 
<
ÏÏ 
selectionCount
ÏÏ  .
;
ÏÏ. /
i
ÏÏ0 1
++
ÏÏ1 3
)
ÏÏ3 4
{
ĞĞ 
var
ÒÒ 
pb
ÒÒ 
=
ÒÒ 
	selection
ÒÒ "
[
ÒÒ" #
i
ÒÒ# $
]
ÒÒ$ %
;
ÒÒ% &

GameObject
ÓÓ 
go
ÓÓ 
=
ÓÓ 
InternalUtility
ÓÓ  /
.
ÓÓ/ 0*
EmptyGameObjectWithTransform
ÓÓ0 L
(
ÓÓL M
pb
ÓÓM O
.
ÓÓO P
	transform
ÓÓP Y
)
ÓÓY Z
;
ÓÓZ [
go
ÔÔ 
.
ÔÔ 
name
ÔÔ 
=
ÔÔ 
pb
ÔÔ 
.
ÔÔ 
name
ÔÔ !
+
ÔÔ" #
$str
ÔÔ$ ;
;
ÔÔ; <
go
ÕÕ 
.
ÕÕ 
AddComponent
ÕÕ 
<
ÕÕ  

MeshFilter
ÕÕ  *
>
ÕÕ* +
(
ÕÕ+ ,
)
ÕÕ, -
.
ÕÕ- .

sharedMesh
ÕÕ. 8
=
ÕÕ9 :
BuildVertexMesh
ÕÕ; J
(
ÕÕJ K
pb
ÕÕK M
,
ÕÕM N
map
ÕÕO R
,
ÕÕR S
ref
ÕÕT W
index
ÕÕX ]
)
ÕÕ] ^
;
ÕÕ^ _
go
ÖÖ 
.
ÖÖ 
AddComponent
ÖÖ 
<
ÖÖ  
MeshRenderer
ÖÖ  ,
>
ÖÖ, -
(
ÖÖ- .
)
ÖÖ. /
.
ÖÖ/ 0
sharedMaterial
ÖÖ0 >
=
ÖÖ? @
BuiltinMaterials
ÖÖA Q
.
ÖÖQ R"
vertexPickerMaterial
ÖÖR f
;
ÖÖf g
pickerObjects
×× 
[
×× 
i
×× 
]
××  
=
××! "
go
××# %
;
××% &
}
ØØ 
if
ÚÚ 
(
ÚÚ 
doDepthTest
ÚÚ 
)
ÚÚ 
{
ÛÛ 
depthObjects
ÜÜ 
=
ÜÜ 
new
ÜÜ "

GameObject
ÜÜ# -
[
ÜÜ- .
selectionCount
ÜÜ. <
]
ÜÜ< =
;
ÜÜ= >
for
ßß 
(
ßß 
int
ßß 
i
ßß 
=
ßß 
$num
ßß 
;
ßß 
i
ßß  !
<
ßß" #
selectionCount
ßß$ 2
;
ßß2 3
i
ßß4 5
++
ßß5 7
)
ßß7 8
{
àà 
var
áá 
pb
áá 
=
áá 
	selection
áá &
[
áá& '
i
áá' (
]
áá( )
;
áá) *

GameObject
ââ 
go
ââ !
=
ââ" #
InternalUtility
ââ$ 3
.
ââ3 4*
EmptyGameObjectWithTransform
ââ4 P
(
ââP Q
pb
ââQ S
.
ââS T
	transform
ââT ]
)
ââ] ^
;
ââ^ _
go
ãã 
.
ãã 
name
ãã 
=
ãã 
pb
ãã  
.
ãã  !
name
ãã! %
+
ãã& '
$str
ãã( 8
;
ãã8 9
go
ää 
.
ää 
AddComponent
ää #
<
ää# $

MeshFilter
ää$ .
>
ää. /
(
ää/ 0
)
ää0 1
.
ää1 2

sharedMesh
ää2 <
=
ää= >
pb
ää? A
.
ääA B
mesh
ääB F
;
ääF G
go
åå 
.
åå 
AddComponent
åå #
<
åå# $
MeshRenderer
åå$ 0
>
åå0 1
(
åå1 2
)
åå2 3
.
åå3 4
sharedMaterial
åå4 B
=
ååC D
BuiltinMaterials
ååE U
.
ååU V 
facePickerMaterial
ååV h
;
ååh i
depthObjects
ææ  
[
ææ  !
i
ææ! "
]
ææ" #
=
ææ$ %
go
ææ& (
;
ææ( )
}
çç 
}
èè 
else
éé 
{
êê 
depthObjects
ëë 
=
ëë 
null
ëë #
;
ëë# $
}
ìì 
}
íí 	
static
ïï 
void
ïï (
GenerateEdgePickingObjects
ïï .
(
ïï. /
IList
ğğ 
<
ğğ 
ProBuilderMesh
ğğ  
>
ğğ  !
	selection
ğğ" +
,
ğğ+ ,
bool
ññ 
doDepthTest
ññ 
,
ññ 
out
òò 

Dictionary
òò 
<
òò 
uint
òò 
,
òò  
SimpleTuple
òò! ,
<
òò, -
ProBuilderMesh
òò- ;
,
òò; <
Edge
òò= A
>
òòA B
>
òòB C
map
òòD G
,
òòG H
out
óó 

GameObject
óó 
[
óó 
]
óó 
depthObjects
óó )
,
óó) *
out
ôô 

GameObject
ôô 
[
ôô 
]
ôô 
pickerObjects
ôô *
)
ôô* +
{
õõ 	
map
öö 
=
öö 
new
öö 

Dictionary
öö  
<
öö  !
uint
öö! %
,
öö% &
SimpleTuple
öö' 2
<
öö2 3
ProBuilderMesh
öö3 A
,
ööA B
Edge
ööC G
>
ööG H
>
ööH I
(
ööI J
)
ööJ K
;
ööK L
uint
øø 
index
øø 
=
øø 
$num
øø 
;
øø 
int
ùù 
selectionCount
ùù 
=
ùù  
	selection
ùù! *
.
ùù* +
Count
ùù+ 0
;
ùù0 1
pickerObjects
úú 
=
úú 
new
úú 

GameObject
úú  *
[
úú* +
selectionCount
úú+ 9
]
úú9 :
;
úú: ;
for
üü 
(
üü 
int
üü 
i
üü 
=
üü 
$num
üü 
;
üü 
i
üü 
<
üü 
selectionCount
üü  .
;
üü. /
i
üü0 1
++
üü1 3
)
üü3 4
{
ıı 
var
ÿÿ 
pb
ÿÿ 
=
ÿÿ 
	selection
ÿÿ "
[
ÿÿ" #
i
ÿÿ# $
]
ÿÿ$ %
;
ÿÿ% &

GameObject
€€ 
go
€€ 
=
€€ 
InternalUtility
€€  /
.
€€/ 0*
EmptyGameObjectWithTransform
€€0 L
(
€€L M
pb
€€M O
.
€€O P
	transform
€€P Y
)
€€Y Z
;
€€Z [
go
 
.
 
name
 
=
 
pb
 
.
 
name
 !
+
" #
$str
$ 9
;
9 :
go
‚‚ 
.
‚‚ 
AddComponent
‚‚ 
<
‚‚  

MeshFilter
‚‚  *
>
‚‚* +
(
‚‚+ ,
)
‚‚, -
.
‚‚- .

sharedMesh
‚‚. 8
=
‚‚9 :
BuildEdgeMesh
‚‚; H
(
‚‚H I
pb
‚‚I K
,
‚‚K L
map
‚‚M P
,
‚‚P Q
ref
‚‚R U
index
‚‚V [
)
‚‚[ \
;
‚‚\ ]
go
ƒƒ 
.
ƒƒ 
AddComponent
ƒƒ 
<
ƒƒ  
MeshRenderer
ƒƒ  ,
>
ƒƒ, -
(
ƒƒ- .
)
ƒƒ. /
.
ƒƒ/ 0
sharedMaterial
ƒƒ0 >
=
ƒƒ? @
BuiltinMaterials
ƒƒA Q
.
ƒƒQ R 
edgePickerMaterial
ƒƒR d
;
ƒƒd e
pickerObjects
„„ 
[
„„ 
i
„„ 
]
„„  
=
„„! "
go
„„# %
;
„„% &
}
…… 
if
‡‡ 
(
‡‡ 
doDepthTest
‡‡ 
)
‡‡ 
{
ˆˆ 
depthObjects
‰‰ 
=
‰‰ 
new
‰‰ "

GameObject
‰‰# -
[
‰‰- .
selectionCount
‰‰. <
]
‰‰< =
;
‰‰= >
for
‹‹ 
(
‹‹ 
int
‹‹ 
i
‹‹ 
=
‹‹ 
$num
‹‹ 
;
‹‹ 
i
‹‹  !
<
‹‹" #
selectionCount
‹‹$ 2
;
‹‹2 3
i
‹‹4 5
++
‹‹5 7
)
‹‹7 8
{
ŒŒ 
var
 
pb
 
=
 
	selection
 &
[
& '
i
' (
]
( )
;
) *

GameObject
 
go
 !
=
" #
InternalUtility
$ 3
.
3 4*
EmptyGameObjectWithTransform
4 P
(
P Q
pb
Q S
.
S T
	transform
T ]
)
] ^
;
^ _
go
 
.
 
name
 
=
 
pb
  
.
  !
name
! %
+
& '
$str
( 8
;
8 9
go
‘‘ 
.
‘‘ 
AddComponent
‘‘ #
<
‘‘# $

MeshFilter
‘‘$ .
>
‘‘. /
(
‘‘/ 0
)
‘‘0 1
.
‘‘1 2

sharedMesh
‘‘2 <
=
‘‘= >
pb
‘‘? A
.
‘‘A B
mesh
‘‘B F
;
‘‘F G
go
’’ 
.
’’ 
AddComponent
’’ #
<
’’# $
MeshRenderer
’’$ 0
>
’’0 1
(
’’1 2
)
’’2 3
.
’’3 4
sharedMaterial
’’4 B
=
’’C D
BuiltinMaterials
’’E U
.
’’U V 
facePickerMaterial
’’V h
;
’’h i
depthObjects
““  
[
““  !
i
““! "
]
““" #
=
““$ %
go
““& (
;
““( )
}
”” 
}
•• 
else
–– 
{
—— 
depthObjects
˜˜ 
=
˜˜ 
null
˜˜ #
;
˜˜# $
}
™™ 
}
šš 	
static
œœ 
Mesh
œœ 
BuildVertexMesh
œœ #
(
œœ# $
ProBuilderMesh
œœ$ 2
pb
œœ3 5
,
œœ5 6

Dictionary
œœ7 A
<
œœA B
uint
œœB F
,
œœF G
SimpleTuple
œœH S
<
œœS T
ProBuilderMesh
œœT b
,
œœb c
int
œœd g
>
œœg h
>
œœh i
map
œœj m
,
œœm n
ref
œœo r
uint
œœs w
index
œœx }
)
œœ} ~
{
 	
int
 
length
 
=
 
System
 
.
  
Math
  $
.
$ %
Min
% (
(
( )
pb
) +
.
+ ,$
sharedVerticesInternal
, B
.
B C
Length
C I
,
I J
ushort
K Q
.
Q R
MaxValue
R Z
/
[ \
$num
] ^
-
_ `
$num
a b
)
b c
;
c d
Vector3
   
[
   
]
   
t_billboards
   $
=
  , -
new
  . 1
Vector3
  2 9
[
  9 :
length
  : @
*
  A B
$num
  C D
]
  D E
;
  E F
Vector2
¡¡ 
[
¡¡ 
]
¡¡ 
t_uvs
¡¡ 
=
¡¡, -
new
¡¡. 1
Vector2
¡¡2 9
[
¡¡9 :
length
¡¡: @
*
¡¡A B
$num
¡¡C D
]
¡¡D E
;
¡¡E F
Vector2
¢¢ 
[
¢¢ 
]
¢¢ 
t_uv2
¢¢ 
=
¢¢, -
new
¢¢. 1
Vector2
¢¢2 9
[
¢¢9 :
length
¢¢: @
*
¢¢A B
$num
¢¢C D
]
¢¢D E
;
¢¢E F
Color
££ 
[
££ 
]
££ 
t_col
££ 
=
££, -
new
££. 1
Color
££2 7
[
££7 8
length
££8 >
*
££? @
$num
££A B
]
££B C
;
££C D
int
¤¤ 
[
¤¤ 
]
¤¤ 
t_tris
¤¤ 
=
¤¤, -
new
¤¤. 1
int
¤¤2 5
[
¤¤5 6
length
¤¤6 <
*
¤¤= >
$num
¤¤? @
]
¤¤@ A
;
¤¤A B
int
¦¦ 
n
¦¦ 
=
¦¦ 
$num
¦¦ 
;
¦¦ 
int
§§ 
t
§§ 
=
§§ 
$num
§§ 
;
§§ 
Vector3
©© 
up
©© 
=
©© 
Vector3
©©  
.
©©  !
up
©©! #
;
©©# $
Vector3
ªª 
right
ªª 
=
ªª 
Vector3
ªª #
.
ªª# $
right
ªª$ )
;
ªª) *
for
¬¬ 
(
¬¬ 
int
¬¬ 
i
¬¬ 
=
¬¬ 
$num
¬¬ 
;
¬¬ 
i
¬¬ 
<
¬¬ 
length
¬¬  &
;
¬¬& '
i
¬¬( )
++
¬¬) +
)
¬¬+ ,
{
­­ 
Vector3
®® 
v
®® 
=
®® 
pb
®® 
.
®® 
positionsInternal
®® 0
[
®®0 1
pb
®®1 3
.
®®3 4$
sharedVerticesInternal
®®4 J
[
®®J K
i
®®K L
]
®®L M
[
®®M N
$num
®®N O
]
®®O P
]
®®P Q
;
®®Q R
t_billboards
°° 
[
°° 
t
°° 
+
°°  
$num
°°! "
]
°°" #
=
°°$ %
v
°°& '
;
°°' (
t_billboards
±± 
[
±± 
t
±± 
+
±±  
$num
±±! "
]
±±" #
=
±±$ %
v
±±& '
;
±±' (
t_billboards
²² 
[
²² 
t
²² 
+
²²  
$num
²²! "
]
²²" #
=
²²$ %
v
²²& '
;
²²' (
t_billboards
³³ 
[
³³ 
t
³³ 
+
³³  
$num
³³! "
]
³³" #
=
³³$ %
v
³³& '
;
³³' (
t_uvs
µµ 
[
µµ 
t
µµ 
+
µµ 
$num
µµ 
]
µµ 
=
µµ 
Vector3
µµ &
.
µµ& '
zero
µµ' +
;
µµ+ ,
t_uvs
¶¶ 
[
¶¶ 
t
¶¶ 
+
¶¶ 
$num
¶¶ 
]
¶¶ 
=
¶¶ 
Vector3
¶¶ &
.
¶¶& '
right
¶¶' ,
;
¶¶, -
t_uvs
·· 
[
·· 
t
·· 
+
·· 
$num
·· 
]
·· 
=
·· 
Vector3
·· &
.
··& '
up
··' )
;
··) *
t_uvs
¸¸ 
[
¸¸ 
t
¸¸ 
+
¸¸ 
$num
¸¸ 
]
¸¸ 
=
¸¸ 
Vector3
¸¸ &
.
¸¸& '
one
¸¸' *
;
¸¸* +
t_uv2
ºº 
[
ºº 
t
ºº 
+
ºº 
$num
ºº 
]
ºº 
=
ºº 
-
ºº  
up
ºº  "
-
ºº# $
right
ºº% *
;
ºº* +
t_uv2
»» 
[
»» 
t
»» 
+
»» 
$num
»» 
]
»» 
=
»» 
-
»»  
up
»»  "
+
»»# $
right
»»% *
;
»»* +
t_uv2
¼¼ 
[
¼¼ 
t
¼¼ 
+
¼¼ 
$num
¼¼ 
]
¼¼ 
=
¼¼ 
up
¼¼  "
-
¼¼# $
right
¼¼% *
;
¼¼* +
t_uv2
½½ 
[
½½ 
t
½½ 
+
½½ 
$num
½½ 
]
½½ 
=
½½ 
up
½½  "
+
½½# $
right
½½% *
;
½½* +
t_tris
¿¿ 
[
¿¿ 
n
¿¿ 
+
¿¿ 
$num
¿¿ 
]
¿¿ 
=
¿¿ 
t
¿¿  !
+
¿¿" #
$num
¿¿$ %
;
¿¿% &
t_tris
ÀÀ 
[
ÀÀ 
n
ÀÀ 
+
ÀÀ 
$num
ÀÀ 
]
ÀÀ 
=
ÀÀ 
t
ÀÀ  !
+
ÀÀ" #
$num
ÀÀ$ %
;
ÀÀ% &
t_tris
ÁÁ 
[
ÁÁ 
n
ÁÁ 
+
ÁÁ 
$num
ÁÁ 
]
ÁÁ 
=
ÁÁ 
t
ÁÁ  !
+
ÁÁ" #
$num
ÁÁ$ %
;
ÁÁ% &
t_tris
ÂÂ 
[
ÂÂ 
n
ÂÂ 
+
ÂÂ 
$num
ÂÂ 
]
ÂÂ 
=
ÂÂ 
t
ÂÂ  !
+
ÂÂ" #
$num
ÂÂ$ %
;
ÂÂ% &
t_tris
ÃÃ 
[
ÃÃ 
n
ÃÃ 
+
ÃÃ 
$num
ÃÃ 
]
ÃÃ 
=
ÃÃ 
t
ÃÃ  !
+
ÃÃ" #
$num
ÃÃ$ %
;
ÃÃ% &
t_tris
ÄÄ 
[
ÄÄ 
n
ÄÄ 
+
ÄÄ 
$num
ÄÄ 
]
ÄÄ 
=
ÄÄ 
t
ÄÄ  !
+
ÄÄ" #
$num
ÄÄ$ %
;
ÄÄ% &
Color32
ÆÆ 
color
ÆÆ 
=
ÆÆ 

EncodeRGBA
ÆÆ  *
(
ÆÆ* +
index
ÆÆ+ 0
)
ÆÆ0 1
;
ÆÆ1 2
map
ÇÇ 
.
ÇÇ 
Add
ÇÇ 
(
ÇÇ 
index
ÇÇ 
++
ÇÇ 
,
ÇÇ  
new
ÇÇ! $
SimpleTuple
ÇÇ% 0
<
ÇÇ0 1
ProBuilderMesh
ÇÇ1 ?
,
ÇÇ? @
int
ÇÇA D
>
ÇÇD E
(
ÇÇE F
pb
ÇÇF H
,
ÇÇH I
i
ÇÇJ K
)
ÇÇK L
)
ÇÇL M
;
ÇÇM N
t_col
ÉÉ 
[
ÉÉ 
t
ÉÉ 
+
ÉÉ 
$num
ÉÉ 
]
ÉÉ 
=
ÉÉ 
color
ÉÉ $
;
ÉÉ$ %
t_col
ÊÊ 
[
ÊÊ 
t
ÊÊ 
+
ÊÊ 
$num
ÊÊ 
]
ÊÊ 
=
ÊÊ 
color
ÊÊ $
;
ÊÊ$ %
t_col
ËË 
[
ËË 
t
ËË 
+
ËË 
$num
ËË 
]
ËË 
=
ËË 
color
ËË $
;
ËË$ %
t_col
ÌÌ 
[
ÌÌ 
t
ÌÌ 
+
ÌÌ 
$num
ÌÌ 
]
ÌÌ 
=
ÌÌ 
color
ÌÌ $
;
ÌÌ$ %
t
ÎÎ 
+=
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
n
ÏÏ 
+=
ÏÏ 
$num
ÏÏ 
;
ÏÏ 
}
ĞĞ 
Mesh
ÒÒ 
mesh
ÒÒ 
=
ÒÒ 
new
ÒÒ 
Mesh
ÒÒ  
(
ÒÒ  !
)
ÒÒ! "
;
ÒÒ" #
mesh
ÓÓ 
.
ÓÓ 
name
ÓÓ 
=
ÓÓ 
$str
ÓÓ *
;
ÓÓ* +
mesh
ÔÔ 
.
ÔÔ 
vertices
ÔÔ 
=
ÔÔ 
t_billboards
ÔÔ (
;
ÔÔ( )
mesh
ÕÕ 
.
ÕÕ 
uv
ÕÕ 
=
ÕÕ 
t_uvs
ÕÕ 
;
ÕÕ 
mesh
ÖÖ 
.
ÖÖ 
uv2
ÖÖ 
=
ÖÖ 
t_uv2
ÖÖ 
;
ÖÖ 
mesh
×× 
.
×× 
colors
×× 
=
×× 
t_col
×× 
;
××  
mesh
ØØ 
.
ØØ 
	triangles
ØØ 
=
ØØ 
t_tris
ØØ #
;
ØØ# $
return
ÚÚ 
mesh
ÚÚ 
;
ÚÚ 
}
ÛÛ 	
static
İİ 
Mesh
İİ 
BuildEdgeMesh
İİ !
(
İİ! "
ProBuilderMesh
İİ" 0
pb
İİ1 3
,
İİ3 4

Dictionary
İİ5 ?
<
İİ? @
uint
İİ@ D
,
İİD E
SimpleTuple
İİF Q
<
İİQ R
ProBuilderMesh
İİR `
,
İİ` a
Edge
İİb f
>
İİf g
>
İİg h
map
İİi l
,
İİl m
ref
İİn q
uint
İİr v
index
İİw |
)
İİ| }
{
ŞŞ 	
int
ßß 
	edgeCount
ßß 
=
ßß 
$num
ßß 
;
ßß 
int
àà 
	faceCount
àà 
=
àà 
pb
àà 
.
àà 
	faceCount
àà (
;
àà( )
for
ââ 
(
ââ 
int
ââ 
i
ââ 
=
ââ 
$num
ââ 
;
ââ 
i
ââ 
<
ââ 
	faceCount
ââ  )
;
ââ) *
i
ââ+ ,
++
ââ, .
)
ââ. /
	edgeCount
ãã 
+=
ãã 
pb
ãã 
.
ãã  
facesInternal
ãã  -
[
ãã- .
i
ãã. /
]
ãã/ 0
.
ãã0 1
edgesInternal
ãã1 >
.
ãã> ?
Length
ãã? E
;
ããE F
int
åå 
elementCount
åå 
=
åå 
System
åå %
.
åå% &
Math
åå& *
.
åå* +
Min
åå+ .
(
åå. /
	edgeCount
åå/ 8
,
åå8 9
ushort
åå: @
.
åå@ A
MaxValue
ååA I
/
ååJ K
$num
ååL M
-
ååN O
$num
ååP Q
)
ååQ R
;
ååR S
Vector3
çç 
[
çç 
]
çç 
	positions
çç 
=
çç  !
new
çç" %
Vector3
çç& -
[
çç- .
elementCount
çç. :
*
çç; <
$num
çç= >
]
çç> ?
;
çç? @
Color32
èè 
[
èè 
]
èè 
color
èè 
=
èè 
new
èè !
Color32
èè" )
[
èè) *
elementCount
èè* 6
*
èè7 8
$num
èè9 :
]
èè: ;
;
èè; <
int
éé 
[
éé 
]
éé 
tris
éé 
=
éé 
new
éé 
int
éé  
[
éé  !
elementCount
éé! -
*
éé. /
$num
éé0 1
]
éé1 2
;
éé2 3
int
ëë 
	edgeIndex
ëë 
=
ëë 
$num
ëë 
;
ëë 
for
íí 
(
íí 
int
íí 
i
íí 
=
íí 
$num
íí 
;
íí 
i
íí 
<
íí 
	faceCount
íí  )
&&
íí* ,
	edgeIndex
íí- 6
<
íí7 8
elementCount
íí9 E
;
ííE F
i
ííG H
++
ííH J
)
ííJ K
{
îî 
for
ïï 
(
ïï 
int
ïï 
n
ïï 
=
ïï 
$num
ïï 
;
ïï 
n
ïï  !
<
ïï" #
pb
ïï$ &
.
ïï& '
facesInternal
ïï' 4
[
ïï4 5
i
ïï5 6
]
ïï6 7
.
ïï7 8
edgesInternal
ïï8 E
.
ïïE F
Length
ïïF L
&&
ïïM O
	edgeIndex
ïïP Y
<
ïïZ [
elementCount
ïï\ h
;
ïïh i
n
ïïj k
++
ïïk m
)
ïïm n
{
ğğ 
var
ññ 
edge
ññ 
=
ññ 
pb
ññ !
.
ññ! "
facesInternal
ññ" /
[
ññ/ 0
i
ññ0 1
]
ññ1 2
.
ññ2 3
edgesInternal
ññ3 @
[
ññ@ A
n
ññA B
]
ññB C
;
ññC D
Vector3
óó 
a
óó 
=
óó 
pb
óó  "
.
óó" #
positionsInternal
óó# 4
[
óó4 5
edge
óó5 9
.
óó9 :
a
óó: ;
]
óó; <
;
óó< =
Vector3
ôô 
b
ôô 
=
ôô 
pb
ôô  "
.
ôô" #
positionsInternal
ôô# 4
[
ôô4 5
edge
ôô5 9
.
ôô9 :
b
ôô: ;
]
ôô; <
;
ôô< =
int
õõ 
positionIndex
õõ %
=
õõ& '
	edgeIndex
õõ( 1
*
õõ2 3
$num
õõ4 5
;
õõ5 6
	positions
÷÷ 
[
÷÷ 
positionIndex
÷÷ +
+
÷÷, -
$num
÷÷. /
]
÷÷/ 0
=
÷÷1 2
a
÷÷3 4
;
÷÷4 5
	positions
øø 
[
øø 
positionIndex
øø +
+
øø, -
$num
øø. /
]
øø/ 0
=
øø1 2
b
øø3 4
;
øø4 5
Color32
úú 
c
úú 
=
úú 

EncodeRGBA
úú  *
(
úú* +
index
úú+ 0
)
úú0 1
;
úú1 2
map
üü 
.
üü 
Add
üü 
(
üü 
index
üü !
++
üü! #
,
üü# $
new
üü% (
SimpleTuple
üü) 4
<
üü4 5
ProBuilderMesh
üü5 C
,
üüC D
Edge
üüE I
>
üüI J
(
üüJ K
pb
üüK M
,
üüM N
edge
üüO S
)
üüS T
)
üüT U
;
üüU V
color
şş 
[
şş 
positionIndex
şş '
+
şş( )
$num
şş* +
]
şş+ ,
=
şş- .
c
şş/ 0
;
şş0 1
color
ÿÿ 
[
ÿÿ 
positionIndex
ÿÿ '
+
ÿÿ( )
$num
ÿÿ* +
]
ÿÿ+ ,
=
ÿÿ- .
c
ÿÿ/ 0
;
ÿÿ0 1
tris
 
[
 
positionIndex
 &
+
' (
$num
) *
]
* +
=
, -
positionIndex
. ;
+
< =
$num
> ?
;
? @
tris
‚‚ 
[
‚‚ 
positionIndex
‚‚ &
+
‚‚' (
$num
‚‚) *
]
‚‚* +
=
‚‚, -
positionIndex
‚‚. ;
+
‚‚< =
$num
‚‚> ?
;
‚‚? @
	edgeIndex
„„ 
++
„„ 
;
„„  
}
…… 
}
†† 
Mesh
ˆˆ 
mesh
ˆˆ 
=
ˆˆ 
new
ˆˆ 
Mesh
ˆˆ  
(
ˆˆ  !
)
ˆˆ! "
;
ˆˆ" #
mesh
‰‰ 
.
‰‰ 
name
‰‰ 
=
‰‰ 
$str
‰‰ (
;
‰‰( )
mesh
ŠŠ 
.
ŠŠ 
vertices
ŠŠ 
=
ŠŠ 
	positions
ŠŠ %
;
ŠŠ% &
mesh
‹‹ 
.
‹‹ 
colors32
‹‹ 
=
‹‹ 
color
‹‹ !
;
‹‹! "
mesh
ŒŒ 
.
ŒŒ 
subMeshCount
ŒŒ 
=
ŒŒ 
$num
ŒŒ  !
;
ŒŒ! "
mesh
 
.
 

SetIndices
 
(
 
tris
  
,
  !
MeshTopology
" .
.
. /
Lines
/ 4
,
4 5
$num
6 7
)
7 8
;
8 9
return
 
mesh
 
;
 
}
 	
public
—— 
static
—— 
uint
—— 

DecodeRGBA
—— %
(
——% &
Color32
——& -
color
——. 3
)
——3 4
{
˜˜ 	
uint
™™ 
r
™™ 
=
™™ 
(
™™ 
uint
™™ 
)
™™ 
color
™™  
.
™™  !
r
™™! "
;
™™" #
uint
šš 
g
šš 
=
šš 
(
šš 
uint
šš 
)
šš 
color
šš  
.
šš  !
g
šš! "
;
šš" #
uint
›› 
b
›› 
=
›› 
(
›› 
uint
›› 
)
›› 
color
››  
.
››  !
b
››! "
;
››" #
if
 
(
 
System
 
.
 
BitConverter
 #
.
# $
IsLittleEndian
$ 2
)
2 3
return
 
r
 
<<
 
$num
 
|
  
g
! "
<<
# %
$num
& '
|
( )
b
* +
;
+ ,
else
ŸŸ 
return
   
r
   
<<
   
$num
   
|
    
g
  ! "
<<
  # %
$num
  & (
|
  ) *
b
  + ,
<<
  - /
$num
  0 1
;
  1 2
}
¡¡ 	
public
¨¨ 
static
¨¨ 
Color32
¨¨ 

EncodeRGBA
¨¨ (
(
¨¨( )
uint
¨¨) -
hash
¨¨. 2
)
¨¨2 3
{
©© 	
if
¬¬ 
(
¬¬ 
System
¬¬ 
.
¬¬ 
BitConverter
¬¬ #
.
¬¬# $
IsLittleEndian
¬¬$ 2
)
¬¬2 3
return
­­ 
new
­­ 
Color32
­­ "
(
­­" #
(
®® 
byte
®® 
)
®® 
(
®® 
hash
®® 
>>
®®  "
$num
®®# %
&
®®& '
$num
®®( ,
)
®®, -
,
®®- .
(
¯¯ 
byte
¯¯ 
)
¯¯ 
(
¯¯ 
hash
¯¯ 
>>
¯¯  "
$num
¯¯$ %
&
¯¯& '
$num
¯¯( ,
)
¯¯, -
,
¯¯- .
(
°° 
byte
°° 
)
°° 
(
°° 
hash
°° 
&
°°& '
$num
°°( ,
)
°°, -
,
°°- .
(
±± 
byte
±± 
)
±± 
(
±± 
$num
±± 
)
±± 
)
±±  
;
±±  !
else
²² 
return
³³ 
new
³³ 
Color32
³³ "
(
³³" #
(
´´ 
byte
´´ 
)
´´ 
(
´´ 
hash
´´ 
>>
´´  "
$num
´´# %
&
´´& '
$num
´´( ,
)
´´, -
,
´´- .
(
µµ 
byte
µµ 
)
µµ 
(
µµ 
hash
µµ 
>>
µµ  "
$num
µµ# %
&
µµ& '
$num
µµ( ,
)
µµ, -
,
µµ- .
(
¶¶ 
byte
¶¶ 
)
¶¶ 
(
¶¶ 
hash
¶¶ 
>>
¶¶  "
$num
¶¶$ %
&
¶¶& '
$num
¶¶( ,
)
¶¶, -
,
¶¶- .
(
·· 
byte
·· 
)
·· 
(
·· 
$num
·· 
)
·· 
)
··  
;
··  !
}
¸¸ 	
static
ºº 
bool
ºº 
ShouldUseHDRP
ºº !
(
ºº! "
)
ºº" #
{
»» 	
return
¿¿ 
false
¿¿ 
;
¿¿ 
}
ÁÁ 	
}
ÂÂ 
}ÃÃ š
ŒD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Transform2D.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed 

class 
Transform2D 
{		 
public 
Vector2 
position  
;  !
public 
float 
rotation 
; 
public 
Vector2 
scale 
; 
public 
Transform2D 
( 
Vector2 "
position# +
,+ ,
float- 2
rotation3 ;
,; <
Vector2= D
scaleE J
)J K
{ 	
this 
. 
position 
= 
position &
;& '
this 
. 
rotation 
= 
rotation &
;& '
this 
. 
scale 
= 
scale #
;# $
} 	
public   
Vector2   
TransformPoint   %
(  % &
Vector2  & -
p  . /
)  / 0
{!! 	
p"" 
+="" 
position"" 
;"" 
p## 
.## 
RotateAroundPoint## 
(##  
p##  !
,##! "
rotation### +
)##+ ,
;##, -
p$$ 
.$$ 
ScaleAroundPoint$$ 
($$ 
p$$  
,$$  !
scale$$" '
)$$' (
;$$( )
return%% 
p%% 
;%% 
}&& 	
public(( 
override(( 
string(( 
ToString(( '
(((' (
)((( )
{)) 	
return** 
$str** 
+** 
position** #
+**$ %
$str**& -
+**. /
rotation**0 8
+**9 :
PreferenceKeys**; I
.**I J
DEGREE_SYMBOL**J W
+**X Y
$str**Z a
+**b c
scale**d i
;**i j
}++ 	
},, 
}-- ©
ŒD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\IHasDefault.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
	interface 
IHasDefault 
{		 
void 
SetDefaultValues 
( 
) 
;  
} 
} ‹™
˜D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SelectionPickerSettings.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[

 
EditorBrowsable

 
(

  
EditorBrowsableState

 )
.

) *
Never

* /
)

/ 0
]

0 1
public 

class 
SceneSelection 
:  !

IEquatable" ,
<, -
SceneSelection- ;
>; <
{ 
public 

GameObject 

gameObject $
;$ %
public 
ProBuilderMesh 
mesh "
;" #
List 
< 
int 
> 

m_Vertices 
; 
List 
< 
Edge 
> 
m_Edges 
; 
List 
< 
Face 
> 
m_Faces 
; 
public 
List 
< 
int 
> 
vertexes !
{ 	
get 
{ 
return 

m_Vertices #
;# $
}% &
set 
{ 

m_Vertices 
= 
value $
;$ %
}& '
} 	
public 
List 
< 
Edge 
> 
edges 
{ 	
get 
{ 
return 
m_Edges  
;  !
}" #
set 
{ 
m_Edges 
= 
value !
;! "
}# $
} 	
public   
List   
<   
Face   
>   
faces   
{!! 	
get"" 
{"" 
return"" 
m_Faces""  
;""  !
}""" #
set## 
{## 
m_Faces## 
=## 
value## !
;##! "
}### $
}$$ 	
[&& 	
Obsolete&&	 
(&& 
$str&& '
)&&' (
]&&( )
public'' 
int'' 
vertex'' 
;'' 
[)) 	
Obsolete))	 
()) 
$str)) %
)))% &
]))& '
public** 
Edge** 
edge** 
;** 
[,, 	
Obsolete,,	 
(,, 
$str,, %
),,% &
],,& '
public-- 
Face-- 
face-- 
;-- 
public// 
SceneSelection// 
(// 

GameObject// (

gameObject//) 3
=//4 5
null//6 :
)//: ;
{00 	
this11 
.11 

gameObject11 
=11 

gameObject11 (
;11( )

m_Vertices22 
=22 
new22 
List22 !
<22! "
int22" %
>22% &
(22& '
)22' (
;22( )
m_Edges33 
=33 
new33 
List33 
<33 
Edge33 #
>33# $
(33$ %
)33% &
;33& '
m_Faces44 
=44 
new44 
List44 
<44 
Face44 #
>44# $
(44$ %
)44% &
;44& '
}55 	
public77 
SceneSelection77 
(77 
ProBuilderMesh77 ,
mesh77- 1
,771 2
int773 6
vertex777 =
)77= >
:77? @
this77A E
(77E F
mesh77F J
,77J K
new77L O
List77P T
<77T U
int77U X
>77X Y
(77Y Z
)77Z [
{77\ ]
vertex77^ d
}77e f
)77f g
{77h i
}77j k
public99 
SceneSelection99 
(99 
ProBuilderMesh99 ,
mesh99- 1
,991 2
Edge993 7
edge998 <
)99< =
:99> ?
this99@ D
(99D E
mesh99E I
,99I J
new99K N
List99O S
<99S T
Edge99T X
>99X Y
(99Y Z
)99Z [
{99\ ]
edge99^ b
}99c d
)99d e
{99f g
}99h i
public;; 
SceneSelection;; 
(;; 
ProBuilderMesh;; ,
mesh;;- 1
,;;1 2
Face;;3 7
face;;8 <
);;< =
:;;> ?
this;;@ D
(;;D E
mesh;;E I
,;;I J
new;;K N
List;;O S
<;;S T
Face;;T X
>;;X Y
(;;Y Z
);;Z [
{;;\ ]
face;;^ b
};;c d
);;d e
{;;f g
};;h i
internal== 
SceneSelection== 
(==  
ProBuilderMesh==  .
mesh==/ 3
,==3 4
List==5 9
<==9 :
int==: =
>=== >
vertexes==? G
)==G H
:==I J
this==K O
(==O P
mesh==P T
!===U W
null==X \
?==] ^
mesh==_ c
.==c d

gameObject==d n
:==o p
null==q u
)==u v
{>> 	
this?? 
.?? 
mesh?? 
=?? 
mesh?? 
;?? 

m_Vertices@@ 
=@@ 
vertexes@@ !
;@@! "
m_EdgesAA 
=AA 
newAA 
ListAA 
<AA 
EdgeAA #
>AA# $
(AA$ %
)AA% &
;AA& '
m_FacesBB 
=BB 
newBB 
ListBB 
<BB 
FaceBB #
>BB# $
(BB$ %
)BB% &
;BB& '
}CC 	
internalEE 
SceneSelectionEE 
(EE  
ProBuilderMeshEE  .
meshEE/ 3
,EE3 4
ListEE5 9
<EE9 :
EdgeEE: >
>EE> ?
edgesEE@ E
)EEE F
:EEG H
thisEEI M
(EEM N
meshEEN R
!=EES U
nullEEV Z
?EE[ \
meshEE] a
.EEa b

gameObjectEEb l
:EEm n
nullEEo s
)EEs t
{FF 	
thisGG 
.GG 
meshGG 
=GG 
meshGG 
;GG 
vertexesHH 
=HH 
newHH 
ListHH 
<HH  
intHH  #
>HH# $
(HH$ %
)HH% &
;HH& '
thisII 
.II 
edgesII 
=II 
edgesII 
;II 
facesJJ 
=JJ 
newJJ 
ListJJ 
<JJ 
FaceJJ !
>JJ! "
(JJ" #
)JJ# $
;JJ$ %
}KK 	
internalMM 
SceneSelectionMM 
(MM  
ProBuilderMeshMM  .
meshMM/ 3
,MM3 4
ListMM5 9
<MM9 :
FaceMM: >
>MM> ?
facesMM@ E
)MME F
:MMG H
thisMMI M
(MMM N
meshMMN R
!=MMS U
nullMMV Z
?MM[ \
meshMM] a
.MMa b

gameObjectMMb l
:MMm n
nullMMo s
)MMs t
{NN 	
thisOO 
.OO 
meshOO 
=OO 
meshOO 
;OO 
vertexesPP 
=PP 
newPP 
ListPP 
<PP  
intPP  #
>PP# $
(PP$ %
)PP% &
;PP& '
edgesQQ 
=QQ 
newQQ 
ListQQ 
<QQ 
EdgeQQ !
>QQ! "
(QQ" #
)QQ# $
;QQ$ %
thisRR 
.RR 
facesRR 
=RR 
facesRR 
;RR 
}SS 	
publicUU 
voidUU 
SetSingleFaceUU !
(UU! "
FaceUU" &
faceUU' +
)UU+ ,
{VV 	
facesWW 
.WW 
ClearWW 
(WW 
)WW 
;WW 
facesXX 
.XX 
AddXX 
(XX 
faceXX 
)XX 
;XX 
}YY 	
public[[ 
void[[ 
SetSingleVertex[[ #
([[# $
int[[$ '
vertex[[( .
)[[. /
{\\ 	
vertexes]] 
.]] 
Clear]] 
(]] 
)]] 
;]] 
vertexes^^ 
.^^ 
Add^^ 
(^^ 
vertex^^ 
)^^  
;^^  !
}__ 	
publicaa 
voidaa 
SetSingleEdgeaa !
(aa! "
Edgeaa" &
edgeaa' +
)aa+ ,
{bb 	
edgescc 
.cc 
Clearcc 
(cc 
)cc 
;cc 
edgesdd 
.dd 
Adddd 
(dd 
edgedd 
)dd 
;dd 
}ee 	
publicgg 
voidgg 
Cleargg 
(gg 
)gg 
{hh 	

gameObjectii 
=ii 
nullii 
;ii 
meshjj 
=jj 
nulljj 
;jj 
faceskk 
.kk 
Clearkk 
(kk 
)kk 
;kk 
edgesll 
.ll 
Clearll 
(ll 
)ll 
;ll 
vertexesmm 
.mm 
Clearmm 
(mm 
)mm 
;mm 
}nn 	
publicpp 
voidpp 
CopyTopp 
(pp 
SceneSelectionpp )
dstpp* -
)pp- .
{qq 	
dstrr 
.rr 

gameObjectrr 
=rr 

gameObjectrr '
;rr' (
dstss 
.ss 
meshss 
=ss 
meshss 
;ss 
dsttt 
.tt 
facestt 
.tt 
Cleartt 
(tt 
)tt 
;tt 
dstuu 
.uu 
edgesuu 
.uu 
Clearuu 
(uu 
)uu 
;uu 
dstvv 
.vv 
vertexesvv 
.vv 
Clearvv 
(vv 
)vv  
;vv  !
foreachww 
(ww 
varww 
xww 
inww 
facesww #
)ww# $
dstxx 
.xx 
facesxx 
.xx 
Addxx 
(xx 
xxx 
)xx  
;xx  !
foreachyy 
(yy 
varyy 
xyy 
inyy 
edgesyy #
)yy# $
dstzz 
.zz 
edgeszz 
.zz 
Addzz 
(zz 
xzz 
)zz  
;zz  !
foreach{{ 
({{ 
var{{ 
x{{ 
in{{ 
vertexes{{ &
){{& '
dst|| 
.|| 
vertexes|| 
.|| 
Add||  
(||  !
x||! "
)||" #
;||# $
}}} 	
public 
override 
string 
ToString '
(' (
)( )
{
€€ 	
var
 
sb
 
=
 
new
 
System
 
.
  
Text
  $
.
$ %
StringBuilder
% 2
(
2 3
)
3 4
;
4 5
sb
‚‚ 
.
‚‚ 

AppendLine
‚‚ 
(
‚‚ 
$str
‚‚ (
+
‚‚) *
(
‚‚+ ,

gameObject
‚‚, 6
!=
‚‚7 9
null
‚‚: >
?
‚‚? @

gameObject
‚‚A K
.
‚‚K L
name
‚‚L P
:
‚‚Q R
null
‚‚S W
)
‚‚W X
)
‚‚X Y
;
‚‚Y Z
sb
ƒƒ 
.
ƒƒ 

AppendLine
ƒƒ 
(
ƒƒ 
$str
ƒƒ ,
+
ƒƒ- .
(
ƒƒ/ 0
mesh
ƒƒ0 4
!=
ƒƒ5 7
null
ƒƒ8 <
?
ƒƒ= >
mesh
ƒƒ? C
.
ƒƒC D
name
ƒƒD H
:
ƒƒI J
null
ƒƒK O
)
ƒƒO P
)
ƒƒP Q
;
ƒƒQ R
sb
„„ 
.
„„ 

AppendLine
„„ 
(
„„ 
$str
„„ "
+
„„# $
(
„„% &
faces
„„& +
!=
„„, .
null
„„/ 3
?
„„4 5
faces
„„6 ;
.
„„; <
ToString
„„< D
(
„„D E
)
„„E F
:
„„G H
null
„„I M
)
„„M N
)
„„N O
;
„„O P
sb
…… 
.
…… 

AppendLine
…… 
(
…… 
$str
…… "
+
……# $
edges
……% *
.
……* +
ToString
……+ 3
(
……3 4
)
……4 5
)
……5 6
;
……6 7
sb
†† 
.
†† 

AppendLine
†† 
(
†† 
$str
†† $
+
††% &
vertexes
††' /
)
††/ 0
;
††0 1
return
‡‡ 
sb
‡‡ 
.
‡‡ 
ToString
‡‡ 
(
‡‡ 
)
‡‡  
;
‡‡  !
}
ˆˆ 	
public
ŠŠ 
bool
ŠŠ 
Equals
ŠŠ 
(
ŠŠ 
SceneSelection
ŠŠ )
other
ŠŠ* /
)
ŠŠ/ 0
{
‹‹ 	
if
ŒŒ 
(
ŒŒ 
ReferenceEquals
ŒŒ 
(
ŒŒ  
null
ŒŒ  $
,
ŒŒ$ %
other
ŒŒ& +
)
ŒŒ+ ,
)
ŒŒ, -
return
ŒŒ. 4
false
ŒŒ5 :
;
ŒŒ: ;
if
 
(
 
ReferenceEquals
 
(
  
this
  $
,
$ %
other
& +
)
+ ,
)
, -
return
. 4
true
5 9
;
9 :
return
 
Equals
 
(
 

gameObject
 $
,
$ %
other
& +
.
+ ,

gameObject
, 6
)
6 7
&&
 
Equals
 
(
 
mesh
 
,
 
other
  %
.
% &
mesh
& *
)
* +
&&
 

Enumerable
 
.
 
SequenceEqual
 +
(
+ ,
vertexes
, 4
,
4 5
other
6 ;
.
; <
vertexes
< D
)
D E
&&
‘‘ 

Enumerable
‘‘ 
.
‘‘ 
SequenceEqual
‘‘ +
(
‘‘+ ,
edges
‘‘, 1
,
‘‘1 2
other
‘‘3 8
.
‘‘8 9
edges
‘‘9 >
)
‘‘> ?
&&
’’ 

Enumerable
’’ 
.
’’ 
SequenceEqual
’’ +
(
’’+ ,
faces
’’, 1
,
’’1 2
other
’’3 8
.
’’8 9
faces
’’9 >
)
’’> ?
;
’’? @
}
““ 	
public
•• 
override
•• 
bool
•• 
Equals
•• #
(
••# $
object
••$ *
obj
••+ .
)
••. /
{
–– 	
if
—— 
(
—— 
ReferenceEquals
—— 
(
——  
null
——  $
,
——$ %
obj
——& )
)
——) *
)
——* +
return
——, 2
false
——3 8
;
——8 9
if
˜˜ 
(
˜˜ 
ReferenceEquals
˜˜ 
(
˜˜  
this
˜˜  $
,
˜˜$ %
obj
˜˜& )
)
˜˜) *
)
˜˜* +
return
˜˜, 2
true
˜˜3 7
;
˜˜7 8
if
™™ 
(
™™ 
obj
™™ 
.
™™ 
GetType
™™ 
(
™™ 
)
™™ 
!=
™™  
this
™™! %
.
™™% &
GetType
™™& -
(
™™- .
)
™™. /
)
™™/ 0
return
™™1 7
false
™™8 =
;
™™= >
return
šš 
Equals
šš 
(
šš 
(
šš 
SceneSelection
šš )
)
šš) *
obj
šš* -
)
šš- .
;
šš. /
}
›› 	
public
 
override
 
int
 
GetHashCode
 '
(
' (
)
( )
{
 	
	unchecked
ŸŸ 
{
   
int
¡¡ 
hashCode
¡¡ 
=
¡¡ 
(
¡¡  

gameObject
¡¡  *
!=
¡¡+ -
null
¡¡. 2
?
¡¡3 4

gameObject
¡¡5 ?
.
¡¡? @
GetHashCode
¡¡@ K
(
¡¡K L
)
¡¡L M
:
¡¡N O
$num
¡¡P Q
)
¡¡Q R
;
¡¡R S
hashCode
¢¢ 
=
¢¢ 
(
¢¢ 
hashCode
¢¢ $
*
¢¢% &
$num
¢¢' *
)
¢¢* +
^
¢¢, -
(
¢¢. /
mesh
¢¢/ 3
!=
¢¢4 6
null
¢¢7 ;
?
¢¢< =
mesh
¢¢> B
.
¢¢B C
GetHashCode
¢¢C N
(
¢¢N O
)
¢¢O P
:
¢¢Q R
$num
¢¢S T
)
¢¢T U
;
¢¢U V
hashCode
££ 
=
££ 
(
££ 
hashCode
££ $
*
££% &
$num
££' *
)
££* +
^
££, -
(
££. /
vertexes
££/ 7
!=
££8 :
null
££; ?
?
££@ A
vertexes
££B J
.
££J K
GetHashCode
££K V
(
££V W
)
££W X
:
££Y Z
$num
££[ \
)
££\ ]
;
££] ^
hashCode
¤¤ 
=
¤¤ 
(
¤¤ 
hashCode
¤¤ $
*
¤¤% &
$num
¤¤' *
)
¤¤* +
^
¤¤, -
(
¤¤. /
edges
¤¤/ 4
!=
¤¤5 7
null
¤¤8 <
?
¤¤= >
edges
¤¤? D
.
¤¤D E
GetHashCode
¤¤E P
(
¤¤P Q
)
¤¤Q R
:
¤¤S T
$num
¤¤U V
)
¤¤V W
;
¤¤W X
hashCode
¥¥ 
=
¥¥ 
(
¥¥ 
hashCode
¥¥ $
*
¥¥% &
$num
¥¥' *
)
¥¥* +
^
¥¥, -
(
¥¥. /
faces
¥¥/ 4
!=
¥¥5 7
null
¥¥8 <
?
¥¥= >
faces
¥¥? D
.
¥¥D E
GetHashCode
¥¥E P
(
¥¥P Q
)
¥¥Q R
:
¥¥S T
$num
¥¥U V
)
¥¥V W
;
¥¥W X
return
¦¦ 
hashCode
¦¦ 
;
¦¦  
}
§§ 
}
¨¨ 	
public
ªª 
static
ªª 
bool
ªª 
operator
ªª #
==
ªª# %
(
ªª% &
SceneSelection
ªª& 4
left
ªª5 9
,
ªª9 :
SceneSelection
ªª; I
right
ªªJ O
)
ªªO P
{
«« 	
return
¬¬ 
Equals
¬¬ 
(
¬¬ 
left
¬¬ 
,
¬¬ 
right
¬¬  %
)
¬¬% &
;
¬¬& '
}
­­ 	
public
¯¯ 
static
¯¯ 
bool
¯¯ 
operator
¯¯ #
!=
¯¯# %
(
¯¯% &
SceneSelection
¯¯& 4
left
¯¯5 9
,
¯¯9 :
SceneSelection
¯¯; I
right
¯¯J O
)
¯¯O P
{
°° 	
return
±± 
!
±± 
Equals
±± 
(
±± 
left
±± 
,
±±  
right
±±! &
)
±±& '
;
±±' (
}
²² 	
}
³³ 
struct
µµ 

VertexPickerEntry
µµ 
{
¶¶ 
public
·· 
ProBuilderMesh
·· 
mesh
·· "
;
··" #
public
¸¸ 
int
¸¸ 
vertex
¸¸ 
;
¸¸ 
public
¹¹ 
float
¹¹ 
screenDistance
¹¹ #
;
¹¹# $
public
ºº 
Vector3
ºº 
worldPosition
ºº $
;
ºº$ %
}
»» 
}¼¼ §)
‰D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Triangle.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ 
Serializable 
] 
struct 

Triangle 
: 

IEquatable  
<  !
Triangle! )
>) *
{ 
[		 	
SerializeField			 
]		 
int

 
m_A

 
;

 
[ 	
SerializeField	 
] 
int 
m_B 
; 
[ 	
SerializeField	 
] 
int 
m_C 
; 
public 
int 
a 
{ 	
get 
{ 
return 
m_A 
; 
} 
} 	
public 
int 
b 
{ 	
get 
{ 
return 
m_B 
; 
} 
} 	
public 
int 
c 
{ 	
get 
{ 
return 
m_C 
; 
} 
} 	
public!! 
IEnumerable!! 
<!! 
int!! 
>!! 
indices!!  '
{"" 	
get## 
{## 
return## 
new## 
[## 
]## 
{##  
m_A##! $
,##$ %
m_B##& )
,##) *
m_C##+ .
}##/ 0
;##0 1
}##2 3
}$$ 	
public&& 
Triangle&& 
(&& 
int&& 
a&& 
,&& 
int&& "
b&&# $
,&&$ %
int&&& )
c&&* +
)&&+ ,
{'' 	
m_A(( 
=(( 
a(( 
;(( 
m_B)) 
=)) 
b)) 
;)) 
m_C** 
=** 
c** 
;** 
}++ 	
public-- 
bool-- 
Equals-- 
(-- 
Triangle-- #
other--$ )
)--) *
{.. 	
return// 
m_A// 
==// 
other// 
.//  
a//  !
&&//" $
m_B//% (
==//) +
other//, 1
.//1 2
b//2 3
&&//4 6
m_C//7 :
==//; =
other//> C
.//C D
c//D E
;//E F
}00 	
public22 
override22 
bool22 
Equals22 #
(22# $
object22$ *
obj22+ .
)22. /
{33 	
return44 
obj44 
is44 
Triangle44 "
other44# (
&&44) +
Equals44, 2
(442 3
other443 8
)448 9
;449 :
}55 	
public77 
override77 
int77 
GetHashCode77 '
(77' (
)77( )
{88 	
	unchecked99 
{:: 
var;; 
hashCode;; 
=;; 
m_A;; "
;;;" #
hashCode<< 
=<< 
(<< 
hashCode<< $
*<<% &
$num<<' *
)<<* +
^<<, -
m_B<<. 1
;<<1 2
hashCode== 
=== 
(== 
hashCode== $
*==% &
$num==' *
)==* +
^==, -
m_C==. 1
;==1 2
return>> 
hashCode>> 
;>>  
}?? 
}@@ 	
publicBB 
boolBB 

IsAdjacentBB 
(BB 
TriangleBB '
otherBB( -
)BB- .
{CC 	
returnDD 
otherDD 
.DD 
ContainsEdgeDD %
(DD% &
newDD& )
EdgeDD* .
(DD. /
aDD/ 0
,DD0 1
bDD2 3
)DD3 4
)DD4 5
||EE 
otherEE 
.EE 
ContainsEdgeEE %
(EE% &
newEE& )
EdgeEE* .
(EE. /
bEE/ 0
,EE0 1
cEE2 3
)EE3 4
)EE4 5
||FF 
otherFF 
.FF 
ContainsEdgeFF %
(FF% &
newFF& )
EdgeFF* .
(FF. /
cFF/ 0
,FF0 1
aFF2 3
)FF3 4
)FF4 5
;FF5 6
}GG 	
boolII 
ContainsEdgeII 
(II 
EdgeII 
edgeII #
)II# $
{JJ 	
ifKK 
(KK 
newKK 
EdgeKK 
(KK 
aKK 
,KK 
bKK 
)KK 
==KK !
edgeKK" &
)KK& '
returnLL 
trueLL 
;LL 
ifMM 
(MM 
newMM 
EdgeMM 
(MM 
bMM 
,MM 
cMM 
)MM 
==MM !
edgeMM" &
)MM& '
returnNN 
trueNN 
;NN 
returnOO 
newOO 
EdgeOO 
(OO 
cOO 
,OO 
aOO  
)OO  !
==OO" $
edgeOO% )
;OO) *
}PP 	
}QQ 
}RR Ûo
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\UV\TextureStitching.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
static 

partial 
class 
	UVEditing "
{ 
public 
static 
bool 

AutoStitch %
(% &
ProBuilderMesh& 4
mesh5 9
,9 :
Face; ?
f1@ B
,B C
FaceD H
f2I K
,K L
intM P
channelQ X
)X Y
{ 	
var 
wings 
= 

WingedEdge "
." #
GetWingedEdges# 1
(1 2
mesh2 6
,6 7
new8 ;
[< =
]= >
{? @
f1A C
,C D
f2E G
}H I
)I J
;J K
var 

sharedEdge 
= 
wings "
." #
FirstOrDefault# 1
(1 2
x2 3
=>4 6
x7 8
.8 9
face9 =
==> @
f1A C
&&D F
xG H
.H I
oppositeI Q
!=R T
nullU Y
&&Z \
x] ^
.^ _
opposite_ g
.g h
faceh l
==m o
f2p r
)r s
;s t
if 
( 

sharedEdge 
== 
null "
)" #
return 
false 
; 
if 
( 
f1 
. 
manualUV 
) 
f2 
. 
manualUV 
= 
true "
;" #
f1 
. 
textureGroup 
= 
- 
$num  
;  !
f2 
. 
textureGroup 
= 
- 
$num  
;  !

Projection 
. 
PlanarProject $
($ %
mesh% )
,) *
f2+ -
)- .
;. /
if!! 
(!! 

AlignEdges!! 
(!! 
mesh!! 
,!!  
f2!!! #
,!!# $

sharedEdge!!% /
.!!/ 0
edge!!0 4
.!!4 5
local!!5 :
,!!: ;

sharedEdge!!< F
.!!F G
opposite!!G O
.!!O P
edge!!P T
.!!T U
local!!U Z
,!!Z [
channel!!\ c
)!!c d
)!!d e
{"" 
if## 
(## 
!## 
f2## 
.## 
manualUV##  
)##  !
{$$ ,
 SetAutoAndAlignUnwrapParamsToUVs%% 4
(%%4 5
mesh%%5 9
,%%9 :
new%%; >
[%%? @
]%%@ A
{%%B C
f2%%D F
}%%G H
)%%H I
;%%I J
}&& 
return(( 
true(( 
;(( 
})) 
return++ 
false++ 
;++ 
},, 	
static77 
bool77 

AlignEdges77 
(77 
ProBuilderMesh77 -
mesh77. 2
,772 3
Face774 8

faceToMove779 C
,77C D
Edge77E I
edgeToAlignTo77J W
,77W X
Edge77Y ]
edgeToBeAligned77^ m
,77m n
int77o r
channel77s z
)77z {
{88 	
Vector299 
[99 
]99 
uvs99 
=99 
GetUVs99 "
(99" #
mesh99# '
,99' (
channel99) 0
)990 1
;991 2
SharedVertex:: 
[:: 
]:: 
sharedIndexes:: (
=::) *
mesh::+ /
.::/ 0"
sharedVerticesInternal::0 F
;::F G
int== 
[== 
]== 
matchX== 
=== 
new== 
int== "
[==" #
$num==# $
]==$ %
{==& '
edgeToAlignTo==( 5
.==5 6
a==6 7
,==7 8
-==9 :
$num==: ;
}==< =
;=== >
int>> 
[>> 
]>> 
matchY>> 
=>> 
new>> 
int>> "
[>>" #
$num>># $
]>>$ %
{>>& '
edgeToAlignTo>>( 5
.>>5 6
b>>6 7
,>>7 8
->>9 :
$num>>: ;
}>>< =
;>>= >
int@@ 
siIndex@@ 
=@@ 
mesh@@ 
.@@ !
GetSharedVertexHandle@@ 4
(@@4 5
edgeToAlignTo@@5 B
.@@B C
a@@C D
)@@D E
;@@E F
ifBB 
(BB 
siIndexBB 
<BB 
$numBB 
)BB 
returnCC 
falseCC 
;CC 
ifEE 
(EE 
sharedIndexesEE 
[EE 
siIndexEE %
]EE% &
.EE& '
ContainsEE' /
(EE/ 0
edgeToBeAlignedEE0 ?
.EE? @
aEE@ A
)EEA B
)EEB C
{FF 
matchXGG 
[GG 
$numGG 
]GG 
=GG 
edgeToBeAlignedGG +
.GG+ ,
aGG, -
;GG- .
matchYHH 
[HH 
$numHH 
]HH 
=HH 
edgeToBeAlignedHH +
.HH+ ,
bHH, -
;HH- .
}II 
elseJJ 
{KK 
matchXLL 
[LL 
$numLL 
]LL 
=LL 
edgeToBeAlignedLL +
.LL+ ,
bLL, -
;LL- .
matchYMM 
[MM 
$numMM 
]MM 
=MM 
edgeToBeAlignedMM +
.MM+ ,
aMM, -
;MM- .
}NN 
floatQQ 
dist_e1QQ 
=QQ 
Vector2QQ #
.QQ# $
DistanceQQ$ ,
(QQ, -
uvsQQ- 0
[QQ0 1
edgeToAlignToQQ1 >
.QQ> ?
aQQ? @
]QQ@ A
,QQA B
uvsQQC F
[QQF G
edgeToAlignToQQG T
.QQT U
bQQU V
]QQV W
)QQW X
;QQX Y
floatRR 
dist_e2RR 
=RR 
Vector2RR #
.RR# $
DistanceRR$ ,
(RR, -
uvsRR- 0
[RR0 1
edgeToBeAlignedRR1 @
.RR@ A
aRRA B
]RRB C
,RRC D
uvsRRE H
[RRH I
edgeToBeAlignedRRI X
.RRX Y
bRRY Z
]RRZ [
)RR[ \
;RR\ ]
floatTT 
scaleTT 
=TT 
dist_e1TT !
/TT" #
dist_e2TT$ +
;TT+ ,
foreachWW 
(WW 
intWW 
iWW 
inWW 

faceToMoveWW (
.WW( )#
distinctIndexesInternalWW) @
)WW@ A
uvsXX 
[XX 
iXX 
]XX 
=XX 
uvsXX 
[XX 
iXX 
]XX 
.XX  
ScaleAroundPointXX  0
(XX0 1
Vector2XX1 8
.XX8 9
zeroXX9 =
,XX= >
Vector2XX? F
.XXF G
oneXXG J
*XXK L
scaleXXM R
)XXR S
;XXS T
Vector2]] 
	f1_center]] 
=]] 
(]]  !
uvs]]! $
[]]$ %
edgeToAlignTo]]% 2
.]]2 3
a]]3 4
]]]4 5
+]]6 7
uvs]]8 ;
[]]; <
edgeToAlignTo]]< I
.]]I J
b]]J K
]]]K L
)]]L M
/]]N O
$num]]P R
;]]R S
Vector2^^ 
	f2_center^^ 
=^^ 
(^^  !
uvs^^! $
[^^$ %
edgeToBeAligned^^% 4
.^^4 5
a^^5 6
]^^6 7
+^^8 9
uvs^^: =
[^^= >
edgeToBeAligned^^> M
.^^M N
b^^N O
]^^O P
)^^P Q
/^^R S
$num^^T V
;^^V W
Vector2`` 
diff`` 
=`` 
	f1_center`` $
-``% &
	f2_center``' 0
;``0 1
foreachee 
(ee 
intee 
iee 
inee 

faceToMoveee (
.ee( )#
distinctIndexesInternalee) @
)ee@ A
uvsff 
[ff 
iff 
]ff 
+=ff 
diffff 
;ff 
Vector2kk 
angle1kk 
=kk 
uvskk  
[kk  !
matchYkk! '
[kk' (
$numkk( )
]kk) *
]kk* +
-kk, -
uvskk. 1
[kk1 2
matchXkk2 8
[kk8 9
$numkk9 :
]kk: ;
]kk; <
;kk< =
Vector2ll 
angle2ll 
=ll 
uvsll  
[ll  !
matchYll! '
[ll' (
$numll( )
]ll) *
]ll* +
-ll, -
uvsll. 1
[ll1 2
matchXll2 8
[ll8 9
$numll9 :
]ll: ;
]ll; <
;ll< =
floatnn 
anglenn 
=nn 
Vector2nn !
.nn! "
Anglenn" '
(nn' (
angle1nn( .
,nn. /
angle2nn0 6
)nn6 7
;nn7 8
ifoo 
(oo 
Vector3oo 
.oo 
Crossoo 
(oo 
angle1oo $
,oo$ %
angle2oo& ,
)oo, -
.oo- .
zoo. /
<oo0 1
$numoo2 3
)oo3 4
anglepp 
=pp 
$numpp 
-pp 
anglepp $
;pp$ %
foreachrr 
(rr 
intrr 
irr 
inrr 

faceToMoverr (
.rr( )#
distinctIndexesInternalrr) @
)rr@ A
uvsss 
[ss 
iss 
]ss 
=ss 
Mathss 
.ss 
RotateAroundPointss /
(ss/ 0
uvsss0 3
[ss3 4
iss4 5
]ss5 6
,ss6 7
	f1_centerss8 A
,ssA B
anglessC H
)ssH I
;ssI J
floatuu 
erroruu 
=uu 
Mathfuu 
.uu  
Absuu  #
(uu# $
Vector2uu$ +
.uu+ ,
Distanceuu, 4
(uu4 5
uvsuu5 8
[uu8 9
matchXuu9 ?
[uu? @
$numuu@ A
]uuA B
]uuB C
,uuC D
uvsuuE H
[uuH I
matchXuuI O
[uuO P
$numuuP Q
]uuQ R
]uuR S
)uuS T
)uuT U
+uuV W
MathfuuX ]
.uu] ^
Absuu^ a
(uua b
Vector2uub i
.uui j
Distanceuuj r
(uur s
uvsuus v
[uuv w
matchYuuw }
[uu} ~
$numuu~ 
]	uu €
]
uu€ 
,
uu ‚
uvs
uuƒ †
[
uu† ‡
matchY
uu‡ 
[
uu 
$num
uu 
]
uu 
]
uu ‘
)
uu‘ ’
)
uu’ “
;
uu“ ”
ifxx 
(xx 
errorxx 
>xx 
$numxx 
)xx 
{yy 
foreach{{ 
({{ 
int{{ 
i{{ 
in{{ !

faceToMove{{" ,
.{{, -#
distinctIndexesInternal{{- D
){{D E
uvs|| 
[|| 
i|| 
]|| 
=|| 
Math|| !
.||! "
RotateAroundPoint||" 3
(||3 4
uvs||4 7
[||7 8
i||8 9
]||9 :
,||: ;
	f1_center||< E
,||E F
$num||G K
)||K L
;||L M
float~~ 
e2~~ 
=~~ 
Mathf~~  
.~~  !
Abs~~! $
(~~$ %
Vector2~~% ,
.~~, -
Distance~~- 5
(~~5 6
uvs~~6 9
[~~9 :
matchX~~: @
[~~@ A
$num~~A B
]~~B C
]~~C D
,~~D E
uvs~~F I
[~~I J
matchX~~J P
[~~P Q
$num~~Q R
]~~R S
]~~S T
)~~T U
)~~U V
+~~W X
Mathf~~Y ^
.~~^ _
Abs~~_ b
(~~b c
Vector2~~c j
.~~j k
Distance~~k s
(~~s t
uvs~~t w
[~~w x
matchY~~x ~
[~~~ 
$num	~~ €
]
~~€ 
]
~~ ‚
,
~~‚ ƒ
uvs
~~„ ‡
[
~~‡ ˆ
matchY
~~ˆ 
[
~~ 
$num
~~ 
]
~~ ‘
]
~~‘ ’
)
~~’ “
)
~~“ ”
;
~~” •
if 
( 
e2 
< 
error 
) 
error
€€ 
=
€€ 
e2
€€ 
;
€€ 
else
 
{
‚‚ 
foreach
„„ 
(
„„ 
int
„„  
i
„„! "
in
„„# %

faceToMove
„„& 0
.
„„0 1%
distinctIndexesInternal
„„1 H
)
„„H I
uvs
…… 
[
…… 
i
…… 
]
…… 
=
……  
Math
……! %
.
……% &
RotateAroundPoint
……& 7
(
……7 8
uvs
……8 ;
[
……; <
i
……< =
]
……= >
,
……> ?
	f1_center
……@ I
,
……I J
$num
……K O
)
……O P
;
……P Q
}
†† 
}
‡‡ 
SplitUVs
ŠŠ 
(
ŠŠ 
mesh
ŠŠ 
,
ŠŠ 

faceToMove
ŠŠ %
.
ŠŠ% &%
distinctIndexesInternal
ŠŠ& =
)
ŠŠ= >
;
ŠŠ> ?
mesh
ŒŒ 
.
ŒŒ #
SetTexturesCoincident
ŒŒ &
(
ŒŒ& '
matchX
ŒŒ' -
)
ŒŒ- .
;
ŒŒ. /
mesh
 
.
 #
SetTexturesCoincident
 &
(
& '
matchY
' -
)
- .
;
. /
ApplyUVs
 
(
 
mesh
 
,
 
uvs
 
,
 
channel
  '
)
' (
;
( )
return
 
true
 
;
 
}
‘‘ 	
}
’’ 
}““ šb
ŒD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\EdgeUtility.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static		 

class		 
EdgeUtility		 
{

 
public 
static 
IEnumerable !
<! "
Edge" &
>& '&
GetSharedVertexHandleEdges( B
(B C
thisC G
ProBuilderMeshH V
meshW [
,[ \
IEnumerable] h
<h i
Edgei m
>m n
edgeso t
)t u
{ 	
return 
edges 
. 
Select 
(  
x  !
=>" $%
GetSharedVertexHandleEdge% >
(> ?
mesh? C
,C D
xE F
)F G
)G H
;H I
} 	
public 
static 
Edge %
GetSharedVertexHandleEdge 4
(4 5
this5 9
ProBuilderMesh: H
meshI M
,M N
EdgeO S
edgeT X
)X Y
{ 	
return 
new 
Edge 
( 
mesh  
.  !
sharedVertexLookup! 3
[3 4
edge4 8
.8 9
a9 :
]: ;
,; <
mesh= A
.A B
sharedVertexLookupB T
[T U
edgeU Y
.Y Z
bZ [
][ \
)\ ]
;] ^
} 	
internal!! 
static!! 
Edge!! *
GetEdgeWithSharedVertexHandles!! ;
(!!; <
this!!< @
ProBuilderMesh!!A O
mesh!!P T
,!!T U
Edge!!V Z
edge!![ _
)!!_ `
{"" 	
return## 
new## 
Edge## 
(## 
mesh##  
.##  !"
sharedVerticesInternal##! 7
[##7 8
edge##8 <
.##< =
a##= >
]##> ?
[##? @
$num##@ A
]##A B
,##B C
mesh##D H
.##H I"
sharedVerticesInternal##I _
[##_ `
edge##` d
.##d e
b##e f
]##f g
[##g h
$num##h i
]##i j
)##j k
;##k l
}$$ 	
public// 
static// 
bool// 
ValidateEdge// '
(//' (
ProBuilderMesh//( 6
mesh//7 ;
,//; <
Edge//= A
edge//B F
,//F G
out//H K
SimpleTuple//L W
<//W X
Face//X \
,//\ ]
Edge//^ b
>//b c
	validEdge//d m
)//m n
{00 	
Face11 
[11 
]11 
faces11 
=11 
mesh11 
.11  
facesInternal11  -
;11- .
SharedVertex22 
[22 
]22 
sharedIndexes22 (
=22) *
mesh22+ /
.22/ 0"
sharedVerticesInternal220 F
;22F G
Edge44 
	universal44 
=44 %
GetSharedVertexHandleEdge44 6
(446 7
mesh447 ;
,44; <
edge44= A
)44A B
;44B C
for66 
(66 
int66 
i66 
=66 
$num66 
;66 
i66 
<66 
faces66  %
.66% &
Length66& ,
;66, -
i66. /
++66/ 1
)661 2
{77 
int88 
dist_x88 
=88 
-88 
$num88 
,88  
dist_y99 
=99 
-99 
$num99 
,99  
shared_x:: 
=:: 
-::  
$num::  !
,::! "
shared_y;; 
=;; 
-;;  
$num;;  !
;;;! "
if== 
(== 
faces== 
[== 
i== 
]== 
.== #
distinctIndexesInternal== 4
.==4 5
ContainsMatch==5 B
(==B C
sharedIndexes==C P
[==P Q
	universal==Q Z
.==Z [
a==[ \
]==\ ]
.==] ^
arrayInternal==^ k
,==k l
out==m p
dist_x==q w
,==w x
out==y |
shared_x	==} …
)
==… †
&&
==‡ ‰
faces>> 
[>> 
i>> 
]>> 
.>> #
distinctIndexesInternal>> 4
.>>4 5
ContainsMatch>>5 B
(>>B C
sharedIndexes>>C P
[>>P Q
	universal>>Q Z
.>>Z [
b>>[ \
]>>\ ]
.>>] ^
arrayInternal>>^ k
,>>k l
out>>m p
dist_y>>q w
,>>w x
out>>y |
shared_y	>>} …
)
>>… †
)
>>† ‡
{?? 
int@@ 
x@@ 
=@@ 
faces@@ !
[@@! "
i@@" #
]@@# $
.@@$ %#
distinctIndexesInternal@@% <
[@@< =
dist_x@@= C
]@@C D
;@@D E
intAA 
yAA 
=AA 
facesAA !
[AA! "
iAA" #
]AA# $
.AA$ %#
distinctIndexesInternalAA% <
[AA< =
dist_yAA= C
]AAC D
;AAD E
	validEdgeCC 
=CC 
newCC  #
SimpleTupleCC$ /
<CC/ 0
FaceCC0 4
,CC4 5
EdgeCC6 :
>CC: ;
(CC; <
facesCC< A
[CCA B
iCCB C
]CCC D
,CCD E
newCCF I
EdgeCCJ N
(CCN O
xCCO P
,CCP Q
yCCR S
)CCS T
)CCT U
;CCU V
returnDD 
trueDD 
;DD  
}EE 
}FF 
	validEdgeHH 
=HH 
newHH 
SimpleTupleHH '
<HH' (
FaceHH( ,
,HH, -
EdgeHH. 2
>HH2 3
(HH3 4
)HH4 5
;HH5 6
returnJJ 
falseJJ 
;JJ 
}KK 	
internalPP 
staticPP 
boolPP 
ContainsPP %
(PP% &
thisPP& *
EdgePP+ /
[PP/ 0
]PP0 1
edgesPP2 7
,PP7 8
EdgePP9 =
edgePP> B
)PPB C
{QQ 	
forRR 
(RR 
intRR 
iRR 
=RR 
$numRR 
;RR 
iRR 
<RR 
edgesRR  %
.RR% &
LengthRR& ,
;RR, -
iRR. /
++RR/ 1
)RR1 2
{SS 
ifTT 
(TT 
edgesTT 
[TT 
iTT 
]TT 
.TT 
EqualsTT #
(TT# $
edgeTT$ (
)TT( )
)TT) *
returnUU 
trueUU 
;UU  
}VV 
returnXX 
falseXX 
;XX 
}YY 	
internalbb 
staticbb 
boolbb 
Containsbb %
(bb% &
thisbb& *
Edgebb+ /
[bb/ 0
]bb0 1
edgesbb2 7
,bb7 8
intbb9 <
xbb= >
,bb> ?
intbb@ C
ybbD E
)bbE F
{cc 	
fordd 
(dd 
intdd 
idd 
=dd 
$numdd 
;dd 
idd 
<dd 
edgesdd  %
.dd% &
Lengthdd& ,
;dd, -
idd. /
++dd/ 1
)dd1 2
{ee 
ifff 
(ff 
(ff 
xff 
==ff 
edgesff 
[ff  
iff  !
]ff! "
.ff" #
aff# $
&&ff% '
yff( )
==ff* ,
edgesff- 2
[ff2 3
iff3 4
]ff4 5
.ff5 6
bff6 7
)ff7 8
||ff9 ;
(ff< =
xff= >
==ff? A
edgesffB G
[ffG H
iffH I
]ffI J
.ffJ K
bffK L
&&ffM O
yffP Q
==ffR T
edgesffU Z
[ffZ [
iff[ \
]ff\ ]
.ff] ^
aff^ _
)ff_ `
)ff` a
returngg 
truegg 
;gg  
}hh 
returnjj 
falsejj 
;jj 
}kk 	
internalmm 
staticmm 
intmm 
IndexOfmm #
(mm# $
thismm$ (
ProBuilderMeshmm) 7
meshmm8 <
,mm< =
IListmm> C
<mmC D
EdgemmD H
>mmH I
edgesmmJ O
,mmO P
EdgemmQ U
edgemmV Z
)mmZ [
{nn 	
foroo 
(oo 
intoo 
ioo 
=oo 
$numoo 
;oo 
ioo 
<oo 
edgesoo  %
.oo% &
Countoo& +
;oo+ ,
ioo- .
++oo. 0
)oo0 1
{pp 
ifqq 
(qq 
edgesqq 
[qq 
iqq 
]qq 
.qq 
Equalsqq #
(qq# $
edgeqq$ (
,qq( )
meshqq* .
.qq. /
sharedVertexLookupqq/ A
)qqA B
)qqB C
returnrr 
irr 
;rr 
}ss 
returnuu 
-uu 
$numuu 
;uu 
}vv 	
internalxx 
staticxx 
intxx 
[xx 
]xx 
AllTrianglesxx *
(xx* +
thisxx+ /
Edgexx0 4
[xx4 5
]xx5 6
edgesxx7 <
)xx< =
{yy 	
intzz 
[zz 
]zz 
arrzz 
=zz 
newzz 
intzz 
[zz  
edgeszz  %
.zz% &
Lengthzz& ,
*zz- .
$numzz/ 0
]zz0 1
;zz1 2
int{{ 
n{{ 
={{ 
$num{{ 
;{{ 
for}} 
(}} 
int}} 
i}} 
=}} 
$num}} 
;}} 
i}} 
<}} 
edges}}  %
.}}% &
Length}}& ,
;}}, -
i}}. /
++}}/ 1
)}}1 2
{~~ 
arr 
[ 
n 
++ 
] 
= 
edges  
[  !
i! "
]" #
.# $
a$ %
;% &
arr
€€ 
[
€€ 
n
€€ 
++
€€ 
]
€€ 
=
€€ 
edges
€€  
[
€€  !
i
€€! "
]
€€" #
.
€€# $
b
€€$ %
;
€€% &
}
 
return
‚‚ 
arr
‚‚ 
;
‚‚ 
}
ƒƒ 	
internal
…… 
static
…… 
Face
…… 
GetFace
…… $
(
……$ %
this
……% )
ProBuilderMesh
……* 8
mesh
……9 =
,
……= >
Edge
……? C
edge
……D H
)
……H I
{
†† 	
Face
‡‡ 
res
‡‡ 
=
‡‡ 
null
‡‡ 
;
‡‡ 
foreach
‰‰ 
(
‰‰ 
var
‰‰ 
face
‰‰ 
in
‰‰  
mesh
‰‰! %
.
‰‰% &
facesInternal
‰‰& 3
)
‰‰3 4
{
ŠŠ 
var
‹‹ 
edges
‹‹ 
=
‹‹ 
face
‹‹  
.
‹‹  !
edgesInternal
‹‹! .
;
‹‹. /
for
 
(
 
int
 
i
 
=
 
$num
 
,
 
c
  !
=
" #
edges
$ )
.
) *
Length
* 0
;
0 1
i
2 3
<
4 5
c
6 7
;
7 8
i
9 :
++
: <
)
< =
{
 
if
 
(
 
edge
 
.
 
Equals
 #
(
# $
edges
$ )
[
) *
i
* +
]
+ ,
)
, -
)
- .
return
 
face
 #
;
# $
if
’’ 
(
’’ 
edges
’’ 
.
’’ 
Contains
’’ &
(
’’& '
edges
’’' ,
[
’’, -
i
’’- .
]
’’. /
)
’’/ 0
)
’’0 1
res
““ 
=
““ 
face
““ "
;
““" #
}
”” 
}
•• 
return
—— 
res
—— 
;
—— 
}
˜˜ 	
}
™™ 
}šš ¹`
“D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\AutoUnwrapSettings.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[		 
System		 
.		 
Serializable		 
]		 
public

 

struct

 
AutoUnwrapSettings

 $
{ 
public 
static 
AutoUnwrapSettings (%
defaultAutoUnwrapSettings) B
{ 	
get 
{ 
var 
settings 
= 
new "
AutoUnwrapSettings# 5
(5 6
)6 7
;7 8
settings 
. 
Reset 
( 
)  
;  !
return 
settings 
;  
} 
} 	
public 
enum 
Anchor 
{ 	
	UpperLeft   
,   
UpperCenter$$ 
,$$ 

UpperRight(( 
,(( 

MiddleLeft,, 
,,, 
MiddleCenter00 
,00 
MiddleRight44 
,44 
	LowerLeft88 
,88 
LowerCenter<< 
,<< 

LowerRight@@ 
,@@ 
NoneDD 
}EE 	
publicJJ 
enumJJ 
FillJJ 
{KK 	
FitOO 
,OO 
TileSS 
,SS 
StretchWW 
}XX 	
[ZZ 	
SerializeFieldZZ	 
]ZZ 
[[[ 	 
FormerlySerializedAs[[	 
([[ 
$str[[ -
)[[- .
][[. /
bool\\ 
m_UseWorldSpace\\ 
;\\ 
[^^ 	
SerializeField^^	 
]^^ 
[__ 	 
FormerlySerializedAs__	 
(__ 
$str__ %
)__% &
]__& '
bool`` 
m_FlipU`` 
;`` 
[bb 	
SerializeFieldbb	 
]bb 
[cc 	 
FormerlySerializedAscc	 
(cc 
$strcc %
)cc% &
]cc& '
booldd 
m_FlipVdd 
;dd 
[ff 	
SerializeFieldff	 
]ff 
[gg 	 
FormerlySerializedAsgg	 
(gg 
$strgg &
)gg& '
]gg' (
boolhh 
m_SwapUVhh 
;hh 
[jj 	
SerializeFieldjj	 
]jj 
[kk 	 
FormerlySerializedAskk	 
(kk 
$strkk $
)kk$ %
]kk% &
Fillll 
m_Fillll 
;ll 
[nn 	
SerializeFieldnn	 
]nn 
[oo 	 
FormerlySerializedAsoo	 
(oo 
$stroo %
)oo% &
]oo& '
Vector2pp 
m_Scalepp 
;pp 
[rr 	
SerializeFieldrr	 
]rr 
[ss 	 
FormerlySerializedAsss	 
(ss 
$strss &
)ss& '
]ss' (
Vector2tt 
m_Offsettt 
;tt 
[vv 	
SerializeFieldvv	 
]vv 
[ww 	 
FormerlySerializedAsww	 
(ww 
$strww (
)ww( )
]ww) *
floatxx 

m_Rotationxx 
;xx 
[zz 	
SerializeFieldzz	 
]zz 
[{{ 	 
FormerlySerializedAs{{	 
({{ 
$str{{ &
){{& '
]{{' (
Anchor|| 
m_Anchor|| 
;|| 
public
 
bool
 
useWorldSpace
 !
{
‚‚ 	
get
ƒƒ 
{
ƒƒ 
return
ƒƒ 
m_UseWorldSpace
ƒƒ (
;
ƒƒ( )
}
ƒƒ* +
set
„„ 
{
„„ 
m_UseWorldSpace
„„ !
=
„„" #
value
„„$ )
;
„„) *
}
„„+ ,
}
…… 	
public
ŠŠ 
bool
ŠŠ 
flipU
ŠŠ 
{
‹‹ 	
get
ŒŒ 
{
ŒŒ 
return
ŒŒ 
m_FlipU
ŒŒ  
;
ŒŒ  !
}
ŒŒ" #
set
 
{
 
m_FlipU
 
=
 
value
 !
;
! "
}
# $
}
 	
public
““ 
bool
““ 
flipV
““ 
{
”” 	
get
•• 
{
•• 
return
•• 
m_FlipV
••  
;
••  !
}
••" #
set
–– 
{
–– 
m_FlipV
–– 
=
–– 
value
–– !
;
––! "
}
––# $
}
—— 	
public
ŸŸ 
bool
ŸŸ 
swapUV
ŸŸ 
{
   	
get
¡¡ 
{
¡¡ 
return
¡¡ 
m_SwapUV
¡¡ !
;
¡¡! "
}
¡¡# $
set
¢¢ 
{
¢¢ 
m_SwapUV
¢¢ 
=
¢¢ 
value
¢¢ "
;
¢¢" #
}
¢¢$ %
}
££ 	
public
¨¨ 
Fill
¨¨ 
fill
¨¨ 
{
©© 	
get
ªª 
{
ªª 
return
ªª 
m_Fill
ªª 
;
ªª  
}
ªª! "
set
«« 
{
«« 
m_Fill
«« 
=
«« 
value
««  
;
««  !
}
««" #
}
¬¬ 	
public
±± 
Vector2
±± 
scale
±± 
{
²² 	
get
³³ 
{
³³ 
return
³³ 
m_Scale
³³  
;
³³  !
}
³³" #
set
´´ 
{
´´ 
m_Scale
´´ 
=
´´ 
value
´´ !
;
´´! "
}
´´# $
}
µµ 	
public
ºº 
Vector2
ºº 
offset
ºº 
{
»» 	
get
¼¼ 
{
¼¼ 
return
¼¼ 
m_Offset
¼¼ !
;
¼¼! "
}
¼¼# $
set
½½ 
{
½½ 
m_Offset
½½ 
=
½½ 
value
½½ "
;
½½" #
}
½½$ %
}
¾¾ 	
public
ÃÃ 
float
ÃÃ 
rotation
ÃÃ 
{
ÄÄ 	
get
ÅÅ 
{
ÅÅ 
return
ÅÅ 

m_Rotation
ÅÅ #
;
ÅÅ# $
}
ÅÅ% &
set
ÆÆ 
{
ÆÆ 

m_Rotation
ÆÆ 
=
ÆÆ 
value
ÆÆ $
;
ÆÆ$ %
}
ÆÆ& '
}
ÇÇ 	
public
ÌÌ 
Anchor
ÌÌ 
anchor
ÌÌ 
{
ÍÍ 	
get
ÎÎ 
{
ÎÎ 
return
ÎÎ 
m_Anchor
ÎÎ !
;
ÎÎ! "
}
ÎÎ# $
set
ÏÏ 
{
ÏÏ 
m_Anchor
ÏÏ 
=
ÏÏ 
value
ÏÏ "
;
ÏÏ" #
}
ÏÏ$ %
}
ĞĞ 	
public
ÖÖ  
AutoUnwrapSettings
ÖÖ !
(
ÖÖ! " 
AutoUnwrapSettings
ÖÖ" 4
unwrapSettings
ÖÖ5 C
)
ÖÖC D
{
×× 	
m_UseWorldSpace
ØØ 
=
ØØ 
unwrapSettings
ØØ ,
.
ØØ, -
m_UseWorldSpace
ØØ- <
;
ØØ< =
m_FlipU
ÙÙ 
=
ÙÙ 
unwrapSettings
ÙÙ $
.
ÙÙ$ %
m_FlipU
ÙÙ% ,
;
ÙÙ, -
m_FlipV
ÚÚ 
=
ÚÚ 
unwrapSettings
ÚÚ $
.
ÚÚ$ %
m_FlipV
ÚÚ% ,
;
ÚÚ, -
m_SwapUV
ÛÛ 
=
ÛÛ 
unwrapSettings
ÛÛ %
.
ÛÛ% &
m_SwapUV
ÛÛ& .
;
ÛÛ. /
m_Fill
ÜÜ 
=
ÜÜ 
unwrapSettings
ÜÜ #
.
ÜÜ# $
m_Fill
ÜÜ$ *
;
ÜÜ* +
m_Scale
İİ 
=
İİ 
unwrapSettings
İİ $
.
İİ$ %
m_Scale
İİ% ,
;
İİ, -
m_Offset
ŞŞ 
=
ŞŞ 
unwrapSettings
ŞŞ %
.
ŞŞ% &
m_Offset
ŞŞ& .
;
ŞŞ. /

m_Rotation
ßß 
=
ßß 
unwrapSettings
ßß '
.
ßß' (

m_Rotation
ßß( 2
;
ßß2 3
m_Anchor
àà 
=
àà 
unwrapSettings
àà %
.
àà% &
m_Anchor
àà& .
;
àà. /
}
áá 	
public
ææ 
static
ææ  
AutoUnwrapSettings
ææ (
tile
ææ) -
{
çç 	
get
èè 
{
éé 
var
êê 
res
êê 
=
êê 
new
êê  
AutoUnwrapSettings
êê 0
(
êê0 1
)
êê1 2
;
êê2 3
res
ëë 
.
ëë 
Reset
ëë 
(
ëë 
)
ëë 
;
ëë 
return
ìì 
res
ìì 
;
ìì 
}
íí 
}
îî 	
public
óó 
static
óó  
AutoUnwrapSettings
óó (
fit
óó) ,
{
ôô 	
get
õõ 
{
öö 
var
÷÷ 
res
÷÷ 
=
÷÷ 
new
÷÷  
AutoUnwrapSettings
÷÷ 0
(
÷÷0 1
)
÷÷1 2
;
÷÷2 3
res
øø 
.
øø 
Reset
øø 
(
øø 
)
øø 
;
øø 
res
ùù 
.
ùù 
fill
ùù 
=
ùù 
Fill
ùù 
.
ùù  
Fit
ùù  #
;
ùù# $
return
úú 
res
úú 
;
úú 
}
ûû 
}
üü 	
public
 
static
  
AutoUnwrapSettings
 (
stretch
) 0
{
‚‚ 	
get
ƒƒ 
{
„„ 
var
…… 
res
…… 
=
…… 
new
……  
AutoUnwrapSettings
…… 0
(
……0 1
)
……1 2
;
……2 3
res
†† 
.
†† 
Reset
†† 
(
†† 
)
†† 
;
†† 
res
‡‡ 
.
‡‡ 
fill
‡‡ 
=
‡‡ 
Fill
‡‡ 
.
‡‡  
Stretch
‡‡  '
;
‡‡' (
return
ˆˆ 
res
ˆˆ 
;
ˆˆ 
}
‰‰ 
}
ŠŠ 	
public
 
void
 
Reset
 
(
 
)
 
{
 	
m_UseWorldSpace
‘‘ 
=
‘‘ 
false
‘‘ #
;
‘‘# $
m_FlipU
’’ 
=
’’ 
false
’’ 
;
’’ 
m_FlipV
““ 
=
““ 
false
““ 
;
““ 
m_SwapUV
”” 
=
”” 
false
”” 
;
”” 
m_Fill
•• 
=
•• 
Fill
•• 
.
•• 
Tile
•• 
;
•• 
m_Scale
–– 
=
–– 
new
–– 
Vector2
–– !
(
––! "
$num
––" $
,
––$ %
$num
––& (
)
––( )
;
––) *
m_Offset
—— 
=
—— 
new
—— 
Vector2
—— "
(
——" #
$num
——# %
,
——% &
$num
——' )
)
——) *
;
——* +

m_Rotation
˜˜ 
=
˜˜ 
$num
˜˜ 
;
˜˜ 
m_Anchor
™™ 
=
™™ 
Anchor
™™ 
.
™™ 
None
™™ "
;
™™" #
}
šš 	
public
œœ 
override
œœ 
string
œœ 
ToString
œœ '
(
œœ' (
)
œœ( )
{
 	
string
 
str
 
=
 
$str
ŸŸ #
+
ŸŸ$ %
useWorldSpace
ŸŸ& 3
+
ŸŸ4 5
$str
ŸŸ6 :
+
ŸŸ; <
$str
   
+
   
flipU
   "
+
  # $
$str
  % )
+
  * +
$str
¡¡ 
+
¡¡ 
flipV
¡¡ "
+
¡¡# $
$str
¡¡% )
+
¡¡* +
$str
¢¢ 
+
¢¢ 
swapUV
¢¢ $
+
¢¢% &
$str
¢¢' +
+
¢¢, -
$str
££ 
+
££ 
fill
££  $
+
££% &
$str
££' +
+
££, -
$str
¤¤ 
+
¤¤ 
anchor
¤¤ #
+
¤¤$ %
$str
¤¤& *
+
¤¤+ ,
$str
¥¥ 
+
¥¥ 
scale
¥¥ !
+
¥¥" #
$str
¥¥$ (
+
¥¥) *
$str
¦¦ 
+
¦¦ 
offset
¦¦ #
+
¦¦$ %
$str
¦¦& *
+
¦¦+ ,
$str
§§ 
+
§§ 
rotation
§§ '
;
§§' (
return
¨¨ 
str
¨¨ 
;
¨¨ 
}
©© 	
}
ªª 
}«« ïc
ŒD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\BezierPoint.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
enum		 
BezierTangentMode			 
{

 
Free 
, 
Aligned 
, 
Mirrored 
} 
enum "
BezierTangentDirection	 
{ 
In 

,
 
Out 
} 
[ 
System 
. 
Serializable 
] 
struct 

BezierPoint 
{ 
public 
Vector3 
position 
;  
public 
Vector3 
	tangentIn  
;  !
public 
Vector3 

tangentOut !
;! "
public 

Quaternion 
rotation "
;" #
public!! 
BezierPoint!! 
(!! 
Vector3!! "
position!!# +
,!!+ ,
Vector3!!- 4
	tangentIn!!5 >
,!!> ?
Vector3!!@ G

tangentOut!!H R
,!!R S

Quaternion!!T ^
rotation!!_ g
)!!g h
{"" 	
this## 
.## 
position## 
=## 
position## $
;##$ %
this$$ 
.$$ 
	tangentIn$$ 
=$$ 
	tangentIn$$ &
;$$& '
this%% 
.%% 

tangentOut%% 
=%% 

tangentOut%% (
;%%( )
this&& 
.&& 
rotation&& 
=&& 
rotation&& $
;&&$ %
}'' 	
public)) 
void)) 
EnforceTangentMode)) &
())& '"
BezierTangentDirection))' =
master))> D
,))D E
BezierTangentMode))F W
mode))X \
)))\ ]
{** 	
if++ 
(++ 
mode++ 
==++ 
BezierTangentMode++ )
.++) *
Aligned++* 1
)++1 2
{,, 
if-- 
(-- 
master-- 
==-- "
BezierTangentDirection-- 4
.--4 5
In--5 7
)--7 8

tangentOut.. 
=..  
position..! )
+..* +
(.., -

tangentOut..- 7
-..8 9
position..: B
)..B C
...C D

normalized..D N
*..O P
(..Q R
	tangentIn..R [
-..\ ]
position..^ f
)..f g
...g h
	magnitude..h q
;..q r
else// 
	tangentIn00 
=00 
position00  (
+00) *
(00+ ,
	tangentIn00, 5
-006 7
position008 @
)00@ A
.00A B

normalized00B L
*00M N
(00O P

tangentOut00P Z
-00[ \
position00] e
)00e f
.00f g
	magnitude00g p
;00p q
}11 
else22 
if22 
(22 
mode22 
==22 
BezierTangentMode22 .
.22. /
Mirrored22/ 7
)227 8
{33 
if44 
(44 
master44 
==44 "
BezierTangentDirection44 4
.444 5
In445 7
)447 8

tangentOut55 
=55  
position55! )
-55* +
(55, -
	tangentIn55- 6
-557 8
position559 A
)55A B
;55B C
else66 
	tangentIn77 
=77 
position77  (
-77) *
(77+ ,

tangentOut77, 6
-777 8
position779 A
)77A B
;77B C
}88 
}99 	
public?? 
void?? 
SetPosition?? 
(??  
Vector3??  '
position??( 0
)??0 1
{@@ 	
Vector3AA 
deltaAA 
=AA 
positionAA $
-AA% &
thisAA' +
.AA+ ,
positionAA, 4
;AA4 5
thisBB 
.BB 
positionBB 
=BB 
positionBB $
;BB$ %
thisCC 
.CC 
	tangentInCC 
+=CC 
deltaCC #
;CC# $
thisDD 
.DD 

tangentOutDD 
+=DD 
deltaDD $
;DD$ %
}EE 	
publicGG 
voidGG 
SetTangentInGG  
(GG  !
Vector3GG! (
tangentGG) 0
,GG0 1
BezierTangentModeGG2 C
modeGGD H
)GGH I
{HH 	
thisII 
.II 
	tangentInII 
=II 
tangentII $
;II$ %
EnforceTangentModeJJ 
(JJ "
BezierTangentDirectionJJ 5
.JJ5 6
InJJ6 8
,JJ8 9
modeJJ: >
)JJ> ?
;JJ? @
}KK 	
publicMM 
voidMM 
SetTangentOutMM !
(MM! "
Vector3MM" )
tangentMM* 1
,MM1 2
BezierTangentModeMM3 D
modeMME I
)MMI J
{NN 	
thisOO 
.OO 

tangentOutOO 
=OO 
tangentOO %
;OO% &
EnforceTangentModePP 
(PP "
BezierTangentDirectionPP 5
.PP5 6
OutPP6 9
,PP9 :
modePP; ?
)PP? @
;PP@ A
}QQ 	
publicSS 
staticSS 
Vector3SS 
QuadraticPositionSS /
(SS/ 0
BezierPointSS0 ;
aSS< =
,SS= >
BezierPointSS? J
bSSK L
,SSL M
floatSSN S
tSST U
)SSU V
{TT 	
floatUU 
xUU 
=UU 
(UU 
$numUU 
-UU 
tUU 
)UU 
*UU  
(UU! "
$numUU" $
-UU% &
tUU' (
)UU( )
*UU* +
aUU, -
.UU- .
positionUU. 6
.UU6 7
xUU7 8
+UU9 :
$numUU; =
*UU> ?
(UU@ A
$numUUA C
-UUD E
tUUF G
)UUG H
*UUI J
tUUK L
*UUM N
aUUO P
.UUP Q

tangentOutUUQ [
.UU[ \
xUU\ ]
+UU^ _
tUU` a
*UUb c
tUUd e
*UUf g
bUUh i
.UUi j
positionUUj r
.UUr s
xUUs t
;UUt u
floatVV 
yVV 
=VV 
(VV 
$numVV 
-VV 
tVV 
)VV 
*VV  
(VV! "
$numVV" $
-VV% &
tVV' (
)VV( )
*VV* +
aVV, -
.VV- .
positionVV. 6
.VV6 7
yVV7 8
+VV9 :
$numVV; =
*VV> ?
(VV@ A
$numVVA C
-VVD E
tVVF G
)VVG H
*VVI J
tVVK L
*VVM N
aVVO P
.VVP Q

tangentOutVVQ [
.VV[ \
yVV\ ]
+VV^ _
tVV` a
*VVb c
tVVd e
*VVf g
bVVh i
.VVi j
positionVVj r
.VVr s
yVVs t
;VVt u
floatWW 
zWW 
=WW 
(WW 
$numWW 
-WW 
tWW 
)WW 
*WW  
(WW! "
$numWW" $
-WW% &
tWW' (
)WW( )
*WW* +
aWW, -
.WW- .
positionWW. 6
.WW6 7
zWW7 8
+WW9 :
$numWW; =
*WW> ?
(WW@ A
$numWWA C
-WWD E
tWWF G
)WWG H
*WWI J
tWWK L
*WWM N
aWWO P
.WWP Q

tangentOutWWQ [
.WW[ \
zWW\ ]
+WW^ _
tWW` a
*WWb c
tWWd e
*WWf g
bWWh i
.WWi j
positionWWj r
.WWr s
zWWs t
;WWt u
returnXX 
newXX 
Vector3XX 
(XX 
xXX  
,XX  !
yXX" #
,XX# $
zXX% &
)XX& '
;XX' (
}YY 	
public[[ 
static[[ 
Vector3[[ 
CubicPosition[[ +
([[+ ,
BezierPoint[[, 7
a[[8 9
,[[9 :
BezierPoint[[; F
b[[G H
,[[H I
float[[J O
t[[P Q
)[[Q R
{\\ 	
t]] 
=]] 
Mathf]] 
.]] 
Clamp01]] 
(]] 
t]] 
)]]  
;]]  !
float__ 
	oneMinusT__ 
=__ 
$num__  
-__! "
t__# $
;__$ %
returnaa 
	oneMinusTaa 
*aa 
	oneMinusTaa (
*aa) *
	oneMinusTaa+ 4
*aa5 6
aaa7 8
.aa8 9
positionaa9 A
+aaB C
$numbb 
*bb 
	oneMinusTbb 
*bb  
	oneMinusTbb! *
*bb+ ,
tbb- .
*bb/ 0
abb1 2
.bb2 3

tangentOutbb3 =
+bb> ?
$numcc 
*cc 
	oneMinusTcc 
*cc  
tcc! "
*cc# $
tcc% &
*cc' (
bcc) *
.cc* +
	tangentIncc+ 4
+cc5 6
tdd 
*dd 
tdd 
*dd 
tdd 
*dd 
bdd 
.dd 
positiondd &
;dd& '
}ee 	
publicgg 
staticgg 
Vector3gg 
GetLookDirectiongg .
(gg. /
IListgg/ 4
<gg4 5
BezierPointgg5 @
>gg@ A
pointsggB H
,ggH I
intggJ M
indexggN S
,ggS T
intggU X
previousggY a
,gga b
intggc f
nextggg k
)ggk l
{hh 	
ifii 
(ii 
previousii 
<ii 
$numii 
)ii 
{jj 
returnkk 
(kk 
pointskk 
[kk 
indexkk $
]kk$ %
.kk% &
positionkk& .
-kk/ 0
QuadraticPositionkk1 B
(kkB C
pointskkC I
[kkI J
indexkkJ O
]kkO P
,kkP Q
pointskkR X
[kkX Y
nextkkY ]
]kk] ^
,kk^ _
$numkk` c
)kkc d
)kkd e
.kke f

normalizedkkf p
;kkp q
}ll 
elsemm 
ifmm 
(mm 
nextmm 
<mm 
$nummm 
)mm 
{nn 
returnoo 
(oo 
QuadraticPositionoo )
(oo) *
pointsoo* 0
[oo0 1
indexoo1 6
]oo6 7
,oo7 8
pointsoo9 ?
[oo? @
previousoo@ H
]ooH I
,ooI J
$numooK N
)ooN O
-ooP Q
pointsooR X
[ooX Y
indexooY ^
]oo^ _
.oo_ `
positionoo` h
)ooh i
.ooi j

normalizedooj t
;oot u
}pp 
elseqq 
ifqq 
(qq 
nextqq 
>qq 
-qq 
$numqq 
&&qq !
previousqq" *
>qq+ ,
-qq- .
$numqq. /
)qq/ 0
{rr 
Vector3ss 
ass 
=ss 
(ss 
QuadraticPositionss .
(ss. /
pointsss/ 5
[ss5 6
indexss6 ;
]ss; <
,ss< =
pointsss> D
[ssD E
previousssE M
]ssM N
,ssN O
$numssP S
)ssS T
-ssU V
pointsssW ]
[ss] ^
indexss^ c
]ssc d
.ssd e
positionsse m
)ssm n
.ssn o

normalizedsso y
;ssy z
Vector3tt 
btt 
=tt 
(tt 
QuadraticPositiontt .
(tt. /
pointstt/ 5
[tt5 6
indextt6 ;
]tt; <
,tt< =
pointstt> D
[ttD E
nextttE I
]ttI J
,ttJ K
$numttL O
)ttO P
-ttQ R
pointsttS Y
[ttY Z
indexttZ _
]tt_ `
.tt` a
positiontta i
)tti j
.ttj k

normalizedttk u
;ttu v
returnuu 
(uu 
(uu 
auu 
+uu 
buu 
)uu 
*uu  !
$numuu" %
)uu% &
.uu& '

normalizeduu' 1
;uu1 2
}vv 
elseww 
{xx 
returnyy 
Vector3yy 
.yy 
forwardyy &
;yy& '
}zz 
}{{ 	
}|| 
}}} õ´
‡D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Vertex.cs
	namespace		 	
UnityEngine		
 
.		 

ProBuilder		  
{

 
[ 
Serializable 
] 
public 

sealed 
class 
Vertex 
:  

IEquatable! +
<+ ,
Vertex, 2
>2 3
{ 
[ 	
SerializeField	 
] 
Vector3 

m_Position 
; 
[ 	
SerializeField	 
] 
Color 
m_Color 
; 
[ 	
SerializeField	 
] 
Vector3 
m_Normal 
; 
[ 	
SerializeField	 
] 
Vector4 
	m_Tangent 
; 
[ 	
SerializeField	 
] 
Vector2   
m_UV0   
;   
["" 	
SerializeField""	 
]"" 
Vector2## 
m_UV2## 
;## 
[%% 	
SerializeField%%	 
]%% 
Vector4&& 
m_UV3&& 
;&& 
[(( 	
SerializeField((	 
](( 
Vector4)) 
m_UV4)) 
;)) 
[++ 	
SerializeField++	 
]++ 

MeshArrays,, 
m_Attributes,, 
;,,  
public22 
Vector322 
position22 
{33 	
get44 
{44 
return44 

m_Position44 #
;44# $
}44% &
set55 
{66 
hasPosition77 
=77 
true77 "
;77" #

m_Position88 
=88 
value88 "
;88" #
}99 
}:: 	
public@@ 
Color@@ 
color@@ 
{AA 	
getBB 
{BB 
returnBB 
m_ColorBB  
;BB  !
}BB" #
setCC 
{DD 
hasColorEE 
=EE 
trueEE 
;EE  
m_ColorFF 
=FF 
valueFF 
;FF  
}GG 
}HH 	
publicNN 
Vector3NN 
normalNN 
{OO 	
getPP 
{PP 
returnPP 
m_NormalPP !
;PP! "
}PP# $
setQQ 
{RR 
	hasNormalSS 
=SS 
trueSS  
;SS  !
m_NormalTT 
=TT 
valueTT  
;TT  !
}UU 
}VV 	
public\\ 
Vector4\\ 
tangent\\ 
{]] 	
get^^ 
{^^ 
return^^ 
	m_Tangent^^ "
;^^" #
}^^$ %
set__ 
{`` 

hasTangentaa 
=aa 
trueaa !
;aa! "
	m_Tangentbb 
=bb 
valuebb !
;bb! "
}cc 
}dd 	
publickk 
Vector2kk 
uv0kk 
{ll 	
getmm 
{mm 
returnmm 
m_UV0mm 
;mm 
}mm  !
setnn 
{oo 
hasUV0pp 
=pp 
truepp 
;pp 
m_UV0qq 
=qq 
valueqq 
;qq 
}rr 
}ss 	
publicyy 
Vector2yy 
uv2yy 
{zz 	
get{{ 
{{{ 
return{{ 
m_UV2{{ 
;{{ 
}{{  !
set|| 
{}} 
hasUV2~~ 
=~~ 
true~~ 
;~~ 
m_UV2 
= 
value 
; 
}
€€ 
}
 	
public
‡‡ 
Vector4
‡‡ 
uv3
‡‡ 
{
ˆˆ 	
get
‰‰ 
{
‰‰ 
return
‰‰ 
m_UV3
‰‰ 
;
‰‰ 
}
‰‰  !
set
ŠŠ 
{
‹‹ 
hasUV3
ŒŒ 
=
ŒŒ 
true
ŒŒ 
;
ŒŒ 
m_UV3
 
=
 
value
 
;
 
}
 
}
 	
public
•• 
Vector4
•• 
uv4
•• 
{
–– 	
get
—— 
{
—— 
return
—— 
m_UV4
—— 
;
—— 
}
——  !
set
˜˜ 
{
™™ 
hasUV4
šš 
=
šš 
true
šš 
;
šš 
m_UV4
›› 
=
›› 
value
›› 
;
›› 
}
œœ 
}
 	
internal
ŸŸ 

MeshArrays
ŸŸ 

attributes
ŸŸ &
{
   	
get
¡¡ 
{
¡¡ 
return
¡¡ 
m_Attributes
¡¡ %
;
¡¡% &
}
¡¡' (
}
¢¢ 	
public
©© 
bool
©© 
	HasArrays
©© 
(
©© 

MeshArrays
©© (
	attribute
©©) 2
)
©©2 3
{
ªª 	
return
«« 
(
«« 
m_Attributes
««  
&
««! "
	attribute
««# ,
)
««, -
==
««. 0
	attribute
««1 :
;
««: ;
}
¬¬ 	
bool
®® 
hasPosition
®® 
{
¯¯ 	
get
°° 
{
°° 
return
°° 
(
°° 
m_Attributes
°° &
&
°°' (

MeshArrays
°°) 3
.
°°3 4
Position
°°4 <
)
°°< =
==
°°> @

MeshArrays
°°A K
.
°°K L
Position
°°L T
;
°°T U
}
°°V W
set
±± 
{
±± 
m_Attributes
±± 
=
±±  
value
±±! &
?
±±' (
(
±±) *
m_Attributes
±±* 6
|
±±7 8

MeshArrays
±±9 C
.
±±C D
Position
±±D L
)
±±L M
:
±±N O
(
±±P Q
m_Attributes
±±Q ]
&
±±^ _
~
±±` a
(
±±a b

MeshArrays
±±b l
.
±±l m
Position
±±m u
)
±±u v
)
±±v w
;
±±w x
}
±±y z
}
²² 	
bool
´´ 
hasColor
´´ 
{
µµ 	
get
¶¶ 
{
¶¶ 
return
¶¶ 
(
¶¶ 
m_Attributes
¶¶ &
&
¶¶' (

MeshArrays
¶¶) 3
.
¶¶3 4
Color
¶¶4 9
)
¶¶9 :
==
¶¶; =

MeshArrays
¶¶> H
.
¶¶H I
Color
¶¶I N
;
¶¶N O
}
¶¶P Q
set
·· 
{
·· 
m_Attributes
·· 
=
··  
value
··! &
?
··' (
(
··) *
m_Attributes
··* 6
|
··7 8

MeshArrays
··9 C
.
··C D
Color
··D I
)
··I J
:
··K L
(
··M N
m_Attributes
··N Z
&
··[ \
~
··] ^
(
··^ _

MeshArrays
··_ i
.
··i j
Color
··j o
)
··o p
)
··p q
;
··q r
}
··s t
}
¸¸ 	
bool
ºº 
	hasNormal
ºº 
{
»» 	
get
¼¼ 
{
¼¼ 
return
¼¼ 
(
¼¼ 
m_Attributes
¼¼ &
&
¼¼' (

MeshArrays
¼¼) 3
.
¼¼3 4
Normal
¼¼4 :
)
¼¼: ;
==
¼¼< >

MeshArrays
¼¼? I
.
¼¼I J
Normal
¼¼J P
;
¼¼P Q
}
¼¼R S
set
½½ 
{
½½ 
m_Attributes
½½ 
=
½½  
value
½½! &
?
½½' (
(
½½) *
m_Attributes
½½* 6
|
½½7 8

MeshArrays
½½9 C
.
½½C D
Normal
½½D J
)
½½J K
:
½½L M
(
½½N O
m_Attributes
½½O [
&
½½\ ]
~
½½^ _
(
½½_ `

MeshArrays
½½` j
.
½½j k
Normal
½½k q
)
½½q r
)
½½r s
;
½½s t
}
½½u v
}
¾¾ 	
bool
ÀÀ 

hasTangent
ÀÀ 
{
ÁÁ 	
get
ÂÂ 
{
ÂÂ 
return
ÂÂ 
(
ÂÂ 
m_Attributes
ÂÂ &
&
ÂÂ' (

MeshArrays
ÂÂ) 3
.
ÂÂ3 4
Tangent
ÂÂ4 ;
)
ÂÂ; <
==
ÂÂ= ?

MeshArrays
ÂÂ@ J
.
ÂÂJ K
Tangent
ÂÂK R
;
ÂÂR S
}
ÂÂT U
set
ÃÃ 
{
ÃÃ 
m_Attributes
ÃÃ 
=
ÃÃ  
value
ÃÃ! &
?
ÃÃ' (
(
ÃÃ) *
m_Attributes
ÃÃ* 6
|
ÃÃ7 8

MeshArrays
ÃÃ9 C
.
ÃÃC D
Tangent
ÃÃD K
)
ÃÃK L
:
ÃÃM N
(
ÃÃO P
m_Attributes
ÃÃP \
&
ÃÃ] ^
~
ÃÃ_ `
(
ÃÃ` a

MeshArrays
ÃÃa k
.
ÃÃk l
Tangent
ÃÃl s
)
ÃÃs t
)
ÃÃt u
;
ÃÃu v
}
ÃÃw x
}
ÄÄ 	
bool
ÆÆ 
hasUV0
ÆÆ 
{
ÇÇ 	
get
ÈÈ 
{
ÈÈ 
return
ÈÈ 
(
ÈÈ 
m_Attributes
ÈÈ &
&
ÈÈ' (

MeshArrays
ÈÈ) 3
.
ÈÈ3 4
Texture0
ÈÈ4 <
)
ÈÈ< =
==
ÈÈ> @

MeshArrays
ÈÈA K
.
ÈÈK L
Texture0
ÈÈL T
;
ÈÈT U
}
ÈÈV W
set
ÉÉ 
{
ÉÉ 
m_Attributes
ÉÉ 
=
ÉÉ  
value
ÉÉ! &
?
ÉÉ' (
(
ÉÉ) *
m_Attributes
ÉÉ* 6
|
ÉÉ7 8

MeshArrays
ÉÉ9 C
.
ÉÉC D
Texture0
ÉÉD L
)
ÉÉL M
:
ÉÉN O
(
ÉÉP Q
m_Attributes
ÉÉQ ]
&
ÉÉ^ _
~
ÉÉ` a
(
ÉÉa b

MeshArrays
ÉÉb l
.
ÉÉl m
Texture0
ÉÉm u
)
ÉÉu v
)
ÉÉv w
;
ÉÉw x
}
ÉÉy z
}
ÊÊ 	
bool
ÌÌ 
hasUV2
ÌÌ 
{
ÍÍ 	
get
ÎÎ 
{
ÎÎ 
return
ÎÎ 
(
ÎÎ 
m_Attributes
ÎÎ &
&
ÎÎ' (

MeshArrays
ÎÎ) 3
.
ÎÎ3 4
Texture1
ÎÎ4 <
)
ÎÎ< =
==
ÎÎ> @

MeshArrays
ÎÎA K
.
ÎÎK L
Texture1
ÎÎL T
;
ÎÎT U
}
ÎÎV W
set
ÏÏ 
{
ÏÏ 
m_Attributes
ÏÏ 
=
ÏÏ  
value
ÏÏ! &
?
ÏÏ' (
(
ÏÏ) *
m_Attributes
ÏÏ* 6
|
ÏÏ7 8

MeshArrays
ÏÏ9 C
.
ÏÏC D
Texture1
ÏÏD L
)
ÏÏL M
:
ÏÏN O
(
ÏÏP Q
m_Attributes
ÏÏQ ]
&
ÏÏ^ _
~
ÏÏ` a
(
ÏÏa b

MeshArrays
ÏÏb l
.
ÏÏl m
Texture1
ÏÏm u
)
ÏÏu v
)
ÏÏv w
;
ÏÏw x
}
ÏÏy z
}
ĞĞ 	
bool
ÒÒ 
hasUV3
ÒÒ 
{
ÓÓ 	
get
ÔÔ 
{
ÔÔ 
return
ÔÔ 
(
ÔÔ 
m_Attributes
ÔÔ &
&
ÔÔ' (

MeshArrays
ÔÔ) 3
.
ÔÔ3 4
Texture2
ÔÔ4 <
)
ÔÔ< =
==
ÔÔ> @

MeshArrays
ÔÔA K
.
ÔÔK L
Texture2
ÔÔL T
;
ÔÔT U
}
ÔÔV W
set
ÕÕ 
{
ÕÕ 
m_Attributes
ÕÕ 
=
ÕÕ  
value
ÕÕ! &
?
ÕÕ' (
(
ÕÕ) *
m_Attributes
ÕÕ* 6
|
ÕÕ7 8

MeshArrays
ÕÕ9 C
.
ÕÕC D
Texture2
ÕÕD L
)
ÕÕL M
:
ÕÕN O
(
ÕÕP Q
m_Attributes
ÕÕQ ]
&
ÕÕ^ _
~
ÕÕ` a
(
ÕÕa b

MeshArrays
ÕÕb l
.
ÕÕl m
Texture2
ÕÕm u
)
ÕÕu v
)
ÕÕv w
;
ÕÕw x
}
ÕÕy z
}
ÖÖ 	
bool
ØØ 
hasUV4
ØØ 
{
ÙÙ 	
get
ÚÚ 
{
ÚÚ 
return
ÚÚ 
(
ÚÚ 
m_Attributes
ÚÚ &
&
ÚÚ' (

MeshArrays
ÚÚ) 3
.
ÚÚ3 4
Texture3
ÚÚ4 <
)
ÚÚ< =
==
ÚÚ> @

MeshArrays
ÚÚA K
.
ÚÚK L
Texture3
ÚÚL T
;
ÚÚT U
}
ÚÚV W
set
ÛÛ 
{
ÛÛ 
m_Attributes
ÛÛ 
=
ÛÛ  
value
ÛÛ! &
?
ÛÛ' (
(
ÛÛ) *
m_Attributes
ÛÛ* 6
|
ÛÛ7 8

MeshArrays
ÛÛ9 C
.
ÛÛC D
Texture3
ÛÛD L
)
ÛÛL M
:
ÛÛN O
(
ÛÛP Q
m_Attributes
ÛÛQ ]
&
ÛÛ^ _
~
ÛÛ` a
(
ÛÛa b

MeshArrays
ÛÛb l
.
ÛÛl m
Texture3
ÛÛm u
)
ÛÛu v
)
ÛÛv w
;
ÛÛw x
}
ÛÛy z
}
ÜÜ 	
public
áá 
Vertex
áá 
(
áá 
)
áá 
{
ââ 	
}
ãã 	
public
êê 
override
êê 
bool
êê 
Equals
êê #
(
êê# $
object
êê$ *
obj
êê+ .
)
êê. /
{
ëë 	
return
ìì 
obj
ìì 
is
ìì 
Vertex
ìì  
&&
ìì! #
Equals
ìì$ *
(
ìì* +
(
ìì+ ,
Vertex
ìì, 2
)
ìì2 3
obj
ìì3 6
)
ìì6 7
;
ìì7 8
}
íí 	
public
ôô 
bool
ôô 
Equals
ôô 
(
ôô 
Vertex
ôô !
other
ôô" '
)
ôô' (
{
õõ 	
if
öö 
(
öö 
ReferenceEquals
öö 
(
öö  
other
öö  %
,
öö% &
null
öö' +
)
öö+ ,
)
öö, -
return
÷÷ 
false
÷÷ 
;
÷÷ 
return
ùù 
Math
ùù 
.
ùù 
Approx3
ùù 
(
ùù  

m_Position
ùù  *
,
ùù* +
other
ùù, 1
.
ùù1 2

m_Position
ùù2 <
)
ùù< =
&&
ùù> @
Math
úú 
.
úú 
ApproxC
úú 
(
úú 
m_Color
úú $
,
úú$ %
other
úú& +
.
úú+ ,
m_Color
úú, 3
)
úú3 4
&&
úú5 7
Math
ûû 
.
ûû 
Approx3
ûû 
(
ûû 
m_Normal
ûû %
,
ûû% &
other
ûû' ,
.
ûû, -
m_Normal
ûû- 5
)
ûû5 6
&&
ûû7 9
Math
üü 
.
üü 
Approx4
üü 
(
üü 
	m_Tangent
üü &
,
üü& '
other
üü( -
.
üü- .
	m_Tangent
üü. 7
)
üü7 8
&&
üü9 ;
Math
ıı 
.
ıı 
Approx2
ıı 
(
ıı 
m_UV0
ıı "
,
ıı" #
other
ıı$ )
.
ıı) *
m_UV0
ıı* /
)
ıı/ 0
&&
ıı1 3
Math
şş 
.
şş 
Approx2
şş 
(
şş 
m_UV2
şş "
,
şş" #
other
şş$ )
.
şş) *
m_UV2
şş* /
)
şş/ 0
&&
şş1 3
Math
ÿÿ 
.
ÿÿ 
Approx4
ÿÿ 
(
ÿÿ 
m_UV3
ÿÿ "
,
ÿÿ" #
other
ÿÿ$ )
.
ÿÿ) *
m_UV3
ÿÿ* /
)
ÿÿ/ 0
&&
ÿÿ1 3
Math
€€ 
.
€€ 
Approx4
€€ 
(
€€ 
m_UV4
€€ "
,
€€" #
other
€€$ )
.
€€) *
m_UV4
€€* /
)
€€/ 0
;
€€0 1
}
 	
public
ƒƒ 
bool
ƒƒ 
Equals
ƒƒ 
(
ƒƒ 
Vertex
ƒƒ !
other
ƒƒ" '
,
ƒƒ' (

MeshArrays
ƒƒ) 3
mask
ƒƒ4 8
)
ƒƒ8 9
{
„„ 	
if
…… 
(
…… 
ReferenceEquals
…… 
(
……  
other
……  %
,
……% &
null
……' +
)
……+ ,
)
……, -
return
†† 
false
†† 
;
†† 
return
ˆˆ 
(
ˆˆ 
(
ˆˆ 
mask
ˆˆ 
&
ˆˆ 

MeshArrays
ˆˆ &
.
ˆˆ& '
Position
ˆˆ' /
)
ˆˆ/ 0
!=
ˆˆ1 3

MeshArrays
ˆˆ4 >
.
ˆˆ> ?
Position
ˆˆ? G
||
ˆˆH J
Math
ˆˆK O
.
ˆˆO P
Approx3
ˆˆP W
(
ˆˆW X

m_Position
ˆˆX b
,
ˆˆb c
other
ˆˆd i
.
ˆˆi j

m_Position
ˆˆj t
)
ˆˆt u
)
ˆˆu v
&&
ˆˆw y
(
‰‰ 
(
‰‰ 
mask
‰‰ 
&
‰‰ 

MeshArrays
‰‰ #
.
‰‰# $
Color
‰‰$ )
)
‰‰) *
!=
‰‰+ -

MeshArrays
‰‰. 8
.
‰‰8 9
Color
‰‰9 >
||
‰‰? A
Math
‰‰B F
.
‰‰F G
ApproxC
‰‰G N
(
‰‰N O
m_Color
‰‰O V
,
‰‰V W
other
‰‰X ]
.
‰‰] ^
m_Color
‰‰^ e
)
‰‰e f
)
‰‰f g
&&
‰‰h j
(
ŠŠ 
(
ŠŠ 
mask
ŠŠ 
&
ŠŠ 

MeshArrays
ŠŠ #
.
ŠŠ# $
Normal
ŠŠ$ *
)
ŠŠ* +
!=
ŠŠ, .

MeshArrays
ŠŠ/ 9
.
ŠŠ9 :
Normal
ŠŠ: @
||
ŠŠA C
Math
ŠŠD H
.
ŠŠH I
Approx3
ŠŠI P
(
ŠŠP Q
m_Normal
ŠŠQ Y
,
ŠŠY Z
other
ŠŠ[ `
.
ŠŠ` a
m_Normal
ŠŠa i
)
ŠŠi j
)
ŠŠj k
&&
ŠŠl n
(
‹‹ 
(
‹‹ 
mask
‹‹ 
&
‹‹ 

MeshArrays
‹‹ #
.
‹‹# $
Tangent
‹‹$ +
)
‹‹+ ,
!=
‹‹- /

MeshArrays
‹‹0 :
.
‹‹: ;
Tangent
‹‹; B
||
‹‹C E
Math
‹‹F J
.
‹‹J K
Approx4
‹‹K R
(
‹‹R S
	m_Tangent
‹‹S \
,
‹‹\ ]
other
‹‹^ c
.
‹‹c d
	m_Tangent
‹‹d m
)
‹‹m n
)
‹‹n o
&&
‹‹p r
(
ŒŒ 
(
ŒŒ 
mask
ŒŒ 
&
ŒŒ 

MeshArrays
ŒŒ #
.
ŒŒ# $
Texture0
ŒŒ$ ,
)
ŒŒ, -
!=
ŒŒ. 0

MeshArrays
ŒŒ1 ;
.
ŒŒ; <
Texture0
ŒŒ< D
||
ŒŒE G
Math
ŒŒH L
.
ŒŒL M
Approx2
ŒŒM T
(
ŒŒT U
m_UV0
ŒŒU Z
,
ŒŒZ [
other
ŒŒ\ a
.
ŒŒa b
m_UV0
ŒŒb g
)
ŒŒg h
)
ŒŒh i
&&
ŒŒj l
(
 
(
 
mask
 
&
 

MeshArrays
 #
.
# $
Texture1
$ ,
)
, -
!=
. 0

MeshArrays
1 ;
.
; <
Texture1
< D
||
E G
Math
H L
.
L M
Approx2
M T
(
T U
m_UV2
U Z
,
Z [
other
\ a
.
a b
m_UV2
b g
)
g h
)
h i
&&
j l
(
 
(
 
mask
 
&
 

MeshArrays
 #
.
# $
Texture2
$ ,
)
, -
!=
. 0

MeshArrays
1 ;
.
; <
Texture2
< D
||
E G
Math
H L
.
L M
Approx4
M T
(
T U
m_UV3
U Z
,
Z [
other
\ a
.
a b
m_UV3
b g
)
g h
)
h i
&&
j l
(
 
(
 
mask
 
&
 

MeshArrays
 #
.
# $
Texture3
$ ,
)
, -
!=
. 0

MeshArrays
1 ;
.
; <
Texture3
< D
||
E G
Math
H L
.
L M
Approx4
M T
(
T U
m_UV4
U Z
,
Z [
other
\ a
.
a b
m_UV4
b g
)
g h
)
h i
;
i j
}
 	
public
–– 
override
–– 
int
–– 
GetHashCode
–– '
(
––' (
)
––( )
{
—— 	
	unchecked
™™ 
{
šš 
int
›› 
hash
›› 
=
›› 
$num
›› 
+
››  

VectorHash
››! +
.
››+ ,
GetHashCode
››, 7
(
››7 8
position
››8 @
)
››@ A
;
››A B
hash
œœ 
=
œœ 
hash
œœ 
*
œœ 
$num
œœ  
+
œœ! "

VectorHash
œœ# -
.
œœ- .
GetHashCode
œœ. 9
(
œœ9 :
uv0
œœ: =
)
œœ= >
;
œœ> ?
hash
 
=
 
hash
 
*
 
$num
  
+
! "

VectorHash
# -
.
- .
GetHashCode
. 9
(
9 :
normal
: @
)
@ A
;
A B
return
 
hash
 
;
 
}
ŸŸ 
}
   	
public
¦¦ 
Vertex
¦¦ 
(
¦¦ 
Vertex
¦¦ 
vertex
¦¦ #
)
¦¦# $
{
§§ 	
if
¨¨ 
(
¨¨ 
vertex
¨¨ 
==
¨¨ 
null
¨¨ 
)
¨¨ 
throw
©© 
new
©© #
ArgumentNullException
©© /
(
©©/ 0
$str
©©0 8
)
©©8 9
;
©©9 :

m_Position
«« 
=
«« 
vertex
«« 
.
««  

m_Position
««  *
;
««* +
hasPosition
¬¬ 
=
¬¬ 
vertex
¬¬  
.
¬¬  !
hasPosition
¬¬! ,
;
¬¬, -
m_Color
­­ 
=
­­ 
vertex
­­ 
.
­­ 
m_Color
­­ $
;
­­$ %
hasColor
®® 
=
®® 
vertex
®® 
.
®® 
hasColor
®® &
;
®®& '
m_UV0
¯¯ 
=
¯¯ 
vertex
¯¯ 
.
¯¯ 
m_UV0
¯¯  
;
¯¯  !
hasUV0
°° 
=
°° 
vertex
°° 
.
°° 
hasUV0
°° "
;
°°" #
m_Normal
±± 
=
±± 
vertex
±± 
.
±± 
m_Normal
±± &
;
±±& '
	hasNormal
²² 
=
²² 
vertex
²² 
.
²² 
	hasNormal
²² (
;
²²( )
	m_Tangent
³³ 
=
³³ 
vertex
³³ 
.
³³ 
	m_Tangent
³³ (
;
³³( )

hasTangent
´´ 
=
´´ 
vertex
´´ 
.
´´  

hasTangent
´´  *
;
´´* +
m_UV2
µµ 
=
µµ 
vertex
µµ 
.
µµ 
m_UV2
µµ  
;
µµ  !
hasUV2
¶¶ 
=
¶¶ 
vertex
¶¶ 
.
¶¶ 
hasUV2
¶¶ "
;
¶¶" #
m_UV3
·· 
=
·· 
vertex
·· 
.
·· 
m_UV3
··  
;
··  !
hasUV3
¸¸ 
=
¸¸ 
vertex
¸¸ 
.
¸¸ 
hasUV3
¸¸ "
;
¸¸" #
m_UV4
¹¹ 
=
¹¹ 
vertex
¹¹ 
.
¹¹ 
m_UV4
¹¹  
;
¹¹  !
hasUV4
ºº 
=
ºº 
vertex
ºº 
.
ºº 
hasUV4
ºº "
;
ºº" #
}
»» 	
public
¾¾ 
static
¾¾ 
bool
¾¾ 
operator
¾¾ #
==
¾¾# %
(
¾¾% &
Vertex
¾¾& ,
a
¾¾- .
,
¾¾. /
Vertex
¾¾0 6
b
¾¾7 8
)
¾¾8 9
{
¿¿ 	
if
ÀÀ 
(
ÀÀ 
ReferenceEquals
ÀÀ 
(
ÀÀ  
a
ÀÀ  !
,
ÀÀ! "
b
ÀÀ# $
)
ÀÀ$ %
)
ÀÀ% &
return
ÁÁ 
true
ÁÁ 
;
ÁÁ 
if
ÃÃ 
(
ÃÃ 
object
ÃÃ 
.
ÃÃ 
ReferenceEquals
ÃÃ &
(
ÃÃ& '
a
ÃÃ' (
,
ÃÃ( )
null
ÃÃ* .
)
ÃÃ. /
||
ÃÃ0 2
object
ÃÃ3 9
.
ÃÃ9 :
ReferenceEquals
ÃÃ: I
(
ÃÃI J
b
ÃÃJ K
,
ÃÃK L
null
ÃÃM Q
)
ÃÃQ R
)
ÃÃR S
return
ÄÄ 
false
ÄÄ 
;
ÄÄ 
return
ÆÆ 
a
ÆÆ 
.
ÆÆ 
Equals
ÆÆ 
(
ÆÆ 
b
ÆÆ 
)
ÆÆ 
;
ÆÆ 
}
ÇÇ 	
public
ÏÏ 
static
ÏÏ 
bool
ÏÏ 
operator
ÏÏ #
!=
ÏÏ# %
(
ÏÏ% &
Vertex
ÏÏ& ,
a
ÏÏ- .
,
ÏÏ. /
Vertex
ÏÏ0 6
b
ÏÏ7 8
)
ÏÏ8 9
{
ĞĞ 	
return
ÑÑ 
!
ÑÑ 
(
ÑÑ 
a
ÑÑ 
==
ÑÑ 
b
ÑÑ 
)
ÑÑ 
;
ÑÑ 
}
ÒÒ 	
public
İİ 
static
İİ 
Vertex
İİ 
operator
İİ %
+
İİ% &
(
İİ& '
Vertex
İİ' -
a
İİ. /
,
İİ/ 0
Vertex
İİ1 7
b
İİ8 9
)
İİ9 :
{
ŞŞ 	
return
ßß 
Add
ßß 
(
ßß 
a
ßß 
,
ßß 
b
ßß 
)
ßß 
;
ßß 
}
àà 	
public
ëë 
static
ëë 
Vertex
ëë 
Add
ëë  
(
ëë  !
Vertex
ëë! '
a
ëë( )
,
ëë) *
Vertex
ëë+ 1
b
ëë2 3
)
ëë3 4
{
ìì 	
Vertex
íí 
v
íí 
=
íí 
new
íí 
Vertex
íí !
(
íí! "
a
íí" #
)
íí# $
;
íí$ %
v
îî 
.
îî 
Add
îî 
(
îî 
b
îî 
)
îî 
;
îî 
return
ïï 
v
ïï 
;
ïï 
}
ğğ 	
public
ùù 
void
ùù 
Add
ùù 
(
ùù 
Vertex
ùù 
b
ùù  
)
ùù  !
{
úú 	
if
ûû 
(
ûû 
b
ûû 
==
ûû 
null
ûû 
)
ûû 
throw
üü 
new
üü #
ArgumentNullException
üü /
(
üü/ 0
$str
üü0 3
)
üü3 4
;
üü4 5

m_Position
şş 
+=
şş 
b
şş 
.
şş 

m_Position
şş &
;
şş& '
m_Color
ÿÿ 
+=
ÿÿ 
b
ÿÿ 
.
ÿÿ 
m_Color
ÿÿ  
;
ÿÿ  !
m_Normal
€€ 
+=
€€ 
b
€€ 
.
€€ 
m_Normal
€€ "
;
€€" #
	m_Tangent
 
+=
 
b
 
.
 
	m_Tangent
 $
;
$ %
m_UV0
‚‚ 
+=
‚‚ 
b
‚‚ 
.
‚‚ 
m_UV0
‚‚ 
;
‚‚ 
m_UV2
ƒƒ 
+=
ƒƒ 
b
ƒƒ 
.
ƒƒ 
m_UV2
ƒƒ 
;
ƒƒ 
m_UV3
„„ 
+=
„„ 
b
„„ 
.
„„ 
m_UV3
„„ 
;
„„ 
m_UV4
…… 
+=
…… 
b
…… 
.
…… 
m_UV4
…… 
;
…… 
}
†† 	
public
‘‘ 
static
‘‘ 
Vertex
‘‘ 
operator
‘‘ %
-
‘‘% &
(
‘‘& '
Vertex
‘‘' -
a
‘‘. /
,
‘‘/ 0
Vertex
‘‘1 7
b
‘‘8 9
)
‘‘9 :
{
’’ 	
return
““ 
Subtract
““ 
(
““ 
a
““ 
,
““ 
b
““  
)
““  !
;
““! "
}
”” 	
public
ŸŸ 
static
ŸŸ 
Vertex
ŸŸ 
Subtract
ŸŸ %
(
ŸŸ% &
Vertex
ŸŸ& ,
a
ŸŸ- .
,
ŸŸ. /
Vertex
ŸŸ0 6
b
ŸŸ7 8
)
ŸŸ8 9
{
   	
var
¡¡ 
c
¡¡ 
=
¡¡ 
new
¡¡ 
Vertex
¡¡ 
(
¡¡ 
a
¡¡  
)
¡¡  !
;
¡¡! "
c
¢¢ 
.
¢¢ 
Subtract
¢¢ 
(
¢¢ 
b
¢¢ 
)
¢¢ 
;
¢¢ 
return
££ 
c
££ 
;
££ 
}
¤¤ 	
public
­­ 
void
­­ 
Subtract
­­ 
(
­­ 
Vertex
­­ #
b
­­$ %
)
­­% &
{
®® 	
if
¯¯ 
(
¯¯ 
b
¯¯ 
==
¯¯ 
null
¯¯ 
)
¯¯ 
throw
°° 
new
°° #
ArgumentNullException
°° /
(
°°/ 0
$str
°°0 3
)
°°3 4
;
°°4 5

m_Position
²² 
-=
²² 
b
²² 
.
²² 

m_Position
²² &
;
²²& '
m_Color
³³ 
-=
³³ 
b
³³ 
.
³³ 
m_Color
³³  
;
³³  !
m_Normal
´´ 
-=
´´ 
b
´´ 
.
´´ 
m_Normal
´´ "
;
´´" #
	m_Tangent
µµ 
-=
µµ 
b
µµ 
.
µµ 
	m_Tangent
µµ $
;
µµ$ %
m_UV0
¶¶ 
-=
¶¶ 
b
¶¶ 
.
¶¶ 
m_UV0
¶¶ 
;
¶¶ 
m_UV2
·· 
-=
·· 
b
·· 
.
·· 
m_UV2
·· 
;
·· 
m_UV3
¸¸ 
-=
¸¸ 
b
¸¸ 
.
¸¸ 
m_UV3
¸¸ 
;
¸¸ 
m_UV4
¹¹ 
-=
¹¹ 
b
¹¹ 
.
¹¹ 
m_UV4
¹¹ 
;
¹¹ 
}
ºº 	
public
ÅÅ 
static
ÅÅ 
Vertex
ÅÅ 
operator
ÅÅ %
*
ÅÅ% &
(
ÅÅ& '
Vertex
ÅÅ' -
a
ÅÅ. /
,
ÅÅ/ 0
float
ÅÅ1 6
value
ÅÅ7 <
)
ÅÅ< =
{
ÆÆ 	
return
ÇÇ 
Multiply
ÇÇ 
(
ÇÇ 
a
ÇÇ 
,
ÇÇ 
value
ÇÇ $
)
ÇÇ$ %
;
ÇÇ% &
}
ÈÈ 	
public
ĞĞ 
static
ĞĞ 
Vertex
ĞĞ 
Multiply
ĞĞ %
(
ĞĞ% &
Vertex
ĞĞ& ,
a
ĞĞ- .
,
ĞĞ. /
float
ĞĞ0 5
value
ĞĞ6 ;
)
ĞĞ; <
{
ÑÑ 	
Vertex
ÒÒ 
v
ÒÒ 
=
ÒÒ 
new
ÒÒ 
Vertex
ÒÒ !
(
ÒÒ! "
a
ÒÒ" #
)
ÒÒ# $
;
ÒÒ$ %
v
ÓÓ 
.
ÓÓ 
Multiply
ÓÓ 
(
ÓÓ 
value
ÓÓ 
)
ÓÓ 
;
ÓÓ 
return
ÔÔ 
v
ÔÔ 
;
ÔÔ 
}
ÕÕ 	
public
ŞŞ 
void
ŞŞ 
Multiply
ŞŞ 
(
ŞŞ 
float
ŞŞ "
value
ŞŞ# (
)
ŞŞ( )
{
ßß 	

m_Position
àà 
*=
àà 
value
àà 
;
àà  
m_Color
áá 
*=
áá 
value
áá 
;
áá 
m_Normal
ââ 
*=
ââ 
value
ââ 
;
ââ 
	m_Tangent
ãã 
*=
ãã 
value
ãã 
;
ãã 
m_UV0
ää 
*=
ää 
value
ää 
;
ää 
m_UV2
åå 
*=
åå 
value
åå 
;
åå 
m_UV3
ææ 
*=
ææ 
value
ææ 
;
ææ 
m_UV4
çç 
*=
çç 
value
çç 
;
çç 
}
èè 	
public
óó 
static
óó 
Vertex
óó 
operator
óó %
/
óó% &
(
óó& '
Vertex
óó' -
a
óó. /
,
óó/ 0
float
óó1 6
value
óó7 <
)
óó< =
{
ôô 	
return
õõ 
Divide
õõ 
(
õõ 
a
õõ 
,
õõ 
value
õõ "
)
õõ" #
;
õõ# $
}
öö 	
public
 
static
 
Vertex
 
Divide
 #
(
# $
Vertex
$ *
a
+ ,
,
, -
float
. 3
value
4 9
)
9 :
{
‚‚ 	
Vertex
ƒƒ 
v
ƒƒ 
=
ƒƒ 
new
ƒƒ 
Vertex
ƒƒ !
(
ƒƒ! "
a
ƒƒ" #
)
ƒƒ# $
;
ƒƒ$ %
v
„„ 
.
„„ 
Divide
„„ 
(
„„ 
value
„„ 
)
„„ 
;
„„ 
return
…… 
v
…… 
;
…… 
}
†† 	
public
 
void
 
Divide
 
(
 
float
  
value
! &
)
& '
{
 	

m_Position
‘‘ 
/=
‘‘ 
value
‘‘ 
;
‘‘  
m_Color
’’ 
/=
’’ 
value
’’ 
;
’’ 
m_Normal
““ 
/=
““ 
value
““ 
;
““ 
	m_Tangent
”” 
/=
”” 
value
”” 
;
”” 
m_UV0
•• 
/=
•• 
value
•• 
;
•• 
m_UV2
–– 
/=
–– 
value
–– 
;
–– 
m_UV3
—— 
/=
—— 
value
—— 
;
—— 
m_UV4
˜˜ 
/=
˜˜ 
value
˜˜ 
;
˜˜ 
}
™™ 	
public
 
void
 
	Normalize
 
(
 
)
 
{
ŸŸ 	

m_Position
   
.
   
	Normalize
    
(
    !
)
  ! "
;
  " #
Vector4
¡¡ 
color4
¡¡ 
=
¡¡ 
m_Color
¡¡ $
;
¡¡$ %
color4
¢¢ 
.
¢¢ 
	Normalize
¢¢ 
(
¢¢ 
)
¢¢ 
;
¢¢ 
m_Color
££ 
=
££ 
color4
££ 
;
££ 
m_Normal
¤¤ 
.
¤¤ 
	Normalize
¤¤ 
(
¤¤ 
)
¤¤  
;
¤¤  !
	m_Tangent
¥¥ 
.
¥¥ 
	Normalize
¥¥ 
(
¥¥  
)
¥¥  !
;
¥¥! "
m_UV0
¦¦ 
.
¦¦ 
	Normalize
¦¦ 
(
¦¦ 
)
¦¦ 
;
¦¦ 
m_UV2
§§ 
.
§§ 
	Normalize
§§ 
(
§§ 
)
§§ 
;
§§ 
m_UV3
¨¨ 
.
¨¨ 
	Normalize
¨¨ 
(
¨¨ 
)
¨¨ 
;
¨¨ 
m_UV4
©© 
.
©© 
	Normalize
©© 
(
©© 
)
©© 
;
©© 
}
ªª 	
public
±± 
string
±± 
ToString
±± 
(
±± 
string
±± %
args
±±& *
=
±±+ ,
null
±±- 1
)
±±1 2
{
²² 	
StringBuilder
³³ 
sb
³³ 
=
³³ 
new
³³ "
StringBuilder
³³# 0
(
³³0 1
)
³³1 2
;
³³2 3
if
´´ 
(
´´ 
hasPosition
´´ 
)
´´ 
sb
´´ 
.
´´  

AppendLine
´´  *
(
´´* +
$str
´´+ 7
+
´´8 9

m_Position
´´: D
.
´´D E
ToString
´´E M
(
´´M N
args
´´N R
)
´´R S
)
´´S T
;
´´T U
if
µµ 
(
µµ 
hasColor
µµ 
)
µµ 
sb
µµ 
.
µµ 

AppendLine
µµ '
(
µµ' (
$str
µµ( 1
+
µµ2 3
m_Color
µµ4 ;
.
µµ; <
ToString
µµ< D
(
µµD E
args
µµE I
)
µµI J
)
µµJ K
;
µµK L
if
¶¶ 
(
¶¶ 
	hasNormal
¶¶ 
)
¶¶ 
sb
¶¶ 
.
¶¶ 

AppendLine
¶¶ (
(
¶¶( )
$str
¶¶) 3
+
¶¶4 5
m_Normal
¶¶6 >
.
¶¶> ?
ToString
¶¶? G
(
¶¶G H
args
¶¶H L
)
¶¶L M
)
¶¶M N
;
¶¶N O
if
·· 
(
·· 

hasTangent
·· 
)
·· 
sb
·· 
.
·· 

AppendLine
·· )
(
··) *
$str
··* 5
+
··6 7
	m_Tangent
··8 A
.
··A B
ToString
··B J
(
··J K
args
··K O
)
··O P
)
··P Q
;
··Q R
if
¸¸ 
(
¸¸ 
hasUV0
¸¸ 
)
¸¸ 
sb
¸¸ 
.
¸¸ 

AppendLine
¸¸ %
(
¸¸% &
$str
¸¸& -
+
¸¸. /
m_UV0
¸¸0 5
.
¸¸5 6
ToString
¸¸6 >
(
¸¸> ?
args
¸¸? C
)
¸¸C D
)
¸¸D E
;
¸¸E F
if
¹¹ 
(
¹¹ 
hasUV2
¹¹ 
)
¹¹ 
sb
¹¹ 
.
¹¹ 

AppendLine
¹¹ %
(
¹¹% &
$str
¹¹& -
+
¹¹. /
m_UV2
¹¹0 5
.
¹¹5 6
ToString
¹¹6 >
(
¹¹> ?
args
¹¹? C
)
¹¹C D
)
¹¹D E
;
¹¹E F
if
ºº 
(
ºº 
hasUV3
ºº 
)
ºº 
sb
ºº 
.
ºº 

AppendLine
ºº %
(
ºº% &
$str
ºº& -
+
ºº. /
m_UV3
ºº0 5
.
ºº5 6
ToString
ºº6 >
(
ºº> ?
args
ºº? C
)
ººC D
)
ººD E
;
ººE F
if
»» 
(
»» 
hasUV4
»» 
)
»» 
sb
»» 
.
»» 

AppendLine
»» %
(
»»% &
$str
»»& -
+
»». /
m_UV4
»»0 5
.
»»5 6
ToString
»»6 >
(
»»> ?
args
»»? C
)
»»C D
)
»»D E
;
»»E F
return
¼¼ 
sb
¼¼ 
.
¼¼ 
ToString
¼¼ 
(
¼¼ 
)
¼¼  
;
¼¼  !
}
½½ 	
public
ÏÏ 
static
ÏÏ 
void
ÏÏ 
	GetArrays
ÏÏ $
(
ÏÏ$ %
IList
ĞĞ 
<
ĞĞ 
Vertex
ĞĞ 
>
ĞĞ 
vertices
ĞĞ "
,
ĞĞ" #
out
ÑÑ 
Vector3
ÑÑ 
[
ÑÑ 
]
ÑÑ 
position
ÑÑ "
,
ÑÑ" #
out
ÒÒ 
Color
ÒÒ 
[
ÒÒ 
]
ÒÒ 
color
ÒÒ 
,
ÒÒ 
out
ÓÓ 
Vector2
ÓÓ 
[
ÓÓ 
]
ÓÓ 
uv0
ÓÓ 
,
ÓÓ 
out
ÔÔ 
Vector3
ÔÔ 
[
ÔÔ 
]
ÔÔ 
normal
ÔÔ  
,
ÔÔ  !
out
ÕÕ 
Vector4
ÕÕ 
[
ÕÕ 
]
ÕÕ 
tangent
ÕÕ !
,
ÕÕ! "
out
ÖÖ 
Vector2
ÖÖ 
[
ÖÖ 
]
ÖÖ 
uv2
ÖÖ 
,
ÖÖ 
out
×× 
List
×× 
<
×× 
Vector4
×× 
>
×× 
uv3
×× !
,
××! "
out
ØØ 
List
ØØ 
<
ØØ 
Vector4
ØØ 
>
ØØ 
uv4
ØØ !
)
ØØ! "
{
ÙÙ 	
	GetArrays
ÚÚ 
(
ÚÚ 
vertices
ÚÚ 
,
ÚÚ 
out
ÚÚ  #
position
ÚÚ$ ,
,
ÚÚ, -
out
ÚÚ. 1
color
ÚÚ2 7
,
ÚÚ7 8
out
ÚÚ9 <
uv0
ÚÚ= @
,
ÚÚ@ A
out
ÚÚB E
normal
ÚÚF L
,
ÚÚL M
out
ÚÚN Q
tangent
ÚÚR Y
,
ÚÚY Z
out
ÚÚ[ ^
uv2
ÚÚ_ b
,
ÚÚb c
out
ÚÚd g
uv3
ÚÚh k
,
ÚÚk l
out
ÚÚm p
uv4
ÚÚq t
,
ÚÚt u

MeshArraysÚÚv €
.ÚÚ€ 
AllÚÚ „
)ÚÚ„ …
;ÚÚ… †
}
ÛÛ 	
public
ïï 
static
ïï 
void
ïï 
	GetArrays
ïï $
(
ïï$ %
IList
ğğ 
<
ğğ 
Vertex
ğğ 
>
ğğ 
vertices
ğğ "
,
ğğ" #
out
ññ 
Vector3
ññ 
[
ññ 
]
ññ 
position
ññ "
,
ññ" #
out
òò 
Color
òò 
[
òò 
]
òò 
color
òò 
,
òò 
out
óó 
Vector2
óó 
[
óó 
]
óó 
uv0
óó 
,
óó 
out
ôô 
Vector3
ôô 
[
ôô 
]
ôô 
normal
ôô  
,
ôô  !
out
õõ 
Vector4
õõ 
[
õõ 
]
õõ 
tangent
õõ !
,
õõ! "
out
öö 
Vector2
öö 
[
öö 
]
öö 
uv2
öö 
,
öö 
out
÷÷ 
List
÷÷ 
<
÷÷ 
Vector4
÷÷ 
>
÷÷ 
uv3
÷÷ !
,
÷÷! "
out
øø 
List
øø 
<
øø 
Vector4
øø 
>
øø 
uv4
øø !
,
øø! "

MeshArrays
ùù 

attributes
ùù !
)
ùù! "
{
úú 	
if
ûû 
(
ûû 
vertices
ûû 
==
ûû 
null
ûû  
)
ûû  !
throw
üü 
new
üü #
ArgumentNullException
üü /
(
üü/ 0
$str
üü0 :
)
üü: ;
;
üü; <
int
şş 
vc
şş 
=
şş 
vertices
şş 
.
şş 
Count
şş #
;
şş# $
var
ÿÿ 
first
ÿÿ 
=
ÿÿ 
vc
ÿÿ 
<
ÿÿ 
$num
ÿÿ 
?
ÿÿ  
new
ÿÿ! $
Vertex
ÿÿ% +
(
ÿÿ+ ,
)
ÿÿ, -
:
ÿÿ. /
vertices
ÿÿ0 8
[
ÿÿ8 9
$num
ÿÿ9 :
]
ÿÿ: ;
;
ÿÿ; <
bool
 
hasPosition
 
=
 
(
  
(
  !

attributes
! +
&
, -

MeshArrays
. 8
.
8 9
Position
9 A
)
A B
==
C E

MeshArrays
F P
.
P Q
Position
Q Y
)
Y Z
&&
[ ]
first
^ c
.
c d
hasPosition
d o
;
o p
bool
‚‚ 
hasColor
‚‚ 
=
‚‚ 
(
‚‚ 
(
‚‚ 

attributes
‚‚ (
&
‚‚) *

MeshArrays
‚‚+ 5
.
‚‚5 6
Color
‚‚6 ;
)
‚‚; <
==
‚‚= ?

MeshArrays
‚‚@ J
.
‚‚J K
Color
‚‚K P
)
‚‚P Q
&&
‚‚R T
first
‚‚U Z
.
‚‚Z [
hasColor
‚‚[ c
;
‚‚c d
bool
ƒƒ 
hasUv0
ƒƒ 
=
ƒƒ 
(
ƒƒ 
(
ƒƒ 

attributes
ƒƒ &
&
ƒƒ' (

MeshArrays
ƒƒ) 3
.
ƒƒ3 4
Texture0
ƒƒ4 <
)
ƒƒ< =
==
ƒƒ> @

MeshArrays
ƒƒA K
.
ƒƒK L
Texture0
ƒƒL T
)
ƒƒT U
&&
ƒƒV X
first
ƒƒY ^
.
ƒƒ^ _
hasUV0
ƒƒ_ e
;
ƒƒe f
bool
„„ 
	hasNormal
„„ 
=
„„ 
(
„„ 
(
„„ 

attributes
„„ )
&
„„* +

MeshArrays
„„, 6
.
„„6 7
Normal
„„7 =
)
„„= >
==
„„? A

MeshArrays
„„B L
.
„„L M
Normal
„„M S
)
„„S T
&&
„„U W
first
„„X ]
.
„„] ^
	hasNormal
„„^ g
;
„„g h
bool
…… 

hasTangent
…… 
=
…… 
(
…… 
(
……  

attributes
……  *
&
……+ ,

MeshArrays
……- 7
.
……7 8
Tangent
……8 ?
)
……? @
==
……A C

MeshArrays
……D N
.
……N O
Tangent
……O V
)
……V W
&&
……X Z
first
……[ `
.
……` a

hasTangent
……a k
;
……k l
bool
†† 
hasUv2
†† 
=
†† 
(
†† 
(
†† 

attributes
†† &
&
††' (

MeshArrays
††) 3
.
††3 4
Texture1
††4 <
)
††< =
==
††> @

MeshArrays
††A K
.
††K L
Texture1
††L T
)
††T U
&&
††V X
first
††Y ^
.
††^ _
hasUV2
††_ e
;
††e f
bool
‡‡ 
hasUv3
‡‡ 
=
‡‡ 
(
‡‡ 
(
‡‡ 

attributes
‡‡ &
&
‡‡' (

MeshArrays
‡‡) 3
.
‡‡3 4
Texture2
‡‡4 <
)
‡‡< =
==
‡‡> @

MeshArrays
‡‡A K
.
‡‡K L
Texture2
‡‡L T
)
‡‡T U
&&
‡‡V X
first
‡‡Y ^
.
‡‡^ _
hasUV3
‡‡_ e
;
‡‡e f
bool
ˆˆ 
hasUv4
ˆˆ 
=
ˆˆ 
(
ˆˆ 
(
ˆˆ 

attributes
ˆˆ &
&
ˆˆ' (

MeshArrays
ˆˆ) 3
.
ˆˆ3 4
Texture3
ˆˆ4 <
)
ˆˆ< =
==
ˆˆ> @

MeshArrays
ˆˆA K
.
ˆˆK L
Texture3
ˆˆL T
)
ˆˆT U
&&
ˆˆV X
first
ˆˆY ^
.
ˆˆ^ _
hasUV4
ˆˆ_ e
;
ˆˆe f
position
ŠŠ 
=
ŠŠ 
hasPosition
ŠŠ "
?
ŠŠ# $
new
ŠŠ% (
Vector3
ŠŠ) 0
[
ŠŠ0 1
vc
ŠŠ1 3
]
ŠŠ3 4
:
ŠŠ5 6
null
ŠŠ7 ;
;
ŠŠ; <
color
‹‹ 
=
‹‹ 
hasColor
‹‹ 
?
‹‹ 
new
‹‹ "
Color
‹‹# (
[
‹‹( )
vc
‹‹) +
]
‹‹+ ,
:
‹‹- .
null
‹‹/ 3
;
‹‹3 4
uv0
ŒŒ 
=
ŒŒ 
hasUv0
ŒŒ 
?
ŒŒ 
new
ŒŒ 
Vector2
ŒŒ &
[
ŒŒ& '
vc
ŒŒ' )
]
ŒŒ) *
:
ŒŒ+ ,
null
ŒŒ- 1
;
ŒŒ1 2
normal
 
=
 
	hasNormal
 
?
  
new
! $
Vector3
% ,
[
, -
vc
- /
]
/ 0
:
1 2
null
3 7
;
7 8
tangent
 
=
 

hasTangent
  
?
! "
new
# &
Vector4
' .
[
. /
vc
/ 1
]
1 2
:
3 4
null
5 9
;
9 :
uv2
 
=
 
hasUv2
 
?
 
new
 
Vector2
 &
[
& '
vc
' )
]
) *
:
+ ,
null
- 1
;
1 2
uv3
 
=
 
hasUv3
 
?
 
new
 
List
 #
<
# $
Vector4
$ +
>
+ ,
(
, -
vc
- /
)
/ 0
:
1 2
null
3 7
;
7 8
uv4
‘‘ 
=
‘‘ 
hasUv4
‘‘ 
?
‘‘ 
new
‘‘ 
List
‘‘ #
<
‘‘# $
Vector4
‘‘$ +
>
‘‘+ ,
(
‘‘, -
vc
‘‘- /
)
‘‘/ 0
:
‘‘1 2
null
‘‘3 7
;
‘‘7 8
for
““ 
(
““ 
int
““ 
i
““ 
=
““ 
$num
““ 
;
““ 
i
““ 
<
““ 
vc
““  "
;
““" #
i
““$ %
++
““% '
)
““' (
{
”” 
if
•• 
(
•• 
hasPosition
•• 
)
••  
position
••! )
[
••) *
i
••* +
]
••+ ,
=
••- .
vertices
••/ 7
[
••7 8
i
••8 9
]
••9 :
.
••: ;

m_Position
••; E
;
••E F
if
–– 
(
–– 
hasColor
–– 
)
–– 
color
–– #
[
––# $
i
––$ %
]
––% &
=
––' (
vertices
––) 1
[
––1 2
i
––2 3
]
––3 4
.
––4 5
m_Color
––5 <
;
––< =
if
—— 
(
—— 
hasUv0
—— 
)
—— 
uv0
—— 
[
——  
i
——  !
]
——! "
=
——# $
vertices
——% -
[
——- .
i
——. /
]
——/ 0
.
——0 1
m_UV0
——1 6
;
——6 7
if
˜˜ 
(
˜˜ 
	hasNormal
˜˜ 
)
˜˜ 
normal
˜˜ %
[
˜˜% &
i
˜˜& '
]
˜˜' (
=
˜˜) *
vertices
˜˜+ 3
[
˜˜3 4
i
˜˜4 5
]
˜˜5 6
.
˜˜6 7
m_Normal
˜˜7 ?
;
˜˜? @
if
™™ 
(
™™ 

hasTangent
™™ 
)
™™ 
tangent
™™  '
[
™™' (
i
™™( )
]
™™) *
=
™™+ ,
vertices
™™- 5
[
™™5 6
i
™™6 7
]
™™7 8
.
™™8 9
	m_Tangent
™™9 B
;
™™B C
if
šš 
(
šš 
hasUv2
šš 
)
šš 
uv2
šš 
[
šš  
i
šš  !
]
šš! "
=
šš# $
vertices
šš% -
[
šš- .
i
šš. /
]
šš/ 0
.
šš0 1
m_UV2
šš1 6
;
šš6 7
if
›› 
(
›› 
hasUv3
›› 
)
›› 
uv3
›› 
.
››  
Add
››  #
(
››# $
vertices
››$ ,
[
››, -
i
››- .
]
››. /
.
››/ 0
m_UV3
››0 5
)
››5 6
;
››6 7
if
œœ 
(
œœ 
hasUv4
œœ 
)
œœ 
uv4
œœ 
.
œœ  
Add
œœ  #
(
œœ# $
vertices
œœ$ ,
[
œœ, -
i
œœ- .
]
œœ. /
.
œœ/ 0
m_UV4
œœ0 5
)
œœ5 6
;
œœ6 7
}
 
}
 	
public
¥¥ 
static
¥¥ 
void
¥¥ 
SetMesh
¥¥ "
(
¥¥" #
Mesh
¥¥# '
mesh
¥¥( ,
,
¥¥, -
IList
¥¥. 3
<
¥¥3 4
Vertex
¥¥4 :
>
¥¥: ;
vertices
¥¥< D
)
¥¥D E
{
¦¦ 	
if
§§ 
(
§§ 
mesh
§§ 
==
§§ 
null
§§ 
)
§§ 
throw
¨¨ 
new
¨¨ #
ArgumentNullException
¨¨ /
(
¨¨/ 0
$str
¨¨0 6
)
¨¨6 7
;
¨¨7 8
if
ªª 
(
ªª 
vertices
ªª 
==
ªª 
null
ªª  
)
ªª  !
throw
«« 
new
«« #
ArgumentNullException
«« /
(
««/ 0
$str
««0 :
)
««: ;
;
««; <
Vector3
­­ 
[
­­ 
]
­­ 
	positions
­­ 
=
­­  !
null
­­" &
;
­­& '
Color
®® 
[
®® 
]
®® 
colors
®® 
=
®® 
null
®® !
;
®®! "
Vector2
¯¯ 
[
¯¯ 
]
¯¯ 
uv0s
¯¯ 
=
¯¯ 
null
¯¯ !
;
¯¯! "
Vector3
°° 
[
°° 
]
°° 
normals
°° 
=
°° 
null
°°  $
;
°°$ %
Vector4
±± 
[
±± 
]
±± 
tangents
±± 
=
±±  
null
±±! %
;
±±% &
Vector2
²² 
[
²² 
]
²² 
uv2s
²² 
=
²² 
null
²² !
;
²²! "
List
³³ 
<
³³ 
Vector4
³³ 
>
³³ 
uv3s
³³ 
=
³³  
null
³³! %
;
³³% &
List
´´ 
<
´´ 
Vector4
´´ 
>
´´ 
uv4s
´´ 
=
´´  
null
´´! %
;
´´% &
	GetArrays
¶¶ 
(
¶¶ 
vertices
¶¶ 
,
¶¶ 
out
¶¶  #
	positions
¶¶$ -
,
¶¶- .
out
·· 
colors
·· 
,
·· 
out
¸¸ 
uv0s
¸¸ 
,
¸¸ 
out
¹¹ 
normals
¹¹ 
,
¹¹ 
out
ºº 
tangents
ºº 
,
ºº 
out
»» 
uv2s
»» 
,
»» 
out
¼¼ 
uv3s
¼¼ 
,
¼¼ 
out
½½ 
uv4s
½½ 
)
½½ 
;
½½ 
mesh
¿¿ 
.
¿¿ 
Clear
¿¿ 
(
¿¿ 
)
¿¿ 
;
¿¿ 
Vertex
ÁÁ 
first
ÁÁ 
=
ÁÁ 
vertices
ÁÁ #
[
ÁÁ# $
$num
ÁÁ$ %
]
ÁÁ% &
;
ÁÁ& '
if
ÃÃ 
(
ÃÃ 
first
ÃÃ 
.
ÃÃ 
hasPosition
ÃÃ !
)
ÃÃ! "
mesh
ÃÃ# '
.
ÃÃ' (
vertices
ÃÃ( 0
=
ÃÃ1 2
	positions
ÃÃ3 <
;
ÃÃ< =
if
ÄÄ 
(
ÄÄ 
first
ÄÄ 
.
ÄÄ 
hasColor
ÄÄ 
)
ÄÄ 
mesh
ÄÄ  $
.
ÄÄ$ %
colors
ÄÄ% +
=
ÄÄ, -
colors
ÄÄ. 4
;
ÄÄ4 5
if
ÅÅ 
(
ÅÅ 
first
ÅÅ 
.
ÅÅ 
hasUV0
ÅÅ 
)
ÅÅ 
mesh
ÅÅ "
.
ÅÅ" #
uv
ÅÅ# %
=
ÅÅ& '
uv0s
ÅÅ( ,
;
ÅÅ, -
if
ÆÆ 
(
ÆÆ 
first
ÆÆ 
.
ÆÆ 
	hasNormal
ÆÆ 
)
ÆÆ  
mesh
ÆÆ! %
.
ÆÆ% &
normals
ÆÆ& -
=
ÆÆ. /
normals
ÆÆ0 7
;
ÆÆ7 8
if
ÇÇ 
(
ÇÇ 
first
ÇÇ 
.
ÇÇ 

hasTangent
ÇÇ  
)
ÇÇ  !
mesh
ÇÇ" &
.
ÇÇ& '
tangents
ÇÇ' /
=
ÇÇ0 1
tangents
ÇÇ2 :
;
ÇÇ: ;
if
ÈÈ 
(
ÈÈ 
first
ÈÈ 
.
ÈÈ 
hasUV2
ÈÈ 
)
ÈÈ 
mesh
ÈÈ "
.
ÈÈ" #
uv2
ÈÈ# &
=
ÈÈ' (
uv2s
ÈÈ) -
;
ÈÈ- .
if
ÊÊ 
(
ÊÊ 
first
ÊÊ 
.
ÊÊ 
hasUV3
ÊÊ 
)
ÊÊ 
if
ËË 
(
ËË 
uv3s
ËË 
!=
ËË 
null
ËË  
)
ËË  !
mesh
ÌÌ 
.
ÌÌ 
SetUVs
ÌÌ 
(
ÌÌ  
$num
ÌÌ  !
,
ÌÌ! "
uv3s
ÌÌ# '
)
ÌÌ' (
;
ÌÌ( )
if
ÍÍ 
(
ÍÍ 
first
ÍÍ 
.
ÍÍ 
hasUV4
ÍÍ 
)
ÍÍ 
if
ÎÎ 
(
ÎÎ 
uv4s
ÎÎ 
!=
ÎÎ 
null
ÎÎ  
)
ÎÎ  !
mesh
ÏÏ 
.
ÏÏ 
SetUVs
ÏÏ 
(
ÏÏ  
$num
ÏÏ  !
,
ÏÏ! "
uv4s
ÏÏ# '
)
ÏÏ' (
;
ÏÏ( )
}
ÑÑ 	
public
ÙÙ 
static
ÙÙ 
Vertex
ÙÙ 
Average
ÙÙ $
(
ÙÙ$ %
IList
ÙÙ% *
<
ÙÙ* +
Vertex
ÙÙ+ 1
>
ÙÙ1 2
vertices
ÙÙ3 ;
,
ÙÙ; <
IList
ÙÙ= B
<
ÙÙB C
int
ÙÙC F
>
ÙÙF G
indexes
ÙÙH O
=
ÙÙP Q
null
ÙÙR V
)
ÙÙV W
{
ÚÚ 	
if
ÛÛ 
(
ÛÛ 
vertices
ÛÛ 
==
ÛÛ 
null
ÛÛ  
)
ÛÛ  !
throw
ÜÜ 
new
ÜÜ #
ArgumentNullException
ÜÜ /
(
ÜÜ/ 0
$str
ÜÜ0 :
)
ÜÜ: ;
;
ÜÜ; <
Vertex
ŞŞ 
v
ŞŞ 
=
ŞŞ 
new
ŞŞ 
Vertex
ŞŞ !
(
ŞŞ! "
)
ŞŞ" #
;
ŞŞ# $
int
àà 
vertexCount
àà 
=
àà 
indexes
àà %
!=
àà& (
null
àà) -
?
àà. /
indexes
àà0 7
.
àà7 8
Count
àà8 =
:
àà> ?
vertices
àà@ H
.
ààH I
Count
ààI N
;
ààN O
int
ââ 
positionCount
ââ 
=
ââ 
$num
ââ  !
,
ââ! "

colorCount
ãã 
=
ãã 
$num
ãã 
,
ãã 
uv0Count
ää 
=
ää 
$num
ää 
,
ää 
normalCount
åå 
=
åå 
$num
åå 
,
åå  
tangentCount
ææ 
=
ææ 
$num
ææ  
,
ææ  !
uv2Count
çç 
=
çç 
$num
çç 
,
çç 
uv3Count
èè 
=
èè 
$num
èè 
,
èè 
uv4Count
éé 
=
éé 
$num
éé 
;
éé 
for
ëë 
(
ëë 
int
ëë 
i
ëë 
=
ëë 
$num
ëë 
;
ëë 
i
ëë 
<
ëë 
vertexCount
ëë  +
;
ëë+ ,
i
ëë- .
++
ëë. 0
)
ëë0 1
{
ìì 
int
íí 
index
íí 
=
íí 
indexes
íí #
==
íí$ &
null
íí' +
?
íí, -
i
íí. /
:
íí0 1
indexes
íí2 9
[
íí9 :
i
íí: ;
]
íí; <
;
íí< =
if
ğğ 
(
ğğ 
vertices
ğğ 
[
ğğ 
index
ğğ "
]
ğğ" #
.
ğğ# $
hasPosition
ğğ$ /
)
ğğ/ 0
{
ññ 
positionCount
òò !
++
òò! #
;
òò# $
v
óó 
.
óó 

m_Position
óó  
+=
óó! #
vertices
óó$ ,
[
óó, -
index
óó- 2
]
óó2 3
.
óó3 4

m_Position
óó4 >
;
óó> ?
}
ôô 
if
öö 
(
öö 
vertices
öö 
[
öö 
index
öö "
]
öö" #
.
öö# $
hasColor
öö$ ,
)
öö, -
{
÷÷ 

colorCount
øø 
++
øø  
;
øø  !
v
ùù 
.
ùù 
m_Color
ùù 
+=
ùù  
vertices
ùù! )
[
ùù) *
index
ùù* /
]
ùù/ 0
.
ùù0 1
m_Color
ùù1 8
;
ùù8 9
}
úú 
if
üü 
(
üü 
vertices
üü 
[
üü 
index
üü "
]
üü" #
.
üü# $
hasUV0
üü$ *
)
üü* +
{
ıı 
uv0Count
şş 
++
şş 
;
şş 
v
ÿÿ 
.
ÿÿ 
m_UV0
ÿÿ 
+=
ÿÿ 
vertices
ÿÿ '
[
ÿÿ' (
index
ÿÿ( -
]
ÿÿ- .
.
ÿÿ. /
m_UV0
ÿÿ/ 4
;
ÿÿ4 5
}
€€ 
if
‚‚ 
(
‚‚ 
vertices
‚‚ 
[
‚‚ 
index
‚‚ "
]
‚‚" #
.
‚‚# $
	hasNormal
‚‚$ -
)
‚‚- .
{
ƒƒ 
normalCount
„„ 
++
„„ !
;
„„! "
v
…… 
.
…… 
m_Normal
…… 
+=
…… !
vertices
……" *
[
……* +
index
……+ 0
]
……0 1
.
……1 2
m_Normal
……2 :
;
……: ;
}
†† 
if
ˆˆ 
(
ˆˆ 
vertices
ˆˆ 
[
ˆˆ 
index
ˆˆ "
]
ˆˆ" #
.
ˆˆ# $

hasTangent
ˆˆ$ .
)
ˆˆ. /
{
‰‰ 
tangentCount
ŠŠ  
++
ŠŠ  "
;
ŠŠ" #
v
‹‹ 
.
‹‹ 
	m_Tangent
‹‹ 
+=
‹‹  "
vertices
‹‹# +
[
‹‹+ ,
index
‹‹, 1
]
‹‹1 2
.
‹‹2 3
	m_Tangent
‹‹3 <
;
‹‹< =
}
ŒŒ 
if
 
(
 
vertices
 
[
 
index
 "
]
" #
.
# $
hasUV2
$ *
)
* +
{
 
uv2Count
 
++
 
;
 
v
‘‘ 
.
‘‘ 
m_UV2
‘‘ 
+=
‘‘ 
vertices
‘‘ '
[
‘‘' (
index
‘‘( -
]
‘‘- .
.
‘‘. /
m_UV2
‘‘/ 4
;
‘‘4 5
}
’’ 
if
”” 
(
”” 
vertices
”” 
[
”” 
index
”” "
]
””" #
.
””# $
hasUV3
””$ *
)
””* +
{
•• 
uv3Count
–– 
++
–– 
;
–– 
v
—— 
.
—— 
m_UV3
—— 
+=
—— 
vertices
—— '
[
——' (
index
——( -
]
——- .
.
——. /
m_UV3
——/ 4
;
——4 5
}
˜˜ 
if
šš 
(
šš 
vertices
šš 
[
šš 
index
šš "
]
šš" #
.
šš# $
hasUV4
šš$ *
)
šš* +
{
›› 
uv4Count
œœ 
++
œœ 
;
œœ 
v
 
.
 
m_UV4
 
+=
 
vertices
 '
[
' (
index
( -
]
- .
.
. /
m_UV4
/ 4
;
4 5
}
 
}
ŸŸ 
if
¡¡ 
(
¡¡ 
positionCount
¡¡ 
>
¡¡ 
$num
¡¡  !
)
¡¡! "
{
¢¢ 
v
££ 
.
££ 
hasPosition
££ 
=
££ 
true
££  $
;
££$ %
v
¤¤ 
.
¤¤ 

m_Position
¤¤ 
*=
¤¤ 
(
¤¤  !
$num
¤¤! #
/
¤¤$ %
positionCount
¤¤& 3
)
¤¤3 4
;
¤¤4 5
}
¥¥ 
if
§§ 
(
§§ 

colorCount
§§ 
>
§§ 
$num
§§ 
)
§§ 
{
¨¨ 
v
©© 
.
©© 
hasColor
©© 
=
©© 
true
©© !
;
©©! "
v
ªª 
.
ªª 
m_Color
ªª 
*=
ªª 
(
ªª 
$num
ªª  
/
ªª! "

colorCount
ªª# -
)
ªª- .
;
ªª. /
}
«« 
if
­­ 
(
­­ 
uv0Count
­­ 
>
­­ 
$num
­­ 
)
­­ 
{
®® 
v
¯¯ 
.
¯¯ 
hasUV0
¯¯ 
=
¯¯ 
true
¯¯ 
;
¯¯  
v
°° 
.
°° 
m_UV0
°° 
*=
°° 
(
°° 
$num
°° 
/
°°  
uv0Count
°°! )
)
°°) *
;
°°* +
}
±± 
if
´´ 
(
´´ 
normalCount
´´ 
>
´´ 
$num
´´ 
)
´´  
{
µµ 
v
¶¶ 
.
¶¶ 
	hasNormal
¶¶ 
=
¶¶ 
true
¶¶ "
;
¶¶" #
v
·· 
.
·· 
m_Normal
·· 
*=
·· 
(
·· 
$num
·· !
/
··" #
normalCount
··$ /
)
··/ 0
;
··0 1
}
¸¸ 
if
ºº 
(
ºº 
tangentCount
ºº 
>
ºº 
$num
ºº  
)
ºº  !
{
»» 
v
¼¼ 
.
¼¼ 

hasTangent
¼¼ 
=
¼¼ 
true
¼¼ #
;
¼¼# $
v
½½ 
.
½½ 
	m_Tangent
½½ 
*=
½½ 
(
½½  
$num
½½  "
/
½½# $
tangentCount
½½% 1
)
½½1 2
;
½½2 3
}
¾¾ 
if
ÀÀ 
(
ÀÀ 
uv2Count
ÀÀ 
>
ÀÀ 
$num
ÀÀ 
)
ÀÀ 
{
ÁÁ 
v
ÂÂ 
.
ÂÂ 
hasUV2
ÂÂ 
=
ÂÂ 
true
ÂÂ 
;
ÂÂ  
v
ÃÃ 
.
ÃÃ 
m_UV2
ÃÃ 
*=
ÃÃ 
(
ÃÃ 
$num
ÃÃ 
/
ÃÃ  
uv2Count
ÃÃ! )
)
ÃÃ) *
;
ÃÃ* +
}
ÄÄ 
if
ÆÆ 
(
ÆÆ 
uv3Count
ÆÆ 
>
ÆÆ 
$num
ÆÆ 
)
ÆÆ 
{
ÇÇ 
v
ÈÈ 
.
ÈÈ 
hasUV3
ÈÈ 
=
ÈÈ 
true
ÈÈ 
;
ÈÈ  
v
ÉÉ 
.
ÉÉ 
m_UV3
ÉÉ 
*=
ÉÉ 
(
ÉÉ 
$num
ÉÉ 
/
ÉÉ  
uv3Count
ÉÉ! )
)
ÉÉ) *
;
ÉÉ* +
}
ÊÊ 
if
ÌÌ 
(
ÌÌ 
uv4Count
ÌÌ 
>
ÌÌ 
$num
ÌÌ 
)
ÌÌ 
{
ÍÍ 
v
ÎÎ 
.
ÎÎ 
hasUV4
ÎÎ 
=
ÎÎ 
true
ÎÎ 
;
ÎÎ  
v
ÏÏ 
.
ÏÏ 
m_UV4
ÏÏ 
*=
ÏÏ 
(
ÏÏ 
$num
ÏÏ 
/
ÏÏ  
uv4Count
ÏÏ! )
)
ÏÏ) *
;
ÏÏ* +
}
ĞĞ 
return
ÒÒ 
v
ÒÒ 
;
ÒÒ 
}
ÓÓ 	
public
ÜÜ 
static
ÜÜ 
Vertex
ÜÜ 
Mix
ÜÜ  
(
ÜÜ  !
Vertex
ÜÜ! '
x
ÜÜ( )
,
ÜÜ) *
Vertex
ÜÜ+ 1
y
ÜÜ2 3
,
ÜÜ3 4
float
ÜÜ5 :
weight
ÜÜ; A
)
ÜÜA B
{
İİ 	
if
ŞŞ 
(
ŞŞ 
x
ŞŞ 
==
ŞŞ 
null
ŞŞ 
||
ŞŞ 
y
ŞŞ 
==
ŞŞ !
null
ŞŞ" &
)
ŞŞ& '
throw
ßß 
new
ßß #
ArgumentNullException
ßß /
(
ßß/ 0
$str
ßß0 3
,
ßß3 4
$str
ßß5 U
)
ßßU V
;
ßßV W
float
áá 
i
áá 
=
áá 
$num
áá 
-
áá 
weight
áá !
;
áá! "
Vertex
ãã 
v
ãã 
=
ãã 
new
ãã 
Vertex
ãã !
(
ãã! "
)
ãã" #
;
ãã# $
v
åå 
.
åå 

m_Position
åå 
=
åå 
x
åå 
.
åå 

m_Position
åå '
*
åå( )
i
åå* +
+
åå, -
y
åå. /
.
åå/ 0

m_Position
åå0 :
*
åå; <
weight
åå= C
;
ååC D
if
çç 
(
çç 
x
çç 
.
çç 
hasColor
çç 
&&
çç 
y
çç 
.
çç  
hasColor
çç  (
)
çç( )
v
èè 
.
èè 
m_Color
èè 
=
èè 
x
èè 
.
èè 
m_Color
èè %
*
èè& '
i
èè( )
+
èè* +
y
èè, -
.
èè- .
m_Color
èè. 5
*
èè6 7
weight
èè8 >
;
èè> ?
else
éé 
if
éé 
(
éé 
x
éé 
.
éé 
hasColor
éé 
)
éé  
v
êê 
.
êê 
m_Color
êê 
=
êê 
x
êê 
.
êê 
m_Color
êê %
;
êê% &
else
ëë 
if
ëë 
(
ëë 
y
ëë 
.
ëë 
hasColor
ëë 
)
ëë  
v
ìì 
.
ìì 
m_Color
ìì 
=
ìì 
y
ìì 
.
ìì 
m_Color
ìì %
;
ìì% &
if
îî 
(
îî 
x
îî 
.
îî 
	hasNormal
îî 
&&
îî 
y
îî  
.
îî  !
	hasNormal
îî! *
)
îî* +
v
ïï 
.
ïï 
m_Normal
ïï 
=
ïï 
x
ïï 
.
ïï 
m_Normal
ïï '
*
ïï( )
i
ïï* +
+
ïï, -
y
ïï. /
.
ïï/ 0
m_Normal
ïï0 8
*
ïï9 :
weight
ïï; A
;
ïïA B
else
ğğ 
if
ğğ 
(
ğğ 
x
ğğ 
.
ğğ 
	hasNormal
ğğ  
)
ğğ  !
v
ññ 
.
ññ 
m_Normal
ññ 
=
ññ 
x
ññ 
.
ññ 
m_Normal
ññ '
;
ññ' (
else
òò 
if
òò 
(
òò 
y
òò 
.
òò 
	hasNormal
òò  
)
òò  !
v
óó 
.
óó 
m_Normal
óó 
=
óó 
y
óó 
.
óó 
m_Normal
óó '
;
óó' (
if
õõ 
(
õõ 
x
õõ 
.
õõ 

hasTangent
õõ 
&&
õõ 
y
õõ  !
.
õõ! "

hasTangent
õõ" ,
)
õõ, -
v
öö 
.
öö 
	m_Tangent
öö 
=
öö 
x
öö 
.
öö  
	m_Tangent
öö  )
*
öö* +
i
öö, -
+
öö. /
y
öö0 1
.
öö1 2
	m_Tangent
öö2 ;
*
öö< =
weight
öö> D
;
ööD E
else
÷÷ 
if
÷÷ 
(
÷÷ 
x
÷÷ 
.
÷÷ 

hasTangent
÷÷ !
)
÷÷! "
v
øø 
.
øø 
	m_Tangent
øø 
=
øø 
x
øø 
.
øø  
	m_Tangent
øø  )
;
øø) *
else
ùù 
if
ùù 
(
ùù 
y
ùù 
.
ùù 

hasTangent
ùù !
)
ùù! "
v
úú 
.
úú 
	m_Tangent
úú 
=
úú 
y
úú 
.
úú  
	m_Tangent
úú  )
;
úú) *
if
üü 
(
üü 
x
üü 
.
üü 
hasUV0
üü 
&&
üü 
y
üü 
.
üü 
hasUV0
üü $
)
üü$ %
v
ıı 
.
ıı 
m_UV0
ıı 
=
ıı 
x
ıı 
.
ıı 
m_UV0
ıı !
*
ıı" #
i
ıı$ %
+
ıı& '
y
ıı( )
.
ıı) *
m_UV0
ıı* /
*
ıı0 1
weight
ıı2 8
;
ıı8 9
else
şş 
if
şş 
(
şş 
x
şş 
.
şş 
hasUV0
şş 
)
şş 
v
ÿÿ 
.
ÿÿ 
m_UV0
ÿÿ 
=
ÿÿ 
x
ÿÿ 
.
ÿÿ 
m_UV0
ÿÿ !
;
ÿÿ! "
else
€€ 
if
€€ 
(
€€ 
y
€€ 
.
€€ 
hasUV0
€€ 
)
€€ 
v
 
.
 
m_UV0
 
=
 
y
 
.
 
m_UV0
 !
;
! "
if
ƒƒ 
(
ƒƒ 
x
ƒƒ 
.
ƒƒ 
hasUV2
ƒƒ 
&&
ƒƒ 
y
ƒƒ 
.
ƒƒ 
hasUV2
ƒƒ $
)
ƒƒ$ %
v
„„ 
.
„„ 
m_UV2
„„ 
=
„„ 
x
„„ 
.
„„ 
m_UV2
„„ !
*
„„" #
i
„„$ %
+
„„& '
y
„„( )
.
„„) *
m_UV2
„„* /
*
„„0 1
weight
„„2 8
;
„„8 9
else
…… 
if
…… 
(
…… 
x
…… 
.
…… 
hasUV2
…… 
)
…… 
v
†† 
.
†† 
m_UV2
†† 
=
†† 
x
†† 
.
†† 
m_UV2
†† !
;
††! "
else
‡‡ 
if
‡‡ 
(
‡‡ 
y
‡‡ 
.
‡‡ 
hasUV2
‡‡ 
)
‡‡ 
v
ˆˆ 
.
ˆˆ 
m_UV2
ˆˆ 
=
ˆˆ 
y
ˆˆ 
.
ˆˆ 
m_UV2
ˆˆ !
;
ˆˆ! "
if
ŠŠ 
(
ŠŠ 
x
ŠŠ 
.
ŠŠ 
hasUV3
ŠŠ 
&&
ŠŠ 
y
ŠŠ 
.
ŠŠ 
hasUV3
ŠŠ $
)
ŠŠ$ %
v
‹‹ 
.
‹‹ 
m_UV3
‹‹ 
=
‹‹ 
x
‹‹ 
.
‹‹ 
m_UV3
‹‹ !
*
‹‹" #
i
‹‹$ %
+
‹‹& '
y
‹‹( )
.
‹‹) *
m_UV3
‹‹* /
*
‹‹0 1
weight
‹‹2 8
;
‹‹8 9
else
ŒŒ 
if
ŒŒ 
(
ŒŒ 
x
ŒŒ 
.
ŒŒ 
hasUV3
ŒŒ 
)
ŒŒ 
v
 
.
 
m_UV3
 
=
 
x
 
.
 
m_UV3
 !
;
! "
else
 
if
 
(
 
y
 
.
 
hasUV3
 
)
 
v
 
.
 
m_UV3
 
=
 
y
 
.
 
m_UV3
 !
;
! "
if
‘‘ 
(
‘‘ 
x
‘‘ 
.
‘‘ 
hasUV4
‘‘ 
&&
‘‘ 
y
‘‘ 
.
‘‘ 
hasUV4
‘‘ $
)
‘‘$ %
v
’’ 
.
’’ 
m_UV4
’’ 
=
’’ 
x
’’ 
.
’’ 
m_UV4
’’ !
*
’’" #
i
’’$ %
+
’’& '
y
’’( )
.
’’) *
m_UV4
’’* /
*
’’0 1
weight
’’2 8
;
’’8 9
else
““ 
if
““ 
(
““ 
x
““ 
.
““ 
hasUV4
““ 
)
““ 
v
”” 
.
”” 
m_UV4
”” 
=
”” 
x
”” 
.
”” 
m_UV4
”” !
;
””! "
else
•• 
if
•• 
(
•• 
y
•• 
.
•• 
hasUV4
•• 
)
•• 
v
–– 
.
–– 
m_UV4
–– 
=
–– 
y
–– 
.
–– 
m_UV4
–– !
;
––! "
return
˜˜ 
v
˜˜ 
;
˜˜ 
}
™™ 	
}
šš 
}›› ’İ
ˆD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\Normals.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 

static 
class 
Normals 
{ 
static 
Vector3 
[ 
] 
s_SmoothAvg $
=% &
new' *
Vector3+ 2
[2 3
	Smoothing3 <
.< =
smoothRangeMax= K
]K L
;L M
static 
float 
[ 
] 
s_SmoothAvgCount '
=( )
new* -
float. 3
[3 4
	Smoothing4 =
.= >
smoothRangeMax> L
]L M
;M N
static		 
int		 
[		 
]		 
s_CachedIntArray		 %
=		& '
new		( +
int		, /
[		/ 0
ushort		0 6
.		6 7
MaxValue		7 ?
]		? @
;		@ A
static 
void 
ClearIntArray !
(! "
int" %
count& +
)+ ,
{ 	
if 
( 
count 
> 
s_CachedIntArray (
.( )
Length) /
)/ 0
Array 
. 
Resize 
( 
ref  
s_CachedIntArray! 1
,1 2
count3 8
)8 9
;9 :
for 
( 
int 
i 
= 
$num 
; 
i 
< 
count  %
;% &
i' (
++( *
)* +
s_CachedIntArray  
[  !
i! "
]" #
=$ %
$num& '
;' (
} 	
public 
static 
void 
CalculateTangents ,
(, -
ProBuilderMesh- ;
mesh< @
)@ A
{ 	
int 
vc 
= 
mesh 
. 
vertexCount %
;% &
if 
( 
! 
mesh 
. 
	HasArrays 
(  

MeshArrays  *
.* +
Tangent+ 2
)2 3
)3 4
mesh 
. 
tangentsInternal %
=& '
new( +
Vector4, 3
[3 4
vc4 6
]6 7
;7 8
if 
( 
! 
mesh 
. 
	HasArrays 
(  

MeshArrays  *
.* +
Position+ 3
)3 4
||5 7
!8 9
mesh9 =
.= >
	HasArrays> G
(G H

MeshArraysH R
.R S
Texture0S [
)[ \
)\ ]
return 
; 
Vector3 
[ 
] 
normals 
= 
mesh  $
.$ %

GetNormals% /
(/ 0
)0 1
;1 2
var!! 
	positions!! 
=!! 
mesh!!  
.!!  !
positionsInternal!!! 2
;!!2 3
var"" 
textures"" 
="" 
mesh"" 
.""  
texturesInternal""  0
;""0 1
var$$ 
tan1$$ 
=$$ 
new$$ 
Vector3$$ "
[$$" #
vc$$# %
]$$% &
;$$& '
var%% 
tan2%% 
=%% 
new%% 
Vector3%% "
[%%" #
vc%%# %
]%%% &
;%%& '
var'' 
tangents'' 
='' 
mesh'' 
.''  
tangentsInternal''  0
;''0 1
foreach)) 
()) 
var)) 
face)) 
in))  
mesh))! %
.))% &
facesInternal))& 3
)))3 4
{** 
int++ 
[++ 
]++ 
	triangles++ 
=++  !
face++" &
.++& '
indexesInternal++' 6
;++6 7
for-- 
(-- 
int-- 
a-- 
=-- 
$num-- 
,-- 
c--  !
=--" #
	triangles--$ -
.--- .
Length--. 4
;--4 5
a--6 7
<--8 9
c--: ;
;--; <
a--= >
+=--? A
$num--B C
)--C D
{.. 
long// 
i1// 
=// 
	triangles// '
[//' (
a//( )
+//* +
$num//, -
]//- .
;//. /
long00 
i200 
=00 
	triangles00 '
[00' (
a00( )
+00* +
$num00, -
]00- .
;00. /
long11 
i311 
=11 
	triangles11 '
[11' (
a11( )
+11* +
$num11, -
]11- .
;11. /
Vector333 
v133 
=33  
	positions33! *
[33* +
i133+ -
]33- .
;33. /
Vector344 
v244 
=44  
	positions44! *
[44* +
i244+ -
]44- .
;44. /
Vector355 
v355 
=55  
	positions55! *
[55* +
i355+ -
]55- .
;55. /
Vector277 
w177 
=77  
textures77! )
[77) *
i177* ,
]77, -
;77- .
Vector288 
w288 
=88  
textures88! )
[88) *
i288* ,
]88, -
;88- .
Vector299 
w399 
=99  
textures99! )
[99) *
i399* ,
]99, -
;99- .
float;; 
x1;; 
=;; 
v2;; !
.;;! "
x;;" #
-;;$ %
v1;;& (
.;;( )
x;;) *
;;;* +
float<< 
x2<< 
=<< 
v3<< !
.<<! "
x<<" #
-<<$ %
v1<<& (
.<<( )
x<<) *
;<<* +
float== 
y1== 
=== 
v2== !
.==! "
y==" #
-==$ %
v1==& (
.==( )
y==) *
;==* +
float>> 
y2>> 
=>> 
v3>> !
.>>! "
y>>" #
->>$ %
v1>>& (
.>>( )
y>>) *
;>>* +
float?? 
z1?? 
=?? 
v2?? !
.??! "
z??" #
-??$ %
v1??& (
.??( )
z??) *
;??* +
float@@ 
z2@@ 
=@@ 
v3@@ !
.@@! "
z@@" #
-@@$ %
v1@@& (
.@@( )
z@@) *
;@@* +
floatBB 
s1BB 
=BB 
w2BB !
.BB! "
xBB" #
-BB$ %
w1BB& (
.BB( )
xBB) *
;BB* +
floatCC 
s2CC 
=CC 
w3CC !
.CC! "
xCC" #
-CC$ %
w1CC& (
.CC( )
xCC) *
;CC* +
floatDD 
t1DD 
=DD 
w2DD !
.DD! "
yDD" #
-DD$ %
w1DD& (
.DD( )
yDD) *
;DD* +
floatEE 
t2EE 
=EE 
w3EE !
.EE! "
yEE" #
-EE$ %
w1EE& (
.EE( )
yEE) *
;EE* +
floatGG 
rGG 
=GG 
$numGG "
/GG# $
(GG% &
s1GG& (
*GG) *
t2GG+ -
-GG. /
s2GG0 2
*GG3 4
t1GG5 7
)GG7 8
;GG8 9
Vector3II 
sdirII  
=II! "
newII# &
Vector3II' .
(II. /
(II/ 0
t2II0 2
*II3 4
x1II5 7
-II8 9
t1II: <
*II= >
x2II? A
)IIA B
*IIC D
rIIE F
,IIF G
(IIH I
t2III K
*IIL M
y1IIN P
-IIQ R
t1IIS U
*IIV W
y2IIX Z
)IIZ [
*II\ ]
rII^ _
,II_ `
(IIa b
t2IIb d
*IIe f
z1IIg i
-IIj k
t1IIl n
*IIo p
z2IIq s
)IIs t
*IIu v
rIIw x
)IIx y
;IIy z
Vector3JJ 
tdirJJ  
=JJ! "
newJJ# &
Vector3JJ' .
(JJ. /
(JJ/ 0
s1JJ0 2
*JJ3 4
x2JJ5 7
-JJ8 9
s2JJ: <
*JJ= >
x1JJ? A
)JJA B
*JJC D
rJJE F
,JJF G
(JJH I
s1JJI K
*JJL M
y2JJN P
-JJQ R
s2JJS U
*JJV W
y1JJX Z
)JJZ [
*JJ\ ]
rJJ^ _
,JJ_ `
(JJa b
s1JJb d
*JJe f
z2JJg i
-JJj k
s2JJl n
*JJo p
z1JJq s
)JJs t
*JJu v
rJJw x
)JJx y
;JJy z
tan1LL 
[LL 
i1LL 
]LL 
+=LL 
sdirLL  $
;LL$ %
tan1MM 
[MM 
i2MM 
]MM 
+=MM 
sdirMM  $
;MM$ %
tan1NN 
[NN 
i3NN 
]NN 
+=NN 
sdirNN  $
;NN$ %
tan2PP 
[PP 
i1PP 
]PP 
+=PP 
tdirPP  $
;PP$ %
tan2QQ 
[QQ 
i2QQ 
]QQ 
+=QQ 
tdirQQ  $
;QQ$ %
tan2RR 
[RR 
i3RR 
]RR 
+=RR 
tdirRR  $
;RR$ %
}SS 
}TT 
forVV 
(VV 
longVV 
aVV 
=VV 
$numVV 
;VV 
aVV 
<VV  
vcVV! #
;VV# $
++VV% '
aVV' (
)VV( )
{WW 
Vector3XX 
nXX 
=XX 
normalsXX #
[XX# $
aXX$ %
]XX% &
;XX& '
Vector3YY 
tYY 
=YY 
tan1YY  
[YY  !
aYY! "
]YY" #
;YY# $
Vector3[[ 
.[[ 
OrthoNormalize[[ &
([[& '
ref[[' *
n[[+ ,
,[[, -
ref[[. 1
t[[2 3
)[[3 4
;[[4 5
tangents]] 
[]] 
a]] 
]]] 
.]] 
x]] 
=]] 
t]]  !
.]]! "
x]]" #
;]]# $
tangents^^ 
[^^ 
a^^ 
]^^ 
.^^ 
y^^ 
=^^ 
t^^  !
.^^! "
y^^" #
;^^# $
tangents__ 
[__ 
a__ 
]__ 
.__ 
z__ 
=__ 
t__  !
.__! "
z__" #
;__# $
tangents`` 
[`` 
a`` 
]`` 
.`` 
w`` 
=`` 
(``  !
Vector3``! (
.``( )
Dot``) ,
(``, -
Vector3``- 4
.``4 5
Cross``5 :
(``: ;
n``; <
,``< =
t``> ?
)``? @
,``@ A
tan2``B F
[``F G
a``G H
]``H I
)``I J
<``K L
$num``M Q
)``Q R
?``S T
-``U V
$num``V Z
:``[ \
$num``] a
;``a b
}aa 
}bb 	
staticii 
voidii  
CalculateHardNormalsii (
(ii( )
ProBuilderMeshii) 7
meshii8 <
)ii< =
{jj 	
varkk 
vertexCountkk 
=kk 
meshkk "
.kk" #
vertexCountkk# .
;kk. /
varll 
	positionsll 
=ll 
meshll  
.ll  !
positionsInternalll! 2
;ll2 3
varmm 
facesmm 
=mm 
meshmm 
.mm 
facesInternalmm *
;mm* +
ClearIntArrayoo 
(oo 
vertexCountoo %
)oo% &
;oo& '
ifqq 
(qq 
!qq 
meshqq 
.qq 
	HasArraysqq 
(qq  

MeshArraysqq  *
.qq* +
Normalqq+ 1
)qq1 2
)qq2 3
meshrr 
.rr 
normalsInternalrr $
=rr% &
newrr' *
Vector3rr+ 2
[rr2 3
vertexCountrr3 >
]rr> ?
;rr? @
vartt 
normalstt 
=tt 
meshtt 
.tt 
normalsInternaltt .
;tt. /
forvv 
(vv 
intvv 
ivv 
=vv 
$numvv 
;vv 
ivv 
<vv 
vertexCountvv  +
;vv+ ,
ivv- .
++vv. 0
)vv0 1
{ww 
normalsxx 
[xx 
ixx 
]xx 
.xx 
xxx 
=xx 
$numxx !
;xx! "
normalsyy 
[yy 
iyy 
]yy 
.yy 
yyy 
=yy 
$numyy !
;yy! "
normalszz 
[zz 
izz 
]zz 
.zz 
zzz 
=zz 
$numzz !
;zz! "
}{{ 
for}} 
(}} 
int}} 
	faceIndex}} 
=}}  
$num}}! "
,}}" #
fc}}$ &
=}}' (
faces}}) .
.}}. /
Length}}/ 5
;}}5 6
	faceIndex}}7 @
<}}A B
fc}}C E
;}}E F
	faceIndex}}G P
++}}P R
)}}R S
{~~ 
int 
[ 
] 
indexes 
= 
faces  %
[% &
	faceIndex& /
]/ 0
.0 1
indexesInternal1 @
;@ A
for
 
(
 
var
 
tri
 
=
 
$num
  
;
  !
tri
" %
<
& '
indexes
( /
.
/ 0
Length
0 6
;
6 7
tri
8 ;
+=
< >
$num
? @
)
@ A
{
‚‚ 
int
ƒƒ 
a
ƒƒ 
=
ƒƒ 
indexes
ƒƒ #
[
ƒƒ# $
tri
ƒƒ$ '
]
ƒƒ' (
,
ƒƒ( )
b
ƒƒ* +
=
ƒƒ, -
indexes
ƒƒ. 5
[
ƒƒ5 6
tri
ƒƒ6 9
+
ƒƒ: ;
$num
ƒƒ< =
]
ƒƒ= >
,
ƒƒ> ?
c
ƒƒ@ A
=
ƒƒB C
indexes
ƒƒD K
[
ƒƒK L
tri
ƒƒL O
+
ƒƒP Q
$num
ƒƒR S
]
ƒƒS T
;
ƒƒT U
Vector3
…… 
cross
…… !
=
……" #
Math
……$ (
.
……( )
Normal
……) /
(
……/ 0
	positions
……0 9
[
……9 :
a
……: ;
]
……; <
,
……< =
	positions
……> G
[
……G H
b
……H I
]
……I J
,
……J K
	positions
……L U
[
……U V
c
……V W
]
……W X
)
……X Y
;
……Y Z
cross
†† 
.
†† 
	Normalize
†† #
(
††# $
)
††$ %
;
††% &
normals
ˆˆ 
[
ˆˆ 
a
ˆˆ 
]
ˆˆ 
.
ˆˆ 
x
ˆˆ  
+=
ˆˆ! #
cross
ˆˆ$ )
.
ˆˆ) *
x
ˆˆ* +
;
ˆˆ+ ,
normals
‰‰ 
[
‰‰ 
b
‰‰ 
]
‰‰ 
.
‰‰ 
x
‰‰  
+=
‰‰! #
cross
‰‰$ )
.
‰‰) *
x
‰‰* +
;
‰‰+ ,
normals
ŠŠ 
[
ŠŠ 
c
ŠŠ 
]
ŠŠ 
.
ŠŠ 
x
ŠŠ  
+=
ŠŠ! #
cross
ŠŠ$ )
.
ŠŠ) *
x
ŠŠ* +
;
ŠŠ+ ,
normals
ŒŒ 
[
ŒŒ 
a
ŒŒ 
]
ŒŒ 
.
ŒŒ 
y
ŒŒ  
+=
ŒŒ! #
cross
ŒŒ$ )
.
ŒŒ) *
y
ŒŒ* +
;
ŒŒ+ ,
normals
 
[
 
b
 
]
 
.
 
y
  
+=
! #
cross
$ )
.
) *
y
* +
;
+ ,
normals
 
[
 
c
 
]
 
.
 
y
  
+=
! #
cross
$ )
.
) *
y
* +
;
+ ,
normals
 
[
 
a
 
]
 
.
 
z
  
+=
! #
cross
$ )
.
) *
z
* +
;
+ ,
normals
‘‘ 
[
‘‘ 
b
‘‘ 
]
‘‘ 
.
‘‘ 
z
‘‘  
+=
‘‘! #
cross
‘‘$ )
.
‘‘) *
z
‘‘* +
;
‘‘+ ,
normals
’’ 
[
’’ 
c
’’ 
]
’’ 
.
’’ 
z
’’  
+=
’’! #
cross
’’$ )
.
’’) *
z
’’* +
;
’’+ ,
s_CachedIntArray
”” $
[
””$ %
a
””% &
]
””& '
++
””' )
;
””) *
s_CachedIntArray
•• $
[
••$ %
b
••% &
]
••& '
++
••' )
;
••) *
s_CachedIntArray
–– $
[
––$ %
c
––% &
]
––& '
++
––' )
;
––) *
}
—— 
}
˜˜ 
for
šš 
(
šš 
var
šš 
i
šš 
=
šš 
$num
šš 
;
šš 
i
šš 
<
šš 
vertexCount
šš  +
;
šš+ ,
i
šš- .
++
šš. 0
)
šš0 1
{
›› 
normals
œœ 
[
œœ 
i
œœ 
]
œœ 
.
œœ 
x
œœ 
=
œœ 
normals
œœ &
[
œœ& '
i
œœ' (
]
œœ( )
.
œœ) *
x
œœ* +
/
œœ, -
s_CachedIntArray
œœ. >
[
œœ> ?
i
œœ? @
]
œœ@ A
;
œœA B
normals
 
[
 
i
 
]
 
.
 
y
 
=
 
normals
 &
[
& '
i
' (
]
( )
.
) *
y
* +
/
, -
s_CachedIntArray
. >
[
> ?
i
? @
]
@ A
;
A B
normals
 
[
 
i
 
]
 
.
 
z
 
=
 
normals
 &
[
& '
i
' (
]
( )
.
) *
z
* +
/
, -
s_CachedIntArray
. >
[
> ?
i
? @
]
@ A
;
A B
}
ŸŸ 
}
   	
public
¦¦ 
static
¦¦ 
void
¦¦ 
CalculateNormals
¦¦ +
(
¦¦+ ,
ProBuilderMesh
¦¦, :
mesh
¦¦; ?
)
¦¦? @
{
§§ 	"
CalculateHardNormals
¨¨  
(
¨¨  !
mesh
¨¨! %
)
¨¨% &
;
¨¨& '
var
ªª 
sharedVertices
ªª 
=
ªª  
mesh
ªª! %
.
ªª% &$
sharedVerticesInternal
ªª& <
;
ªª< =
var
«« 
faces
«« 
=
«« 
mesh
«« 
.
«« 
facesInternal
«« *
;
««* +
var
­­ 
normals
­­ 
=
­­ 
mesh
­­ 
.
­­ 
normalsInternal
­­ .
;
­­. /
int
®® 
smoothGroupMax
®® 
=
®®  
$num
®®! #
;
®®# $
ClearIntArray
°° 
(
°° 
mesh
°° 
.
°° 
vertexCount
°° *
)
°°* +
;
°°+ ,
for
³³ 
(
³³ 
int
³³ 
i
³³ 
=
³³ 
$num
³³ 
,
³³ 
c
³³ 
=
³³ 
mesh
³³  $
.
³³$ %
	faceCount
³³% .
;
³³. /
i
³³0 1
<
³³2 3
c
³³4 5
;
³³5 6
i
³³7 8
++
³³8 :
)
³³: ;
{
´´ 
var
µµ 
face
µµ 
=
µµ 
faces
µµ  
[
µµ  !
i
µµ! "
]
µµ" #
;
µµ# $
var
¶¶ 
indices
¶¶ 
=
¶¶ 
face
¶¶ "
.
¶¶" #%
distinctIndexesInternal
¶¶# :
;
¶¶: ;
for
¸¸ 
(
¸¸ 
int
¸¸ 
n
¸¸ 
=
¸¸ 
$num
¸¸ 
,
¸¸ 
d
¸¸  !
=
¸¸" #
indices
¸¸$ +
.
¸¸+ ,
Length
¸¸, 2
;
¸¸2 3
n
¸¸4 5
<
¸¸6 7
d
¸¸8 9
;
¸¸9 :
n
¸¸; <
++
¸¸< >
)
¸¸> ?
{
¹¹ 
s_CachedIntArray
ºº $
[
ºº$ %
indices
ºº% ,
[
ºº, -
n
ºº- .
]
ºº. /
]
ºº/ 0
=
ºº1 2
face
ºº3 7
.
ºº7 8
smoothingGroup
ºº8 F
;
ººF G
if
¼¼ 
(
¼¼ 
face
¼¼ 
.
¼¼ 
smoothingGroup
¼¼ +
>=
¼¼, .
smoothGroupMax
¼¼/ =
)
¼¼= >
smoothGroupMax
½½ &
=
½½' (
face
½½) -
.
½½- .
smoothingGroup
½½. <
+
½½= >
$num
½½? @
;
½½@ A
}
¾¾ 
}
¿¿ 
if
ÂÂ 
(
ÂÂ 
smoothGroupMax
ÂÂ 
>
ÂÂ  
s_SmoothAvg
ÂÂ! ,
.
ÂÂ, -
Length
ÂÂ- 3
)
ÂÂ3 4
{
ÃÃ 
Array
ÄÄ 
.
ÄÄ 
Resize
ÄÄ 
(
ÄÄ 
ref
ÄÄ  
s_SmoothAvg
ÄÄ! ,
,
ÄÄ, -
smoothGroupMax
ÄÄ. <
)
ÄÄ< =
;
ÄÄ= >
Array
ÅÅ 
.
ÅÅ 
Resize
ÅÅ 
(
ÅÅ 
ref
ÅÅ  
s_SmoothAvgCount
ÅÅ! 1
,
ÅÅ1 2
smoothGroupMax
ÅÅ3 A
)
ÅÅA B
;
ÅÅB C
}
ÆÆ 
for
ÊÊ 
(
ÊÊ 
var
ÊÊ 
i
ÊÊ 
=
ÊÊ 
$num
ÊÊ 
;
ÊÊ 
i
ÊÊ 
<
ÊÊ 
sharedVertices
ÊÊ  .
.
ÊÊ. /
Length
ÊÊ/ 5
;
ÊÊ5 6
i
ÊÊ7 8
++
ÊÊ8 :
)
ÊÊ: ;
{
ËË 
for
ÌÌ 
(
ÌÌ 
var
ÌÌ 
n
ÌÌ 
=
ÌÌ 
$num
ÌÌ 
;
ÌÌ 
n
ÌÌ  !
<
ÌÌ" #
smoothGroupMax
ÌÌ$ 2
;
ÌÌ2 3
n
ÌÌ4 5
++
ÌÌ5 7
)
ÌÌ7 8
{
ÍÍ 
s_SmoothAvg
ÎÎ 
[
ÎÎ  
n
ÎÎ  !
]
ÎÎ! "
.
ÎÎ" #
x
ÎÎ# $
=
ÎÎ% &
$num
ÎÎ' )
;
ÎÎ) *
s_SmoothAvg
ÏÏ 
[
ÏÏ  
n
ÏÏ  !
]
ÏÏ! "
.
ÏÏ" #
y
ÏÏ# $
=
ÏÏ% &
$num
ÏÏ' )
;
ÏÏ) *
s_SmoothAvg
ĞĞ 
[
ĞĞ  
n
ĞĞ  !
]
ĞĞ! "
.
ĞĞ" #
z
ĞĞ# $
=
ĞĞ% &
$num
ĞĞ' )
;
ĞĞ) *
s_SmoothAvgCount
ÑÑ $
[
ÑÑ$ %
n
ÑÑ% &
]
ÑÑ& '
=
ÑÑ( )
$num
ÑÑ* ,
;
ÑÑ, -
}
ÒÒ 
for
ÔÔ 
(
ÔÔ 
var
ÔÔ 
n
ÔÔ 
=
ÔÔ 
$num
ÔÔ 
;
ÔÔ 
n
ÔÔ  !
<
ÔÔ" #
sharedVertices
ÔÔ$ 2
[
ÔÔ2 3
i
ÔÔ3 4
]
ÔÔ4 5
.
ÔÔ5 6
Count
ÔÔ6 ;
;
ÔÔ; <
n
ÔÔ= >
++
ÔÔ> @
)
ÔÔ@ A
{
ÕÕ 
int
ÖÖ 
index
ÖÖ 
=
ÖÖ 
sharedVertices
ÖÖ  .
[
ÖÖ. /
i
ÖÖ/ 0
]
ÖÖ0 1
[
ÖÖ1 2
n
ÖÖ2 3
]
ÖÖ3 4
;
ÖÖ4 5
int
×× 
group
×× 
=
×× 
s_CachedIntArray
××  0
[
××0 1
index
××1 6
]
××6 7
;
××7 8
if
ÛÛ 
(
ÛÛ 
group
ÛÛ 
<=
ÛÛ  
	Smoothing
ÛÛ! *
.
ÛÛ* + 
smoothingGroupNone
ÛÛ+ =
||
ÛÛ> @
(
ÜÜ 
group
ÜÜ 
>
ÜÜ  
	Smoothing
ÜÜ! *
.
ÜÜ* +
smoothRangeMax
ÜÜ+ 9
&&
ÜÜ: <
group
ÜÜ= B
<
ÜÜC D
	Smoothing
ÜÜE N
.
ÜÜN O
hardRangeMax
ÜÜO [
)
ÜÜ[ \
)
ÜÜ\ ]
continue
İİ  
;
İİ  !
s_SmoothAvg
ßß 
[
ßß  
group
ßß  %
]
ßß% &
.
ßß& '
x
ßß' (
+=
ßß) +
normals
ßß, 3
[
ßß3 4
index
ßß4 9
]
ßß9 :
.
ßß: ;
x
ßß; <
;
ßß< =
s_SmoothAvg
àà 
[
àà  
group
àà  %
]
àà% &
.
àà& '
y
àà' (
+=
àà) +
normals
àà, 3
[
àà3 4
index
àà4 9
]
àà9 :
.
àà: ;
y
àà; <
;
àà< =
s_SmoothAvg
áá 
[
áá  
group
áá  %
]
áá% &
.
áá& '
z
áá' (
+=
áá) +
normals
áá, 3
[
áá3 4
index
áá4 9
]
áá9 :
.
áá: ;
z
áá; <
;
áá< =
s_SmoothAvgCount
ââ $
[
ââ$ %
group
ââ% *
]
ââ* +
+=
ââ, .
$num
ââ/ 1
;
ââ1 2
}
ãã 
for
åå 
(
åå 
int
åå 
n
åå 
=
åå 
$num
åå 
;
åå 
n
åå  !
<
åå" #
sharedVertices
åå$ 2
[
åå2 3
i
åå3 4
]
åå4 5
.
åå5 6
Count
åå6 ;
;
åå; <
n
åå= >
++
åå> @
)
åå@ A
{
ææ 
int
çç 
index
çç 
=
çç 
sharedVertices
çç  .
[
çç. /
i
çç/ 0
]
çç0 1
[
çç1 2
n
çç2 3
]
çç3 4
;
çç4 5
int
èè 
group
èè 
=
èè 
s_CachedIntArray
èè  0
[
èè0 1
index
èè1 6
]
èè6 7
;
èè7 8
if
êê 
(
êê 
group
êê 
<=
êê  
	Smoothing
êê! *
.
êê* + 
smoothingGroupNone
êê+ =
||
êê> @
(
ëë 
group
ëë 
>
ëë  
	Smoothing
ëë! *
.
ëë* +
smoothRangeMax
ëë+ 9
&&
ëë: <
group
ëë= B
<
ëëC D
	Smoothing
ëëE N
.
ëëN O
hardRangeMax
ëëO [
)
ëë[ \
)
ëë\ ]
continue
ìì  
;
ìì  !
normals
îî 
[
îî 
index
îî !
]
îî! "
.
îî" #
x
îî# $
=
îî% &
s_SmoothAvg
îî' 2
[
îî2 3
group
îî3 8
]
îî8 9
.
îî9 :
x
îî: ;
/
îî< =
s_SmoothAvgCount
îî> N
[
îîN O
group
îîO T
]
îîT U
;
îîU V
normals
ïï 
[
ïï 
index
ïï !
]
ïï! "
.
ïï" #
y
ïï# $
=
ïï% &
s_SmoothAvg
ïï' 2
[
ïï2 3
group
ïï3 8
]
ïï8 9
.
ïï9 :
y
ïï: ;
/
ïï< =
s_SmoothAvgCount
ïï> N
[
ïïN O
group
ïïO T
]
ïïT U
;
ïïU V
normals
ğğ 
[
ğğ 
index
ğğ !
]
ğğ! "
.
ğğ" #
z
ğğ# $
=
ğğ% &
s_SmoothAvg
ğğ' 2
[
ğğ2 3
group
ğğ3 8
]
ğğ8 9
.
ğğ9 :
z
ğğ: ;
/
ğğ< =
s_SmoothAvgCount
ğğ> N
[
ğğN O
group
ğğO T
]
ğğT U
;
ğğU V
normals
òò 
[
òò 
index
òò !
]
òò! "
.
òò" #
	Normalize
òò# ,
(
òò, -
)
òò- .
;
òò. /
}
óó 
}
ôô 
}
õõ 	
}
öö 
}÷÷ şÉ
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\Bevel.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{		 
public 

static 
class 
Bevel 
{ 
public 
static 
List 
< 
Face 
>  

BevelEdges! +
(+ ,
ProBuilderMesh, :
mesh; ?
,? @
IListA F
<F G
EdgeG K
>K L
edgesM R
,R S
floatT Y
amountZ `
)` a
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new !
ArgumentNullException /
(/ 0
$str0 6
)6 7
;7 8

Dictionary 
< 
int 
, 
int 
>  
lookup! '
=( )
mesh* .
.. /
sharedVertexLookup/ A
;A B
List 
< 
Vertex 
> 
vertices !
=" #
new$ '
List( ,
<, -
Vertex- 3
>3 4
(4 5
mesh5 9
.9 :
GetVertices: E
(E F
)F G
)G H
;H I
List 
< 

EdgeLookup 
> 
m_edges $
=% &

EdgeLookup' 1
.1 2
GetEdgeLookup2 ?
(? @
edges@ E
,E F
lookupG M
)M N
.N O
DistinctO W
(W X
)X Y
.Y Z
ToListZ `
(` a
)a b
;b c
List 
< 

WingedEdge 
> 
wings "
=# $

WingedEdge% /
./ 0
GetWingedEdges0 >
(> ?
mesh? C
)C D
;D E
List 
< 
FaceRebuildData  
>  !
appendFaces" -
=. /
new0 3
List4 8
<8 9
FaceRebuildData9 H
>H I
(I J
)J K
;K L

Dictionary!! 
<!! 
Face!! 
,!! 
List!! !
<!!! "
int!!" %
>!!% &
>!!& '
ignore!!( .
=!!/ 0
new!!1 4

Dictionary!!5 ?
<!!? @
Face!!@ D
,!!D E
List!!F J
<!!J K
int!!K N
>!!N O
>!!O P
(!!P Q
)!!Q R
;!!R S
HashSet"" 
<"" 
int"" 
>"" 
slide"" 
=""  
new""! $
HashSet""% ,
<"", -
int""- 0
>""0 1
(""1 2
)""2 3
;""3 4
int## 
beveled## 
=## 
$num## 
;## 

Dictionary%% 
<%% 
int%% 
,%% 
List%%  
<%%  !
SimpleTuple%%! ,
<%%, -
FaceRebuildData%%- <
,%%< =
List%%> B
<%%B C
int%%C F
>%%F G
>%%G H
>%%H I
>%%I J
holes%%K P
=%%Q R
new%%S V

Dictionary%%W a
<%%a b
int%%b e
,%%e f
List%%g k
<%%k l
SimpleTuple%%l w
<%%w x
FaceRebuildData	%%x ‡
,
%%‡ ˆ
List
%%‰ 
<
%% 
int
%% ‘
>
%%‘ ’
>
%%’ “
>
%%“ ”
>
%%” •
(
%%• –
)
%%– —
;
%%— ˜

Dictionary)) 
<)) 
int)) 
,)) 
List))  
<))  !

WingedEdge))! +
>))+ ,
>)), -
spokes)). 4
=))5 6

WingedEdge))7 A
.))A B
	GetSpokes))B K
())K L
wings))L Q
)))Q R
;))R S
HashSet** 
<** 
int** 
>** 
tested_common** &
=**' (
new**) ,
HashSet**- 4
<**4 5
int**5 8
>**8 9
(**9 :
)**: ;
;**; <
foreach,, 
(,, 

EdgeLookup,, 
e,,  !
in,," $
m_edges,,% ,
),,, -
{-- 
if.. 
(.. 
tested_common.. !
...! "
Add.." %
(..% &
e..& '
...' (
common..( .
.... /
a../ 0
)..0 1
)..1 2
{// 
foreach00 
(00 

WingedEdge00 '
w00( )
in00* ,
spokes00- 3
[003 4
e004 5
.005 6
common006 <
.00< =
a00= >
]00> ?
)00? @
{11 
Edge22 
le22 
=22  !
w22" #
.22# $
edge22$ (
.22( )
local22) .
;22. /
amount33 
=33  
Mathf33! &
.33& '
Min33' *
(33* +
Vector333+ 2
.332 3
Distance333 ;
(33; <
vertices33< D
[33D E
le33E G
.33G H
a33H I
]33I J
.33J K
position33K S
,33S T
vertices33U ]
[33] ^
le33^ `
.33` a
b33a b
]33b c
.33c d
position33d l
)33l m
-33n o
$num33p u
,33u v
amount33w }
)33} ~
;33~ 
}44 
}55 
if77 
(77 
tested_common77 !
.77! "
Add77" %
(77% &
e77& '
.77' (
common77( .
.77. /
b77/ 0
)770 1
)771 2
{88 
foreach99 
(99 

WingedEdge99 '
w99( )
in99* ,
spokes99- 3
[993 4
e994 5
.995 6
common996 <
.99< =
b99= >
]99> ?
)99? @
{:: 
Edge;; 
le;; 
=;;  !
w;;" #
.;;# $
edge;;$ (
.;;( )
local;;) .
;;;. /
amount<< 
=<<  
Mathf<<! &
.<<& '
Min<<' *
(<<* +
Vector3<<+ 2
.<<2 3
Distance<<3 ;
(<<; <
vertices<<< D
[<<D E
le<<E G
.<<G H
a<<H I
]<<I J
.<<J K
position<<K S
,<<S T
vertices<<U ]
[<<] ^
le<<^ `
.<<` a
b<<a b
]<<b c
.<<c d
position<<d l
)<<l m
-<<n o
$num<<p u
,<<u v
amount<<w }
)<<} ~
;<<~ 
}== 
}>> 
}?? 
ifAA 
(AA 
amountAA 
<AA 
$numAA 
)AA 
{BB 
LogCC 
.CC 
InfoCC 
(CC 
$strCC =
)CC= >
;CC> ?
returnDD 
nullDD 
;DD 
}EE 
foreachII 
(II 

EdgeLookupII 
lupII  #
inII$ &
m_edgesII' .
)II. /
{JJ 

WingedEdgeKK 
weKK 
=KK 
wingsKK  %
.KK% &
FirstOrDefaultKK& 4
(KK4 5
xKK5 6
=>KK7 9
xKK: ;
.KK; <
edgeKK< @
.KK@ A
EqualsKKA G
(KKG H
lupKKH K
)KKK L
)KKL M
;KKM N
ifMM 
(MM 
weMM 
==MM 
nullMM 
||MM !
weMM" $
.MM$ %
oppositeMM% -
==MM. 0
nullMM1 5
)MM5 6
continueNN 
;NN 
beveledPP 
++PP 
;PP 
ignoreRR 
.RR 
AddOrAppendRR "
(RR" #
weRR# %
.RR% &
faceRR& *
,RR* +
weRR, .
.RR. /
edgeRR/ 3
.RR3 4
commonRR4 :
.RR: ;
aRR; <
)RR< =
;RR= >
ignoreSS 
.SS 
AddOrAppendSS "
(SS" #
weSS# %
.SS% &
faceSS& *
,SS* +
weSS, .
.SS. /
edgeSS/ 3
.SS3 4
commonSS4 :
.SS: ;
bSS; <
)SS< =
;SS= >
ignoreTT 
.TT 
AddOrAppendTT "
(TT" #
weTT# %
.TT% &
oppositeTT& .
.TT. /
faceTT/ 3
,TT3 4
weTT5 7
.TT7 8
edgeTT8 <
.TT< =
commonTT= C
.TTC D
aTTD E
)TTE F
;TTF G
ignoreUU 
.UU 
AddOrAppendUU "
(UU" #
weUU# %
.UU% &
oppositeUU& .
.UU. /
faceUU/ 3
,UU3 4
weUU5 7
.UU7 8
edgeUU8 <
.UU< =
commonUU= C
.UUC D
bUUD E
)UUE F
;UUF G
slideXX 
.XX 
AddXX 
(XX 
weXX 
.XX 
edgeXX !
.XX! "
commonXX" (
.XX( )
aXX) *
)XX* +
;XX+ ,
slideYY 
.YY 
AddYY 
(YY 
weYY 
.YY 
edgeYY !
.YY! "
commonYY" (
.YY( )
bYY) *
)YY* +
;YY+ ,
	SlideEdge[[ 
([[ 
vertices[[ "
,[[" #
we[[$ &
,[[& '
amount[[( .
)[[. /
;[[/ 0
	SlideEdge\\ 
(\\ 
vertices\\ "
,\\" #
we\\$ &
.\\& '
opposite\\' /
,\\/ 0
amount\\1 7
)\\7 8
;\\8 9
appendFaces^^ 
.^^ 
AddRange^^ $
(^^$ %
GetBridgeFaces^^% 3
(^^3 4
vertices^^4 <
,^^< =
we^^> @
,^^@ A
we^^B D
.^^D E
opposite^^E M
,^^M N
holes^^O T
)^^T U
)^^U V
;^^V W
}__ 
ifaa 
(aa 
beveledaa 
<aa 
$numaa 
)aa 
{bb 
Logcc 
.cc 
Infocc 
(cc 
$strcc 2
)cc2 3
;cc3 4
returndd 
nulldd 
;dd 
}ee 
varii 
createdFacesii 
=ii 
newii "
Listii# '
<ii' (
Faceii( ,
>ii, -
(ii- .
appendFacesii. 9
.ii9 :
Selectii: @
(ii@ A
xiiA B
=>iiC E
xiiF G
.iiG H
faceiiH L
)iiL M
)iiM N
;iiN O

Dictionarykk 
<kk 
Facekk 
,kk 
Listkk !
<kk! "
SimpleTuplekk" -
<kk- .

WingedEdgekk. 8
,kk8 9
intkk: =
>kk= >
>kk> ?
>kk? @
sortedkkA G
=kkH I
newkkJ M

DictionarykkN X
<kkX Y
FacekkY ]
,kk] ^
Listkk_ c
<kkc d
SimpleTuplekkd o
<kko p

WingedEdgekkp z
,kkz {
intkk| 
>	kk €
>
kk€ 
>
kk ‚
(
kk‚ ƒ
)
kkƒ „
;
kk„ …
foreachoo 
(oo 
intoo 
coo 
inoo 
slideoo #
)oo# $
{pp 
IEnumerableqq 
<qq 

WingedEdgeqq &
>qq& '
matchesqq( /
=qq0 1
wingsqq2 7
.qq7 8
Whereqq8 =
(qq= >
xqq> ?
=>qq@ B
xqqC D
.qqD E
edgeqqE I
.qqI J
commonqqJ P
.qqP Q
ContainsqqQ Y
(qqY Z
cqqZ [
)qq[ \
&&qq] _
!qq` a
(qqa b
ignoreqqb h
.qqh i
ContainsKeyqqi t
(qqt u
xqqu v
.qqv w
faceqqw {
)qq{ |
&&qq} 
ignore
qq€ †
[
qq† ‡
x
qq‡ ˆ
.
qqˆ ‰
face
qq‰ 
]
qq 
.
qq 
Contains
qq —
(
qq— ˜
c
qq˜ ™
)
qq™ š
)
qqš ›
)
qq› œ
;
qqœ 
HashSetss 
<ss 
Facess 
>ss 
usedss "
=ss# $
newss% (
HashSetss) 0
<ss0 1
Facess1 5
>ss5 6
(ss6 7
)ss7 8
;ss8 9
foreachuu 
(uu 

WingedEdgeuu #
matchuu$ )
inuu* ,
matchesuu- 4
)uu4 5
{vv 
ifww 
(ww 
!ww 
usedww 
.ww 
Addww !
(ww! "
matchww" '
.ww' (
faceww( ,
)ww, -
)ww- .
continuexx  
;xx  !
sortedzz 
.zz 
AddOrAppendzz &
(zz& '
matchzz' ,
.zz, -
facezz- 1
,zz1 2
newzz3 6
SimpleTuplezz7 B
<zzB C

WingedEdgezzC M
,zzM N
intzzO R
>zzR S
(zzS T
matchzzT Y
,zzY Z
czz[ \
)zz\ ]
)zz] ^
;zz^ _
}{{ 
}|| 
foreach 
( 
KeyValuePair !
<! "
Face" &
,& '
List( ,
<, -
SimpleTuple- 8
<8 9

WingedEdge9 C
,C D
intE H
>H I
>I J
>J K
kvpL O
inP R
sortedS Y
)Y Z
{
€€ 

Dictionary
‚‚ 
<
‚‚ 
int
‚‚ 
,
‚‚ 
List
‚‚  $
<
‚‚$ %
int
‚‚% (
>
‚‚( )
>
‚‚) *
appended
‚‚+ 3
;
‚‚3 4
FaceRebuildData
„„ 
f
„„  !
=
„„" #
VertexEditing
„„$ 1
.
„„1 2
ExplodeVertex
„„2 ?
(
„„? @
vertices
„„@ H
,
„„H I
kvp
„„J M
.
„„M N
Value
„„N S
,
„„S T
amount
„„U [
,
„„[ \
out
„„] `
appended
„„a i
)
„„i j
;
„„j k
if
†† 
(
†† 
f
†† 
==
†† 
null
†† 
)
†† 
continue
‡‡ 
;
‡‡ 
appendFaces
‰‰ 
.
‰‰ 
Add
‰‰ 
(
‰‰  
f
‰‰  !
)
‰‰! "
;
‰‰" #
foreach
‹‹ 
(
‹‹ 
var
‹‹ 
apv
‹‹  
in
‹‹! #
appended
‹‹$ ,
)
‹‹, -
{
ŒŒ 
holes
 
.
 
AddOrAppend
 %
(
% &
apv
& )
.
) *
Key
* -
,
- .
new
/ 2
SimpleTuple
3 >
<
> ?
FaceRebuildData
? N
,
N O
List
P T
<
T U
int
U X
>
X Y
>
Y Z
(
Z [
f
[ \
,
\ ]
apv
^ a
.
a b
Value
b g
)
g h
)
h i
;
i j
}
 
}
‘‘ 
FaceRebuildData
““ 
.
““ 
Apply
““ !
(
““! "
appendFaces
““" -
,
““- .
mesh
““/ 3
,
““3 4
vertices
““5 =
)
““= >
;
““> ?
int
”” 
removed
”” 
=
”” 
mesh
”” 
.
”” 
DeleteFaces
”” *
(
””* +
sorted
””+ 1
.
””1 2
Keys
””2 6
)
””6 7
.
””7 8
Length
””8 >
;
””> ?
mesh
•• 
.
•• 
sharedTextures
•• 
=
••  !
new
••" %
SharedVertex
••& 2
[
••2 3
$num
••3 4
]
••4 5
;
••5 6
mesh
–– 
.
–– 
sharedVertices
–– 
=
––  !
SharedVertex
––" .
.
––. /,
GetSharedVerticesWithPositions
––/ M
(
––M N
mesh
––N R
.
––R S
positionsInternal
––S d
)
––d e
;
––e f
SharedVertex
™™ 
[
™™ 
]
™™ 
sharedIndexes
™™ (
=
™™) *
mesh
™™+ /
.
™™/ 0$
sharedVerticesInternal
™™0 F
;
™™F G
lookup
šš 
=
šš 
mesh
šš 
.
šš  
sharedVertexLookup
šš ,
;
šš, -
List
›› 
<
›› 
HashSet
›› 
<
›› 
int
›› 
>
›› 
>
››  
holesCommonIndexes
›› 1
=
››2 3
new
››4 7
List
››8 <
<
››< =
HashSet
››= D
<
››D E
int
››E H
>
››H I
>
››I J
(
››J K
)
››K L
;
››L M
foreach
 
(
 
KeyValuePair
 !
<
! "
int
" %
,
% &
List
' +
<
+ ,
SimpleTuple
, 7
<
7 8
FaceRebuildData
8 G
,
G H
List
I M
<
M N
int
N Q
>
Q R
>
R S
>
S T
>
T U
hole
V Z
in
[ ]
holes
^ c
)
c d
{
ŸŸ 
if
¡¡ 
(
¡¡ 
hole
¡¡ 
.
¡¡ 
Value
¡¡ 
.
¡¡ 
Sum
¡¡ "
(
¡¡" #
x
¡¡# $
=>
¡¡% '
x
¡¡( )
.
¡¡) *
item2
¡¡* /
.
¡¡/ 0
Count
¡¡0 5
)
¡¡5 6
<
¡¡7 8
$num
¡¡9 :
)
¡¡: ;
continue
¢¢ 
;
¢¢ 
HashSet
¤¤ 
<
¤¤ 
int
¤¤ 
>
¤¤ 

holeCommon
¤¤ '
=
¤¤( )
new
¤¤* -
HashSet
¤¤. 5
<
¤¤5 6
int
¤¤6 9
>
¤¤9 :
(
¤¤: ;
)
¤¤; <
;
¤¤< =
foreach
¦¦ 
(
¦¦ 
SimpleTuple
¦¦ $
<
¦¦$ %
FaceRebuildData
¦¦% 4
,
¦¦4 5
List
¦¦6 :
<
¦¦: ;
int
¦¦; >
>
¦¦> ?
>
¦¦? @
path
¦¦A E
in
¦¦F H
hole
¦¦I M
.
¦¦M N
Value
¦¦N S
)
¦¦S T
{
§§ 
int
¨¨ 
offset
¨¨ 
=
¨¨  
path
¨¨! %
.
¨¨% &
item1
¨¨& +
.
¨¨+ ,
Offset
¨¨, 2
(
¨¨2 3
)
¨¨3 4
-
¨¨5 6
removed
¨¨7 >
;
¨¨> ?
for
ªª 
(
ªª 
int
ªª 
i
ªª 
=
ªª  
$num
ªª! "
;
ªª" #
i
ªª$ %
<
ªª& '
path
ªª( ,
.
ªª, -
item2
ªª- 2
.
ªª2 3
Count
ªª3 8
;
ªª8 9
i
ªª: ;
++
ªª; =
)
ªª= >

holeCommon
«« "
.
««" #
Add
««# &
(
««& '
lookup
««' -
[
««- .
path
««. 2
.
««2 3
item2
««3 8
[
««8 9
i
««9 :
]
««: ;
+
««< =
offset
««> D
]
««D E
)
««E F
;
««F G
}
¬¬  
holesCommonIndexes
®® "
.
®®" #
Add
®®# &
(
®®& '

holeCommon
®®' 1
)
®®1 2
;
®®2 3
}
¯¯ 
List
±± 
<
±± 

WingedEdge
±± 
>
±± 
modified
±± %
=
±±& '

WingedEdge
±±( 2
.
±±2 3
GetWingedEdges
±±3 A
(
±±A B
mesh
±±B F
,
±±F G
appendFaces
±±H S
.
±±S T
Select
±±T Z
(
±±Z [
x
±±[ \
=>
±±] _
x
±±` a
.
±±a b
face
±±b f
)
±±f g
)
±±g h
;
±±h i
vertices
´´ 
=
´´ 
new
´´ 
List
´´ 
<
´´  
Vertex
´´  &
>
´´& '
(
´´' (
mesh
´´( ,
.
´´, -
GetVertices
´´- 8
(
´´8 9
)
´´9 :
)
´´: ;
;
´´; <
List
¶¶ 
<
¶¶ 
FaceRebuildData
¶¶  
>
¶¶  !
	holeFaces
¶¶" +
=
¶¶, -
new
¶¶. 1
List
¶¶2 6
<
¶¶6 7
FaceRebuildData
¶¶7 F
>
¶¶F G
(
¶¶G H
)
¶¶H I
;
¶¶I J
foreach
¸¸ 
(
¸¸ 
HashSet
¸¸ 
<
¸¸ 
int
¸¸  
>
¸¸  !
h
¸¸" #
in
¸¸$ & 
holesCommonIndexes
¸¸' 9
)
¸¸9 :
{
¹¹ 
if
¼¼ 
(
¼¼ 
h
¼¼ 
.
¼¼ 
Count
¼¼ 
<
¼¼ 
$num
¼¼ 
)
¼¼  
{
½½ 
continue
¾¾ 
;
¾¾ 
}
¿¿ 
if
ÁÁ 
(
ÁÁ 
h
ÁÁ 
.
ÁÁ 
Count
ÁÁ 
<
ÁÁ 
$num
ÁÁ 
)
ÁÁ  
{
ÂÂ 
List
ÃÃ 
<
ÃÃ 
Vertex
ÃÃ 
>
ÃÃ  
v
ÃÃ! "
=
ÃÃ# $
new
ÃÃ% (
List
ÃÃ) -
<
ÃÃ- .
Vertex
ÃÃ. 4
>
ÃÃ4 5
(
ÃÃ5 6
mesh
ÃÃ6 :
.
ÃÃ: ;
GetVertices
ÃÃ; F
(
ÃÃF G
h
ÃÃG H
.
ÃÃH I
Select
ÃÃI O
(
ÃÃO P
x
ÃÃP Q
=>
ÃÃR T
sharedIndexes
ÃÃU b
[
ÃÃb c
x
ÃÃc d
]
ÃÃd e
[
ÃÃe f
$num
ÃÃf g
]
ÃÃg h
)
ÃÃh i
.
ÃÃi j
ToList
ÃÃj p
(
ÃÃp q
)
ÃÃq r
)
ÃÃr s
)
ÃÃs t
;
ÃÃt u
	holeFaces
ÄÄ 
.
ÄÄ 
Add
ÄÄ !
(
ÄÄ! "
AppendElements
ÄÄ" 0
.
ÄÄ0 1
FaceWithVertices
ÄÄ1 A
(
ÄÄA B
v
ÄÄB C
)
ÄÄC D
)
ÄÄD E
;
ÄÄE F
}
ÅÅ 
else
ÇÇ 
{
ÈÈ 
List
ÉÉ 
<
ÉÉ 
int
ÉÉ 
>
ÉÉ 
holePath
ÉÉ &
=
ÉÉ' (

WingedEdge
ÉÉ) 3
.
ÉÉ3 4*
SortCommonIndexesByAdjacency
ÉÉ4 P
(
ÉÉP Q
modified
ÉÉQ Y
,
ÉÉY Z
h
ÉÉ[ \
)
ÉÉ\ ]
;
ÉÉ] ^
if
ÊÊ 
(
ÊÊ 
holePath
ÊÊ  
!=
ÊÊ! #
null
ÊÊ$ (
)
ÊÊ( )
{
ËË 
List
ÌÌ 
<
ÌÌ 
Vertex
ÌÌ #
>
ÌÌ# $
v
ÌÌ% &
=
ÌÌ' (
new
ÍÍ 
List
ÍÍ  $
<
ÍÍ$ %
Vertex
ÍÍ% +
>
ÍÍ+ ,
(
ÍÍ, -
mesh
ÍÍ- 1
.
ÍÍ1 2
GetVertices
ÍÍ2 =
(
ÍÍ= >
holePath
ÍÍ> F
.
ÍÍF G
Select
ÍÍG M
(
ÍÍM N
x
ÍÍN O
=>
ÍÍP R
sharedIndexes
ÍÍS `
[
ÍÍ` a
x
ÍÍa b
]
ÍÍb c
[
ÍÍc d
$num
ÍÍd e
]
ÍÍe f
)
ÍÍf g
.
ÍÍg h
ToList
ÍÍh n
(
ÍÍn o
)
ÍÍo p
)
ÍÍp q
)
ÍÍq r
;
ÍÍr s
	holeFaces
ÎÎ !
.
ÎÎ! "
AddRange
ÎÎ" *
(
ÎÎ* +
AppendElements
ÎÎ+ 9
.
ÎÎ9 :!
TentCapWithVertices
ÎÎ: M
(
ÎÎM N
v
ÎÎN O
)
ÎÎO P
)
ÎÎP Q
;
ÎÎQ R
}
ÏÏ 
}
ĞĞ 
}
ÑÑ 
FaceRebuildData
ÓÓ 
.
ÓÓ 
Apply
ÓÓ !
(
ÓÓ! "
	holeFaces
ÓÓ" +
,
ÓÓ+ ,
mesh
ÓÓ- 1
,
ÓÓ1 2
vertices
ÓÓ3 ;
)
ÓÓ; <
;
ÓÓ< =
mesh
ÔÔ 
.
ÔÔ 
sharedVertices
ÔÔ 
=
ÔÔ  !
SharedVertex
ÔÔ" .
.
ÔÔ. /,
GetSharedVerticesWithPositions
ÔÔ/ M
(
ÔÔM N
mesh
ÔÔN R
.
ÔÔR S
positionsInternal
ÔÔS d
)
ÔÔd e
;
ÔÔe f
HashSet
ÚÚ 
<
ÚÚ 
Face
ÚÚ 
>
ÚÚ 
newFaces
ÚÚ "
=
ÚÚ# $
new
ÚÚ% (
HashSet
ÚÚ) 0
<
ÚÚ0 1
Face
ÚÚ1 5
>
ÚÚ5 6
(
ÚÚ6 7
	holeFaces
ÚÚ7 @
.
ÚÚ@ A
Select
ÚÚA G
(
ÚÚG H
x
ÚÚH I
=>
ÚÚJ L
x
ÚÚM N
.
ÚÚN O
face
ÚÚO S
)
ÚÚS T
)
ÚÚT U
;
ÚÚU V
newFaces
ÛÛ 
.
ÛÛ 
	UnionWith
ÛÛ 
(
ÛÛ 
createdFaces
ÛÛ +
)
ÛÛ+ ,
;
ÛÛ, -
appendFaces
İİ 
.
İİ 
AddRange
İİ  
(
İİ  !
	holeFaces
İİ! *
)
İİ* +
;
İİ+ ,
List
ßß 
<
ßß 

WingedEdge
ßß 
>
ßß 
allNewFaceEdges
ßß ,
=
ßß- .

WingedEdge
ßß/ 9
.
ßß9 :
GetWingedEdges
ßß: H
(
ßßH I
mesh
ßßI M
,
ßßM N
appendFaces
ßßO Z
.
ßßZ [
Select
ßß[ a
(
ßßa b
x
ßßb c
=>
ßßd f
x
ßßg h
.
ßßh i
face
ßßi m
)
ßßm n
)
ßßn o
;
ßßo p
for
áá 
(
áá 
int
áá 
i
áá 
=
áá 
$num
áá 
;
áá 
i
áá 
<
áá 
allNewFaceEdges
áá  /
.
áá/ 0
Count
áá0 5
&&
áá6 8
newFaces
áá9 A
.
ááA B
Count
ááB G
>
ááH I
$num
ááJ K
;
ááK L
i
ááM N
++
ááN P
)
ááP Q
{
ââ 

WingedEdge
ãã 
wing
ãã 
=
ãã  !
allNewFaceEdges
ãã" 1
[
ãã1 2
i
ãã2 3
]
ãã3 4
;
ãã4 5
if
åå 
(
åå 
newFaces
åå 
.
åå 
Contains
åå %
(
åå% &
wing
åå& *
.
åå* +
face
åå+ /
)
åå/ 0
)
åå0 1
{
ææ 
newFaces
çç 
.
çç 
Remove
çç #
(
çç# $
wing
çç$ (
.
çç( )
face
çç) -
)
çç- .
;
çç. /
using
ìì 
(
ìì 
var
ìì 
it
ìì !
=
ìì" #
new
ìì$ '"
WingedEdgeEnumerator
ìì( <
(
ìì< =
wing
ìì= A
)
ììA B
)
ììB C
{
íí 
while
îî 
(
îî 
it
îî !
.
îî! "
MoveNext
îî" *
(
îî* +
)
îî+ ,
)
îî, -
{
ïï 
var
ğğ 
w
ğğ  !
=
ğğ" #
it
ğğ$ &
.
ğğ& '
Current
ğğ' .
;
ğğ. /
if
òò 
(
òò  
w
òò  !
.
òò! "
opposite
òò" *
!=
òò+ -
null
òò. 2
&&
òò3 5
!
òò6 7
newFaces
òò7 ?
.
òò? @
Contains
òò@ H
(
òòH I
w
òòI J
.
òòJ K
opposite
òòK S
.
òòS T
face
òòT X
)
òòX Y
)
òòY Z
{
óó 
w
ôô  !
.
ôô! "
face
ôô" &
.
ôô& '
submeshIndex
ôô' 3
=
ôô4 5
w
ôô6 7
.
ôô7 8
opposite
ôô8 @
.
ôô@ A
face
ôôA E
.
ôôE F
submeshIndex
ôôF R
;
ôôR S
w
õõ  !
.
õõ! "
face
õõ" &
.
õõ& '
uv
õõ' )
=
õõ* +
new
õõ, / 
AutoUnwrapSettings
õõ0 B
(
õõB C
w
õõC D
.
õõD E
opposite
õõE M
.
õõM N
face
õõN R
.
õõR S
uv
õõS U
)
õõU V
;
õõV W
SurfaceTopology
öö  /
.
öö/ 0#
ConformOppositeNormal
öö0 E
(
ööE F
w
ööF G
.
ööG H
opposite
ööH P
)
ööP Q
;
ööQ R
break
÷÷  %
;
÷÷% &
}
øø 
}
ùù 
}
úú 
}
ûû 
}
üü 
mesh
şş 
.
şş 
ToMesh
şş 
(
şş 
)
şş 
;
şş 
return
€€ 
createdFaces
€€ 
;
€€  
}
 	
static
ƒƒ 
readonly
ƒƒ 
int
ƒƒ 
[
ƒƒ 
]
ƒƒ  
k_BridgeIndexesTri
ƒƒ 0
=
ƒƒ1 2
new
ƒƒ3 6
int
ƒƒ7 :
[
ƒƒ: ;
]
ƒƒ; <
{
ƒƒ= >
$num
ƒƒ? @
,
ƒƒ@ A
$num
ƒƒB C
,
ƒƒC D
$num
ƒƒE F
}
ƒƒG H
;
ƒƒH I
static
…… 
List
…… 
<
…… 
FaceRebuildData
…… #
>
……# $
GetBridgeFaces
……% 3
(
……3 4
IList
†† 
<
†† 
Vertex
†† 
>
†† 
vertices
†† "
,
††" #

WingedEdge
‡‡ 
left
‡‡ 
,
‡‡ 

WingedEdge
ˆˆ 
right
ˆˆ 
,
ˆˆ 

Dictionary
‰‰ 
<
‰‰ 
int
‰‰ 
,
‰‰ 
List
‰‰  
<
‰‰  !
SimpleTuple
‰‰! ,
<
‰‰, -
FaceRebuildData
‰‰- <
,
‰‰< =
List
‰‰> B
<
‰‰B C
int
‰‰C F
>
‰‰F G
>
‰‰G H
>
‰‰H I
>
‰‰I J
holes
‰‰K P
)
‰‰P Q
{
ŠŠ 	
List
‹‹ 
<
‹‹ 
FaceRebuildData
‹‹  
>
‹‹  !
faces
‹‹" '
=
‹‹( )
new
‹‹* -
List
‹‹. 2
<
‹‹2 3
FaceRebuildData
‹‹3 B
>
‹‹B C
(
‹‹C D
)
‹‹D E
;
‹‹E F
FaceRebuildData
 
rf
 
=
  
new
! $
FaceRebuildData
% 4
(
4 5
)
5 6
;
6 7

EdgeLookup
 
a
 
=
 
left
 
.
  
edge
  $
;
$ %

EdgeLookup
 
b
 
=
 
right
  
.
  !
edge
! %
;
% &
rf
’’ 
.
’’ 
vertices
’’ 
=
’’ 
new
’’ 
List
’’ "
<
’’" #
Vertex
’’# )
>
’’) *
(
’’* +
)
’’+ ,
{
““ 
vertices
”” 
[
”” 
a
”” 
.
”” 
local
””  
.
””  !
a
””! "
]
””" #
,
””# $
vertices
•• 
[
•• 
a
•• 
.
•• 
local
••  
.
••  !
b
••! "
]
••" #
,
••# $
vertices
–– 
[
–– 
a
–– 
.
–– 
common
–– !
.
––! "
a
––" #
==
––$ &
b
––' (
.
––( )
common
––) /
.
––/ 0
a
––0 1
?
––2 3
b
––4 5
.
––5 6
local
––6 ;
.
––; <
a
––< =
:
––> ?
b
––@ A
.
––A B
local
––B G
.
––G H
b
––H I
]
––I J
,
––J K
vertices
—— 
[
—— 
a
—— 
.
—— 
common
—— !
.
——! "
a
——" #
==
——$ &
b
——' (
.
——( )
common
——) /
.
——/ 0
a
——0 1
?
——2 3
b
——4 5
.
——5 6
local
——6 ;
.
——; <
b
——< =
:
——> ?
b
——@ A
.
——A B
local
——B G
.
——G H
a
——H I
]
——I J
}
˜˜ 
;
˜˜ 
Vector3
šš 
an
šš 
=
šš 
Math
šš 
.
šš 
Normal
šš $
(
šš$ %
vertices
šš% -
,
šš- .
left
šš/ 3
.
šš3 4
face
šš4 8
.
šš8 9
indexesInternal
šš9 H
)
ššH I
;
ššI J
Vector3
›› 
bn
›› 
=
›› 
Math
›› 
.
›› 
Normal
›› $
(
››$ %
rf
››% '
.
››' (
vertices
››( 0
,
››0 1 
k_BridgeIndexesTri
››2 D
)
››D E
;
››E F
int
 
[
 
]
 
	triangles
 
=
 
new
 !
int
" %
[
% &
]
& '
{
( )
$num
* +
,
+ ,
$num
- .
,
. /
$num
0 1
,
1 2
$num
3 4
,
4 5
$num
6 7
,
7 8
$num
9 :
}
; <
;
< =
if
ŸŸ 
(
ŸŸ 
Vector3
ŸŸ 
.
ŸŸ 
Dot
ŸŸ 
(
ŸŸ 
an
ŸŸ 
,
ŸŸ 
bn
ŸŸ  "
)
ŸŸ" #
<
ŸŸ$ %
$num
ŸŸ& (
)
ŸŸ( )
System
   
.
   
Array
   
.
   
Reverse
   $
(
  $ %
	triangles
  % .
)
  . /
;
  / 0
rf
¢¢ 
.
¢¢ 
face
¢¢ 
=
¢¢ 
new
¢¢ 
Face
¢¢ 
(
¢¢ 
	triangles
££ 
,
££ 
left
¤¤ 
.
¤¤ 
face
¤¤ 
.
¤¤ 
submeshIndex
¤¤ *
,
¤¤* + 
AutoUnwrapSettings
¥¥ &
.
¥¥& '
tile
¥¥' +
,
¥¥+ ,
-
¦¦ 
$num
¦¦ 
,
¦¦ 
-
§§ 
$num
§§ 
,
§§ 
-
¨¨ 
$num
¨¨ 
,
¨¨ 
false
©© 
)
©© 
;
©© 
faces
«« 
.
«« 
Add
«« 
(
«« 
rf
«« 
)
«« 
;
«« 
holes
­­ 
.
­­ 
AddOrAppend
­­ 
(
­­ 
a
­­ 
.
­­  
common
­­  &
.
­­& '
a
­­' (
,
­­( )
new
­­* -
SimpleTuple
­­. 9
<
­­9 :
FaceRebuildData
­­: I
,
­­I J
List
­­K O
<
­­O P
int
­­P S
>
­­S T
>
­­T U
(
­­U V
rf
­­V X
,
­­X Y
new
­­Z ]
List
­­^ b
<
­­b c
int
­­c f
>
­­f g
(
­­g h
)
­­h i
{
­­j k
$num
­­l m
,
­­m n
$num
­­o p
}
­­q r
)
­­r s
)
­­s t
;
­­t u
holes
®® 
.
®® 
AddOrAppend
®® 
(
®® 
a
®® 
.
®®  
common
®®  &
.
®®& '
b
®®' (
,
®®( )
new
®®* -
SimpleTuple
®®. 9
<
®®9 :
FaceRebuildData
®®: I
,
®®I J
List
®®K O
<
®®O P
int
®®P S
>
®®S T
>
®®T U
(
®®U V
rf
®®V X
,
®®X Y
new
®®Z ]
List
®®^ b
<
®®b c
int
®®c f
>
®®f g
(
®®g h
)
®®h i
{
®®j k
$num
®®l m
,
®®m n
$num
®®o p
}
®®q r
)
®®r s
)
®®s t
;
®®t u
return
°° 
faces
°° 
;
°° 
}
±± 	
static
³³ 
void
³³ 
	SlideEdge
³³ 
(
³³ 
IList
³³ #
<
³³# $
Vertex
³³$ *
>
³³* +
vertices
³³, 4
,
³³4 5

WingedEdge
³³6 @
we
³³A C
,
³³C D
float
³³E J
amount
³³K Q
)
³³Q R
{
´´ 	
we
µµ 
.
µµ 
face
µµ 
.
µµ 
manualUV
µµ 
=
µµ 
true
µµ #
;
µµ# $
we
¶¶ 
.
¶¶ 
face
¶¶ 
.
¶¶ 
textureGroup
¶¶  
=
¶¶! "
-
¶¶# $
$num
¶¶$ %
;
¶¶% &
Edge
¸¸ 
slide_x
¸¸ 
=
¸¸ 
GetLeadingEdge
¸¸ )
(
¸¸) *
we
¸¸* ,
,
¸¸, -
we
¸¸. 0
.
¸¸0 1
edge
¸¸1 5
.
¸¸5 6
common
¸¸6 <
.
¸¸< =
a
¸¸= >
)
¸¸> ?
;
¸¸? @
Edge
¹¹ 
slide_y
¹¹ 
=
¹¹ 
GetLeadingEdge
¹¹ )
(
¹¹) *
we
¹¹* ,
,
¹¹, -
we
¹¹. 0
.
¹¹0 1
edge
¹¹1 5
.
¹¹5 6
common
¹¹6 <
.
¹¹< =
b
¹¹= >
)
¹¹> ?
;
¹¹? @
if
»» 
(
»» 
!
»» 
slide_x
»» 
.
»» 
IsValid
»»  
(
»»  !
)
»»! "
||
»»# %
!
»»& '
slide_y
»»' .
.
»». /
IsValid
»»/ 6
(
»»6 7
)
»»7 8
)
»»8 9
return
¼¼ 
;
¼¼ 
Vertex
¾¾ 
x
¾¾ 
=
¾¾ 
(
¾¾ 
vertices
¾¾  
[
¾¾  !
slide_x
¾¾! (
.
¾¾( )
a
¾¾) *
]
¾¾* +
-
¾¾, -
vertices
¾¾. 6
[
¾¾6 7
slide_x
¾¾7 >
.
¾¾> ?
b
¾¾? @
]
¾¾@ A
)
¾¾A B
;
¾¾B C
x
¿¿ 
.
¿¿ 
	Normalize
¿¿ 
(
¿¿ 
)
¿¿ 
;
¿¿ 
Vertex
ÁÁ 
y
ÁÁ 
=
ÁÁ 
(
ÁÁ 
vertices
ÁÁ  
[
ÁÁ  !
slide_y
ÁÁ! (
.
ÁÁ( )
a
ÁÁ) *
]
ÁÁ* +
-
ÁÁ, -
vertices
ÁÁ. 6
[
ÁÁ6 7
slide_y
ÁÁ7 >
.
ÁÁ> ?
b
ÁÁ? @
]
ÁÁ@ A
)
ÁÁA B
;
ÁÁB C
y
ÂÂ 
.
ÂÂ 
	Normalize
ÂÂ 
(
ÂÂ 
)
ÂÂ 
;
ÂÂ 
vertices
ÅÅ 
[
ÅÅ 
we
ÅÅ 
.
ÅÅ 
edge
ÅÅ 
.
ÅÅ 
local
ÅÅ "
.
ÅÅ" #
a
ÅÅ# $
]
ÅÅ$ %
.
ÅÅ% &
Add
ÅÅ& )
(
ÅÅ) *
x
ÅÅ* +
*
ÅÅ, -
amount
ÅÅ. 4
)
ÅÅ4 5
;
ÅÅ5 6
vertices
ÆÆ 
[
ÆÆ 
we
ÆÆ 
.
ÆÆ 
edge
ÆÆ 
.
ÆÆ 
local
ÆÆ "
.
ÆÆ" #
b
ÆÆ# $
]
ÆÆ$ %
.
ÆÆ% &
Add
ÆÆ& )
(
ÆÆ) *
y
ÆÆ* +
*
ÆÆ, -
amount
ÆÆ. 4
)
ÆÆ4 5
;
ÆÆ5 6
}
ÇÇ 	
static
ÉÉ 
Edge
ÉÉ 
GetLeadingEdge
ÉÉ "
(
ÉÉ" #

WingedEdge
ÉÉ# -
wing
ÉÉ. 2
,
ÉÉ2 3
int
ÉÉ4 7
common
ÉÉ8 >
)
ÉÉ> ?
{
ÊÊ 	
if
ËË 
(
ËË 
wing
ËË 
.
ËË 
previous
ËË 
.
ËË 
edge
ËË "
.
ËË" #
common
ËË# )
.
ËË) *
a
ËË* +
==
ËË, .
common
ËË/ 5
)
ËË5 6
return
ÌÌ 
new
ÌÌ 
Edge
ÌÌ 
(
ÌÌ  
wing
ÌÌ  $
.
ÌÌ$ %
previous
ÌÌ% -
.
ÌÌ- .
edge
ÌÌ. 2
.
ÌÌ2 3
local
ÌÌ3 8
.
ÌÌ8 9
b
ÌÌ9 :
,
ÌÌ: ;
wing
ÌÌ< @
.
ÌÌ@ A
previous
ÌÌA I
.
ÌÌI J
edge
ÌÌJ N
.
ÌÌN O
local
ÌÌO T
.
ÌÌT U
a
ÌÌU V
)
ÌÌV W
;
ÌÌW X
else
ÍÍ 
if
ÍÍ 
(
ÍÍ 
wing
ÍÍ 
.
ÍÍ 
previous
ÍÍ "
.
ÍÍ" #
edge
ÍÍ# '
.
ÍÍ' (
common
ÍÍ( .
.
ÍÍ. /
b
ÍÍ/ 0
==
ÍÍ1 3
common
ÍÍ4 :
)
ÍÍ: ;
return
ÎÎ 
new
ÎÎ 
Edge
ÎÎ 
(
ÎÎ  
wing
ÎÎ  $
.
ÎÎ$ %
previous
ÎÎ% -
.
ÎÎ- .
edge
ÎÎ. 2
.
ÎÎ2 3
local
ÎÎ3 8
.
ÎÎ8 9
a
ÎÎ9 :
,
ÎÎ: ;
wing
ÎÎ< @
.
ÎÎ@ A
previous
ÎÎA I
.
ÎÎI J
edge
ÎÎJ N
.
ÎÎN O
local
ÎÎO T
.
ÎÎT U
b
ÎÎU V
)
ÎÎV W
;
ÎÎW X
else
ÏÏ 
if
ÏÏ 
(
ÏÏ 
wing
ÏÏ 
.
ÏÏ 
next
ÏÏ 
.
ÏÏ 
edge
ÏÏ #
.
ÏÏ# $
common
ÏÏ$ *
.
ÏÏ* +
a
ÏÏ+ ,
==
ÏÏ- /
common
ÏÏ0 6
)
ÏÏ6 7
return
ĞĞ 
new
ĞĞ 
Edge
ĞĞ 
(
ĞĞ  
wing
ĞĞ  $
.
ĞĞ$ %
next
ĞĞ% )
.
ĞĞ) *
edge
ĞĞ* .
.
ĞĞ. /
local
ĞĞ/ 4
.
ĞĞ4 5
b
ĞĞ5 6
,
ĞĞ6 7
wing
ĞĞ8 <
.
ĞĞ< =
next
ĞĞ= A
.
ĞĞA B
edge
ĞĞB F
.
ĞĞF G
local
ĞĞG L
.
ĞĞL M
a
ĞĞM N
)
ĞĞN O
;
ĞĞO P
else
ÑÑ 
if
ÑÑ 
(
ÑÑ 
wing
ÑÑ 
.
ÑÑ 
next
ÑÑ 
.
ÑÑ 
edge
ÑÑ #
.
ÑÑ# $
common
ÑÑ$ *
.
ÑÑ* +
b
ÑÑ+ ,
==
ÑÑ- /
common
ÑÑ0 6
)
ÑÑ6 7
return
ÒÒ 
new
ÒÒ 
Edge
ÒÒ 
(
ÒÒ  
wing
ÒÒ  $
.
ÒÒ$ %
next
ÒÒ% )
.
ÒÒ) *
edge
ÒÒ* .
.
ÒÒ. /
local
ÒÒ/ 4
.
ÒÒ4 5
a
ÒÒ5 6
,
ÒÒ6 7
wing
ÒÒ8 <
.
ÒÒ< =
next
ÒÒ= A
.
ÒÒA B
edge
ÒÒB F
.
ÒÒF G
local
ÒÒG L
.
ÒÒL M
b
ÒÒM N
)
ÒÒN O
;
ÒÒO P
return
ÔÔ 
Edge
ÔÔ 
.
ÔÔ 
Empty
ÔÔ 
;
ÔÔ 
}
ÕÕ 	
}
ÖÖ 
}×× ÍÅ
šD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\ConnectElements.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
sealed 

class "
ConnectFaceRebuildData '
{ 
public 
FaceRebuildData 
faceRebuildData .
;. /
public 
List 
< 
int 
> 
newVertexIndexes )
;) *
public "
ConnectFaceRebuildData %
(% &
FaceRebuildData& 5
faceRebuildData6 E
,E F
ListG K
<K L
intL O
>O P
newVertexIndexesQ a
)a b
{ 	
this 
. 
faceRebuildData  
=! "
faceRebuildData# 2
;2 3
this 
. 
newVertexIndexes !
=" #
newVertexIndexes$ 4
;4 5
} 	
} 
public 

static 
class 
ConnectElements '
{ 
public"" 
static"" 
Face"" 
["" 
]"" 
Connect"" $
(""$ %
this""% )
ProBuilderMesh""* 8
mesh""9 =
,""= >
IEnumerable""? J
<""J K
Face""K O
>""O P
faces""Q V
)""V W
{## 	
var$$ 
split$$ 
=$$ 
MeshValidation$$ &
.$$& '7
+EnsureFacesAreComposedOfContiguousTriangles$$' R
($$R S
mesh$$S W
,$$W X
faces$$Y ^
)$$^ _
;$$_ `
HashSet%% 
<%% 
Face%% 
>%% 
mask%% 
=%%  
new%%! $
HashSet%%% ,
<%%, -
Face%%- 1
>%%1 2
(%%2 3
faces%%3 8
)%%8 9
;%%9 :
if&& 
(&& 
split&& 
.&& 
Count&& 
>&& 
$num&& 
)&&  
{'' 
foreach(( 
((( 
var(( 
face(( !
in((" $
split((% *
)((* +
mask)) 
.)) 
Add)) 
()) 
face)) !
)))! "
;))" #
}** 
IEnumerable++ 
<++ 
Edge++ 
>++ 
edges++ #
=++$ %
mask++& *
.++* +

SelectMany+++ 5
(++5 6
x++6 7
=>++8 :
x++; <
.++< =
edgesInternal++= J
)++J K
;++K L
Edge,, 
[,, 
],, 
empty,, 
;,, 
Face-- 
[-- 
]-- 
res-- 
;-- 
Connect.. 
(.. 
mesh.. 
,.. 
edges.. 
,..  
out..! $
res..% (
,..( )
out..* -
empty... 3
,..3 4
true..5 9
,..9 :
false..; @
,..@ A
mask..B F
)..F G
;..G H
return// 
res// 
;// 
}00 	
public88 
static88 
SimpleTuple88 !
<88! "
Face88" &
[88& '
]88' (
,88( )
Edge88* .
[88. /
]88/ 0
>880 1
Connect882 9
(889 :
this88: >
ProBuilderMesh88? M
mesh88N R
,88R S
IEnumerable88T _
<88_ `
Edge88` d
>88d e
edges88f k
)88k l
{99 	
Edge:: 
[:: 
]:: 
empty:: 
;:: 
Face;; 
[;; 
];; 
faces;; 
;;; 
Connect<< 
(<< 
mesh<< 
,<< 
edges<< 
,<<  
out<<! $
faces<<% *
,<<* +
out<<, /
empty<<0 5
,<<5 6
true<<7 ;
,<<; <
true<<= A
)<<A B
;<<B C
return== 
new== 
SimpleTuple== "
<==" #
Face==# '
[==' (
]==( )
,==) *
Edge==+ /
[==/ 0
]==0 1
>==1 2
(==2 3
faces==3 8
,==8 9
empty==: ?
)==? @
;==@ A
}>> 	
publicFF 
staticFF 
intFF 
[FF 
]FF 
ConnectFF #
(FF# $
thisFF$ (
ProBuilderMeshFF) 7
meshFF8 <
,FF< =
IListFF> C
<FFC D
intFFD G
>FFG H
indexesFFI P
)FFP Q
{GG 	
ifHH 
(HH 
meshHH 
==HH 
nullHH 
)HH 
throwII 
newII !
ArgumentNullExceptionII /
(II/ 0
$strII0 6
)II6 7
;II7 8
ifKK 
(KK 
indexesKK 
==KK 
nullKK 
)KK  
throwLL 
newLL !
ArgumentNullExceptionLL /
(LL/ 0
$strLL0 9
)LL9 :
;LL: ;
intNN 
sharedIndexOffsetNN !
=NN" #
meshNN$ (
.NN( )"
sharedVerticesInternalNN) ?
.NN? @
LengthNN@ F
;NNF G

DictionaryOO 
<OO 
intOO 
,OO 
intOO 
>OO  
lookupOO! '
=OO( )
meshOO* .
.OO. /
sharedVertexLookupOO/ A
;OOA B
HashSetQQ 
<QQ 
intQQ 
>QQ 
distinctQQ !
=QQ" #
newQQ$ '
HashSetQQ( /
<QQ/ 0
intQQ0 3
>QQ3 4
(QQ4 5
indexesQQ5 <
.QQ< =
SelectQQ= C
(QQC D
xQQD E
=>QQF H
lookupQQI O
[QQO P
xQQP Q
]QQQ R
)QQR S
)QQS T
;QQT U
HashSetRR 
<RR 
intRR 
>RR 
affectedRR !
=RR" #
newRR$ '
HashSetRR( /
<RR/ 0
intRR0 3
>RR3 4
(RR4 5
)RR5 6
;RR6 7
foreachTT 
(TT 
intTT 
iTT 
inTT 
distinctTT &
)TT& '
affectedUU 
.UU 
	UnionWithUU "
(UU" #
meshUU# '
.UU' ("
sharedVerticesInternalUU( >
[UU> ?
iUU? @
]UU@ A
.UUA B
arrayInternalUUB O
)UUO P
;UUP Q

DictionaryWW 
<WW 
FaceWW 
,WW 
ListWW !
<WW! "
intWW" %
>WW% &
>WW& '
splitsWW( .
=WW/ 0
newWW1 4

DictionaryWW5 ?
<WW? @
FaceWW@ D
,WWD E
ListWWF J
<WWJ K
intWWK N
>WWN O
>WWO P
(WWP Q
)WWQ R
;WWR S
ListXX 
<XX 
VertexXX 
>XX 
verticesXX !
=XX" #
newXX$ '
ListXX( ,
<XX, -
VertexXX- 3
>XX3 4
(XX4 5
meshXX5 9
.XX9 :
GetVerticesXX: E
(XXE F
)XXF G
)XXG H
;XXH I
foreachZZ 
(ZZ 
FaceZZ 
faceZZ 
inZZ !
meshZZ" &
.ZZ& '
facesInternalZZ' 4
)ZZ4 5
{[[ 
int\\ 
[\\ 
]\\ 
f\\ 
=\\ 
face\\ 
.\\ #
distinctIndexesInternal\\ 6
;\\6 7
for^^ 
(^^ 
int^^ 
i^^ 
=^^ 
$num^^ 
;^^ 
i^^  !
<^^" #
f^^$ %
.^^% &
Length^^& ,
;^^, -
i^^. /
++^^/ 1
)^^1 2
{__ 
if`` 
(`` 
affected``  
.``  !
Contains``! )
(``) *
f``* +
[``+ ,
i``, -
]``- .
)``. /
)``/ 0
splitsaa 
.aa 
AddOrAppendaa *
(aa* +
faceaa+ /
,aa/ 0
faa1 2
[aa2 3
iaa3 4
]aa4 5
)aa5 6
;aa6 7
}bb 
}cc 
Listee 
<ee "
ConnectFaceRebuildDataee '
>ee' (
appendFacesee) 4
=ee5 6
newee7 :
Listee; ?
<ee? @"
ConnectFaceRebuildDataee@ V
>eeV W
(eeW X
)eeX Y
;eeY Z
Listff 
<ff 
Faceff 
>ff 
successfulSplitsff '
=ff( )
newff* -
Listff. 2
<ff2 3
Faceff3 7
>ff7 8
(ff8 9
)ff9 :
;ff: ;
HashSetgg 
<gg 
intgg 
>gg 
usedTextureGroupsgg *
=gg+ ,
newgg- 0
HashSetgg1 8
<gg8 9
intgg9 <
>gg< =
(gg= >
meshgg> B
.ggB C
facesInternalggC P
.ggP Q
SelectggQ W
(ggW X
xggX Y
=>ggZ \
xgg] ^
.gg^ _
textureGroupgg_ k
)ggk l
)ggl m
;ggm n
inthh  
newTextureGroupIndexhh $
=hh% &
$numhh' (
;hh( )
foreachjj 
(jj 
KeyValuePairjj !
<jj! "
Facejj" &
,jj& '
Listjj( ,
<jj, -
intjj- 0
>jj0 1
>jj1 2
splitjj3 8
injj9 ;
splitsjj< B
)jjB C
{kk 
Facell 
facell 
=ll 
splitll !
.ll! "
Keyll" %
;ll% &
Listnn 
<nn "
ConnectFaceRebuildDatann +
>nn+ ,
resnn- 0
=nn1 2
splitnn3 8
.nn8 9
Valuenn9 >
.nn> ?
Countnn? D
==nnE G
$numnnH I
?nnJ K!
ConnectIndexesPerFaceoo )
(oo) *
faceoo* .
,oo. /
splitoo0 5
.oo5 6
Valueoo6 ;
[oo; <
$numoo< =
]oo= >
,oo> ?
splitoo@ E
.ooE F
ValueooF K
[ooK L
$numooL M
]ooM N
,ooN O
verticesooP X
,ooX Y
lookupooZ `
)oo` a
:oob c!
ConnectIndexesPerFacepp )
(pp) *
facepp* .
,pp. /
splitpp0 5
.pp5 6
Valuepp6 ;
,pp; <
verticespp= E
,ppE F
lookupppG M
,ppM N
sharedIndexOffsetppO `
++pp` b
)ppb c
;ppc d
ifrr 
(rr 
resrr 
==rr 
nullrr 
)rr  
continuess 
;ss 
ifuu 
(uu 
faceuu 
.uu 
textureGroupuu %
<uu& '
$numuu( )
)uu) *
{vv 
whileww 
(ww 
usedTextureGroupsww ,
.ww, -
Containsww- 5
(ww5 6 
newTextureGroupIndexww6 J
)wwJ K
)wwK L 
newTextureGroupIndexxx ,
++xx, .
;xx. /
usedTextureGroupszz %
.zz% &
Addzz& )
(zz) * 
newTextureGroupIndexzz* >
)zz> ?
;zz? @
}{{ 
foreach}} 
(}} "
ConnectFaceRebuildData}} /
c}}0 1
in}}2 4
res}}5 8
)}}8 9
{~~ 
c 
. 
faceRebuildData %
.% &
face& *
.* +
textureGroup+ 7
=< =
face> B
.B C
textureGroupC O
<P Q
$numR S
?T U 
newTextureGroupIndexV j
:k l
facem q
.q r
textureGroupr ~
;~ 
c
€€ 
.
€€ 
faceRebuildData
€€ %
.
€€% &
face
€€& *
.
€€* +
uv
€€+ -
=
€€< =
new
€€> A 
AutoUnwrapSettings
€€B T
(
€€T U
face
€€U Y
.
€€Y Z
uv
€€Z \
)
€€\ ]
;
€€] ^
c
 
.
 
faceRebuildData
 %
.
% &
face
& *
.
* +
smoothingGroup
+ 9
=
< =
face
> B
.
B C
smoothingGroup
C Q
;
Q R
c
‚‚ 
.
‚‚ 
faceRebuildData
‚‚ %
.
‚‚% &
face
‚‚& *
.
‚‚* +
manualUV
‚‚+ 3
=
‚‚< =
face
‚‚> B
.
‚‚B C
manualUV
‚‚C K
;
‚‚K L
c
ƒƒ 
.
ƒƒ 
faceRebuildData
ƒƒ %
.
ƒƒ% &
face
ƒƒ& *
.
ƒƒ* +
submeshIndex
ƒƒ+ 7
=
ƒƒ< =
face
ƒƒ> B
.
ƒƒB C
submeshIndex
ƒƒC O
;
ƒƒO P
}
„„ 
successfulSplits
††  
.
††  !
Add
††! $
(
††$ %
face
††% )
)
††) *
;
††* +
appendFaces
‡‡ 
.
‡‡ 
AddRange
‡‡ $
(
‡‡$ %
res
‡‡% (
)
‡‡( )
;
‡‡) *
}
ˆˆ 
FaceRebuildData
ŠŠ 
.
ŠŠ 
Apply
ŠŠ !
(
ŠŠ! "
appendFaces
ŠŠ" -
.
ŠŠ- .
Select
ŠŠ. 4
(
ŠŠ4 5
x
ŠŠ5 6
=>
ŠŠ7 9
x
ŠŠ: ;
.
ŠŠ; <
faceRebuildData
ŠŠ< K
)
ŠŠK L
,
ŠŠL M
mesh
ŠŠN R
,
ŠŠR S
vertices
ŠŠT \
,
ŠŠ\ ]
null
ŠŠ^ b
)
ŠŠb c
;
ŠŠc d
int
‹‹  
removedVertexCount
‹‹ "
=
‹‹# $
mesh
‹‹% )
.
‹‹) *
DeleteFaces
‹‹* 5
(
‹‹5 6
successfulSplits
‹‹6 F
)
‹‹F G
.
‹‹G H
Length
‹‹H N
;
‹‹N O
lookup
ŒŒ 
=
ŒŒ 
mesh
ŒŒ 
.
ŒŒ  
sharedVertexLookup
ŒŒ ,
;
ŒŒ, -
HashSet
 
<
 
int
 
>
 
newVertexIndexes
 )
=
* +
new
, /
HashSet
0 7
<
7 8
int
8 ;
>
; <
(
< =
)
= >
;
> ?
for
 
(
 
int
 
i
 
=
 
$num
 
;
 
i
 
<
 
appendFaces
  +
.
+ ,
Count
, 1
;
1 2
i
3 4
++
4 6
)
6 7
for
‘‘ 
(
‘‘ 
int
‘‘ 
n
‘‘ 
=
‘‘ 
$num
‘‘ 
;
‘‘ 
n
‘‘  !
<
‘‘" #
appendFaces
‘‘$ /
[
‘‘/ 0
i
‘‘0 1
]
‘‘1 2
.
‘‘2 3
newVertexIndexes
‘‘3 C
.
‘‘C D
Count
‘‘D I
;
‘‘I J
n
‘‘K L
++
‘‘L N
)
‘‘N O
newVertexIndexes
’’ $
.
’’$ %
Add
’’% (
(
’’( )
lookup
’’) /
[
’’/ 0
appendFaces
’’0 ;
[
’’; <
i
’’< =
]
’’= >
.
’’> ?
newVertexIndexes
’’? O
[
’’O P
n
’’P Q
]
’’Q R
+
’’S T
(
’’U V
appendFaces
’’V a
[
’’a b
i
’’b c
]
’’c d
.
’’d e
faceRebuildData
’’e t
.
’’t u
Offset
’’u {
(
’’{ |
)
’’| }
-
’’~ "
removedVertexCount’’€ ’
)’’’ “
]’’“ ”
)’’” •
;’’• –
mesh
”” 
.
”” 
ToMesh
”” 
(
”” 
)
”” 
;
”” 
return
–– 
newVertexIndexes
–– #
.
––# $
Select
––$ *
(
––* +
x
––+ ,
=>
––- /
mesh
––0 4
.
––4 5$
sharedVerticesInternal
––5 K
[
––K L
x
––L M
]
––M N
[
––N O
$num
––O P
]
––P Q
)
––Q R
.
––R S
ToArray
––S Z
(
––Z [
)
––[ \
;
––\ ]
}
—— 	
internal
¤¤ 
static
¤¤ 
ActionResult
¤¤ $
Connect
¤¤% ,
(
¤¤, -
this
¥¥ 
ProBuilderMesh
¥¥ 
mesh
¥¥  $
,
¥¥$ %
IEnumerable
¦¦ 
<
¦¦ 
Edge
¦¦ 
>
¦¦ 
edges
¦¦ #
,
¦¦# $
out
§§ 
Face
§§ 
[
§§ 
]
§§ 

addedFaces
§§ !
,
§§! "
out
¨¨ 
Edge
¨¨ 
[
¨¨ 
]
¨¨ 
connections
¨¨ "
,
¨¨" #
bool
©© 
returnFaces
©© 
=
©© 
false
©© $
,
©©$ %
bool
ªª 
returnEdges
ªª 
=
ªª 
false
ªª $
,
ªª$ %
HashSet
«« 
<
«« 
Face
«« 
>
«« 
faceMask
«« "
=
««# $
null
««% )
)
««) *
{
¬¬ 	

Dictionary
­­ 
<
­­ 
int
­­ 
,
­­ 
int
­­ 
>
­­  
lookup
­­! '
=
­­( )
mesh
­­* .
.
­­. / 
sharedVertexLookup
­­/ A
;
­­A B

Dictionary
®® 
<
®® 
int
®® 
,
®® 
int
®® 
>
®®  
lookupUV
®®! )
=
®®* +
mesh
®®, 0
.
®®0 1!
sharedTextureLookup
®®1 D
;
®®D E
HashSet
¯¯ 
<
¯¯ 

EdgeLookup
¯¯ 
>
¯¯ 
distinctEdges
¯¯  -
=
¯¯. /
new
¯¯0 3
HashSet
¯¯4 ;
<
¯¯; <

EdgeLookup
¯¯< F
>
¯¯F G
(
¯¯G H

EdgeLookup
¯¯H R
.
¯¯R S
GetEdgeLookup
¯¯S `
(
¯¯` a
edges
¯¯a f
,
¯¯f g
lookup
¯¯h n
)
¯¯n o
)
¯¯o p
;
¯¯p q
List
°° 
<
°° 

WingedEdge
°° 
>
°° 
wings
°° "
=
°°# $

WingedEdge
°°% /
.
°°/ 0
GetWingedEdges
°°0 >
(
°°> ?
mesh
°°? C
)
°°C D
;
°°D E

Dictionary
³³ 
<
³³ 
Face
³³ 
,
³³ 
List
³³ !
<
³³! "

WingedEdge
³³" ,
>
³³, -
>
³³- .
touched
³³/ 6
=
³³7 8
new
³³9 <

Dictionary
³³= G
<
³³G H
Face
³³H L
,
³³L M
List
³³N R
<
³³R S

WingedEdge
³³S ]
>
³³] ^
>
³³^ _
(
³³_ `
)
³³` a
;
³³a b
foreach
µµ 
(
µµ 

WingedEdge
µµ 
wing
µµ  $
in
µµ% '
wings
µµ( -
)
µµ- .
{
¶¶ 
if
·· 
(
·· 
distinctEdges
·· !
.
··! "
Contains
··" *
(
··* +
wing
··+ /
.
··/ 0
edge
··0 4
)
··4 5
)
··5 6
{
¸¸ 
List
¹¹ 
<
¹¹ 

WingedEdge
¹¹ #
>
¹¹# $
	faceEdges
¹¹% .
;
¹¹. /
if
ºº 
(
ºº 
touched
ºº 
.
ºº  
TryGetValue
ºº  +
(
ºº+ ,
wing
ºº, 0
.
ºº0 1
face
ºº1 5
,
ºº5 6
out
ºº7 :
	faceEdges
ºº; D
)
ººD E
)
ººE F
	faceEdges
»» !
.
»»! "
Add
»»" %
(
»»% &
wing
»»& *
)
»»* +
;
»»+ ,
else
¼¼ 
touched
½½ 
.
½½  
Add
½½  #
(
½½# $
wing
½½$ (
.
½½( )
face
½½) -
,
½½- .
new
½½/ 2
List
½½3 7
<
½½7 8

WingedEdge
½½8 B
>
½½B C
(
½½C D
)
½½D E
{
½½F G
wing
½½H L
}
½½M N
)
½½N O
;
½½O P
}
¾¾ 
}
¿¿ 

Dictionary
ÁÁ 
<
ÁÁ 
Face
ÁÁ 
,
ÁÁ 
List
ÁÁ !
<
ÁÁ! "

WingedEdge
ÁÁ" ,
>
ÁÁ, -
>
ÁÁ- .
affected
ÁÁ/ 7
=
ÁÁ8 9
new
ÁÁ: =

Dictionary
ÁÁ> H
<
ÁÁH I
Face
ÁÁI M
,
ÁÁM N
List
ÁÁO S
<
ÁÁS T

WingedEdge
ÁÁT ^
>
ÁÁ^ _
>
ÁÁ_ `
(
ÁÁ` a
)
ÁÁa b
;
ÁÁb c
foreach
ÄÄ 
(
ÄÄ 
KeyValuePair
ÄÄ !
<
ÄÄ! "
Face
ÄÄ" &
,
ÄÄ& '
List
ÄÄ( ,
<
ÄÄ, -

WingedEdge
ÄÄ- 7
>
ÄÄ7 8
>
ÄÄ8 9
kvp
ÄÄ: =
in
ÄÄ> @
touched
ÄÄA H
)
ÄÄH I
{
ÅÅ 
if
ÆÆ 
(
ÆÆ 
kvp
ÆÆ 
.
ÆÆ 
Value
ÆÆ 
.
ÆÆ 
Count
ÆÆ #
<=
ÆÆ$ &
$num
ÆÆ' (
)
ÆÆ( )
{
ÇÇ 

WingedEdge
ÈÈ 
opp
ÈÈ "
=
ÈÈ# $
kvp
ÈÈ% (
.
ÈÈ( )
Value
ÈÈ) .
[
ÈÈ. /
$num
ÈÈ/ 0
]
ÈÈ0 1
.
ÈÈ1 2
opposite
ÈÈ2 :
;
ÈÈ: ;
if
ÊÊ 
(
ÊÊ 
opp
ÊÊ 
==
ÊÊ 
null
ÊÊ #
)
ÊÊ# $
continue
ËË  
;
ËË  !
List
ÍÍ 
<
ÍÍ 

WingedEdge
ÍÍ #
>
ÍÍ# $
opp_list
ÍÍ% -
;
ÍÍ- .
if
ÏÏ 
(
ÏÏ 
!
ÏÏ 
touched
ÏÏ  
.
ÏÏ  !
TryGetValue
ÏÏ! ,
(
ÏÏ, -
opp
ÏÏ- 0
.
ÏÏ0 1
face
ÏÏ1 5
,
ÏÏ5 6
out
ÏÏ7 :
opp_list
ÏÏ; C
)
ÏÏC D
)
ÏÏD E
continue
ĞĞ  
;
ĞĞ  !
if
ÒÒ 
(
ÒÒ 
opp_list
ÒÒ  
.
ÒÒ  !
Count
ÒÒ! &
<=
ÒÒ' )
$num
ÒÒ* +
)
ÒÒ+ ,
continue
ÓÓ  
;
ÓÓ  !
}
ÔÔ 
affected
ÖÖ 
.
ÖÖ 
Add
ÖÖ 
(
ÖÖ 
kvp
ÖÖ  
.
ÖÖ  !
Key
ÖÖ! $
,
ÖÖ$ %
kvp
ÖÖ& )
.
ÖÖ) *
Value
ÖÖ* /
)
ÖÖ/ 0
;
ÖÖ0 1
}
×× 
List
ÙÙ 
<
ÙÙ 
Vertex
ÙÙ 
>
ÙÙ 
vertices
ÙÙ !
=
ÙÙ" #
new
ÙÙ$ '
List
ÙÙ( ,
<
ÙÙ, -
Vertex
ÙÙ- 3
>
ÙÙ3 4
(
ÙÙ4 5
mesh
ÙÙ5 9
.
ÙÙ9 :
GetVertices
ÙÙ: E
(
ÙÙE F
)
ÙÙF G
)
ÙÙG H
;
ÙÙH I
List
ÚÚ 
<
ÚÚ $
ConnectFaceRebuildData
ÚÚ '
>
ÚÚ' (
results
ÚÚ) 0
=
ÚÚ1 2
new
ÚÚ3 6
List
ÚÚ7 ;
<
ÚÚ; <$
ConnectFaceRebuildData
ÚÚ< R
>
ÚÚR S
(
ÚÚS T
)
ÚÚT U
;
ÚÚU V
List
ÜÜ 
<
ÜÜ 
Face
ÜÜ 
>
ÜÜ 
connectedFaces
ÜÜ %
=
ÜÜ& '
new
ÜÜ( +
List
ÜÜ, 0
<
ÜÜ0 1
Face
ÜÜ1 5
>
ÜÜ5 6
(
ÜÜ6 7
)
ÜÜ7 8
;
ÜÜ8 9
HashSet
ŞŞ 
<
ŞŞ 
int
ŞŞ 
>
ŞŞ 
usedTextureGroups
ŞŞ *
=
ŞŞ+ ,
new
ŞŞ- 0
HashSet
ŞŞ1 8
<
ŞŞ8 9
int
ŞŞ9 <
>
ŞŞ< =
(
ŞŞ= >
mesh
ŞŞ> B
.
ŞŞB C
facesInternal
ŞŞC P
.
ŞŞP Q
Select
ŞŞQ W
(
ŞŞW X
x
ŞŞX Y
=>
ŞŞZ \
x
ŞŞ] ^
.
ŞŞ^ _
textureGroup
ŞŞ_ k
)
ŞŞk l
)
ŞŞl m
;
ŞŞm n
int
ßß "
newTextureGroupIndex
ßß $
=
ßß% &
$num
ßß' (
;
ßß( )
foreach
ââ 
(
ââ 
KeyValuePair
ââ !
<
ââ! "
Face
ââ" &
,
ââ& '
List
ââ( ,
<
ââ, -

WingedEdge
ââ- 7
>
ââ7 8
>
ââ8 9
split
ââ: ?
in
ââ@ B
affected
ââC K
)
ââK L
{
ãã 
Face
ää 
face
ää 
=
ää 
split
ää !
.
ää! "
Key
ää" %
;
ää% &
List
åå 
<
åå 

WingedEdge
åå 
>
åå  
targetEdges
åå! ,
=
åå- .
split
åå/ 4
.
åå4 5
Value
åå5 :
;
åå: ;
int
ææ 
inserts
ææ 
=
ææ 
targetEdges
ææ )
.
ææ) *
Count
ææ* /
;
ææ/ 0
Vector3
çç 
nrm
çç 
=
çç 
Math
çç "
.
çç" #
Normal
çç# )
(
çç) *
vertices
çç* 2
,
çç2 3
face
çç4 8
.
çç8 9
indexesInternal
çç9 H
)
ççH I
;
ççI J
if
éé 
(
éé 
inserts
éé 
==
éé 
$num
éé  
||
éé! #
(
éé$ %
faceMask
éé% -
!=
éé. 0
null
éé1 5
&&
éé6 8
!
éé9 :
faceMask
éé: B
.
ééB C
Contains
ééC K
(
ééK L
face
ééL P
)
ééP Q
)
ééQ R
)
ééR S
{
êê $
ConnectFaceRebuildData
ëë *
c
ëë+ ,
;
ëë, -
if
íí 
(
íí 
InsertVertices
íí &
(
íí& '
face
íí' +
,
íí+ ,
targetEdges
íí- 8
,
íí8 9
vertices
íí: B
,
ííB C
out
ííD G
c
ííH I
)
ííI J
)
ííJ K
{
îî 
Vector3
ïï 
fn
ïï  "
=
ïï# $
Math
ïï% )
.
ïï) *
Normal
ïï* 0
(
ïï0 1
c
ïï1 2
.
ïï2 3
faceRebuildData
ïï3 B
.
ïïB C
vertices
ïïC K
,
ïïK L
c
ïïM N
.
ïïN O
faceRebuildData
ïïO ^
.
ïï^ _
face
ïï_ c
.
ïïc d
indexesInternal
ïïd s
)
ïïs t
;
ïït u
if
ññ 
(
ññ 
Vector3
ññ #
.
ññ# $
Dot
ññ$ '
(
ññ' (
nrm
ññ( +
,
ññ+ ,
fn
ññ- /
)
ññ/ 0
<
ññ1 2
$num
ññ3 4
)
ññ4 5
c
òò 
.
òò 
faceRebuildData
òò -
.
òò- .
face
òò. 2
.
òò2 3
Reverse
òò3 :
(
òò: ;
)
òò; <
;
òò< =
results
ôô 
.
ôô  
Add
ôô  #
(
ôô# $
c
ôô$ %
)
ôô% &
;
ôô& '
}
õõ 
}
öö 
else
÷÷ 
if
÷÷ 
(
÷÷ 
inserts
÷÷  
>
÷÷! "
$num
÷÷# $
)
÷÷$ %
{
øø 
List
ùù 
<
ùù $
ConnectFaceRebuildData
ùù /
>
ùù/ 0
res
ùù1 4
=
ùù5 6
inserts
ùù7 >
==
ùù? A
$num
ùùB C
?
ùùD E 
ConnectEdgesInFace
úú *
(
úú* +
face
úú+ /
,
úú/ 0
targetEdges
úú1 <
[
úú< =
$num
úú= >
]
úú> ?
,
úú? @
targetEdges
úúA L
[
úúL M
$num
úúM N
]
úúN O
,
úúO P
vertices
úúQ Y
)
úúY Z
:
úú[ \ 
ConnectEdgesInFace
ûû *
(
ûû* +
face
ûû+ /
,
ûû/ 0
targetEdges
ûû1 <
,
ûû< =
vertices
ûû> F
)
ûûF G
;
ûûG H
if
ıı 
(
ıı 
face
ıı 
.
ıı 
textureGroup
ıı )
<
ıı* +
$num
ıı, -
)
ıı- .
{
şş 
while
ÿÿ 
(
ÿÿ 
usedTextureGroups
ÿÿ 0
.
ÿÿ0 1
Contains
ÿÿ1 9
(
ÿÿ9 :"
newTextureGroupIndex
ÿÿ: N
)
ÿÿN O
)
ÿÿO P"
newTextureGroupIndex
€€ 0
++
€€0 2
;
€€2 3
usedTextureGroups
‚‚ )
.
‚‚) *
Add
‚‚* -
(
‚‚- ."
newTextureGroupIndex
‚‚. B
)
‚‚B C
;
‚‚C D
}
ƒƒ 
if
†† 
(
†† 
res
†† 
==
†† 
null
†† #
)
††# $
{
‡‡ 
connections
ˆˆ #
=
ˆˆ$ %
null
ˆˆ& *
;
ˆˆ* +

addedFaces
‰‰ "
=
‰‰# $
null
‰‰% )
;
‰‰) *
return
ŠŠ 
new
ŠŠ "
ActionResult
ŠŠ# /
(
ŠŠ/ 0
ActionResult
ŠŠ0 <
.
ŠŠ< =
Status
ŠŠ= C
.
ŠŠC D
Failure
ŠŠD K
,
ŠŠK L
$str
ŠŠM f
)
ŠŠf g
;
ŠŠg h
}
‹‹ 
else
ŒŒ 
{
 
foreach
 
(
  !$
ConnectFaceRebuildData
! 7
c
8 9
in
: <
res
= @
)
@ A
{
 
connectedFaces
 *
.
* +
Add
+ .
(
. /
c
/ 0
.
0 1
faceRebuildData
1 @
.
@ A
face
A E
)
E F
;
F G
Vector3
’’ #
fn
’’$ &
=
’’' (
Math
’’) -
.
’’- .
Normal
’’. 4
(
’’4 5
c
’’5 6
.
’’6 7
faceRebuildData
’’7 F
.
’’F G
vertices
’’G O
,
’’O P
c
““  !
.
““! "
faceRebuildData
““" 1
.
““1 2
face
““2 6
.
““6 7
indexesInternal
““7 F
)
““F G
;
““G H
if
•• 
(
••  
Vector3
••  '
.
••' (
Dot
••( +
(
••+ ,
nrm
••, /
,
••/ 0
fn
••1 3
)
••3 4
<
••5 6
$num
••7 8
)
••8 9
c
––  !
.
––! "
faceRebuildData
––" 1
.
––1 2
face
––2 6
.
––6 7
Reverse
––7 >
(
––> ?
)
––? @
;
––@ A
c
˜˜ 
.
˜˜ 
faceRebuildData
˜˜ -
.
˜˜- .
face
˜˜. 2
.
˜˜2 3
textureGroup
˜˜3 ?
=
˜˜@ A
face
™™  $
.
™™$ %
textureGroup
™™% 1
<
™™2 3
$num
™™4 5
?
™™6 7"
newTextureGroupIndex
™™8 L
:
™™M N
face
™™O S
.
™™S T
textureGroup
™™T `
;
™™` a
c
šš 
.
šš 
faceRebuildData
šš -
.
šš- .
face
šš. 2
.
šš2 3
uv
šš3 5
=
šš6 7
new
šš8 ; 
AutoUnwrapSettings
šš< N
(
ššN O
face
ššO S
.
ššS T
uv
ššT V
)
ššV W
;
ššW X
c
›› 
.
›› 
faceRebuildData
›› -
.
››- .
face
››. 2
.
››2 3
submeshIndex
››3 ?
=
››@ A
face
››B F
.
››F G
submeshIndex
››G S
;
››S T
c
œœ 
.
œœ 
faceRebuildData
œœ -
.
œœ- .
face
œœ. 2
.
œœ2 3
smoothingGroup
œœ3 A
=
œœB C
face
œœD H
.
œœH I
smoothingGroup
œœI W
;
œœW X
c
 
.
 
faceRebuildData
 -
.
- .
face
. 2
.
2 3
manualUV
3 ;
=
< =
face
> B
.
B C
manualUV
C K
;
K L
}
 
results
   
.
    
AddRange
    (
(
  ( )
res
  ) ,
)
  , -
;
  - .
}
¡¡ 
}
¢¢ 
}
££ 
FaceRebuildData
¥¥ 
.
¥¥ 
Apply
¥¥ !
(
¥¥! "
results
¥¥" )
.
¥¥) *
Select
¥¥* 0
(
¥¥0 1
x
¥¥1 2
=>
¥¥3 5
x
¥¥6 7
.
¥¥7 8
faceRebuildData
¥¥8 G
)
¥¥G H
,
¥¥H I
mesh
¥¥J N
,
¥¥N O
vertices
¥¥P X
,
¥¥X Y
null
¥¥Z ^
)
¥¥^ _
;
¥¥_ `
mesh
§§ 
.
§§ 
sharedTextures
§§ 
=
§§  !
new
§§" %
SharedVertex
§§& 2
[
§§2 3
$num
§§3 4
]
§§4 5
;
§§5 6
int
¨¨  
removedVertexCount
¨¨ "
=
¨¨# $
mesh
¨¨% )
.
¨¨) *
DeleteFaces
¨¨* 5
(
¨¨5 6
affected
¨¨6 >
.
¨¨> ?
Keys
¨¨? C
)
¨¨C D
.
¨¨D E
Length
¨¨E K
;
¨¨K L
mesh
©© 
.
©© 
sharedVertices
©© 
=
©©  !
SharedVertex
©©" .
.
©©. /,
GetSharedVerticesWithPositions
©©/ M
(
©©M N
mesh
©©N R
.
©©R S
positionsInternal
©©S d
)
©©d e
;
©©e f
mesh
ªª 
.
ªª 
ToMesh
ªª 
(
ªª 
)
ªª 
;
ªª 
if
­­ 
(
­­ 
returnEdges
­­ 
)
­­ 
{
®® 
var
°° 
appended
°° 
=
°° 
new
°° "
HashSet
°°# *
<
°°* +
int
°°+ .
>
°°. /
(
°°/ 0
)
°°0 1
;
°°1 2
for
²² 
(
²² 
int
²² 
n
²² 
=
²² 
$num
²² 
;
²² 
n
²²  !
<
²²" #
results
²²$ +
.
²²+ ,
Count
²², 1
;
²²1 2
n
²²3 4
++
²²4 6
)
²²6 7
for
³³ 
(
³³ 
int
³³ 
i
³³ 
=
³³  
$num
³³! "
;
³³" #
i
³³$ %
<
³³& '
results
³³( /
[
³³/ 0
n
³³0 1
]
³³1 2
.
³³2 3
newVertexIndexes
³³3 C
.
³³C D
Count
³³D I
;
³³I J
i
³³K L
++
³³L N
)
³³N O
appended
´´  
.
´´  !
Add
´´! $
(
´´$ %
(
´´% &
results
´´& -
[
´´- .
n
´´. /
]
´´/ 0
.
´´0 1
newVertexIndexes
´´1 A
[
´´A B
i
´´B C
]
´´C D
+
´´E F
results
´´G N
[
´´N O
n
´´O P
]
´´P Q
.
´´Q R
faceRebuildData
´´R a
.
´´a b
Offset
´´b h
(
´´h i
)
´´i j
)
´´j k
-
´´l m!
removedVertexCount´´n €
)´´€ 
;´´ ‚

Dictionary
¶¶ 
<
¶¶ 
int
¶¶ 
,
¶¶ 
int
¶¶  #
>
¶¶# $
lup
¶¶% (
=
¶¶) *
mesh
¶¶+ /
.
¶¶/ 0 
sharedVertexLookup
¶¶0 B
;
¶¶B C
IEnumerable
·· 
<
·· 
Edge
··  
>
··  !
newEdges
··" *
=
··+ ,
results
··- 4
.
··4 5

SelectMany
··5 ?
(
··? @
x
··@ A
=>
··B D
x
··E F
.
··F G
faceRebuildData
··G V
.
··V W
face
··W [
.
··[ \
edgesInternal
··\ i
)
··i j
.
··j k
Where
··k p
(
··p q
x
··q r
=>
··s u
appended
··v ~
.
··~ 
Contains·· ‡
(··‡ ˆ
x··ˆ ‰
.··‰ Š
a··Š ‹
)··‹ Œ
&&·· 
appended·· ˜
.··˜ ™
Contains··™ ¡
(··¡ ¢
x··¢ £
.··£ ¤
b··¤ ¥
)··¥ ¦
)··¦ §
;··§ ¨
IEnumerable
¸¸ 
<
¸¸ 

EdgeLookup
¸¸ &
>
¸¸& '
distNewEdges
¸¸( 4
=
¸¸5 6

EdgeLookup
¸¸7 A
.
¸¸A B
GetEdgeLookup
¸¸B O
(
¸¸O P
newEdges
¸¸P X
,
¸¸X Y
lup
¸¸Z ]
)
¸¸] ^
;
¸¸^ _
connections
ºº 
=
ºº 
distNewEdges
ºº *
.
ºº* +
Distinct
ºº+ 3
(
ºº3 4
)
ºº4 5
.
ºº5 6
Select
ºº6 <
(
ºº< =
x
ºº= >
=>
ºº? A
x
ººB C
.
ººC D
local
ººD I
)
ººI J
.
ººJ K
ToArray
ººK R
(
ººR S
)
ººS T
;
ººT U
}
»» 
else
¼¼ 
{
½½ 
connections
¾¾ 
=
¾¾ 
null
¾¾ "
;
¾¾" #
}
¿¿ 
if
ÁÁ 
(
ÁÁ 
returnFaces
ÁÁ 
)
ÁÁ 

addedFaces
ÂÂ 
=
ÂÂ 
connectedFaces
ÂÂ +
.
ÂÂ+ ,
ToArray
ÂÂ, 3
(
ÂÂ3 4
)
ÂÂ4 5
;
ÂÂ5 6
else
ÃÃ 

addedFaces
ÄÄ 
=
ÄÄ 
null
ÄÄ !
;
ÄÄ! "
return
ÆÆ 
new
ÆÆ 
ActionResult
ÆÆ #
(
ÆÆ# $
ActionResult
ÆÆ$ 0
.
ÆÆ0 1
Status
ÆÆ1 7
.
ÆÆ7 8
Success
ÆÆ8 ?
,
ÆÆ? @
string
ÆÆA G
.
ÆÆG H
Format
ÆÆH N
(
ÆÆN O
$str
ÆÆO d
,
ÆÆd e
results
ÆÆf m
.
ÆÆm n
Count
ÆÆn s
/
ÆÆt u
$num
ÆÆv w
)
ÆÆw x
)
ÆÆx y
;
ÆÆy z
}
ÇÇ 	
static
ÑÑ 
List
ÑÑ 
<
ÑÑ $
ConnectFaceRebuildData
ÑÑ *
>
ÑÑ* + 
ConnectEdgesInFace
ÑÑ, >
(
ÑÑ> ?
Face
ÒÒ 
face
ÒÒ 
,
ÒÒ 

WingedEdge
ÓÓ 
a
ÓÓ 
,
ÓÓ 

WingedEdge
ÔÔ 
b
ÔÔ 
,
ÔÔ 
List
ÕÕ 
<
ÕÕ 
Vertex
ÕÕ 
>
ÕÕ 
vertices
ÕÕ !
)
ÕÕ! "
{
ÖÖ 	
List
×× 
<
×× 
Edge
×× 
>
×× 
	perimeter
××  
=
××! "

WingedEdge
××# -
.
××- ."
SortEdgesByAdjacency
××. B
(
××B C
face
××C G
)
××G H
;
××H I
List
ÙÙ 
<
ÙÙ 
Vertex
ÙÙ 
>
ÙÙ 
[
ÙÙ 
]
ÙÙ 

n_vertices
ÙÙ %
=
ÙÙ& '
new
ÙÙ( +
List
ÙÙ, 0
<
ÙÙ0 1
Vertex
ÙÙ1 7
>
ÙÙ7 8
[
ÙÙ8 9
$num
ÙÙ9 :
]
ÙÙ: ;
{
ÚÚ 
new
ÛÛ 
List
ÛÛ 
<
ÛÛ 
Vertex
ÛÛ 
>
ÛÛ  
(
ÛÛ  !
)
ÛÛ! "
,
ÛÛ" #
new
ÜÜ 
List
ÜÜ 
<
ÜÜ 
Vertex
ÜÜ 
>
ÜÜ  
(
ÜÜ  !
)
ÜÜ! "
}
İİ 
;
İİ 
List
ßß 
<
ßß 
int
ßß 
>
ßß 
[
ßß 
]
ßß 
	n_indexes
ßß !
=
ßß" #
new
ßß$ '
List
ßß( ,
<
ßß, -
int
ßß- 0
>
ßß0 1
[
ßß1 2
$num
ßß2 3
]
ßß3 4
{
àà 
new
áá 
List
áá 
<
áá 
int
áá 
>
áá 
(
áá 
)
áá 
,
áá  
new
ââ 
List
ââ 
<
ââ 
int
ââ 
>
ââ 
(
ââ 
)
ââ 
}
ãã 
;
ãã 
int
åå 
index
åå 
=
åå 
$num
åå 
;
åå 
for
èè 
(
èè 
int
èè 
i
èè 
=
èè 
$num
èè 
;
èè 
i
èè 
<
èè 
	perimeter
èè  )
.
èè) *
Count
èè* /
;
èè/ 0
i
èè1 2
++
èè2 4
)
èè4 5
{
éé 

n_vertices
êê 
[
êê 
index
êê  
%
êê! "
$num
êê# $
]
êê$ %
.
êê% &
Add
êê& )
(
êê) *
vertices
êê* 2
[
êê2 3
	perimeter
êê3 <
[
êê< =
i
êê= >
]
êê> ?
.
êê? @
a
êê@ A
]
êêA B
)
êêB C
;
êêC D
if
ìì 
(
ìì 
	perimeter
ìì 
[
ìì 
i
ìì 
]
ìì  
.
ìì  !
Equals
ìì! '
(
ìì' (
a
ìì( )
.
ìì) *
edge
ìì* .
.
ìì. /
local
ìì/ 4
)
ìì4 5
||
ìì6 8
	perimeter
ìì9 B
[
ììB C
i
ììC D
]
ììD E
.
ììE F
Equals
ììF L
(
ììL M
b
ììM N
.
ììN O
edge
ììO S
.
ììS T
local
ììT Y
)
ììY Z
)
ììZ [
{
íí 
Vertex
îî 
mix
îî 
=
îî  
Vertex
îî! '
.
îî' (
Mix
îî( +
(
îî+ ,
vertices
îî, 4
[
îî4 5
	perimeter
îî5 >
[
îî> ?
i
îî? @
]
îî@ A
.
îîA B
a
îîB C
]
îîC D
,
îîD E
vertices
îîF N
[
îîN O
	perimeter
îîO X
[
îîX Y
i
îîY Z
]
îîZ [
.
îî[ \
b
îî\ ]
]
îî] ^
,
îî^ _
$num
îî` c
)
îîc d
;
îîd e
	n_indexes
ğğ 
[
ğğ 
index
ğğ #
%
ğğ$ %
$num
ğğ& '
]
ğğ' (
.
ğğ( )
Add
ğğ) ,
(
ğğ, -

n_vertices
ğğ- 7
[
ğğ7 8
index
ğğ8 =
%
ğğ> ?
$num
ğğ@ A
]
ğğA B
.
ğğB C
Count
ğğC H
)
ğğH I
;
ğğI J

n_vertices
ññ 
[
ññ 
index
ññ $
%
ññ% &
$num
ññ' (
]
ññ( )
.
ññ) *
Add
ññ* -
(
ññ- .
mix
ññ. 1
)
ññ1 2
;
ññ2 3
index
òò 
++
òò 
;
òò 
	n_indexes
óó 
[
óó 
index
óó #
%
óó$ %
$num
óó& '
]
óó' (
.
óó( )
Add
óó) ,
(
óó, -

n_vertices
óó- 7
[
óó7 8
index
óó8 =
%
óó> ?
$num
óó@ A
]
óóA B
.
óóB C
Count
óóC H
)
óóH I
;
óóI J

n_vertices
ôô 
[
ôô 
index
ôô $
%
ôô% &
$num
ôô' (
]
ôô( )
.
ôô) *
Add
ôô* -
(
ôô- .
mix
ôô. 1
)
ôô1 2
;
ôô2 3
}
õõ 
}
öö 
List
øø 
<
øø $
ConnectFaceRebuildData
øø '
>
øø' (
faces
øø) .
=
øø/ 0
new
øø1 4
List
øø5 9
<
øø9 :$
ConnectFaceRebuildData
øø: P
>
øøP Q
(
øøQ R
)
øøR S
;
øøS T
for
úú 
(
úú 
int
úú 
i
úú 
=
úú 
$num
úú 
;
úú 
i
úú 
<
úú 

n_vertices
úú  *
.
úú* +
Length
úú+ 1
;
úú1 2
i
úú3 4
++
úú4 6
)
úú6 7
{
ûû 
FaceRebuildData
üü 
f
üü  !
=
üü" #
AppendElements
üü$ 2
.
üü2 3
FaceWithVertices
üü3 C
(
üüC D

n_vertices
üüD N
[
üüN O
i
üüO P
]
üüP Q
,
üüQ R
false
üüS X
)
üüX Y
;
üüY Z
faces
ıı 
.
ıı 
Add
ıı 
(
ıı 
new
ıı $
ConnectFaceRebuildData
ıı 4
(
ıı4 5
f
ıı5 6
,
ıı6 7
	n_indexes
ıı8 A
[
ııA B
i
ııB C
]
ııC D
)
ııD E
)
ııE F
;
ııF G
}
şş 
return
€€ 
faces
€€ 
;
€€ 
}
 	
static
ŠŠ 
List
ŠŠ 
<
ŠŠ $
ConnectFaceRebuildData
ŠŠ *
>
ŠŠ* + 
ConnectEdgesInFace
ŠŠ, >
(
ŠŠ> ?
Face
‹‹ 
face
‹‹ 
,
‹‹ 
List
ŒŒ 
<
ŒŒ 

WingedEdge
ŒŒ 
>
ŒŒ 
edges
ŒŒ "
,
ŒŒ" #
List
 
<
 
Vertex
 
>
 
vertices
 !
)
! "
{
 	
List
 
<
 
Edge
 
>
 
	perimeter
  
=
! "

WingedEdge
# -
.
- ."
SortEdgesByAdjacency
. B
(
B C
face
C G
)
G H
;
H I
int
 

splitCount
 
=
 
edges
 "
.
" #
Count
# (
;
( )
Vertex
’’ 
centroid
’’ 
=
’’ 
Vertex
’’ $
.
’’$ %
Average
’’% ,
(
’’, -
vertices
’’- 5
,
’’5 6
face
’’7 ;
.
’’; <%
distinctIndexesInternal
’’< S
)
’’S T
;
’’T U
List
”” 
<
”” 
List
”” 
<
”” 
Vertex
”” 
>
”” 
>
”” 

n_vertices
”” )
=
””* +
ArrayUtility
””, 8
.
””8 9
Fill
””9 =
<
””= >
List
””> B
<
””B C
Vertex
””C I
>
””I J
>
””J K
(
””K L
x
””L M
=>
””N P
{
””Q R
return
””S Y
new
””Z ]
List
””^ b
<
””b c
Vertex
””c i
>
””i j
(
””j k
)
””k l
;
””l m
}
””n o
,
””o p

splitCount
””q {
)
””{ |
;
””| }
List
•• 
<
•• 
List
•• 
<
•• 
int
•• 
>
•• 
>
•• 
	n_indexes
•• %
=
••& '
ArrayUtility
••( 4
.
••4 5
Fill
••5 9
<
••9 :
List
••: >
<
••> ?
int
••? B
>
••B C
>
••C D
(
••D E
x
••E F
=>
••G I
{
••J K
return
••L R
new
••S V
List
••W [
<
••[ \
int
••\ _
>
••_ `
(
••` a
)
••a b
;
••b c
}
••d e
,
••e f

splitCount
••g q
)
••q r
;
••r s
HashSet
—— 
<
—— 
Edge
—— 
>
—— 
edgesToSplit
—— &
=
——' (
new
——) ,
HashSet
——- 4
<
——4 5
Edge
——5 9
>
——9 :
(
——: ;
edges
——; @
.
——@ A
Select
——A G
(
——G H
x
——H I
=>
——J L
x
——M N
.
——N O
edge
——O S
.
——S T
local
——T Y
)
——Y Z
)
——Z [
;
——[ \
int
™™ 
index
™™ 
=
™™ 
$num
™™ 
;
™™ 
for
œœ 
(
œœ 
int
œœ 
i
œœ 
=
œœ 
$num
œœ 
;
œœ 
i
œœ 
<
œœ 
	perimeter
œœ  )
.
œœ) *
Count
œœ* /
;
œœ/ 0
i
œœ1 2
++
œœ2 4
)
œœ4 5
{
 

n_vertices
 
[
 
index
  
%
! "

splitCount
# -
]
- .
.
. /
Add
/ 2
(
2 3
vertices
3 ;
[
; <
	perimeter
< E
[
E F
i
F G
]
G H
.
H I
a
I J
]
J K
)
K L
;
L M
if
   
(
   
edgesToSplit
    
.
    !
Contains
  ! )
(
  ) *
	perimeter
  * 3
[
  3 4
i
  4 5
]
  5 6
)
  6 7
)
  7 8
{
¡¡ 
Vertex
¢¢ 
mix
¢¢ 
=
¢¢  
Vertex
¢¢! '
.
¢¢' (
Mix
¢¢( +
(
¢¢+ ,
vertices
¢¢, 4
[
¢¢4 5
	perimeter
¢¢5 >
[
¢¢> ?
i
¢¢? @
]
¢¢@ A
.
¢¢A B
a
¢¢B C
]
¢¢C D
,
¢¢D E
vertices
¢¢F N
[
¢¢N O
	perimeter
¢¢O X
[
¢¢X Y
i
¢¢Y Z
]
¢¢Z [
.
¢¢[ \
b
¢¢\ ]
]
¢¢] ^
,
¢¢^ _
$num
¢¢` c
)
¢¢c d
;
¢¢d e
	n_indexes
¥¥ 
[
¥¥ 
index
¥¥ #
]
¥¥# $
.
¥¥$ %
Add
¥¥% (
(
¥¥( )

n_vertices
¥¥) 3
[
¥¥3 4
index
¥¥4 9
]
¥¥9 :
.
¥¥: ;
Count
¥¥; @
)
¥¥@ A
;
¥¥A B

n_vertices
¦¦ 
[
¦¦ 
index
¦¦ $
]
¦¦$ %
.
¦¦% &
Add
¦¦& )
(
¦¦) *
mix
¦¦* -
)
¦¦- .
;
¦¦. /
	n_indexes
©© 
[
©© 
index
©© #
]
©©# $
.
©©$ %
Add
©©% (
(
©©( )

n_vertices
©©) 3
[
©©3 4
index
©©4 9
]
©©9 :
.
©©: ;
Count
©©; @
)
©©@ A
;
©©A B

n_vertices
ªª 
[
ªª 
index
ªª $
]
ªª$ %
.
ªª% &
Add
ªª& )
(
ªª) *
centroid
ªª* 2
)
ªª2 3
;
ªª3 4
index
­­ 
=
­­ 
(
­­ 
index
­­ "
+
­­# $
$num
­­% &
)
­­& '
%
­­( )

splitCount
­­* 4
;
­­4 5

n_vertices
°° 
[
°° 
index
°° $
]
°°$ %
.
°°% &
Add
°°& )
(
°°) *
mix
°°* -
)
°°- .
;
°°. /
}
±± 
}
²² 
List
´´ 
<
´´ $
ConnectFaceRebuildData
´´ '
>
´´' (
faces
´´) .
=
´´/ 0
new
´´1 4
List
´´5 9
<
´´9 :$
ConnectFaceRebuildData
´´: P
>
´´P Q
(
´´Q R
)
´´R S
;
´´S T
for
¶¶ 
(
¶¶ 
int
¶¶ 
i
¶¶ 
=
¶¶ 
$num
¶¶ 
;
¶¶ 
i
¶¶ 
<
¶¶ 

n_vertices
¶¶  *
.
¶¶* +
Count
¶¶+ 0
;
¶¶0 1
i
¶¶2 3
++
¶¶3 5
)
¶¶5 6
{
·· 
FaceRebuildData
¸¸ 
f
¸¸  !
=
¸¸" #
AppendElements
¸¸$ 2
.
¸¸2 3
FaceWithVertices
¸¸3 C
(
¸¸C D

n_vertices
¸¸D N
[
¸¸N O
i
¸¸O P
]
¸¸P Q
,
¸¸Q R
false
¸¸S X
)
¸¸X Y
;
¸¸Y Z
if
¹¹ 
(
¹¹ 
f
¹¹ 
==
¹¹ 
null
¹¹ 
)
¹¹ 
{
ºº 
faces
»» 
.
»» 
Clear
»» 
(
»»  
)
»»  !
;
»»! "
return
¼¼ 
null
¼¼ 
;
¼¼  
}
½½ 
faces
¾¾ 
.
¾¾ 
Add
¾¾ 
(
¾¾ 
new
¾¾ $
ConnectFaceRebuildData
¾¾ 4
(
¾¾4 5
f
¾¾5 6
,
¾¾6 7
	n_indexes
¾¾8 A
[
¾¾A B
i
¾¾B C
]
¾¾C D
)
¾¾D E
)
¾¾E F
;
¾¾F G
}
¿¿ 
return
ÁÁ 
faces
ÁÁ 
;
ÁÁ 
}
ÂÂ 	
static
ÄÄ 
bool
ÄÄ 
InsertVertices
ÄÄ "
(
ÄÄ" #
Face
ÄÄ# '
face
ÄÄ( ,
,
ÄÄ, -
List
ÄÄ. 2
<
ÄÄ2 3

WingedEdge
ÄÄ3 =
>
ÄÄ= >
edges
ÄÄ? D
,
ÄÄD E
List
ÄÄF J
<
ÄÄJ K
Vertex
ÄÄK Q
>
ÄÄQ R
vertices
ÄÄS [
,
ÄÄ[ \
out
ÄÄ] `$
ConnectFaceRebuildData
ÄÄa w
data
ÄÄx |
)
ÄÄ| }
{
ÅÅ 	
List
ÆÆ 
<
ÆÆ 
Edge
ÆÆ 
>
ÆÆ 
	perimeter
ÆÆ  
=
ÆÆ! "

WingedEdge
ÆÆ# -
.
ÆÆ- ."
SortEdgesByAdjacency
ÆÆ. B
(
ÆÆB C
face
ÆÆC G
)
ÆÆG H
;
ÆÆH I
List
ÇÇ 
<
ÇÇ 
Vertex
ÇÇ 
>
ÇÇ 

n_vertices
ÇÇ #
=
ÇÇ$ %
new
ÇÇ& )
List
ÇÇ* .
<
ÇÇ. /
Vertex
ÇÇ/ 5
>
ÇÇ5 6
(
ÇÇ6 7
)
ÇÇ7 8
;
ÇÇ8 9
List
ÈÈ 
<
ÈÈ 
int
ÈÈ 
>
ÈÈ 
newVertexIndexes
ÈÈ &
=
ÈÈ' (
new
ÈÈ) ,
List
ÈÈ- 1
<
ÈÈ1 2
int
ÈÈ2 5
>
ÈÈ5 6
(
ÈÈ6 7
)
ÈÈ7 8
;
ÈÈ8 9
HashSet
ÉÉ 
<
ÉÉ 
Edge
ÉÉ 
>
ÉÉ 
affected
ÉÉ "
=
ÉÉ# $
new
ÉÉ% (
HashSet
ÉÉ) 0
<
ÉÉ0 1
Edge
ÉÉ1 5
>
ÉÉ5 6
(
ÉÉ6 7
edges
ÉÉ7 <
.
ÉÉ< =
Select
ÉÉ= C
(
ÉÉC D
x
ÉÉD E
=>
ÉÉF H
x
ÉÉI J
.
ÉÉJ K
edge
ÉÉK O
.
ÉÉO P
local
ÉÉP U
)
ÉÉU V
)
ÉÉV W
;
ÉÉW X
for
ËË 
(
ËË 
int
ËË 
i
ËË 
=
ËË 
$num
ËË 
;
ËË 
i
ËË 
<
ËË 
	perimeter
ËË  )
.
ËË) *
Count
ËË* /
;
ËË/ 0
i
ËË1 2
++
ËË2 4
)
ËË4 5
{
ÌÌ 

n_vertices
ÍÍ 
.
ÍÍ 
Add
ÍÍ 
(
ÍÍ 
vertices
ÍÍ '
[
ÍÍ' (
	perimeter
ÍÍ( 1
[
ÍÍ1 2
i
ÍÍ2 3
]
ÍÍ3 4
.
ÍÍ4 5
a
ÍÍ5 6
]
ÍÍ6 7
)
ÍÍ7 8
;
ÍÍ8 9
if
ÏÏ 
(
ÏÏ 
affected
ÏÏ 
.
ÏÏ 
Contains
ÏÏ %
(
ÏÏ% &
	perimeter
ÏÏ& /
[
ÏÏ/ 0
i
ÏÏ0 1
]
ÏÏ1 2
)
ÏÏ2 3
)
ÏÏ3 4
{
ĞĞ 
newVertexIndexes
ÑÑ $
.
ÑÑ$ %
Add
ÑÑ% (
(
ÑÑ( )

n_vertices
ÑÑ) 3
.
ÑÑ3 4
Count
ÑÑ4 9
)
ÑÑ9 :
;
ÑÑ: ;

n_vertices
ÒÒ 
.
ÒÒ 
Add
ÒÒ "
(
ÒÒ" #
Vertex
ÒÒ# )
.
ÒÒ) *
Mix
ÒÒ* -
(
ÒÒ- .
vertices
ÒÒ. 6
[
ÒÒ6 7
	perimeter
ÒÒ7 @
[
ÒÒ@ A
i
ÒÒA B
]
ÒÒB C
.
ÒÒC D
a
ÒÒD E
]
ÒÒE F
,
ÒÒF G
vertices
ÒÒH P
[
ÒÒP Q
	perimeter
ÒÒQ Z
[
ÒÒZ [
i
ÒÒ[ \
]
ÒÒ\ ]
.
ÒÒ] ^
b
ÒÒ^ _
]
ÒÒ_ `
,
ÒÒ` a
$num
ÒÒb e
)
ÒÒe f
)
ÒÒf g
;
ÒÒg h
}
ÓÓ 
}
ÔÔ 
FaceRebuildData
ÖÖ 
res
ÖÖ 
=
ÖÖ  !
AppendElements
ÖÖ" 0
.
ÖÖ0 1
FaceWithVertices
ÖÖ1 A
(
ÖÖA B

n_vertices
ÖÖB L
,
ÖÖL M
false
ÖÖN S
)
ÖÖS T
;
ÖÖT U
if
ØØ 
(
ØØ 
res
ØØ 
!=
ØØ 
null
ØØ 
)
ØØ 
{
ÙÙ 
res
ÚÚ 
.
ÚÚ 
face
ÚÚ 
.
ÚÚ 
textureGroup
ÚÚ %
=
ÚÚ& '
face
ÚÚ( ,
.
ÚÚ, -
textureGroup
ÚÚ- 9
;
ÚÚ9 :
res
ÛÛ 
.
ÛÛ 
face
ÛÛ 
.
ÛÛ 
uv
ÛÛ 
=
ÛÛ 
new
ÛÛ ! 
AutoUnwrapSettings
ÛÛ" 4
(
ÛÛ4 5
face
ÛÛ5 9
.
ÛÛ9 :
uv
ÛÛ: <
)
ÛÛ< =
;
ÛÛ= >
res
ÜÜ 
.
ÜÜ 
face
ÜÜ 
.
ÜÜ 
smoothingGroup
ÜÜ '
=
ÜÜ( )
face
ÜÜ* .
.
ÜÜ. /
smoothingGroup
ÜÜ/ =
;
ÜÜ= >
res
İİ 
.
İİ 
face
İİ 
.
İİ 
manualUV
İİ !
=
İİ" #
face
İİ$ (
.
İİ( )
manualUV
İİ) 1
;
İİ1 2
res
ŞŞ 
.
ŞŞ 
face
ŞŞ 
.
ŞŞ 
submeshIndex
ŞŞ %
=
ŞŞ& '
face
ŞŞ( ,
.
ŞŞ, -
submeshIndex
ŞŞ- 9
;
ŞŞ9 :
data
àà 
=
àà 
new
àà $
ConnectFaceRebuildData
àà 1
(
àà1 2
res
àà2 5
,
àà5 6
newVertexIndexes
àà7 G
)
ààG H
;
ààH I
return
áá 
true
áá 
;
áá 
}
ââ 
data
ää 
=
ää 
null
ää 
;
ää 
return
ææ 
false
ææ 
;
ææ 
}
çç 	
static
éé 
List
éé 
<
éé $
ConnectFaceRebuildData
éé *
>
éé* +#
ConnectIndexesPerFace
éé, A
(
ééA B
Face
êê 
face
êê 
,
êê 
int
ëë 
a
ëë 
,
ëë 
int
ìì 
b
ìì 
,
ìì 
List
íí 
<
íí 
Vertex
íí 
>
íí 
vertices
íí !
,
íí! "

Dictionary
îî 
<
îî 
int
îî 
,
îî 
int
îî 
>
îî  
lookup
îî! '
)
îî' (
{
ïï 	
List
ğğ 
<
ğğ 
Edge
ğğ 
>
ğğ 
	perimeter
ğğ  
=
ğğ! "

WingedEdge
ğğ# -
.
ğğ- ."
SortEdgesByAdjacency
ğğ. B
(
ğğB C
face
ğğC G
)
ğğG H
;
ğğH I
List
òò 
<
òò 
Vertex
òò 
>
òò 
[
òò 
]
òò 

n_vertices
òò %
=
òò& '
new
òò( +
List
òò, 0
<
òò0 1
Vertex
òò1 7
>
òò7 8
[
òò8 9
]
òò9 :
{
òò; <
new
óó 
List
óó 
<
óó 
Vertex
óó 
>
óó  
(
óó  !
)
óó! "
,
óó" #
new
ôô 
List
ôô 
<
ôô 
Vertex
ôô 
>
ôô  
(
ôô  !
)
ôô! "
}
õõ 
;
õõ 
List
÷÷ 
<
÷÷ 
int
÷÷ 
>
÷÷ 
[
÷÷ 
]
÷÷ 
n_sharedIndexes
÷÷ '
=
÷÷( )
new
÷÷* -
List
÷÷. 2
<
÷÷2 3
int
÷÷3 6
>
÷÷6 7
[
÷÷7 8
]
÷÷8 9
{
÷÷: ;
new
øø 
List
øø 
<
øø 
int
øø 
>
øø 
(
øø 
)
øø 
,
øø  
new
ùù 
List
ùù 
<
ùù 
int
ùù 
>
ùù 
(
ùù 
)
ùù 
}
úú 
;
úú 
List
üü 
<
üü 
int
üü 
>
üü 
[
üü 
]
üü 
	n_indexes
üü !
=
üü" #
new
üü$ '
List
üü( ,
<
üü, -
int
üü- 0
>
üü0 1
[
üü1 2
]
üü2 3
{
üü4 5
new
ıı 
List
ıı 
<
ıı 
int
ıı 
>
ıı 
(
ıı 
)
ıı 
,
ıı  
new
şş 
List
şş 
<
şş 
int
şş 
>
şş 
(
şş 
)
şş 
}
ÿÿ 
;
ÿÿ 
int
 
index
 
=
 
$num
 
;
 
for
ƒƒ 
(
ƒƒ 
int
ƒƒ 
i
ƒƒ 
=
ƒƒ 
$num
ƒƒ 
;
ƒƒ 
i
ƒƒ 
<
ƒƒ 
	perimeter
ƒƒ  )
.
ƒƒ) *
Count
ƒƒ* /
;
ƒƒ/ 0
i
ƒƒ1 2
++
ƒƒ2 4
)
ƒƒ4 5
{
„„ 
if
†† 
(
†† 
	perimeter
†† 
[
†† 
i
†† 
]
††  
.
††  !
Contains
††! )
(
††) *
a
††* +
)
††+ ,
&&
††- /
	perimeter
††0 9
[
††9 :
i
††: ;
]
††; <
.
††< =
Contains
††= E
(
††E F
b
††F G
)
††G H
)
††H I
return
‡‡ 
null
‡‡ 
;
‡‡  
int
‰‰ 
cur
‰‰ 
=
‰‰ 
	perimeter
‰‰ #
[
‰‰# $
i
‰‰$ %
]
‰‰% &
.
‰‰& '
a
‰‰' (
;
‰‰( )

n_vertices
‹‹ 
[
‹‹ 
index
‹‹  
]
‹‹  !
.
‹‹! "
Add
‹‹" %
(
‹‹% &
vertices
‹‹& .
[
‹‹. /
cur
‹‹/ 2
]
‹‹2 3
)
‹‹3 4
;
‹‹4 5
n_sharedIndexes
ŒŒ 
[
ŒŒ  
index
ŒŒ  %
]
ŒŒ% &
.
ŒŒ& '
Add
ŒŒ' *
(
ŒŒ* +
lookup
ŒŒ+ 1
[
ŒŒ1 2
cur
ŒŒ2 5
]
ŒŒ5 6
)
ŒŒ6 7
;
ŒŒ7 8
if
 
(
 
cur
 
==
 
a
 
||
 
cur
  #
==
$ &
b
' (
)
( )
{
 
index
 
=
 
(
 
index
 "
+
# $
$num
% &
)
& '
%
( )
$num
* +
;
+ ,
	n_indexes
’’ 
[
’’ 
index
’’ #
]
’’# $
.
’’$ %
Add
’’% (
(
’’( )

n_vertices
’’) 3
[
’’3 4
index
’’4 9
]
’’9 :
.
’’: ;
Count
’’; @
)
’’@ A
;
’’A B

n_vertices
““ 
[
““ 
index
““ $
]
““$ %
.
““% &
Add
““& )
(
““) *
vertices
““* 2
[
““2 3
cur
““3 6
]
““6 7
)
““7 8
;
““8 9
n_sharedIndexes
”” #
[
””# $
index
””$ )
]
””) *
.
””* +
Add
””+ .
(
””. /
lookup
””/ 5
[
””5 6
cur
””6 9
]
””9 :
)
””: ;
;
””; <
}
•• 
}
–– 
List
˜˜ 
<
˜˜ $
ConnectFaceRebuildData
˜˜ '
>
˜˜' (
faces
˜˜) .
=
˜˜/ 0
new
˜˜1 4
List
˜˜5 9
<
˜˜9 :$
ConnectFaceRebuildData
˜˜: P
>
˜˜P Q
(
˜˜Q R
)
˜˜R S
;
˜˜S T
Vector3
™™ 
nrm
™™ 
=
™™ 
Math
™™ 
.
™™ 
Normal
™™ %
(
™™% &
vertices
™™& .
,
™™. /
face
™™0 4
.
™™4 5
indexesInternal
™™5 D
)
™™D E
;
™™E F
for
›› 
(
›› 
int
›› 
i
›› 
=
›› 
$num
›› 
;
›› 
i
›› 
<
›› 

n_vertices
››  *
.
››* +
Length
››+ 1
;
››1 2
i
››3 4
++
››4 6
)
››6 7
{
œœ 
FaceRebuildData
 
f
  !
=
" #
AppendElements
$ 2
.
2 3
FaceWithVertices
3 C
(
C D

n_vertices
D N
[
N O
i
O P
]
P Q
,
Q R
false
S X
)
X Y
;
Y Z
f
 
.
 
sharedIndexes
 
=
  !
n_sharedIndexes
" 1
[
1 2
i
2 3
]
3 4
;
4 5
Vector3
   
fn
   
=
   
Math
   !
.
  ! "
Normal
  " (
(
  ( )

n_vertices
  ) 3
[
  3 4
i
  4 5
]
  5 6
,
  6 7
f
  8 9
.
  9 :
face
  : >
.
  > ?
indexesInternal
  ? N
)
  N O
;
  O P
if
¢¢ 
(
¢¢ 
Vector3
¢¢ 
.
¢¢ 
Dot
¢¢ 
(
¢¢  
nrm
¢¢  #
,
¢¢# $
fn
¢¢% '
)
¢¢' (
<
¢¢) *
$num
¢¢+ ,
)
¢¢, -
f
££ 
.
££ 
face
££ 
.
££ 
Reverse
££ "
(
££" #
)
££# $
;
££$ %
faces
¥¥ 
.
¥¥ 
Add
¥¥ 
(
¥¥ 
new
¥¥ $
ConnectFaceRebuildData
¥¥ 4
(
¥¥4 5
f
¥¥5 6
,
¥¥6 7
	n_indexes
¥¥8 A
[
¥¥A B
i
¥¥B C
]
¥¥C D
)
¥¥D E
)
¥¥E F
;
¥¥F G
}
¦¦ 
return
¨¨ 
faces
¨¨ 
;
¨¨ 
}
©© 	
static
«« 
List
«« 
<
«« $
ConnectFaceRebuildData
«« *
>
««* +#
ConnectIndexesPerFace
««, A
(
««A B
Face
¬¬ 
face
¬¬ 
,
¬¬ 
List
­­ 
<
­­ 
int
­­ 
>
­­ 
indexes
­­ 
,
­­ 
List
®® 
<
®® 
Vertex
®® 
>
®® 
vertices
®® !
,
®®! "

Dictionary
¯¯ 
<
¯¯ 
int
¯¯ 
,
¯¯ 
int
¯¯ 
>
¯¯  
lookup
¯¯! '
,
¯¯' (
int
°° 
sharedIndexOffset
°° !
)
°°! "
{
±± 	
if
²² 
(
²² 
indexes
²² 
.
²² 
Count
²² 
<
²² 
$num
²²  !
)
²²! "
return
³³ 
null
³³ 
;
³³ 
List
µµ 
<
µµ 
Edge
µµ 
>
µµ 
	perimeter
µµ  
=
µµ! "

WingedEdge
µµ# -
.
µµ- ."
SortEdgesByAdjacency
µµ. B
(
µµB C
face
µµC G
)
µµG H
;
µµH I
int
·· 

splitCount
·· 
=
·· 
indexes
·· $
.
··$ %
Count
··% *
;
··* +
List
¹¹ 
<
¹¹ 
List
¹¹ 
<
¹¹ 
Vertex
¹¹ 
>
¹¹ 
>
¹¹ 

n_vertices
¹¹ )
=
¹¹* +
ArrayUtility
¹¹, 8
.
¹¹8 9
Fill
¹¹9 =
<
¹¹= >
List
¹¹> B
<
¹¹B C
Vertex
¹¹C I
>
¹¹I J
>
¹¹J K
(
¹¹K L
x
¹¹L M
=>
¹¹N P
{
¹¹Q R
return
¹¹S Y
new
¹¹Z ]
List
¹¹^ b
<
¹¹b c
Vertex
¹¹c i
>
¹¹i j
(
¹¹j k
)
¹¹k l
;
¹¹l m
}
¹¹n o
,
¹¹o p

splitCount
¹¹q {
)
¹¹{ |
;
¹¹| }
List
ºº 
<
ºº 
List
ºº 
<
ºº 
int
ºº 
>
ºº 
>
ºº 
n_sharedIndexes
ºº +
=
ºº, -
ArrayUtility
ºº. :
.
ºº: ;
Fill
ºº; ?
<
ºº? @
List
ºº@ D
<
ººD E
int
ººE H
>
ººH I
>
ººI J
(
ººJ K
x
ººK L
=>
ººM O
{
ººP Q
return
ººR X
new
ººY \
List
ºº] a
<
ººa b
int
ººb e
>
ººe f
(
ººf g
)
ººg h
;
ººh i
}
ººj k
,
ººk l

splitCount
ººm w
)
ººw x
;
ººx y
List
»» 
<
»» 
List
»» 
<
»» 
int
»» 
>
»» 
>
»» 
	n_indexes
»» %
=
»»& '
ArrayUtility
»»( 4
.
»»4 5
Fill
»»5 9
<
»»9 :
List
»»: >
<
»»> ?
int
»»? B
>
»»B C
>
»»C D
(
»»D E
x
»»E F
=>
»»G I
{
»»J K
return
»»L R
new
»»S V
List
»»W [
<
»»[ \
int
»»\ _
>
»»_ `
(
»»` a
)
»»a b
;
»»b c
}
»»d e
,
»»e f

splitCount
»»g q
)
»»q r
;
»»r s
Vertex
½½ 
center
½½ 
=
½½ 
Vertex
½½ "
.
½½" #
Average
½½# *
(
½½* +
vertices
½½+ 3
,
½½3 4
indexes
½½5 <
)
½½< =
;
½½= >
Vector3
¾¾ 
nrm
¾¾ 
=
¾¾ 
Math
¾¾ 
.
¾¾ 
Normal
¾¾ %
(
¾¾% &
vertices
¾¾& .
,
¾¾. /
face
¾¾0 4
.
¾¾4 5
indexesInternal
¾¾5 D
)
¾¾D E
;
¾¾E F
int
ÀÀ 
index
ÀÀ 
=
ÀÀ 
$num
ÀÀ 
;
ÀÀ 
for
ÂÂ 
(
ÂÂ 
int
ÂÂ 
i
ÂÂ 
=
ÂÂ 
$num
ÂÂ 
;
ÂÂ 
i
ÂÂ 
<
ÂÂ 
	perimeter
ÂÂ  )
.
ÂÂ) *
Count
ÂÂ* /
;
ÂÂ/ 0
i
ÂÂ1 2
++
ÂÂ2 4
)
ÂÂ4 5
{
ÃÃ 
int
ÄÄ 
cur
ÄÄ 
=
ÄÄ 
	perimeter
ÄÄ #
[
ÄÄ# $
i
ÄÄ$ %
]
ÄÄ% &
.
ÄÄ& '
a
ÄÄ' (
;
ÄÄ( )

n_vertices
ÆÆ 
[
ÆÆ 
index
ÆÆ  
]
ÆÆ  !
.
ÆÆ! "
Add
ÆÆ" %
(
ÆÆ% &
vertices
ÆÆ& .
[
ÆÆ. /
cur
ÆÆ/ 2
]
ÆÆ2 3
)
ÆÆ3 4
;
ÆÆ4 5
n_sharedIndexes
ÇÇ 
[
ÇÇ  
index
ÇÇ  %
]
ÇÇ% &
.
ÇÇ& '
Add
ÇÇ' *
(
ÇÇ* +
lookup
ÇÇ+ 1
[
ÇÇ1 2
cur
ÇÇ2 5
]
ÇÇ5 6
)
ÇÇ6 7
;
ÇÇ7 8
if
ÉÉ 
(
ÉÉ 
indexes
ÉÉ 
.
ÉÉ 
Contains
ÉÉ $
(
ÉÉ$ %
cur
ÉÉ% (
)
ÉÉ( )
)
ÉÉ) *
{
ÊÊ 
	n_indexes
ËË 
[
ËË 
index
ËË #
]
ËË# $
.
ËË$ %
Add
ËË% (
(
ËË( )

n_vertices
ËË) 3
[
ËË3 4
index
ËË4 9
]
ËË9 :
.
ËË: ;
Count
ËË; @
)
ËË@ A
;
ËËA B

n_vertices
ÌÌ 
[
ÌÌ 
index
ÌÌ $
]
ÌÌ$ %
.
ÌÌ% &
Add
ÌÌ& )
(
ÌÌ) *
center
ÌÌ* 0
)
ÌÌ0 1
;
ÌÌ1 2
n_sharedIndexes
ÍÍ #
[
ÍÍ# $
index
ÍÍ$ )
]
ÍÍ) *
.
ÍÍ* +
Add
ÍÍ+ .
(
ÍÍ. /
sharedIndexOffset
ÍÍ/ @
)
ÍÍ@ A
;
ÍÍA B
index
ÏÏ 
=
ÏÏ 
(
ÏÏ 
index
ÏÏ "
+
ÏÏ# $
$num
ÏÏ% &
)
ÏÏ& '
%
ÏÏ( )

splitCount
ÏÏ* 4
;
ÏÏ4 5
	n_indexes
ÑÑ 
[
ÑÑ 
index
ÑÑ #
]
ÑÑ# $
.
ÑÑ$ %
Add
ÑÑ% (
(
ÑÑ( )

n_vertices
ÑÑ) 3
[
ÑÑ3 4
index
ÑÑ4 9
]
ÑÑ9 :
.
ÑÑ: ;
Count
ÑÑ; @
)
ÑÑ@ A
;
ÑÑA B

n_vertices
ÒÒ 
[
ÒÒ 
index
ÒÒ $
]
ÒÒ$ %
.
ÒÒ% &
Add
ÒÒ& )
(
ÒÒ) *
vertices
ÒÒ* 2
[
ÒÒ2 3
cur
ÒÒ3 6
]
ÒÒ6 7
)
ÒÒ7 8
;
ÒÒ8 9
n_sharedIndexes
ÓÓ #
[
ÓÓ# $
index
ÓÓ$ )
]
ÓÓ) *
.
ÓÓ* +
Add
ÓÓ+ .
(
ÓÓ. /
lookup
ÓÓ/ 5
[
ÓÓ5 6
cur
ÓÓ6 9
]
ÓÓ9 :
)
ÓÓ: ;
;
ÓÓ; <
}
ÔÔ 
}
ÕÕ 
List
×× 
<
×× $
ConnectFaceRebuildData
×× '
>
××' (
faces
××) .
=
××/ 0
new
××1 4
List
××5 9
<
××9 :$
ConnectFaceRebuildData
××: P
>
××P Q
(
××Q R
)
××R S
;
××S T
for
ÙÙ 
(
ÙÙ 
int
ÙÙ 
i
ÙÙ 
=
ÙÙ 
$num
ÙÙ 
;
ÙÙ 
i
ÙÙ 
<
ÙÙ 

n_vertices
ÙÙ  *
.
ÙÙ* +
Count
ÙÙ+ 0
;
ÙÙ0 1
i
ÙÙ2 3
++
ÙÙ3 5
)
ÙÙ5 6
{
ÚÚ 
if
ÛÛ 
(
ÛÛ 

n_vertices
ÛÛ 
[
ÛÛ 
i
ÛÛ  
]
ÛÛ  !
.
ÛÛ! "
Count
ÛÛ" '
<
ÛÛ( )
$num
ÛÛ* +
)
ÛÛ+ ,
continue
ÜÜ 
;
ÜÜ 
FaceRebuildData
ŞŞ 
f
ŞŞ  !
=
ŞŞ" #
AppendElements
ŞŞ$ 2
.
ŞŞ2 3
FaceWithVertices
ŞŞ3 C
(
ŞŞC D

n_vertices
ŞŞD N
[
ŞŞN O
i
ŞŞO P
]
ŞŞP Q
,
ŞŞQ R
false
ŞŞS X
)
ŞŞX Y
;
ŞŞY Z
f
ßß 
.
ßß 
sharedIndexes
ßß 
=
ßß  !
n_sharedIndexes
ßß" 1
[
ßß1 2
i
ßß2 3
]
ßß3 4
;
ßß4 5
Vector3
áá 
fn
áá 
=
áá 
Math
áá !
.
áá! "
Normal
áá" (
(
áá( )

n_vertices
áá) 3
[
áá3 4
i
áá4 5
]
áá5 6
,
áá6 7
f
áá8 9
.
áá9 :
face
áá: >
.
áá> ?
indexesInternal
áá? N
)
ááN O
;
ááO P
if
ãã 
(
ãã 
Vector3
ãã 
.
ãã 
Dot
ãã 
(
ãã  
nrm
ãã  #
,
ãã# $
fn
ãã% '
)
ãã' (
<
ãã) *
$num
ãã+ ,
)
ãã, -
f
ää 
.
ää 
face
ää 
.
ää 
Reverse
ää "
(
ää" #
)
ää# $
;
ää$ %
faces
ææ 
.
ææ 
Add
ææ 
(
ææ 
new
ææ $
ConnectFaceRebuildData
ææ 4
(
ææ4 5
f
ææ5 6
,
ææ6 7
	n_indexes
ææ8 A
[
ææA B
i
ææB C
]
ææC D
)
ææD E
)
ææE F
;
ææF G
}
çç 
return
éé 
faces
éé 
;
éé 
}
êê 	
}
ëë 
}ìì Ô
‹D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\VectorHash.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static

 

class

 

VectorHash

 
{ 
public 
const 
float  
FltCompareResolution /
=0 1
$num2 7
;7 8
static 
int 
	HashFloat 
( 
float "
f# $
)$ %
{ 	
ulong 
u 
= 
( 
ulong 
) 
( 
f 
*  ! 
FltCompareResolution" 6
)6 7
;7 8
return 
( 
int 
) 
( 
u 
% 
int  
.  !
MaxValue! )
)) *
;* +
} 	
public 
static 
int 
GetHashCode %
(% &
Vector2& -
v. /
)/ 0
{ 	
int 
hash 
= 
$num 
; 
	unchecked 
{ 
hash   
=   
hash   
*   
$num    
+  ! "
	HashFloat  # ,
(  , -
v  - .
.  . /
x  / 0
)  0 1
;  1 2
hash!! 
=!! 
hash!! 
*!! 
$num!!  
+!!! "
	HashFloat!!# ,
(!!, -
v!!- .
.!!. /
y!!/ 0
)!!0 1
;!!1 2
}"" 
return$$ 
hash$$ 
;$$ 
}%% 	
public,, 
static,, 
int,, 
GetHashCode,, %
(,,% &
Vector3,,& -
v,,. /
),,/ 0
{-- 	
int// 
hash// 
=// 
$num// 
;// 
	unchecked11 
{22 
hash33 
=33 
hash33 
*33 
$num33  
+33! "
	HashFloat33# ,
(33, -
v33- .
.33. /
x33/ 0
)330 1
;331 2
hash44 
=44 
hash44 
*44 
$num44  
+44! "
	HashFloat44# ,
(44, -
v44- .
.44. /
y44/ 0
)440 1
;441 2
hash55 
=55 
hash55 
*55 
$num55  
+55! "
	HashFloat55# ,
(55, -
v55- .
.55. /
z55/ 0
)550 1
;551 2
}66 
return88 
hash88 
;88 
}99 	
public@@ 
static@@ 
int@@ 
GetHashCode@@ %
(@@% &
Vector4@@& -
v@@. /
)@@/ 0
{AA 	
intCC 
hashCC 
=CC 
$numCC 
;CC 
	uncheckedEE 
{FF 
hashGG 
=GG 
hashGG 
*GG 
$numGG  
+GG! "
	HashFloatGG# ,
(GG, -
vGG- .
.GG. /
xGG/ 0
)GG0 1
;GG1 2
hashHH 
=HH 
hashHH 
*HH 
$numHH  
+HH! "
	HashFloatHH# ,
(HH, -
vHH- .
.HH. /
yHH/ 0
)HH0 1
;HH1 2
hashII 
=II 
hashII 
*II 
$numII  
+II! "
	HashFloatII# ,
(II, -
vII- .
.II. /
zII/ 0
)II0 1
;II1 2
hashJJ 
=JJ 
hashJJ 
*JJ 
$numJJ  
+JJ! "
	HashFloatJJ# ,
(JJ, -
vJJ- .
.JJ. /
wJJ/ 0
)JJ0 1
;JJ1 2
}KK 
returnMM 
hashMM 
;MM 
}NN 	
}OO 
}PP ƒ~
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\UV\AutoUvConversion.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
static 
partial 
class 
	UVEditing 
{ 
internal 

static 
void 
	SetAutoUV  
(  !
ProBuilderMesh! /
mesh0 4
,4 5
Face6 :
[: ;
]; <
faces= B
,B C
boolD H
autoI M
)M N
{ 
if 
( 
auto 
) 
{ ,
 SetAutoAndAlignUnwrapParamsToUVs $
($ %
mesh% )
,) *
faces+ 0
.0 1
Where1 6
(6 7
x7 8
=>9 ;
x< =
.= >
manualUV> F
)F G
)G H
;H I
} 
else 
{ 
foreach 
( 
Face 
f 
in 
faces 
) 
{ 
f 
. 
textureGroup 
= 
- 
$num 
; 
f 
. 
manualUV 
= 
true 
; 
} 
} 
} 
internal'' 

static'' 
void'' ,
 SetAutoAndAlignUnwrapParamsToUVs'' 7
(''7 8
ProBuilderMesh''8 F
mesh''G K
,''K L
IEnumerable''M X
<''X Y
Face''Y ]
>''] ^
facesToConvert''_ m
)''m n
{(( 
var)) 
destinationTextures)) 
=)) 
mesh)) !
.))! "
textures))" *
.))* +
ToArray))+ 2
())2 3
)))3 4
;))4 5
var** 
faces** 
=** 
facesToConvert** 
as**  
Face**! %
[**% &
]**& '
??**( *
facesToConvert**+ 9
.**9 :
ToArray**: A
(**A B
)**B C
;**C D
foreach,, 

(,, 
var,, 
face,, 
in,, 
faces,, 
),, 
{-- 
face.. 
... 	
uv..	 
=.. 
AutoUnwrapSettings..  
...  !%
defaultAutoUnwrapSettings..! :
;..: ;
face// 
.// 	
elementGroup//	 
=// 
-// 
$num// 
;// 
face00 
.00 	
textureGroup00	 
=00 
-00 
$num00 
;00 
face11 
.11 	
manualUV11	 
=11 
false11 
;11 
}22 
mesh44 
.44 
	RefreshUV44 
(44 
faces44 
)44 
;44 
var55  
unmodifiedProjection55 
=55 
mesh55 "
.55" #
texturesInternal55# 3
;553 4
foreach77 

(77 
var77 
face77 
in77 
faces77 
)77 
{88 
var99 
trs99 
=99 
CalculateDelta99 
(99  
unmodifiedProjection99 1
,991 2
face993 7
.997 8
indexesInternal998 G
,99G H
destinationTextures99I \
,99\ ]
face99^ b
.99b c
indexesInternal99c r
)99r s
;99s t
var:: 
uv:: 

=:: 
face:: 
.:: 
uv:: 
;:: 
uv?? 
.?? 
offset?? 
=?? 
-?? 
trs?? 
.?? 
translation??  
;??  !
uv@@ 
.@@ 
rotation@@ 
=@@ 
trs@@ 
.@@ 
rotation@@ 
;@@ 
uvAA 
.AA 
scaleAA 
=AA 
trsAA 
.AA 
scaleAA 
;AA 
faceBB 
.BB 	
uvBB	 
=BB 
uvBB 
;BB 
}CC 
meshEE 
.EE 
	RefreshUVEE 
(EE 
facesEE 
)EE 
;EE 
}FF 
internalHH 

structHH 
UVTransformHH 
{II 
publicJJ 	
Vector2JJ
 
translationJJ 
;JJ 
publicKK 	
floatKK
 
rotationKK 
;KK 
publicLL 	
Vector2LL
 
scaleLL 
;LL 
publicNN 	
overrideNN
 
stringNN 
ToStringNN "
(NN" #
)NN# $
{OO 
returnPP 

translationPP 
.PP 
ToStringPP 
(PP  
$strPP  $
)PP$ %
+PP& '
$strPP( ,
+PP- .
rotationPP/ 7
+PP8 9
$strPP: >
+PP? @
scalePPA F
.PPF G
ToStringPPG O
(PPO P
$strPPP T
)PPT U
;PPU V
}QQ 
}RR 
staticTT 
ListTT	 
<TT 
Vector2TT 
>TT )
s_UVTransformProjectionBufferTT 4
=TT5 6
newTT7 :
ListTT; ?
<TT? @
Vector2TT@ G
>TTG H
(TTH I
$numTTI J
)TTJ K
;TTK L
internal\\ 
static\\ 
AutoUnwrapSettings\\ *!
GetAutoUnwrapSettings\\+ @
(\\@ A
ProBuilderMesh\\A O
mesh\\P T
,\\T U
Face\\V Z
face\\[ _
)\\_ `
{]] 	
if^^ 
(^^ 
!^^ 
face^^ 
.^^ 
manualUV^^ 
)^^ 
return__ 
new__ 
AutoUnwrapSettings__ -
(__- .
face__. 2
.__2 3
uv__3 5
)__5 6
;__6 7
varaa 
trsaa 
=aa 
GetUVTransformaa $
(aa$ %
meshaa% )
,aa) *
faceaa+ /
)aa/ 0
;aa0 1
varbb 

uvSettingsbb 
=bb 
AutoUnwrapSettingsbb /
.bb/ 0%
defaultAutoUnwrapSettingsbb0 I
;bbI J

uvSettingscc 
.cc 
offsetcc 
=cc 
trscc  #
.cc# $
translationcc$ /
;cc/ 0

uvSettingsdd 
.dd 
rotationdd 
=dd  !
$numdd" %
-dd& '
trsdd( +
.dd+ ,
rotationdd, 4
;dd4 5

uvSettingsee 
.ee 
scaleee 
=ee 

uvSettingsee )
.ee) *
scaleee* /
/ee/ 0
trsee0 3
.ee3 4
scaleee4 9
;ee9 :
returngg 

uvSettingsgg 
;gg 
}hh 	
internalqq 
staticqq 
UVTransformqq #
GetUVTransformqq$ 2
(qq2 3
ProBuilderMeshqq3 A
meshqqB F
,qqF G
FaceqqH L
faceqqM Q
)qqQ R
{rr 

Projectionss 
.ss 
PlanarProjectss 
(ss 
meshss  
.ss  !
positionsInternalss! 2
,ss2 3
facess4 8
.ss8 9
indexesInternalss9 H
,ssH I
MathssJ N
.ssN O
NormalssO U
(ssU V
meshssV Z
,ssZ [
facess\ `
)ss` a
,ssa b*
s_UVTransformProjectionBuffer	ssc €
)
ss€ 
;
ss ‚
returntt 	
CalculateDeltatt
 
(tt 
meshtt 
.tt 
texturesInternaltt .
,tt. /
facett0 4
.tt4 5
indexesInternaltt5 D
,ttD E)
s_UVTransformProjectionBufferttF c
,ttc d
nulltte i
)tti j
;ttj k
}uu 
staticyy 
intyy	 
GetIndexyy 
(yy 
IListyy 
<yy 
intyy 
>yy  

collectionyy! +
,yy+ ,
intyy- 0
indexyy1 6
)yy6 7
{zz 
return{{ 	

collection{{
 
=={{ 
null{{ 
?{{ 
index{{ $
:{{% &

collection{{' 1
[{{1 2
index{{2 7
]{{7 8
;{{8 9
}|| 
internal
€€ 

static
€€ 
UVTransform
€€ 
CalculateDelta
€€ ,
(
€€, -
IList
€€- 2
<
€€2 3
Vector2
€€3 :
>
€€: ;
src
€€< ?
,
€€? @
IList
€€A F
<
€€F G
int
€€G J
>
€€J K

srcIndices
€€L V
,
€€V W
IList
€€X ]
<
€€] ^
Vector2
€€^ e
>
€€e f
dst
€€g j
,
€€j k
IList
€€l q
<
€€q r
int
€€r u
>
€€u v

dstIndices€€w 
)€€ ‚
{
 	
Vector2
ƒƒ	 
dstAngle
ƒƒ 
=
ƒƒ 
dst
ƒƒ 
[
ƒƒ  
GetIndex
ƒƒ  (
(
ƒƒ( )

dstIndices
ƒƒ) 3
,
ƒƒ3 4
$num
ƒƒ5 6
)
ƒƒ6 7
]
ƒƒ7 8
-
ƒƒ9 :
dst
ƒƒ; >
[
ƒƒ> ?
GetIndex
ƒƒ? G
(
ƒƒG H

dstIndices
ƒƒH R
,
ƒƒR S
$num
ƒƒT U
)
ƒƒU V
]
ƒƒV W
;
ƒƒW X
Vector2
„„	 
srcAngle
„„ 
=
„„ 
src
„„ 
[
„„  
GetIndex
„„  (
(
„„( )

srcIndices
„„) 3
,
„„3 4
$num
„„5 6
)
„„6 7
]
„„7 8
-
„„9 :
src
„„; >
[
„„> ?
GetIndex
„„? G
(
„„G H

srcIndices
„„H R
,
„„R S
$num
„„T U
)
„„U V
]
„„V W
;
„„W X
float
††	 
rotation
†† 
=
†† 
Vector2
†† !
.
††! "
Angle
††" '
(
††' (
dstAngle
††( 0
,
††0 1
srcAngle
††2 :
)
††: ;
;
††; <
if
ˆˆ	 
(
ˆˆ 
Vector2
ˆˆ 
.
ˆˆ 
Dot
ˆˆ 
(
ˆˆ 
Vector2
ˆˆ  
.
ˆˆ  !
Perpendicular
ˆˆ! .
(
ˆˆ. /
dstAngle
ˆˆ/ 7
)
ˆˆ7 8
,
ˆˆ8 9
srcAngle
ˆˆ: B
)
ˆˆB C
<
ˆˆD E
$num
ˆˆF G
)
ˆˆG H
rotation
‰‰
 
=
‰‰ 
$num
‰‰ 
-
‰‰ 
rotation
‰‰ $
;
‰‰$ %
Vector2
‹‹	 
	dstCenter
‹‹ 
=
‹‹ 

dstIndices
‹‹ '
==
‹‹( *
null
‹‹+ /
?
‹‹0 1
Bounds2D
‹‹2 :
.
‹‹: ;
Center
‹‹; A
(
‹‹A B
dst
‹‹B E
)
‹‹E F
:
‹‹G H
Bounds2D
‹‹I Q
.
‹‹Q R
Center
‹‹R X
(
‹‹X Y
dst
‹‹Y \
,
‹‹\ ]

dstIndices
‹‹^ h
)
‹‹h i
;
‹‹i j
Vector2
	 
dstSize
 
=
 
GetRotatedSize
 )
(
) *
dst
* -
,
- .

dstIndices
/ 9
,
9 :
	dstCenter
; D
,
D E
-
F G
rotation
G O
)
O P
;
P Q
var
	 
	srcBounds
 
=
 

srcIndices
 #
==
$ &
null
' +
?
, -
new
. 1
Bounds2D
2 :
(
: ;
src
; >
)
> ?
:
@ A
new
B E
Bounds2D
F N
(
N O
src
O R
,
R S

srcIndices
T ^
)
^ _
;
_ `
return
’’ 	
new
’’
 
UVTransform
’’ 
(
’’ 
)
’’ 
{
““ 
translation
”” 
=
”” 
	dstCenter
”” 
-
”” 
	srcBounds
”” '
.
””' (
center
””( .
,
””. /
rotation
•• 
=
•• 
rotation
•• 
,
•• 
scale
–– 	
=
––
 
dstSize
–– 
.
–– 
DivideBy
–– 
(
–– 
	srcBounds
–– &
.
––& '
size
––' +
)
––+ ,
}
—— 
;
—— 
}
˜˜ 	
static
šš 
Vector2
šš 
GetRotatedSize
šš %
(
šš% &
IList
šš& +
<
šš+ ,
Vector2
šš, 3
>
šš3 4
points
šš5 ;
,
šš; <
IList
šš= B
<
ššB C
int
ššC F
>
ššF G
indices
ššH O
,
ššO P
Vector2
ššQ X
center
ššY _
,
šš_ `
float
šša f
rotation
ššg o
)
ššo p
{
›› 	
int
œœ	 
size
œœ 
=
œœ 
indices
œœ 
==
œœ 
null
œœ #
?
œœ$ %
points
œœ& ,
.
œœ, -
Count
œœ- 2
:
œœ3 4
indices
œœ5 <
.
œœ< =
Count
œœ= B
;
œœB C
Vector2
	 
point
 
=
 
points
 
[
  
GetIndex
  (
(
( )
indices
) 0
,
0 1
$num
2 3
)
3 4
]
4 5
.
5 6
RotateAroundPoint
6 G
(
G H
center
H N
,
N O
rotation
P X
)
X Y
;
Y Z
float
  	 
xMin
   
=
   
point
   
.
   
x
   
;
   
float
¡¡	 
yMin
¡¡ 
=
¡¡ 
point
¡¡ 
.
¡¡ 
y
¡¡ 
;
¡¡ 
float
¢¢	 
xMax
¢¢ 
=
¢¢ 
xMin
¢¢ 
;
¢¢ 
float
££	 
yMax
££ 
=
££ 
yMin
££ 
;
££ 
for
¥¥	 
(
¥¥ 
int
¥¥ 
i
¥¥ 
=
¥¥ 
$num
¥¥ 
;
¥¥ 
i
¥¥ 
<
¥¥ 
size
¥¥ !
;
¥¥! "
i
¥¥# $
++
¥¥$ &
)
¥¥& '
{
¦¦	 

point
§§
 
=
§§ 
points
§§ 
[
§§ 
GetIndex
§§ !
(
§§! "
indices
§§" )
,
§§) *
i
§§+ ,
)
§§, -
]
§§- .
.
§§. /
RotateAroundPoint
§§/ @
(
§§@ A
center
§§A G
,
§§G H
rotation
§§I Q
)
§§Q R
;
§§R S
float
©©
 
x
©© 
=
©© 
point
©© 
.
©© 
x
©© 
;
©© 
float
ªª
 
y
ªª 
=
ªª 
point
ªª 
.
ªª 
y
ªª 
;
ªª 
if
¬¬
 
(
¬¬ 
x
¬¬ 
<
¬¬ 
xMin
¬¬ 
)
¬¬ 
xMin
¬¬ 
=
¬¬ 
x
¬¬  
;
¬¬  !
if
­­
 
(
­­ 
x
­­ 
>
­­ 
xMax
­­ 
)
­­ 
xMax
­­ 
=
­­ 
x
­­  
;
­­  !
if
¯¯
 
(
¯¯ 
y
¯¯ 
<
¯¯ 
yMin
¯¯ 
)
¯¯ 
yMin
¯¯ 
=
¯¯ 
y
¯¯  
;
¯¯  !
if
°°
 
(
°° 
y
°° 
>
°° 
yMax
°° 
)
°° 
yMax
°° 
=
°° 
y
°°  
;
°°  !
}
±±	 

return
³³	 
new
³³ 
Vector2
³³ 
(
³³ 
xMax
³³  
-
³³! "
xMin
³³# '
,
³³' (
yMax
³³) -
-
³³. /
yMin
³³0 4
)
³³4 5
;
³³5 6
}
´´ 	
}
µµ 
}¶¶ öÆ
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\PreferenceKeys.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
static		 

class		 
PreferenceKeys		 
{

 
public 
const 
string 
pluginTitle '
=( )
$str* 6
;6 7
internal 
const 
float )
k_MaxPointDistanceFromControl :
=; <
$num= @
;@ A
internal 
const 
char 
DEGREE_SYMBOL )
=, -
(. /
char/ 3
)3 4
$num4 7
;7 8
internal 
const 
char 
	CMD_SUPER %
=, -
$char. 6
;6 7
internal 
const 
char 
	CMD_SHIFT %
=, -
$char. 6
;6 7
internal 
const 
char 

CMD_OPTION &
=, -
$char. 6
;6 7
internal 
const 
char 
CMD_ALT #
=, -
$char. 6
;6 7
internal 
const 
char 

CMD_DELETE &
=, -
$char. 6
;6 7
internal 
static 
readonly  
Color! &
proBuilderBlue' 5
=6 7
new8 ;
Color< A
(A B
$numB D
,D E
$numF K
,K L
$numM R
,R S
$numT V
)V W
;W X
internal 
static 
readonly  
Color! &
proBuilderLightGray' :
=; <
new= @
ColorA F
(F G
$numG K
,K L
$numM Q
,Q R
$numS W
,W X
$numY \
)\ ]
;] ^
internal 
static 
readonly  
Color! &
proBuilderDarkGray' 9
=: ;
new< ?
Color@ E
(E F
$numF I
,I J
$numK N
,N O
$numP S
,S T
$numU X
)X Y
;Y Z
public 
const 
int 

menuEditor #
=$ %
$num& )
;) *
public$$ 
const$$ 
int$$ 
menuSelection$$ &
=$$' (
$num$$) ,
;$$, -
public)) 
const)) 
int)) 
menuGeometry)) %
=))& '
$num))( +
;))+ ,
public.. 
const.. 
int.. 
menuActions.. $
=..% &
$num..' *
;..* +
public33 
const33 
int33 
menuMaterialColors33 +
=33, -
$num33. 1
;331 2
public88 
const88 
int88 
menuVertexColors88 )
=88* +
$num88, /
;88/ 0
public== 
const== 
int== 

menuRepair== #
===$ %
$num==& )
;==) *
publicBB 
constBB 
intBB 
menuMiscBB !
=BB" #
$numBB$ '
;BB' (
publicGG 
constGG 
intGG 

menuExportGG #
=GG$ %
$numGG& )
;GG) *
[II 	
ObsoleteII	 
(II 
$strII ;
)II; <
]II< =
internalJJ 
constJJ 
stringJJ 
pbDefaultEditLevelJJ 0
=JJ1 2
$strJJ3 G
;JJG H
[KK 	
ObsoleteKK	 
(KK 
$strKK ;
)KK; <
]KK< =
internalLL 
constLL 
stringLL "
pbDefaultSelectionModeLL 4
=LL5 6
$strLL7 O
;LLO P
[MM 	
ObsoleteMM	 
(MM 
$strMM ;
)MM; <
]MM< =
internalNN 
constNN 
stringNN 
pbHandleAlignmentNN /
=NN0 1
$strNN2 E
;NNE F
[OO 	
ObsoleteOO	 
(OO 
$strOO ;
)OO; <
]OO< =
internalPP 
constPP 
stringPP 
pbVertexColorToolPP /
=PP0 1
$strPP2 E
;PPE F
[QQ 	
ObsoleteQQ	 
(QQ 
$strQQ ;
)QQ; <
]QQ< =
internalRR 
constRR 
stringRR 
pbToolbarLocationRR /
=RR0 1
$strRR2 E
;RRE F
[SS 	
ObsoleteSS	 
(SS 
$strSS ;
)SS; <
]SS< =
internalTT 
constTT 
stringTT 
pbDefaultEntityTT -
=TT. /
$strTT0 A
;TTA B
[UU 	
ObsoleteUU	 
(UU 
$strUU ;
)UU; <
]UU< =
internalVV 
constVV 
stringVV 
pbExtrudeMethodVV -
=VV. /
$strVV0 A
;VVA B
[WW 	
ObsoleteWW	 
(WW 
$strWW ;
)WW; <
]WW< =
internalXX 
constXX 
stringXX  
pbDefaultStaticFlagsXX 2
=XX3 4
$strXX5 K
;XXK L
[YY 	
ObsoleteYY	 
(YY 
$strYY ;
)YY; <
]YY< =
internalZZ 
constZZ 
stringZZ 
pbSelectedFaceColorZZ 1
=ZZ2 3
$strZZ4 H
;ZZH I
[[[ 	
Obsolete[[	 
([[ 
$str[[ ;
)[[; <
][[< =
internal\\ 
const\\ 
string\\ 
pbWireframeColor\\ .
=\\/ 0
$str\\1 E
;\\E F
[]] 	
Obsolete]]	 
(]] 
$str]] ;
)]]; <
]]]< =
internal^^ 
const^^ 
string^^ !
pbUnselectedEdgeColor^^ 3
=^^4 5
$str^^6 M
;^^M N
[__ 	
Obsolete__	 
(__ 
$str__ ;
)__; <
]__< =
internal`` 
const`` 
string`` 
pbSelectedEdgeColor`` 1
=``2 3
$str``4 I
;``I J
[aa 	
Obsoleteaa	 
(aa 
$straa ;
)aa; <
]aa< =
internalbb 
constbb 
stringbb !
pbSelectedVertexColorbb 3
=bb4 5
$strbb6 T
;bbT U
[cc 	
Obsoletecc	 
(cc 
$strcc ;
)cc; <
]cc< =
internaldd 
constdd 
stringdd #
pbUnselectedVertexColordd 5
=dd6 7
$strdd8 N
;ddN O
[ee 	
Obsoleteee	 
(ee 
$stree ;
)ee; <
]ee< =
internalff 
constff 
stringff 
pbPreselectionColorff 1
=ff2 3
$strff4 I
;ffI J
[gg 	
Obsoletegg	 
(gg 
$strgg ;
)gg; <
]gg< =
internalhh 
consthh 
stringhh )
pbDefaultOpenInDockableWindowhh ;
=hh< =
$strhh> ]
;hh] ^
[ii 	
Obsoleteii	 
(ii 
$strii ;
)ii; <
]ii< =
internaljj 
constjj 
stringjj 
pbEditorPrefVersionjj 1
=jj2 3
$strjj4 I
;jjI J
[kk 	
Obsoletekk	 
(kk 
$strkk ;
)kk; <
]kk< =
internalll 
constll 
stringll $
pbEditorShortcutsVersionll 6
=ll7 8
$strll9 S
;llS T
[mm 	
Obsoletemm	 
(mm 
$strmm ;
)mm; <
]mm< =
internalnn 
constnn 
stringnn 
pbDefaultCollidernn /
=nn0 1
$strnn2 E
;nnE F
[oo 	
Obsoleteoo	 
(oo 
$stroo ;
)oo; <
]oo< =
internalpp 
constpp 
stringpp 
pbForceConvexpp +
=pp, -
$strpp. =
;pp= >
[qq 	
Obsoleteqq	 
(qq 
$strqq ;
)qq; <
]qq< =
internalrr 
constrr 
stringrr 
pbVertexColorPrefsrr 0
=rr1 2
$strrr3 G
;rrG H
[ss 	
Obsoletess	 
(ss 
$strss ;
)ss; <
]ss< =
internaltt 
consttt 
stringtt %
pbShowEditorNotificationstt 7
=tt8 9
$strtt: U
;ttU V
[uu 	
Obsoleteuu	 
(uu 
$struu ;
)uu; <
]uu< =
internalvv 
constvv 
stringvv 
pbDragCheckLimitvv .
=vv/ 0
$strvv1 C
;vvC D
[ww 	
Obsoleteww	 
(ww 
$strww ;
)ww; <
]ww< =
internalxx 
constxx 
stringxx 
pbForceVertexPivotxx 0
=xx1 2
$strxx3 G
;xxG H
[yy 	
Obsoleteyy	 
(yy 
$stryy ;
)yy; <
]yy< =
internalzz 
constzz 
stringzz 
pbForceGridPivotzz .
=zz/ 0
$strzz1 C
;zzC D
[{{ 	
Obsolete{{	 
({{ 
$str{{ ;
){{; <
]{{< =
internal|| 
const|| 
string|| #
pbManifoldEdgeExtrusion|| 5
=||6 7
$str||8 Q
;||Q R
[}} 	
Obsolete}}	 
(}} 
$str}} ;
)}}; <
]}}< =
internal~~ 
const~~ 
string~~ %
pbPerimeterEdgeBridgeOnly~~ 7
=~~8 9
$str~~: U
;~~U V
[ 	
Obsolete	 
( 
$str ;
); <
]< =
internal
€€ 
const
€€ 
string
€€  
pbPBOSelectionOnly
€€ 0
=
€€1 2
$str
€€3 G
;
€€G H
[
 	
Obsolete
	 
(
 
$str
 ;
)
; <
]
< =
internal
‚‚ 
const
‚‚ 
string
‚‚  
pbCloseShapeWindow
‚‚ 0
=
‚‚1 2
$str
‚‚3 G
;
‚‚G H
[
ƒƒ 	
Obsolete
ƒƒ	 
(
ƒƒ 
$str
ƒƒ ;
)
ƒƒ; <
]
ƒƒ< =
internal
„„ 
const
„„ 
string
„„  
pbUVEditorFloating
„„ 0
=
„„1 2
$str
„„3 G
;
„„G H
[
…… 	
Obsolete
……	 
(
…… 
$str
…… ;
)
……; <
]
……< =
internal
†† 
const
†† 
string
†† !
pbUVMaterialPreview
†† 1
=
††2 3
$str
††4 I
;
††I J
[
‡‡ 	
Obsolete
‡‡	 
(
‡‡ 
$str
‡‡ ;
)
‡‡; <
]
‡‡< =
internal
ˆˆ 
const
ˆˆ 
string
ˆˆ  
pbShowSceneToolbar
ˆˆ 0
=
ˆˆ1 2
$str
ˆˆ3 G
;
ˆˆG H
[
‰‰ 	
Obsolete
‰‰	 
(
‰‰ 
$str
‰‰ ;
)
‰‰; <
]
‰‰< =
internal
ŠŠ 
const
ŠŠ 
string
ŠŠ .
 pbNormalizeUVsOnPlanarProjection
ŠŠ >
=
ŠŠ? @
$str
ŠŠA c
;
ŠŠc d
[
‹‹ 	
Obsolete
‹‹	 
(
‹‹ 
$str
‹‹ ;
)
‹‹; <
]
‹‹< =
internal
ŒŒ 
const
ŒŒ 
string
ŒŒ &
pbStripProBuilderOnBuild
ŒŒ 6
=
ŒŒ7 8
$str
ŒŒ9 S
;
ŒŒS T
[
 	
Obsolete
	 
(
 
$str
 ;
)
; <
]
< =
internal
 
const
 
string
 (
pbDisableAutoUV2Generation
 8
=
9 :
$str
; W
;
W X
[
 	
Obsolete
	 
(
 
$str
 ;
)
; <
]
< =
internal
 
const
 
string
 
pbShowSceneInfo
 -
=
. /
$str
0 A
;
A B
[
‘‘ 	
Obsolete
‘‘	 
(
‘‘ 
$str
‘‘ ;
)
‘‘; <
]
‘‘< =
internal
’’ 
const
’’ 
string
’’ '
pbEnableBackfaceSelection
’’ 7
=
’’8 9
$str
’’: U
;
’’U V
[
““ 	
Obsolete
““	 
(
““ 
$str
““ ;
)
““; <
]
““< =
internal
”” 
const
”” 
string
”” %
pbVertexPaletteDockable
”” 5
=
””6 7
$str
””8 Q
;
””Q R
[
•• 	
Obsolete
••	 
(
•• 
$str
•• ;
)
••; <
]
••< =
internal
–– 
const
–– 
string
–– 
pbExtrudeAsGroup
–– .
=
––/ 0
$str
––1 C
;
––C D
[
—— 	
Obsolete
——	 
(
—— 
$str
—— ;
)
——; <
]
——< =
internal
˜˜ 
const
˜˜ 
string
˜˜ #
pbUniqueModeShortcuts
˜˜ 3
=
˜˜4 5
$str
˜˜6 M
;
˜˜M N
[
™™ 	
Obsolete
™™	 
(
™™ 
$str
™™ ;
)
™™; <
]
™™< =
internal
šš 
const
šš 
string
šš &
pbMaterialEditorFloating
šš 6
=
šš7 8
$str
šš9 S
;
ššS T
[
›› 	
Obsolete
››	 
(
›› 
$str
›› ;
)
››; <
]
››< =
internal
œœ 
const
œœ 
string
œœ #
pbShapeWindowFloating
œœ 3
=
œœ4 5
$str
œœ6 M
;
œœM N
[
 	
Obsolete
	 
(
 
$str
 ;
)
; <
]
< =
internal
 
const
 
string
 
	pbIconGUI
 '
=
( )
$str
* 5
;
5 6
[
ŸŸ 	
Obsolete
ŸŸ	 
(
ŸŸ 
$str
ŸŸ ;
)
ŸŸ; <
]
ŸŸ< =
internal
   
const
   
string
   !
pbShiftOnlyTooltips
   1
=
  2 3
$str
  4 I
;
  I J
[
¡¡ 	
Obsolete
¡¡	 
(
¡¡ 
$str
¡¡ ;
)
¡¡; <
]
¡¡< =
internal
¢¢ 
const
¢¢ 
string
¢¢ 
pbDrawAxisLines
¢¢ -
=
¢¢. /
$str
¢¢0 A
;
¢¢A B
[
££ 	
Obsolete
££	 
(
££ 
$str
££ ;
)
££; <
]
££< =
internal
¤¤ 
const
¤¤ 
string
¤¤ %
pbCollapseVertexToFirst
¤¤ 5
=
¤¤6 7
$str
¤¤8 Q
;
¤¤Q R
[
¥¥ 	
Obsolete
¥¥	 
(
¥¥ 
$str
¥¥ ;
)
¥¥; <
]
¥¥< =
internal
¦¦ 
const
¦¦ 
string
¦¦ 
pbMeshesAreAssets
¦¦ /
=
¦¦0 1
$str
¦¦2 E
;
¦¦E F
[
§§ 	
Obsolete
§§	 
(
§§ 
$str
§§ ;
)
§§; <
]
§§< =
internal
¨¨ 
const
¨¨ 
string
¨¨ (
pbElementSelectIsHamFisted
¨¨ 8
=
¨¨9 :
$str
¨¨; W
;
¨¨W X
[
©© 	
Obsolete
©©	 
(
©© 
$str
©© ;
)
©©; <
]
©©< =
internal
ªª 
const
ªª 
string
ªª )
pbFillHoleSelectsEntirePath
ªª 9
=
ªª: ;
$str
ªª< Y
;
ªªY Z
[
«« 	
Obsolete
««	 
(
«« 
$str
«« ;
)
««; <
]
««< =
internal
¬¬ 
const
¬¬ 
string
¬¬ !
pbDetachToNewObject
¬¬ 1
=
¬¬2 3
$str
¬¬4 I
;
¬¬I J
[
­­ 	
Obsolete
­­	 
(
­­ 
$str
­­ ;
)
­­; <
]
­­< =
internal
®® 
const
®® 
string
®® 
pbPreserveFaces
®® -
=
®®. /
$str
®®0 A
;
®®A B
[
¯¯ 	
Obsolete
¯¯	 
(
¯¯ 
$str
¯¯ ;
)
¯¯; <
]
¯¯< =
internal
°° 
const
°° 
string
°° &
pbDragSelectWholeElement
°° 6
=
°°7 8
$str
°°9 S
;
°°S T
[
±± 	
Obsolete
±±	 
(
±± 
$str
±± ;
)
±±; <
]
±±< =
internal
²² 
const
²² 
string
²² )
pbShowPreselectionHighlight
²² 9
=
²²: ;
$str
²²< Y
;
²²Y Z
[
³³ 	
Obsolete
³³	 
(
³³ 
$str
³³ ;
)
³³; <
]
³³< =
internal
´´ 
const
´´ 
string
´´ 
pbRectSelectMode
´´ .
=
´´/ 0
$str
´´1 C
;
´´C D
[
µµ 	
Obsolete
µµ	 
(
µµ 
$str
µµ ;
)
µµ; <
]
µµ< =
internal
¶¶ 
const
¶¶ 
string
¶¶ 
pbDragSelectMode
¶¶ .
=
¶¶/ 0
$str
¶¶1 C
;
¶¶C D
[
·· 	
Obsolete
··	 
(
·· 
$str
·· ;
)
··; <
]
··< =
internal
¸¸ 
const
¸¸ 
string
¸¸ !
pbShadowCastingMode
¸¸ 1
=
¸¸2 3
$str
¸¸4 I
;
¸¸I J
[
¹¹ 	
Obsolete
¹¹	 
(
¹¹ 
$str
¹¹ ;
)
¹¹; <
]
¹¹< =
internal
ºº 
const
ºº 
string
ºº "
pbEnableExperimental
ºº 2
=
ºº3 4
$str
ºº5 K
;
ººK L
[
»» 	
Obsolete
»»	 
(
»» 
$str
»» ;
)
»»; <
]
»»< =
internal
¼¼ 
const
¼¼ 
string
¼¼ )
pbCheckForProBuilderUpdates
¼¼ 9
=
¼¼: ;
$str
¼¼< Y
;
¼¼Y Z
[
½½ 	
Obsolete
½½	 
(
½½ 
$str
½½ ;
)
½½; <
]
½½< =
internal
¾¾ 
const
¾¾ 
string
¾¾ ,
pbManageLightmappingStaticFlag
¾¾ <
=
¾¾= >
$str
¾¾? _
;
¾¾_ `
[
¿¿ 	
Obsolete
¿¿	 
(
¿¿ 
$str
¿¿ ;
)
¿¿; <
]
¿¿< =
internal
ÀÀ 
const
ÀÀ 
string
ÀÀ ,
pbShowMissingLightmapUvWarning
ÀÀ <
=
ÀÀ= >
$str
ÀÀ? n
;
ÀÀn o
[
ÁÁ 	
Obsolete
ÁÁ	 
(
ÁÁ 
$str
ÁÁ ;
)
ÁÁ; <
]
ÁÁ< =
internal
ÂÂ 
const
ÂÂ 
string
ÂÂ "
pbSelectedFaceDither
ÂÂ 2
=
ÂÂ3 4
$str
ÂÂ5 K
;
ÂÂK L
[
ÃÃ 	
Obsolete
ÃÃ	 
(
ÃÃ 
$str
ÃÃ ;
)
ÃÃ; <
]
ÃÃ< =
internal
ÄÄ 
const
ÄÄ 
string
ÄÄ 
pbUseUnityColors
ÄÄ .
=
ÄÄ/ 0
$str
ÄÄ1 C
;
ÄÄC D
[
ÅÅ 	
Obsolete
ÅÅ	 
(
ÅÅ 
$str
ÅÅ ;
)
ÅÅ; <
]
ÅÅ< =
internal
ÆÆ 
const
ÆÆ 
string
ÆÆ  
pbVertexHandleSize
ÆÆ 0
=
ÆÆ1 2
$str
ÆÆ3 G
;
ÆÆG H
[
ÇÇ 	
Obsolete
ÇÇ	 
(
ÇÇ 
$str
ÇÇ ;
)
ÇÇ; <
]
ÇÇ< =
internal
ÈÈ 
const
ÈÈ 
string
ÈÈ 
pbUVGridSnapValue
ÈÈ /
=
ÈÈ0 1
$str
ÈÈ2 E
;
ÈÈE F
[
ÉÉ 	
Obsolete
ÉÉ	 
(
ÉÉ 
$str
ÉÉ ;
)
ÉÉ; <
]
ÉÉ< =
internal
ÊÊ 
const
ÊÊ 
string
ÊÊ 
pbUVWeldDistance
ÊÊ .
=
ÊÊ/ 0
$str
ÊÊ1 C
;
ÊÊC D
[
ËË 	
Obsolete
ËË	 
(
ËË 
$str
ËË ;
)
ËË; <
]
ËË< =
internal
ÌÌ 
const
ÌÌ 
string
ÌÌ 
pbLineHandleSize
ÌÌ .
=
ÌÌ/ 0
$str
ÌÌ1 C
;
ÌÌC D
[
ÍÍ 	
Obsolete
ÍÍ	 
(
ÍÍ 
$str
ÍÍ ;
)
ÍÍ; <
]
ÍÍ< =
internal
ÎÎ 
const
ÎÎ 
string
ÎÎ 
pbWireframeSize
ÎÎ -
=
ÎÎ. /
$str
ÎÎ0 A
;
ÎÎA B
[
ÏÏ 	
Obsolete
ÏÏ	 
(
ÏÏ 
$str
ÏÏ ;
)
ÏÏ; <
]
ÏÏ< =
internal
ĞĞ 
const
ĞĞ 
string
ĞĞ 
pbWeldDistance
ĞĞ ,
=
ĞĞ- .
$str
ĞĞ/ ?
;
ĞĞ? @
[
ÑÑ 	
Obsolete
ÑÑ	 
(
ÑÑ 
$str
ÑÑ ;
)
ÑÑ; <
]
ÑÑ< =
internal
ÒÒ 
const
ÒÒ 
string
ÒÒ 
pbExtrudeDistance
ÒÒ /
=
ÒÒ0 1
$str
ÒÒ2 E
;
ÒÒE F
[
ÓÓ 	
Obsolete
ÓÓ	 
(
ÓÓ 
$str
ÓÓ ;
)
ÓÓ; <
]
ÓÓ< =
internal
ÔÔ 
const
ÔÔ 
string
ÔÔ 
pbBevelAmount
ÔÔ +
=
ÔÔ, -
$str
ÔÔ. =
;
ÔÔ= >
[
ÕÕ 	
Obsolete
ÕÕ	 
(
ÕÕ 
$str
ÕÕ ;
)
ÕÕ; <
]
ÕÕ< =
internal
ÖÖ 
const
ÖÖ 
string
ÖÖ  
pbEdgeSubdivisions
ÖÖ 0
=
ÖÖ1 2
$str
ÖÖ3 G
;
ÖÖG H
[
×× 	
Obsolete
××	 
(
×× 
$str
×× ;
)
××; <
]
××< =
internal
ØØ 
const
ØØ 
string
ØØ  
pbDefaultShortcuts
ØØ 0
=
ØØ1 2
$str
ØØ3 G
;
ØØG H
[
ÙÙ 	
Obsolete
ÙÙ	 
(
ÙÙ 
$str
ÙÙ ;
)
ÙÙ; <
]
ÙÙ< =
internal
ÚÚ 
const
ÚÚ 
string
ÚÚ 
pbDefaultMaterial
ÚÚ /
=
ÚÚ0 1
$str
ÚÚ2 E
;
ÚÚE F
[
ÛÛ 	
Obsolete
ÛÛ	 
(
ÛÛ 
$str
ÛÛ ;
)
ÛÛ; <
]
ÛÛ< =
internal
ÜÜ 
const
ÜÜ 
string
ÜÜ &
pbCurrentMaterialPalette
ÜÜ 6
=
ÜÜ7 8
$str
ÜÜ9 S
;
ÜÜS T
[
İİ 	
Obsolete
İİ	 
(
İİ 
$str
İİ ;
)
İİ; <
]
İİ< =
internal
ŞŞ 
const
ŞŞ 
string
ŞŞ '
pbGrowSelectionUsingAngle
ŞŞ 7
=
ŞŞ8 9
$str
ŞŞ: U
;
ŞŞU V
[
ßß 	
Obsolete
ßß	 
(
ßß 
$str
ßß ;
)
ßß; <
]
ßß< =
internal
àà 
const
àà 
string
àà "
pbGrowSelectionAngle
àà 2
=
àà3 4
$str
àà5 K
;
ààK L
[
áá 	
Obsolete
áá	 
(
áá 
$str
áá ;
)
áá; <
]
áá< =
internal
ââ 
const
ââ 
string
ââ +
pbGrowSelectionAngleIterative
ââ ;
=
ââ< =
$str
ââ> ]
;
ââ] ^
[
ãã 	
Obsolete
ãã	 
(
ãã 
$str
ãã ;
)
ãã; <
]
ãã< =
internal
ää 
const
ää 
string
ää 
pbShowDetail
ää *
=
ää+ ,
$str
ää- ;
;
ää; <
[
åå 	
Obsolete
åå	 
(
åå 
$str
åå ;
)
åå; <
]
åå< =
internal
ææ 
const
ææ 
string
ææ 
pbShowOccluder
ææ ,
=
ææ- .
$str
ææ/ ?
;
ææ? @
[
çç 	
Obsolete
çç	 
(
çç 
$str
çç ;
)
çç; <
]
çç< =
internal
èè 
const
èè 
string
èè 
pbShowMover
èè )
=
èè* +
$str
èè, 9
;
èè9 :
[
éé 	
Obsolete
éé	 
(
éé 
$str
éé ;
)
éé; <
]
éé< =
internal
êê 
const
êê 
string
êê 
pbShowCollider
êê ,
=
êê- .
$str
êê/ ?
;
êê? @
[
ëë 	
Obsolete
ëë	 
(
ëë 
$str
ëë ;
)
ëë; <
]
ëë< =
internal
ìì 
const
ìì 
string
ìì 
pbShowTrigger
ìì +
=
ìì, -
$str
ìì. =
;
ìì= >
[
íí 	
Obsolete
íí	 
(
íí 
$str
íí ;
)
íí; <
]
íí< =
internal
îî 
const
îî 
string
îî 
pbShowNoDraw
îî *
=
îî+ ,
$str
îî- ;
;
îî; <
[
ïï 	
Obsolete
ïï	 
(
ïï 
$str
ïï ;
)
ïï; <
]
ïï< =
internal
ğğ 
const
ğğ 
string
ğğ %
defaultUnwrapParameters
ğğ 5
=
ğğ6 7
$str
ğğ8 S
;
ğğS T
}
ññ 
}òò „	
“D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ProGridsIgnoreSnap.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[ 
AttributeUsage 
( 
AttributeTargets $
.$ %
Class% *
,* +
AllowMultiple, 9
=: ;
false< A
,A B
	InheritedC L
=M N
trueO S
)S T
]T U
sealed 

class #
ProGridsNoSnapAttribute (
:) *
	Attribute+ 4
{ 
} 
[ 
AttributeUsage 
( 
AttributeTargets $
.$ %
Class% *
,* +
AllowMultiple, 9
=: ;
false< A
,A B
	InheritedC L
=M N
trueO S
)S T
]T U
sealed 

class ,
 ProGridsConditionalSnapAttribute 1
:2 3
	Attribute4 =
{ 
} 
} ó?
D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\ProBuilderEnum.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
[

 
System

 
.

 
Flags

 
]

 
public 

enum 

SelectMode 
{ 
None 
= 
$num 
<< 
$num 
, 
Object 
= 
$num 
<< 
$num 
, 
Vertex 
= 
$num 
<< 
$num 
, 
Edge 
= 
$num 
<< 
$num 
, 
Face$$ 
=$$ 
$num$$ 
<<$$ 
$num$$ 
,$$ 
TextureFace)) 
=)) 
$num)) 
<<)) 
$num)) 
,)) 
TextureEdge.. 
=.. 
$num.. 
<<.. 
$num.. 
,.. 
TextureVertex33 
=33 
$num33 
<<33 
$num33 
,33 
	InputTool88 
=88 
$num88 
<<88 
$num88 
,88 
Any== 
=== 
$num== 
}>> 
enumCC 
ComponentModeCC	 
{DD 
VertexHH 
=HH 
$numHH 
,HH 
EdgeLL 
=LL 
$numLL 
,LL 
FacePP 
=PP 
$numPP 
}QQ 
internalVV 
enumVV 
	EditLevelVV 
{WW 
Top[[ 
=[[ 
$num[[ 
,[[ 
Geometry__ 
=__ 
$num__ 
,__ 
Texturecc 
=cc 
$numcc 
,cc 
Plugingg 
=gg 
$numgg 
}hh 
enummm 

EntityTypemm	 
{nn 
Detailoo 
,oo 
Occluderpp 
,pp 
Triggerqq 
,qq 
Colliderrr 
,rr 
Moverss 
}tt 
enumvv 
ColliderTypevv	 
{ww 
Nonexx 
,xx 
BoxCollideryy 
,yy 
MeshColliderzz 
}{{ 
public
€€ 

enum
€€ 
ProjectionAxis
€€ 
{
 
X
…… 	
,
……	 

Y
‰‰ 	
,
‰‰	 

Z
 	
,
	 

	XNegative
‘‘ 
,
‘‘ 
	YNegative
•• 
,
•• 
	ZNegative
™™ 
}
šš 
enum
œœ 

HandleAxis
œœ	 
{
 
X
 	
=

 
$num
 
<<
 
$num
 
,
 
Y
ŸŸ 	
=
ŸŸ
 
$num
ŸŸ 
<<
ŸŸ 
$num
ŸŸ 
,
ŸŸ 
Z
   	
=
  
 
$num
   
<<
   
$num
   
,
   
Free
¡¡ 
=
¡¡ 
$num
¡¡ 
<<
¡¡ 
$num
¡¡ 
}
¢¢ 
[
§§ 
System
§§ 
.
§§ 
Obsolete
§§ 
(
§§ 
$str
§§ '
)
§§' (
]
§§( )
enum
¨¨ 
Shape
¨¨	 
{
©© 
Cube
ªª 
,
ªª 
Stair
«« 
,
«« 
Prism
¬¬ 
,
¬¬ 
Cylinder
­­ 
,
­­ 
Plane
®® 
,
®® 
Door
¯¯ 
,
¯¯ 
Pipe
°° 
,
°° 
Cone
±± 
,
±± 
Sprite
²² 
,
²² 
Arch
³³ 
,
³³ 
Icosahedron
´´ 
,
´´ 
Torus
µµ 
,
µµ 
Custom
¶¶ 
}
·· 
public
¼¼ 

enum
¼¼ 
Axis
¼¼ 
{
½½ 
Right
ÁÁ 
,
ÁÁ 
Left
ÅÅ 
,
ÅÅ 
Up
ÉÉ 

,
ÉÉ
 
Down
ÍÍ 
,
ÍÍ 
Forward
ÑÑ 
,
ÑÑ 
Backward
ÕÕ 
}
ÖÖ 
public
ÛÛ 

enum
ÛÛ 
WindingOrder
ÛÛ 
{
ÜÜ 
Unknown
àà 
,
àà 
	Clockwise
ää 
,
ää 
CounterClockwise
èè 
}
éé 
public
îî 

enum
îî 

SortMethod
îî 
{
ïï 
	Clockwise
óó 
,
óó 
CounterClockwise
÷÷ 
}
øø 
;
øø 
[
ıı 
System
ıı 
.
ıı 
Flags
ıı 
]
ıı 
public
şş 

enum
şş 
CullingMode
şş 
{
ÿÿ 
None
ƒƒ 
=
ƒƒ 
$num
ƒƒ 
<<
ƒƒ 
$num
ƒƒ 
,
ƒƒ 
Back
‡‡ 
=
‡‡ 
$num
‡‡ 
<<
‡‡ 
$num
‡‡ 
,
‡‡ 
Front
‹‹ 
=
‹‹ 
$num
‹‹ 
<<
‹‹ 
$num
‹‹ 
,
‹‹ 
	FrontBack
 
=
 
Front
 
|
 
Back
  
,
  !
}
 
public
•• 

enum
•• 
RectSelectMode
•• 
{
–– 
Partial
šš 
,
šš 
Complete
 
}
ŸŸ 
public
¤¤ 

enum
¤¤ 
MeshSyncState
¤¤ 
{
¥¥ 
Null
©© 
,
©©  
InstanceIDMismatch
®® 
,
®® 
Lightmap
³³ 
,
³³ 
InSync
·· 
}
¸¸ 
[
½½ 
System
½½ 
.
½½ 
Flags
½½ 
]
½½ 
public
¾¾ 

enum
¾¾ 

MeshArrays
¾¾ 
{
¿¿ 
Position
ÃÃ 
=
ÃÃ 
$num
ÃÃ 
,
ÃÃ 
Texture0
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
,
ÇÇ 
Texture1
ËË 
=
ËË 
$num
ËË 
,
ËË 
Lightmap
ÏÏ 
=
ÏÏ 
$num
ÏÏ 
,
ÏÏ 
Texture2
ÓÓ 
=
ÓÓ 
$num
ÓÓ 
,
ÓÓ 
Texture3
×× 
=
×× 
$num
×× 
,
×× 
Color
ÛÛ 
=
ÛÛ 
$num
ÛÛ 
,
ÛÛ 
Normal
ßß 
=
ßß 
$num
ßß 
,
ßß 
Tangent
ãã 
=
ãã 
$num
ãã 
,
ãã 
All
çç 
=
çç 
$num
çç 
}
èè 
;
èè 
enum
êê 
IndexFormat
êê	 
{
ëë 
Local
ìì 
=
ìì 
$num
ìì 
,
ìì 
Common
íí 
=
íí 
$num
íí 
,
íí 
Both
îî 
=
îî 
$num
îî 
}
ïï 
;
ïï 
[
õõ 
System
õõ 
.
õõ 
Flags
õõ 
]
õõ 
public
öö 

enum
öö 
RefreshMask
öö 
{
÷÷ 
UV
ûû 

=
ûû 
$num
ûû 
,
ûû 
Colors
ÿÿ 
=
ÿÿ 
$num
ÿÿ 
,
ÿÿ 
Normals
ƒƒ 
=
ƒƒ 
$num
ƒƒ 
,
ƒƒ 
Tangents
‡‡ 
=
‡‡ 
$num
‡‡ 
,
‡‡ 

Collisions
‹‹ 
=
‹‹ 
$num
‹‹ 
,
‹‹ 
All
 
=
 
UV
 
|
 
Colors
 
|
 
Normals
 #
|
$ %
Tangents
& .
|
/ 0

Collisions
1 ;
}
 
;
 
public
•• 

enum
•• 
ExtrudeMethod
•• 
{
–– 
IndividualFaces
šš 
=
šš 
$num
šš 
,
šš 
VertexNormal
 
=
 
$num
 
,
 

FaceNormal
¢¢ 
=
¢¢ 
$num
¢¢ 
}
££ 
}¤¤ ĞT
˜D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\MergeElements.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
static 

class 
MergeElements 
{ 
public 
static 
List 
< 
Face 
>  

MergePairs! +
(+ ,
ProBuilderMesh, :
target; A
,A B
IEnumerableC N
<N O
SimpleTupleO Z
<Z [
Face[ _
,_ `
Facea e
>e f
>f g
pairsh m
,m n
boolo s'
collapseCoincidentVertices	t 
=
 
true
‘ •
)
• –
{ 	
HashSet 
< 
Face 
> 
remove  
=! "
new# &
HashSet' .
<. /
Face/ 3
>3 4
(4 5
)5 6
;6 7
List 
< 
Face 
> 
add 
= 
new  
List! %
<% &
Face& *
>* +
(+ ,
), -
;- .
foreach 
( 
SimpleTuple  
<  !
Face! %
,% &
Face' +
>+ ,
pair- 1
in2 4
pairs5 :
): ;
{ 
Face 
left 
= 
pair  
.  !
item1! &
;& '
Face 
right 
= 
pair !
.! "
item2" '
;' (
int 

leftLength 
=  
left! %
.% &
indexesInternal& 5
.5 6
Length6 <
;< =
int 
rightLength 
=  !
right" '
.' (
indexesInternal( 7
.7 8
Length8 >
;> ?
int 
[ 
] 
indexes 
= 
new  #
int$ '
[' (

leftLength( 2
+3 4
rightLength5 @
]@ A
;A B
System   
.   
Array   
.   
Copy   !
(  ! "
left  " &
.  & '
indexesInternal  ' 6
,  6 7
$num  8 9
,  9 :
indexes  ; B
,  B C
$num  D E
,  E F

leftLength  G Q
)  Q R
;  R S
System!! 
.!! 
Array!! 
.!! 
Copy!! !
(!!! "
right!!" '
.!!' (
indexesInternal!!( 7
,!!7 8
$num!!9 :
,!!: ;
indexes!!< C
,!!C D

leftLength!!E O
,!!O P
rightLength!!Q \
)!!\ ]
;!!] ^
add"" 
."" 
Add"" 
("" 
new"" 
Face""  
(""  !
indexes""! (
,""( )
left## 
.## 
submeshIndex## )
,##) *
left$$ 
.$$ 
uv$$ 
,$$  
left%% 
.%% 
smoothingGroup%% +
,%%+ ,
left&& 
.&& 
textureGroup&& )
,&&) *
left'' 
.'' 
elementGroup'' )
,'') *
left(( 
.(( 
manualUV(( %
)((% &
)((& '
;((' (
remove)) 
.)) 
Add)) 
()) 
left)) 
)))  
;))  !
remove** 
.** 
Add** 
(** 
right**  
)**  !
;**! "
}++ 
List-- 
<-- 
Face-- 
>-- 
faces-- 
=-- 
target-- %
.--% &
facesInternal--& 3
.--3 4
Where--4 9
(--9 :
x--: ;
=>--< >
!--? @
remove--@ F
.--F G
Contains--G O
(--O P
x--P Q
)--Q R
)--R S
.--S T
ToList--T Z
(--Z [
)--[ \
;--\ ]
faces.. 
... 
AddRange.. 
(.. 
add.. 
).. 
;..  
target// 
.// 
faces// 
=// 
faces//  
;//  !
if11 
(11 &
collapseCoincidentVertices11 *
)11* +&
CollapseCoincidentVertices22 *
(22* +
target22+ 1
,221 2
add223 6
)226 7
;227 8
return44 
add44 
;44 
}55 	
publicAA 
staticAA 
FaceAA 
MergeAA  
(AA  !
ProBuilderMeshAA! /
targetAA0 6
,AA6 7
IEnumerableAA8 C
<AAC D
FaceAAD H
>AAH I
facesAAJ O
)AAO P
{BB 	
intCC 
mergedCountCC 
=CC 
facesCC #
!=CC$ &
nullCC' +
?CC, -
facesCC. 3
.CC3 4
CountCC4 9
(CC9 :
)CC: ;
:CC< =
$numCC> ?
;CC? @
ifEE 
(EE 
mergedCountEE 
<EE 
$numEE 
)EE  
returnFF 
nullFF 
;FF 
FaceHH 
firstHH 
=HH 
facesHH 
.HH 
FirstHH $
(HH$ %
)HH% &
;HH& '
FaceJJ 

mergedFaceJJ 
=JJ 
newJJ !
FaceJJ" &
(JJ& '
facesJJ' ,
.JJ, -

SelectManyJJ- 7
(JJ7 8
xJJ8 9
=>JJ: <
xJJ= >
.JJ> ?
indexesInternalJJ? N
)JJN O
.JJO P
ToArrayJJP W
(JJW X
)JJX Y
,JJY Z
firstKK 
.KK 
submeshIndexKK &
,KK& '
firstLL 
.LL 
uvLL 
,LL 
firstMM 
.MM 
smoothingGroupMM (
,MM( )
firstNN 
.NN 
textureGroupNN &
,NN& '
firstOO 
.OO 
elementGroupOO &
,OO& '
firstPP 
.PP 
manualUVPP "
)PP" #
;PP# $
FaceRR 
[RR 
]RR 
rebuiltFacesRR 
=RR  !
newRR" %
FaceRR& *
[RR* +
targetRR+ 1
.RR1 2
facesInternalRR2 ?
.RR? @
LengthRR@ F
-RRG H
mergedCountRRI T
+RRU V
$numRRW X
]RRX Y
;RRY Z
intTT 
nTT 
=TT 
$numTT 
;TT 
HashSetVV 
<VV 
FaceVV 
>VV 
skipVV 
=VV  
newVV! $
HashSetVV% ,
<VV, -
FaceVV- 1
>VV1 2
(VV2 3
facesVV3 8
)VV8 9
;VV9 :
foreachXX 
(XX 
FaceXX 
fXX 
inXX 
targetXX %
.XX% &
facesInternalXX& 3
)XX3 4
{YY 
ifZZ 
(ZZ 
!ZZ 
skipZZ 
.ZZ 
ContainsZZ "
(ZZ" #
fZZ# $
)ZZ$ %
)ZZ% &
rebuiltFaces[[  
[[[  !
n[[! "
++[[" $
][[$ %
=[[& '
f[[( )
;[[) *
}\\ 
rebuiltFaces^^ 
[^^ 
n^^ 
]^^ 
=^^ 

mergedFace^^ (
;^^( )
target`` 
.`` 
faces`` 
=`` 
rebuiltFaces`` '
;``' (&
CollapseCoincidentVerticesbb &
(bb& '
targetbb' -
,bb- .
newbb/ 2
Facebb3 7
[bb7 8
]bb8 9
{bb: ;

mergedFacebb< F
}bbG H
)bbH I
;bbI J
returndd 

mergedFacedd 
;dd 
}ee 	
internalmm 
staticmm 
voidmm &
CollapseCoincidentVerticesmm 7
(mm7 8
ProBuilderMeshmm8 F
meshmmG K
,mmK L
IEnumerablemmM X
<mmX Y
FacemmY ]
>mm] ^
facesmm_ d
)mmd e
{nn 	

Dictionaryoo 
<oo 
intoo 
,oo 
intoo 
>oo  
lookupoo! '
=oo( )
meshoo* .
.oo. /
sharedVertexLookupoo/ A
;ooA B

Dictionarypp 
<pp 
intpp 
,pp 
intpp 
>pp  
matchespp! (
=pp) *
newpp+ .

Dictionarypp/ 9
<pp9 :
intpp: =
,pp= >
intpp? B
>ppB C
(ppC D
)ppD E
;ppE F
foreachrr 
(rr 
Facerr 
facerr 
inrr !
facesrr" '
)rr' (
{ss 
matchestt 
.tt 
Cleartt 
(tt 
)tt 
;tt  
forvv 
(vv 
intvv 
ivv 
=vv 
$numvv 
;vv 
ivv  !
<vv" #
facevv$ (
.vv( )
indexesInternalvv) 8
.vv8 9
Lengthvv9 ?
;vv? @
ivvA B
++vvB D
)vvD E
{ww 
intxx 
commonxx 
=xx  
lookupxx! '
[xx' (
facexx( ,
.xx, -
indexesInternalxx- <
[xx< =
ixx= >
]xx> ?
]xx? @
;xx@ A
ifzz 
(zz 
matcheszz 
.zz  
ContainsKeyzz  +
(zz+ ,
commonzz, 2
)zz2 3
)zz3 4
face{{ 
.{{ 
indexesInternal{{ ,
[{{, -
i{{- .
]{{. /
={{0 1
matches{{2 9
[{{9 :
common{{: @
]{{@ A
;{{A B
else|| 
matches}} 
.}}  
Add}}  #
(}}# $
common}}$ *
,}}* +
face}}, 0
.}}0 1
indexesInternal}}1 @
[}}@ A
i}}A B
]}}B C
)}}C D
;}}D E
}~~ 
face
€€ 
.
€€ 
InvalidateCache
€€ $
(
€€$ %
)
€€% &
;
€€& '
}
 
MeshValidation
ƒƒ 
.
ƒƒ "
RemoveUnusedVertices
ƒƒ /
(
ƒƒ/ 0
mesh
ƒƒ0 4
)
ƒƒ4 5
;
ƒƒ5 6
}
„„ 	
}
…… 
}†† ©
—D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\AssemblyInfo.cs
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> W
)W X
]X Y
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> V
)V W
]W X
[ 
assembly 	
:	 

System 
. 
Runtime 
. 
CompilerServices *
.* +
InternalsVisibleTo+ =
(= >
$str> ]
)] ^
]^ _ªâ
™D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\AppendElements.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{		 
public 

static 
class 
AppendElements &
{ 
internal 
static 
Face 

AppendFace '
(' (
this( ,
ProBuilderMesh- ;
mesh< @
,@ A
Vector3B I
[I J
]J K
	positionsL U
,U V
ColorW \
[\ ]
]] ^
colors_ e
,e f
Vector2g n
[n o
]o p
uvsq t
,t u
Facev z
face{ 
,	 €
int
 „
[
„ …
]
… †
common
‡ 
)
 
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new !
ArgumentNullException /
(/ 0
$str0 6
)6 7
;7 8
if 
( 
	positions 
== 
null !
)! "
throw 
new !
ArgumentNullException /
(/ 0
$str0 ;
); <
;< =
if!! 
(!! 
face!! 
==!! 
null!! 
)!! 
throw"" 
new"" !
ArgumentNullException"" /
(""/ 0
$str""0 6
)""6 7
;""7 8
int$$ 
faceVertexCount$$ 
=$$  !
	positions$$" +
.$$+ ,
Length$$, 2
;$$2 3
if&& 
(&& 
common&& 
==&& 
null&& 
)&& 
{'' 
common(( 
=(( 
new(( 
int((  
[((  !
faceVertexCount((! 0
]((0 1
;((1 2
for)) 
()) 
int)) 
i)) 
=)) 
$num)) 
;)) 
i))  !
<))" #
faceVertexCount))$ 3
;))3 4
i))5 6
++))6 8
)))8 9
common** 
[** 
i** 
]** 
=** 
-**  !
$num**! "
;**" #
}++ 
int-- 
vertexCount-- 
=-- 
mesh-- "
.--" #
vertexCount--# .
;--. /
var// 
mc// 
=// 
mesh// 
.// 
	HasArrays// #
(//# $

MeshArrays//$ .
.//. /
Color/// 4
)//4 5
;//5 6
var00 
fc00 
=00 
colors00 
!=00 
null00 #
;00# $
var11 
mt11 
=11 
mesh11 
.11 
	HasArrays11 #
(11# $

MeshArrays11$ .
.11. /
Texture011/ 7
)117 8
;118 9
var22 
ft22 
=22 
uvs22 
!=22 
null22  
;22  !
Vector344 
[44 
]44 
newPositions44 "
=44# $
new44% (
Vector344) 0
[440 1
vertexCount441 <
+44= >
faceVertexCount44? N
]44N O
;44O P
Color55 
[55 
]55 
	newColors55 
=55 
(55  !
mc55! #
||55$ &
fc55' )
)55) *
?55+ ,
new55- 0
Color551 6
[556 7
vertexCount557 B
+55C D
faceVertexCount55E T
]55T U
:55V W
null55X \
;55\ ]
Vector266 
[66 
]66 
newTextures66 !
=66" #
(66$ %
mt66% '
||66( *
ft66+ -
)66- .
?66/ 0
new661 4
Vector2665 <
[66< =
vertexCount66= H
+66I J
faceVertexCount66K Z
]66Z [
:66\ ]
null66^ b
;66b c
List88 
<88 
Face88 
>88 
faces88 
=88 
new88 "
List88# '
<88' (
Face88( ,
>88, -
(88- .
mesh88. 2
.882 3
facesInternal883 @
)88@ A
;88A B
Array99 
.99 
Copy99 
(99 
mesh99 
.99 
positionsInternal99 -
,99- .
$num99/ 0
,990 1
newPositions992 >
,99> ?
$num99@ A
,99A B
vertexCount99C N
)99N O
;99O P
Array:: 
.:: 
Copy:: 
(:: 
	positions::  
,::  !
$num::" #
,::# $
newPositions::% 1
,::1 2
vertexCount::3 >
,::> ?
faceVertexCount::@ O
)::O P
;::P Q
if<< 
(<< 
mc<< 
||<< 
fc<< 
)<< 
{== 
Array>> 
.>> 
Copy>> 
(>> 
mc>> 
?>> 
mesh>>  $
.>>$ %
colorsInternal>>% 3
:>>4 5
ArrayUtility>>6 B
.>>B C
Fill>>C G
(>>G H
Color>>H M
.>>M N
white>>N S
,>>S T
vertexCount>>U `
)>>` a
,>>a b
$num>>c d
,>>d e
	newColors>>f o
,>>o p
$num>>q r
,>>r s
vertexCount>>t 
)	>> €
;
>>€ 
Array?? 
.?? 
Copy?? 
(?? 
fc?? 
??? 
colors??  &
:??' (
ArrayUtility??) 5
.??5 6
Fill??6 :
(??: ;
Color??; @
.??@ A
white??A F
,??F G
faceVertexCount??H W
)??W X
,??X Y
$num??Z [
,??[ \
	newColors??] f
,??f g
vertexCount??h s
,??s t
colors??u {
.??{ |
Length	??| ‚
)
??‚ ƒ
;
??ƒ „
}@@ 
ifBB 
(BB 
mtBB 
||BB 
ftBB 
)BB 
{CC 
ArrayDD 
.DD 
CopyDD 
(DD 
mtDD 
?DD 
meshDD  $
.DD$ %
texturesInternalDD% 5
:DD6 7
ArrayUtilityDD8 D
.DDD E
FillDDE I
(DDI J
Vector2DDJ Q
.DDQ R
zeroDDR V
,DDV W
vertexCountDDX c
)DDc d
,DDd e
$numDDf g
,DDg h
newTexturesDDi t
,DDt u
$numDDv w
,DDw x
vertexCount	DDy „
)
DD„ …
;
DD… †
ArrayEE 
.EE 
CopyEE 
(EE 
ftEE 
?EE 
uvsEE  #
:EE$ %
ArrayUtilityEE& 2
.EE2 3
FillEE3 7
(EE7 8
Vector2EE8 ?
.EE? @
zeroEE@ D
,EED E
faceVertexCountEEF U
)EEU V
,EEV W
$numEEX Y
,EEY Z
newTexturesEE[ f
,EEf g
meshEEh l
.EEl m
texturesInternalEEm }
.EE} ~
Length	EE~ „
,
EE„ …
faceVertexCount
EE† •
)
EE• –
;
EE– —
}FF 
faceHH 
.HH 
ShiftIndexesToZeroHH #
(HH# $
)HH$ %
;HH% &
faceII 
.II 
ShiftIndexesII 
(II 
vertexCountII )
)II) *
;II* +
facesKK 
.KK 
AddKK 
(KK 
faceKK 
)KK 
;KK 
forMM 
(MM 
intMM 
iMM 
=MM 
$numMM 
;MM 
iMM 
<MM 
commonMM  &
.MM& '
LengthMM' -
;MM- .
iMM/ 0
++MM0 2
)MM2 3
{NN 
ifOO 
(OO 
commonOO 
[OO 
iOO 
]OO 
<OO 
$numOO  !
)OO! "
meshPP 
.PP 
AddSharedVertexPP (
(PP( )
newPP) ,
SharedVertexPP- 9
(PP9 :
newPP: =
intPP> A
[PPA B
]PPB C
{PPD E
iPPF G
+PPH I
vertexCountPPJ U
}PPV W
)PPW X
)PPX Y
;PPY Z
elseQQ 
meshRR 
.RR 
AddToSharedVertexRR *
(RR* +
commonRR+ 1
[RR1 2
iRR2 3
]RR3 4
,RR4 5
iRR6 7
+RR8 9
vertexCountRR: E
)RRE F
;RRF G
}SS 
meshUU 
.UU 
	positionsUU 
=UU 
newPositionsUU )
;UU) *
meshVV 
.VV 
colorsVV 
=VV 
	newColorsVV #
;VV# $
meshWW 
.WW 
texturesWW 
=WW 
newTexturesWW '
;WW' (
meshXX 
.XX 
facesXX 
=XX 
facesXX 
;XX 
returnZZ 
faceZZ 
;ZZ 
}[[ 	
publicgg 
staticgg 
Facegg 
[gg 
]gg 
AppendFacesgg (
(gg( )
thishh 
ProBuilderMeshhh 
meshhh  $
,hh$ %
Vector3ii 
[ii 
]ii 
[ii 
]ii 
	positionsii !
,ii! "
Colorjj 
[jj 
]jj 
[jj 
]jj 
colorsjj 
,jj 
Vector2kk 
[kk 
]kk 
[kk 
]kk 
uvskk 
,kk 
Facell 
[ll 
]ll 
facesll 
,ll 
intmm 
[mm 
]mm 
[mm 
]mm 
sharedmm 
)mm 
{nn 	
ifoo 
(oo 
meshoo 
==oo 
nulloo 
)oo 
throwpp 
newpp !
ArgumentNullExceptionpp /
(pp/ 0
$strpp0 6
)pp6 7
;pp7 8
ifrr 
(rr 
	positionsrr 
==rr 
nullrr !
)rr! "
throwss 
newss !
ArgumentNullExceptionss /
(ss/ 0
$strss0 ;
)ss; <
;ss< =
ifuu 
(uu 
colorsuu 
==uu 
nulluu 
)uu 
throwvv 
newvv !
ArgumentNullExceptionvv /
(vv/ 0
$strvv0 8
)vv8 9
;vv9 :
ifxx 
(xx 
uvsxx 
==xx 
nullxx 
)xx 
throwyy 
newyy !
ArgumentNullExceptionyy /
(yy/ 0
$stryy0 5
)yy5 6
;yy6 7
if{{ 
({{ 
faces{{ 
=={{ 
null{{ 
){{ 
throw|| 
new|| !
ArgumentNullException|| /
(||/ 0
$str||0 7
)||7 8
;||8 9
var~~ 
newPositions~~ 
=~~ 
new~~ "
List~~# '
<~~' (
Vector3~~( /
>~~/ 0
(~~0 1
mesh~~1 5
.~~5 6
positionsInternal~~6 G
)~~G H
;~~H I
var 
	newColors 
= 
new 
List  $
<$ %
Color% *
>* +
(+ ,
mesh, 0
.0 1
colorsInternal1 ?
)? @
;@ A
var
€€ 
newTextures
€€ 
=
€€ 
new
€€ !
List
€€" &
<
€€& '
Vector2
€€' .
>
€€. /
(
€€/ 0
mesh
€€0 4
.
€€4 5
texturesInternal
€€5 E
)
€€E F
;
€€F G
var
 
newFaces
 
=
 
new
 
List
 #
<
# $
Face
$ (
>
( )
(
) *
mesh
* .
.
. /
facesInternal
/ <
)
< =
;
= >
var
‚‚ 
lookup
‚‚ 
=
‚‚ 
mesh
‚‚ 
.
‚‚  
sharedVertexLookup
‚‚ 0
;
‚‚0 1
int
„„ 
vc
„„ 
=
„„ 
mesh
„„ 
.
„„ 
vertexCount
„„ %
;
„„% &
for
†† 
(
†† 
int
†† 
i
†† 
=
†† 
$num
†† 
;
†† 
i
†† 
<
†† 
faces
††  %
.
††% &
Length
††& ,
;
††, -
i
††. /
++
††/ 1
)
††1 2
{
‡‡ 
newPositions
ˆˆ 
.
ˆˆ 
AddRange
ˆˆ %
(
ˆˆ% &
	positions
ˆˆ& /
[
ˆˆ/ 0
i
ˆˆ0 1
]
ˆˆ1 2
)
ˆˆ2 3
;
ˆˆ3 4
	newColors
‰‰ 
.
‰‰ 
AddRange
‰‰ "
(
‰‰" #
colors
‰‰# )
[
‰‰) *
i
‰‰* +
]
‰‰+ ,
)
‰‰, -
;
‰‰- .
newTextures
ŠŠ 
.
ŠŠ 
AddRange
ŠŠ $
(
ŠŠ$ %
uvs
ŠŠ% (
[
ŠŠ( )
i
ŠŠ) *
]
ŠŠ* +
)
ŠŠ+ ,
;
ŠŠ, -
faces
ŒŒ 
[
ŒŒ 
i
ŒŒ 
]
ŒŒ 
.
ŒŒ  
ShiftIndexesToZero
ŒŒ +
(
ŒŒ+ ,
)
ŒŒ, -
;
ŒŒ- .
faces
 
[
 
i
 
]
 
.
 
ShiftIndexes
 %
(
% &
vc
& (
)
( )
;
) *
newFaces
 
.
 
Add
 
(
 
faces
 "
[
" #
i
# $
]
$ %
)
% &
;
& '
if
 
(
 
shared
 
!=
 
null
 "
&&
# %
	positions
& /
[
/ 0
i
0 1
]
1 2
.
2 3
Length
3 9
!=
: <
shared
= C
[
C D
i
D E
]
E F
.
F G
Length
G M
)
M N
{
‘‘ 
Debug
’’ 
.
’’ 
LogError
’’ "
(
’’" #
$str
’’# m
)
’’m n
;
’’n o
return
““ 
null
““ 
;
““  
}
”” 
var
–– 
	hasCommon
–– 
=
–– 
shared
––  &
!=
––' )
null
––* .
;
––. /
for
˜˜ 
(
˜˜ 
int
˜˜ 
j
˜˜ 
=
˜˜ 
$num
˜˜ 
;
˜˜ 
j
˜˜  !
<
˜˜" #
shared
˜˜$ *
[
˜˜* +
i
˜˜+ ,
]
˜˜, -
.
˜˜- .
Length
˜˜. 4
;
˜˜4 5
j
˜˜6 7
++
˜˜7 9
)
˜˜9 :
lookup
™™ 
.
™™ 
Add
™™ 
(
™™ 
j
™™  
+
™™! "
vc
™™# %
,
™™% &
	hasCommon
™™' 0
?
™™1 2
shared
™™3 9
[
™™9 :
i
™™: ;
]
™™; <
[
™™< =
j
™™= >
]
™™> ?
:
™™@ A
-
™™B C
$num
™™C D
)
™™D E
;
™™E F
vc
›› 
=
›› 
newPositions
›› !
.
››! "
Count
››" '
;
››' (
}
œœ 
mesh
 
.
 
	positions
 
=
 
newPositions
 )
;
) *
mesh
ŸŸ 
.
ŸŸ 
colors
ŸŸ 
=
ŸŸ 
	newColors
ŸŸ #
;
ŸŸ# $
mesh
   
.
   
textures
   
=
   
newTextures
   '
;
  ' (
mesh
¡¡ 
.
¡¡ 
faces
¡¡ 
=
¡¡ 
newFaces
¡¡ !
;
¡¡! "
mesh
¢¢ 
.
¢¢ 
SetSharedVertices
¢¢ "
(
¢¢" #
lookup
¢¢# )
)
¢¢) *
;
¢¢* +
return
¤¤ 
faces
¤¤ 
;
¤¤ 
}
¥¥ 	
public
®® 
static
®® 
Face
®® 
CreatePolygon
®® (
(
®®( )
this
®®) -
ProBuilderMesh
®®. <
mesh
®®= A
,
®®A B
IList
®®C H
<
®®H I
int
®®I L
>
®®L M
indexes
®®N U
,
®®U V
bool
®®W [
	unordered
®®\ e
)
®®e f
{
¯¯ 	
if
°° 
(
°° 
mesh
°° 
==
°° 
null
°° 
)
°° 
throw
±± 
new
±± #
ArgumentNullException
±± /
(
±±/ 0
$str
±±0 6
)
±±6 7
;
±±7 8
SharedVertex
³³ 
[
³³ 
]
³³ 
sharedIndexes
³³ (
=
³³) *
mesh
³³+ /
.
³³/ 0$
sharedVerticesInternal
³³0 F
;
³³F G

Dictionary
´´ 
<
´´ 
int
´´ 
,
´´ 
int
´´ 
>
´´  
lookup
´´! '
=
´´( )
mesh
´´* .
.
´´. / 
sharedVertexLookup
´´/ A
;
´´A B
HashSet
µµ 
<
µµ 
int
µµ 
>
µµ 
common
µµ 
=
µµ  !
mesh
µµ" &
.
µµ& '$
GetSharedVertexHandles
µµ' =
(
µµ= >
indexes
µµ> E
)
µµE F
;
µµF G
List
¶¶ 
<
¶¶ 
Vertex
¶¶ 
>
¶¶ 
vertices
¶¶ !
=
¶¶" #
new
¶¶$ '
List
¶¶( ,
<
¶¶, -
Vertex
¶¶- 3
>
¶¶3 4
(
¶¶4 5
mesh
¶¶5 9
.
¶¶9 :
GetVertices
¶¶: E
(
¶¶E F
)
¶¶F G
)
¶¶G H
;
¶¶H I
List
·· 
<
·· 
Vertex
·· 
>
·· 
appendVertices
·· '
=
··( )
new
··* -
List
··. 2
<
··2 3
Vertex
··3 9
>
··9 :
(
··: ;
)
··; <
;
··< =
foreach
¹¹ 
(
¹¹ 
int
¹¹ 
i
¹¹ 
in
¹¹ 
common
¹¹ $
)
¹¹$ %
{
ºº 
int
»» 
index
»» 
=
»» 
sharedIndexes
»» )
[
»») *
i
»»* +
]
»»+ ,
[
»», -
$num
»»- .
]
»». /
;
»»/ 0
appendVertices
¼¼ 
.
¼¼ 
Add
¼¼ "
(
¼¼" #
new
¼¼# &
Vertex
¼¼' -
(
¼¼- .
vertices
¼¼. 6
[
¼¼6 7
index
¼¼7 <
]
¼¼< =
)
¼¼= >
)
¼¼> ?
;
¼¼? @
}
½½ 
FaceRebuildData
¿¿ 
data
¿¿  
=
¿¿! "
FaceWithVertices
¿¿# 3
(
¿¿3 4
appendVertices
¿¿4 B
,
¿¿B C
	unordered
¿¿D M
)
¿¿M N
;
¿¿N O
if
ÁÁ 
(
ÁÁ 
data
ÁÁ 
!=
ÁÁ 
null
ÁÁ 
)
ÁÁ 
{
ÂÂ 
data
ÃÃ 
.
ÃÃ 
sharedIndexes
ÃÃ "
=
ÃÃ# $
common
ÃÃ% +
.
ÃÃ+ ,
ToList
ÃÃ, 2
(
ÃÃ2 3
)
ÃÃ3 4
;
ÃÃ4 5
List
ÄÄ 
<
ÄÄ 
Face
ÄÄ 
>
ÄÄ 
faces
ÄÄ  
=
ÄÄ! "
new
ÄÄ# &
List
ÄÄ' +
<
ÄÄ+ ,
Face
ÄÄ, 0
>
ÄÄ0 1
(
ÄÄ1 2
mesh
ÄÄ2 6
.
ÄÄ6 7
facesInternal
ÄÄ7 D
)
ÄÄD E
;
ÄÄE F
FaceRebuildData
ÅÅ 
.
ÅÅ  
Apply
ÅÅ  %
(
ÅÅ% &
new
ÅÅ& )
FaceRebuildData
ÅÅ* 9
[
ÅÅ9 :
]
ÅÅ: ;
{
ÅÅ< =
data
ÅÅ> B
}
ÅÅC D
,
ÅÅD E
vertices
ÅÅF N
,
ÅÅN O
faces
ÅÅP U
,
ÅÅU V
lookup
ÅÅW ]
,
ÅÅ] ^
null
ÅÅ_ c
)
ÅÅc d
;
ÅÅd e
mesh
ÆÆ 
.
ÆÆ 
SetVertices
ÆÆ  
(
ÆÆ  !
vertices
ÆÆ! )
)
ÆÆ) *
;
ÆÆ* +
mesh
ÇÇ 
.
ÇÇ 
faces
ÇÇ 
=
ÇÇ 
faces
ÇÇ "
;
ÇÇ" #
mesh
ÈÈ 
.
ÈÈ 
SetSharedVertices
ÈÈ &
(
ÈÈ& '
lookup
ÈÈ' -
)
ÈÈ- .
;
ÈÈ. /
return
ÊÊ 
data
ÊÊ 
.
ÊÊ 
face
ÊÊ  
;
ÊÊ  !
}
ËË 
const
ÍÍ 
string
ÍÍ  
insufficientPoints
ÍÍ +
=
ÍÍ, -
$str
ÍÍ. N
;
ÍÍN O
const
ÎÎ 
string
ÎÎ 

badWinding
ÎÎ #
=
ÎÎ$ %
$str
ÎÎ& D
;
ÎÎD E
Log
ĞĞ 
.
ĞĞ 
Info
ĞĞ 
(
ĞĞ 
	unordered
ĞĞ 
?
ĞĞ   
insufficientPoints
ĞĞ! 3
:
ĞĞ4 5

badWinding
ĞĞ6 @
)
ĞĞ@ A
;
ĞĞA B
return
ÒÒ 
null
ÒÒ 
;
ÒÒ 
}
ÓÓ 	
public
ÚÚ 
static
ÚÚ 
ActionResult
ÚÚ "$
CreateShapeFromPolygon
ÚÚ# 9
(
ÚÚ9 :
this
ÚÚ: >
	PolyShape
ÚÚ? H
poly
ÚÚI M
)
ÚÚM N
{
ÛÛ 	
return
ÜÜ 
poly
ÜÜ 
.
ÜÜ 
mesh
ÜÜ 
.
ÜÜ $
CreateShapeFromPolygon
ÜÜ 3
(
ÜÜ3 4
poly
ÜÜ4 8
.
ÜÜ8 9
m_Points
ÜÜ9 A
,
ÜÜA B
poly
ÜÜC G
.
ÜÜG H
extrude
ÜÜH O
,
ÜÜO P
poly
ÜÜQ U
.
ÜÜU V
flipNormals
ÜÜV a
)
ÜÜa b
;
ÜÜb c
}
İİ 	
internal
ãã 
static
ãã 
void
ãã !
ClearAndRefreshMesh
ãã 0
(
ãã0 1
this
ãã1 5
ProBuilderMesh
ãã6 D
mesh
ããE I
)
ããI J
{
ää 	
mesh
åå 
.
åå 
Clear
åå 
(
åå 
)
åå 
;
åå 
mesh
ææ 
.
ææ 
ToMesh
ææ 
(
ææ 
)
ææ 
;
ææ 
mesh
çç 
.
çç 
Refresh
çç 
(
çç 
)
çç 
;
çç 
}
èè 	
public
òò 
static
òò 
ActionResult
òò "$
CreateShapeFromPolygon
òò# 9
(
òò9 :
this
òò: >
ProBuilderMesh
òò? M
mesh
òòN R
,
òòR S
IList
òòT Y
<
òòY Z
Vector3
òòZ a
>
òòa b
points
òòc i
,
òòi j
float
òòk p
extrude
òòq x
,
òòx y
bool
òòz ~
flipNormalsòò Š
)òòŠ ‹
{
óó 	
return
ôô $
CreateShapeFromPolygon
ôô )
(
ôô) *
mesh
ôô* .
,
ôô. /
points
ôô0 6
,
ôô6 7
extrude
ôô8 ?
,
ôô? @
flipNormals
ôôA L
,
ôôL M
null
ôôN R
)
ôôR S
;
ôôS T
}
õõ 	
[
 	
Obsolete
	 
(
 
$str
 g
)
g h
]
h i
public
‚‚ 
static
‚‚ 
ActionResult
‚‚ "$
CreateShapeFromPolygon
‚‚# 9
(
‚‚9 :
this
‚‚: >
ProBuilderMesh
‚‚? M
mesh
‚‚N R
,
‚‚R S
IList
‚‚T Y
<
‚‚Y Z
Vector3
‚‚Z a
>
‚‚a b
points
‚‚c i
,
‚‚i j
float
‚‚k p
extrude
‚‚q x
,
‚‚x y
bool
‚‚z ~
flipNormals‚‚ Š
,‚‚Š ‹
Vector3‚‚Œ “
cameraLookAt‚‚”  
,‚‚  ¡
IList‚‚¢ §
<‚‚§ ¨
IList‚‚¨ ­
<‚‚­ ®
Vector3‚‚® µ
>‚‚µ ¶
>‚‚¶ ·

holePoints‚‚¸ Â
=‚‚Ã Ä
null‚‚Å É
)‚‚É Ê
{
ƒƒ 	
return
„„ $
CreateShapeFromPolygon
„„ )
(
„„) *
mesh
„„* .
,
„„. /
points
„„0 6
,
„„6 7
extrude
„„8 ?
,
„„? @
flipNormals
„„A L
,
„„L M
null
„„N R
)
„„R S
;
„„S T
}
…… 	
public
 
static
 
ActionResult
 "$
CreateShapeFromPolygon
# 9
(
9 :
this
: >
ProBuilderMesh
? M
mesh
N R
,
R S
IList
T Y
<
Y Z
Vector3
Z a
>
a b
points
c i
,
i j
float
k p
extrude
q x
,
x y
bool
z ~
flipNormals Š
,Š ‹
IListŒ ‘
<‘ ’
IList’ —
<— ˜
Vector3˜ Ÿ
>Ÿ  
>  ¡

holePoints¢ ¬
)¬ ­
{
‘‘ 	
if
’’ 
(
’’ 
mesh
’’ 
==
’’ 
null
’’ 
)
’’ 
throw
““ 
new
““ #
ArgumentNullException
““ /
(
““/ 0
$str
““0 6
)
““6 7
;
““7 8
if
•• 
(
•• 
points
•• 
==
•• 
null
•• 
||
•• !
points
••" (
.
••( )
Count
••) .
<
••/ 0
$num
••1 2
)
••2 3
{
–– !
ClearAndRefreshMesh
—— #
(
——# $
mesh
——$ (
)
——( )
;
——) *
return
˜˜ 
new
˜˜ 
ActionResult
˜˜ '
(
˜˜' (
ActionResult
˜˜( 4
.
˜˜4 5
Status
˜˜5 ;
.
˜˜; <
NoChange
˜˜< D
,
˜˜D E
$str
˜˜F V
)
˜˜V W
;
˜˜W X
}
™™ 
Vector3
›› 
[
›› 
]
›› 
vertices
›› 
=
››  
points
››! '
.
››' (
ToArray
››( /
(
››/ 0
)
››0 1
;
››1 2
Vector3
 
[
 
]
 
[
 
]
 
holeVertices
 $
=
% &
null
' +
;
+ ,
if
 
(
 

holePoints
 
!=
 
null
 "
&&
# %

holePoints
& 0
.
0 1
Count
1 6
>
7 8
$num
9 :
)
: ;
{
ŸŸ 
holeVertices
   
=
   
new
   "
Vector3
  # *
[
  * +

holePoints
  + 5
.
  5 6
Count
  6 ;
]
  ; <
[
  < =
]
  = >
;
  > ?
for
¡¡ 
(
¡¡ 
int
¡¡ 
i
¡¡ 
=
¡¡ 
$num
¡¡ 
;
¡¡ 
i
¡¡  !
<
¡¡" #

holePoints
¡¡$ .
.
¡¡. /
Count
¡¡/ 4
;
¡¡4 5
i
¡¡6 7
++
¡¡7 9
)
¡¡9 :
{
¢¢ 
if
££ 
(
££ 

holePoints
££ !
[
££! "
i
££" #
]
££# $
==
££% '
null
££( ,
||
££- /

holePoints
££0 :
[
££: ;
i
££; <
]
££< =
.
££= >
Count
££> C
<
££D E
$num
££F G
)
££G H
{
¤¤ !
ClearAndRefreshMesh
¥¥ +
(
¥¥+ ,
mesh
¥¥, 0
)
¥¥0 1
;
¥¥1 2
return
¦¦ 
new
¦¦ "
ActionResult
¦¦# /
(
¦¦/ 0
ActionResult
¦¦0 <
.
¦¦< =
Status
¦¦= C
.
¦¦C D
NoChange
¦¦D L
,
¦¦L M
$str
¦¦N g
+
¦¦h i
i
¦¦j k
)
¦¦k l
;
¦¦l m
}
§§ 
holeVertices
¨¨  
[
¨¨  !
i
¨¨! "
]
¨¨" #
=
¨¨$ %

holePoints
¨¨& 0
[
¨¨0 1
i
¨¨1 2
]
¨¨2 3
.
¨¨3 4
ToArray
¨¨4 ;
(
¨¨; <
)
¨¨< =
;
¨¨= >
}
©© 
}
ªª 
List
¬¬ 
<
¬¬ 
int
¬¬ 
>
¬¬ 
	triangles
¬¬ 
;
¬¬  
Log
®® 
.
®® 
PushLogLevel
®® 
(
®® 
LogLevel
®® %
.
®®% &
Error
®®& +
)
®®+ ,
;
®®, -
if
°° 
(
°° 
Triangulation
°° 
.
°° !
TriangulateVertices
°° 1
(
°°1 2
vertices
°°2 :
,
°°: ;
out
°°< ?
	triangles
°°@ I
,
°°I J
holeVertices
°°K W
)
°°W X
)
°°X Y
{
±± 
Vector3
²² 
[
²² 
]
²² 
combinedVertices
²² *
=
²²+ ,
null
²²- 1
;
²²1 2
if
³³ 
(
³³ 
holeVertices
³³  
!=
³³! #
null
³³$ (
)
³³( )
{
´´ 
combinedVertices
µµ $
=
µµ% &
new
µµ' *
Vector3
µµ+ 2
[
µµ2 3
vertices
µµ3 ;
.
µµ; <
Length
µµ< B
+
µµC D
holeVertices
µµE Q
.
µµQ R
Sum
µµR U
(
µµU V
arr
µµV Y
=>
µµZ \
arr
µµ] `
.
µµ` a
Length
µµa g
)
µµg h
]
µµh i
;
µµi j
Array
¶¶ 
.
¶¶ 
Copy
¶¶ 
(
¶¶ 
vertices
¶¶ '
,
¶¶' (
combinedVertices
¶¶) 9
,
¶¶9 :
vertices
¶¶; C
.
¶¶C D
Length
¶¶D J
)
¶¶J K
;
¶¶K L
int
·· 
destinationIndex
·· (
=
··) *
vertices
··+ 3
.
··3 4
Length
··4 :
;
··: ;
foreach
¸¸ 
(
¸¸ 
var
¸¸  
hole
¸¸! %
in
¸¸& (
holeVertices
¸¸) 5
)
¸¸5 6
{
¹¹ 
Array
ºº 
.
ºº 
ConstrainedCopy
ºº -
(
ºº- .
hole
ºº. 2
,
ºº2 3
$num
ºº4 5
,
ºº5 6
combinedVertices
ºº7 G
,
ººG H
destinationIndex
ººI Y
,
ººY Z
hole
ºº[ _
.
ºº_ `
Length
ºº` f
)
ººf g
;
ººg h
destinationIndex
»» (
+=
»») +
hole
»», 0
.
»»0 1
Length
»»1 7
;
»»7 8
}
¼¼ 
}
½½ 
else
¾¾ 
{
¿¿ 
combinedVertices
ÀÀ $
=
ÀÀ% &
vertices
ÀÀ' /
;
ÀÀ/ 0
}
ÁÁ 
int
ÂÂ 
[
ÂÂ 
]
ÂÂ 
indexes
ÂÂ 
=
ÂÂ 
	triangles
ÂÂ  )
.
ÂÂ) *
ToArray
ÂÂ* 1
(
ÂÂ1 2
)
ÂÂ2 3
;
ÂÂ3 4
if
ÄÄ 
(
ÄÄ 
Math
ÄÄ 
.
ÄÄ 
PolygonArea
ÄÄ $
(
ÄÄ$ %
combinedVertices
ÄÄ% 5
,
ÄÄ5 6
indexes
ÄÄ7 >
)
ÄÄ> ?
<
ÄÄ@ A
Mathf
ÄÄB G
.
ÄÄG H
Epsilon
ÄÄH O
)
ÄÄO P
{
ÅÅ !
ClearAndRefreshMesh
ÆÆ '
(
ÆÆ' (
mesh
ÆÆ( ,
)
ÆÆ, -
;
ÆÆ- .
Log
ÇÇ 
.
ÇÇ 
PopLogLevel
ÇÇ #
(
ÇÇ# $
)
ÇÇ$ %
;
ÇÇ% &
return
ÈÈ 
new
ÈÈ 
ActionResult
ÈÈ +
(
ÈÈ+ ,
ActionResult
ÈÈ, 8
.
ÈÈ8 9
Status
ÈÈ9 ?
.
ÈÈ? @
Failure
ÈÈ@ G
,
ÈÈG H
$str
ÈÈI a
)
ÈÈa b
;
ÈÈb c
}
ÉÉ 
mesh
ËË 
.
ËË 
Clear
ËË 
(
ËË 
)
ËË 
;
ËË 
mesh
ÍÍ 
.
ÍÍ 
positionsInternal
ÍÍ &
=
ÍÍ' (
combinedVertices
ÍÍ) 9
;
ÍÍ9 :
var
ÎÎ 
newFace
ÎÎ 
=
ÎÎ 
new
ÎÎ !
Face
ÎÎ" &
(
ÎÎ& '
indexes
ÎÎ' .
)
ÎÎ. /
;
ÎÎ/ 0
mesh
ÏÏ 
.
ÏÏ 
facesInternal
ÏÏ "
=
ÏÏ# $
new
ÏÏ% (
[
ÏÏ( )
]
ÏÏ) *
{
ÏÏ+ ,
newFace
ÏÏ- 4
}
ÏÏ5 6
;
ÏÏ6 7
mesh
ĞĞ 
.
ĞĞ $
sharedVerticesInternal
ĞĞ +
=
ĞĞ, -
SharedVertex
ĞĞ. :
.
ĞĞ: ;,
GetSharedVerticesWithPositions
ĞĞ; Y
(
ĞĞY Z
combinedVertices
ĞĞZ j
)
ĞĞj k
;
ĞĞk l
mesh
ÑÑ 
.
ÑÑ 
InvalidateCaches
ÑÑ %
(
ÑÑ% &
)
ÑÑ& '
;
ÑÑ' (
if
ÔÔ 
(
ÔÔ 
newFace
ÔÔ 
.
ÔÔ %
distinctIndexesInternal
ÔÔ 3
.
ÔÔ3 4
Length
ÔÔ4 :
!=
ÔÔ; =
combinedVertices
ÔÔ> N
.
ÔÔN O
Length
ÔÔO U
)
ÔÔU V
{
ÕÕ !
ClearAndRefreshMesh
ÖÖ '
(
ÖÖ' (
mesh
ÖÖ( ,
)
ÖÖ, -
;
ÖÖ- .
Log
×× 
.
×× 
PopLogLevel
×× #
(
××# $
)
××$ %
;
××% &
return
ØØ 
new
ØØ 
ActionResult
ØØ +
(
ØØ+ ,
ActionResult
ØØ, 8
.
ØØ8 9
Status
ØØ9 ?
.
ØØ? @
Failure
ØØ@ G
,
ØØG H
$str
ØØI g
)
ØØg h
;
ØØh i
}
ÙÙ 
Vector3
ÛÛ 
nrm
ÛÛ 
=
ÛÛ 
Math
ÛÛ "
.
ÛÛ" #
Normal
ÛÛ# )
(
ÛÛ) *
mesh
ÛÛ* .
,
ÛÛ. /
mesh
ÛÛ0 4
.
ÛÛ4 5
facesInternal
ÛÛ5 B
[
ÛÛB C
$num
ÛÛC D
]
ÛÛD E
)
ÛÛE F
;
ÛÛF G
nrm
ÜÜ 
=
ÜÜ 
mesh
ÜÜ 
.
ÜÜ 

gameObject
ÜÜ %
.
ÜÜ% &
	transform
ÜÜ& /
.
ÜÜ/ 0 
TransformDirection
ÜÜ0 B
(
ÜÜB C
nrm
ÜÜC F
)
ÜÜF G
;
ÜÜG H
if
İİ 
(
İİ 
(
İİ 
flipNormals
İİ  
?
İİ! "
Vector3
İİ# *
.
İİ* +
Dot
İİ+ .
(
İİ. /
mesh
İİ/ 3
.
İİ3 4

gameObject
İİ4 >
.
İİ> ?
	transform
İİ? H
.
İİH I
up
İİI K
,
İİK L
nrm
İİM P
)
İİP Q
>
İİR S
$num
İİT V
:
İİW X
Vector3
İİY `
.
İİ` a
Dot
İİa d
(
İİd e
mesh
İİe i
.
İİi j

gameObject
İİj t
.
İİt u
	transform
İİu ~
.
İİ~ 
upİİ 
,İİ ‚
nrmİİƒ †
)İİ† ‡
<İİˆ ‰
$numİİŠ Œ
)İİŒ 
)İİ 
{
ŞŞ 
mesh
ßß 
.
ßß 
facesInternal
ßß &
[
ßß& '
$num
ßß' (
]
ßß( )
.
ßß) *
Reverse
ßß* 1
(
ßß1 2
)
ßß2 3
;
ßß3 4
}
àà 
if
ââ 
(
ââ 
extrude
ââ 
!=
ââ 
$num
ââ #
)
ââ# $
{
ãã 
mesh
ää 
.
ää 
DuplicateAndFlip
ää )
(
ää) *
mesh
ää* .
.
ää. /
facesInternal
ää/ <
)
ää< =
;
ää= >
mesh
ææ 
.
ææ 
Extrude
ææ  
(
ææ  !
new
ææ! $
Face
ææ% )
[
ææ) *
]
ææ* +
{
ææ, -
(
ææ. /
flipNormals
ææ/ :
?
ææ; <
mesh
ææ= A
.
ææA B
facesInternal
ææB O
[
ææO P
$num
ææP Q
]
ææQ R
:
ææS T
mesh
ææU Y
.
ææY Z
facesInternal
ææZ g
[
ææg h
$num
ææh i
]
ææi j
)
ææj k
}
ææl m
,
ææm n
ExtrudeMethod
ææo |
.
ææ| }
IndividualFacesææ} Œ
,ææŒ 
extrudeææ •
)ææ• –
;ææ– —
if
èè 
(
èè 
(
èè 
extrude
èè  
<
èè! "
$num
èè# %
&&
èè& (
!
èè) *
flipNormals
èè* 5
)
èè5 6
||
èè7 9
(
èè: ;
extrude
èè; B
>
èèC D
$num
èèE G
&&
èèH J
flipNormals
èèK V
)
èèV W
)
èèW X
{
éé 
foreach
êê 
(
êê  !
var
êê! $
face
êê% )
in
êê* ,
mesh
êê- 1
.
êê1 2
facesInternal
êê2 ?
)
êê? @
face
ëë  
.
ëë  !
Reverse
ëë! (
(
ëë( )
)
ëë) *
;
ëë* +
}
ìì 
}
íí 
mesh
ïï 
.
ïï 
ToMesh
ïï 
(
ïï 
)
ïï 
;
ïï 
mesh
ğğ 
.
ğğ 
Refresh
ğğ 
(
ğğ 
)
ğğ 
;
ğğ 
}
ññ 
else
òò 
{
óó !
ClearAndRefreshMesh
õõ #
(
õõ# $
mesh
õõ$ (
)
õõ( )
;
õõ) *
Log
öö 
.
öö 
PopLogLevel
öö 
(
öö  
)
öö  !
;
öö! "
return
÷÷ 
new
÷÷ 
ActionResult
÷÷ '
(
÷÷' (
ActionResult
÷÷( 4
.
÷÷4 5
Status
÷÷5 ;
.
÷÷; <
Failure
÷÷< C
,
÷÷C D
$str
÷÷E b
)
÷÷b c
;
÷÷c d
}
øø 
Log
úú 
.
úú 
PopLogLevel
úú 
(
úú 
)
úú 
;
úú 
return
üü 
new
üü 
ActionResult
üü #
(
üü# $
ActionResult
üü$ 0
.
üü0 1
Status
üü1 7
.
üü7 8
Success
üü8 ?
,
üü? @
$str
üüA W
)
üüW X
;
üüX Y
}
ıı 	
internal
…… 
static
…… 
FaceRebuildData
…… '
FaceWithVertices
……( 8
(
……8 9
List
……9 =
<
……= >
Vertex
……> D
>
……D E
vertices
……F N
,
……N O
bool
……P T
	unordered
……U ^
=
……_ `
true
……a e
)
……e f
{
†† 	
List
‡‡ 
<
‡‡ 
int
‡‡ 
>
‡‡ 
	triangles
‡‡ 
;
‡‡  
if
‰‰ 
(
‰‰ 
Triangulation
‰‰ 
.
‰‰ !
TriangulateVertices
‰‰ 1
(
‰‰1 2
vertices
‰‰2 :
,
‰‰: ;
out
‰‰< ?
	triangles
‰‰@ I
,
‰‰I J
	unordered
‰‰K T
)
‰‰T U
)
‰‰U V
{
ŠŠ 
FaceRebuildData
‹‹ 
data
‹‹  $
=
‹‹% &
new
‹‹' *
FaceRebuildData
‹‹+ :
(
‹‹: ;
)
‹‹; <
;
‹‹< =
data
ŒŒ 
.
ŒŒ 
vertices
ŒŒ 
=
ŒŒ 
vertices
ŒŒ  (
;
ŒŒ( )
data
 
.
 
face
 
=
 
new
 
Face
  $
(
$ %
	triangles
% .
)
. /
;
/ 0
return
 
data
 
;
 
}
 
return
‘‘ 
null
‘‘ 
;
‘‘ 
}
’’ 	
internal
™™ 
static
™™ 
List
™™ 
<
™™ 
FaceRebuildData
™™ ,
>
™™, -!
TentCapWithVertices
™™. A
(
™™A B
List
™™B F
<
™™F G
Vertex
™™G M
>
™™M N
path
™™O S
)
™™S T
{
šš 	
int
›› 
count
›› 
=
›› 
path
›› 
.
›› 
Count
›› "
;
››" #
Vertex
œœ 
center
œœ 
=
œœ 
Vertex
œœ "
.
œœ" #
Average
œœ# *
(
œœ* +
path
œœ+ /
)
œœ/ 0
;
œœ0 1
List
 
<
 
FaceRebuildData
  
>
  !
faces
" '
=
( )
new
* -
List
. 2
<
2 3
FaceRebuildData
3 B
>
B C
(
C D
)
D E
;
E F
for
ŸŸ 
(
ŸŸ 
int
ŸŸ 
i
ŸŸ 
=
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
i
ŸŸ 
<
ŸŸ 
count
ŸŸ  %
;
ŸŸ% &
i
ŸŸ' (
++
ŸŸ( *
)
ŸŸ* +
{
   
List
¡¡ 
<
¡¡ 
Vertex
¡¡ 
>
¡¡ 
vertices
¡¡ %
=
¡¡& '
new
¡¡( +
List
¡¡, 0
<
¡¡0 1
Vertex
¡¡1 7
>
¡¡7 8
(
¡¡8 9
)
¡¡9 :
{
¢¢ 
path
££ 
[
££ 
i
££ 
]
££ 
,
££ 
center
¤¤ 
,
¤¤ 
path
¥¥ 
[
¥¥ 
(
¥¥ 
i
¥¥ 
+
¥¥ 
$num
¥¥ 
)
¥¥  
%
¥¥! "
count
¥¥# (
]
¥¥( )
}
¦¦ 
;
¦¦ 
FaceRebuildData
¨¨ 
data
¨¨  $
=
¨¨% &
new
¨¨' *
FaceRebuildData
¨¨+ :
(
¨¨: ;
)
¨¨; <
;
¨¨< =
data
©© 
.
©© 
vertices
©© 
=
©© 
vertices
©©  (
;
©©( )
data
ªª 
.
ªª 
face
ªª 
=
ªª 
new
ªª 
Face
ªª  $
(
ªª$ %
new
ªª% (
int
ªª) ,
[
ªª, -
]
ªª- .
{
ªª/ 0
$num
ªª0 1
,
ªª2 3
$num
ªª4 5
,
ªª5 6
$num
ªª7 8
}
ªª8 9
)
ªª9 :
;
ªª: ;
faces
¬¬ 
.
¬¬ 
Add
¬¬ 
(
¬¬ 
data
¬¬ 
)
¬¬ 
;
¬¬  
}
­­ 
return
¯¯ 
faces
¯¯ 
;
¯¯ 
}
°° 	
public
·· 
static
·· 
void
·· 
DuplicateAndFlip
·· +
(
··+ ,
this
··, 0
ProBuilderMesh
··1 ?
mesh
··@ D
,
··D E
Face
··F J
[
··J K
]
··K L
faces
··M R
)
··R S
{
¸¸ 	
if
¹¹ 
(
¹¹ 
mesh
¹¹ 
==
¹¹ 
null
¹¹ 
)
¹¹ 
throw
ºº 
new
ºº #
ArgumentNullException
ºº /
(
ºº/ 0
$str
ºº0 6
)
ºº6 7
;
ºº7 8
if
¼¼ 
(
¼¼ 
faces
¼¼ 
==
¼¼ 
null
¼¼ 
)
¼¼ 
throw
½½ 
new
½½ #
ArgumentNullException
½½ /
(
½½/ 0
$str
½½0 7
)
½½7 8
;
½½8 9
List
¿¿ 
<
¿¿ 
FaceRebuildData
¿¿  
>
¿¿  !
rebuild
¿¿" )
=
¿¿* +
new
¿¿, /
List
¿¿0 4
<
¿¿4 5
FaceRebuildData
¿¿5 D
>
¿¿D E
(
¿¿E F
)
¿¿F G
;
¿¿G H
List
ÀÀ 
<
ÀÀ 
Vertex
ÀÀ 
>
ÀÀ 
vertices
ÀÀ !
=
ÀÀ" #
new
ÀÀ$ '
List
ÀÀ( ,
<
ÀÀ, -
Vertex
ÀÀ- 3
>
ÀÀ3 4
(
ÀÀ4 5
mesh
ÀÀ5 9
.
ÀÀ9 :
GetVertices
ÀÀ: E
(
ÀÀE F
)
ÀÀF G
)
ÀÀG H
;
ÀÀH I

Dictionary
ÁÁ 
<
ÁÁ 
int
ÁÁ 
,
ÁÁ 
int
ÁÁ 
>
ÁÁ  
lookup
ÁÁ! '
=
ÁÁ( )
mesh
ÁÁ* .
.
ÁÁ. / 
sharedVertexLookup
ÁÁ/ A
;
ÁÁA B
foreach
ÃÃ 
(
ÃÃ 
Face
ÃÃ 
face
ÃÃ 
in
ÃÃ !
faces
ÃÃ" '
)
ÃÃ' (
{
ÄÄ 
FaceRebuildData
ÅÅ 
data
ÅÅ  $
=
ÅÅ% &
new
ÅÅ' *
FaceRebuildData
ÅÅ+ :
(
ÅÅ: ;
)
ÅÅ; <
;
ÅÅ< =
data
ÇÇ 
.
ÇÇ 
vertices
ÇÇ 
=
ÇÇ 
new
ÇÇ  #
List
ÇÇ$ (
<
ÇÇ( )
Vertex
ÇÇ) /
>
ÇÇ/ 0
(
ÇÇ0 1
)
ÇÇ1 2
;
ÇÇ2 3
data
ÈÈ 
.
ÈÈ 
face
ÈÈ 
=
ÈÈ 
new
ÈÈ 
Face
ÈÈ  $
(
ÈÈ$ %
face
ÈÈ% )
)
ÈÈ) *
;
ÈÈ* +
data
ÉÉ 
.
ÉÉ 
sharedIndexes
ÉÉ "
=
ÉÉ# $
new
ÉÉ% (
List
ÉÉ) -
<
ÉÉ- .
int
ÉÉ. 1
>
ÉÉ1 2
(
ÉÉ2 3
)
ÉÉ3 4
;
ÉÉ4 5

Dictionary
ËË 
<
ËË 
int
ËË 
,
ËË 
int
ËË  #
>
ËË# $
map
ËË% (
=
ËË) *
new
ËË+ .

Dictionary
ËË/ 9
<
ËË9 :
int
ËË: =
,
ËË= >
int
ËË? B
>
ËËB C
(
ËËC D
)
ËËD E
;
ËËE F
int
ÌÌ 
len
ÌÌ 
=
ÌÌ 
data
ÌÌ 
.
ÌÌ 
face
ÌÌ #
.
ÌÌ# $
indexesInternal
ÌÌ$ 3
.
ÌÌ3 4
Length
ÌÌ4 :
;
ÌÌ: ;
for
ÎÎ 
(
ÎÎ 
int
ÎÎ 
i
ÎÎ 
=
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
i
ÎÎ  !
<
ÎÎ" #
len
ÎÎ$ '
;
ÎÎ' (
i
ÎÎ) *
++
ÎÎ* ,
)
ÎÎ, -
{
ÏÏ 
if
ĞĞ 
(
ĞĞ 
map
ĞĞ 
.
ĞĞ 
ContainsKey
ĞĞ '
(
ĞĞ' (
face
ĞĞ( ,
.
ĞĞ, -
indexesInternal
ĞĞ- <
[
ĞĞ< =
i
ĞĞ= >
]
ĞĞ> ?
)
ĞĞ? @
)
ĞĞ@ A
continue
ÑÑ  
;
ÑÑ  !
map
ÓÓ 
.
ÓÓ 
Add
ÓÓ 
(
ÓÓ 
face
ÓÓ  
.
ÓÓ  !
indexesInternal
ÓÓ! 0
[
ÓÓ0 1
i
ÓÓ1 2
]
ÓÓ2 3
,
ÓÓ3 4
map
ÓÓ5 8
.
ÓÓ8 9
Count
ÓÓ9 >
)
ÓÓ> ?
;
ÓÓ? @
data
ÔÔ 
.
ÔÔ 
vertices
ÔÔ !
.
ÔÔ! "
Add
ÔÔ" %
(
ÔÔ% &
vertices
ÔÔ& .
[
ÔÔ. /
face
ÔÔ/ 3
.
ÔÔ3 4
indexesInternal
ÔÔ4 C
[
ÔÔC D
i
ÔÔD E
]
ÔÔE F
]
ÔÔF G
)
ÔÔG H
;
ÔÔH I
data
ÕÕ 
.
ÕÕ 
sharedIndexes
ÕÕ &
.
ÕÕ& '
Add
ÕÕ' *
(
ÕÕ* +
lookup
ÕÕ+ 1
[
ÕÕ1 2
face
ÕÕ2 6
.
ÕÕ6 7
indexesInternal
ÕÕ7 F
[
ÕÕF G
i
ÕÕG H
]
ÕÕH I
]
ÕÕI J
)
ÕÕJ K
;
ÕÕK L
}
ÖÖ 
int
ØØ 
[
ØØ 
]
ØØ 
tris
ØØ 
=
ØØ 
new
ØØ  
int
ØØ! $
[
ØØ$ %
len
ØØ% (
]
ØØ( )
;
ØØ) *
for
ÚÚ 
(
ÚÚ 
var
ÚÚ 
i
ÚÚ 
=
ÚÚ 
$num
ÚÚ 
;
ÚÚ 
i
ÚÚ  !
<
ÚÚ" #
len
ÚÚ$ '
;
ÚÚ' (
i
ÚÚ) *
++
ÚÚ* ,
)
ÚÚ, -
tris
ÛÛ 
[
ÛÛ 
len
ÛÛ 
-
ÛÛ 
(
ÛÛ  
i
ÛÛ  !
+
ÛÛ" #
$num
ÛÛ$ %
)
ÛÛ% &
]
ÛÛ& '
=
ÛÛ( )
map
ÛÛ* -
[
ÛÛ- .
data
ÛÛ. 2
.
ÛÛ2 3
face
ÛÛ3 7
[
ÛÛ7 8
i
ÛÛ8 9
]
ÛÛ9 :
]
ÛÛ: ;
;
ÛÛ; <
data
İİ 
.
İİ 
face
İİ 
.
İİ 

SetIndexes
İİ $
(
İİ$ %
tris
İİ% )
)
İİ) *
;
İİ* +
rebuild
ßß 
.
ßß 
Add
ßß 
(
ßß 
data
ßß  
)
ßß  !
;
ßß! "
}
àà 
FaceRebuildData
ââ 
.
ââ 
Apply
ââ !
(
ââ! "
rebuild
ââ" )
,
ââ) *
mesh
ââ+ /
,
ââ/ 0
vertices
ââ1 9
)
ââ9 :
;
ââ: ;
}
ãã 	
public
íí 
static
íí 
Face
íí 
Bridge
íí !
(
íí! "
this
íí" &
ProBuilderMesh
íí' 5
mesh
íí6 :
,
íí: ;
Edge
íí< @
a
ííA B
,
ííB C
Edge
ííD H
b
ííI J
,
ííJ K
bool
ííL P&
allowNonManifoldGeometry
ííQ i
=
ííj k
false
ííl q
)
ííq r
{
îî 	
if
ïï 
(
ïï 
mesh
ïï 
==
ïï 
null
ïï 
)
ïï 
throw
ğğ 
new
ğğ #
ArgumentNullException
ğğ /
(
ğğ/ 0
$str
ğğ0 6
)
ğğ6 7
;
ğğ7 8
SharedVertex
òò 
[
òò 
]
òò 
sharedVertices
òò )
=
òò* +
mesh
òò, 0
.
òò0 1$
sharedVerticesInternal
òò1 G
;
òòG H

Dictionary
óó 
<
óó 
int
óó 
,
óó 
int
óó 
>
óó  
lookup
óó! '
=
óó( )
mesh
óó* .
.
óó. / 
sharedVertexLookup
óó/ A
;
óóA B
if
öö 
(
öö 
!
öö &
allowNonManifoldGeometry
öö )
)
öö) *
{
÷÷ 
if
øø 
(
øø 
ElementSelection
øø $
.
øø$ %
GetNeighborFaces
øø% 5
(
øø5 6
mesh
øø6 :
,
øø: ;
a
øø< =
)
øø= >
.
øø> ?
Count
øø? D
>
øøE F
$num
øøG H
||
øøI K
ElementSelection
øøL \
.
øø\ ]
GetNeighborFaces
øø] m
(
øøm n
mesh
øøn r
,
øør s
b
øøt u
)
øøu v
.
øøv w
Count
øøw |
>
øø} ~
$numøø €
)øø€ 
{
ùù 
return
úú 
null
úú 
;
úú  
}
ûû 
}
üü 
foreach
şş 
(
şş 
Face
şş 
face
şş 
in
şş !
mesh
şş" &
.
şş& '
facesInternal
şş' 4
)
şş4 5
{
ÿÿ 
if
€€ 
(
€€ 
mesh
€€ 
.
€€ 
IndexOf
€€  
(
€€  !
face
€€! %
.
€€% &
edgesInternal
€€& 3
,
€€3 4
a
€€5 6
)
€€6 7
>=
€€8 :
$num
€€; <
&&
€€= ?
mesh
€€@ D
.
€€D E
IndexOf
€€E L
(
€€L M
face
€€M Q
.
€€Q R
edgesInternal
€€R _
,
€€_ `
b
€€a b
)
€€b c
>=
€€d f
$num
€€g h
)
€€h i
{
 
Log
‚‚ 
.
‚‚ 
Warning
‚‚ 
(
‚‚  
$str
‚‚  N
)
‚‚N O
;
‚‚O P
return
ƒƒ 
null
ƒƒ 
;
ƒƒ  
}
„„ 
}
…… 
Vector3
‡‡ 
[
‡‡ 
]
‡‡ 
	positions
‡‡ 
=
‡‡  !
mesh
‡‡" &
.
‡‡& '
positionsInternal
‡‡' 8
;
‡‡8 9
bool
ˆˆ 
	hasColors
ˆˆ 
=
ˆˆ 
mesh
ˆˆ !
.
ˆˆ! "
	HasArrays
ˆˆ" +
(
ˆˆ+ ,

MeshArrays
ˆˆ, 6
.
ˆˆ6 7
Color
ˆˆ7 <
)
ˆˆ< =
;
ˆˆ= >
Color
‰‰ 
[
‰‰ 
]
‰‰ 
colors
‰‰ 
=
‰‰ 
	hasColors
‰‰ &
?
‰‰' (
mesh
‰‰) -
.
‰‰- .
colorsInternal
‰‰. <
:
‰‰= >
null
‰‰? C
;
‰‰C D
Vector3
‹‹ 
[
‹‹ 
]
‹‹ 
v
‹‹ 
;
‹‹ 
Color
ŒŒ 
[
ŒŒ 
]
ŒŒ 
c
ŒŒ 
;
ŒŒ 
int
 
[
 
]
 
s
 
;
  
AutoUnwrapSettings
 
uvs
 "
=
# $ 
AutoUnwrapSettings
% 7
.
7 8
tile
8 <
;
< =
int
 
submeshIndex
 
=
 
$num
  
;
  !
SimpleTuple
’’ 
<
’’ 
Face
’’ 
,
’’ 
Edge
’’ "
>
’’" #
faceAndEdge
’’$ /
;
’’/ 0
if
”” 
(
”” 
EdgeUtility
”” 
.
”” 
ValidateEdge
”” (
(
””( )
mesh
””) -
,
””- .
a
””/ 0
,
””0 1
out
””2 5
faceAndEdge
””6 A
)
””A B
||
””C E
EdgeUtility
””F Q
.
””Q R
ValidateEdge
””R ^
(
””^ _
mesh
””_ c
,
””c d
b
””e f
,
””f g
out
””h k
faceAndEdge
””l w
)
””w x
)
””x y
{
•• 
uvs
–– 
=
–– 
new
––  
AutoUnwrapSettings
–– ,
(
––, -
faceAndEdge
––- 8
.
––8 9
item1
––9 >
.
––> ?
uv
––? A
)
––A B
;
––B C
submeshIndex
—— 
=
—— 
faceAndEdge
—— *
.
——* +
item1
——+ 0
.
——0 1
submeshIndex
——1 =
;
——= >
}
˜˜ 
if
›› 
(
›› 
a
›› 
.
›› 
Contains
›› 
(
›› 
b
›› 
.
›› 
a
›› 
,
›› 
lookup
››  &
)
››& '
||
››( *
a
››+ ,
.
››, -
Contains
››- 5
(
››5 6
b
››6 7
.
››7 8
b
››8 9
,
››9 :
lookup
››; A
)
››A B
)
››B C
{
œœ 
v
 
=
 
new
 
Vector3
 
[
  
$num
  !
]
! "
;
" #
c
 
=
 
new
 
Color
 
[
 
$num
 
]
  
;
  !
s
ŸŸ 
=
ŸŸ 
new
ŸŸ 
int
ŸŸ 
[
ŸŸ 
$num
ŸŸ 
]
ŸŸ 
;
ŸŸ 
bool
¡¡ 
axbx
¡¡ 
=
¡¡ 
Array
¡¡ !
.
¡¡! "
IndexOf
¡¡" )
(
¡¡) *
sharedVertices
¡¡* 8
[
¡¡8 9
mesh
¡¡9 =
.
¡¡= >#
GetSharedVertexHandle
¡¡> S
(
¡¡S T
a
¡¡T U
.
¡¡U V
a
¡¡V W
)
¡¡W X
]
¡¡X Y
.
¡¡Y Z
arrayInternal
¡¡Z g
,
¡¡g h
b
¡¡i j
.
¡¡j k
a
¡¡k l
)
¡¡l m
>
¡¡n o
-
¡¡p q
$num
¡¡q r
;
¡¡r s
bool
¢¢ 
axby
¢¢ 
=
¢¢ 
Array
¢¢ !
.
¢¢! "
IndexOf
¢¢" )
(
¢¢) *
sharedVertices
¢¢* 8
[
¢¢8 9
mesh
¢¢9 =
.
¢¢= >#
GetSharedVertexHandle
¢¢> S
(
¢¢S T
a
¢¢T U
.
¢¢U V
a
¢¢V W
)
¢¢W X
]
¢¢X Y
.
¢¢Y Z
arrayInternal
¢¢Z g
,
¢¢g h
b
¢¢i j
.
¢¢j k
b
¢¢k l
)
¢¢l m
>
¢¢n o
-
¢¢p q
$num
¢¢q r
;
¢¢r s
bool
¤¤ 
aybx
¤¤ 
=
¤¤ 
Array
¤¤ !
.
¤¤! "
IndexOf
¤¤" )
(
¤¤) *
sharedVertices
¤¤* 8
[
¤¤8 9
mesh
¤¤9 =
.
¤¤= >#
GetSharedVertexHandle
¤¤> S
(
¤¤S T
a
¤¤T U
.
¤¤U V
b
¤¤V W
)
¤¤W X
]
¤¤X Y
.
¤¤Y Z
arrayInternal
¤¤Z g
,
¤¤g h
b
¤¤i j
.
¤¤j k
a
¤¤k l
)
¤¤l m
>
¤¤n o
-
¤¤p q
$num
¤¤q r
;
¤¤r s
bool
¥¥ 
ayby
¥¥ 
=
¥¥ 
Array
¥¥ !
.
¥¥! "
IndexOf
¥¥" )
(
¥¥) *
sharedVertices
¥¥* 8
[
¥¥8 9
mesh
¥¥9 =
.
¥¥= >#
GetSharedVertexHandle
¥¥> S
(
¥¥S T
a
¥¥T U
.
¥¥U V
b
¥¥V W
)
¥¥W X
]
¥¥X Y
.
¥¥Y Z
arrayInternal
¥¥Z g
,
¥¥g h
b
¥¥i j
.
¥¥j k
b
¥¥k l
)
¥¥l m
>
¥¥n o
-
¥¥p q
$num
¥¥q r
;
¥¥r s
if
§§ 
(
§§ 
axbx
§§ 
)
§§ 
{
¨¨ 
v
©© 
[
©© 
$num
©© 
]
©© 
=
©© 
	positions
©© $
[
©©$ %
a
©©% &
.
©©& '
a
©©' (
]
©©( )
;
©©) *
if
ªª 
(
ªª 
	hasColors
ªª !
)
ªª! "
c
ªª# $
[
ªª$ %
$num
ªª% &
]
ªª& '
=
ªª( )
colors
ªª* 0
[
ªª0 1
a
ªª1 2
.
ªª2 3
a
ªª3 4
]
ªª4 5
;
ªª5 6
s
«« 
[
«« 
$num
«« 
]
«« 
=
«« 
mesh
«« 
.
««  #
GetSharedVertexHandle
««  5
(
««5 6
a
««6 7
.
««7 8
a
««8 9
)
««9 :
;
««: ;
v
¬¬ 
[
¬¬ 
$num
¬¬ 
]
¬¬ 
=
¬¬ 
	positions
¬¬ $
[
¬¬$ %
a
¬¬% &
.
¬¬& '
b
¬¬' (
]
¬¬( )
;
¬¬) *
if
­­ 
(
­­ 
	hasColors
­­ !
)
­­! "
c
­­# $
[
­­$ %
$num
­­% &
]
­­& '
=
­­( )
colors
­­* 0
[
­­0 1
a
­­1 2
.
­­2 3
b
­­3 4
]
­­4 5
;
­­5 6
s
®® 
[
®® 
$num
®® 
]
®® 
=
®® 
mesh
®® 
.
®®  #
GetSharedVertexHandle
®®  5
(
®®5 6
a
®®6 7
.
®®7 8
b
®®8 9
)
®®9 :
;
®®: ;
v
¯¯ 
[
¯¯ 
$num
¯¯ 
]
¯¯ 
=
¯¯ 
	positions
¯¯ $
[
¯¯$ %
b
¯¯% &
.
¯¯& '
b
¯¯' (
]
¯¯( )
;
¯¯) *
if
°° 
(
°° 
	hasColors
°° !
)
°°! "
c
°°# $
[
°°$ %
$num
°°% &
]
°°& '
=
°°( )
colors
°°* 0
[
°°0 1
b
°°1 2
.
°°2 3
b
°°3 4
]
°°4 5
;
°°5 6
s
±± 
[
±± 
$num
±± 
]
±± 
=
±± 
mesh
±± 
.
±±  #
GetSharedVertexHandle
±±  5
(
±±5 6
b
±±6 7
.
±±7 8
b
±±8 9
)
±±9 :
;
±±: ;
}
²² 
else
³³ 
if
³³ 
(
³³ 
axby
³³ 
)
³³ 
{
´´ 
v
µµ 
[
µµ 
$num
µµ 
]
µµ 
=
µµ 
	positions
µµ $
[
µµ$ %
a
µµ% &
.
µµ& '
a
µµ' (
]
µµ( )
;
µµ) *
if
¶¶ 
(
¶¶ 
	hasColors
¶¶ !
)
¶¶! "
c
¶¶# $
[
¶¶$ %
$num
¶¶% &
]
¶¶& '
=
¶¶( )
colors
¶¶* 0
[
¶¶0 1
a
¶¶1 2
.
¶¶2 3
a
¶¶3 4
]
¶¶4 5
;
¶¶5 6
s
·· 
[
·· 
$num
·· 
]
·· 
=
·· 
mesh
·· 
.
··  #
GetSharedVertexHandle
··  5
(
··5 6
a
··6 7
.
··7 8
a
··8 9
)
··9 :
;
··: ;
v
¸¸ 
[
¸¸ 
$num
¸¸ 
]
¸¸ 
=
¸¸ 
	positions
¸¸ $
[
¸¸$ %
a
¸¸% &
.
¸¸& '
b
¸¸' (
]
¸¸( )
;
¸¸) *
if
¹¹ 
(
¹¹ 
	hasColors
¹¹ !
)
¹¹! "
c
¹¹# $
[
¹¹$ %
$num
¹¹% &
]
¹¹& '
=
¹¹( )
colors
¹¹* 0
[
¹¹0 1
a
¹¹1 2
.
¹¹2 3
b
¹¹3 4
]
¹¹4 5
;
¹¹5 6
s
ºº 
[
ºº 
$num
ºº 
]
ºº 
=
ºº 
mesh
ºº 
.
ºº  #
GetSharedVertexHandle
ºº  5
(
ºº5 6
a
ºº6 7
.
ºº7 8
b
ºº8 9
)
ºº9 :
;
ºº: ;
v
»» 
[
»» 
$num
»» 
]
»» 
=
»» 
	positions
»» $
[
»»$ %
b
»»% &
.
»»& '
a
»»' (
]
»»( )
;
»») *
if
¼¼ 
(
¼¼ 
	hasColors
¼¼ !
)
¼¼! "
c
¼¼# $
[
¼¼$ %
$num
¼¼% &
]
¼¼& '
=
¼¼( )
colors
¼¼* 0
[
¼¼0 1
b
¼¼1 2
.
¼¼2 3
a
¼¼3 4
]
¼¼4 5
;
¼¼5 6
s
½½ 
[
½½ 
$num
½½ 
]
½½ 
=
½½ 
mesh
½½ 
.
½½  #
GetSharedVertexHandle
½½  5
(
½½5 6
b
½½6 7
.
½½7 8
a
½½8 9
)
½½9 :
;
½½: ;
}
¾¾ 
else
¿¿ 
if
¿¿ 
(
¿¿ 
aybx
¿¿ 
)
¿¿ 
{
ÀÀ 
v
ÁÁ 
[
ÁÁ 
$num
ÁÁ 
]
ÁÁ 
=
ÁÁ 
	positions
ÁÁ $
[
ÁÁ$ %
a
ÁÁ% &
.
ÁÁ& '
b
ÁÁ' (
]
ÁÁ( )
;
ÁÁ) *
if
ÂÂ 
(
ÂÂ 
	hasColors
ÂÂ !
)
ÂÂ! "
c
ÂÂ# $
[
ÂÂ$ %
$num
ÂÂ% &
]
ÂÂ& '
=
ÂÂ( )
colors
ÂÂ* 0
[
ÂÂ0 1
a
ÂÂ1 2
.
ÂÂ2 3
b
ÂÂ3 4
]
ÂÂ4 5
;
ÂÂ5 6
s
ÃÃ 
[
ÃÃ 
$num
ÃÃ 
]
ÃÃ 
=
ÃÃ 
mesh
ÃÃ 
.
ÃÃ  #
GetSharedVertexHandle
ÃÃ  5
(
ÃÃ5 6
a
ÃÃ6 7
.
ÃÃ7 8
b
ÃÃ8 9
)
ÃÃ9 :
;
ÃÃ: ;
v
ÄÄ 
[
ÄÄ 
$num
ÄÄ 
]
ÄÄ 
=
ÄÄ 
	positions
ÄÄ $
[
ÄÄ$ %
a
ÄÄ% &
.
ÄÄ& '
a
ÄÄ' (
]
ÄÄ( )
;
ÄÄ) *
if
ÅÅ 
(
ÅÅ 
	hasColors
ÅÅ !
)
ÅÅ! "
c
ÅÅ# $
[
ÅÅ$ %
$num
ÅÅ% &
]
ÅÅ& '
=
ÅÅ( )
colors
ÅÅ* 0
[
ÅÅ0 1
a
ÅÅ1 2
.
ÅÅ2 3
a
ÅÅ3 4
]
ÅÅ4 5
;
ÅÅ5 6
s
ÆÆ 
[
ÆÆ 
$num
ÆÆ 
]
ÆÆ 
=
ÆÆ 
mesh
ÆÆ 
.
ÆÆ  #
GetSharedVertexHandle
ÆÆ  5
(
ÆÆ5 6
a
ÆÆ6 7
.
ÆÆ7 8
a
ÆÆ8 9
)
ÆÆ9 :
;
ÆÆ: ;
v
ÇÇ 
[
ÇÇ 
$num
ÇÇ 
]
ÇÇ 
=
ÇÇ 
	positions
ÇÇ $
[
ÇÇ$ %
b
ÇÇ% &
.
ÇÇ& '
b
ÇÇ' (
]
ÇÇ( )
;
ÇÇ) *
if
ÈÈ 
(
ÈÈ 
	hasColors
ÈÈ !
)
ÈÈ! "
c
ÈÈ# $
[
ÈÈ$ %
$num
ÈÈ% &
]
ÈÈ& '
=
ÈÈ( )
colors
ÈÈ* 0
[
ÈÈ0 1
b
ÈÈ1 2
.
ÈÈ2 3
b
ÈÈ3 4
]
ÈÈ4 5
;
ÈÈ5 6
s
ÉÉ 
[
ÉÉ 
$num
ÉÉ 
]
ÉÉ 
=
ÉÉ 
mesh
ÉÉ 
.
ÉÉ  #
GetSharedVertexHandle
ÉÉ  5
(
ÉÉ5 6
b
ÉÉ6 7
.
ÉÉ7 8
b
ÉÉ8 9
)
ÉÉ9 :
;
ÉÉ: ;
}
ÊÊ 
else
ËË 
if
ËË 
(
ËË 
ayby
ËË 
)
ËË 
{
ÌÌ 
v
ÍÍ 
[
ÍÍ 
$num
ÍÍ 
]
ÍÍ 
=
ÍÍ 
	positions
ÍÍ $
[
ÍÍ$ %
a
ÍÍ% &
.
ÍÍ& '
b
ÍÍ' (
]
ÍÍ( )
;
ÍÍ) *
if
ÎÎ 
(
ÎÎ 
	hasColors
ÎÎ !
)
ÎÎ! "
c
ÎÎ# $
[
ÎÎ$ %
$num
ÎÎ% &
]
ÎÎ& '
=
ÎÎ( )
colors
ÎÎ* 0
[
ÎÎ0 1
a
ÎÎ1 2
.
ÎÎ2 3
b
ÎÎ3 4
]
ÎÎ4 5
;
ÎÎ5 6
s
ÏÏ 
[
ÏÏ 
$num
ÏÏ 
]
ÏÏ 
=
ÏÏ 
mesh
ÏÏ 
.
ÏÏ  #
GetSharedVertexHandle
ÏÏ  5
(
ÏÏ5 6
a
ÏÏ6 7
.
ÏÏ7 8
b
ÏÏ8 9
)
ÏÏ9 :
;
ÏÏ: ;
v
ĞĞ 
[
ĞĞ 
$num
ĞĞ 
]
ĞĞ 
=
ĞĞ 
	positions
ĞĞ $
[
ĞĞ$ %
a
ĞĞ% &
.
ĞĞ& '
a
ĞĞ' (
]
ĞĞ( )
;
ĞĞ) *
if
ÑÑ 
(
ÑÑ 
	hasColors
ÑÑ !
)
ÑÑ! "
c
ÑÑ# $
[
ÑÑ$ %
$num
ÑÑ% &
]
ÑÑ& '
=
ÑÑ( )
colors
ÑÑ* 0
[
ÑÑ0 1
a
ÑÑ1 2
.
ÑÑ2 3
a
ÑÑ3 4
]
ÑÑ4 5
;
ÑÑ5 6
s
ÒÒ 
[
ÒÒ 
$num
ÒÒ 
]
ÒÒ 
=
ÒÒ 
mesh
ÒÒ 
.
ÒÒ  #
GetSharedVertexHandle
ÒÒ  5
(
ÒÒ5 6
a
ÒÒ6 7
.
ÒÒ7 8
a
ÒÒ8 9
)
ÒÒ9 :
;
ÒÒ: ;
v
ÓÓ 
[
ÓÓ 
$num
ÓÓ 
]
ÓÓ 
=
ÓÓ 
	positions
ÓÓ $
[
ÓÓ$ %
b
ÓÓ% &
.
ÓÓ& '
a
ÓÓ' (
]
ÓÓ( )
;
ÓÓ) *
if
ÔÔ 
(
ÔÔ 
	hasColors
ÔÔ !
)
ÔÔ! "
c
ÔÔ# $
[
ÔÔ$ %
$num
ÔÔ% &
]
ÔÔ& '
=
ÔÔ( )
colors
ÔÔ* 0
[
ÔÔ0 1
b
ÔÔ1 2
.
ÔÔ2 3
a
ÔÔ3 4
]
ÔÔ4 5
;
ÔÔ5 6
s
ÕÕ 
[
ÕÕ 
$num
ÕÕ 
]
ÕÕ 
=
ÕÕ 
mesh
ÕÕ 
.
ÕÕ  #
GetSharedVertexHandle
ÕÕ  5
(
ÕÕ5 6
b
ÕÕ6 7
.
ÕÕ7 8
a
ÕÕ8 9
)
ÕÕ9 :
;
ÕÕ: ;
}
ÖÖ 
return
ØØ 
mesh
ØØ 
.
ØØ 

AppendFace
ØØ &
(
ØØ& '
v
ÙÙ 
,
ÙÙ 
	hasColors
ÚÚ 
?
ÚÚ 
c
ÚÚ  !
:
ÚÚ" #
null
ÚÚ$ (
,
ÚÚ( )
new
ÛÛ 
Vector2
ÛÛ 
[
ÛÛ  
v
ÛÛ  !
.
ÛÛ! "
Length
ÛÛ" (
]
ÛÛ( )
,
ÛÛ) *
new
ÜÜ 
Face
ÜÜ 
(
ÜÜ 
axbx
ÜÜ !
||
ÜÜ" $
axby
ÜÜ% )
?
ÜÜ* +
new
ÜÜ, /
int
ÜÜ0 3
[
ÜÜ3 4
$num
ÜÜ4 5
]
ÜÜ5 6
{
ÜÜ7 8
$num
ÜÜ8 9
,
ÜÜ9 :
$num
ÜÜ; <
,
ÜÜ< =
$num
ÜÜ> ?
}
ÜÜ? @
:
ÜÜA B
new
ÜÜC F
int
ÜÜG J
[
ÜÜJ K
$num
ÜÜK L
]
ÜÜL M
{
ÜÜN O
$num
ÜÜO P
,
ÜÜP Q
$num
ÜÜR S
,
ÜÜS T
$num
ÜÜU V
}
ÜÜV W
,
ÜÜW X
submeshIndex
ÜÜY e
,
ÜÜe f
uvs
ÜÜg j
,
ÜÜj k
$num
ÜÜl m
,
ÜÜm n
-
ÜÜo p
$num
ÜÜp q
,
ÜÜq r
-
ÜÜs t
$num
ÜÜt u
,
ÜÜu v
false
ÜÜw |
)
ÜÜ| }
,
ÜÜ} ~
s
İİ 
)
İİ 
;
İİ 
}
ŞŞ 
v
ââ 
=
ââ 
new
ââ 
Vector3
ââ 
[
ââ 
$num
ââ 
]
ââ 
;
ââ 
c
ãã 
=
ãã 
new
ãã 
Color
ãã 
[
ãã 
$num
ãã 
]
ãã 
;
ãã 
s
ää 
=
ää 
new
ää 
int
ää 
[
ää 
$num
ää 
]
ää 
;
ää 
v
ææ 
[
ææ 
$num
ææ 
]
ææ 
=
ææ 
	positions
ææ 
[
ææ 
a
ææ 
.
ææ 
a
ææ  
]
ææ  !
;
ææ! "
if
çç 
(
çç 
	hasColors
çç 
)
çç 
c
èè 
[
èè 
$num
èè 
]
èè 
=
èè 
mesh
èè 
.
èè 
colorsInternal
èè *
[
èè* +
a
èè+ ,
.
èè, -
a
èè- .
]
èè. /
;
èè/ 0
s
éé 
[
éé 
$num
éé 
]
éé 
=
éé 
mesh
éé 
.
éé #
GetSharedVertexHandle
éé -
(
éé- .
a
éé. /
.
éé/ 0
a
éé0 1
)
éé1 2
;
éé2 3
v
êê 
[
êê 
$num
êê 
]
êê 
=
êê 
	positions
êê 
[
êê 
a
êê 
.
êê 
b
êê  
]
êê  !
;
êê! "
if
ëë 
(
ëë 
	hasColors
ëë 
)
ëë 
c
ìì 
[
ìì 
$num
ìì 
]
ìì 
=
ìì 
mesh
ìì 
.
ìì 
colorsInternal
ìì *
[
ìì* +
a
ìì+ ,
.
ìì, -
b
ìì- .
]
ìì. /
;
ìì/ 0
s
íí 
[
íí 
$num
íí 
]
íí 
=
íí 
mesh
íí 
.
íí #
GetSharedVertexHandle
íí -
(
íí- .
a
íí. /
.
íí/ 0
b
íí0 1
)
íí1 2
;
íí2 3
Vector3
ïï 
nrm
ïï 
=
ïï 
Vector3
ïï !
.
ïï! "
Cross
ïï" '
(
ïï' (
	positions
ïï( 1
[
ïï1 2
b
ïï2 3
.
ïï3 4
a
ïï4 5
]
ïï5 6
-
ïï7 8
	positions
ïï9 B
[
ïïB C
a
ïïC D
.
ïïD E
a
ïïE F
]
ïïF G
,
ïïG H
	positions
ïïI R
[
ïïR S
a
ïïS T
.
ïïT U
b
ïïU V
]
ïïV W
-
ïïX Y
	positions
ïïZ c
[
ïïc d
a
ïïd e
.
ïïe f
a
ïïf g
]
ïïg h
)
ïïh i
.
ïïi j

normalized
ïïj t
;
ïït u
Vector2
ğğ 
[
ğğ 
]
ğğ 
planed
ğğ 
=
ğğ 

Projection
ğğ )
.
ğğ) *
PlanarProject
ğğ* 7
(
ğğ7 8
new
ğğ8 ;
Vector3
ğğ< C
[
ğğC D
$num
ğğD E
]
ğğE F
{
ğğG H
	positions
ğğI R
[
ğğR S
a
ğğS T
.
ğğT U
a
ğğU V
]
ğğV W
,
ğğW X
	positions
ğğY b
[
ğğb c
a
ğğc d
.
ğğd e
b
ğğe f
]
ğğf g
,
ğğg h
	positions
ğği r
[
ğğr s
b
ğğs t
.
ğğt u
a
ğğu v
]
ğğv w
,
ğğw x
	positionsğğy ‚
[ğğ‚ ƒ
bğğƒ „
.ğğ„ …
bğğ… †
]ğğ† ‡
}ğğˆ ‰
,ğğ‰ Š
nullğğ‹ 
,ğğ 
nrmğğ‘ ”
)ğğ” •
;ğğ• –
Vector2
òò 
ipoint
òò 
=
òò 
Vector2
òò $
.
òò$ %
zero
òò% )
;
òò) *
bool
óó 

intersects
óó 
=
óó 
Math
óó "
.
óó" #%
GetLineSegmentIntersect
óó# :
(
óó: ;
planed
óó; A
[
óóA B
$num
óóB C
]
óóC D
,
óóD E
planed
óóF L
[
óóL M
$num
óóM N
]
óóN O
,
óóO P
planed
óóQ W
[
óóW X
$num
óóX Y
]
óóY Z
,
óóZ [
planed
óó\ b
[
óób c
$num
óóc d
]
óód e
,
óóe f
ref
óóg j
ipoint
óók q
)
óóq r
;
óór s
if
õõ 
(
õõ 
!
õõ 

intersects
õõ 
)
õõ 
{
öö 
v
÷÷ 
[
÷÷ 
$num
÷÷ 
]
÷÷ 
=
÷÷ 
	positions
÷÷  
[
÷÷  !
b
÷÷! "
.
÷÷" #
a
÷÷# $
]
÷÷$ %
;
÷÷% &
if
øø 
(
øø 
	hasColors
øø 
)
øø 
c
ùù 
[
ùù 
$num
ùù 
]
ùù 
=
ùù 
mesh
ùù 
.
ùù  
colorsInternal
ùù  .
[
ùù. /
b
ùù/ 0
.
ùù0 1
a
ùù1 2
]
ùù2 3
;
ùù3 4
s
úú 
[
úú 
$num
úú 
]
úú 
=
úú 
mesh
úú 
.
úú #
GetSharedVertexHandle
úú 1
(
úú1 2
b
úú2 3
.
úú3 4
a
úú4 5
)
úú5 6
;
úú6 7
v
ûû 
[
ûû 
$num
ûû 
]
ûû 
=
ûû 
	positions
ûû  
[
ûû  !
b
ûû! "
.
ûû" #
b
ûû# $
]
ûû$ %
;
ûû% &
if
üü 
(
üü 
	hasColors
üü 
)
üü 
c
ıı 
[
ıı 
$num
ıı 
]
ıı 
=
ıı 
mesh
ıı 
.
ıı  
colorsInternal
ıı  .
[
ıı. /
b
ıı/ 0
.
ıı0 1
b
ıı1 2
]
ıı2 3
;
ıı3 4
s
şş 
[
şş 
$num
şş 
]
şş 
=
şş 
mesh
şş 
.
şş #
GetSharedVertexHandle
şş 1
(
şş1 2
b
şş2 3
.
şş3 4
b
şş4 5
)
şş5 6
;
şş6 7
}
ÿÿ 
else
€€ 
{
 
v
‚‚ 
[
‚‚ 
$num
‚‚ 
]
‚‚ 
=
‚‚ 
	positions
‚‚  
[
‚‚  !
b
‚‚! "
.
‚‚" #
b
‚‚# $
]
‚‚$ %
;
‚‚% &
if
ƒƒ 
(
ƒƒ 
	hasColors
ƒƒ 
)
ƒƒ 
c
„„ 
[
„„ 
$num
„„ 
]
„„ 
=
„„ 
mesh
„„ 
.
„„  
colorsInternal
„„  .
[
„„. /
b
„„/ 0
.
„„0 1
b
„„1 2
]
„„2 3
;
„„3 4
s
…… 
[
…… 
$num
…… 
]
…… 
=
…… 
mesh
…… 
.
…… #
GetSharedVertexHandle
…… 1
(
……1 2
b
……2 3
.
……3 4
b
……4 5
)
……5 6
;
……6 7
v
†† 
[
†† 
$num
†† 
]
†† 
=
†† 
	positions
††  
[
††  !
b
††! "
.
††" #
a
††# $
]
††$ %
;
††% &
if
‡‡ 
(
‡‡ 
	hasColors
‡‡ 
)
‡‡ 
c
ˆˆ 
[
ˆˆ 
$num
ˆˆ 
]
ˆˆ 
=
ˆˆ 
mesh
ˆˆ 
.
ˆˆ  
colorsInternal
ˆˆ  .
[
ˆˆ. /
b
ˆˆ/ 0
.
ˆˆ0 1
a
ˆˆ1 2
]
ˆˆ2 3
;
ˆˆ3 4
s
‰‰ 
[
‰‰ 
$num
‰‰ 
]
‰‰ 
=
‰‰ 
mesh
‰‰ 
.
‰‰ #
GetSharedVertexHandle
‰‰ 1
(
‰‰1 2
b
‰‰2 3
.
‰‰3 4
a
‰‰4 5
)
‰‰5 6
;
‰‰6 7
}
ŠŠ 
return
ŒŒ 
mesh
ŒŒ 
.
ŒŒ 

AppendFace
ŒŒ "
(
ŒŒ" #
v
 
,
 
	hasColors
 
?
 
c
 
:
 
null
  $
,
$ %
new
 
Vector2
 
[
 
v
 
.
 
Length
 $
]
$ %
,
% &
new
 
Face
 
(
 
new
 
int
  
[
  !
$num
! "
]
" #
{
$ %
$num
% &
,
& '
$num
( )
,
) *
$num
+ ,
,
, -
$num
. /
,
/ 0
$num
1 2
,
2 3
$num
4 5
}
6 7
,
7 8
submeshIndex
9 E
,
E F
uvs
G J
,
J K
$num
L M
,
M N
-
O P
$num
P Q
,
Q R
-
S T
$num
T U
,
U V
false
W \
)
\ ]
,
] ^
s
‘‘ 
)
‘‘ 
;
‘‘ 
}
’’ 	
public
›› 
static
›› 
Face
›› "
AppendVerticesToFace
›› /
(
››/ 0
this
››0 4
ProBuilderMesh
››5 C
mesh
››D H
,
››H I
Face
››J N
face
››O S
,
››S T
Vector3
››U \
[
››\ ]
]
››] ^
points
››_ e
)
››e f
{
œœ 	
if
 
(
 
mesh
 
==
 
null
 
)
 
throw
 
new
 #
ArgumentNullException
 /
(
/ 0
$str
0 6
)
6 7
;
7 8
if
   
(
   
face
   
==
   
null
   
)
   
throw
¡¡ 
new
¡¡ #
ArgumentNullException
¡¡ /
(
¡¡/ 0
$str
¡¡0 6
)
¡¡6 7
;
¡¡7 8
if
££ 
(
££ 
points
££ 
==
££ 
null
££ 
)
££ 
throw
¤¤ 
new
¤¤ #
ArgumentNullException
¤¤ /
(
¤¤/ 0
$str
¤¤0 8
)
¤¤8 9
;
¤¤9 :
List
¦¦ 
<
¦¦ 
Vertex
¦¦ 
>
¦¦ 
vertices
¦¦ !
=
¦¦" #
mesh
¦¦$ (
.
¦¦( )
GetVertices
¦¦) 4
(
¦¦4 5
)
¦¦5 6
.
¦¦6 7
ToList
¦¦7 =
(
¦¦= >
)
¦¦> ?
;
¦¦? @
List
§§ 
<
§§ 
Face
§§ 
>
§§ 
faces
§§ 
=
§§ 
new
§§ "
List
§§# '
<
§§' (
Face
§§( ,
>
§§, -
(
§§- .
mesh
§§. 2
.
§§2 3
facesInternal
§§3 @
)
§§@ A
;
§§A B

Dictionary
¨¨ 
<
¨¨ 
int
¨¨ 
,
¨¨ 
int
¨¨ 
>
¨¨  
lookup
¨¨! '
=
¨¨( )
mesh
¨¨* .
.
¨¨. / 
sharedVertexLookup
¨¨/ A
;
¨¨A B

Dictionary
©© 
<
©© 
int
©© 
,
©© 
int
©© 
>
©©  
lookupUV
©©! )
=
©©* +
null
©©, 0
;
©©0 1
if
«« 
(
«« 
mesh
«« 
.
«« 
sharedTextures
«« #
!=
««$ &
null
««' +
)
««+ ,
{
¬¬ 
lookupUV
­­ 
=
­­ 
new
­­ 

Dictionary
­­ )
<
­­) *
int
­­* -
,
­­- .
int
­­/ 2
>
­­2 3
(
­­3 4
)
­­4 5
;
­­5 6
SharedVertex
®® 
.
®® #
GetSharedVertexLookup
®® 2
(
®®2 3
mesh
®®3 7
.
®®7 8
sharedTextures
®®8 F
,
®®F G
lookupUV
®®H P
)
®®P Q
;
®®Q R
}
¯¯ 
List
±± 
<
±± 
Edge
±± 
>
±± 
wound
±± 
=
±± 

WingedEdge
±± )
.
±±) *"
SortEdgesByAdjacency
±±* >
(
±±> ?
face
±±? C
)
±±C D
;
±±D E
List
³³ 
<
³³ 
Vertex
³³ 
>
³³ 

n_vertices
³³ #
=
³³$ %
new
³³& )
List
³³* .
<
³³. /
Vertex
³³/ 5
>
³³5 6
(
³³6 7
)
³³7 8
;
³³8 9
List
´´ 
<
´´ 
int
´´ 
>
´´ 
n_shared
´´ 
=
´´  
new
´´! $
List
´´% )
<
´´) *
int
´´* -
>
´´- .
(
´´. /
)
´´/ 0
;
´´0 1
List
µµ 
<
µµ 
int
µµ 
>
µµ 

n_sharedUV
µµ  
=
µµ! "
lookupUV
µµ# +
!=
µµ, .
null
µµ/ 3
?
µµ4 5
new
µµ6 9
List
µµ: >
<
µµ> ?
int
µµ? B
>
µµB C
(
µµC D
)
µµD E
:
µµF G
null
µµH L
;
µµL M
for
·· 
(
·· 
int
·· 
i
·· 
=
·· 
$num
·· 
;
·· 
i
·· 
<
·· 
wound
··  %
.
··% &
Count
··& +
;
··+ ,
i
··- .
++
··. 0
)
··0 1
{
¸¸ 

n_vertices
¹¹ 
.
¹¹ 
Add
¹¹ 
(
¹¹ 
vertices
¹¹ '
[
¹¹' (
wound
¹¹( -
[
¹¹- .
i
¹¹. /
]
¹¹/ 0
.
¹¹0 1
a
¹¹1 2
]
¹¹2 3
)
¹¹3 4
;
¹¹4 5
n_shared
ºº 
.
ºº 
Add
ºº 
(
ºº 
lookup
ºº #
[
ºº# $
wound
ºº$ )
[
ºº) *
i
ºº* +
]
ºº+ ,
.
ºº, -
a
ºº- .
]
ºº. /
)
ºº/ 0
;
ºº0 1
if
¼¼ 
(
¼¼ 
lookupUV
¼¼ 
!=
¼¼ 
null
¼¼  $
)
¼¼$ %
{
½½ 
int
¾¾ 
uv
¾¾ 
;
¾¾ 
if
ÀÀ 
(
ÀÀ 
lookupUV
ÀÀ  
.
ÀÀ  !
TryGetValue
ÀÀ! ,
(
ÀÀ, -
wound
ÀÀ- 2
[
ÀÀ2 3
i
ÀÀ3 4
]
ÀÀ4 5
.
ÀÀ5 6
a
ÀÀ6 7
,
ÀÀ7 8
out
ÀÀ9 <
uv
ÀÀ= ?
)
ÀÀ? @
)
ÀÀ@ A

n_sharedUV
ÁÁ "
.
ÁÁ" #
Add
ÁÁ# &
(
ÁÁ& '
uv
ÁÁ' )
)
ÁÁ) *
;
ÁÁ* +
else
ÂÂ 

n_sharedUV
ÃÃ "
.
ÃÃ" #
Add
ÃÃ# &
(
ÃÃ& '
-
ÃÃ' (
$num
ÃÃ( )
)
ÃÃ) *
;
ÃÃ* +
}
ÄÄ 
}
ÅÅ 
for
ÈÈ 
(
ÈÈ 
int
ÈÈ 
i
ÈÈ 
=
ÈÈ 
$num
ÈÈ 
;
ÈÈ 
i
ÈÈ 
<
ÈÈ 
points
ÈÈ  &
.
ÈÈ& '
Length
ÈÈ' -
;
ÈÈ- .
i
ÈÈ/ 0
++
ÈÈ0 2
)
ÈÈ2 3
{
ÉÉ 
int
ÊÊ 
index
ÊÊ 
=
ÊÊ 
-
ÊÊ 
$num
ÊÊ 
;
ÊÊ 
float
ËË 
best
ËË 
=
ËË 
Mathf
ËË "
.
ËË" #
Infinity
ËË# +
;
ËË+ ,
Vector3
ÌÌ 
p
ÌÌ 
=
ÌÌ 
points
ÌÌ "
[
ÌÌ" #
i
ÌÌ# $
]
ÌÌ$ %
;
ÌÌ% &
int
ÍÍ 
vc
ÍÍ 
=
ÍÍ 

n_vertices
ÍÍ #
.
ÍÍ# $
Count
ÍÍ$ )
;
ÍÍ) *
for
ÏÏ 
(
ÏÏ 
int
ÏÏ 
n
ÏÏ 
=
ÏÏ 
$num
ÏÏ 
;
ÏÏ 
n
ÏÏ  !
<
ÏÏ" #
vc
ÏÏ$ &
;
ÏÏ& '
n
ÏÏ( )
++
ÏÏ) +
)
ÏÏ+ ,
{
ĞĞ 
Vector3
ÑÑ 
v
ÑÑ 
=
ÑÑ 

n_vertices
ÑÑ  *
[
ÑÑ* +
n
ÑÑ+ ,
]
ÑÑ, -
.
ÑÑ- .
position
ÑÑ. 6
;
ÑÑ6 7
Vector3
ÒÒ 
w
ÒÒ 
=
ÒÒ 

n_vertices
ÒÒ  *
[
ÒÒ* +
(
ÒÒ+ ,
n
ÒÒ, -
+
ÒÒ. /
$num
ÒÒ0 1
)
ÒÒ1 2
%
ÒÒ3 4
vc
ÒÒ5 7
]
ÒÒ7 8
.
ÒÒ8 9
position
ÒÒ9 A
;
ÒÒA B
float
ÔÔ 
dist
ÔÔ 
=
ÔÔ  
Math
ÔÔ! %
.
ÔÔ% &&
DistancePointLineSegment
ÔÔ& >
(
ÔÔ> ?
p
ÔÔ? @
,
ÔÔ@ A
v
ÔÔB C
,
ÔÔC D
w
ÔÔE F
)
ÔÔF G
;
ÔÔG H
if
ÖÖ 
(
ÖÖ 
dist
ÖÖ 
<
ÖÖ 
best
ÖÖ #
)
ÖÖ# $
{
×× 
best
ØØ 
=
ØØ 
dist
ØØ #
;
ØØ# $
index
ÙÙ 
=
ÙÙ 
n
ÙÙ  !
;
ÙÙ! "
}
ÚÚ 
}
ÛÛ 
Vertex
İİ 
left
İİ 
=
İİ 

n_vertices
İİ (
[
İİ( )
index
İİ) .
]
İİ. /
,
İİ/ 0
right
İİ1 6
=
İİ7 8

n_vertices
İİ9 C
[
İİC D
(
İİD E
index
İİE J
+
İİK L
$num
İİM N
)
İİN O
%
İİP Q
vc
İİR T
]
İİT U
;
İİU V
float
ßß 
x
ßß 
=
ßß 
(
ßß 
p
ßß 
-
ßß 
left
ßß #
.
ßß# $
position
ßß$ ,
)
ßß, -
.
ßß- .
sqrMagnitude
ßß. :
;
ßß: ;
float
àà 
y
àà 
=
àà 
(
àà 
p
àà 
-
àà 
right
àà $
.
àà$ %
position
àà% -
)
àà- .
.
àà. /
sqrMagnitude
àà/ ;
;
àà; <
Vertex
ââ 
insert
ââ 
=
ââ 
Vertex
ââ  &
.
ââ& '
Mix
ââ' *
(
ââ* +
left
ââ+ /
,
ââ/ 0
right
ââ1 6
,
ââ6 7
x
ââ8 9
/
ââ: ;
(
ââ< =
x
ââ= >
+
ââ? @
y
ââA B
)
ââB C
)
ââC D
;
ââD E

n_vertices
ää 
.
ää 
Insert
ää !
(
ää! "
(
ää" #
index
ää# (
+
ää) *
$num
ää+ ,
)
ää, -
%
ää. /
vc
ää0 2
,
ää2 3
insert
ää4 :
)
ää: ;
;
ää; <
n_shared
åå 
.
åå 
Insert
åå 
(
åå  
(
åå  !
index
åå! &
+
åå' (
$num
åå) *
)
åå* +
%
åå, -
vc
åå. 0
,
åå0 1
-
åå2 3
$num
åå3 4
)
åå4 5
;
åå5 6
if
ææ 
(
ææ 

n_sharedUV
ææ 
!=
ææ !
null
ææ" &
)
ææ& '

n_sharedUV
ææ( 2
.
ææ2 3
Insert
ææ3 9
(
ææ9 :
(
ææ: ;
index
ææ; @
+
ææA B
$num
ææC D
)
ææD E
%
ææF G
vc
ææH J
,
ææJ K
-
ææL M
$num
ææM N
)
ææN O
;
ææO P
}
çç 
List
éé 
<
éé 
int
éé 
>
éé 
	triangles
éé 
;
éé  
try
ëë 
{
ìì 
Triangulation
íí 
.
íí !
TriangulateVertices
íí 1
(
íí1 2

n_vertices
íí2 <
,
íí< =
out
íí> A
	triangles
ííB K
,
ííK L
false
ííM R
)
ííR S
;
ííS T
}
îî 
catch
ïï 
{
ğğ 
Debug
ññ 
.
ññ 
Log
ññ 
(
ññ 
$str
ññ O
)
ññO P
;
ññP Q
return
òò 
null
òò 
;
òò 
}
óó 
FaceRebuildData
õõ 
data
õõ  
=
õõ! "
new
õõ# &
FaceRebuildData
õõ' 6
(
õõ6 7
)
õõ7 8
;
õõ8 9
data
÷÷ 
.
÷÷ 
face
÷÷ 
=
÷÷ 
new
÷÷ 
Face
÷÷  
(
÷÷  !
	triangles
÷÷! *
.
÷÷* +
ToArray
÷÷+ 2
(
÷÷2 3
)
÷÷3 4
,
÷÷4 5
face
÷÷6 :
.
÷÷: ;
submeshIndex
÷÷; G
,
÷÷G H
new
÷÷I L 
AutoUnwrapSettings
÷÷M _
(
÷÷_ `
face
÷÷` d
.
÷÷d e
uv
÷÷e g
)
÷÷g h
,
÷÷h i
face
÷÷j n
.
÷÷n o
smoothingGroup
÷÷o }
,
÷÷} ~
face÷÷ ƒ
.÷÷ƒ „
textureGroup÷÷„ 
,÷÷ ‘
-÷÷’ “
$num÷÷“ ”
,÷÷” •
face÷÷– š
.÷÷š ›
manualUV÷÷› £
)÷÷£ ¤
;÷÷¤ ¥
data
øø 
.
øø 
vertices
øø 
=
øø$ %

n_vertices
øø& 0
;
øø0 1
data
ùù 
.
ùù 
sharedIndexes
ùù 
=
ùù$ %
n_shared
ùù& .
;
ùù. /
data
úú 
.
úú 
sharedIndexesUV
úú  
=
úú$ %

n_sharedUV
úú& 0
;
úú0 1
FaceRebuildData
üü 
.
üü 
Apply
üü !
(
üü! "
new
üü" %
List
üü& *
<
üü* +
FaceRebuildData
üü+ :
>
üü: ;
(
üü; <
)
üü< =
{
üü> ?
data
üü@ D
}
üüE F
,
üüF G
vertices
ıı 
,
ıı 
faces
şş 
,
şş 
lookup
ÿÿ 
,
ÿÿ 
lookupUV
€€ 
)
€€ 
;
€€ 
var
‚‚ 
newFace
‚‚ 
=
‚‚ 
data
‚‚ 
.
‚‚ 
face
‚‚ #
;
‚‚# $
mesh
„„ 
.
„„ 
SetVertices
„„ 
(
„„ 
vertices
„„ %
)
„„% &
;
„„& '
mesh
…… 
.
…… 
faces
…… 
=
…… 
faces
…… 
;
…… 
mesh
†† 
.
†† 
SetSharedVertices
†† "
(
††" #
lookup
††# )
)
††) *
;
††* +
mesh
‡‡ 
.
‡‡ 
SetSharedTextures
‡‡ "
(
‡‡" #
lookupUV
‡‡# +
)
‡‡+ ,
;
‡‡, -
Vector3
ŠŠ 
oldNrm
ŠŠ 
=
ŠŠ 
Math
ŠŠ !
.
ŠŠ! "
Normal
ŠŠ" (
(
ŠŠ( )
mesh
ŠŠ) -
,
ŠŠ- .
face
ŠŠ/ 3
)
ŠŠ3 4
;
ŠŠ4 5
Vector3
‹‹ 
newNrm
‹‹ 
=
‹‹ 
Math
‹‹ !
.
‹‹! "
Normal
‹‹" (
(
‹‹( )
mesh
‹‹) -
,
‹‹- .
newFace
‹‹/ 6
)
‹‹6 7
;
‹‹7 8
if
 
(
 
Vector3
 
.
 
Dot
 
(
 
oldNrm
 "
,
" #
newNrm
$ *
)
* +
<
, -
$num
. /
)
/ 0
newFace
 
.
 
Reverse
 
(
  
)
  !
;
! "
mesh
 
.
 

DeleteFace
 
(
 
face
  
)
  !
;
! "
return
’’ 
newFace
’’ 
;
’’ 
}
““ 	
public
œœ 
static
œœ 
List
œœ 
<
œœ 
Edge
œœ 
>
œœ  "
AppendVerticesToEdge
œœ! 5
(
œœ5 6
this
œœ6 :
ProBuilderMesh
œœ; I
mesh
œœJ N
,
œœN O
Edge
œœP T
edge
œœU Y
,
œœY Z
int
œœ[ ^
count
œœ_ d
)
œœd e
{
 	
return
 "
AppendVerticesToEdge
 '
(
' (
mesh
( ,
,
, -
new
. 1
Edge
2 6
[
6 7
]
7 8
{
9 :
edge
; ?
}
@ A
,
A B
count
C H
)
H I
;
I J
}
ŸŸ 	
public
¨¨ 
static
¨¨ 
List
¨¨ 
<
¨¨ 
Edge
¨¨ 
>
¨¨  "
AppendVerticesToEdge
¨¨! 5
(
¨¨5 6
this
¨¨6 :
ProBuilderMesh
¨¨; I
mesh
¨¨J N
,
¨¨N O
IList
¨¨P U
<
¨¨U V
Edge
¨¨V Z
>
¨¨Z [
edges
¨¨\ a
,
¨¨a b
int
¨¨c f
count
¨¨g l
)
¨¨l m
{
©© 	
if
ªª 
(
ªª 
mesh
ªª 
==
ªª 
null
ªª 
)
ªª 
throw
«« 
new
«« #
ArgumentNullException
«« /
(
««/ 0
$str
««0 6
)
««6 7
;
««7 8
if
­­ 
(
­­ 
edges
­­ 
==
­­ 
null
­­ 
)
­­ 
throw
®® 
new
®® #
ArgumentNullException
®® /
(
®®/ 0
$str
®®0 7
)
®®7 8
;
®®8 9
if
°° 
(
°° 
count
°° 
<
°° 
$num
°° 
||
°° 
count
°° "
>
°°# $
$num
°°% (
)
°°( )
{
±± 
Log
²² 
.
²² 
Error
²² 
(
²² 
$str
²² U
)
²²U V
;
²²V W
return
³³ 
null
³³ 
;
³³ 
}
´´ 
List
¶¶ 
<
¶¶ 
Vertex
¶¶ 
>
¶¶ 
vertices
¶¶ !
=
¶¶" #
new
¶¶$ '
List
¶¶( ,
<
¶¶, -
Vertex
¶¶- 3
>
¶¶3 4
(
¶¶4 5
mesh
¶¶5 9
.
¶¶9 :
GetVertices
¶¶: E
(
¶¶E F
)
¶¶F G
)
¶¶G H
;
¶¶H I

Dictionary
·· 
<
·· 
int
·· 
,
·· 
int
·· 
>
··  
lookup
··! '
=
··( )
mesh
··* .
.
··. / 
sharedVertexLookup
··/ A
;
··A B

Dictionary
¸¸ 
<
¸¸ 
int
¸¸ 
,
¸¸ 
int
¸¸ 
>
¸¸  
lookupUV
¸¸! )
=
¸¸* +
mesh
¸¸, 0
.
¸¸0 1!
sharedTextureLookup
¸¸1 D
;
¸¸D E
List
¹¹ 
<
¹¹ 
int
¹¹ 
>
¹¹ 
indexesToDelete
¹¹ %
=
¹¹& '
new
¹¹( +
List
¹¹, 0
<
¹¹0 1
int
¹¹1 4
>
¹¹4 5
(
¹¹5 6
)
¹¹6 7
;
¹¹7 8
IEnumerable
ºº 
<
ºº 
Edge
ºº 
>
ºº 
commonEdges
ºº )
=
ºº* +
EdgeUtility
ºº, 7
.
ºº7 8(
GetSharedVertexHandleEdges
ºº8 R
(
ººR S
mesh
ººS W
,
ººW X
edges
ººY ^
)
ºº^ _
;
ºº_ `
List
»» 
<
»» 
Edge
»» 
>
»» 
distinctEdges
»» $
=
»»% &
commonEdges
»»' 2
.
»»2 3
Distinct
»»3 ;
(
»»; <
)
»»< =
.
»»= >
ToList
»»> D
(
»»D E
)
»»E F
;
»»F G

Dictionary
½½ 
<
½½ 
Face
½½ 
,
½½ 
FaceRebuildData
½½ ,
>
½½, -
modifiedFaces
½½. ;
=
½½< =
new
½½> A

Dictionary
½½B L
<
½½L M
Face
½½M Q
,
½½Q R
FaceRebuildData
½½S b
>
½½b c
(
½½c d
)
½½d e
;
½½e f
int
¿¿ (
originalSharedIndexesCount
¿¿ *
=
¿¿+ ,
lookup
¿¿- 3
.
¿¿3 4
Count
¿¿4 9
(
¿¿9 :
)
¿¿: ;
;
¿¿; <
int
ÀÀ  
sharedIndexesCount
ÀÀ "
=
ÀÀ# $(
originalSharedIndexesCount
ÀÀ% ?
;
ÀÀ? @
foreach
ÂÂ 
(
ÂÂ 
Edge
ÂÂ 
edge
ÂÂ 
in
ÂÂ !
distinctEdges
ÂÂ" /
)
ÂÂ/ 0
{
ÃÃ 
Edge
ÄÄ 
	localEdge
ÄÄ 
=
ÄÄ  
EdgeUtility
ÄÄ! ,
.
ÄÄ, -,
GetEdgeWithSharedVertexHandles
ÄÄ- K
(
ÄÄK L
mesh
ÄÄL P
,
ÄÄP Q
edge
ÄÄR V
)
ÄÄV W
;
ÄÄW X
List
ÇÇ 
<
ÇÇ 
Vertex
ÇÇ 
>
ÇÇ 
verticesToAppend
ÇÇ -
=
ÇÇ. /
new
ÇÇ0 3
List
ÇÇ4 8
<
ÇÇ8 9
Vertex
ÇÇ9 ?
>
ÇÇ? @
(
ÇÇ@ A
count
ÇÇA F
)
ÇÇF G
;
ÇÇG H
for
ÉÉ 
(
ÉÉ 
int
ÉÉ 
i
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
;
ÉÉ 
i
ÉÉ  !
<
ÉÉ" #
count
ÉÉ$ )
;
ÉÉ) *
i
ÉÉ+ ,
++
ÉÉ, .
)
ÉÉ. /
verticesToAppend
ÊÊ $
.
ÊÊ$ %
Add
ÊÊ% (
(
ÊÊ( )
Vertex
ÊÊ) /
.
ÊÊ/ 0
Mix
ÊÊ0 3
(
ÊÊ3 4
vertices
ÊÊ4 <
[
ÊÊ< =
	localEdge
ÊÊ= F
.
ÊÊF G
a
ÊÊG H
]
ÊÊH I
,
ÊÊI J
vertices
ÊÊK S
[
ÊÊS T
	localEdge
ÊÊT ]
.
ÊÊ] ^
b
ÊÊ^ _
]
ÊÊ_ `
,
ÊÊ` a
(
ÊÊb c
i
ÊÊc d
+
ÊÊe f
$num
ÊÊg h
)
ÊÊh i
/
ÊÊj k
(
ÊÊl m
(
ÊÊm n
float
ÊÊn s
)
ÊÊs t
count
ÊÊt y
+
ÊÊz {
$num
ÊÊ| }
)
ÊÊ} ~
)
ÊÊ~ 
)ÊÊ €
;ÊÊ€ 
List
ÌÌ 
<
ÌÌ 
SimpleTuple
ÌÌ  
<
ÌÌ  !
Face
ÌÌ! %
,
ÌÌ% &
Edge
ÌÌ' +
>
ÌÌ+ ,
>
ÌÌ, -
adjacentFaces
ÌÌ. ;
=
ÌÌ< =
ElementSelection
ÌÌ> N
.
ÌÌN O
GetNeighborFaces
ÌÌO _
(
ÌÌ_ `
mesh
ÌÌ` d
,
ÌÌd e
	localEdge
ÌÌf o
)
ÌÌo p
;
ÌÌp q
foreach
ÏÏ 
(
ÏÏ 
SimpleTuple
ÏÏ $
<
ÏÏ$ %
Face
ÏÏ% )
,
ÏÏ) *
Edge
ÏÏ+ /
>
ÏÏ/ 0
tup
ÏÏ1 4
in
ÏÏ5 7
adjacentFaces
ÏÏ8 E
)
ÏÏE F
{
ĞĞ 
Face
ÑÑ 
face
ÑÑ 
=
ÑÑ 
tup
ÑÑ  #
.
ÑÑ# $
item1
ÑÑ$ )
;
ÑÑ) *
FaceRebuildData
ÓÓ #
data
ÓÓ$ (
;
ÓÓ( )
if
ÕÕ 
(
ÕÕ 
!
ÕÕ 
modifiedFaces
ÕÕ &
.
ÕÕ& '
TryGetValue
ÕÕ' 2
(
ÕÕ2 3
face
ÕÕ3 7
,
ÕÕ7 8
out
ÕÕ9 <
data
ÕÕ= A
)
ÕÕA B
)
ÕÕB C
{
ÖÖ 
data
×× 
=
×× 
new
×× "
FaceRebuildData
××# 2
(
××2 3
)
××3 4
;
××4 5
data
ØØ 
.
ØØ 
face
ØØ !
=
ØØ" #
new
ØØ$ '
Face
ØØ( ,
(
ØØ, -
new
ØØ- 0
int
ØØ1 4
[
ØØ4 5
$num
ØØ5 6
]
ØØ6 7
,
ØØ7 8
face
ØØ9 =
.
ØØ= >
submeshIndex
ØØ> J
,
ØØJ K
new
ØØL O 
AutoUnwrapSettings
ØØP b
(
ØØb c
face
ØØc g
.
ØØg h
uv
ØØh j
)
ØØj k
,
ØØk l
face
ØØm q
.
ØØq r
smoothingGroupØØr €
,ØØ€ 
faceØØ‚ †
.ØØ† ‡
textureGroupØØ‡ “
,ØØ“ ”
-ØØ• –
$numØØ– —
,ØØ— ˜
faceØØ™ 
.ØØ 
manualUVØØ ¦
)ØØ¦ §
;ØØ§ ¨
data
ÙÙ 
.
ÙÙ 
vertices
ÙÙ %
=
ÙÙ& '
new
ÙÙ( +
List
ÙÙ, 0
<
ÙÙ0 1
Vertex
ÙÙ1 7
>
ÙÙ7 8
(
ÙÙ8 9
ArrayUtility
ÙÙ9 E
.
ÙÙE F
ValuesWithIndexes
ÙÙF W
(
ÙÙW X
vertices
ÙÙX `
,
ÙÙ` a
face
ÙÙb f
.
ÙÙf g%
distinctIndexesInternal
ÙÙg ~
)
ÙÙ~ 
)ÙÙ €
;ÙÙ€ 
data
ÚÚ 
.
ÚÚ 
sharedIndexes
ÚÚ *
=
ÚÚ+ ,
new
ÚÚ- 0
List
ÚÚ1 5
<
ÚÚ5 6
int
ÚÚ6 9
>
ÚÚ9 :
(
ÚÚ: ;
)
ÚÚ; <
;
ÚÚ< =
data
ÛÛ 
.
ÛÛ 
sharedIndexesUV
ÛÛ ,
=
ÛÛ- .
new
ÛÛ/ 2
List
ÛÛ3 7
<
ÛÛ7 8
int
ÛÛ8 ;
>
ÛÛ; <
(
ÛÛ< =
)
ÛÛ= >
;
ÛÛ> ?
foreach
İİ 
(
İİ  !
int
İİ! $
i
İİ% &
in
İİ' )
face
İİ* .
.
İİ. /%
distinctIndexesInternal
İİ/ F
)
İİF G
{
ŞŞ 
int
ßß 
shared
ßß  &
;
ßß& '
if
áá 
(
áá  
lookup
áá  &
.
áá& '
TryGetValue
áá' 2
(
áá2 3
i
áá3 4
,
áá4 5
out
áá6 9
shared
áá: @
)
áá@ A
)
ááA B
data
ââ  $
.
ââ$ %
sharedIndexes
ââ% 2
.
ââ2 3
Add
ââ3 6
(
ââ6 7
shared
ââ7 =
)
ââ= >
;
ââ> ?
if
ää 
(
ää  
lookupUV
ää  (
.
ää( )
TryGetValue
ää) 4
(
ää4 5
i
ää5 6
,
ää6 7
out
ää8 ;
shared
ää< B
)
ääB C
)
ääC D
data
åå  $
.
åå$ %
sharedIndexesUV
åå% 4
.
åå4 5
Add
åå5 8
(
åå8 9
shared
åå9 ?
)
åå? @
;
åå@ A
}
ææ 
indexesToDelete
èè '
.
èè' (
AddRange
èè( 0
(
èè0 1
face
èè1 5
.
èè5 6%
distinctIndexesInternal
èè6 M
)
èèM N
;
èèN O
modifiedFaces
êê %
.
êê% &
Add
êê& )
(
êê) *
face
êê* .
,
êê. /
data
êê0 4
)
êê4 5
;
êê5 6
}
ëë 
data
íí 
.
íí 
vertices
íí !
.
íí! "
AddRange
íí" *
(
íí* +
verticesToAppend
íí+ ;
)
íí; <
;
íí< =
for
ïï 
(
ïï 
int
ïï 
i
ïï 
=
ïï  
$num
ïï! "
;
ïï" #
i
ïï$ %
<
ïï& '
count
ïï( -
;
ïï- .
i
ïï/ 0
++
ïï0 2
)
ïï2 3
{
ğğ 
data
ññ 
.
ññ 
sharedIndexes
ññ *
.
ññ* +
Add
ññ+ .
(
ññ. / 
sharedIndexesCount
ññ/ A
+
ññB C
i
ññD E
)
ññE F
;
ññF G
data
òò 
.
òò 
sharedIndexesUV
òò ,
.
òò, -
Add
òò- 0
(
òò0 1
-
òò1 2
$num
òò2 3
)
òò3 4
;
òò4 5
}
óó 
}
ôô  
sharedIndexesCount
öö "
+=
öö# %
count
öö& +
;
öö+ ,
}
÷÷ 
List
úú 
<
úú 
Face
úú 
>
úú 
dic_face
úú 
=
úú  !
modifiedFaces
úú" /
.
úú/ 0
Keys
úú0 4
.
úú4 5
ToList
úú5 ;
(
úú; <
)
úú< =
;
úú= >
List
ûû 
<
ûû 
FaceRebuildData
ûû  
>
ûû  !
dic_data
ûû" *
=
ûû+ ,
modifiedFaces
ûû- :
.
ûû: ;
Values
ûû; A
.
ûûA B
ToList
ûûB H
(
ûûH I
)
ûûI J
;
ûûJ K
List
üü 
<
üü 

EdgeLookup
üü 
>
üü 
appendedEdges
üü *
=
üü+ ,
new
üü- 0
List
üü1 5
<
üü5 6

EdgeLookup
üü6 @
>
üü@ A
(
üüA B
)
üüB C
;
üüC D
for
şş 
(
şş 
int
şş 
i
şş 
=
şş 
$num
şş 
;
şş 
i
şş 
<
şş 
dic_face
şş  (
.
şş( )
Count
şş) .
;
şş. /
i
şş0 1
++
şş1 3
)
şş3 4
{
ÿÿ 
Face
€€ 
face
€€ 
=
€€ 
dic_face
€€ $
[
€€$ %
i
€€% &
]
€€& '
;
€€' (
FaceRebuildData
 
data
  $
=
% &
dic_data
' /
[
/ 0
i
0 1
]
1 2
;
2 3
Vector3
ƒƒ 
nrm
ƒƒ 
=
ƒƒ 
Math
ƒƒ "
.
ƒƒ" #
Normal
ƒƒ# )
(
ƒƒ) *
mesh
ƒƒ* .
,
ƒƒ. /
face
ƒƒ0 4
)
ƒƒ4 5
;
ƒƒ5 6
Vector2
„„ 
[
„„ 
]
„„ 

projection
„„ $
=
„„% &

Projection
„„' 1
.
„„1 2
PlanarProject
„„2 ?
(
„„? @
data
„„@ D
.
„„D E
vertices
„„E M
.
„„M N
Select
„„N T
(
„„T U
x
„„U V
=>
„„W Y
x
„„Z [
.
„„[ \
position
„„\ d
)
„„d e
.
„„e f
ToArray
„„f m
(
„„m n
)
„„n o
,
„„o p
null
„„q u
,
„„u v
nrm
„„w z
)
„„z {
;
„„{ |
int
†† 
vertexCount
†† 
=
††  !
vertices
††" *
.
††* +
Count
††+ 0
;
††0 1
List
‰‰ 
<
‰‰ 
int
‰‰ 
>
‰‰ 
indexes
‰‰ !
;
‰‰! "
if
‹‹ 
(
‹‹ 
Triangulation
‹‹ !
.
‹‹! " 
SortAndTriangulate
‹‹" 4
(
‹‹4 5

projection
‹‹5 ?
,
‹‹? @
out
‹‹A D
indexes
‹‹E L
)
‹‹L M
)
‹‹M N
data
ŒŒ 
.
ŒŒ 
face
ŒŒ 
.
ŒŒ 
indexesInternal
ŒŒ -
=
ŒŒ. /
indexes
ŒŒ0 7
.
ŒŒ7 8
ToArray
ŒŒ8 ?
(
ŒŒ? @
)
ŒŒ@ A
;
ŒŒA B
else
 
continue
 
;
 
data
 
.
 
face
 
.
 
ShiftIndexes
 &
(
& '
vertexCount
' 2
)
2 3
;
3 4
face
‘‘ 
.
‘‘ 
CopyFrom
‘‘ 
(
‘‘ 
data
‘‘ "
.
‘‘" #
face
‘‘# '
)
‘‘' (
;
‘‘( )
for
““ 
(
““ 
int
““ 
n
““ 
=
““ 
$num
““ 
;
““ 
n
““  !
<
““" #
data
““$ (
.
““( )
vertices
““) 1
.
““1 2
Count
““2 7
;
““7 8
n
““9 :
++
““: <
)
““< =
lookup
”” 
.
”” 
Add
”” 
(
”” 
vertexCount
”” *
+
””+ ,
n
””- .
,
””. /
data
””0 4
.
””4 5
sharedIndexes
””5 B
[
””B C
n
””C D
]
””D E
)
””E F
;
””F G
if
–– 
(
–– 
data
–– 
.
–– 
sharedIndexesUV
–– (
.
––( )
Count
––) .
==
––/ 1
data
––2 6
.
––6 7
vertices
––7 ?
.
––? @
Count
––@ E
)
––E F
{
—— 
for
˜˜ 
(
˜˜ 
int
˜˜ 
n
˜˜ 
=
˜˜  
$num
˜˜! "
;
˜˜" #
n
˜˜$ %
<
˜˜& '
data
˜˜( ,
.
˜˜, -
vertices
˜˜- 5
.
˜˜5 6
Count
˜˜6 ;
;
˜˜; <
n
˜˜= >
++
˜˜> @
)
˜˜@ A
lookupUV
™™  
.
™™  !
Add
™™! $
(
™™$ %
vertexCount
™™% 0
+
™™1 2
n
™™3 4
,
™™4 5
data
™™6 :
.
™™: ;
sharedIndexesUV
™™; J
[
™™J K
n
™™K L
]
™™L M
)
™™M N
;
™™N O
}
šš 
vertices
œœ 
.
œœ 
AddRange
œœ !
(
œœ! "
data
œœ" &
.
œœ& '
vertices
œœ' /
)
œœ/ 0
;
œœ0 1
foreach
 
(
 
Edge
 
e
 
in
  "
face
# '
.
' (
edgesInternal
( 5
)
5 6
{
ŸŸ 

EdgeLookup
   
el
   !
=
  " #
new
  $ '

EdgeLookup
  ( 2
(
  2 3
new
  3 6
Edge
  7 ;
(
  ; <
lookup
  < B
[
  B C
e
  C D
.
  D E
a
  E F
]
  F G
,
  G H
lookup
  I O
[
  O P
e
  P Q
.
  Q R
b
  R S
]
  S T
)
  T U
,
  U V
e
  W X
)
  X Y
;
  Y Z
if
¢¢ 
(
¢¢ 
el
¢¢ 
.
¢¢ 
common
¢¢ !
.
¢¢! "
a
¢¢" #
>=
¢¢$ &(
originalSharedIndexesCount
¢¢' A
||
¢¢B D
el
¢¢E G
.
¢¢G H
common
¢¢H N
.
¢¢N O
b
¢¢O P
>=
¢¢Q S(
originalSharedIndexesCount
¢¢T n
)
¢¢n o
appendedEdges
££ %
.
££% &
Add
££& )
(
££) *
el
££* ,
)
££, -
;
££- .
}
¤¤ 
}
¥¥ 
indexesToDelete
§§ 
=
§§ 
indexesToDelete
§§ -
.
§§- .
Distinct
§§. 6
(
§§6 7
)
§§7 8
.
§§8 9
ToList
§§9 ?
(
§§? @
)
§§@ A
;
§§A B
int
¨¨ 
delCount
¨¨ 
=
¨¨ 
indexesToDelete
¨¨ *
.
¨¨* +
Count
¨¨+ 0
;
¨¨0 1
var
ªª 
newEdges
ªª 
=
ªª 
appendedEdges
ªª (
.
ªª( )
Distinct
ªª) 1
(
ªª1 2
)
ªª2 3
.
ªª3 4
Select
ªª4 :
(
ªª: ;
x
ªª; <
=>
ªª= ?
x
ªª@ A
.
ªªA B
local
ªªB G
-
ªªH I
delCount
ªªJ R
)
ªªR S
.
ªªS T
ToList
ªªT Z
(
ªªZ [
)
ªª[ \
;
ªª\ ]
mesh
¬¬ 
.
¬¬ 
SetVertices
¬¬ 
(
¬¬ 
vertices
¬¬ %
)
¬¬% &
;
¬¬& '
mesh
­­ 
.
­­ 
SetSharedVertices
­­ "
(
­­" #
lookup
­­# )
)
­­) *
;
­­* +
mesh
®® 
.
®® 
SetSharedTextures
®® "
(
®®" #
lookupUV
®®# +
)
®®+ ,
;
®®, -
mesh
¯¯ 
.
¯¯ 
DeleteVertices
¯¯ 
(
¯¯  
indexesToDelete
¯¯  /
)
¯¯/ 0
;
¯¯0 1
return
±± 
newEdges
±± 
;
±± 
}
²² 	
}
³³ 
}´´ Õ
›D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SelectionModifierBehaviour.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
public 
enum %
SelectionModifierBehavior &
{ 
Add 
, 
Subtract 

,
 

Difference 
} 
} Ë
œD:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\SelectionPickerRendererHDRP.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
internal 
partial 
class #
SelectionPickerRenderer 2
{ 
internal 
class '
SelectionPickerRendererHDRP 2
:3 4$
ISelectionPickerRenderer5 M
{ 	
public

 
	Texture2D

 
RenderLookupTexture

 0
(

0 1
Camera 
camera 
, 
Shader 
shader 
, 
string 
tag 
, 
int 
width 
= 
- 
$num 
, 
int 
height 
= 
- 
$num 
)  
{ 
returnII 
nullII 
;II 
}KK 
}cc 
}dd 
}ee Ü
‹D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\Core\MeshHandle.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
{ 
sealed 

class 

MeshHandle 
{ 
	Transform 
m_Transform 
; 
Mesh		 
m_Mesh		 
;		 
public 
Mesh 
mesh 
{ 	
get 
{ 
return 
m_Mesh 
;  
}! "
} 	
public 

MeshHandle 
( 
	Transform #
	transform$ -
,- .
Mesh/ 3
mesh4 8
)8 9
{ 	
m_Transform 
= 
	transform #
;# $
m_Mesh 
= 
mesh 
; 
} 	
public 
void 
DrawMeshNow 
(  
int  #
submeshIndex$ 0
)0 1
{ 	
if 
( 
m_Transform 
== 
null #
||$ &
m_Mesh' -
==. 0
null1 5
)5 6
return 
; 
Graphics 
. 
DrawMeshNow  
(  !
m_Mesh! '
,' (
m_Transform) 4
.4 5
localToWorldMatrix5 G
,G H
submeshIndexI U
)U V
;V W
} 	
} 
} z
™D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\DeleteElements.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
public 

static 
class 
DeleteElements &
{ 
public 
static 
void 
DeleteVertices )
() *
this* .
ProBuilderMesh/ =
mesh> B
,B C
IEnumerableD O
<O P
intP S
>S T
distinctIndexesU d
)d e
{ 	
if 
( 
mesh 
== 
null 
) 
throw 
new !
ArgumentNullException /
(/ 0
$str0 6
)6 7
;7 8
if 
( 
distinctIndexes 
==  "
null# '
||( *
!+ ,
distinctIndexes, ;
.; <
Any< ?
(? @
)@ A
)A B
return 
; 
Vertex 
[ 
] 
vertices 
= 
mesh  $
.$ %
GetVertices% 0
(0 1
)1 2
;2 3
int 
originalVertexCount #
=$ %
vertices& .
.. /
Length/ 5
;5 6
int 
[ 
] 
offset 
= 
new 
int "
[" #
originalVertexCount# 6
]6 7
;7 8
List!! 
<!! 
int!! 
>!! 
sorted!! 
=!! 
new!! "
List!!# '
<!!' (
int!!( +
>!!+ ,
(!!, -
distinctIndexes!!- <
)!!< =
;!!= >
sorted## 
.## 
Sort## 
(## 
)## 
;## 
vertices%% 
=%% 
vertices%% 
.%%  
SortedRemoveAt%%  .
(%%. /
sorted%%/ 5
)%%5 6
;%%6 7
for(( 
((( 
int(( 
i(( 
=(( 
$num(( 
;(( 
i(( 
<(( 
originalVertexCount((  3
;((3 4
i((5 6
++((6 8
)((8 9
offset)) 
[)) 
i)) 
])) 
=)) 
ArrayUtility)) (
.))( )$
NearestIndexPriorToValue))) A
())A B
sorted))B H
,))H I
i))J K
)))K L
+))M N
$num))O P
;))P Q
foreach++ 
(++ 
Face++ 
face++ 
in++ !
mesh++" &
.++& '
facesInternal++' 4
)++4 5
{,, 
int-- 
[-- 
]-- 
indexes-- 
=-- 
face--  $
.--$ %
indexesInternal--% 4
;--4 5
for// 
(// 
int// 
i// 
=// 
$num// 
;// 
i//  !
<//" #
indexes//$ +
.//+ ,
Length//, 2
;//2 3
i//4 5
++//5 7
)//7 8
indexes00 
[00 
i00 
]00 
-=00 !
offset00" (
[00( )
indexes00) 0
[000 1
i001 2
]002 3
]003 4
;004 5
face22 
.22 
InvalidateCache22 $
(22$ %
)22% &
;22& '
}33 
var66 
common66 
=66 
mesh66 
.66 
sharedVertexLookup66 0
.660 1
Where661 6
(666 7
x667 8
=>669 ;
sorted66< B
.66B C
BinarySearch66C O
(66O P
x66P Q
.66Q R
Key66R U
)66U V
<66W X
$num66Y Z
)66Z [
.66[ \
Select66\ b
(66b c
y66c d
=>66e g
new66h k
KeyValuePair66l x
<66x y
int66y |
,66| }
int	66~ 
>
66 ‚
(
66‚ ƒ
y
66ƒ „
.
66„ …
Key
66… ˆ
-
66‰ Š
offset
66‹ ‘
[
66‘ ’
y
66’ “
.
66“ ”
Key
66” —
]
66— ˜
,
66˜ ™
y
66š ›
.
66› œ
Value
66œ ¡
)
66¡ ¢
)
66¢ £
;
66£ ¤
var77 
commonUV77 
=77 
mesh77 
.77  
sharedTextureLookup77  3
.773 4
Where774 9
(779 :
x77: ;
=>77< >
sorted77? E
.77E F
BinarySearch77F R
(77R S
x77S T
.77T U
Key77U X
)77X Y
<77Z [
$num77\ ]
)77] ^
.77^ _
Select77_ e
(77e f
y77f g
=>77h j
new77k n
KeyValuePair77o {
<77{ |
int77| 
,	77 €
int
77 „
>
77„ …
(
77… †
y
77† ‡
.
77‡ ˆ
Key
77ˆ ‹
-
77Œ 
offset
77 ”
[
77” •
y
77• –
.
77– —
Key
77— š
]
77š ›
,
77› œ
y
77 
.
77 Ÿ
Value
77Ÿ ¤
)
77¤ ¥
)
77¥ ¦
;
77¦ §
mesh99 
.99 
SetVertices99 
(99 
vertices99 %
)99% &
;99& '
mesh:: 
.:: 
SetSharedVertices:: "
(::" #
common::# )
)::) *
;::* +
mesh;; 
.;; 
SetSharedTextures;; "
(;;" #
commonUV;;# +
);;+ ,
;;;, -
}<< 	
publicDD 
staticDD 
intDD 
[DD 
]DD 

DeleteFaceDD &
(DD& '
thisDD' +
ProBuilderMeshDD, :
meshDD; ?
,DD? @
FaceDDA E
faceDDF J
)DDJ K
{EE 	
returnFF 
DeleteFacesFF 
(FF 
meshFF #
,FF# $
newFF% (
FaceFF) -
[FF- .
]FF. /
{FF0 1
faceFF2 6
}FF7 8
)FF8 9
;FF9 :
}GG 	
publicOO 
staticOO 
intOO 
[OO 
]OO 
DeleteFacesOO '
(OO' (
thisOO( ,
ProBuilderMeshOO- ;
meshOO< @
,OO@ A
IEnumerableOOB M
<OOM N
FaceOON R
>OOR S
facesOOT Y
)OOY Z
{PP 	
returnQQ 
DeleteFacesQQ 
(QQ 
meshQQ #
,QQ# $
facesQQ% *
.QQ* +
SelectQQ+ 1
(QQ1 2
xQQ2 3
=>QQ4 6
SystemQQ7 =
.QQ= >
ArrayQQ> C
.QQC D
IndexOfQQD K
(QQK L
meshQQL P
.QQP Q
facesInternalQQQ ^
,QQ^ _
xQQ` a
)QQa b
)QQb c
.QQc d
ToListQQd j
(QQj k
)QQk l
)QQl m
;QQm n
}RR 	
publicZZ 
staticZZ 
intZZ 
[ZZ 
]ZZ 
DeleteFacesZZ '
(ZZ' (
thisZZ( ,
ProBuilderMeshZZ- ;
meshZZ< @
,ZZ@ A
IListZZB G
<ZZG H
intZZH K
>ZZK L
faceIndexesZZM X
)ZZX Y
{[[ 	
if\\ 
(\\ 
mesh\\ 
==\\ 
null\\ 
)\\ 
throw]] 
new]] !
ArgumentNullException]] /
(]]/ 0
$str]]0 6
)]]6 7
;]]7 8
if__ 
(__ 
faceIndexes__ 
==__ 
null__ #
)__# $
throw`` 
new`` !
ArgumentNullException`` /
(``/ 0
$str``0 =
)``= >
;``> ?
Facebb 
[bb 
]bb 
facesbb 
=bb 
newbb 
Facebb #
[bb# $
faceIndexesbb$ /
.bb/ 0
Countbb0 5
]bb5 6
;bb6 7
fordd 
(dd 
intdd 
idd 
=dd 
$numdd 
;dd 
idd 
<dd 
facesdd  %
.dd% &
Lengthdd& ,
;dd, -
idd. /
++dd/ 1
)dd1 2
facesee 
[ee 
iee 
]ee 
=ee 
meshee 
.ee  
facesInternalee  -
[ee- .
faceIndexesee. 9
[ee9 :
iee: ;
]ee; <
]ee< =
;ee= >
Listgg 
<gg 
intgg 
>gg 
indexesToRemovegg %
=gg& '
facesgg( -
.gg- .

SelectManygg. 8
(gg8 9
xgg9 :
=>gg; =
xgg> ?
.gg? @#
distinctIndexesInternalgg@ W
)ggW X
.ggX Y
DistinctggY a
(gga b
)ggb c
.ggc d
ToListggd j
(ggj k
)ggk l
;ggl m
indexesToRemovehh 
.hh 
Sorthh  
(hh  !
)hh! "
;hh" #
intjj 
vertexCountjj 
=jj 
meshjj "
.jj" #
positionsInternaljj# 4
.jj4 5
Lengthjj5 ;
;jj; <
Facell 
[ll 
]ll 
nFacesll 
=ll 
meshll  
.ll  !
facesInternalll! .
.ll. /
RemoveAtll/ 7
(ll7 8
faceIndexesll8 C
)llC D
;llD E
varmm 
verticesmm 
=mm 
meshmm 
.mm  
GetVerticesmm  +
(mm+ ,
)mm, -
.mm- .
SortedRemoveAtmm. <
(mm< =
indexesToRemovemm= L
)mmL M
;mmM N

Dictionaryoo 
<oo 
intoo 
,oo 
intoo 
>oo  
shiftmapoo! )
=oo* +
newoo, /

Dictionaryoo0 :
<oo: ;
intoo; >
,oo> ?
intoo@ C
>ooC D
(ooD E
)ooE F
;ooF G
forqq 
(qq 
varqq 
iqq 
=qq 
$numqq 
;qq 
iqq 
<qq 
vertexCountqq  +
;qq+ ,
iqq- .
++qq. 0
)qq0 1
shiftmaprr 
.rr 
Addrr 
(rr 
irr 
,rr 
ArrayUtilityrr  ,
.rr, -$
NearestIndexPriorToValuerr- E
<rrE F
intrrF I
>rrI J
(rrJ K
indexesToRemoverrK Z
,rrZ [
irr\ ]
)rr] ^
+rr_ `
$numrra b
)rrb c
;rrc d
foruu 
(uu 
varuu 
iuu 
=uu 
$numuu 
;uu 
iuu 
<uu 
nFacesuu  &
.uu& '
Lengthuu' -
;uu- .
iuu/ 0
++uu0 2
)uu2 3
{vv 
intww 
[ww 
]ww 
trisww 
=ww 
nFacesww #
[ww# $
iww$ %
]ww% &
.ww& '
indexesInternalww' 6
;ww6 7
foryy 
(yy 
varyy 
nyy 
=yy 
$numyy 
;yy 
nyy  !
<yy" #
trisyy$ (
.yy( )
Lengthyy) /
;yy/ 0
nyy1 2
++yy2 4
)yy4 5
triszz 
[zz 
nzz 
]zz 
-=zz 
shiftmapzz '
[zz' (
triszz( ,
[zz, -
nzz- .
]zz. /
]zz/ 0
;zz0 1
nFaces|| 
[|| 
i|| 
]|| 
.|| 
indexesInternal|| )
=||* +
tris||, 0
;||0 1
}}} 
mesh 
. 
SetVertices 
( 
vertices %
)% &
;& '
mesh
€€ 
.
€€ $
sharedVerticesInternal
€€ '
=
€€( )
SharedVertex
€€* 6
.
€€6 7"
SortedRemoveAndShift
€€7 K
(
€€K L
mesh
€€L P
.
€€P Q 
sharedVertexLookup
€€Q c
,
€€c d
indexesToRemove
€€e t
)
€€t u
;
€€u v
mesh
 
.
 
sharedTextures
 
=
  !
SharedVertex
" .
.
. /"
SortedRemoveAndShift
/ C
(
C D
mesh
D H
.
H I!
sharedTextureLookup
I \
,
\ ]
indexesToRemove
^ m
)
m n
;
n o
mesh
‚‚ 
.
‚‚ 
facesInternal
‚‚ 
=
‚‚  
nFaces
‚‚! '
;
‚‚' (
int
ƒƒ 
[
ƒƒ 
]
ƒƒ 
array
ƒƒ 
=
ƒƒ 
indexesToRemove
ƒƒ )
.
ƒƒ) *
ToArray
ƒƒ* 1
(
ƒƒ1 2
)
ƒƒ2 3
;
ƒƒ3 4
return
…… 
array
…… 
;
…… 
}
†† 	
[
ˆˆ 	
Obsolete
ˆˆ	 
(
ˆˆ 
$str
ˆˆ @
)
ˆˆ@ A
]
ˆˆA B
[
‰‰ 	
EditorBrowsable
‰‰	 
(
‰‰ "
EditorBrowsableState
‰‰ -
.
‰‰- .
Never
‰‰. 3
)
‰‰3 4
]
‰‰4 5
public
ŠŠ 
static
ŠŠ 
int
ŠŠ 
[
ŠŠ 
]
ŠŠ '
RemoveDegenerateTriangles
ŠŠ 5
(
ŠŠ5 6
this
ŠŠ6 :
ProBuilderMesh
ŠŠ; I
mesh
ŠŠJ N
)
ŠŠN O
{
‹‹ 	
List
ŒŒ 
<
ŒŒ 
int
ŒŒ 
>
ŒŒ 
removed
ŒŒ 
=
ŒŒ 
new
ŒŒ  #
List
ŒŒ$ (
<
ŒŒ( )
int
ŒŒ) ,
>
ŒŒ, -
(
ŒŒ- .
)
ŒŒ. /
;
ŒŒ/ 0
MeshValidation
 
.
 '
RemoveDegenerateTriangles
 4
(
4 5
mesh
5 9
,
9 :
removed
; B
)
B C
;
C D
return
 
removed
 
.
 
ToArray
 "
(
" #
)
# $
;
$ %
}
 	
[
‘‘ 	
Obsolete
‘‘	 
(
‘‘ 
$str
‘‘ ;
)
‘‘; <
]
‘‘< =
[
’’ 	
EditorBrowsable
’’	 
(
’’ "
EditorBrowsableState
’’ -
.
’’- .
Never
’’. 3
)
’’3 4
]
’’4 5
public
““ 
static
““ 
int
““ 
[
““ 
]
““ "
RemoveUnusedVertices
““ 0
(
““0 1
this
““1 5
ProBuilderMesh
““6 D
mesh
““E I
)
““I J
{
”” 	
List
•• 
<
•• 
int
•• 
>
•• 
removed
•• 
=
•• 
new
••  #
List
••$ (
<
••( )
int
••) ,
>
••, -
(
••- .
)
••. /
;
••/ 0
MeshValidation
–– 
.
–– "
RemoveUnusedVertices
–– /
(
––/ 0
mesh
––0 4
,
––4 5
removed
––6 =
)
––= >
;
––> ?
return
—— 
removed
—— 
.
—— 
ToArray
—— "
(
——" #
)
——# $
;
——$ %
}
˜˜ 	
}
™™ 
}šš ‚
–D:\Dakota\OneDriveOU\School\CS3560\repos\3560-Project-Spring2021\Library\PackageCache\com.unity.probuilder@4.4.0\Runtime\MeshOperations\Subdivision.cs
	namespace 	
UnityEngine
 
. 

ProBuilder  
.  !
MeshOperations! /
{ 
static		 

class		 
Subdivision		 
{

 
public 
static 
ActionResult "
	Subdivide# ,
(, -
this- 1
ProBuilderMesh2 @
pbA C
)C D
{ 	
return 
pb 
. 
	Subdivide 
(  
pb  "
." #
facesInternal# 0
)0 1
!=2 4
null5 9
?: ;
new< ?
ActionResult@ L
(L M
ActionResultM Y
.Y Z
StatusZ `
.` a
Successa h
,h i
$strj u
)u v
:w x
newy |
ActionResult	} ‰
(
‰ Š
ActionResult
Š –
.
– —
Status
— 
.
 
Failure
 ¥
,
¥ ¦
$str
§ ¹
)
¹ º
;
º »
} 	
public 
static 
Face 
[ 
] 
	Subdivide &
(& '
this' +
ProBuilderMesh, :
pb; =
,= >
IList? D
<D E
FaceE I
>I J
facesK P
)P Q
{ 	
return 
ConnectElements "
." #
Connect# *
(* +
pb+ -
,- .
faces/ 4
)4 5
;5 6
} 	
}   
}!! 